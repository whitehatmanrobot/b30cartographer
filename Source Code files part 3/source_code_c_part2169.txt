                           \
        p = (PTDI_REQUEST_KERNEL_RECEIVE)&_IRPSP->Parameters;                \
        p->ReceiveFlags = InFlags;                                           \
        p->ReceiveLength = ReceiveLen;                                       \
        Irp->MdlAddress = MdlAddr;                                           \
    }

#define TdiBuildSend(Irp, DevObj, FileObj, CompRoutine, Contxt, MdlAddr, InFlags, SendLen)\
    {                                                                        \
        PTDI_REQUEST_KERNEL_SEND p;                                          \
        PIO_STACK_LOCATION _IRPSP;                                           \
        if ( CompRoutine != NULL) {                                          \
            IoSetCompletionRoutine( Irp, CompRoutine, Contxt, TRUE, TRUE, TRUE);\
        } else {                                                             \
            IoSetCompletionRoutine( Irp, NULL, NULL, FALSE, FALSE, FALSE);   \
        }                                                                    \
        _IRPSP = IoGetNextIrpStackLocation (Irp);                            \
        _IRPSP->MajorFunction = IRP_MJ_INTERNAL_DEVICE_CONTROL;              \
        _IRPSP->MinorFunction = TDI_SEND;                                    \
        _IRPSP->DeviceObject = DevObj;                                       \
        _IRPSP->FileObject = FileObj;                                        \
        p = (PTDI_REQUEST_KERNEL_SEND)&_IRPSP->Parameters;                   \
        p->SendFlags = InFlags;                                              \
        p->SendLength = SendLen;                                             \
        Irp->MdlAddress = MdlAddr;                                           \
    }

#define TdiBuildSendDatagram(Irp, DevObj, FileObj, CompRoutine, Contxt, MdlAddr, SendLen, SendDatagramInfo)\
    {                                                                        \
        PTDI_REQUEST_KERNEL_SENDDG p;                                        \
        PIO_STACK_LOCATION _IRPSP;                                           \
        if ( CompRoutine != NULL) {                                          \
            IoSetCompletionRoutine( Irp, CompRoutine, Contxt, TRUE, TRUE, TRUE);\
        } else {                                                             \
            IoSetCompletionRoutine( Irp, NULL, NULL, FALSE, FALSE, FALSE);   \
        }                                                                    \
        _IRPSP = IoGetNextIrpStackLocation (Irp);                            \
        _IRPSP->MajorFunction = IRP_MJ_INTERNAL_DEVICE_CONTROL;              \
        _IRPSP->MinorFunction = TDI_SEND_DATAGRAM;                           \
        _IRPSP->DeviceObject = DevObj;                                       \
        _IRPSP->FileObject = FileObj;                                        \
        p = (PTDI_REQUEST_KERNEL_SENDDG)&_IRPSP->Parameters;                 \
        p->SendLength = SendLen;                                             \
        p->SendDatagramInformation = SendDatagramInfo;                       \
        Irp->MdlAddress = MdlAddr;                                           \
    }

#define TdiBuildReceiveDatagram(Irp, DevObj, FileObj, CompRoutine, Contxt, MdlAddr, ReceiveLen, ReceiveDatagramInfo, ReturnInfo, InFlags)\
    {                                                                        \
        PTDI_REQUEST_KERNEL_RECEIVEDG p;                                     \
        PIO_STACK_LOCATION _IRPSP;                                           \
        if ( CompRoutine != NULL) {                                          \
            IoSetCompletionRoutine( Irp, CompRoutine, Contxt, TRUE, TRUE, TRUE);\
        } else {                                                             \
            IoSetCompletionRoutine( Irp, NULL, NULL, FALSE, FALSE, FALSE);   \
        }                                                                    \
        _IRPSP = IoGetNextIrpStackLocation (Irp);                            \
        _IRPSP->MajorFunction = IRP_MJ_INTERNAL_DEVICE_CONTROL;              \
        _IRPSP->MinorFunction = TDI_RECEIVE_DATAGRAM;                        \
        _IRPSP->DeviceObject = DevObj;                                       \
        _IRPSP->FileObject = FileObj;                                        \
        p = (PTDI_REQUEST_KERNEL_RECEIVEDG)&_IRPSP->Parameters;              \
        p->ReceiveLength = ReceiveLen;                                       \
        p->ReceiveDatagramInformation = ReceiveDatagramInfo;                 \
        p->ReturnDatagramInformation = ReturnInfo;                           \
        p->ReceiveFlags = InFlags;                                           \
        Irp->MdlAddress = MdlAddr;                                           \
    }

#define TdiBuildSetEventHandler(Irp, DevObj, FileObj, CompRoutine, Contxt, InEventType, InEventHandler, InEventContext) \
    {                                                                        \
        PTDI_REQUEST_KERNEL_SET_EVENT p;                                     \
        PIO_STACK_LOCATION _IRPSP;                                           \
        if ( CompRoutine != NULL) {                                          \
            IoSetCompletionRoutine( Irp, CompRoutine, Contxt, TRUE, TRUE, TRUE);\
        } else {                                                             \
            IoSetCompletionRoutine( Irp, NULL, NULL, FALSE, FALSE, FALSE);   \
        }                                                                    \
        _IRPSP = IoGetNextIrpStackLocation (Irp);                            \
        _IRPSP->MajorFunction = IRP_MJ_INTERNAL_DEVICE_CONTROL;              \
        _IRPSP->MinorFunction = TDI_SET_EVENT_HANDLER;                       \
        _IRPSP->DeviceObject = DevObj;                                       \
        _IRPSP->FileObject = FileObj;                                        \
        p = (PTDI_REQUEST_KERNEL_SET_EVENT)&_IRPSP->Parameters;              \
        p->EventType = InEventType;                                          \
        p->EventHandler = (PVOID)InEventHandler;                             \
        p->EventContext = (PVOID)InEventContext;                             \
    }

#define TdiBuildQueryInformationEx(Irp, DevObj, FileObj, CompRoutine, Contxt, QType, MdlAddr, ConnInfo)\
    {                                                                        \
        PTDI_REQUEST_KERNEL_QUERY_INFORMATION p;                             \
        PIO_STACK_LOCATION _IRPSP;                                           \
        Irp->MdlAddress = MdlAddr;                                           \
        if ( CompRoutine != NULL) {                                          \
            IoSetCompletionRoutine( Irp, CompRoutine, Contxt, TRUE, TRUE, TRUE);\
        } else {                                                             \
            IoSetCompletionRoutine( Irp, NULL, NULL, FALSE, FALSE, FALSE);   \
        }                                                                    \
        _IRPSP = IoGetNextIrpStackLocation (Irp);                            \
        _IRPSP->MajorFunction = IRP_MJ_INTERNAL_DEVICE_CONTROL;              \
        _IRPSP->MinorFunction = TDI_QUERY_INFORMATION;                       \
        _IRPSP->DeviceObject = DevObj;                                       \
        _IRPSP->FileObject = FileObj;                                        \
        p = (PTDI_REQUEST_KERNEL_QUERY_INFORMATION)&_IRPSP->Parameters;      \
        p->QueryType = (ULONG)QType;                                         \
        p->RequestConnectionInformation = ConnInfo;                          \
    }


#define TdiBuildQueryInformation(Irp, DevObj, FileObj, CompRoutine, Contxt, QType, MdlAddr)\
        TdiBuildQueryInformationEx(Irp, DevObj, FileObj, CompRoutine, Contxt, QType, MdlAddr, NULL);


#define TdiBuildSetInformation(Irp, DevObj, FileObj, CompRoutine, Contxt, SType, MdlAddr)\
    {                                                                        \
        PTDI_REQUEST_KERNEL_SET_INFORMATION p;                                          \
        PIO_STACK_LOCATION _IRPSP;                                           \
        Irp->MdlAddress = MdlAddr;                                           \
        if ( CompRoutine != NULL) {                                          \
            IoSetCompletionRoutine( Irp, CompRoutine, Contxt, TRUE, TRUE, TRUE);\
        } else {                                                             \
            IoSetCompletionRoutine( Irp, NULL, NULL, FALSE, FALSE, FALSE);   \
        }                                                                    \
        _IRPSP = IoGetNextIrpStackLocation (Irp);                            \
        _IRPSP->MajorFunction = IRP_MJ_INTERNAL_DEVICE_CONTROL;              \
        _IRPSP->MinorFunction = TDI_SET_INFORMATION;                         \
        _IRPSP->DeviceObject = DevObj;                                       \
        _IRPSP->FileObject = FileObj;                                        \
        p = (PTDI_REQUEST_KERNEL_SET_INFORMATION)&_IRPSP->Parameters;                   \
        p->SetType = (ULONG)SType;                                           \
        p->RequestConnectionInformation = NULL;                              \
    }

#define TdiBuildAction(Irp, DevObj, FileObj, CompRoutine, Contxt, MdlAddr)\
    {                                                                        \
        PIO_STACK_LOCATION _IRPSP;                                           \
        if ( CompRoutine != NULL) {                                          \
            IoSetCompletionRoutine( Irp, CompRoutine, Contxt, TRUE, TRUE, TRUE);\
        } else {                                                             \
            IoSetCompletionRoutine( Irp, NULL, NULL, FALSE, FALSE, FALSE);   \
        }                                                                    \
        _IRPSP = IoGetNextIrpStackLocation (Irp);                            \
        _IRPSP->MajorFunction = IRP_MJ_INTERNAL_DEVICE_CONTROL;              \
        _IRPSP->MinorFunction = TDI_ACTION;                                  \
        _IRPSP->DeviceObject = DevObj;                                       \
        _IRPSP->FileObject = FileObj;                                        \
        Irp->MdlAddress = MdlAddr;                                           \
    }

//
// definitions for the helper routines for TDI compliant transports and clients
//
// Note that the IOCTL used here for the Irp Function is not real; it is used
// to avoid this IO routine having to map buffers (which we don't want).
//
//PIRP
//TdiBuildInternalDeviceControlIrp (
//    IN CCHAR IrpSubFunction,
//    IN PDEVICE_OBJECT DeviceObject,
//    IN PFILE_OBJECT FileObject,
//    IN PKEVENT Event,
//    IN PIO_STATUS_BLOCK IoStatusBlock
//    );

#define TdiBuildInternalDeviceControlIrp(IrpSubFunction,DeviceObject,FileObject,Event,IoStatusBlock) \
    IoBuildDeviceIoControlRequest (\
        0x00000003,\
        DeviceObject, \
        NULL,   \
        0,      \
        NULL,   \
        0,      \
        TRUE,   \
        Event,  \
        IoStatusBlock)


//
// VOID
// TdiCopyLookaheadData(
//     IN PVOID Destination,
//     IN PVOID Source,
//     IN ULONG Length,
//     IN ULONG ReceiveFlags
//     );
//

#ifdef _M_IX86
#define TdiCopyLookaheadData(_Destination,_Source,_Length,_ReceiveFlags)   \
    RtlCopyMemory(_Destination,_Source,_Length)
#else
#define TdiCopyLookaheadData(_Destination,_Source,_Length,_ReceiveFlags) { \
    if ((_ReceiveFlags) & TDI_RECEIVE_COPY_LOOKAHEAD) {                    \
        RtlCopyMemory(_Destination,_Source,_Length);                       \
    } else {                                                               \
        PUCHAR _Src = (PUCHAR)(_Source);                                   \
        PUCHAR _Dest = (PUCHAR)(_Destination);                             \
        PUCHAR _End = _Dest + (_Length);                                   \
        while (_Dest < _End) {                                             \
            *_Dest++ = *_Src++;                                            \
        }                                                                  \
    }                                                                      \
}
#endif


NTSTATUS
TdiMapUserRequest(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp,
    IN PIO_STACK_LOCATION IrpSp
    );

#if (NTDDI_VERSION < NTDDI_WINXP)
VOID
TdiMapBuffer (
    IN PMDL MdlChain
    );

VOID
TdiUnmapBuffer (
    IN PMDL MdlChain
    );
#endif

NTSTATUS
TdiCopyBufferToMdl (
    IN PVOID SourceBuffer,
    IN ULONG SourceOffset,
    IN ULONG SourceBytesToCopy,
    IN PMDL DestinationMdlChain,
    IN ULONG DestinationOffset,
    IN PULONG BytesCopied
    );

NTSTATUS
TdiCopyMdlToBuffer(
    IN PMDL SourceMdlChain,
    IN ULONG SourceOffset,
    IN PVOID DestinationBuffer,
    IN ULONG DestinationOffset,
    IN ULONG DestinationBufferSize,
    OUT PULONG BytesCopied
    );

#if (NTDDI_VERSION >= NTDDI_WINXP)
NTSTATUS
TdiCopyMdlChainToMdlChain(
    IN PMDL SourceMdlChain,
    IN ULONG SourceOffset,
    IN PMDL DestinationMdlChain,
    IN ULONG DestinationOffset,
    OUT PULONG BytesCopied
    );
#endif

#if (NTDDI_VERSION >= NTDDI_WS03)
VOID
TdiCopyBufferToMdlWithReservedMappingAtDpcLevel(
    IN PVOID SourceBuffer,
    IN PMDL DestinationMdl,
    IN ULONG DestinationOffset,
    IN ULONG BytesToCopy
    );

__inline
VOID
TdiCopyBufferToMdlWithReservedMapping(
    IN PVOID SourceBuffer,
    IN PMDL DestinationMdl,
    IN ULONG DestinationOffset,
    IN ULONG BytesToCopy
    )
{
    KIRQL OldIrql;
    KeRaiseIrql(DISPATCH_LEVEL, &OldIrql);
    TdiCopyBufferToMdlWithReservedMappingAtDpcLevel(SourceBuffer,
                                                    DestinationMdl,
                                                    DestinationOffset,
                                                    BytesToCopy);
    KeLowerIrql(OldIrql);
}
#endif

VOID
TdiBuildNetbiosAddress (
    IN PUCHAR NetbiosName,
    IN BOOLEAN IsGroupName,
    IN OUT PTA_NETBIOS_ADDRESS NetworkName
    );

NTSTATUS
TdiBuildNetbiosAddressEa (
    IN PUCHAR Buffer,
    IN BOOLEAN IsGroupName,
    IN PUCHAR NetbiosName
    );

//++
//
//  VOID
//  TdiCompleteRequest (
//      IN PIRP Irp,
//      IN NTSTATUS Status
//      );
//
//  Routine Description:
//
//      This routine is used to complete an IRP with the indicated
//      status.
//
//  Arguments:
//
//      Irp - Supplies a pointer to the Irp to complete
//
//      Status - Supplies the completion status for the Irp
//
//  Return Value:
//
//      None.
//
//--

#define TdiCompleteRequest(IRP,STATUS) {              \
    (IRP)->IoStatus.Status = (STATUS);                \
    IoCompleteRequest( (IRP), IO_NETWORK_INCREMENT ); \
}


VOID
TdiReturnChainedReceives(
    IN PVOID *TsduDescriptors,
    IN ULONG  NumberOfTsdus
    );


// The type definition for a TDI Bind handler callout. This callout is
// called when a new transport device arrives.

typedef VOID
(*TDI_BIND_HANDLER)(
    IN      PUNICODE_STRING DeviceName
    );

typedef VOID
(*TDI_UNBIND_HANDLER)(
    IN      PUNICODE_STRING DeviceName
    );

// The type definition for a TDI address handler callout.
// This is typedefed  defined at the end (with the others)

typedef VOID
(*TDI_ADD_ADDRESS_HANDLER)(
    IN      PTA_ADDRESS             Address
    );

typedef VOID
(*TDI_DEL_ADDRESS_HANDLER)(
    IN      PTA_ADDRESS             Address
    );

typedef VOID
(* TDI_NET_READY_HANDLER)(
    IN NTSTATUS ProviderStatus
    );

typedef VOID
(* ProviderPnPPowerComplete)(
    IN PNET_PNP_EVENT  NetEvent,
    IN NTSTATUS        ProviderStatus
    );


NTSTATUS
TdiRegisterAddressChangeHandler(
    IN TDI_ADD_ADDRESS_HANDLER  AddHandler,
    IN TDI_DEL_ADDRESS_HANDLER  DeleteHandler,
    OUT HANDLE                  *BindingHandle
    );

NTSTATUS
TdiDeregisterAddressChangeHandler(
    IN HANDLE BindingHandle
);

NTSTATUS
TdiRegisterNotificationHandler(
    IN TDI_BIND_HANDLER   BindHandler,
    IN TDI_UNBIND_HANDLER UnbindHandler,
    OUT HANDLE            *BindingHandle
);

NTSTATUS
TdiDeregisterNotificationHandler(
    IN HANDLE BindingHandle
);

NTSTATUS
TdiRegisterDeviceObject(
    IN PUNICODE_STRING DeviceName,
    OUT HANDLE         *RegistrationHandle
);

NTSTATUS
TdiDeregisterDeviceObject(
    IN HANDLE RegistrationHandle
);

NTSTATUS
TdiDeregisterNetAddress(
    IN HANDLE RegistrationHandle
);

VOID
TdiInitialize(
    VOID
);


// PnP extensions to TDI. Spec : TdiPnp.doc : MunilS

typedef enum _TDI_PNP_OPCODE {
    TDI_PNP_OP_MIN,
    TDI_PNP_OP_ADD,
    TDI_PNP_OP_DEL,
    TDI_PNP_OP_UPDATE,
    TDI_PNP_OP_PROVIDERREADY,
    TDI_PNP_OP_NETREADY,
    TDI_PNP_OP_ADD_IGNORE_BINDING,
    TDI_PNP_OP_DELETE_IGNORE_BINDING,
    TDI_PNP_OP_MAX,
} TDI_PNP_OPCODE;

typedef struct _TDI_PNP_CONTEXT_WIN2K {
    USHORT ContextSize;
    USHORT ContextType;
    UCHAR POINTER_ALIGNMENT ContextData[1];
} TDI_PNP_CONTEXT_WIN2K, *PTDI_PNP_CONTEXT_WIN2K;

typedef struct _TDI_PNP_CONTEXT_XP {
    USHORT ContextSize;
    USHORT ContextType;
    UCHAR POINTER_ALIGNMENT ContextData[1];
} TDI_PNP_CONTEXT_XP, *PTDI_PNP_CONTEXT_XP;

#if (NTDDI_VERSION >= NTDDI_WINXP)
typedef TDI_PNP_CONTEXT_XP TDI_PNP_CONTEXT;
#else
typedef TDI_PNP_CONTEXT_WIN2K TDI_PNP_CONTEXT;
#endif

typedef TDI_PNP_CONTEXT* PTDI_PNP_CONTEXT;

typedef VOID
(*TDI_BINDING_HANDLER)(
    IN TDI_PNP_OPCODE PnPOpcode,
    IN PUNICODE_STRING DeviceName,
    IN PWSTR MultiSZBindList
    );

typedef VOID
(*TDI_ADD_ADDRESS_HANDLER_V2)(
    IN  PTA_ADDRESS      Address,
    IN  PUNICODE_STRING  DeviceName,
    IN  PTDI_PNP_CONTEXT Context
    );

typedef VOID
(*TDI_DEL_ADDRESS_HANDLER_V2)(
    IN  PTA_ADDRESS      Address,
    IN  PUNICODE_STRING  DeviceName,
    IN  PTDI_PNP_CONTEXT Context
    );


typedef NTSTATUS
(*TDI_PNP_POWER_HANDLER)(
    IN PUNICODE_STRING  DeviceName,
    IN PNET_PNP_EVENT   PowerEvent,
    IN PTDI_PNP_CONTEXT Context1,
    IN PTDI_PNP_CONTEXT Context2
    );

// When the user makes changes using the NCPA, a TdiMakeNCPAChanges request
// is generated through NDIS. The following structure is used to communicate
// these changes.

typedef struct _TDI_NCPA_BINDING_INFO {
    PUNICODE_STRING TdiClientName;
    PUNICODE_STRING TdiProviderName;
    PUNICODE_STRING BindList;
    PVOID           ReconfigBuffer;
    unsigned int    ReconfigBufferSize;
    TDI_PNP_OPCODE  PnpOpcode;
} TDI_NCPA_BINDING_INFO, *PTDI_NCPA_BINDING_INFO;

//
// The following structure makes it easy for consistency/integrity checking
//
typedef struct _TDI_VERSION_ {
    union {
        struct {
            UCHAR MajorTdiVersion;
            UCHAR MinorTdiVersion;
        };
        USHORT TdiVersion;
    };
} TDI_VERSION, *PTDI_VERSION;

#define TDI20
typedef struct _TDI20_CLIENT_INTERFACE_INFO {
     union {
       struct {
          UCHAR MajorTdiVersion;
          UCHAR MinorTdiVersion;
       };
       USHORT TdiVersion;
    };

    //TDI_VERSION                       TdiVersion;
        USHORT                          Unused;
        PUNICODE_STRING         ClientName;
        TDI_PNP_POWER_HANDLER   PnPPowerHandler;

    union {

        TDI_BINDING_HANDLER     BindingHandler;

        struct {
            //
            // Putting these back in for backward compatibility.
            //

            TDI_BIND_HANDLER        BindHandler;
            TDI_UNBIND_HANDLER      UnBindHandler;

        };
    };


    union {
        struct {

            TDI_ADD_ADDRESS_HANDLER_V2 AddAddressHandlerV2;
            TDI_DEL_ADDRESS_HANDLER_V2 DelAddressHandlerV2;

        };
        struct {

            //
            // Putting these back in for backward compatibility.
            //

            TDI_ADD_ADDRESS_HANDLER AddAddressHandler;
            TDI_DEL_ADDRESS_HANDLER DelAddressHandler;

        };

    };

//    TDI_NET_READY_HANDLER       NetReadyHandler;

} TDI20_CLIENT_INTERFACE_INFO, *PTDI20_CLIENT_INTERFACE_INFO;


#ifdef TDI20

#define TDI_CURRENT_MAJOR_VERSION (2)
#define TDI_CURRENT_MINOR_VERSION (0)

typedef TDI20_CLIENT_INTERFACE_INFO TDI_CLIENT_INTERFACE_INFO;

#define TDI_CURRENT_VERSION ((TDI_CURRENT_MINOR_VERSION) << 8 | \
                        (TDI_CURRENT_MAJOR_VERSION))

#endif // TDI20

#define TDI_VERSION_ONE 0x0001

typedef TDI_CLIENT_INTERFACE_INFO *PTDI_CLIENT_INTERFACE_INFO;


NTSTATUS
TdiRegisterPnPHandlers(
    IN PTDI_CLIENT_INTERFACE_INFO ClientInterfaceInfo,
    IN ULONG InterfaceInfoSize,
    OUT HANDLE *BindingHandle
    );

NTSTATUS
TdiDeregisterPnPHandlers(
    IN HANDLE BindingHandle
    );

NTSTATUS
TdiPnPPowerRequest(
    IN PUNICODE_STRING  DeviceName,
    IN PNET_PNP_EVENT   PowerEvent,
    IN PTDI_PNP_CONTEXT Context1,
    IN PTDI_PNP_CONTEXT Context2,
    IN ProviderPnPPowerComplete ProtocolCompletionHandler
    );

VOID
TdiPnPPowerComplete(
    IN HANDLE           BindingHandle,
    //IN PUNICODE_STRING  DeviceName,
    IN PNET_PNP_EVENT   PowerEvent,
    IN NTSTATUS         Status
    );

NTSTATUS
TdiRegisterNetAddress(
    IN PTA_ADDRESS              Address,
    IN PUNICODE_STRING      DeviceName,
    IN PTDI_PNP_CONTEXT     Context,
    OUT HANDLE                      *RegistrationHandle
    );

NTSTATUS
TdiMakeNCPAChanges(
    IN TDI_NCPA_BINDING_INFO NcpaBindingInfo
    );

//
// Enumerate all TDI addresses for a client
//
NTSTATUS
TdiEnumerateAddresses(
    IN HANDLE BindingHandle
    );

//
// Introducing the concept of Transport provider.
//

NTSTATUS
TdiRegisterProvider(
    PUNICODE_STRING ProviderName,
    HANDLE  *ProviderHandle
    );

NTSTATUS
TdiProviderReady(
    HANDLE      ProviderHandle
    );

NTSTATUS
TdiDeregisterProvider(
    HANDLE  ProviderHandle
    );

BOOLEAN
TdiMatchPdoWithChainedReceiveContext(
    IN PVOID TsduDescriptor,
    IN PVOID PDO
    );



#define  TDI_STATUS_BAD_VERSION             0xC0010004L // same as NDIS, is that OK?
#define  TDI_STATUS_BAD_CHARACTERISTICS     0xC0010005L // ,,


//
// PNP context types
//
#define TDI_PNP_CONTEXT_TYPE_IF_NAME            0x1
#define TDI_PNP_CONTEXT_TYPE_IF_ADDR            0x2
#define TDI_PNP_CONTEXT_TYPE_PDO                0x3
#define TDI_PNP_CONTEXT_TYPE_FIRST_OR_LAST_IF   0x4

// The following structures and macros are for handlers that support returning
// ancillary data via a control structure
//

//
// Layout of ancillary data objects in the control buffer
//
typedef struct _TDI_CMSGHDR_XP {
    SIZE_T      cmsg_len;
    LONG        cmsg_level;
    LONG        cmsg_type;
    /* followed by UCHAR cmsg_data[] */
} TDI_CMSGHDR_XP, *PTDI_CMSGHDR_XP;

#if (NTDDI_VERSION >= NTDDI_WINXP)
typedef TDI_CMSGHDR_XP TDI_CMSGHDR;
typedef TDI_CMSGHDR* PTDI_CMSGHDR;
#endif

//
// Alignment macros for header and data members of
// the control buffer.
//
#define TDI_CMSGHDR_ALIGN(length)                           \
            ( ((length) + TYPE_ALIGNMENT(TDI_CMSGHDR)-1) &   \
                (~(TYPE_ALIGNMENT(TDI_CMSGHDR)-1)) )         \

#define TDI_CMSGDATA_ALIGN(length)                          \
            ( ((length) + MAX_NATURAL_ALIGNMENT-1) &        \
                (~(MAX_NATURAL_ALIGNMENT-1)) )



//  Returns a pointer to the first byte of data (what is referred 
//  to as the cmsg_data member though it is not defined in 
//  the structure).
//
//  UCHAR *
//  TDI_CMSG_DATA (
//      PTDI_CMSGHDR   pcmsg
//      );
//
#define TDI_CMSG_DATA(cmsg)             \
            ( (UCHAR *)(cmsg) + TDI_CMSGDATA_ALIGN(sizeof(TDI_CMSGHDR)) )

//
//  Returns total size of an ancillary data object given 
//  the amount of data. Used to allocate the correct amount 
//  of space.
//
//  SIZE_T
//  TDI_CMSG_SPACE (
//      SIZE_T length
//      );
//
#define TDI_CMSG_SPACE(length)  \
        (TDI_CMSGDATA_ALIGN(sizeof(TDI_CMSGHDR) + TDI_CMSGHDR_ALIGN(length)))

//  Returns the value to store in cmsg_len given the amount of data.
//
//  SIZE_T
//  TDI_CMSG_LEN (
//      SIZE_T length
//  );
//
#define TDI_CMSG_LEN(length)    \
        (TDI_CMSGDATA_ALIGN(sizeof(TDI_CMSGHDR)) + length)


// Initializes the members of a TDI_CMSGHDR structure
//
// VOID
// TDI_INIT_CMSGHDR (
//      PTDI_CMSGHDR cmsg,
//      INT level,
//      INT type,
//      SIZE_T length,
//      );
//
#define TDI_INIT_CMSGHDR(cmsg, level, type, length) { \
        ((TDI_CMSGHDR *) cmsg)->cmsg_level = level; \
        ((TDI_CMSGHDR *) cmsg)->cmsg_type = type;  \
        ((TDI_CMSGHDR *) cmsg)->cmsg_len = TDI_CMSG_LEN(length); \
        }
        
#pragma warning(pop)
#endif // _TDI_KRNL_
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\win2k8\ddk\inc\tdistat.h ===
/*++

Copyright (c) Microsoft Corporation. All rights reserved.

Module Name:

    tdistat.h

Abstract:

    This file contains the TDI status code definitions.

Revision History:

--*/

#pragma once

#ifndef NT

#define TDI_SUCCESS             0           // Success
#define TDI_NO_RESOURCES        1           // No resources.
#define TDI_ADDR_IN_USE         2           // Address already in use.
#define TDI_BAD_ADDR            3           // Address given is bad.
#define TDI_NO_FREE_ADDR        4           // No addresses available.
#define TDI_ADDR_INVALID        6           // Address object is invalid.
#define TDI_ADDR_DELETED        7           // Address object was deleted.
#define TDI_BUFFER_OVERFLOW     9           // Buffer overflowed.
#define TDI_BAD_EVENT_TYPE      10          // Bad event type.
#define TDI_BAD_OPTION          11          // Bad option or length.
#define TDI_CONN_REFUSED        14          // Connection was refused.
#define TDI_INVALID_CONNECTION  15          // Invalid connection.
#define TDI_ALREADY_ASSOCIATED  16          // Connection already associated.
#define TDI_NOT_ASSOCIATED      17          // Connection not associated.
#define TDI_CONNECTION_ACTIVE   18          // Connection is still active.
#define TDI_CONNECTION_ABORTED  19          // Connection was aborted.
#define TDI_CONNECTION_RESET    20          // Connection was reset.
#define TDI_TIMED_OUT           21          // Connection timed out.
#define TDI_GRACEFUL_DISC       22          // Received a graceful disconnect.
#define TDI_NOT_ACCEPTED        23          // Data not accepted.
#define TDI_MORE_PROCESSING     24          // More processing required.
#define TDI_INVALID_STATE       25          // TCB in an invalid state.
#define TDI_INVALID_PARAMETER   26          // An invalid parameter.
#define TDI_DEST_NET_UNREACH    27          // Destination net is unreachable.
#define TDI_DEST_HOST_UNREACH   28          // Dest. host is unreachable.
#define TDI_DEST_UNREACHABLE    TDI_DEST_HOST_UNREACH
#define TDI_DEST_PROT_UNREACH   29          // Destination protocol is
                                            // unreachable.
#define TDI_DEST_PORT_UNREACH   30          // Dest. port is unreachable.
#define TDI_INVALID_QUERY       31          // Invalid query type specified.
#define TDI_REQ_ABORTED         32          // Request was aborted for some
                                            // reason.
#define TDI_BUFFER_TOO_SMALL    33          // Buffer was too small.
#define TDI_CANCELLED           34          // The request was cancelled.
#define TDI_BUFFER_TOO_BIG      35          // Send buffer was too big.
#define TDI_ITEM_NOT_FOUND      36          // Item not found.
#define TDI_INVALID_REQUEST     0xfe        // Invalid request.
#define TDI_PENDING             0xff        // Pending

#else

//
// Map to NT STATUS codes.
//
#define TDI_SUCCESS             STATUS_SUCCESS
#define TDI_NO_RESOURCES        STATUS_INSUFFICIENT_RESOURCES
#define TDI_ADDR_IN_USE         STATUS_ADDRESS_ALREADY_EXISTS
#define TDI_BAD_ADDR            STATUS_INVALID_ADDRESS_COMPONENT
#define TDI_NO_FREE_ADDR        STATUS_TOO_MANY_ADDRESSES
#define TDI_ADDR_INVALID        STATUS_INVALID_ADDRESS
#define TDI_ADDR_DELETED        STATUS_ADDRESS_CLOSED
#define TDI_BUFFER_OVERFLOW     STATUS_BUFFER_OVERFLOW
#define TDI_BAD_EVENT_TYPE      STATUS_INVALID_PARAMETER
#define TDI_BAD_OPTION          STATUS_INVALID_PARAMETER
#define TDI_CONN_REFUSED        STATUS_CONNECTION_REFUSED
#define TDI_INVALID_CONNECTION  STATUS_CONNECTION_INVALID
#define TDI_ALREADY_ASSOCIATED  STATUS_ADDRESS_ALREADY_ASSOCIATED
#define TDI_NOT_ASSOCIATED      STATUS_ADDRESS_NOT_ASSOCIATED
#define TDI_CONNECTION_ACTIVE   STATUS_CONNECTION_ACTIVE
#define TDI_CONNECTION_ABORTED  STATUS_CONNECTION_ABORTED
#define TDI_CONNECTION_RESET    STATUS_CONNECTION_RESET
#define TDI_TIMED_OUT           STATUS_IO_TIMEOUT
#define TDI_GRACEFUL_DISC       STATUS_GRACEFUL_DISCONNECT
#define TDI_NOT_ACCEPTED        STATUS_DATA_NOT_ACCEPTED
#define TDI_MORE_PROCESSING     STATUS_MORE_PROCESSING_REQUIRED
#define TDI_INVALID_STATE       STATUS_INVALID_DEVICE_STATE
#define TDI_INVALID_PARAMETER   STATUS_INVALID_PARAMETER
#define TDI_DEST_NET_UNREACH    STATUS_NETWORK_UNREACHABLE
#define TDI_DEST_HOST_UNREACH   STATUS_HOST_UNREACHABLE
#define TDI_DEST_UNREACHABLE    TDI_DEST_HOST_UNREACH
#define TDI_DEST_PROT_UNREACH   STATUS_PROTOCOL_UNREACHABLE
#define TDI_DEST_PORT_UNREACH   STATUS_PORT_UNREACHABLE
#define TDI_INVALID_QUERY       STATUS_INVALID_DEVICE_REQUEST
#define TDI_REQ_ABORTED         STATUS_REQUEST_ABORTED
#define TDI_BUFFER_TOO_SMALL    STATUS_BUFFER_TOO_SMALL
#define TDI_CANCELLED           STATUS_CANCELLED
#define TDI_BUFFER_TOO_BIG      STATUS_INVALID_BUFFER_SIZE
#define TDI_INVALID_REQUEST     STATUS_INVALID_DEVICE_REQUEST
#define TDI_PENDING             STATUS_PENDING
#define TDI_ITEM_NOT_FOUND      STATUS_OBJECT_NAME_NOT_FOUND


#endif  // NT

#define TDI_OPTION_EOL              0

#define TDI_ADDRESS_OPTION_REUSE    1
#define TDI_ADDRESS_OPTION_DHCP     2
#define TDI_ADDRESS_OPTION_RAW      3
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\win2k8\ddk\inc\usbdrivr.h ===
/*++

Copyright (c) Microsoft Corporation. All rights reserved.

Module Name:

        USBDRIVR.H

Abstract:

   This file defined USB header files of interest to a driver.

Environment:

    Kernel mode

Revision History:

--*/

#ifndef   __USBDRIVR_H__
#define   __USBDRIVR_H__

#define USB_KERNEL_IOCTL
#include "usbioctl.h"
#undef USB_KERNEL_IOCTL

#include "usb.h"
#include "usbdlib.h"
#include "usbbusif.h"


#endif // __USBDRIVR_H__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\win2k8\ddk\inc\usbbusif.h ===
/*++

Copyright (c) Microsoft Corporation. All rights reserved.

Module Name:

    usbbusif.h

Abstract:

Environment:

    Kernel mode

Revision History:

    6-20-99 : created

--*/

#ifndef   __USBBUSIF_H__
#define   __USBBUSIF_H__

/*
  Bus interfaces are supported for Windows XP and later only
*/

#ifndef USB_BUSIFFN
#define USB_BUSIFFN __stdcall
#endif

#if (NTDDI_VERSION >= NTDDI_WINXP)

typedef PVOID PUSB_DEVICE_HANDLE;


/****************************************************************************
    Bus interface for USB FUNCTION DRIVERS 
*****************************************************************************/


/*
    The following bus interface is defined for USB function drivers
    as an alternative to linking directly with USBD.SYS

    It provides irp-less interfaces that may be called at Raised IRQL.
*/


/* 

NTSTATUS
USBPORT_SubmitIsoOutUrb(
    IN PVOID BusContext,
    IN PURB Urb
    );

Routine Description:

    Service exported for Real-Time Thread support.  Allows a driver
    to submit a request without going thru IoCallDriver or allocating 
    an Irp.  

    Additionally the request is scheduled while at high IRQL. The driver
    forfeits any packet level error information when calling this function.

    IRQL = ANY
    
Arguments:

    BusContext - Handle returned from get_bus_interface

    Urb - 

*/

typedef NTSTATUS
    (USB_BUSIFFN *PUSB_BUSIFFN_SUBMIT_ISO_OUT_URB) (
        IN PVOID,
        IN PURB
    );


/* 
VOID
USBPORT_GetUSBDIVersion(
    IN PVOID BusContext,
    IN OUT PUSBD_VERSION_INFORMATION VersionInformation,
    IN OUT PULONG HcdCapabilities
    );

Routine Description:

    Service Returns the Highest USBDI Interface Version supported 
    by the port driver.

    Released Interface Vesrions are:

    Win98Gold,usbd              0x00000102
    Win98SE,usbd                0x00000200
    Win2K,usbd                  0x00000300
    Win98M (Millenium),usbd     0x00000400   

    Usbport                     0x00000500

    IRQL = ANY
    
Arguments:

    VersionInformation - Ptr to USBD_VERSION_INFORMATION 
    HcdCapabilities - Ptr to ULONG that will be filled in with 
                the Host controller (port) driver capability flags.
*/

/*
    Host Controller 'Port' driver capabilities flags
*/

#define USB_HCD_CAPS_SUPPORTS_RT_THREADS    0x00000001


typedef VOID
    (USB_BUSIFFN *PUSB_BUSIFFN_GETUSBDI_VERSION) (
        IN PVOID,
        IN OUT PUSBD_VERSION_INFORMATION,
        IN OUT PULONG 
    );

/* 
NTSTATUS
USBPORT_QueryBusTime(
    IN PVOID BusContext,   
    IN OUT PULONG CurrentUsbFrame
    );

Routine Description:

    Returns the current 32 bit USB frame number.  The function 
    replaces the USBD_QueryBusTime Service.

    IRQL = ANY
    
Arguments:


*/


typedef NTSTATUS
    (USB_BUSIFFN *PUSB_BUSIFFN_QUERY_BUS_TIME) (
        IN PVOID,
        IN PULONG
    );    

/* 
NTSTATUS
USBPORT_BusEnumLogEntry(
    PVOID BusContext,
    ULONG DriverTag,
    ULONG EnumTag,
    ULONG P1,
    ULONG P2
    );

Routine Description:
    
    IRQL = ANY
    
Arguments:


*/


typedef NTSTATUS
    (USB_BUSIFFN *PUSB_BUSIFFN_ENUM_LOG_ENTRY) (
        IN PVOID,
        IN ULONG,
        IN ULONG,
        IN ULONG,
        IN ULONG
    );    



/* 
NTSTATUS
USBPORT_QueryBusInformation(
    IN PVOID BusContext,   
    IN ULONG Level,
    IN OUT PVOID BusInformationBuffer,
    IN OUT PULONG BusInformationBufferLength,
    OUT PULONG BusInformationActualLength
    );

Routine Description:

    IRQL = ANY
    
Arguments:


*/

typedef struct _USB_BUS_INFORMATION_LEVEL_0 {

    /* bandwidth in bits/sec */
    ULONG TotalBandwidth;
    /* mean bandwidth consumed in bits/sec */ 
    ULONG ConsumedBandwidth;  
    
} USB_BUS_INFORMATION_LEVEL_0, *PUSB_BUS_INFORMATION_LEVEL_0;


typedef struct _USB_BUS_INFORMATION_LEVEL_1 {

    /* bandwidth in bits/sec */
    ULONG TotalBandwidth;
    /* mean bandwidth consumed in bits/sec */ 
    ULONG ConsumedBandwidth;  

    /*
        controller 'unicode' symbolic name 
    */       

    ULONG ControllerNameLength;
    WCHAR ControllerNameUnicodeString[1];
    
} USB_BUS_INFORMATION_LEVEL_1, *PUSB_BUS_INFORMATION_LEVEL_1;


typedef NTSTATUS
    (USB_BUSIFFN *PUSB_BUSIFFN_QUERY_BUS_INFORMATION) (
        IN PVOID,
        IN ULONG,
        IN OUT PVOID,
        IN OUT PULONG,
        OUT PULONG
    );        


/* 
BOOLEAN
USBPORT_IsDeviceHighSpeed(
    IN PVOID BusContext   
    );

Routine Description:

    Returns true if device is operating at high speed

    IRQL = ANY
    
Arguments:


*/

typedef BOOLEAN
    (USB_BUSIFFN *PUSB_BUSIFFN_IS_DEVICE_HIGH_SPEED) (
        IN PVOID
    );         

#define USB_BUSIF_USBDI_VERSION_0         0x0000
#define USB_BUSIF_USBDI_VERSION_1         0x0001
#define USB_BUSIF_USBDI_VERSION_2         0x0002
#define USB_BUSIF_USBDI_VERSION_3         0x0003

// {B1A96A13-3DE0-4574-9B01-C08FEAB318D6}
DEFINE_GUID(USB_BUS_INTERFACE_USBDI_GUID, 
0xb1a96a13, 0x3de0, 0x4574, 0x9b, 0x1, 0xc0, 0x8f, 0xea, 0xb3, 0x18, 0xd6);


/* 
   Note: that this version must remain unchanged, this is the 
   version that is supported by USBD in Win2k and WinMe
*/   
typedef struct _USB_BUS_INTERFACE_USBDI_V0 {

    USHORT Size;
    USHORT Version;
    
    PVOID BusContext;
    PINTERFACE_REFERENCE InterfaceReference;
    PINTERFACE_DEREFERENCE InterfaceDereference;
    
    // interface specific entries go here

    // the following functions must be callable at high IRQL,
    // (ie higher than DISPATCH_LEVEL)
    
    PUSB_BUSIFFN_GETUSBDI_VERSION GetUSBDIVersion;
    PUSB_BUSIFFN_QUERY_BUS_TIME QueryBusTime;
    PUSB_BUSIFFN_SUBMIT_ISO_OUT_URB SubmitIsoOutUrb;
    PUSB_BUSIFFN_QUERY_BUS_INFORMATION QueryBusInformation;

} USB_BUS_INTERFACE_USBDI_V0, *PUSB_BUS_INTERFACE_USBDI_V0;

/*
    New extensions for Windows XP
*/
typedef struct _USB_BUS_INTERFACE_USBDI_V1 {

    USHORT Size;
    USHORT Version;
    
    PVOID BusContext;
    PINTERFACE_REFERENCE InterfaceReference;
    PINTERFACE_DEREFERENCE InterfaceDereference;
    
    // interface specific entries go here

    // the following functions must be callable at high IRQL,
    // (ie higher than DISPATCH_LEVEL)
    
    PUSB_BUSIFFN_GETUSBDI_VERSION GetUSBDIVersion;
    PUSB_BUSIFFN_QUERY_BUS_TIME QueryBusTime;
    PUSB_BUSIFFN_SUBMIT_ISO_OUT_URB SubmitIsoOutUrb;
    PUSB_BUSIFFN_QUERY_BUS_INFORMATION QueryBusInformation;
    PUSB_BUSIFFN_IS_DEVICE_HIGH_SPEED IsDeviceHighSpeed;
    
} USB_BUS_INTERFACE_USBDI_V1, *PUSB_BUS_INTERFACE_USBDI_V1;


/*
    New extensions for Windows XP
*/
typedef struct _USB_BUS_INTERFACE_USBDI_V2 {

    USHORT Size;
    USHORT Version;
    
    PVOID BusContext;
    PINTERFACE_REFERENCE InterfaceReference;
    PINTERFACE_DEREFERENCE InterfaceDereference;
    
    // interface specific entries go here

    // the following functions must be callable at high IRQL,
    // (ie higher than DISPATCH_LEVEL)
    
    PUSB_BUSIFFN_GETUSBDI_VERSION GetUSBDIVersion;
    PUSB_BUSIFFN_QUERY_BUS_TIME QueryBusTime;
    PUSB_BUSIFFN_SUBMIT_ISO_OUT_URB SubmitIsoOutUrb;
    PUSB_BUSIFFN_QUERY_BUS_INFORMATION QueryBusInformation;
    PUSB_BUSIFFN_IS_DEVICE_HIGH_SPEED IsDeviceHighSpeed;

    PUSB_BUSIFFN_ENUM_LOG_ENTRY EnumLogEntry;
    
} USB_BUS_INTERFACE_USBDI_V2, *PUSB_BUS_INTERFACE_USBDI_V2;

#endif

#if (NTDDI_VERSION >= NTDDI_VISTA)

/* 
NTSTATUS
USBPORT_QueryBusTimeEx(
    IN PVOID BusContext,   
    OUT PULONG HighSpeedFrameCounter
    );
*/

typedef NTSTATUS
    (USB_BUSIFFN *PUSB_BUSIFFN_QUERY_BUS_TIME_EX) (
        IN PVOID,
        OUT PULONG
    );     

/* 


/*
NTSTATUS
USBPORTBUSIF_UsbdQueryControllerType(
    __in_opt PVOID BusContext,
    __out_opt PULONG HcdiOptionFlags,
    __out_opt PUSHORT PciVendorId,
    __out_opt PUSHORT PciDeviceId,
    __out_opt PUCHAR PciClass,
    __out_opt PUCHAR PciSubClass,
    __out_opt PUCHAR PciRevisionId,
    __out_opt PUCHAR PciProgIf
    );
*/

typedef NTSTATUS
    (USB_BUSIFFN *PUSB_BUSIFFN_QUERY_CONTROLLER_TYPE) (
        IN PVOID,
        OUT PULONG,
        OUT PUSHORT,
        OUT PUSHORT,
        OUT PUCHAR,
        OUT PUCHAR,
        OUT PUCHAR,
        OUT PUCHAR
    ); 


// version 3 Vista and later

typedef struct _USB_BUS_INTERFACE_USBDI_V3 {

    USHORT Size;
    USHORT Version;
    
    PVOID BusContext;
    PINTERFACE_REFERENCE InterfaceReference;
    PINTERFACE_DEREFERENCE InterfaceDereference;
    
    // interface specific entries go here

    // the following functions must be callable at high IRQL,
    // (ie higher than DISPATCH_LEVEL)
    
    PUSB_BUSIFFN_GETUSBDI_VERSION GetUSBDIVersion;
    PUSB_BUSIFFN_QUERY_BUS_TIME QueryBusTime;
    PUSB_BUSIFFN_SUBMIT_ISO_OUT_URB SubmitIsoOutUrb;
    PUSB_BUSIFFN_QUERY_BUS_INFORMATION QueryBusInformation;
    PUSB_BUSIFFN_IS_DEVICE_HIGH_SPEED IsDeviceHighSpeed;
    PUSB_BUSIFFN_ENUM_LOG_ENTRY EnumLogEntry;

    PUSB_BUSIFFN_QUERY_BUS_TIME_EX QueryBusTimeEx;
    PUSB_BUSIFFN_QUERY_CONTROLLER_TYPE QueryControllerType;
           
} USB_BUS_INTERFACE_USBDI_V3, *PUSB_BUS_INTERFACE_USBDI_V3;


//
// USBCCGP.SYS filter driver bus interfaces supported for Windows Longhorn and later.
// These are callback functions that the usbccgp.sys driver will invoke to allow
// a filter driver to customize the device.  The filter driver must export the interface.
//

// {893B6A96-0B7F-4d4d-BDB4-BBD4CEEBB31C}
DEFINE_GUID(USB_BUS_INTERFACE_USBC_CONFIGURATION_GUID, 
0x893b6a96, 0xb7f, 0x4d4d, 0xbd, 0xb4, 0xbb, 0xd4, 0xce, 0xeb, 0xb3, 0x1c);

#define USBC_FUNCTION_FLAG_APPEND_ID 0x1

typedef struct _USBC_FUNCTION_DESCRIPTOR{
    // The 0-based index of the function described
    UCHAR FunctionNumber;
    
    // The number of interfaces contained in this function
    UCHAR NumberOfInterfaces;
    
    // A callee allocated array of pointers into the config desc buffer passed as an input
    PUSB_INTERFACE_DESCRIPTOR *InterfaceDescriptorList;
    
    // Callee allocated PNP IDs for this PDO
    UNICODE_STRING HardwareId;
    UNICODE_STRING CompatibleId;
    UNICODE_STRING FunctionDescription;
    
    // Custom Flags
    ULONG FunctionFlags;
    PVOID Reserved;
} USBC_FUNCTION_DESCRIPTOR, *PUSBC_FUNCTION_DESCRIPTOR;

//
// Callback invoked during START to customize PDO interface groupings and PNP ids.
//

typedef
NTSTATUS
(USB_BUSIFFN *USBC_START_DEVICE_CALLBACK)(
    __in PUSB_DEVICE_DESCRIPTOR DeviceDescriptor,
    __in PUSB_CONFIGURATION_DESCRIPTOR ConfigurationDescriptor,
    __deref_out_bcount_opt(*FunctionDescriptorBufferLength) PUSBC_FUNCTION_DESCRIPTOR *FunctionDescriptorBuffer,
    __out PULONG FunctionDescriptorBufferLength,
    __in PDEVICE_OBJECT FdoDeviceObject,
    __in PDEVICE_OBJECT PdoDeviceObject
    );
    
typedef
BOOLEAN
(USB_BUSIFFN *USBC_PDO_ENABLE_CALLBACK)(
   __in PVOID  Context,
   __in USHORT FirstInterfaceNumber,
   __in USHORT NumberOfInterfaces,
   __in UCHAR  FunctionClass,
   __in UCHAR  FunctionSubClass,
   __in UCHAR  FunctionProtocol
   );
   

#define USBC_DEVICE_CONFIGURATION_INTERFACE_VERSION_1         0x0001

typedef struct _USBC_DEVICE_CONFIGURATION_INTERFACE_V1 {
    USHORT Size;
    USHORT Version;
    PVOID Context;
    PINTERFACE_REFERENCE InterfaceReference;
    PINTERFACE_DEREFERENCE InterfaceDereference;
    
    USBC_START_DEVICE_CALLBACK StartDeviceCallback;
    USBC_PDO_ENABLE_CALLBACK   PdoEnableCallback;
    
    PVOID Reserved[7];
} USBC_DEVICE_CONFIGURATION_INTERFACE_V1, *PUSBC_DEVICE_CONFIGURATION_INTERFACE_V1;

#endif

#endif  /* __USBBUSIF_H */
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\win2k8\ddk\inc\usbdlib.h ===
/*++

Copyright (c) Microsoft Corporation. All rights reserved.

Module Name:

    USBDLIB.H

Abstract:

   Services exported by USBD.

Environment:

    Kernel & user mode

Revision History:

    06-10-96 : created

--*/

#ifndef   __USBDLIB_H__
#define   __USBDLIB_H__

#ifdef OSR21_COMPAT
#pragma message("WARNING: OSR21_COMPAT SWITCH NOT SUPPORTED")
#endif

typedef struct _USBD_INTERFACE_LIST_ENTRY {
    PUSB_INTERFACE_DESCRIPTOR InterfaceDescriptor;
    PUSBD_INTERFACE_INFORMATION Interface;
} USBD_INTERFACE_LIST_ENTRY, *PUSBD_INTERFACE_LIST_ENTRY;


//
// Macros for building URB requests
//

#define UsbBuildInterruptOrBulkTransferRequest(urb, \
                                               length, \
                                               pipeHandle, \
                                               transferBuffer, \
                                               transferBufferMDL, \
                                               transferBufferLength, \
                                               transferFlags, \
                                               link) { \
            (urb)->UrbHeader.Function = URB_FUNCTION_BULK_OR_INTERRUPT_TRANSFER; \
            (urb)->UrbHeader.Length = (length); \
            (urb)->UrbBulkOrInterruptTransfer.PipeHandle = (pipeHandle); \
            (urb)->UrbBulkOrInterruptTransfer.TransferBufferLength = (transferBufferLength); \
            (urb)->UrbBulkOrInterruptTransfer.TransferBufferMDL = (transferBufferMDL); \
            (urb)->UrbBulkOrInterruptTransfer.TransferBuffer = (transferBuffer); \
            (urb)->UrbBulkOrInterruptTransfer.TransferFlags = (transferFlags); \
            (urb)->UrbBulkOrInterruptTransfer.UrbLink = (link); }
            

#define UsbBuildGetDescriptorRequest(urb, \
                                     length, \
                                     descriptorType, \
                                     descriptorIndex, \
                                     languageId, \
                                     transferBuffer, \
                                     transferBufferMDL, \
                                     transferBufferLength, \
                                     link) { \
            (urb)->UrbHeader.Function =  URB_FUNCTION_GET_DESCRIPTOR_FROM_DEVICE; \
            (urb)->UrbHeader.Length = (length); \
            (urb)->UrbControlDescriptorRequest.TransferBufferLength = (transferBufferLength); \
            (urb)->UrbControlDescriptorRequest.TransferBufferMDL = (transferBufferMDL); \
            (urb)->UrbControlDescriptorRequest.TransferBuffer = (transferBuffer); \
            (urb)->UrbControlDescriptorRequest.DescriptorType = (descriptorType); \
            (urb)->UrbControlDescriptorRequest.Index = (descriptorIndex); \
            (urb)->UrbControlDescriptorRequest.LanguageId = (languageId); \
            (urb)->UrbControlDescriptorRequest.UrbLink = (link); }



#define UsbBuildGetStatusRequest(urb, \
                                 op, \
                                 index, \
                                 transferBuffer, \
                                 transferBufferMDL, \
                                 link) { \
            (urb)->UrbHeader.Function =  (op); \
            (urb)->UrbHeader.Length = sizeof(struct _URB_CONTROL_GET_STATUS_REQUEST); \
            (urb)->UrbControlGetStatusRequest.TransferBufferLength = sizeof(USHORT); \
            (urb)->UrbControlGetStatusRequest.TransferBufferMDL = (transferBufferMDL); \
            (urb)->UrbControlGetStatusRequest.TransferBuffer = (transferBuffer); \
            (urb)->UrbControlGetStatusRequest.Index = (index); \
            (urb)->UrbControlGetStatusRequest.UrbLink = (link); }


#define UsbBuildFeatureRequest(urb, \
                               op, \
                               featureSelector, \
                               index, \
                               link) { \
            (urb)->UrbHeader.Function =  (op); \
            (urb)->UrbHeader.Length = sizeof(struct _URB_CONTROL_FEATURE_REQUEST); \
            (urb)->UrbControlFeatureRequest.FeatureSelector = (featureSelector); \
            (urb)->UrbControlFeatureRequest.Index = (index); \
            (urb)->UrbControlFeatureRequest.UrbLink = (link); }



#define UsbBuildSelectConfigurationRequest(urb, \
                                         length, \
                                         configurationDescriptor) { \
            (urb)->UrbHeader.Function =  URB_FUNCTION_SELECT_CONFIGURATION; \
            (urb)->UrbHeader.Length = (length); \
            (urb)->UrbSelectConfiguration.ConfigurationDescriptor = (configurationDescriptor);    }

#define UsbBuildSelectInterfaceRequest(urb, \
                                      length, \
                                      configurationHandle, \
                                      interfaceNumber, \
                                      alternateSetting) { \
            (urb)->UrbHeader.Function =  URB_FUNCTION_SELECT_INTERFACE; \
            (urb)->UrbHeader.Length = (length); \
            (urb)->UrbSelectInterface.Interface.AlternateSetting = (alternateSetting); \
            (urb)->UrbSelectInterface.Interface.InterfaceNumber = (interfaceNumber); \
            (urb)->UrbSelectInterface.Interface.Length = (length - sizeof(struct _URB_HEADER) - sizeof(USBD_CONFIGURATION_HANDLE)); \
            (urb)->UrbSelectInterface.ConfigurationHandle = (configurationHandle);  }


#define UsbBuildVendorRequest(urb, \
                              cmd, \
                              length, \
                              transferFlags, \
                              reservedbits, \
                              request, \
                              value, \
                              index, \
                              transferBuffer, \
                              transferBufferMDL, \
                              transferBufferLength, \
                              link) { \
            (urb)->UrbHeader.Function =  cmd; \
            (urb)->UrbHeader.Length = (length); \
            (urb)->UrbControlVendorClassRequest.TransferBufferLength = (transferBufferLength); \
            (urb)->UrbControlVendorClassRequest.TransferBufferMDL = (transferBufferMDL); \
            (urb)->UrbControlVendorClassRequest.TransferBuffer = (transferBuffer); \
            (urb)->UrbControlVendorClassRequest.RequestTypeReservedBits = (reservedbits); \
            (urb)->UrbControlVendorClassRequest.Request = (request); \
            (urb)->UrbControlVendorClassRequest.Value = (value); \
            (urb)->UrbControlVendorClassRequest.Index = (index); \
            (urb)->UrbControlVendorClassRequest.TransferFlags = (transferFlags); \
            (urb)->UrbControlVendorClassRequest.UrbLink = (link); }


// This is just a special vendor class request.
// Defined for windows XP and later

#if (NTDDI_VERSION >= NTDDI_WINXP)

#define UsbBuildOsFeatureDescriptorRequest(urb, \
                              length, \
                              interface, \
                              index, \
                              transferBuffer, \
                              transferBufferMDL, \
                              transferBufferLength, \
                              link) { \
            (urb)->UrbHeader.Function = URB_FUNCTION_GET_MS_FEATURE_DESCRIPTOR; \
            (urb)->UrbHeader.Length = (length); \
            (urb)->UrbOSFeatureDescriptorRequest.TransferBufferLength = (transferBufferLength); \
            (urb)->UrbOSFeatureDescriptorRequest.TransferBufferMDL = (transferBufferMDL); \
            (urb)->UrbOSFeatureDescriptorRequest.TransferBuffer = (transferBuffer); \
            (urb)->UrbOSFeatureDescriptorRequest.InterfaceNumber = (interface); \
            (urb)->UrbOSFeatureDescriptorRequest.MS_FeatureDescriptorIndex = (index); \
            (urb)->UrbOSFeatureDescriptorRequest.UrbLink = (link); }

#endif

//
// Get the USB status code
//

#define URB_STATUS(urb) ((urb)->UrbHeader.Status)

//
// Macros used for select interface and select configuration requests
//

//
// Calculates the size needed for a SELECT_CONFIGURATION URB request given
// the number of interfaces and the total number of pipes in all interfaces
// selected.
//


#define GET_SELECT_CONFIGURATION_REQUEST_SIZE(totalInterfaces, totalPipes) \
            (sizeof(struct _URB_SELECT_CONFIGURATION) + \
                ((totalInterfaces-1) * sizeof(USBD_INTERFACE_INFORMATION)) + \
                ((totalPipes-totalInterfaces)*sizeof(USBD_PIPE_INFORMATION)))

//
// Calculates the size needed for a SELECT_INTERFACE URB request given
// the number of pipes in the alternate interface selected.
//

#define GET_SELECT_INTERFACE_REQUEST_SIZE(totalPipes) \
            (sizeof(struct _URB_SELECT_INTERFACE) + \
             ((totalPipes-1)*sizeof(USBD_PIPE_INFORMATION)))

//
// Calculates the size of the interface information structure needed to describe
// a give interface based on the number of endpoints.
//


#define GET_USBD_INTERFACE_SIZE(numEndpoints) (sizeof(USBD_INTERFACE_INFORMATION) + \
                        (sizeof(USBD_PIPE_INFORMATION)*(numEndpoints)) \
                         - sizeof(USBD_PIPE_INFORMATION))

//
// Calculates the size of an iso urb request given the number of packets
//

#define  GET_ISO_URB_SIZE(n) (sizeof(struct _URB_ISOCH_TRANSFER)+\
        sizeof(USBD_ISO_PACKET_DESCRIPTOR)*n)


#ifndef _USBD_

DECLSPEC_IMPORT
VOID
USBD_Debug_LogEntry(
	IN CHAR *Name,
	IN ULONG Info1,
	IN ULONG Info2,
	IN ULONG Info3
	);


DECLSPEC_IMPORT
VOID
USBD_GetUSBDIVersion(
    PUSBD_VERSION_INFORMATION VersionInformation
    );


DECLSPEC_IMPORT
PUSB_INTERFACE_DESCRIPTOR
USBD_ParseConfigurationDescriptor(
    IN PUSB_CONFIGURATION_DESCRIPTOR ConfigurationDescriptor,
    IN UCHAR InterfaceNumber,
    IN UCHAR AlternateSetting
    );
/*++

Routine Description:

    This function is replaced by USBD_ParseConfigurationDescriptorEx

Arguments:

Return Value:


--*/


DECLSPEC_IMPORT
PURB
USBD_CreateConfigurationRequest(
    IN PUSB_CONFIGURATION_DESCRIPTOR ConfigurationDescriptor,
    IN OUT PUSHORT Siz
    );
/*++

Routine Description:

    This function is replaced by USBD_CreateConfigurationRequestEx

Arguments:


Return Value:


--*/


//
// These APIS replace USBD_CreateConfigurationRequest,
//                    USBD_ParseConfigurationDescriptor
//

DECLSPEC_IMPORT
PUSB_COMMON_DESCRIPTOR
USBD_ParseDescriptors(
    IN PVOID DescriptorBuffer,
    IN ULONG TotalLength,
    IN PVOID StartPosition,
    IN LONG DescriptorType
    );
/*++

Routine Description:

    Parses a group of standard USB configuration descriptors (returned from a device) for
    a specific descriptor type.

Arguments:

    DescriptorBuffer - pointer to a block of contiguous USB desscriptors
    TotalLength - size in bytes of the Descriptor buffer
    StartPosition - starting position in the buffer to begin parsing,
                    this must point to the begining of a USB descriptor.
    DescriptorType - USB descritor type to locate.


Return Value:

    pointer to a usb descriptor with a DescriptorType field matching the
            input parameter or NULL if not found.

--*/


DECLSPEC_IMPORT
PUSB_INTERFACE_DESCRIPTOR
USBD_ParseConfigurationDescriptorEx(
    IN PUSB_CONFIGURATION_DESCRIPTOR ConfigurationDescriptor,
    IN PVOID StartPosition,
    IN LONG InterfaceNumber,
    IN LONG AlternateSetting,
    IN LONG InterfaceClass,
    IN LONG InterfaceSubClass,
    IN LONG InterfaceProtocol
    );
/*++

Routine Description:

    Parses a standard USB configuration descriptor (returned from a device) for
    a specific interface, alternate setting class subclass or protocol codes

Arguments:

    ConfigurationDescriptor - pointer to USB configuration descriptor, returned
                            from a device (includes all interface and endpoint
                            descriptors).
    StartPosition - pointer to starting position within the configuration
                    descrptor to begin parsing -- this must be a valid usb
                    descriptor.
    InterfaceNumber - interface number to find, (-1) match any
    AlternateSetting - alt setting number to find, (-1) match any
    InterfaceClass - class to find, (-1) match any
    InterfaceSubClass - subclass to find, (-1) match any
    InterfaceProtocol - protocol to find, (-1) match any

Return Value:

    returns a pointer to the first interface descriptor matching the parameters
    passed in (starting from startposition) or NULL if no match is found.

--*/

DECLSPEC_IMPORT
PURB
USBD_CreateConfigurationRequestEx(
    IN PUSB_CONFIGURATION_DESCRIPTOR ConfigurationDescriptor,
    IN PUSBD_INTERFACE_LIST_ENTRY InterfaceList
    );
/*++

Routine Description:

    Allocates and initilaizes a urb of sufficient size to configure a device
    based on the list of interfaces passed in.

    The interface list is a contiguous array of USBD_INTERFACE_LIST_ENTRIES
    each pointing to a specific interface descriptor to be incorporated in
    the request, the list is terminated by a list entry with an
    InterfaceDescriptor pointer of NULL.

    On return the interface field of each list entry is filled in with a pointer
    to the USBD_INTERFACE_INFORMATION structure within the URB corrisponding to
    the same interface descriptor.

Arguments:

    ConfigurationDescriptor - pointer to USB configuration descriptor, returned
                            from a device (includes all interface and endpoint
                            descriptors).

    InterfaceList - list of interfaces we are interested in.

Return Value:

    Pointer to initailized select_configuration urb.

--*/

__declspec(dllexport)
ULONG
USBD_GetInterfaceLength(
    IN PUSB_INTERFACE_DESCRIPTOR InterfaceDescriptor,
    IN PUCHAR BufferEnd
    );
/*++

Routine Description:

    Returns the length (in bytes) of a given interface descriptor
    including all endpoint and class descriptors


Arguments:

    InterfaceDescriptor

    BufferEnd - Pointer to the end of the buffer containing the descriptors

Return Value:

    length of descriptors

--*/


__declspec(dllexport)
VOID
USBD_RegisterHcFilter(
    PDEVICE_OBJECT DeviceObject,
    PDEVICE_OBJECT FilterDeviceObject
    );

/*++

Routine Description:

    Called by an HC filter driver after it attaches to the top
    of the host controller driver stack.

Arguments:

    DeviceObject - current top of stack

    FilterDeviceObject - device object for the filter driver

Return Value:

    none

--*/

__declspec(dllexport)
NTSTATUS
USBD_GetPdoRegistryParameter(
    IN PDEVICE_OBJECT PhysicalDeviceObject,
    IN OUT PVOID Parameter,
    IN ULONG ParameterLength,
    IN PWCHAR KeyName,
    IN ULONG KeyNameLength
    );
/*++

Routine Description:

Arguments:

Return Value:

--*/

__declspec(dllexport)
NTSTATUS
USBD_QueryBusTime(
    IN PDEVICE_OBJECT RootHubPdo,
    IN PULONG CurrentFrame
    );
/*++

Routine Description:

    Returns the current frame, callable at any IRQL

Arguments:

Return Value:

--*/

/*
    Defined for Windows XP and later
*/

#if (NTDDI_VERSION >= NTDDI_WINXP)

DECLSPEC_IMPORT
ULONG
USBD_CalculateUsbBandwidth(
    ULONG MaxPacketSize,
    UCHAR EndpointType,
    BOOLEAN LowSpeed
    );
/*++

Routine Description:

    Returns bus bw consumed based on the endpoint type and
    packet size

Arguments:

Return Value:

--*/
#endif

#if (NTDDI_VERSION >= NTDDI_VISTA)

DECLSPEC_IMPORT
USBD_STATUS
USBD_ValidateConfigurationDescriptor(
                    IN PUSB_CONFIGURATION_DESCRIPTOR ConfigDesc,
                    IN ULONG BufferLength,
                    IN USHORT Level,
                    IN PUCHAR *Offset,
                    IN ULONG Tag);
/*++

Routine Description:

    Validates a USB Configuration Descriptor

Arguments:

    ConfigDesc:  Pointer to the USB Configuration descriptor to be validated
    
    BufferLength: Known size of buffer pointed to by ConfigDesc (NOT NECESSARILY wTotalLength)
    
    Level: Level of checking desired:
           1: Basic Config Descriptor header check only
           
           2: Full pass-through of the config descriptor checking for the following:
                
                a) Unique endpoint addresses and interface numbers
                c) Number of interfaces contained in the descriptor
                d) Ensures the bLength values of the USB descriptors do not
                   exceed the length of the buffer.
                c) Basic validation of information in a USB_INTERFACE_ASSOCIATION_DESCRIPTOR
               
           3: Includes all of the validation for levels 1-2 plus the following:
            
                a) Validation of the number of endpoints in each interface
                b) Enforcement of the USB spec descriptor bLength sizes.
                c) Check to see if all interface numbers are in 
                sequential(not necessarily consecutive) order.
             

   Offset: if the USBD_STATUS returned is not USBD_STATUS_SUCCESS, offet will
   be set to the address within the ConfigDesc buffer where the failure occured.

   Tag:  Driver-defined heap pool tag to be used by usbdlib.
   
 Return Value:  
 
    One of the USBD_STATUS codes declared in usb.h
    
--*/

#endif /* (NTDDI_VERSION >= NTDDI_VISTA) */

#endif /* _USBD_ */

#endif /* __USBDLIB_H__ */
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\win2k8\ddk\inc\usbkern.h ===
/*++

Copyright (c) Microsoft Corporation. All rights reserved.

Module Name:

        USBKERN.H

Abstract:

        This file contains KERNEL Mode IOCTLS supported by
        the HCD (PORT) drivers ROOT HUB PDO.
        
        OBSOLETE header file.  Use usbioctl.h instead.

Environment:

    kernel mode

Revision History:

    4/2003:  Header obsolete


--*/

#ifndef   __USBKERN_H__
#define   __USBKERN_H__


#include "usbioctl.h"

#endif //__USBKERN_H__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\win2k8\ddk\inc\usbprint.h ===
/*++

Copyright (c) 1998 - 2000  Microsoft Corporation

Module Name:

    ioctl.h

Abstract:

        

Environment:

    Kernel & user mode

Revision History:


--*/

#define USBPRINT_IOCTL_INDEX  0x0000


#define IOCTL_USBPRINT_GET_LPT_STATUS  CTL_CODE(FILE_DEVICE_UNKNOWN,  \
                                                   USBPRINT_IOCTL_INDEX+12,\
                                                   METHOD_BUFFERED,  \
                                                   FILE_ANY_ACCESS)                                                           

#define IOCTL_USBPRINT_GET_1284_ID     CTL_CODE(FILE_DEVICE_UNKNOWN,  \
                                                   USBPRINT_IOCTL_INDEX+13,\
                                                   METHOD_BUFFERED,  \
                                                   FILE_ANY_ACCESS)                                                           

#define IOCTL_USBPRINT_VENDOR_SET_COMMAND CTL_CODE(FILE_DEVICE_UNKNOWN,  \
                                                   USBPRINT_IOCTL_INDEX+14,\
                                                   METHOD_BUFFERED,  \
                                                   FILE_ANY_ACCESS)                                                           

#define IOCTL_USBPRINT_VENDOR_GET_COMMAND CTL_CODE(FILE_DEVICE_UNKNOWN,  \
                                                   USBPRINT_IOCTL_INDEX+15,\
                                                   METHOD_BUFFERED,  \
                                                   FILE_ANY_ACCESS)                                                           

#define IOCTL_USBPRINT_SOFT_RESET         CTL_CODE(FILE_DEVICE_UNKNOWN,  \
                                                   USBPRINT_IOCTL_INDEX+16,\
                                                   METHOD_BUFFERED,  \
                                                   FILE_ANY_ACCESS)
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\win2k8\ddk\inc\USBProtocolDefs.h ===
/*++

Copyright (c) 2005  Microsoft Corporation

Module Name:

    USBProtocolDefs.h

Abstract:

    USB protocol definitions

Author:

--*/
#ifndef _USBPROTOCOLDEFS_H_
#define _USBPROTOCOLDEFS_H_

#include <PSHPACK1.h>


// Initial address for an unconnected wired device.
#define USB_UnConnected_Device_Address 0

#define USB_UNCONNECTED_ADDRESS(address) ( USB_UnConnected_Device_Address == (address))

#define USB_CONNECTED_ADDRESS(address) ( USB_UnConnected_Device_Address != (address) )

//PID definition taken from
//USB Spec 2.0 chapter 8.3.1

// Token
#define PID_OUT                             1
#define PID_IN                              9
#define PID_SOF                             5
#define PID_SETUP                           13

// Data
#define PID_DATA0                           3
#define PID_DATA1                           11
#define PID_DATA2                           7
#define PID_MDATA                           15

// Handshake
#define USB_ACK                             2
#define USB_NAK                             10
#define USB_STALL                           14
#define USB_NYET                            6

// Special
#define USB_PRE                             12
#define USB_ERR                             12
#define USB_SPLIT                           8
#define USB_PING                            4

/////////////////////////////////////////////////////////////////////
// Spec release
#define USB_SPEC                            0x0200
#define HID_SPEC                            0x0101


/////////////////////////////////////////////////////////////////////
// USB Device specification
#define USB_20_SPEC                        0x0200
#define USB_11_SPEC                        0x0110
#define USB_10_SPEC                        0x0100

/////////////////////////////////////////////////////////////////////
// Default values:
// Device Descriptor
#define HID_MAX_PACKET_SIZE0                0x08
#define MICROSOFT_VENDOR_ID                 0x045E
#define HID_DEVICE_RELEASE                  0x0100
// Endpoint Descriptor
#define HID_MAX_PACKET_SIZE                 0x0008
#define HID_POLLING_INTERVAL                0x0A
#define MAX_POLLING_INTERVAL                0xFF

// Product IDs
#define USB_DEFAULT_KEYBOARD_PRODUCT_ID     0x000B // Microsoft USB Natural Keyboard from keyboard.inf
#define USB_DEFAULT_MOUSE_PRODUCT_ID        0x0040 // Microsoft USB Wheel Mouse Optical from msmouse.inf

/////////////////////////////////////////////////////////////////////
// Descriptor type Table 9.5 usb2.0 spec
#define DEVICE_DESCRIPTOR                   0x01
#define CONFIGURATION_DESCRIPTOR            0x02
#define STRING_DESCRIPTOR                   0x03
#define INTERFACE_DESCRIPTOR                0x04
#define ENDPOINT_DESCRIPTOR                 0x05
#define QUALIFIER_DESCRIPTOR                0x06
#define OTHER_SPEED_DESCRIPTOR              0x07
#define INTERFACE_POWER_DESCRIPTOR          0x08
// Class-specific descriptor types
#define HID_DESCRIPTOR                      0x21
#define REPORT_DESCRIPTOR                   0x22
#define PHYSICAL_DESCRIPTOR                 0x23
#define HUB_DESCRIPTOR                      0x29

// USBDESCRIPTORTYPE defines the high byte of wValue for a
// GET_DESCRIPTOR request

typedef union _USBDESCRIPTORTYPE
{
    BYTE Byte;

#if !defined(MIDL_PASS)
    struct Bits
    {
        BYTE      Descriptor:5;    // bits 0-4 descriptor type as qualified by the Type field
        BYTE      Type:2;          // bits 5-6 
        BYTE      Reserved:1;      // bit 7
    } Bits;
#endif
} USBDESCRIPTORTYPE;

// These are the possible values for USBDESCRIPTORTYPE.Bits.Type
#define USB_DESCRIPTOR_TYPE_STD             0
#define USB_DESCRIPTOR_TYPE_CLASS           1
#define USB_DESCRIPTOR_TYPE_VENDOR          2
#define USB_DESCRIPTOR_TYPE_RESERVED        3




/////////////////////////////////////////////////////////////////////
// REQUEST TYPES
// Taken from USB 2.0 spec. Table 9-2

// Data transfer direction. D7
#define DIR_HOST_TO_DEVICE                  0
#define DIR_DEVICE_TO_HOST                  1

// Type. D6..5
#define TYPE_STANDARD                       0
#define TYPE_CLASS                          1
#define TYPE_VENDOR                         2
#define TYPE_RESERVED                       3

// Recipient D4..0
#define RCPT_DEVICE                         0
#define RCPT_INTERFACE                      1
#define RCPT_ENDPOINT                       2
#define RCPT_OTHER                          3

#if !defined(MIDL_PASS)
#define USB_MAKE_REQUEST_TYPE(direction, type, recipient) (BYTE)( ((BYTE)direction << 7) | ((BYTE)type << 5) | ((BYTE)recipient & 0x03) )
#endif

/////////////////////////////////////////////////////////////////////
// STANDARD REQUESTS
#define GET_STATUS                          0
#define CLEAR_FEATURE                       1
#define SET_FEATURE                         3
#define SET_ADDRESS                         5
#define GET_DESCRIPTOR                      6
#define SET_DESCRIPTOR                      7
#define GET_CONFIGURATION                   8
#define SET_CONFIGURATION                   9
#define GET_INTERFACE                       10
#define SET_INTERFACE                       11
#define SYNCH_FRAME                         12

/////////////////////////////////////////////////////////////////////
// BULK-ONLY MASS STORAGE CLASS REQUESTS
#define USB_BULK_ONLY_MASS_STG_RESET        0xFF
#define USB_BULK_ONLY_MASS_STG_GET_MAX_LUN  0xFE


/////////////////////////////////////////////////////////////////////
// HID CLASS REQUESTS
#define GET_REPORT                          0x01
#define GET_IDLE                            0x02
#define GET_PROTOCOL                        0x03
#define SET_REPORT                          0x09
#define SET_IDLE                            0x0A
#define SET_PROTOCOL                        0x0B

/////////////////////////////////////////////////////////////////////
// HID REPORT TYPES
#define HID_REPORT_TYPE_INPUT               0x01
#define HID_REPORT_TYPE_OUTPUT              0x02
#define HID_REPORT_TYPE_FEATURE             0x03

/////////////////////////////////////////////////////////////////////
// HID protocol types for GET/SET_PROTOCOL requests
#define HID_PROTOCOL_TYPE_BOOT               0x00
#define HID_PROTOCOL_TYPE_REPORT             0x01

///////////////////////////////////////////////////////////////////
// HUB protocol definitions
#define HUB_DEVICE_PROTOCOL_1X                0
#define HUB_DEVICE_PROTOCOL_SINGLE_TT         1
#define HUB_DEVICE_PROTOCOL_MULTI_TT          2

#define HUB_INTERFACE_PROTOCOL_1X                           0
#define HUB_INTERFACE_PROTOCOL_SINGLE_TT                    0
#define HUB_INTERFACE_PROTOCOL_MULTI_TT_IN_SINGLE_TT_MODE   1
#define HUB_INTERFACE_PROTOCOL_MULTI_TT_IN_MULTI_TT_MODE    2

///////////////////////////////////////////////////////////////////
//HUB Class Request code
#define CLEAR_TT_BUFFER                      8
#define RESET_TT                             9
#define GET_TT_STATE                         10
#define STOP_TT                              11

///////////////////////////////////////////////////////////////////
//HUB And PORT Feature selector
#define C_HUB_LOCAL_POWER                    0
#define C_HUB_OVER_CURRENT                   1
#define PORT_CONNECTION                      0
#define PORT_ENABLE                          1
#define PORT_SUSPEND                         2
#define PORT_OVER_CURRENT                    3
#define PORT_RESET                           4
#define PORT_POWER                           8
#define PORT_LOW_SPEED                       9
#define C_PORT_CONNECTION                    16
#define C_PORT_ENABLE                        17
#define C_PORT_SUSPEND                       18
#define C_PORT_OVER_CURRENT                  19
#define C_PORT_RESET                         20
#define PORT_TEST                            21
#define PORT_INDICATOR                       22


/////////////////////////////////////////////////////////////////////
// SETUP Constants
#define USBSETUPSIZE                        8
#define USBINREQUEST                        128

/////////////////////////////////////////////////////////////////////
// BM_REQUESTES
#define BM_GET_DEVICE                       128
#define BM_GET_INTERFACE                    129
#define BM_GET_ENDPOINT                     130

#define BM_SET_DEVICE                       0
#define BM_SET_INTERFACE                    1
#define BM_SET_ENDPOINT                     2


#define HALT_ENDPOINT                       0
#define REMOTE_WAKEUP                       1
#define TEST_MODE                           2

/////////////////////////////////////////////////////////////////////
// Descriptor requests
#define DEVICE_DESCRIPTION_TYPE             0x100     
#define QUALIFIER_DESCRIPTION_TYPE          0x600
#define OTHER_SPEED_DESCRIPTION_TYPE        0x700
#define CONFIG_DESCRIPTION_TYPE             0x200
#define STRING_DESCRIPTION_TYPE             0x300


/////////////////////////////////////////////////////////////////////
// Configuration Descriptor values
// bmAttribute bits in Configuration Descriptor
//  - USB 2.0 9.6.3 (bmAttributes in Table 9-10): Bit 7 is reserved, and always set to one
#define CONFIG_BUS_POWERED                  0x80
#define CONFIG_SELF_POWERED                 0x40
// Not to be confused with Device Remote Wakeup feature selector!
#define CONFIG_REMOTE_WAKEUP                0x20


typedef union _USBCONFIGATTRIBS
{
    BYTE Byte;

#if !defined(MIDL_PASS)

    struct Bits
    {
        BYTE bReserved0_4:5;   // bits 0-4
        BYTE bRemoteWakeup:1;  // bit 5
        BYTE bSelfPowered:1;   // bit 6
        BYTE bReserved7:1;     // bit 7
    } Bits;

#endif

} USBCONFIGATTRIBS;


/////////////////////////////////////////////////////////////////////
// Interface Descriptor values
// bInterfaceClass values
#define USB_HID_CLASS_CODE                  0x03
#define USB_MASS_STORAGE_CLASS_CODE         0x08
#define USB_HUB_CLASS_CODE                  0x09

// bInterfaceSubClass value
#define BOOT_INTERFACE_SUBCLASS             0x01

// bInterfaceProtocol values for HID
#define PROTOCOL_NONE                       0x00
#define PROTOCOL_KEYBOARD                   0x01
#define PROTOCOL_MOUSE                      0x02

/////////////////////////////////////////////////////////////////////
// Endpoint Descriptor values
// Macros for generating bEndpointAddress value
// - USB HID 1.11 Appendix E.5
#define EP_OUT                              0
#define EP_IN                               1
// Bit 0..3     The end point number
// Bit 4..6     Reserved, reset to zero
// Bit 7        Direction, ignored for control endpoints
#define MAKE_ENDPOINT_ADDRESS(num, dir)     ( ((BYTE)(dir) << 7) | ((BYTE)(num) & 0x0F) )

// bmAttributes values
// ENDPOINT TYPES
#define ENDPOINT_TYPE                       0x03
#define CONTROL_ENDPOINT                    0
#define ISOCHRONOUS_ENDPOINT                1
#define BULK_ENDPOINT                       2
#define INTERRUPT_ENDPOINT                  3



//Define standard USB structures which are used to transfer data from the
//host to the endpoints

typedef union _USBREQUESTTYPE
{
    BYTE Byte;

#if !defined(MIDL_PASS)
    struct Bits
    {
        BYTE      Recipient:5;      // bits 0-4
        BYTE      Type:2;           // bits 5-6
        BYTE      Direction:1;      // bit 7
    } Bits;
#endif
} USBREQUESTTYPE;


#if !defined(MIDL_PASS)
C_ASSERT((sizeof(USBREQUESTTYPE) == sizeof(BYTE)));
#endif

typedef struct _USBSETUPREQUEST
{
    USBREQUESTTYPE  bmRequestType;  // Setup request type
    BYTE            bRequest;       // Setup Request
    SHORT           sSetupValue;    // Value for the setup request
    SHORT           sSetupIndex;    // Index for the setup request
    SHORT           sSetupLength;   // Data Length for the device
} USBSETUPREQUEST;


#if !defined(MIDL_PASS)

typedef struct _USBDEVICEDESC
{
    BYTE   bLength; 
    BYTE   bDescriptorType;
    SHORT  sUSB;
    BYTE   bDeviceClass; 
    BYTE   bDeviceSubClass;
    BYTE   bProtocol;
    BYTE   bMaxPacket0;
    SHORT  sVendor; 
    USHORT sProduct; 
    SHORT  sDeviceNumber; 
    BYTE   bManufacturer; 
    BYTE   bProductDesc;  
    BYTE   bSerialNumber; 
    BYTE   bNumConfigs;

} USBDEVICEDESC;


typedef struct _USBCONFIGDESC
{
    BYTE      bLength;
    BYTE      bDescriptorType; 
    SHORT     sTotalLength; 
    BYTE      bNumInterfaces;
    BYTE      bConfigValue; 
    BYTE      bConfig; 
    BYTE      bAttributes; 
    BYTE      bMaxPower; 
} USBCONFIGDESC;


typedef struct _USBINTERFACEDESC
{
    BYTE      bLength; 
    BYTE      bDescriptorType; 
    BYTE      bInterfaceNumber;
    BYTE      bAlternateSetting;
    BYTE      bNumEndpoints;
    BYTE      bClass;
    BYTE      bSubClass;
    BYTE      bProtocol;
    BYTE      bDescription; 
} USBINTERFACEDESC;


#define USB_ENDPOINT_DIRECTION_OUT  0
#define USB_ENDPOINT_DIRECTION_IN   1


typedef union _USBENDPOINTADDRESS
{
    BYTE Byte;

    struct Bits
    {
        BYTE      Number:4;     // bits 0-3
        BYTE      Reserved:3;   // bits 4-6
        BYTE      Direction:1;  // bit 7
    } Bits;

} USBENDPOINTADDRESS;


C_ASSERT((sizeof(USBENDPOINTADDRESS) == sizeof(BYTE)));


#define USB_TRANSFER_TYPE_CONTROL       0
#define USB_TRANSFER_TYPE_ISOCH         1
#define USB_TRANSFER_TYPE_BULK          2
#define USB_TRANSFER_TYPE_INTERRUPT     3

#define USB_SYNC_TYPE_NONE              0
#define USB_SYNC_TYPE_ASYNC             1
#define USB_SYNC_TYPE_ADAPTIVE          2
#define USB_SYNC_TYPE_SYNC              3

#define USB_USAGE_TYPE_DATA             0
#define USB_USAGE_TYPE_FEEDBACK         1
#define USB_USAGE_TYPE_IMPLICIT         2
#define USB_USAGE_TYPE_RESERVED         3

typedef union _USBENDPOINTATTRIBS
{
    BYTE Byte;

    struct Bits
    {
        BYTE      TransferType:2;   // bits 0-1
        BYTE      SyncType:2;       // bits 3-4
        BYTE      UsageType:2;      // bits 5-6
        BYTE      Reserved:2;       // bits 7-8
    } Bits;

} USBENDPOINTATTRIBS;

C_ASSERT((sizeof(USBENDPOINTATTRIBS) == sizeof(BYTE)));


typedef union _USBMAXPACKET
{
    WORD Word;

    struct Bits
    {
        WORD      Size:11;              // bits 0-10
        WORD      AdditionalXactions:2; // bits 11-12
        WORD      Reserved:3;           // bits 13-15
    } Bits;

} USBMAXPACKET;

C_ASSERT((sizeof(USBMAXPACKET) == sizeof(WORD)));


typedef struct _USBENDPOINTDESC
{
    BYTE                bLength; 
    BYTE                bDescriptorType;
    USBENDPOINTADDRESS  Address;
    USBENDPOINTATTRIBS  Attributes;
    USBMAXPACKET        MaxPacket;
    BYTE                bInterval;
} USBENDPOINTDESC;


typedef struct _USBQUALIFIERDESC
{
    BYTE     bLength; 
    BYTE     bDescriptorType;
    SHORT    sUSB;
    BYTE     bDeviceClass; 
    BYTE     bDeviceSubClass;
    BYTE     bProtocol; 
    BYTE     bMaxPacket;
    BYTE     bNumConfigs;
    BYTE     bReserved;
} USBQUALIFIERDESC;


typedef struct _USBSTRINGDESC
{
    BYTE     bLength;
    BYTE     bDescriptorType;
    WCHAR    wchData[1];
} USBSTRINGDESC;


typedef struct _USBSTRINGLANGIDS
{
    BYTE     bLength;
    BYTE     bDescriptorType;
    WORD     wLANGIDs[1];
} USBSTRINGLANGIDS;


typedef struct _USBHIDSTANDARDDESC
{
    BYTE  bLength;
    BYTE  bDescriptorType;
    SHORT bcdHID;
    BYTE  bCountryCode;
    BYTE  bNumDescriptors;
} USBHIDSTANDARDDESC;


typedef struct _USBHIDOPTIONALDESC
{
    BYTE  bClassDescriptorType;
    SHORT sDescriptorLength;
} USBHIDOPTIONALDESC;


typedef struct _USBPHYSICALDESCSET0
{
    BYTE bNumber;
    BYTE bLength;
} USBPHYSICALDESCSET0;


typedef union _USBPHYSICALDESCSET
{
    BYTE bPhysicalInfo;

    struct Bits
    {
        BYTE bPreference : 5;
        BYTE bBias       : 3;
    } Bits;
} USBPHYSICALDESCSET;


typedef struct _USBPHYSICALDESCITEM
{
    BYTE bDesignator;

    union Flags
    {
        BYTE bFlags;

        struct Bits
        {
            BYTE bEffort    : 5;
            BYTE bQualifier : 3;
        } Bits;

    } Flags;

} USBPHYSICALDESCITEM;


typedef union _USBHUBCHARACTERISTICS
{
    WORD wHubCharacteristics;

    struct Bits
    {
        BYTE bLogicalPowerSwitchingMode : 2;
        BYTE fCompoundDevice            : 1;
        BYTE bOverCurrentMode           : 2;
        BYTE bTTThinkTime               : 2;
        BYTE fPortIndicatorSupport      : 1;
        BYTE bReserved                  : 8;
    } Bits;

} USBHUBCHARACTERISTICS;

#if !defined(MIDL_PASS)
C_ASSERT((sizeof(USBHUBCHARACTERISTICS) == sizeof(WORD)));
#endif


typedef struct _USBHUBDESC
{
    BYTE                  bLength;
    BYTE                  bDescriptorType;
    BYTE                  bNumberOfPorts;
    USBHUBCHARACTERISTICS Characteristics;
    BYTE                  bPwrOn2PwrGood;
    BYTE                  bHubContrCurrent;
    BYTE                  bDeviceRemovable[32]; // Defined as its maximum possible size for 255 ports
    BYTE                  bPortPwrCtrlMask[32]; // Defined as its maximum possible size for 255 ports
} USBHUBDESC;

#if !defined(MIDL_PASS)
C_ASSERT((sizeof(USBHUBDESC) == 71));
#endif


typedef union _USBHUBPORTSTATUS
{
    WORD wPortStatus;

    struct Bits
    {
        BYTE  fCurrentConnectionStatus : 1;
        BYTE  fEnabled                 : 1;
        BYTE  fSuspend                 : 1;
        BYTE  fOverCurrent             : 1;
        BYTE  fReset                   : 1;
        BYTE  bReserved1               : 3;
        BYTE  fPortPower               : 1;
        BYTE  fLowSpeedDevice          : 1;
        BYTE  fHighSpeedDevice         : 1;
        BYTE  fTestMode                : 1;
        BYTE  fPortIndicatorControl    : 1;
        BYTE  bReserved2               : 3;
    } Bits;
} USBHUBPORTSTATUS;

#if !defined(MIDL_PASS)
C_ASSERT((sizeof(USBHUBPORTSTATUS) == sizeof(WORD)));
#endif


typedef union _USBHUBPORTSTATUSCHANGE
{
    WORD wPortStatusChange;

    struct Bits
    {
        BYTE  fConnectionStatusChange : 1;
        BYTE  fEnabledChange          : 1;
        BYTE  fSuspendChange          : 1;
        BYTE  fOverCurrentChange      : 1;
        BYTE  fResetChange            : 1;
        BYTE  bReserved1              : 3;
        BYTE  bReserved2              : 8;
    } Bits;
} USBHUBPORTSTATUSCHANGE;
       
#if !defined(MIDL_PASS)
C_ASSERT((sizeof(USBHUBPORTSTATUSCHANGE) == sizeof(WORD)));
#endif


typedef struct _USBHUBPORTDATA
{
    USBHUBPORTSTATUS        PortStatus;
    USBHUBPORTSTATUSCHANGE  PortStatusChange;
} USBHUBPORTDATA;
            
            
// USB Language Identifiers
//
// These are taken directly from http://www.usb.org/developers/docs/USB_LANGIDs.pdf

// USB_MAKE_LANGID(lang, sublang)
//
// Use this macro to create a language ID. For example, for US English
// use:
//
// USB_MAKE_LANGID(USB_LANG_ENGLISH, USB_SUBLANG_ENGLISH_US)

#define USB_MAKE_LANGID(lang, sublang) ((((USHORT)(sublang)) << 10) | (USHORT)(lang))


#define USB_LANG_RESERVED                                   0x00 
#define USB_LANG_ARABIC                                     0x01
#define USB_LANG_BULGARIAN                                  0x02
#define USB_LANG_CATALAN                                    0x03
#define USB_LANG_CHINESE                                    0x04
#define USB_LANG_CZECH                                      0x05
#define USB_LANG_DANISH                                     0x06
#define USB_LANG_GERMAN                                     0x07
#define USB_LANG_GREEK                                      0x08
#define USB_LANG_ENGLISH                                    0x09
#define USB_LANG_SPANISH                                    0x0a
#define USB_LANG_FINNISH                                    0x0b
#define USB_LANG_FRENCH                                     0x0c
#define USB_LANG_HEBREW                                     0x0d
#define USB_LANG_HUNGARIAN                                  0x0e
#define USB_LANG_ICELANDIC                                  0x0f
#define USB_LANG_ITALIAN                                    0x10
#define USB_LANG_JAPANESE                                   0x11
#define USB_LANG_KOREAN                                     0x12
#define USB_LANG_DUTCH                                      0x13
#define USB_LANG_NORWEGIAN                                  0x14
#define USB_LANG_POLISH                                     0x15
#define USB_LANG_PORTUGUESE                                 0x16
#define USB_LANG_ROMANIAN                                   0x18
#define USB_LANG_RUSSIAN                                    0x19
#define USB_LANG_CROATIAN                                   0x1a
#define USB_LANG_SERBIAN                                    0x1a
#define USB_LANG_SLOVAK                                     0x1b
#define USB_LANG_ALBANIAN                                   0x1c
#define USB_LANG_SWEDISH                                    0x1d
#define USB_LANG_THAI                                       0x1e
#define USB_LANG_TURKISH                                    0x1f
#define USB_LANG_URDU                                       0x20
#define USB_LANG_INDONESIAN                                 0x21
#define USB_LANG_UKRANIAN                                   0x22
#define USB_LANG_BELARUSIAN                                 0x23
#define USB_LANG_SLOVENIAN                                  0x24
#define USB_LANG_ESTONIAN                                   0x25
#define USB_LANG_LATVIAN                                    0x26
#define USB_LANG_LITHUANIAN                                 0x27
#define USB_LANG_FARSI                                      0x29
#define USB_LANG_VIETNAMESE                                 0x2a
#define USB_LANG_ARMENIAN                                   0x2b
#define USB_LANG_AZERI                                      0x2c
#define USB_LANG_BASQUE                                     0x2d
#define USB_LANG_MACEDONIAN                                 0x2f // This is actually Macedonian (FYROM)
#define USB_LANG_AFRIKAANS                                  0x36
#define USB_LANG_GEORGIAN                                   0x37
#define USB_LANG_FAEROESE                                   0x38
#define USB_LANG_HINDI                                      0x39
#define USB_LANG_MALAY                                      0x3e
#define USB_LANG_KAZAK                                      0x3f
#define USB_LANG_SWAHILI                                    0x41
#define USB_LANG_UZBEK                                      0x43
#define USB_LANG_TATAR                                      0x44
#define USB_LANG_BENGALI                                    0x45
#define USB_LANG_PUNJABI                                    0x46
#define USB_LANG_GUJARATI                                   0x47
#define USB_LANG_ORIYA                                      0x48
#define USB_LANG_TAMIL                                      0x49
#define USB_LANG_TELUGU                                     0x4a
#define USB_LANG_KANNADA                                    0x4b
#define USB_LANG_MALAYALAM                                  0x4c
#define USB_LANG_ASSAMESE                                   0x4d
#define USB_LANG_MARATHI                                    0x4e
#define USB_LANG_SANSKRIT                                   0x4f
#define USB_LANG_KONKANI                                    0x57
#define USB_LANG_MANIPURI                                   0x58
#define USB_LANG_SINDHI                                     0x59
#define USB_LANG_KASHMIRI                                   0x60
#define USB_LANG_NEPALI                                     0x61
#define USB_LANG_HID                                        0xff
   
#define USB_SUBLANG_ARABIC_SAUDI_ARABIA                     0x01
#define USB_SUBLANG_ARABIC_SAUDI_ARABIA                     0x01
#define USB_SUBLANG_ARABIC_IRAQ                             0x02
#define USB_SUBLANG_ARABIC_EGYPT                            0x03
#define USB_SUBLANG_ARABIC_LIBYA                            0x04
#define USB_SUBLANG_ARABIC_ALGERIA                          0x05
#define USB_SUBLANG_ARABIC_MOROCCO                          0x06
#define USB_SUBLANG_ARABIC_TUNISIA                          0x07
#define USB_SUBLANG_ARABIC_OMAN                             0x08
#define USB_SUBLANG_ARABIC_YEMEN                            0x09
#define USB_SUBLANG_ARABIC_SYRIA                            0x10
#define USB_SUBLANG_ARABIC_JORDAN                           0x11
#define USB_SUBLANG_ARABIC_LEBANON                          0x12
#define USB_SUBLANG_ARABIC_KUWAIT                           0x13
#define USB_SUBLANG_ARABIC_UAE                              0x14
#define USB_SUBLANG_ARABIC_BAHRAIN                          0x15
#define USB_SUBLANG_ARABIC_QATAR                            0x16
#define USB_SUBLANG_AZERI_CYRILLIC                          0x01
#define USB_SUBLANG_AZERI_LATIN                             0x02
#define USB_SUBLANG_CHINESE_TRADITIONAL                     0x01
#define USB_SUBLANG_CHINESE_SIMPLIFIED                      0x02
#define USB_SUBLANG_CHINESE_HONGKONG                        0x03
#define USB_SUBLANG_CHINESE_SINGAPORE                       0x04
#define USB_SUBLANG_CHINESE_MACAU                           0x05
#define USB_SUBLANG_DUTCH                                   0x01
#define USB_SUBLANG_DUTCH_BELGIAN                           0x02
#define USB_SUBLANG_ENGLISH_US                              0x01
#define USB_SUBLANG_ENGLISH_UK                              0x02
#define USB_SUBLANG_ENGLISH_AUS                             0x03
#define USB_SUBLANG_ENGLISH_CAN                             0x04
#define USB_SUBLANG_ENGLISH_NZ                              0x05
#define USB_SUBLANG_ENGLISH_EIRE                            0x06
#define USB_SUBLANG_ENGLISH_SOUTH_AFRICA                    0x07
#define USB_SUBLANG_ENGLISH_JAMAICA                         0x08
#define USB_SUBLANG_ENGLISH_CARIBBEAN                       0x09
#define USB_SUBLANG_ENGLISH_BELIZE                          0x0a
#define USB_SUBLANG_ENGLISH_TRINIDAD                        0x0b
#define USB_SUBLANG_ENGLISH_PHILIPPINES                     0x0c
#define USB_SUBLANG_ENGLISH_ZIMBABWE                        0x0d
#define USB_SUBLANG_FRENCH                                  0x01
#define USB_SUBLANG_FRENCH_BELGIAN                          0x02
#define USB_SUBLANG_FRENCH_CANADIAN                         0x03
#define USB_SUBLANG_FRENCH_SWISS                            0x04
#define USB_SUBLANG_FRENCH_LUXEMBOURG                       0x05
#define USB_SUBLANG_FRENCH_MONACO                           0x06
#define USB_SUBLANG_GERMAN                                  0x01
#define USB_SUBLANG_GERMAN_SWISS                            0x02
#define USB_SUBLANG_GERMAN_AUSTRIAN                         0x03
#define USB_SUBLANG_GERMAN_LUXEMBOURG                       0x04
#define USB_SUBLANG_GERMAN_LIECHTENSTEIN                    0x05
#define USB_SUBLANG_ITALIAN                                 0x01
#define USB_SUBLANG_ITALIAN_SWISS                           0x02
#define USB_SUBLANG_KASHMIRI_INDIA                          0x02
#define USB_SUBLANG_KOREAN                                  0x01
#define USB_SUBLANG_LITHUANIAN                              0x01
#define USB_SUBLANG_MALAY_MALAYSIA                          0x01
#define USB_SUBLANG_MALAY_BRUNEI_DARUSSALAM                 0x02
#define USB_SUBLANG_NEPALI_INDIA                            0x02
#define USB_SUBLANG_NORWEGIAN_BOKMAL                        0x01
#define USB_SUBLANG_NORWEGIAN_NYNORSK                       0x02
#define USB_SUBLANG_PORTUGUESE                              0x01
#define USB_SUBLANG_PORTUGUESE_BRAZILIAN                    0x02
#define USB_SUBLANG_SERBIAN_LATIN                           0x02
#define USB_SUBLANG_SERBIAN_CYRILLIC                        0x03
#define USB_SUBLANG_SPANISH                                 0x01
#define USB_SUBLANG_SPANISH_MEXICAN                         0x02
#define USB_SUBLANG_SPANISH_MODERN                          0x03
#define USB_SUBLANG_SPANISH_GUATEMALA                       0x04
#define USB_SUBLANG_SPANISH_COSTA_RICA                      0x05
#define USB_SUBLANG_SPANISH_PANAMA                          0x06
#define USB_SUBLANG_SPANISH_DOMINICAN_REPUBLIC              0x07
#define USB_SUBLANG_SPANISH_VENEZUELA                       0x08
#define USB_SUBLANG_SPANISH_COLOMBIA                        0x09
#define USB_SUBLANG_SPANISH_PERU                            0x0a
#define USB_SUBLANG_SPANISH_ARGENTINA                       0x0b
#define USB_SUBLANG_SPANISH_ECUADOR                         0x0c
#define USB_SUBLANG_SPANISH_CHILE                           0x0d
#define USB_SUBLANG_SPANISH_URUGUAY                         0x0e
#define USB_SUBLANG_SPANISH_PARAGUAY                        0x0f
#define USB_SUBLANG_SPANISH_BOLIVIA                         0x10
#define USB_SUBLANG_SPANISH_EL_SALVADOR                     0x11
#define USB_SUBLANG_SPANISH_HONDURAS                        0x12
#define USB_SUBLANG_SPANISH_NICARAGUA                       0x13
#define USB_SUBLANG_SPANISH_PUERTO_RICO                     0x14
#define USB_SUBLANG_SWEDISH                                 0x01
#define USB_SUBLANG_SWEDISH_FINLAND                         0x02
#define USB_SUBLANG_URDU_PAKISTAN                           0x01
#define USB_SUBLANG_URDU_INDIA                              0x02
#define USB_SUBLANG_UZBEK_LATIN                             0x01
#define USB_SUBLANG_UZBEK_CYRILLIC                          0x02
#define USB_SUBLANG_HID_USAGE_DATA_DESCRIPTOR               0x01
#define USB_SUBLANG_HID_VENDOR_DEFINED_1                    0x3c
#define USB_SUBLANG_HID_VENDOR_DEFINED_2                    0x3d
#define USB_SUBLANG_HID_VENDOR_DEFINED_3                    0x3e
#define USB_SUBLANG_HID_VENDOR_DEFINED_4                    0x3f

#endif // !defined(MIDL_PASS)



#include <POPPACK.h>



#endif //_USBPROTOCOLDEFS_H_
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\win2k8\ddk\inc\vfwext.h ===
/*++

Copyright (c) Microsoft Corporation. All rights reserved.

Module Name:

    VfWExt.h

Abstract:

    Constants and function prototypes needed to create IHV's extension DLL
    and constants used to programatically open a target capture device.
    

--*/

#include <prsht.h>

#define VFW_HIDE_SETTINGS_PAGE       0x00000001
#define VFW_HIDE_VIDEOSRC_PAGE       0x00000002
#define VFW_HIDE_CAMERACONTROL_PAGE  0x00000004
#define VFW_HIDE_ALL_PAGES           (VFW_HIDE_SETTINGS_PAGE |\
                                     VFW_HIDE_VIDEOSRC_PAGE  |\
                                     VFW_HIDE_CAMERACONTROL_PAGE)
#define VFW_OEM_ADD_PAGE             0x80000000  // If OEM has added any page


#define VFW_USE_DEVICE_HANDLE        0x00000001
#define VFW_USE_STREAM_HANDLE        0x00000002
#define VFW_QUERY_DEV_CHANGED        0x00000100  // if selected_dev == streaming_dev


//
// This is the function pointer that vfwwdm mapper calls to add an page
//
typedef 
DWORD (CALLBACK FAR * VFWWDMExtensionProc)(
	LPVOID					pfnDeviceIoControl, 
	LPFNADDPROPSHEETPAGE	pfnAddPropertyPage, 
	LPARAM					lParam);

//
// This is the function pointer that you can call to make DeviceIoControl() calls.
//
typedef 
BOOL (CALLBACK FAR * LPFNEXTDEVIO)(
					LPARAM lParam,	
					DWORD dwFlags,
					DWORD dwIoControlCode, 
					LPVOID lpInBuffer, 
					DWORD nInBufferSize, 
					LPVOID lpOutBuffer, 
					DWORD nOutBufferSize, 
					LPDWORD lpBytesReturned,
					LPOVERLAPPED lpOverlapped);
               

//                                                             
// HLM\System\CurrentControlSet\Control\MediaResources\msvideo\MSVideo.VFWWDM 
//
// Registry values used to allow a VfW client application to programatically
// open a target capture device.  The first is the FriendlyName of the capture
// device; and the 2nd flag if set, vfwwdm mapper will open only; if failed, 
// no attempt will be made by VfWWDM mapper to open other WDM capture device.
//
// Both registry value should be clear after capDriverConnect().  VfWWDM mapper
// will not clear them unless video source dialog box is chosen.
//                
#define TARGET_DEVICE_FRIENDLY_NAME     "TargetDeviceFriendlyName"      // REG_SZ
#define TARGET_DEVICE_OPEN_EXCLUSIVELY  "TargetDeviceOpenExclusively"   // REG_DWORD
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\win2k8\ddk\inc\vcclr.h ===
//
//	vcclr.h - helper code for using the managed extensions to C++
//
//		Copyright (C) Microsoft Corporation
//		All rights reserved.
//

#if _MSC_VER > 1000
#pragma once
#endif

#if !defined(_INC_VCCLR)
#define _INC_VCCLR

#include <gcroot.h>

#pragma warning(push)
#pragma warning(disable:4400)

#ifdef __cplusplus_cli
typedef cli::interior_ptr<const System::Char> __const_Char_ptr;
typedef cli::interior_ptr<const System::Byte> __const_Byte_ptr;
typedef cli::interior_ptr<System::Byte> _Byte_ptr;
typedef const System::String^ __const_String_handle;
#define _NULLPTR nullptr
#else
typedef const System::Char* __const_Char_ptr;
typedef const System::Byte* __const_Byte_ptr;
typedef System::Byte* _Byte_ptr;
typedef const System::String* __const_String_handle;
#define _NULLPTR 0
#endif


//
// get an interior gc pointer to the first character contained in a System::String object
//
inline
__const_Char_ptr
#ifdef __cplusplus_cli
__clrcall
#endif
PtrToStringChars(
	__const_String_handle s
	)
{
	_Byte_ptr bp = const_cast<_Byte_ptr>(reinterpret_cast<__const_Byte_ptr>(s));
	if( bp != _NULLPTR ) {
		unsigned offset = System::Runtime::CompilerServices::RuntimeHelpers::OffsetToStringData;
    	bp += offset;
	}
    return reinterpret_cast<__const_Char_ptr>(bp);
}

#pragma warning(pop)

#undef _NULLPTR

#endif //_INC_VCCLR
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\win2k8\ddk\inc\videoagp.h ===
/*++

Copyright (c) Microsoft Corporation. All rights reserved.

Module Name:

    videoagp.h

Abstract:
    Video miniport AGP support.

Notes:

Revision History:

--*/

#ifndef __VIDEOAGP_H__
#define __VIDEOAGP_H__

#define VIDEO_AGP_RATE_1X       1
#define VIDEO_AGP_RATE_2X       2
#define VIDEO_AGP_RATE_4X       4
#define VIDEO_AGP_RATE_8X       8

typedef enum
{
    VpNonCached = 0,
    VpWriteCombined,
    VpCached
} VIDEO_PORT_CACHE_TYPE;

typedef
PHYSICAL_ADDRESS
(STDAPICALLTYPE *PAGP_RESERVE_PHYSICAL)(
    IN PVOID HwDeviceExtension,
    IN ULONG Pages,
    IN VIDEO_PORT_CACHE_TYPE Caching,
    OUT PVOID *PhysicalReserveContext
    );

typedef
VOID
(STDAPICALLTYPE *PAGP_RELEASE_PHYSICAL)(
    IN PVOID HwDeviceExtension,
    IN PVOID PhysicalReserveContext
    );

typedef
BOOLEAN
(STDAPICALLTYPE *PAGP_COMMIT_PHYSICAL)(
    IN PVOID HwDeviceExtension,
    IN PVOID PhysicalReserveContext,
    IN ULONG Pages,
    IN ULONG Offset
    );

typedef
VOID
(STDAPICALLTYPE *PAGP_FREE_PHYSICAL)(
    IN PVOID HwDeviceExtension,
    IN PVOID PhysicalReserveContext,
    IN ULONG Pages,
    IN ULONG Offset
    );

typedef
PVOID
(STDAPICALLTYPE *PAGP_RESERVE_VIRTUAL)(
    IN PVOID HwDeviceExtension,
    IN HANDLE ProcessHandle,
    IN PVOID PhysicalReserveContext,
    OUT PVOID *VirtualReserveContext
    );

typedef
VOID
(STDAPICALLTYPE *PAGP_RELEASE_VIRTUAL)(
    IN PVOID HwDeviceExtension,
    IN PVOID VirtualReserveContext
    );

typedef
PVOID
(STDAPICALLTYPE *PAGP_COMMIT_VIRTUAL)(
    IN PVOID HwDeviceExtension,
    IN PVOID VirtualReserveContext,
    IN ULONG Pages,
    IN ULONG Offset
    );

typedef
VOID
(STDAPICALLTYPE *PAGP_FREE_VIRTUAL)(
    IN PVOID HwDeviceExtension,
    IN PVOID VirtualReserveContext,
    IN ULONG Pages,
    IN ULONG Offset
    );

typedef
BOOLEAN
(STDAPICALLTYPE *PAGP_SET_RATE)(
    IN PVOID HwDeviceExtension,
    IN ULONG AgpRate
    );

typedef struct _VIDEO_PORT_AGP_SERVICES
{
    PAGP_RESERVE_PHYSICAL AgpReservePhysical;
    PAGP_RELEASE_PHYSICAL AgpReleasePhysical;
    PAGP_COMMIT_PHYSICAL  AgpCommitPhysical;
    PAGP_FREE_PHYSICAL    AgpFreePhysical;

    PAGP_RESERVE_VIRTUAL  AgpReserveVirtual;
    PAGP_RELEASE_VIRTUAL  AgpReleaseVirtual;
    PAGP_COMMIT_VIRTUAL   AgpCommitVirtual;
    PAGP_FREE_VIRTUAL     AgpFreeVirtual;
    ULONGLONG AllocationLimit;

} VIDEO_PORT_AGP_SERVICES, *PVIDEO_PORT_AGP_SERVICES;

BOOLEAN
STDAPICALLTYPE
VideoPortGetAgpServices(
    IN PVOID HwDeviceExtension,
    IN PVIDEO_PORT_AGP_SERVICES AgpServices
    );

#endif // ifndef __VIDEOAGP_H__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\win2k8\ddk\inc\video.h ===
/*++

Copyright (c) Microsoft Corporation. All rights reserved.

Module Name:

    video.h

Abstract:

    Contains all structure and routine definitions common to the video port
    driver and the video miniport drivers.

Notes:

Revision History:

--*/

#ifndef __VIDEO_H__
#define __VIDEO_H__

#include <videoagp.h>

#ifdef __cplusplus
extern "C" {
#endif

//
// Define port driver status code.
// The values for these are the Win32 error codes
//

typedef LONG VP_STATUS;
typedef VP_STATUS *PVP_STATUS;

//
// Defines for registry information and synchronization.
//

typedef enum VIDEO_SYNCHRONIZE_PRIORITY {
    VpLowPriority,
    VpMediumPriority,
    VpHighPriority
} VIDEO_SYNCHRONIZE_PRIORITY, *PVIDEO_SYNCHRONIZE_PRIORITY;

typedef struct _VIDEO_PORT_SPIN_LOCK *PSPIN_LOCK;

//
// Type of information requested with GetDeviceData
//

typedef enum _VIDEO_DEVICE_DATA_TYPE {
    VpMachineData,
    VpCmosData,
    VpBusData,
    VpControllerData,
    VpMonitorData
} VIDEO_DEVICE_DATA_TYPE, *PVIDEO_DEVICE_DATA_TYPE;

typedef enum _VP_POOL_TYPE {
    VpNonPagedPool,
    VpPagedPool,
    VpNonPagedPoolCacheAligned = 4,
    VpPagedPoolCacheAligned
} VP_POOL_TYPE, *PVP_POOL_TYPE;

//
// Data returned with VpControllerData
//

typedef struct _VIDEO_HARDWARE_CONFIGURATION_DATA {
    INTERFACE_TYPE InterfaceType;
    ULONG BusNumber;
    USHORT Version;
    USHORT Revision;
    USHORT Irql;
    USHORT Vector;
    ULONG ControlBase;
    ULONG ControlSize;
    ULONG CursorBase;
    ULONG CursorSize;
    ULONG FrameBase;
    ULONG FrameSize;
} VIDEO_HARDWARE_CONFIGURATION_DATA, *PVIDEO_HARDWARE_CONFIGURATION_DATA;

//
// Define structure used to call the BIOS int 10 function
//

typedef struct _VIDEO_X86_BIOS_ARGUMENTS {
    ULONG Eax;
    ULONG Ebx;
    ULONG Ecx;
    ULONG Edx;
    ULONG Esi;
    ULONG Edi;
    ULONG Ebp;
} VIDEO_X86_BIOS_ARGUMENTS, *PVIDEO_X86_BIOS_ARGUMENTS;

typedef struct _INT10_BIOS_ARGUMENTS {
    ULONG Eax;
    ULONG Ebx;
    ULONG Ecx;
    ULONG Edx;
    ULONG Esi;
    ULONG Edi;
    ULONG Ebp;
    USHORT SegDs;
    USHORT SegEs;
} INT10_BIOS_ARGUMENTS, *PINT10_BIOS_ARGUMENTS;

//
// Debugging statements. This will remove all the debug information from the
// "free" version.
//

#if DBG
#define VideoDebugPrint(arg) VideoPortDebugPrint arg
#else
#define VideoDebugPrint(arg)
#endif

typedef enum VIDEO_DEBUG_LEVEL {
    Error = 0,
    Warn,
    Trace,
    Info
} VIDEO_DEBUG_LEVEL, *PVIDEO_DEBUG_LEVEL;

//
// Allows us to remove lots of unused code.
//


#ifndef _NTOSDEF_

//don't pickup ntosp version
#ifdef PAGED_CODE
#undef PAGED_CODE
#endif

#define ALLOC_PRAGMA 1
#define VIDEOPORT_API __declspec(dllimport)

#if DBG
#define PAGED_CODE() \
    if (VideoPortGetCurrentIrql() > 1 /*APC_LEVEL*/) { \
        VideoPortDebugPrint(0, "Video: Pageable code called at IRQL %d\n", VideoPortGetCurrentIrql() ); \
        ASSERT(FALSE); \
        }

#else
#define PAGED_CODE()
#endif

ULONG
DriverEntry(
    PVOID Context1,
    PVOID Context2
    );

#else
#define VIDEOPORT_API
#endif

#ifndef _NTOS_

//
// These are the various function prototypes of the routines that are
// provided by the kernel driver to hook out access to io ports.
//

typedef
VP_STATUS
(*PDRIVER_IO_PORT_UCHAR ) (
    ULONG_PTR Context,
    ULONG Port,
    UCHAR AccessMode,
    PUCHAR Data
    );

typedef
VP_STATUS
(*PDRIVER_IO_PORT_UCHAR_STRING ) (
    ULONG_PTR Context,
    ULONG Port,
    UCHAR AccessMode,
    PUCHAR Data,
    ULONG DataLength
    );

typedef
VP_STATUS
(*PDRIVER_IO_PORT_USHORT ) (
    ULONG_PTR Context,
    ULONG Port,
    UCHAR AccessMode,
    PUSHORT Data
    );

typedef
VP_STATUS
(*PDRIVER_IO_PORT_USHORT_STRING ) (
    ULONG_PTR Context,
    ULONG Port,
    UCHAR AccessMode,
    PUSHORT Data,
    ULONG DataLength // number of words
    );

typedef
VP_STATUS
(*PDRIVER_IO_PORT_ULONG ) (
    ULONG_PTR Context,
    ULONG Port,
    UCHAR AccessMode,
    PULONG Data
    );

typedef
VP_STATUS
(*PDRIVER_IO_PORT_ULONG_STRING ) (
    ULONG_PTR Context,
    ULONG Port,
    UCHAR AccessMode,
    PULONG Data,
    ULONG DataLength  // number of dwords
    );

#endif // _NTOS_


//
// Definition of the request packet sent from the port driver to the
// miniport driver. It reflects the parameters passed from the
// DeviceIOControl call made by the windows display driver.
//
// N.B. The definition of the STATUS_BLOCK must be the same as the
//      the definition of IO_STATUS_BLOCK defined in ntioapi.h.
//

typedef struct _STATUS_BLOCK {

    //
    // Contains the status code of the operation.
    // This value in one of the Win32 error codes that are defined for use
    // in the video miniport drivers.
    //

    union {
       VP_STATUS Status;
       PVOID Pointer;
    };

    //
    // Information returned to the callee.
    // The meaning of the information varies from function to function. It
    // is generally used to return the minimum size for the input buffer if
    // the function takes an input buffer, or the amount of data transfered
    // back to the caller if the operation returns output.
    //

    ULONG_PTR Information;

} STATUS_BLOCK, *PSTATUS_BLOCK;

typedef struct _VIDEO_REQUEST_PACKET {

    //
    // The IO control code passed to the DeviceIoControl function by the
    // caller.
    //

    ULONG IoControlCode;

    //
    // Pointer to a status block provided by the caller. This should be
    // filled out by the callee with the appropriate information.
    //

    PSTATUS_BLOCK StatusBlock;

    //
    // Pointer to an input buffer which contains the information passed in
    // by the caller.
    //

    PVOID InputBuffer;

    //
    // Size of the input buffer
    //

    ULONG InputBufferLength;

    //
    // Pointer to an output buffer into which the data returned to the caller
    // should be stored.
    //

    PVOID OutputBuffer;

    //
    // Length of the output buffer. This buffer can not be grown by the
    // callee.
    //

    ULONG OutputBufferLength;

} VIDEO_REQUEST_PACKET, *PVIDEO_REQUEST_PACKET;

//
//  typedef for scattergather array available via GET_VIDEO_SCATTERGATHER().
//

typedef struct __VRB_SG {
    __int64   PhysicalAddress;
    ULONG     Length;
    } VRB_SG, *PVRB_SG;

//
// Opaque type for dma handle
//

typedef struct __DMA_PARAMETERS * PDMA;

//
//  The following macro returns in Address the 32 bit physical address of
//  the VirtualAddress lying within the InputBuffer passed into EngDevIo
//

#define GET_VIDEO_PHYSICAL_ADDRESS(scatterList, VirtualAddress, InputBuffer, pLength, Address)    \
                                                                                           \
        do {                                                                               \
            ULONG_PTR          byteOffset;                                                  \
                                                                                           \
            byteOffset = (PCHAR) VirtualAddress - (PCHAR)InputBuffer;                \
                                                                                           \
            while (byteOffset >= scatterList->Length) {                                    \
                                                                                           \
                byteOffset -= scatterList->Length;                                         \
                scatterList++;                                                             \
            }                                                                              \
                                                                                           \
            *pLength = scatterList->Length - byteOffset;                                   \
                                                                                           \
            Address = (ULONG_PTR) (scatterList->PhysicalAddress + byteOffset);                  \
                                                                                           \
        } while (0)


#define GET_VIDEO_SCATTERGATHER(ppDma)   (**(PVRB_SG **)ppDma)

//
// Opaque type for PVP_DMA_ADAPTER
//

typedef struct __VP_DMA_ADAPTER *PVP_DMA_ADAPTER;

typedef enum _VP_LOCK_OPERATION {
    VpReadAccess,
    VpWriteAccess,
    VpModifyAccess
    } VP_LOCK_OPERATION;

typedef struct _VP_DEVICE_DESCRIPTION {
    BOOLEAN  ScatterGather;
    BOOLEAN  Dma32BitAddresses;
    BOOLEAN  Dma64BitAddresses;
    ULONG    MaximumLength;
} VP_DEVICE_DESCRIPTION, *PVP_DEVICE_DESCRIPTION;

typedef struct _VP_SCATTER_GATHER_ELEMENT {
    PHYSICAL_ADDRESS Address;
    ULONG Length;
    ULONG_PTR Reserved;
    } VP_SCATTER_GATHER_ELEMENT, *PVP_SCATTER_GATHER_ELEMENT;

#pragma warning(disable:4200)
typedef struct _VP_SCATTER_GATHER_LIST {
    ULONG NumberOfElements;
    ULONG_PTR Reserved;
    VP_SCATTER_GATHER_ELEMENT Elements[];
    } VP_SCATTER_GATHER_LIST, *PVP_SCATTER_GATHER_LIST;
#pragma warning(default:4200)

#define VIDEO_RANGE_PASSIVE_DECODE   0x1
#define VIDEO_RANGE_10_BIT_DECODE    0x2


//
// The following structure is used to define access ranges. The ranges are
// used to indicate which ports and memory adresses are being used by the
// card.
//

typedef struct _VIDEO_ACCESS_RANGE {

    //
    // Indicates the starting memory address or port number of the range.
    // This values should be stored before being transformed by
    // VideoPortGetDeviceBase() which returns the logical address that must
    // be used by the miniport driver when referencing physical addresses.
    //

    PHYSICAL_ADDRESS RangeStart;

    //
    // Indicates the length in bytes, or number of ports in the range. This
    // value should indicate the range actually decoded by the adapter. For
    // example, if the adapter uses 7 registers but responds to eight, the
    // RangeLength should be set to 8.

    ULONG RangeLength;

    //
    // Indicates if the range is in IO space (TRUE) or in memory space (FALSE).
    //

    UCHAR RangeInIoSpace;

    //
    // Indicates if the range should be visible by the Windows display driver.
    // This is done so that a Windows display driver can access certain
    // video ports directly. This will only be allowed if the caller has the
    // required privileges (is a trusted subsystem) to access the range.
    //
    // Synchronization of access to ports or memory in the range must be
    // done explicitly by the miniport driver and the user mode process so
    // that they both don't try to program the device simultaneously.
    //
    // Non visible ranges should include video memory, ROM addresses, etc.
    // which are not required to program the device for output purposes.
    //
    //

    UCHAR RangeVisible;

    //
    // This field determines if the range can be shared with another device.
    // The rule should be applied as follow.
    //
    // - If the range of memory or IO ports should be "owned" by this driver,
    //   and that any other driver trying to access this range may cause
    //   a problem, FALSE should be returned.
    //
    // - If the range can be shared with another co-operating device driver,
    //   then the share field should be set to TRUE.
    //
    // As a guideline, the VGA miniport driver will claim all of its resources
    // as shareable so that it can be used as a VGA compatible device with
    // any other driver (such as an S3 or XGA.
    //
    // Super VGA miniport drivers that implement all the VGA functionality
    // (declared in the Registry as VGACOMPATIBLE=1) should claim the range
    // as non-shareable since they don't want the VGA to run at the same time.
    //
    // Miniports for cards such as an S3 or XGA that have an XGA on the board
    // but do not implement the VGA functionality will run with the VGA
    // miniport loaded and should therefore claim all the resources shared
    // with the VGA as shareable.
    //
    // Miniports for cards that work with a pass-through and that can be
    // connected to any VGA/SVGA card should not be using any VGA ports or
    // memory ranges ! ... but if they do they should not claim those
    // resources since they will cause a conflict in the system because the
    // SVGA cards will have claimed them as non-shareable ...
    //

    UCHAR RangeShareable;

    //
    // Indicates that the range is decoded by the hardware, but that the
    // driver will never access this port.
    //

    UCHAR RangePassive;

} VIDEO_ACCESS_RANGE, *PVIDEO_ACCESS_RANGE;


typedef
PVOID
(*PVIDEO_PORT_GET_PROC_ADDRESS)(
    IN PVOID HwDeviceExtension,
    IN PUCHAR FunctionName
    );

//
// This structure contains the specific configuration information about the
// device. The information is initialized by the port driver and it should
// be completed by the miniport driver.
// The information is used to setup the device, as weel as providing
// information to the port driver so it can perform some of the requests on
// behalf of the miniport driver.
//

typedef struct _VIDEO_PORT_CONFIG_INFO {

    //
    // Specifies the length of the PVIDEO_PORT_CONFIG_INFO structure as
    // returned by sizeof(). Since this structure may grow in later
    // releases, the miniport driver should check that the length of the
    // structure is greater than or equal to the length it expects (since
    // it is guaranteed that defined fields will not change).
    //
    // This field is always initialized by the port driver.
    //

    ULONG Length;

    //
    // Specifies which IO bus is tp be scanned. This field is used as a
    // parameter to some VideoPortXXX calls.
    //
    // This field is always initialized by the port driver.
    //

    ULONG SystemIoBusNumber;

    //
    // Specifies the type of bus being scanned. This field is equal to the
    // value being passed into VideoPortInitialize in the
    // VIDEO_HW_INITIALIZATION_DATA structure.
    //
    // This field is always initialized by the port driver.
    //

    INTERFACE_TYPE AdapterInterfaceType;

    //
    // Specifies the bus interrupt request level. This level corresponds to
    // the IRQL on ISA and MCA buses.
    // This value is only used if the device supports interrupts, which is
    // determined by the presence of an interrupt service routine in the
    // VIDEO_HW_INITIALIZATION_DATA structure.
    //
    // The preset default value for this field is zero. Otherwise, it is the
    // value found in the device configuration information.
    //

    ULONG BusInterruptLevel;

    //
    // Specifies the bus vector returned by the adapter. This is used for
    // systems which have IO buses that use interrupt vectors. For ISA, MCA
    // and EISA buses, this field is unused.
    //
    // The preset default value for this field is zero.
    //

    ULONG BusInterruptVector;

    //
    // Specifies whether this adapter uses latched or edge-triggered type
    // interrupts.
    //
    // This field is always initialized by the port driver.
    //

    KINTERRUPT_MODE InterruptMode;

    //
    // Specifies the number of emulator access entries that the adapter
    // uses.  It indicates the number of array elements in the following field.
    //
    // This field can be reinitialized with the number of entries in the
    // EmulatorAccessEntries structure if the structure is statically
    // defined in the miniport driver. The EmulatorAccessEntries fields
    // should also be updated.
    //

    ULONG NumEmulatorAccessEntries;

    //
    // Supplies a pointer to an array of EMULATOR_ACCESS_ENTRY structures.
    // The number of elements in the array is indicated by the
    // NumEmulatorAccessEntries field. The driver should fill out each entry
    // for the adapter.
    //
    // The uninitialized value for the structure is NULL.
    // EmulatorAccessEntries will be NULL if NumEmulatorAccessEntries is
    // zero.
    //
    // A poiner to an array of emulator access entries can be passed back
    // if such a structure is defined statically in the miniport driver. The
    // NumEmulatorAccessEntries field should also be updated.
    //

    PEMULATOR_ACCESS_ENTRY EmulatorAccessEntries;

    //
    // This is a context values that is passed with each call to the
    // emulator/validator functions defined in the EmulatorAccessEntries
    // defined above.
    // This parameter should in general be a pointer to the miniports
    // device extension or other such storage location.
    //
    // This pointer will allow the miniport to save some state temporarily
    // to allow for the batching of IO requests.
    //

    ULONG_PTR EmulatorAccessEntriesContext;

    //
    // Physical address of the video memory that must be mapped into a VDM's
    // address space for proper BIOS support
    //

    PHYSICAL_ADDRESS VdmPhysicalVideoMemoryAddress;

    //
    // Length of the video memory that must be mapped into a VDM's addres
    // space for proper BIOS support.
    //

    ULONG VdmPhysicalVideoMemoryLength;

    //
    // Determines the minimum size required to store the hardware state
    // information returned by IOCTL_VIDEO_SAVE_HARDWARE_STATE.
    //
    // The uninitialized value for this field is zero.
    //
    // If the field is left to zero, SAVE_HARDWARE_STATE will return an
    // ERROR_INVALID_FUNCTION status code.
    //

    ULONG HardwareStateSize;

    //
    // New for version 3.5
    //

    //
    // Optional DMA channel, if required by the device.
    // 0 for the Channel and Port indicates DMA is not used by the device.
    //

    ULONG DmaChannel;

    //
    // Optional DMA channel, if required by the device.
    // 0 for the Channel and Port indicates DMA is not used by the device.
    //

    ULONG DmaPort;

    //
    // Set to 1 if the DMA channel can be shared with another device.
    // Set to 0 if the DMA channel must be owned exclusively by the driver.
    //

    UCHAR DmaShareable;

    //
    // Set to 1 if the interrupt can be shared with another device.
    // Set to 0 if the interrupt must be owned exclusively by the driver.
    //

    UCHAR InterruptShareable;

    //
    //  Start new dma stuff
    //

    //
    // Set to TRUE if the DMA device is a busmaster, FALSE otherwise.
    //

    BOOLEAN Master;

    //
    // Set to number of bits wide. Consistent with DEVICE_DESCRIPTION.
    // See ntioapi.h
    //

    DMA_WIDTH   DmaWidth;

    //
    // Set to speed so miniport can set DEVICE_DESCRIPTION field.
    // See ntioapi.h
    //

    DMA_SPEED   DmaSpeed;

    //
    // Set to TRUE if the DMA device requires mapped buffers. Also
    // a DEVICE_DESCRIPTION  field.
    //

    BOOLEAN bMapBuffers;

    //
    // Set to TRUE if the DMA device requires physical addresses.
    //

    BOOLEAN NeedPhysicalAddresses;

    //
    // Set to TRUE if the DMA device supports demand mode, FALSE otherwise.
    // Also DEVICE_DESCRIPTION support.
    //

    BOOLEAN DemandMode;

    //
    // Set to max transfer length the DMA device supports.
    //

    ULONG   MaximumTransferLength;

    //
    // Set to max number of Physical breaks the DMA device supports.
    //

    ULONG   NumberOfPhysicalBreaks;

    //
    // Set to TRUE if the DMA device supports scatter gather, FALSE otherwise.
    //

    BOOLEAN ScatterGather;

    //
    // Maximal Length in PVRB_SG returned measured in bytes. If the device
    // has no maximum size, zero should be entered.
    //

    ULONG   MaximumScatterGatherChunkSize;

    //
    // Allow for 4.0/5.0 compatibilty
    //

    PVIDEO_PORT_GET_PROC_ADDRESS VideoPortGetProcAddress;

    //
    // Provide a pointer to the device's registry path
    //

    PWSTR DriverRegistryPath;

    //
    // Indicates to a driver the amount of physical memory in the system
    //

    ULONGLONG SystemMemorySize;

} VIDEO_PORT_CONFIG_INFO, *PVIDEO_PORT_CONFIG_INFO;

#define SIZE_OF_NT4_VIDEO_PORT_CONFIG_INFO FIELD_OFFSET(VIDEO_PORT_CONFIG_INFO, Master)
#define SIZE_OF_WXP_VIDEO_PORT_CONFIG_INFO sizeof(VIDEO_PORT_CONFIG_INFO)

//
// Video Adapter Dependent Routines.
//

typedef
VP_STATUS
(*PVIDEO_HW_FIND_ADAPTER) (
    PVOID HwDeviceExtension,
    PVOID HwContext,
    PWSTR ArgumentString,
    PVIDEO_PORT_CONFIG_INFO ConfigInfo,
    PUCHAR Again
    );

typedef
BOOLEAN
(*PVIDEO_HW_INITIALIZE) (
    PVOID HwDeviceExtension
    );

typedef
BOOLEAN
(*PVIDEO_HW_INTERRUPT) (
    PVOID HwDeviceExtension
    );

typedef
VOID
(*PVIDEO_HW_LEGACYRESOURCES) (
    IN ULONG VendorId,
    IN ULONG DeviceId,
    IN OUT PVIDEO_ACCESS_RANGE *LegacyResourceList,
    IN OUT PULONG LegacyResourceCount
    );

//
// type to be returned by HwStartDma().
//

typedef enum _HW_DMA_RETURN {
    DmaAsyncReturn,
    DmaSyncReturn
    } HW_DMA_RETURN, *PHW_DMA_RETURN;


typedef
HW_DMA_RETURN
(*PVIDEO_HW_START_DMA) (
    PVOID                   HwDeviceExtension,
    PDMA                    pDma
    );

typedef
VOID
(*PEXECUTE_DMA)(
    PVOID                   HwDeviceExtension,
    PVP_DMA_ADAPTER         VpDmaAdapter,
    PVP_SCATTER_GATHER_LIST SGList,
    PVOID                   Context
    );


//
//  Flags to be passed into VideoPortLockPages() or VideoPortDoDma().
//

//
//  The flag VideoPortUnlockAfterDma tells the video port to unlock the pages
//  after the miniport signals that the dma is complete via the
//  pDmaCompletionEvent in HwStartDma. Failure to set this event at
//  dma completion may cause the memory to be unlocked at randon times.
//  This flag is best used when one wants to do one dma transfer which
//  occurs infrequently. It allows locking, dmaing and unlocking to be performed
//  in the context of 1 IOCTL.
//

//
//  The flag VideoPortKeepPagesLocked tells the video port to leave the pages
//  locked if possible.
//

//
//  The flag VideoPortDmaInitOnly tells the Video Port to lock the pages, but don't
//  call HwStartDma. Not applicable to VideoPortDoDma().
//


typedef enum {
    VideoPortUnlockAfterDma = 1,
    VideoPortKeepPagesLocked,
    VideoPortDmaInitOnly
    }   DMA_FLAGS;

//
// Event flags
//

typedef ULONG DMA_EVENT_FLAGS;

#define SET_USER_EVENT    0x01
#define SET_DISPLAY_EVENT 0x02

#define EVENT_TYPE_MASK            1
#define SYNCHRONIZATION_EVENT      0
#define NOTIFICATION_EVENT         1

#define INITIAL_EVENT_STATE_MASK   2
#define INITIAL_EVENT_NOT_SIGNALED 0
#define INITIAL_EVENT_SIGNALED     2

//
// Child Enumeration structure passed in to the PVIDEO_HW_GET_CHILD_DESCRIPTOR
// function.
//
// All these parameters are input parameters and must not be modified by the
// callee
//
// Size - Size of the structure.  It can be used by the calle for versioning.
//
// ChildDescriptorSize - Size of the pChildDescriptor buffer passed in as the
//     third parameter to PVIDEO_HW_GET_CHILD_DESCRIPTOR.
//
// ChildIndex - Index of the device to be enumerated.  This field should be
//     used to enumerate devices not enumerated by ACPI or other operating
//     system components.  If this field is set to 0 it indicates the ACPIHwId
//     field.
//
// ACPIHwId - ID returned by the ACPI BIOS that represent the device being
//     queried.  The ACPIHwId returned by the firmware must match the HwIds
//     returned by the driver.  The System BIOS manufacturer and the graphics
//     IHV must synchronize these IDs.
//
// ChildHwDeviceExtension - Pointer to a device extension specific to this
//     child device.  This field will only be filled in if the miniport driver
//     filled the ChildHwDeviceExtensionSize to be non-NULL.
//

typedef struct _VIDEO_CHILD_ENUM_INFO {
    ULONG Size;
    ULONG ChildDescriptorSize;
    ULONG ChildIndex;
    ULONG ACPIHwId;
    PVOID ChildHwDeviceExtension;
} VIDEO_CHILD_ENUM_INFO, *PVIDEO_CHILD_ENUM_INFO;

//
//  VIDEO_CHILD_TYPE enum:
//
//  'Monitor' identifies a device which may have a DDC2 compliant EDID data
//  structure. If the video miniport detects such a device, it is to extract
//  the edid from the monitor and put that in the paged buffer provided by
//  videoprt.sys in the callback to PVIDEO_HW_GET_CHILD_DESCRIPTOR and return
//  this type in the the OUT PVIDEO_CHILD_TYPE parameter of that call. This
//  EDID, if available, will be written to the registry. If the EDID is not
//  available, nothing should be put in the buffer.
//
//  'NonPrimaryChip' identifies another VGA chip on the video board which
//  is not the primary VGA chip. This type is to be used if and only if the
//  miniport detects more than one VGA chip on the board. Such an identifier
//  will cause the videoprt to create another DEVICE_EXTENSION and associated
//  HW_DEVICE_EXTENSION to be associated with the chip so identified.
//
//  'Other' identifies some other video device attached to the video card. If
//  the miniport detects such a device, it is to put a wide char string
//  (WSTR) into the paged buffer provided by the videoprt.sys which is the
//  PNP hardware identifier of the device. This string will be used to create
//  a value of that name in the registry.
//

typedef enum {
    Monitor = 1,
    NonPrimaryChip,
    VideoChip,
    Other
} VIDEO_CHILD_TYPE, *PVIDEO_CHILD_TYPE;

//
//  define a constant that represents the display adapter self query.
//

#define DISPLAY_ADAPTER_HW_ID           0xFFFFFFFF

//
// Define invalid child device id (needed for failure return value).
//

#define VIDEO_INVALID_CHILD_ID          0xFFFFFFFF

typedef struct _VIDEO_CHILD_STATE {
    ULONG   Id;
    ULONG   State;
} VIDEO_CHILD_STATE, *PVIDEO_CHILD_STATE;

typedef struct _VIDEO_CHILD_STATE_CONFIGURATION {
    ULONG             Count;
    VIDEO_CHILD_STATE ChildStateArray[ANYSIZE_ARRAY];
} VIDEO_CHILD_STATE_CONFIGURATION, *PVIDEO_CHILD_STATE_CONFIGURATION;

//
//  The following routine should return TRUE if successful. It should:
//      1)  put the type of the child device in VideoChildType.
//      2)  put the information from the device in Buffer. This
//          buffer is of size 256 bytes. If the type returned in
//          PVideoChildType is Monitor, this buffer must contain the
//          EDID of the monitor if readable. If the type returned in
//          PVideoChildType is Other, a wide character string representing
//          the PNP Device Id must be put in the buffer. This string will
//          be used to create a key for the device if the buffer contains
//          an EDID. Otherwise, it is used to obtain a PNP ID for the
//          device.
//      3)  Put a miniport determined HANDLE in HwId. This value will be
//          passed back to the miniport for Power management operations,
//          as well as other operations. This allows the miniport to define
//          the contract between the system and the miniport which defines a
//          particular device.
//
//  It should  only return FALSE if there are no devices attached to that
//  display adapter connector.
//

typedef
VP_STATUS
(*PVIDEO_HW_GET_CHILD_DESCRIPTOR) (
    IN  PVOID                   HwDeviceExtension,
    IN  PVIDEO_CHILD_ENUM_INFO  ChildEnumInfo,
    OUT PVIDEO_CHILD_TYPE       VideoChildType,
    OUT PUCHAR                  pChildDescriptor,
    OUT PULONG                  UId,
    OUT PULONG                  pUnused
    );


//
// This routine is used to set the power on the graphics devices.
// These include all the Children enumerated by GET_CHILD_DESCRIPTOR callback
// as well as the graphics adapter itself.
//
// The HwDevice extension represent the adapter instance of the device.
//
// The HwId parameter is the unique ID as returned by the enumeration routine.
// The miniport will only be called to set the power on the devices it
// enumerated, as well as the graphics adapter itself.  A HwId of 0xFFFFFFFF
// will be passed in to identify the graphics adapter itself.
// The miniport driver should never turn off the power to the graphics adapter
// unless specifically request to.
//
// The VideoPowerControl is the level to which the device shold be set.
// The videoport driver will manage these states.
//

typedef
VP_STATUS
(*PVIDEO_HW_POWER_SET) (
    PVOID                   HwDeviceExtension,
    ULONG                   HwId,
    PVIDEO_POWER_MANAGEMENT VideoPowerControl
    );

//
// This routine simply returns whether or not the device can support the
// requested state.
//
// See HW_POWER_SET for a description of the parameters.
//

typedef
VP_STATUS
(*PVIDEO_HW_POWER_GET) (
    PVOID                   HwDeviceExtension,
    ULONG                   HwId,
    PVIDEO_POWER_MANAGEMENT VideoPowerControl
    );

//
// This structure should match the QueryInterface struct defined
// in io.h.
//

typedef struct _QUERY_INTERFACE {
    CONST GUID *InterfaceType;
    USHORT Size;
    USHORT Version;
    PINTERFACE Interface;
    PVOID InterfaceSpecificData;
} QUERY_INTERFACE, *PQUERY_INTERFACE;

typedef
VP_STATUS
(*PVIDEO_HW_QUERY_INTERFACE) (
    PVOID HwDeviceExtension,
    PQUERY_INTERFACE QueryInterface
    );

typedef
VP_STATUS
(*PVIDEO_HW_CHILD_CALLBACK) (
    PVOID HwDeviceExtension,
    PVOID ChildDeviceExtension
    );

//
// Entry point for all IOCTL calls made to the miniport driver.
//

typedef
BOOLEAN
(*PVIDEO_HW_START_IO) (
    PVOID HwDeviceExtension,
    PVIDEO_REQUEST_PACKET RequestPacket
    );

//
// The return value determines if the mode was completely programmed (TRUE)
// or if an int10 should be done by the HAL to complete the modeset (FALSE).
//

typedef
BOOLEAN
(*PVIDEO_HW_RESET_HW) (
    PVOID HwDeviceExtension,
    ULONG Columns,
    ULONG Rows
    );

//
// Timer routine called every second.
//

typedef
VOID
(*PVIDEO_HW_TIMER) (
    PVOID HwDeviceExtension
    );

//
// Structure passed by the miniport entry point to the video port
// initialization routine.
//

typedef struct _VIDEO_HW_INITIALIZATION_DATA {

    //
    // Supplies the size of the structure in bytes as determined by sizeof().
    //

    ULONG HwInitDataSize;

    //
    // Indicates the bus type the adapter works with, such as Eisa, Isa, MCA.
    //

    INTERFACE_TYPE AdapterInterfaceType;

    //
    // Supplies a pointer to the miniport driver's find adapter routine.
    //

    PVIDEO_HW_FIND_ADAPTER HwFindAdapter;

    //
    // Supplies a pointer to the miniport driver's initialization routine.
    //

    PVIDEO_HW_INITIALIZE HwInitialize;

    //
    // Supplies a pointer to the miniport driver's interrupt service routine.
    //

    PVIDEO_HW_INTERRUPT HwInterrupt;

    //
    // Supplies a pointer to the miniport driver's start io routine.
    //

    PVIDEO_HW_START_IO HwStartIO;

    //
    // Supplies the size in bytes required for the miniport driver's private
    // device extension. This storage is used by the miniport driver to hold
    // per-adapter information. A pointer to this storage is provided with
    // every call made to the miniport driver. This data storage is
    // initialized to zero by the port driver.
    //

    ULONG HwDeviceExtensionSize;

    //
    // Supplies the number with which device numbering should be started.
    // The device numbering is used to determine which \DeviceX entry under
    // the \Parameters section in the registry should be used for parameters
    // to the miniport driver.
    // The number is *automatically* incremented when the miniport is called
    // back in it's FindAdapter routine due to an appropriate _Again_
    // parameter.
    //

    ULONG StartingDeviceNumber;


    //
    // New for version 3.5
    //

    //
    // Supplies a pointer to the miniport driver's HwResetHw routine.
    //
    // This function is called when the machine needs to bugchecks (go back
    // to the blue screen).
    //
    // This function should reset the video adapter to a character mode,
    // or at least to a state from which an int 10 can reset the card to
    // a character mode.
    //
    // This routine CAN NOT call int10.
    // It can only call Read\Write Port\Register functions from the port driver.
    //
    // The function must also be completely in non-paged pool since the IO\MM
    // subsystems may have crashed.
    //

    PVIDEO_HW_RESET_HW HwResetHw;

    //
    // Pointer to a timer routine to be called every second.
    //

    PVIDEO_HW_TIMER HwTimer;

    //
    //  Start of 5.0 stuff.
    //

    //
    //  Supplies a pointer to the miniport driver's start dma routine. This routine must
    //  return a HW_DMA_RETURN consistent with it's return behavior.
    //

    PVIDEO_HW_START_DMA HwStartDma;

    //
    //  HW dependent Power management routines.
    //

    PVIDEO_HW_POWER_SET HwSetPowerState;
    PVIDEO_HW_POWER_GET HwGetPowerState;

    //
    // Supplies a pointer to a miniport driver routine which can be called to
    // enumerate devices physically attached to the graphics adapter.
    //

    PVIDEO_HW_GET_CHILD_DESCRIPTOR HwGetVideoChildDescriptor;

    //
    // Supplies a pointer to a miniport driver routine which can be called to
    // query external programming interfaces supported in the miniport
    // driver.
    //

    PVIDEO_HW_QUERY_INTERFACE HwQueryInterface;

    //
    // Obselete.  Don't set it.
    //

    ULONG HwChildDeviceExtensionSize;

    //
    // Allows the device to report legacy resources that should be
    // associated with the Plug and Play device.
    //

    PVIDEO_ACCESS_RANGE HwLegacyResourceList;

    //
    // Number of elements in the legacy resource list.
    //

    ULONG HwLegacyResourceCount;

    //
    // Call this routine to allow a driver to specify it's
    // legacy resources based on its device/vendor id.
    //

    PVIDEO_HW_LEGACYRESOURCES HwGetLegacyResources;

    //
    // Can HwGetVideoChildDescriptor be called before HwInitialize?
    //

    BOOLEAN AllowEarlyEnumeration;

    //
    //  Start of 5.1 stuff.
    //

    ULONG Reserved;

} VIDEO_HW_INITIALIZATION_DATA, *PVIDEO_HW_INITIALIZATION_DATA;

#define SIZE_OF_NT4_VIDEO_HW_INITIALIZATION_DATA     FIELD_OFFSET(VIDEO_HW_INITIALIZATION_DATA, HwStartDma)
#define SIZE_OF_W2K_VIDEO_HW_INITIALIZATION_DATA     FIELD_OFFSET(VIDEO_HW_INITIALIZATION_DATA, Reserved)
#define SIZE_OF_WXP_VIDEO_HW_INITIALIZATION_DATA     (SIZE_OF_W2K_VIDEO_HW_INITIALIZATION_DATA + sizeof(ULONG))

//
// DDC help routines.
//

typedef
VOID
(*PVIDEO_WRITE_CLOCK_LINE)(
    PVOID HwDeviceExtension,
    UCHAR Data
    );

typedef
VOID
(*PVIDEO_WRITE_DATA_LINE)(
    PVOID HwDeviceExtension,
    UCHAR Data
    );

typedef
BOOLEAN
(*PVIDEO_READ_CLOCK_LINE)(
    PVOID HwDeviceExtension
    );

typedef
BOOLEAN
(*PVIDEO_READ_DATA_LINE)(
    PVOID HwDeviceExtension
    );

typedef
VOID
(*PVIDEO_WAIT_VSYNC_ACTIVE)(
    PVOID HwDeviceExtension
    );

//
// Data structures used I2C and DDC helper functions.
//

typedef struct _I2C_FNC_TABLE
{
    IN ULONG                    Size;
    IN PVIDEO_WRITE_CLOCK_LINE  WriteClockLine;
    IN PVIDEO_WRITE_DATA_LINE   WriteDataLine;
    IN PVIDEO_READ_CLOCK_LINE   ReadClockLine;
    IN PVIDEO_READ_DATA_LINE    ReadDataLine;
    IN PVIDEO_WAIT_VSYNC_ACTIVE WaitVsync;
    PVOID                       Reserved;
} I2C_FNC_TABLE, *PI2C_FNC_TABLE;

typedef struct _I2C_CALLBACKS
{
    IN PVIDEO_WRITE_CLOCK_LINE WriteClockLine;
    IN PVIDEO_WRITE_DATA_LINE  WriteDataLine;
    IN PVIDEO_READ_CLOCK_LINE  ReadClockLine;
    IN PVIDEO_READ_DATA_LINE   ReadDataLine;
} I2C_CALLBACKS, *PI2C_CALLBACKS;

typedef struct _DDC_CONTROL
{
    IN ULONG         Size;
    IN I2C_CALLBACKS I2CCallbacks;
    IN UCHAR         EdidSegment;
} DDC_CONTROL, *PDDC_CONTROL;

typedef struct _VIDEO_I2C_CONTROL
{
    IN PVIDEO_WRITE_CLOCK_LINE WriteClockLine;
    IN PVIDEO_WRITE_DATA_LINE  WriteDataLine;
    IN PVIDEO_READ_CLOCK_LINE  ReadClockLine;
    IN PVIDEO_READ_DATA_LINE   ReadDataLine;
    IN ULONG                   I2CDelay;        // 100ns units
} VIDEO_I2C_CONTROL, *PVIDEO_I2C_CONTROL;

//
// Types of services exported by the VideoPortQueryServices().
//

typedef enum
{
    VideoPortServicesAGP = 1,
    VideoPortServicesI2C,
    VideoPortServicesHeadless,
    VideoPortServicesInt10,
    VideoPortServicesDebugReport,
    VideoPortServicesWCMemoryProtection
} VIDEO_PORT_SERVICES;

//
// AGP services interface.
//

#define VIDEO_PORT_AGP_INTERFACE_VERSION_1      1

typedef struct _VIDEO_PORT_AGP_INTERFACE
{
    IN USHORT                  Size;
    IN USHORT                  Version;
    OUT PVOID                  Context;
    OUT PINTERFACE_REFERENCE   InterfaceReference;
    OUT PINTERFACE_DEREFERENCE InterfaceDereference;
    OUT PAGP_RESERVE_PHYSICAL  AgpReservePhysical;
    OUT PAGP_RELEASE_PHYSICAL  AgpReleasePhysical;
    OUT PAGP_COMMIT_PHYSICAL   AgpCommitPhysical;
    OUT PAGP_FREE_PHYSICAL     AgpFreePhysical;
    OUT PAGP_RESERVE_VIRTUAL   AgpReserveVirtual;
    OUT PAGP_RELEASE_VIRTUAL   AgpReleaseVirtual;
    OUT PAGP_COMMIT_VIRTUAL    AgpCommitVirtual;
    OUT PAGP_FREE_VIRTUAL      AgpFreeVirtual;
    OUT ULONGLONG              AgpAllocationLimit;
} VIDEO_PORT_AGP_INTERFACE, *PVIDEO_PORT_AGP_INTERFACE;

#define VIDEO_PORT_AGP_INTERFACE_VERSION_2      2

typedef struct _VIDEO_PORT_AGP_INTERFACE_2
{
    IN USHORT                  Size;
    IN USHORT                  Version;
    OUT PVOID                  Context;
    OUT PINTERFACE_REFERENCE   InterfaceReference;
    OUT PINTERFACE_DEREFERENCE InterfaceDereference;
    OUT PAGP_RESERVE_PHYSICAL  AgpReservePhysical;
    OUT PAGP_RELEASE_PHYSICAL  AgpReleasePhysical;
    OUT PAGP_COMMIT_PHYSICAL   AgpCommitPhysical;
    OUT PAGP_FREE_PHYSICAL     AgpFreePhysical;
    OUT PAGP_RESERVE_VIRTUAL   AgpReserveVirtual;
    OUT PAGP_RELEASE_VIRTUAL   AgpReleaseVirtual;
    OUT PAGP_COMMIT_VIRTUAL    AgpCommitVirtual;
    OUT PAGP_FREE_VIRTUAL      AgpFreeVirtual;
    OUT ULONGLONG              AgpAllocationLimit;
    OUT PAGP_SET_RATE          AgpSetRate;
} VIDEO_PORT_AGP_INTERFACE_2, *PVIDEO_PORT_AGP_INTERFACE_2;

//
// I2C helper routines exported via VideoPortQueryServices().
//

typedef
BOOLEAN
(*PI2C_START)(
    IN PVOID HwDeviceExtension,
    IN PI2C_CALLBACKS I2CCallbacks
    );

typedef
BOOLEAN
(*PI2C_STOP)(
    IN PVOID HwDeviceExtension,
    IN PI2C_CALLBACKS I2CCallbacks
    );

typedef
BOOLEAN
(*PI2C_WRITE)(
    IN PVOID HwDeviceExtension,
    IN PI2C_CALLBACKS I2CCallbacks,
    IN PUCHAR Buffer,
    IN ULONG Length
    );

typedef
BOOLEAN
(*PI2C_READ)(
    IN PVOID HwDeviceExtension,
    IN PI2C_CALLBACKS I2CCallbacks,
    OUT PUCHAR Buffer,
    IN ULONG Length
    );

//
// I2C services interface.
//

#define VIDEO_PORT_I2C_INTERFACE_VERSION_1      1

typedef struct _VIDEO_PORT_I2C_INTERFACE
{
    IN USHORT                  Size;
    IN USHORT                  Version;
    OUT PVOID                  Context;
    OUT PINTERFACE_REFERENCE   InterfaceReference;
    OUT PINTERFACE_DEREFERENCE InterfaceDereference;
    OUT PI2C_START             I2CStart;
    OUT PI2C_STOP              I2CStop;
    OUT PI2C_WRITE             I2CWrite;
    OUT PI2C_READ              I2CRead;
} VIDEO_PORT_I2C_INTERFACE, *PVIDEO_PORT_I2C_INTERFACE;

//
// I2C helper routines exported via VideoPortQueryServices()
// for I2C interface version 2.
//

typedef
BOOLEAN
(*PI2C_START_2)(
    IN PVOID HwDeviceExtension,
    IN PVIDEO_I2C_CONTROL I2CControl
    );

typedef
BOOLEAN
(*PI2C_STOP_2)(
    IN PVOID HwDeviceExtension,
    IN PVIDEO_I2C_CONTROL I2CControl
    );

typedef
BOOLEAN
(*PI2C_WRITE_2)(
    IN PVOID HwDeviceExtension,
    IN PVIDEO_I2C_CONTROL I2CControl,
    IN PUCHAR Buffer,
    IN ULONG Length
    );

typedef
BOOLEAN
(*PI2C_READ_2)(
    IN PVOID HwDeviceExtension,
    IN PVIDEO_I2C_CONTROL I2CControl,
    OUT PUCHAR Buffer,
    IN ULONG Length,
    IN BOOLEAN EndOfRead
    );

//
// I2C services interface version 2.
//

#define VIDEO_PORT_I2C_INTERFACE_VERSION_2      2

typedef struct _VIDEO_PORT_I2C_INTERFACE_2
{
    IN USHORT                  Size;
    IN USHORT                  Version;
    OUT PVOID                  Context;
    OUT PINTERFACE_REFERENCE   InterfaceReference;
    OUT PINTERFACE_DEREFERENCE InterfaceDereference;
    OUT PI2C_START_2           I2CStart;
    OUT PI2C_STOP_2            I2CStop;
    OUT PI2C_WRITE_2           I2CWrite;
    OUT PI2C_READ_2            I2CRead;
} VIDEO_PORT_I2C_INTERFACE_2, *PVIDEO_PORT_I2C_INTERFACE_2;

typedef
VP_STATUS
(*PINT10_ALLOCATE_BUFFER)(
    IN PVOID Context,
    OUT PUSHORT Seg,
    OUT PUSHORT Off,
    IN OUT PULONG Length
    );

typedef
VP_STATUS
(*PINT10_FREE_BUFFER)(
    IN PVOID Context,
    IN USHORT Seg,
    IN USHORT Off
    );

typedef
VP_STATUS
(*PINT10_READ_MEMORY)(
    IN PVOID Context,
    IN USHORT Seg,
    IN USHORT Off,
    OUT PVOID Buffer,
    IN ULONG Length
    );

typedef
VP_STATUS
(*PINT10_WRITE_MEMORY)(
    IN PVOID Context,
    IN USHORT Seg,
    IN USHORT Off,
    IN PVOID Buffer,
    IN ULONG Length
    );

typedef
VP_STATUS
(*PINT10_CALL_BIOS)(
    PVOID Context,
    PINT10_BIOS_ARGUMENTS BiosArguments
    );

#define VIDEO_PORT_INT10_INTERFACE_VERSION_1 1

typedef struct _VIDEO_PORT_INT10_INTERFACE
{
    IN USHORT                    Size;
    IN USHORT                    Version;
    OUT PVOID                    Context;
    OUT PINTERFACE_REFERENCE     InterfaceReference;
    OUT PINTERFACE_DEREFERENCE   InterfaceDereference;
    OUT PINT10_ALLOCATE_BUFFER   Int10AllocateBuffer;
    OUT PINT10_FREE_BUFFER       Int10FreeBuffer;
    OUT PINT10_READ_MEMORY       Int10ReadMemory;
    OUT PINT10_WRITE_MEMORY      Int10WriteMemory;
    OUT PINT10_CALL_BIOS         Int10CallBios;
} VIDEO_PORT_INT10_INTERFACE, *PVIDEO_PORT_INT10_INTERFACE;

//
// WCMemoryProtection services interface.
//

typedef
VP_STATUS
(*PROTECT_WC_MEMORY)(
    IN PVOID Context,
    IN PVOID HwDeviceExtension
    );

typedef
VP_STATUS
(*RESTORE_WC_MEMORY)(
    IN PVOID Context,
    IN PVOID HwDeviceExtension
    );

#define VIDEO_PORT_WCMEMORYPROTECTION_INTERFACE_VERSION_1      1

typedef struct _VIDEO_PORT_WCMEMORYPROTECTION_INTERFACE
{
    IN  USHORT                 Size;
    IN  USHORT                 Version;
    OUT PVOID                  Context;
    OUT PINTERFACE_REFERENCE   InterfaceReference;
    OUT PINTERFACE_DEREFERENCE InterfaceDereference;
    OUT PROTECT_WC_MEMORY      VideoPortProtectWCMemory;
    OUT RESTORE_WC_MEMORY      VideoPortRestoreWCMemory;
} VIDEO_PORT_WCMEMORYPROTECTION_INTERFACE, *PVIDEO_PORT_WCMEMORYPROTECTION_INTERFACE;


typedef struct _VPOSVERSIONINFO
{
    IN  ULONG  Size;
    OUT ULONG  MajorVersion;
    OUT ULONG  MinorVersion;
    OUT ULONG  BuildNumber;
    OUT USHORT ServicePackMajor;
    OUT USHORT ServicePackMinor;
} VPOSVERSIONINFO, *PVPOSVERSIONINFO;

//
// Flags that can be passed to VideoPortGetDeviceBase or VideoPortMapMemory.
//

#define VIDEO_MEMORY_SPACE_MEMORY    0x00  // Should not be set by display driver
#define VIDEO_MEMORY_SPACE_IO        0x01  // Should not be set by display driver
#define VIDEO_MEMORY_SPACE_USER_MODE 0x02  // Memory pointer for application use
#define VIDEO_MEMORY_SPACE_DENSE     0x04  // Mapped dense, linearly (ALPHA)
#define VIDEO_MEMORY_SPACE_P6CACHE   0x08  // P6 MTRR caching (kernel and user)

//
// Define status codes returned by HwGetVideoChildDescriptor()
// miniport enumaration routine.
//
// Note: For backword compatibility reasons these values match
// existing WINERROR codes.
//

//
// Call again (ACPI and non-ACPI devices will be enumerated).
//

#define VIDEO_ENUM_MORE_DEVICES     ERROR_CONTINUE

//
// Stop enumeration.
//

#define VIDEO_ENUM_NO_MORE_DEVICES  ERROR_NO_MORE_DEVICES

//
// Call again, device could not be enumerated.
//

#define VIDEO_ENUM_INVALID_DEVICE   ERROR_INVALID_NAME

//
// Define the bits in VgaStatus.
//

#define DEVICE_VGA_ENABLED          1

//
// Port driver routines called by miniport driver and callbacks.
//

VIDEOPORT_API
VP_STATUS
VideoPortAllocateBuffer(
    IN PVOID HwDeviceExtension,
    IN ULONG Size,
    OUT PVOID *Buffer
    );

VIDEOPORT_API
VOID
VideoPortAcquireDeviceLock(
    IN PVOID HwDeviceExtension
    );

VIDEOPORT_API
ULONG
VideoPortCompareMemory(
    PVOID Source1,
    PVOID Source2,
    SIZE_T Length
    );

VIDEOPORT_API
BOOLEAN
VideoPortDDCMonitorHelper(
    IN PVOID HwDeviceExtension,
    IN PVOID DDCControl,
    IN OUT __inout_bcount(EdidBufferSize) PUCHAR EdidBuffer,
    IN ULONG EdidBufferSize
    );

VIDEOPORT_API
VOID
VideoPortDebugPrint(
    VIDEO_DEBUG_LEVEL DebugPrintLevel,
    __in PSTR DebugMessage,
    ...
    );

VIDEOPORT_API
VP_STATUS
VideoPortDisableInterrupt(
    PVOID HwDeviceExtension
    );

VIDEOPORT_API
VP_STATUS
VideoPortEnableInterrupt(
    PVOID HwDeviceExtension
    );

VIDEOPORT_API
VP_STATUS
VideoPortEnumerateChildren(
    IN PVOID HwDeviceExtension,
    IN __reserved PVOID Reserved
    );

VIDEOPORT_API
VOID
VideoPortFreeDeviceBase(
    PVOID HwDeviceExtension,
    PVOID MappedAddress
    );

typedef
VP_STATUS
(*PMINIPORT_QUERY_DEVICE_ROUTINE)(
    PVOID HwDeviceExtension,
    PVOID Context,
    VIDEO_DEVICE_DATA_TYPE DeviceDataType,
    PVOID Identifier,
    ULONG IdentiferLength,
    PVOID ConfigurationData,
    ULONG ConfigurationDataLength,
    PVOID ComponentInformation,
    ULONG ComponentInformationLength
    );

VIDEOPORT_API
VP_STATUS
VideoPortGetAccessRanges(
    PVOID HwDeviceExtension,
    ULONG NumRequestedResources,
    __in_ecount_opt(NumRequestedResources) PIO_RESOURCE_DESCRIPTOR RequestedResources OPTIONAL,
    ULONG NumAccessRanges,
    __out_ecount(NumAccessRanges) PVIDEO_ACCESS_RANGE AccessRanges,
    PVOID VendorId,
    PVOID DeviceId,
    PULONG Slot
    );

VIDEOPORT_API
PVOID
VideoPortGetAssociatedDeviceExtension(
    IN PVOID DeviceObject
    );

VIDEOPORT_API
ULONG
VideoPortGetBusData(
    PVOID HwDeviceExtension,
    BUS_DATA_TYPE BusDataType,
    ULONG SlotNumber,
    __out_bcount(Length) PVOID Buffer,
    ULONG Offset,
    ULONG Length
    );

VIDEOPORT_API
UCHAR
VideoPortGetCurrentIrql();

VIDEOPORT_API
PVOID
VideoPortGetDeviceBase(
    PVOID HwDeviceExtension,
    PHYSICAL_ADDRESS IoAddress,
    ULONG NumberOfUchars,
    UCHAR InIoSpace
    );

VIDEOPORT_API
VP_STATUS
VideoPortGetDeviceData(
    PVOID HwDeviceExtension,
    VIDEO_DEVICE_DATA_TYPE DeviceDataType,
    PMINIPORT_QUERY_DEVICE_ROUTINE CallbackRoutine,
    PVOID Context
    );

typedef
VP_STATUS
(*PMINIPORT_GET_REGISTRY_ROUTINE)(
    PVOID HwDeviceExtension,
    PVOID Context,
    PWSTR ValueName,
    PVOID ValueData,
    ULONG ValueLength
    );

VIDEOPORT_API
VP_STATUS
VideoPortGetRegistryParameters(
    PVOID HwDeviceExtension,
    __in PWSTR ParameterName,
    UCHAR IsParameterFileName,
    PMINIPORT_GET_REGISTRY_ROUTINE GetRegistryRoutine,
    PVOID Context
    );

VIDEOPORT_API
__out_bcount_opt(Length) PVOID
VideoPortGetRomImage(
    IN PVOID HwDeviceExtension,
    IN __reserved PVOID Unused1,
    IN __reserved ULONG Unused2,
    IN ULONG Length
    );

VIDEOPORT_API
VP_STATUS
VideoPortGetVgaStatus(
    PVOID HwDeviceExtension,
    OUT PULONG VgaStatus
    );

VIDEOPORT_API
LONG
FASTCALL
VideoPortInterlockedDecrement(
    IN PLONG Addend
    );

VIDEOPORT_API
LONG
FASTCALL
VideoPortInterlockedIncrement(
    IN PLONG Addend
    );

VIDEOPORT_API
LONG
FASTCALL
VideoPortInterlockedExchange(
    IN OUT PLONG Target,
    IN LONG Value
    );

VIDEOPORT_API
ULONG
VideoPortInitialize(
    PVOID Argument1,
    PVOID Argument2,
    PVIDEO_HW_INITIALIZATION_DATA HwInitializationData,
    PVOID HwContext
    );

VIDEOPORT_API
VP_STATUS
VideoPortInt10(
    PVOID HwDeviceExtension,
    PVIDEO_X86_BIOS_ARGUMENTS BiosArguments
    );

VIDEOPORT_API
VOID
VideoPortLogError(
    PVOID HwDeviceExtension,
    PVIDEO_REQUEST_PACKET Vrp OPTIONAL,
    VP_STATUS ErrorCode,
    ULONG UniqueId
    );

VIDEOPORT_API
VP_STATUS
VideoPortMapBankedMemory(
    PVOID HwDeviceExtension,
    PHYSICAL_ADDRESS PhysicalAddress,
    PULONG Length,
    PULONG InIoSpace,
    PVOID *VirtualAddress,
    ULONG BankLength,
    UCHAR ReadWriteBank,
    PBANKED_SECTION_ROUTINE BankRoutine,
    PVOID Context
    );

VIDEOPORT_API
VP_STATUS
VideoPortMapMemory(
    PVOID HwDeviceExtension,
    PHYSICAL_ADDRESS PhysicalAddress,
    PULONG Length,
    PULONG InIoSpace,
    PVOID *VirtualAddress
    );

VIDEOPORT_API
VOID
VideoPortMoveMemory(
    __inout_bcount(Length) PVOID Destination,
    __inout_bcount(Length) PVOID Source,
    ULONG Length
    );

VIDEOPORT_API
LONGLONG
VideoPortQueryPerformanceCounter(
    IN PVOID HwDeviceExtension,
    OUT PLONGLONG PerformanceFrequency OPTIONAL
    );

VIDEOPORT_API
VP_STATUS
VideoPortQueryServices(
    IN PVOID HwDeviceExtension,
    IN VIDEO_PORT_SERVICES ServicesType,
    IN OUT PINTERFACE Interface
    );

typedef
VOID
(*PMINIPORT_DPC_ROUTINE)(
    IN PVOID HwDeviceExtension,
    IN PVOID Context
    );

VIDEOPORT_API
BOOLEAN
VideoPortQueueDpc(
    IN PVOID HwDeviceExtension,
    IN PMINIPORT_DPC_ROUTINE CallbackRoutine,
    IN PVOID Context
    );

VIDEOPORT_API
UCHAR
VideoPortReadPortUchar(
    PUCHAR Port
    );

VIDEOPORT_API
USHORT
VideoPortReadPortUshort(
    PUSHORT Port
    );

VIDEOPORT_API
ULONG
VideoPortReadPortUlong(
    PULONG Port
    );

VIDEOPORT_API
VOID
VideoPortReadPortBufferUchar(
    PUCHAR Port,
    __out_ecount(Count) PUCHAR Buffer,
    ULONG Count
    );

VIDEOPORT_API
VOID
VideoPortReadPortBufferUshort(
    PUSHORT Port,
    __out_ecount(Count) PUSHORT Buffer,
    ULONG Count
    );

VIDEOPORT_API
VOID
VideoPortReadPortBufferUlong(
    PULONG Port,
    __out_ecount(Count) PULONG Buffer,
    ULONG Count
    );

VIDEOPORT_API
UCHAR
VideoPortReadRegisterUchar(
    PUCHAR Register
    );

VIDEOPORT_API
USHORT
VideoPortReadRegisterUshort(
    PUSHORT Register
    );

VIDEOPORT_API
ULONG
VideoPortReadRegisterUlong(
    PULONG Register
    );

VIDEOPORT_API
VOID
VideoPortReadRegisterBufferUchar(
    PUCHAR Register,
    __out_ecount(Count) PUCHAR Buffer,
    ULONG Count
    );

VIDEOPORT_API
VOID
VideoPortReadRegisterBufferUshort(
    PUSHORT Register,
    __out_ecount(Count) PUSHORT Buffer,
    ULONG Count
    );

VIDEOPORT_API
VOID
VideoPortReadRegisterBufferUlong(
    PULONG Register,
    __out_ecount(Count) PULONG Buffer,
    ULONG Count
    );

VIDEOPORT_API
VOID
VideoPortReleaseBuffer(
  IN PVOID HwDeviceExtension,
  IN PVOID Buffer
  );

VIDEOPORT_API
VOID
VideoPortReleaseDeviceLock(
    IN PVOID HwDeviceExtension
    );

VIDEOPORT_API
BOOLEAN
VideoPortScanRom(
    PVOID HwDeviceExtension,
    PUCHAR RomBase,
    ULONG RomLength,
    PUCHAR String
    );

VIDEOPORT_API
ULONG
VideoPortSetBusData(
    PVOID HwDeviceExtension,
    BUS_DATA_TYPE BusDataType,
    ULONG SlotNumber,
    __in_bcount(Length) PVOID Buffer,
    ULONG Offset,
    ULONG Length
    );

VIDEOPORT_API
VP_STATUS
VideoPortSetRegistryParameters(
    PVOID HwDeviceExtension,
    __in PWSTR ValueName,
    __in_bcount(ValueLength) PVOID ValueData,
    ULONG ValueLength
    );

VIDEOPORT_API
VP_STATUS
VideoPortSetTrappedEmulatorPorts(
    PVOID HwDeviceExtension,
    ULONG NumAccessRanges,
    __in_ecount(NumAccessRanges) PVIDEO_ACCESS_RANGE AccessRange
    );

VIDEOPORT_API
VOID
VideoPortStallExecution(
    ULONG Microseconds
    );

VIDEOPORT_API
VOID
VideoPortStartTimer(
    PVOID HwDeviceExtension
    );

VIDEOPORT_API
VOID
VideoPortStopTimer(
    PVOID HwDeviceExtension
    );

typedef
BOOLEAN
(*PMINIPORT_SYNCHRONIZE_ROUTINE)(
    PVOID Context
    );

BOOLEAN
VIDEOPORT_API
VideoPortSynchronizeExecution(
    PVOID HwDeviceExtension,
    VIDEO_SYNCHRONIZE_PRIORITY Priority,
    PMINIPORT_SYNCHRONIZE_ROUTINE SynchronizeRoutine,
    PVOID Context
    );

VIDEOPORT_API
VP_STATUS
VideoPortUnmapMemory(
    PVOID HwDeviceExtension,
    PVOID VirtualAddress,
    HANDLE ProcessHandle
    );

VIDEOPORT_API
VP_STATUS
VideoPortVerifyAccessRanges(
    PVOID HwDeviceExtension,
    ULONG NumAccessRanges,
    __in_ecount_opt(NumAccessRanges) PVIDEO_ACCESS_RANGE AccessRanges
    );

VIDEOPORT_API
VOID
VideoPortWritePortUchar(
    PUCHAR Port,
    UCHAR Value
    );

VIDEOPORT_API
VOID
VideoPortWritePortUshort(
    PUSHORT Port,
    USHORT Value
    );

VIDEOPORT_API
VOID
VideoPortWritePortUlong(
    PULONG Port,
    ULONG Value
    );

VIDEOPORT_API
VOID
VideoPortWritePortBufferUchar(
    PUCHAR Port,
    __in_ecount(Count) PUCHAR Buffer,
    ULONG Count
    );

VIDEOPORT_API
VOID
VideoPortWritePortBufferUshort(
    PUSHORT Port,
    __in_ecount(Count) PUSHORT Buffer,
    ULONG Count
    );

VIDEOPORT_API
VOID
VideoPortWritePortBufferUlong(
    PULONG Port,
    __in_ecount(Count) PULONG Buffer,
    ULONG Count
    );

VIDEOPORT_API
VOID
VideoPortWriteRegisterUchar(
    PUCHAR Register,
    UCHAR Value
    );

VIDEOPORT_API
VOID
VideoPortWriteRegisterUshort(
    PUSHORT Register,
    USHORT Value
    );

VIDEOPORT_API
VOID
VideoPortWriteRegisterUlong(
    PULONG Register,
    ULONG Value
    );

VIDEOPORT_API
VOID
VideoPortWriteRegisterBufferUchar(
    PUCHAR Register,
    __in_ecount(Count) PUCHAR Buffer,
    ULONG Count
    );

VIDEOPORT_API
VOID
VideoPortWriteRegisterBufferUshort(
    PUSHORT Register,
    __in_ecount(Count) PUSHORT Buffer,
    ULONG Count
    );

VIDEOPORT_API
VOID
VideoPortWriteRegisterBufferUlong(
    PULONG Register,
    __in_ecount(Count) PULONG Buffer,
    ULONG Count
    );

VIDEOPORT_API
VOID
VideoPortZeroDeviceMemory(
    PVOID Destination,
    ULONG Length
    );

VIDEOPORT_API
VOID
VideoPortZeroMemory(
    __out_bcount(Length) PVOID Destination,
    ULONG Length
    );

//
// DMA support.
// TODO: Move to the separate module -- will be obsolete.
//

VIDEOPORT_API
PVOID
VideoPortAllocateContiguousMemory(
    IN  PVOID            HwDeviceExtension,
    IN  ULONG            NumberOfBytes,
    IN  PHYSICAL_ADDRESS HighestAcceptableAddress
    );

VIDEOPORT_API
PVOID
VideoPortGetCommonBuffer(
    IN  PVOID              HwDeviceExtension,
    IN  ULONG              DesiredLength,
    IN  ULONG              Alignment,
    OUT PPHYSICAL_ADDRESS  LogicalAddress,
    OUT PULONG             pActualLength,
    IN  BOOLEAN            CacheEnabled
    );

VIDEOPORT_API
VOID
VideoPortFreeCommonBuffer(
    IN  PVOID            HwDeviceExtension,
    IN  ULONG            Length,
    IN  PVOID            VirtualAddress,
    IN  PHYSICAL_ADDRESS LogicalAddress,
    IN  BOOLEAN          CacheEnabled
    );

VIDEOPORT_API
PDMA
VideoPortDoDma(
    IN PVOID      HwDeviceExtension,
    IN PDMA       pDma,
    IN DMA_FLAGS  DmaFlags
    );

VIDEOPORT_API
BOOLEAN
VideoPortLockPages(
    IN      PVOID                   HwDeviceExtension,
    IN OUT  PVIDEO_REQUEST_PACKET   pVrp,
    IN      PEVENT                  pUEvent,
    IN      PEVENT                  pDisplayEvent,
    IN      DMA_FLAGS               DmaFlags
    );

VIDEOPORT_API
BOOLEAN
VideoPortUnlockPages(
    PVOID   hwDeviceExtension,
    PDMA    pDma
    );

VIDEOPORT_API
BOOLEAN
VideoPortSignalDmaComplete(
    IN  PVOID HwDeviceExtension,
    IN  PDMA  pDmaHandle
    );

VIDEOPORT_API
PVOID
VideoPortGetMdl(
    IN  PVOID   HwDeviceExtension,
    IN  PDMA    pDma
    );

VIDEOPORT_API
PVOID
VideoPortGetDmaContext(
    IN  PVOID HwDeviceExtension,
    IN  PDMA  pDma
    );

VIDEOPORT_API
VOID
VideoPortSetDmaContext(
    IN  PVOID   HwDeviceExtension,
    OUT PDMA    pDma,
    IN  PVOID   InstanceContext
    );

VIDEOPORT_API
ULONG
VideoPortGetBytesUsed(
    IN  PVOID   HwDeviceExtension,
    IN  PDMA    pDma
    );

VIDEOPORT_API
VOID
VideoPortSetBytesUsed(
    IN      PVOID   HwDeviceExtension,
    IN OUT  PDMA    pDma,
    IN      ULONG   BytesUsed
    );

VIDEOPORT_API
PDMA
VideoPortAssociateEventsWithDmaHandle(
    IN      PVOID                 HwDeviceExtension,
    IN OUT  PVIDEO_REQUEST_PACKET pVrp,
    IN      PVOID                 MappedUserEvent,
    IN      PVOID                 DisplayDriverEvent
    );

VIDEOPORT_API
PDMA
VideoPortMapDmaMemory(
    IN      PVOID                   HwDeviceExtension,
    IN      PVIDEO_REQUEST_PACKET   pVrp,
    IN      PHYSICAL_ADDRESS        BoardAddress,
    IN      PULONG                  Length,
    IN      PULONG                  InIoSpace,
    IN      PVOID                   MappedUserEvent,
    IN      PVOID                   DisplayDriverEvent,
    IN OUT  PVOID                 * VirtualAddress
    );

VIDEOPORT_API
BOOLEAN
VideoPortUnmapDmaMemory(
    PVOID               HwDeviceExtension,
    PVOID               VirtualAddress,
    HANDLE              ProcessHandle,
    PDMA                BoardMemoryHandle
    );

VIDEOPORT_API
VP_STATUS
VideoPortCreateSecondaryDisplay(
    IN PVOID HwDeviceExtension,
    IN OUT PVOID *SecondaryDeviceExtension,
    IN ULONG ulFlag
    );

VIDEOPORT_API
PVP_DMA_ADAPTER
VideoPortGetDmaAdapter(
    IN PVOID                   HwDeviceExtension,
    IN PVP_DEVICE_DESCRIPTION  VpDeviceDescription
    );

VIDEOPORT_API
VOID
VideoPortPutDmaAdapter(
    IN PVOID           HwDeviceExtension,
    IN PVP_DMA_ADAPTER VpDmaAdapter
    );

VIDEOPORT_API
PVOID
VideoPortAllocateCommonBuffer(
    IN  PVOID             HwDeviceExtension,
    IN  PVP_DMA_ADAPTER   VpDmaAdapter,
    IN  ULONG             DesiredLength,
    OUT PPHYSICAL_ADDRESS LogicalAddress,
    IN  BOOLEAN           CacheEnabled,
    OUT PVOID             Reserved
    );

VIDEOPORT_API
VOID
VideoPortReleaseCommonBuffer(
    IN  PVOID             HwDeviceExtension,
    IN  PVP_DMA_ADAPTER   VpDmaAdapter,
    IN  ULONG             Length,
    IN  PHYSICAL_ADDRESS  LogicalAddress,
    IN  PVOID             VirtualAddress,
    IN  BOOLEAN           CacheEnabled
    );

VIDEOPORT_API
PVOID
VideoPortLockBuffer(
    IN PVOID              HwDeviceExtension,
    IN PVOID              BaseAddress,
    IN ULONG              Length,
    IN VP_LOCK_OPERATION  Operation
    );

VIDEOPORT_API
VOID
VideoPortUnlockBuffer(
    IN PVOID   HwDeviceExtension,
    IN PVOID   Mdl
    );

VIDEOPORT_API
VP_STATUS
VideoPortStartDma(
    IN PVOID HwDeviceExtension,
    IN PVP_DMA_ADAPTER VpDmaAdapter,
    IN PVOID Mdl,
    IN ULONG Offset,
    IN OUT PULONG pLength,
    IN PEXECUTE_DMA ExecuteDmaRoutine,
    IN PVOID Context,
    IN BOOLEAN WriteToDevice
    );

VIDEOPORT_API
VP_STATUS
VideoPortCompleteDma(
    IN PVOID HwDeviceExtension,
    IN PVP_DMA_ADAPTER VpDmaAdapter,
    IN PVP_SCATTER_GATHER_LIST VpScatterGather,
    IN BOOLEAN WriteToDevice
    );

VIDEOPORT_API
VP_STATUS
VideoPortCreateEvent(
    IN PVOID HwDeviceExtension,
    IN ULONG EventFlag,
    IN PVOID Unused,
    OUT PEVENT *ppEvent
    );

VIDEOPORT_API
VP_STATUS
VideoPortDeleteEvent(
    IN PVOID HwDeviceExtension,
    IN PEVENT pEvent
    );

VIDEOPORT_API
LONG
VideoPortSetEvent(
    IN PVOID HwDeviceExtension,
    IN PEVENT pEvent
    );

VIDEOPORT_API
VOID
VideoPortClearEvent(
    IN PVOID HwDeviceExtension,
    IN PEVENT pEvent
);

VIDEOPORT_API
LONG
VideoPortReadStateEvent(
    IN PVOID HwDeviceExtension,
    IN PEVENT pEvent
    );

VIDEOPORT_API
VP_STATUS
VideoPortWaitForSingleObject(
    IN PVOID HwDeviceExtension,
    IN PVOID Object,
    IN PLARGE_INTEGER Timeout
    );

VIDEOPORT_API
PVOID
VideoPortAllocatePool(
    IN PVOID HwDeviceExtension,
    IN VP_POOL_TYPE PoolType,
    IN SIZE_T NumberOfBytes,
    IN ULONG Tag
    );

VIDEOPORT_API
VOID
VideoPortFreePool(
    IN PVOID HwDeviceExtension,
    IN PVOID Ptr
    );

VIDEOPORT_API
VP_STATUS
VideoPortCreateSpinLock(
    IN PVOID HwDeviceExtension,
    OUT PSPIN_LOCK *SpinLock
    );

VIDEOPORT_API
VP_STATUS
VideoPortDeleteSpinLock(
    IN PVOID HwDeviceExtension,
    IN PSPIN_LOCK SpinLock
    );

VIDEOPORT_API
VOID
VideoPortAcquireSpinLock(
    IN PVOID HwDeviceExtension,
    IN PSPIN_LOCK SpinLock,
    OUT PUCHAR OldIrql
    );

VIDEOPORT_API
VOID
VideoPortAcquireSpinLockAtDpcLevel(
    IN PVOID HwDeviceExtension,
    IN PSPIN_LOCK SpinLock
    );

VIDEOPORT_API
VOID
VideoPortReleaseSpinLock(
    IN PVOID HwDeviceExtension,
    IN PSPIN_LOCK SpinLock,
    IN UCHAR NewIrql
    );

VIDEOPORT_API
VOID
VideoPortReleaseSpinLockFromDpcLevel(
    IN PVOID HwDeviceExtension,
    IN PSPIN_LOCK SpinLock
    );

VIDEOPORT_API
VOID
VideoPortQuerySystemTime(
    OUT PLARGE_INTEGER CurrentTime
    );

#define CDE_USE_SUBSYSTEM_IDS   0x00000001
#define CDE_USE_REVISION        0x00000002

VIDEOPORT_API
BOOLEAN
VideoPortCheckForDeviceExistence(
    IN PVOID HwDeviceExtension,
    IN USHORT VendorId,
    IN USHORT DeviceId,
    IN UCHAR RevisionId,
    IN USHORT SubVendorId,
    IN USHORT SubSystemId,
    IN ULONG Flags
    );

VIDEOPORT_API
ULONG
VideoPortGetAssociatedDeviceID(
    IN PVOID DeviceObject
    );

VIDEOPORT_API
VP_STATUS
VideoPortFlushRegistry(
    PVOID HwDeviceExtension
    );

VIDEOPORT_API
VP_STATUS
VideoPortGetVersion(
    IN PVOID HwDeviceExtension,
    IN OUT PVPOSVERSIONINFO pVpOsVersionInfo
    );

VIDEOPORT_API
BOOLEAN
VideoPortIsNoVesa(
    VOID
    );

//
// TODO: End of move block.
//

//
// Support for bugcheck reason callbacks
//

#define BUGCHECK_DATA_SIZE_RESERVED 48

typedef
VOID
(*PVIDEO_BUGCHECK_CALLBACK) (
    IN PVOID HwDeviceExtension,
    IN ULONG BugcheckCode,
    IN PUCHAR Buffer,
    IN ULONG BufferSize
    );

VIDEOPORT_API
VP_STATUS
VideoPortRegisterBugcheckCallback(
    IN PVOID HwDeviceExtension,
    IN ULONG BugcheckCode,
    IN PVIDEO_BUGCHECK_CALLBACK Callback,
    IN ULONG BugcheckDataSize
    );

//
// Video Debug Report API provides ability for IHV to report non fatal
// failures via Microsoft OCA servers
//

#define VIDEO_DEBUG_REPORT_MAX_SIZE 0x8000

typedef struct _VIDEO_DEBUG_REPORT *PVIDEO_DEBUG_REPORT;

VIDEOPORT_API
PVIDEO_DEBUG_REPORT
VideoPortDbgReportCreate(
    IN PVOID HwDeviceExtension,
    IN ULONG ulCode,
    IN ULONG_PTR ulpArg1,
    IN ULONG_PTR ulpArg2,
    IN ULONG_PTR ulpArg3,
    IN ULONG_PTR ulpArg4
    );

VIDEOPORT_API
BOOLEAN
VideoPortDbgReportSecondaryData(
    IN OUT PVIDEO_DEBUG_REPORT pReport,
    IN __in_bcount(ulDataSize) PVOID pvData,
    IN ULONG ulDataSize
    );

VIDEOPORT_API
VOID
VideoPortDbgReportComplete(
    IN OUT PVIDEO_DEBUG_REPORT pReport
    );

//
// Debug Report API interface
//

#define VIDEO_PORT_DEBUG_REPORT_INTERFACE_VERSION_1      1

typedef struct _VIDEO_PORT_DEBUG_REPORT_INTERFACE
{
    IN USHORT                  Size;
    IN USHORT                  Version;
    OUT PVOID                  Context;
    OUT PINTERFACE_REFERENCE   InterfaceReference;
    OUT PINTERFACE_DEREFERENCE InterfaceDereference;

    OUT
    PVIDEO_DEBUG_REPORT
    (*DbgReportCreate)(
        IN PVOID HwDeviceExtension,
        IN ULONG ulCode,
        IN ULONG_PTR ulpArg1,
        IN ULONG_PTR ulpArg2,
        IN ULONG_PTR ulpArg3,
        IN ULONG_PTR ulpArg4
        );

    OUT
    BOOLEAN
    (*DbgReportSecondaryData)(
        IN OUT PVIDEO_DEBUG_REPORT pReport,
        IN PVOID pvData,
        IN ULONG ulDataSize
        );

    OUT
    VOID
    (*DbgReportComplete)(
        IN OUT PVIDEO_DEBUG_REPORT pReport
        );
} VIDEO_PORT_DEBUG_REPORT_INTERFACE, *PVIDEO_PORT_DEBUG_REPORT_INTERFACE;

#ifdef __cplusplus
} // extern "C"
#endif

#endif // ifndef __VIDEO_H__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\win2k8\ddk\inc\usbscan.h ===
/*++

Copyright (C) 1997, Logitech Inc.

Module Name:
    UsbScan.h

Abstract:
    Interface with UsbScan kernel driver

Environment:
    User and kernel mode use

Notes:
    Interface definition for USB still image driver.

--*/

#if (NTDDI_VERSION >= NTDDI_WIN2K)

#ifndef _USBSCAN_H_
#define _USBSCAN_H_
#pragma pack(push,8)

#ifndef MAX_NUM_PIPES
 #define MAX_NUM_PIPES   8
#endif

#define BULKIN_FLAG 0x80

typedef struct _DRV_VERSION {
    OUT     unsigned    major;
    OUT     unsigned    minor;
    OUT     unsigned    internal;
} DRV_VERSION, *PDRV_VERSION;

typedef struct _IO_BLOCK {
    IN      unsigned    uOffset;
    IN      unsigned    uLength;
    IN OUT  PUCHAR      pbyData;
    IN      unsigned    uIndex;
} IO_BLOCK, *PIO_BLOCK;

typedef struct _IO_BLOCK_EX {
    IN      unsigned    uOffset;
    IN      unsigned    uLength;
    IN OUT  PUCHAR      pbyData;
    IN      unsigned    uIndex;

    //
    // Following two fields are described in sec. 9.3.1,2 USB specification
    //
    IN      UCHAR       bRequest;               // Specific request
    IN      UCHAR       bmRequestType;          // Bitmap - charateristics of request
    IN      UCHAR       fTransferDirectionIn;   // TRUE - Device-->Host; FALSE - Host-->Device

} IO_BLOCK_EX, *PIO_BLOCK_EX;


typedef struct _CHANNEL_INFO {
    OUT     unsigned    EventChannelSize;
    OUT     unsigned    uReadDataAlignment;
    OUT     unsigned    uWriteDataAlignment;
} CHANNEL_INFO, *PCHANNEL_INFO;

typedef enum {
    EVENT_PIPE,
    READ_DATA_PIPE,
    WRITE_DATA_PIPE,
    ALL_PIPE
} PIPE_TYPE;


typedef struct _USBSCAN_GET_DESCRIPTOR {
    IN      UCHAR   DescriptorType;             // high byte of wValue field in USB spec.
    IN      UCHAR   Index;                      // low byte of wValue field in USB spec.
    IN      USHORT  LanguageId;                 // wIndex field in USB spec.
} USBSCAN_GET_DESCRIPTOR, *PUSBSCAN_GET_DESCRIPTOR;


//
// The device descriptor structure reports information define in the hardware.
// If there is enough space to copy the strings, it will be done otherwise
// only the three first fields:
//
//   USHORT usVendorId;
//   USHORT usProductId;
//   USHORT usBcdDevice;
//
// will contain valid data.  Remember: The strings are UNICODE format.
//

typedef struct _DEVICE_DESCRIPTOR {
    OUT     USHORT   usVendorId;
    OUT     USHORT   usProductId;
    OUT     USHORT   usBcdDevice;
    OUT     USHORT   usLanguageId;
//    IN OUT  PWCHAR   pszManufacturer;
//    IN OUT  unsigned uManufacturerStrSize;
//    IN OUT  PWCHAR   pszProduct;
//    IN OUT  unsigned uProductStrSize;
//    IN OUT  PWCHAR   pszSerialNb;
//    IN OUT  unsigned uSerialNbStrSize;
} DEVICE_DESCRIPTOR, *PDEVICE_DESCRIPTOR;

typedef enum _RAW_PIPE_TYPE {
    USBSCAN_PIPE_CONTROL,
    USBSCAN_PIPE_ISOCHRONOUS,
    USBSCAN_PIPE_BULK,
    USBSCAN_PIPE_INTERRUPT
} RAW_PIPE_TYPE;

typedef struct _USBSCAN_PIPE_INFORMATION {
    USHORT          MaximumPacketSize;  // Maximum packet size for this pipe
    UCHAR           EndpointAddress;    // 8 bit USB endpoint address (includes direction)
    UCHAR           Interval;           // Polling interval in ms if interrupt pipe 
    RAW_PIPE_TYPE   PipeType;           // PipeType identifies type of transfer valid for this pipe
} USBSCAN_PIPE_INFORMATION, *PUSBSCAN_PIPE_INFORMATION;

typedef struct _USBSCAN_PIPE_CONFIGURATION {
    OUT     ULONG                          NumberOfPipes;
    OUT     USBSCAN_PIPE_INFORMATION       PipeInfo[MAX_NUM_PIPES];
} USBSCAN_PIPE_CONFIGURATION, *PUSBSCAN_PIPE_CONFIGURATION;

#if (NTDDI_VERSION >= NTDDI_WINXP)
typedef struct _USBSCAN_TIMEOUT {
    ULONG           TimeoutRead;
    ULONG           TimeoutWrite;
    ULONG           TimeoutEvent;
} USBSCAN_TIMEOUT, *PUSBSCAN_TIMEOUT;
#endif // (NTDDI_VERSION >= NTDDI_WINXP)

#define FILE_DEVICE_USB_SCAN    0x8000
#define IOCTL_INDEX             0x0800

#define IOCTL_GET_VERSION               CTL_CODE(FILE_DEVICE_USB_SCAN,IOCTL_INDEX,   METHOD_BUFFERED,FILE_ANY_ACCESS)
#define IOCTL_CANCEL_IO                 CTL_CODE(FILE_DEVICE_USB_SCAN,IOCTL_INDEX+1, METHOD_BUFFERED,FILE_ANY_ACCESS)
#define IOCTL_WAIT_ON_DEVICE_EVENT      CTL_CODE(FILE_DEVICE_USB_SCAN,IOCTL_INDEX+2, METHOD_BUFFERED,FILE_ANY_ACCESS)
#define IOCTL_READ_REGISTERS            CTL_CODE(FILE_DEVICE_USB_SCAN,IOCTL_INDEX+3, METHOD_BUFFERED,FILE_ANY_ACCESS)
#define IOCTL_WRITE_REGISTERS           CTL_CODE(FILE_DEVICE_USB_SCAN,IOCTL_INDEX+4, METHOD_BUFFERED,FILE_ANY_ACCESS)
#define IOCTL_GET_CHANNEL_ALIGN_RQST    CTL_CODE(FILE_DEVICE_USB_SCAN,IOCTL_INDEX+5, METHOD_BUFFERED,FILE_ANY_ACCESS)
#define IOCTL_GET_DEVICE_DESCRIPTOR     CTL_CODE(FILE_DEVICE_USB_SCAN,IOCTL_INDEX+6, METHOD_BUFFERED,FILE_ANY_ACCESS)
#define IOCTL_RESET_PIPE                CTL_CODE(FILE_DEVICE_USB_SCAN,IOCTL_INDEX+7, METHOD_BUFFERED,FILE_ANY_ACCESS)
#define IOCTL_GET_USB_DESCRIPTOR        CTL_CODE(FILE_DEVICE_USB_SCAN,IOCTL_INDEX+8, METHOD_BUFFERED,FILE_ANY_ACCESS)
#define IOCTL_SEND_USB_REQUEST          CTL_CODE(FILE_DEVICE_USB_SCAN,IOCTL_INDEX+9, METHOD_BUFFERED,FILE_ANY_ACCESS)
#define IOCTL_GET_PIPE_CONFIGURATION    CTL_CODE(FILE_DEVICE_USB_SCAN,IOCTL_INDEX+10,METHOD_BUFFERED,FILE_ANY_ACCESS)

#if (NTDDI_VERSION >= NTDDI_WINXP)
#define IOCTL_SET_TIMEOUT               CTL_CODE(FILE_DEVICE_USB_SCAN,IOCTL_INDEX+11,METHOD_BUFFERED,FILE_ANY_ACCESS)
#endif // (NTDDI_VERSION >= NTDDI_WINXP)

//
// Temporary to avoid breaking LOGISCAN code
//
#define ALL ALL_PIPE
#define IOCTL_ABORT_PIPE        IOCTL_CANCEL_IO
//
//
#pragma pack(pop)
#endif // _USBSCAN_H_

#endif // (NTDDI_VERSION >= NTDDI_WIN2K)
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\win2k8\ddk\inc\wdmguid.h ===
/*++

Copyright (c) Microsoft Corporation.  All rights reserved.

Module Name:

    wdmguid.h

Abstract:

    Defines GUIDs for function device classes and device events used in
    Plug & Play.

Revision History:

--*/

#ifndef FAR
#define FAR
#endif

//
// Device events that can be broadcasted to drivers and user-mode apps.
//

#if (NTDDI_VERSION >= NTDDI_WIN2K)
DEFINE_GUID( GUID_HWPROFILE_QUERY_CHANGE,          0xcb3a4001L, 0x46f0, 0x11d0, 0xb0, 0x8f, 0x00, 0x60, 0x97, 0x13, 0x05, 0x3f );
DEFINE_GUID( GUID_HWPROFILE_CHANGE_CANCELLED,      0xcb3a4002L, 0x46f0, 0x11d0, 0xb0, 0x8f, 0x00, 0x60, 0x97, 0x13, 0x05, 0x3f );
DEFINE_GUID( GUID_HWPROFILE_CHANGE_COMPLETE,       0xcb3a4003L, 0x46f0, 0x11d0, 0xb0, 0x8f, 0x00, 0x60, 0x97, 0x13, 0x05, 0x3f );
DEFINE_GUID( GUID_DEVICE_INTERFACE_ARRIVAL,        0xcb3a4004L, 0x46f0, 0x11d0, 0xb0, 0x8f, 0x00, 0x60, 0x97, 0x13, 0x05, 0x3f );
DEFINE_GUID( GUID_DEVICE_INTERFACE_REMOVAL,        0xcb3a4005L, 0x46f0, 0x11d0, 0xb0, 0x8f, 0x00, 0x60, 0x97, 0x13, 0x05, 0x3f );
DEFINE_GUID( GUID_TARGET_DEVICE_QUERY_REMOVE,      0xcb3a4006L, 0x46f0, 0x11d0, 0xb0, 0x8f, 0x00, 0x60, 0x97, 0x13, 0x05, 0x3f );
DEFINE_GUID( GUID_TARGET_DEVICE_REMOVE_CANCELLED,  0xcb3a4007L, 0x46f0, 0x11d0, 0xb0, 0x8f, 0x00, 0x60, 0x97, 0x13, 0x05, 0x3f );
DEFINE_GUID( GUID_TARGET_DEVICE_REMOVE_COMPLETE,   0xcb3a4008L, 0x46f0, 0x11d0, 0xb0, 0x8f, 0x00, 0x60, 0x97, 0x13, 0x05, 0x3f );
DEFINE_GUID( GUID_PNP_CUSTOM_NOTIFICATION,         0xACA73F8EL, 0x8D23, 0x11D1, 0xAC, 0x7D, 0x00, 0x00, 0xF8, 0x75, 0x71, 0xD0 );
DEFINE_GUID( GUID_PNP_POWER_NOTIFICATION,          0xC2CF0660L, 0xEB7A, 0x11D1, 0xBD, 0x7F, 0x00, 0x00, 0xF8, 0x75, 0x71, 0xD0 );
#endif

#if (NTDDI_VERSION >= NTDDI_VISTA)
DEFINE_GUID( GUID_PNP_POWER_SETTING_CHANGE,        0x29C69B3EL, 0xC79A, 0x43BF, 0xBB, 0xDE, 0xA9, 0x32, 0xFA, 0x1B, 0xEA, 0x7E );
#endif

//
// Interface GUIDs used for IRP_MN_QUERY_INTERFACE
//

#if (NTDDI_VERSION >= NTDDI_WIN2K)
DEFINE_GUID( GUID_BUS_INTERFACE_STANDARD,               0x496B8280L, 0x6F25, 0x11D0, 0xBE, 0xAF, 0x08, 0x00, 0x2B, 0xE2, 0x09, 0x2F );
DEFINE_GUID( GUID_PCI_BUS_INTERFACE_STANDARD,           0x496B8281L, 0x6F25, 0x11D0, 0xBE, 0xAF, 0x08, 0x00, 0x2B, 0xE2, 0x09, 0x2F );
DEFINE_GUID( GUID_ARBITER_INTERFACE_STANDARD,           0xe644f185L, 0x8c0e, 0x11d0, 0xbe, 0xcf, 0x08, 0x00, 0x2b, 0xe2, 0x09, 0x2f );
DEFINE_GUID( GUID_TRANSLATOR_INTERFACE_STANDARD,        0x6c154a92L, 0xaacf, 0x11d0, 0x8d, 0x2a, 0x00, 0xa0, 0xc9, 0x06, 0xb2, 0x44 );
DEFINE_GUID( GUID_ACPI_INTERFACE_STANDARD,              0xb091a08aL, 0xba97, 0x11d0, 0xbd, 0x14, 0x00, 0xaa, 0x00, 0xb7, 0xb3, 0x2a );
DEFINE_GUID( GUID_INT_ROUTE_INTERFACE_STANDARD,         0x70941bf4L, 0x0073, 0x11d1, 0xa0, 0x9e, 0x00, 0xc0, 0x4f, 0xc3, 0x40, 0xb1 );
DEFINE_GUID( GUID_PCMCIA_BUS_INTERFACE_STANDARD,        0x76173af0L, 0xc504, 0x11d1, 0x94, 0x7f, 0x00, 0xc0, 0x4f, 0xb9, 0x60, 0xee );
DEFINE_GUID( GUID_ACPI_REGS_INTERFACE_STANDARD,         0x06141966L, 0x7245, 0x6369, 0x46, 0x2e, 0x4e, 0x65, 0x6c, 0x73, 0x6f, 0x6e );
DEFINE_GUID( GUID_LEGACY_DEVICE_DETECTION_STANDARD,     0x50feb0deL, 0x596a, 0x11d2, 0xa5, 0xb8, 0x00, 0x00, 0xf8, 0x1a, 0x46, 0x19 );
DEFINE_GUID( GUID_PCI_DEVICE_PRESENT_INTERFACE,         0xd1b82c26L, 0xbf49, 0x45ef, 0xb2, 0x16, 0x71, 0xcb, 0xd7, 0x88, 0x9b, 0x57 );
DEFINE_GUID( GUID_MF_ENUMERATION_INTERFACE,             0xaeb895f0L, 0x5586, 0x11d1, 0x8d, 0x84, 0x00, 0xa0, 0xc9, 0x06, 0xb2, 0x44 );
DEFINE_GUID( GUID_REENUMERATE_SELF_INTERFACE_STANDARD,  0x2aeb0243,  0x6a6e, 0x486b, 0x82, 0xfc, 0xd8, 0x15, 0xf6, 0xb9, 0x70, 0x06 );
#endif

#if (NTDDI_VERSION >= NTDDI_WINXP)
DEFINE_GUID( GUID_AGP_TARGET_BUS_INTERFACE_STANDARD, 0xB15CFCE8L, 0x06D1, 0x4D37, 0x9D, 0x4C, 0xBE, 0xDD, 0xE0, 0xC2, 0xA6, 0xFF );
DEFINE_GUID( GUID_ACPI_CMOS_INTERFACE_STANDARD,    0x3a8d0384L, 0x6505, 0x40ca, 0xbc, 0x39, 0x56, 0xc1, 0x5f, 0x8c, 0x5f, 0xed );
DEFINE_GUID( GUID_ACPI_PORT_RANGES_INTERFACE_STANDARD, 0xf14f609bL, 0xcbbd, 0x4957, 0xa6, 0x74, 0xbc, 0x0, 0x21, 0x3f, 0x1c, 0x97 );
#endif

#if (NTDDI_VERSION >= NTDDI_VISTA)
DEFINE_GUID( GUID_ACPI_INTERFACE_STANDARD2,        0xe8695f63L, 0x1831, 0x4870, 0xa8, 0xcf, 0x9c, 0x2f, 0x03, 0xf9, 0xdc, 0xb5 );
DEFINE_GUID( GUID_PNP_LOCATION_INTERFACE,          0x70211b0e,  0x0afb, 0x47db, 0xaf, 0xc1, 0x41, 0x0b, 0xf8, 0x42, 0x49, 0x7a );
DEFINE_GUID( GUID_PCI_EXPRESS_LINK_QUIESCENT_INTERFACE, 0x146cd41cL, 0xdae3, 0x4437, 0x8a, 0xff, 0x2a, 0xf3, 0xf0, 0x38, 0x09, 0x9b );
DEFINE_GUID( GUID_PCI_EXPRESS_ROOT_PORT_INTERFACE,      0x83a7734aL, 0x84c7, 0x4161, 0x9a, 0x98, 0x60, 0x00, 0xed, 0x0c, 0x4a, 0x33 );
DEFINE_GUID( GUID_MSIX_TABLE_CONFIG_INTERFACE,     0x1a6a460b, 0x194f, 0x455d, 0xb3, 0x4b, 0xb8, 0x4c, 0x5b, 0x05, 0x71, 0x2b );
#endif

//
// Bus type GUIDs
//

#if (NTDDI_VERSION >= NTDDI_WIN2K)
DEFINE_GUID( GUID_BUS_TYPE_INTERNAL,               0x1530ea73L, 0x086b, 0x11d1, 0xa0, 0x9f, 0x00, 0xc0, 0x4f, 0xc3, 0x40, 0xb1 );
DEFINE_GUID( GUID_BUS_TYPE_PCMCIA,                 0x09343630L, 0xaf9f, 0x11d0, 0x92, 0xE9, 0x00, 0x00, 0xf8, 0x1e, 0x1b, 0x30 );
DEFINE_GUID( GUID_BUS_TYPE_PCI,                    0xc8ebdfb0L, 0xb510, 0x11d0, 0x80, 0xe5, 0x00, 0xa0, 0xc9, 0x25, 0x42, 0xe3 );
DEFINE_GUID( GUID_BUS_TYPE_ISAPNP,                 0xe676f854L, 0xd87d, 0x11d0, 0x92, 0xb2, 0x00, 0xa0, 0xc9, 0x05, 0x5f, 0xc5 );
DEFINE_GUID( GUID_BUS_TYPE_EISA,                   0xddc35509L, 0xf3fc, 0x11d0, 0xa5, 0x37, 0x00, 0x00, 0xf8, 0x75, 0x3e, 0xd1 );
DEFINE_GUID( GUID_BUS_TYPE_MCA,                    0x1c75997aL, 0xdc33, 0x11d0, 0x92, 0xb2, 0x00, 0xa0, 0xc9, 0x05, 0x5f, 0xc5 );
DEFINE_GUID( GUID_BUS_TYPE_SERENUM,                0x77114a87L, 0x8944, 0x11d1, 0xbd, 0x90, 0x00, 0xa0, 0xc9, 0x06, 0xbe, 0x2d );
DEFINE_GUID( GUID_BUS_TYPE_USB,                    0x9d7debbcL, 0xc85d, 0x11d1, 0x9e, 0xb4, 0x00, 0x60, 0x08, 0xc3, 0xa1, 0x9a );
#endif

#if (NTDDI_VERSION >= NTDDI_WINXP)
DEFINE_GUID( GUID_BUS_TYPE_LPTENUM,                0xc4ca1000L, 0x2ddc, 0x11d5, 0xa1, 0x7a, 0x00, 0xc0, 0x4f, 0x60, 0x52, 0x4d );
DEFINE_GUID( GUID_BUS_TYPE_USBPRINT,               0x441ee000L, 0x4342, 0x11d5, 0xa1, 0x84, 0x00, 0xc0, 0x4f, 0x60, 0x52, 0x4d );
DEFINE_GUID( GUID_BUS_TYPE_DOT4PRT,                0x441ee001L, 0x4342, 0x11d5, 0xa1, 0x84, 0x00, 0xc0, 0x4f, 0x60, 0x52, 0x4d );
DEFINE_GUID( GUID_BUS_TYPE_1394,                   0xf74e73ebL, 0x9ac5, 0x45eb, 0xbe, 0x4d, 0x77, 0x2c, 0xc7, 0x1d, 0xdf, 0xb3 );
DEFINE_GUID( GUID_BUS_TYPE_HID,                    0xeeaf37d0L, 0x1963, 0x47c4, 0xaa, 0x48, 0x72, 0x47, 0x6d, 0xb7, 0xcf, 0x49 );
DEFINE_GUID( GUID_BUS_TYPE_AVC,                    0xc06ff265L, 0xae09, 0x48f0, 0x81, 0x2c, 0x16, 0x75, 0x3d, 0x7c, 0xba, 0x83 );
DEFINE_GUID( GUID_BUS_TYPE_IRDA,                   0x7ae17dc1L, 0xc944, 0x44d6, 0x88, 0x1f, 0x4c, 0x2e, 0x61, 0x05, 0x3b, 0xc1 );
DEFINE_GUID( GUID_BUS_TYPE_SD,                     0xe700cc04L, 0x4036, 0x4e89, 0x95, 0x79, 0x89, 0xeb, 0xf4, 0x5f, 0x00, 0xcd );
#endif

//
// Power management WMI guids for device control
//

#if (NTDDI_VERSION >= NTDDI_WIN2K)
DEFINE_GUID( GUID_POWER_DEVICE_ENABLE,             0x827c0a6fL, 0xfeb0, 0x11d0, 0xbd, 0x26, 0x00, 0xaa, 0x00, 0xb7, 0xb3, 0x2a );
DEFINE_GUID( GUID_POWER_DEVICE_TIMEOUTS,           0xa45da735L, 0xfeb0, 0x11d0, 0xbd, 0x26, 0x00, 0xaa, 0x00, 0xb7, 0xb3, 0x2a );
DEFINE_GUID( GUID_POWER_DEVICE_WAKE_ENABLE,        0xa9546a82L, 0xfeb0, 0x11d0, 0xbd, 0x26, 0x00, 0xaa, 0x00, 0xb7, 0xb3, 0x2a );
#endif

//
// User-Mode Driver Framework device events for detecting driver host crashes.
//

#if (NTDDI_VERSION >= NTDDI_WINXP)
DEFINE_GUID( GUID_WUDF_DEVICE_HOST_PROBLEM,        0xc43d25bdL, 0x9346, 0x40ee, 0xa2, 0xd2, 0xd7, 0x0c, 0x15, 0xf8, 0xb7, 0x5b );
#endif

//
// Dynamic partitioning replace interface.
//

#if (NTDDI_VERSION >= NTDDI_VISTA)
DEFINE_GUID(GUID_PARTITION_UNIT_INTERFACE_STANDARD, 0x52363f5bL, 0xd891, 0x429b, 0x81, 0x95, 0xae, 0xc5, 0xfe, 0xf6, 0x85, 0x3c);
#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\win2k8\ddk\inc\wiaintfc.h ===
/*++

Copyright (c) 1986-2003  Microsoft Corporation

Module Name:

    wiaintfc.h

Abstract:

    This module contains interface class GUID for WIA.

Revision History:


--*/

#if (_WIN32_WINNT >= 0x0501) // Windows XP and later

#ifndef _WIAINTFC_H_
#define _WIAINTFC_H_

//
// Set packing
//

#include <pshpack8.h>
#include <guiddef.h>

//
// GUID for Image class device interface.
//

DEFINE_GUID(GUID_DEVINTERFACE_IMAGE, 0x6bdd1fc6L, 0x810f, 0x11d0, 0xbe, 0xc7, 0x08, 0x00, 0x2b, 0xe2, 0x09, 0x2f);

#endif // _WIAINTFC_H_

#endif //#if (_WIN32_WINNT >= 0x0501)
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\win2k8\ddk\inc\wiamdef.h ===
/******************************************************************************
*
*  (C) COPYRIGHT MICROSOFT CORP., 1998-1999
*
*  TITLE:       wiamdef.h
*
*  VERSION:     2.0
*
*  DATE:        28 July, 1999
*
*  DESCRIPTION:
*   Header file used to define WIA constants and globals.
*   Note: This header was introduced first in Windows XP
*
******************************************************************************/

#ifndef _WIAMDEF_H_
#define _WIAMDEF_H_

#if (NTDDI_VERSION >= NTDDI_WINXP)
#pragma once

#define STRSAFE_NO_DEPRECATE
#include <strsafe.h>

//
//  The following array of PROPIDs identifies properties that are ALWAYS
//  present in a WIA_PROPERTY_CONTEXT.  Drivers can specify additional
//  properties when creating a property context with wiasCreatePropContext.
//

#ifdef STD_PROPS_IN_CONTEXT

#define NUM_STD_PROPS_IN_CONTEXT 13
PROPID  WIA_StdPropsInContext[NUM_STD_PROPS_IN_CONTEXT] = {
    WIA_IPA_DATATYPE,
    WIA_IPA_DEPTH,
    WIA_IPS_XRES,
    WIA_IPS_XPOS,
    WIA_IPS_XEXTENT,
    WIA_IPA_PIXELS_PER_LINE,
    WIA_IPS_YRES,
    WIA_IPS_YPOS,
    WIA_IPS_YEXTENT,
    WIA_IPA_NUMBER_OF_LINES,
    WIA_IPS_CUR_INTENT,
    WIA_IPA_TYMED,
    WIA_IPA_FORMAT,
    };
#endif

#if (NTDDI_VERSION >= NTDDI_VISTA)
//
//  drvAcquireItemData flags
//
#define WIA_MINIDRV_TRANSFER_ACQUIRE_CHILDREN  0x00000001
#define WIA_MINIDRV_TRANSFER_DOWNLOAD          0x00000002
#define WIA_MINIDRV_TRANSFER_UPLOAD            0x00000004
#endif //#if (NTDDI_VERSION >= NTDDI_VISTA)

//**************************************************************************
//
//  WIA Service prototypes
//
//
// History:
//
//    4/27/1999 - Initial Version
//
//**************************************************************************

// Flag used by wiasGetImageInformation.

#define WIAS_INIT_CONTEXT 1

// Flag used by wiasDownSampleBuffer

#define WIAS_GET_DOWNSAMPLED_SIZE_ONLY 0x1

//
// IWiaMiniDrvService methods
//

#ifdef __cplusplus
extern "C" {
#endif

HRESULT _stdcall wiasCreateDrvItem(LONG lObjectFlags, BSTR bstrItemName, BSTR bstrFullItemName, 
   __inout IWiaMiniDrv *pIMiniDrv, LONG cbDevSpecContext, 
   __deref_out_bcount(cbDevSpecContext) BYTE **ppDevSpecContext, __out IWiaDrvItem **ppIWiaDrvItem);

HRESULT _stdcall wiasReadMultiple(__in BYTE *pWiasContext, ULONG ulCount, 
   __in_ecount(ulCount) const PROPSPEC *ps, __out_ecount(ulCount) PROPVARIANT *pv, 
   __out_ecount(ulCount) PROPVARIANT *pvOld);

HRESULT _stdcall wiasWriteMultiple(__in BYTE *pWiasContext, ULONG ulCount, 
   __in_ecount(ulCount) const PROPSPEC *ps, const PROPVARIANT *pv);

HRESULT _stdcall wiasWritePropBin(__in BYTE *pWiasContext, PROPID propid, LONG cbVal, 
   __in_bcount(cbVal) BYTE *pbVal);

HRESULT _stdcall wiasGetPropertyAttributes(__in BYTE *pWiasContext, LONG cPropSpec, 
   __in_ecount(cPropSpec) PROPSPEC *pPropSpec, ULONG *pulAccessFlags, 
   __out_ecount(cPropSpec) PROPVARIANT *pPropVar);

HRESULT _stdcall wiasSetPropertyAttributes(__in BYTE *pWiasContext, LONG cPropSpec, 
   __in_ecount(cPropSpec) PROPSPEC *pPropSpec, __in ULONG *pulAccessFlags, 
   __out_ecount(cPropSpec) PROPVARIANT  *pPropVar);

HRESULT _stdcall wiasValidateItemProperties(__in BYTE *pWiasContext, ULONG nPropSpec, 
    __in_ecount(nPropSpec) const PROPSPEC *pPropSpec);

HRESULT _stdcall wiasCreatePropContext(ULONG cPropSpec, __in_ecount(cPropSpec) PROPSPEC *pPropSpec, 
   ULONG cProps, __in_ecount_opt(cProps) PROPID *pProps, __in WIA_PROPERTY_CONTEXT  *pContext);

HRESULT _stdcall wiasGetImageInformation(__in BYTE *pWiasContext, LONG lFlags, 
    __inout PMINIDRV_TRANSFER_CONTEXT pmdtc);

HRESULT _stdcall wiasWritePageBufToFile(__in PMINIDRV_TRANSFER_CONTEXT pmdtc);
HRESULT _stdcall wiasWritePageBufToStream(__in PMINIDRV_TRANSFER_CONTEXT pmdtc, __in IStream * pstream);
HRESULT _stdcall wiasWriteBufToFile(LONG lFlags, __in PMINIDRV_TRANSFER_CONTEXT pmdtc);

HRESULT _stdcall wiasReadPropStr(__in BYTE *pWiasContext, PROPID propid, 
    __out BSTR *pbstr, __out_opt BSTR *pbstrOld, BOOL bMustExist);
HRESULT _stdcall wiasReadPropLong(__in BYTE *pWiasContext, PROPID propid, 
   __out LONG *plVal,  __out_opt LONG *plValOld, BOOL bMustExist);
HRESULT _stdcall wiasReadPropFloat(__in BYTE *pWiasContext, PROPID propid, 
   __out FLOAT *pfVal, __out_opt FLOAT *pfValOld, BOOL bMustExist);
HRESULT _stdcall wiasReadPropGuid(__in BYTE *pWiasContext, PROPID propid, 
    __out GUID *pguidVal, __out_opt GUID *pguidValOld, BOOL bMustExist);
HRESULT _stdcall wiasReadPropBin(__in BYTE *pWiasContext, PROPID propid,
    __out BYTE **ppbVal, __out_opt BYTE **ppbValOld, BOOL bMustExist);

HRESULT _stdcall wiasWritePropStr(__in BYTE *pWiasContext, PROPID propid, __in_opt BSTR bstr);
HRESULT _stdcall wiasWritePropLong(__in BYTE *pWiasContext, PROPID propid, LONG lVal);
HRESULT _stdcall wiasWritePropFloat(__in BYTE *pWiasContext, PROPID propid, float fVal);
HRESULT _stdcall wiasWritePropGuid(__in BYTE *pWiasContext, PROPID propid, GUID guidVal);

HRESULT _stdcall wiasSetItemPropNames(__in BYTE *pWiasContext, LONG cItemProps, 
    __inout_ecount(cItemProps) PROPID *ppId, __inout_ecount(cItemProps) LPOLESTR *ppszNames);
HRESULT _stdcall wiasSetItemPropAttribs(__in BYTE *pWiasContext, LONG cPropSpec,
    __in_ecount(cPropSpec) PROPSPEC *pPropSpec, __in_ecount(cPropSpec) PWIA_PROPERTY_INFO pwpi);

HRESULT _stdcall wiasSendEndOfPage(__in BYTE *pWiasContext, 
   LONG lPageCount, __inout PMINIDRV_TRANSFER_CONTEXT pmdtc);

HRESULT _stdcall wiasGetItemType(__in BYTE *pWiasContext, __out LONG *plType);

HRESULT _stdcall wiasGetDrvItem(__in BYTE *pWiasContext, __out IWiaDrvItem **ppIWiaDrvItem);
HRESULT _stdcall wiasGetRootItem(__in BYTE *pWiasContext, __out BYTE **ppWiasContext);

HRESULT _stdcall wiasSetValidFlag(__in BYTE* pWiasContext, PROPID propid, ULONG ulNom, ULONG ulValidBits);
HRESULT _stdcall wiasSetValidRangeLong(__in BYTE* pWiasContext, PROPID propid, LONG lMin, LONG lNom, LONG lMax, LONG lStep);
HRESULT _stdcall wiasSetValidRangeFloat(__in BYTE* pWiasContext, PROPID propid, FLOAT fMin, FLOAT fNom, FLOAT fMax, FLOAT fStep);
HRESULT _stdcall wiasSetValidListLong(__in BYTE *pWiasContext, PROPID propid, ULONG ulCount, LONG lNom, LONG *plValues);
HRESULT _stdcall wiasSetValidListFloat(__in BYTE *pWiasContext, PROPID propid, ULONG ulCount, FLOAT fNom, __in_ecount(ulCount) FLOAT *pfValues);
HRESULT _stdcall wiasSetValidListGuid(__in BYTE *pWiasContext, PROPID propid, ULONG ulCount, GUID guidNom, __in_ecount(ulCount) GUID *pguidValues);
HRESULT _stdcall wiasSetValidListStr(__in BYTE *pWiasContext, PROPID propid, ULONG ulCount, BSTR bstrNom, __in_ecount(ulCount) BSTR *bstrValues);

HRESULT _stdcall wiasFreePropContext(__inout WIA_PROPERTY_CONTEXT *pContext);
HRESULT _stdcall wiasIsPropChanged(PROPID propid, __in WIA_PROPERTY_CONTEXT *pContext, __out BOOL *pbChanged);
HRESULT _stdcall wiasSetPropChanged(PROPID propid, __in WIA_PROPERTY_CONTEXT *pContext, BOOL bChanged);
HRESULT _stdcall wiasGetChangedValueLong(__in BYTE *pWiasContext, __in WIA_PROPERTY_CONTEXT *pContext,
    BOOL bNoValidation, PROPID propID, __out WIAS_CHANGED_VALUE_INFO *pInfo);
HRESULT _stdcall wiasGetChangedValueFloat(__in BYTE *pWiasContext, __in WIA_PROPERTY_CONTEXT *pContext,
    BOOL bNoValidation, PROPID propID, __out WIAS_CHANGED_VALUE_INFO *pInfo);
HRESULT _stdcall wiasGetChangedValueGuid(__in BYTE *pWiasContext, __in WIA_PROPERTY_CONTEXT *pContext,
    BOOL bNoValidation, PROPID propID, __out WIAS_CHANGED_VALUE_INFO *pInfo);
HRESULT _stdcall wiasGetChangedValueStr(__in BYTE *pWiasContext, __in WIA_PROPERTY_CONTEXT *pContext,
    BOOL bNoValidation, PROPID propID, __out WIAS_CHANGED_VALUE_INFO *pInfo);

HRESULT _stdcall wiasGetContextFromName(__in BYTE *pWiasContext, LONG lFlags, __in BSTR bstrName, __out BYTE **ppWiasContext);

HRESULT _stdcall wiasUpdateScanRect(__in BYTE *pWiasContext, __in WIA_PROPERTY_CONTEXT *pContext, LONG lWidth, LONG lHeight);
HRESULT _stdcall wiasUpdateValidFormat(__in BYTE *pWiasContext, __in WIA_PROPERTY_CONTEXT *pContext, __in IWiaMiniDrv *pIMiniDrv);

HRESULT _stdcall wiasGetChildrenContexts(__in BYTE *pParentContext, __out ULONG *pulNumChildren,
    __out_ecount(*pulNumChildren) BYTE ***pppChildren);

HRESULT _stdcall wiasQueueEvent(__in BSTR bstrDeviceId, __in const GUID *pEventGUID, __in_opt BSTR bstrFullItemName);

VOID __cdecl wiasDebugTrace(__in HINSTANCE hInstance, __in LPCSTR pszFormat, ... );
VOID __cdecl wiasDebugError(__in HINSTANCE hInstance, __in LPCSTR pszFormat, ... );
VOID __stdcall wiasPrintDebugHResult(__in HINSTANCE hInstance, HRESULT hr );

BSTR __cdecl wiasFormatArgs(__in LPCSTR lpszFormat, ...);

HRESULT _stdcall wiasCreateChildAppItem(__in BYTE *pParentWiasContext, LONG lFlags, 
    __in BSTR bstrItemName, __in BSTR bstrFullItemName, __out BYTE  **ppWiasChildContext);

HRESULT _stdcall wiasCreateLogInstance(__in BYTE *pModuleHandle, __out IWiaLogEx  **ppIWiaLogEx);
HRESULT _stdcall wiasDownSampleBuffer(LONG lFlags, __inout WIAS_DOWN_SAMPLE_INFO *pInfo);
HRESULT _stdcall wiasParseEndorserString(__in BYTE *pWiasContext, LONG lFlags, 
   __out_opt WIAS_ENDORSER_INFO *pInfo, __out BSTR *pOutputString);

#ifndef WIA_MAP_OLD_DEBUG

#if defined(_DEBUG) || defined(DBG) || defined(WIA_DEBUG)

#define WIAS_TRACE(x) wiasDebugTrace x
#define WIAS_ERROR(x) wiasDebugError x
#define WIAS_HRESULT(x) wiasPrintDebugHResult x
#define WIAS_ASSERT(x, y) \
        if (!(y)) { \
            WIAS_ERROR((x, (char*) TEXT("ASSERTION FAILED: %hs(%d): %hs"), __FILE__,__LINE__,#x)); \
            DebugBreak(); \
        }

#else

#define WIAS_TRACE(x)
#define WIAS_ERROR(x)
#define WIAS_HRESULT(x)
#define WIAS_ASSERT(x, y)

#endif

#define WIAS_LTRACE(pILog,ResID,Detail,Args) \
         { if ( pILog ) \
            pILog->Log(WIALOG_TRACE, ResID, Detail, wiasFormatArgs Args);\
         };
#define WIAS_LERROR(pILog,ResID,Args) \
         {if ( pILog )\
            pILog->Log(WIALOG_ERROR, ResID, WIALOG_NO_LEVEL, wiasFormatArgs Args);\
         };
#define WIAS_LWARNING(pILog,ResID,Args) \
         {if ( pILog )\
            pILog->Log(WIALOG_WARNING, ResID, WIALOG_NO_LEVEL, wiasFormatArgs Args);\
         };
#define WIAS_LHRESULT(pILog,hr) \
         {if ( pILog )\
            pILog->hResult(hr);\
         };

//
// IWiaLog Defines
//

// Type of logging
#define WIALOG_TRACE   0x00000001
#define WIALOG_WARNING 0x00000002
#define WIALOG_ERROR   0x00000004

// level of detail for TRACE logging
#define WIALOG_LEVEL1  1 // Entry and Exit point of each function/method
#define WIALOG_LEVEL2  2 // LEVEL 1, + traces within the function/method
#define WIALOG_LEVEL3  3 // LEVEL 1, LEVEL 2, and any extra debugging information
#define WIALOG_LEVEL4  4 // USER DEFINED data + all LEVELS of tracing

#define WIALOG_NO_RESOURCE_ID   0
#define WIALOG_NO_LEVEL         0

//
// Entering / Leaving class
//

class CWiaLogProc {
private:
    CHAR   m_szMessage[MAX_PATH];
    IWiaLog *m_pIWiaLog;
    INT     m_DetailLevel;
    INT     m_ResourceID;

public:
    inline CWiaLogProc(IWiaLog *pIWiaLog, INT ResourceID, INT DetailLevel, __in CHAR *pszMsg) {
        ZeroMemory(m_szMessage, sizeof(m_szMessage));
        StringCchCopyA(m_szMessage, ARRAYSIZE(m_szMessage), pszMsg);
        m_pIWiaLog = pIWiaLog;
        m_DetailLevel = DetailLevel;
        m_ResourceID = ResourceID;
        WIAS_LTRACE(pIWiaLog,
                    ResourceID,
                    DetailLevel,
                    ("%s, entering",m_szMessage));
    }

    inline ~CWiaLogProc() {
        WIAS_LTRACE(m_pIWiaLog,
                    m_ResourceID,
                    m_DetailLevel,
                    ("%s, leaving",m_szMessage));
    }
};

class CWiaLogProcEx {
private:
    CHAR        m_szMessage[MAX_PATH];
    IWiaLogEx   *m_pIWiaLog;
    INT         m_DetailLevel;
    INT         m_ResourceID;

public:
    inline CWiaLogProcEx(IWiaLogEx *pIWiaLog, INT ResourceID, INT DetailLevel, __in CHAR *pszMsg, LONG lMethodId = 0) {
        ZeroMemory(m_szMessage, sizeof(m_szMessage));
        StringCchCopyA(m_szMessage, ARRAYSIZE(m_szMessage), pszMsg);
        m_pIWiaLog = pIWiaLog;
        m_DetailLevel = DetailLevel;
        m_ResourceID = ResourceID;
        WIAS_LTRACE(pIWiaLog,
                    ResourceID,
                    DetailLevel,
                    ("%s, entering",m_szMessage));
    }

    inline ~CWiaLogProcEx() {
        WIAS_LTRACE(m_pIWiaLog,
                    m_ResourceID,
                    m_DetailLevel,
                    ("%s, leaving",m_szMessage));
    }
};

#endif // WIA_MAP_OLD_DEBUG


#ifdef __cplusplus
}

#endif
#endif //#ifdef (NTDDI_VERSION >= NTDDI_WINXP)

#endif // _WIAMDEF_H_
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\win2k8\ddk\inc\wdmwarn4.h ===
/*
Include before wdm.h to be able to compile at warning level 4
*/

/*
4214 nonstandard extension used : bit field types other than int
4201 nonstandard extension using nameless struct/union
4115 nonstandard extension used : named type definition in parens
4200 nonstandard extension used : zero-sized array in struct/union
4514 unreferenced inline function
**4100 unreferenced formal parameter
4057
4127 condition expression is constant
*/

#pragma warning(disable:4214 4201 4115 4200 4100 4514 4057 4127)
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\win2k8\ddk\inc\wiamicro.h ===
/****************************************************************************
*
*  (C) COPYRIGHT 1999-2000, MICROSOFT CORP.
*
*  FILE:        wiamicro.h
*
*  VERSION:     3.0
*
*  DESCRIPTION:
*    Definitions to support WIA scanner and camera microdrivers.
*
*****************************************************************************/

#if (_WIN32_WINNT >= 0x0501) // Windows XP and later

#pragma once

#include <SCSISCAN.H>

#define WIAMICRO_API __declspec(dllexport)

#include <pshpack8.h>

/****************************************************************************\
* Scanner microdriver definitions
\****************************************************************************/

//
// Private #defines
//

#define MAX_IO_HANDLES 16
#define MAX_RESERVED    4
#define MAX_ANSI_CHAR 255

//
// Common BUS types
//

#define BUS_TYPE_SCSI         200
#define BUS_TYPE_USB          201
#define BUS_TYPE_PARALLEL     202
#define BUS_TYPE_FIREWIRE     203

//
// command list
//

#define SCAN_FIRST             10
#define SCAN_NEXT              20
#define SCAN_FINISHED          30

#define SCANMODE_FINALSCAN     0
#define SCANMODE_PREVIEWSCAN   1

#define CMD_INITIALIZE        100
#define CMD_UNINITIALIZE      101
#define CMD_SETXRESOLUTION    102
#define CMD_SETYRESOLUTION    103
#define CMD_SETCONTRAST       104
#define CMD_SETINTENSITY      105
#define CMD_SETDATATYPE       106
#define CMD_SETDITHER         107
#define CMD_SETMIRROR         108
#define CMD_SETNEGATIVE       109
#define CMD_SETTONEMAP        110
#define CMD_SETCOLORDITHER    111
#define CMD_SETMATRIX         112
#define CMD_SETSPEED          113
#define CMD_SETFILTER         114
#define CMD_LOAD_ADF          115
#define CMD_UNLOAD_ADF        116
#define CMD_GETADFAVAILABLE   117
#define CMD_GETADFOPEN        118
#define CMD_GETADFREADY       119
#define CMD_GETADFHASPAPER    120
#define CMD_GETADFSTATUS      121
#define CMD_GETADFUNLOADREADY 122
#define CMD_GETTPAAVAILABLE   123
#define CMD_GETTPAOPENED      124
#define CMD_TPAREADY          125
#define CMD_SETLAMP           126
#define CMD_SENDSCSICOMMAND   127
#define CMD_STI_DEVICERESET   128
#define CMD_STI_GETSTATUS     129
#define CMD_STI_DIAGNOSTIC    130
#define CMD_RESETSCANNER      131
#define CMD_GETCAPABILITIES   132
#define CMD_GET_INTERRUPT_EVENT 133
#define CMD_SETGSDNAME        134
#define CMD_SETSCANMODE       135
#define CMD_SETSTIDEVICEHKEY  136
#define CMD_GETSUPPORTEDFILEFORMATS 138
#define CMD_GETSUPPORTEDMEMORYFORMATS 139
#define CMD_SETFORMAT   140

#define SUPPORT_COLOR      0x00000001
#define SUPPORT_BW         0x00000002
#define SUPPORT_GRAYSCALE  0x00000004

//
// Error Codes
//

#define MCRO_ERROR_GENERAL_ERROR     0 // All lVal values are initialized to '0'
#define MCRO_STATUS_OK               1 // General success status return
#define MCRO_ERROR_PAPER_JAM         2 // ADF has a paper Jam
#define MCRO_ERROR_PAPER_PROBLEM     3 // ADF has a paper problem
#define MCRO_ERROR_PAPER_EMPTY       4 // ADF has no paper
#define MCRO_ERROR_OFFLINE           5 // ADF or Device is offline
#define MCRO_ERROR_USER_INTERVENTION 6 // User needs to interact with the physical device

//
// WIA compatible #defines
//

#define WIA_PACKED_PIXEL         0
#define WIA_PLANAR               1

#define WIA_ORDER_RGB            0
#define WIA_ORDER_BGR            1

#define WIA_DATA_THRESHOLD       0
#define WIA_DATA_DITHER          1
#define WIA_DATA_GRAYSCALE       2
#define WIA_DATA_COLOR           3
#define WIA_DATA_COLOR_THRESHOLD 4
#define WIA_DATA_COLOR_DITHER    5

//
// structure definitions
//

typedef struct _RANGEVALUE {
    LONG lMin;                  // minimum value
    LONG lMax;                  // maximum value
    LONG lStep;                 // increment/step value
} RANGEVALUE, *PRANGEVALUE;

typedef struct _SCANWINDOW {
    LONG xPos;                  // X position (left)
    LONG yPos;                  // Y position (top)
    LONG xExtent;               // X extent   (right)
    LONG yExtent;               // Y extent   (bottom)
} SCANWINDOW, *PSCANWINDOW;

typedef struct _SCANINFO {
    // Common Scanner specs
    LONG ADF;                   // (0 - no support,  1 - supported, 2 - supported and It can duplex)
    LONG TPA;                   // (0 - no support,  1 - supported)
    LONG Endorser;              // (0 - no endorser, 1 - supported)
    LONG OpticalXResolution;    // (dpi setting of optics)
    LONG OpticalYResolution;    // (dpi setting of optics)
    LONG BedWidth;              // (bed width in 1000's of an inch)
    LONG BedHeight;             // (bed height in 1000's of an inch)
    RANGEVALUE IntensityRange;  // (Intensity/Brightness ranges)
    RANGEVALUE ContrastRange;   // (Contrast ranges)
    LONG SupportedCompressionType; // (mask of supported compression types, 0 - None)
    LONG SupportedDataTypes;    // (mask of supported types, (ie. SUPPORT_COLOR|SUPPORT_BW...))
    // Current Image Info
    LONG WidthPixels;           // (width of image, using current scanner settings in pixels)
    LONG WidthBytes;            // (width of image, using current scanner settings in bytes)
    LONG Lines;                 // (height of image, using current scanner settings in pixles)
    LONG DataType;              // (current data type set)
    LONG PixelBits;             // (current bit depth setting)
    // Current Scanner settings
    LONG Intensity;             // (current Intensity/Brightness setting)
    LONG Contrast;              // (current contrast setting)
    LONG Xresolution;           // (current X Resolution)
    LONG Yresolution;           // (current Y Resolution
    SCANWINDOW Window;          // (current scanner window settings)
    // Scanner options
    LONG DitherPattern;
    LONG Negative;              // (0 - off,        1 - Negative is on)
    LONG Mirror;                // (0 - off,        1 - Mirror is on)
    LONG AutoBack;              // (0 - off,        1 - AutoBack is on)
    LONG ColorDitherPattern;    // (dither pattern??)
    LONG ToneMap;               // (tone map ??)
    LONG Compression;           // (0 - off,        1 - Compression is on)
    LONG RawDataFormat;         // (0 - Packed data 1 - Planar data)
    LONG RawPixelOrder;         // (0 - RGB,        1 - BGR)
    LONG bNeedDataAlignment;    // (0 - FALSE,      1 - TRUE)
    LONG DelayBetweenRead;      // delay between WIA Scan() calls requesting data (milliseconds)
    LONG MaxBufferSize;         // maximum buffer size in scanner
    HANDLE DeviceIOHandles[MAX_IO_HANDLES]; // Device IO handles needed for device communication
    LONG lReserved[MAX_RESERVED]; // (silly reserved bits)
    VOID *pMicroDriverContext;  // private data for Micro driver's only.
                                // The Micro Driver is responsible for allocating and freeing.
                                // CMD_INITIALIZE - allocate, CMD_UNINITIALIZE - free
}SCANINFO, *PSCANINFO;

typedef struct VAL {
        LONG      lVal;             // long value
        double    dblVal;           // float/double value
        GUID     *pGuid;            // GUID pointer
        PSCANINFO pScanInfo;        // pointer to the shared ScanInfo struct
        HGLOBAL   handle;           // handle value
        WCHAR   **ppButtonNames;    // pointer to button names array
        HANDLE   *pHandle;          // pointer to a Handle value
        LONG      lReserved;        // lone value
        CHAR   szVal[MAX_ANSI_CHAR];// ANSI string
}VAL, *PVAL;

//
// Micro driver entry points
//

WIAMICRO_API HRESULT MicroEntry(LONG lCommand, PVAL pValue);
WIAMICRO_API HRESULT Scan(PSCANINFO pScanInfo, LONG lPhase, __out_bcount(lLength) PBYTE pBuffer, LONG lLength, LONG *plReceived);
WIAMICRO_API HRESULT SetPixelWindow(PSCANINFO pScanInfo, LONG x, LONG y, LONG xExtent, LONG yExtent);

//
// optional debug trace
//

VOID Trace(LPCTSTR Format, ...);

#include <poppack.h>

#endif //#if (_WIN32_WINNT >= 0x0501)
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\win2k8\ddk\inc\wdm.h ===
/*++ BUILD Version: 0162    // Increment this if a change has global effects

Copyright (c) Microsoft Corporation. All rights reserved.

Module Name:

    wdm.h

Abstract:

    This module defines the WDM types, constants, and functions that are
    exposed to device drivers.

Revision History:

--*/

#ifndef _WDMDDK_
#define _WDMDDK_

#ifndef _NTDDK_
#define _WDM_INCLUDED_
#define _DDK_DRIVER_

//
// Use 9x compat Interlocked functions by default when including wdm.h
//

#define NO_INTERLOCKED_INTRINSICS

#endif

#define _NTDDK_
#define _STRSAFE_USE_SECURE_CRT 0

#ifndef RC_INVOKED
#if _MSC_VER < 1300
#error Compiler version not supported by Windows DDK
#endif
#endif // RC_INVOKED

#define NT_INCLUDED
#define _CTYPE_DISABLE_MACROS

#if _MSC_VER >= 1200
#pragma warning(push)
#endif

#pragma warning(disable:4115) // named type definition in parentheses
#pragma warning(disable:4201) // nameless struct/union
#pragma warning(disable:4214) // bit field types other than int

#include <excpt.h>
#include <ntdef.h>
#include <ntstatus.h>
#include <bugcodes.h>
#include <ntiologc.h>

#include <driverspecs.h>
__internal_kernel_driver

#ifdef __cplusplus
extern "C" {
#endif

//
// Define types that are not exported.
//

typedef struct _ACCESS_STATE *PACCESS_STATE;
typedef struct _CALLBACK_OBJECT *PCALLBACK_OBJECT;
#if defined(_NTHAL_INCLUDED_)
typedef struct _KPROCESS *PEPROCESS;
typedef struct _ETHREAD *PETHREAD;
#elif defined(_NTIFS_INCLUDED_)
typedef struct _KPROCESS *PEPROCESS;
typedef struct _KTHREAD *PETHREAD;
#else
typedef struct _EPROCESS *PEPROCESS;
typedef struct _ETHREAD *PETHREAD;
#endif
typedef struct _IO_TIMER *PIO_TIMER;
typedef struct _KINTERRUPT *PKINTERRUPT;
typedef struct _KTHREAD *PKTHREAD, *PRKTHREAD;
typedef struct _OBJECT_TYPE *POBJECT_TYPE;
typedef struct _SECURITY_QUALITY_OF_SERVICE *PSECURITY_QUALITY_OF_SERVICE;


//
// Declare empty structure definitions so that they may be referenced by
// routines before they are defined
//
typedef struct _CONTEXT *PCONTEXT;
typedef struct _IO_STACK_LOCATION *PIO_STACK_LOCATION;
typedef struct _VPB *PVPB;
typedef struct _FILE_GET_QUOTA_INFORMATION *PFILE_GET_QUOTA_INFORMATION;


#if defined(_M_AMD64)

ULONG64
__readgsqword (
    IN ULONG Offset
    );

#pragma intrinsic(__readgsqword)

__forceinline
PKTHREAD
KeGetCurrentThread (
    VOID
    )

{
    return (struct _KTHREAD *)__readgsqword(0x188);
}

#endif // defined(_M_AMD64)

#if defined(_M_IX86) || defined(_M_IA64)

NTSYSAPI
PKTHREAD
NTAPI
KeGetCurrentThread(
    VOID
    );

#endif // defined(_M_IX86) || defined(_M_IA64)

//
// Define base address for kernel and user space
//

#ifndef _WIN64

#define KADDRESS_BASE 0

#define UADDRESS_BASE 0

#endif // !_WIN64


#if defined(_M_IA64) && !defined(_NTHAL_)

//
// Define Address of Processor Control Registers.
//

#define KIPCR ((ULONG_PTR)(KADDRESS_BASE + 0xFFFF0000))            // kernel address of first PCR

//
// Define Pointer to Processor Control Registers.
//

#define PCR ((volatile KPCR * const)KIPCR)

#endif // defined(_M_IA64) && !defined(_NTHAL_)

#include <mce.h>

#ifndef FAR
#define FAR
#endif

#define PsGetCurrentProcess IoGetCurrentProcess

#if (NTDDI_VERSION >= NTDDI_VISTA)
extern NTSYSAPI volatile CCHAR KeNumberProcessors;
#else
#if (NTDDI_VERSION >= NTDDI_WINXP)
extern NTSYSAPI CCHAR KeNumberProcessors;
#else
extern PCCHAR KeNumberProcessors;
#endif
#endif

#ifdef _X86_

//
// Disable these two pragmas that evaluate to "sti" "cli" on x86 so that driver
// writers to not leave them inadvertantly in their code.
//

#if !defined(MIDL_PASS)
#if !defined(RC_INVOKED)

#if _MSC_VER >= 1200
#pragma warning(push)
#endif
#pragma warning(disable:4164)   // disable C4164 warning so that apps that
                                // build with /Od don't get weird errors !
#ifdef _M_IX86
#pragma function(_enable)
#pragma function(_disable)
#endif

#if _MSC_VER >= 1200
#pragma warning(pop)
#else
#pragma warning(default:4164)   // reenable C4164 warning
#endif

#endif
#endif


#if defined(_M_IX86) && !defined(RC_INVOKED) && !defined(MIDL_PASS)

#ifdef __cplusplus
extern "C" {
#endif


//
// [pfx_parse] - guard against PREfix intrinsic error
//
#if (_MSC_FULL_VER >= 14000101) && (!defined(_PREFIX_))


//
// Define bit test intrinsics.
//

#define BitTest _bittest
#define BitTestAndComplement _bittestandcomplement
#define BitTestAndSet _bittestandset
#define BitTestAndReset _bittestandreset
#define InterlockedBitTestAndSet _interlockedbittestandset
#define InterlockedBitTestAndReset _interlockedbittestandreset

BOOLEAN
_bittest (
    IN LONG const *Base,
    IN LONG Offset
    );

BOOLEAN
_bittestandcomplement (
    IN LONG *Base,
    IN LONG Offset
    );

BOOLEAN
_bittestandset (
    IN LONG *Base,
    IN LONG Offset
    );

BOOLEAN
_bittestandreset (
    IN LONG *Base,
    IN LONG Offset
    );

BOOLEAN
_interlockedbittestandset (
    IN LONG volatile *Base,
    IN LONG Offset
    );

BOOLEAN
_interlockedbittestandreset (
    IN LONG volatile *Base,
    IN LONG Offset
    );

#pragma intrinsic(_bittest)
#pragma intrinsic(_bittestandcomplement)
#pragma intrinsic(_bittestandset)
#pragma intrinsic(_bittestandreset)
#pragma intrinsic(_interlockedbittestandset)
#pragma intrinsic(_interlockedbittestandreset)

//
// Define bit scan intrinsics.
//

#define BitScanForward _BitScanForward
#define BitScanReverse _BitScanReverse

BOOLEAN
_BitScanForward (
    __out ULONG *Index,
    __in ULONG Mask
    );

BOOLEAN
_BitScanReverse (
    __out ULONG *Index,
    __in ULONG Mask
    );

#pragma intrinsic(_BitScanForward)
#pragma intrinsic(_BitScanReverse)

#else

#pragma warning(push)
#pragma warning(disable:4035 4793)

FORCEINLINE
BOOLEAN
InterlockedBitTestAndSet (
    IN LONG volatile *Base,
    IN LONG Bit
    )
{
    __asm {
           mov eax, Bit
           mov ecx, Base
           lock bts [ecx], eax
           setc al
    };
}

FORCEINLINE
BOOLEAN
InterlockedBitTestAndReset (
    IN LONG volatile *Base,
    IN LONG Bit
    )
{
    __asm {
           mov eax, Bit
           mov ecx, Base
           lock btr [ecx], eax
           setc al
    };
}
#pragma warning(pop)

#endif	/* _MSC_FULL_VER >= 14000101 */

//
// [pfx_parse] - guard against PREfix intrinsic error
//
#if (_MSC_FULL_VER >= 140040816) || (defined(_PREFAST_) && (_MSC_VER >= 1400))


#define InterlockedCompareExchange16 _InterlockedCompareExchange16

SHORT
_InterlockedCompareExchange16 (
    __inout SHORT volatile *Destination,
    __in SHORT ExChange,
    __in SHORT Comperand
    );

#pragma intrinsic(_InterlockedCompareExchange16)

#endif  /* _MSC_FULL_VER >= 140040816 */

#if !defined(_M_CEE_PURE)
#pragma warning(push)
#pragma warning(disable:4035 4793)

FORCEINLINE
BOOLEAN
InterlockedBitTestAndComplement (
    IN LONG volatile *Base,
    IN LONG Bit
    )
{
    __asm {
           mov eax, Bit
           mov ecx, Base
           lock btc [ecx], eax
           setc al
    };
}
#pragma warning(pop)
#endif	/* _M_CEE_PURE */

//
// [pfx_parse]
// guard against __readfsbyte parsing error
//
#if (_MSC_FULL_VER >= 13012035) || defined(_PREFIX_) || defined(_PREFAST_)

//
// Define FS referencing intrinsics
//

UCHAR
__readfsbyte (
    IN ULONG Offset
    );
 
USHORT
__readfsword (
    IN ULONG Offset
    );
 
ULONG
__readfsdword (
    IN ULONG Offset
    );
 
VOID
__writefsbyte (
    IN ULONG Offset,
    IN UCHAR Data
    );
 
VOID
__writefsword (
    IN ULONG Offset,
    IN USHORT Data
    );
 
VOID
__writefsdword (
    IN ULONG Offset,
    IN ULONG Data
    );

#pragma intrinsic(__readfsbyte)
#pragma intrinsic(__readfsword)
#pragma intrinsic(__readfsdword)
#pragma intrinsic(__writefsbyte)
#pragma intrinsic(__writefsword)
#pragma intrinsic(__writefsdword)

#endif	/* _MSC_FULL_VER >= 13012035 */

#if (_MSC_FULL_VER >= 140050727) || defined(_PREFIX_) || defined(_PREFAST_)

#if !defined(_MANAGED)

VOID
__incfsbyte (
    ULONG Offset
    );
 
VOID
__addfsbyte (
    ULONG Offset,
    UCHAR Value
    );
 
VOID
__incfsword (
    ULONG Offset
    );
 
VOID
__addfsword (
    ULONG Offset,
    USHORT Value
    );
 
VOID
__incfsdword (
    ULONG Offset
    );
 
VOID
__addfsdword (
    ULONG Offset,
    ULONG Value
    );
 
#if 0
#pragma intrinsic(__incfsbyte)
#pragma intrinsic(__addfsbyte)
#pragma intrinsic(__incfsword)
#pragma intrinsic(__addfsword)
#pragma intrinsic(__incfsdword)
#pragma intrinsic(__addfsdword)
#endif

#endif

#endif	/* _MSC_FULL_VER >= 140050727 */

#if (_MSC_FULL_VER >= 140041204) || defined(_PREFIX_) || defined(_PREFAST_)

VOID
_mm_pause (
    VOID
    );

#pragma intrinsic(_mm_pause)

#define YieldProcessor _mm_pause

#else

#if !defined(_M_CEE_PURE)
#define YieldProcessor() __asm { rep nop }
#endif  // !defined(_M_CEE_PURE)

#endif  // (_MSC_FULL_VER >= 140041204)

#ifdef __cplusplus
}
#endif

#endif  /* !defined(MIDL_PASS) || defined(_M_IX86) */


#if defined(_X86_) && defined(_M_IX86) && !defined(RC_INVOKED) && !defined(MIDL_PASS)

#if _MSC_FULL_VER >= 140030222

VOID
__int2c (
    VOID
    );

#pragma intrinsic(__int2c)
#define DbgRaiseAssertionFailure() __int2c()

#else
#pragma warning( push )
#pragma warning( disable : 4793 )

FORCEINLINE
VOID
DbgRaiseAssertionFailure (
    void
    )

{
    __asm int 0x2c
}

#pragma warning( pop )

#endif

#endif

#endif // _X86_

#ifdef _AMD64_


#if defined(_M_AMD64) && !defined(RC_INVOKED) && !defined(MIDL_PASS)

//
// Define bit test intrinsics.
//

#ifdef __cplusplus
extern "C" {
#endif

#define BitTest _bittest
#define BitTestAndComplement _bittestandcomplement
#define BitTestAndSet _bittestandset
#define BitTestAndReset _bittestandreset
#define InterlockedBitTestAndSet _interlockedbittestandset
#define InterlockedBitTestAndReset _interlockedbittestandreset

#define BitTest64 _bittest64
#define BitTestAndComplement64 _bittestandcomplement64
#define BitTestAndSet64 _bittestandset64
#define BitTestAndReset64 _bittestandreset64
#define InterlockedBitTestAndSet64 _interlockedbittestandset64
#define InterlockedBitTestAndReset64 _interlockedbittestandreset64

BOOLEAN
_bittest (
    IN LONG const *Base,
    IN LONG Offset
    );

BOOLEAN
_bittestandcomplement (
    IN LONG *Base,
    IN LONG Offset
    );

BOOLEAN
_bittestandset (
    IN LONG *Base,
    IN LONG Offset
    );

BOOLEAN
_bittestandreset (
    IN LONG *Base,
    IN LONG Offset
    );

BOOLEAN
_interlockedbittestandset (
    IN LONG volatile *Base,
    IN LONG Offset
    );

BOOLEAN
_interlockedbittestandreset (
    IN LONG volatile *Base,
    IN LONG Offset
    );

BOOLEAN
_bittest64 (
    IN LONG64 const *Base,
    IN LONG64 Offset
    );

BOOLEAN
_bittestandcomplement64 (
    IN LONG64 *Base,
    IN LONG64 Offset
    );

BOOLEAN
_bittestandset64 (
    IN LONG64 *Base,
    IN LONG64 Offset
    );

BOOLEAN
_bittestandreset64 (
    IN LONG64 *Base,
    IN LONG64 Offset
    );

BOOLEAN
_interlockedbittestandset64 (
    IN LONG64 volatile *Base,
    IN LONG64 Offset
    );

BOOLEAN
_interlockedbittestandreset64 (
    IN LONG64 volatile *Base,
    IN LONG64 Offset
    );

#pragma intrinsic(_bittest)
#pragma intrinsic(_bittestandcomplement)
#pragma intrinsic(_bittestandset)
#pragma intrinsic(_bittestandreset)
#pragma intrinsic(_interlockedbittestandset)
#pragma intrinsic(_interlockedbittestandreset)

#pragma intrinsic(_bittest64)
#pragma intrinsic(_bittestandcomplement64)
#pragma intrinsic(_bittestandset64)
#pragma intrinsic(_bittestandreset64)
#pragma intrinsic(_interlockedbittestandset64)
#pragma intrinsic(_interlockedbittestandreset64)

//
// Define bit scan intrinsics.
//

#define BitScanForward _BitScanForward
#define BitScanReverse _BitScanReverse
#define BitScanForward64 _BitScanForward64
#define BitScanReverse64 _BitScanReverse64

BOOLEAN
_BitScanForward (
    __out ULONG *Index,
    __in ULONG Mask
    );

BOOLEAN
_BitScanReverse (
    __out ULONG *Index,
    __in ULONG Mask
    );

BOOLEAN
_BitScanForward64 (
    __out ULONG *Index,
    __in ULONG64 Mask
    );

BOOLEAN
_BitScanReverse64 (
    __out ULONG *Index,
    __in ULONG64 Mask
    );

#pragma intrinsic(_BitScanForward)
#pragma intrinsic(_BitScanReverse)
#pragma intrinsic(_BitScanForward64)
#pragma intrinsic(_BitScanReverse64)

//
// Interlocked intrinsic functions.
//

#define InterlockedIncrement16 _InterlockedIncrement16
#define InterlockedDecrement16 _InterlockedDecrement16
#define InterlockedCompareExchange16 _InterlockedCompareExchange16

#define InterlockedAnd _InterlockedAnd
#define InterlockedOr _InterlockedOr
#define InterlockedXor _InterlockedXor
#define InterlockedIncrement _InterlockedIncrement
#define InterlockedIncrementAcquire InterlockedIncrement
#define InterlockedIncrementRelease InterlockedIncrement
#define InterlockedDecrement _InterlockedDecrement
#define InterlockedDecrementAcquire InterlockedDecrement
#define InterlockedDecrementRelease InterlockedDecrement
#define InterlockedAdd _InterlockedAdd
#define InterlockedExchange _InterlockedExchange
#define InterlockedExchangeAdd _InterlockedExchangeAdd
#define InterlockedCompareExchange _InterlockedCompareExchange
#define InterlockedCompareExchangeAcquire InterlockedCompareExchange
#define InterlockedCompareExchangeRelease InterlockedCompareExchange

#define InterlockedAnd64 _InterlockedAnd64
#define InterlockedAndAffinity InterlockedAnd64
#define InterlockedOr64 _InterlockedOr64
#define InterlockedOrAffinity InterlockedOr64
#define InterlockedXor64 _InterlockedXor64
#define InterlockedIncrement64 _InterlockedIncrement64
#define InterlockedDecrement64 _InterlockedDecrement64
#define InterlockedAdd64 _InterlockedAdd64
#define InterlockedExchange64 _InterlockedExchange64
#define InterlockedExchangeAcquire64 InterlockedExchange64
#define InterlockedExchangeAdd64 _InterlockedExchangeAdd64
#define InterlockedCompareExchange64 _InterlockedCompareExchange64
#define InterlockedCompareExchangeAcquire64 InterlockedCompareExchange64
#define InterlockedCompareExchangeRelease64 InterlockedCompareExchange64

#define InterlockedExchangePointer _InterlockedExchangePointer
#define InterlockedCompareExchangePointer _InterlockedCompareExchangePointer
#define InterlockedCompareExchangePointerAcquire _InterlockedCompareExchangePointer
#define InterlockedCompareExchangePointerRelease _InterlockedCompareExchangePointer

#define InterlockedExchangeAddSizeT(a, b) InterlockedExchangeAdd64((LONG64 *)a, b)
#define InterlockedIncrementSizeT(a) InterlockedIncrement64((LONG64 *)a)
#define InterlockedDecrementSizeT(a) InterlockedDecrement64((LONG64 *)a)

SHORT
InterlockedIncrement16 (
    __inout SHORT volatile *Addend
    );

SHORT
InterlockedDecrement16 (
    __inout SHORT volatile *Addend
    );

SHORT
InterlockedCompareExchange16 (
    __inout SHORT volatile *Destination,
    __in SHORT ExChange,
    __in SHORT Comperand
    );

LONG
InterlockedAnd (
    __inout LONG volatile *Destination,
    __in LONG Value
    );

LONG
InterlockedOr (
    __inout LONG volatile *Destination,
    __in LONG Value
    );

LONG
InterlockedXor (
    __inout LONG volatile *Destination,
    __in LONG Value
    );

LONG64
InterlockedAnd64 (
    __inout LONG64 volatile *Destination,
    __in LONG64 Value
    );

LONG64
InterlockedOr64 (
    __inout LONG64 volatile *Destination,
    __in LONG64 Value
    );

LONG64
InterlockedXor64 (
    __inout LONG64 volatile *Destination,
    __in LONG64 Value
    );

LONG
InterlockedIncrement(
    __inout LONG volatile *Addend
    );

LONG
InterlockedDecrement(
    __inout LONG volatile *Addend
    );

LONG
InterlockedExchange(
    __inout LONG volatile *Target,
    __in LONG Value
    );

LONG
InterlockedExchangeAdd(
    __inout LONG volatile *Addend,
    __in LONG Value
    );

#if !defined(_X86AMD64_)

__forceinline
LONG
InterlockedAdd(
    __inout LONG volatile *Addend,
    __in LONG Value
    )

{
    return InterlockedExchangeAdd(Addend, Value) + Value;
}

#endif

LONG
InterlockedCompareExchange (
    __inout LONG volatile *Destination,
    __in LONG ExChange,
    __in LONG Comperand
    );

LONG64
InterlockedIncrement64(
    __inout LONG64 volatile *Addend
    );

LONG64
InterlockedDecrement64(
    __inout LONG64 volatile *Addend
    );

LONG64
InterlockedExchange64(
    __inout LONG64 volatile *Target,
    __in LONG64 Value
    );

LONG64
InterlockedExchangeAdd64(
    __inout LONG64 volatile *Addend,
    __in LONG64 Value
    );

#if !defined(_X86AMD64_)

__forceinline
LONG64
InterlockedAdd64(
    __inout LONG64 volatile *Addend,
    __in LONG64 Value
    )

{
    return InterlockedExchangeAdd64(Addend, Value) + Value;
}

#endif

LONG64
InterlockedCompareExchange64 (
    __inout LONG64 volatile *Destination,
    __in LONG64 ExChange,
    __in LONG64 Comperand
    );

PVOID
InterlockedCompareExchangePointer (
    __inout PVOID volatile *Destination,
    __in_opt PVOID Exchange,
    __in_opt PVOID Comperand
    );

PVOID
InterlockedExchangePointer(
    __inout PVOID volatile *Target,
    __in_opt PVOID Value
    );

#pragma intrinsic(_InterlockedIncrement16)
#pragma intrinsic(_InterlockedDecrement16)
#pragma intrinsic(_InterlockedCompareExchange16)
#pragma intrinsic(_InterlockedAnd)
#pragma intrinsic(_InterlockedOr)
#pragma intrinsic(_InterlockedXor)
#pragma intrinsic(_InterlockedIncrement)
#pragma intrinsic(_InterlockedDecrement)
#pragma intrinsic(_InterlockedExchange)
#pragma intrinsic(_InterlockedExchangeAdd)
#pragma intrinsic(_InterlockedCompareExchange)
#pragma intrinsic(_InterlockedAnd64)
#pragma intrinsic(_InterlockedOr64)
#pragma intrinsic(_InterlockedXor64)
#pragma intrinsic(_InterlockedIncrement64)
#pragma intrinsic(_InterlockedDecrement64)
#pragma intrinsic(_InterlockedExchange64)
#pragma intrinsic(_InterlockedExchangeAdd64)
#pragma intrinsic(_InterlockedCompareExchange64)
#pragma intrinsic(_InterlockedExchangePointer)
#pragma intrinsic(_InterlockedCompareExchangePointer)

#if _MSC_FULL_VER >= 140041204

#define InterlockedAnd8 _InterlockedAnd8
#define InterlockedOr8 _InterlockedOr8
#define InterlockedXor8 _InterlockedXor8
#define InterlockedAnd16 _InterlockedAnd16
#define InterlockedOr16 _InterlockedOr16
#define InterlockedXor16 _InterlockedXor16

char
InterlockedAnd8 (
    __inout char volatile *Destination,
    __in char Value
    );

char
InterlockedOr8 (
    __inout char volatile *Destination,
    __in char Value
    );

char
InterlockedXor8 (
    __inout char volatile *Destination,
    __in char Value
    );

SHORT
InterlockedAnd16(
    __inout SHORT volatile *Destination,
    __in SHORT Value
    );
    
SHORT
InterlockedOr16(
    __inout SHORT volatile *Destination,
    __in SHORT Value
    );

SHORT
InterlockedXor16(
    __inout SHORT volatile *Destination,
    __in SHORT Value
    );

#pragma intrinsic (_InterlockedAnd8)
#pragma intrinsic (_InterlockedOr8)
#pragma intrinsic (_InterlockedXor8)
#pragma intrinsic (_InterlockedAnd16)
#pragma intrinsic (_InterlockedOr16)
#pragma intrinsic (_InterlockedXor16)

#endif

//
// Define function to flush a cache line.
//

#define CacheLineFlush(Address) _mm_clflush(Address)

VOID
_mm_clflush (
    __in VOID const *Address
    );

#pragma intrinsic(_mm_clflush)

VOID
_ReadWriteBarrier (
    VOID
    );

#pragma intrinsic(_ReadWriteBarrier)

//
// Define memory fence intrinsics
//

#define FastFence __faststorefence
#define LoadFence _mm_lfence
#define MemoryFence _mm_mfence
#define StoreFence _mm_sfence

VOID
__faststorefence (
    VOID
    );

VOID
_mm_lfence (
    VOID
    );

VOID
_mm_mfence (
    VOID
    );

VOID
_mm_sfence (
    VOID
    );

VOID
_mm_pause (
    VOID
    );

VOID 
_mm_prefetch (
    __in CHAR CONST *a, 
    __in int sel
    );

VOID
_m_prefetchw (
    __in volatile CONST VOID *Source
    );

//
// Define constants for use with _mm_prefetch.
//

#define _MM_HINT_T0     1
#define _MM_HINT_T1     2
#define _MM_HINT_T2     3
#define _MM_HINT_NTA    0

#pragma intrinsic(__faststorefence)
#pragma intrinsic(_mm_pause)
#pragma intrinsic(_mm_prefetch)
#pragma intrinsic(_mm_lfence)
#pragma intrinsic(_mm_mfence)
#pragma intrinsic(_mm_sfence)
#pragma intrinsic(_m_prefetchw)

#define YieldProcessor _mm_pause
#define MemoryBarrier __faststorefence
#define PreFetchCacheLine(l, a)  _mm_prefetch((CHAR CONST *) a, l)
#define PrefetchForWrite(p) _m_prefetchw(p)
#define ReadForWriteAccess(p) (_m_prefetchw(p), *(p))

//
// PreFetchCacheLine level defines.
//

#define PF_TEMPORAL_LEVEL_1 _MM_HINT_T0
#define PF_TEMPORAL_LEVEL_2 _MM_HINT_T1
#define PF_TEMPORAL_LEVEL_3 _MM_HINT_T2
#define PF_NON_TEMPORAL_LEVEL_ALL _MM_HINT_NTA

//
// Define get/set MXCSR intrinsics.
//

#define ReadMxCsr _mm_getcsr
#define WriteMxCsr _mm_setcsr

unsigned int
_mm_getcsr (
    VOID
    );

VOID
_mm_setcsr (
    __in unsigned int MxCsr
    );

#pragma intrinsic(_mm_getcsr)
#pragma intrinsic(_mm_setcsr)

//
// Assert exception.
//

VOID
__int2c (
    VOID
    );

#pragma intrinsic(__int2c)

#define DbgRaiseAssertionFailure() __int2c()

//
// Define function to get the caller's EFLAGs value.
//

#define GetCallersEflags() __getcallerseflags()

unsigned __int32
__getcallerseflags (
    VOID
    );

#pragma intrinsic(__getcallerseflags)

//
// Define function to get segment limit.
//

#define GetSegmentLimit __segmentlimit

ULONG
__segmentlimit (
    __in ULONG Selector
    );

#pragma intrinsic(__segmentlimit)

//
// Define function to read the value of a performance counter.
//

#define ReadPMC __readpmc

ULONG64
__readpmc (
    __in ULONG Counter
    );

#pragma intrinsic(__readpmc)

//
// Define function to read the value of the time stamp counter
//

#define ReadTimeStampCounter() __rdtsc()

ULONG64
__rdtsc (
    VOID
    );

#pragma intrinsic(__rdtsc)

//
// Define functions to move strings as bytes, words, dwords, and qwords.
//

VOID
__movsb (
    IN PUCHAR Destination,
    IN UCHAR const *Source,
    IN SIZE_T Count
    );

VOID
__movsw (
    IN PUSHORT Destination,
    IN USHORT const *Source,
    IN SIZE_T Count
    );

VOID
__movsd (
    IN PULONG Destination,
    IN ULONG const *Source,
    IN SIZE_T Count
    );

VOID
__movsq (
    IN PULONG64 Destination,
    IN ULONG64 const *Source,
    IN SIZE_T Count
    );

#pragma intrinsic(__movsb)
#pragma intrinsic(__movsw)
#pragma intrinsic(__movsd)
#pragma intrinsic(__movsq)

//
// Define functions to store strings as bytes, words, dwords, and qwords.
//

VOID
__stosb (
    IN PUCHAR Destination,
    IN UCHAR Value,
    IN SIZE_T Count
    );

VOID
__stosw (
    IN PUSHORT Destination,
    IN USHORT Value,
    IN SIZE_T Count
    );

VOID
__stosd (
    IN PULONG Destination,
    IN ULONG Value,
    IN SIZE_T Count
    );

VOID
__stosq (
    IN PULONG64 Destination,
    IN ULONG64 Value,
    IN SIZE_T Count
    );

#pragma intrinsic(__stosb)
#pragma intrinsic(__stosw)
#pragma intrinsic(__stosd)
#pragma intrinsic(__stosq)

//
// Define functions to capture the high 64-bits of a 128-bit multiply.
//

#define MultiplyHigh __mulh
#define UnsignedMultiplyHigh __umulh

LONGLONG
MultiplyHigh (
    __in LONG64 Multiplier,
    __in LONG64 Multiplicand
    );

ULONGLONG
UnsignedMultiplyHigh (
    __in ULONG64 Multiplier,
    __in ULONG64 Multiplicand
    );

#pragma intrinsic(__mulh)
#pragma intrinsic(__umulh)

//
// Define functions to perform 128-bit shifts
//

#define ShiftLeft128 __shiftleft128
#define ShiftRight128 __shiftright128

ULONG64
ShiftLeft128 (
    __in ULONG64 LowPart,
    __in ULONG64 HighPart,
    __in UCHAR Shift
    );

ULONG64
ShiftRight128 (
    __in ULONG64 LowPart,
    __in ULONG64 HighPart,
    __in UCHAR Shift
    );

#pragma intrinsic(__shiftleft128)
#pragma intrinsic(__shiftright128)

//
// Define functions to perform 128-bit multiplies.
//

#define Multiply128 _mul128

LONG64
Multiply128 (
    __in LONG64 Multiplier,
    __in LONG64 Multiplicand,
    __out LONG64 *HighProduct
    );

#pragma intrinsic(_mul128)

#ifndef UnsignedMultiply128

#define UnsignedMultiply128 _umul128

ULONG64
UnsignedMultiply128 (
    __in ULONG64 Multiplier,
    __in ULONG64 Multiplicand,
    __out ULONG64 *HighProduct
    );

#pragma intrinsic(_umul128)

#endif

__forceinline
LONG64
MultiplyExtract128 (
    __in LONG64 Multiplier,
    __in LONG64 Multiplicand,
    __in UCHAR Shift
    )

{

    LONG64 extractedProduct;
    LONG64 highProduct;
    LONG64 lowProduct;
    BOOLEAN negate;
    ULONG64 uhighProduct;
    ULONG64 ulowProduct;

    lowProduct = Multiply128(Multiplier, Multiplicand, &highProduct);
    negate = FALSE;
    uhighProduct = (ULONG64)highProduct;
    ulowProduct = (ULONG64)lowProduct;
    if (highProduct < 0) {
        negate = TRUE;
        uhighProduct = (ULONG64)(-highProduct);
        ulowProduct = (ULONG64)(-lowProduct);
        if (ulowProduct != 0) {
            uhighProduct -= 1;
        }
    }

    extractedProduct = (LONG64)ShiftRight128(ulowProduct, uhighProduct, Shift);
    if (negate != FALSE) {
        extractedProduct = -extractedProduct;
    }

    return extractedProduct;
}

__forceinline
ULONG64
UnsignedMultiplyExtract128 (
    __in ULONG64 Multiplier,
    __in ULONG64 Multiplicand,
    __in UCHAR Shift
    )

{

    ULONG64 extractedProduct;
    ULONG64 highProduct;
    ULONG64 lowProduct;

    lowProduct = UnsignedMultiply128(Multiplier, Multiplicand, &highProduct);
    extractedProduct = ShiftRight128(lowProduct, highProduct, Shift);
    return extractedProduct;
}

//
// Define functions to read and write the uer TEB and the system PCR/PRCB.
//

UCHAR
__readgsbyte (
    __in ULONG Offset
    );

USHORT
__readgsword (
    __in ULONG Offset
    );

ULONG
__readgsdword (
    __in ULONG Offset
    );

ULONG64
__readgsqword (
    __in ULONG Offset
    );

VOID
__writegsbyte (
    __in ULONG Offset,
    __in UCHAR Data
    );

VOID
__writegsword (
    __in ULONG Offset,
    __in USHORT Data
    );

VOID
__writegsdword (
    __in ULONG Offset,
    __in ULONG Data
    );

VOID
__writegsqword (
    __in ULONG Offset,
    __in ULONG64 Data
    );

#pragma intrinsic(__readgsbyte)
#pragma intrinsic(__readgsword)
#pragma intrinsic(__readgsdword)
#pragma intrinsic(__readgsqword)
#pragma intrinsic(__writegsbyte)
#pragma intrinsic(__writegsword)
#pragma intrinsic(__writegsdword)
#pragma intrinsic(__writegsqword)

#if !defined(_MANAGED)

VOID
__incgsbyte (
    __in ULONG Offset
    );
 
VOID
__addgsbyte (
    __in ULONG Offset,
    __in UCHAR Value
    );
 
VOID
__incgsword (
    __in ULONG Offset
    );
 
VOID
__addgsword (
    __in ULONG Offset,
    __in USHORT Value
    );
 
VOID
__incgsdword (
    __in ULONG Offset
    );
 
VOID
__addgsdword (
    __in ULONG Offset,
    __in ULONG Value
    );
 
VOID
__incgsqword (
    __in ULONG Offset
    );
 
VOID
__addgsqword (
    __in ULONG Offset,
    __in ULONG64 Value
    );

#if 0
#pragma intrinsic(__incgsbyte)
#pragma intrinsic(__addgsbyte)
#pragma intrinsic(__incgsword)
#pragma intrinsic(__addgsword)
#pragma intrinsic(__incgsdword)
#pragma intrinsic(__addgsdword)
#pragma intrinsic(__incgsqword)
#pragma intrinsic(__addgsqword)
#endif

#endif

#ifdef __cplusplus
}
#endif 

#endif // defined(_M_AMD64) && !defined(RC_INVOKED) && !defined(MIDL_PASS)


#endif // _AMD64_


#ifdef _IA64_


#if defined(_M_IA64) && !defined(RC_INVOKED) && !defined(MIDL_PASS)

#ifdef __cplusplus
extern "C" {
#endif

//
// Define bit test intrinsics.
//

#define BitTest _bittest
#define BitTestAndComplement _bittestandcomplement
#define BitTestAndSet _bittestandset
#define BitTestAndReset _bittestandreset

#define BitTest64 _bittest64
#define BitTestAndComplement64 _bittestandcomplement64
#define BitTestAndSet64 _bittestandset64
#define BitTestAndReset64 _bittestandreset64

BOOLEAN
_bittest (
    IN LONG const *Base,
    IN LONG Offset
    );

BOOLEAN
_bittestandcomplement (
    IN LONG *Base,
    IN LONG Offset
    );

BOOLEAN
_bittestandset (
    IN LONG *Base,
    IN LONG Offset
    );

BOOLEAN
_bittestandreset (
    IN LONG *Base,
    IN LONG Offset
    );

BOOLEAN
_bittest64 (
    IN LONG64 const *Base,
    IN LONG64 Offset
    );

BOOLEAN
_bittestandcomplement64 (
    IN LONG64 *Base,
    IN LONG64 Offset
    );

BOOLEAN
_bittestandset64 (
    IN LONG64 *Base,
    IN LONG64 Offset
    );

BOOLEAN
_bittestandreset64 (
    IN LONG64 *Base,
    IN LONG64 Offset
    );

#pragma intrinsic(_bittest)
#pragma intrinsic(_bittestandcomplement)
#pragma intrinsic(_bittestandset)
#pragma intrinsic(_bittestandreset)

#pragma intrinsic(_bittest64)
#pragma intrinsic(_bittestandcomplement64)
#pragma intrinsic(_bittestandset64)
#pragma intrinsic(_bittestandreset64)

//
// Define bit scan intrinsics.
//

#define BitScanForward _BitScanForward
#define BitScanReverse _BitScanReverse
#define BitScanForward64 _BitScanForward64
#define BitScanReverse64 _BitScanReverse64

BOOLEAN
_BitScanForward (
    OUT ULONG *Index,
    IN ULONG Mask
    );

BOOLEAN
_BitScanReverse (
    OUT ULONG *Index,
    IN ULONG Mask
    );

BOOLEAN
_BitScanForward64 (
    OUT ULONG *Index,
    IN ULONG64 Mask
    );

BOOLEAN
_BitScanReverse64 (
    OUT ULONG *Index,
    IN ULONG64 Mask
    );

#pragma intrinsic(_BitScanForward)
#pragma intrinsic(_BitScanReverse)
#pragma intrinsic(_BitScanForward64)
#pragma intrinsic(_BitScanReverse64)

#define InterlockedCompareExchange16 _InterlockedCompareExchange16

SHORT
_InterlockedCompareExchange16 (
    __inout SHORT volatile *Destination,
    __in SHORT ExChange,
    __in SHORT Comperand
    );

#pragma intrinsic(_InterlockedCompareExchange16)

#ifdef __cplusplus
}
#endif

#define InterlockedAdd 				_InterlockedAdd
#define InterlockedAddAcquire 			_InterlockedAdd_acq
#define InterlockedAddRelease 			_InterlockedAdd_rel

#define InterlockedIncrement 			_InterlockedIncrement
#define InterlockedIncrementAcquire 		_InterlockedIncrement_acq
#define InterlockedIncrementRelease 		_InterlockedIncrement_rel

#define InterlockedDecrement 			_InterlockedDecrement
#define InterlockedDecrementAcquire 		_InterlockedDecrement_acq
#define InterlockedDecrementRelease 		_InterlockedDecrement_rel

#define InterlockedExchange 			_InterlockedExchange
#define InterlockedExchangeAcquire 		_InterlockedExchange_acq

#define InterlockedExchangeAdd 			_InterlockedExchangeAdd
#define InterlockedExchangeAddAcquire 		_InterlockedExchangeAdd_acq
#define InterlockedExchangeAddRelease 		_InterlockedExchangeAdd_rel

#define InterlockedAdd64 			_InterlockedAdd64
#define InterlockedAddAcquire64 		_InterlockedAdd64_acq
#define InterlockedAddRelease64 		_InterlockedAdd64_rel

#define InterlockedIncrement64 			_InterlockedIncrement64
#define InterlockedIncrementAcquire64 		_InterlockedIncrement64_acq
#define InterlockedIncrementRelease64 		_InterlockedIncrement64_rel

#define InterlockedDecrement64 			_InterlockedDecrement64
#define InterlockedDecrementAcquire64 		_InterlockedDecrement64_acq
#define InterlockedDecrementRelease64 		_InterlockedDecrement64_rel

#define InterlockedExchange64 			_InterlockedExchange64
#define InterlockedExchangeAcquire64 		_InterlockedExchange64_acq

#define InterlockedExchangeAdd64 		_InterlockedExchangeAdd64
#define InterlockedExchangeAddAcquire64 	_InterlockedExchangeAdd64_acq
#define InterlockedExchangeAddRelease64 	_InterlockedExchangeAdd64_rel

#define InterlockedCompareExchange64 		_InterlockedCompareExchange64
#define InterlockedCompareExchangeAcquire64 	_InterlockedCompareExchange64_acq
#define InterlockedCompareExchangeRelease64 	_InterlockedCompareExchange64_rel

#define InterlockedCompare64Exchange128     _InterlockedCompare64Exchange128
#define InterlockedCompare64ExchangeAcquire128  _InterlockedCompare64Exchange128_acq
#define InterlockedCompare64ExchangeRelease128  _InterlockedCompare64Exchange128_rel

#define InterlockedCompareExchange 		_InterlockedCompareExchange
#define InterlockedCompareExchangeAcquire 	_InterlockedCompareExchange_acq
#define InterlockedCompareExchangeRelease 	_InterlockedCompareExchange_rel

#define InterlockedExchangePointer 		_InterlockedExchangePointer
#define InterlockedExchangePointerAcquire       _InterlockedExchangePointer_acq

#define InterlockedCompareExchangePointer 	 _InterlockedCompareExchangePointer
#define InterlockedCompareExchangePointerRelease _InterlockedCompareExchangePointer_rel
#define InterlockedCompareExchangePointerAcquire _InterlockedCompareExchangePointer_acq


#define InterlockedExchangeAddSizeT(a, b) InterlockedExchangeAdd64((LONG64 *)a, b)
#define InterlockedIncrementSizeT(a) InterlockedIncrement64((LONG64 *)a)
#define InterlockedDecrementSizeT(a) InterlockedDecrement64((LONG64 *)a)

#define InterlockedOr       _InterlockedOr
#define InterlockedOrAcquire   _InterlockedOr_acq
#define InterlockedOrRelease   _InterlockedOr_rel
#define InterlockedOr8      _InterlockedOr8
#define InterlockedOr8Acquire  _InterlockedOr8_acq
#define InterlockedOr8Release  _InterlockedOr8_rel
#define InterlockedOr16     _InterlockedOr16
#define InterlockedOr16Acquire _InterlockedOr16_acq
#define InterlockedOr16Release _InterlockedOr16_rel
#define InterlockedOr64     _InterlockedOr64
#define InterlockedOr64Acquire _InterlockedOr64_acq
#define InterlockedOr64Release _InterlockedOr64_rel
#define InterlockedXor      _InterlockedXor
#define InterlockedXorAcquire  _InterlockedXor_acq
#define InterlockedXorRelease  _InterlockedXor_rel
#define InterlockedXor8     _InterlockedXor8
#define InterlockedXor8Acquire _InterlockedXor8_acq
#define InterlockedXor8Release _InterlockedXor8_rel
#define InterlockedXor16    _InterlockedXor16
#define InterlockedXor16Acquire _InterlockedXor16_acq
#define InterlockedXor16Release _InterlockedXor16_rel
#define InterlockedXor64     _InterlockedXor64
#define InterlockedXor64Acquire _InterlockedXor64_acq
#define InterlockedXor64Release _InterlockedXor64_rel
#define InterlockedAnd       _InterlockedAnd
#define InterlockedAndAcquire   _InterlockedAnd_acq
#define InterlockedAndRelease   _InterlockedAnd_rel
#define InterlockedAnd8      _InterlockedAnd8
#define InterlockedAnd8Acquire  _InterlockedAnd8_acq
#define InterlockedAnd8Release  _InterlockedAnd8_rel
#define InterlockedAnd16     _InterlockedAnd16
#define InterlockedAnd16Acquire _InterlockedAnd16_acq
#define InterlockedAnd16Release _InterlockedAnd16_rel
#define InterlockedAnd64     _InterlockedAnd64
#define InterlockedAnd64Acquire _InterlockedAnd64_acq
#define InterlockedAnd64Release _InterlockedAnd64_rel

#ifdef __cplusplus
extern "C" {
#endif

LONG
__cdecl
InterlockedAdd (
    LONG volatile *Addend,
    LONG Value
    );

LONG
__cdecl
InterlockedAddAcquire (
    LONG volatile *Addend,
    LONG Value
    );

LONG
__cdecl
InterlockedAddRelease (
    LONG volatile *Addend,
    LONG Value
    );
    
LONGLONG
__cdecl
InterlockedAdd64 (
    LONGLONG volatile *Addend,
    LONGLONG Value
    );

LONGLONG
__cdecl
InterlockedAddAcquire64 (
    LONGLONG volatile *Addend,
    LONGLONG Value
    );


LONGLONG
__cdecl
InterlockedAddRelease64 (
    LONGLONG volatile *Addend,
    LONGLONG Value
    );

LONG
__cdecl
InterlockedIncrement(
    IN OUT LONG volatile *Addend
    );

LONG
__cdecl
InterlockedDecrement(
    IN OUT LONG volatile *Addend
    );

LONG
__cdecl
InterlockedIncrementAcquire(
    IN OUT LONG volatile *Addend
    );

LONG
__cdecl
InterlockedDecrementAcquire(
    IN OUT LONG volatile *Addend
    );

LONG
__cdecl
InterlockedIncrementRelease(
    IN OUT LONG volatile *Addend
    );

LONG
__cdecl
InterlockedDecrementRelease(
    IN OUT LONG volatile *Addend
    );

LONG
__cdecl
InterlockedExchange(
    IN OUT LONG volatile *Target,
    IN LONG Value
    );

LONG
__cdecl
InterlockedExchangeAcquire(
    IN OUT LONG volatile *Target,
    IN LONG Value
    );

LONG
__cdecl
InterlockedExchangeAdd(
    IN OUT LONG volatile *Addend,
    IN LONG Value
    );

LONG
__cdecl
InterlockedExchangeAddAcquire(
    IN OUT LONG volatile *Addend,
    IN LONG Value
    );

LONG
__cdecl
InterlockedExchangeAddRelease(
    IN OUT LONG volatile *Addend,
    IN LONG Value
    );
LONG
__cdecl
InterlockedCompareExchange (
    IN OUT LONG volatile *Destination,
    IN LONG ExChange,
    IN LONG Comperand
    );


LONG
__cdecl
InterlockedCompareExchangeRelease (
    IN OUT LONG volatile *Destination,
    IN LONG ExChange,
    IN LONG Comperand
    );


LONG
__cdecl
InterlockedCompareExchangeAcquire (
    IN OUT LONG volatile *Destination,
    IN LONG ExChange,
    IN LONG Comperand
    );


LONGLONG
__cdecl
InterlockedIncrement64(
    IN OUT LONGLONG volatile *Addend
    );

LONGLONG
__cdecl
InterlockedIncrementAcquire64(
    IN OUT LONGLONG volatile *Addend
    );

LONGLONG
__cdecl
InterlockedIncrementRelease64(
    IN OUT LONGLONG volatile *Addend
    );

LONGLONG
__cdecl
InterlockedDecrement64(
    IN OUT LONGLONG volatile *Addend
    );

LONGLONG
__cdecl
InterlockedDecrementAcquire64(
    IN OUT LONGLONG volatile *Addend
    );

LONGLONG
__cdecl
InterlockedDecrementRelease64(
    IN OUT LONGLONG volatile *Addend
    );

LONGLONG
__cdecl
InterlockedExchange64(
    IN OUT LONGLONG volatile *Target,
    IN LONGLONG Value
    );

LONGLONG
__cdecl
InterlockedExchangeAcquire64(
    IN OUT LONGLONG volatile *Target,
    IN LONGLONG Value
    );

LONGLONG
__cdecl
InterlockedExchangeAdd64(
    IN OUT LONGLONG volatile *Addend,
    IN LONGLONG Value
    );

LONGLONG
__cdecl
InterlockedExchangeAddAcquire64(
    IN OUT LONGLONG volatile *Addend,
    IN LONGLONG Value
    );

LONGLONG
__cdecl
InterlockedExchangeAddRelease64(
    IN OUT LONGLONG volatile *Addend,
    IN LONGLONG Value
    );

LONGLONG
__cdecl
InterlockedCompareExchange64 (
    IN OUT LONGLONG volatile *Destination,
    IN LONGLONG ExChange,
    IN LONGLONG Comperand
    );

LONGLONG
__cdecl
InterlockedCompareExchangeAcquire64 (
    IN OUT LONGLONG volatile *Destination,
    IN LONGLONG ExChange,
    IN LONGLONG Comperand
    );

LONGLONG
__cdecl
InterlockedCompareExchangeRelease64 (
    IN OUT LONGLONG volatile *Destination,
    IN LONGLONG ExChange,
    IN LONGLONG Comperand
    );

LONG64
__cdecl
InterlockedCompare64Exchange128(
    __inout LONG64 volatile * Destination,
    __in LONG64 ExchangeHigh,
    __in LONG64 ExchangeLow,
    __in LONG64 Comperand
    );

LONG64
__cdecl
InterlockedCompare64ExchangeAcquire128(
    __inout LONG64 volatile * Destination,
    __in LONG64 ExchangeHigh,
    __in LONG64 ExchangeLow,
    __in LONG64 Comperand
    );

LONG64
__cdecl
InterlockedCompare64ExchangeRelease128(
    __inout LONG64 volatile * Destination,
    __in LONG64 ExchangeHigh,
    __in LONG64 ExchangeLow,
    __in LONG64 Comperand
    );

PVOID
__cdecl
InterlockedCompareExchangePointer (
    IN OUT PVOID volatile *Destination,
    IN PVOID Exchange,
    IN PVOID Comperand
    );

PVOID
__cdecl
InterlockedCompareExchangePointerAcquire (
    IN OUT PVOID volatile *Destination,
    IN PVOID Exchange,
    IN PVOID Comperand
    );

PVOID
__cdecl
InterlockedCompareExchangePointerRelease (
    IN OUT PVOID volatile *Destination,
    IN PVOID Exchange,
    IN PVOID Comperand
    );

PVOID
__cdecl
InterlockedExchangePointer(
    IN OUT PVOID volatile *Target,
    IN PVOID Value
    );

PVOID
__cdecl
InterlockedExchangePointerAcquire(
    IN OUT PVOID volatile *Target,
    IN PVOID Value
    );

LONG
__cdecl
InterlockedOr (
    IN OUT LONG volatile *Destination,
    IN LONG Value
    );

LONG
__cdecl
InterlockedOrAcquire (
    IN OUT LONG volatile *Destination,
    IN LONG Value
    );
    
LONG
__cdecl
InterlockedOrRelease (
    IN OUT LONG volatile *Destination,
    IN LONG Value
    );

CHAR
__cdecl
InterlockedOr8 (
    IN OUT CHAR volatile *Destination,
    IN    CHAR Value
    );

CHAR
__cdecl
InterlockedOr8Acquire (
    IN OUT CHAR volatile *Destination,
    IN    CHAR Value
    );

CHAR
__cdecl
InterlockedOr8Release (
    IN OUT CHAR volatile *Destination,
    IN CHAR Value
    );

SHORT
__cdecl
InterlockedOr16(
    IN OUT SHORT volatile *Destination,
    IN SHORT Value
    );
    
SHORT
__cdecl
InterlockedOr16Acquire (
    IN OUT SHORT volatile *Destination,
    IN SHORT Value
    );

SHORT
__cdecl
InterlockedOr16Release (
    IN OUT SHORT volatile *Destination,
    IN SHORT Value
    );

LONGLONG
__cdecl
InterlockedOr64 (
    IN OUT LONGLONG volatile *Destination,
    IN LONGLONG Value
    );

LONGLONG
__cdecl
InterlockedOr64Acquire (
    IN OUT LONGLONG volatile *Destination,
    IN LONGLONG Value
    );
    
LONGLONG
__cdecl
InterlockedOr64Release (
    IN OUT LONGLONG volatile *Destination,
    IN LONGLONG Value
    );

LONG
__cdecl
InterlockedXor (
    IN OUT LONG volatile *Destination,
    IN LONG Value
    );

LONG
__cdecl
InterlockedXorAcquire (
    IN OUT LONG volatile *Destination,
    IN LONG Value
    );
    
LONG
__cdecl
InterlockedXorRelease (
    IN OUT LONG volatile *Destination,
    IN LONG Value
    );

CHAR
__cdecl
InterlockedXor8 (
    IN OUT CHAR volatile *Destination,
    IN CHAR Value
    );

CHAR
__cdecl
InterlockedXor8Acquire (
    IN OUT CHAR volatile *Destination,
    IN CHAR Value
    );

CHAR
__cdecl
InterlockedXor8Release (
    IN OUT CHAR volatile *Destination,
    IN CHAR Value
    );

SHORT
__cdecl
InterlockedXor16(
    IN OUT SHORT volatile *Destination,
    IN SHORT Value
    );
    
SHORT
__cdecl
InterlockedXor16Acquire (
    IN OUT SHORT volatile *Destination,
    IN SHORT Value
    );

SHORT
__cdecl
InterlockedXor16Release (
    IN OUT SHORT volatile *Destination,
    IN SHORT Value
    );

LONGLONG
__cdecl
InterlockedXor64 (
    IN OUT LONGLONG volatile *Destination,
    IN LONGLONG Value
    );

LONGLONG
__cdecl
InterlockedXor64Acquire (
    IN OUT LONGLONG volatile *Destination,
    IN LONGLONG Value
    );
    
LONGLONG
__cdecl
InterlockedXor64Release (
    IN OUT LONGLONG volatile *Destination,
    IN LONGLONG Value
    );

LONG
__cdecl
InterlockedAnd (
    IN OUT LONG volatile *Destination,
    IN LONG Value
    );

LONG
__cdecl
InterlockedAndAcquire (
    IN OUT LONG volatile *Destination,
    IN LONG Value
    );
    
LONG
__cdecl
InterlockedAndRelease (
    IN OUT LONG volatile *Destination,
    IN LONG Value
    );

CHAR
__cdecl
InterlockedAnd8 (
    IN OUT CHAR volatile *Destination,
    IN CHAR Value
    );

CHAR
__cdecl
InterlockedAnd8Acquire (
    IN OUT CHAR volatile *Destination,
    IN CHAR Value
    );

CHAR
__cdecl
InterlockedAnd8Release (
    IN OUT CHAR volatile *Destination,
    IN CHAR Value
    );

SHORT
__cdecl
InterlockedAnd16(
    IN OUT SHORT volatile *Destination,
    IN SHORT Value
    );
    
SHORT
__cdecl
InterlockedAnd16Acquire (
    IN OUT SHORT volatile *Destination,
    IN SHORT Value
    );

SHORT
__cdecl
InterlockedAnd16Release (
    IN OUT SHORT volatile *Destination,
    IN SHORT Value
    );

LONGLONG
__cdecl
InterlockedAnd64 (
    IN OUT LONGLONG volatile *Destination,
    IN LONGLONG Value
    );

LONGLONG
__cdecl
InterlockedAnd64Acquire (
    IN OUT LONGLONG volatile *Destination,
    IN LONGLONG Value
    );
    
LONGLONG
__cdecl
InterlockedAnd64Release (
    IN OUT LONGLONG volatile *Destination,
    IN LONGLONG Value
    );

#pragma intrinsic(_InterlockedAdd)
#pragma intrinsic(_InterlockedIncrement)
#pragma intrinsic(_InterlockedIncrement_acq)
#pragma intrinsic(_InterlockedIncrement_rel)
#pragma intrinsic(_InterlockedDecrement)
#pragma intrinsic(_InterlockedDecrement_acq)
#pragma intrinsic(_InterlockedDecrement_rel)
#pragma intrinsic(_InterlockedExchange)
#pragma intrinsic(_InterlockedCompareExchange)
#pragma intrinsic(_InterlockedCompareExchange_acq)
#pragma intrinsic(_InterlockedCompareExchange_rel)
#pragma intrinsic(_InterlockedExchangeAdd)
#pragma intrinsic(_InterlockedAdd64)
#pragma intrinsic(_InterlockedIncrement64)
#pragma intrinsic(_InterlockedDecrement64)
#pragma intrinsic(_InterlockedExchange64)
#pragma intrinsic(_InterlockedExchange64_acq)
#pragma intrinsic(_InterlockedCompareExchange64)
#pragma intrinsic(_InterlockedCompareExchange64_acq)
#pragma intrinsic(_InterlockedCompareExchange64_rel)
#pragma intrinsic(_InterlockedCompare64Exchange128)
#pragma intrinsic(_InterlockedCompare64Exchange128_acq)
#pragma intrinsic(_InterlockedCompare64Exchange128_rel)
#pragma intrinsic(_InterlockedExchangeAdd64)
#pragma intrinsic(_InterlockedExchangePointer)
#pragma intrinsic(_InterlockedCompareExchangePointer)
#pragma intrinsic(_InterlockedCompareExchangePointer_acq)
#pragma intrinsic(_InterlockedCompareExchangePointer_rel)
#pragma intrinsic(_InterlockedAdd_acq)
#pragma intrinsic(_InterlockedAdd_rel)
#pragma intrinsic(_InterlockedExchange_acq)
#pragma intrinsic(_InterlockedExchangeAdd_acq)
#pragma intrinsic(_InterlockedExchangeAdd_rel)
#pragma intrinsic(_InterlockedAdd64_acq)
#pragma intrinsic(_InterlockedAdd64_rel)
#pragma intrinsic(_InterlockedIncrement64_acq)
#pragma intrinsic(_InterlockedIncrement64_rel)
#pragma intrinsic(_InterlockedDecrement64_acq)
#pragma intrinsic(_InterlockedDecrement64_rel)
#pragma intrinsic(_InterlockedExchangeAdd64_acq)
#pragma intrinsic(_InterlockedExchangeAdd64_rel)
#pragma intrinsic(_InterlockedExchangePointer_acq)
#pragma intrinsic (_InterlockedOr)
#pragma intrinsic (_InterlockedOr_acq)
#pragma intrinsic (_InterlockedOr_rel)
#pragma intrinsic (_InterlockedOr8)
#pragma intrinsic (_InterlockedOr8_acq)
#pragma intrinsic (_InterlockedOr8_rel)
#pragma intrinsic (_InterlockedOr16)
#pragma intrinsic (_InterlockedOr16_acq)
#pragma intrinsic (_InterlockedOr16_rel)
#pragma intrinsic (_InterlockedOr64)
#pragma intrinsic (_InterlockedOr64_acq)
#pragma intrinsic (_InterlockedOr64_rel)
#pragma intrinsic (_InterlockedXor)
#pragma intrinsic (_InterlockedXor_acq)
#pragma intrinsic (_InterlockedXor_rel)
#pragma intrinsic (_InterlockedXor8)
#pragma intrinsic (_InterlockedXor8_acq)
#pragma intrinsic (_InterlockedXor8_rel)
#pragma intrinsic (_InterlockedXor16)
#pragma intrinsic (_InterlockedXor16_acq)
#pragma intrinsic (_InterlockedXor16_rel)
#pragma intrinsic (_InterlockedXor64)
#pragma intrinsic (_InterlockedXor64_acq)
#pragma intrinsic (_InterlockedXor64_rel)
#pragma intrinsic (_InterlockedAnd)
#pragma intrinsic (_InterlockedAnd_acq)
#pragma intrinsic (_InterlockedAnd_rel)
#pragma intrinsic (_InterlockedAnd8)
#pragma intrinsic (_InterlockedAnd8_acq)
#pragma intrinsic (_InterlockedAnd8_rel)
#pragma intrinsic (_InterlockedAnd16)
#pragma intrinsic (_InterlockedAnd16_acq)
#pragma intrinsic (_InterlockedAnd16_rel)
#pragma intrinsic (_InterlockedAnd64)
#pragma intrinsic (_InterlockedAnd64_acq)
#pragma intrinsic (_InterlockedAnd64_rel)

#if !defined (InterlockedAnd64)

#define InterlockedAnd64 InterlockedAnd64_Inline

LONGLONG
FORCEINLINE
InterlockedAnd64_Inline (
    IN OUT LONGLONG volatile *Destination,
    IN LONGLONG Value
    )
{
    LONGLONG Old;

    do {
        Old = *Destination;
    } while (InterlockedCompareExchange64(Destination,
                                          Old & Value,
                                          Old) != Old);

    return Old;
}

#endif

#define InterlockedAndAffinity InterlockedAnd64

#if !defined (InterlockedOr64)

#define InterlockedOr64 InterlockedOr64_Inline

LONGLONG
FORCEINLINE
InterlockedOr64_Inline (
    IN OUT LONGLONG volatile *Destination,
    IN LONGLONG Value
    )
{
    LONGLONG Old;

    do {
        Old = *Destination;
    } while (InterlockedCompareExchange64(Destination,
                                          Old | Value,
                                          Old) != Old);

    return Old;
}

#endif

#define InterlockedOrAffinity InterlockedOr64

#if !defined (InterlockedXor64)

#define InterlockedXor64 InterlockedXor64_Inline

LONGLONG
FORCEINLINE
InterlockedXor64_Inline (
    IN OUT LONGLONG volatile *Destination,
    IN LONGLONG Value
    )
{
    LONGLONG Old;

    do {
        Old = *Destination;
    } while (InterlockedCompareExchange64(Destination,
                                          Old ^ Value,
                                          Old) != Old);

    return Old;
}

#endif

#if !defined (InterlockedBitTestAndSet)

#define InterlockedBitTestAndSet InterlockedBitTestAndSet_Inline

BOOLEAN
FORCEINLINE
InterlockedBitTestAndSet_Inline (
    IN LONG volatile *Base,
    IN LONG Bit
    )
{
    LONG tBit;

    tBit = 1<<(Bit & (sizeof (*Base)*8-1));
    return (BOOLEAN) ((InterlockedOr (&Base[Bit/(sizeof (*Base)*8)], tBit)&tBit) != 0);
}

#endif

#if !defined (InterlockedBitTestAndReset)

#define InterlockedBitTestAndReset InterlockedBitTestAndReset_Inline

BOOLEAN
FORCEINLINE
InterlockedBitTestAndReset_Inline (
    IN LONG volatile *Base,
    IN LONG Bit
    )
{
    LONG tBit;

    tBit = 1<<(Bit & (sizeof (*Base)*8-1));
    return (BOOLEAN) ((InterlockedAnd (&Base[Bit/(sizeof (*Base)*8)], ~tBit)&tBit) != 0);
}

#endif

#if !defined (InterlockedBitTestAndSet64)

#define InterlockedBitTestAndSet64 InterlockedBitTestAndSet64_Inline

BOOLEAN
FORCEINLINE
InterlockedBitTestAndSet64_Inline (
    IN LONG64 volatile *Base,
    IN LONG64 Bit
    )
{
    LONG64 tBit;

    tBit = 1i64<<(Bit & (sizeof (*Base)*8-1));
    return (BOOLEAN) ((InterlockedOr64 (&Base[Bit/(sizeof (*Base)*8)], tBit)&tBit) != 0);
}

#endif

#if !defined (InterlockedBitTestAndReset64)

#define InterlockedBitTestAndReset64 InterlockedBitTestAndReset64_Inline

BOOLEAN
FORCEINLINE
InterlockedBitTestAndReset64_Inline (
    IN LONG64 volatile *Base,
    IN LONG64 Bit
    )
{
    LONG64 tBit;

    tBit = 1i64<<(Bit & (sizeof (*Base)*8-1));
    return (BOOLEAN) ((InterlockedAnd64 (&Base[Bit/(sizeof (*Base)*8)], ~tBit)&tBit) != 0);
}

#endif

#if !defined (InterlockedBitTestAndComplement)

#define InterlockedBitTestAndComplement InterlockedBitTestAndComplement_Inline

BOOLEAN
FORCEINLINE
InterlockedBitTestAndComplement_Inline (
    IN LONG volatile *Base,
    IN LONG Bit
    )
{
    LONG tBit;

    tBit = 1<<(Bit & (sizeof (*Base)*8-1));
    return (BOOLEAN) ((InterlockedXor (&Base[Bit/(sizeof (*Base)*8)], tBit)&tBit) != 0);
}

#endif

#if !defined (InterlockedBitTestAndComplement64)

#define InterlockedBitTestAndComplement64 InterlockedBitTestAndComplement64_Inline

BOOLEAN
FORCEINLINE
InterlockedBitTestAndComplement64_Inline (
    IN LONG64 volatile *Base,
    IN LONG64 Bit
    )
{
    LONG64 tBit;

    tBit = 1i64<<(Bit & (sizeof (*Base)*8-1));
    return (BOOLEAN) ((InterlockedXor64 (&Base[Bit/(sizeof (*Base)*8)], tBit)&tBit) != 0);
}

#endif

#ifdef __cplusplus
}
#endif

#endif /* defined(_M_IA64) && !defined(RC_INVOKED) && !defined(MIDL_PASS) */


#if defined(_IA64_) && defined(_M_IA64) && !defined(RC_INVOKED) && !defined(MIDL_PASS)

void 
__break( 
    int
    );

#pragma intrinsic (__break)

#define BREAK_DEBUG_BASE    0x080000
#define ASSERT_BREAKPOINT         (BREAK_DEBUG_BASE+3)  // Cause a STATUS_ASSERTION_FAILURE exception to be raised.

#define DbgRaiseAssertionFailure() __break(ASSERT_BREAKPOINT)

#endif

#endif // _IA64_
//
//  Define an access token from a programmer's viewpoint.  The structure is
//  completely opaque and the programer is only allowed to have pointers
//  to tokens.
//

typedef PVOID PACCESS_TOKEN;            

//
// Pointer to a SECURITY_DESCRIPTOR  opaque data type.
//

typedef PVOID PSECURITY_DESCRIPTOR;     

//
// Define a pointer to the Security ID data type (an opaque data type)
//

typedef PVOID PSID;     

typedef ULONG ACCESS_MASK;
typedef ACCESS_MASK *PACCESS_MASK;


//
//  The following are masks for the predefined standard access types
//

#define DELETE                           (0x00010000L)
#define READ_CONTROL                     (0x00020000L)
#define WRITE_DAC                        (0x00040000L)
#define WRITE_OWNER                      (0x00080000L)
#define SYNCHRONIZE                      (0x00100000L)

#define STANDARD_RIGHTS_REQUIRED         (0x000F0000L)

#define STANDARD_RIGHTS_READ             (READ_CONTROL)
#define STANDARD_RIGHTS_WRITE            (READ_CONTROL)
#define STANDARD_RIGHTS_EXECUTE          (READ_CONTROL)

#define STANDARD_RIGHTS_ALL              (0x001F0000L)

#define SPECIFIC_RIGHTS_ALL              (0x0000FFFFL)

//
// AccessSystemAcl access type
//

#define ACCESS_SYSTEM_SECURITY           (0x01000000L)

//
// MaximumAllowed access type
//

#define MAXIMUM_ALLOWED                  (0x02000000L)

//
//  These are the generic rights.
//

#define GENERIC_READ                     (0x80000000L)
#define GENERIC_WRITE                    (0x40000000L)
#define GENERIC_EXECUTE                  (0x20000000L)
#define GENERIC_ALL                      (0x10000000L)


//
//  Define the generic mapping array.  This is used to denote the
//  mapping of each generic access right to a specific access mask.
//

typedef struct _GENERIC_MAPPING {
    ACCESS_MASK GenericRead;
    ACCESS_MASK GenericWrite;
    ACCESS_MASK GenericExecute;
    ACCESS_MASK GenericAll;
} GENERIC_MAPPING;
typedef GENERIC_MAPPING *PGENERIC_MAPPING;



////////////////////////////////////////////////////////////////////////
//                                                                    //
//                        LUID_AND_ATTRIBUTES                         //
//                                                                    //
////////////////////////////////////////////////////////////////////////
//
//


#include <pshpack4.h>

typedef struct _LUID_AND_ATTRIBUTES {
    LUID Luid;
    ULONG Attributes;
    } LUID_AND_ATTRIBUTES, * PLUID_AND_ATTRIBUTES;
typedef LUID_AND_ATTRIBUTES LUID_AND_ATTRIBUTES_ARRAY[ANYSIZE_ARRAY];
typedef LUID_AND_ATTRIBUTES_ARRAY *PLUID_AND_ATTRIBUTES_ARRAY;

#include <poppack.h>

// This is the *current* ACL revision

#define ACL_REVISION     (2)
#define ACL_REVISION_DS  (4)

// This is the history of ACL revisions.  Add a new one whenever
// ACL_REVISION is updated

#define ACL_REVISION1   (1)
#define MIN_ACL_REVISION ACL_REVISION2
#define ACL_REVISION2   (2)
#define ACL_REVISION3   (3)
#define ACL_REVISION4   (4)
#define MAX_ACL_REVISION ACL_REVISION4

typedef struct _ACL {
    UCHAR AclRevision;
    UCHAR Sbz1;
    USHORT AclSize;
    USHORT AceCount;
    USHORT Sbz2;
} ACL;
typedef ACL *PACL;

//
// Current security descriptor revision value
//

#define SECURITY_DESCRIPTOR_REVISION     (1)
#define SECURITY_DESCRIPTOR_REVISION1    (1)

//
// Privilege attributes
//

#define SE_PRIVILEGE_ENABLED_BY_DEFAULT (0x00000001L)
#define SE_PRIVILEGE_ENABLED            (0x00000002L)
#define SE_PRIVILEGE_REMOVED            (0X00000004L)
#define SE_PRIVILEGE_USED_FOR_ACCESS    (0x80000000L)

#define SE_PRIVILEGE_VALID_ATTRIBUTES   (SE_PRIVILEGE_ENABLED_BY_DEFAULT | \
                                         SE_PRIVILEGE_ENABLED            | \
                                         SE_PRIVILEGE_REMOVED            | \
                                         SE_PRIVILEGE_USED_FOR_ACCESS)


//
// Privilege Set Control flags
//

#define PRIVILEGE_SET_ALL_NECESSARY    (1)

//
//  Privilege Set - This is defined for a privilege set of one.
//                  If more than one privilege is needed, then this structure
//                  will need to be allocated with more space.
//
//  Note: don't change this structure without fixing the INITIAL_PRIVILEGE_SET
//  structure (defined in se.h)
//

typedef struct _PRIVILEGE_SET {
    ULONG PrivilegeCount;
    ULONG Control;
    LUID_AND_ATTRIBUTES Privilege[ANYSIZE_ARRAY];
    } PRIVILEGE_SET, * PPRIVILEGE_SET;

//
// These must be converted to LUIDs before use.
//

#define SE_MIN_WELL_KNOWN_PRIVILEGE         (2L)
#define SE_CREATE_TOKEN_PRIVILEGE           (2L)
#define SE_ASSIGNPRIMARYTOKEN_PRIVILEGE     (3L)
#define SE_LOCK_MEMORY_PRIVILEGE            (4L)
#define SE_INCREASE_QUOTA_PRIVILEGE         (5L)

#define SE_MACHINE_ACCOUNT_PRIVILEGE        (6L)
#define SE_TCB_PRIVILEGE                    (7L)
#define SE_SECURITY_PRIVILEGE               (8L)
#define SE_TAKE_OWNERSHIP_PRIVILEGE         (9L)
#define SE_LOAD_DRIVER_PRIVILEGE            (10L)
#define SE_SYSTEM_PROFILE_PRIVILEGE         (11L)
#define SE_SYSTEMTIME_PRIVILEGE             (12L)
#define SE_PROF_SINGLE_PROCESS_PRIVILEGE    (13L)
#define SE_INC_BASE_PRIORITY_PRIVILEGE      (14L)
#define SE_CREATE_PAGEFILE_PRIVILEGE        (15L)
#define SE_CREATE_PERMANENT_PRIVILEGE       (16L)
#define SE_BACKUP_PRIVILEGE                 (17L)
#define SE_RESTORE_PRIVILEGE                (18L)
#define SE_SHUTDOWN_PRIVILEGE               (19L)
#define SE_DEBUG_PRIVILEGE                  (20L)
#define SE_AUDIT_PRIVILEGE                  (21L)
#define SE_SYSTEM_ENVIRONMENT_PRIVILEGE     (22L)
#define SE_CHANGE_NOTIFY_PRIVILEGE          (23L)
#define SE_REMOTE_SHUTDOWN_PRIVILEGE        (24L)
#define SE_UNDOCK_PRIVILEGE                 (25L)
#define SE_SYNC_AGENT_PRIVILEGE             (26L)
#define SE_ENABLE_DELEGATION_PRIVILEGE      (27L)
#define SE_MANAGE_VOLUME_PRIVILEGE          (28L)
#define SE_IMPERSONATE_PRIVILEGE            (29L)
#define SE_CREATE_GLOBAL_PRIVILEGE          (30L)
#define SE_TRUSTED_CREDMAN_ACCESS_PRIVILEGE (31L)
#define SE_RELABEL_PRIVILEGE                (32L)
#define SE_INC_WORKING_SET_PRIVILEGE        (33L)
#define SE_TIME_ZONE_PRIVILEGE              (34L)
#define SE_CREATE_SYMBOLIC_LINK_PRIVILEGE   (35L)
#define SE_MAX_WELL_KNOWN_PRIVILEGE         (SE_CREATE_SYMBOLIC_LINK_PRIVILEGE)

//
// Impersonation Level
//
// Impersonation level is represented by a pair of bits in Windows.
// If a new impersonation level is added or lowest value is changed from
// 0 to something else, fix the Windows CreateFile call.
//

typedef enum _SECURITY_IMPERSONATION_LEVEL {
    SecurityAnonymous,
    SecurityIdentification,
    SecurityImpersonation,
    SecurityDelegation
    } SECURITY_IMPERSONATION_LEVEL, * PSECURITY_IMPERSONATION_LEVEL;

#define SECURITY_MAX_IMPERSONATION_LEVEL SecurityDelegation
#define SECURITY_MIN_IMPERSONATION_LEVEL SecurityAnonymous
#define DEFAULT_IMPERSONATION_LEVEL SecurityImpersonation
#define VALID_IMPERSONATION_LEVEL(L) (((L) >= SECURITY_MIN_IMPERSONATION_LEVEL) && ((L) <= SECURITY_MAX_IMPERSONATION_LEVEL))
//
// Security Tracking Mode
//

#define SECURITY_DYNAMIC_TRACKING      (TRUE)
#define SECURITY_STATIC_TRACKING       (FALSE)

typedef BOOLEAN SECURITY_CONTEXT_TRACKING_MODE,
                    * PSECURITY_CONTEXT_TRACKING_MODE;



//
// Quality Of Service
//

typedef struct _SECURITY_QUALITY_OF_SERVICE {
    ULONG Length;
    SECURITY_IMPERSONATION_LEVEL ImpersonationLevel;
    SECURITY_CONTEXT_TRACKING_MODE ContextTrackingMode;
    BOOLEAN EffectiveOnly;
    } SECURITY_QUALITY_OF_SERVICE, * PSECURITY_QUALITY_OF_SERVICE;


//
// Used to represent information related to a thread impersonation
//

typedef struct _SE_IMPERSONATION_STATE {
    PACCESS_TOKEN Token;
    BOOLEAN CopyOnOpen;
    BOOLEAN EffectiveOnly;
    SECURITY_IMPERSONATION_LEVEL Level;
} SE_IMPERSONATION_STATE, *PSE_IMPERSONATION_STATE;


typedef ULONG SECURITY_INFORMATION, *PSECURITY_INFORMATION;

#define OWNER_SECURITY_INFORMATION       (0x00000001L)
#define GROUP_SECURITY_INFORMATION       (0x00000002L)
#define DACL_SECURITY_INFORMATION        (0x00000004L)
#define SACL_SECURITY_INFORMATION        (0x00000008L)
#define LABEL_SECURITY_INFORMATION       (0x00000010L)

#define PROTECTED_DACL_SECURITY_INFORMATION     (0x80000000L)
#define PROTECTED_SACL_SECURITY_INFORMATION     (0x40000000L)
#define UNPROTECTED_DACL_SECURITY_INFORMATION   (0x20000000L)
#define UNPROTECTED_SACL_SECURITY_INFORMATION   (0x10000000L)

// begin_ntsecapi
#ifndef _NTLSA_IFS_


//
// All of this stuff (between the Ifndef _NTLSA_AUDIT_ and its endif) were not
// present in NTIFS prior to Windows Server 2003 SP1. All of the definitions however
// exist down to windows 2000 (except for the few exceptions noted in the code).
//

#ifndef _NTLSA_AUDIT_
#define _NTLSA_AUDIT_

/////////////////////////////////////////////////////////////////////////
//                                                                     //
// Data types related to Auditing                                      //
//                                                                     //
/////////////////////////////////////////////////////////////////////////


//
// The following enumerated type is used between the reference monitor and
// LSA in the generation of audit messages.  It is used to indicate the
// type of data being passed as a parameter from the reference monitor
// to LSA.  LSA is responsible for transforming the specified data type
// into a set of unicode strings that are added to the event record in
// the audit log.
//

typedef enum _SE_ADT_PARAMETER_TYPE {

    SeAdtParmTypeNone = 0,          //Produces 1 parameter
                                    //Received value:
                                    //
                                    //  None.
                                    //
                                    //Results in:
                                    //
                                    //  a unicode string containing "-".
                                    //
                                    //Note:  This is typically used to
                                    //       indicate that a parameter value
                                    //       was not available.
                                    //

    SeAdtParmTypeString,            //Produces 1 parameter.
                                    //Received Value:
                                    //
                                    //  Unicode String (variable length)
                                    //
                                    //Results in:
                                    //
                                    //  No transformation.  The string
                                    //  entered into the event record as
                                    //  received.
                                    //
                                    // The Address value of the audit info
                                    // should be a pointer to a UNICODE_STRING
                                    // structure.



    SeAdtParmTypeFileSpec,          //Produces 1 parameter.
                                    //Received value:
                                    //
                                    //  Unicode string containing a file or
                                    //  directory name.
                                    //
                                    //Results in:
                                    //
                                    //  Unicode string with the prefix of the
                                    //  file's path replaced by a drive letter
                                    //  if possible.
                                    //




    SeAdtParmTypeUlong,             //Produces 1 parameter
                                    //Received value:
                                    //
                                    //  Ulong
                                    //
                                    //Results in:
                                    //
                                    //  Unicode string representation of
                                    //  unsigned integer value.


    SeAdtParmTypeSid,               //Produces 1 parameter.
                                    //Received value:
                                    //
                                    //  SID (variable length)
                                    //
                                    //Results in:
                                    //
                                    //  String representation of SID
                                    //




    SeAdtParmTypeLogonId,           //Produces 4 parameters.
                                    //Received Value:
                                    //
                                    //  LUID (fixed length)
                                    //
                                    //Results in:
                                    //
                                    //  param 1: Sid string
                                    //  param 2: Username string
                                    //  param 3: domain name string
                                    //  param 4: Logon ID (Luid) string


    SeAdtParmTypeNoLogonId,         //Produces 3 parameters.
                                    //Received value:
                                    //
                                    //  None.
                                    //
                                    //Results in:
                                    //
                                    //  param 1: "-"
                                    //  param 2: "-"
                                    //  param 3: "-"
                                    //  param 4: "-"
                                    //
                                    //Note:
                                    //
                                    //  This type is used when a logon ID
                                    //  is needed, but one is not available
                                    //  to pass.  For example, if an
                                    //  impersonation logon ID is expected
                                    //  but the subject is not impersonating
                                    //  anyone.
                                    //

    SeAdtParmTypeAccessMask,        //Produces 1 parameter with formatting.
                                    //Received value:
                                    //
                                    //  ACCESS_MASK followed by
                                    //  a Unicode string.  The unicode
                                    //  string contains the name of the
                                    //  type of object the access mask
                                    //  applies to.  The event's source
                                    //  further qualifies the object type.
                                    //
                                    //Results in:
                                    //
                                    //  formatted unicode string built to
                                    //  take advantage of the specified
                                    //  source's parameter message file.
                                    //
                                    //Note:
                                    //
                                    //  An access mask containing three
                                    //  access types for a Widget object
                                    //  type (defined by the Foozle source)
                                    //  might end up looking like:
                                    //
                                    //      %%1062\n\t\t%1066\n\t\t%%601
                                    //
                                    //  The %%numbers are signals to the
                                    //  event viewer to perform parameter
                                    //  substitution before display.
                                    //



    SeAdtParmTypePrivs,             //Produces 1 parameter with formatting.
                                    //Received value:
                                    //
                                    //Results in:
                                    //
                                    //  formatted unicode string similar to
                                    //  that for access types.  Each priv
                                    //  will be formatted to be displayed
                                    //  on its own line.  E.g.,
                                    //
                                    //      %%642\n\t\t%%651\n\t\t%%655
                                    //

    SeAdtParmTypeObjectTypes,       //Produces 10 parameters with formatting.
                                    //Received value:
                                    //
                                    // Produces a list a stringized GUIDS along
                                    // with information similar to that for
                                    // an access mask.

    SeAdtParmTypeHexUlong,          //Produces 1 parameter
                                    //Received value:
                                    //
                                    //  Ulong
                                    //
                                    //Results in:
                                    //
                                    //  Unicode string representation of
                                    //  unsigned integer value in hexadecimal.

// In W2k this value did not exist, it was ParmTypeLUID

    SeAdtParmTypePtr,               //Produces 1 parameter
                                    //Received value:
                                    //
                                    //  pointer
                                    //
                                    //Results in:
                                    //
                                    //  Unicode string representation of
                                    //  unsigned integer value in hexadecimal.

//
// Everything below exists only in Windows XP and greater
//

    SeAdtParmTypeTime,              //Produces 2 parameters
                                    //Received value:
                                    //
                                    //  LARGE_INTEGER
                                    //
                                    //Results in:
                                    //
                                    // Unicode string representation of
                                    // date and time.

                                    //
    SeAdtParmTypeGuid,              //Produces 1 parameter
                                    //Received value:
                                    //
                                    //  GUID pointer
                                    //
                                    //Results in:
                                    //
                                    // Unicode string representation of GUID
                                    // {xxxxxxxx-xxxx-xxxx-xxxx-xxxxxxxxxxxx}
                                    //

//
// Everything below exists only in Windows Server 2003 and Greater
//

    SeAdtParmTypeLuid,              //
                                    //Produces 1 parameter
                                    //Received value:
                                    //
                                    // LUID
                                    //
                                    //Results in:
                                    //
                                    // Hex LUID
                                    //

    SeAdtParmTypeHexInt64,          //Produces 1 parameter
                                    //Received value:
                                    //
                                    //  64 bit integer
                                    //
                                    //Results in:
                                    //
                                    //  Unicode string representation of
                                    //  unsigned integer value in hexadecimal.

    SeAdtParmTypeStringList,        //Produces 1 parameter
                                    //Received value:
                                    //
                                    // ptr to LSAP_ADT_STRING_LIST
                                    //
                                    //Results in:
                                    //
                                    // Unicode string representation of
                                    // concatenation of the strings in the list

    SeAdtParmTypeSidList,           //Produces 1 parameter
                                    //Received value:
                                    //
                                    // ptr to LSAP_ADT_SID_LIST
                                    //
                                    //Results in:
                                    //
                                    // Unicode string representation of
                                    // concatenation of the SIDs in the list

    SeAdtParmTypeDuration,          //Produces 1 parameters
                                    //Received value:
                                    //
                                    //  LARGE_INTEGER
                                    //
                                    //Results in:
                                    //
                                    // Unicode string representation of
                                    // a duration.

    SeAdtParmTypeUserAccountControl,//Produces 3 parameters
                                    //Received value:
                                    //
                                    // old and new UserAccountControl values
                                    //
                                    //Results in:
                                    //
                                    // Unicode string representations of
                                    // the flags in UserAccountControl.
                                    // 1 - old value in hex
                                    // 2 - new value in hex
                                    // 3 - difference as strings

    SeAdtParmTypeNoUac,             //Produces 3 parameters
                                    //Received value:
                                    //
                                    // none
                                    //
                                    //Results in:
                                    //
                                    // Three dashes ('-') as unicode strings.

    SeAdtParmTypeMessage,           //Produces 1 Parameter
                                    //Received value:
                                    //
                                    //  ULONG (MessageNo from msobjs.mc)
                                    //
                                    //Results in:
                                    //
                                    // Unicode string representation of
                                    // %%MessageNo which the event viewer
                                    // will replace with the message string
                                    // from msobjs.mc

    SeAdtParmTypeDateTime,          //Produces 1 Parameter
                                    //Received value:
                                    //
                                    //  LARGE_INTEGER
                                    //
                                    //Results in:
                                    //
                                    // Unicode string representation of
                                    // date and time (in _one_ string).

    SeAdtParmTypeSockAddr,          // Produces 2 parameters
                                    //
                                    // Received value:
                                    //
                                    // pointer to SOCKADDR_IN/SOCKADDR_IN6
                                    // structure
                                    //
                                    // Results in:
                                    //
                                    // param 1: IP address string
                                    // param 2: Port number string
                                    //

//
// Everything below this exists only in Longhorn and greater
//

    SeAdtParmTypeSD,                // Produces 1 parameters
                                    //
                                    // Received value:
                                    //
                                    // pointer to SECURITY_DESCRIPTOR
                                    // structure
                                    //
                                    // Results in:
                                    //
                                    // SDDL string representation of SD
                                    //

    SeAdtParmTypeLogonHours,        // Produces 1 parameters
                                    //
                                    // Received value:
                                    //
                                    // pointer to LOGON_HOURS
                                    // structure
                                    //
                                    // Results in:
                                    //
                                    // String representation of allowed logon hours
                                    //

    SeAdtParmTypeLogonIdNoSid,      //Produces 3 parameters.
                                    //Received Value:
                                    //
                                    //  LUID (fixed length)
                                    //
                                    //Results in:
                                    //
                                    //  param 1: Username string
                                    //  param 2: domain name string
                                    //  param 3: Logon ID (Luid) string

    SeAdtParmTypeUlongNoConv,       // Produces 1 parameter.
                                    // Received Value:
                                    // Ulong
                                    //
                                    //Results in:
                                    // Not converted to string
                                    //

    SeAdtParmTypeSockAddrNoPort     // Produces 1 parameter
                                    //
                                    // Received value:
                                    //
                                    // pointer to SOCKADDR_IN/SOCKADDR_IN6
                                    // structure
                                    //
                                    // Results in:
                                    //
                                    // param 1: IPv4/IPv6 address string
                                    //

} SE_ADT_PARAMETER_TYPE, *PSE_ADT_PARAMETER_TYPE;

#ifndef GUID_DEFINED
#include <guiddef.h>
#endif /* GUID_DEFINED */

typedef struct _SE_ADT_OBJECT_TYPE {
    GUID ObjectType;
    USHORT Flags;
#define SE_ADT_OBJECT_ONLY 0x1
    USHORT Level;
    ACCESS_MASK AccessMask;
} SE_ADT_OBJECT_TYPE, *PSE_ADT_OBJECT_TYPE;

typedef struct _SE_ADT_PARAMETER_ARRAY_ENTRY {

    SE_ADT_PARAMETER_TYPE Type;
    ULONG Length;
    ULONG_PTR Data[2];
    PVOID Address;

} SE_ADT_PARAMETER_ARRAY_ENTRY, *PSE_ADT_PARAMETER_ARRAY_ENTRY;



//
// Structure that will be passed between the Reference Monitor and LSA
// to transmit auditing information.
//

#define SE_MAX_AUDIT_PARAMETERS 32
#define SE_MAX_GENERIC_AUDIT_PARAMETERS 28

typedef struct _SE_ADT_PARAMETER_ARRAY {

    ULONG CategoryId;
    ULONG AuditId;
    ULONG ParameterCount;
    ULONG Length;
    USHORT FlatSubCategoryId;
    USHORT Type;
    ULONG Flags;
    SE_ADT_PARAMETER_ARRAY_ENTRY Parameters[ SE_MAX_AUDIT_PARAMETERS ];

} SE_ADT_PARAMETER_ARRAY, *PSE_ADT_PARAMETER_ARRAY;


#define SE_ADT_PARAMETERS_SELF_RELATIVE     0x00000001
#define SE_ADT_PARAMETERS_SEND_TO_LSA       0x00000002
#define SE_ADT_PARAMETER_EXTENSIBLE_AUDIT   0x00000004
#define SE_ADT_PARAMETER_GENERIC_AUDIT      0x00000008
#define SE_ADT_PARAMETER_WRITE_SYNCHRONOUS  0x00000010


//
// This macro only existed in longhorn and after
//

#define LSAP_SE_ADT_PARAMETER_ARRAY_TRUE_SIZE(AuditParameters)    \
     ( sizeof(SE_ADT_PARAMETER_ARRAY) -                           \
       sizeof(SE_ADT_PARAMETER_ARRAY_ENTRY) *                     \
       (SE_MAX_AUDIT_PARAMETERS - AuditParameters->ParameterCount) )

#endif // _NTLSA_AUDIT_


#endif // _NTLSA_IFS_
// end_ntsecapi

#define LOW_PRIORITY 0              // Lowest thread priority level
#define LOW_REALTIME_PRIORITY 16    // Lowest realtime priority level
#define HIGH_PRIORITY 31            // Highest thread priority level
#define MAXIMUM_PRIORITY 32         // Number of thread priority levels

#define MAXIMUM_WAIT_OBJECTS 64     // Maximum number of wait objects

#define MAXIMUM_SUSPEND_COUNT MAXCHAR // Maximum times thread can be suspended


//
// Define system time structure.
//

typedef struct _KSYSTEM_TIME {
    ULONG LowPart;
    LONG High1Time;
    LONG High2Time;
} KSYSTEM_TIME, *PKSYSTEM_TIME;

//
// Thread priority
//

typedef LONG KPRIORITY;

//
// Spin Lock
//



typedef ULONG_PTR KSPIN_LOCK;
typedef KSPIN_LOCK *PKSPIN_LOCK;


//
// Define per processor lock queue structure.
//
// N.B. The lock field of the spin lock queue structure contains the address
//      of the associated kernel spin lock, an owner bit, and a lock bit. Bit
//      0 of the spin lock address is the wait bit and bit 1 is the owner bit.
//      The use of this field is such that the bits can be set and cleared
//      noninterlocked, however, the back pointer must be preserved.
//
//      The lock wait bit is set when a processor enqueues itself on the lock
//      queue and it is not the only entry in the queue. The processor will
//      spin on this bit waiting for the lock to be granted.
//
//      The owner bit is set when the processor owns the respective lock.
//
//      The next field of the spin lock queue structure is used to line the
//      queued lock structures together in fifo order. It also can set set and
//      cleared noninterlocked.
//

#define LOCK_QUEUE_WAIT 1
#define LOCK_QUEUE_WAIT_BIT 0

#define LOCK_QUEUE_OWNER 2
#define LOCK_QUEUE_OWNER_BIT 1

#if defined(_AMD64_)

#define LOCK_QUEUE_TIMER_LOCK_SHIFT 3
#define LOCK_QUEUE_TIMER_TABLE_LOCKS (1 << (8 - LOCK_QUEUE_TIMER_LOCK_SHIFT))

typedef ULONG64 KSPIN_LOCK_QUEUE_NUMBER;

#define LockQueueDispatcherLock 0
#define LockQueueExpansionLock 1
#define LockQueuePfnLock 2
#define LockQueueSystemSpaceLock 3
#define LockQueueVacbLock 4
#define LockQueueMasterLock 5
#define LockQueueNonPagedPoolLock 6
#define LockQueueIoCancelLock 7
#define LockQueueWorkQueueLock 8
#define LockQueueIoVpbLock 9
#define LockQueueIoDatabaseLock 10
#define LockQueueIoCompletionLock 11
#define LockQueueNtfsStructLock 12
#define LockQueueAfdWorkQueueLock 13
#define LockQueueBcbLock 14
#define LockQueueMmNonPagedPoolLock 15
#define LockQueueUnusedSpare16 16
#define LockQueueTimerTableLock 17
#define LockQueueMaximumLock (LockQueueTimerTableLock + LOCK_QUEUE_TIMER_TABLE_LOCKS)

#else

#define LOCK_QUEUE_TIMER_LOCK_SHIFT 3
#define LOCK_QUEUE_TIMER_TABLE_LOCKS (1 << (8 - LOCK_QUEUE_TIMER_LOCK_SHIFT))

typedef enum _KSPIN_LOCK_QUEUE_NUMBER {
    LockQueueDispatcherLock,
    LockQueueExpansionLock,
    LockQueuePfnLock,
    LockQueueSystemSpaceLock,
    LockQueueVacbLock,
    LockQueueMasterLock,
    LockQueueNonPagedPoolLock,
    LockQueueIoCancelLock,
    LockQueueWorkQueueLock,
    LockQueueIoVpbLock,
    LockQueueIoDatabaseLock,
    LockQueueIoCompletionLock,
    LockQueueNtfsStructLock,
    LockQueueAfdWorkQueueLock,
    LockQueueBcbLock,
    LockQueueMmNonPagedPoolLock,
    LockQueueUnusedSpare16,
    LockQueueTimerTableLock,
    LockQueueMaximumLock = LockQueueTimerTableLock + LOCK_QUEUE_TIMER_TABLE_LOCKS
} KSPIN_LOCK_QUEUE_NUMBER, *PKSPIN_LOCK_QUEUE_NUMBER;

#endif

typedef struct _KSPIN_LOCK_QUEUE {
    struct _KSPIN_LOCK_QUEUE * volatile Next;
    PKSPIN_LOCK volatile Lock;
} KSPIN_LOCK_QUEUE, *PKSPIN_LOCK_QUEUE;

typedef struct _KLOCK_QUEUE_HANDLE {
    KSPIN_LOCK_QUEUE LockQueue;
    KIRQL OldIrql;
} KLOCK_QUEUE_HANDLE, *PKLOCK_QUEUE_HANDLE;


//
// Interrupt routine (first level dispatch)
//

typedef
VOID
(*PKINTERRUPT_ROUTINE) (
    VOID
    );

//
// Profile source types
//
typedef enum _KPROFILE_SOURCE {
    ProfileTime,
    ProfileAlignmentFixup,
    ProfileTotalIssues,
    ProfilePipelineDry,
    ProfileLoadInstructions,
    ProfilePipelineFrozen,
    ProfileBranchInstructions,
    ProfileTotalNonissues,
    ProfileDcacheMisses,
    ProfileIcacheMisses,
    ProfileCacheMisses,
    ProfileBranchMispredictions,
    ProfileStoreInstructions,
    ProfileFpInstructions,
    ProfileIntegerInstructions,
    Profile2Issue,
    Profile3Issue,
    Profile4Issue,
    ProfileSpecialInstructions,
    ProfileTotalCycles,
    ProfileIcacheIssues,
    ProfileDcacheAccesses,
    ProfileMemoryBarrierCycles,
    ProfileLoadLinkedIssues,
    ProfileMaximum
} KPROFILE_SOURCE;

//
// Define the various device type values.  Note that values used by Microsoft
// Corporation are in the range 0-32767, and 32768-65535 are reserved for use
// by customers.
//

#define DEVICE_TYPE ULONG

#define FILE_DEVICE_BEEP                0x00000001
#define FILE_DEVICE_CD_ROM              0x00000002
#define FILE_DEVICE_CD_ROM_FILE_SYSTEM  0x00000003
#define FILE_DEVICE_CONTROLLER          0x00000004
#define FILE_DEVICE_DATALINK            0x00000005
#define FILE_DEVICE_DFS                 0x00000006
#define FILE_DEVICE_DISK                0x00000007
#define FILE_DEVICE_DISK_FILE_SYSTEM    0x00000008
#define FILE_DEVICE_FILE_SYSTEM         0x00000009
#define FILE_DEVICE_INPORT_PORT         0x0000000a
#define FILE_DEVICE_KEYBOARD            0x0000000b
#define FILE_DEVICE_MAILSLOT            0x0000000c
#define FILE_DEVICE_MIDI_IN             0x0000000d
#define FILE_DEVICE_MIDI_OUT            0x0000000e
#define FILE_DEVICE_MOUSE               0x0000000f
#define FILE_DEVICE_MULTI_UNC_PROVIDER  0x00000010
#define FILE_DEVICE_NAMED_PIPE          0x00000011
#define FILE_DEVICE_NETWORK             0x00000012
#define FILE_DEVICE_NETWORK_BROWSER     0x00000013
#define FILE_DEVICE_NETWORK_FILE_SYSTEM 0x00000014
#define FILE_DEVICE_NULL                0x00000015
#define FILE_DEVICE_PARALLEL_PORT       0x00000016
#define FILE_DEVICE_PHYSICAL_NETCARD    0x00000017
#define FILE_DEVICE_PRINTER             0x00000018
#define FILE_DEVICE_SCANNER             0x00000019
#define FILE_DEVICE_SERIAL_MOUSE_PORT   0x0000001a
#define FILE_DEVICE_SERIAL_PORT         0x0000001b
#define FILE_DEVICE_SCREEN              0x0000001c
#define FILE_DEVICE_SOUND               0x0000001d
#define FILE_DEVICE_STREAMS             0x0000001e
#define FILE_DEVICE_TAPE                0x0000001f
#define FILE_DEVICE_TAPE_FILE_SYSTEM    0x00000020
#define FILE_DEVICE_TRANSPORT           0x00000021
#define FILE_DEVICE_UNKNOWN             0x00000022
#define FILE_DEVICE_VIDEO               0x00000023
#define FILE_DEVICE_VIRTUAL_DISK        0x00000024
#define FILE_DEVICE_WAVE_IN             0x00000025
#define FILE_DEVICE_WAVE_OUT            0x00000026
#define FILE_DEVICE_8042_PORT           0x00000027
#define FILE_DEVICE_NETWORK_REDIRECTOR  0x00000028
#define FILE_DEVICE_BATTERY             0x00000029
#define FILE_DEVICE_BUS_EXTENDER        0x0000002a
#define FILE_DEVICE_MODEM               0x0000002b
#define FILE_DEVICE_VDM                 0x0000002c
#define FILE_DEVICE_MASS_STORAGE        0x0000002d
#define FILE_DEVICE_SMB                 0x0000002e
#define FILE_DEVICE_KS                  0x0000002f
#define FILE_DEVICE_CHANGER             0x00000030
#define FILE_DEVICE_SMARTCARD           0x00000031
#define FILE_DEVICE_ACPI                0x00000032
#define FILE_DEVICE_DVD                 0x00000033
#define FILE_DEVICE_FULLSCREEN_VIDEO    0x00000034
#define FILE_DEVICE_DFS_FILE_SYSTEM     0x00000035
#define FILE_DEVICE_DFS_VOLUME          0x00000036
#define FILE_DEVICE_SERENUM             0x00000037
#define FILE_DEVICE_TERMSRV             0x00000038
#define FILE_DEVICE_KSEC                0x00000039
#define FILE_DEVICE_FIPS                0x0000003A
#define FILE_DEVICE_INFINIBAND          0x0000003B
#define FILE_DEVICE_VMBUS               0x0000003E
#define FILE_DEVICE_CRYPT_PROVIDER      0x0000003F
#define FILE_DEVICE_WPD                 0x00000040
#define FILE_DEVICE_BLUETOOTH           0x00000041

//
// Macro definition for defining IOCTL and FSCTL function control codes.  Note
// that function codes 0-2047 are reserved for Microsoft Corporation, and
// 2048-4095 are reserved for customers.
//

#define CTL_CODE( DeviceType, Function, Method, Access ) (                 \
    ((DeviceType) << 16) | ((Access) << 14) | ((Function) << 2) | (Method) \
)

//
// Macro to extract device type out of the device io control code
//
#define DEVICE_TYPE_FROM_CTL_CODE(ctrlCode)     (((ULONG)(ctrlCode & 0xffff0000)) >> 16)

//
// Macro to extract buffering method out of the device io control code
//
#define METHOD_FROM_CTL_CODE(ctrlCode)          ((ULONG)(ctrlCode & 3))

//
// Define the method codes for how buffers are passed for I/O and FS controls
//

#define METHOD_BUFFERED                 0
#define METHOD_IN_DIRECT                1
#define METHOD_OUT_DIRECT               2
#define METHOD_NEITHER                  3

//
// Define some easier to comprehend aliases:
//   METHOD_DIRECT_TO_HARDWARE (writes, aka METHOD_IN_DIRECT)
//   METHOD_DIRECT_FROM_HARDWARE (reads, aka METHOD_OUT_DIRECT)
//

#define METHOD_DIRECT_TO_HARDWARE       METHOD_IN_DIRECT
#define METHOD_DIRECT_FROM_HARDWARE     METHOD_OUT_DIRECT

//
// Define the access check value for any access
//
//
// The FILE_READ_ACCESS and FILE_WRITE_ACCESS constants are also defined in
// ntioapi.h as FILE_READ_DATA and FILE_WRITE_DATA. The values for these
// constants *MUST* always be in sync.
//
//
// FILE_SPECIAL_ACCESS is checked by the NT I/O system the same as FILE_ANY_ACCESS.
// The file systems, however, may add additional access checks for I/O and FS controls
// that use this value.
//


#define FILE_ANY_ACCESS                 0
#define FILE_SPECIAL_ACCESS    (FILE_ANY_ACCESS)
#define FILE_READ_ACCESS          ( 0x0001 )    // file & pipe
#define FILE_WRITE_ACCESS         ( 0x0002 )    // file & pipe



//
// Define access rights to files and directories
//

//
// The FILE_READ_DATA and FILE_WRITE_DATA constants are also defined in
// devioctl.h as FILE_READ_ACCESS and FILE_WRITE_ACCESS. The values for these
// constants *MUST* always be in sync.
// The values are redefined in devioctl.h because they must be available to
// both DOS and NT.
//

#define FILE_READ_DATA            ( 0x0001 )    // file & pipe
#define FILE_LIST_DIRECTORY       ( 0x0001 )    // directory

#define FILE_WRITE_DATA           ( 0x0002 )    // file & pipe
#define FILE_ADD_FILE             ( 0x0002 )    // directory

#define FILE_APPEND_DATA          ( 0x0004 )    // file
#define FILE_ADD_SUBDIRECTORY     ( 0x0004 )    // directory
#define FILE_CREATE_PIPE_INSTANCE ( 0x0004 )    // named pipe


#define FILE_READ_EA              ( 0x0008 )    // file & directory

#define FILE_WRITE_EA             ( 0x0010 )    // file & directory

#define FILE_EXECUTE              ( 0x0020 )    // file
#define FILE_TRAVERSE             ( 0x0020 )    // directory

#define FILE_DELETE_CHILD         ( 0x0040 )    // directory

#define FILE_READ_ATTRIBUTES      ( 0x0080 )    // all

#define FILE_WRITE_ATTRIBUTES     ( 0x0100 )    // all

#define FILE_ALL_ACCESS (STANDARD_RIGHTS_REQUIRED | SYNCHRONIZE | 0x1FF)

#define FILE_GENERIC_READ         (STANDARD_RIGHTS_READ     |\
                                   FILE_READ_DATA           |\
                                   FILE_READ_ATTRIBUTES     |\
                                   FILE_READ_EA             |\
                                   SYNCHRONIZE)


#define FILE_GENERIC_WRITE        (STANDARD_RIGHTS_WRITE    |\
                                   FILE_WRITE_DATA          |\
                                   FILE_WRITE_ATTRIBUTES    |\
                                   FILE_WRITE_EA            |\
                                   FILE_APPEND_DATA         |\
                                   SYNCHRONIZE)


#define FILE_GENERIC_EXECUTE      (STANDARD_RIGHTS_EXECUTE  |\
                                   FILE_READ_ATTRIBUTES     |\
                                   FILE_EXECUTE             |\
                                   SYNCHRONIZE)




//
// Define share access rights to files and directories
//

#define FILE_SHARE_READ                 0x00000001  
#define FILE_SHARE_WRITE                0x00000002  
#define FILE_SHARE_DELETE               0x00000004  
#define FILE_SHARE_VALID_FLAGS          0x00000007

//
// Define the file attributes values
//
// Note:  0x00000008 is reserved for use for the old DOS VOLID (volume ID)
//        and is therefore not considered valid in NT.
//
// Note:  Note also that the order of these flags is set to allow both the
//        FAT and the Pinball File Systems to directly set the attributes
//        flags in attributes words without having to pick each flag out
//        individually.  The order of these flags should not be changed!
//

#define FILE_ATTRIBUTE_READONLY             0x00000001  
#define FILE_ATTRIBUTE_HIDDEN               0x00000002  
#define FILE_ATTRIBUTE_SYSTEM               0x00000004  
//OLD DOS VOLID                             0x00000008

#define FILE_ATTRIBUTE_DIRECTORY            0x00000010  
#define FILE_ATTRIBUTE_ARCHIVE              0x00000020  
#define FILE_ATTRIBUTE_DEVICE               0x00000040  
#define FILE_ATTRIBUTE_NORMAL               0x00000080  

#define FILE_ATTRIBUTE_TEMPORARY            0x00000100  
#define FILE_ATTRIBUTE_SPARSE_FILE          0x00000200  
#define FILE_ATTRIBUTE_REPARSE_POINT        0x00000400  
#define FILE_ATTRIBUTE_COMPRESSED           0x00000800  

#define FILE_ATTRIBUTE_OFFLINE              0x00001000  
#define FILE_ATTRIBUTE_NOT_CONTENT_INDEXED  0x00002000  
#define FILE_ATTRIBUTE_ENCRYPTED            0x00004000  

#define FILE_ATTRIBUTE_VIRTUAL              0x00010000  

#define FILE_ATTRIBUTE_VALID_FLAGS          0x00007fb7
#define FILE_ATTRIBUTE_VALID_SET_FLAGS      0x000031a7

//
// Define the create disposition values
//

#define FILE_SUPERSEDE                  0x00000000
#define FILE_OPEN                       0x00000001
#define FILE_CREATE                     0x00000002
#define FILE_OPEN_IF                    0x00000003
#define FILE_OVERWRITE                  0x00000004
#define FILE_OVERWRITE_IF               0x00000005
#define FILE_MAXIMUM_DISPOSITION        0x00000005

//
// Define the create/open option flags
//

#define FILE_DIRECTORY_FILE                     0x00000001
#define FILE_WRITE_THROUGH                      0x00000002
#define FILE_SEQUENTIAL_ONLY                    0x00000004
#define FILE_NO_INTERMEDIATE_BUFFERING          0x00000008

#define FILE_SYNCHRONOUS_IO_ALERT               0x00000010
#define FILE_SYNCHRONOUS_IO_NONALERT            0x00000020
#define FILE_NON_DIRECTORY_FILE                 0x00000040
#define FILE_CREATE_TREE_CONNECTION             0x00000080

#define FILE_COMPLETE_IF_OPLOCKED               0x00000100
#define FILE_NO_EA_KNOWLEDGE                    0x00000200
#define FILE_OPEN_REMOTE_INSTANCE               0x00000400
#define FILE_RANDOM_ACCESS                      0x00000800

#define FILE_DELETE_ON_CLOSE                    0x00001000
#define FILE_OPEN_BY_FILE_ID                    0x00002000
#define FILE_OPEN_FOR_BACKUP_INTENT             0x00004000
#define FILE_NO_COMPRESSION                     0x00008000

#define FILE_RESERVE_OPFILTER                   0x00100000
#define FILE_OPEN_REPARSE_POINT                 0x00200000
#define FILE_OPEN_NO_RECALL                     0x00400000
#define FILE_OPEN_FOR_FREE_SPACE_QUERY          0x00800000


#define FILE_COPY_STRUCTURED_STORAGE            0x00000041
#define FILE_STRUCTURED_STORAGE                 0x00000441


#define FILE_VALID_OPTION_FLAGS                 0x00ffffff
#define FILE_VALID_PIPE_OPTION_FLAGS            0x00000032
#define FILE_VALID_MAILSLOT_OPTION_FLAGS        0x00000032
#define FILE_VALID_SET_FLAGS                    0x00000036

//
// Define the I/O status information return values for NtCreateFile/NtOpenFile
//

#define FILE_SUPERSEDED                 0x00000000
#define FILE_OPENED                     0x00000001
#define FILE_CREATED                    0x00000002
#define FILE_OVERWRITTEN                0x00000003
#define FILE_EXISTS                     0x00000004
#define FILE_DOES_NOT_EXIST             0x00000005

//
// Define special ByteOffset parameters for read and write operations
//

#define FILE_WRITE_TO_END_OF_FILE       0xffffffff
#define FILE_USE_FILE_POINTER_POSITION  0xfffffffe

//
// Define alignment requirement values
//

#define FILE_BYTE_ALIGNMENT             0x00000000
#define FILE_WORD_ALIGNMENT             0x00000001
#define FILE_LONG_ALIGNMENT             0x00000003
#define FILE_QUAD_ALIGNMENT             0x00000007
#define FILE_OCTA_ALIGNMENT             0x0000000f
#define FILE_32_BYTE_ALIGNMENT          0x0000001f
#define FILE_64_BYTE_ALIGNMENT          0x0000003f
#define FILE_128_BYTE_ALIGNMENT         0x0000007f
#define FILE_256_BYTE_ALIGNMENT         0x000000ff
#define FILE_512_BYTE_ALIGNMENT         0x000001ff

//
// Define the maximum length of a filename string
//

#define MAXIMUM_FILENAME_LENGTH         256

//
// Define the various device characteristics flags
//

#define FILE_REMOVABLE_MEDIA                    0x00000001
#define FILE_READ_ONLY_DEVICE                   0x00000002
#define FILE_FLOPPY_DISKETTE                    0x00000004
#define FILE_WRITE_ONCE_MEDIA                   0x00000008
#define FILE_REMOTE_DEVICE                      0x00000010
#define FILE_DEVICE_IS_MOUNTED                  0x00000020
#define FILE_VIRTUAL_VOLUME                     0x00000040
#define FILE_AUTOGENERATED_DEVICE_NAME          0x00000080
#define FILE_DEVICE_SECURE_OPEN                 0x00000100
#define FILE_CHARACTERISTIC_PNP_DEVICE          0x00000800
#define FILE_CHARACTERISTIC_TS_DEVICE           0x00001000
#define FILE_CHARACTERISTIC_WEBDAV_DEVICE       0x00002000

//
// Define the base asynchronous I/O argument types
//

typedef struct _IO_STATUS_BLOCK {
    union {
        NTSTATUS Status;
        PVOID Pointer;
    } DUMMYUNIONNAME;

    ULONG_PTR Information;
} IO_STATUS_BLOCK, *PIO_STATUS_BLOCK;

#if defined(_WIN64)

typedef struct _IO_STATUS_BLOCK32 {
    NTSTATUS Status;
    ULONG Information;
} IO_STATUS_BLOCK32, *PIO_STATUS_BLOCK32;

#endif

//
// Define an Asynchronous Procedure Call from I/O viewpoint
//

typedef
VOID
(NTAPI *PIO_APC_ROUTINE) (
    IN PVOID ApcContext,
    IN PIO_STATUS_BLOCK IoStatusBlock,
    IN ULONG Reserved
    );

#define PIO_APC_ROUTINE_DEFINED

//
// Define the file information class values
//
// WARNING:  The order of the following values are assumed by the I/O system.
//           Any changes made here should be reflected there as well.
//

typedef enum _FILE_INFORMATION_CLASS {
    FileDirectoryInformation         = 1,
    FileFullDirectoryInformation,   // 2
    FileBothDirectoryInformation,   // 3
    FileBasicInformation,           // 4
    FileStandardInformation,        // 5
    FileInternalInformation,        // 6
    FileEaInformation,              // 7
    FileAccessInformation,          // 8
    FileNameInformation,            // 9
    FileRenameInformation,          // 10
    FileLinkInformation,            // 11
    FileNamesInformation,           // 12
    FileDispositionInformation,     // 13
    FilePositionInformation,        // 14
    FileFullEaInformation,          // 15
    FileModeInformation,            // 16
    FileAlignmentInformation,       // 17
    FileAllInformation,             // 18
    FileAllocationInformation,      // 19
    FileEndOfFileInformation,       // 20
    FileAlternateNameInformation,   // 21
    FileStreamInformation,          // 22
    FilePipeInformation,            // 23
    FilePipeLocalInformation,       // 24
    FilePipeRemoteInformation,      // 25
    FileMailslotQueryInformation,   // 26
    FileMailslotSetInformation,     // 27
    FileCompressionInformation,     // 28
    FileObjectIdInformation,        // 29
    FileCompletionInformation,      // 30
    FileMoveClusterInformation,     // 31
    FileQuotaInformation,           // 32
    FileReparsePointInformation,    // 33
    FileNetworkOpenInformation,     // 34
    FileAttributeTagInformation,    // 35
    FileTrackingInformation,        // 36
    FileIdBothDirectoryInformation, // 37
    FileIdFullDirectoryInformation, // 38
    FileValidDataLengthInformation, // 39
    FileShortNameInformation,       // 40
    FileIoCompletionNotificationInformation, // 41
    FileIoStatusBlockRangeInformation,       // 42
    FileIoPriorityHintInformation,           // 43
    FileSfioReserveInformation,              // 44
    FileSfioVolumeInformation,               // 45
    FileHardLinkInformation,                 // 46
    FileProcessIdsUsingFileInformation,      // 47
    FileNormalizedNameInformation,           // 48
    FileNetworkPhysicalNameInformation,      // 49 
    FileIdGlobalTxDirectoryInformation,      // 50
    FileMaximumInformation
} FILE_INFORMATION_CLASS, *PFILE_INFORMATION_CLASS;

//
// Define the various structures which are returned on query operations
//

typedef struct _FILE_BASIC_INFORMATION {
    LARGE_INTEGER CreationTime;
    LARGE_INTEGER LastAccessTime;
    LARGE_INTEGER LastWriteTime;
    LARGE_INTEGER ChangeTime;
    ULONG FileAttributes;
} FILE_BASIC_INFORMATION, *PFILE_BASIC_INFORMATION;

typedef struct _FILE_STANDARD_INFORMATION {
    LARGE_INTEGER AllocationSize;
    LARGE_INTEGER EndOfFile;
    ULONG NumberOfLinks;
    BOOLEAN DeletePending;
    BOOLEAN Directory;
} FILE_STANDARD_INFORMATION, *PFILE_STANDARD_INFORMATION;


typedef struct _FILE_POSITION_INFORMATION {
    LARGE_INTEGER CurrentByteOffset;
} FILE_POSITION_INFORMATION, *PFILE_POSITION_INFORMATION;


typedef struct _FILE_NETWORK_OPEN_INFORMATION {
    LARGE_INTEGER CreationTime;
    LARGE_INTEGER LastAccessTime;
    LARGE_INTEGER LastWriteTime;
    LARGE_INTEGER ChangeTime;
    LARGE_INTEGER AllocationSize;
    LARGE_INTEGER EndOfFile;
    ULONG FileAttributes;
} FILE_NETWORK_OPEN_INFORMATION, *PFILE_NETWORK_OPEN_INFORMATION;





typedef struct _FILE_FULL_EA_INFORMATION {
    ULONG NextEntryOffset;
    UCHAR Flags;
    UCHAR EaNameLength;
    USHORT EaValueLength;
    CHAR EaName[1];
} FILE_FULL_EA_INFORMATION, *PFILE_FULL_EA_INFORMATION;


//
// Support to reserve bandwidth for a file handle.
//

typedef struct _FILE_SFIO_RESERVE_INFORMATION {
    ULONG RequestsPerPeriod;
    ULONG Period;
    BOOLEAN RetryFailures;
    BOOLEAN Discardable;
    ULONG RequestSize;
    ULONG NumOutstandingRequests;
} FILE_SFIO_RESERVE_INFORMATION, *PFILE_SFIO_RESERVE_INFORMATION;

//
// Support to query bandwidth properties of a volume.
//

typedef struct _FILE_SFIO_VOLUME_INFORMATION {
    ULONG MaximumRequestsPerPeriod;
    ULONG MinimumPeriod;
    ULONG MinimumTransferSize;
} FILE_SFIO_VOLUME_INFORMATION, *PFILE_SFIO_VOLUME_INFORMATION;

//
// Support to set priority hints on a filehandle.
//

typedef enum _IO_PRIORITY_HINT {
    IoPriorityVeryLow = 0,    // Winfs promotion, defragging, content indexing and other background I/Os
    IoPriorityLow,            // Prefetching for applications.
    IoPriorityNormal,         // Normal I/Os
    IoPriorityHigh,           // Used by filesystems for checkpoint I/O
    IoPriorityCritical,       // Used by memory manager. Not available for applications.
    MaxIoPriorityTypes
} IO_PRIORITY_HINT;

typedef struct _FILE_IO_PRIORITY_HINT_INFORMATION {
    IO_PRIORITY_HINT   PriorityHint;
} FILE_IO_PRIORITY_HINT_INFORMATION, *PFILE_IO_PRIORITY_HINT_INFORMATION;

//
// Don't queue an entry to an associated completion port if returning success
// synchronously.
//
#define FILE_SKIP_COMPLETION_PORT_ON_SUCCESS    0x1

//
// Don't set the file handle event on IO completion.
//
#define FILE_SKIP_SET_EVENT_ON_HANDLE           0x2

//
// Don't set user supplied event on successful fast-path IO completion.
//
#define FILE_SKIP_SET_USER_EVENT_ON_FAST_IO     0x4

typedef  struct _FILE_IO_COMPLETION_NOTIFICATION_INFORMATION {
    ULONG Flags;
} FILE_IO_COMPLETION_NOTIFICATION_INFORMATION, *PFILE_IO_COMPLETION_NOTIFICATION_INFORMATION;

typedef  struct _FILE_PROCESS_IDS_USING_FILE_INFORMATION {
    ULONG NumberOfProcessIdsInList;
    ULONG_PTR ProcessIdList[1];
} FILE_PROCESS_IDS_USING_FILE_INFORMATION, *PFILE_PROCESS_IDS_USING_FILE_INFORMATION;

//
// Set an range of IOSBs on a file handle.
//

typedef struct _FILE_IOSTATUSBLOCK_RANGE_INFORMATION {
    PUCHAR       IoStatusBlockRange;
    ULONG        Length;
} FILE_IOSTATUSBLOCK_RANGE_INFORMATION, *PFILE_IOSTATUSBLOCK_RANGE_INFORMATION;

//
// Define the file system information class values
//
// WARNING:  The order of the following values are assumed by the I/O system.
//           Any changes made here should be reflected there as well.

typedef enum _FSINFOCLASS {
    FileFsVolumeInformation       = 1,
    FileFsLabelInformation,      // 2
    FileFsSizeInformation,       // 3
    FileFsDeviceInformation,     // 4
    FileFsAttributeInformation,  // 5
    FileFsControlInformation,    // 6
    FileFsFullSizeInformation,   // 7
    FileFsObjectIdInformation,   // 8
    FileFsDriverPathInformation, // 9
    FileFsVolumeFlagsInformation,// 10
    FileFsMaximumInformation
} FS_INFORMATION_CLASS, *PFS_INFORMATION_CLASS;


typedef struct _FILE_FS_DEVICE_INFORMATION {
    DEVICE_TYPE DeviceType;
    ULONG Characteristics;
} FILE_FS_DEVICE_INFORMATION, *PFILE_FS_DEVICE_INFORMATION;

//
// Define the I/O bus interface types.
//

typedef enum _INTERFACE_TYPE {
    InterfaceTypeUndefined = -1,
    Internal,
    Isa,
    Eisa,
    MicroChannel,
    TurboChannel,
    PCIBus,
    VMEBus,
    NuBus,
    PCMCIABus,
    CBus,
    MPIBus,
    MPSABus,
    ProcessorInternal,
    InternalPowerBus,
    PNPISABus,
    PNPBus,
    Vmcs,
    MaximumInterfaceType
}INTERFACE_TYPE, *PINTERFACE_TYPE;

//
// Define the DMA transfer widths.
//

typedef enum _DMA_WIDTH {
    Width8Bits,
    Width16Bits,
    Width32Bits,
    MaximumDmaWidth
}DMA_WIDTH, *PDMA_WIDTH;

//
// Define DMA transfer speeds.
//

typedef enum _DMA_SPEED {
    Compatible,
    TypeA,
    TypeB,
    TypeC,
    TypeF,
    MaximumDmaSpeed
}DMA_SPEED, *PDMA_SPEED;

//
// Define Interface reference/dereference routines for
//  Interfaces exported by IRP_MN_QUERY_INTERFACE
//

typedef VOID (*PINTERFACE_REFERENCE)(PVOID Context);
typedef VOID (*PINTERFACE_DEREFERENCE)(PVOID Context);

//
// Define I/O Driver error log packet structure.  This structure is filled in
// by the driver.
//

typedef struct _IO_ERROR_LOG_PACKET {
    UCHAR MajorFunctionCode;
    UCHAR RetryCount;
    USHORT DumpDataSize;
    USHORT NumberOfStrings;
    USHORT StringOffset;
    USHORT EventCategory;
    NTSTATUS ErrorCode;
    ULONG UniqueErrorValue;
    NTSTATUS FinalStatus;
    ULONG SequenceNumber;
    ULONG IoControlCode;
    LARGE_INTEGER DeviceOffset;
    ULONG DumpData[1];
}IO_ERROR_LOG_PACKET, *PIO_ERROR_LOG_PACKET;

//
// Define the I/O error log message.  This message is sent by the error log
// thread over the lpc port.
//

typedef struct _IO_ERROR_LOG_MESSAGE {
    USHORT Type;
    USHORT Size;
    USHORT DriverNameLength;
    LARGE_INTEGER TimeStamp;
    ULONG DriverNameOffset;
    IO_ERROR_LOG_PACKET EntryData;
}IO_ERROR_LOG_MESSAGE, *PIO_ERROR_LOG_MESSAGE;

//
// Define the maximum message size that will be sent over the LPC to the
// application reading the error log entries.
//

//
// Regardless of LPC size restrictions, ERROR_LOG_MAXIMUM_SIZE must remain
// a value that can fit in a UCHAR.
//

#define ERROR_LOG_LIMIT_SIZE (256-16)

//
// This limit, exclusive of IO_ERROR_LOG_MESSAGE_HEADER_LENGTH, also applies
// to IO_ERROR_LOG_MESSAGE_LENGTH
//

#define IO_ERROR_LOG_MESSAGE_HEADER_LENGTH (sizeof(IO_ERROR_LOG_MESSAGE) -    \
                                            sizeof(IO_ERROR_LOG_PACKET) +     \
                                            (sizeof(WCHAR) * 40))

#define ERROR_LOG_MESSAGE_LIMIT_SIZE                                          \
    (ERROR_LOG_LIMIT_SIZE + IO_ERROR_LOG_MESSAGE_HEADER_LENGTH)

//
// IO_ERROR_LOG_MESSAGE_LENGTH is
// min(PORT_MAXIMUM_MESSAGE_LENGTH, ERROR_LOG_MESSAGE_LIMIT_SIZE)
//

#define IO_ERROR_LOG_MESSAGE_LENGTH                                           \
    ((PORT_MAXIMUM_MESSAGE_LENGTH > ERROR_LOG_MESSAGE_LIMIT_SIZE) ?           \
        ERROR_LOG_MESSAGE_LIMIT_SIZE :                                        \
        PORT_MAXIMUM_MESSAGE_LENGTH)

//
// Define the maximum packet size a driver can allocate.
//

#define ERROR_LOG_MAXIMUM_SIZE (IO_ERROR_LOG_MESSAGE_LENGTH -                 \
                                IO_ERROR_LOG_MESSAGE_HEADER_LENGTH)

#ifdef _WIN64
#define PORT_MAXIMUM_MESSAGE_LENGTH 512
#else
#define PORT_MAXIMUM_MESSAGE_LENGTH 256
#endif

#define LPC_MAX_CONNECTION_INFO_SIZE (16 * sizeof(ULONG_PTR)) 

#define PORT_TOTAL_MAXIMUM_MESSAGE_LENGTH ((PORT_MAXIMUM_MESSAGE_LENGTH + sizeof (PORT_MESSAGE) + LPC_MAX_CONNECTION_INFO_SIZE + 15) & ~15)

//
// Registry Specific Access Rights.
//

#define KEY_QUERY_VALUE         (0x0001)
#define KEY_SET_VALUE           (0x0002)
#define KEY_CREATE_SUB_KEY      (0x0004)
#define KEY_ENUMERATE_SUB_KEYS  (0x0008)
#define KEY_NOTIFY              (0x0010)
#define KEY_CREATE_LINK         (0x0020)
#define KEY_WOW64_32KEY         (0x0200)
#define KEY_WOW64_64KEY         (0x0100)
#define KEY_WOW64_RES           (0x0300)

#define KEY_READ                ((STANDARD_RIGHTS_READ       |\
                                  KEY_QUERY_VALUE            |\
                                  KEY_ENUMERATE_SUB_KEYS     |\
                                  KEY_NOTIFY)                 \
                                  &                           \
                                 (~SYNCHRONIZE))


#define KEY_WRITE               ((STANDARD_RIGHTS_WRITE      |\
                                  KEY_SET_VALUE              |\
                                  KEY_CREATE_SUB_KEY)         \
                                  &                           \
                                 (~SYNCHRONIZE))

#define KEY_EXECUTE             ((KEY_READ)                   \
                                  &                           \
                                 (~SYNCHRONIZE))

#define KEY_ALL_ACCESS          ((STANDARD_RIGHTS_ALL        |\
                                  KEY_QUERY_VALUE            |\
                                  KEY_SET_VALUE              |\
                                  KEY_CREATE_SUB_KEY         |\
                                  KEY_ENUMERATE_SUB_KEYS     |\
                                  KEY_NOTIFY                 |\
                                  KEY_CREATE_LINK)            \
                                  &                           \
                                 (~SYNCHRONIZE))

//
// Open/Create Options
//

#define REG_OPTION_RESERVED         (0x00000000L)   // Parameter is reserved

#define REG_OPTION_NON_VOLATILE     (0x00000000L)   // Key is preserved
                                                    // when system is rebooted

#define REG_OPTION_VOLATILE         (0x00000001L)   // Key is not preserved
                                                    // when system is rebooted

#define REG_OPTION_CREATE_LINK      (0x00000002L)   // Created key is a
                                                    // symbolic link

#define REG_OPTION_BACKUP_RESTORE   (0x00000004L)   // open for backup or restore
                                                    // special access rules
                                                    // privilege required

#define REG_OPTION_OPEN_LINK        (0x00000008L)   // Open symbolic link

#define REG_LEGAL_OPTION            \
                (REG_OPTION_RESERVED            |\
                 REG_OPTION_NON_VOLATILE        |\
                 REG_OPTION_VOLATILE            |\
                 REG_OPTION_CREATE_LINK         |\
                 REG_OPTION_BACKUP_RESTORE      |\
                 REG_OPTION_OPEN_LINK)

//
// Key creation/open disposition
//

#define REG_CREATED_NEW_KEY         (0x00000001L)   // New Registry Key created
#define REG_OPENED_EXISTING_KEY     (0x00000002L)   // Existing Key opened

//
// hive format to be used by Reg(Nt)SaveKeyEx
//
#define REG_STANDARD_FORMAT     1
#define REG_LATEST_FORMAT       2
#define REG_NO_COMPRESSION      4

//
// Key restore & hive load flags
//

#define REG_WHOLE_HIVE_VOLATILE         (0x00000001L)   // Restore whole hive volatile
#define REG_REFRESH_HIVE                (0x00000002L)   // Unwind changes to last flush
#define REG_NO_LAZY_FLUSH               (0x00000004L)   // Never lazy flush this hive
#define REG_FORCE_RESTORE               (0x00000008L)   // Force the restore process even when we have open handles on subkeys
#define REG_APP_HIVE                    (0x00000010L)   // Loads the hive visible to the calling process
#define REG_PROCESS_PRIVATE             (0x00000020L)   // Hive cannot be mounted by any other process while in use
#define REG_START_JOURNAL               (0x00000040L)   // Starts Hive Journal
#define REG_HIVE_EXACT_FILE_GROWTH      (0x00000080L)   // Grow hive file in exact 4k increments
#define REG_HIVE_NO_RM                  (0x00000100L)   // No RM is started for this hive (no transactions)
#define REG_HIVE_SINGLE_LOG             (0x00000200L)   // Legacy single logging is used for this hive

//
// Unload Flags
//
#define REG_FORCE_UNLOAD            1

//
// Notify filter values
//

#define REG_NOTIFY_CHANGE_NAME          (0x00000001L) // Create or delete (child)
#define REG_NOTIFY_CHANGE_ATTRIBUTES    (0x00000002L)
#define REG_NOTIFY_CHANGE_LAST_SET      (0x00000004L) // time stamp
#define REG_NOTIFY_CHANGE_SECURITY      (0x00000008L)

#define REG_LEGAL_CHANGE_FILTER                 \
                (REG_NOTIFY_CHANGE_NAME          |\
                 REG_NOTIFY_CHANGE_ATTRIBUTES    |\
                 REG_NOTIFY_CHANGE_LAST_SET      |\
                 REG_NOTIFY_CHANGE_SECURITY)
 
//
// Key query structures
//

typedef struct _KEY_BASIC_INFORMATION {
    LARGE_INTEGER LastWriteTime;
    ULONG   TitleIndex;
    ULONG   NameLength;
    WCHAR   Name[1];            // Variable length string
} KEY_BASIC_INFORMATION, *PKEY_BASIC_INFORMATION;

typedef struct _KEY_NODE_INFORMATION {
    LARGE_INTEGER LastWriteTime;
    ULONG   TitleIndex;
    ULONG   ClassOffset;
    ULONG   ClassLength;
    ULONG   NameLength;
    WCHAR   Name[1];            // Variable length string
//          Class[1];           // Variable length string not declared
} KEY_NODE_INFORMATION, *PKEY_NODE_INFORMATION;

typedef struct _KEY_FULL_INFORMATION {
    LARGE_INTEGER LastWriteTime;
    ULONG   TitleIndex;
    ULONG   ClassOffset;
    ULONG   ClassLength;
    ULONG   SubKeys;
    ULONG   MaxNameLen;
    ULONG   MaxClassLen;
    ULONG   Values;
    ULONG   MaxValueNameLen;
    ULONG   MaxValueDataLen;
    WCHAR   Class[1];           // Variable length
} KEY_FULL_INFORMATION, *PKEY_FULL_INFORMATION;

typedef enum _KEY_INFORMATION_CLASS {
    KeyBasicInformation,
    KeyNodeInformation,
    KeyFullInformation,
    KeyNameInformation,
    KeyCachedInformation,
    KeyFlagsInformation,
    KeyVirtualizationInformation,
    MaxKeyInfoClass  // MaxKeyInfoClass should always be the last enum
} KEY_INFORMATION_CLASS;

typedef struct _KEY_WRITE_TIME_INFORMATION {
    LARGE_INTEGER LastWriteTime;
} KEY_WRITE_TIME_INFORMATION, *PKEY_WRITE_TIME_INFORMATION;

typedef struct _KEY_WOW64_FLAGS_INFORMATION {
    ULONG   UserFlags;
} KEY_WOW64_FLAGS_INFORMATION, *PKEY_WOW64_FLAGS_INFORMATION;

typedef struct _KEY_CONTROL_FLAGS_INFORMATION {
    ULONG   ControlFlags;
} KEY_CONTROL_FLAGS_INFORMATION, *PKEY_CONTROL_FLAGS_INFORMATION;

typedef struct _KEY_SET_VIRTUALIZATION_INFORMATION {
    ULONG   VirtualTarget           : 1; // Tells if the key is a virtual target key. 
    ULONG   VirtualStore	        : 1; // Tells if the key is a virtual store key.
    ULONG   VirtualSource           : 1; // Tells if the key has been virtualized at least one (virtual hint)
    ULONG   Reserved                : 29;   
} KEY_SET_VIRTUALIZATION_INFORMATION, *PKEY_SET_VIRTUALIZATION_INFORMATION;

typedef enum _KEY_SET_INFORMATION_CLASS {
    KeyWriteTimeInformation,
    KeyWow64FlagsInformation,
    KeyControlFlagsInformation,
    KeySetVirtualizationInformation,
    KeySetDebugInformation,
    MaxKeySetInfoClass  // MaxKeySetInfoClass should always be the last enum
} KEY_SET_INFORMATION_CLASS;

//
// Value entry query structures
//

typedef struct _KEY_VALUE_BASIC_INFORMATION {
    ULONG   TitleIndex;
    ULONG   Type;
    ULONG   NameLength;
    WCHAR   Name[1];            // Variable size
} KEY_VALUE_BASIC_INFORMATION, *PKEY_VALUE_BASIC_INFORMATION;

typedef struct _KEY_VALUE_FULL_INFORMATION {
    ULONG   TitleIndex;
    ULONG   Type;
    ULONG   DataOffset;
    ULONG   DataLength;
    ULONG   NameLength;
    WCHAR   Name[1];            // Variable size
//          Data[1];            // Variable size data not declared
} KEY_VALUE_FULL_INFORMATION, *PKEY_VALUE_FULL_INFORMATION;

typedef struct _KEY_VALUE_PARTIAL_INFORMATION {
    ULONG   TitleIndex;
    ULONG   Type;
    ULONG   DataLength;
    UCHAR   Data[1];            // Variable size
} KEY_VALUE_PARTIAL_INFORMATION, *PKEY_VALUE_PARTIAL_INFORMATION;

typedef struct _KEY_VALUE_PARTIAL_INFORMATION_ALIGN64 {
    ULONG   Type;
    ULONG   DataLength;
    UCHAR   Data[1];            // Variable size
} KEY_VALUE_PARTIAL_INFORMATION_ALIGN64, *PKEY_VALUE_PARTIAL_INFORMATION_ALIGN64;

typedef struct _KEY_VALUE_ENTRY {
    PUNICODE_STRING ValueName;
    ULONG           DataLength;
    ULONG           DataOffset;
    ULONG           Type;
} KEY_VALUE_ENTRY, *PKEY_VALUE_ENTRY;

typedef enum _KEY_VALUE_INFORMATION_CLASS {
    KeyValueBasicInformation,
    KeyValueFullInformation,
    KeyValuePartialInformation,
    KeyValueFullInformationAlign64,
    KeyValuePartialInformationAlign64,
    MaxKeyValueInfoClass  // MaxKeyValueInfoClass should always be the last enum
} KEY_VALUE_INFORMATION_CLASS;



#define OBJ_NAME_PATH_SEPARATOR ((WCHAR)L'\\')


//
// Object Manager Object Type Specific Access Rights.
//

#define OBJECT_TYPE_CREATE (0x0001)

#define OBJECT_TYPE_ALL_ACCESS (STANDARD_RIGHTS_REQUIRED | 0x1)

//
// Object Manager Directory Specific Access Rights.
//

#define DIRECTORY_QUERY                 (0x0001)
#define DIRECTORY_TRAVERSE              (0x0002)
#define DIRECTORY_CREATE_OBJECT         (0x0004)
#define DIRECTORY_CREATE_SUBDIRECTORY   (0x0008)

#define DIRECTORY_ALL_ACCESS (STANDARD_RIGHTS_REQUIRED | 0xF)

//begin_winnt

//
// Object Manager Symbolic Link Specific Access Rights.
//

//end_winnt

#define SYMBOLIC_LINK_QUERY (0x0001)

#define SYMBOLIC_LINK_ALL_ACCESS (STANDARD_RIGHTS_REQUIRED | 0x1)

typedef struct _OBJECT_NAME_INFORMATION {
    UNICODE_STRING Name;
} OBJECT_NAME_INFORMATION, *POBJECT_NAME_INFORMATION;

#define DUPLICATE_CLOSE_SOURCE      0x00000001  
#define DUPLICATE_SAME_ACCESS       0x00000002  
#define DUPLICATE_SAME_ATTRIBUTES   0x00000004

//
// Section Information Structures.
//

typedef enum _SECTION_INHERIT {
    ViewShare = 1,
    ViewUnmap = 2
} SECTION_INHERIT;

//
// Section Access Rights.
//


#define SECTION_QUERY                0x0001
#define SECTION_MAP_WRITE            0x0002
#define SECTION_MAP_READ             0x0004
#define SECTION_MAP_EXECUTE          0x0008
#define SECTION_EXTEND_SIZE          0x0010
#define SECTION_MAP_EXECUTE_EXPLICIT 0x0020 // not included in SECTION_ALL_ACCESS

#define SECTION_ALL_ACCESS (STANDARD_RIGHTS_REQUIRED|SECTION_QUERY|\
                            SECTION_MAP_WRITE |      \
                            SECTION_MAP_READ |       \
                            SECTION_MAP_EXECUTE |    \
                            SECTION_EXTEND_SIZE)

#define SESSION_QUERY_ACCESS  0x0001
#define SESSION_MODIFY_ACCESS 0x0002

#define SESSION_ALL_ACCESS (STANDARD_RIGHTS_REQUIRED |  \
                            SESSION_QUERY_ACCESS |             \
                            SESSION_MODIFY_ACCESS)



#define SEGMENT_ALL_ACCESS SECTION_ALL_ACCESS

#define PAGE_NOACCESS          0x01     
#define PAGE_READONLY          0x02     
#define PAGE_READWRITE         0x04     
#define PAGE_WRITECOPY         0x08     
#define PAGE_EXECUTE           0x10     
#define PAGE_EXECUTE_READ      0x20     
#define PAGE_EXECUTE_READWRITE 0x40     
#define PAGE_EXECUTE_WRITECOPY 0x80     
#define PAGE_GUARD            0x100     
#define PAGE_NOCACHE          0x200     
#define PAGE_WRITECOMBINE     0x400     

#define MEM_COMMIT           0x1000     
#define MEM_RESERVE          0x2000     
#define MEM_DECOMMIT         0x4000     
#define MEM_RELEASE          0x8000     
#define MEM_FREE            0x10000     
#define MEM_PRIVATE         0x20000     
#define MEM_MAPPED          0x40000     
#define MEM_RESET           0x80000     
#define MEM_TOP_DOWN       0x100000     
#define MEM_LARGE_PAGES  0x20000000     
#define MEM_4MB_PAGES    0x80000000     
#define SEC_RESERVE       0x4000000     
#define SEC_LARGE_PAGES  0x80000000     
#define PROCESS_DUP_HANDLE                 (0x0040)  
#if (NTDDI_VERSION >= NTDDI_VISTA)
#define PROCESS_ALL_ACCESS        (STANDARD_RIGHTS_REQUIRED | SYNCHRONIZE | \
                                   0xFFFF)
#else
#define PROCESS_ALL_ACCESS        (STANDARD_RIGHTS_REQUIRED | SYNCHRONIZE | \
                                   0xFFF)
#endif

#if defined(_WIN64)

#define MAXIMUM_PROCESSORS 64

#else

#define MAXIMUM_PROCESSORS 32

#endif



//
// Thread Specific Access Rights
//

#define THREAD_TERMINATE                 (0x0001)  
#define THREAD_SUSPEND_RESUME            (0x0002)  
#define THREAD_ALERT                     (0x0004)
#define THREAD_GET_CONTEXT               (0x0008)  
#define THREAD_SET_CONTEXT               (0x0010)  
#define THREAD_SET_INFORMATION           (0x0020)  
#define THREAD_SET_LIMITED_INFORMATION   (0x0400)  
#define THREAD_QUERY_LIMITED_INFORMATION (0x0800)  
#if (NTDDI_VERSION >= NTDDI_VISTA)
#define THREAD_ALL_ACCESS         (STANDARD_RIGHTS_REQUIRED | SYNCHRONIZE | \
                                   0xFFFF)
#else
#define THREAD_ALL_ACCESS         (STANDARD_RIGHTS_REQUIRED | SYNCHRONIZE | \
                                   0x3FF)
#endif
//
// ClientId
//

typedef struct _CLIENT_ID {
    HANDLE UniqueProcess;
    HANDLE UniqueThread;
} CLIENT_ID;
typedef CLIENT_ID *PCLIENT_ID;

#define NtCurrentProcess() ( (HANDLE)(LONG_PTR) -1 )  
#define ZwCurrentProcess() NtCurrentProcess()         
#define NtCurrentThread() ( (HANDLE)(LONG_PTR) -2 )   
#define ZwCurrentThread() NtCurrentThread()           

//
// =========================================
// Define GUIDs which represent well-known power schemes
// =========================================
//

//
// Maximum Power Savings - indicates that very aggressive power savings measures will be used to help
//                         stretch battery life.
//
// {a1841308-3541-4fab-bc81-f71556f20b4a}
//
DEFINE_GUID( GUID_MAX_POWER_SAVINGS, 0xA1841308, 0x3541, 0x4FAB, 0xBC, 0x81, 0xF7, 0x15, 0x56, 0xF2, 0x0B, 0x4A );

//
// No Power Savings - indicates that almost no power savings measures will be used.
//
// {8c5e7fda-e8bf-4a96-9a85-a6e23a8c635c}
//
DEFINE_GUID( GUID_MIN_POWER_SAVINGS, 0x8C5E7FDA, 0xE8BF, 0x4A96, 0x9A, 0x85, 0xA6, 0xE2, 0x3A, 0x8C, 0x63, 0x5C );

//
// Typical Power Savings - indicates that fairly aggressive power savings measures will be used.
//
// {381b4222-f694-41f0-9685-ff5bb260df2e}
//
DEFINE_GUID( GUID_TYPICAL_POWER_SAVINGS, 0x381B4222, 0xF694, 0x41F0, 0x96, 0x85, 0xFF, 0x5B, 0xB2, 0x60, 0xDF, 0x2E );

//
// This is a special GUID that represents "no subgroup" of settings.  That is, it indicates
// that settings that are in the root of the power policy hierarchy as opposed to settings
// that are buried under a subgroup of settings.  This should be used when querying for
// power settings that may not fall into a subgroup.
//
DEFINE_GUID( NO_SUBGROUP_GUID, 0xFEA3413E, 0x7E05, 0x4911, 0x9A, 0x71, 0x70, 0x03, 0x31, 0xF1, 0xC2, 0x94 );

//
// This is a special GUID that represents "every power scheme".  That is, it indicates
// that any write to this power scheme should be reflected to every scheme present.
// This allows users to write a single setting once and have it apply to all schemes.  They
// can then apply custom settings to specific power schemes that they care about.
//
DEFINE_GUID( ALL_POWERSCHEMES_GUID, 0x68A1E95E, 0x13EA, 0x41E1, 0x80, 0x11, 0x0C, 0x49, 0x6C, 0xA4, 0x90, 0xB0 );

//
// This is a special GUID that represents a 'personality' that each power scheme will have.
// In other words, each power scheme will have this key indicating "I'm most like *this* base
// power scheme."  This individual setting will have one of three settings:
// GUID_MAX_POWER_SAVINGS
// GUID_MIN_POWER_SAVINGS
// GUID_TYPICAL_POWER_SAVINGS
//
// This allows several features:
// 1. Drivers and applications can register for notification of this GUID.  So when this power
//    scheme is activiated, this GUID's setting will be sent across the system and drivers/applications
//    can see "GUID_MAX_POWER_SAVINGS" which will tell them in a generic fashion "get real aggressive
//    about conserving power".
// 2. UserB may install a driver or application which creates power settings, and UserB may modify
//    those power settings.  Now UserA logs in.  How does he see those settings?  They simply don't
//    exist in his private power key.  Well they do exist over in the system power key.  When we
//    enumerate all the power settings in this system power key and don't find a corresponding entry
//    in the user's private power key, then we can go look at this "personality" key in the users
//    power scheme.  We can then go get a default value for the power setting, depending on which
//    "personality" power scheme is being operated on.  Here's an example:
//    A. UserB installs an application that creates a power setting Seetting1
//    B. UserB changes Setting1 to have a value of 50 because that's one of the possible settings
//       available for setting1.
//    C. UserB logs out
//    D. UserA logs in and his active power scheme is some custom scheme that was derived from
//       the GUID_TYPICAL_POWER_SAVINGS.  But remember that UserA has no setting1 in his
//       private power key.
//    E. When activating UserA's selected power scheme, all power settings in the system power key will
//       be enumerated (including Setting1).
//    F. The power manager will see that UserA has no Setting1 power setting in his private power scheme.
//    G. The power manager will query UserA's power scheme for its personality and retrieve
//       GUID_TYPICAL_POWER_SAVINGS.
//    H. The power manager then looks in Setting1 in the system power key and looks in its set of default
//       values for the corresponding value for GUID_TYPICAL_POWER_SAVINGS power schemes.
//    I. This derived power setting is applied.
DEFINE_GUID( GUID_POWERSCHEME_PERSONALITY, 0x245D8541, 0x3943, 0x4422, 0xB0, 0x25, 0x13, 0xA7, 0x84, 0xF6, 0x79, 0xB7 );

//
// Define a special GUID which will be used to define the active power scheme.
// User will register for this power setting GUID, and when the active power
// scheme changes, they'll get a callback where the payload is the GUID
// representing the active powerscheme.
// ( 31F9F286-5084-42FE-B720-2B0264993763 }
//
DEFINE_GUID( GUID_ACTIVE_POWERSCHEME, 0x31F9F286, 0x5084, 0x42FE, 0xB7, 0x20, 0x2B, 0x02, 0x64, 0x99, 0x37, 0x63 );

//
// =========================================
// Define GUIDs which represent well-known power settings
// =========================================
//

// Video settings
// --------------
//
// Specifies the subgroup which will contain all of the video
// settings for a single policy.
//
DEFINE_GUID( GUID_VIDEO_SUBGROUP, 0x7516B95F, 0xF776, 0x4464, 0x8C, 0x53, 0x06, 0x16, 0x7F, 0x40, 0xCC, 0x99 );

//
// Specifies (in seconds) how long we wait after the last user input has been
// recieved before we power off the video.
//
DEFINE_GUID( GUID_VIDEO_POWERDOWN_TIMEOUT, 0x3C0BC021, 0xC8A8, 0x4E07, 0xA9, 0x73, 0x6B, 0x14, 0xCB, 0xCB, 0x2B, 0x7E );

//
// Specifies if the operating system should use adaptive timers (based on
// previous behavior) to power down the video,
//
DEFINE_GUID( GUID_VIDEO_ADAPTIVE_POWERDOWN, 0x90959D22, 0xD6A1, 0x49B9, 0xAF, 0x93, 0xBC, 0xE8, 0x85, 0xAD, 0x33, 0x5B );

//
// Specifies if the monitor is currently being powered or not.
// 02731015-4510-4526-99E6-E5A17EBD1AEA
//
DEFINE_GUID( GUID_MONITOR_POWER_ON, 0x02731015, 0x4510, 0x4526, 0x99, 0xE6, 0xE5, 0xA1, 0x7E, 0xBD, 0x1A, 0xEA );

// Harddisk settings
// -----------------
//
// Specifies the subgroup which will contain all of the harddisk
// settings for a single policy.
//
DEFINE_GUID( GUID_DISK_SUBGROUP, 0x0012EE47, 0x9041, 0x4B5D, 0x9B, 0x77, 0x53, 0x5F, 0xBA, 0x8B, 0x14, 0x42 );

//
// Specifies (in seconds) how long we wait after the last disk access
// before we power off the disk.
//
DEFINE_GUID( GUID_DISK_POWERDOWN_TIMEOUT, 0x6738E2C4, 0xE8A5, 0x4A42, 0xB1, 0x6A, 0xE0, 0x40, 0xE7, 0x69, 0x75, 0x6E );

//
// Specifies the amount of contiguous disk activity time to ignore when
// calculating disk idleness.
//
// 80e3c60e-bb94-4ad8-bbe0-0d3195efc663
//

DEFINE_GUID( GUID_DISK_BURST_IGNORE_THRESHOLD, 0x80e3c60e, 0xbb94, 0x4ad8, 0xbb, 0xe0, 0x0d, 0x31, 0x95, 0xef, 0xc6, 0x63 );

//
// Specifies if the operating system should use adaptive timers (based on
// previous behavior) to power down the disk,
//
DEFINE_GUID( GUID_DISK_ADAPTIVE_POWERDOWN, 0x396A32E1, 0x499A, 0x40B2, 0x91, 0x24, 0xA9, 0x6A, 0xFE, 0x70, 0x76, 0x67 );

// System sleep settings
// ---------------------
//
// Specifies the subgroup which will contain all of the sleep
// settings for a single policy.
// { 238C9FA8-0AAD-41ED-83F4-97BE242C8F20 }
//
DEFINE_GUID( GUID_SLEEP_SUBGROUP, 0x238C9FA8, 0x0AAD, 0x41ED, 0x83, 0xF4, 0x97, 0xBE, 0x24, 0x2C, 0x8F, 0x20 );

//
// Specifies an idle treshold percentage (0-100). The system must be this idle
// over a period of time in order to idle to sleep.
//
DEFINE_GUID( GUID_SLEEP_IDLE_THRESHOLD, 0x81cd32e0, 0x7833, 0x44f3, 0x87, 0x37, 0x70, 0x81, 0xf3, 0x8d, 0x1f, 0x70 );

//
// Specifies (in seconds) how long we wait after the system is deemed
// "idle" before moving to standby (S1, S2 or S3).
//
DEFINE_GUID( GUID_STANDBY_TIMEOUT, 0x29F6C1DB, 0x86DA, 0x48C5, 0x9F, 0xDB, 0xF2, 0xB6, 0x7B, 0x1F, 0x44, 0xDA );

//
// Specifies (in seconds) how long the system should go back to sleep after
// waking unattended. 0 indicates that the standard standby/hibernate idle
// policy should be used instead.
//
// {7bc4a2f9-d8fc-4469-b07b-33eb785aaca0}
//
DEFINE_GUID( GUID_UNATTEND_SLEEP_TIMEOUT, 0x7bc4a2f9, 0xd8fc, 0x4469, 0xb0, 0x7b, 0x33, 0xeb, 0x78, 0x5a, 0xac, 0xa0 );

//
// Specifies (in seconds) how long we wait after the system is deemed
// "idle" before moving to hibernate (S4).
//
DEFINE_GUID( GUID_HIBERNATE_TIMEOUT, 0x9D7815A6, 0x7EE4, 0x497E, 0x88, 0x88, 0x51, 0x5A, 0x05, 0xF0, 0x23, 0x64 );

//
// Specifies whether or not Fast S4 should be enabled if the system supports it
// 94AC6D29-73CE-41A6-809F-6363BA21B47E
//
DEFINE_GUID( GUID_HIBERNATE_FASTS4_POLICY, 0x94AC6D29, 0x73CE, 0x41A6, 0x80, 0x9F, 0x63, 0x63, 0xBA, 0x21, 0xB4, 0x7E );

//
// Define a GUID for controlling the criticality of sleep state transitions.
// Critical sleep transitions do not query applications, services or drivers
// before transitioning the platform to a sleep state.
//
// {B7A27025-E569-46c2-A504-2B96CAD225A1}
//
DEFINE_GUID( GUID_CRITICAL_POWER_TRANSITION,  0xB7A27025, 0xE569, 0x46c2, 0xA5, 0x04, 0x2B, 0x96, 0xCA, 0xD2, 0x25, 0xA1);

//
// Specifies if the system is entering or exiting 'away mode'.
// 98A7F580-01F7-48AA-9C0F-44352C29E5C0
//
DEFINE_GUID( GUID_SYSTEM_AWAYMODE, 0x98A7F580, 0x01F7, 0x48AA, 0x9C, 0x0F, 0x44, 0x35, 0x2C, 0x29, 0xE5, 0xC0 );

// Specify whether away mode is allowed
//
// {25DFA149-5DD1-4736-B5AB-E8A37B5B8187}
//
DEFINE_GUID( GUID_ALLOW_AWAYMODE, 0x25dfa149, 0x5dd1, 0x4736, 0xb5, 0xab, 0xe8, 0xa3, 0x7b, 0x5b, 0x81, 0x87 );

//
// Defines a guid for enabling/disabling standby (S1-S3) states. This does not
// affect hibernation (S4).
//
// {abfc2519-3608-4c2a-94ea-171b0ed546ab}
//
DEFINE_GUID( GUID_ALLOW_STANDBY_STATES, 0xabfc2519, 0x3608, 0x4c2a, 0x94, 0xea, 0x17, 0x1b, 0x0e, 0xd5, 0x46, 0xab );

//
// Defines a guid for enabling/disabling the ability to wake via RTC.
//
// {BD3B718A-0680-4D9D-8AB2-E1D2B4AC806D}
//
DEFINE_GUID( GUID_ALLOW_RTC_WAKE, 0xBD3B718A, 0x0680, 0x4D9D, 0x8A, 0xB2, 0xE1, 0xD2, 0xB4, 0xAC, 0x80, 0x6D );

// System button actions
// ---------------------
//
//
// Specifies the subgroup which will contain all of the system button
// settings for a single policy.
//
DEFINE_GUID( GUID_SYSTEM_BUTTON_SUBGROUP, 0x4F971E89, 0xEEBD, 0x4455, 0xA8, 0xDE, 0x9E, 0x59, 0x04, 0x0E, 0x73, 0x47 );

// Specifies (in a POWER_ACTION_POLICY structure) the appropriate action to
// take when the system power button is pressed.
//
DEFINE_GUID( GUID_POWERBUTTON_ACTION, 0x7648EFA3, 0xDD9C, 0x4E3E, 0xB5, 0x66, 0x50, 0xF9, 0x29, 0x38, 0x62, 0x80 );
DEFINE_GUID( GUID_POWERBUTTON_ACTION_FLAGS, 0x857E7FAC, 0x034B, 0x4704, 0xAB, 0xB1, 0xBC, 0xA5, 0x4A, 0xA3, 0x14, 0x78 );

//
// Specifies (in a POWER_ACTION_POLICY structure) the appropriate action to
// take when the system sleep button is pressed.
//
DEFINE_GUID( GUID_SLEEPBUTTON_ACTION, 0x96996BC0, 0xAD50, 0x47EC, 0x92, 0x3B, 0x6F, 0x41, 0x87, 0x4D, 0xD9, 0xEB );
DEFINE_GUID( GUID_SLEEPBUTTON_ACTION_FLAGS, 0x2A160AB1, 0xB69D, 0x4743, 0xB7, 0x18, 0xBF, 0x14, 0x41, 0xD5, 0xE4, 0x93 );

//
// Specifies (in a POWER_ACTION_POLICY structure) the appropriate action to
// take when the system sleep button is pressed.
// { A7066653-8D6C-40A8-910E-A1F54B84C7E5 }
//
DEFINE_GUID( GUID_USERINTERFACEBUTTON_ACTION, 0xA7066653, 0x8D6C, 0x40A8, 0x91, 0x0E, 0xA1, 0xF5, 0x4B, 0x84, 0xC7, 0xE5 );

//
// Specifies (in a POWER_ACTION_POLICY structure) the appropriate action to
// take when the system lid is closed.
//
DEFINE_GUID( GUID_LIDCLOSE_ACTION, 0x5CA83367, 0x6E45, 0x459F, 0xA2, 0x7B, 0x47, 0x6B, 0x1D, 0x01, 0xC9, 0x36 );
DEFINE_GUID( GUID_LIDCLOSE_ACTION_FLAGS, 0x97E969AC, 0x0D6C, 0x4D08, 0x92, 0x7C, 0xD7, 0xBD, 0x7A, 0xD7, 0x85, 0x7B );
DEFINE_GUID( GUID_LIDOPEN_POWERSTATE, 0x99FF10E7, 0x23B1, 0x4C07, 0xA9, 0xD1, 0x5C, 0x32, 0x06, 0xD7, 0x41, 0xB4 );


// Battery Discharge Settings
// --------------------------
//
// Specifies the subgroup which will contain all of the battery discharge
// settings for a single policy.
//
DEFINE_GUID( GUID_BATTERY_SUBGROUP, 0xE73A048D, 0xBF27, 0x4F12, 0x97, 0x31, 0x8B, 0x20, 0x76, 0xE8, 0x89, 0x1F );

//
// 4 battery discharge alarm settings.
//
// GUID_BATTERY_DISCHARGE_ACTION_x - This is the action to take.  It is a value
//                                   of type POWER_ACTION
// GUID_BATTERY_DISCHARGE_LEVEL_x  - This is the battery level (%)
// GUID_BATTERY_DISCHARGE_FLAGS_x  - Flags defined below:
//                                   POWER_ACTION_POLICY->EventCode flags
//                                   BATTERY_DISCHARGE_FLAGS_EVENTCODE_MASK
//                                   BATTERY_DISCHARGE_FLAGS_ENABLE
DEFINE_GUID( GUID_BATTERY_DISCHARGE_ACTION_0, 0x637EA02F, 0xBBCB, 0x4015, 0x8E, 0x2C, 0xA1, 0xC7, 0xB9, 0xC0, 0xB5, 0x46 );
DEFINE_GUID( GUID_BATTERY_DISCHARGE_LEVEL_0, 0x9A66D8D7, 0x4FF7, 0x4EF9, 0xB5, 0xA2, 0x5A, 0x32, 0x6C, 0xA2, 0xA4, 0x69 );
DEFINE_GUID( GUID_BATTERY_DISCHARGE_FLAGS_0, 0x5dbb7c9f, 0x38e9, 0x40d2, 0x97, 0x49, 0x4f, 0x8a, 0x0e, 0x9f, 0x64, 0x0f );

DEFINE_GUID( GUID_BATTERY_DISCHARGE_ACTION_1, 0xD8742DCB, 0x3E6A, 0x4B3C, 0xB3, 0xFE, 0x37, 0x46, 0x23, 0xCD, 0xCF, 0x06 );
DEFINE_GUID( GUID_BATTERY_DISCHARGE_LEVEL_1, 0x8183BA9A, 0xE910, 0x48DA, 0x87, 0x69, 0x14, 0xAE, 0x6D, 0xC1, 0x17, 0x0A );
DEFINE_GUID( GUID_BATTERY_DISCHARGE_FLAGS_1, 0xbcded951, 0x187b, 0x4d05, 0xbc, 0xcc, 0xf7, 0xe5, 0x19, 0x60, 0xc2, 0x58 );

DEFINE_GUID( GUID_BATTERY_DISCHARGE_ACTION_2, 0x421CBA38, 0x1A8E, 0x4881, 0xAC, 0x89, 0xE3, 0x3A, 0x8B, 0x04, 0xEC, 0xE4 );
DEFINE_GUID( GUID_BATTERY_DISCHARGE_LEVEL_2, 0x07A07CA2, 0xADAF, 0x40D7, 0xB0, 0x77, 0x53, 0x3A, 0xAD, 0xED, 0x1B, 0xFA );
DEFINE_GUID( GUID_BATTERY_DISCHARGE_FLAGS_2, 0x7fd2f0c4, 0xfeb7, 0x4da3, 0x81, 0x17, 0xe3, 0xfb, 0xed, 0xc4, 0x65, 0x82 );

DEFINE_GUID( GUID_BATTERY_DISCHARGE_ACTION_3, 0x80472613, 0x9780, 0x455E, 0xB3, 0x08, 0x72, 0xD3, 0x00, 0x3C, 0xF2, 0xF8 );
DEFINE_GUID( GUID_BATTERY_DISCHARGE_LEVEL_3, 0x58AFD5A6, 0xC2DD, 0x47D2, 0x9F, 0xBF, 0xEF, 0x70, 0xCC, 0x5C, 0x59, 0x65 );
DEFINE_GUID( GUID_BATTERY_DISCHARGE_FLAGS_3, 0x73613ccf, 0xdbfa, 0x4279, 0x83, 0x56, 0x49, 0x35, 0xf6, 0xbf, 0x62, 0xf3 );

// Processor power settings
// ------------------------
//

// Specifies the subgroup which will contain all of the processor
// settings for a single policy.
//
DEFINE_GUID( GUID_PROCESSOR_SETTINGS_SUBGROUP, 0x54533251, 0x82BE, 0x4824, 0x96, 0xC1, 0x47, 0xB6, 0x0B, 0x74, 0x0D, 0x00 );


DEFINE_GUID( GUID_PROCESSOR_THROTTLE_POLICY, 0x57027304, 0x4AF6, 0x4104, 0x92, 0x60, 0xE3, 0xD9, 0x52, 0x48, 0xFC, 0x36 );

//
// Specifies a percentage (between 0 and 100) that the processor frequency
// should never go above.  For example, if this value is set to 80, then
// the processor frequency will never be throttled above 80 percent of its
// maximum frequency by the system.
//
DEFINE_GUID( GUID_PROCESSOR_THROTTLE_MAXIMUM, 0xBC5038F7, 0x23E0, 0x4960, 0x96, 0xDA, 0x33, 0xAB, 0xAF, 0x59, 0x35, 0xEC );

//
// Specifies a percentage (between 0 and 100) that the processor frequency
// should not drop below.  For example, if this value is set to 50, then the
// processor frequency will never be throttled below 50 percent of its
// maximum frequency by the system.
//
DEFINE_GUID( GUID_PROCESSOR_THROTTLE_MINIMUM, 0x893DEE8E, 0x2BEF, 0x41E0, 0x89, 0xC6, 0xB5, 0x5D, 0x09, 0x29, 0x96, 0x4C );

//
// Specifies whether throttle states are allowed to be used even when
// performance states are available.
//
// {3b04d4fd-1cc7-4f23-ab1c-d1337819c4bb}
//
DEFINE_GUID( GUID_PROCESSOR_ALLOW_THROTTLING, 0x3b04d4fd, 0x1cc7, 0x4f23, 0xab, 0x1c, 0xd1, 0x33, 0x78, 0x19, 0xc4, 0xbb );

//
// Specifies processor power settings for CState policy data
// {68F262A7-F621-4069-B9A5-4874169BE23C}
//
DEFINE_GUID( GUID_PROCESSOR_IDLESTATE_POLICY, 0x68f262a7, 0xf621, 0x4069, 0xb9, 0xa5, 0x48, 0x74, 0x16, 0x9b, 0xe2, 0x3c);

//
// Specifies processor power settings for PerfState policy data
// {BBDC3814-18E9-4463-8A55-D197327C45C0}
//
DEFINE_GUID( GUID_PROCESSOR_PERFSTATE_POLICY, 0xBBDC3814, 0x18E9, 0x4463, 0x8A, 0x55, 0xD1, 0x97, 0x32, 0x7C, 0x45, 0xC0);

//
// Specifies active vs passive cooling.  Although not directly related to
// processor settings, it is the processor that gets throttled if we're doing
// passive cooling, so it is fairly strongly related.
// {94D3A615-A899-4AC5-AE2B-E4D8F634367F}
//
DEFINE_GUID( GUID_SYSTEM_COOLING_POLICY, 0x94D3A615, 0xA899, 0x4AC5, 0xAE, 0x2B, 0xE4, 0xD8, 0xF6, 0x34, 0x36, 0x7F);

// Lock Console on Wake
// --------------------
//

// Specifies the behavior of the system when we wake from standby or
// hibernate.  If this is set, then we will cause the console to lock
// after we resume.
//
DEFINE_GUID( GUID_LOCK_CONSOLE_ON_WAKE, 0x0E796BDB, 0x100D, 0x47D6, 0xA2, 0xD5, 0xF7, 0xD2, 0xDA, 0xA5, 0x1F, 0x51 );

// Device idle characteristics
// ---------------------------
//
// Specifies whether to use the "performance" or "conservative" timeouts for
// device idle management.
//
// 4faab71a-92e5-4726-b531-224559672d19
//
DEFINE_GUID( GUID_DEVICE_IDLE_POLICY, 0x4faab71a, 0x92e5, 0x4726, 0xb5, 0x31, 0x22, 0x45, 0x59, 0x67, 0x2d, 0x19 );

#define POWER_DEVICE_IDLE_POLICY_PERFORMANCE  0
#define POWER_DEVICE_IDLE_POLICY_CONSERVATIVE 1

// AC/DC power source
// ------------------
//

// Specifies the power source for the system.  consumers may register for
// notification when the power source changes and will be notified with
// one of 3 values:
// 0 - Indicates the system is being powered by an AC power source.
// 1 - Indicates the system is being powered by a DC power source.
// 2 - Indicates the system is being powered by a short-term DC power
//     source.  For example, this would be the case if the system is
//     being powed by a short-term battery supply in a backing UPS
//     system.  When this value is recieved, the consumer should make
//     preparations for either a system hibernate or system shutdown.
//
// { 5D3E9A59-E9D5-4B00-A6BD-FF34FF516548 }
DEFINE_GUID( GUID_ACDC_POWER_SOURCE, 0x5D3E9A59, 0xE9D5, 0x4B00, 0xA6, 0xBD, 0xFF, 0x34, 0xFF, 0x51, 0x65, 0x48 );

// Lid state changes
// -----------------
//
// Specifies the current state of the lid (open or closed). The callback won't
// be called at all until a lid device is found and its current state is known.
//
// Values:
//
// 0 - closed
// 1 - opened
//
// { BA3E0F4D-B817-4094-A2D1-D56379E6A0F3 }
//

DEFINE_GUID( GUID_LIDSWITCH_STATE_CHANGE,  0xBA3E0F4D, 0xB817, 0x4094, 0xA2, 0xD1, 0xD5, 0x63, 0x79, 0xE6, 0xA0, 0xF3 );

// Battery life remaining
// ----------------------
//

// Specifies the percentage of battery life remaining.  The consumer
// may register for notification in order to track battery life in
// a fine-grained manner.
//
// Once registered, the consumer can expect to be notified as the battery
// life percentage changes.
//
// The consumer will recieve a value between 0 and 100 (inclusive) which
// indicates percent battery life remaining.
//
// { A7AD8041-B45A-4CAE-87A3-EECBB468A9E1 }
DEFINE_GUID( GUID_BATTERY_PERCENTAGE_REMAINING, 0xA7AD8041, 0xB45A, 0x4CAE, 0x87, 0xA3, 0xEE, 0xCB, 0xB4, 0x68, 0xA9, 0xE1 );


// Notification to listeners that the system is fairly busy and won't be moving
// into an idle state any time soon.  This can be used as a hint to listeners
// that now might be a good time to do background tasks.
//
DEFINE_GUID( GUID_IDLE_BACKGROUND_TASK, 0x515C31D8, 0xF734, 0x163D, 0xA0, 0xFD, 0x11, 0xA0, 0x8C, 0x91, 0xE8, 0xF1 );

// Notification to listeners that the system is fairly busy and won't be moving
// into an idle state any time soon.  This can be used as a hint to listeners
// that now might be a good time to do background tasks.
//
// { CF23F240-2A54-48D8-B114-DE1518FF052E }
DEFINE_GUID( GUID_BACKGROUND_TASK_NOTIFICATION, 0xCF23F240, 0x2A54, 0x48D8, 0xB1, 0x14, 0xDE, 0x15, 0x18, 0xFF, 0x05, 0x2E );

// Define a GUID that will represent the action of a direct experience button
// on the platform.  Users will register for this DPPE setting and recieve
// notification when the h/w button is pressed.
//
// { 1A689231-7399-4E9A-8F99-B71F999DB3FA }
//
DEFINE_GUID( GUID_APPLAUNCH_BUTTON, 0x1A689231, 0x7399, 0x4E9A, 0x8F, 0x99, 0xB7, 0x1F, 0x99, 0x9D, 0xB3, 0xFA );

// PCI Express power settings
// ------------------------
//

// Specifies the subgroup which will contain all of the PCI Express
// settings for a single policy.
//
// {501a4d13-42af-4429-9fd1-a8218c268e20}
//
DEFINE_GUID( GUID_PCIEXPRESS_SETTINGS_SUBGROUP, 0x501a4d13, 0x42af,0x4429, 0x9f, 0xd1, 0xa8, 0x21, 0x8c, 0x26, 0x8e, 0x20 );

// Specifies the PCI Express ASPM power policy.
//
// {ee12f906-d277-404b-b6da-e5fa1a576df5}
//
DEFINE_GUID( GUID_PCIEXPRESS_ASPM_POLICY, 0xee12f906, 0xd277, 0x404b, 0xb6, 0xda, 0xe5, 0xfa, 0x1a, 0x57, 0x6d, 0xf5 );


#ifndef _PO_DDK_
#define _PO_DDK_



typedef enum _SYSTEM_POWER_STATE {
    PowerSystemUnspecified = 0,
    PowerSystemWorking     = 1,
    PowerSystemSleeping1   = 2,
    PowerSystemSleeping2   = 3,
    PowerSystemSleeping3   = 4,
    PowerSystemHibernate   = 5,
    PowerSystemShutdown    = 6,
    PowerSystemMaximum     = 7
} SYSTEM_POWER_STATE, *PSYSTEM_POWER_STATE;

#define POWER_SYSTEM_MAXIMUM 7

typedef enum {
    PowerActionNone = 0,
    PowerActionReserved,
    PowerActionSleep,
    PowerActionHibernate,
    PowerActionShutdown,
    PowerActionShutdownReset,
    PowerActionShutdownOff,
    PowerActionWarmEject
} POWER_ACTION, *PPOWER_ACTION;

typedef enum _DEVICE_POWER_STATE {
    PowerDeviceUnspecified = 0,
    PowerDeviceD0,
    PowerDeviceD1,
    PowerDeviceD2,
    PowerDeviceD3,
    PowerDeviceMaximum
} DEVICE_POWER_STATE, *PDEVICE_POWER_STATE;




typedef union _POWER_STATE {
    SYSTEM_POWER_STATE SystemState;
    DEVICE_POWER_STATE DeviceState;
} POWER_STATE, *PPOWER_STATE;

typedef enum _POWER_STATE_TYPE {
    SystemPowerState = 0,
    DevicePowerState
} POWER_STATE_TYPE, *PPOWER_STATE_TYPE;

#if (NTDDI_VERSION >= NTDDI_VISTA)
typedef struct _SYSTEM_POWER_STATE_CONTEXT {
    union {
        struct {
            ULONG   Reserved1             : 8;
            ULONG   TargetSystemState     : 4;
            ULONG   EffectiveSystemState  : 4;
            ULONG   CurrentSystemState    : 4;
            ULONG   IgnoreHibernationPath : 1;
            ULONG   PseudoTransition      : 1;
            ULONG   Reserved2             : 10;
        } DUMMYSTRUCTNAME;

        ULONG ContextAsUlong;
    } DUMMYUNIONNAME;
} SYSTEM_POWER_STATE_CONTEXT, *PSYSTEM_POWER_STATE_CONTEXT;
#endif // (NTDDI_VERSION >= NTDDI_VISTA)

//
// Generic power related IOCTLs
//

#define IOCTL_QUERY_DEVICE_POWER_STATE  \
        CTL_CODE(FILE_DEVICE_BATTERY, 0x0, METHOD_BUFFERED, FILE_READ_ACCESS)

#define IOCTL_SET_DEVICE_WAKE           \
        CTL_CODE(FILE_DEVICE_BATTERY, 0x1, METHOD_BUFFERED, FILE_WRITE_ACCESS)

#define IOCTL_CANCEL_DEVICE_WAKE        \
        CTL_CODE(FILE_DEVICE_BATTERY, 0x2, METHOD_BUFFERED, FILE_WRITE_ACCESS)


//
// Defines for W32 interfaces
//



#define ES_SYSTEM_REQUIRED   ((ULONG)0x00000001)
#define ES_DISPLAY_REQUIRED  ((ULONG)0x00000002)
#define ES_USER_PRESENT      ((ULONG)0x00000004)
#define ES_AWAYMODE_REQUIRED ((ULONG)0x00000040)
#define ES_CONTINUOUS        ((ULONG)0x80000000)

typedef ULONG EXECUTION_STATE;

typedef enum {
    LT_DONT_CARE,
    LT_LOWEST_LATENCY
} LATENCY_TIME;



#if (NTDDI_VERSION >= NTDDI_WINXP)

//-----------------------------------------------------------------------------
// Device Power Information
// Accessable via CM_Get_DevInst_Registry_Property_Ex(CM_DRP_DEVICE_POWER_DATA)
//-----------------------------------------------------------------------------

#define PDCAP_D0_SUPPORTED              0x00000001
#define PDCAP_D1_SUPPORTED              0x00000002
#define PDCAP_D2_SUPPORTED              0x00000004
#define PDCAP_D3_SUPPORTED              0x00000008
#define PDCAP_WAKE_FROM_D0_SUPPORTED    0x00000010
#define PDCAP_WAKE_FROM_D1_SUPPORTED    0x00000020
#define PDCAP_WAKE_FROM_D2_SUPPORTED    0x00000040
#define PDCAP_WAKE_FROM_D3_SUPPORTED    0x00000080
#define PDCAP_WARM_EJECT_SUPPORTED      0x00000100

typedef struct CM_Power_Data_s {
    ULONG               PD_Size;
    DEVICE_POWER_STATE  PD_MostRecentPowerState;
    ULONG               PD_Capabilities;
    ULONG               PD_D1Latency;
    ULONG               PD_D2Latency;
    ULONG               PD_D3Latency;
    DEVICE_POWER_STATE  PD_PowerStateMapping[POWER_SYSTEM_MAXIMUM];
    SYSTEM_POWER_STATE  PD_DeepestSystemWake;
} CM_POWER_DATA, *PCM_POWER_DATA;

#endif // (NTDDI_VERSION >= NTDDI_WINXP)



typedef enum {
    SystemPowerPolicyAc,
    SystemPowerPolicyDc,
    VerifySystemPolicyAc,
    VerifySystemPolicyDc,
    SystemPowerCapabilities,
    SystemBatteryState,
    SystemPowerStateHandler,
    ProcessorStateHandler,
    SystemPowerPolicyCurrent,
    AdministratorPowerPolicy,
    SystemReserveHiberFile,
    ProcessorInformation,
    SystemPowerInformation,
    ProcessorStateHandler2,
    LastWakeTime,                                   // Compare with KeQueryInterruptTime()
    LastSleepTime,                                  // Compare with KeQueryInterruptTime()
    SystemExecutionState,
    SystemPowerStateNotifyHandler,
    ProcessorPowerPolicyAc,
    ProcessorPowerPolicyDc,
    VerifyProcessorPowerPolicyAc,
    VerifyProcessorPowerPolicyDc,
    ProcessorPowerPolicyCurrent,
    SystemPowerStateLogging,
    SystemPowerLoggingEntry,
    SetPowerSettingValue,
    NotifyUserPowerSetting,
    GetPowerTransitionVetoes,
    SetPowerTransitionVeto,
    SystemVideoState,
    TraceApplicationPowerMessage,
    TraceApplicationPowerMessageEnd,
    ProcessorPerfStates,
    ProcessorIdleStates,
    ProcessorThrottleStates,
    SystemWakeSource,
    SystemHiberFileInformation,
    TraceServicePowerMessage,
    ProcessorLoad,
    PowerShutdownNotification,
    MonitorCapabilities
} POWER_INFORMATION_LEVEL;

//
// Power Transition Vetos
//

#define PO_TRANSITION_VETO_TYPE_WINDOW  0x00000001
#define PO_TRANSITION_VETO_TYPE_SERVICE 0x00000002
//#define PO_TRANSITION_VETO_TYPE_DRIVER  0x00000004

#define PO_TRANSITION_VETO_TYPE_ALL     \
    (PO_TRANSITION_VETO_TYPE_WINDOW | PO_TRANSITION_VETO_TYPE_SERVICE)

typedef struct _PO_TRANSITION_VETO_REASON {
    ULONG ResourceId;
    ULONG ModuleNameOffset;
} PO_TRANSITION_VETO_REASON, *PPO_TRANSITION_VETO_REASON;

typedef struct _PO_TRANSITION_VETO_WINDOW {
    HANDLE Handle;
} PO_TRANSITION_VETO_WINDOW, *PPO_TRANSITION_VETO_WINDOW;

typedef struct _PO_TRANSITION_VETO_SERVICE {
    ULONG ServiceNameOffset;
} PO_TRANSITION_VETO_SERVICE, *PPO_TRANSITION_VETO_SERVICE;

/*

typedef struct _PO_TRANSITION_VETO_DRIVER {
    ULONG InstancePathOffset;
    ULONG DriverNameOffset;
} PO_TRANSITION_VETO_DRIVER, *PPO_TRANSITION_VETO_DRIVER;

*/

typedef struct _PO_TRANSITION_VETO {
    ULONG Type;
    PO_TRANSITION_VETO_REASON Reason;
    ULONG ProcessId;

    union {
        PO_TRANSITION_VETO_WINDOW Window;
        PO_TRANSITION_VETO_SERVICE Service;
        //PO_TRANSITION_VETO_DRIVER Driver;
    } DUMMYUNIONNAME;
} PO_TRANSITION_VETO, *PPO_TRANSITION_VETO;

typedef struct _PO_TRANSITION_VETOES {
    ULONG Count;
    PO_TRANSITION_VETO Vetoes[ANYSIZE_ARRAY];
} PO_TRANSITION_VETOES, *PPO_TRANSITION_VETOES;

//
// Power Setting definitions
//

typedef enum {
    PoAc,
    PoDc,
    PoHot,
    PoConditionMaximum
} SYSTEM_POWER_CONDITION;

typedef struct {

    //
    // Version of this structure.  Currently should be set to
    // POWER_SETTING_VALUE_VERSION.
    //
    ULONG       Version;


    //
    // GUID representing the power setting being applied.
    //
    GUID        Guid;


    //
    // What power state should this setting be applied to?  E.g.
    // AC, DC, thermal, ...
    //
    SYSTEM_POWER_CONDITION PowerCondition;

    //
    // Length (in bytes) of the 'Data' member.
    //
    ULONG       DataLength;

    //
    // Data which contains the actual setting value.
    //
    UCHAR   Data[ANYSIZE_ARRAY];
} SET_POWER_SETTING_VALUE, *PSET_POWER_SETTING_VALUE;

#define POWER_SETTING_VALUE_VERSION (0x1)

typedef struct {
    GUID Guid;
} NOTIFY_USER_POWER_SETTING, *PNOTIFY_USER_POWER_SETTING;

//
// Package definition for an experience button device notification.  When
// someone registers for GUID_EXPERIENCE_BUTTON, this is the definition of
// the setting data they'll get.
//
typedef struct _APPLICATIONLAUNCH_SETTING_VALUE {

    //
    // System time when the most recent button press ocurred.  Note that this is
    // specified in 100ns internvals since January 1, 1601.
    //
    LARGE_INTEGER       ActivationTime;

    //
    // Reserved for internal use.
    //
    ULONG               Flags;

    //
    // which instance of this device was pressed?
    //
    ULONG               ButtonInstanceID;


} APPLICATIONLAUNCH_SETTING_VALUE, *PAPPLICATIONLAUNCH_SETTING_VALUE;

//
// define platform roles
//

typedef enum {
    PlatformRoleUnspecified = 0,
    PlatformRoleDesktop,
    PlatformRoleMobile,
    PlatformRoleWorkstation,
    PlatformRoleEnterpriseServer,
    PlatformRoleSOHOServer,
    PlatformRoleAppliancePC,
    PlatformRolePerformanceServer,
    PlatformRoleMaximum
} POWER_PLATFORM_ROLE;

//
// Wake source tracking
//

typedef enum {
    DeviceWakeSourceType,
    FixedWakeSourceType
} PO_WAKE_SOURCE_TYPE, *PPO_WAKE_SOURCE_TYPE;

typedef enum {
    FixedWakeSourcePowerButton,
    FixedWakeSourceSleepButton,
    FixedWakeSourceRtc
} PO_FIXED_WAKE_SOURCE_TYPE, *PPO_FIXED_WAKE_SOURCE_TYPE;

typedef struct _PO_WAKE_SOURCE_HEADER {
    PO_WAKE_SOURCE_TYPE Type;
    ULONG Size;
} PO_WAKE_SOURCE_HEADER, *PPO_WAKE_SOURCE_HEADER;

typedef struct _PO_WAKE_SOURCE_DEVICE {
    PO_WAKE_SOURCE_HEADER Header;
    WCHAR InstancePath[ANYSIZE_ARRAY];
} PO_WAKE_SOURCE_DEVICE, *PPO_WAKE_SOURCE_DEVICE;

typedef struct _PO_WAKE_SOURCE_FIXED {
    PO_WAKE_SOURCE_HEADER Header;
    PO_FIXED_WAKE_SOURCE_TYPE FixedWakeSourceType;
} PO_WAKE_SOURCE_FIXED, *PPO_WAKE_SOURCE_FIXED;

typedef struct _PO_WAKE_SOURCE_INFO {
    ULONG Count;
    ULONG Offsets[ANYSIZE_ARRAY];
} PO_WAKE_SOURCE_INFO, *PPO_WAKE_SOURCE_INFO;

typedef struct _PO_WAKE_SOURCE_HISTORY {
    ULONG Count;
    ULONG Offsets[ANYSIZE_ARRAY];
} PO_WAKE_SOURCE_HISTORY, *PPO_WAKE_SOURCE_HISTORY;

//
// System power manager capabilities
//

#if (NTDDI_VERSION >= NTDDI_WINXP) || !defined(_BATCLASS_)
typedef struct {
    ULONG       Granularity;
    ULONG       Capacity;
} BATTERY_REPORTING_SCALE, *PBATTERY_REPORTING_SCALE;
#endif // (NTDDI_VERSION >= NTDDI_WINXP) || !defined(_BATCLASS_)


#endif // !_PO_DDK_

//
// Predefined Value Types.
//

#define REG_NONE                    ( 0 )   // No value type
#define REG_SZ                      ( 1 )   // Unicode nul terminated string
#define REG_EXPAND_SZ               ( 2 )   // Unicode nul terminated string
                                            // (with environment variable references)
#define REG_BINARY                  ( 3 )   // Free form binary
#define REG_DWORD                   ( 4 )   // 32-bit number
#define REG_DWORD_LITTLE_ENDIAN     ( 4 )   // 32-bit number (same as REG_DWORD)
#define REG_DWORD_BIG_ENDIAN        ( 5 )   // 32-bit number
#define REG_LINK                    ( 6 )   // Symbolic Link (unicode)
#define REG_MULTI_SZ                ( 7 )   // Multiple Unicode strings
#define REG_RESOURCE_LIST           ( 8 )   // Resource list in the resource map
#define REG_FULL_RESOURCE_DESCRIPTOR ( 9 )  // Resource list in the hardware description
#define REG_RESOURCE_REQUIREMENTS_LIST ( 10 )
#define REG_QWORD                   ( 11 )  // 64-bit number
#define REG_QWORD_LITTLE_ENDIAN     ( 11 )  // 64-bit number (same as REG_QWORD)

//
// Service Types (Bit Mask)
//
#define SERVICE_KERNEL_DRIVER          0x00000001
#define SERVICE_FILE_SYSTEM_DRIVER     0x00000002
#define SERVICE_ADAPTER                0x00000004
#define SERVICE_RECOGNIZER_DRIVER      0x00000008

#define SERVICE_DRIVER                 (SERVICE_KERNEL_DRIVER | \
                                        SERVICE_FILE_SYSTEM_DRIVER | \
                                        SERVICE_RECOGNIZER_DRIVER)

#define SERVICE_WIN32_OWN_PROCESS      0x00000010
#define SERVICE_WIN32_SHARE_PROCESS    0x00000020
#define SERVICE_WIN32                  (SERVICE_WIN32_OWN_PROCESS | \
                                        SERVICE_WIN32_SHARE_PROCESS)

#define SERVICE_INTERACTIVE_PROCESS    0x00000100

#define SERVICE_TYPE_ALL               (SERVICE_WIN32  | \
                                        SERVICE_ADAPTER | \
                                        SERVICE_DRIVER  | \
                                        SERVICE_INTERACTIVE_PROCESS)

//
// Start Type
//

#define SERVICE_BOOT_START             0x00000000
#define SERVICE_SYSTEM_START           0x00000001
#define SERVICE_AUTO_START             0x00000002
#define SERVICE_DEMAND_START           0x00000003
#define SERVICE_DISABLED               0x00000004

//
// Error control type
//
#define SERVICE_ERROR_IGNORE           0x00000000
#define SERVICE_ERROR_NORMAL           0x00000001
#define SERVICE_ERROR_SEVERE           0x00000002
#define SERVICE_ERROR_CRITICAL         0x00000003

//
//
// Define the registry driver node enumerations
//

typedef enum _CM_SERVICE_NODE_TYPE {
    DriverType               = SERVICE_KERNEL_DRIVER,
    FileSystemType           = SERVICE_FILE_SYSTEM_DRIVER,
    Win32ServiceOwnProcess   = SERVICE_WIN32_OWN_PROCESS,
    Win32ServiceShareProcess = SERVICE_WIN32_SHARE_PROCESS,
    AdapterType              = SERVICE_ADAPTER,
    RecognizerType           = SERVICE_RECOGNIZER_DRIVER
} SERVICE_NODE_TYPE;

typedef enum _CM_SERVICE_LOAD_TYPE {
    BootLoad    = SERVICE_BOOT_START,
    SystemLoad  = SERVICE_SYSTEM_START,
    AutoLoad    = SERVICE_AUTO_START,
    DemandLoad  = SERVICE_DEMAND_START,
    DisableLoad = SERVICE_DISABLED
} SERVICE_LOAD_TYPE;

typedef enum _CM_ERROR_CONTROL_TYPE {
    IgnoreError   = SERVICE_ERROR_IGNORE,
    NormalError   = SERVICE_ERROR_NORMAL,
    SevereError   = SERVICE_ERROR_SEVERE,
    CriticalError = SERVICE_ERROR_CRITICAL
} SERVICE_ERROR_TYPE;

//
// Service node Flags
//

//
// The following flag, if set, is used by the OS loader to promote
// a driver's start type to boot start when booting from a network.
//

#define CM_SERVICE_NETWORK_BOOT_LOAD  0x00000001



//
// Resource List definitions
//



//
// Defines the Type in the RESOURCE_DESCRIPTOR
//
// NOTE:  For all CM_RESOURCE_TYPE values, there must be a
// corresponding ResType value in the 32-bit ConfigMgr headerfile
// (cfgmgr32.h).  Values in the range [0x6,0x80) use the same values
// as their ConfigMgr counterparts.  CM_RESOURCE_TYPE values with
// the high bit set (i.e., in the range [0x80,0xFF]), are
// non-arbitrated resources.  These correspond to the same values
// in cfgmgr32.h that have their high bit set (however, since
// cfgmgr32.h uses 16 bits for ResType values, these values are in
// the range [0x8000,0x807F).  Note that ConfigMgr ResType values
// cannot be in the range [0x8080,0xFFFF), because they would not
// be able to map into CM_RESOURCE_TYPE values.  (0xFFFF itself is
// a special value, because it maps to CmResourceTypeDeviceSpecific.)
//

typedef int CM_RESOURCE_TYPE;

// CmResourceTypeNull is reserved

#define CmResourceTypeNull                0   // ResType_All or ResType_None (0x0000)
#define CmResourceTypePort                1   // ResType_IO (0x0002)
#define CmResourceTypeInterrupt           2   // ResType_IRQ (0x0004)
#define CmResourceTypeMemory              3   // ResType_Mem (0x0001)
#define CmResourceTypeDma                 4   // ResType_DMA (0x0003)
#define CmResourceTypeDeviceSpecific      5   // ResType_ClassSpecific (0xFFFF)
#define CmResourceTypeBusNumber           6   // ResType_BusNumber (0x0006)
#define CmResourceTypeMemoryLarge         7   // ResType_LargeMem (0x0007)
#define CmResourceTypeNonArbitrated     128   // Not arbitrated if 0x80 bit set
#define CmResourceTypeConfigData        128   // ResType_Reserved (0x8000)
#define CmResourceTypeDevicePrivate     129   // ResType_DevicePrivate (0x8001)
#define CmResourceTypePcCardConfig      130   // ResType_PcCardConfig (0x8002)
#define CmResourceTypeMfCardConfig      131   // ResType_MfCardConfig (0x8003)

//
// Defines the ShareDisposition in the RESOURCE_DESCRIPTOR
//

typedef enum _CM_SHARE_DISPOSITION {
    CmResourceShareUndetermined = 0,    // Reserved
    CmResourceShareDeviceExclusive,
    CmResourceShareDriverExclusive,
    CmResourceShareShared
} CM_SHARE_DISPOSITION;

//
// Define the bit masks for Flags when type is CmResourceTypeInterrupt
//

#define CM_RESOURCE_INTERRUPT_LEVEL_SENSITIVE           0
#define CM_RESOURCE_INTERRUPT_LATCHED                   1
#define CM_RESOURCE_INTERRUPT_MESSAGE                   2
#define CM_RESOURCE_INTERRUPT_POLICY_INCLUDED           4

//
// A bitmask defining the bits in a resource or requirements descriptor
// flags field that corresponds to the latch mode or a level triggered
// interrupt.
//

#define CM_RESOURCE_INTERRUPT_LEVEL_LATCHED_BITS 0x0001

//
// Define the token value used for an interrupt vector to mean that the vector
// is message signaled.  This value is used in the MaximumVector field.
//

#define CM_RESOURCE_INTERRUPT_MESSAGE_TOKEN   ((ULONG)-2)

//
// Define the bit masks for Flags when type is CmResourceTypeMemory 
// or CmResourceTypeMemoryLarge
//

#define CM_RESOURCE_MEMORY_READ_WRITE                       0x0000
#define CM_RESOURCE_MEMORY_READ_ONLY                        0x0001
#define CM_RESOURCE_MEMORY_WRITE_ONLY                       0x0002
#define CM_RESOURCE_MEMORY_WRITEABILITY_MASK                0x0003
#define CM_RESOURCE_MEMORY_PREFETCHABLE                     0x0004

#define CM_RESOURCE_MEMORY_COMBINEDWRITE                    0x0008
#define CM_RESOURCE_MEMORY_24                               0x0010
#define CM_RESOURCE_MEMORY_CACHEABLE                        0x0020
#define CM_RESOURCE_MEMORY_WINDOW_DECODE                    0x0040
#define CM_RESOURCE_MEMORY_BAR                              0x0080

#define CM_RESOURCE_MEMORY_COMPAT_FOR_INACCESSIBLE_RANGE    0x0100

//
// Define the bit masks exclusive to type CmResourceTypeMemoryLarge.
// 

#define CM_RESOURCE_MEMORY_LARGE                            0x0E00
#define CM_RESOURCE_MEMORY_LARGE_40                         0x0200
#define CM_RESOURCE_MEMORY_LARGE_48                         0x0400
#define CM_RESOURCE_MEMORY_LARGE_64                         0x0800

// 
// Define limits for large memory resources
// 

#define CM_RESOURCE_MEMORY_LARGE_40_MAXLEN          0x000000FFFFFFFF00
#define CM_RESOURCE_MEMORY_LARGE_48_MAXLEN          0x0000FFFFFFFF0000
#define CM_RESOURCE_MEMORY_LARGE_64_MAXLEN          0xFFFFFFFF00000000

//
// Define the bit masks for Flags when type is CmResourceTypePort
//

#define CM_RESOURCE_PORT_MEMORY                             0x0000
#define CM_RESOURCE_PORT_IO                                 0x0001
#define CM_RESOURCE_PORT_10_BIT_DECODE                      0x0004
#define CM_RESOURCE_PORT_12_BIT_DECODE                      0x0008
#define CM_RESOURCE_PORT_16_BIT_DECODE                      0x0010
#define CM_RESOURCE_PORT_POSITIVE_DECODE                    0x0020
#define CM_RESOURCE_PORT_PASSIVE_DECODE                     0x0040
#define CM_RESOURCE_PORT_WINDOW_DECODE                      0x0080
#define CM_RESOURCE_PORT_BAR                                0x0100

//
// Define the bit masks for Flags when type is CmResourceTypeDma
//

#define CM_RESOURCE_DMA_8                   0x0000
#define CM_RESOURCE_DMA_16                  0x0001
#define CM_RESOURCE_DMA_32                  0x0002
#define CM_RESOURCE_DMA_8_AND_16            0x0004
#define CM_RESOURCE_DMA_BUS_MASTER          0x0008
#define CM_RESOURCE_DMA_TYPE_A              0x0010
#define CM_RESOURCE_DMA_TYPE_B              0x0020
#define CM_RESOURCE_DMA_TYPE_F              0x0040



//
// This structure defines one type of resource used by a driver.
//
// There can only be *1* DeviceSpecificData block. It must be located at
// the end of all resource descriptors in a full descriptor block.
//

//
// Make sure alignment is made properly by compiler; otherwise move
// flags back to the top of the structure (common to all members of the
// union).
//


#include "pshpack4.h"
typedef struct _CM_PARTIAL_RESOURCE_DESCRIPTOR {
    UCHAR Type;
    UCHAR ShareDisposition;
    USHORT Flags;
    union {

        //
        // Range of resources, inclusive.  These are physical, bus relative.
        // It is known that Port and Memory below have the exact same layout
        // as Generic.
        //

        struct {
            PHYSICAL_ADDRESS Start;
            ULONG Length;
        } Generic;

        //
        //

        struct {
            PHYSICAL_ADDRESS Start;
            ULONG Length;
        } Port;

        //
        //

        struct {
            ULONG Level;
            ULONG Vector;
            KAFFINITY Affinity;
        } Interrupt;

        //
        // Values for message signaled interrupts are distinct in the
        // raw and translated cases.
        //

        struct {
            union {
               struct {
                   USHORT Reserved;
                   USHORT MessageCount;
                   ULONG Vector;
                   KAFFINITY Affinity;
               } Raw;

               struct {
                   ULONG Level;
                   ULONG Vector;
                   KAFFINITY Affinity;
               } Translated;
            } DUMMYUNIONNAME;
        } MessageInterrupt;
        
        //
        // Range of memory addresses, inclusive. These are physical, bus
        // relative. The value should be the same as the one passed to
        // HalTranslateBusAddress().
        //

        struct {
            PHYSICAL_ADDRESS Start;    // 64 bit physical addresses.
            ULONG Length;
        } Memory;

        //
        // Physical DMA channel.
        //

        struct {
            ULONG Channel;
            ULONG Port;
            ULONG Reserved1;
        } Dma;

        //
        // Device driver private data, usually used to help it figure
        // what the resource assignments decisions that were made.
        //

        struct {
            ULONG Data[3];
        } DevicePrivate;

        //
        // Bus Number information.
        //

        struct {
            ULONG Start;
            ULONG Length;
            ULONG Reserved;
        } BusNumber;

        //
        // Device Specific information defined by the driver.
        // The DataSize field indicates the size of the data in bytes. The
        // data is located immediately after the DeviceSpecificData field in
        // the structure.
        //

        struct {
            ULONG DataSize;
            ULONG Reserved1;
            ULONG Reserved2;
        } DeviceSpecificData;

        // The following structures provide support for memory-mapped
        // IO resources greater than MAXULONG
        struct {
            PHYSICAL_ADDRESS Start;
            ULONG Length40;
        } Memory40;

        struct {
            PHYSICAL_ADDRESS Start;
            ULONG Length48;
        } Memory48;

        struct {
            PHYSICAL_ADDRESS Start;
            ULONG Length64;
        } Memory64;
        
        
    } u;
} CM_PARTIAL_RESOURCE_DESCRIPTOR, *PCM_PARTIAL_RESOURCE_DESCRIPTOR;
#include "poppack.h"

//
// A Partial Resource List is what can be found in the ARC firmware
// or will be generated by ntdetect.com.
// The configuration manager will transform this structure into a Full
// resource descriptor when it is about to store it in the regsitry.
//
// Note: There must a be a convention to the order of fields of same type,
// (defined on a device by device basis) so that the fields can make sense
// to a driver (i.e. when multiple memory ranges are necessary).
//

typedef struct _CM_PARTIAL_RESOURCE_LIST {
    USHORT Version;
    USHORT Revision;
    ULONG Count;
    CM_PARTIAL_RESOURCE_DESCRIPTOR PartialDescriptors[1];
} CM_PARTIAL_RESOURCE_LIST, *PCM_PARTIAL_RESOURCE_LIST;

//
// A Full Resource Descriptor is what can be found in the registry.
// This is what will be returned to a driver when it queries the registry
// to get device information; it will be stored under a key in the hardware
// description tree.
//
// Note: There must a be a convention to the order of fields of same type,
// (defined on a device by device basis) so that the fields can make sense
// to a driver (i.e. when multiple memory ranges are necessary).
//

typedef struct _CM_FULL_RESOURCE_DESCRIPTOR {
    INTERFACE_TYPE InterfaceType; // unused for WDM
    ULONG BusNumber; // unused for WDM
    CM_PARTIAL_RESOURCE_LIST PartialResourceList;
} CM_FULL_RESOURCE_DESCRIPTOR, *PCM_FULL_RESOURCE_DESCRIPTOR;

//
// The Resource list is what will be stored by the drivers into the
// resource map via the IO API.
//

typedef struct _CM_RESOURCE_LIST {
    ULONG Count;
    CM_FULL_RESOURCE_DESCRIPTOR List[1];
} CM_RESOURCE_LIST, *PCM_RESOURCE_LIST;


//
// Define the structures used to interpret configuration data of
// \\Registry\machine\hardware\description tree.
// Basically, these structures are used to interpret component
// sepcific data.
//

//
// Define DEVICE_FLAGS
//

typedef struct _DEVICE_FLAGS {
    ULONG Failed : 1;
    ULONG ReadOnly : 1;
    ULONG Removable : 1;
    ULONG ConsoleIn : 1;
    ULONG ConsoleOut : 1;
    ULONG Input : 1;
    ULONG Output : 1;
} DEVICE_FLAGS, *PDEVICE_FLAGS;

//
// Define Component Information structure
//

typedef struct _CM_COMPONENT_INFORMATION {
    DEVICE_FLAGS Flags;
    ULONG Version;
    ULONG Key;
    KAFFINITY AffinityMask;
} CM_COMPONENT_INFORMATION, *PCM_COMPONENT_INFORMATION;

//
// The following structures are used to interpret x86
// DeviceSpecificData of CM_PARTIAL_RESOURCE_DESCRIPTOR.
// (Most of the structures are defined by BIOS.  They are
// not aligned on word (or dword) boundary.
//

//
// Define the Rom Block structure
//

typedef struct _CM_ROM_BLOCK {
    ULONG Address;
    ULONG Size;
} CM_ROM_BLOCK, *PCM_ROM_BLOCK;



#include "pshpack1.h"



//
// Define INT13 driver parameter block
//

typedef struct _CM_INT13_DRIVE_PARAMETER {
    USHORT DriveSelect;
    ULONG MaxCylinders;
    USHORT SectorsPerTrack;
    USHORT MaxHeads;
    USHORT NumberDrives;
} CM_INT13_DRIVE_PARAMETER, *PCM_INT13_DRIVE_PARAMETER;



//
// Define Mca POS data block for slot
//

typedef struct _CM_MCA_POS_DATA {
    USHORT AdapterId;
    UCHAR PosData1;
    UCHAR PosData2;
    UCHAR PosData3;
    UCHAR PosData4;
} CM_MCA_POS_DATA, *PCM_MCA_POS_DATA;

//
// Memory configuration of eisa data block structure
//

typedef struct _EISA_MEMORY_TYPE {
    UCHAR ReadWrite: 1;
    UCHAR Cached : 1;
    UCHAR Reserved0 :1;
    UCHAR Type:2;
    UCHAR Shared:1;
    UCHAR Reserved1 :1;
    UCHAR MoreEntries : 1;
} EISA_MEMORY_TYPE, *PEISA_MEMORY_TYPE;

typedef struct _EISA_MEMORY_CONFIGURATION {
    EISA_MEMORY_TYPE ConfigurationByte;
    UCHAR DataSize;
    USHORT AddressLowWord;
    UCHAR AddressHighByte;
    USHORT MemorySize;
} EISA_MEMORY_CONFIGURATION, *PEISA_MEMORY_CONFIGURATION;


//
// Interrupt configurationn of eisa data block structure
//

typedef struct _EISA_IRQ_DESCRIPTOR {
    UCHAR Interrupt : 4;
    UCHAR Reserved :1;
    UCHAR LevelTriggered :1;
    UCHAR Shared : 1;
    UCHAR MoreEntries : 1;
} EISA_IRQ_DESCRIPTOR, *PEISA_IRQ_DESCRIPTOR;

typedef struct _EISA_IRQ_CONFIGURATION {
    EISA_IRQ_DESCRIPTOR ConfigurationByte;
    UCHAR Reserved;
} EISA_IRQ_CONFIGURATION, *PEISA_IRQ_CONFIGURATION;


//
// DMA description of eisa data block structure
//

typedef struct _DMA_CONFIGURATION_BYTE0 {
    UCHAR Channel : 3;
    UCHAR Reserved : 3;
    UCHAR Shared :1;
    UCHAR MoreEntries :1;
} DMA_CONFIGURATION_BYTE0;

typedef struct _DMA_CONFIGURATION_BYTE1 {
    UCHAR Reserved0 : 2;
    UCHAR TransferSize : 2;
    UCHAR Timing : 2;
    UCHAR Reserved1 : 2;
} DMA_CONFIGURATION_BYTE1;

typedef struct _EISA_DMA_CONFIGURATION {
    DMA_CONFIGURATION_BYTE0 ConfigurationByte0;
    DMA_CONFIGURATION_BYTE1 ConfigurationByte1;
} EISA_DMA_CONFIGURATION, *PEISA_DMA_CONFIGURATION;


//
// Port description of eisa data block structure
//

typedef struct _EISA_PORT_DESCRIPTOR {
    UCHAR NumberPorts : 5;
    UCHAR Reserved :1;
    UCHAR Shared :1;
    UCHAR MoreEntries : 1;
} EISA_PORT_DESCRIPTOR, *PEISA_PORT_DESCRIPTOR;

typedef struct _EISA_PORT_CONFIGURATION {
    EISA_PORT_DESCRIPTOR Configuration;
    USHORT PortAddress;
} EISA_PORT_CONFIGURATION, *PEISA_PORT_CONFIGURATION;


//
// Eisa slot information definition
// N.B. This structure is different from the one defined
//      in ARC eisa addendum.
//

typedef struct _CM_EISA_SLOT_INFORMATION {
    UCHAR ReturnCode;
    UCHAR ReturnFlags;
    UCHAR MajorRevision;
    UCHAR MinorRevision;
    USHORT Checksum;
    UCHAR NumberFunctions;
    UCHAR FunctionInformation;
    ULONG CompressedId;
} CM_EISA_SLOT_INFORMATION, *PCM_EISA_SLOT_INFORMATION;


//
// Eisa function information definition
//

typedef struct _CM_EISA_FUNCTION_INFORMATION {
    ULONG CompressedId;
    UCHAR IdSlotFlags1;
    UCHAR IdSlotFlags2;
    UCHAR MinorRevision;
    UCHAR MajorRevision;
    UCHAR Selections[26];
    UCHAR FunctionFlags;
    UCHAR TypeString[80];
    EISA_MEMORY_CONFIGURATION EisaMemory[9];
    EISA_IRQ_CONFIGURATION EisaIrq[7];
    EISA_DMA_CONFIGURATION EisaDma[4];
    EISA_PORT_CONFIGURATION EisaPort[20];
    UCHAR InitializationData[60];
} CM_EISA_FUNCTION_INFORMATION, *PCM_EISA_FUNCTION_INFORMATION;

//
// The following defines the way pnp bios information is stored in
// the registry \\HKEY_LOCAL_MACHINE\HARDWARE\Description\System\MultifunctionAdapter\x
// key, where x is an integer number indicating adapter instance. The
// "Identifier" of the key must equal to "PNP BIOS" and the
// "ConfigurationData" is organized as follow:
//
//      CM_PNP_BIOS_INSTALLATION_CHECK        +
//      CM_PNP_BIOS_DEVICE_NODE for device 1  +
//      CM_PNP_BIOS_DEVICE_NODE for device 2  +
//                ...
//      CM_PNP_BIOS_DEVICE_NODE for device n
//

//
// Pnp BIOS device node structure
//

typedef struct _CM_PNP_BIOS_DEVICE_NODE {
    USHORT Size;
    UCHAR Node;
    ULONG ProductId;
    UCHAR DeviceType[3];
    USHORT DeviceAttributes;
    // followed by AllocatedResourceBlock, PossibleResourceBlock
    // and CompatibleDeviceId
} CM_PNP_BIOS_DEVICE_NODE,*PCM_PNP_BIOS_DEVICE_NODE;

//
// Pnp BIOS Installation check
//

typedef struct _CM_PNP_BIOS_INSTALLATION_CHECK {
    UCHAR Signature[4];             // $PnP (ascii)
    UCHAR Revision;
    UCHAR Length;
    USHORT ControlField;
    UCHAR Checksum;
    ULONG EventFlagAddress;         // Physical address
    USHORT RealModeEntryOffset;
    USHORT RealModeEntrySegment;
    USHORT ProtectedModeEntryOffset;
    ULONG ProtectedModeCodeBaseAddress;
    ULONG OemDeviceId;
    USHORT RealModeDataBaseAddress;
    ULONG ProtectedModeDataBaseAddress;
} CM_PNP_BIOS_INSTALLATION_CHECK, *PCM_PNP_BIOS_INSTALLATION_CHECK;

#include "poppack.h"

//
// Masks for EISA function information
//

#define EISA_FUNCTION_ENABLED                   0x80
#define EISA_FREE_FORM_DATA                     0x40
#define EISA_HAS_PORT_INIT_ENTRY                0x20
#define EISA_HAS_PORT_RANGE                     0x10
#define EISA_HAS_DMA_ENTRY                      0x08
#define EISA_HAS_IRQ_ENTRY                      0x04
#define EISA_HAS_MEMORY_ENTRY                   0x02
#define EISA_HAS_TYPE_ENTRY                     0x01
#define EISA_HAS_INFORMATION                    EISA_HAS_PORT_RANGE + \
                                                EISA_HAS_DMA_ENTRY + \
                                                EISA_HAS_IRQ_ENTRY + \
                                                EISA_HAS_MEMORY_ENTRY + \
                                                EISA_HAS_TYPE_ENTRY

//
// Masks for EISA memory configuration
//

#define EISA_MORE_ENTRIES                       0x80
#define EISA_SYSTEM_MEMORY                      0x00
#define EISA_MEMORY_TYPE_RAM                    0x01

//
// Returned error code for EISA bios call
//

#define EISA_INVALID_SLOT                       0x80
#define EISA_INVALID_FUNCTION                   0x81
#define EISA_INVALID_CONFIGURATION              0x82
#define EISA_EMPTY_SLOT                         0x83
#define EISA_INVALID_BIOS_CALL                  0x86



//
// The following structures are used to interpret mips
// DeviceSpecificData of CM_PARTIAL_RESOURCE_DESCRIPTOR.
//

//
// Device data records for adapters.
//

//
// The device data record for the Emulex SCSI controller.
//

typedef struct _CM_SCSI_DEVICE_DATA {
    USHORT Version;
    USHORT Revision;
    UCHAR HostIdentifier;
} CM_SCSI_DEVICE_DATA, *PCM_SCSI_DEVICE_DATA;

//
// Device data records for controllers.
//

//
// The device data record for the Video controller.
//

typedef struct _CM_VIDEO_DEVICE_DATA {
    USHORT Version;
    USHORT Revision;
    ULONG VideoClock;
} CM_VIDEO_DEVICE_DATA, *PCM_VIDEO_DEVICE_DATA;

//
// The device data record for the SONIC network controller.
//

typedef struct _CM_SONIC_DEVICE_DATA {
    USHORT Version;
    USHORT Revision;
    USHORT DataConfigurationRegister;
    UCHAR EthernetAddress[8];
} CM_SONIC_DEVICE_DATA, *PCM_SONIC_DEVICE_DATA;

//
// The device data record for the serial controller.
//

typedef struct _CM_SERIAL_DEVICE_DATA {
    USHORT Version;
    USHORT Revision;
    ULONG BaudClock;
} CM_SERIAL_DEVICE_DATA, *PCM_SERIAL_DEVICE_DATA;

//
// Device data records for peripherals.
//

//
// The device data record for the Monitor peripheral.
//

typedef struct _CM_MONITOR_DEVICE_DATA {
    USHORT Version;
    USHORT Revision;
    USHORT HorizontalScreenSize;
    USHORT VerticalScreenSize;
    USHORT HorizontalResolution;
    USHORT VerticalResolution;
    USHORT HorizontalDisplayTimeLow;
    USHORT HorizontalDisplayTime;
    USHORT HorizontalDisplayTimeHigh;
    USHORT HorizontalBackPorchLow;
    USHORT HorizontalBackPorch;
    USHORT HorizontalBackPorchHigh;
    USHORT HorizontalFrontPorchLow;
    USHORT HorizontalFrontPorch;
    USHORT HorizontalFrontPorchHigh;
    USHORT HorizontalSyncLow;
    USHORT HorizontalSync;
    USHORT HorizontalSyncHigh;
    USHORT VerticalBackPorchLow;
    USHORT VerticalBackPorch;
    USHORT VerticalBackPorchHigh;
    USHORT VerticalFrontPorchLow;
    USHORT VerticalFrontPorch;
    USHORT VerticalFrontPorchHigh;
    USHORT VerticalSyncLow;
    USHORT VerticalSync;
    USHORT VerticalSyncHigh;
} CM_MONITOR_DEVICE_DATA, *PCM_MONITOR_DEVICE_DATA;

//
// The device data record for the Floppy peripheral.
//

typedef struct _CM_FLOPPY_DEVICE_DATA {
    USHORT Version;
    USHORT Revision;
    CHAR Size[8];
    ULONG MaxDensity;
    ULONG MountDensity;
    //
    // New data fields for version >= 2.0
    //
    UCHAR StepRateHeadUnloadTime;
    UCHAR HeadLoadTime;
    UCHAR MotorOffTime;
    UCHAR SectorLengthCode;
    UCHAR SectorPerTrack;
    UCHAR ReadWriteGapLength;
    UCHAR DataTransferLength;
    UCHAR FormatGapLength;
    UCHAR FormatFillCharacter;
    UCHAR HeadSettleTime;
    UCHAR MotorSettleTime;
    UCHAR MaximumTrackValue;
    UCHAR DataTransferRate;
} CM_FLOPPY_DEVICE_DATA, *PCM_FLOPPY_DEVICE_DATA;

//
// The device data record for the Keyboard peripheral.
// The KeyboardFlags is defined (by x86 BIOS INT 16h, function 02) as:
//      bit 7 : Insert on
//      bit 6 : Caps Lock on
//      bit 5 : Num Lock on
//      bit 4 : Scroll Lock on
//      bit 3 : Alt Key is down
//      bit 2 : Ctrl Key is down
//      bit 1 : Left shift key is down
//      bit 0 : Right shift key is down
//

typedef struct _CM_KEYBOARD_DEVICE_DATA {
    USHORT Version;
    USHORT Revision;
    UCHAR Type;
    UCHAR Subtype;
    USHORT KeyboardFlags;
} CM_KEYBOARD_DEVICE_DATA, *PCM_KEYBOARD_DEVICE_DATA;

//
// Declaration of the structure for disk geometries
//

typedef struct _CM_DISK_GEOMETRY_DEVICE_DATA {
    ULONG BytesPerSector;
    ULONG NumberOfCylinders;
    ULONG SectorsPerTrack;
    ULONG NumberOfHeads;
} CM_DISK_GEOMETRY_DEVICE_DATA, *PCM_DISK_GEOMETRY_DEVICE_DATA;



//
// Define the bitmasks for resource options
//

#define IO_RESOURCE_PREFERRED       0x01
#define IO_RESOURCE_DEFAULT         0x02
#define IO_RESOURCE_ALTERNATIVE     0x08

//
// Define interrupt affinity policy values
//

typedef enum _IRQ_DEVICE_POLICY {
    IrqPolicyMachineDefault = 0,
    IrqPolicyAllCloseProcessors,
    IrqPolicyOneCloseProcessor,
    IrqPolicyAllProcessorsInMachine,
    IrqPolicySpecifiedProcessors,
    IrqPolicySpreadMessagesAcrossAllProcessors
} IRQ_DEVICE_POLICY, *PIRQ_DEVICE_POLICY;

//
// Define interrupt priority policy values
//

typedef enum _IRQ_PRIORITY {
    IrqPriorityUndefined = 0,
    IrqPriorityLow,
    IrqPriorityNormal,
    IrqPriorityHigh
} IRQ_PRIORITY, *PIRQ_PRIORITY;

//
// This structure defines one type of resource requested by the driver
//

typedef struct _IO_RESOURCE_DESCRIPTOR {
    UCHAR Option;
    UCHAR Type;                         // use CM_RESOURCE_TYPE
    UCHAR ShareDisposition;             // use CM_SHARE_DISPOSITION
    UCHAR Spare1;
    USHORT Flags;                       // use CM resource flag defines
    USHORT Spare2;                      // align

    union {
        struct {
            ULONG Length;
            ULONG Alignment;
            PHYSICAL_ADDRESS MinimumAddress;
            PHYSICAL_ADDRESS MaximumAddress;
        } Port;

        struct {
            ULONG Length;
            ULONG Alignment;
            PHYSICAL_ADDRESS MinimumAddress;
            PHYSICAL_ADDRESS MaximumAddress;
        } Memory;

        struct {
            ULONG MinimumVector;
            ULONG MaximumVector;
            IRQ_DEVICE_POLICY AffinityPolicy;
            IRQ_PRIORITY PriorityPolicy;
            KAFFINITY TargetedProcessors;
        } Interrupt;

        struct {
            ULONG MinimumChannel;
            ULONG MaximumChannel;
        } Dma;

        struct {
            ULONG Length;
            ULONG Alignment;
            PHYSICAL_ADDRESS MinimumAddress;
            PHYSICAL_ADDRESS MaximumAddress;
        } Generic;

        struct {
            ULONG Data[3];
        } DevicePrivate;

        //
        // Bus Number information.
        //

        struct {
            ULONG Length;
            ULONG MinBusNumber;
            ULONG MaxBusNumber;
            ULONG Reserved;
        } BusNumber;

        struct {
            ULONG Priority;   // use LCPRI_Xxx values in cfg.h
            ULONG Reserved1;
            ULONG Reserved2;
        } ConfigData;

        //
        // The following structures provide descriptions
        // for memory resource requirement greater than MAXULONG
        //

        struct {
            ULONG Length40;
            ULONG Alignment40;
            PHYSICAL_ADDRESS MinimumAddress;
            PHYSICAL_ADDRESS MaximumAddress;
        } Memory40;

        struct {
            ULONG Length48;
            ULONG Alignment48;
            PHYSICAL_ADDRESS MinimumAddress;
            PHYSICAL_ADDRESS MaximumAddress;
        } Memory48;

        struct {
            ULONG Length64;
            ULONG Alignment64;
            PHYSICAL_ADDRESS MinimumAddress;
            PHYSICAL_ADDRESS MaximumAddress;
        } Memory64;


    } u;

} IO_RESOURCE_DESCRIPTOR, *PIO_RESOURCE_DESCRIPTOR;




typedef struct _IO_RESOURCE_LIST {
    USHORT Version;
    USHORT Revision;

    ULONG Count;
    IO_RESOURCE_DESCRIPTOR Descriptors[1];
} IO_RESOURCE_LIST, *PIO_RESOURCE_LIST;


typedef struct _IO_RESOURCE_REQUIREMENTS_LIST {
    ULONG ListSize;
    INTERFACE_TYPE InterfaceType; // unused for WDM
    ULONG BusNumber; // unused for WDM
    ULONG SlotNumber;
    ULONG Reserved[3];
    ULONG AlternativeLists;
    IO_RESOURCE_LIST  List[1];
} IO_RESOURCE_REQUIREMENTS_LIST, *PIO_RESOURCE_REQUIREMENTS_LIST;

//
// for move macros
//
#ifdef _MAC
#ifndef _INC_STRING
#include <string.h>
#endif /* _INC_STRING */
#else
#include <string.h>
#endif // _MAC


#ifndef _SLIST_HEADER_
#define _SLIST_HEADER_

#if defined(_WIN64)

//
// The type SINGLE_LIST_ENTRY is not suitable for use with SLISTs.  For
// WIN64, an entry on an SLIST is required to be 16-byte aligned, while a
// SINGLE_LIST_ENTRY structure has only 8 byte alignment.
//
// Therefore, all SLIST code should use the SLIST_ENTRY type instead of the
// SINGLE_LIST_ENTRY type.
//

#pragma warning(push)
#pragma warning(disable:4324)   // structure padded due to align()
typedef struct DECLSPEC_ALIGN(16) _SLIST_ENTRY *PSLIST_ENTRY;
typedef struct DECLSPEC_ALIGN(16) _SLIST_ENTRY {
    PSLIST_ENTRY Next;
} SLIST_ENTRY;
#pragma warning(pop)

#else

#define SLIST_ENTRY SINGLE_LIST_ENTRY
#define _SLIST_ENTRY _SINGLE_LIST_ENTRY
#define PSLIST_ENTRY PSINGLE_LIST_ENTRY

#endif // _WIN64

#if defined(_WIN64)

typedef union DECLSPEC_ALIGN(16) _SLIST_HEADER {
    struct {  // original struct
        ULONGLONG Alignment;
        ULONGLONG Region;
    } DUMMYSTRUCTNAME;
    struct {  // 8-byte header
        ULONGLONG Depth:16;
        ULONGLONG Sequence:9;
        ULONGLONG NextEntry:39;
        ULONGLONG HeaderType:1; // 0: 8-byte; 1: 16-byte
        ULONGLONG Init:1;       // 0: uninitialized; 1: initialized
        ULONGLONG Reserved:59;
        ULONGLONG Region:3;
    } Header8;
    struct {  // 16-byte header
        ULONGLONG Depth:16;
        ULONGLONG Sequence:48;
        ULONGLONG HeaderType:1; // 0: 8-byte; 1: 16-byte
        ULONGLONG Init:1;       // 0: uninitialized; 1: initialized
        ULONGLONG Reserved:2;
        ULONGLONG NextEntry:60; // last 4 bits are always 0's
    } Header16;
} SLIST_HEADER, *PSLIST_HEADER;

#else

typedef union _SLIST_HEADER {
    ULONGLONG Alignment;
    struct {
        SLIST_ENTRY Next;
        USHORT Depth;
        USHORT Sequence;
    } DUMMYSTRUCTNAME;
} SLIST_HEADER, *PSLIST_HEADER;

#endif // _WIN64

#endif // _SLIST_HEADER_

//
// If debugging support enabled, define an ASSERT macro that works.  Otherwise
// define the ASSERT macro to expand to an empty expression.
//
// The ASSERT macro has been updated to be an expression instead of a statement.
//

NTSYSAPI
VOID
NTAPI
RtlAssert(
    __in PVOID VoidFailedAssertion,
    __in PVOID VoidFileName,
    __in ULONG LineNumber,
    __in_opt PSTR MutableMessage
    );

#if DBG

#define ASSERT( exp ) \
    ((!(exp)) ? \
        (RtlAssert( #exp, __FILE__, __LINE__, NULL ),FALSE) : \
        TRUE)

#define ASSERTMSG( msg, exp ) \
    ((!(exp)) ? \
        (RtlAssert( #exp, __FILE__, __LINE__, msg ),FALSE) : \
        TRUE)

#define RTL_SOFT_ASSERT(_exp) \
    ((!(_exp)) ? \
        (DbgPrint("%s(%d): Soft assertion failed\n   Expression: %s\n", __FILE__, __LINE__, #_exp),FALSE) : \
        TRUE)

#define RTL_SOFT_ASSERTMSG(_msg, _exp) \
    ((!(_exp)) ? \
        (DbgPrint("%s(%d): Soft assertion failed\n   Expression: %s\n   Message: %s\n", __FILE__, __LINE__, #_exp, (_msg)),FALSE) : \
        TRUE)

#if _MSC_VER >= 1300

#define NT_ASSERT(_exp) \
    ((!(_exp)) ? \
        (__annotation(L"Debug", L"AssertFail", L#_exp), \
         DbgRaiseAssertionFailure(), FALSE) : \
        TRUE)

#define NT_ASSERTMSG(_msg, _exp) \
    ((!(_exp)) ? \
        (__annotation(L"Debug", L"AssertFail", L##_msg), \
         DbgRaiseAssertionFailure(), FALSE) : \
        TRUE)

#define NT_ASSERTMSGW(_msg, _exp) \
    ((!(_exp)) ? \
        (__annotation(L"Debug", L"AssertFail", _msg), \
         DbgRaiseAssertionFailure(), FALSE) : \
        TRUE)

#define NT_VERIFY     NT_ASSERT
#define NT_VERIFYMSG  NT_ASSERTMSG
#define NT_VERIFYMSGW NT_ASSERTMSGW

#endif // #if _MSC_VER >= 1300

#define RTL_VERIFY         ASSERT
#define RTL_VERIFYMSG      ASSERTMSG

#define RTL_SOFT_VERIFY    RTL_SOFT_ASSERT
#define RTL_SOFT_VERIFYMSG RTL_SOFT_ASSERTMSG

#else
#define ASSERT( exp )         ((void) 0)
#define ASSERTMSG( msg, exp ) ((void) 0)

#if _MSC_VER >= 1300

#define NT_ASSERT(_exp)           ((void) 0)
#define NT_ASSERTMSG(_msg, _exp)  ((void) 0)
#define NT_ASSERTMSGW(_msg, _exp) ((void) 0)

#define NT_VERIFY(_exp)           ((_exp) ? TRUE : FALSE)
#define NT_VERIFYMSG(_msg, _exp ) ((_exp) ? TRUE : FALSE)
#define NT_VERIFYMSGW(_msg, _exp) ((_exp) ? TRUE : FALSE)

#endif // #if _MSC_VER >= 1300

#define RTL_SOFT_ASSERT(_exp)          ((void) 0)
#define RTL_SOFT_ASSERTMSG(_msg, _exp) ((void) 0)

#define RTL_VERIFY( exp )         ((exp) ? TRUE : FALSE)
#define RTL_VERIFYMSG( msg, exp ) ((exp) ? TRUE : FALSE)

#define RTL_SOFT_VERIFY(_exp)         ((_exp) ? TRUE : FALSE)
#define RTL_SOFT_VERIFYMSG(msg, _exp) ((_exp) ? TRUE : FALSE)

#endif // DBG

//
//  Doubly-linked list manipulation routines.
//


//
//  VOID
//  InitializeListHead32(
//      PLIST_ENTRY32 ListHead
//      );
//

#define InitializeListHead32(ListHead) (\
    (ListHead)->Flink = (ListHead)->Blink = PtrToUlong((ListHead)))

#if !defined(MIDL_PASS) && !defined(SORTPP_PASS)

#define RTL_STATIC_LIST_HEAD(x) LIST_ENTRY x = { &x, &x }

FORCEINLINE
VOID
InitializeListHead(
    IN PLIST_ENTRY ListHead
    )
{
    ListHead->Flink = ListHead->Blink = ListHead;
}

BOOLEAN
FORCEINLINE
IsListEmpty(
    IN const LIST_ENTRY * ListHead
    )
{
    return (BOOLEAN)(ListHead->Flink == ListHead);
}

FORCEINLINE
BOOLEAN
RemoveEntryList(
    IN PLIST_ENTRY Entry
    )
{
    PLIST_ENTRY Blink;
    PLIST_ENTRY Flink;

    Flink = Entry->Flink;
    Blink = Entry->Blink;
    Blink->Flink = Flink;
    Flink->Blink = Blink;
    return (BOOLEAN)(Flink == Blink);
}

FORCEINLINE
PLIST_ENTRY
RemoveHeadList(
    IN PLIST_ENTRY ListHead
    )
{
    PLIST_ENTRY Flink;
    PLIST_ENTRY Entry;

    Entry = ListHead->Flink;
    Flink = Entry->Flink;
    ListHead->Flink = Flink;
    Flink->Blink = ListHead;
    return Entry;
}



FORCEINLINE
PLIST_ENTRY
RemoveTailList(
    IN PLIST_ENTRY ListHead
    )
{
    PLIST_ENTRY Blink;
    PLIST_ENTRY Entry;

    Entry = ListHead->Blink;
    Blink = Entry->Blink;
    ListHead->Blink = Blink;
    Blink->Flink = ListHead;
    return Entry;
}


FORCEINLINE
VOID
InsertTailList(
    IN PLIST_ENTRY ListHead,
    IN PLIST_ENTRY Entry
    )
{
    PLIST_ENTRY Blink;

    Blink = ListHead->Blink;
    Entry->Flink = ListHead;
    Entry->Blink = Blink;
    Blink->Flink = Entry;
    ListHead->Blink = Entry;
}


FORCEINLINE
VOID
InsertHeadList(
    IN PLIST_ENTRY ListHead,
    IN PLIST_ENTRY Entry
    )
{
    PLIST_ENTRY Flink;

    Flink = ListHead->Flink;
    Entry->Flink = Flink;
    Entry->Blink = ListHead;
    Flink->Blink = Entry;
    ListHead->Flink = Entry;
}

FORCEINLINE
VOID
AppendTailList(
    IN PLIST_ENTRY ListHead,
    IN PLIST_ENTRY ListToAppend
    )
{
    PLIST_ENTRY ListEnd = ListHead->Blink;

    ListHead->Blink->Flink = ListToAppend;
    ListHead->Blink = ListToAppend->Blink;
    ListToAppend->Blink->Flink = ListHead;
    ListToAppend->Blink = ListEnd;
}

FORCEINLINE
PSINGLE_LIST_ENTRY
PopEntryList(
    PSINGLE_LIST_ENTRY ListHead
    )
{
    PSINGLE_LIST_ENTRY FirstEntry;
    FirstEntry = ListHead->Next;
    if (FirstEntry != NULL) {
        ListHead->Next = FirstEntry->Next;
    }

    return FirstEntry;
}


FORCEINLINE
VOID
PushEntryList(
    PSINGLE_LIST_ENTRY ListHead,
    PSINGLE_LIST_ENTRY Entry
    )
{
    Entry->Next = ListHead->Next;
    ListHead->Next = Entry;
}

#endif // !MIDL_PASS

//
// Subroutines for dealing with the Registry
//

typedef NTSTATUS (NTAPI * PRTL_QUERY_REGISTRY_ROUTINE)(
    IN PWSTR ValueName,
    IN ULONG ValueType,
    IN PVOID ValueData,
    IN ULONG ValueLength,
    IN PVOID Context,
    IN PVOID EntryContext
    );

typedef struct _RTL_QUERY_REGISTRY_TABLE {
    PRTL_QUERY_REGISTRY_ROUTINE QueryRoutine;
    ULONG Flags;
    PWSTR Name;
    PVOID EntryContext;
    ULONG DefaultType;
    PVOID DefaultData;
    ULONG DefaultLength;

} RTL_QUERY_REGISTRY_TABLE, *PRTL_QUERY_REGISTRY_TABLE;


//
// The following flags specify how the Name field of a RTL_QUERY_REGISTRY_TABLE
// entry is interpreted.  A NULL name indicates the end of the table.
//

#define RTL_QUERY_REGISTRY_SUBKEY   0x00000001  // Name is a subkey and remainder of
                                                // table or until next subkey are value
                                                // names for that subkey to look at.

#define RTL_QUERY_REGISTRY_TOPKEY   0x00000002  // Reset current key to original key for
                                                // this and all following table entries.

#define RTL_QUERY_REGISTRY_REQUIRED 0x00000004  // Fail if no match found for this table
                                                // entry.

#define RTL_QUERY_REGISTRY_NOVALUE  0x00000008  // Used to mark a table entry that has no
                                                // value name, just wants a call out, not
                                                // an enumeration of all values.

#define RTL_QUERY_REGISTRY_NOEXPAND 0x00000010  // Used to suppress the expansion of
                                                // REG_MULTI_SZ into multiple callouts or
                                                // to prevent the expansion of environment
                                                // variable values in REG_EXPAND_SZ

#define RTL_QUERY_REGISTRY_DIRECT   0x00000020  // QueryRoutine field ignored.  EntryContext
                                                // field points to location to store value.
                                                // For null terminated strings, EntryContext
                                                // points to UNICODE_STRING structure that
                                                // that describes maximum size of buffer.
                                                // If .Buffer field is NULL then a buffer is
                                                // allocated.
                                                //

#define RTL_QUERY_REGISTRY_DELETE   0x00000040  // Used to delete value keys after they
                                                // are queried.

#if (NTDDI_VERSION >= NTDDI_WIN2K)
NTSYSAPI
NTSTATUS
NTAPI
RtlQueryRegistryValues(
    IN ULONG RelativeTo,
    IN PCWSTR Path,
    IN PRTL_QUERY_REGISTRY_TABLE QueryTable,
    IN PVOID Context,
    IN PVOID Environment OPTIONAL
    );
#endif

#if (NTDDI_VERSION >= NTDDI_WIN2K)
NTSYSAPI
NTSTATUS
NTAPI
RtlWriteRegistryValue(
    IN ULONG RelativeTo,
    IN PCWSTR Path,
    IN PCWSTR ValueName,
    IN ULONG ValueType,
    IN PVOID ValueData,
    IN ULONG ValueLength
    );
#endif

#if (NTDDI_VERSION >= NTDDI_WIN2K)
NTSYSAPI
NTSTATUS
NTAPI
RtlDeleteRegistryValue(
    IN ULONG RelativeTo,
    IN PCWSTR Path,
    IN PCWSTR ValueName
    );
#endif

#if (NTDDI_VERSION >= NTDDI_WIN2K)
NTSYSAPI
NTSTATUS
NTAPI
RtlCreateRegistryKey(
    __in ULONG RelativeTo,
    __in PWSTR Path
    );
#endif

#if (NTDDI_VERSION >= NTDDI_WIN2K)
NTSYSAPI
NTSTATUS
NTAPI
RtlCheckRegistryKey(
    __in ULONG RelativeTo,
    __in PWSTR Path
    );
#endif

//
// The following values for the RelativeTo parameter determine what the
// Path parameter to RtlQueryRegistryValues is relative to.
//

#define RTL_REGISTRY_ABSOLUTE     0   // Path is a full path
#define RTL_REGISTRY_SERVICES     1   // \Registry\Machine\System\CurrentControlSet\Services
#define RTL_REGISTRY_CONTROL      2   // \Registry\Machine\System\CurrentControlSet\Control
#define RTL_REGISTRY_WINDOWS_NT   3   // \Registry\Machine\Software\Microsoft\Windows NT\CurrentVersion
#define RTL_REGISTRY_DEVICEMAP    4   // \Registry\Machine\Hardware\DeviceMap
#define RTL_REGISTRY_USER         5   // \Registry\User\CurrentUser
#define RTL_REGISTRY_MAXIMUM      6
#define RTL_REGISTRY_HANDLE       0x40000000    // Low order bits are registry handle
#define RTL_REGISTRY_OPTIONAL     0x80000000    // Indicates the key node is optional


#if (NTDDI_VERSION >= NTDDI_WIN2K)
NTSYSAPI
NTSTATUS
NTAPI
RtlIntegerToUnicodeString (
    ULONG Value,
    ULONG Base,
    PUNICODE_STRING String
    );
#endif

#if (NTDDI_VERSION >= NTDDI_WIN2K)
NTSYSAPI
NTSTATUS
NTAPI
RtlInt64ToUnicodeString (
    IN ULONGLONG Value,
    IN ULONG Base OPTIONAL,
    IN OUT PUNICODE_STRING String
    );
#endif

#ifdef _WIN64
#define RtlIntPtrToUnicodeString(Value, Base, String) RtlInt64ToUnicodeString(Value, Base, String)
#else
#define RtlIntPtrToUnicodeString(Value, Base, String) RtlIntegerToUnicodeString(Value, Base, String)
#endif

#if (NTDDI_VERSION >= NTDDI_WIN2K)
NTSYSAPI
NTSTATUS
NTAPI
RtlUnicodeStringToInteger (
    PCUNICODE_STRING String,
    ULONG Base,
    PULONG Value
    );
#endif

//
//  String manipulation routines
//

#ifdef _NTSYSTEM_

#define NLS_MB_CODE_PAGE_TAG NlsMbCodePageTag
#define NLS_MB_OEM_CODE_PAGE_TAG NlsMbOemCodePageTag

#else

#define NLS_MB_CODE_PAGE_TAG (*NlsMbCodePageTag)
#define NLS_MB_OEM_CODE_PAGE_TAG (*NlsMbOemCodePageTag)

#endif // _NTSYSTEM_

extern BOOLEAN NLS_MB_CODE_PAGE_TAG;     // TRUE -> Multibyte CP, FALSE -> Singlebyte
extern BOOLEAN NLS_MB_OEM_CODE_PAGE_TAG; // TRUE -> Multibyte CP, FALSE -> Singlebyte

#if (NTDDI_VERSION >= NTDDI_WIN2K)
NTSYSAPI
VOID
NTAPI
RtlInitString(
    PSTRING DestinationString,
    PCSZ SourceString
    );
#endif

#if (NTDDI_VERSION >= NTDDI_WIN2K)
NTSYSAPI
VOID
NTAPI
RtlInitAnsiString(
    __out PANSI_STRING DestinationString,
    __in_opt PCSZ SourceString
    );
#endif

NTSYSAPI
VOID
NTAPI
RtlInitUnicodeString(
    __out PUNICODE_STRING DestinationString,
    __in_opt PCWSTR SourceString
    );

#if !defined(MIDL_PASS)
FORCEINLINE
VOID
RtlInitEmptyUnicodeString(
    __out PUNICODE_STRING UnicodeString,
    __in_bcount_opt(BufferSize) PWSTR Buffer,
    __in USHORT BufferSize
    )
{
    UnicodeString->Length = 0;
    UnicodeString->MaximumLength = BufferSize;
    UnicodeString->Buffer = Buffer;
}

FORCEINLINE
VOID
RtlInitEmptyAnsiString(
    __inout PANSI_STRING AnsiString,
    __out_ecount(BufferSize) PCHAR Buffer,
    __in USHORT BufferSize
    )
{
    AnsiString->Length = 0;
    AnsiString->MaximumLength = BufferSize;
    AnsiString->Buffer = Buffer;
}
#endif // !defined(MIDL_PASS)

//
// NLS String functions
//

#if (NTDDI_VERSION >= NTDDI_WIN2K)
NTSYSAPI
NTSTATUS
NTAPI
RtlAnsiStringToUnicodeString(
    __inout PUNICODE_STRING DestinationString,
    __in PCANSI_STRING SourceString,
    __in BOOLEAN AllocateDestinationString
    );
#endif


#if (NTDDI_VERSION >= NTDDI_WIN2K)
NTSYSAPI
NTSTATUS
NTAPI
RtlUnicodeStringToAnsiString(
    __inout PANSI_STRING DestinationString,
    __in PCUNICODE_STRING SourceString,
    __in BOOLEAN AllocateDestinationString
    );
#endif


#if (NTDDI_VERSION >= NTDDI_WIN2K)
NTSYSAPI
LONG
NTAPI
RtlCompareUnicodeStrings(
    __in_ecount(String1Length) PCWCH String1,
    __in SIZE_T String1Length,
    __in_ecount(String2Length) PCWCH String2,
    __in SIZE_T String2Length,
    __in BOOLEAN CaseInSensitive
    );

NTSYSAPI
LONG
NTAPI
RtlCompareUnicodeString(
    __in PCUNICODE_STRING String1,
    __in PCUNICODE_STRING String2,
    __in BOOLEAN CaseInSensitive
    );
#endif

#if (NTDDI_VERSION >= NTDDI_WIN2K)
NTSYSAPI
BOOLEAN
NTAPI
RtlEqualUnicodeString(
    __in PCUNICODE_STRING String1,
    __in PCUNICODE_STRING String2,
    __in BOOLEAN CaseInSensitive
    );
#endif

#define HASH_STRING_ALGORITHM_DEFAULT   (0)
#define HASH_STRING_ALGORITHM_X65599    (1)
#define HASH_STRING_ALGORITHM_INVALID   (0xffffffff)

#if (NTDDI_VERSION >= NTDDI_WINXP)
NTSYSAPI
NTSTATUS
NTAPI
RtlHashUnicodeString(
    IN const UNICODE_STRING *String,
    IN BOOLEAN CaseInSensitive,
    IN ULONG HashAlgorithm,
    OUT PULONG HashValue
    );

#endif // NTDDI_VERSION >= NTDDI_WINXP


#if (NTDDI_VERSION >= NTDDI_WIN2K)
NTSYSAPI
VOID
NTAPI
RtlCopyUnicodeString(
    __inout PUNICODE_STRING DestinationString,
    __in_opt PCUNICODE_STRING SourceString
    );
#endif

#if (NTDDI_VERSION >= NTDDI_WIN2K)
NTSYSAPI
NTSTATUS
NTAPI
RtlAppendUnicodeStringToString (
    __inout PUNICODE_STRING Destination,
    __in PCUNICODE_STRING Source
    );
#endif

#if (NTDDI_VERSION >= NTDDI_WIN2K)
NTSYSAPI
NTSTATUS
NTAPI
RtlAppendUnicodeToString (
    __inout PUNICODE_STRING Destination,
    __in_opt PCWSTR Source
    );
#endif



#if (NTDDI_VERSION >= NTDDI_WIN2K)
NTSYSAPI
WCHAR
NTAPI
RtlUpcaseUnicodeChar(
    __in WCHAR SourceCharacter
    );
#endif

#if (NTDDI_VERSION >= NTDDI_WINXP)
NTSYSAPI
WCHAR
NTAPI
RtlDowncaseUnicodeChar(
    WCHAR SourceCharacter
    );
#endif

NTSYSAPI
VOID
NTAPI
RtlFreeUnicodeString(
    __inout PUNICODE_STRING UnicodeString
    );

#if (NTDDI_VERSION >= NTDDI_WIN2K)
NTSYSAPI
VOID
NTAPI
RtlFreeAnsiString(
    __inout PANSI_STRING AnsiString
    );
#endif

#if (NTDDI_VERSION >= NTDDI_WIN2K)
NTSYSAPI
ULONG
NTAPI
RtlxUnicodeStringToAnsiSize(
    PCUNICODE_STRING UnicodeString
    );
#endif

//
//  NTSYSAPI
//  ULONG
//  NTAPI
//  RtlUnicodeStringToAnsiSize(
//      PUNICODE_STRING UnicodeString
//      );
//

#define RtlUnicodeStringToAnsiSize(STRING) (                  \
    NLS_MB_CODE_PAGE_TAG ?                                    \
    RtlxUnicodeStringToAnsiSize(STRING) :                     \
    ((STRING)->Length + sizeof(UNICODE_NULL)) / sizeof(WCHAR) \
)


#if (NTDDI_VERSION >= NTDDI_WIN2K)
NTSYSAPI
ULONG
NTAPI
RtlxAnsiStringToUnicodeSize(
    __in PCANSI_STRING AnsiString
    );
#endif

//
//  NTSYSAPI
//  ULONG
//  NTAPI
//  RtlAnsiStringToUnicodeSize(
//      PANSI_STRING AnsiString
//      );
//

#define RtlAnsiStringToUnicodeSize(STRING) (                 \
    NLS_MB_CODE_PAGE_TAG ?                                   \
    RtlxAnsiStringToUnicodeSize(STRING) :                    \
    ((STRING)->Length + sizeof(ANSI_NULL)) * sizeof(WCHAR) \
)




#include <guiddef.h>



#ifndef DEFINE_GUIDEX
    #define DEFINE_GUIDEX(name) EXTERN_C const CDECL GUID name
#endif // !defined(DEFINE_GUIDEX)

#ifndef STATICGUIDOF
    #define STATICGUIDOF(guid) STATIC_##guid
#endif // !defined(STATICGUIDOF)

#ifndef __IID_ALIGNED__
    #define __IID_ALIGNED__
    #ifdef __cplusplus
        inline int IsEqualGUIDAligned(REFGUID guid1, REFGUID guid2)
        {
            return ((*(PLONGLONG)(&guid1) == *(PLONGLONG)(&guid2)) && (*((PLONGLONG)(&guid1) + 1) == *((PLONGLONG)(&guid2) + 1)));
        }
    #else // !__cplusplus
        #define IsEqualGUIDAligned(guid1, guid2) \
            ((*(PLONGLONG)(guid1) == *(PLONGLONG)(guid2)) && (*((PLONGLONG)(guid1) + 1) == *((PLONGLONG)(guid2) + 1)))
    #endif // !__cplusplus
#endif // !__IID_ALIGNED__

NTSYSAPI
NTSTATUS
NTAPI
RtlStringFromGUID(
    IN REFGUID Guid,
    OUT PUNICODE_STRING GuidString
    );

NTSYSAPI
NTSTATUS
NTAPI
RtlGUIDFromString(
    IN PUNICODE_STRING GuidString,
    OUT GUID* Guid
    );

//
// Fast primitives to compare, move, and zero memory
//



#if _DBG_MEMCPY_INLINE_ && !defined(MIDL_PASS) && !defined(_MEMCPY_INLINE_) && !defined(_CRTBLD)
#define _MEMCPY_INLINE_
FORCEINLINE
PVOID
__cdecl
memcpy_inline (
    void *dst,
    const void *src,
    size_t size
    )
{
    //
    // Make sure the source and destination do not overlap such that the
    // move destroys the destination.
    //
    if (((char *)dst > (char *)src) &&
        ((char *)dst < ((char *)src + size))) {
        __debugbreak();
    }
    return memcpy(dst, src, size);
}
#define memcpy memcpy_inline
#endif

#if (NTDDI_VERSION >= NTDDI_WIN2K)
NTSYSAPI
SIZE_T
NTAPI
RtlCompareMemory (
    const VOID *Source1,
    const VOID *Source2,
    SIZE_T Length
    );

#endif

#define RtlEqualMemory(Destination,Source,Length) (!memcmp((Destination),(Source),(Length)))
#define RtlMoveMemory(Destination,Source,Length) memmove((Destination),(Source),(Length))
#define RtlCopyMemory(Destination,Source,Length) memcpy((Destination),(Source),(Length))
#define RtlFillMemory(Destination,Length,Fill) memset((Destination),(Fill),(Length))
#define RtlZeroMemory(Destination,Length) memset((Destination),0,(Length))


#if !defined(MIDL_PASS)

FORCEINLINE
PVOID
RtlSecureZeroMemory(
    __in_bcount(cnt) PVOID ptr,
    __in SIZE_T cnt
    )
{
    volatile char *vptr = (volatile char *)ptr;

#if defined(_M_AMD64)

        __stosb((PUCHAR)((ULONG64)vptr), 0, cnt);

#else

    while (cnt) {
        *vptr = 0;
        vptr++;
        cnt--;
    }

#endif

    return ptr;
}

#endif



#define RtlCopyBytes RtlCopyMemory
#define RtlZeroBytes RtlZeroMemory
#define RtlFillBytes RtlFillMemory

#if defined(_M_AMD64)

NTSYSAPI
VOID
NTAPI
RtlCopyMemoryNonTemporal (
   VOID UNALIGNED *Destination,
   CONST VOID UNALIGNED *Source,
   SIZE_T Length
   );

#else

#define RtlCopyMemoryNonTemporal RtlCopyMemory

#endif

#if (NTDDI_VERSION >= NTDDI_WIN2KSP3)
NTSYSAPI
VOID
FASTCALL
RtlPrefetchMemoryNonTemporal(
    IN PVOID Source,
    IN SIZE_T Length
    );

#endif

//
// Define kernel debugger print prototypes and macros.
//
// N.B. The following function cannot be directly imported because there are
//      a few places in the source tree where this function is redefined.
//

#if (NTDDI_VERSION >= NTDDI_WIN2K)
VOID
NTAPI
DbgBreakPoint(
    VOID
    );

#endif

#if (NTDDI_VERSION >= NTDDI_WIN2K)
NTSYSAPI
VOID
NTAPI
DbgBreakPointWithStatus(
    IN ULONG Status
    );
#endif

#define DBG_STATUS_CONTROL_C        1
#define DBG_STATUS_SYSRQ            2
#define DBG_STATUS_BUGCHECK_FIRST   3
#define DBG_STATUS_BUGCHECK_SECOND  4
#define DBG_STATUS_FATAL            5
#define DBG_STATUS_DEBUG_CONTROL    6
#define DBG_STATUS_WORKER           7

#if DBG

#define KdPrint(_x_) DbgPrint _x_
#define KdPrintEx(_x_) DbgPrintEx _x_
#define vKdPrintEx(_x_) vDbgPrintEx _x_
#define vKdPrintExWithPrefix(_x_) vDbgPrintExWithPrefix _x_
#define KdBreakPoint() DbgBreakPoint()

#define KdBreakPointWithStatus(s) DbgBreakPointWithStatus(s)

#else

#define KdPrint(_x_)
#define KdPrintEx(_x_)
#define vKdPrintEx(_x_)
#define vKdPrintExWithPrefix(_x_)
#define KdBreakPoint()

#define KdBreakPointWithStatus(s)

#endif // DBG

#ifndef _DBGNT_

ULONG
__cdecl
DbgPrint (
    __in PCCH Format,
    ...
    );

#if (NTDDI_VERSION >= NTDDI_WINXP)
NTSYSAPI
ULONG
__cdecl
DbgPrintEx (
    __in ULONG ComponentId,
    __in ULONG Level,
    __in PCCH Format,
    ...
    );
#endif

#ifdef _VA_LIST_DEFINED

#if (NTDDI_VERSION >= NTDDI_WINXP)
NTSYSAPI
ULONG
NTAPI
vDbgPrintEx(
    __in ULONG ComponentId,
    __in ULONG Level,
    __in PCCH Format,
    __in va_list arglist
    );

NTSYSAPI
ULONG
NTAPI
vDbgPrintExWithPrefix (
    __in PCCH Prefix,
    __in ULONG ComponentId,
    __in ULONG Level,
    __in PCCH Format,
    __in va_list arglist
    );

#endif

#endif // _VA_LIST_DEFINED

#if (NTDDI_VERSION >= NTDDI_WIN2K)
NTSYSAPI
ULONG
__cdecl
DbgPrintReturnControlC (
    __in PCCH Format,
    ...
    );
#endif

#if (NTDDI_VERSION >= NTDDI_WINXP)
NTSYSAPI
NTSTATUS
NTAPI
DbgQueryDebugFilterState (
    __in ULONG ComponentId,
    __in ULONG Level
    );
#endif

#if (NTDDI_VERSION >= NTDDI_WINXP)
NTSYSAPI
NTSTATUS
NTAPI
DbgSetDebugFilterState (
    __in ULONG ComponentId,
    __in ULONG Level,
    __in BOOLEAN State
    );
#endif

#if (NTDDI_VERSION >= NTDDI_VISTA)
typedef
VOID
(*PDEBUG_PRINT_CALLBACK) (
    __in PSTRING Output,
    __in ULONG ComponentId,
    __in ULONG Level
    );

NTSYSAPI
NTSTATUS
NTAPI
DbgSetDebugPrintCallback (
    __in PDEBUG_PRINT_CALLBACK DebugPrintCallback,
    __in BOOLEAN Enable
    );
#endif

#endif // _DBGNT_

//
// Large integer arithmetic routines.
//

//
// Large integer add - 64-bits + 64-bits -> 64-bits
//


#if !defined(MIDL_PASS)


DECLSPEC_DEPRECATED_DDK         // Use native __int64 math
__inline
LARGE_INTEGER
NTAPI_INLINE
RtlLargeIntegerAdd (
    LARGE_INTEGER Addend1,
    LARGE_INTEGER Addend2
    )
{
    LARGE_INTEGER Sum;

    Sum.QuadPart = Addend1.QuadPart + Addend2.QuadPart;
    return Sum;
}

//
// Enlarged integer multiply - 32-bits * 32-bits -> 64-bits
//

DECLSPEC_DEPRECATED_DDK         // Use native __int64 math
__inline
LARGE_INTEGER
NTAPI_INLINE
RtlEnlargedIntegerMultiply (
    LONG Multiplicand,
    LONG Multiplier
    )
{
    LARGE_INTEGER Product;

    Product.QuadPart = (LONGLONG)Multiplicand * (ULONGLONG)Multiplier;
    return Product;
}

//
// Unsigned enlarged integer multiply - 32-bits * 32-bits -> 64-bits
//

DECLSPEC_DEPRECATED_DDK         // Use native __int64 math
__inline
LARGE_INTEGER
NTAPI_INLINE
RtlEnlargedUnsignedMultiply (
    ULONG Multiplicand,
    ULONG Multiplier
    )
{
    LARGE_INTEGER Product;

    Product.QuadPart = (ULONGLONG)Multiplicand * (ULONGLONG)Multiplier;
    return Product;
}

//
// Enlarged integer divide - 64-bits / 32-bits > 32-bits
//

DECLSPEC_DEPRECATED_DDK         // Use native __int64 math
__inline
ULONG
NTAPI_INLINE
RtlEnlargedUnsignedDivide (
    IN ULARGE_INTEGER Dividend,
    IN ULONG Divisor,
    IN PULONG Remainder OPTIONAL
    )
{
    ULONG Quotient;

    Quotient = (ULONG)(Dividend.QuadPart / Divisor);
    if (ARGUMENT_PRESENT(Remainder)) {
        *Remainder = (ULONG)(Dividend.QuadPart % Divisor);
    }

    return Quotient;
}

//
// Large integer negation - -(64-bits)
//

DECLSPEC_DEPRECATED_DDK         // Use native __int64 math
__inline
LARGE_INTEGER
NTAPI_INLINE
RtlLargeIntegerNegate (
    LARGE_INTEGER Subtrahend
    )
{
    LARGE_INTEGER Difference;

    Difference.QuadPart = -Subtrahend.QuadPart;
    return Difference;
}

//
// Large integer subtract - 64-bits - 64-bits -> 64-bits.
//

DECLSPEC_DEPRECATED_DDK         // Use native __int64 math
__inline
LARGE_INTEGER
NTAPI_INLINE
RtlLargeIntegerSubtract (
    LARGE_INTEGER Minuend,
    LARGE_INTEGER Subtrahend
    )
{
    LARGE_INTEGER Difference;

    Difference.QuadPart = Minuend.QuadPart - Subtrahend.QuadPart;
    return Difference;
}

//
// Extended large integer magic divide - 64-bits / 32-bits -> 64-bits
//

#if defined(_AMD64_)

DECLSPEC_DEPRECATED_DDK         // Use native __int64 math
__inline
LARGE_INTEGER
NTAPI_INLINE
RtlExtendedMagicDivide (
    LARGE_INTEGER Dividend,
    LARGE_INTEGER MagicDivisor,
    CCHAR ShiftCount
    )

{

    LARGE_INTEGER Quotient;

    if (Dividend.QuadPart >= 0) {
        Quotient.QuadPart = UnsignedMultiplyHigh(Dividend.QuadPart,
                                                 (ULONG64)MagicDivisor.QuadPart);

    } else {
        Quotient.QuadPart = UnsignedMultiplyHigh(-Dividend.QuadPart,
                                                 (ULONG64)MagicDivisor.QuadPart);
    }

    Quotient.QuadPart = (ULONG64)Quotient.QuadPart >> ShiftCount;
    if (Dividend.QuadPart < 0) {
        Quotient.QuadPart = - Quotient.QuadPart;
    }

    return Quotient;
}

#endif // defined(_AMD64_)

#if defined(_X86_) || defined(_IA64_)

#if (NTDDI_VERSION >= NTDDI_WIN2K)
DECLSPEC_DEPRECATED_DDK         // Use native __int64 math
NTSYSAPI
LARGE_INTEGER
NTAPI
RtlExtendedMagicDivide (
    LARGE_INTEGER Dividend,
    LARGE_INTEGER MagicDivisor,
    CCHAR ShiftCount
    );
#endif

#endif // defined(_X86_) || defined(_IA64_)


#if defined(_AMD64_) || defined(_IA64_)


//
// Large Integer divide - 64-bits / 32-bits -> 64-bits
//

DECLSPEC_DEPRECATED_DDK         // Use native __int64 math
__inline
LARGE_INTEGER
NTAPI_INLINE
RtlExtendedLargeIntegerDivide (
    LARGE_INTEGER Dividend,
    ULONG Divisor,
    PULONG Remainder OPTIONAL
    )
{
    LARGE_INTEGER Quotient;

    Quotient.QuadPart = (ULONG64)Dividend.QuadPart / Divisor;
    if (ARGUMENT_PRESENT(Remainder)) {
        *Remainder = (ULONG)(Dividend.QuadPart % Divisor);
    }

    return Quotient;
}

//
// Extended integer multiply - 32-bits * 64-bits -> 64-bits
//

DECLSPEC_DEPRECATED_DDK         // Use native __int64 math
__inline
LARGE_INTEGER
NTAPI_INLINE
RtlExtendedIntegerMultiply (
    LARGE_INTEGER Multiplicand,
    LONG Multiplier
    )
{
    LARGE_INTEGER Product;

    Product.QuadPart = Multiplicand.QuadPart * Multiplier;
    return Product;
}


#else


//
// Large Integer divide - 64-bits / 32-bits -> 64-bits
//

#if (NTDDI_VERSION >= NTDDI_WIN2K)
DECLSPEC_DEPRECATED_DDK         // Use native __int64 math
NTSYSAPI
LARGE_INTEGER
NTAPI
RtlExtendedLargeIntegerDivide (
    LARGE_INTEGER Dividend,
    ULONG Divisor,
    PULONG Remainder
    );
#endif

//
// Extended integer multiply - 32-bits * 64-bits -> 64-bits
//

#if (NTDDI_VERSION >= NTDDI_WIN2K)
DECLSPEC_DEPRECATED_DDK         // Use native __int64 math
NTSYSAPI
LARGE_INTEGER
NTAPI
RtlExtendedIntegerMultiply (
    LARGE_INTEGER Multiplicand,
    LONG Multiplier
    );
#endif


#endif // defined(_AMD64_) || defined(_IA64_)


//
// Large integer and - 64-bite & 64-bits -> 64-bits.
//

#if PRAGMA_DEPRECATED_DDK
#pragma deprecated(RtlLargeIntegerAnd)      // Use native __int64 math
#endif
#define RtlLargeIntegerAnd(Result, Source, Mask) \
    Result.QuadPart = Source.QuadPart & Mask.QuadPart

//
// Convert signed integer to large integer.
//

DECLSPEC_DEPRECATED_DDK_WINXP         // Use native __int64 math
__inline
LARGE_INTEGER
NTAPI_INLINE
RtlConvertLongToLargeInteger (
    LONG SignedInteger
    )
{
    LARGE_INTEGER Result;

    Result.QuadPart = SignedInteger;
    return Result;
}

//
// Convert unsigned integer to large integer.
//

DECLSPEC_DEPRECATED_DDK_WINXP         // Use native __int64 math
__inline
LARGE_INTEGER
NTAPI_INLINE
RtlConvertUlongToLargeInteger (
    ULONG UnsignedInteger
    )
{
    LARGE_INTEGER Result;

    Result.QuadPart = UnsignedInteger;
    return Result;
}

//
// Large integer shift routines.
//

DECLSPEC_DEPRECATED_DDK_WINXP         // Use native __int64 math
__inline
LARGE_INTEGER
NTAPI_INLINE
RtlLargeIntegerShiftLeft (
    LARGE_INTEGER LargeInteger,
    CCHAR ShiftCount
    )
{
    LARGE_INTEGER Result;

    Result.QuadPart = LargeInteger.QuadPart << ShiftCount;
    return Result;
}

DECLSPEC_DEPRECATED_DDK_WINXP         // Use native __int64 math
__inline
LARGE_INTEGER
NTAPI_INLINE
RtlLargeIntegerShiftRight (
    LARGE_INTEGER LargeInteger,
    CCHAR ShiftCount
    )
{
    LARGE_INTEGER Result;

    Result.QuadPart = (ULONG64)LargeInteger.QuadPart >> ShiftCount;
    return Result;
}

DECLSPEC_DEPRECATED_DDK_WINXP         // Use native __int64 math
__inline
LARGE_INTEGER
NTAPI_INLINE
RtlLargeIntegerArithmeticShift (
    LARGE_INTEGER LargeInteger,
    CCHAR ShiftCount
    )
{
    LARGE_INTEGER Result;

    Result.QuadPart = LargeInteger.QuadPart >> ShiftCount;
    return Result;
}


//
// Large integer comparison routines.
//

#if PRAGMA_DEPRECATED_DDK
#pragma deprecated(RtlLargeIntegerGreaterThan)      // Use native __int64 math
#pragma deprecated(RtlLargeIntegerGreaterThanOrEqualTo)      // Use native __int64 math
#pragma deprecated(RtlLargeIntegerEqualTo)      // Use native __int64 math
#pragma deprecated(RtlLargeIntegerNotEqualTo)      // Use native __int64 math
#pragma deprecated(RtlLargeIntegerLessThan)      // Use native __int64 math
#pragma deprecated(RtlLargeIntegerLessThanOrEqualTo)      // Use native __int64 math
#pragma deprecated(RtlLargeIntegerGreaterThanZero)      // Use native __int64 math
#pragma deprecated(RtlLargeIntegerGreaterOrEqualToZero)      // Use native __int64 math
#pragma deprecated(RtlLargeIntegerEqualToZero)      // Use native __int64 math
#pragma deprecated(RtlLargeIntegerNotEqualToZero)      // Use native __int64 math
#pragma deprecated(RtlLargeIntegerLessThanZero)      // Use native __int64 math
#pragma deprecated(RtlLargeIntegerLessOrEqualToZero)      // Use native __int64 math
#endif

#define RtlLargeIntegerGreaterThan(X,Y) (                              \
    (((X).HighPart == (Y).HighPart) && ((X).LowPart > (Y).LowPart)) || \
    ((X).HighPart > (Y).HighPart)                                      \
)

#define RtlLargeIntegerGreaterThanOrEqualTo(X,Y) (                      \
    (((X).HighPart == (Y).HighPart) && ((X).LowPart >= (Y).LowPart)) || \
    ((X).HighPart > (Y).HighPart)                                       \
)

#define RtlLargeIntegerEqualTo(X,Y) (                              \
    !(((X).LowPart ^ (Y).LowPart) | ((X).HighPart ^ (Y).HighPart)) \
)

#define RtlLargeIntegerNotEqualTo(X,Y) (                          \
    (((X).LowPart ^ (Y).LowPart) | ((X).HighPart ^ (Y).HighPart)) \
)

#define RtlLargeIntegerLessThan(X,Y) (                                 \
    (((X).HighPart == (Y).HighPart) && ((X).LowPart < (Y).LowPart)) || \
    ((X).HighPart < (Y).HighPart)                                      \
)

#define RtlLargeIntegerLessThanOrEqualTo(X,Y) (                         \
    (((X).HighPart == (Y).HighPart) && ((X).LowPart <= (Y).LowPart)) || \
    ((X).HighPart < (Y).HighPart)                                       \
)

#define RtlLargeIntegerGreaterThanZero(X) (       \
    (((X).HighPart == 0) && ((X).LowPart > 0)) || \
    ((X).HighPart > 0 )                           \
)

#define RtlLargeIntegerGreaterOrEqualToZero(X) ( \
    (X).HighPart >= 0                            \
)

#define RtlLargeIntegerEqualToZero(X) ( \
    !((X).LowPart | (X).HighPart)       \
)

#define RtlLargeIntegerNotEqualToZero(X) ( \
    ((X).LowPart | (X).HighPart)           \
)

#define RtlLargeIntegerLessThanZero(X) ( \
    ((X).HighPart < 0)                   \
)

#define RtlLargeIntegerLessOrEqualToZero(X) (           \
    ((X).HighPart < 0) || !((X).LowPart | (X).HighPart) \
)


#endif // !defined(MIDL_PASS)


//
//  Time conversion routines
//

typedef struct _TIME_FIELDS {
    CSHORT Year;        // range [1601...]
    CSHORT Month;       // range [1..12]
    CSHORT Day;         // range [1..31]
    CSHORT Hour;        // range [0..23]
    CSHORT Minute;      // range [0..59]
    CSHORT Second;      // range [0..59]
    CSHORT Milliseconds;// range [0..999]
    CSHORT Weekday;     // range [0..6] == [Sunday..Saturday]
} TIME_FIELDS;
typedef TIME_FIELDS *PTIME_FIELDS;


#if (NTDDI_VERSION >= NTDDI_WIN2K)
NTSYSAPI
VOID
NTAPI
RtlTimeToTimeFields (
    PLARGE_INTEGER Time,
    PTIME_FIELDS TimeFields
    );
#endif

//
//  A time field record (Weekday ignored) -> 64 bit Time value
//

#if (NTDDI_VERSION >= NTDDI_WIN2K)
NTSYSAPI
BOOLEAN
NTAPI
RtlTimeFieldsToTime (
    PTIME_FIELDS TimeFields,
    PLARGE_INTEGER Time
    );
#endif

//
// The following macros store and retrieve USHORTS and ULONGS from potentially
// unaligned addresses, avoiding alignment faults.  they should probably be
// rewritten in assembler
//

#define SHORT_SIZE  (sizeof(USHORT))
#define SHORT_MASK  (SHORT_SIZE - 1)
#define LONG_SIZE       (sizeof(LONG))
#define LONGLONG_SIZE   (sizeof(LONGLONG))
#define LONG_MASK       (LONG_SIZE - 1)
#define LONGLONG_MASK   (LONGLONG_SIZE - 1)
#define LOWBYTE_MASK 0x00FF

#define FIRSTBYTE(VALUE)  ((VALUE) & LOWBYTE_MASK)
#define SECONDBYTE(VALUE) (((VALUE) >> 8) & LOWBYTE_MASK)
#define THIRDBYTE(VALUE)  (((VALUE) >> 16) & LOWBYTE_MASK)
#define FOURTHBYTE(VALUE) (((VALUE) >> 24) & LOWBYTE_MASK)

//
// if MIPS Big Endian, order of bytes is reversed.
//

#define SHORT_LEAST_SIGNIFICANT_BIT  0
#define SHORT_MOST_SIGNIFICANT_BIT   1

#define LONG_LEAST_SIGNIFICANT_BIT       0
#define LONG_3RD_MOST_SIGNIFICANT_BIT    1
#define LONG_2ND_MOST_SIGNIFICANT_BIT    2
#define LONG_MOST_SIGNIFICANT_BIT        3

//++
//
// VOID
// RtlStoreUshort (
//     PUSHORT ADDRESS
//     USHORT VALUE
//     )
//
// Routine Description:
//
// This macro stores a USHORT value in at a particular address, avoiding
// alignment faults.
//
// Arguments:
//
//     ADDRESS - where to store USHORT value
//     VALUE - USHORT to store
//
// Return Value:
//
//     none.
//
//--

#if defined(_AMD64_)

#define RtlStoreUshort(ADDRESS,VALUE)                           \
        *(USHORT UNALIGNED *)(ADDRESS) = (VALUE)

#else

#define RtlStoreUshort(ADDRESS,VALUE)                     \
         if ((ULONG_PTR)(ADDRESS) & SHORT_MASK) {         \
             ((PUCHAR) (ADDRESS))[SHORT_LEAST_SIGNIFICANT_BIT] = (UCHAR)(FIRSTBYTE(VALUE));    \
             ((PUCHAR) (ADDRESS))[SHORT_MOST_SIGNIFICANT_BIT ] = (UCHAR)(SECONDBYTE(VALUE));   \
         }                                                \
         else {                                           \
             *((PUSHORT) (ADDRESS)) = (USHORT) VALUE;     \
         }

#endif

//++
//
// VOID
// RtlStoreUlong (
//     PULONG ADDRESS
//     ULONG VALUE
//     )
//
// Routine Description:
//
// This macro stores a ULONG value in at a particular address, avoiding
// alignment faults.
//
// Arguments:
//
//     ADDRESS - where to store ULONG value
//     VALUE - ULONG to store
//
// Return Value:
//
//     none.
//
// Note:
//     Depending on the machine, we might want to call storeushort in the
//     unaligned case.
//
//--


#if defined(_AMD64_)

#define RtlStoreUlong(ADDRESS,VALUE)                        \
        *(ULONG UNALIGNED *)(ADDRESS) = (VALUE)

#else

#define RtlStoreUlong(ADDRESS,VALUE)                      \
         if ((ULONG_PTR)(ADDRESS) & LONG_MASK) {          \
             ((PUCHAR) (ADDRESS))[LONG_LEAST_SIGNIFICANT_BIT      ] = (UCHAR)(FIRSTBYTE(VALUE));    \
             ((PUCHAR) (ADDRESS))[LONG_3RD_MOST_SIGNIFICANT_BIT   ] = (UCHAR)(SECONDBYTE(VALUE));   \
             ((PUCHAR) (ADDRESS))[LONG_2ND_MOST_SIGNIFICANT_BIT   ] = (UCHAR)(THIRDBYTE(VALUE));    \
             ((PUCHAR) (ADDRESS))[LONG_MOST_SIGNIFICANT_BIT       ] = (UCHAR)(FOURTHBYTE(VALUE));   \
         }                                                \
         else {                                           \
             *((PULONG) (ADDRESS)) = (ULONG) (VALUE);     \
         }

#endif

//++
//
// VOID
// RtlStoreUlonglong (
//     PULONGLONG ADDRESS
//     ULONG VALUE
//     )
//
// Routine Description:
//
// This macro stores a ULONGLONG value in at a particular address, avoiding
// alignment faults.
//
// Arguments:
//
//     ADDRESS - where to store ULONGLONG value
//     VALUE - ULONGLONG to store
//
// Return Value:
//
//     none.
//
//--

#if defined(_AMD64_)

#define RtlStoreUlonglong(ADDRESS,VALUE)                        \
        *(ULONGLONG UNALIGNED *)(ADDRESS) = (VALUE)

#else

#define RtlStoreUlonglong(ADDRESS,VALUE)                        \
         if ((ULONG_PTR)(ADDRESS) & LONGLONG_MASK) {            \
             RtlStoreUlong((ULONG_PTR)(ADDRESS),                \
                           (ULONGLONG)(VALUE) & 0xFFFFFFFF);    \
             RtlStoreUlong((ULONG_PTR)(ADDRESS)+sizeof(ULONG),  \
                           (ULONGLONG)(VALUE) >> 32);           \
         } else {                                               \
             *((PULONGLONG)(ADDRESS)) = (ULONGLONG)(VALUE);     \
         }

#endif

//++
//
// VOID
// RtlStoreUlongPtr (
//     PULONG_PTR ADDRESS
//     ULONG_PTR VALUE
//     )
//
// Routine Description:
//
// This macro stores a ULONG_PTR value in at a particular address, avoiding
// alignment faults.
//
// Arguments:
//
//     ADDRESS - where to store ULONG_PTR value
//     VALUE - ULONG_PTR to store
//
// Return Value:
//
//     none.
//
//--

#ifdef _WIN64

#define RtlStoreUlongPtr(ADDRESS,VALUE)                         \
         RtlStoreUlonglong(ADDRESS,VALUE)

#else

#define RtlStoreUlongPtr(ADDRESS,VALUE)                         \
         RtlStoreUlong(ADDRESS,VALUE)

#endif

//++
//
// VOID
// RtlRetrieveUshort (
//     PUSHORT DESTINATION_ADDRESS
//     PUSHORT SOURCE_ADDRESS
//     )
//
// Routine Description:
//
// This macro retrieves a USHORT value from the SOURCE address, avoiding
// alignment faults.  The DESTINATION address is assumed to be aligned.
//
// Arguments:
//
//     DESTINATION_ADDRESS - where to store USHORT value
//     SOURCE_ADDRESS - where to retrieve USHORT value from
//
// Return Value:
//
//     none.
//
//--

#if defined(_AMD64_)

#define RtlRetrieveUshort(DEST_ADDRESS,SRC_ADDRESS)                     \
         *(USHORT UNALIGNED *)(DEST_ADDRESS) = *(PUSHORT)(SRC_ADDRESS)

#else

#define RtlRetrieveUshort(DEST_ADDRESS,SRC_ADDRESS)                   \
         if ((ULONG_PTR)SRC_ADDRESS & SHORT_MASK) {                       \
             ((PUCHAR) (DEST_ADDRESS))[0] = ((PUCHAR) (SRC_ADDRESS))[0];  \
             ((PUCHAR) (DEST_ADDRESS))[1] = ((PUCHAR) (SRC_ADDRESS))[1];  \
         }                                                            \
         else {                                                       \
             *((PUSHORT) DEST_ADDRESS) = *((PUSHORT) SRC_ADDRESS);    \
         }                                                            \

#endif

//++
//
// VOID
// RtlRetrieveUlong (
//     PULONG DESTINATION_ADDRESS
//     PULONG SOURCE_ADDRESS
//     )
//
// Routine Description:
//
// This macro retrieves a ULONG value from the SOURCE address, avoiding
// alignment faults.  The DESTINATION address is assumed to be aligned.
//
// Arguments:
//
//     DESTINATION_ADDRESS - where to store ULONG value
//     SOURCE_ADDRESS - where to retrieve ULONG value from
//
// Return Value:
//
//     none.
//
// Note:
//     Depending on the machine, we might want to call retrieveushort in the
//     unaligned case.
//
//--

#if defined(_AMD64_)

#define RtlRetrieveUlong(DEST_ADDRESS,SRC_ADDRESS)                     \
         *(ULONG UNALIGNED *)(DEST_ADDRESS) = *(PULONG)(SRC_ADDRESS)

#else

#define RtlRetrieveUlong(DEST_ADDRESS,SRC_ADDRESS)                    \
         if ((ULONG_PTR)SRC_ADDRESS & LONG_MASK) {                        \
             ((PUCHAR) (DEST_ADDRESS))[0] = ((PUCHAR) (SRC_ADDRESS))[0];  \
             ((PUCHAR) (DEST_ADDRESS))[1] = ((PUCHAR) (SRC_ADDRESS))[1];  \
             ((PUCHAR) (DEST_ADDRESS))[2] = ((PUCHAR) (SRC_ADDRESS))[2];  \
             ((PUCHAR) (DEST_ADDRESS))[3] = ((PUCHAR) (SRC_ADDRESS))[3];  \
         }                                                            \
         else {                                                       \
             *((PULONG) DEST_ADDRESS) = *((PULONG) SRC_ADDRESS);      \
         }

#endif

//
//  BitMap routines.  The following structure, routines, and macros are
//  for manipulating bitmaps.  The user is responsible for allocating a bitmap
//  structure (which is really a header) and a buffer (which must be longword
//  aligned and multiple longwords in size).
//

typedef struct _RTL_BITMAP {
    ULONG SizeOfBitMap;                     // Number of bits in bit map
    PULONG Buffer;                          // Pointer to the bit map itself
} RTL_BITMAP;
typedef RTL_BITMAP *PRTL_BITMAP;

//
//  The following routine initializes a new bitmap.  It does not alter the
//  data currently in the bitmap.  This routine must be called before
//  any other bitmap routine/macro.
//

#if (NTDDI_VERSION >= NTDDI_WIN2K)
NTSYSAPI
VOID
NTAPI
RtlInitializeBitMap (
    PRTL_BITMAP BitMapHeader,
    PULONG BitMapBuffer,
    ULONG SizeOfBitMap
    );
#endif

//
//  The following three routines clear, set, and test the state of a
//  single bit in a bitmap.
//

#if (NTDDI_VERSION >= NTDDI_WINXP)
NTSYSAPI
VOID
NTAPI
RtlClearBit (
    PRTL_BITMAP BitMapHeader,
    ULONG BitNumber
    );
#endif

#if (NTDDI_VERSION >= NTDDI_WINXP)
NTSYSAPI
VOID
NTAPI
RtlSetBit (
    PRTL_BITMAP BitMapHeader,
    ULONG BitNumber
    );
#endif

#if (NTDDI_VERSION >= NTDDI_WINXP)
NTSYSAPI
BOOLEAN
NTAPI
RtlTestBit (
    PRTL_BITMAP BitMapHeader,
    ULONG BitNumber
    );
#endif

//
//  The following two routines either clear or set all of the bits
//  in a bitmap.
//

#if (NTDDI_VERSION >= NTDDI_WIN2K)
NTSYSAPI
VOID
NTAPI
RtlClearAllBits (
    PRTL_BITMAP BitMapHeader
    );
#endif

#if (NTDDI_VERSION >= NTDDI_WIN2K)
NTSYSAPI
VOID
NTAPI
RtlSetAllBits (
    PRTL_BITMAP BitMapHeader
    );
#endif

//
//  The following two routines locate a contiguous region of either
//  clear or set bits within the bitmap.  The region will be at least
//  as large as the number specified, and the search of the bitmap will
//  begin at the specified hint index (which is a bit index within the
//  bitmap, zero based).  The return value is the bit index of the located
//  region (zero based) or -1 (i.e., 0xffffffff) if such a region cannot
//  be located
//

#if (NTDDI_VERSION >= NTDDI_WIN2K)
NTSYSAPI
ULONG
NTAPI
RtlFindClearBits (
    PRTL_BITMAP BitMapHeader,
    ULONG NumberToFind,
    ULONG HintIndex
    );
#endif

#if (NTDDI_VERSION >= NTDDI_WIN2K)
NTSYSAPI
ULONG
NTAPI
RtlFindSetBits (
    PRTL_BITMAP BitMapHeader,
    ULONG NumberToFind,
    ULONG HintIndex
    );
#endif

//
//  The following two routines locate a contiguous region of either
//  clear or set bits within the bitmap and either set or clear the bits
//  within the located region.  The region will be as large as the number
//  specified, and the search for the region will begin at the specified
//  hint index (which is a bit index within the bitmap, zero based).  The
//  return value is the bit index of the located region (zero based) or
//  -1 (i.e., 0xffffffff) if such a region cannot be located.  If a region
//  cannot be located then the setting/clearing of the bitmap is not performed.
//

#if (NTDDI_VERSION >= NTDDI_WIN2K)
NTSYSAPI
ULONG
NTAPI
RtlFindClearBitsAndSet (
    PRTL_BITMAP BitMapHeader,
    ULONG NumberToFind,
    ULONG HintIndex
    );
#endif

#if (NTDDI_VERSION >= NTDDI_WIN2K)
NTSYSAPI
ULONG
NTAPI
RtlFindSetBitsAndClear (
    PRTL_BITMAP BitMapHeader,
    ULONG NumberToFind,
    ULONG HintIndex
    );
#endif

//
//  The following two routines clear or set bits within a specified region
//  of the bitmap.  The starting index is zero based.
//

#if (NTDDI_VERSION >= NTDDI_WIN2K)
NTSYSAPI
VOID
NTAPI
RtlClearBits (
    PRTL_BITMAP BitMapHeader,
    ULONG StartingIndex,
    ULONG NumberToClear
    );
#endif

#if (NTDDI_VERSION >= NTDDI_WIN2K)
NTSYSAPI
VOID
NTAPI
RtlSetBits (
    PRTL_BITMAP BitMapHeader,
    ULONG StartingIndex,
    ULONG NumberToSet
    );
#endif

//
//  The following routine locates a set of contiguous regions of clear
//  bits within the bitmap.  The caller specifies whether to return the
//  longest runs or just the first found lcoated.  The following structure is
//  used to denote a contiguous run of bits.  The two routines return an array
//  of this structure, one for each run located.
//

typedef struct _RTL_BITMAP_RUN {

    ULONG StartingIndex;
    ULONG NumberOfBits;

} RTL_BITMAP_RUN;
typedef RTL_BITMAP_RUN *PRTL_BITMAP_RUN;

#if (NTDDI_VERSION >= NTDDI_WIN2K)
NTSYSAPI
ULONG
NTAPI
RtlFindClearRuns (
    PRTL_BITMAP BitMapHeader,
    PRTL_BITMAP_RUN RunArray,
    ULONG SizeOfRunArray,
    BOOLEAN LocateLongestRuns
    );
#endif

//
//  The following routine locates the longest contiguous region of
//  clear bits within the bitmap.  The returned starting index value
//  denotes the first contiguous region located satisfying our requirements
//  The return value is the length (in bits) of the longest region found.
//

#if (NTDDI_VERSION >= NTDDI_WIN2K)
NTSYSAPI
ULONG
NTAPI
RtlFindLongestRunClear (
    PRTL_BITMAP BitMapHeader,
    PULONG StartingIndex
    );
#endif

//
//  The following routine locates the first contiguous region of
//  clear bits within the bitmap.  The returned starting index value
//  denotes the first contiguous region located satisfying our requirements
//  The return value is the length (in bits) of the region found.
//

#if (NTDDI_VERSION >= NTDDI_WIN2K)
NTSYSAPI
ULONG
NTAPI
RtlFindFirstRunClear (
    PRTL_BITMAP BitMapHeader,
    PULONG StartingIndex
    );
#endif

//
//  The following macro returns the value of the bit stored within the
//  bitmap at the specified location.  If the bit is set a value of 1 is
//  returned otherwise a value of 0 is returned.
//
//      ULONG
//      RtlCheckBit (
//          PRTL_BITMAP BitMapHeader,
//          ULONG BitPosition
//          );
//
//
//  To implement CheckBit the macro retrieves the longword containing the
//  bit in question, shifts the longword to get the bit in question into the
//  low order bit position and masks out all other bits.
//

#if defined(_M_AMD64) && !defined(MIDL_PASS)

FORCEINLINE
BOOLEAN
RtlCheckBit (
    PRTL_BITMAP BitMapHeader,
    ULONG BitPosition
    )

{

    return BitTest((LONG const *)BitMapHeader->Buffer, BitPosition);
}

#else

#define RtlCheckBit(BMH,BP) (((((PLONG)(BMH)->Buffer)[(BP) / 32]) >> ((BP) % 32)) & 0x1)

#endif

//
//  The following two procedures return to the caller the total number of
//  clear or set bits within the specified bitmap.
//

#if (NTDDI_VERSION >= NTDDI_WIN2K)
NTSYSAPI
ULONG
NTAPI
RtlNumberOfClearBits (
    PRTL_BITMAP BitMapHeader
    );
#endif

#if (NTDDI_VERSION >= NTDDI_WIN2K)
NTSYSAPI
ULONG
NTAPI
RtlNumberOfSetBits (
    PRTL_BITMAP BitMapHeader
    );
#endif

//
//  The following two procedures return to the caller a boolean value
//  indicating if the specified range of bits are all clear or set.
//

#if (NTDDI_VERSION >= NTDDI_WIN2K)
NTSYSAPI
BOOLEAN
NTAPI
RtlAreBitsClear (
    PRTL_BITMAP BitMapHeader,
    ULONG StartingIndex,
    ULONG Length
    );
#endif

#if (NTDDI_VERSION >= NTDDI_WIN2K)
NTSYSAPI
BOOLEAN
NTAPI
RtlAreBitsSet (
    PRTL_BITMAP BitMapHeader,
    ULONG StartingIndex,
    ULONG Length
    );
#endif

#if (NTDDI_VERSION >= NTDDI_WIN2K)
NTSYSAPI
ULONG
NTAPI
RtlFindNextForwardRunClear (
    IN PRTL_BITMAP BitMapHeader,
    IN ULONG FromIndex,
    IN PULONG StartingRunIndex
    );
#endif

#if (NTDDI_VERSION >= NTDDI_WIN2K)
NTSYSAPI
ULONG
NTAPI
RtlFindLastBackwardRunClear (
    IN PRTL_BITMAP BitMapHeader,
    IN ULONG FromIndex,
    IN PULONG StartingRunIndex
    );
#endif

//
//  The following two procedures return to the caller a value indicating
//  the position within a ULONGLONG of the most or least significant non-zero
//  bit.  A value of zero results in a return value of -1.
//

#if (NTDDI_VERSION >= NTDDI_WIN2K)
NTSYSAPI
CCHAR
NTAPI
RtlFindLeastSignificantBit (
    IN ULONGLONG Set
    );
#endif

#if (NTDDI_VERSION >= NTDDI_WIN2K)
NTSYSAPI
CCHAR
NTAPI
RtlFindMostSignificantBit (
    IN ULONGLONG Set
    );
#endif

//
// The following procedure finds the number of set bits within a ULONG_PTR
// value.
//

#if (NTDDI_VERSION >= NTDDI_VISTA)
NTSYSAPI
ULONG
NTAPI
RtlNumberOfSetBitsUlongPtr (
    IN ULONG_PTR Target
    );
#endif


//
// BOOLEAN
// RtlEqualLuid(
//      PLUID L1,
//      PLUID L2
//      );

#define RtlEqualLuid(L1, L2) (((L1)->LowPart == (L2)->LowPart) && \
                              ((L1)->HighPart  == (L2)->HighPart))

//
// BOOLEAN
// RtlIsZeroLuid(
//      PLUID L1
//      );
//
#define RtlIsZeroLuid(L1) ((BOOLEAN) (((L1)->LowPart | (L1)->HighPart) == 0))

//
//  SecurityDescriptor RTL routine definitions
//

#if (NTDDI_VERSION >= NTDDI_WIN2K)
NTSYSAPI
NTSTATUS
NTAPI
RtlCreateSecurityDescriptor (
    PSECURITY_DESCRIPTOR SecurityDescriptor,
    ULONG Revision
    );
#endif


#if (NTDDI_VERSION >= NTDDI_WIN2K)
NTSYSAPI
BOOLEAN
NTAPI
RtlValidSecurityDescriptor (
    PSECURITY_DESCRIPTOR SecurityDescriptor
    );
#endif

#if (NTDDI_VERSION >= NTDDI_WIN2K)
NTSYSAPI
ULONG
NTAPI
RtlLengthSecurityDescriptor (
    PSECURITY_DESCRIPTOR SecurityDescriptor
    );
#endif

#if (NTDDI_VERSION >= NTDDI_WIN2K)
NTSYSAPI
BOOLEAN
NTAPI
RtlValidRelativeSecurityDescriptor (
    IN PSECURITY_DESCRIPTOR SecurityDescriptorInput,
    IN ULONG SecurityDescriptorLength,
    IN SECURITY_INFORMATION RequiredInformation
    );
#endif


#if (NTDDI_VERSION >= NTDDI_WIN2K)
NTSYSAPI
NTSTATUS
NTAPI
RtlSetDaclSecurityDescriptor (
    PSECURITY_DESCRIPTOR SecurityDescriptor,
    BOOLEAN DaclPresent,
    PACL Dacl,
    BOOLEAN DaclDefaulted
    );
#endif


//
// Byte swap routines.  These are used to convert from little-endian to
// big-endian and vice-versa.
//

#if (defined(_M_IX86) && (_MSC_FULL_VER > 13009037)) || ((defined(_M_AMD64) || defined(_M_IA64)) && (_MSC_FULL_VER > 13009175))
#ifdef __cplusplus
extern "C" {
#endif
__checkReturn unsigned short __cdecl _byteswap_ushort(unsigned short);
__checkReturn unsigned long  __cdecl _byteswap_ulong (unsigned long);
unsigned __int64 __cdecl _byteswap_uint64(unsigned __int64);
#ifdef __cplusplus
}
#endif
#pragma intrinsic(_byteswap_ushort)
#pragma intrinsic(_byteswap_ulong)
#pragma intrinsic(_byteswap_uint64)

#define RtlUshortByteSwap(_x)    _byteswap_ushort((USHORT)(_x))
#define RtlUlongByteSwap(_x)     _byteswap_ulong((_x))
#define RtlUlonglongByteSwap(_x) _byteswap_uint64((_x))
#else

#if (NTDDI_VERSION >= NTDDI_WIN2K)
NTSYSAPI
USHORT
FASTCALL
RtlUshortByteSwap(
    IN USHORT Source
    );
#endif

#if (NTDDI_VERSION >= NTDDI_WIN2K)
NTSYSAPI
ULONG
FASTCALL
RtlUlongByteSwap(
    IN ULONG Source
    );
#endif

#if (NTDDI_VERSION >= NTDDI_WIN2K)
NTSYSAPI
ULONGLONG
FASTCALL
RtlUlonglongByteSwap(
    IN ULONGLONG Source
    );
#endif

#endif


#define RTLVERLIB_DDI(x) x

typedef BOOLEAN (*PFN_RTL_IS_NTDDI_VERSION_AVAILABLE)(
    IN ULONG Version
    );

typedef BOOLEAN (*PFN_RTL_IS_SERVICE_PACK_VERSION_INSTALLED)(
    IN ULONG Version
    );

BOOLEAN
RTLVERLIB_DDI(RtlIsNtDdiVersionAvailable)(
    ULONG Version
    );

BOOLEAN
RTLVERLIB_DDI(RtlIsServicePackVersionInstalled)(
    ULONG Version
    );

#if (NTDDI_VERSION < NTDDI_VISTA)

BOOLEAN
RTLVERLIB_DDI(WdmlibRtlIsNtDdiVersionAvailable)(
    ULONG Version
    );

BOOLEAN
RTLVERLIB_DDI(WdmlibRtlIsServicePackVersionInstalled)(
    ULONG Version
    );

#define RtlIsNtDdiVersionAvailable WdmlibRtlIsNtDdiVersionAvailable
#define RtlIsServicePackVersionInstalled WdmlibRtlIsServicePackVersionInstalled

#endif



//
// Interlocked bit manipulation interfaces
//

#define RtlInterlockedSetBits(Flags, Flag) \
    InterlockedOr((PLONG)(Flags), Flag)

#define RtlInterlockedAndBits(Flags, Flag) \
    InterlockedAnd((PLONG)(Flags), Flag)

#define RtlInterlockedClearBits(Flags, Flag) \
    RtlInterlockedAndBits(Flags, ~(Flag))

#define RtlInterlockedXorBits(Flags, Flag) \
    InterlockedXor(Flags, Flag)

#define RtlInterlockedSetBitsDiscardReturn(Flags, Flag) \
    (VOID) RtlInterlockedSetBits(Flags, Flag)

#define RtlInterlockedAndBitsDiscardReturn(Flags, Flag) \
    (VOID) RtlInterlockedAndBits(Flags, Flag)

#define RtlInterlockedClearBitsDiscardReturn(Flags, Flag) \
    RtlInterlockedAndBitsDiscardReturn(Flags, ~(Flag))

#if (NTDDI_VERSION >= NTDDI_WINXP)
#include <dpfilter.h>
#endif

#if (NTDDI_VERSION >= NTDDI_VISTA)
NTSYSAPI
NTSTATUS
NTAPI
RtlIoEncodeMemIoResource (
    __in PIO_RESOURCE_DESCRIPTOR Descriptor,
    __in UCHAR Type,
    __in ULONGLONG Length,
    __in ULONGLONG Alignment,
    __in ULONGLONG MinimumAddress,
    __in ULONGLONG MaximumAddress
    );
#endif

#if (NTDDI_VERSION >= NTDDI_VISTA)
NTSYSAPI
NTSTATUS
NTAPI
RtlCmEncodeMemIoResource (
    __in PCM_PARTIAL_RESOURCE_DESCRIPTOR Descriptor,
    __in UCHAR Type,
    __in ULONGLONG Length,
    __in ULONGLONG Start
    );
#endif

#if (NTDDI_VERSION >= NTDDI_VISTA)
NTSYSAPI
ULONGLONG
NTAPI
RtlIoDecodeMemIoResource (
    __in PIO_RESOURCE_DESCRIPTOR Descriptor,
    __out_opt PULONGLONG Alignment,
    __out_opt PULONGLONG MinimumAddress,
    __out_opt PULONGLONG MaximumAddress
    );
#endif

#if (NTDDI_VERSION >= NTDDI_VISTA)
NTSYSAPI
ULONGLONG
NTAPI
RtlCmDecodeMemIoResource (
    __in PCM_PARTIAL_RESOURCE_DESCRIPTOR Descriptor,
    __out_opt PULONGLONG Start
    );
#endif

#if (NTDDI_VERSION >= NTDDI_VISTA)
NTSYSAPI
NTSTATUS
NTAPI
RtlFindClosestEncodableLength (
    __in ULONGLONG SourceLength,
    __out PULONGLONG TargetLength
    );
#endif

#ifndef _NTTMAPI_
#define _NTTMAPI_


#ifdef __cplusplus
extern "C" {
#endif


#include <ktmtypes.h>

//
// Types for Nt level TM calls
//

//
// KTM Tm object rights
//
#define TRANSACTIONMANAGER_QUERY_INFORMATION     ( 0x0001 )
#define TRANSACTIONMANAGER_SET_INFORMATION       ( 0x0002 )
#define TRANSACTIONMANAGER_RECOVER               ( 0x0004 )
#define TRANSACTIONMANAGER_RENAME                ( 0x0008 )
#define TRANSACTIONMANAGER_CREATE_RM             ( 0x0010 )

// The following right is intended for DTC's use only; it will be
// deprecated, and no one else should take a dependency on it.
#define TRANSACTIONMANAGER_BIND_TRANSACTION      ( 0x0020 )

//
// Generic mappings for transaction manager rights.
//

#define TRANSACTIONMANAGER_GENERIC_READ            (STANDARD_RIGHTS_READ            |\
                                                    TRANSACTIONMANAGER_QUERY_INFORMATION)

#define TRANSACTIONMANAGER_GENERIC_WRITE           (STANDARD_RIGHTS_WRITE           |\
                                                    TRANSACTIONMANAGER_SET_INFORMATION     |\
                                                    TRANSACTIONMANAGER_RECOVER             |\
                                                    TRANSACTIONMANAGER_RENAME              |\
                                                    TRANSACTIONMANAGER_CREATE_RM)

#define TRANSACTIONMANAGER_GENERIC_EXECUTE         (STANDARD_RIGHTS_EXECUTE)

#define TRANSACTIONMANAGER_ALL_ACCESS              (STANDARD_RIGHTS_REQUIRED        |\
                                                    TRANSACTIONMANAGER_GENERIC_READ        |\
                                                    TRANSACTIONMANAGER_GENERIC_WRITE       |\
                                                    TRANSACTIONMANAGER_GENERIC_EXECUTE     |\
                                                    TRANSACTIONMANAGER_BIND_TRANSACTION)


//
// KTM transaction object rights.
//
#define TRANSACTION_QUERY_INFORMATION     ( 0x0001 )
#define TRANSACTION_SET_INFORMATION       ( 0x0002 )
#define TRANSACTION_ENLIST                ( 0x0004 )
#define TRANSACTION_COMMIT                ( 0x0008 )
#define TRANSACTION_ROLLBACK              ( 0x0010 )
#define TRANSACTION_PROPAGATE             ( 0x0020 )
#define TRANSACTION_RIGHT_RESERVED1       ( 0x0040 )

//
// Generic mappings for transaction rights.
// Resource managers, when enlisting, should generally use the macro
// TRANSACTION_RESOURCE_MANAGER_RIGHTS when opening a transaction.
// It's the same as generic read and write except that it does not allow
// a commit decision to be made.
//

#define TRANSACTION_GENERIC_READ            (STANDARD_RIGHTS_READ            |\
                                             TRANSACTION_QUERY_INFORMATION   |\
                                             SYNCHRONIZE)

#define TRANSACTION_GENERIC_WRITE           (STANDARD_RIGHTS_WRITE           |\
                                             TRANSACTION_SET_INFORMATION     |\
                                             TRANSACTION_COMMIT              |\
                                             TRANSACTION_ENLIST              |\
                                             TRANSACTION_ROLLBACK            |\
                                             TRANSACTION_PROPAGATE           |\
                                             SYNCHRONIZE)

#define TRANSACTION_GENERIC_EXECUTE         (STANDARD_RIGHTS_EXECUTE         |\
                                             TRANSACTION_COMMIT              |\
                                             TRANSACTION_ROLLBACK            |\
                                             SYNCHRONIZE)

#define TRANSACTION_ALL_ACCESS              (STANDARD_RIGHTS_REQUIRED        |\
                                             TRANSACTION_GENERIC_READ        |\
                                             TRANSACTION_GENERIC_WRITE       |\
                                             TRANSACTION_GENERIC_EXECUTE)

#define TRANSACTION_RESOURCE_MANAGER_RIGHTS (TRANSACTION_GENERIC_READ        |\
                                             STANDARD_RIGHTS_WRITE           |\
                                             TRANSACTION_SET_INFORMATION     |\
                                             TRANSACTION_ENLIST              |\
                                             TRANSACTION_ROLLBACK            |\
                                             TRANSACTION_PROPAGATE           |\
                                             SYNCHRONIZE)

//
// KTM resource manager object rights.
//
#define RESOURCEMANAGER_QUERY_INFORMATION     ( 0x0001 )
#define RESOURCEMANAGER_SET_INFORMATION       ( 0x0002 )
#define RESOURCEMANAGER_RECOVER               ( 0x0004 )
#define RESOURCEMANAGER_ENLIST                ( 0x0008 )
#define RESOURCEMANAGER_GET_NOTIFICATION      ( 0x0010 )
#define RESOURCEMANAGER_REGISTER_PROTOCOL     ( 0x0020 )
#define RESOURCEMANAGER_COMPLETE_PROPAGATION  ( 0x0040 )

//
// Generic mappings for resource manager rights.
//
#define RESOURCEMANAGER_GENERIC_READ        (STANDARD_RIGHTS_READ                 |\
                                             RESOURCEMANAGER_QUERY_INFORMATION    |\
                                             SYNCHRONIZE)

#define RESOURCEMANAGER_GENERIC_WRITE       (STANDARD_RIGHTS_WRITE                |\
                                             RESOURCEMANAGER_SET_INFORMATION      |\
                                             RESOURCEMANAGER_RECOVER              |\
                                             RESOURCEMANAGER_ENLIST               |\
                                             RESOURCEMANAGER_GET_NOTIFICATION     |\
                                             RESOURCEMANAGER_REGISTER_PROTOCOL    |\
                                             RESOURCEMANAGER_COMPLETE_PROPAGATION |\
                                             SYNCHRONIZE)

#define RESOURCEMANAGER_GENERIC_EXECUTE     (STANDARD_RIGHTS_EXECUTE              |\
                                             RESOURCEMANAGER_RECOVER              |\
                                             RESOURCEMANAGER_ENLIST               |\
                                             RESOURCEMANAGER_GET_NOTIFICATION     |\
                                             RESOURCEMANAGER_COMPLETE_PROPAGATION |\
                                             SYNCHRONIZE)

#define RESOURCEMANAGER_ALL_ACCESS          (STANDARD_RIGHTS_REQUIRED             |\
                                             RESOURCEMANAGER_GENERIC_READ         |\
                                             RESOURCEMANAGER_GENERIC_WRITE        |\
                                             RESOURCEMANAGER_GENERIC_EXECUTE)


//
// KTM enlistment object rights.
//
#define ENLISTMENT_QUERY_INFORMATION     ( 0x0001 )
#define ENLISTMENT_SET_INFORMATION       ( 0x0002 )
#define ENLISTMENT_RECOVER               ( 0x0004 )
#define ENLISTMENT_SUBORDINATE_RIGHTS    ( 0x0008 )
#define ENLISTMENT_SUPERIOR_RIGHTS       ( 0x0010 )

//
// Generic mappings for enlistment rights.
//
#define ENLISTMENT_GENERIC_READ        (STANDARD_RIGHTS_READ           |\
                                        ENLISTMENT_QUERY_INFORMATION)

#define ENLISTMENT_GENERIC_WRITE       (STANDARD_RIGHTS_WRITE          |\
                                        ENLISTMENT_SET_INFORMATION     |\
                                        ENLISTMENT_RECOVER             |\
                                        ENLISTMENT_SUBORDINATE_RIGHTS  |\
                                        ENLISTMENT_SUPERIOR_RIGHTS)

#define ENLISTMENT_GENERIC_EXECUTE     (STANDARD_RIGHTS_EXECUTE        |\
                                        ENLISTMENT_RECOVER             |\
                                        ENLISTMENT_SUBORDINATE_RIGHTS  |\
                                        ENLISTMENT_SUPERIOR_RIGHTS)

#define ENLISTMENT_ALL_ACCESS          (STANDARD_RIGHTS_REQUIRED       |\
                                        ENLISTMENT_GENERIC_READ        |\
                                        ENLISTMENT_GENERIC_WRITE       |\
                                        ENLISTMENT_GENERIC_EXECUTE)


//
// Transaction outcomes.
//
// TODO: warning, must match values in KTRANSACTION_OUTCOME duplicated def 
// in tm.h.
//

typedef enum _TRANSACTION_OUTCOME {
    TransactionOutcomeUndetermined = 1,
    TransactionOutcomeCommitted,
    TransactionOutcomeAborted,
} TRANSACTION_OUTCOME;


typedef enum _TRANSACTION_STATE {
    TransactionStateNormal = 1,
    TransactionStateIndoubt,
    TransactionStateCommittedNotify,
} TRANSACTION_STATE;


typedef struct _TRANSACTION_BASIC_INFORMATION {
    GUID    TransactionId;
    ULONG   State;
    ULONG   Outcome;
} TRANSACTION_BASIC_INFORMATION, *PTRANSACTION_BASIC_INFORMATION;

typedef struct _TRANSACTIONMANAGER_BASIC_INFORMATION {
    GUID    TmIdentity;
    LARGE_INTEGER VirtualClock;
} TRANSACTIONMANAGER_BASIC_INFORMATION, *PTRANSACTIONMANAGER_BASIC_INFORMATION;

typedef struct _TRANSACTIONMANAGER_LOG_INFORMATION {
    GUID  LogIdentity;
} TRANSACTIONMANAGER_LOG_INFORMATION, *PTRANSACTIONMANAGER_LOG_INFORMATION;

typedef struct _TRANSACTIONMANAGER_LOGPATH_INFORMATION {
    ULONG LogPathLength;
    __field_ecount(LogPathLength) WCHAR LogPath[1]; // Variable size
//  Data[1];                                        // Variable size data not declared
} TRANSACTIONMANAGER_LOGPATH_INFORMATION, *PTRANSACTIONMANAGER_LOGPATH_INFORMATION;

typedef struct _TRANSACTIONMANAGER_RECOVERY_INFORMATION {
    ULONGLONG  LastRecoveredLsn;
} TRANSACTIONMANAGER_RECOVERY_INFORMATION, *PTRANSACTIONMANAGER_RECOVERY_INFORMATION;




typedef struct _TRANSACTION_PROPERTIES_INFORMATION {
    ULONG              IsolationLevel;
    ULONG              IsolationFlags;
    LARGE_INTEGER      Timeout;
    ULONG              Outcome;
    ULONG              DescriptionLength;
    WCHAR              Description[1];            // Variable size
//          Data[1];            // Variable size data not declared
} TRANSACTION_PROPERTIES_INFORMATION, *PTRANSACTION_PROPERTIES_INFORMATION;

// The following info-class is intended for DTC's use only; it will be
// deprecated, and no one else should take a dependency on it.
typedef struct _TRANSACTION_BIND_INFORMATION {
    HANDLE TmHandle;
} TRANSACTION_BIND_INFORMATION, *PTRANSACTION_BIND_INFORMATION;

typedef struct _TRANSACTION_ENLISTMENT_PAIR {
    GUID   EnlistmentId;
    GUID   ResourceManagerId;
} TRANSACTION_ENLISTMENT_PAIR, *PTRANSACTION_ENLISTMENT_PAIR;

typedef struct _TRANSACTION_ENLISTMENTS_INFORMATION {
    ULONG                       NumberOfEnlistments;
    TRANSACTION_ENLISTMENT_PAIR EnlistmentPair[1]; // Variable size
} TRANSACTION_ENLISTMENTS_INFORMATION, *PTRANSACTION_ENLISTMENTS_INFORMATION;

typedef struct _TRANSACTION_SUPERIOR_ENLISTMENT_INFORMATION {
    TRANSACTION_ENLISTMENT_PAIR SuperiorEnlistmentPair;
} TRANSACTION_SUPERIOR_ENLISTMENT_INFORMATION, *PTRANSACTION_SUPERIOR_ENLISTMENT_INFORMATION;


typedef struct _RESOURCEMANAGER_BASIC_INFORMATION {
    GUID    ResourceManagerId;
    ULONG   DescriptionLength;
    WCHAR   Description[1];            // Variable size
} RESOURCEMANAGER_BASIC_INFORMATION, *PRESOURCEMANAGER_BASIC_INFORMATION;

typedef struct _RESOURCEMANAGER_COMPLETION_INFORMATION {
    HANDLE    IoCompletionPortHandle;
    ULONG_PTR CompletionKey;
} RESOURCEMANAGER_COMPLETION_INFORMATION, *PRESOURCEMANAGER_COMPLETION_INFORMATION;

typedef enum _TRANSACTION_INFORMATION_CLASS {
    TransactionBasicInformation,
    TransactionPropertiesInformation,
    TransactionEnlistmentInformation,
    TransactionSuperiorEnlistmentInformation
} TRANSACTION_INFORMATION_CLASS;


typedef enum _TRANSACTIONMANAGER_INFORMATION_CLASS {
    TransactionManagerBasicInformation,
    TransactionManagerLogInformation,
    TransactionManagerLogPathInformation,
    TransactionManagerRecoveryInformation = 4

} TRANSACTIONMANAGER_INFORMATION_CLASS;



typedef enum _RESOURCEMANAGER_INFORMATION_CLASS {
    ResourceManagerBasicInformation,
    ResourceManagerCompletionInformation,
} RESOURCEMANAGER_INFORMATION_CLASS;


typedef struct _ENLISTMENT_BASIC_INFORMATION {
    GUID    EnlistmentId;
    GUID    TransactionId;
    GUID    ResourceManagerId;
} ENLISTMENT_BASIC_INFORMATION, *PENLISTMENT_BASIC_INFORMATION;

typedef struct _ENLISTMENT_CRM_INFORMATION {
    GUID   CrmTransactionManagerId;
    GUID   CrmResourceManagerId;
    GUID   CrmEnlistmentId;
} ENLISTMENT_CRM_INFORMATION, *PENLISTMENT_CRM_INFORMATION;



typedef enum _ENLISTMENT_INFORMATION_CLASS {
    EnlistmentBasicInformation,
    EnlistmentRecoveryInformation,
    EnlistmentCrmInformation
} ENLISTMENT_INFORMATION_CLASS;

typedef struct _TRANSACTION_LIST_ENTRY {
    UOW    UOW;
} TRANSACTION_LIST_ENTRY, *PTRANSACTION_LIST_ENTRY;

typedef struct _TRANSACTION_LIST_INFORMATION {
    ULONG   NumberOfTransactions;
    TRANSACTION_LIST_ENTRY TransactionInformation[1]; // Var size
} TRANSACTION_LIST_INFORMATION, *PTRANSACTION_LIST_INFORMATION;


//
// Types of objects known to the kernel transaction manager.
//

typedef enum _KTMOBJECT_TYPE {

    KTMOBJECT_TRANSACTION,
    KTMOBJECT_TRANSACTION_MANAGER,
    KTMOBJECT_RESOURCE_MANAGER,
    KTMOBJECT_ENLISTMENT,
    KTMOBJECT_INVALID

} KTMOBJECT_TYPE, *PKTMOBJECT_TYPE;


//
// KTMOBJECT_CURSOR
//
// Used by NtEnumerateTransactionObject to enumerate a transaction
// object namespace (e.g. enlistments in a resource manager).
//

typedef struct _KTMOBJECT_CURSOR {

    //
    // The last GUID enumerated; zero if beginning enumeration.
    // 

    GUID    LastQuery;

    //
    // A count of GUIDs filled in by this last enumeration.
    // 

    ULONG   ObjectIdCount;

    //
    // ObjectIdCount GUIDs from the namespace specified.
    // 

    GUID    ObjectIds[1];

} KTMOBJECT_CURSOR, *PKTMOBJECT_CURSOR;



//
// Nt level transaction manager API calls
//

NTSYSCALLAPI
NTSTATUS
NTAPI
NtCreateTransactionManager (
    OUT PHANDLE TmHandle,
    IN ACCESS_MASK DesiredAccess,
    IN POBJECT_ATTRIBUTES ObjectAttributes OPTIONAL,
    IN PUNICODE_STRING LogFileName OPTIONAL,
    IN ULONG CreateOptions OPTIONAL,
    IN ULONG CommitStrength OPTIONAL
    );

NTSYSCALLAPI
NTSTATUS
NTAPI
NtOpenTransactionManager (
    OUT PHANDLE TmHandle,
    IN ACCESS_MASK DesiredAccess,
    IN POBJECT_ATTRIBUTES ObjectAttributes OPTIONAL,
    IN PUNICODE_STRING LogFileName OPTIONAL,
    IN LPGUID TmIdentity OPTIONAL,
    IN ULONG OpenOptions OPTIONAL
    );

NTSYSCALLAPI
NTSTATUS
NTAPI
NtRenameTransactionManager (
    IN PUNICODE_STRING LogFileName,
    IN LPGUID ExistingTransactionManagerGuid
    );

NTSYSCALLAPI
NTSTATUS
NTAPI
NtRollforwardTransactionManager (
    IN HANDLE TransactionManagerHandle,
    __in_opt PLARGE_INTEGER TmVirtualClock
    );

NTSYSCALLAPI
NTSTATUS
NTAPI
NtRecoverTransactionManager (
    IN HANDLE TransactionManagerHandle
    );


NTSYSCALLAPI
NTSTATUS
NTAPI
NtQueryInformationTransactionManager (
    IN HANDLE TransactionManagerHandle,
    IN TRANSACTIONMANAGER_INFORMATION_CLASS TransactionManagerInformationClass,
    OUT PVOID TransactionManagerInformation,
    IN ULONG TransactionManagerInformationLength,
    OUT PULONG ReturnLength OPTIONAL
    );

NTSYSCALLAPI
NTSTATUS
NTAPI
NtSetInformationTransactionManager (
    IN HANDLE TmHandle,
    IN TRANSACTIONMANAGER_INFORMATION_CLASS TransactionManagerInformationClass,
    IN PVOID TransactionManagerInformation,
    IN ULONG TransactionManagerInformationLength
    );

NTSYSCALLAPI
NTSTATUS 
NTAPI
NtEnumerateTransactionObject (
    __in_opt HANDLE            RootObjectHandle,
    __in     KTMOBJECT_TYPE    QueryType,
    __inout_bcount(ObjectCursorLength) PKTMOBJECT_CURSOR ObjectCursor,
    __in     ULONG             ObjectCursorLength,
    __out    PULONG            ReturnLength
    );

typedef NTSTATUS (NTAPI * PFN_NT_CREATE_TRANSACTION)(
    OUT PHANDLE TransactionHandle,
    IN ACCESS_MASK DesiredAccess,
    IN POBJECT_ATTRIBUTES ObjectAttributes OPTIONAL,
    IN LPGUID Uow OPTIONAL,
    IN HANDLE TmHandle OPTIONAL,
    IN ULONG CreateOptions OPTIONAL,
    IN ULONG IsolationLevel OPTIONAL,
    IN ULONG IsolationFlags OPTIONAL,
    IN PLARGE_INTEGER Timeout OPTIONAL,
    IN PUNICODE_STRING Description OPTIONAL
    );    

NTSYSCALLAPI
NTSTATUS
NTAPI
NtCreateTransaction (
    OUT PHANDLE TransactionHandle,
    IN ACCESS_MASK DesiredAccess,
    IN POBJECT_ATTRIBUTES ObjectAttributes OPTIONAL,
    IN LPGUID Uow OPTIONAL,
    IN HANDLE TmHandle OPTIONAL,
    IN ULONG CreateOptions OPTIONAL,
    IN ULONG IsolationLevel OPTIONAL,
    IN ULONG IsolationFlags OPTIONAL,
    IN PLARGE_INTEGER Timeout OPTIONAL,
    IN PUNICODE_STRING Description OPTIONAL
    );

typedef NTSTATUS (NTAPI *PFN_NT_OPEN_TRANSACTION)(
    OUT PHANDLE TransactionHandle,
    IN ACCESS_MASK DesiredAccess,
    IN POBJECT_ATTRIBUTES ObjectAttributes,
    IN LPGUID Uow OPTIONAL,
    IN HANDLE TmHandle OPTIONAL
    );

NTSYSCALLAPI
NTSTATUS
NTAPI
NtOpenTransaction (
    OUT PHANDLE TransactionHandle,
    IN ACCESS_MASK DesiredAccess,
    IN POBJECT_ATTRIBUTES ObjectAttributes,
    IN LPGUID Uow,
    IN HANDLE TmHandle OPTIONAL
    );

typedef NTSTATUS (NTAPI * PFN_NT_QUERY_INFORMATION_TRANSACTION)(
    IN HANDLE TransactionHandle,
    IN TRANSACTION_INFORMATION_CLASS TransactionInformationClass,
    OUT PVOID TransactionInformation,
    IN ULONG TransactionInformationLength,
    OUT PULONG ReturnLength OPTIONAL
    );

NTSYSCALLAPI
NTSTATUS
NTAPI
NtQueryInformationTransaction (
    IN HANDLE TransactionHandle,
    IN TRANSACTION_INFORMATION_CLASS TransactionInformationClass,
    OUT PVOID TransactionInformation,
    IN ULONG TransactionInformationLength,
    OUT PULONG ReturnLength OPTIONAL
    );

typedef NTSTATUS (NTAPI * PFN_NT_SET_INFORMATION_TRANSACTION)(
    IN HANDLE TransactionHandle,
    IN TRANSACTION_INFORMATION_CLASS TransactionInformationClass,
    IN PVOID TransactionInformation,
    IN ULONG TransactionInformationLength
    );

NTSYSCALLAPI
NTSTATUS
NTAPI
NtSetInformationTransaction (
    IN HANDLE TransactionHandle,
    IN TRANSACTION_INFORMATION_CLASS TransactionInformationClass,
    IN PVOID TransactionInformation,
    IN ULONG TransactionInformationLength
    );

typedef NTSTATUS (NTAPI * PFN_NT_COMMIT_TRANSACTION)(
    IN HANDLE  TransactionHandle,
    IN BOOLEAN Wait
    );

NTSYSCALLAPI
NTSTATUS
NTAPI
NtCommitTransaction (
    IN HANDLE  TransactionHandle,
    IN BOOLEAN Wait
    );

typedef NTSTATUS (NTAPI * PFN_NT_ROLLBACK_TRANSACTION)(
    IN HANDLE  TransactionHandle,
    IN BOOLEAN Wait
    );

NTSYSCALLAPI
NTSTATUS
NTAPI
NtRollbackTransaction (
    IN HANDLE  TransactionHandle,
    IN BOOLEAN Wait
    );

NTSYSCALLAPI
NTSTATUS
NTAPI
NtCreateEnlistment (
    OUT PHANDLE           EnlistmentHandle,
    IN ACCESS_MASK        DesiredAccess,
    IN HANDLE             ResourceManagerHandle,
    IN HANDLE             TransactionHandle,
    IN POBJECT_ATTRIBUTES ObjectAttributes OPTIONAL,
    IN ULONG              CreateOptions OPTIONAL,
    IN NOTIFICATION_MASK  NotificationMask,
    IN PVOID              EnlistmentKey OPTIONAL
    );

NTSYSCALLAPI
NTSTATUS
NTAPI
NtOpenEnlistment (
    OUT PHANDLE           EnlistmentHandle,
    IN ACCESS_MASK        DesiredAccess,
    IN HANDLE             ResourceManagerHandle,
    IN LPGUID             EnlistmentGuid,
    IN POBJECT_ATTRIBUTES ObjectAttributes OPTIONAL
    );


NTSYSCALLAPI
NTSTATUS
NTAPI
NtQueryInformationEnlistment (
    IN HANDLE EnlistmentHandle,
    IN ENLISTMENT_INFORMATION_CLASS EnlistmentInformationClass,
    OUT PVOID EnlistmentInformation,
    IN ULONG EnlistmentInformationLength,
    OUT PULONG ReturnLength OPTIONAL
    );

NTSYSCALLAPI
NTSTATUS
NTAPI
NtSetInformationEnlistment (
    IN HANDLE EnlistmentHandle,
    IN ENLISTMENT_INFORMATION_CLASS EnlistmentInformationClass,
    IN PVOID EnlistmentInformation,
    IN ULONG EnlistmentInformationLength
    );

NTSYSCALLAPI
NTSTATUS
NTAPI
NtRecoverEnlistment (
    IN	HANDLE            EnlistmentHandle,
    IN PVOID              EnlistmentKey OPTIONAL
    );

NTSYSCALLAPI
NTSTATUS
NTAPI
NtPrePrepareEnlistment (
    IN HANDLE EnlistmentHandle,
    __in_opt PLARGE_INTEGER TmVirtualClock
    );

NTSYSCALLAPI
NTSTATUS
NTAPI
NtPrepareEnlistment (
    IN HANDLE EnlistmentHandle,
    __in_opt PLARGE_INTEGER TmVirtualClock
    );

NTSYSCALLAPI
NTSTATUS
NTAPI
NtCommitEnlistment (
    IN HANDLE EnlistmentHandle,
    __in_opt PLARGE_INTEGER TmVirtualClock
    );

NTSYSCALLAPI
NTSTATUS
NTAPI
NtRollbackEnlistment (
    IN HANDLE EnlistmentHandle,
    __in_opt PLARGE_INTEGER TmVirtualClock
    );

NTSYSCALLAPI
NTSTATUS
NTAPI 
NtPrePrepareComplete (
    IN	HANDLE            EnlistmentHandle,
    __in_opt PLARGE_INTEGER TmVirtualClock
    );

NTSYSCALLAPI
NTSTATUS
NTAPI 
NtPrepareComplete (
    IN	HANDLE            EnlistmentHandle,
    __in_opt PLARGE_INTEGER TmVirtualClock
    );

NTSYSCALLAPI
NTSTATUS
NTAPI 
NtCommitComplete (
    IN	HANDLE            EnlistmentHandle,
    __in_opt PLARGE_INTEGER TmVirtualClock
    );

NTSYSCALLAPI
NTSTATUS
NTAPI 
NtReadOnlyEnlistment (
    IN	HANDLE            EnlistmentHandle,
    __in_opt PLARGE_INTEGER TmVirtualClock
    );


NTSYSCALLAPI
NTSTATUS
NTAPI 
NtRollbackComplete (
    IN	HANDLE            EnlistmentHandle,
    __in_opt PLARGE_INTEGER TmVirtualClock
    );

NTSYSCALLAPI
NTSTATUS
NTAPI 
NtSinglePhaseReject (
    IN	HANDLE            EnlistmentHandle,
    __in_opt PLARGE_INTEGER TmVirtualClock
    );



NTSYSCALLAPI
NTSTATUS
NTAPI
NtCreateResourceManager (
    OUT PHANDLE ResourceManagerHandle,
    IN ACCESS_MASK DesiredAccess,
    IN HANDLE TmHandle,
    IN LPGUID RmGuid,
    IN POBJECT_ATTRIBUTES ObjectAttributes OPTIONAL,
    IN ULONG CreateOptions OPTIONAL,
    IN PUNICODE_STRING Description OPTIONAL
    );

NTSYSCALLAPI
NTSTATUS
NTAPI
NtOpenResourceManager (
    OUT PHANDLE ResourceManagerHandle,
    IN ACCESS_MASK DesiredAccess,
    IN HANDLE TmHandle,
    IN LPGUID ResourceManagerGuid OPTIONAL,
    IN POBJECT_ATTRIBUTES ObjectAttributes OPTIONAL
    );

NTSYSCALLAPI
NTSTATUS
NTAPI
NtRecoverResourceManager (
    IN HANDLE ResourceManagerHandle
    );


NTSYSCALLAPI
NTSTATUS
NTAPI
NtGetNotificationResourceManager (
    __in HANDLE				ResourceManagerHandle,
    __out PTRANSACTION_NOTIFICATION	TransactionNotification,
    __in ULONG				NotificationLength,
    __in PLARGE_INTEGER			Timeout OPTIONAL,
    __out_opt PULONG	                ReturnLength,
    __in ULONG                          Asynchronous,
    __in_opt ULONG_PTR                  AsynchronousContext
    );


NTSYSCALLAPI
NTSTATUS
NTAPI
NtQueryInformationResourceManager (
    IN HANDLE ResourceManagerHandle,
    IN RESOURCEMANAGER_INFORMATION_CLASS ResourceManagerInformationClass,
    OUT PVOID ResourceManagerInformation,
    IN ULONG ResourceManagerInformationLength,
    OUT PULONG ReturnLength OPTIONAL
    );

NTSYSCALLAPI
NTSTATUS
NTAPI
NtSetInformationResourceManager (
    IN HANDLE ResourceManagerHandle,
    IN RESOURCEMANAGER_INFORMATION_CLASS ResourceManagerInformationClass,
    IN PVOID ResourceManagerInformation,
    IN ULONG ResourceManagerInformationLength
    );

NTSYSCALLAPI
NTSTATUS
NTAPI
NtRegisterProtocolAddressInformation(
    IN HANDLE           ResourceManager,
    IN PCRM_PROTOCOL_ID ProtocolId,
    IN ULONG            ProtocolInformationSize,
    IN PVOID            ProtocolInformation,
    IN ULONG            CreateOptions OPTIONAL
    );

NTSYSCALLAPI
NTSTATUS
NTAPI
NtPropagationComplete(
    IN  HANDLE            ResourceManagerHandle,
    IN  ULONG             RequestCookie,
    IN  ULONG             BufferLength,
    IN  PVOID             Buffer
    );

NTSYSCALLAPI
NTSTATUS
NTAPI
NtPropagationFailed(
    IN  HANDLE            ResourceManagerHandle,
    IN  ULONG             RequestCookie,
    IN  NTSTATUS          PropStatus
    );


#ifdef __cplusplus
}
#endif

#endif // _NTTMAPI_


//
// Define alignment macros to align structure sizes and pointers up and down.
//

#define ALIGN_DOWN(length, type) \
    ((ULONG)(length) & ~(sizeof(type) - 1))

#define ALIGN_UP(length, type) \
    (ALIGN_DOWN(((ULONG)(length) + sizeof(type) - 1), type))

#define ALIGN_DOWN_POINTER(address, type) \
    ((PVOID)((ULONG_PTR)(address) & ~((ULONG_PTR)sizeof(type) - 1)))

#define ALIGN_UP_POINTER(address, type) \
    (ALIGN_DOWN_POINTER(((ULONG_PTR)(address) + sizeof(type) - 1), type))

#define POOL_TAGGING 1

#if DBG

#define IF_DEBUG if (TRUE)

#else

#define IF_DEBUG if (FALSE)

#endif

#if DEVL


extern ULONG NtGlobalFlag;

#define IF_NTOS_DEBUG(FlagName) \
    if (NtGlobalFlag & (FLG_ ## FlagName))

#else

#define IF_NTOS_DEBUG(FlagName) if(FALSE)

#endif



//
// Define General Lookaside and supporting types here
//

typedef enum _POOL_TYPE POOL_TYPE;

typedef
PVOID
(*PALLOCATE_FUNCTION) (
    __in POOL_TYPE PoolType,
    __in SIZE_T NumberOfBytes,
    __in ULONG Tag
    );

typedef
VOID
(*PFREE_FUNCTION) (
    __in PVOID Buffer
    );

typedef struct _LOOKASIDE_LIST_EX *PLOOKASIDE_LIST_EX;

typedef
PVOID
(*PALLOCATE_FUNCTION_EX) (
    __in POOL_TYPE PoolType,
    __in SIZE_T NumberOfBytes,
    __in ULONG Tag,
    __inout PLOOKASIDE_LIST_EX Lookaside
    );

typedef
VOID
(*PFREE_FUNCTION_EX) (
    __in PVOID Buffer,
    __inout PLOOKASIDE_LIST_EX Lookaside
    );

#if !defined(_WIN64) && (defined(_NTDDK_) || defined(_NTIFS_) || defined(_NDIS_))

#define LOOKASIDE_ALIGN

#else

#define LOOKASIDE_ALIGN DECLSPEC_CACHEALIGN

#endif


//
// The goal here is to end up with two structure types that are identical except
// for the fact that one (GENERAL_LOOKASIDE) is cache aligned, and the other
// (GENERAL_LOOKASIDE_POOL) is merely naturally aligned.
//
// An anonymous structure element would do the trick except that C++ can't handle
// such complex syntax, so we're stuck with this macro technique.
//

#define GENERAL_LOOKASIDE_LAYOUT                \
    union {                                     \
        SLIST_HEADER ListHead;                  \
        SINGLE_LIST_ENTRY SingleListHead;       \
    } DUMMYUNIONNAME;                           \
    USHORT Depth;                               \
    USHORT MaximumDepth;                        \
    ULONG TotalAllocates;                       \
    union {                                     \
        ULONG AllocateMisses;                   \
        ULONG AllocateHits;                     \
    } DUMMYUNIONNAME2;                          \
                                                \
    ULONG TotalFrees;                           \
    union {                                     \
        ULONG FreeMisses;                       \
        ULONG FreeHits;                         \
    } DUMMYUNIONNAME3;                          \
                                                \
    POOL_TYPE Type;                             \
    ULONG Tag;                                  \
    ULONG Size;                                 \
    union {                                     \
        PALLOCATE_FUNCTION_EX AllocateEx;       \
        PALLOCATE_FUNCTION Allocate;            \
    } DUMMYUNIONNAME4;                          \
                                                \
    union {                                     \
        PFREE_FUNCTION_EX FreeEx;               \
        PFREE_FUNCTION Free;                    \
    } DUMMYUNIONNAME5;                          \
                                                \
    LIST_ENTRY ListEntry;                       \
    ULONG LastTotalAllocates;                   \
    union {                                     \
        ULONG LastAllocateMisses;               \
        ULONG LastAllocateHits;                 \
    } DUMMYUNIONNAME6;                          \
    ULONG Future[2];

//
// GENERAL_LOOKASIDE is a cache aligned type, typically shared between
// multiple processors
//

#if _MSC_VER >= 1200
#pragma warning(push)
#pragma warning(disable:4324) // structure was padded due to __declspec(align())
#endif

typedef struct LOOKASIDE_ALIGN _GENERAL_LOOKASIDE {
    GENERAL_LOOKASIDE_LAYOUT
} GENERAL_LOOKASIDE, *PGENERAL_LOOKASIDE;

#if _MSC_VER >= 1200
#pragma warning(pop)
#endif



//
// GENERAL_LOOKASIDE_POOL is the same layout as GENERAL_LOOKASIDE but is
// not cacheblock aligned, for use in cases where access is limited to a
// single processor
//

typedef struct _GENERAL_LOOKASIDE_POOL {
    GENERAL_LOOKASIDE_LAYOUT
} GENERAL_LOOKASIDE_POOL, *PGENERAL_LOOKASIDE_POOL;

//
// The above two structures should have identical layouts.  A few spot-checks
// just to make sure.
//

#define LOOKASIDE_CHECK(f)  \
    C_ASSERT(FIELD_OFFSET(GENERAL_LOOKASIDE,f)==FIELD_OFFSET(GENERAL_LOOKASIDE_POOL,f))

LOOKASIDE_CHECK(TotalFrees);
LOOKASIDE_CHECK(Tag);
LOOKASIDE_CHECK(Future);

//
// Kernel definitions that need to be here for forward reference purposes
//


//
// Processor modes.
//

typedef CCHAR KPROCESSOR_MODE;

typedef enum _MODE {
    KernelMode,
    UserMode,
    MaximumMode
} MODE;


//
// APC function types
//

//
// Put in an empty definition for the KAPC so that the
// routines can reference it before it is declared.
//

struct _KAPC;

typedef
VOID
(*PKNORMAL_ROUTINE) (
    IN PVOID NormalContext,
    IN PVOID SystemArgument1,
    IN PVOID SystemArgument2
    );

typedef
VOID
(*PKKERNEL_ROUTINE) (
    IN struct _KAPC *Apc,
    IN OUT PKNORMAL_ROUTINE *NormalRoutine,
    IN OUT PVOID *NormalContext,
    IN OUT PVOID *SystemArgument1,
    IN OUT PVOID *SystemArgument2
    );

typedef
VOID
(*PKRUNDOWN_ROUTINE) (
    IN struct _KAPC *Apc
    );

typedef
BOOLEAN
(*PKSYNCHRONIZE_ROUTINE) (
    IN PVOID SynchronizeContext
    );

typedef
BOOLEAN
(*PKTRANSFER_ROUTINE) (
    VOID
    );

//
//
// Asynchronous Procedure Call (APC) object
//
// N.B. The size of this structure cannot change since it has been exported.
//

#define ASSERT_APC(E) NT_ASSERT((E)->Type == ApcObject)

typedef struct _KAPC {
    UCHAR Type;
    UCHAR SpareByte0;
    UCHAR Size;
    UCHAR SpareByte1;
    ULONG SpareLong0;
    struct _KTHREAD *Thread;
    LIST_ENTRY ApcListEntry;
    PKKERNEL_ROUTINE KernelRoutine;
    PKRUNDOWN_ROUTINE RundownRoutine;
    PKNORMAL_ROUTINE NormalRoutine;
    PVOID NormalContext;

    //
    // N.B. The following two members MUST be together.
    //

    PVOID SystemArgument1;
    PVOID SystemArgument2;
    CCHAR ApcStateIndex;
    KPROCESSOR_MODE ApcMode;
    BOOLEAN Inserted;
} KAPC, *PKAPC, *PRKAPC;

#define KAPC_OFFSET_TO_SPARE_BYTE0 FIELD_OFFSET(KAPC, SpareByte0)
#define KAPC_OFFSET_TO_SPARE_BYTE1 FIELD_OFFSET(KAPC, SpareByte1)
#define KAPC_OFFSET_TO_SPARE_LONG FIELD_OFFSET(KAPC, SpareLong0)
#define KAPC_OFFSET_TO_SYSTEMARGUMENT1 FIELD_OFFSET(KAPC, SystemArgument1)
#define KAPC_OFFSET_TO_SYSTEMARGUMENT2 FIELD_OFFSET(KAPC, SystemArgument2)
#define KAPC_OFFSET_TO_APCSTATEINDEX FIELD_OFFSET(KAPC, ApcStateIndex)
#define KAPC_ACTUAL_LENGTH (FIELD_OFFSET(KAPC, Inserted) + sizeof(BOOLEAN))


//
// DPC routine
//

struct _KDPC;

typedef
VOID
(*PKDEFERRED_ROUTINE) (
    IN struct _KDPC *Dpc,
    IN PVOID DeferredContext,
    IN PVOID SystemArgument1,
    IN PVOID SystemArgument2
    );

//
// Define DPC importance.
//
// LowImportance - Queue DPC at end of target DPC queue.
// MediumImportance - Queue DPC at end of target DPC queue.
// MediumHighImportance - Queue DPC at end of target DPC queue.
// HighImportance - Queue DPC at front of target DPC DPC queue.
//
// If there is currently a DPC active on the target processor, or a DPC
// interrupt has already been requested on the target processor when a
// DPC is queued, then no further action is necessary. The DPC will be
// executed on the target processor when its queue entry is processed.
//
// If there is not a DPC active on the target processor and a DPC interrupt
// has not been requested on the target processor, then the exact treatment
// of the DPC is dependent on whether the host system is a UP system or an
// MP system.
//
// UP system.
//
// If the DPC is not of low importance, the current DPC queue depth
// is greater than the maximum target depth, or current DPC request rate is
// less the minimum target rate, then a DPC interrupt is requested on the
// host processor and the DPC will be processed when the interrupt occurs.
// Otherwise, no DPC interupt is requested and the DPC execution will be
// delayed until the DPC queue depth is greater that the target depth or the
// minimum DPC rate is less than the target rate.
//
// MP system.
//
// If the DPC is being queued to another processor and the depth of the DPC
// queue on the target processor is greater than the maximum target depth or
// the DPC is of medium high or high importance, then a DPC interrupt is
// requested on the target processor and the DPC will be processed when the
// Interrupt occurs.  Otherwise, the DPC execution will be delayed on the target
// processor until the DPC queue depth on the target processor is greater that
// the maximum target depth or the minimum DPC rate on the target processor is
// less than the target mimimum rate.
//
// If the DPC is being queued to the current processor and the DPC is not of
// low importance, the current DPC queue depth is greater than the maximum
// target depth, or the minimum DPC rate is less than the minimum target rate,
// then a DPC interrupt is request on the current processor and the DPV will
// be processed when the interrupt occurs. Otherwise, no DPC interupt is
// requested and the DPC execution will be delayed until the DPC queue depth
// is greater that the target depth or the minimum DPC rate is less than the
// target rate.
//

typedef enum _KDPC_IMPORTANCE {
    LowImportance,
    MediumImportance,
    HighImportance,
    MediumHighImportance
} KDPC_IMPORTANCE;

//
// Define DPC type indicies.
//

#define DPC_NORMAL 0
#define DPC_THREADED 1

//
// Deferred Procedure Call (DPC) object
//

#define ASSERT_DPC(Object)                                                   \
    ASSERT(((Object)->Type == 0) ||                                          \
           ((Object)->Type == DpcObject) ||                                  \
           ((Object)->Type == ThreadedDpcObject))

typedef struct _KDPC {
    UCHAR Type;
    UCHAR Importance;
    volatile USHORT Number;
    LIST_ENTRY DpcListEntry;
    PKDEFERRED_ROUTINE DeferredRoutine;
    PVOID DeferredContext;
    PVOID SystemArgument1;
    PVOID SystemArgument2;
    __volatile PVOID DpcData;
} KDPC, *PKDPC, *PRKDPC;

//
// Interprocessor interrupt worker routine function prototype.
//

typedef PVOID PKIPI_CONTEXT;

typedef
VOID
(*PKIPI_WORKER)(
    IN PKIPI_CONTEXT PacketContext,
    IN PVOID Parameter1,
    IN PVOID Parameter2,
    IN PVOID Parameter3
    );

//
// Define interprocessor interrupt performance counters.
//

typedef struct _KIPI_COUNTS {
    ULONG Freeze;
    ULONG Packet;
    ULONG DPC;
    ULONG APC;
    ULONG FlushSingleTb;
    ULONG FlushMultipleTb;
    ULONG FlushEntireTb;
    ULONG GenericCall;
    ULONG ChangeColor;
    ULONG SweepDcache;
    ULONG SweepIcache;
    ULONG SweepIcacheRange;
    ULONG FlushIoBuffers;
    ULONG GratuitousDPC;
} KIPI_COUNTS, *PKIPI_COUNTS;


//
// I/O system definitions.
//
// Define a Memory Descriptor List (MDL)
//
// An MDL describes pages in a virtual buffer in terms of physical pages.  The
// pages associated with the buffer are described in an array that is allocated
// just after the MDL header structure itself.
//
// One simply calculates the base of the array by adding one to the base
// MDL pointer:
//
//      Pages = (PPFN_NUMBER) (Mdl + 1);
//
// Notice that while in the context of the subject thread, the base virtual
// address of a buffer mapped by an MDL may be referenced using the following:
//
//      Mdl->StartVa | Mdl->ByteOffset
//

typedef __struct_bcount(Size) struct _MDL {
    struct _MDL *Next;
    CSHORT Size;
    CSHORT MdlFlags;
    struct _EPROCESS *Process;
    PVOID MappedSystemVa;
    PVOID StartVa;
    ULONG ByteCount;
    ULONG ByteOffset;
} MDL, *PMDL;

typedef __inexpressible_readableTo(polymorphism) MDL *PMDLX;

#define MDL_MAPPED_TO_SYSTEM_VA     0x0001
#define MDL_PAGES_LOCKED            0x0002
#define MDL_SOURCE_IS_NONPAGED_POOL 0x0004
#define MDL_ALLOCATED_FIXED_SIZE    0x0008
#define MDL_PARTIAL                 0x0010
#define MDL_PARTIAL_HAS_BEEN_MAPPED 0x0020
#define MDL_IO_PAGE_READ            0x0040
#define MDL_WRITE_OPERATION         0x0080
#define MDL_PARENT_MAPPED_SYSTEM_VA 0x0100
#define MDL_FREE_EXTRA_PTES         0x0200
#define MDL_DESCRIBES_AWE           0x0400
#define MDL_IO_SPACE                0x0800
#define MDL_NETWORK_HEADER          0x1000
#define MDL_MAPPING_CAN_FAIL        0x2000
#define MDL_ALLOCATED_MUST_SUCCEED  0x4000
#define MDL_INTERNAL                0x8000

#define MDL_MAPPING_FLAGS (MDL_MAPPED_TO_SYSTEM_VA     | \
                           MDL_PAGES_LOCKED            | \
                           MDL_SOURCE_IS_NONPAGED_POOL | \
                           MDL_PARTIAL_HAS_BEEN_MAPPED | \
                           MDL_PARENT_MAPPED_SYSTEM_VA | \
                           MDL_SYSTEM_VA               | \
                           MDL_IO_SPACE )


//
// switch to PREFast or DBG when appropriate
//

#if defined(_PREFAST_)

void __PREfastPagedCode(void);
void __PREfastPagedCodeLocked(void);
#define PAGED_CODE()        __PREfastPagedCode();
#define PAGED_CODE_LOCKED() __PREfastPagedCodeLocked();

#elif DBG

#define PAGED_CODE() {                                                       \
    if (KeGetCurrentIrql() > APC_LEVEL) {                                    \
        KdPrint(("EX: Pageable code called at IRQL %d\n", KeGetCurrentIrql())); \
        NT_ASSERT(FALSE);                                                    \
    }                                                                        \
}

#define PAGED_CODE_LOCKED() NOP_FUNCTION;

#else

#define PAGED_CODE()        NOP_FUNCTION;
#define PAGED_CODE_LOCKED() NOP_FUNCTION;

#endif

#define NTKERNELAPI DECLSPEC_IMPORT     

#if defined(_X86_) && !defined(_NTHAL_)

#define _DECL_HAL_KE_IMPORT  DECLSPEC_IMPORT

#elif defined(_X86_)

#define _DECL_HAL_KE_IMPORT

#else

#define _DECL_HAL_KE_IMPORT NTKERNELAPI

#endif


#if !defined(_NTHALDLL_) && !defined(_BLDR_)

#define NTHALAPI DECLSPEC_IMPORT            

#else

#define NTHALAPI

#endif

//
// Common dispatcher object header
//
// N.B. The size field contains the number of dwords in the structure.
//

typedef struct _DISPATCHER_HEADER {
    union {
        struct {
            UCHAR Type;
            union {
                UCHAR Abandoned;
                UCHAR Absolute;
                UCHAR NpxIrql;
                BOOLEAN Signalling;
            } DUMMYUNIONNAME;

            union {
                UCHAR Size;
                UCHAR Hand;
            } DUMMYUNIONNAME2;

            union {
                UCHAR Inserted;
                BOOLEAN DebugActive;
                BOOLEAN DpcActive;
            } DUMMYUNIONNAME3;
        } DUMMYSTRUCTNAME;

        volatile LONG Lock;
    } DUMMYUNIONNAME;

    LONG SignalState;
    LIST_ENTRY WaitListHead;
} DISPATCHER_HEADER;




//
// Event object
//

#define ASSERT_EVENT(E)                                                      \
    NT_ASSERT(((E)->Header.Type == NotificationEvent) ||                     \
              ((E)->Header.Type == SynchronizationEvent))

typedef struct _KEVENT {
    DISPATCHER_HEADER Header;
} KEVENT, *PKEVENT, *PRKEVENT;

//
// Gate object
//
// N.B. Gate object services allow the specification of synchronization
//      events. This allows fast mutex to be transparently replaced with
//      gates.
//

#define ASSERT_GATE(object)                                                  \
    NT_ASSERT((((object)->Header.Type & KOBJECT_TYPE_MASK) == GateObject) || \
             (((object)->Header.Type & KOBJECT_TYPE_MASK) == EventSynchronizationObject))

typedef struct _KGATE {
    DISPATCHER_HEADER Header;
} KGATE, *PKGATE;

//
// Define timer table size.
//

#define TIMER_TABLE_SIZE 512
#define TIMER_TABLE_SHIFT 9

C_ASSERT((1 << TIMER_TABLE_SHIFT) == TIMER_TABLE_SIZE);
C_ASSERT((TIMER_TABLE_SIZE & (TIMER_TABLE_SIZE - 1)) == 0);

//
// Timer object
//
// N.B. The period field must be the last member of this structure.
//

#define ASSERT_TIMER(E)                                                      \
    NT_ASSERT(((E)->Header.Type == TimerNotificationObject) ||               \
              ((E)->Header.Type == TimerSynchronizationObject))

typedef struct _KTIMER {
    DISPATCHER_HEADER Header;
    ULARGE_INTEGER DueTime;
    LIST_ENTRY TimerListEntry;
    struct _KDPC *Dpc;
    LONG Period;
} KTIMER, *PKTIMER, *PRKTIMER;

#define KTIMER_ACTUAL_LENGTH                                                \
    (FIELD_OFFSET(KTIMER, Period) + sizeof(LONG))

typedef enum _LOCK_OPERATION {
    IoReadAccess,
    IoWriteAccess,
    IoModifyAccess
} LOCK_OPERATION;


#if defined(_X86_)


//
// Types to use to contain PFNs and their counts.
//

typedef ULONG PFN_COUNT;

typedef LONG SPFN_NUMBER, *PSPFN_NUMBER;
typedef ULONG PFN_NUMBER, *PPFN_NUMBER;

//
// Define maximum size of flush multiple TB request.
//

#define FLUSH_MULTIPLE_MAXIMUM 32

//
// Indicate that the i386 compiler supports the pragma textout construct.
//

#define ALLOC_PRAGMA 1
//
// Indicate that the i386 compiler supports the DATA_SEG("INIT") and
// DATA_SEG("PAGE") pragmas
//

#define ALLOC_DATA_PRAGMA 1

//
// Interrupt Request Level definitions
//

#define PASSIVE_LEVEL 0             // Passive release level
#define LOW_LEVEL 0                 // Lowest interrupt level
#define APC_LEVEL 1                 // APC interrupt level
#define DISPATCH_LEVEL 2            // Dispatcher level
#define CMCI_LEVEL 5                // CMCI handler level

#define PROFILE_LEVEL 27            // timer used for profiling.
#define CLOCK1_LEVEL 28             // Interval clock 1 level - Not used on x86
#define CLOCK2_LEVEL 28             // Interval clock 2 level
#define IPI_LEVEL 29                // Interprocessor interrupt level
#define POWER_LEVEL 30              // Power failure level
#define HIGH_LEVEL 31               // Highest interrupt level

#if (NTDDI_VERSION >= NTDDI_WIN2K)
_DECL_HAL_KE_IMPORT
VOID
FASTCALL
KfLowerIrql (
    __in KIRQL NewIrql
    );
#endif

#if (NTDDI_VERSION >= NTDDI_WIN2K)
_DECL_HAL_KE_IMPORT
KIRQL
FASTCALL
KfRaiseIrql (
    __in KIRQL NewIrql
    );
#endif

#define KeLowerIrql(a) KfLowerIrql(a)
#define KeRaiseIrql(a,b) *(b) = KfRaiseIrql(a)


#if (NTDDI_VERSION >= NTDDI_WIN2K)
_DECL_HAL_KE_IMPORT
KIRQL
KeRaiseIrqlToDpcLevel (
    VOID
    );
#endif


//
// I/O space read and write macros.
//
//  These have to be actual functions on the 386, because we need
//  to use assembler, but cannot return a value if we inline it.
//
//  The READ/WRITE_REGISTER_* calls manipulate I/O registers in MEMORY space.
//  (Use x86 move instructions, with LOCK prefix to force correct behavior
//   w.r.t. caches and write buffers.)
//
//  The READ/WRITE_PORT_* calls manipulate I/O registers in PORT space.
//  (Use x86 in/out instructions.)
//

NTKERNELAPI
UCHAR
NTAPI
READ_REGISTER_UCHAR(
    PUCHAR  Register
    );

NTKERNELAPI
USHORT
NTAPI
READ_REGISTER_USHORT(
    PUSHORT Register
    );

NTKERNELAPI
ULONG
NTAPI
READ_REGISTER_ULONG(
    PULONG  Register
    );

NTKERNELAPI
VOID
NTAPI
READ_REGISTER_BUFFER_UCHAR(
    PUCHAR  Register,
    PUCHAR  Buffer,
    ULONG   Count
    );

NTKERNELAPI
VOID
NTAPI
READ_REGISTER_BUFFER_USHORT(
    PUSHORT Register,
    PUSHORT Buffer,
    ULONG   Count
    );

NTKERNELAPI
VOID
NTAPI
READ_REGISTER_BUFFER_ULONG(
    PULONG  Register,
    PULONG  Buffer,
    ULONG   Count
    );


NTKERNELAPI
VOID
NTAPI
WRITE_REGISTER_UCHAR(
    PUCHAR  Register,
    UCHAR   Value
    );

NTKERNELAPI
VOID
NTAPI
WRITE_REGISTER_USHORT(
    PUSHORT Register,
    USHORT  Value
    );

NTKERNELAPI
VOID
NTAPI
WRITE_REGISTER_ULONG(
    PULONG  Register,
    ULONG   Value
    );

NTKERNELAPI
VOID
NTAPI
WRITE_REGISTER_BUFFER_UCHAR(
    PUCHAR  Register,
    PUCHAR  Buffer,
    ULONG   Count
    );

NTKERNELAPI
VOID
NTAPI
WRITE_REGISTER_BUFFER_USHORT(
    PUSHORT Register,
    PUSHORT Buffer,
    ULONG   Count
    );

NTKERNELAPI
VOID
NTAPI
WRITE_REGISTER_BUFFER_ULONG(
    PULONG  Register,
    PULONG  Buffer,
    ULONG   Count
    );

NTHALAPI
UCHAR
NTAPI
READ_PORT_UCHAR(
    PUCHAR  Port
    );

NTHALAPI
USHORT
NTAPI
READ_PORT_USHORT(
    PUSHORT Port
    );

NTHALAPI
ULONG
NTAPI
READ_PORT_ULONG(
    PULONG  Port
    );

NTHALAPI
VOID
NTAPI
READ_PORT_BUFFER_UCHAR(
    PUCHAR  Port,
    PUCHAR  Buffer,
    ULONG   Count
    );

NTHALAPI
VOID
NTAPI
READ_PORT_BUFFER_USHORT(
    PUSHORT Port,
    PUSHORT Buffer,
    ULONG   Count
    );

NTHALAPI
VOID
NTAPI
READ_PORT_BUFFER_ULONG(
    PULONG  Port,
    PULONG  Buffer,
    ULONG   Count
    );

NTHALAPI
VOID
NTAPI
WRITE_PORT_UCHAR(
    PUCHAR  Port,
    UCHAR   Value
    );

NTHALAPI
VOID
NTAPI
WRITE_PORT_USHORT(
    PUSHORT Port,
    USHORT  Value
    );

NTHALAPI
VOID
NTAPI
WRITE_PORT_ULONG(
    PULONG  Port,
    ULONG   Value
    );

NTHALAPI
VOID
NTAPI
WRITE_PORT_BUFFER_UCHAR(
    PUCHAR  Port,
    PUCHAR  Buffer,
    ULONG   Count
    );

NTHALAPI
VOID
NTAPI
WRITE_PORT_BUFFER_USHORT(
    PUSHORT Port,
    PUSHORT Buffer,
    ULONG   Count
    );

NTHALAPI
VOID
NTAPI
WRITE_PORT_BUFFER_ULONG(
    PULONG  Port,
    PULONG  Buffer,
    ULONG   Count
    );


//
// Get data cache fill size.
//

#if PRAGMA_DEPRECATED_DDK
#pragma deprecated(KeGetDcacheFillSize)      // Use GetDmaAlignment
#endif

#define KeGetDcacheFillSize() 1L


#define KeFlushIoBuffers(Mdl, ReadOperation, DmaOperation)


#define ExAcquireSpinLock(Lock, OldIrql) KeAcquireSpinLock((Lock), (OldIrql))
#define ExReleaseSpinLock(Lock, OldIrql) KeReleaseSpinLock((Lock), (OldIrql))
#define ExAcquireSpinLockAtDpcLevel(Lock) KeAcquireSpinLockAtDpcLevel(Lock)
#define ExReleaseSpinLockFromDpcLevel(Lock) KeReleaseSpinLockFromDpcLevel(Lock)


#define KeQueryTickCount(CurrentCount) { \
    KSYSTEM_TIME volatile *_TickCount = *((PKSYSTEM_TIME *)(&KeTickCount)); \
    for (;;) {                                                              \
        (CurrentCount)->HighPart = _TickCount->High1Time;                   \
        (CurrentCount)->LowPart = _TickCount->LowPart;                      \
        if ((CurrentCount)->HighPart == _TickCount->High2Time) break;       \
        YieldProcessor();                                                   \
    }                                                                       \
}

//
// The non-volatile 387 state
//

typedef struct _KFLOATING_SAVE {
    ULONG   ControlWord;
    ULONG   StatusWord;
    ULONG   ErrorOffset;
    ULONG   ErrorSelector;
    ULONG   DataOffset;                 // Not used in wdm
    ULONG   DataSelector;
    ULONG   Cr0NpxState;
    ULONG   Spare1;                     // Not used in wdm
} KFLOATING_SAVE, *PKFLOATING_SAVE;

//
// Structure of AMD cache information returned by CPUID instruction
//

typedef union _AMD_L1_CACHE_INFO {
    ULONG Ulong;
    struct {
        UCHAR LineSize;
        UCHAR LinesPerTag;
        UCHAR Associativity;
        UCHAR Size;
    };
} AMD_L1_CACHE_INFO, *PAMD_L1_CACHE_INFO;

typedef union _AMD_L2_CACHE_INFO {
    ULONG Ulong;
    struct {
        UCHAR  LineSize;
        UCHAR  LinesPerTag   : 4;
        UCHAR  Associativity : 4;
        USHORT Size;
    };
} AMD_L2_CACHE_INFO, *PAMD_L2_CACHE_INFO;

//
// Structure of Intel deterministic cache information returned by
// CPUID instruction
//

typedef enum _INTEL_CACHE_TYPE {
    IntelCacheNull,
    IntelCacheData,
    IntelCacheInstruction,
    IntelCacheUnified,
    IntelCacheRam,
    IntelCacheTrace
} INTEL_CACHE_TYPE;

typedef union INTEL_CACHE_INFO_EAX {
    ULONG Ulong;
    struct {
        INTEL_CACHE_TYPE Type : 5;
        ULONG Level : 3;
        ULONG SelfInitializing : 1;
        ULONG FullyAssociative : 1;
        ULONG Reserved : 4;
        ULONG ThreadsSharing : 12;
        ULONG ProcessorCores : 6;
    };
} INTEL_CACHE_INFO_EAX, *PINTEL_CACHE_INFO_EAX;

typedef union INTEL_CACHE_INFO_EBX {
    ULONG Ulong;
    struct {
        ULONG LineSize      : 12;
        ULONG Partitions    : 10;
        ULONG Associativity : 10;
    };
} INTEL_CACHE_INFO_EBX, *PINTEL_CACHE_INFO_EBX;

//
// i386 Specific portions of mm component
//

//
// Define the page size for the Intel 386 as 4096 (0x1000).
//

#define PAGE_SIZE 0x1000

//
// Define the number of trailing zeroes in a page aligned virtual address.
// This is used as the shift count when shifting virtual addresses to
// virtual page numbers.
//

#define PAGE_SHIFT 12L


#define MmGetProcedureAddress(Address) (Address)
#define MmLockPagableCodeSection(Address) MmLockPagableDataSection(Address)

#define KIP0PCRADDRESS              0xffdff000  

#define KI_USER_SHARED_DATA         0xffdf0000
#define SharedUserData  ((KUSER_SHARED_DATA * const) KI_USER_SHARED_DATA)

//
// Result type definition for i386.  (Machine specific enumerate type
// which is return type for portable exinterlockedincrement/decrement
// procedures.)  In general, you should use the enumerated type defined
// in ex.h instead of directly referencing these constants.
//

// Flags loaded into AH by LAHF instruction

#define EFLAG_SIGN      0x8000
#define EFLAG_ZERO      0x4000
#define EFLAG_SELECT    (EFLAG_SIGN | EFLAG_ZERO)

#define RESULT_NEGATIVE ((EFLAG_SIGN & ~EFLAG_ZERO) & EFLAG_SELECT)
#define RESULT_ZERO     ((~EFLAG_SIGN & EFLAG_ZERO) & EFLAG_SELECT)
#define RESULT_POSITIVE ((~EFLAG_SIGN & ~EFLAG_ZERO) & EFLAG_SELECT)

//
// Convert various portable ExInterlock APIs into their architectural
// equivalents.
//

#if PRAGMA_DEPRECATED_DDK
#pragma deprecated(ExInterlockedIncrementLong)      // Use InterlockedIncrement
#pragma deprecated(ExInterlockedDecrementLong)      // Use InterlockedDecrement
#pragma deprecated(ExInterlockedExchangeUlong)      // Use InterlockedExchange
#endif

#define ExInterlockedIncrementLong(Addend,Lock) \
        Exfi386InterlockedIncrementLong(Addend)

#define ExInterlockedDecrementLong(Addend,Lock) \
        Exfi386InterlockedDecrementLong(Addend)

#define ExInterlockedExchangeUlong(Target,Value,Lock) \
        Exfi386InterlockedExchangeUlong(Target,Value)

#define ExInterlockedAddUlong           ExfInterlockedAddUlong
#define ExInterlockedInsertHeadList     ExfInterlockedInsertHeadList
#define ExInterlockedInsertTailList     ExfInterlockedInsertTailList
#define ExInterlockedRemoveHeadList     ExfInterlockedRemoveHeadList
#define ExInterlockedPopEntryList       ExfInterlockedPopEntryList
#define ExInterlockedPushEntryList      ExfInterlockedPushEntryList

#if !defined(MIDL_PASS)
#if defined(NO_INTERLOCKED_INTRINSICS) || defined(_CROSS_PLATFORM_)

NTKERNELAPI
LONG
FASTCALL
InterlockedIncrement(
    IN LONG volatile *Addend
    );

NTKERNELAPI
LONG
FASTCALL
InterlockedDecrement(
    IN LONG volatile *Addend
    );

NTKERNELAPI
LONG
FASTCALL
InterlockedExchange(
    IN OUT LONG volatile *Target,
    IN LONG Value
    );

LONG
FASTCALL
InterlockedExchangeAdd(
    IN OUT LONG volatile *Addend,
    IN LONG Increment
    );

NTKERNELAPI
LONG
FASTCALL
InterlockedCompareExchange (
    IN OUT LONG volatile *Destination,
    IN LONG ExChange,
    IN LONG Comperand
    );

#define InterlockedCompareExchangePointer(Destination, ExChange, Comperand) \
    (PVOID)InterlockedCompareExchange((PLONG)Destination, (LONG)ExChange, (LONG)Comperand)

NTKERNELAPI
LONGLONG
FASTCALL
ExfInterlockedCompareExchange64 (
    IN OUT LONGLONG volatile *Destination,
    IN PLONGLONG ExChange,
    IN PLONGLONG Comperand
    );

FORCEINLINE
LONGLONG
InterlockedCompareExchange64_inline (
    IN OUT LONGLONG volatile *Destination,
    IN LONGLONG ExChange,
    IN LONGLONG Comperand
    )
{
    return ExfInterlockedCompareExchange64(Destination, &ExChange, &Comperand);
}

#define InterlockedCompareExchange64 InterlockedCompareExchange64_inline

#else       // NO_INTERLOCKED_INTRINSICS || _CROSS_PLATFORM_

#if (_MSC_FULL_VER > 13009037)
LONG
__cdecl
_InterlockedExchange(
    IN OUT LONG volatile *Target,
    IN LONG Value
    );

#pragma intrinsic(_InterlockedExchange)
#define InterlockedExchange _InterlockedExchange
#else
FORCEINLINE
LONG
FASTCALL
InterlockedExchange(
    IN OUT LONG volatile *Target,
    IN LONG Value
    )
{
    __asm {
        mov     eax, Value
        mov     ecx, Target
        xchg    [ecx], eax
    }
}
#endif

#if (_MSC_FULL_VER > 13009037)
LONG
__cdecl
_InterlockedIncrement(
    IN LONG volatile *Addend
    );

#pragma intrinsic(_InterlockedIncrement)
#define InterlockedIncrement _InterlockedIncrement
#else
#define InterlockedIncrement(Addend) (InterlockedExchangeAdd (Addend, 1)+1)
#endif

#if (_MSC_FULL_VER > 13009037)
LONG
__cdecl
_InterlockedDecrement(
    IN LONG volatile *Addend
    );

#pragma intrinsic(_InterlockedDecrement)
#define InterlockedDecrement _InterlockedDecrement
#else
#define InterlockedDecrement(Addend) (InterlockedExchangeAdd (Addend, -1)-1)
#endif

#if (_MSC_FULL_VER > 13009037)
LONG
__cdecl
_InterlockedExchangeAdd(
    IN OUT LONG volatile *Addend,
    IN LONG Increment
    );

#pragma intrinsic(_InterlockedExchangeAdd)
#define InterlockedExchangeAdd _InterlockedExchangeAdd
#else

FORCEINLINE
LONG
FASTCALL
InterlockedExchangeAdd(
    IN OUT LONG volatile *Addend,
    IN LONG Increment
    )
{
    __asm {
         mov     eax, Increment
         mov     ecx, Addend
    lock xadd    [ecx], eax
    }
}

#endif

#if (_MSC_FULL_VER > 13009037)
LONG
__cdecl
_InterlockedCompareExchange (
    IN OUT LONG volatile *Destination,
    IN LONG ExChange,
    IN LONG Comperand
    );

#pragma intrinsic(_InterlockedCompareExchange)
#define InterlockedCompareExchange (LONG)_InterlockedCompareExchange
#else
FORCEINLINE
LONG
FASTCALL
InterlockedCompareExchange(
    IN OUT LONG volatile *Destination,
    IN LONG Exchange,
    IN LONG Comperand
    )
{
    __asm {
        mov     eax, Comperand
        mov     ecx, Destination
        mov     edx, Exchange
   lock cmpxchg [ecx], edx
    }
}
#endif

#define InterlockedCompareExchangePointer(Destination, ExChange, Comperand) \
    (PVOID)InterlockedCompareExchange((PLONG)Destination, (LONG)ExChange, (LONG)Comperand)

NTKERNELAPI
LONGLONG
FASTCALL
ExfInterlockedCompareExchange64 (
    IN OUT LONGLONG volatile *Destination,
    IN PLONGLONG ExChange,
    IN PLONGLONG Comperand
    );

LONGLONG
FORCEINLINE
InterlockedCompareExchange64_inline (
    IN OUT LONGLONG volatile *Destination,
    IN LONGLONG ExChange,
    IN LONGLONG Comperand
    )
{
    return ExfInterlockedCompareExchange64(Destination, &ExChange, &Comperand);
}

#if (_MSC_FULL_VER >= 140031008)

LONGLONG
__cdecl
_InterlockedCompareExchange64 (
    IN OUT LONGLONG volatile *Destination,
    IN LONGLONG ExChange,
    IN LONGLONG Comperand
    );

#pragma intrinsic(_InterlockedCompareExchange64)
#define InterlockedCompareExchange64 _InterlockedCompareExchange64

#else

#define InterlockedCompareExchange64 InterlockedCompareExchange64_inline

#endif // _MSC_FULL_VER > 140031008

#endif      // INTERLOCKED_INTRINSICS || _CROSS_PLATFORM_

#define InterlockedExchangePointer(Target, Value) \
    (PVOID)InterlockedExchange((PLONG)Target, (LONG)Value)

#endif      // MIDL_PASS

#define InterlockedIncrementAcquire InterlockedIncrement
#define InterlockedIncrementRelease InterlockedIncrement
#define InterlockedDecrementAcquire InterlockedDecrement
#define InterlockedDecrementRelease InterlockedDecrement
#define InterlockedExchangeAcquire64 InterlockedExchange64
#define InterlockedCompareExchangeAcquire InterlockedCompareExchange
#define InterlockedCompareExchangeRelease InterlockedCompareExchange
#define InterlockedCompareExchangeAcquire64 InterlockedCompareExchange64
#define InterlockedCompareExchangeRelease64 InterlockedCompareExchange64
#define InterlockedCompareExchangePointerAcquire InterlockedCompareExchangePointer
#define InterlockedCompareExchangePointerRelease InterlockedCompareExchangePointer

#define InterlockedExchangeAddSizeT(a, b) InterlockedExchangeAdd((LONG *)a, b)
#define InterlockedIncrementSizeT(a) InterlockedIncrement((LONG *)a)
#define InterlockedDecrementSizeT(a) InterlockedDecrement((LONG *)a)


#if !defined(MIDL_PASS) && defined(_M_IX86)

//
// i386 function definitions
//


//
// Get current IRQL.
//
// On x86 this function resides in the HAL
//

NTHALAPI
KIRQL
NTAPI
KeGetCurrentIrql(
    VOID
    );

#endif // !defined(MIDL_PASS) && defined(_M_IX86)


//++
//
// VOID
// KeMemoryBarrier (
//    VOID
//    )
//
// VOID
// KeMemoryBarrierWithoutFence (
//    VOID
//    )
//
//
// Routine Description:
//
//    These functions order memory accesses as seen by other processors.
//
// Arguments:
//
//    None.
//
// Return Value:
//
//    None.
//
//--

#ifdef __cplusplus
extern "C" {
#endif

//
// Define function to flush a cache line.
//

#define CacheLineFlush(Address) _mm_clflush(Address)

VOID
_mm_clflush (
    VOID const *Address
    );

#pragma intrinsic(_mm_clflush)

VOID
_ReadWriteBarrier(
    VOID
    );

#ifdef __cplusplus
}
#endif

#pragma intrinsic(_ReadWriteBarrier)

#pragma warning( push )
#pragma warning( disable : 4793 )

FORCEINLINE
VOID
KeMemoryBarrier (
    VOID
    )
{
    LONG Barrier;
    __asm {
        xchg Barrier, eax
    }
}

#pragma warning( pop )

#define KeMemoryBarrierWithoutFence() _ReadWriteBarrier()


NTKERNELAPI
NTSTATUS
NTAPI
KeSaveFloatingPointState (
    OUT PKFLOATING_SAVE     FloatSave
    );

NTKERNELAPI
NTSTATUS
NTAPI
KeRestoreFloatingPointState (
    IN PKFLOATING_SAVE      FloatSave
    );


#endif // defined(_X86_)



#if defined(_M_AMD64) && !defined(RC_INVOKED) && !defined(MIDL_PASS)

//
// Define intrinsic function to do in's and out's.
//

#ifdef __cplusplus
extern "C" {
#endif

UCHAR
__inbyte (
    IN USHORT Port
    );

USHORT
__inword (
    IN USHORT Port
    );

ULONG
__indword (
    IN USHORT Port
    );

VOID
__outbyte (
    IN USHORT Port,
    IN UCHAR Data
    );

VOID
__outword (
    IN USHORT Port,
    IN USHORT Data
    );

VOID
__outdword (
    IN USHORT Port,
    IN ULONG Data
    );

VOID
__inbytestring (
    IN USHORT Port,
    IN PUCHAR Buffer,
    IN ULONG Count
    );

VOID
__inwordstring (
    IN USHORT Port,
    IN PUSHORT Buffer,
    IN ULONG Count
    );

VOID
__indwordstring (
    IN USHORT Port,
    IN PULONG Buffer,
    IN ULONG Count
    );

VOID
__outbytestring (
    IN USHORT Port,
    IN PUCHAR Buffer,
    IN ULONG Count
    );

VOID
__outwordstring (
    IN USHORT Port,
    IN PUSHORT Buffer,
    IN ULONG Count
    );

VOID
__outdwordstring (
    IN USHORT Port,
    IN PULONG Buffer,
    IN ULONG Count
    );

#pragma intrinsic(__inbyte)
#pragma intrinsic(__inword)
#pragma intrinsic(__indword)
#pragma intrinsic(__outbyte)
#pragma intrinsic(__outword)
#pragma intrinsic(__outdword)
#pragma intrinsic(__inbytestring)
#pragma intrinsic(__inwordstring)
#pragma intrinsic(__indwordstring)
#pragma intrinsic(__outbytestring)
#pragma intrinsic(__outwordstring)
#pragma intrinsic(__outdwordstring)

#ifdef __cplusplus
}
#endif

#endif // defined(_M_AMD64) && !defined(RC_INVOKED) && !defined(MIDL_PASS)


#if defined(_AMD64_) // ntddk nthal

//
// Types to use to contain PFNs and their counts.
//

typedef ULONG PFN_COUNT;
typedef LONG64 SPFN_NUMBER, *PSPFN_NUMBER;
typedef ULONG64 PFN_NUMBER, *PPFN_NUMBER;

//
// Define maximum size of flush multiple TB request.
//

#define FLUSH_MULTIPLE_MAXIMUM 19

//
// Indicate that the AMD64 compiler supports the allocate pragmas.
//

#define ALLOC_PRAGMA 1
#define ALLOC_DATA_PRAGMA 1

//
// Define functions to read and write CR8.
//
// CR8 is the APIC TPR register.
//

#ifdef __cplusplus
extern "C" {
#endif

#define ReadCR8() __readcr8()

ULONG64
__readcr8 (
    VOID
    );

#define WriteCR8(Data) __writecr8(Data)

VOID
__writecr8 (
    IN ULONG64 Data
    );

#pragma intrinsic(__readcr8)
#pragma intrinsic(__writecr8)

#ifdef __cplusplus
}
#endif

//
// Interrupt Request Level definitions
//

#define PASSIVE_LEVEL 0                 // Passive release level
#define LOW_LEVEL 0                     // Lowest interrupt level
#define APC_LEVEL 1                     // APC interrupt level
#define DISPATCH_LEVEL 2                // Dispatcher level
#define CMCI_LEVEL 5                    // CMCI handler level

#define CLOCK_LEVEL 13                  // Interval clock level
#define IPI_LEVEL 14                    // Interprocessor interrupt level
#define POWER_LEVEL 14                  // Power failure level
#define PROFILE_LEVEL 15                // timer used for profiling.
#define HIGH_LEVEL 15                   // Highest interrupt level




#if defined(_AMD64_) && !defined(DSF_DRIVER)

//
// I/O space read and write macros.
//
//  The READ/WRITE_REGISTER_* calls manipulate I/O registers in MEMORY space.
//
//  The READ/WRITE_PORT_* calls manipulate I/O registers in PORT space.
//

#ifdef __cplusplus
extern "C" {
#endif

__forceinline
UCHAR
READ_REGISTER_UCHAR (
    volatile UCHAR *Register
    )
{
    _ReadWriteBarrier();
    return *Register;
}

__forceinline
USHORT
READ_REGISTER_USHORT (
    volatile USHORT *Register
    )
{
    _ReadWriteBarrier();
    return *Register;
}

__forceinline
ULONG
READ_REGISTER_ULONG (
    volatile ULONG *Register
    )
{
    _ReadWriteBarrier();
    return *Register;
}

__forceinline
ULONG64
READ_REGISTER_ULONG64 (
    volatile ULONG64 *Register
    )
{
    _ReadWriteBarrier();
    return *Register;
}

__forceinline
VOID
READ_REGISTER_BUFFER_UCHAR (
    PUCHAR Register,
    PUCHAR Buffer,
    ULONG Count
    )
{
    _ReadWriteBarrier();
    __movsb(Buffer, Register, Count);
    return;
}

__forceinline
VOID
READ_REGISTER_BUFFER_USHORT (
    PUSHORT Register,
    PUSHORT Buffer,
    ULONG Count
    )
{
    _ReadWriteBarrier();
    __movsw(Buffer, Register, Count);
    return;
}

__forceinline
VOID
READ_REGISTER_BUFFER_ULONG (
    PULONG Register,
    PULONG Buffer,
    ULONG Count
    )
{
    _ReadWriteBarrier();
    __movsd(Buffer, Register, Count);
    return;
}

__forceinline
VOID
READ_REGISTER_BUFFER_ULONG64 (
    PULONG64 Register,
    PULONG64 Buffer,
    ULONG Count
    )
{
    _ReadWriteBarrier();
    __movsq(Buffer, Register, Count);
    return;
}

__forceinline
VOID
WRITE_REGISTER_UCHAR (
    volatile UCHAR *Register,
    UCHAR Value
    )
{

    *Register = Value;
    FastFence();
    return;
}

__forceinline
VOID
WRITE_REGISTER_USHORT (
    volatile USHORT *Register,
    USHORT Value
    )
{

    *Register = Value;
    FastFence();
    return;
}

__forceinline
VOID
WRITE_REGISTER_ULONG (
    volatile ULONG *Register,
    ULONG Value
    )
{

    *Register = Value;
    FastFence();
    return;
}

__forceinline
VOID
WRITE_REGISTER_ULONG64 (
    volatile ULONG64 *Register,
    ULONG64 Value
    )
{

    *Register = Value;
    FastFence();
    return;
}

__forceinline
VOID
WRITE_REGISTER_BUFFER_UCHAR (
    PUCHAR Register,
    PUCHAR Buffer,
    ULONG Count
    )
{

    __movsb(Register, Buffer, Count);
    FastFence();
    return;
}

__forceinline
VOID
WRITE_REGISTER_BUFFER_USHORT (
    PUSHORT Register,
    PUSHORT Buffer,
    ULONG Count
    )
{

    __movsw(Register, Buffer, Count);
    FastFence();
    return;
}

__forceinline
VOID
WRITE_REGISTER_BUFFER_ULONG (
    PULONG Register,
    PULONG Buffer,
    ULONG Count
    )
{

    __movsd(Register, Buffer, Count);
    FastFence();
    return;
}

__forceinline
VOID
WRITE_REGISTER_BUFFER_ULONG64 (
    PULONG64 Register,
    PULONG64 Buffer,
    ULONG Count
    )
{

    __movsq(Register, Buffer, Count);
    FastFence();
    return;
}

__forceinline
UCHAR
READ_PORT_UCHAR (
    PUCHAR Port
    )

{
    UCHAR Result;

    _ReadWriteBarrier();
    Result = __inbyte((USHORT)((ULONG_PTR)Port));
    _ReadWriteBarrier();
    return Result;
}

__forceinline
USHORT
READ_PORT_USHORT (
    PUSHORT Port
    )

{
    USHORT Result;

    _ReadWriteBarrier();
    Result = __inword((USHORT)((ULONG_PTR)Port));
    _ReadWriteBarrier();
    return Result;
}

__forceinline
ULONG
READ_PORT_ULONG (
    PULONG Port
    )

{
    ULONG Result;

    _ReadWriteBarrier();
    Result = __indword((USHORT)((ULONG_PTR)Port));
    _ReadWriteBarrier();
    return Result;
}


__forceinline
VOID
READ_PORT_BUFFER_UCHAR (
    PUCHAR Port,
    PUCHAR Buffer,
    ULONG Count
    )

{
    _ReadWriteBarrier();
    __inbytestring((USHORT)((ULONG_PTR)Port), Buffer, Count);
    _ReadWriteBarrier();
    return;
}

__forceinline
VOID
READ_PORT_BUFFER_USHORT (
    PUSHORT Port,
    PUSHORT Buffer,
    ULONG Count
    )

{
    _ReadWriteBarrier();
    __inwordstring((USHORT)((ULONG_PTR)Port), Buffer, Count);
    _ReadWriteBarrier();
    return;
}

__forceinline
VOID
READ_PORT_BUFFER_ULONG (
    PULONG Port,
    PULONG Buffer,
    ULONG Count
    )

{
    _ReadWriteBarrier();
    __indwordstring((USHORT)((ULONG_PTR)Port), Buffer, Count);
    _ReadWriteBarrier();
    return;
}

__forceinline
VOID
WRITE_PORT_UCHAR (
    PUCHAR Port,
    UCHAR Value
    )

{
    _ReadWriteBarrier();
    __outbyte((USHORT)((ULONG_PTR)Port), Value);
    _ReadWriteBarrier();
    return;
}

__forceinline
VOID
WRITE_PORT_USHORT (
    PUSHORT Port,
    USHORT Value
    )

{
    _ReadWriteBarrier();
    __outword((USHORT)((ULONG_PTR)Port), Value);
    _ReadWriteBarrier();
    return;
}

__forceinline
VOID
WRITE_PORT_ULONG (
    PULONG Port,
    ULONG Value
    )

{
    _ReadWriteBarrier();
    __outdword((USHORT)((ULONG_PTR)Port), Value);
    _ReadWriteBarrier();
    return;
}

__forceinline
VOID
WRITE_PORT_BUFFER_UCHAR (
    PUCHAR Port,
    PUCHAR Buffer,
    ULONG Count
    )

{
    _ReadWriteBarrier();
    __outbytestring((USHORT)((ULONG_PTR)Port), Buffer, Count);
    _ReadWriteBarrier();
    return;
}

__forceinline
VOID
WRITE_PORT_BUFFER_USHORT (
    PUSHORT Port,
    PUSHORT Buffer,
    ULONG Count
    )

{
    _ReadWriteBarrier();
    __outwordstring((USHORT)((ULONG_PTR)Port), Buffer, Count);
    _ReadWriteBarrier();
    return;
}

__forceinline
VOID
WRITE_PORT_BUFFER_ULONG (
    PULONG Port,
    PULONG Buffer,
    ULONG Count
    )

{
    _ReadWriteBarrier();
    __outdwordstring((USHORT)((ULONG_PTR)Port), Buffer, Count);
    _ReadWriteBarrier();
    return;
}

#ifdef __cplusplus
}
#endif

#elif defined(_AMD64_) && defined(DSF_DRIVER)
#include <DsfHrmPorts.h>
#endif




//
// Get data cache fill size.
//

#if PRAGMA_DEPRECATED_DDK
#pragma deprecated(KeGetDcacheFillSize)      // Use GetDmaAlignment
#endif

#define KeGetDcacheFillSize() 1L


#define KeFlushIoBuffers(Mdl, ReadOperation, DmaOperation)


#define ExAcquireSpinLock(Lock, OldIrql) KeAcquireSpinLock((Lock), (OldIrql))
#define ExReleaseSpinLock(Lock, OldIrql) KeReleaseSpinLock((Lock), (OldIrql))
#define ExAcquireSpinLockAtDpcLevel(Lock) KeAcquireSpinLockAtDpcLevel(Lock)
#define ExReleaseSpinLockFromDpcLevel(Lock) KeReleaseSpinLockFromDpcLevel(Lock)


#define KI_USER_SHARED_DATA 0xFFFFF78000000000UI64

#define SharedUserData ((KUSER_SHARED_DATA * const)KI_USER_SHARED_DATA)

#define SharedInterruptTime (KI_USER_SHARED_DATA + 0x8)
#define SharedSystemTime (KI_USER_SHARED_DATA + 0x14)
#define SharedTickCount (KI_USER_SHARED_DATA + 0x320)

#define KeQueryInterruptTime() *((volatile ULONG64 *)(SharedInterruptTime))

#define KeQuerySystemTime(CurrentCount)                                     \
    *((PULONG64)(CurrentCount)) = *((volatile ULONG64 *)(SharedSystemTime))

#define KeQueryTickCount(CurrentCount)                                      \
    *((PULONG64)(CurrentCount)) = *((volatile ULONG64 *)(SharedTickCount))

//
// Dummy nonvolatile floating state structure.
//

typedef struct _KFLOATING_SAVE {
    ULONG Dummy;
} KFLOATING_SAVE, *PKFLOATING_SAVE;

//
// AMD64 Specific portions of mm component.
//
// Define the page size for the AMD64 as 4096 (0x1000).
//

#define PAGE_SIZE 0x1000

//
// Define the number of trailing zeroes in a page aligned virtual address.
// This is used as the shift count when shifting virtual addresses to
// virtual page numbers.
//

#define PAGE_SHIFT 12L


#define MmGetProcedureAddress(Address) (Address)
#define MmLockPagableCodeSection(Address) MmLockPagableDataSection(Address)


//
// Define macro to perform a load fence after a lock acquisition.
//

#define LFENCE_ACQUIRE() LoadFence()

#if !defined(_CROSS_PLATFORM_)

FORCEINLINE
VOID
KeMemoryBarrier (
    VOID
    )

/*++

Routine Description:

    This function orders memory accesses as seen by other processors.

Arguments:

    None.

Return Value:

    None.

--*/

{

    FastFence();
    LFENCE_ACQUIRE();
    return;
}

//++
//
// VOID
// KeMemoryBarrierWithoutFence (
//    VOID
//    )
//
//
// Routine Description:
//
//    This function instructs the compiler not to reorder loads and stores
//    across the function invocation.
//
// Arguments:
//
//    None.
//
// Return Value:
//
//    None.
//
//--

#define KeMemoryBarrierWithoutFence() _ReadWriteBarrier()

#else

#define KeMemoryBarrier()
#define KeMemoryBarrierWithoutFence()

#endif


__forceinline
NTSTATUS
KeSaveFloatingPointState (
    __out PVOID FloatingState
    )

{

    UNREFERENCED_PARAMETER(FloatingState);

    return STATUS_SUCCESS;
}

__forceinline
NTSTATUS
KeRestoreFloatingPointState (
    __in PVOID FloatingState
    )

{

    UNREFERENCED_PARAMETER(FloatingState);

    return STATUS_SUCCESS;
}


#endif // defined(_AMD64_)


//
// Platform specific kernel fucntions to raise and lower IRQL.
//


#if defined(_AMD64_) && !defined(MIDL_PASS)


__forceinline
KIRQL
KeGetCurrentIrql (
    VOID
    )

/*++

Routine Description:

    This function return the current IRQL.

Arguments:

    None.

Return Value:

    The current IRQL is returned as the function value.

--*/

{

    return (KIRQL)ReadCR8();
}

__forceinline
VOID
KeLowerIrql (
   __in KIRQL NewIrql
   )

/*++

Routine Description:

    This function lowers the IRQL to the specified value.

Arguments:

    NewIrql  - Supplies the new IRQL value.

Return Value:

    None.

--*/

{

    NT_ASSERT(KeGetCurrentIrql() >= NewIrql);

    WriteCR8(NewIrql);
    return;
}

#define KeRaiseIrql(a,b) *(b) = KfRaiseIrql(a)

__forceinline
KIRQL
KfRaiseIrql (
    __in KIRQL NewIrql
    )

/*++

Routine Description:

    This function raises the current IRQL to the specified value and returns
    the previous IRQL.

Arguments:

    NewIrql (cl) - Supplies the new IRQL value.

Return Value:

    The previous IRQL is retured as the function value.

--*/

{

    KIRQL OldIrql;

    OldIrql = KeGetCurrentIrql();

    NT_ASSERT(OldIrql <= NewIrql);

    WriteCR8(NewIrql);
    return OldIrql;
}

#endif // defined(_AMD64_) && !defined(MIDL_PASS)


#if defined(_IA64_)

//
// Types to use to contain PFNs and their counts.
//

typedef ULONG PFN_COUNT;

typedef LONG_PTR SPFN_NUMBER, *PSPFN_NUMBER;
typedef ULONG_PTR PFN_NUMBER, *PPFN_NUMBER;

//
// Indicate that the IA64 compiler supports the pragma textout construct.
//

#define ALLOC_PRAGMA 1

//
// Define intrinsic calls and their prototypes
//

#include "ia64reg.h"

#ifdef __cplusplus
extern "C" {
#endif

unsigned __int64 __getReg (int);
void __setReg (int, unsigned __int64);
void __isrlz (void);
void __dsrlz (void);
void __fwb (void);
void __mf (void);
void __mfa (void);
void __synci (void);
__int64 __thash (__int64);
__int64 __ttag (__int64);
void __ptcl (__int64, __int64);
void __ptcg (__int64, __int64);
void __ptcga (__int64, __int64);
void __ptri (__int64, __int64);
void __ptrd (__int64, __int64);
void __invalat (void);
void __break (int);
void __fc (__int64);
void __fci (__int64);
void __sum (int);
void __rsm (int);
void _ReleaseSpinLock( unsigned __int64 *);
void __yield();
void __lfetch(int, volatile void const *);
void __lfetchfault(int, volatile void const *);
void __lfetch_excl(int, volatile void const *);
void __lfetchfault_excl(int, volatile void const *);
#ifdef _M_IA64
#pragma intrinsic (__getReg)
#pragma intrinsic (__setReg)
#pragma intrinsic (__isrlz)
#pragma intrinsic (__dsrlz)
#pragma intrinsic (__fwb)
#pragma intrinsic (__mf)
#pragma intrinsic (__mfa)
#pragma intrinsic (__synci)
#pragma intrinsic (__thash)
#pragma intrinsic (__ttag)
#pragma intrinsic (__ptcl)
#pragma intrinsic (__ptcg)
#pragma intrinsic (__ptcga)
#pragma intrinsic (__ptri)
#pragma intrinsic (__ptrd)
#pragma intrinsic (__invalat)
#pragma intrinsic (__break)
#pragma intrinsic (__fc)
#pragma intrinsic (__fci)
#pragma intrinsic (__sum)
#pragma intrinsic (__rsm)
#pragma intrinsic (_ReleaseSpinLock)
#pragma intrinsic (__yield)
#pragma intrinsic (__lfetch)
#pragma intrinsic (__lfetchfault)
#pragma intrinsic (__lfetchfault_excl)
#pragma intrinsic (__lfetch_excl)
#endif // _M_IA64

#ifdef __cplusplus
}
#endif



//
// Define length of interrupt vector table.
//

#define MAXIMUM_VECTOR 256

//
// Begin of a block of definitions that must be synchronized with kxia64.h.
//
// Define Interrupt Request Levels.
//

#define PASSIVE_LEVEL            0      // Passive release level
#define LOW_LEVEL                0      // Lowest interrupt level
#define APC_LEVEL                1      // APC interrupt level
#define DISPATCH_LEVEL           2      // Dispatcher level
#define CMC_LEVEL                3      // Correctable machine check level
#define DEVICE_LEVEL_BASE        4      // 4 - 11 - Device IRQLs
#define PC_LEVEL                12      // Performance Counter IRQL
#define IPI_LEVEL               14      // IPI IRQL
#define CLOCK_LEVEL             13      // Clock Timer IRQL
#define POWER_LEVEL             15      // Power failure level
#define PROFILE_LEVEL           15      // Profiling level
#define HIGH_LEVEL              15      // Highest interrupt level


#define KI_USER_SHARED_DATA ((ULONG_PTR)(KADDRESS_BASE + 0xFFFE0000))
#define SharedUserData ((KUSER_SHARED_DATA * const)KI_USER_SHARED_DATA)


__forceinline
NTSTATUS
KeSaveFloatingPointState (
    PVOID FloatingState
    )

{

    UNREFERENCED_PARAMETER(FloatingState);

    return STATUS_SUCCESS;
}

__forceinline
NTSTATUS
KeRestoreFloatingPointState (
    PVOID FloatingState
    )

{

    UNREFERENCED_PARAMETER(FloatingState);

    return STATUS_SUCCESS;
}



//
//
// VOID
// KeMemoryBarrierWithoutFence (
//    VOID
//    )
//
//
// Routine Description:
//
//    This function cases ordering of memory acceses generated by the compiler.
//
//
// Arguments:
//
//    None.
//
// Return Value:
//
//    None.
//--

#ifdef __cplusplus
extern "C" {
#endif

VOID
_ReadWriteBarrier (
    VOID
    );

#ifdef __cplusplus
}
#endif

#pragma intrinsic(_ReadWriteBarrier)

#define KeMemoryBarrierWithoutFence() _ReadWriteBarrier()

//++
//
//
// VOID
// KeMemoryBarrier (
//    VOID
//    )
//
//
// Routine Description:
//
//    This function cases ordering of memory acceses as generated by the compiler and
//    as seen by other processors.
//
//
// Arguments:
//
//    None.
//
// Return Value:
//
//    None.
//--

#define KE_MEMORY_BARRIER_REQUIRED

#define KeMemoryBarrier() __mf()

//
// Define the page size
//

#define PAGE_SIZE 0x2000

//
// Define the number of trailing zeroes in a page aligned virtual address.
// This is used as the shift count when shifting virtual addresses to
// virtual page numbers.
//

#define PAGE_SHIFT 13L

//
// Cache and write buffer flush functions.
//

NTKERNELAPI
VOID
KeFlushIoBuffers (
    IN PMDL Mdl,
    IN BOOLEAN ReadOperation,
    IN BOOLEAN DmaOperation
    );


//
// Kernel breakin breakpoint
//

VOID
KeBreakinBreakpoint (
    VOID
    );


#define ExAcquireSpinLock(Lock, OldIrql) KeAcquireSpinLock((Lock), (OldIrql))
#define ExReleaseSpinLock(Lock, OldIrql) KeReleaseSpinLock((Lock), (OldIrql))
#define ExAcquireSpinLockAtDpcLevel(Lock) KeAcquireSpinLockAtDpcLevel(Lock)
#define ExReleaseSpinLockFromDpcLevel(Lock) KeReleaseSpinLockFromDpcLevel(Lock)


#if defined(_NTDRIVER_) || defined(_NTDDK_) || defined(_NTIFS_)

#define KeQueryTickCount(CurrentCount ) \
    *(PULONGLONG)(CurrentCount) = **((volatile ULONGLONG **)(&KeTickCount));

#else


NTKERNELAPI
VOID
KeQueryTickCount (
    OUT PLARGE_INTEGER CurrentCount
    );

#endif // defined(_NTDRIVER_) || defined(_NTDDK_) || defined(_NTIFS_)

//
// I/O space read and write macros.
//

NTHALAPI
UCHAR
READ_PORT_UCHAR (
    PUCHAR RegisterAddress
    );

NTHALAPI
USHORT
READ_PORT_USHORT (
    PUSHORT RegisterAddress
    );

NTHALAPI
ULONG
READ_PORT_ULONG (
    PULONG RegisterAddress
    );

NTHALAPI
VOID
READ_PORT_BUFFER_UCHAR (
    PUCHAR portAddress,
    PUCHAR readBuffer,
    ULONG  readCount
    );

NTHALAPI
VOID
READ_PORT_BUFFER_USHORT (
    PUSHORT portAddress,
    PUSHORT readBuffer,
    ULONG  readCount
    );

NTHALAPI
VOID
READ_PORT_BUFFER_ULONG (
    PULONG portAddress,
    PULONG readBuffer,
    ULONG  readCount
    );

NTHALAPI
VOID
WRITE_PORT_UCHAR (
    PUCHAR portAddress,
    UCHAR  Data
    );

NTHALAPI
VOID
WRITE_PORT_USHORT (
    PUSHORT portAddress,
    USHORT  Data
    );

NTHALAPI
VOID
WRITE_PORT_ULONG (
    PULONG portAddress,
    ULONG  Data
    );

NTHALAPI
VOID
WRITE_PORT_BUFFER_UCHAR (
    PUCHAR portAddress,
    PUCHAR writeBuffer,
    ULONG  writeCount
    );

NTHALAPI
VOID
WRITE_PORT_BUFFER_USHORT (
    PUSHORT portAddress,
    PUSHORT writeBuffer,
    ULONG  writeCount
    );

NTHALAPI
VOID
WRITE_PORT_BUFFER_ULONG (
    PULONG portAddress,
    PULONG writeBuffer,
    ULONG  writeCount
    );


#define READ_REGISTER_UCHAR(x) \
    (__mf(), *(volatile UCHAR * const)(x))

#define READ_REGISTER_USHORT(x) \
    (__mf(), *(volatile USHORT * const)(x))

#define READ_REGISTER_ULONG(x) \
    (__mf(), *(volatile ULONG * const)(x))

#define READ_REGISTER_ULONG64(x) \
    (__mf(), *(volatile ULONG64 * const)(x))

#define READ_REGISTER_BUFFER_UCHAR(x, y, z) {                           \
    PUCHAR registerBuffer = x;                                          \
    PUCHAR readBuffer = y;                                              \
    ULONG readCount;                                                    \
    __mf();                                                             \
    for (readCount = z; readCount--; readBuffer++, registerBuffer++) {  \
        *readBuffer = *(volatile UCHAR * const)(registerBuffer);        \
    }                                                                   \
}

#define READ_REGISTER_BUFFER_USHORT(x, y, z) {                          \
    PUSHORT registerBuffer = x;                                         \
    PUSHORT readBuffer = y;                                             \
    ULONG readCount;                                                    \
    __mf();                                                             \
    for (readCount = z; readCount--; readBuffer++, registerBuffer++) {  \
        *readBuffer = *(volatile USHORT * const)(registerBuffer);       \
    }                                                                   \
}

#define READ_REGISTER_BUFFER_ULONG(x, y, z) {                           \
    PULONG registerBuffer = x;                                          \
    PULONG readBuffer = y;                                              \
    ULONG readCount;                                                    \
    __mf();                                                             \
    for (readCount = z; readCount--; readBuffer++, registerBuffer++) {  \
        *readBuffer = *(volatile ULONG * const)(registerBuffer);        \
    }                                                                   \
}

#define READ_REGISTER_BUFFER_ULONG64(x, y, z) {                         \
    PULONG64 registerBuffer = x;                                        \
    PULONG64 readBuffer = y;                                            \
    ULONG readCount;                                                    \
    __mf();                                                             \
    for (readCount = z; readCount--; readBuffer++, registerBuffer++) {  \
        *readBuffer = *(volatile ULONG64 * const)(registerBuffer);      \
    }                                                                   \
}

#define WRITE_REGISTER_UCHAR(x, y) {    \
    *(volatile UCHAR * const)(x) = y;   \
    KeFlushWriteBuffer();               \
}

#define WRITE_REGISTER_USHORT(x, y) {   \
    *(volatile USHORT * const)(x) = y;  \
    KeFlushWriteBuffer();               \
}

#define WRITE_REGISTER_ULONG(x, y) {    \
    *(volatile ULONG * const)(x) = y;   \
    KeFlushWriteBuffer();               \
}

#define WRITE_REGISTER_ULONG64(x, y) {  \
    *(volatile ULONG64 * const)(x) = y; \
    KeFlushWriteBuffer();               \
}

#define WRITE_REGISTER_BUFFER_UCHAR(x, y, z) {                            \
    PUCHAR registerBuffer = x;                                            \
    PUCHAR writeBuffer = y;                                               \
    ULONG writeCount;                                                     \
    for (writeCount = z; writeCount--; writeBuffer++, registerBuffer++) { \
        *(volatile UCHAR * const)(registerBuffer) = *writeBuffer;         \
    }                                                                     \
    KeFlushWriteBuffer();                                                 \
}

#define WRITE_REGISTER_BUFFER_USHORT(x, y, z) {                           \
    PUSHORT registerBuffer = x;                                           \
    PUSHORT writeBuffer = y;                                              \
    ULONG writeCount;                                                     \
    for (writeCount = z; writeCount--; writeBuffer++, registerBuffer++) { \
        *(volatile USHORT * const)(registerBuffer) = *writeBuffer;        \
    }                                                                     \
    KeFlushWriteBuffer();                                                 \
}

#define WRITE_REGISTER_BUFFER_ULONG(x, y, z) {                            \
    PULONG registerBuffer = x;                                            \
    PULONG writeBuffer = y;                                               \
    ULONG writeCount;                                                     \
    for (writeCount = z; writeCount--; writeBuffer++, registerBuffer++) { \
        *(volatile ULONG * const)(registerBuffer) = *writeBuffer;         \
    }                                                                     \
    KeFlushWriteBuffer();                                                 \
}

#define WRITE_REGISTER_BUFFER_ULONG64(x, y, z) {                          \
    PULONG64 registerBuffer = x;                                          \
    PULONG64 writeBuffer = y;                                             \
    ULONG writeCount;                                                     \
    for (writeCount = z; writeCount--; writeBuffer++, registerBuffer++) { \
        *(volatile ULONG64 * const)(registerBuffer) = *writeBuffer;       \
    }                                                                     \
    KeFlushWriteBuffer();                                                 \
}


//
// Non-volatile floating point state
//

typedef struct _KFLOATING_SAVE {
    ULONG   Reserved;
} KFLOATING_SAVE, *PKFLOATING_SAVE;


NTKERNELAPI
KIRQL
KeGetCurrentIrql(
    VOID
    );

NTKERNELAPI
VOID
KeLowerIrql (
    IN KIRQL NewIrql
    );

NTKERNELAPI
VOID
KeRaiseIrql (
    IN KIRQL NewIrql,
    OUT PKIRQL OldIrql
    );


#define MmGetProcedureAddress(Address) (Address)
#define MmLockPagableCodeSection(PLabelAddress) \
    MmLockPagableDataSection((PVOID)(*((PULONGLONG)PLabelAddress)))

#define VRN_MASK   0xE000000000000000UI64    // Virtual Region Number mask

//
// The lowest address for system space.
//

#define MM_LOWEST_SYSTEM_ADDRESS ((PVOID)((ULONG_PTR)(KADDRESS_BASE + 0xC0C00000)))
#endif // defined(_IA64_)
//
// Event Specific Access Rights.
//

#define EVENT_QUERY_STATE       0x0001
#define EVENT_MODIFY_STATE      0x0002  
#define EVENT_ALL_ACCESS (STANDARD_RIGHTS_REQUIRED|SYNCHRONIZE|0x3) 

//
// Semaphore Specific Access Rights.
//

#define SEMAPHORE_QUERY_STATE       0x0001
#define SEMAPHORE_MODIFY_STATE      0x0002  

#define SEMAPHORE_ALL_ACCESS (STANDARD_RIGHTS_REQUIRED|SYNCHRONIZE|0x3) 


//
// Defined processor features
//

#define PF_FLOATING_POINT_PRECISION_ERRATA  0   
#define PF_FLOATING_POINT_EMULATED          1   
#define PF_COMPARE_EXCHANGE_DOUBLE          2   
#define PF_MMX_INSTRUCTIONS_AVAILABLE       3   
#define PF_PPC_MOVEMEM_64BIT_OK             4   
#define PF_ALPHA_BYTE_INSTRUCTIONS          5   
#define PF_XMMI_INSTRUCTIONS_AVAILABLE      6   
#define PF_3DNOW_INSTRUCTIONS_AVAILABLE     7   
#define PF_RDTSC_INSTRUCTION_AVAILABLE      8   
#define PF_PAE_ENABLED                      9   
#define PF_XMMI64_INSTRUCTIONS_AVAILABLE   10   
#define PF_SSE_DAZ_MODE_AVAILABLE          11   
#define PF_NX_ENABLED                      12   
#define PF_SSE3_INSTRUCTIONS_AVAILABLE     13   
#define PF_COMPARE_EXCHANGE128             14   
#define PF_COMPARE64_EXCHANGE128           15   
#define PF_CHANNELS_ENABLED                16   

typedef enum _ALTERNATIVE_ARCHITECTURE_TYPE {
    StandardDesign,                 // None == 0 == standard design
    NEC98x86,                       // NEC PC98xx series on X86
    EndAlternatives                 // past end of known alternatives
} ALTERNATIVE_ARCHITECTURE_TYPE;

// correctly define these run-time definitions for non X86 machines

#ifndef _X86_

#ifndef IsNEC_98
#define IsNEC_98 (FALSE)
#endif

#ifndef IsNotNEC_98
#define IsNotNEC_98 (TRUE)
#endif

#ifndef SetNEC_98
#define SetNEC_98
#endif

#ifndef SetNotNEC_98
#define SetNotNEC_98
#endif

#endif // _X86_

#define PROCESSOR_FEATURE_MAX 64

//
// Exception flag definitions.
//


#define EXCEPTION_NONCONTINUABLE 0x1    // Noncontinuable exception


//
// Define maximum number of exception parameters.
//


#define EXCEPTION_MAXIMUM_PARAMETERS 15 // maximum number of exception parameters

//
// Exception record definition.
//

typedef struct _EXCEPTION_RECORD {
    NTSTATUS ExceptionCode;
    ULONG ExceptionFlags;
    struct _EXCEPTION_RECORD *ExceptionRecord;
    PVOID ExceptionAddress;
    ULONG NumberParameters;
    ULONG_PTR ExceptionInformation[EXCEPTION_MAXIMUM_PARAMETERS];
    } EXCEPTION_RECORD;

typedef EXCEPTION_RECORD *PEXCEPTION_RECORD;

typedef struct _EXCEPTION_RECORD32 {
    NTSTATUS ExceptionCode;
    ULONG ExceptionFlags;
    ULONG ExceptionRecord;
    ULONG ExceptionAddress;
    ULONG NumberParameters;
    ULONG ExceptionInformation[EXCEPTION_MAXIMUM_PARAMETERS];
} EXCEPTION_RECORD32, *PEXCEPTION_RECORD32;

typedef struct _EXCEPTION_RECORD64 {
    NTSTATUS ExceptionCode;
    ULONG ExceptionFlags;
    ULONG64 ExceptionRecord;
    ULONG64 ExceptionAddress;
    ULONG NumberParameters;
    ULONG __unusedAlignment;
    ULONG64 ExceptionInformation[EXCEPTION_MAXIMUM_PARAMETERS];
} EXCEPTION_RECORD64, *PEXCEPTION_RECORD64;

//
// Typedef for pointer returned by exception_info()
//

typedef struct _EXCEPTION_POINTERS {
    PEXCEPTION_RECORD ExceptionRecord;
    PCONTEXT ContextRecord;
} EXCEPTION_POINTERS, *PEXCEPTION_POINTERS;


#define THREAD_WAIT_OBJECTS 3           // Builtin usable wait blocks



//
// Several routines have an architecture specific implementation. Generate
// an error if a supported target is not defined.
//

#if !(defined(_X86_) || defined(_AMD64_) || defined(_IA64_))

#error "No target architecture defined"

#endif



//
// Interrupt modes.
//

typedef enum _KINTERRUPT_MODE {
    LevelSensitive,
    Latched
} KINTERRUPT_MODE;

typedef enum _KINTERRUPT_POLARITY {
    InterruptPolarityUnknown,
    InterruptActiveHigh,
    InterruptActiveLow
} KINTERRUPT_POLARITY, *PKINTERRUPT_POLARITY;


//
// Wait reasons
//

typedef enum _KWAIT_REASON {
    Executive,
    FreePage,
    PageIn,
    PoolAllocation,
    DelayExecution,
    Suspended,
    UserRequest,
    WrExecutive,
    WrFreePage,
    WrPageIn,
    WrPoolAllocation,
    WrDelayExecution,
    WrSuspended,
    WrUserRequest,
    WrEventPair,
    WrQueue,
    WrLpcReceive,
    WrLpcReply,
    WrVirtualMemory,
    WrPageOut,
    WrRendezvous,
    Spare2,
    Spare3,
    Spare4,
    Spare5,
    WrCalloutStack,
    WrKernel,
    WrResource,
    WrPushLock,
    WrMutex,
    WrQuantumEnd,
    WrDispatchInt,
    WrPreempted,
    WrYieldExecution,
    WrFastMutex,
    WrGuardedMutex,
    WrRundown,
    MaximumWaitReason
} KWAIT_REASON;


typedef struct _KWAIT_BLOCK {
    LIST_ENTRY WaitListEntry;
    struct _KTHREAD *Thread;
    PVOID Object;
    struct _KWAIT_BLOCK *NextWaitBlock;
    USHORT WaitKey;
    UCHAR WaitType;
    UCHAR SpareByte;

#if defined(_AMD64_)

    LONG SpareLong;

#endif

} KWAIT_BLOCK, *PKWAIT_BLOCK, *PRKWAIT_BLOCK;

//
// Thread start function
//

typedef
VOID
(*PKSTART_ROUTINE) (
    IN PVOID StartContext
    );

//
// Kernel object structure definitions
//

//
// Device Queue object and entry
//

#define ASSERT_DEVICE_QUEUE(E) NT_ASSERT((E)->Type == DeviceQueueObject)

typedef struct _KDEVICE_QUEUE {
    CSHORT Type;
    CSHORT Size;
    LIST_ENTRY DeviceListHead;
    KSPIN_LOCK Lock;

#if defined(_AMD64_)

    union {
        BOOLEAN Busy;
        struct {
            LONG64 Reserved : 8;
            LONG64 Hint : 56;
        };
    };

#else

    BOOLEAN Busy;

#endif

} KDEVICE_QUEUE, *PKDEVICE_QUEUE, *PRKDEVICE_QUEUE;

typedef struct _KDEVICE_QUEUE_ENTRY {
    LIST_ENTRY DeviceListEntry;
    ULONG SortKey;
    BOOLEAN Inserted;
} KDEVICE_QUEUE_ENTRY, *PKDEVICE_QUEUE_ENTRY, *PRKDEVICE_QUEUE_ENTRY;

//
// Define the interrupt service function type and the empty struct
// type.
//

typedef
BOOLEAN
KSERVICE_ROUTINE (
    IN struct _KINTERRUPT *Interrupt,
    IN PVOID ServiceContext
    );

typedef KSERVICE_ROUTINE *PKSERVICE_ROUTINE;

typedef
BOOLEAN
KMESSAGE_SERVICE_ROUTINE (
    IN struct _KINTERRUPT *Interrupt,
    IN PVOID ServiceContext,
    IN ULONG MessageID
    );

typedef KMESSAGE_SERVICE_ROUTINE *PKMESSAGE_SERVICE_ROUTINE;

//
// Mutant object
//

#define ASSERT_MUTANT(E) NT_ASSERT((E)->Header.Type == MutantObject)

typedef struct _KMUTANT {
    DISPATCHER_HEADER Header;
    LIST_ENTRY MutantListEntry;
    struct _KTHREAD *OwnerThread;
    BOOLEAN Abandoned;
    UCHAR ApcDisable;
} KMUTANT, *PKMUTANT, *PRKMUTANT, KMUTEX, *PKMUTEX, *PRKMUTEX;

//
//
// Semaphore object
//
// N.B. The limit field must be the last member of this structure.
//

#define ASSERT_SEMAPHORE(E) NT_ASSERT((E)->Header.Type == SemaphoreObject)

typedef struct _KSEMAPHORE {
    DISPATCHER_HEADER Header;
    LONG Limit;
} KSEMAPHORE, *PKSEMAPHORE, *PRKSEMAPHORE;

#define KSEMAPHORE_ACTUAL_LENGTH                                             \
    (FIELD_OFFSET(KSEMAPHORE, Limit) + sizeof(LONG))

//
// DPC object
//

#if (NTDDI_VERSION >= NTDDI_WIN2K)
NTKERNELAPI
VOID
KeInitializeDpc (
    __out PRKDPC Dpc,
    __in PKDEFERRED_ROUTINE DeferredRoutine,
    __in_opt PVOID DeferredContext
    );
#endif


#if (NTDDI_VERSION >= NTDDI_WIN2K)
NTKERNELAPI
BOOLEAN
KeInsertQueueDpc (
    __inout PRKDPC Dpc,
    __in_opt PVOID SystemArgument1,
    __in_opt PVOID SystemArgument2
    );
#endif

#if (NTDDI_VERSION >= NTDDI_WIN2K)
NTKERNELAPI
BOOLEAN
KeRemoveQueueDpc (
    __inout PRKDPC Dpc
    );
#endif



#if (NTDDI_VERSION >= NTDDI_WIN2K)
NTKERNELAPI
VOID
KeSetImportanceDpc (
    __inout PRKDPC Dpc,
    __in KDPC_IMPORTANCE Importance
    );
#endif

#if (NTDDI_VERSION >= NTDDI_WIN2K)
NTKERNELAPI
VOID
KeSetTargetProcessorDpc (
    __inout PRKDPC Dpc,
    __in CCHAR Number
    );
#endif



#if (NTDDI_VERSION >= NTDDI_WINXPSP2)
NTKERNELAPI
VOID
KeFlushQueuedDpcs (
    VOID
    );
#endif

//
// Device queue object
//

#if (NTDDI_VERSION >= NTDDI_WIN2K)
NTKERNELAPI
VOID
KeInitializeDeviceQueue (
    __out PKDEVICE_QUEUE DeviceQueue
    );
#endif

#if (NTDDI_VERSION >= NTDDI_WIN2K)
NTKERNELAPI
BOOLEAN
KeInsertDeviceQueue (
    __inout PKDEVICE_QUEUE DeviceQueue,
    __inout PKDEVICE_QUEUE_ENTRY DeviceQueueEntry
    );
#endif

#if (NTDDI_VERSION >= NTDDI_WIN2K)
NTKERNELAPI
BOOLEAN
KeInsertByKeyDeviceQueue (
    __inout PKDEVICE_QUEUE DeviceQueue,
    __inout PKDEVICE_QUEUE_ENTRY DeviceQueueEntry,
    __in ULONG SortKey
    );
#endif

#if (NTDDI_VERSION >= NTDDI_WIN2K)
NTKERNELAPI
PKDEVICE_QUEUE_ENTRY
KeRemoveDeviceQueue (
    __inout PKDEVICE_QUEUE DeviceQueue
    );
#endif

#if (NTDDI_VERSION >= NTDDI_WIN2K)
NTKERNELAPI
PKDEVICE_QUEUE_ENTRY
KeRemoveByKeyDeviceQueue (
    __inout PKDEVICE_QUEUE DeviceQueue,
    __in ULONG SortKey
    );
#endif

#if (NTDDI_VERSION >= NTDDI_WINXP)
NTKERNELAPI
PKDEVICE_QUEUE_ENTRY
KeRemoveByKeyDeviceQueueIfBusy (
    __inout PKDEVICE_QUEUE DeviceQueue,
    __in ULONG SortKey
    );
#endif

#if (NTDDI_VERSION >= NTDDI_WIN2K)
NTKERNELAPI
BOOLEAN
KeRemoveEntryDeviceQueue (
    __inout PKDEVICE_QUEUE DeviceQueue,
    __inout PKDEVICE_QUEUE_ENTRY DeviceQueueEntry
    );
#endif


#if (NTDDI_VERSION >= NTDDI_WIN2K)
NTKERNELAPI
BOOLEAN
KeSynchronizeExecution (
    __inout PKINTERRUPT Interrupt,
    __in PKSYNCHRONIZE_ROUTINE SynchronizeRoutine,
    __in_opt PVOID SynchronizeContext
    );
#endif

#if (NTDDI_VERSION >= NTDDI_WINXP)
NTKERNELAPI
KIRQL
KeAcquireInterruptSpinLock (
    __inout PKINTERRUPT Interrupt
    );
#endif

#if (NTDDI_VERSION >= NTDDI_WINXP)
NTKERNELAPI
VOID
KeReleaseInterruptSpinLock (
    __inout PKINTERRUPT Interrupt,
    __in KIRQL OldIrql
    );
#endif

//
// Kernel dispatcher object functions
//
// Event Object
//

NTKERNELAPI
VOID
KeInitializeEvent (
    __out PRKEVENT Event,
    __in EVENT_TYPE Type,
    __in BOOLEAN State
    );

NTKERNELAPI
VOID
KeClearEvent (
    __inout PRKEVENT Event
    );


#if (NTDDI_VERSION >= NTDDI_WIN2K)
NTKERNELAPI
LONG
KeReadStateEvent (
    __in PRKEVENT Event
    );
#endif

#if (NTDDI_VERSION >= NTDDI_WIN2K)
NTKERNELAPI
LONG
KeResetEvent (
    __inout PRKEVENT Event
    );
#endif

#if (NTDDI_VERSION >= NTDDI_WIN2K)
NTKERNELAPI
LONG
KeSetEvent (
    __inout PRKEVENT Event,
    __in KPRIORITY Increment,
    __in BOOLEAN Wait
    );
#endif

//
// Mutex object
//

#if (NTDDI_VERSION >= NTDDI_WIN2K)
NTKERNELAPI
VOID
KeInitializeMutex (
    __out PRKMUTEX Mutex,
    __in ULONG Level
    );
#endif

#if (NTDDI_VERSION >= NTDDI_WIN2K)
NTKERNELAPI
LONG
KeReadStateMutex (
    __in PRKMUTEX Mutex
    );
#endif

#if (NTDDI_VERSION >= NTDDI_WIN2K)
NTKERNELAPI
LONG
KeReleaseMutex (
    __inout PRKMUTEX Mutex,
    __in BOOLEAN Wait
    );
#endif

//
// Semaphore object
//

#if (NTDDI_VERSION >= NTDDI_WIN2K)
NTKERNELAPI
VOID
KeInitializeSemaphore (
    __out PRKSEMAPHORE Semaphore,
    __in LONG Count,
    __in LONG Limit
    );
#endif

#if (NTDDI_VERSION >= NTDDI_WIN2K)
NTKERNELAPI
LONG
KeReadStateSemaphore (
    __in PRKSEMAPHORE Semaphore
    );
#endif

#if (NTDDI_VERSION >= NTDDI_WIN2K)
NTKERNELAPI
LONG
KeReleaseSemaphore (
    __inout PRKSEMAPHORE Semaphore,
    __in KPRIORITY Increment,
    __in LONG Adjustment,
    __in BOOLEAN Wait
    );
#endif


#if (NTDDI_VERSION >= NTDDI_WIN2K)
NTKERNELAPI
NTSTATUS
KeDelayExecutionThread (
    __in KPROCESSOR_MODE WaitMode,
    __in BOOLEAN Alertable,
    __in PLARGE_INTEGER Interval
    );
#endif


#if (NTDDI_VERSION >= NTDDI_WIN2K)
NTKERNELAPI
KPRIORITY
KeQueryPriorityThread (
    __in PKTHREAD Thread
    );
#endif

#if (NTDDI_VERSION >= NTDDI_WINXP)
NTKERNELAPI
ULONG
KeQueryRuntimeThread (
    __in PKTHREAD Thread,
    __out PULONG UserTime
    );
#endif


#if (NTDDI_VERSION >= NTDDI_WIN2K)
NTKERNELAPI
VOID
KeRevertToUserAffinityThread (
    VOID
    );
#endif

#if (NTDDI_VERSION >= NTDDI_WIN2K)
NTKERNELAPI
VOID
KeSetSystemAffinityThread (
    __in KAFFINITY Affinity
    );
#endif

#if (NTDDI_VERSION >= NTDDI_VISTA)
NTKERNELAPI
VOID
KeRevertToUserAffinityThreadEx (
    __in KAFFINITY Affinity
    );
#endif

#if (NTDDI_VERSION >= NTDDI_VISTA)
NTKERNELAPI
KAFFINITY
KeSetSystemAffinityThreadEx (
    __in KAFFINITY Affinity
    );
#endif

#if (NTDDI_VERSION >= NTDDI_WIN2K)
NTKERNELAPI
KPRIORITY
KeSetPriorityThread (
    __inout PKTHREAD Thread,
    __in KPRIORITY Priority
    );
#endif



#if (NTDDI_VERSION >= NTDDI_WIN2K)
NTKERNELAPI
VOID
KeEnterCriticalRegion (
    VOID
    );
#endif

#if (NTDDI_VERSION >= NTDDI_WIN2K)
NTKERNELAPI
VOID
KeLeaveCriticalRegion (
    VOID
    );
#endif

#if (NTDDI_VERSION >= NTDDI_WS03SP1)
NTKERNELAPI
VOID
KeEnterGuardedRegion (
    VOID
    );
#endif

#if (NTDDI_VERSION >= NTDDI_WS03SP1)
NTKERNELAPI
VOID
KeLeaveGuardedRegion (
    VOID
    );
#endif

#if (NTDDI_VERSION >= NTDDI_WINXP)
NTKERNELAPI
BOOLEAN
KeAreApcsDisabled (
    VOID
    );
#endif



//
// Timer object
//

#if (NTDDI_VERSION >= NTDDI_WIN2K)
NTKERNELAPI
VOID
KeInitializeTimer (
    __out PKTIMER Timer
    );
#endif

#if (NTDDI_VERSION >= NTDDI_WIN2K)
NTKERNELAPI
VOID
KeInitializeTimerEx (
    __out PKTIMER Timer,
    __in TIMER_TYPE Type
    );
#endif

#if (NTDDI_VERSION >= NTDDI_WIN2K)
NTKERNELAPI
BOOLEAN
KeCancelTimer (
    __inout PKTIMER
    );
#endif

#if (NTDDI_VERSION >= NTDDI_WIN2K)
NTKERNELAPI
BOOLEAN
KeReadStateTimer (
    __in PKTIMER Timer
    );
#endif

#if (NTDDI_VERSION >= NTDDI_WIN2K)
NTKERNELAPI
BOOLEAN
KeSetTimer (
    __inout PKTIMER Timer,
    __in LARGE_INTEGER DueTime,
    __in_opt PKDPC Dpc
    );
#endif

#if (NTDDI_VERSION >= NTDDI_WIN2K)
NTKERNELAPI
BOOLEAN
KeSetTimerEx (
    __inout PKTIMER Timer,
    __in LARGE_INTEGER DueTime,
    __in LONG Period,
    __in_opt PKDPC Dpc
    );
#endif


#define KeWaitForMutexObject KeWaitForSingleObject

#if (NTDDI_VERSION >= NTDDI_WIN2K)
NTKERNELAPI
NTSTATUS
KeWaitForMultipleObjects (
    __in ULONG Count,
    __in_ecount(Count) PVOID Object[],
    __in WAIT_TYPE WaitType,
    __in KWAIT_REASON WaitReason,
    __in KPROCESSOR_MODE WaitMode,
    __in BOOLEAN Alertable,
    __in_opt PLARGE_INTEGER Timeout,
    __out_opt PKWAIT_BLOCK WaitBlockArray
    );
#endif

#if (NTDDI_VERSION >= NTDDI_WIN2K)
NTKERNELAPI
NTSTATUS
KeWaitForSingleObject (
    __in PVOID Object,
    __in KWAIT_REASON WaitReason,
    __in KPROCESSOR_MODE WaitMode,
    __in BOOLEAN Alertable,
    __in_opt PLARGE_INTEGER Timeout
    );
#endif

//
// Define interprocess interrupt generic call types.
//

typedef
ULONG_PTR
(*PKIPI_BROADCAST_WORKER)(
    IN ULONG_PTR Argument
    );

#if (NTDDI_VERSION >= NTDDI_WS03)
NTKERNELAPI
ULONG_PTR
KeIpiGenericCall (
    IN PKIPI_BROADCAST_WORKER BroadcastFunction,
    IN ULONG_PTR Context
    );
#endif

//
// spin lock functions
//

#if defined(_X86_) && (defined(_WDM_INCLUDED_) || defined(WIN9X_COMPAT_SPINLOCK))

#if (NTDDI_VERSION >= NTDDI_WIN2K)
NTKERNELAPI
VOID
NTAPI
KeInitializeSpinLock (
    __out PKSPIN_LOCK SpinLock
    );
#endif

#else

FORCEINLINE
VOID
NTAPI
KeInitializeSpinLock (
    __out PKSPIN_LOCK SpinLock
    )
{
    *SpinLock = 0;
}

#endif



#if (NTDDI_VERSION >= NTDDI_WS03)
NTKERNELAPI
BOOLEAN
FASTCALL
KeTestSpinLock (
    __in PKSPIN_LOCK SpinLock
    );
#endif

#if (NTDDI_VERSION >= NTDDI_WS03SP1)
NTKERNELAPI
BOOLEAN
FASTCALL
KeTryToAcquireSpinLockAtDpcLevel (
    __inout PKSPIN_LOCK SpinLock
    );
#endif

#if defined(_X86_)   // ntifs

#if (NTDDI_VERSION >= NTDDI_WIN2K)
NTKERNELAPI
VOID
FASTCALL
KefAcquireSpinLockAtDpcLevel (
    __inout PKSPIN_LOCK SpinLock
    );
#endif

#if (NTDDI_VERSION >= NTDDI_WIN2K)
NTKERNELAPI
VOID
FASTCALL
KefReleaseSpinLockFromDpcLevel (
    __inout PKSPIN_LOCK SpinLock
    );
#endif

#define KeAcquireSpinLockAtDpcLevel(a) KefAcquireSpinLockAtDpcLevel(a)
#define KeReleaseSpinLockFromDpcLevel(a) KefReleaseSpinLockFromDpcLevel(a)

#if (NTDDI_VERSION >= NTDDI_WIN2K)
_DECL_HAL_KE_IMPORT
KIRQL
FASTCALL
KfAcquireSpinLock (
    __inout PKSPIN_LOCK SpinLock
    );
#endif

#if (NTDDI_VERSION >= NTDDI_WIN2K)
_DECL_HAL_KE_IMPORT
VOID
FASTCALL
KfReleaseSpinLock (
    __inout PKSPIN_LOCK SpinLock,
    __in KIRQL NewIrql
    );
#endif


#define KeAcquireSpinLock(a,b) *(b) = KfAcquireSpinLock(a)
#define KeReleaseSpinLock(a,b) KfReleaseSpinLock(a,b)

#else // ntifs

//
// These functions are imported for IA64, ntddk, ntifs, nthal, ntosp, and wdm.
// They can be inlined for the system on AMD64.
//

#define KeAcquireSpinLock(SpinLock, OldIrql) \
    *(OldIrql) = KeAcquireSpinLockRaiseToDpc(SpinLock)


#if (NTDDI_VERSION >= NTDDI_WIN2K)
NTKERNELAPI
VOID
KeAcquireSpinLockAtDpcLevel (
    __inout PKSPIN_LOCK SpinLock
    );
#endif

#if (NTDDI_VERSION >= NTDDI_WIN2K)
NTKERNELAPI
KIRQL
KeAcquireSpinLockRaiseToDpc (
    __inout PKSPIN_LOCK SpinLock
    );
#endif

#if (NTDDI_VERSION >= NTDDI_WIN2K)
NTKERNELAPI
VOID
KeReleaseSpinLock (
    __inout PKSPIN_LOCK SpinLock,
    __in KIRQL NewIrql
    );
#endif

#if (NTDDI_VERSION >= NTDDI_WIN2K)
NTKERNELAPI
VOID
KeReleaseSpinLockFromDpcLevel (
    __inout PKSPIN_LOCK SpinLock
    );
#endif

#endif // ntifs



#if (NTDDI_VERSION >= NTDDI_WS03)
NTKERNELAPI
KIRQL
FASTCALL
KeAcquireSpinLockForDpc (
    __inout PKSPIN_LOCK SpinLock
    );
#endif

#if (NTDDI_VERSION >= NTDDI_WS03)
NTKERNELAPI
VOID
FASTCALL
KeReleaseSpinLockForDpc (
    __inout PKSPIN_LOCK SpinLock,
    __in KIRQL OldIrql
    );
#endif



//
// Queued spin lock functions for "in stack" lock handles.
//
// The following three functions RAISE and LOWER IRQL when a queued
// in stack spin lock is acquired or released using these routines.
//

#if (NTDDI_VERSION >= NTDDI_WINXP)
_DECL_HAL_KE_IMPORT
VOID
FASTCALL
KeAcquireInStackQueuedSpinLock (
    __inout PKSPIN_LOCK SpinLock,
    __out PKLOCK_QUEUE_HANDLE LockHandle
    );
#endif

#if (NTDDI_VERSION >= NTDDI_WINXP)
_DECL_HAL_KE_IMPORT
VOID
FASTCALL
KeReleaseInStackQueuedSpinLock (
    __in PKLOCK_QUEUE_HANDLE LockHandle
    );
#endif

//
// The following two functions do NOT raise or lower IRQL when a queued
// in stack spin lock is acquired or released using these functions.
//

#if (NTDDI_VERSION >= NTDDI_WINXP)
NTKERNELAPI
VOID
FASTCALL
KeAcquireInStackQueuedSpinLockAtDpcLevel (
    __inout PKSPIN_LOCK SpinLock,
    __out PKLOCK_QUEUE_HANDLE LockHandle
    );
#endif

#if (NTDDI_VERSION >= NTDDI_WINXP)
NTKERNELAPI
VOID
FASTCALL
KeReleaseInStackQueuedSpinLockFromDpcLevel (
    __in PKLOCK_QUEUE_HANDLE LockHandle
    );
#endif

//
// The following two functions conditionally raise or lower IRQL when a
// queued in-stack spin lock is acquired or released using these functions.
//

#if (NTDDI_VERSION >= NTDDI_VISTA)
NTKERNELAPI
VOID
FASTCALL
KeAcquireInStackQueuedSpinLockForDpc (
    __inout PKSPIN_LOCK SpinLock,
    __out PKLOCK_QUEUE_HANDLE LockHandle
    );
#endif

#if (NTDDI_VERSION >= NTDDI_VISTA)
NTKERNELAPI
VOID
FASTCALL
KeReleaseInStackQueuedSpinLockForDpc (
    __in PKLOCK_QUEUE_HANDLE LockHandle
    );
#endif

//
// Miscellaneous kernel functions
//

typedef struct _KDPC_WATCHDOG_INFORMATION {
    ULONG DpcTimeLimit;
    ULONG DpcTimeCount;
    ULONG DpcWatchdogLimit;
    ULONG DpcWatchdogCount;
    ULONG Reserved;
} KDPC_WATCHDOG_INFORMATION, *PKDPC_WATCHDOG_INFORMATION;

#if (NTDDI_VERSION >= NTDDI_VISTA)
NTKERNELAPI
NTSTATUS
KeQueryDpcWatchdogInformation (
    __out PKDPC_WATCHDOG_INFORMATION WatchdogInformation
    );
#endif

typedef enum _KBUGCHECK_BUFFER_DUMP_STATE {
    BufferEmpty,
    BufferInserted,
    BufferStarted,
    BufferFinished,
    BufferIncomplete
} KBUGCHECK_BUFFER_DUMP_STATE;

typedef
VOID
(*PKBUGCHECK_CALLBACK_ROUTINE) (
    IN PVOID Buffer,
    IN ULONG Length
    );

typedef struct _KBUGCHECK_CALLBACK_RECORD {
    LIST_ENTRY Entry;
    PKBUGCHECK_CALLBACK_ROUTINE CallbackRoutine;
    __field_bcount_opt(Length) PVOID Buffer;
    ULONG Length;
    PUCHAR Component;
    ULONG_PTR Checksum;
    UCHAR State;
} KBUGCHECK_CALLBACK_RECORD, *PKBUGCHECK_CALLBACK_RECORD;

#define KeInitializeCallbackRecord(CallbackRecord) \
    (CallbackRecord)->State = BufferEmpty

#if (NTDDI_VERSION >= NTDDI_WIN2K)
NTKERNELAPI
BOOLEAN
KeDeregisterBugCheckCallback (
    __inout PKBUGCHECK_CALLBACK_RECORD CallbackRecord
    );
#endif

#if (NTDDI_VERSION >= NTDDI_WIN2K)
NTKERNELAPI
BOOLEAN
KeRegisterBugCheckCallback (
    __out PKBUGCHECK_CALLBACK_RECORD CallbackRecord,
    __in PKBUGCHECK_CALLBACK_ROUTINE CallbackRoutine,
    __in_bcount_opt(Length) PVOID Buffer,
    __in ULONG Length,
    __in PUCHAR Component
    );
#endif

typedef enum _KBUGCHECK_CALLBACK_REASON {
    KbCallbackInvalid,
    KbCallbackReserved1,
    KbCallbackSecondaryDumpData,
    KbCallbackDumpIo,
    KbCallbackAddPages
} KBUGCHECK_CALLBACK_REASON;

typedef
VOID
(*PKBUGCHECK_REASON_CALLBACK_ROUTINE) (
    IN KBUGCHECK_CALLBACK_REASON Reason,
    IN struct _KBUGCHECK_REASON_CALLBACK_RECORD* Record,
    IN OUT PVOID ReasonSpecificData,
    IN ULONG ReasonSpecificDataLength
    );

typedef struct _KBUGCHECK_REASON_CALLBACK_RECORD {
    LIST_ENTRY Entry;
    PKBUGCHECK_REASON_CALLBACK_ROUTINE CallbackRoutine;
    PUCHAR Component;
    ULONG_PTR Checksum;
    KBUGCHECK_CALLBACK_REASON Reason;
    UCHAR State;
} KBUGCHECK_REASON_CALLBACK_RECORD, *PKBUGCHECK_REASON_CALLBACK_RECORD;

typedef struct _KBUGCHECK_SECONDARY_DUMP_DATA {
    IN PVOID InBuffer;
    IN ULONG InBufferLength;
    IN ULONG MaximumAllowed;
    OUT GUID Guid;
    OUT PVOID OutBuffer;
    OUT ULONG OutBufferLength;
} KBUGCHECK_SECONDARY_DUMP_DATA, *PKBUGCHECK_SECONDARY_DUMP_DATA;

typedef enum _KBUGCHECK_DUMP_IO_TYPE {
    KbDumpIoInvalid,
    KbDumpIoHeader,
    KbDumpIoBody,
    KbDumpIoSecondaryData,
    KbDumpIoComplete
} KBUGCHECK_DUMP_IO_TYPE;

typedef struct _KBUGCHECK_DUMP_IO {
    IN ULONG64 Offset;
    IN PVOID Buffer;
    IN ULONG BufferLength;
    IN KBUGCHECK_DUMP_IO_TYPE Type;
} KBUGCHECK_DUMP_IO, *PKBUGCHECK_DUMP_IO;

#define KB_ADD_PAGES_FLAG_VIRTUAL_ADDRESS           0x00000001UL
#define KB_ADD_PAGES_FLAG_PHYSICAL_ADDRESS          0x00000002UL
#define KB_ADD_PAGES_FLAG_ADDITIONAL_RANGES_EXIST   0x80000000UL

typedef struct _KBUGCHECK_ADD_PAGES {
    __inout PVOID Context;      // Private context for callback use
    __inout ULONG Flags;        // Zero initialized on input
    __reserved ULONG Reserved;
    __out ULONG_PTR Address;
    __out ULONG_PTR Count;
} KBUGCHECK_ADD_PAGES, *PKBUGCHECK_ADD_PAGES;

//
// Equates for exceptions which cause system fatal error
//

#define EXCEPTION_DIVIDED_BY_ZERO       0
#define EXCEPTION_DEBUG                 1
#define EXCEPTION_NMI                   2
#define EXCEPTION_INT3                  3
#define EXCEPTION_BOUND_CHECK           5
#define EXCEPTION_INVALID_OPCODE        6
#define EXCEPTION_NPX_NOT_AVAILABLE     7
#define EXCEPTION_DOUBLE_FAULT          8
#define EXCEPTION_NPX_OVERRUN           9
#define EXCEPTION_INVALID_TSS           0x0A
#define EXCEPTION_SEGMENT_NOT_PRESENT   0x0B
#define EXCEPTION_STACK_FAULT           0x0C
#define EXCEPTION_GP_FAULT              0x0D
#define EXCEPTION_RESERVED_TRAP         0x0F
#define EXCEPTION_NPX_ERROR             0x010
#define EXCEPTION_ALIGNMENT_CHECK       0x011

#if (NTDDI_VERSION >= NTDDI_WINXPSP1)
NTKERNELAPI
BOOLEAN
KeDeregisterBugCheckReasonCallback (
    __inout PKBUGCHECK_REASON_CALLBACK_RECORD CallbackRecord
    );
#endif

#if (NTDDI_VERSION >= NTDDI_WINXPSP1)
NTKERNELAPI
BOOLEAN
KeRegisterBugCheckReasonCallback (
    __out PKBUGCHECK_REASON_CALLBACK_RECORD CallbackRecord,
    __in PKBUGCHECK_REASON_CALLBACK_ROUTINE CallbackRoutine,
    __in KBUGCHECK_CALLBACK_REASON Reason,
    __in PUCHAR Component
    );
#endif

typedef
BOOLEAN
(*PNMI_CALLBACK)(
    __in_opt PVOID Context,
    __in BOOLEAN Handled
    );

#if (NTDDI_VERSION >= NTDDI_WS03)
NTKERNELAPI
PVOID
KeRegisterNmiCallback (
    __in PNMI_CALLBACK CallbackRoutine,
    __in_opt PVOID Context
    );
#endif

#if (NTDDI_VERSION >= NTDDI_WS03)
NTKERNELAPI
NTSTATUS
KeDeregisterNmiCallback (
    __in PVOID Handle
    );
#endif


#if (NTDDI_VERSION >= NTDDI_WIN2K)
NTKERNELAPI
DECLSPEC_NORETURN
VOID
NTAPI
KeBugCheckEx(
    __in ULONG BugCheckCode,
    __in ULONG_PTR BugCheckParameter1,
    __in ULONG_PTR BugCheckParameter2,
    __in ULONG_PTR BugCheckParameter3,
    __in ULONG_PTR BugCheckParameter4
    );
#endif

#if !defined(_AMD64_)

#if (NTDDI_VERSION >= NTDDI_WIN2K)
NTKERNELAPI
ULONGLONG
KeQueryInterruptTime (
    VOID
    );
#endif

#if (NTDDI_VERSION >= NTDDI_WIN2K)
NTKERNELAPI
VOID
KeQuerySystemTime (
    OUT PLARGE_INTEGER CurrentTime
    );
#endif

#endif // !_AMD64_

#if (NTDDI_VERSION >= NTDDI_WIN2K)
NTKERNELAPI
ULONG
KeQueryTimeIncrement (
    VOID
    );
#endif

#if (NTDDI_VERSION >= NTDDI_WINXP)
NTKERNELAPI
ULONG
KeGetRecommendedSharedDataAlignment (
    VOID
    );
#endif


#if defined(_IA64_)

extern volatile LARGE_INTEGER KeTickCount;

#elif defined(_X86_)

extern volatile KSYSTEM_TIME KeTickCount;

#endif


typedef enum _MEMORY_CACHING_TYPE_ORIG {
    MmFrameBufferCached = 2
} MEMORY_CACHING_TYPE_ORIG;

typedef enum _MEMORY_CACHING_TYPE {
    MmNonCached = FALSE,
    MmCached = TRUE,
    MmWriteCombined = MmFrameBufferCached,
    MmHardwareCoherentCached,
    MmNonCachedUnordered,       // IA64
    MmUSWCCached,
    MmMaximumCacheType
} MEMORY_CACHING_TYPE;

#define GM_LOCK_BIT          0x1 // Actual lock bit, 0 = Unlocked, 1 = Locked
#define GM_LOCK_BIT_V        0x0 // Lock bit as a bit number
#define GM_LOCK_WAITER_WOKEN 0x2 // A single waiter has been woken to acquire this lock
#define GM_LOCK_WAITER_INC   0x4 // Increment value to change the waiters count

typedef struct _KGUARDED_MUTEX {
    volatile LONG Count;
    PKTHREAD Owner;
    ULONG Contention;
    KGATE Gate;
    union {
        struct {
            SHORT KernelApcDisable;
            SHORT SpecialApcDisable;
        };

        ULONG CombinedApcDisable;
    };

} KGUARDED_MUTEX, *PKGUARDED_MUTEX;


#if (NTDDI_VERSION >= NTDDI_WS03SP1)
NTKERNELAPI
BOOLEAN
KeAreAllApcsDisabled (
    VOID
    );
#endif

#if (NTDDI_VERSION >= NTDDI_WS03SP1)
NTKERNELAPI
VOID
FASTCALL
KeInitializeGuardedMutex (
    __out PKGUARDED_MUTEX Mutex
    );
#endif

#if (NTDDI_VERSION >= NTDDI_WS03SP1)
NTKERNELAPI
VOID
FASTCALL
KeAcquireGuardedMutex (
    __inout PKGUARDED_MUTEX Mutex
    );
#endif

#if (NTDDI_VERSION >= NTDDI_WS03SP1)
NTKERNELAPI
VOID
FASTCALL
KeReleaseGuardedMutex (
    __inout PKGUARDED_MUTEX Mutex
    );
#endif

#if (NTDDI_VERSION >= NTDDI_WS03SP1)
NTKERNELAPI
BOOLEAN
FASTCALL
KeTryToAcquireGuardedMutex (
    __inout PKGUARDED_MUTEX Mutex
    );
#endif

#if (NTDDI_VERSION >= NTDDI_WS03SP1)
NTKERNELAPI
VOID
FASTCALL
KeAcquireGuardedMutexUnsafe (
    __inout PKGUARDED_MUTEX FastMutex
    );
#endif

#if (NTDDI_VERSION >= NTDDI_WS03SP1)
NTKERNELAPI
VOID
FASTCALL
KeReleaseGuardedMutexUnsafe (
    __inout PKGUARDED_MUTEX FastMutex
    );
#endif


//
// Define dynamic processor add types.
//

typedef enum {
    KeProcessorAddStartNotify = 0,
    KeProcessorAddCompleteNotify,
    KeProcessorAddFailureNotify
} KE_PROCESSOR_CHANGE_NOTIFY_STATE;

typedef struct _KE_PROCESSOR_CHANGE_NOTIFY_CONTEXT {
    KE_PROCESSOR_CHANGE_NOTIFY_STATE State;
    ULONG NtNumber;
    NTSTATUS Status;


} KE_PROCESSOR_CHANGE_NOTIFY_CONTEXT, *PKE_PROCESSOR_CHANGE_NOTIFY_CONTEXT;

typedef
VOID
(*PPROCESSOR_CALLBACK_FUNCTION) (
    __in PVOID CallbackContext,
    __in PKE_PROCESSOR_CHANGE_NOTIFY_CONTEXT ChangeContext,
    __inout PNTSTATUS OperationStatus
    );

#define KE_PROCESSOR_CHANGE_ADD_EXISTING 1

#if (NTDDI_VERSION >= NTDDI_WS08)
PVOID
KeRegisterProcessorChangeCallback (
    __in PPROCESSOR_CALLBACK_FUNCTION CallbackFunction,
    __in PVOID CallbackContext,
    __in ULONG Flags
    );
#endif

#if (NTDDI_VERSION >= NTDDI_WS08)
VOID
KeDeregisterProcessorChangeCallback (
    __in PVOID CallbackHandle
    );
#endif

//
// Define external data.
//

#if defined(_NTDDK_) || defined(_NTIFS_) || defined(_NTHAL_) || defined(_WDMDDK_) || defined(_NTOSP_)

extern PBOOLEAN KdDebuggerNotPresent;
extern PBOOLEAN KdDebuggerEnabled;
#define KD_DEBUGGER_ENABLED     *KdDebuggerEnabled
#define KD_DEBUGGER_NOT_PRESENT *KdDebuggerNotPresent

#else

extern BOOLEAN KdDebuggerNotPresent;
extern BOOLEAN KdDebuggerEnabled;
#define KD_DEBUGGER_ENABLED     KdDebuggerEnabled
#define KD_DEBUGGER_NOT_PRESENT KdDebuggerNotPresent

#endif

#if (NTDDI_VERSION >= NTDDI_WIN2K)
NTKERNELAPI
NTSTATUS
KdDisableDebugger(
    VOID
    );
#endif

#if (NTDDI_VERSION >= NTDDI_WIN2K)
NTKERNELAPI
NTSTATUS
KdEnableDebugger(
    VOID
    );
#endif

//
// KdRefreshDebuggerPresent attempts to communicate with
// the debugger host machine to refresh the state of
// KdDebuggerNotPresent.  It returns the state of
// KdDebuggerNotPresent while the kd locks are held.
// KdDebuggerNotPresent may immediately change state
// after the kd locks are released so it may not
// match the return value.
//

#if (NTDDI_VERSION >= NTDDI_WS03)
NTKERNELAPI
BOOLEAN
KdRefreshDebuggerNotPresent(
    VOID
    );
#endif

typedef enum _KD_OPTION {
    KD_OPTION_SET_BLOCK_ENABLE,
} KD_OPTION;

#if (NTDDI_VERSION >= NTDDI_WS03SP1)
NTSTATUS
KdChangeOption(
    IN KD_OPTION Option,
    IN ULONG InBufferBytes OPTIONAL,
    IN PVOID InBuffer,
    IN ULONG OutBufferBytes OPTIONAL,
    OUT PVOID OutBuffer,
    OUT PULONG OutBufferNeeded OPTIONAL
    );
#endif

//
// Pool Allocation routines (in pool.c)
//

typedef enum _POOL_TYPE {
    NonPagedPool,
    PagedPool,
    NonPagedPoolMustSucceed,
    DontUseThisType,
    NonPagedPoolCacheAligned,
    PagedPoolCacheAligned,
    NonPagedPoolCacheAlignedMustS,
    MaxPoolType,
    //
    // Note these per session types are carefully chosen so that the appropriate
    // masking still applies as well as MaxPoolType above.
    //

    NonPagedPoolSession = 32,
    PagedPoolSession = NonPagedPoolSession + 1,
    NonPagedPoolMustSucceedSession = PagedPoolSession + 1,
    DontUseThisTypeSession = NonPagedPoolMustSucceedSession + 1,
    NonPagedPoolCacheAlignedSession = DontUseThisTypeSession + 1,
    PagedPoolCacheAlignedSession = NonPagedPoolCacheAlignedSession + 1,
    NonPagedPoolCacheAlignedMustSSession = PagedPoolCacheAlignedSession + 1,

    } POOL_TYPE;

#define POOL_COLD_ALLOCATION 256     // Note this cannot encode into the header.


#define POOL_QUOTA_FAIL_INSTEAD_OF_RAISE 8
#define POOL_RAISE_IF_ALLOCATION_FAILURE 16


#if (NTDDI_VERSION >= NTDDI_WIN2K)
DECLSPEC_DEPRECATED_DDK                     // Use ExAllocatePoolWithTag
NTKERNELAPI
__bcount(NumberOfBytes)
PVOID
ExAllocatePool(
    __in POOL_TYPE PoolType,
    __in SIZE_T NumberOfBytes
    );
#endif

#if (NTDDI_VERSION >= NTDDI_WIN2K)
DECLSPEC_DEPRECATED_DDK                     // Use ExAllocatePoolWithQuotaTag
NTKERNELAPI
__bcount(NumberOfBytes)
PVOID
ExAllocatePoolWithQuota(
    __in POOL_TYPE PoolType,
    __in SIZE_T NumberOfBytes
    );
#endif

#if (NTDDI_VERSION >= NTDDI_WIN2K)
NTKERNELAPI
__bcount(NumberOfBytes)
PVOID
NTAPI
ExAllocatePoolWithTag(
    __in POOL_TYPE PoolType,
    __in SIZE_T NumberOfBytes,
    __in ULONG Tag
    );
#endif

//
// _EX_POOL_PRIORITY_ provides a method for the system to handle requests
// intelligently in low resource conditions.
//
// LowPoolPriority should be used when it is acceptable to the driver for the
// mapping request to fail if the system is low on resources.  An example of
// this could be for a non-critical network connection where the driver can
// handle the failure case when system resources are close to being depleted.
//
// NormalPoolPriority should be used when it is acceptable to the driver for the
// mapping request to fail if the system is very low on resources.  An example
// of this could be for a non-critical local filesystem request.
//
// HighPoolPriority should be used when it is unacceptable to the driver for the
// mapping request to fail unless the system is completely out of resources.
// An example of this would be the paging file path in a driver.
//
// SpecialPool can be specified to bound the allocation at a page end (or
// beginning).  This should only be done on systems being debugged as the
// memory cost is expensive.
//
// N.B.  These values are very carefully chosen so that the pool allocation
//       code can quickly crack the priority request.
//

typedef enum _EX_POOL_PRIORITY {
    LowPoolPriority,
    LowPoolPrioritySpecialPoolOverrun = 8,
    LowPoolPrioritySpecialPoolUnderrun = 9,
    NormalPoolPriority = 16,
    NormalPoolPrioritySpecialPoolOverrun = 24,
    NormalPoolPrioritySpecialPoolUnderrun = 25,
    HighPoolPriority = 32,
    HighPoolPrioritySpecialPoolOverrun = 40,
    HighPoolPrioritySpecialPoolUnderrun = 41

    } EX_POOL_PRIORITY;

#if (NTDDI_VERSION >= NTDDI_WIN2K)
NTKERNELAPI
__bcount(NumberOfBytes)
PVOID
NTAPI
ExAllocatePoolWithTagPriority(
    __in POOL_TYPE PoolType,
    __in SIZE_T NumberOfBytes,
    __in ULONG Tag,
    __in EX_POOL_PRIORITY Priority
    );
#endif

#ifndef POOL_TAGGING
#define ExAllocatePoolWithTag(a,b,c) ExAllocatePool(a,b)
#endif //POOL_TAGGING

#if (NTDDI_VERSION >= NTDDI_WIN2K)
NTKERNELAPI
__bcount(NumberOfBytes)
PVOID
ExAllocatePoolWithQuotaTag(
    __in POOL_TYPE PoolType,
    __in SIZE_T NumberOfBytes,
    __in ULONG Tag
    );
#endif

#ifndef POOL_TAGGING
#define ExAllocatePoolWithQuotaTag(a,b,c) ExAllocatePoolWithQuota(a,b)
#endif //POOL_TAGGING

#if (NTDDI_VERSION >= NTDDI_WIN2K)
NTKERNELAPI
VOID
NTAPI
ExFreePool(
    __in PVOID P
    );
#endif


#if (NTDDI_VERSION >= NTDDI_WIN2K)
NTKERNELAPI
VOID
ExFreePoolWithTag(
    __in PVOID P,
    __in ULONG Tag
    );
#endif

//
// Routines to support fast mutexes.
//

typedef struct _FAST_MUTEX {

#define FM_LOCK_BIT          0x1 // Actual lock bit, 1 = Unlocked, 0 = Locked
#define FM_LOCK_BIT_V        0x0 // Lock bit as a bit number
#define FM_LOCK_WAITER_WOKEN 0x2 // A single waiter has been woken to acquire this lock
#define FM_LOCK_WAITER_INC   0x4 // Increment value to change the waiters count

    volatile LONG Count;
    PKTHREAD Owner;
    ULONG Contention;
    KEVENT Gate;
    ULONG OldIrql;
} FAST_MUTEX, *PFAST_MUTEX;

VOID
FORCEINLINE
ExInitializeFastMutex (
    __out PFAST_MUTEX FastMutex
    )
{
    FastMutex->Count = FM_LOCK_BIT;
    FastMutex->Owner = NULL;
    FastMutex->Contention = 0;
    KeInitializeEvent(&FastMutex->Gate, SynchronizationEvent, FALSE);
    return;
}

#if (NTDDI_VERSION >= NTDDI_WIN2K)
NTKERNELAPI
VOID
FASTCALL
ExAcquireFastMutexUnsafe (
    __inout PFAST_MUTEX FastMutex
    );
#endif

#if (NTDDI_VERSION >= NTDDI_WIN2K)
NTKERNELAPI
VOID
FASTCALL
ExReleaseFastMutexUnsafe (
    __inout PFAST_MUTEX FastMutex
    );
#endif


#if defined(_NTHAL_) && defined(_X86_)

NTKERNELAPI
VOID
FASTCALL
ExiAcquireFastMutex (
    __inout PFAST_MUTEX FastMutex
    );

NTKERNELAPI
VOID
FASTCALL
ExiReleaseFastMutex (
    __inout PFAST_MUTEX FastMutex
    );

NTKERNELAPI
BOOLEAN
FASTCALL
ExiTryToAcquireFastMutex (
    __inout PFAST_MUTEX FastMutex
    );

#define ExAcquireFastMutex(FastMutex) ExiAcquireFastMutex(FastMutex)

#define ExReleaseFastMutex(FastMutex) ExiReleaseFastMutex(FastMutex)

#define ExTryToAcquireFastMutex(FastMutex) ExiTryToAcquireFastMutex(FastMutex)

#else

#if (NTDDI_VERSION >= NTDDI_WIN2K)
NTKERNELAPI
VOID
FASTCALL
ExAcquireFastMutex (
    __inout PFAST_MUTEX FastMutex
    );
#endif

#if (NTDDI_VERSION >= NTDDI_WIN2K)
NTKERNELAPI
VOID
FASTCALL
ExReleaseFastMutex (
    __inout PFAST_MUTEX FastMutex
    );
#endif

#if (NTDDI_VERSION >= NTDDI_WIN2K)
NTKERNELAPI
BOOLEAN
FASTCALL
ExTryToAcquireFastMutex (
    __inout PFAST_MUTEX FastMutex
    );
#endif

#endif // _NTHAL_ && _X86_


//

#if defined(_WIN64)

#define ExInterlockedAddLargeStatistic(Addend, Increment)                   \
    (VOID)InterlockedAdd64(&(Addend)->QuadPart, Increment)

#else

#ifdef __cplusplus
extern "C" {
#endif

LONG
_InterlockedAddLargeStatistic (
    IN PLONGLONG Addend,
    IN ULONG Increment
    );

#ifdef __cplusplus
}
#endif

#pragma intrinsic (_InterlockedAddLargeStatistic)

#define ExInterlockedAddLargeStatistic(Addend,Increment)                     \
    (VOID)_InterlockedAddLargeStatistic((PLONGLONG)&(Addend)->QuadPart, Increment)

#endif // defined(_WIN64)



#if (NTDDI_VERSION >= NTDDI_WIN2K)
NTKERNELAPI
LARGE_INTEGER
ExInterlockedAddLargeInteger (
    __inout PLARGE_INTEGER Addend,
    __in LARGE_INTEGER Increment,
    __inout PKSPIN_LOCK Lock
    );
#endif


#if (NTDDI_VERSION >= NTDDI_WIN2K)
NTKERNELAPI
ULONG
FASTCALL
ExInterlockedAddUlong (
    __inout PULONG Addend,
    __in ULONG Increment,
    __inout PKSPIN_LOCK Lock
    );
#endif // NTDDI_VERSION >= NTDDI_WIN2K


#if defined(_AMD64_) || defined(_IA64_)

#define ExInterlockedCompareExchange64(Destination, Exchange, Comperand, Lock) \
    InterlockedCompareExchange64(Destination, *(Exchange), *(Comperand))

#else

#define ExInterlockedCompareExchange64(Destination, Exchange, Comperand, Lock) \
    ExfInterlockedCompareExchange64(Destination, Exchange, Comperand)

#endif

#if (NTDDI_VERSION >= NTDDI_WIN2K)
NTKERNELAPI
PLIST_ENTRY
FASTCALL
ExInterlockedInsertHeadList (
    __inout PLIST_ENTRY ListHead,
    __inout PLIST_ENTRY ListEntry,
    __inout PKSPIN_LOCK Lock
    );
#endif

#if (NTDDI_VERSION >= NTDDI_WIN2K)
NTKERNELAPI
PLIST_ENTRY
FASTCALL
ExInterlockedInsertTailList (
    __inout PLIST_ENTRY ListHead,
    __inout PLIST_ENTRY ListEntry,
    __inout PKSPIN_LOCK Lock
    );
#endif

#if (NTDDI_VERSION >= NTDDI_WIN2K)
NTKERNELAPI
PLIST_ENTRY
FASTCALL
ExInterlockedRemoveHeadList (
    __inout PLIST_ENTRY ListHead,
    __inout PKSPIN_LOCK Lock
    );
#endif

#if (NTDDI_VERSION >= NTDDI_WIN2K)
NTKERNELAPI
PSINGLE_LIST_ENTRY
FASTCALL
ExInterlockedPopEntryList (
    __inout PSINGLE_LIST_ENTRY ListHead,
    __inout PKSPIN_LOCK Lock
    );
#endif

#if (NTDDI_VERSION >= NTDDI_WIN2K)
NTKERNELAPI
PSINGLE_LIST_ENTRY
FASTCALL
ExInterlockedPushEntryList (
    __inout PSINGLE_LIST_ENTRY ListHead,
    __inout PSINGLE_LIST_ENTRY ListEntry,
    __inout PKSPIN_LOCK Lock
    );
#endif

//
// Define interlocked sequenced listhead functions.
//
// A sequenced interlocked list is a singly linked list with a header that
// contains the current depth and a sequence number. Each time an entry is
// inserted or removed from the list the depth is updated and the sequence
// number is incremented. This enables AMD64, IA64, and Pentium and later
// machines to insert and remove from the list without the use of spinlocks.
//

#if !defined(_WINBASE_)

/*++

Routine Description:

    This function initializes a sequenced singly linked listhead.

Arguments:

    SListHead - Supplies a pointer to a sequenced singly linked listhead.

Return Value:

    None.

--*/

#if defined(_WIN64) && (defined(_NTDRIVER_) || defined(_NTDDK_) || defined(_NTIFS_) || defined(_NTHAL_) || defined(_NTOSP_))

NTKERNELAPI
VOID
InitializeSListHead (
    __out PSLIST_HEADER SListHead
    );

#else

//
// Since the following function will be compiled inline for user code, the
// initialization changes for IA64 will only take effect if the user code
// is recompiled with this new header. For those binaries that are recompiled
// with this new code, it will not have to go through an extra step of header
// initialization on its first push or pop operation. Note that the SLIST code
// will still work perfectly even without the changes in this initialization
// function.
//

__inline
VOID
InitializeSListHead (
    __out PSLIST_HEADER SListHead
    )

{

#if defined(_IA64_)

    ULONG64 FeatureBits;

#endif

    //
    // Slist headers must be 16 byte aligned.
    //

#ifdef _WIN64

    if ((ULONG_PTR) SListHead & 0x0f) {
        KdPrint(("InitializeSListHead unaligned Slist header. Address = %p, Caller = %p\n",
                 SListHead,
                 _ReturnAddress()));

        RtlRaiseStatus(STATUS_DATATYPE_MISALIGNMENT);
    }

#endif

    RtlZeroMemory(SListHead, sizeof(SLIST_HEADER));

    //
    // Check feature bits to determine if 16-byte atomic operations are
    // supported.
    //

#if defined(_IA64_)

    FeatureBits = __getReg(CV_IA64_CPUID4);
    if (FeatureBits & KF_16BYTE_INSTR) {

        //
        // Initialize 16-byte header.
        //

        SListHead->Header16.HeaderType = 1;
        SListHead->Header16.Init = 1;

    } else {

        //
        // Initialize 8-byte header.
        //
        // Save the region number for the elements of the list in a separate
        // field. This imposes the requirement that all elements stored in the
        // list are from the same region.
        //
        // N.B. This is true for 8-byte SLIST header only.
        //

        SListHead->Region = (ULONG_PTR)SListHead & VRN_MASK;
        SListHead->Header8.HeaderType = 0;
        SListHead->Header8.Init = 1;
    }

#endif

    return;
}

#endif

#endif // !defined(_WINBASE_)

#define ExInitializeSListHead InitializeSListHead

PSLIST_ENTRY
FirstEntrySList (
    IN const SLIST_HEADER *SListHead
    );

/*++

Routine Description:

    This function queries the current number of entries contained in a
    sequenced single linked list.

Arguments:

    SListHead - Supplies a pointer to the sequenced listhead which is
        be queried.

Return Value:

    The current number of entries in the sequenced singly linked list is
    returned as the function value.

--*/

#if defined(_WIN64)

#if (defined(_NTDRIVER_) || defined(_NTDDK_) || defined(_NTIFS_) || defined(_NTHAL_) || defined(_NTOSP_))

NTKERNELAPI
USHORT
ExQueryDepthSList (
    __in PSLIST_HEADER SListHead
    );

#else

__inline
USHORT
ExQueryDepthSList (
    __in PSLIST_HEADER SListHead
    )

{

    return (USHORT)(SListHead->Alignment & 0xffff);
}

#endif

#else

#define ExQueryDepthSList(_listhead_) (_listhead_)->Depth

#endif

#if defined(_WIN64)

#define ExInterlockedPopEntrySList(Head, Lock) \
    ExpInterlockedPopEntrySList(Head)

#define ExInterlockedPushEntrySList(Head, Entry, Lock) \
    ExpInterlockedPushEntrySList(Head, Entry)

#define ExInterlockedFlushSList(Head) \
    ExpInterlockedFlushSList(Head)

#if !defined(_WINBASE_)

#define InterlockedPopEntrySList(Head) \
    ExpInterlockedPopEntrySList(Head)

#define InterlockedPushEntrySList(Head, Entry) \
    ExpInterlockedPushEntrySList(Head, Entry)

#define InterlockedFlushSList(Head) \
    ExpInterlockedFlushSList(Head)

#define QueryDepthSList(Head) \
    ExQueryDepthSList(Head)

#endif // !defined(_WINBASE_)

NTKERNELAPI
PSLIST_ENTRY
ExpInterlockedPopEntrySList (
    __inout PSLIST_HEADER ListHead
    );

NTKERNELAPI
PSLIST_ENTRY
ExpInterlockedPushEntrySList (
    __inout PSLIST_HEADER ListHead,
    __inout PSLIST_ENTRY ListEntry
    );

NTKERNELAPI
PSLIST_ENTRY
ExpInterlockedFlushSList (
    __inout PSLIST_HEADER ListHead
    );

#else

#if defined(_WIN2K_COMPAT_SLIST_USAGE) && defined(_X86_)

NTKERNELAPI
PSLIST_ENTRY
FASTCALL
ExInterlockedPopEntrySList (
    __inout PSLIST_HEADER ListHead,
    __inout PKSPIN_LOCK Lock
    );

NTKERNELAPI
PSLIST_ENTRY
FASTCALL
ExInterlockedPushEntrySList (
    __inout PSLIST_HEADER ListHead,
    __inout PSLIST_ENTRY ListEntry,
    __inout PKSPIN_LOCK Lock
    );

#else

#define ExInterlockedPopEntrySList(ListHead, Lock) \
    InterlockedPopEntrySList(ListHead)

#define ExInterlockedPushEntrySList(ListHead, ListEntry, Lock) \
    InterlockedPushEntrySList(ListHead, ListEntry)

#endif

NTKERNELAPI
PSLIST_ENTRY
FASTCALL
ExInterlockedFlushSList (
    __inout PSLIST_HEADER ListHead
    );

#if !defined(_WINBASE_)

NTKERNELAPI
PSLIST_ENTRY
FASTCALL
InterlockedPopEntrySList (
    __inout PSLIST_HEADER ListHead
    );

NTKERNELAPI
PSLIST_ENTRY
FASTCALL
InterlockedPushEntrySList (
    __inout PSLIST_HEADER ListHead,
    __inout PSLIST_ENTRY ListEntry
    );

#define InterlockedFlushSList(Head) \
    ExInterlockedFlushSList(Head)

#define QueryDepthSList(Head) \
    ExQueryDepthSList(Head)

#endif // !defined(_WINBASE_)

#endif // defined(_WIN64)


#define LOOKASIDE_MINIMUM_BLOCK_SIZE  (RTL_SIZEOF_THROUGH_FIELD (SLIST_ENTRY, Next))

//
// N.B. Note that this structure is not cache aligned to enable its use
//  in a larger containing structure.
//

typedef struct _LOOKASIDE_LIST_EX {
    GENERAL_LOOKASIDE_POOL L;
} LOOKASIDE_LIST_EX, *PLOOKASIDE_LIST_EX;

#if (NTDDI_VERSION >= NTDDI_VISTA)

#define EX_LOOKASIDE_LIST_EX_FLAGS_RAISE_ON_FAIL    0x00000001UL
#define EX_LOOKASIDE_LIST_EX_FLAGS_FAIL_NO_RAISE    0x00000002UL

#define EX_MAXIMUM_LOOKASIDE_DEPTH_BASE     256     // Base maximum depth
#define EX_MAXIMUM_LOOKASIDE_DEPTH_LIMIT    1024    // Upper limit maximum depth

NTKERNELAPI
NTSTATUS
ExInitializeLookasideListEx (
    __out PLOOKASIDE_LIST_EX Lookaside,
    __in_opt PALLOCATE_FUNCTION_EX Allocate,
    __in_opt PFREE_FUNCTION_EX Free,
    __in POOL_TYPE PoolType,
    __in ULONG Flags,
    __in SIZE_T Size,
    __in ULONG Tag,
    __in USHORT Depth
    );

NTKERNELAPI
VOID
ExDeleteLookasideListEx (
    __inout PLOOKASIDE_LIST_EX Lookaside
    );

NTKERNELAPI
VOID
ExFlushLookasideListEx (
    __inout PLOOKASIDE_LIST_EX Lookaside
    );

PVOID
FORCEINLINE
ExAllocateFromLookasideListEx (
    __inout PLOOKASIDE_LIST_EX Lookaside
    )

/*++

Routine Description:

    This function removes (pops) the first entry from the specified
    lookaside list.

Arguments:

    Lookaside - Supplies a pointer to a LOOKASIDE_LIST_EX structure.

Return Value:

    If an entry is removed from the specified lookaside list, then the
    address of the entry is returned as the function value. Otherwise,
    NULL is returned.

--*/

{

    PVOID Entry;

    Lookaside->L.TotalAllocates += 1;
    Entry = InterlockedPopEntrySList(&Lookaside->L.ListHead);
    if (Entry == NULL) {
        Lookaside->L.AllocateMisses += 1;
        Entry = (Lookaside->L.AllocateEx)(Lookaside->L.Type,
                                          Lookaside->L.Size,
                                          Lookaside->L.Tag,
                                          Lookaside);
    }

    return Entry;
}

VOID
FORCEINLINE
ExFreeToLookasideListEx (
    __inout PLOOKASIDE_LIST_EX Lookaside,
    __in PVOID Entry
    )

/*++

Routine Description:

    This function inserts (pushes) the specified entry into the specified
    lookaside list.

Arguments:

    Lookaside - Supplies a pointer to a LOOKASIDE_LIST_EX structure.

    Entry - Supples a pointer to the entry that is inserted in the
        lookaside list.

Return Value:

    None.

--*/

{

    Lookaside->L.TotalFrees += 1;
    if (ExQueryDepthSList(&Lookaside->L.ListHead) >= Lookaside->L.Depth) {
        Lookaside->L.FreeMisses += 1;
        (Lookaside->L.FreeEx)(Entry, Lookaside);

    } else {
        InterlockedPushEntrySList(&Lookaside->L.ListHead, (PSLIST_ENTRY)Entry);
    }

    return;
}

#endif // (NTDDI_VERSION >= NTDDI_VISTA)

typedef struct LOOKASIDE_ALIGN _NPAGED_LOOKASIDE_LIST {

    GENERAL_LOOKASIDE L;

#if !defined(_AMD64_) && !defined(_IA64_)

    KSPIN_LOCK Lock__ObsoleteButDoNotDelete;

#endif

} NPAGED_LOOKASIDE_LIST, *PNPAGED_LOOKASIDE_LIST;

#if (NTDDI_VERSION >= NTDDI_WIN2K)
NTKERNELAPI
VOID
ExInitializeNPagedLookasideList (
    __out PNPAGED_LOOKASIDE_LIST Lookaside,
    __in_opt PALLOCATE_FUNCTION Allocate,
    __in_opt PFREE_FUNCTION Free,
    __in ULONG Flags,
    __in SIZE_T Size,
    __in ULONG Tag,
    __in USHORT Depth
    );
#endif

#if (NTDDI_VERSION >= NTDDI_WIN2K)
NTKERNELAPI
VOID
ExDeleteNPagedLookasideList (
    __inout PNPAGED_LOOKASIDE_LIST Lookaside
    );
#endif

__inline
PVOID
ExAllocateFromNPagedLookasideList (
    IN PNPAGED_LOOKASIDE_LIST Lookaside
    )

/*++

Routine Description:

    This function removes (pops) the first entry from the specified
    nonpaged lookaside list.

Arguments:

    Lookaside - Supplies a pointer to a nonpaged lookaside list structure.

Return Value:

    If an entry is removed from the specified lookaside list, then the
    address of the entry is returned as the function value. Otherwise,
    NULL is returned.

--*/

{

    PVOID Entry;

    Lookaside->L.TotalAllocates += 1;

#if defined(_WIN2K_COMPAT_SLIST_USAGE) && defined(_X86_)

    Entry = ExInterlockedPopEntrySList(&Lookaside->L.ListHead,
                                       &Lookaside->Lock__ObsoleteButDoNotDelete);

#else

    Entry = InterlockedPopEntrySList(&Lookaside->L.ListHead);

#endif

    if (Entry == NULL) {
        Lookaside->L.AllocateMisses += 1;
        Entry = (Lookaside->L.Allocate)(Lookaside->L.Type,
                                        Lookaside->L.Size,
                                        Lookaside->L.Tag);
    }

    return Entry;
}

__inline
VOID
ExFreeToNPagedLookasideList (
    IN PNPAGED_LOOKASIDE_LIST Lookaside,
    IN PVOID Entry
    )

/*++

Routine Description:

    This function inserts (pushes) the specified entry into the specified
    nonpaged lookaside list.

Arguments:

    Lookaside - Supplies a pointer to a nonpaged lookaside list structure.

    Entry - Supples a pointer to the entry that is inserted in the
        lookaside list.

Return Value:

    None.

--*/

{

    Lookaside->L.TotalFrees += 1;
    if (ExQueryDepthSList(&Lookaside->L.ListHead) >= Lookaside->L.Depth) {
        Lookaside->L.FreeMisses += 1;
        (Lookaside->L.Free)(Entry);

    } else {

#if defined(_WIN2K_COMPAT_SLIST_USAGE) && defined(_X86_)

        ExInterlockedPushEntrySList(&Lookaside->L.ListHead,
                                    (PSLIST_ENTRY)Entry,
                                    &Lookaside->Lock__ObsoleteButDoNotDelete);

#else

        InterlockedPushEntrySList(&Lookaside->L.ListHead, (PSLIST_ENTRY)Entry);

#endif

    }

    return;
}



typedef struct LOOKASIDE_ALIGN _PAGED_LOOKASIDE_LIST {

    GENERAL_LOOKASIDE L;

#if !defined(_AMD64_) && !defined(_IA64_)

    FAST_MUTEX Lock__ObsoleteButDoNotDelete;

#endif

} PAGED_LOOKASIDE_LIST, *PPAGED_LOOKASIDE_LIST;


#if (NTDDI_VERSION >= NTDDI_WIN2K)
NTKERNELAPI
VOID
ExInitializePagedLookasideList (
    __out PPAGED_LOOKASIDE_LIST Lookaside,
    __in_opt PALLOCATE_FUNCTION Allocate,
    __in_opt PFREE_FUNCTION Free,
    __in ULONG Flags,
    __in SIZE_T Size,
    __in ULONG Tag,
    __in USHORT Depth
    );
#endif

#if (NTDDI_VERSION >= NTDDI_WIN2K)
NTKERNELAPI
VOID
ExDeletePagedLookasideList (
    __inout PPAGED_LOOKASIDE_LIST Lookaside
    );
#endif

#if defined(_WIN2K_COMPAT_SLIST_USAGE) && defined(_X86_)

NTKERNELAPI
PVOID
ExAllocateFromPagedLookasideList (
    __inout PPAGED_LOOKASIDE_LIST Lookaside
    );

#else

__inline
PVOID
ExAllocateFromPagedLookasideList (
    __inout PPAGED_LOOKASIDE_LIST Lookaside
    )

/*++

Routine Description:

    This function removes (pops) the first entry from the specified
    paged lookaside list.

Arguments:

    Lookaside - Supplies a pointer to a paged lookaside list structure.

Return Value:

    If an entry is removed from the specified lookaside list, then the
    address of the entry is returned as the function value. Otherwise,
    NULL is returned.

--*/

{

    PVOID Entry;

    Lookaside->L.TotalAllocates += 1;
    Entry = InterlockedPopEntrySList(&Lookaside->L.ListHead);
    if (Entry == NULL) {
        Lookaside->L.AllocateMisses += 1;
        Entry = (Lookaside->L.Allocate)(Lookaside->L.Type,
                                        Lookaside->L.Size,
                                        Lookaside->L.Tag);
    }

    return Entry;
}

#endif

#if defined(_WIN2K_COMPAT_SLIST_USAGE) && defined(_X86_)

NTKERNELAPI
VOID
ExFreeToPagedLookasideList (
    __inout PPAGED_LOOKASIDE_LIST Lookaside,
    __in PVOID Entry
    );

#else

__inline
VOID
ExFreeToPagedLookasideList (
    __inout PPAGED_LOOKASIDE_LIST Lookaside,
    __in PVOID Entry
    )

/*++

Routine Description:

    This function inserts (pushes) the specified entry into the specified
    paged lookaside list.

Arguments:

    Lookaside - Supplies a pointer to a nonpaged lookaside list structure.

    Entry - Supples a pointer to the entry that is inserted in the
        lookaside list.

Return Value:

    None.

--*/

{

    Lookaside->L.TotalFrees += 1;
    if (ExQueryDepthSList(&Lookaside->L.ListHead) >= Lookaside->L.Depth) {
        Lookaside->L.FreeMisses += 1;
        (Lookaside->L.Free)(Entry);

    } else {
        InterlockedPushEntrySList(&Lookaside->L.ListHead,
                                  (PSLIST_ENTRY)Entry);
    }

    return;
}

#endif


#if defined(_NTDDK_) || defined(_NTIFS_)

#if (NTDDI_VERSION >= NTDDI_WIN2K)
NTKERNELAPI
VOID
NTAPI
ProbeForRead (
    __in_data_source(USER_MODE) __out_validated(MEMORY) __in_bcount(Length) VOID *Address,
    __in SIZE_T Length,
    __in ULONG Alignment
    );
#endif

#endif

//
// Raise status from kernel mode.
//

#if (NTDDI_VERSION >= NTDDI_WIN2K)
NTKERNELAPI
DECLSPEC_NORETURN
VOID
NTAPI
ExRaiseStatus (
    __in NTSTATUS Status
    );
#endif


//
// Common probe for write functions.
//

#if (NTDDI_VERSION >= NTDDI_WIN2K)
NTKERNELAPI
VOID
NTAPI
ProbeForWrite (
    __in_data_source(USER_MODE) __out_validated(MEMORY) __inout_bcount(Length) PVOID Address,
    __in SIZE_T Length,
    __in ULONG Alignment
    );
#endif

//
// Worker Thread
//

typedef enum _WORK_QUEUE_TYPE {
    CriticalWorkQueue,
    DelayedWorkQueue,
    HyperCriticalWorkQueue,
    MaximumWorkQueue
} WORK_QUEUE_TYPE;

typedef
VOID
(*PWORKER_THREAD_ROUTINE)(
    IN PVOID Parameter
    );

typedef struct _WORK_QUEUE_ITEM {
    LIST_ENTRY List;
    PWORKER_THREAD_ROUTINE WorkerRoutine;
    __volatile PVOID Parameter;
} WORK_QUEUE_ITEM, *PWORK_QUEUE_ITEM;

#if PRAGMA_DEPRECATED_DDK
#pragma deprecated(ExInitializeWorkItem)    // Use IoAllocateWorkItem
#endif
#define ExInitializeWorkItem(Item, Routine, Context) \
    (Item)->WorkerRoutine = (Routine);               \
    (Item)->Parameter = (Context);                   \
    (Item)->List.Flink = NULL;

#if (NTDDI_VERSION >= NTDDI_WIN2K)
DECLSPEC_DEPRECATED_DDK                     // Use IoQueueWorkItem
NTKERNELAPI
VOID
ExQueueWorkItem(
    __inout PWORK_QUEUE_ITEM WorkItem,
    __in WORK_QUEUE_TYPE QueueType
    );
#endif

#if (NTDDI_VERSION >= NTDDI_WIN2K)
NTKERNELAPI
BOOLEAN
ExIsProcessorFeaturePresent(
    __in ULONG ProcessorFeature
    );
#endif

//
//  Define executive resource data structures.
//

typedef ULONG_PTR ERESOURCE_THREAD;
typedef ERESOURCE_THREAD *PERESOURCE_THREAD;

typedef struct _OWNER_ENTRY {
    ERESOURCE_THREAD OwnerThread;
    union {
        LONG OwnerCount;
        ULONG TableSize;
    };

} OWNER_ENTRY, *POWNER_ENTRY;

typedef struct _ERESOURCE {
    LIST_ENTRY SystemResourcesList;
    POWNER_ENTRY OwnerTable;

    //
    // ActiveEntries is the true, 32-bit count.  Existing code
    // checks for ActiveCount == 0, so this toggles between
    // 0 and 1 and back as ActiveEntries goes from 0 to
    // non-zero and back.
    //

    SHORT ActiveCount;
    USHORT Flag;
    __volatile PKSEMAPHORE SharedWaiters;
    __volatile PKEVENT ExclusiveWaiters;

    //
    // If the resource is owned exclusive, OwnerEntry contains the
    // resource owner.
    //
    // If the resource is owned shared, OwnerEntry may contain one
    // of the shared owners.
    //

    OWNER_ENTRY OwnerEntry;
    ULONG ActiveEntries;
    ULONG ContentionCount;
    ULONG NumberOfSharedWaiters;
    ULONG NumberOfExclusiveWaiters;
#if defined(_WIN64)
    PVOID Reserved2;
#endif
    union {
        PVOID Address;
        ULONG_PTR CreatorBackTraceIndex;
    };

    KSPIN_LOCK SpinLock;
} ERESOURCE, *PERESOURCE;
//
//  Values for ERESOURCE.Flag
//

#define ResourceNeverExclusive       0x10
#define ResourceReleaseByOtherThread 0x20
#define ResourceOwnedExclusive       0x80

#define RESOURCE_HASH_TABLE_SIZE 64

typedef struct _RESOURCE_HASH_ENTRY {
    LIST_ENTRY ListEntry;
    PVOID Address;
    ULONG ContentionCount;
    ULONG Number;
} RESOURCE_HASH_ENTRY, *PRESOURCE_HASH_ENTRY;

typedef struct _RESOURCE_PERFORMANCE_DATA {
    ULONG ActiveResourceCount;
    ULONG TotalResourceCount;
    ULONG ExclusiveAcquire;
    ULONG SharedFirstLevel;
    ULONG SharedSecondLevel;
    ULONG StarveFirstLevel;
    ULONG StarveSecondLevel;
    ULONG WaitForExclusive;
    ULONG OwnerTableExpands;
    ULONG MaximumTableExpand;
    LIST_ENTRY HashTable[RESOURCE_HASH_TABLE_SIZE];
} RESOURCE_PERFORMANCE_DATA, *PRESOURCE_PERFORMANCE_DATA;

//
// Define executive resource function prototypes.
//
#if (NTDDI_VERSION >= NTDDI_WIN2K)
NTKERNELAPI
NTSTATUS
ExInitializeResourceLite (
    __out PERESOURCE Resource
    );
#endif

#if (NTDDI_VERSION >= NTDDI_WIN2K)
NTKERNELAPI
NTSTATUS
ExReinitializeResourceLite (
    __inout PERESOURCE Resource
    );
#endif

#if (NTDDI_VERSION >= NTDDI_WIN2K)
NTKERNELAPI
BOOLEAN
ExAcquireResourceSharedLite (
    __inout PERESOURCE Resource,
    __in BOOLEAN Wait
    );
#endif

#if (NTDDI_VERSION >= NTDDI_VISTA || NTDDI_VERSION >= NTDDI_WS03SP1)
NTKERNELAPI
PVOID
ExEnterCriticalRegionAndAcquireResourceShared (
    __inout PERESOURCE Resource
    );

#endif


#if (NTDDI_VERSION >= NTDDI_WIN2K)
NTKERNELAPI
BOOLEAN
ExAcquireResourceExclusiveLite (
    __inout PERESOURCE Resource,
    __in BOOLEAN Wait
    );
#endif

#if (NTDDI_VERSION >= NTDDI_VISTA || NTDDI_VERSION >= NTDDI_WS03SP1)
NTKERNELAPI
PVOID
ExEnterCriticalRegionAndAcquireResourceExclusive (
    __inout PERESOURCE Resource
    );
#endif


#if (NTDDI_VERSION >= NTDDI_WIN2K)
NTKERNELAPI
BOOLEAN
ExAcquireSharedStarveExclusive(
    __inout PERESOURCE Resource,
    __in BOOLEAN Wait
    );
#endif

#if (NTDDI_VERSION >= NTDDI_WIN2K)
NTKERNELAPI
BOOLEAN
ExAcquireSharedWaitForExclusive(
    __inout PERESOURCE Resource,
    __in BOOLEAN Wait
    );
#endif

#if (NTDDI_VERSION >= NTDDI_VISTA || NTDDI_VERSION >= NTDDI_WS03SP1)
NTKERNELAPI
PVOID
ExEnterCriticalRegionAndAcquireSharedWaitForExclusive (
    __inout PERESOURCE Resource
    );
#endif

//
//  VOID
//  ExReleaseResource(
//      IN PERESOURCE Resource
//      );
//

#if PRAGMA_DEPRECATED_DDK
#pragma deprecated(ExReleaseResource)       // Use ExReleaseResourceLite
#endif
#define ExReleaseResource(R) (ExReleaseResourceLite(R))

#if (NTDDI_VERSION >= NTDDI_WIN2K)
NTKERNELAPI
VOID
FASTCALL
ExReleaseResourceLite(
    __inout PERESOURCE Resource
    );
#endif

#if (NTDDI_VERSION >= NTDDI_VISTA || NTDDI_VERSION >= NTDDI_WS03SP1)
NTKERNELAPI
VOID
FASTCALL
ExReleaseResourceAndLeaveCriticalRegion(
    __inout PERESOURCE Resource
    );
#endif


#if (NTDDI_VERSION >= NTDDI_WIN2K)
NTKERNELAPI
VOID
ExReleaseResourceForThreadLite(
    __inout PERESOURCE Resource,
    __in ERESOURCE_THREAD ResourceThreadId
    );
#endif

#if (NTDDI_VERSION >= NTDDI_WIN2K)
NTKERNELAPI
VOID
ExSetResourceOwnerPointer(
    __inout PERESOURCE Resource,
    __in PVOID OwnerPointer
    );
#endif

#if (NTDDI_VERSION >= NTDDI_WIN2K)
NTKERNELAPI
VOID
ExConvertExclusiveToSharedLite(
    __inout PERESOURCE Resource
    );
#endif

#if (NTDDI_VERSION >= NTDDI_WIN2K)
NTKERNELAPI
NTSTATUS
ExDeleteResourceLite (
    __inout PERESOURCE Resource
    );
#endif

#if (NTDDI_VERSION >= NTDDI_WIN2K)
NTKERNELAPI
ULONG
ExGetExclusiveWaiterCount (
    __in PERESOURCE Resource
    );
#endif

#if (NTDDI_VERSION >= NTDDI_WIN2K)
NTKERNELAPI
ULONG
ExGetSharedWaiterCount (
    __in PERESOURCE Resource
    );
#endif

//
//  ERESOURCE_THREAD
//  ExGetCurrentResourceThread(
//      );
//

#define ExGetCurrentResourceThread() ((ULONG_PTR)PsGetCurrentThread())

#if (NTDDI_VERSION >= NTDDI_WIN2K)
NTKERNELAPI
BOOLEAN
ExIsResourceAcquiredExclusiveLite (
    __in PERESOURCE Resource
    );
#endif

#if (NTDDI_VERSION >= NTDDI_WIN2K)
NTKERNELAPI
ULONG
ExIsResourceAcquiredSharedLite (
    __in PERESOURCE Resource
    );
#endif

//
// An acquired resource is always owned shared, as shared ownership is a subset
// of exclusive ownership.
//
#define ExIsResourceAcquiredLite ExIsResourceAcquiredSharedLite


//
// Rundown protection structure
//
typedef struct _EX_RUNDOWN_REF {

#define EX_RUNDOWN_ACTIVE      0x1
#define EX_RUNDOWN_COUNT_SHIFT 0x1
#define EX_RUNDOWN_COUNT_INC   (1<<EX_RUNDOWN_COUNT_SHIFT)
    union {
        __volatile ULONG_PTR Count;
        __volatile PVOID Ptr;
    };
} EX_RUNDOWN_REF, *PEX_RUNDOWN_REF;

//
//  Opaque cache-aware rundown ref structure
//

typedef struct _EX_RUNDOWN_REF_CACHE_AWARE  *PEX_RUNDOWN_REF_CACHE_AWARE;

//
// Get previous mode
//

#if (NTDDI_VERSION >= NTDDI_WIN2K)
NTKERNELAPI
KPROCESSOR_MODE
ExGetPreviousMode(
    VOID
    );
#endif

//
// Set timer resolution.
//

#if (NTDDI_VERSION >= NTDDI_WIN2K)
NTKERNELAPI
ULONG
ExSetTimerResolution (
    __in ULONG DesiredTime,
    __in BOOLEAN SetResolution
    );
#endif

//
// Subtract time zone bias from system time to get local time.
//

#if (NTDDI_VERSION >= NTDDI_WIN2K)
NTKERNELAPI
VOID
ExSystemTimeToLocalTime (
    __in PLARGE_INTEGER SystemTime,
    __out PLARGE_INTEGER LocalTime
    );
#endif

//
// Add time zone bias to local time to get system time.
//

#if (NTDDI_VERSION >= NTDDI_WIN2K)
NTKERNELAPI
VOID
ExLocalTimeToSystemTime (
    __in PLARGE_INTEGER LocalTime,
    __out PLARGE_INTEGER SystemTime
    );
#endif


//
// Define the type for Callback function.
//

typedef struct _CALLBACK_OBJECT *PCALLBACK_OBJECT;

typedef VOID (*PCALLBACK_FUNCTION ) (
    __in_opt PVOID CallbackContext,
    __in_opt PVOID Argument1,
    __in_opt PVOID Argument2
    );


#if (NTDDI_VERSION >= NTDDI_WIN2K)
NTKERNELAPI
NTSTATUS
ExCreateCallback (
    __deref_out PCALLBACK_OBJECT *CallbackObject,
    __in POBJECT_ATTRIBUTES ObjectAttributes,
    __in BOOLEAN Create,
    __in BOOLEAN AllowMultipleCallbacks
    );
#endif

#if (NTDDI_VERSION >= NTDDI_WIN2K)
NTKERNELAPI
PVOID
ExRegisterCallback (
    __inout PCALLBACK_OBJECT CallbackObject,
    __in PCALLBACK_FUNCTION CallbackFunction,
    __in_opt PVOID CallbackContext
    );
#endif

#if (NTDDI_VERSION >= NTDDI_WIN2K)
NTKERNELAPI
VOID
ExUnregisterCallback (
    __inout PVOID CallbackRegistration
    );
#endif

#if (NTDDI_VERSION >= NTDDI_WIN2K)
NTKERNELAPI
VOID
ExNotifyCallback (
    __in PVOID CallbackObject,
    __in_opt PVOID Argument1,
    __in_opt PVOID Argument2
    );
#endif

//
// suite support
//

#if (NTDDI_VERSION >= NTDDI_WINXP)
NTKERNELAPI
BOOLEAN
ExVerifySuite(
    __in SUITE_TYPE SuiteType
    );
#endif


//
//  Rundown Locks
//

#if (NTDDI_VERSION >= NTDDI_WINXP)
NTKERNELAPI
VOID
FASTCALL
ExInitializeRundownProtection (
     __out PEX_RUNDOWN_REF RunRef
     );
#endif

#if (NTDDI_VERSION >= NTDDI_WINXP)
NTKERNELAPI
VOID
FASTCALL
ExReInitializeRundownProtection (
     __out PEX_RUNDOWN_REF RunRef
     );
#endif

#if (NTDDI_VERSION >= NTDDI_WINXP)
NTKERNELAPI
BOOLEAN
FASTCALL
ExAcquireRundownProtection (
     __inout PEX_RUNDOWN_REF RunRef
     );
#endif

#if (NTDDI_VERSION >= NTDDI_WINXPSP2 || NTDDI_VERSION >= NTDDI_WS03)
NTKERNELAPI
BOOLEAN
FASTCALL
ExAcquireRundownProtectionEx (
     __inout PEX_RUNDOWN_REF RunRef,
     __in ULONG Count
     );
#endif

#if (NTDDI_VERSION >= NTDDI_WINXP)
NTKERNELAPI
VOID
FASTCALL
ExReleaseRundownProtection (
     __inout PEX_RUNDOWN_REF RunRef
     );
#endif

#if (NTDDI_VERSION >= NTDDI_WINXPSP2 || NTDDI_VERSION >= NTDDI_WS03)
NTKERNELAPI
VOID
FASTCALL
ExReleaseRundownProtectionEx (
     __inout PEX_RUNDOWN_REF RunRef,
     __in ULONG Count
     );
#endif

#if (NTDDI_VERSION >= NTDDI_WINXP)
NTKERNELAPI
VOID
FASTCALL
ExRundownCompleted (
     __out PEX_RUNDOWN_REF RunRef
     );
#endif

#if (NTDDI_VERSION >= NTDDI_WINXP)
NTKERNELAPI
VOID
FASTCALL
ExWaitForRundownProtectionRelease (
     __inout PEX_RUNDOWN_REF RunRef
     );
#endif

#if (NTDDI_VERSION >= NTDDI_WS03SP1)
NTKERNELAPI
PEX_RUNDOWN_REF_CACHE_AWARE
ExAllocateCacheAwareRundownProtection(
    __in POOL_TYPE PoolType,
    __in ULONG PoolTag
    );
#endif

#if (NTDDI_VERSION >= NTDDI_WS03SP1)
NTKERNELAPI
SIZE_T
ExSizeOfRundownProtectionCacheAware(
    VOID
    );
#endif

#if (NTDDI_VERSION >= NTDDI_WS03SP1)
NTKERNELAPI
VOID
ExInitializeRundownProtectionCacheAware(
    __out PEX_RUNDOWN_REF_CACHE_AWARE RunRefCacheAware,
    __in SIZE_T RunRefSize
    );
#endif

#if (NTDDI_VERSION >= NTDDI_WS03SP1)
NTKERNELAPI
VOID
ExFreeCacheAwareRundownProtection(
    __inout PEX_RUNDOWN_REF_CACHE_AWARE RunRefCacheAware
    );
#endif

#if (NTDDI_VERSION >= NTDDI_WS03SP1)
NTKERNELAPI
BOOLEAN
FASTCALL
ExAcquireRundownProtectionCacheAware (
     __inout PEX_RUNDOWN_REF_CACHE_AWARE RunRefCacheAware
     );
#endif

#if (NTDDI_VERSION >= NTDDI_WS03SP1)
NTKERNELAPI
VOID
FASTCALL
ExReleaseRundownProtectionCacheAware (
     __inout PEX_RUNDOWN_REF_CACHE_AWARE RunRefCacheAware
     );
#endif

#if (NTDDI_VERSION >= NTDDI_WS03SP1)
NTKERNELAPI
BOOLEAN
FASTCALL
ExAcquireRundownProtectionCacheAwareEx (
     __inout PEX_RUNDOWN_REF_CACHE_AWARE RunRefCacheAware,
     __in ULONG Count
     );
#endif

#if (NTDDI_VERSION >= NTDDI_WS03SP1)
NTKERNELAPI
VOID
FASTCALL
ExReleaseRundownProtectionCacheAwareEx (
     __inout PEX_RUNDOWN_REF_CACHE_AWARE RunRef,
     __in ULONG Count
     );
#endif

#if (NTDDI_VERSION >= NTDDI_WS03SP1)
NTKERNELAPI
VOID
FASTCALL
ExWaitForRundownProtectionReleaseCacheAware (
     __inout PEX_RUNDOWN_REF_CACHE_AWARE RunRef
     );
#endif

#if (NTDDI_VERSION >= NTDDI_WS03SP1)
NTKERNELAPI
VOID
FASTCALL
ExReInitializeRundownProtectionCacheAware (
    __inout PEX_RUNDOWN_REF_CACHE_AWARE RunRefCacheAware
    );
#endif

#if (NTDDI_VERSION >= NTDDI_WS03SP1)
NTKERNELAPI
VOID
FASTCALL
ExRundownCompletedCacheAware (
    __inout PEX_RUNDOWN_REF_CACHE_AWARE RunRefCacheAware
    );
#endif


//
// Define a block to hold the actual routine registration.
//
typedef NTSTATUS (*PEX_CALLBACK_FUNCTION ) (
    IN PVOID CallbackContext,
    IN PVOID Argument1,
    IN PVOID Argument2
    );



//
// Registry kernel mode callbacks
//

//
// Hook selector
//
typedef enum _REG_NOTIFY_CLASS {
    RegNtDeleteKey,
    RegNtPreDeleteKey = RegNtDeleteKey,
    RegNtSetValueKey,
    RegNtPreSetValueKey = RegNtSetValueKey,
    RegNtDeleteValueKey,
    RegNtPreDeleteValueKey = RegNtDeleteValueKey,
    RegNtSetInformationKey,
    RegNtPreSetInformationKey = RegNtSetInformationKey,
    RegNtRenameKey,
    RegNtPreRenameKey = RegNtRenameKey,
    RegNtEnumerateKey,
    RegNtPreEnumerateKey = RegNtEnumerateKey,
    RegNtEnumerateValueKey,
    RegNtPreEnumerateValueKey = RegNtEnumerateValueKey,
    RegNtQueryKey,
    RegNtPreQueryKey = RegNtQueryKey,
    RegNtQueryValueKey,
    RegNtPreQueryValueKey = RegNtQueryValueKey,
    RegNtQueryMultipleValueKey,
    RegNtPreQueryMultipleValueKey = RegNtQueryMultipleValueKey,
    RegNtPreCreateKey,
    RegNtPostCreateKey,
    RegNtPreOpenKey,
    RegNtPostOpenKey,
    RegNtKeyHandleClose,
    RegNtPreKeyHandleClose = RegNtKeyHandleClose,
    //
    // .Net only
    //    
    RegNtPostDeleteKey,
    RegNtPostSetValueKey,
    RegNtPostDeleteValueKey,
    RegNtPostSetInformationKey,
    RegNtPostRenameKey,
    RegNtPostEnumerateKey,
    RegNtPostEnumerateValueKey,
    RegNtPostQueryKey,
    RegNtPostQueryValueKey,
    RegNtPostQueryMultipleValueKey,
    RegNtPostKeyHandleClose,
    RegNtPreCreateKeyEx,
    RegNtPostCreateKeyEx,
    RegNtPreOpenKeyEx,
    RegNtPostOpenKeyEx,
    //
    // new to Windows Vista
    //
    RegNtPreFlushKey,
    RegNtPostFlushKey,
    RegNtPreLoadKey,
    RegNtPostLoadKey,
    RegNtPreUnLoadKey,
    RegNtPostUnLoadKey,
    RegNtPreQueryKeySecurity,
    RegNtPostQueryKeySecurity,
    RegNtPreSetKeySecurity,
    RegNtPostSetKeySecurity,
    //
    // per-object context cleanup
    //
    RegNtCallbackObjectContextCleanup,
    MaxRegNtNotifyClass //should always be the last enum
} REG_NOTIFY_CLASS;

//
// Parameter description for each notify class
//
typedef struct _REG_DELETE_KEY_INFORMATION {
    PVOID    Object;                      // IN
    PVOID    CallContext;  // new to Windows Vista
    PVOID    ObjectContext;// new to Windows Vista
    PVOID    Reserved;     // new to Windows Vista
} REG_DELETE_KEY_INFORMATION, *PREG_DELETE_KEY_INFORMATION
#if (NTDDI_VERSION >= NTDDI_VISTA)
, REG_FLUSH_KEY_INFORMATION, *PREG_FLUSH_KEY_INFORMATION
#endif // NTDDI_VERSION >= NTDDI_VISTA
;

typedef struct _REG_SET_VALUE_KEY_INFORMATION {
    PVOID               Object;                         // IN
    PUNICODE_STRING     ValueName;                      // IN
    ULONG               TitleIndex;                     // IN
    ULONG               Type;                           // IN
    PVOID               Data;                           // IN
    ULONG               DataSize;                       // IN
    PVOID               CallContext;  // new to Windows Vista
    PVOID               ObjectContext;// new to Windows Vista
    PVOID               Reserved;     // new to Windows Vista
} REG_SET_VALUE_KEY_INFORMATION, *PREG_SET_VALUE_KEY_INFORMATION;

typedef struct _REG_DELETE_VALUE_KEY_INFORMATION {
    PVOID               Object;                         // IN
    PUNICODE_STRING     ValueName;                      // IN
    PVOID               CallContext;  // new to Windows Vista
    PVOID               ObjectContext;// new to Windows Vista
    PVOID               Reserved;     // new to Windows Vista
} REG_DELETE_VALUE_KEY_INFORMATION, *PREG_DELETE_VALUE_KEY_INFORMATION;

typedef struct _REG_SET_INFORMATION_KEY_INFORMATION {
    PVOID                       Object;                 // IN
    KEY_SET_INFORMATION_CLASS   KeySetInformationClass; // IN
    PVOID                       KeySetInformation;      // IN
    ULONG                       KeySetInformationLength;// IN
    PVOID                       CallContext;  // new to Windows Vista
    PVOID                       ObjectContext;// new to Windows Vista
    PVOID                       Reserved;     // new to Windows Vista
} REG_SET_INFORMATION_KEY_INFORMATION, *PREG_SET_INFORMATION_KEY_INFORMATION;

typedef struct _REG_ENUMERATE_KEY_INFORMATION {
    PVOID                       Object;                 // IN
    ULONG                       Index;                  // IN
    KEY_INFORMATION_CLASS       KeyInformationClass;    // IN
    PVOID                       KeyInformation;         // IN
    ULONG                       Length;                 // IN
    PULONG                      ResultLength;           // OUT
    PVOID                       CallContext;  // new to Windows Vista
    PVOID                       ObjectContext;// new to Windows Vista
    PVOID                       Reserved;     // new to Windows Vista
} REG_ENUMERATE_KEY_INFORMATION, *PREG_ENUMERATE_KEY_INFORMATION;

typedef struct _REG_ENUMERATE_VALUE_KEY_INFORMATION {
    PVOID                           Object;                     // IN
    ULONG                           Index;                      // IN
    KEY_VALUE_INFORMATION_CLASS     KeyValueInformationClass;   // IN
    PVOID                           KeyValueInformation;        // IN
    ULONG                           Length;                     // IN
    PULONG                          ResultLength;               // OUT
    PVOID                           CallContext;  // new to Windows Vista
    PVOID                           ObjectContext;// new to Windows Vista
    PVOID                           Reserved;     // new to Windows Vista
} REG_ENUMERATE_VALUE_KEY_INFORMATION, *PREG_ENUMERATE_VALUE_KEY_INFORMATION;

typedef struct _REG_QUERY_KEY_INFORMATION {
    PVOID                       Object;                 // IN
    KEY_INFORMATION_CLASS       KeyInformationClass;    // IN
    PVOID                       KeyInformation;         // IN
    ULONG                       Length;                 // IN
    PULONG                      ResultLength;           // OUT
    PVOID                       CallContext;  // new to Windows Vista
    PVOID                       ObjectContext;// new to Windows Vista
    PVOID                       Reserved;     // new to Windows Vista
} REG_QUERY_KEY_INFORMATION, *PREG_QUERY_KEY_INFORMATION;

typedef struct _REG_QUERY_VALUE_KEY_INFORMATION {
    PVOID                           Object;                     // IN
    PUNICODE_STRING                 ValueName;                  // IN
    KEY_VALUE_INFORMATION_CLASS     KeyValueInformationClass;   // IN
    PVOID                           KeyValueInformation;        // IN
    ULONG                           Length;                     // IN
    PULONG                          ResultLength;               // OUT
    PVOID                           CallContext;  // new to Windows Vista
    PVOID                           ObjectContext;// new to Windows Vista
    PVOID                           Reserved;     // new to Windows Vista
} REG_QUERY_VALUE_KEY_INFORMATION, *PREG_QUERY_VALUE_KEY_INFORMATION;

typedef struct _REG_QUERY_MULTIPLE_VALUE_KEY_INFORMATION {
    PVOID               Object;                 // IN
    PKEY_VALUE_ENTRY    ValueEntries;           // IN
    ULONG               EntryCount;             // IN
    PVOID               ValueBuffer;            // IN
    PULONG              BufferLength;           // IN OUT
    PULONG              RequiredBufferLength;   // OUT
    PVOID               CallContext;  // new to Windows Vista
    PVOID               ObjectContext;// new to Windows Vista
    PVOID 	            Reserved;     // new to Windows Vista
} REG_QUERY_MULTIPLE_VALUE_KEY_INFORMATION, *PREG_QUERY_MULTIPLE_VALUE_KEY_INFORMATION;

typedef struct _REG_RENAME_KEY_INFORMATION {
    PVOID            Object;    // IN
    PUNICODE_STRING  NewName;   // IN
    PVOID            CallContext;  // new to Windows Vista
    PVOID            ObjectContext;// new to Windows Vista
    PVOID            Reserved;     // new to Windows Vista
} REG_RENAME_KEY_INFORMATION, *PREG_RENAME_KEY_INFORMATION;


typedef struct _REG_KEY_HANDLE_CLOSE_INFORMATION {
    PVOID               Object;         // IN
    PVOID               CallContext;  // new to Windows Vista
    PVOID               ObjectContext;// new to Windows Vista
    PVOID               Reserved;     // new to Windows Vista
} REG_KEY_HANDLE_CLOSE_INFORMATION, *PREG_KEY_HANDLE_CLOSE_INFORMATION;

/* .Net Only */
typedef struct _REG_CREATE_KEY_INFORMATION {
    PUNICODE_STRING     CompleteName; // IN
    PVOID               RootObject;   // IN
    PVOID               ObjectType;   // new to Windows Vista
    ULONG               CreateOptions;// new to Windows Vista
    PUNICODE_STRING     Class;        // new to Windows Vista
    PVOID               SecurityDescriptor;// new to Windows Vista
    PVOID               SecurityQualityOfService;// new to Windows Vista
    ACCESS_MASK         DesiredAccess;// new to Windows Vista
    ACCESS_MASK         GrantedAccess;// new to Windows Vista
			  		                  // to be filled in by callbacks 
                                      // when bypassing native code
    PULONG              Disposition;  // new to Windows Vista
                                      // on pass through, callback should fill 
                                      // in disposition
    PVOID               *ResultObject;// new to Windows Vista
				                      // on pass through, callback should return 
                                      // object to be used for the return handle
    PVOID               CallContext;  // new to Windows Vista
    PVOID               RootObjectContext;  // new to Windows Vista
    PVOID               Transaction;  // new to Windows Vista
    PVOID               Reserved;     // new to Windows Vista
} REG_CREATE_KEY_INFORMATION, REG_OPEN_KEY_INFORMATION,*PREG_CREATE_KEY_INFORMATION, *PREG_OPEN_KEY_INFORMATION;

typedef struct _REG_POST_OPERATION_INFORMATION {
    PVOID               Object;         // IN
    NTSTATUS            Status;         // IN
    PVOID               PreInformation; // new to Windows Vista; identical with the pre information that was sent
                                        // in the pre notification
    NTSTATUS            ReturnStatus;   // new to Windows Vista; callback can now change the outcome of the operation
                                        // during post by returning the new staus here
    PVOID               CallContext;    // new to Windows Vista
    PVOID               ObjectContext;  // new to Windows Vista
    PVOID               Reserved;       // new to Windows Vista
} REG_POST_OPERATION_INFORMATION,*PREG_POST_OPERATION_INFORMATION;
/* end .Net Only */

/* XP only */
typedef struct _REG_PRE_CREATE_KEY_INFORMATION {
    PUNICODE_STRING     CompleteName;   // IN
} REG_PRE_CREATE_KEY_INFORMATION, REG_PRE_OPEN_KEY_INFORMATION,*PREG_PRE_CREATE_KEY_INFORMATION, *PREG_PRE_OPEN_KEY_INFORMATION;;

typedef struct _REG_POST_CREATE_KEY_INFORMATION {
    PUNICODE_STRING     CompleteName;   // IN
    PVOID               Object;         // IN
    NTSTATUS            Status;         // IN
} REG_POST_CREATE_KEY_INFORMATION,REG_POST_OPEN_KEY_INFORMATION, *PREG_POST_CREATE_KEY_INFORMATION, *PREG_POST_OPEN_KEY_INFORMATION;
/* end XP only */

/* new to Windows Vista */
#if (NTDDI_VERSION >= NTDDI_VISTA)
typedef struct _REG_LOAD_KEY_INFORMATION {
    PVOID               Object;
    PUNICODE_STRING     KeyName;
    PUNICODE_STRING     SourceFile;
	ULONG				Flags;
    PVOID               TrustClassObject;
	PVOID               UserEvent;
	ACCESS_MASK         DesiredAccess;
    PHANDLE             RootHandle;
    PVOID               CallContext;  
    PVOID               ObjectContext;
    PVOID               Reserved;     
} REG_LOAD_KEY_INFORMATION, *PREG_LOAD_KEY_INFORMATION;

typedef struct _REG_UNLOAD_KEY_INFORMATION {
    PVOID    Object;                      
    PVOID	 UserEvent;
    PVOID    CallContext;  
    PVOID    ObjectContext;
    PVOID    Reserved;     
} REG_UNLOAD_KEY_INFORMATION, *PREG_UNLOAD_KEY_INFORMATION;

typedef struct _REG_CALLBACK_CONTEXT_CLEANUP_INFORMATION {
    PVOID   Object;
    PVOID   ObjectContext;  
    PVOID   Reserved;     
} REG_CALLBACK_CONTEXT_CLEANUP_INFORMATION, *PREG_CALLBACK_CONTEXT_CLEANUP_INFORMATION;

typedef struct _REG_QUERY_KEY_SECURITY_INFORMATION {
    PVOID                   Object;
    PSECURITY_INFORMATION   SecurityInformation;  // IN
    PSECURITY_DESCRIPTOR    SecurityDescriptor;   // INOUT  
    PULONG                  Length;               // INOUT  
    PVOID                   CallContext;  
    PVOID                   ObjectContext;
    PVOID                   Reserved;     
} REG_QUERY_KEY_SECURITY_INFORMATION, *PREG_QUERY_KEY_SECURITY_INFORMATION;

typedef struct _REG_SET_KEY_SECURITY_INFORMATION {
    PVOID                   Object;
    PSECURITY_INFORMATION   SecurityInformation;  // IN
    PSECURITY_DESCRIPTOR    SecurityDescriptor;   // IN
    PVOID                   CallContext;  
    PVOID                   ObjectContext;
    PVOID                   Reserved;     
} REG_SET_KEY_SECURITY_INFORMATION, *PREG_SET_KEY_SECURITY_INFORMATION;

#endif // NTDDI_VERSION >= NTDDI_VISTA

#if (NTDDI_VERSION >= NTDDI_WINXP)
NTSTATUS
CmRegisterCallback(__in     PEX_CALLBACK_FUNCTION Function,
                   __in_opt PVOID                 Context,
                   __out    PLARGE_INTEGER        Cookie
                    );
NTSTATUS
CmUnRegisterCallback(__in LARGE_INTEGER    Cookie);

#endif // NTDDI_VERSION >= NTDDI_WINXP

#if (NTDDI_VERSION >= NTDDI_VISTA)
NTSTATUS
CmRegisterCallbackEx (  __in        PEX_CALLBACK_FUNCTION   Function,
                        __in        PCUNICODE_STRING        Altitude,
                        __in        PVOID                   Driver, //PDRIVER_OBJECT
                        __in_opt    PVOID                 	Context,
                        __out       PLARGE_INTEGER    	    Cookie,
                        __reserved  PVOID			        Reserved
                    );
VOID 
CmGetCallbackVersion (  __out_opt   PULONG  Major,
                        __out_opt   PULONG  Minor
                        );

NTSTATUS
CmSetCallbackObjectContext (__inout     PVOID	        Object,
                            __in        PLARGE_INTEGER  Cookie,
                            __in        PVOID           NewContext,
                            __out_opt   PVOID           *OldContext
                           );

NTSTATUS
CmCallbackGetKeyObjectID (  __in            PLARGE_INTEGER      Cookie,
                            __in 	        PVOID	            Object,
                            __out_opt       PULONG_PTR          ObjectID,
                            __deref_opt_out PCUNICODE_STRING    *ObjectName
                           );

PVOID
CmGetBoundTransaction(__in  PLARGE_INTEGER  Cookie,
                      __in	PVOID	        Object );

#endif // NTDDI_VERSION >= NTDDI_VISTA

//
// Priority increment definitions.  The comment for each definition gives
// the names of the system services that use the definition when satisfying
// a wait.
//

//
// Priority increment used when satisfying a wait on an executive event
// (NtPulseEvent and NtSetEvent)
//

#define EVENT_INCREMENT                 1

//
// Priority increment when no I/O has been done.  This is used by device
// and file system drivers when completing an IRP (IoCompleteRequest).
//

#define IO_NO_INCREMENT                 0


//
// Priority increment for completing CD-ROM I/O.  This is used by CD-ROM device
// and file system drivers when completing an IRP (IoCompleteRequest)
//

#define IO_CD_ROM_INCREMENT             1

//
// Priority increment for completing disk I/O.  This is used by disk device
// and file system drivers when completing an IRP (IoCompleteRequest)
//

#define IO_DISK_INCREMENT               1



//
// Priority increment for completing keyboard I/O.  This is used by keyboard
// device drivers when completing an IRP (IoCompleteRequest)
//

#define IO_KEYBOARD_INCREMENT           6


//
// Priority increment for completing mailslot I/O.  This is used by the mail-
// slot file system driver when completing an IRP (IoCompleteRequest).
//

#define IO_MAILSLOT_INCREMENT           2


//
// Priority increment for completing mouse I/O.  This is used by mouse device
// drivers when completing an IRP (IoCompleteRequest)
//

#define IO_MOUSE_INCREMENT              6


//
// Priority increment for completing named pipe I/O.  This is used by the
// named pipe file system driver when completing an IRP (IoCompleteRequest).
//

#define IO_NAMED_PIPE_INCREMENT         2

//
// Priority increment for completing network I/O.  This is used by network
// device and network file system drivers when completing an IRP
// (IoCompleteRequest).
//

#define IO_NETWORK_INCREMENT            2


//
// Priority increment for completing parallel I/O.  This is used by parallel
// device drivers when completing an IRP (IoCompleteRequest)
//

#define IO_PARALLEL_INCREMENT           1

//
// Priority increment for completing serial I/O.  This is used by serial device
// drivers when completing an IRP (IoCompleteRequest)
//

#define IO_SERIAL_INCREMENT             2

//
// Priority increment for completing sound I/O.  This is used by sound device
// drivers when completing an IRP (IoCompleteRequest)
//

#define IO_SOUND_INCREMENT              8

//
// Priority increment for completing video I/O.  This is used by video device
// drivers when completing an IRP (IoCompleteRequest)
//

#define IO_VIDEO_INCREMENT              1

//
// Priority increment used when satisfying a wait on an executive semaphore
// (NtReleaseSemaphore)
//

#define SEMAPHORE_INCREMENT             1

//
//  Indicates the system may do I/O to physical addresses above 4 GB.
//

extern PBOOLEAN Mm64BitPhysicalAddress;


//
//  Provides a known bad pointer address which always bugchecks if
//  acccessed.   This gives drivers a way to find pointer bugs by
//  initializing invalid pointers to this value.
//

extern PVOID MmBadPointer;

//
// Define the old maximum disk transfer size to be used by MM and Cache
// Manager.  Current transfer sizes can typically be much larger.
//

#define MM_MAXIMUM_DISK_IO_SIZE          (0x10000)

//++
//
// ULONG_PTR
// ROUND_TO_PAGES (
//     __in ULONG_PTR Size
//     )
//
// Routine Description:
//
//     The ROUND_TO_PAGES macro takes a size in bytes and rounds it up to a
//     multiple of the page size.
//
//     NOTE: This macro fails for values 0xFFFFFFFF - (PAGE_SIZE - 1).
//
// Arguments:
//
//     Size - Size in bytes to round up to a page multiple.
//
// Return Value:
//
//     Returns the size rounded up to a multiple of the page size.
//
//--

#define ROUND_TO_PAGES(Size)  (((ULONG_PTR)(Size) + PAGE_SIZE - 1) & ~(PAGE_SIZE - 1))

//++
//
// ULONG
// BYTES_TO_PAGES (
//     __in ULONG Size
//     )
//
// Routine Description:
//
//     The BYTES_TO_PAGES macro takes the size in bytes and calculates the
//     number of pages required to contain the bytes.
//
// Arguments:
//
//     Size - Size in bytes.
//
// Return Value:
//
//     Returns the number of pages required to contain the specified size.
//
//--

#define BYTES_TO_PAGES(Size)  (((Size) >> PAGE_SHIFT) + \
                               (((Size) & (PAGE_SIZE - 1)) != 0))

//++
//
// ULONG
// BYTE_OFFSET (
//     __in PVOID Va
//     )
//
// Routine Description:
//
//     The BYTE_OFFSET macro takes a virtual address and returns the byte offset
//     of that address within the page.
//
// Arguments:
//
//     Va - Virtual address.
//
// Return Value:
//
//     Returns the byte offset portion of the virtual address.
//
//--

#define BYTE_OFFSET(Va) ((ULONG)((LONG_PTR)(Va) & (PAGE_SIZE - 1)))

//++
//
// PVOID
// PAGE_ALIGN (
//     __in PVOID Va
//     )
//
// Routine Description:
//
//     The PAGE_ALIGN macro takes a virtual address and returns a page-aligned
//     virtual address for that page.
//
// Arguments:
//
//     Va - Virtual address.
//
// Return Value:
//
//     Returns the page aligned virtual address.
//
//--

#define PAGE_ALIGN(Va) ((PVOID)((ULONG_PTR)(Va) & ~(PAGE_SIZE - 1)))

//++
//
// ULONG
// ADDRESS_AND_SIZE_TO_SPAN_PAGES (
//     __in PVOID Va,
//     __in ULONG Size
//     )
//
// Routine Description:
//
//     The ADDRESS_AND_SIZE_TO_SPAN_PAGES macro takes a virtual address and
//     size and returns the number of pages spanned by the size.
//
// Arguments:
//
//     Va - Virtual address.
//
//     Size - Size in bytes.
//
// Return Value:
//
//     Returns the number of pages spanned by the size.
//
//--

#define ADDRESS_AND_SIZE_TO_SPAN_PAGES(Va,Size) \
    ((ULONG)((((ULONG_PTR)(Size)) >> PAGE_SHIFT) + ((BYTE_OFFSET (Va) + BYTE_OFFSET (Size) + PAGE_SIZE - 1) >> PAGE_SHIFT)))

#if PRAGMA_DEPRECATED_DDK
#pragma deprecated(COMPUTE_PAGES_SPANNED)   // Use ADDRESS_AND_SIZE_TO_SPAN_PAGES
#endif

#define COMPUTE_PAGES_SPANNED(Va, Size) ADDRESS_AND_SIZE_TO_SPAN_PAGES(Va,Size)


//++
// PPFN_NUMBER
// MmGetMdlPfnArray (
//     __in PMDL Mdl
//     )
//
// Routine Description:
//
//     The MmGetMdlPfnArray routine returns the virtual address of the
//     first element of the array of physical page numbers associated with
//     the MDL.
//
// Arguments:
//
//     Mdl - Pointer to an MDL.
//
// Return Value:
//
//     Returns the virtual address of the first element of the array of
//     physical page numbers associated with the MDL.
//
//--

#define MmGetMdlPfnArray(Mdl) ((PPFN_NUMBER)(Mdl + 1))

//++
//
// PVOID
// MmGetMdlVirtualAddress (
//     __in PMDL Mdl
//     )
//
// Routine Description:
//
//     The MmGetMdlVirtualAddress returns the virtual address of the buffer
//     described by the Mdl.
//
// Arguments:
//
//     Mdl - Pointer to an MDL.
//
// Return Value:
//
//     Returns the virtual address of the buffer described by the Mdl
//
//--

#define MmGetMdlVirtualAddress(Mdl)                                     \
    ((PVOID) ((PCHAR) ((Mdl)->StartVa) + (Mdl)->ByteOffset))

//++
//
// ULONG
// MmGetMdlByteCount (
//     __in PMDL Mdl
//     )
//
// Routine Description:
//
//     The MmGetMdlByteCount returns the length in bytes of the buffer
//     described by the Mdl.
//
// Arguments:
//
//     Mdl - Pointer to an MDL.
//
// Return Value:
//
//     Returns the byte count of the buffer described by the Mdl
//
//--

#define MmGetMdlByteCount(Mdl)  ((Mdl)->ByteCount)

//++
//
// ULONG
// MmGetMdlByteOffset (
//     __in PMDL Mdl
//     )
//
// Routine Description:
//
//     The MmGetMdlByteOffset returns the byte offset within the page
//     of the buffer described by the Mdl.
//
// Arguments:
//
//     Mdl - Pointer to an MDL.
//
// Return Value:
//
//     Returns the byte offset within the page of the buffer described by the Mdl
//
//--

#define MmGetMdlByteOffset(Mdl)  ((Mdl)->ByteOffset)

//++
//
// PVOID
// MmGetMdlStartVa (
//     __in PMDL Mdl
//     )
//
// Routine Description:
//
//     The MmGetMdlBaseVa returns the virtual address of the buffer
//     described by the Mdl rounded down to the nearest page.
//
// Arguments:
//
//     Mdl - Pointer to an MDL.
//
// Return Value:
//
//     Returns the returns the starting virtual address of the MDL.
//
//
//--

#define MmGetMdlBaseVa(Mdl)  ((Mdl)->StartVa)

typedef enum _MM_SYSTEM_SIZE {
    MmSmallSystem,
    MmMediumSystem,
    MmLargeSystem
} MM_SYSTEMSIZE;

#if (NTDDI_VERSION >= NTDDI_WIN2K)
NTKERNELAPI
MM_SYSTEMSIZE
MmQuerySystemSize (
    VOID
    );
#endif


#if (NTDDI_VERSION >= NTDDI_WINXP)
NTKERNELAPI
NTSTATUS
MmIsVerifierEnabled (
    __out PULONG VerifierFlags
    );
#endif

#if (NTDDI_VERSION >= NTDDI_WINXP)
NTKERNELAPI
NTSTATUS
MmAddVerifierThunks (
    __in_bcount (ThunkBufferSize) PVOID ThunkBuffer,
    __in ULONG ThunkBufferSize
    );
#endif


#if (NTDDI_VERSION >= NTDDI_WIN2K)
NTKERNELAPI
VOID
MmProbeAndLockProcessPages (
    __inout PMDL MemoryDescriptorList,
    __in PEPROCESS Process,
    __in KPROCESSOR_MODE AccessMode,
    __in LOCK_OPERATION Operation
    );
#endif

//
// I/O support routines.
//

#if (NTDDI_VERSION >= NTDDI_WIN2K)
NTKERNELAPI
VOID
MmProbeAndLockPages (
    __inout PMDLX MemoryDescriptorList,
    __in KPROCESSOR_MODE AccessMode,
    __in LOCK_OPERATION Operation
    );
#endif

#if (NTDDI_VERSION >= NTDDI_WIN2K)
NTKERNELAPI
VOID
MmUnlockPages (
    __inout PMDLX MemoryDescriptorList
    );
#endif

#if (NTDDI_VERSION >= NTDDI_WIN2K)
NTKERNELAPI
VOID
MmBuildMdlForNonPagedPool (
    __inout PMDLX MemoryDescriptorList
    );
#endif

#if (NTDDI_VERSION >= NTDDI_WIN2K)
DECLSPEC_DEPRECATED_DDK
NTKERNELAPI
PVOID
MmMapLockedPages (
    __in PMDL MemoryDescriptorList,
    __in KPROCESSOR_MODE AccessMode
    );
#endif

#if (NTDDI_VERSION >= NTDDI_WS03)
NTKERNELAPI
LOGICAL
MmIsIoSpaceActive (
    __in PHYSICAL_ADDRESS StartAddress,
    __in SIZE_T NumberOfBytes
    );
#endif

#if (NTDDI_VERSION >= NTDDI_WIN2K)
NTKERNELAPI
PVOID
MmGetSystemRoutineAddress (
    __in PUNICODE_STRING SystemRoutineName
    );
#endif

#if (NTDDI_VERSION >= NTDDI_WINXP)
NTKERNELAPI
NTSTATUS
MmAdvanceMdl (
    __inout PMDLX Mdl,
    __in ULONG NumberOfBytes
    );
#endif

#if (NTDDI_VERSION >= NTDDI_WINXP)
NTKERNELAPI
NTSTATUS
MmProtectMdlSystemAddress (
    __in PMDLX MemoryDescriptorList,
    __in ULONG NewProtect
    );
#endif

//
// _MM_PAGE_PRIORITY_ provides a method for the system to handle requests
// intelligently in low resource conditions.
//
// LowPagePriority should be used when it is acceptable to the driver for the
// mapping request to fail if the system is low on resources.  An example of
// this could be for a non-critical network connection where the driver can
// handle the failure case when system resources are close to being depleted.
//
// NormalPagePriority should be used when it is acceptable to the driver for the
// mapping request to fail if the system is very low on resources.  An example
// of this could be for a non-critical local filesystem request.
//
// HighPagePriority should be used when it is unacceptable to the driver for the
// mapping request to fail unless the system is completely out of resources.
// An example of this would be the paging file path in a driver.
//



typedef enum _MM_PAGE_PRIORITY {
    LowPagePriority,
    NormalPagePriority = 16,
    HighPagePriority = 32
} MM_PAGE_PRIORITY;



//
// Note: This function is not available in WDM 1.0
//
#if (NTDDI_VERSION >= NTDDI_WIN2K)
NTKERNELAPI
PVOID
MmMapLockedPagesSpecifyCache (
     __in PMDLX MemoryDescriptorList,
     __in KPROCESSOR_MODE AccessMode,
     __in MEMORY_CACHING_TYPE CacheType,
     __in_opt PVOID BaseAddress,
     __in ULONG BugCheckOnFailure,
     __in MM_PAGE_PRIORITY Priority
     );
#endif

#if (NTDDI_VERSION >= NTDDI_WIN2K)
NTKERNELAPI
VOID
MmUnmapLockedPages (
    __in PVOID BaseAddress,
    __in PMDL MemoryDescriptorList
    );
#endif

#if (NTDDI_VERSION >= NTDDI_WINXP)
NTKERNELAPI
__out_bcount_opt (NumberOfBytes) PVOID
MmAllocateMappingAddress (
     __in SIZE_T NumberOfBytes,
     __in ULONG PoolTag
     );
#endif

#if (NTDDI_VERSION >= NTDDI_WINXP)
NTKERNELAPI
VOID
MmFreeMappingAddress (
     __in PVOID BaseAddress,
     __in ULONG PoolTag
     );
#endif

#if (NTDDI_VERSION >= NTDDI_WINXP)
NTKERNELAPI
PVOID
MmMapLockedPagesWithReservedMapping (
    __in PVOID MappingAddress,
    __in ULONG PoolTag,
    __in PMDLX MemoryDescriptorList,
    __in MEMORY_CACHING_TYPE CacheType
    );
#endif

#if (NTDDI_VERSION >= NTDDI_WINXP)
NTKERNELAPI
VOID
MmUnmapReservedMapping (
     __in PVOID BaseAddress,
     __in ULONG PoolTag,
     __in PMDLX MemoryDescriptorList
     );
#endif


#define MM_DONT_ZERO_ALLOCATION             0x00000001
#define MM_ALLOCATE_FROM_LOCAL_NODE_ONLY    0x00000002

#if (NTDDI_VERSION >= NTDDI_WS03SP1)
NTKERNELAPI
PMDL
MmAllocatePagesForMdlEx (
    __in PHYSICAL_ADDRESS LowAddress,
    __in PHYSICAL_ADDRESS HighAddress,
    __in PHYSICAL_ADDRESS SkipBytes,
    __in SIZE_T TotalBytes,
    __in MEMORY_CACHING_TYPE CacheType,
    __in ULONG Flags
    );
#endif

#if (NTDDI_VERSION >= NTDDI_WIN2K)
NTKERNELAPI
PMDL
MmAllocatePagesForMdl (
    __in PHYSICAL_ADDRESS LowAddress,
    __in PHYSICAL_ADDRESS HighAddress,
    __in PHYSICAL_ADDRESS SkipBytes,
    __in SIZE_T TotalBytes
    );
#endif

#if (NTDDI_VERSION >= NTDDI_WIN2K)
NTKERNELAPI
VOID
MmFreePagesFromMdl (
    __in PMDLX MemoryDescriptorList
    );
#endif

#if (NTDDI_VERSION >= NTDDI_WIN2K)
NTKERNELAPI
__out_bcount_opt (NumberOfBytes) PVOID
MmMapIoSpace (
    __in PHYSICAL_ADDRESS PhysicalAddress,
    __in SIZE_T NumberOfBytes,
    __in MEMORY_CACHING_TYPE CacheType
    );
#endif

#if (NTDDI_VERSION >= NTDDI_WIN2K)
NTKERNELAPI
VOID
MmUnmapIoSpace (
    __in_bcount (NumberOfBytes) PVOID BaseAddress,
    __in SIZE_T NumberOfBytes
    );
#endif


#if (NTDDI_VERSION >= NTDDI_WIN2K)
NTKERNELAPI
SIZE_T
MmSizeOfMdl (
    __in_bcount_opt (Length) PVOID Base,
    __in SIZE_T Length
    );
#endif

#if (NTDDI_VERSION >= NTDDI_WIN2K)
DECLSPEC_DEPRECATED_DDK                 // Use IoAllocateMdl
NTKERNELAPI
PMDL
MmCreateMdl (
    __in_opt PMDL MemoryDescriptorList,
    __in_bcount_opt (Length) PVOID Base,
    __in SIZE_T Length
    );
#endif

#if (NTDDI_VERSION >= NTDDI_WIN2K)
NTKERNELAPI
PVOID
MmLockPagableDataSection (
    __in PVOID AddressWithinSection
    );
#endif

#if (NTDDI_VERSION >= NTDDI_WIN2K)
NTKERNELAPI
VOID
MmResetDriverPaging (
    __in PVOID AddressWithinSection
    );
#endif

#if (NTDDI_VERSION >= NTDDI_WIN2K)
NTKERNELAPI
PVOID
MmPageEntireDriver (
    __in PVOID AddressWithinSection
    );
#endif

#if (NTDDI_VERSION >= NTDDI_WIN2K)
NTKERNELAPI
VOID
MmUnlockPagableImageSection (
    __in PVOID ImageSectionHandle
    );
#endif


//++
//
// VOID
// MmInitializeMdl (
//     __in PMDL MemoryDescriptorList,
//     __in PVOID BaseVa,
//     __in SIZE_T Length
//     )
//
// Routine Description:
//
//     This routine initializes the header of a Memory Descriptor List (MDL).
//
// Arguments:
//
//     MemoryDescriptorList - Pointer to the MDL to initialize.
//
//     BaseVa - Base virtual address mapped by the MDL.
//
//     Length - Length, in bytes, of the buffer mapped by the MDL.
//
// Return Value:
//
//     None.
//
//--

#define MmInitializeMdl(MemoryDescriptorList, BaseVa, Length) { \
    (MemoryDescriptorList)->Next = (PMDL) NULL; \
    (MemoryDescriptorList)->Size = (CSHORT)(sizeof(MDL) +  \
            (sizeof(PFN_NUMBER) * ADDRESS_AND_SIZE_TO_SPAN_PAGES((BaseVa), (Length)))); \
    (MemoryDescriptorList)->MdlFlags = 0; \
    (MemoryDescriptorList)->StartVa = (PVOID) PAGE_ALIGN((BaseVa)); \
    (MemoryDescriptorList)->ByteOffset = BYTE_OFFSET((BaseVa)); \
    (MemoryDescriptorList)->ByteCount = (ULONG)(Length); \
    }

//++
//
// PVOID
// MmGetSystemAddressForMdlSafe (
//     __in PMDL MDL,
//     __in MM_PAGE_PRIORITY PRIORITY
//     )
//
// Routine Description:
//
//     This routine returns the mapped address of an MDL. If the
//     Mdl is not already mapped or a system address, it is mapped.
//
// Arguments:
//
//     MemoryDescriptorList - Pointer to the MDL to map.
//
//     Priority - Supplies an indication as to how important it is that this
//                request succeed under low available PTE conditions.
//
// Return Value:
//
//     Returns the base address where the pages are mapped.  The base address
//     has the same offset as the virtual address in the MDL.
//
//     Unlike MmGetSystemAddressForMdl, Safe guarantees that it will always
//     return NULL on failure instead of bugchecking the system.
//
//     This macro is not usable by WDM 1.0 drivers as 1.0 did not include
//     MmMapLockedPagesSpecifyCache.  The solution for WDM 1.0 drivers is to
//     provide synchronization and set/reset the MDL_MAPPING_CAN_FAIL bit.
//
//--

#define MmGetSystemAddressForMdlSafe(MDL, PRIORITY)                    \
     (((MDL)->MdlFlags & (MDL_MAPPED_TO_SYSTEM_VA |                    \
                        MDL_SOURCE_IS_NONPAGED_POOL)) ?                \
                             ((MDL)->MappedSystemVa) :                 \
                             (MmMapLockedPagesSpecifyCache((MDL),      \
                                                           KernelMode, \
                                                           MmCached,   \
                                                           NULL,       \
                                                           FALSE,      \
                                                           (PRIORITY))))

//++
//
// PVOID
// MmGetSystemAddressForMdl (
//     __in PMDL MDL
//     )
//
// Routine Description:
//
//     This routine returns the mapped address of an MDL, if the
//     Mdl is not already mapped or a system address, it is mapped.
//
// Arguments:
//
//     MemoryDescriptorList - Pointer to the MDL to map.
//
// Return Value:
//
//     Returns the base address where the pages are mapped.  The base address
//     has the same offset as the virtual address in the MDL.
//
//--

//#define MmGetSystemAddressForMdl(MDL)
//     (((MDL)->MdlFlags & (MDL_MAPPED_TO_SYSTEM_VA)) ?
//                             ((MDL)->MappedSystemVa) :
//                ((((MDL)->MdlFlags & (MDL_SOURCE_IS_NONPAGED_POOL)) ?
//                      ((PVOID)((ULONG)(MDL)->StartVa | (MDL)->ByteOffset)) :
//                            (MmMapLockedPages((MDL),KernelMode)))))

#if PRAGMA_DEPRECATED_DDK
#pragma deprecated(MmGetSystemAddressForMdl)    // Use MmGetSystemAddressForMdlSafe
#endif

#define MmGetSystemAddressForMdl(MDL)                                  \
     (((MDL)->MdlFlags & (MDL_MAPPED_TO_SYSTEM_VA |                    \
                        MDL_SOURCE_IS_NONPAGED_POOL)) ?                \
                             ((MDL)->MappedSystemVa) :                 \
                             (MmMapLockedPages((MDL),KernelMode)))

//++
//
// VOID
// MmPrepareMdlForReuse (
//     __in PMDL MDL
//     )
//
// Routine Description:
//
//     This routine will take all of the steps necessary to allow an MDL to be
//     re-used.
//
// Arguments:
//
//     MemoryDescriptorList - Pointer to the MDL that will be re-used.
//
// Return Value:
//
//     None.
//
//--

#define MmPrepareMdlForReuse(MDL)                                       \
    if (((MDL)->MdlFlags & MDL_PARTIAL_HAS_BEEN_MAPPED) != 0) {         \
        ASSERT(((MDL)->MdlFlags & MDL_PARTIAL) != 0);                   \
        MmUnmapLockedPages( (MDL)->MappedSystemVa, (MDL) );             \
    } else if (((MDL)->MdlFlags & MDL_PARTIAL) == 0) {                  \
        ASSERT(((MDL)->MdlFlags & MDL_MAPPED_TO_SYSTEM_VA) == 0);       \
    }

typedef NTSTATUS (*PMM_DLL_INITIALIZE) (
    IN PUNICODE_STRING RegistryPath
    );

typedef NTSTATUS (*PMM_DLL_UNLOAD) (
    VOID
    );



//
// Define an empty typedef for the _DRIVER_OBJECT structure so it may be
// referenced by function types before it is actually defined.
//
struct _DRIVER_OBJECT;

#if (NTDDI_VERSION >= NTDDI_WIN2K)
NTKERNELAPI
LOGICAL
MmIsDriverVerifying (
    __in struct _DRIVER_OBJECT *DriverObject
    );
#endif

#if (NTDDI_VERSION >= NTDDI_VISTA)
NTKERNELAPI
LOGICAL
MmIsDriverVerifyingByAddress (
    __in PVOID AddressWithinSection
    );
#endif

//
//  Security operation codes
//

typedef enum _SECURITY_OPERATION_CODE {
    SetSecurityDescriptor,
    QuerySecurityDescriptor,
    DeleteSecurityDescriptor,
    AssignSecurityDescriptor
    } SECURITY_OPERATION_CODE, *PSECURITY_OPERATION_CODE;

//
//  Data structure used to capture subject security context
//  for access validations and auditing.
//
//  THE FIELDS OF THIS DATA STRUCTURE SHOULD BE CONSIDERED OPAQUE
//  BY ALL EXCEPT THE SECURITY ROUTINES.
//

typedef struct _SECURITY_SUBJECT_CONTEXT {
    PACCESS_TOKEN ClientToken;
    SECURITY_IMPERSONATION_LEVEL ImpersonationLevel;
    PACCESS_TOKEN PrimaryToken;
    PVOID ProcessAuditId;
    } SECURITY_SUBJECT_CONTEXT, *PSECURITY_SUBJECT_CONTEXT;

///////////////////////////////////////////////////////////////////////////////
//                                                                           //
//                  ACCESS_STATE and related structures                      //
//                                                                           //
///////////////////////////////////////////////////////////////////////////////

//
//  Initial Privilege Set - Room for three privileges, which should
//  be enough for most applications.  This structure exists so that
//  it can be imbedded in an ACCESS_STATE structure.  Use PRIVILEGE_SET
//  for all other references to Privilege sets.
//

#define INITIAL_PRIVILEGE_COUNT         3

typedef struct _INITIAL_PRIVILEGE_SET {
    ULONG PrivilegeCount;
    ULONG Control;
    LUID_AND_ATTRIBUTES Privilege[INITIAL_PRIVILEGE_COUNT];
    } INITIAL_PRIVILEGE_SET, * PINITIAL_PRIVILEGE_SET;



//
// Combine the information that describes the state
// of an access-in-progress into a single structure
//


typedef struct _ACCESS_STATE {
   LUID OperationID;                // Currently unused, replaced by TransactionId in AUX_ACCESS_DATA
   BOOLEAN SecurityEvaluated;
   BOOLEAN GenerateAudit;
   BOOLEAN GenerateOnClose;
   BOOLEAN PrivilegesAllocated;
   ULONG Flags;
   ACCESS_MASK RemainingDesiredAccess;
   ACCESS_MASK PreviouslyGrantedAccess;
   ACCESS_MASK OriginalDesiredAccess;
   SECURITY_SUBJECT_CONTEXT SubjectSecurityContext;
   PSECURITY_DESCRIPTOR SecurityDescriptor;
   PVOID AuxData;
   union {
      INITIAL_PRIVILEGE_SET InitialPrivilegeSet;
      PRIVILEGE_SET PrivilegeSet;
      } Privileges;

   BOOLEAN AuditPrivileges;
   UNICODE_STRING ObjectName;
   UNICODE_STRING ObjectTypeName;

   } ACCESS_STATE, *PACCESS_STATE;


#if (NTDDI_VERSION >= NTDDI_WIN2K)
NTKERNELAPI
VOID
SeCaptureSubjectContext (
    __out PSECURITY_SUBJECT_CONTEXT SubjectContext
    );
#endif

#if (NTDDI_VERSION >= NTDDI_WIN2K)
NTKERNELAPI
VOID
SeLockSubjectContext(
    __in PSECURITY_SUBJECT_CONTEXT SubjectContext
    );
#endif

#if (NTDDI_VERSION >= NTDDI_WIN2K)
NTKERNELAPI
VOID
SeUnlockSubjectContext(
    __in PSECURITY_SUBJECT_CONTEXT SubjectContext
    );
#endif

#if (NTDDI_VERSION >= NTDDI_WIN2K)
NTKERNELAPI
VOID
SeReleaseSubjectContext (
    __inout PSECURITY_SUBJECT_CONTEXT SubjectContext
    );
#endif


#if (NTDDI_VERSION >= NTDDI_WIN2K)
NTKERNELAPI
NTSTATUS
SeAssignSecurity (
    __in_opt PSECURITY_DESCRIPTOR ParentDescriptor,
    __in_opt PSECURITY_DESCRIPTOR ExplicitDescriptor,
    __out PSECURITY_DESCRIPTOR *NewDescriptor,
    __in BOOLEAN IsDirectoryObject,
    __in PSECURITY_SUBJECT_CONTEXT SubjectContext,
    __in PGENERIC_MAPPING GenericMapping,
    __in POOL_TYPE PoolType
    );
#endif

#if (NTDDI_VERSION >= NTDDI_VISTA)
NTKERNELAPI
ULONG
SeComputeAutoInheritByObjectType(
    __in PVOID ObjectType,
    __in_opt PSECURITY_DESCRIPTOR SecurityDescriptor,
    __in_opt PSECURITY_DESCRIPTOR ParentSecurityDescriptor
    );
#endif

#if (NTDDI_VERSION >= NTDDI_WIN2K)
NTKERNELAPI
NTSTATUS
SeAssignSecurityEx (
    __in_opt PSECURITY_DESCRIPTOR ParentDescriptor,
    __in_opt PSECURITY_DESCRIPTOR ExplicitDescriptor,
    __out PSECURITY_DESCRIPTOR *NewDescriptor,
    __in_opt GUID *ObjectType,
    __in BOOLEAN IsDirectoryObject,
    __in ULONG AutoInheritFlags,
    __in PSECURITY_SUBJECT_CONTEXT SubjectContext,
    __in PGENERIC_MAPPING GenericMapping,
    __in POOL_TYPE PoolType
    );
#endif

#if (NTDDI_VERSION >= NTDDI_WIN2K)
NTKERNELAPI
NTSTATUS
SeDeassignSecurity (
    __deref_inout PSECURITY_DESCRIPTOR *SecurityDescriptor
    );
#endif

#if (NTDDI_VERSION >= NTDDI_WIN2K)
NTKERNELAPI
ULONG
SeObjectCreateSaclAccessBits(
    __in PSECURITY_DESCRIPTOR SecurityDescriptor
    );

NTKERNELAPI
BOOLEAN
SeAccessCheck (
    __in PSECURITY_DESCRIPTOR SecurityDescriptor,
    __in PSECURITY_SUBJECT_CONTEXT SubjectSecurityContext,
    __in BOOLEAN SubjectContextLocked,
    __in ACCESS_MASK DesiredAccess,
    __in ACCESS_MASK PreviouslyGrantedAccess,
    __deref_opt_out PPRIVILEGE_SET *Privileges,
    __in PGENERIC_MAPPING GenericMapping,
    __in KPROCESSOR_MODE AccessMode,
    __out PACCESS_MASK GrantedAccess,
    __out PNTSTATUS AccessStatus
    );
#endif

#ifdef SE_NTFS_WORLD_CACHE

#if (NTDDI_VERSION >= NTDDI_VISTA)
VOID
SeGetWorldRights (
    __in PSECURITY_DESCRIPTOR SecurityDescriptor,
    __in PGENERIC_MAPPING GenericMapping,
    __out PACCESS_MASK GrantedAccess
    );
#endif

#endif

#if (NTDDI_VERSION >= NTDDI_WS03SP1)
NTSTATUS
SeSetAuditParameter(
    __inout PSE_ADT_PARAMETER_ARRAY AuditParameters,
    __in SE_ADT_PARAMETER_TYPE Type,
    __in ULONG Index,
    __in PVOID Data
    );
#endif

#if (NTDDI_VERSION >= NTDDI_WS03SP1)
NTSTATUS
SeReportSecurityEvent(
    __in ULONG Flags,
    __in PUNICODE_STRING SourceName,
    __in_opt PSID UserSid,
    __in PSE_ADT_PARAMETER_ARRAY AuditParameters
    );
#endif


#if (NTDDI_VERSION >= NTDDI_WIN2K)
NTKERNELAPI
BOOLEAN
SeValidSecurityDescriptor(
    __in ULONG Length,
    __in_bcount(Length) PSECURITY_DESCRIPTOR SecurityDescriptor
    );
#endif


#if !defined(_PSGETCURRENTTHREAD_)

#define _PSGETCURRENTTHREAD_

FORCEINLINE
PETHREAD
PsGetCurrentThread (
    VOID
    )

/*++

Routine Description:

    This function returns a pointer to the current executive thread object.

Arguments:

    None.

Return Value:

    A pointer to the current executive thread object.

--*/

{

    return (PETHREAD)KeGetCurrentThread();
}

#endif

//
// System Thread and Process Creation and Termination
//

#if (NTDDI_VERSION >= NTDDI_WIN2K)
NTKERNELAPI
__checkReturn
NTSTATUS
PsCreateSystemThread(
    __out PHANDLE ThreadHandle,
    __in ULONG DesiredAccess,
    __in_opt POBJECT_ATTRIBUTES ObjectAttributes,
    __in_opt  HANDLE ProcessHandle,
    __out_opt PCLIENT_ID ClientId,
    __in PKSTART_ROUTINE StartRoutine,
    __in_opt PVOID StartContext
    );
#endif

#if (NTDDI_VERSION >= NTDDI_WIN2K)
NTKERNELAPI
NTSTATUS
PsTerminateSystemThread(
    __in NTSTATUS ExitStatus
    );
#endif

NTKERNELAPI
NTSTATUS
PsWrapApcWow64Thread (
    __inout PVOID *ApcContext,
    __inout PVOID *ApcRoutine);


//
// Define I/O system data structure type codes.  Each major data structure in
// the I/O system has a type code  The type field in each structure is at the
// same offset.  The following values can be used to determine which type of
// data structure a pointer refers to.
//

#define IO_TYPE_ADAPTER                 0x00000001
#define IO_TYPE_CONTROLLER              0x00000002
#define IO_TYPE_DEVICE                  0x00000003
#define IO_TYPE_DRIVER                  0x00000004
#define IO_TYPE_FILE                    0x00000005
#define IO_TYPE_IRP                     0x00000006
#define IO_TYPE_MASTER_ADAPTER          0x00000007
#define IO_TYPE_OPEN_PACKET             0x00000008
#define IO_TYPE_TIMER                   0x00000009
#define IO_TYPE_VPB                     0x0000000a
#define IO_TYPE_ERROR_LOG               0x0000000b
#define IO_TYPE_ERROR_MESSAGE           0x0000000c
#define IO_TYPE_DEVICE_OBJECT_EXTENSION 0x0000000d


//
// Define the major function codes for IRPs.
//


#define IRP_MJ_CREATE                   0x00
#define IRP_MJ_CREATE_NAMED_PIPE        0x01
#define IRP_MJ_CLOSE                    0x02
#define IRP_MJ_READ                     0x03
#define IRP_MJ_WRITE                    0x04
#define IRP_MJ_QUERY_INFORMATION        0x05
#define IRP_MJ_SET_INFORMATION          0x06
#define IRP_MJ_QUERY_EA                 0x07
#define IRP_MJ_SET_EA                   0x08
#define IRP_MJ_FLUSH_BUFFERS            0x09
#define IRP_MJ_QUERY_VOLUME_INFORMATION 0x0a
#define IRP_MJ_SET_VOLUME_INFORMATION   0x0b
#define IRP_MJ_DIRECTORY_CONTROL        0x0c
#define IRP_MJ_FILE_SYSTEM_CONTROL      0x0d
#define IRP_MJ_DEVICE_CONTROL           0x0e
#define IRP_MJ_INTERNAL_DEVICE_CONTROL  0x0f
#define IRP_MJ_SHUTDOWN                 0x10
#define IRP_MJ_LOCK_CONTROL             0x11
#define IRP_MJ_CLEANUP                  0x12
#define IRP_MJ_CREATE_MAILSLOT          0x13
#define IRP_MJ_QUERY_SECURITY           0x14
#define IRP_MJ_SET_SECURITY             0x15
#define IRP_MJ_POWER                    0x16
#define IRP_MJ_SYSTEM_CONTROL           0x17
#define IRP_MJ_DEVICE_CHANGE            0x18
#define IRP_MJ_QUERY_QUOTA              0x19
#define IRP_MJ_SET_QUOTA                0x1a
#define IRP_MJ_PNP                      0x1b
#define IRP_MJ_PNP_POWER                IRP_MJ_PNP      // Obsolete....
#define IRP_MJ_MAXIMUM_FUNCTION         0x1b

//
// Make the Scsi major code the same as internal device control.
//

#define IRP_MJ_SCSI                     IRP_MJ_INTERNAL_DEVICE_CONTROL

//
// Define the minor function codes for IRPs.  The lower 128 codes, from 0x00 to
// 0x7f are reserved to Microsoft.  The upper 128 codes, from 0x80 to 0xff, are
// reserved to customers of Microsoft.
//

//
// Device Control Request minor function codes for SCSI support. Note that
// user requests are assumed to be zero.
//

#define IRP_MN_SCSI_CLASS               0x01

//
// PNP minor function codes.
//

#define IRP_MN_START_DEVICE                 0x00
#define IRP_MN_QUERY_REMOVE_DEVICE          0x01
#define IRP_MN_REMOVE_DEVICE                0x02
#define IRP_MN_CANCEL_REMOVE_DEVICE         0x03
#define IRP_MN_STOP_DEVICE                  0x04
#define IRP_MN_QUERY_STOP_DEVICE            0x05
#define IRP_MN_CANCEL_STOP_DEVICE           0x06

#define IRP_MN_QUERY_DEVICE_RELATIONS       0x07
#define IRP_MN_QUERY_INTERFACE              0x08
#define IRP_MN_QUERY_CAPABILITIES           0x09
#define IRP_MN_QUERY_RESOURCES              0x0A
#define IRP_MN_QUERY_RESOURCE_REQUIREMENTS  0x0B
#define IRP_MN_QUERY_DEVICE_TEXT            0x0C
#define IRP_MN_FILTER_RESOURCE_REQUIREMENTS 0x0D

#define IRP_MN_READ_CONFIG                  0x0F
#define IRP_MN_WRITE_CONFIG                 0x10
#define IRP_MN_EJECT                        0x11
#define IRP_MN_SET_LOCK                     0x12
#define IRP_MN_QUERY_ID                     0x13
#define IRP_MN_QUERY_PNP_DEVICE_STATE       0x14
#define IRP_MN_QUERY_BUS_INFORMATION        0x15
#define IRP_MN_DEVICE_USAGE_NOTIFICATION    0x16
#define IRP_MN_SURPRISE_REMOVAL             0x17

//
// POWER minor function codes
//
#define IRP_MN_WAIT_WAKE                    0x00
#define IRP_MN_POWER_SEQUENCE               0x01
#define IRP_MN_SET_POWER                    0x02
#define IRP_MN_QUERY_POWER                  0x03


//
// WMI minor function codes under IRP_MJ_SYSTEM_CONTROL
//

#define IRP_MN_QUERY_ALL_DATA               0x00
#define IRP_MN_QUERY_SINGLE_INSTANCE        0x01
#define IRP_MN_CHANGE_SINGLE_INSTANCE       0x02
#define IRP_MN_CHANGE_SINGLE_ITEM           0x03
#define IRP_MN_ENABLE_EVENTS                0x04
#define IRP_MN_DISABLE_EVENTS               0x05
#define IRP_MN_ENABLE_COLLECTION            0x06
#define IRP_MN_DISABLE_COLLECTION           0x07
#define IRP_MN_REGINFO                      0x08
#define IRP_MN_EXECUTE_METHOD               0x09
// Minor code 0x0a is reserved
#define IRP_MN_REGINFO_EX                   0x0b



//
// Define option flags for IoCreateFile.  Note that these values must be
// exactly the same as the SL_... flags for a create function.  Note also
// that there are flags that may be passed to IoCreateFile that are not
// placed in the stack location for the create IRP.  These flags start in
// the next byte.
//

#define IO_FORCE_ACCESS_CHECK           0x0001
#define IO_NO_PARAMETER_CHECKING        0x0100

//
// Define Information fields for whether or not a REPARSE or a REMOUNT has
// occurred in the file system.
//

#define IO_REPARSE                      0x0
#define IO_REMOUNT                      0x1

//
// Define the objects that can be created by IoCreateFile.
//

typedef enum _CREATE_FILE_TYPE {
    CreateFileTypeNone,
    CreateFileTypeNamedPipe,
    CreateFileTypeMailslot
} CREATE_FILE_TYPE;

//
// Define the structures used by the I/O system
//

//
// Define empty typedefs for the _IRP, _DEVICE_OBJECT, and _DRIVER_OBJECT
// structures so they may be referenced by function types before they are
// actually defined.
//
struct _DEVICE_DESCRIPTION;
struct _DEVICE_OBJECT;
struct _DMA_ADAPTER;
struct _DRIVER_OBJECT;
struct _DRIVE_LAYOUT_INFORMATION;
struct _DISK_PARTITION;

struct _FILE_OBJECT;

#if defined(_WIN64)
#define POINTER_ALIGNMENT DECLSPEC_ALIGN(8)
#else
#define POINTER_ALIGNMENT
#endif

struct DECLSPEC_ALIGN(MEMORY_ALLOCATION_ALIGNMENT) _IRP;
struct _SCSI_REQUEST_BLOCK;
struct _SCATTER_GATHER_LIST;

//
// Define the I/O version of a DPC routine.
//

typedef
VOID
IO_DPC_ROUTINE (
    __in PKDPC Dpc,
    __in struct _DEVICE_OBJECT *DeviceObject,
    __in struct _IRP *Irp,
    __in_opt PVOID Context
    );

typedef IO_DPC_ROUTINE *PIO_DPC_ROUTINE;

//
// Define driver timer routine type.
//

typedef
VOID
IO_TIMER_ROUTINE (
    __in struct _DEVICE_OBJECT *DeviceObject,
    __in_opt PVOID Context
    );

typedef IO_TIMER_ROUTINE *PIO_TIMER_ROUTINE;

//
// Define driver initialization routine type.
//
typedef
NTSTATUS
DRIVER_INITIALIZE (
    __in struct _DRIVER_OBJECT *DriverObject,
    __in PUNICODE_STRING RegistryPath
    );

typedef DRIVER_INITIALIZE *PDRIVER_INITIALIZE;

//
// Define driver cancel routine type.
//

typedef
VOID
DRIVER_CANCEL (
    __in struct _DEVICE_OBJECT *DeviceObject,
    __in struct _IRP *Irp
    );

typedef DRIVER_CANCEL *PDRIVER_CANCEL;

//
// Define driver dispatch routine type.
//

typedef
NTSTATUS
DRIVER_DISPATCH (
    __in struct _DEVICE_OBJECT *DeviceObject,
    __in struct _IRP *Irp
    );

typedef DRIVER_DISPATCH *PDRIVER_DISPATCH;

//
// Define driver start I/O routine type.
//

typedef
VOID
DRIVER_STARTIO (
    __in struct _DEVICE_OBJECT *DeviceObject,
    __in struct _IRP *Irp
    );

typedef DRIVER_STARTIO *PDRIVER_STARTIO;

//
// Define driver unload routine type.
//
typedef
VOID
DRIVER_UNLOAD (
    __in struct _DRIVER_OBJECT *DriverObject
    );

typedef DRIVER_UNLOAD *PDRIVER_UNLOAD;

//
// Define driver AddDevice routine type.
//

typedef
NTSTATUS
DRIVER_ADD_DEVICE (
    __in struct _DRIVER_OBJECT *DriverObject,
    __in struct _DEVICE_OBJECT *PhysicalDeviceObject
    );

typedef DRIVER_ADD_DEVICE *PDRIVER_ADD_DEVICE;


//
// Define fast I/O procedure prototypes.
//
// Fast I/O read and write procedures.
//

typedef
BOOLEAN
FAST_IO_CHECK_IF_POSSIBLE (
    __in struct _FILE_OBJECT *FileObject,
    __in PLARGE_INTEGER FileOffset,
    __in ULONG Length,
    __in BOOLEAN Wait,
    __in ULONG LockKey,
    __in BOOLEAN CheckForReadOperation,
    __out PIO_STATUS_BLOCK IoStatus,
    __in struct _DEVICE_OBJECT *DeviceObject
    );

typedef FAST_IO_CHECK_IF_POSSIBLE *PFAST_IO_CHECK_IF_POSSIBLE;

typedef
BOOLEAN
FAST_IO_READ (
    __in struct _FILE_OBJECT *FileObject,
    __in PLARGE_INTEGER FileOffset,
    __in ULONG Length,
    __in BOOLEAN Wait,
    __in ULONG LockKey,
    __out PVOID Buffer,
    __out PIO_STATUS_BLOCK IoStatus,
    __in struct _DEVICE_OBJECT *DeviceObject
    );

typedef FAST_IO_READ *PFAST_IO_READ;

typedef
BOOLEAN
FAST_IO_WRITE (
    __in struct _FILE_OBJECT *FileObject,
    __in PLARGE_INTEGER FileOffset,
    __in ULONG Length,
    __in BOOLEAN Wait,
    __in ULONG LockKey,
    __in PVOID Buffer,
    __out PIO_STATUS_BLOCK IoStatus,
    __in struct _DEVICE_OBJECT *DeviceObject
    );

typedef FAST_IO_WRITE *PFAST_IO_WRITE;

//
// Fast I/O query basic and standard information procedures.
//

typedef
BOOLEAN
FAST_IO_QUERY_BASIC_INFO (
    __in struct _FILE_OBJECT *FileObject,
    __in BOOLEAN Wait,
    __out PFILE_BASIC_INFORMATION Buffer,
    __out PIO_STATUS_BLOCK IoStatus,
    __in struct _DEVICE_OBJECT *DeviceObject
    );

typedef FAST_IO_QUERY_BASIC_INFO *PFAST_IO_QUERY_BASIC_INFO;

typedef
BOOLEAN
FAST_IO_QUERY_STANDARD_INFO (
    __in struct _FILE_OBJECT *FileObject,
    __in BOOLEAN Wait,
    __out PFILE_STANDARD_INFORMATION Buffer,
    __out PIO_STATUS_BLOCK IoStatus,
    __in struct _DEVICE_OBJECT *DeviceObject
    );

typedef FAST_IO_QUERY_STANDARD_INFO *PFAST_IO_QUERY_STANDARD_INFO;

//
// Fast I/O lock and unlock procedures.
//

typedef
BOOLEAN
FAST_IO_LOCK (
    __in struct _FILE_OBJECT *FileObject,
    __in PLARGE_INTEGER FileOffset,
    __in PLARGE_INTEGER Length,
    __in PEPROCESS ProcessId,
    __in ULONG Key,
    __in BOOLEAN FailImmediately,
    __in BOOLEAN ExclusiveLock,
    __out PIO_STATUS_BLOCK IoStatus,
    __in struct _DEVICE_OBJECT *DeviceObject
    );

typedef FAST_IO_LOCK *PFAST_IO_LOCK;

typedef
BOOLEAN
FAST_IO_UNLOCK_SINGLE (
    __in struct _FILE_OBJECT *FileObject,
    __in PLARGE_INTEGER FileOffset,
    __in PLARGE_INTEGER Length,
    __in PEPROCESS ProcessId,
    __in ULONG Key,
    __out PIO_STATUS_BLOCK IoStatus,
    __in struct _DEVICE_OBJECT *DeviceObject
    );

typedef FAST_IO_UNLOCK_SINGLE *PFAST_IO_UNLOCK_SINGLE;

typedef
BOOLEAN
FAST_IO_UNLOCK_ALL (
    __in struct _FILE_OBJECT *FileObject,
    __in PEPROCESS ProcessId,
    __out PIO_STATUS_BLOCK IoStatus,
    __in struct _DEVICE_OBJECT *DeviceObject
    );

typedef FAST_IO_UNLOCK_ALL *PFAST_IO_UNLOCK_ALL;

typedef
BOOLEAN
FAST_IO_UNLOCK_ALL_BY_KEY (
    __in struct _FILE_OBJECT *FileObject,
    __in PVOID ProcessId,
    __in ULONG Key,
    __out PIO_STATUS_BLOCK IoStatus,
    __in struct _DEVICE_OBJECT *DeviceObject
    );

typedef FAST_IO_UNLOCK_ALL_BY_KEY *PFAST_IO_UNLOCK_ALL_BY_KEY;

//
// Fast I/O device control procedure.
//

typedef
BOOLEAN
FAST_IO_DEVICE_CONTROL (
    __in struct _FILE_OBJECT *FileObject,
    __in BOOLEAN Wait,
    __in_opt PVOID InputBuffer,
    __in ULONG InputBufferLength,
    __out_opt PVOID OutputBuffer,
    __in ULONG OutputBufferLength,
    __in ULONG IoControlCode,
    __out PIO_STATUS_BLOCK IoStatus,
    __in struct _DEVICE_OBJECT *DeviceObject
    );

typedef FAST_IO_DEVICE_CONTROL *PFAST_IO_DEVICE_CONTROL;

//
// Define callbacks for NtCreateSection to synchronize correctly with
// the file system.  It pre-acquires the resources that will be needed
// when calling to query and set file/allocation size in the file system.
//

typedef
VOID
FAST_IO_ACQUIRE_FILE (
    __in struct _FILE_OBJECT *FileObject
    );

typedef FAST_IO_ACQUIRE_FILE *PFAST_IO_ACQUIRE_FILE;

typedef
VOID
FAST_IO_RELEASE_FILE (
    __in struct _FILE_OBJECT *FileObject
    );

typedef FAST_IO_RELEASE_FILE *PFAST_IO_RELEASE_FILE;

//
// Define callback for drivers that have device objects attached to lower-
// level drivers' device objects.  This callback is made when the lower-level
// driver is deleting its device object.
//

typedef
VOID
FAST_IO_DETACH_DEVICE (
    __in struct _DEVICE_OBJECT *SourceDevice,
    __in struct _DEVICE_OBJECT *TargetDevice
    );

typedef FAST_IO_DETACH_DEVICE *PFAST_IO_DETACH_DEVICE;

//
// This structure is used by the server to quickly get the information needed
// to service a server open call.  It is takes what would be two fast io calls
// one for basic information and the other for standard information and makes
// it into one call.
//

typedef
BOOLEAN
FAST_IO_QUERY_NETWORK_OPEN_INFO (
    __in struct _FILE_OBJECT *FileObject,
    __in BOOLEAN Wait,
    __out struct _FILE_NETWORK_OPEN_INFORMATION *Buffer,
    __out struct _IO_STATUS_BLOCK *IoStatus,
    __in struct _DEVICE_OBJECT *DeviceObject
    );

typedef FAST_IO_QUERY_NETWORK_OPEN_INFO *PFAST_IO_QUERY_NETWORK_OPEN_INFO;

//
//  Define Mdl-based routines for the server to call
//

typedef
BOOLEAN
FAST_IO_MDL_READ (
    __in struct _FILE_OBJECT *FileObject,
    __in PLARGE_INTEGER FileOffset,
    __in ULONG Length,
    __in ULONG LockKey,
    __out PMDL *MdlChain,
    __out PIO_STATUS_BLOCK IoStatus,
    __in struct _DEVICE_OBJECT *DeviceObject
    );

typedef FAST_IO_MDL_READ *PFAST_IO_MDL_READ;

typedef
BOOLEAN
FAST_IO_MDL_READ_COMPLETE (
    __in struct _FILE_OBJECT *FileObject,
    __in PMDL MdlChain,
    __in struct _DEVICE_OBJECT *DeviceObject
    );

typedef FAST_IO_MDL_READ_COMPLETE *PFAST_IO_MDL_READ_COMPLETE;

typedef
BOOLEAN
FAST_IO_PREPARE_MDL_WRITE (
    __in struct _FILE_OBJECT *FileObject,
    __in PLARGE_INTEGER FileOffset,
    __in ULONG Length,
    __in ULONG LockKey,
    __out PMDL *MdlChain,
    __out PIO_STATUS_BLOCK IoStatus,
    __in struct _DEVICE_OBJECT *DeviceObject
    );

typedef FAST_IO_PREPARE_MDL_WRITE *PFAST_IO_PREPARE_MDL_WRITE;

typedef
BOOLEAN
FAST_IO_MDL_WRITE_COMPLETE (
    __in struct _FILE_OBJECT *FileObject,
    __in PLARGE_INTEGER FileOffset,
    __in PMDL MdlChain,
    __in struct _DEVICE_OBJECT *DeviceObject
    );

typedef FAST_IO_MDL_WRITE_COMPLETE *PFAST_IO_MDL_WRITE_COMPLETE;

//
//  If this routine is present, it will be called by FsRtl
//  to acquire the file for the mapped page writer.
//

typedef
NTSTATUS
FAST_IO_ACQUIRE_FOR_MOD_WRITE (
    __in struct _FILE_OBJECT *FileObject,
    __in PLARGE_INTEGER EndingOffset,
    __out struct _ERESOURCE **ResourceToRelease,
    __in struct _DEVICE_OBJECT *DeviceObject
             );

typedef FAST_IO_ACQUIRE_FOR_MOD_WRITE *PFAST_IO_ACQUIRE_FOR_MOD_WRITE;

typedef
NTSTATUS
FAST_IO_RELEASE_FOR_MOD_WRITE (
    __in struct _FILE_OBJECT *FileObject,
    __in struct _ERESOURCE *ResourceToRelease,
    __in struct _DEVICE_OBJECT *DeviceObject
             );

typedef FAST_IO_RELEASE_FOR_MOD_WRITE *PFAST_IO_RELEASE_FOR_MOD_WRITE;

//
//  If this routine is present, it will be called by FsRtl
//  to acquire the file for the mapped page writer.
//

typedef
NTSTATUS
FAST_IO_ACQUIRE_FOR_CCFLUSH (
    __in struct _FILE_OBJECT *FileObject,
    __in struct _DEVICE_OBJECT *DeviceObject
             );

typedef FAST_IO_ACQUIRE_FOR_CCFLUSH *PFAST_IO_ACQUIRE_FOR_CCFLUSH;

typedef
NTSTATUS
FAST_IO_RELEASE_FOR_CCFLUSH (
    __in struct _FILE_OBJECT *FileObject,
    __in struct _DEVICE_OBJECT *DeviceObject
             );

typedef FAST_IO_RELEASE_FOR_CCFLUSH *PFAST_IO_RELEASE_FOR_CCFLUSH;

typedef
BOOLEAN
FAST_IO_READ_COMPRESSED (
    __in struct _FILE_OBJECT *FileObject,
    __in PLARGE_INTEGER FileOffset,
    __in ULONG Length,
    __in ULONG LockKey,
    __out PVOID Buffer,
    __out PMDL *MdlChain,
    __out PIO_STATUS_BLOCK IoStatus,
    __out struct _COMPRESSED_DATA_INFO *CompressedDataInfo,
    __in ULONG CompressedDataInfoLength,
    __in struct _DEVICE_OBJECT *DeviceObject
    );

typedef FAST_IO_READ_COMPRESSED *PFAST_IO_READ_COMPRESSED;

typedef
BOOLEAN
FAST_IO_WRITE_COMPRESSED (
    __in struct _FILE_OBJECT *FileObject,
    __in PLARGE_INTEGER FileOffset,
    __in ULONG Length,
    __in ULONG LockKey,
    __in PVOID Buffer,
    __out PMDL *MdlChain,
    __out PIO_STATUS_BLOCK IoStatus,
    __in struct _COMPRESSED_DATA_INFO *CompressedDataInfo,
    __in ULONG CompressedDataInfoLength,
    __in struct _DEVICE_OBJECT *DeviceObject
    );

typedef FAST_IO_WRITE_COMPRESSED *PFAST_IO_WRITE_COMPRESSED;

typedef
BOOLEAN
FAST_IO_MDL_READ_COMPLETE_COMPRESSED (
    __in struct _FILE_OBJECT *FileObject,
    __in PMDL MdlChain,
    __in struct _DEVICE_OBJECT *DeviceObject
    );

typedef FAST_IO_MDL_READ_COMPLETE_COMPRESSED *PFAST_IO_MDL_READ_COMPLETE_COMPRESSED;

typedef
BOOLEAN
FAST_IO_MDL_WRITE_COMPLETE_COMPRESSED (
    __in struct _FILE_OBJECT *FileObject,
    __in PLARGE_INTEGER FileOffset,
    __in PMDL MdlChain,
    __in struct _DEVICE_OBJECT *DeviceObject
    );

typedef FAST_IO_MDL_WRITE_COMPLETE_COMPRESSED *PFAST_IO_MDL_WRITE_COMPLETE_COMPRESSED;

typedef
BOOLEAN
FAST_IO_QUERY_OPEN (
    __in struct _IRP *Irp,
    __out PFILE_NETWORK_OPEN_INFORMATION NetworkInformation,
    __in struct _DEVICE_OBJECT *DeviceObject
    );

typedef FAST_IO_QUERY_OPEN *PFAST_IO_QUERY_OPEN;

//
// Define the structure to describe the Fast I/O dispatch routines.  Any
// additions made to this structure MUST be added monotonically to the end
// of the structure, and fields CANNOT be removed from the middle.
//

typedef struct _FAST_IO_DISPATCH {
    ULONG SizeOfFastIoDispatch;
    PFAST_IO_CHECK_IF_POSSIBLE FastIoCheckIfPossible;
    PFAST_IO_READ FastIoRead;
    PFAST_IO_WRITE FastIoWrite;
    PFAST_IO_QUERY_BASIC_INFO FastIoQueryBasicInfo;
    PFAST_IO_QUERY_STANDARD_INFO FastIoQueryStandardInfo;
    PFAST_IO_LOCK FastIoLock;
    PFAST_IO_UNLOCK_SINGLE FastIoUnlockSingle;
    PFAST_IO_UNLOCK_ALL FastIoUnlockAll;
    PFAST_IO_UNLOCK_ALL_BY_KEY FastIoUnlockAllByKey;
    PFAST_IO_DEVICE_CONTROL FastIoDeviceControl;
    PFAST_IO_ACQUIRE_FILE AcquireFileForNtCreateSection;
    PFAST_IO_RELEASE_FILE ReleaseFileForNtCreateSection;
    PFAST_IO_DETACH_DEVICE FastIoDetachDevice;
    PFAST_IO_QUERY_NETWORK_OPEN_INFO FastIoQueryNetworkOpenInfo;
    PFAST_IO_ACQUIRE_FOR_MOD_WRITE AcquireForModWrite;
    PFAST_IO_MDL_READ MdlRead;
    PFAST_IO_MDL_READ_COMPLETE MdlReadComplete;
    PFAST_IO_PREPARE_MDL_WRITE PrepareMdlWrite;
    PFAST_IO_MDL_WRITE_COMPLETE MdlWriteComplete;
    PFAST_IO_READ_COMPRESSED FastIoReadCompressed;
    PFAST_IO_WRITE_COMPRESSED FastIoWriteCompressed;
    PFAST_IO_MDL_READ_COMPLETE_COMPRESSED MdlReadCompleteCompressed;
    PFAST_IO_MDL_WRITE_COMPLETE_COMPRESSED MdlWriteCompleteCompressed;
    PFAST_IO_QUERY_OPEN FastIoQueryOpen;
    PFAST_IO_RELEASE_FOR_MOD_WRITE ReleaseForModWrite;
    PFAST_IO_ACQUIRE_FOR_CCFLUSH AcquireForCcFlush;
    PFAST_IO_RELEASE_FOR_CCFLUSH ReleaseForCcFlush;
} FAST_IO_DISPATCH, *PFAST_IO_DISPATCH;

//
// Define the actions that a driver execution routine may request of the
// adapter/controller allocation routines upon return.
//

typedef enum _IO_ALLOCATION_ACTION {
    KeepObject = 1,
    DeallocateObject,
    DeallocateObjectKeepRegisters
} IO_ALLOCATION_ACTION, *PIO_ALLOCATION_ACTION;

//
// Define device driver adapter/controller execution routine.
//

typedef
IO_ALLOCATION_ACTION
(*PDRIVER_CONTROL) (
    IN struct _DEVICE_OBJECT *DeviceObject,
    IN struct _IRP *Irp,
    IN PVOID MapRegisterBase,
    IN PVOID Context
    );

//
// Define the I/O system's security context type for use by file system's
// when checking access to volumes, files, and directories.
//

typedef struct _IO_SECURITY_CONTEXT {
    PSECURITY_QUALITY_OF_SERVICE SecurityQos;
    PACCESS_STATE AccessState;
    ACCESS_MASK DesiredAccess;
    ULONG FullCreateOptions;
} IO_SECURITY_CONTEXT, *PIO_SECURITY_CONTEXT;

//
// Define Volume Parameter Block (VPB) flags.
//

#define VPB_MOUNTED                     0x00000001
#define VPB_LOCKED                      0x00000002
#define VPB_PERSISTENT                  0x00000004
#define VPB_REMOVE_PENDING              0x00000008
#define VPB_RAW_MOUNT                   0x00000010
#define VPB_DIRECT_WRITES_ALLOWED       0x00000020


//
// Volume Parameter Block (VPB)
//

#define MAXIMUM_VOLUME_LABEL_LENGTH  (32 * sizeof(WCHAR)) // 32 characters

typedef struct _VPB {
    CSHORT Type;
    CSHORT Size;
    USHORT Flags;
    USHORT VolumeLabelLength; // in bytes
    struct _DEVICE_OBJECT *DeviceObject;
    struct _DEVICE_OBJECT *RealDevice;
    ULONG SerialNumber;
    ULONG ReferenceCount;
    WCHAR VolumeLabel[MAXIMUM_VOLUME_LABEL_LENGTH / sizeof(WCHAR)];
} VPB, *PVPB;


#if defined(_WIN64)

//
// Use __inline DMA macros (hal.h)
//
#ifndef USE_DMA_MACROS
#define USE_DMA_MACROS
#endif

//
// Only PnP drivers!
//
#ifndef NO_LEGACY_DRIVERS
#define NO_LEGACY_DRIVERS
#endif

#endif // _WIN64


#if defined(USE_DMA_MACROS) && !defined(_NTHAL_) && ( defined(_NTDDK_) || defined(_NTDRIVER_) || defined(_NTOSP_))

//
// Define object type specific fields of various objects used by the I/O system
//

typedef struct _DMA_ADAPTER *PADAPTER_OBJECT;

#elif defined(_WDM_INCLUDED_)

typedef struct _DMA_ADAPTER *PADAPTER_OBJECT;

#else

//
// Define object type specific fields of various objects used by the I/O system
//

typedef struct _ADAPTER_OBJECT *PADAPTER_OBJECT; 

#endif // USE_DMA_MACROS && (_NTDDK_ || _NTDRIVER_ || _NTOSP_)

//
// Define Wait Context Block (WCB)
//

typedef struct _WAIT_CONTEXT_BLOCK {
    KDEVICE_QUEUE_ENTRY WaitQueueEntry;
    PDRIVER_CONTROL DeviceRoutine;
    PVOID DeviceContext;
    ULONG NumberOfMapRegisters;
    PVOID DeviceObject;
    PVOID CurrentIrp;
    PKDPC BufferChainingDpc;
} WAIT_CONTEXT_BLOCK, *PWAIT_CONTEXT_BLOCK;

//
// Define Device Object (DO) flags
//
#define DO_VERIFY_VOLUME                0x00000002      
#define DO_BUFFERED_IO                  0x00000004      
#define DO_EXCLUSIVE                    0x00000008      
#define DO_DIRECT_IO                    0x00000010      
#define DO_MAP_IO_BUFFER                0x00000020      
#define DO_DEVICE_INITIALIZING          0x00000080      
#define DO_SHUTDOWN_REGISTERED          0x00000800      
#define DO_BUS_ENUMERATED_DEVICE        0x00001000      
#define DO_POWER_PAGABLE                0x00002000      
#define DO_POWER_INRUSH                 0x00004000      
//
// Device Object structure definition
//

#if _MSC_VER >= 1200
#pragma warning(push)
#pragma warning(disable:4324) // structure was padded due to __declspec(align())
#endif

typedef struct DECLSPEC_ALIGN(MEMORY_ALLOCATION_ALIGNMENT) _DEVICE_OBJECT {
    CSHORT Type;
    USHORT Size;
    LONG ReferenceCount;
    struct _DRIVER_OBJECT *DriverObject;
    struct _DEVICE_OBJECT *NextDevice;
    struct _DEVICE_OBJECT *AttachedDevice;
    struct _IRP *CurrentIrp;
    PIO_TIMER Timer;
    ULONG Flags;                                // See above:  DO_...
    ULONG Characteristics;                      // See ntioapi:  FILE_...
    __volatile PVPB Vpb;
    PVOID DeviceExtension;
    DEVICE_TYPE DeviceType;
    CCHAR StackSize;
    union {
        LIST_ENTRY ListEntry;
        WAIT_CONTEXT_BLOCK Wcb;
    } Queue;
    ULONG AlignmentRequirement;
    KDEVICE_QUEUE DeviceQueue;
    KDPC Dpc;

    //
    //  The following field is for exclusive use by the filesystem to keep
    //  track of the number of Fsp threads currently using the device
    //

    ULONG ActiveThreadCount;
    PSECURITY_DESCRIPTOR SecurityDescriptor;
    KEVENT DeviceLock;

    USHORT SectorSize;
    USHORT Spare1;

    struct _DEVOBJ_EXTENSION  *DeviceObjectExtension;
    PVOID  Reserved;

} DEVICE_OBJECT;

typedef struct _DEVICE_OBJECT *PDEVICE_OBJECT; 

#if _MSC_VER >= 1200
#pragma warning(pop)
#endif


struct  _DEVICE_OBJECT_POWER_EXTENSION;

typedef struct _DEVOBJ_EXTENSION {

    CSHORT          Type;
    USHORT          Size;

    //
    // Public part of the DeviceObjectExtension structure
    //

    PDEVICE_OBJECT  DeviceObject;               // owning device object


} DEVOBJ_EXTENSION, *PDEVOBJ_EXTENSION;

//
// Define Driver Object (DRVO) flags
//

#define DRVO_UNLOAD_INVOKED             0x00000001
#define DRVO_LEGACY_DRIVER              0x00000002
#define DRVO_BUILTIN_DRIVER             0x00000004    // Driver objects for Hal, PnP Mgr

typedef struct _DRIVER_EXTENSION {

    //
    // Back pointer to Driver Object
    //

    struct _DRIVER_OBJECT *DriverObject;

    //
    // The AddDevice entry point is called by the Plug & Play manager
    // to inform the driver when a new device instance arrives that this
    // driver must control.
    //

    PDRIVER_ADD_DEVICE AddDevice;

    //
    // The count field is used to count the number of times the driver has
    // had its registered reinitialization routine invoked.
    //

    ULONG Count;

    //
    // The service name field is used by the pnp manager to determine
    // where the driver related info is stored in the registry.
    //

    UNICODE_STRING ServiceKeyName;

    //
    // Note: any new shared fields get added here.
    //


} DRIVER_EXTENSION, *PDRIVER_EXTENSION;

typedef struct _DRIVER_OBJECT {
    CSHORT Type;
    CSHORT Size;

    //
    // The following links all of the devices created by a single driver
    // together on a list, and the Flags word provides an extensible flag
    // location for driver objects.
    //

    PDEVICE_OBJECT DeviceObject;
    ULONG Flags;

    //
    // The following section describes where the driver is loaded.  The count
    // field is used to count the number of times the driver has had its
    // registered reinitialization routine invoked.
    //

    PVOID DriverStart;
    ULONG DriverSize;
    PVOID DriverSection;
    PDRIVER_EXTENSION DriverExtension;

    //
    // The driver name field is used by the error log thread
    // determine the name of the driver that an I/O request is/was bound.
    //

    UNICODE_STRING DriverName;

    //
    // The following section is for registry support.  Thise is a pointer
    // to the path to the hardware information in the registry
    //

    PUNICODE_STRING HardwareDatabase;

    //
    // The following section contains the optional pointer to an array of
    // alternate entry points to a driver for "fast I/O" support.  Fast I/O
    // is performed by invoking the driver routine directly with separate
    // parameters, rather than using the standard IRP call mechanism.  Note
    // that these functions may only be used for synchronous I/O, and when
    // the file is cached.
    //

    PFAST_IO_DISPATCH FastIoDispatch;

    //
    // The following section describes the entry points to this particular
    // driver.  Note that the major function dispatch table must be the last
    // field in the object so that it remains extensible.
    //

    PDRIVER_INITIALIZE DriverInit;
    PDRIVER_STARTIO DriverStartIo;
    PDRIVER_UNLOAD DriverUnload;
    PDRIVER_DISPATCH MajorFunction[IRP_MJ_MAXIMUM_FUNCTION + 1];

} DRIVER_OBJECT;
typedef struct _DRIVER_OBJECT *PDRIVER_OBJECT; 



//
// The following structure is pointed to by the SectionObject pointer field
// of a file object, and is allocated by the various NT file systems.
//

typedef struct _SECTION_OBJECT_POINTERS {
    PVOID DataSectionObject;
    PVOID SharedCacheMap;
    PVOID ImageSectionObject;
} SECTION_OBJECT_POINTERS;
typedef SECTION_OBJECT_POINTERS *PSECTION_OBJECT_POINTERS;

//
// Define the format of a completion message.
//

typedef struct _IO_COMPLETION_CONTEXT {
    PVOID Port;
    PVOID Key;
} IO_COMPLETION_CONTEXT, *PIO_COMPLETION_CONTEXT;

//
// Define File Object (FO) flags
//

#define FO_FILE_OPEN                    0x00000001
#define FO_SYNCHRONOUS_IO               0x00000002
#define FO_ALERTABLE_IO                 0x00000004
#define FO_NO_INTERMEDIATE_BUFFERING    0x00000008
#define FO_WRITE_THROUGH                0x00000010
#define FO_SEQUENTIAL_ONLY              0x00000020
#define FO_CACHE_SUPPORTED              0x00000040
#define FO_NAMED_PIPE                   0x00000080
#define FO_STREAM_FILE                  0x00000100
#define FO_MAILSLOT                     0x00000200
#define FO_GENERATE_AUDIT_ON_CLOSE      0x00000400
#define FO_QUEUE_IRP_TO_THREAD          FO_GENERATE_AUDIT_ON_CLOSE
#define FO_DIRECT_DEVICE_OPEN           0x00000800
#define FO_FILE_MODIFIED                0x00001000
#define FO_FILE_SIZE_CHANGED            0x00002000
#define FO_CLEANUP_COMPLETE             0x00004000
#define FO_TEMPORARY_FILE               0x00008000
#define FO_DELETE_ON_CLOSE              0x00010000
#define FO_OPENED_CASE_SENSITIVE        0x00020000
#define FO_HANDLE_CREATED               0x00040000
#define FO_FILE_FAST_IO_READ            0x00080000
#define FO_RANDOM_ACCESS                0x00100000
#define FO_FILE_OPEN_CANCELLED          0x00200000
#define FO_VOLUME_OPEN                  0x00400000
#define FO_REMOTE_ORIGIN                0x01000000
#define FO_SKIP_COMPLETION_PORT         0x02000000
#define FO_SKIP_SET_EVENT               0x04000000
#define FO_SKIP_SET_FAST_IO             0x08000000

typedef struct _FILE_OBJECT {
    CSHORT Type;
    CSHORT Size;
    PDEVICE_OBJECT DeviceObject;
    PVPB Vpb;
    PVOID FsContext;
    PVOID FsContext2;
    PSECTION_OBJECT_POINTERS SectionObjectPointer;
    PVOID PrivateCacheMap;
    NTSTATUS FinalStatus;
    struct _FILE_OBJECT *RelatedFileObject;
    BOOLEAN LockOperation;
    BOOLEAN DeletePending;
    BOOLEAN ReadAccess;
    BOOLEAN WriteAccess;
    BOOLEAN DeleteAccess;
    BOOLEAN SharedRead;
    BOOLEAN SharedWrite;
    BOOLEAN SharedDelete;
    ULONG Flags;
    UNICODE_STRING FileName;
    LARGE_INTEGER CurrentByteOffset;
    __volatile ULONG Waiters;
    __volatile ULONG Busy;
    PVOID LastLock;
    KEVENT Lock;
    KEVENT Event;
    __volatile PIO_COMPLETION_CONTEXT CompletionContext;
    KSPIN_LOCK IrpListLock;
    LIST_ENTRY IrpList;
    __volatile PVOID FileObjectExtension;
} FILE_OBJECT;
typedef struct _FILE_OBJECT *PFILE_OBJECT; 

//
// Define I/O Request Packet (IRP) flags
//

#define IRP_NOCACHE                     0x00000001
#define IRP_PAGING_IO                   0x00000002
#define IRP_MOUNT_COMPLETION            0x00000002
#define IRP_SYNCHRONOUS_API             0x00000004
#define IRP_ASSOCIATED_IRP              0x00000008
#define IRP_BUFFERED_IO                 0x00000010
#define IRP_DEALLOCATE_BUFFER           0x00000020
#define IRP_INPUT_OPERATION             0x00000040
#define IRP_SYNCHRONOUS_PAGING_IO       0x00000040
#define IRP_CREATE_OPERATION            0x00000080
#define IRP_READ_OPERATION              0x00000100
#define IRP_WRITE_OPERATION             0x00000200
#define IRP_CLOSE_OPERATION             0x00000400
#define IRP_DEFER_IO_COMPLETION         0x00000800
#define IRP_OB_QUERY_NAME               0x00001000
#define IRP_HOLD_DEVICE_QUEUE           0x00002000

//
// Define I/O request packet (IRP) alternate flags for allocation control.
//

#define IRP_QUOTA_CHARGED               0x01
#define IRP_ALLOCATED_MUST_SUCCEED      0x02
#define IRP_ALLOCATED_FIXED_SIZE        0x04
#define IRP_LOOKASIDE_ALLOCATION        0x08



//
// I/O Request Packet (IRP) definition
//

typedef struct DECLSPEC_ALIGN(MEMORY_ALLOCATION_ALIGNMENT) _IRP {
    CSHORT Type;
    USHORT Size;

    //
    // Define the common fields used to control the IRP.
    //

    //
    // Define a pointer to the Memory Descriptor List (MDL) for this I/O
    // request.  This field is only used if the I/O is "direct I/O".
    //

    PMDL MdlAddress;

    //
    // Flags word - used to remember various flags.
    //

    ULONG Flags;

    //
    // The following union is used for one of three purposes:
    //
    //    1. This IRP is an associated IRP.  The field is a pointer to a master
    //       IRP.
    //
    //    2. This is the master IRP.  The field is the count of the number of
    //       IRPs which must complete (associated IRPs) before the master can
    //       complete.
    //
    //    3. This operation is being buffered and the field is the address of
    //       the system space buffer.
    //

    union {
        struct _IRP *MasterIrp;
        __volatile LONG IrpCount;
        PVOID SystemBuffer;
    } AssociatedIrp;

    //
    // Thread list entry - allows queueing the IRP to the thread pending I/O
    // request packet list.
    //

    LIST_ENTRY ThreadListEntry;

    //
    // I/O status - final status of operation.
    //

    IO_STATUS_BLOCK IoStatus;

    //
    // Requestor mode - mode of the original requestor of this operation.
    //

    KPROCESSOR_MODE RequestorMode;

    //
    // Pending returned - TRUE if pending was initially returned as the
    // status for this packet.
    //

    BOOLEAN PendingReturned;

    //
    // Stack state information.
    //

    CHAR StackCount;
    CHAR CurrentLocation;

    //
    // Cancel - packet has been canceled.
    //

    BOOLEAN Cancel;

    //
    // Cancel Irql - Irql at which the cancel spinlock was acquired.
    //

    KIRQL CancelIrql;

    //
    // ApcEnvironment - Used to save the APC environment at the time that the
    // packet was initialized.
    //

    CCHAR ApcEnvironment;

    //
    // Allocation control flags.
    //

    UCHAR AllocationFlags;

    //
    // User parameters.
    //

    PIO_STATUS_BLOCK UserIosb;
    PKEVENT UserEvent;
    union {
        struct {
            union {
                PIO_APC_ROUTINE UserApcRoutine;
                PVOID IssuingProcess;
            };
            PVOID UserApcContext;
        } AsynchronousParameters;
        LARGE_INTEGER AllocationSize;
    } Overlay;

    //
    // CancelRoutine - Used to contain the address of a cancel routine supplied
    // by a device driver when the IRP is in a cancelable state.
    //

    __volatile PDRIVER_CANCEL CancelRoutine;

    //
    // Note that the UserBuffer parameter is outside of the stack so that I/O
    // completion can copy data back into the user's address space without
    // having to know exactly which service was being invoked.  The length
    // of the copy is stored in the second half of the I/O status block. If
    // the UserBuffer field is NULL, then no copy is performed.
    //

    PVOID UserBuffer;

    //
    // Kernel structures
    //
    // The following section contains kernel structures which the IRP needs
    // in order to place various work information in kernel controller system
    // queues.  Because the size and alignment cannot be controlled, they are
    // placed here at the end so they just hang off and do not affect the
    // alignment of other fields in the IRP.
    //

    union {

        struct {

            union {

                //
                // DeviceQueueEntry - The device queue entry field is used to
                // queue the IRP to the device driver device queue.
                //

                KDEVICE_QUEUE_ENTRY DeviceQueueEntry;

                struct {

                    //
                    // The following are available to the driver to use in
                    // whatever manner is desired, while the driver owns the
                    // packet.
                    //

                    PVOID DriverContext[4];

                } ;

            } ;

            //
            // Thread - pointer to caller's Thread Control Block.
            //

            PETHREAD Thread;

            //
            // Auxiliary buffer - pointer to any auxiliary buffer that is
            // required to pass information to a driver that is not contained
            // in a normal buffer.
            //

            PCHAR AuxiliaryBuffer;

            //
            // The following unnamed structure must be exactly identical
            // to the unnamed structure used in the minipacket header used
            // for completion queue entries.
            //

            struct {

                //
                // List entry - used to queue the packet to completion queue, among
                // others.
                //

                LIST_ENTRY ListEntry;

                union {

                    //
                    // Current stack location - contains a pointer to the current
                    // IO_STACK_LOCATION structure in the IRP stack.  This field
                    // should never be directly accessed by drivers.  They should
                    // use the standard functions.
                    //

                    struct _IO_STACK_LOCATION *CurrentStackLocation;

                    //
                    // Minipacket type.
                    //

                    ULONG PacketType;
                };
            };

            //
            // Original file object - pointer to the original file object
            // that was used to open the file.  This field is owned by the
            // I/O system and should not be used by any other drivers.
            //

            PFILE_OBJECT OriginalFileObject;

        } Overlay;

        //
        // APC - This APC control block is used for the special kernel APC as
        // well as for the caller's APC, if one was specified in the original
        // argument list.  If so, then the APC is reused for the normal APC for
        // whatever mode the caller was in and the "special" routine that is
        // invoked before the APC gets control simply deallocates the IRP.
        //

        KAPC Apc;

        //
        // CompletionKey - This is the key that is used to distinguish
        // individual I/O operations initiated on a single file handle.
        //

        PVOID CompletionKey;

    } Tail;

} IRP, *PIRP;

//
// Define completion routine types for use in stack locations in an IRP
//

typedef
NTSTATUS
IO_COMPLETION_ROUTINE (
    __in PDEVICE_OBJECT DeviceObject,
    __in PIRP Irp,
    __in_opt PVOID Context
    );

typedef IO_COMPLETION_ROUTINE *PIO_COMPLETION_ROUTINE;

//
// Define stack location control flags
//

#define SL_PENDING_RETURNED             0x01
#define SL_ERROR_RETURNED               0x02
#define SL_INVOKE_ON_CANCEL             0x20
#define SL_INVOKE_ON_SUCCESS            0x40
#define SL_INVOKE_ON_ERROR              0x80

//
// Define flags for various functions
//

//
// Create / Create Named Pipe
//
// The following flags must exactly match those in the IoCreateFile call's
// options.  The case sensitive flag is added in later, by the parse routine,
// and is not an actual option to open.  Rather, it is part of the object
// manager's attributes structure.
//

#define SL_FORCE_ACCESS_CHECK           0x01
#define SL_OPEN_PAGING_FILE             0x02
#define SL_OPEN_TARGET_DIRECTORY        0x04
#define SL_STOP_ON_SYMLINK              0x08


#define SL_CASE_SENSITIVE               0x80

//
// Read / Write
//

#define SL_KEY_SPECIFIED                0x01
#define SL_OVERRIDE_VERIFY_VOLUME       0x02
#define SL_WRITE_THROUGH                0x04
#define SL_FT_SEQUENTIAL_WRITE          0x08
#define SL_FORCE_DIRECT_WRITE           0x10

//
// Device I/O Control
//
//
// Same SL_OVERRIDE_VERIFY_VOLUME as for read/write above.
//

#define SL_READ_ACCESS_GRANTED          0x01
#define SL_WRITE_ACCESS_GRANTED         0x04    // Gap for SL_OVERRIDE_VERIFY_VOLUME

//
// Lock
//

#define SL_FAIL_IMMEDIATELY             0x01
#define SL_EXCLUSIVE_LOCK               0x02

//
// QueryDirectory / QueryEa / QueryQuota
//

#define SL_RESTART_SCAN                 0x01
#define SL_RETURN_SINGLE_ENTRY          0x02
#define SL_INDEX_SPECIFIED              0x04

//
// NotifyDirectory
//

#define SL_WATCH_TREE                   0x01

//
// FileSystemControl
//
//    minor: mount/verify volume
//

#define SL_ALLOW_RAW_MOUNT              0x01

//
// Define PNP/POWER types required by IRP_MJ_PNP/IRP_MJ_POWER.
//

typedef enum _DEVICE_RELATION_TYPE {
    BusRelations,
    EjectionRelations,
    PowerRelations,
    RemovalRelations,
    TargetDeviceRelation,
    SingleBusRelations
} DEVICE_RELATION_TYPE, *PDEVICE_RELATION_TYPE;

typedef struct _DEVICE_RELATIONS {
    ULONG Count;
    PDEVICE_OBJECT Objects[1];  // variable length
} DEVICE_RELATIONS, *PDEVICE_RELATIONS;

typedef enum _DEVICE_USAGE_NOTIFICATION_TYPE {
    DeviceUsageTypeUndefined,
    DeviceUsageTypePaging,
    DeviceUsageTypeHibernation,
    DeviceUsageTypeDumpFile
} DEVICE_USAGE_NOTIFICATION_TYPE;



// workaround overloaded definition (rpc generated headers all define INTERFACE
// to match the class name).
#undef INTERFACE

typedef struct _INTERFACE {
    USHORT Size;
    USHORT Version;
    PVOID Context;
    PINTERFACE_REFERENCE InterfaceReference;
    PINTERFACE_DEREFERENCE InterfaceDereference;
    // interface specific entries go here
} INTERFACE, *PINTERFACE;



typedef __struct_bcount(Size) struct _DEVICE_CAPABILITIES {
    USHORT Size;
    USHORT Version;  // the version documented here is version 1
    ULONG DeviceD1:1;
    ULONG DeviceD2:1;
    ULONG LockSupported:1;
    ULONG EjectSupported:1; // Ejectable in S0
    ULONG Removable:1;
    ULONG DockDevice:1;
    ULONG UniqueID:1;
    ULONG SilentInstall:1;
    ULONG RawDeviceOK:1;
    ULONG SurpriseRemovalOK:1;
    ULONG WakeFromD0:1;
    ULONG WakeFromD1:1;
    ULONG WakeFromD2:1;
    ULONG WakeFromD3:1;
    ULONG HardwareDisabled:1;
    ULONG NonDynamic:1;
    ULONG WarmEjectSupported:1;
    ULONG NoDisplayInUI:1;
    ULONG Reserved:14;

    ULONG Address;
    ULONG UINumber;

    DEVICE_POWER_STATE DeviceState[POWER_SYSTEM_MAXIMUM];
    SYSTEM_POWER_STATE SystemWake;
    DEVICE_POWER_STATE DeviceWake;
    ULONG D1Latency;
    ULONG D2Latency;
    ULONG D3Latency;
} DEVICE_CAPABILITIES, *PDEVICE_CAPABILITIES;

typedef struct _POWER_SEQUENCE {
    ULONG SequenceD1;
    ULONG SequenceD2;
    ULONG SequenceD3;
} POWER_SEQUENCE, *PPOWER_SEQUENCE;

typedef enum {
    BusQueryDeviceID = 0,       // <Enumerator>\<Enumerator-specific device id>
    BusQueryHardwareIDs = 1,    // Hardware ids
    BusQueryCompatibleIDs = 2,  // compatible device ids
    BusQueryInstanceID = 3,     // persistent id for this instance of the device
    BusQueryDeviceSerialNumber = 4    // serial number for this device
} BUS_QUERY_ID_TYPE, *PBUS_QUERY_ID_TYPE;

typedef ULONG PNP_DEVICE_STATE, *PPNP_DEVICE_STATE;

#define PNP_DEVICE_DISABLED                      0x00000001
#define PNP_DEVICE_DONT_DISPLAY_IN_UI            0x00000002
#define PNP_DEVICE_FAILED                        0x00000004
#define PNP_DEVICE_REMOVED                       0x00000008
#define PNP_DEVICE_RESOURCE_REQUIREMENTS_CHANGED 0x00000010
#define PNP_DEVICE_NOT_DISABLEABLE               0x00000020

typedef enum {
    DeviceTextDescription = 0,            // DeviceDesc property
    DeviceTextLocationInformation = 1     // DeviceLocation property
} DEVICE_TEXT_TYPE, *PDEVICE_TEXT_TYPE;

//
// Define I/O Request Packet (IRP) stack locations
//

#if !defined(_AMD64_) && !defined(_IA64_)
#include "pshpack4.h"
#endif



#if defined(_WIN64)
#define POINTER_ALIGNMENT DECLSPEC_ALIGN(8)
#else
#define POINTER_ALIGNMENT
#endif



#if _MSC_VER >= 1200
#pragma warning(push)
#pragma warning(disable:4324) // structure was padded due to __declspec(align())
#endif

typedef struct _IO_STACK_LOCATION {
    UCHAR MajorFunction;
    UCHAR MinorFunction;
    UCHAR Flags;
    UCHAR Control;

    //
    // The following user parameters are based on the service that is being
    // invoked.  Drivers and file systems can determine which set to use based
    // on the above major and minor function codes.
    //

    union {

        //
        // System service parameters for:  NtCreateFile
        //

        struct {
            PIO_SECURITY_CONTEXT SecurityContext;
            ULONG Options;
            USHORT POINTER_ALIGNMENT FileAttributes;
            USHORT ShareAccess;
            ULONG POINTER_ALIGNMENT EaLength;
        } Create;


        //
        // System service parameters for:  NtReadFile
        //

        struct {
            ULONG Length;
            ULONG POINTER_ALIGNMENT Key;
            LARGE_INTEGER ByteOffset;
        } Read;

        //
        // System service parameters for:  NtWriteFile
        //

        struct {
            ULONG Length;
            ULONG POINTER_ALIGNMENT Key;
            LARGE_INTEGER ByteOffset;
        } Write;

        //
        // System service parameters for:  NtQueryDirectoryFile
        //

        struct {
            ULONG Length;
            PUNICODE_STRING FileName;
            FILE_INFORMATION_CLASS FileInformationClass;
            ULONG POINTER_ALIGNMENT FileIndex;
        } QueryDirectory;

        //
        // System service parameters for:  NtNotifyChangeDirectoryFile
        //

        struct {
            ULONG Length;
            ULONG POINTER_ALIGNMENT CompletionFilter;
        } NotifyDirectory;

        //
        // System service parameters for:  NtQueryInformationFile
        //

        struct {
            ULONG Length;
            FILE_INFORMATION_CLASS POINTER_ALIGNMENT FileInformationClass;
        } QueryFile;

        //
        // System service parameters for:  NtSetInformationFile
        //

        struct {
            ULONG Length;
            FILE_INFORMATION_CLASS POINTER_ALIGNMENT FileInformationClass;
            PFILE_OBJECT FileObject;
            union {
                struct {
                    BOOLEAN ReplaceIfExists;
                    BOOLEAN AdvanceOnly;
                };
                ULONG ClusterCount;
                HANDLE DeleteHandle;
            };
        } SetFile;



        //
        // System service parameters for:  NtQueryEaFile
        //

        struct {
            ULONG Length;
            PVOID EaList;
            ULONG EaListLength;
            ULONG POINTER_ALIGNMENT EaIndex;
        } QueryEa;

        //
        // System service parameters for:  NtSetEaFile
        //

        struct {
            ULONG Length;
        } SetEa;



        //
        // System service parameters for:  NtQueryVolumeInformationFile
        //

        struct {
            ULONG Length;
            FS_INFORMATION_CLASS POINTER_ALIGNMENT FsInformationClass;
        } QueryVolume;



        //
        // System service parameters for:  NtSetVolumeInformationFile
        //

        struct {
            ULONG Length;
            FS_INFORMATION_CLASS POINTER_ALIGNMENT FsInformationClass;
        } SetVolume;

        //
        // System service parameters for:  NtFsControlFile
        //
        // Note that the user's output buffer is stored in the UserBuffer field
        // and the user's input buffer is stored in the SystemBuffer field.
        //

        struct {
            ULONG OutputBufferLength;
            ULONG POINTER_ALIGNMENT InputBufferLength;
            ULONG POINTER_ALIGNMENT FsControlCode;
            PVOID Type3InputBuffer;
        } FileSystemControl;
        //
        // System service parameters for:  NtLockFile/NtUnlockFile
        //

        struct {
            PLARGE_INTEGER Length;
            ULONG POINTER_ALIGNMENT Key;
            LARGE_INTEGER ByteOffset;
        } LockControl;

        //
        // System service parameters for:  NtFlushBuffersFile
        //
        // No extra user-supplied parameters.
        //



        //
        // System service parameters for:  NtCancelIoFile
        //
        // No extra user-supplied parameters.
        //



        //
        // System service parameters for:  NtDeviceIoControlFile
        //
        // Note that the user's output buffer is stored in the UserBuffer field
        // and the user's input buffer is stored in the SystemBuffer field.
        //

        struct {
            ULONG OutputBufferLength;
            ULONG POINTER_ALIGNMENT InputBufferLength;
            ULONG POINTER_ALIGNMENT IoControlCode;
            PVOID Type3InputBuffer;
        } DeviceIoControl;

        //
        // System service parameters for:  NtQuerySecurityObject
        //

        struct {
            SECURITY_INFORMATION SecurityInformation;
            ULONG POINTER_ALIGNMENT Length;
        } QuerySecurity;

        //
        // System service parameters for:  NtSetSecurityObject
        //

        struct {
            SECURITY_INFORMATION SecurityInformation;
            PSECURITY_DESCRIPTOR SecurityDescriptor;
        } SetSecurity;

        //
        // Non-system service parameters.
        //
        // Parameters for MountVolume
        //

        struct {
            PVPB Vpb;
            PDEVICE_OBJECT DeviceObject;
        } MountVolume;

        //
        // Parameters for VerifyVolume
        //

        struct {
            PVPB Vpb;
            PDEVICE_OBJECT DeviceObject;
        } VerifyVolume;

        //
        // Parameters for Scsi with internal device contorl.
        //

        struct {
            struct _SCSI_REQUEST_BLOCK *Srb;
        } Scsi;



        //
        // System service parameters for:  NtQueryQuotaInformationFile
        //

        struct {
            ULONG Length;
            PSID StartSid;
            PFILE_GET_QUOTA_INFORMATION SidList;
            ULONG SidListLength;
        } QueryQuota;

        //
        // System service parameters for:  NtSetQuotaInformationFile
        //

        struct {
            ULONG Length;
        } SetQuota;



        //
        // Parameters for IRP_MN_QUERY_DEVICE_RELATIONS
        //

        struct {
            DEVICE_RELATION_TYPE Type;
        } QueryDeviceRelations;

        //
        // Parameters for IRP_MN_QUERY_INTERFACE
        //

        struct {
            CONST GUID *InterfaceType;
            USHORT Size;
            USHORT Version;
            PINTERFACE Interface;
            PVOID InterfaceSpecificData;
        } QueryInterface;

        //
        // Parameters for IRP_MN_QUERY_CAPABILITIES
        //

        struct {
            PDEVICE_CAPABILITIES Capabilities;
        } DeviceCapabilities;

        //
        // Parameters for IRP_MN_FILTER_RESOURCE_REQUIREMENTS
        //

        struct {
            PIO_RESOURCE_REQUIREMENTS_LIST IoResourceRequirementList;
        } FilterResourceRequirements;

        //
        // Parameters for IRP_MN_READ_CONFIG and IRP_MN_WRITE_CONFIG
        //

        struct {
            ULONG WhichSpace;
            PVOID Buffer;
            ULONG Offset;
            ULONG POINTER_ALIGNMENT Length;
        } ReadWriteConfig;

        //
        // Parameters for IRP_MN_SET_LOCK
        //

        struct {
            BOOLEAN Lock;
        } SetLock;

        //
        // Parameters for IRP_MN_QUERY_ID
        //

        struct {
            BUS_QUERY_ID_TYPE IdType;
        } QueryId;

        //
        // Parameters for IRP_MN_QUERY_DEVICE_TEXT
        //

        struct {
            DEVICE_TEXT_TYPE DeviceTextType;
            LCID POINTER_ALIGNMENT LocaleId;
        } QueryDeviceText;

        //
        // Parameters for IRP_MN_DEVICE_USAGE_NOTIFICATION
        //

        struct {
            BOOLEAN InPath;
            BOOLEAN Reserved[3];
            DEVICE_USAGE_NOTIFICATION_TYPE POINTER_ALIGNMENT Type;
        } UsageNotification;

        //
        // Parameters for IRP_MN_WAIT_WAKE
        //

        struct {
            SYSTEM_POWER_STATE PowerState;
        } WaitWake;

        //
        // Parameter for IRP_MN_POWER_SEQUENCE
        //

        struct {
            PPOWER_SEQUENCE PowerSequence;
        } PowerSequence;

        //
        // Parameters for IRP_MN_SET_POWER and IRP_MN_QUERY_POWER
        //

#if (NTDDI_VERSION >= NTDDI_VISTA)
        struct {
            union {
                ULONG SystemContext;
                SYSTEM_POWER_STATE_CONTEXT SystemPowerStateContext;
            };
            POWER_STATE_TYPE POINTER_ALIGNMENT Type;
            POWER_STATE POINTER_ALIGNMENT State;
            POWER_ACTION POINTER_ALIGNMENT ShutdownType;
        } Power;
#else
        struct {
            ULONG SystemContext;
            POWER_STATE_TYPE POINTER_ALIGNMENT Type;
            POWER_STATE POINTER_ALIGNMENT State;
            POWER_ACTION POINTER_ALIGNMENT ShutdownType;
        } Power;
#endif // (NTDDI_VERSION >= NTDDI_VISTA)

        //
        // Parameters for StartDevice
        //

        struct {
            PCM_RESOURCE_LIST AllocatedResources;
            PCM_RESOURCE_LIST AllocatedResourcesTranslated;
        } StartDevice;

        //
        // Parameters for Cleanup
        //
        // No extra parameters supplied
        //

        //
        // WMI Irps
        //

        struct {
            ULONG_PTR ProviderId;
            PVOID DataPath;
            ULONG BufferSize;
            PVOID Buffer;
        } WMI;

        //
        // Others - driver-specific
        //

        struct {
            PVOID Argument1;
            PVOID Argument2;
            PVOID Argument3;
            PVOID Argument4;
        } Others;

    } Parameters;

    //
    // Save a pointer to this device driver's device object for this request
    // so it can be passed to the completion routine if needed.
    //

    PDEVICE_OBJECT DeviceObject;

    //
    // The following location contains a pointer to the file object for this
    // request.
    //

    PFILE_OBJECT FileObject;

    //
    // The following routine is invoked depending on the flags in the above
    // flags field.
    //

    PIO_COMPLETION_ROUTINE CompletionRoutine;

    //
    // The following is used to store the address of the context parameter
    // that should be passed to the CompletionRoutine.
    //

    PVOID Context;

} IO_STACK_LOCATION, *PIO_STACK_LOCATION;

#if _MSC_VER >= 1200
#pragma warning(pop)
#endif

#if !defined(_AMD64_) && !defined(_IA64_)
#include "poppack.h"
#endif

//
// Define the share access structure used by file systems to determine
// whether or not another accessor may open the file.
//

typedef struct _SHARE_ACCESS {
    ULONG OpenCount;
    ULONG Readers;
    ULONG Writers;
    ULONG Deleters;
    ULONG SharedRead;
    ULONG SharedWrite;
    ULONG SharedDelete;
} SHARE_ACCESS, *PSHARE_ACCESS;

//
// Public I/O routine definitions
//

#if (NTDDI_VERSION >= NTDDI_WIN2K)
NTKERNELAPI
VOID
IoAcquireCancelSpinLock(
    __out PKIRQL Irql
    );
#endif


#if (NTDDI_VERSION >= NTDDI_WIN2K)
NTKERNELAPI
NTSTATUS
IoAllocateDriverObjectExtension(
    __in  PDRIVER_OBJECT DriverObject,
    __in  PVOID ClientIdentificationAddress,
    __in  ULONG DriverObjectExtensionSize,
    __out PVOID *DriverObjectExtension
    );
#endif

#if (NTDDI_VERSION >= NTDDI_WIN2K)
NTKERNELAPI
PVOID
IoAllocateErrorLogEntry(
    __in PVOID IoObject,
    __in UCHAR EntrySize
    );
#endif

#if (NTDDI_VERSION >= NTDDI_WIN2K)
NTKERNELAPI
PIRP
IoAllocateIrp(
    __in CCHAR StackSize,
    __in BOOLEAN ChargeQuota
    );
#endif

#if (NTDDI_VERSION >= NTDDI_WIN2K)
NTKERNELAPI
PMDL
IoAllocateMdl(
    __in_opt PVOID VirtualAddress,
    __in ULONG Length,
    __in BOOLEAN SecondaryBuffer,
    __in BOOLEAN ChargeQuota,
    __inout_opt PIRP Irp
    );
#endif

typedef enum _IO_PAGING_PRIORITY {
    IoPagingPriorityInvalid,        // Returned if a non-paging IO IRP is passed.
    IoPagingPriorityNormal,         // For regular paging IO
    IoPagingPriorityHigh,           // For high priority paging IO
    IoPagingPriorityReserved1,      // Reserved for future use.
    IoPagingPriorityReserved2       // Reserved for future use.
} IO_PAGING_PRIORITY;

#if (NTDDI_VERSION >= NTDDI_WIN2K)
NTKERNELAPI
NTSTATUS
IoAttachDevice(
    __in  PDEVICE_OBJECT SourceDevice,
    __in  PUNICODE_STRING TargetDevice,
    __out PDEVICE_OBJECT *AttachedDevice
    );
#endif


#if (NTDDI_VERSION >= NTDDI_WIN2K)
NTKERNELAPI
PDEVICE_OBJECT
IoAttachDeviceToDeviceStack(
    __in PDEVICE_OBJECT SourceDevice,
    __in PDEVICE_OBJECT TargetDevice
    );
#endif

#if (NTDDI_VERSION >= NTDDI_WIN2K)
NTKERNELAPI
PIRP
IoBuildAsynchronousFsdRequest(
    __in ULONG MajorFunction,
    __in PDEVICE_OBJECT DeviceObject,
    __inout_opt PVOID Buffer,
    __in_opt ULONG Length,
    __in_opt PLARGE_INTEGER StartingOffset,
    __in_opt PIO_STATUS_BLOCK IoStatusBlock
    );
#endif

#if (NTDDI_VERSION >= NTDDI_WIN2K)
NTKERNELAPI
PIRP
IoBuildDeviceIoControlRequest(
    __in  ULONG IoControlCode,
    __in  PDEVICE_OBJECT DeviceObject,
    __in_opt  PVOID InputBuffer,
    __in  ULONG InputBufferLength,
    __out_opt PVOID OutputBuffer,
    __in ULONG OutputBufferLength,
    __in BOOLEAN InternalDeviceIoControl,
    __in PKEVENT Event,
    __out PIO_STATUS_BLOCK IoStatusBlock
    );
#endif

#if (NTDDI_VERSION >= NTDDI_WIN2K)
NTKERNELAPI
VOID
IoBuildPartialMdl(
    __in PMDL SourceMdl,
    __inout PMDL TargetMdl,
    __in PVOID VirtualAddress,
    __in ULONG Length
    );
#endif

typedef struct _BOOTDISK_INFORMATION {
    LONGLONG BootPartitionOffset;
    LONGLONG SystemPartitionOffset;
    ULONG BootDeviceSignature;
    ULONG SystemDeviceSignature;
} BOOTDISK_INFORMATION, *PBOOTDISK_INFORMATION;

//
// This structure should follow the previous structure field for field.
//
typedef struct _BOOTDISK_INFORMATION_EX {
    LONGLONG BootPartitionOffset;
    LONGLONG SystemPartitionOffset;
    ULONG BootDeviceSignature;
    ULONG SystemDeviceSignature;
    GUID BootDeviceGuid;
    GUID SystemDeviceGuid;
    BOOLEAN BootDeviceIsGpt;
    BOOLEAN SystemDeviceIsGpt;
} BOOTDISK_INFORMATION_EX, *PBOOTDISK_INFORMATION_EX;

#if (NTDDI_VERSION >= NTDDI_VISTA)
typedef struct _BOOTDISK_INFORMATION_LITE {
    ULONG BootDeviceSignature;
    ULONG SystemDeviceSignature;
    GUID BootDeviceGuid;
    GUID SystemDeviceGuid;
    BOOLEAN BootDeviceIsGpt;
    BOOLEAN SystemDeviceIsGpt;
} BOOTDISK_INFORMATION_LITE, *PBOOTDISK_INFORMATION_LITE;
#endif // NTDDI_VERSION >= NTDDI_VISTA

#if (NTDDI_VERSION >= NTDDI_WIN2K)
NTKERNELAPI
NTSTATUS
IoGetBootDiskInformation(
    __inout PBOOTDISK_INFORMATION BootDiskInformation,
    __in ULONG Size
    );
#endif

#if (NTDDI_VERSION >= NTDDI_VISTA)
NTKERNELAPI
NTSTATUS
IoGetBootDiskInformationLite(
    __inout PBOOTDISK_INFORMATION_LITE BootDiskInformation,
    __in ULONG Size
    );

#endif // NTDDI_VERSION >= NTDDI_VISTA


#if (NTDDI_VERSION >= NTDDI_WIN2K)
NTKERNELAPI
PIRP
IoBuildSynchronousFsdRequest(
    __in  ULONG MajorFunction,
    __in  PDEVICE_OBJECT DeviceObject,
    __inout_opt PVOID Buffer,
    __in_opt ULONG Length,
    __in_opt PLARGE_INTEGER StartingOffset,
    __in  PKEVENT Event,
    __out PIO_STATUS_BLOCK IoStatusBlock
    );
#endif

#if (NTDDI_VERSION >= NTDDI_WIN2K)
NTKERNELAPI
NTSTATUS
FASTCALL
IofCallDriver(
    __in PDEVICE_OBJECT DeviceObject,
    __inout PIRP Irp
    );
#endif

#define IoCallDriver(a,b)   \
        IofCallDriver(a,b)


#if (NTDDI_VERSION >= NTDDI_WIN2K)
NTKERNELAPI
BOOLEAN
IoCancelIrp(
    __in PIRP Irp
    );
#endif


#if (NTDDI_VERSION >= NTDDI_WIN2K)
NTKERNELAPI
NTSTATUS
IoCheckShareAccess(
    __in ACCESS_MASK DesiredAccess,
    __in ULONG DesiredShareAccess,
    __inout PFILE_OBJECT FileObject,
    __inout PSHARE_ACCESS ShareAccess,
    __in BOOLEAN Update
    );
#endif

#if (NTDDI_VERSION >= NTDDI_VISTA)
NTKERNELAPI
NTSTATUS
IoCheckShareAccessEx(
    __in ACCESS_MASK DesiredAccess,
    __in ULONG DesiredShareAccess,
    __inout PFILE_OBJECT FileObject,
    __inout PSHARE_ACCESS ShareAccess,
    __in BOOLEAN Update,
    __in PBOOLEAN WritePermission
    );
#endif

//
// This value should be returned from completion routines to continue
// completing the IRP upwards. Otherwise, STATUS_MORE_PROCESSING_REQUIRED
// should be returned.
//
#define STATUS_CONTINUE_COMPLETION      STATUS_SUCCESS

//
// Completion routines can also use this enumeration in place of status codes.
//
typedef enum _IO_COMPLETION_ROUTINE_RESULT {

    ContinueCompletion = STATUS_CONTINUE_COMPLETION,
    StopCompletion = STATUS_MORE_PROCESSING_REQUIRED

} IO_COMPLETION_ROUTINE_RESULT, *PIO_COMPLETION_ROUTINE_RESULT;

#if (NTDDI_VERSION >= NTDDI_WIN2K)
NTKERNELAPI
VOID
FASTCALL
IofCompleteRequest(
    __in PIRP Irp,
    __in CCHAR PriorityBoost
    );
#endif

#define IoCompleteRequest(a,b)  \
        IofCompleteRequest(a,b)

#if (NTDDI_VERSION >= NTDDI_WIN2K)
NTKERNELAPI
NTSTATUS
IoConnectInterrupt(
    __out PKINTERRUPT *InterruptObject,
    __in  PKSERVICE_ROUTINE ServiceRoutine,
    __in_opt PVOID ServiceContext,
    __in_opt PKSPIN_LOCK SpinLock,
    __in  ULONG Vector,
    __in  KIRQL Irql,
    __in  KIRQL SynchronizeIrql,
    __in  KINTERRUPT_MODE InterruptMode,
    __in  BOOLEAN ShareVector,
    __in  KAFFINITY ProcessorEnableMask,
    __in  BOOLEAN FloatingSave
    );
#endif

//
// Interrupt message information table entry definition
//

typedef struct _IO_INTERRUPT_MESSAGE_INFO_ENTRY {

    //
    // Message address - indicates the address the device should use to
    // generate this message signaled interrupt.
    //

    PHYSICAL_ADDRESS MessageAddress;

    //
    // Target processor set - indicates the set of processors that this
    // message in allowed to interrupt.
    //

    KAFFINITY TargetProcessorSet;

    //
    // Interrupt object - holds a pointer to the interrupt object associated
    // with this interrupt message.  This structure is opaque to drivers.
    //

    PKINTERRUPT InterruptObject;

    //
    // Message data - supplies the value that the device should write to the
    // message address in order to generate this interrupt message.
    //

    ULONG MessageData;

    //
    // The remaining fields indicate the system interrupt vector, IRQL,
    // trigger mode, and interrupt polarity associated with this interrupt
    // message.  These first three values are suitable for use in a fully
    // specified connection parameter structure in a call to
    // IoConnectInterruptEx.
    //

    ULONG Vector;
    KIRQL Irql;
    KINTERRUPT_MODE Mode;
    KINTERRUPT_POLARITY Polarity;

} IO_INTERRUPT_MESSAGE_INFO_ENTRY, *PIO_INTERRUPT_MESSAGE_INFO_ENTRY;

//
// Interrupt message information table definition
//

typedef struct _IO_INTERRUPT_MESSAGE_INFO {

    //
    // Unified IRQL - indicates the IRQL that will be used when calling a
    // message service routine associated with any of the interrupt messages
    // in this table.  Such a unified IRQL will only exist in cases where 1) a
    // driver provides a spinlock to IoConnectInterruptEx with the intent of
    // serializing delivery of all of the messages listed in this table or 2)
    // the driver provides a synchronization IRQL, and no spinlock, with the
    // intent of blocking any message service routine associated with this
    // table from directly preempting another one.  If neither of these cases
    // applies, then the different messages in this table are allowed to be
    // delivered in parallel and at different IRQLs.  In this case this field
    // will be set to zero.
    //

    KIRQL UnifiedIrql;

    //
    // Message count - indicates the number of entries contained in this
    // message information table.
    //

    ULONG MessageCount;

    //
    // Message info - lies at the start of a variable size array of
    // information table entries, with the size of the array dictated by the
    // message count associated with this table.  Each entry describes a
    // different interrupt message that has been allocated to this device.
    //

    IO_INTERRUPT_MESSAGE_INFO_ENTRY MessageInfo[1];

} IO_INTERRUPT_MESSAGE_INFO, *PIO_INTERRUPT_MESSAGE_INFO;

//
// Define the connection parameters associated with a fully specified
// interrupt connection request.
//

typedef struct _IO_CONNECT_INTERRUPT_FULLY_SPECIFIED_PARAMETERS {

    //
    // PhysicalDeviceObject - Supplies the physical device object associated
    //     with the interrupt being connected.  This is normally the physical
    //     device object associated with the device that generates the given
    //     interrupt.
    //

    IN PDEVICE_OBJECT PhysicalDeviceObject;

    //
    // InterruptObject - Supplies a pointer to the location that will be used
    //     to return a pointer to the interrupt object allocated in
    //     association with the interrupt being connected.
    //

    OUT PKINTERRUPT *InterruptObject;

    //
    // ServiceRoutine - Supplies the address of the interrupt service routine
    //     (ISR) that should be executed when the interrupt occurs.
    //

    IN PKSERVICE_ROUTINE ServiceRoutine;

    //
    // ServiceContext - Supplies an opaque pointer to the driver context
    //     information that should be passed to the ISR.
    //

    IN PVOID ServiceContext;

    //
    // SpinLock - Supplies an optional pointer to a spin lock that will be
    //     acquired before every call to the ISR.  After providing a spin
    //     lock, the driver can synchronize with the ISR by acquiring the spin
    //     lock at the synchronization IRQL associated with the interrupt.  If
    //     this parameter is not provided, then an internal spin lock will be
    //     acquired before each call to the ISR.  The driver can use
    //     KeSynchronizeExecution to acquire this internal spin lock at the
    //     appropriate IRQL and thus synchronize with the ISR.
    //

    IN PKSPIN_LOCK SpinLock OPTIONAL;

    //
    // SynchronizeIrql - Supplies the IRQL at which the interrupt spin lock
    //     should be acquired and at which the ISR should be executed.  This
    //     parameter must be greater than or equal to the IRQL associated with
    //     the interrupt.  This parameter is most often used in conjunction
    //     with a caller provided spin lock to serialize ISR execution across
    //     multiple interrupts, however it can also be used without a spin
    //     lock to block this ISR from directly preempting or being directly
    //     preempted by some other ISR.
    //

    IN KIRQL SynchronizeIrql;

    //
    // FloatingSave - Supplies an indication of whether or not the machine's
    //     floating point state should be saved before invoking the ISR.
    //

    IN BOOLEAN FloatingSave;

    //
    // ShareVector - Supplies an indication of whether this interrupt vector
    //     can be shared with other interrupt objects.  This value is usually
    //     passed to a driver as part of the translated resources sent along
    //     with IRP_MN_START_DEVICE.
    //

    IN BOOLEAN ShareVector;

    //
    // Vector - Supplies the system interrupt vector associated with the
    //     interrupt being connected.  This value is usually passed to a
    //     driver as part of the translated resources sent along with
    //     IRP_MN_START_DEVICE.
    //

    IN ULONG Vector;

    //
    // Irql - Supplies the IRQL associated with the interrupt being connected.
    //     This value is usually passed to a driver as part of its translated
    //     resources sent along with IRP_MN_START_DEVICE.
    //

    IN KIRQL Irql;

    //
    // InterruptMode - Supplies the trigger mode of the interrupt being
    //     connected.  This parameter must be LevelSensitive for level
    //     triggered interrupts and Latched for edge triggered interrupts.
    //     This value is usually passed to a driver as part of its translated
    //     resources sent along with IRP_MN_START_DEVICE.
    //

    IN KINTERRUPT_MODE InterruptMode;

    //
    // ProcessorEnableMask - Supplies an affinity mask indicating the set of
    //     processors on which delivery of the interrupt should be allowed.
    //     This value is usually passed to a driver as part of its translated
    //     resources sent along with IRP_MN_START_DEVICE.
    //

    IN KAFFINITY ProcessorEnableMask;

} IO_CONNECT_INTERRUPT_FULLY_SPECIFIED_PARAMETERS,
  *PIO_CONNECT_INTERRUPT_FULLY_SPECIFIED_PARAMETERS;

//
// Define the connection parameters associated with a line based interrupt
// connection request.
//

typedef struct _IO_CONNECT_INTERRUPT_LINE_BASED_PARAMETERS {

    //
    // PhysicalDeviceObject - Supplies the physical device object associated
    //     with the line based interrupt being connected.  In order to
    //     correctly determine the interrupt to connect, this is generally
    //     required to be the physical device object associated with the
    //     device that generates the interrupt of interest.
    //

    IN PDEVICE_OBJECT PhysicalDeviceObject;

    //
    // InterruptObject - Supplies a pointer to the location that will be used
    //     to return a pointer to the interrupt object allocated in
    //     association with the interrupt being connected.
    //

    OUT PKINTERRUPT *InterruptObject;

    //
    // ServiceRoutine - Supplies the address of the interrupt service routine
    //     (ISR) that should be executed when the interrupt occurs.
    //

    IN PKSERVICE_ROUTINE ServiceRoutine;

    //
    // ServiceContext - Supplies an opaque pointer to the driver context
    //     information that should be passed to the ISR.
    //

    IN PVOID ServiceContext;

    //
    // SpinLock - Supplies an optional pointer to a spin lock that will be
    //     acquired before every call to the ISR.  After providing a spin
    //     lock, the driver can synchronize with the ISR by acquiring the spin
    //     lock at the synchronization IRQL associated with the interrupt.  If
    //     this parameter is not provided, then an internal spin lock will be
    //     acquired before each call to the ISR.  The driver can use
    //     KeSynchronizeExecution to acquire this internal spin lock at the
    //     appropriate IRQL and thus synchronize with the ISR.
    //

    IN PKSPIN_LOCK SpinLock OPTIONAL;

    //
    // SynchronizeIrql - Supplies an optional IRQL at which the interrupt spin
    //     lock should be acquired and at which the ISR should be executed.
    //     If a nonzero value is provided for this parameter, it must be
    //     greater than or equal to the IRQL associated with the interrupt.
    //     This parameter is most often used in conjunction with a caller
    //     provided spin lock to serialize ISR execution across multiple
    //     interrupts, however it can also be used without a spin lock to
    //     block this ISR from directly preempting or being directly preempted
    //     by some other ISR.  If this parameter is omitted then the IRQL of
    //     the interrupt being connected is used as the sychronization IRQL,
    //     both in the case where the caller provides a spin lock and in the
    //     case where the spin lock is omitted.
    //

    IN KIRQL SynchronizeIrql OPTIONAL;

    //
    // FloatingSave - Supplies an indication of whether or not the machine's
    //     floating point state should be saved before invoking the ISR.
    //

    IN BOOLEAN FloatingSave;

} IO_CONNECT_INTERRUPT_LINE_BASED_PARAMETERS,
  *PIO_CONNECT_INTERRUPT_LINE_BASED_PARAMETERS;

//
// Define the connection parameters associated with a message signaled
// interrupt connection request.
//

typedef struct _IO_CONNECT_INTERRUPT_MESSAGE_BASED_PARAMETERS {

    //
    // PhysicalDeviceObject - Supplies the physical device object associated
    //     with the interrupt messages being connected.  In order to correctly
    //     determine the set of messages to connect, this is generally
    //     required to be the physical device object associated with the
    //     device that generates the interrupt messages of interest.
    //

    IN PDEVICE_OBJECT PhysicalDeviceObject;

    //
    // ConnectionContext - Supplies a union containing a pointer to the
    //     location that will be used to return the interrupt connection
    //     context to the caller.  If message based interrupt connection is
    //     successful, then the connection context is a pointer to the
    //     associated interrupt message information table.  If connection
    //     succeeds only after falling back on the associated line based
    //     interrupt, then the connection context is a pointer to the
    //     associated interrupt object.
    //

    union {
        OUT PVOID *Generic;
        OUT PIO_INTERRUPT_MESSAGE_INFO *InterruptMessageTable;
        OUT PKINTERRUPT *InterruptObject;
    } ConnectionContext;

    //
    // MessageServiceRoutine - Supplies the interrupt message service routine
    //     (IMSR) that should be executed every time any one of the interrupt
    //     messages being connected is signaled.
    //

    IN PKMESSAGE_SERVICE_ROUTINE MessageServiceRoutine;

    //
    // ServiceContext - Supplies an opaque pointer to the driver context
    //     information that should be passed to the IMSR.
    //

    IN PVOID ServiceContext;

    //
    // SpinLock - Supplies an optional pointer to a spin lock that will be
    //     acquired before every call to the IMSR.  After providing a spin
    //     lock, the driver can synchronize with the IMSR by acquiring the
    //     spin lock at the synchronization IRQL associated with the IMSR.
    //     Note that providing a spin lock will serialize processing of all of
    //     the interrupt messages being connected.  In other words, providing
    //     a spin lock implies that no two interrupt messages out of the set
    //     being connected can ever be serviced in parallel by the IMSR.
    //
    //     If this parameter is not provided, then an internal spin lock will
    //     be acquired before each call to the IMSR.  This internal spin lock
    //     is associated with the interrupt object corresponding to the actual
    //     message that caused us to execute the IMSR, meaning that the IMSR
    //     can run on multiple processors and potentially at multiple IRQLs in
    //     this case.  KeSynchronizeExecution can be used to acquire this
    //     internal spin lock at the appropriate IRQL, thus synchronizing with
    //     IMSR execution associated with a specific interrupt message while
    //     still allowing all other messages to be serviced as they are
    //     signaled.
    //

    IN PKSPIN_LOCK SpinLock OPTIONAL;

    //
    // SynchronizeIrql - Supplies an optional IRQL at which the interrupt spin
    //     lock should be acquired and at which the IMSR should be executed.
    //     If a nonzero value is provided for this parameter, it must be
    //     greater than or equal to the maximum IRQL associated with any of
    //     the interrupt messages being connected.
    //
    //     This parameter is most often used in conjunction with a caller
    //     provided spin lock to serialize IMSR execution across multiple
    //     messages.  If a spin lock is provided and this parameter is
    //     omitted, then the synchronization IRQL will be set to the maximum
    //     IRQL associated with any of the interrupt messages.
    //
    //     This parameter can be used without a spin lock to block this IMSR
    //     from directly preempting or being directly preempted by itself,
    //     some other IMSR, or some other line based interrupt service
    //     routine.  If this parameter is omitted and the spin lock is also
    //     omitted, then the IMSR will be executed at the IRQL associated with
    //     the individual message being serviced.  In this case it is possible
    //     for the IMSR to preempt itself if it is connected to multiple
    //     messages with different associated IRQLs.
    //

    IN KIRQL SynchronizeIrql OPTIONAL;

    //
    // FloatingSave - Supplies an indication of whether or not the machine's
    //     floating point state should be saved before invoking the IMSR.
    //

    IN BOOLEAN FloatingSave;

    //
    // FallBackServiceRoutine - Supplies an optional address of an interrupt
    //     service routine (ISR) that should be executed when the line based
    //     interrupt associated with this device is signaled.  This parameter
    //     will only be used when connection to this device's interrupt
    //     messages fails, which most commonly occurs when no interrupt
    //     messages are available for this device.
    //
    //     Connection to the fall back service routine is functionally
    //     identical to a normal line based interrupt connection operation,
    //     the only difference being that in this case the service context,
    //     spin lock, synchronization IRQL, and floating save parameters given
    //     for the IMSR are reused when connecting the ISR.
    //

    IN PKSERVICE_ROUTINE FallBackServiceRoutine OPTIONAL;

} IO_CONNECT_INTERRUPT_MESSAGE_BASED_PARAMETERS,
  *PIO_CONNECT_INTERRUPT_MESSAGE_BASED_PARAMETERS;

//
// Define the different interrupt connection types that can be requested
// through IoConnectInterruptEx
//

#define CONNECT_FULLY_SPECIFIED     0x1
#define CONNECT_LINE_BASED          0x2
#define CONNECT_MESSAGE_BASED       0x3
#define CONNECT_CURRENT_VERSION     0x3

//
// Interrupt connection parameter structure definition
//

typedef struct _IO_CONNECT_INTERRUPT_PARAMETERS {

    //
    // Version - Supplies the type of interrupt connection requested by this
    //     structure.  This field must hold one of the following values.
    //
    //         CONNECT_FULLY_SPECIFIED - Indicates that an attempt should be
    //             made to connect to the precise interrupt described by this
    //             structure.  This vector can be either line based or message
    //             signaled.
    //
    //         CONNECT_LINE_BASED - Indicates that an attempt should be made
    //             to connect to the line based interrupt associated with this
    //             device.
    //
    //         CONNECT_MESSAGE_BASED - Indicates that an attempt should be
    //             made to connect to the interrupt messages that have been
    //             allocated for this device, optionally falling back on the
    //             device's line based interrupt if interrupt messages aren't
    //             available.
    //
    //     After successfully connecting an interrupt, this field is filled on
    //     output with the type of connection that was performed.  This will
    //     always be the connection type given by the caller except in the
    //     case of a message based connection attempt that falls back to
    //     connection to the associated line based interrupt.
    //
    //     If the caller passes an unsupported connection type, this field is
    //     filled on output with the maximum connection type supported by the
    //     interrupt connection routine.
    //

    IN OUT ULONG Version;

    //
    // Define a union to overlay the connection parameter structures
    // associated with the different connection types on top of one another.
    //

    union {
        IO_CONNECT_INTERRUPT_FULLY_SPECIFIED_PARAMETERS FullySpecified;
        IO_CONNECT_INTERRUPT_LINE_BASED_PARAMETERS LineBased;
        IO_CONNECT_INTERRUPT_MESSAGE_BASED_PARAMETERS MessageBased;
    };

} IO_CONNECT_INTERRUPT_PARAMETERS, *PIO_CONNECT_INTERRUPT_PARAMETERS;

#if (NTDDI_VERSION >= NTDDI_VISTA)
NTKERNELAPI
NTSTATUS
IoConnectInterruptEx (
    __inout PIO_CONNECT_INTERRUPT_PARAMETERS Parameters
    );
#endif // NTDDI_VERSION >= NTDDI_VISTA


#if (NTDDI_VERSION >= NTDDI_WIN2K)
NTKERNELAPI
NTSTATUS
IoCreateDevice(
    __in  PDRIVER_OBJECT DriverObject,
    __in  ULONG DeviceExtensionSize,
    __in_opt PUNICODE_STRING DeviceName,
    __in  DEVICE_TYPE DeviceType,
    __in  ULONG DeviceCharacteristics,
    __in  BOOLEAN Exclusive,
    __out PDEVICE_OBJECT *DeviceObject
    );
#endif

#define WDM_MAJORVERSION        0x06
#define WDM_MINORVERSION        0x00

#if (NTDDI_VERSION >= NTDDI_WIN2K)
NTKERNELAPI
BOOLEAN
IoIsWdmVersionAvailable(
    __in UCHAR MajorVersion,
    __in UCHAR MinorVersion
    );
#endif

#if (NTDDI_VERSION >= NTDDI_WIN2K)
NTKERNELAPI
NTSTATUS
IoCreateFile(
    __out PHANDLE FileHandle,
    __in  ACCESS_MASK DesiredAccess,
    __in  POBJECT_ATTRIBUTES ObjectAttributes,
    __out PIO_STATUS_BLOCK IoStatusBlock,
    __in_opt PLARGE_INTEGER AllocationSize,
    __in  ULONG FileAttributes,
    __in  ULONG ShareAccess,
    __in  ULONG Disposition,
    __in  ULONG CreateOptions,
    __in_opt PVOID EaBuffer,
    __in  ULONG EaLength,
    __in  CREATE_FILE_TYPE CreateFileType,
    __in_opt PVOID InternalParameters,
    __in  ULONG Options
    );
#endif


#if (NTDDI_VERSION >= NTDDI_WIN2K)
NTKERNELAPI
PKEVENT
IoCreateNotificationEvent(
    __in  PUNICODE_STRING EventName,
    __out PHANDLE EventHandle
    );
#endif

#if (NTDDI_VERSION >= NTDDI_WIN2K)
NTKERNELAPI
NTSTATUS
IoCreateSymbolicLink(
    __in PUNICODE_STRING SymbolicLinkName,
    __in PUNICODE_STRING DeviceName
    );
#endif

#if (NTDDI_VERSION >= NTDDI_WIN2K)
NTKERNELAPI
PKEVENT
IoCreateSynchronizationEvent(
    __in  PUNICODE_STRING EventName,
    __out PHANDLE EventHandle
    );
#endif

#if (NTDDI_VERSION >= NTDDI_WIN2K)
NTKERNELAPI
NTSTATUS
IoCreateUnprotectedSymbolicLink(
    __in PUNICODE_STRING SymbolicLinkName,
    __in PUNICODE_STRING DeviceName
    );
#endif


#if (NTDDI_VERSION >= NTDDI_WIN2K)
NTKERNELAPI
VOID
IoDeleteDevice(
    __in PDEVICE_OBJECT DeviceObject
    );
#endif

#if (NTDDI_VERSION >= NTDDI_WIN2K)
NTKERNELAPI
NTSTATUS
IoDeleteSymbolicLink(
    __in PUNICODE_STRING SymbolicLinkName
    );
#endif

#if (NTDDI_VERSION >= NTDDI_WIN2K)
NTKERNELAPI
VOID
IoDetachDevice(
    __inout PDEVICE_OBJECT TargetDevice
    );
#endif

#if (NTDDI_VERSION >= NTDDI_WIN2K)
NTKERNELAPI
VOID
IoDisconnectInterrupt(
    __in PKINTERRUPT InterruptObject
    );
#endif

//
// Interrupt disconnection parameter structure definition
//

typedef struct _IO_DISCONNECT_INTERRUPT_PARAMETERS {

    //
    // Version - Supplies the type of interrupt disconnection operation
    //     requested by this structure.  This field must match the connection
    //     type returned by a corresponding successful call to
    //     IoConnectInterruptEx.
    //

    IN ULONG Version;

    //
    // ConnectionContext - Supplies a union containing the connection context
    //     associated with the interrupt being disconnected.  When
    //     disconnecting fully specified or line based interrupts, this
    //     parameter supplies the interrupt object pointer that was returned
    //     when the interrupt was initially connected.  When disconnecting a
    //     set of interrupt messages, this parameter supplies the interrupt
    //     message information table pointer that was returned when the
    //     interrupt messages were initially connected.
    //

    union {
        IN PVOID Generic;
        IN PKINTERRUPT InterruptObject;
        IN PIO_INTERRUPT_MESSAGE_INFO InterruptMessageTable;
    } ConnectionContext;

} IO_DISCONNECT_INTERRUPT_PARAMETERS, *PIO_DISCONNECT_INTERRUPT_PARAMETERS;

#if (NTDDI_VERSION >= NTDDI_VISTA)
NTKERNELAPI
VOID
IoDisconnectInterruptEx (
    __in PIO_DISCONNECT_INTERRUPT_PARAMETERS Parameters
    );
#endif // NTDDI_VERSION >= NTDDI_VISTA


#if (NTDDI_VERSION >= NTDDI_WIN2K)
NTKERNELAPI
VOID
IoFreeIrp(
    __in PIRP Irp
    );
#endif

#if (NTDDI_VERSION >= NTDDI_WIN2K)
NTKERNELAPI
VOID
IoFreeMdl(
    PMDL Mdl
    );
#endif

#if (NTDDI_VERSION >= NTDDI_WIN2K)          
NTKERNELAPI                                 
PDEVICE_OBJECT                              
IoGetAttachedDeviceReference(               
    __in PDEVICE_OBJECT DeviceObject        
    );                                      
#endif                                      
                                            

//++
//
// PIO_STACK_LOCATION
// IoGetCurrentIrpStackLocation(
//     IN PIRP Irp
//     )
//
// Routine Description:
//
//     This routine is invoked to return a pointer to the current stack location
//     in an I/O Request Packet (IRP).
//
// Arguments:
//
//     Irp - Pointer to the I/O Request Packet.
//
// Return Value:
//
//     The function value is a pointer to the current stack location in the
//     packet.
//
//--

#define IoGetCurrentIrpStackLocation( Irp ) ( (Irp)->Tail.Overlay.CurrentStackLocation )


#if (NTDDI_VERSION >= NTDDI_WIN2K)
NTKERNELAPI
PVOID
IoGetDriverObjectExtension(
    __in PDRIVER_OBJECT DriverObject,
    __in PVOID ClientIdentificationAddress
    );
#endif

#if (NTDDI_VERSION >= NTDDI_WIN2K)
NTKERNELAPI
PEPROCESS
IoGetCurrentProcess(
    VOID
    );
#endif

#if (NTDDI_VERSION >= NTDDI_WIN2K)
NTKERNELAPI
NTSTATUS
IoGetDeviceObjectPointer(
    __in  PUNICODE_STRING ObjectName,
    __in  ACCESS_MASK DesiredAccess,
    __out PFILE_OBJECT *FileObject,
    __out PDEVICE_OBJECT *DeviceObject
    );
#endif

#if (NTDDI_VERSION >= NTDDI_WIN2K)
NTKERNELAPI
struct _DMA_ADAPTER *
IoGetDmaAdapter(
    __in_opt PDEVICE_OBJECT PhysicalDeviceObject,           // required for PnP drivers
    __in struct _DEVICE_DESCRIPTION *DeviceDescription,
    __inout PULONG NumberOfMapRegisters
    );
#endif

#if (NTDDI_VERSION >= NTDDI_WINXP)
NTKERNELAPI
BOOLEAN
IoForwardIrpSynchronously(
    __in PDEVICE_OBJECT DeviceObject,
    __in PIRP Irp
    );

#define IoForwardAndCatchIrp IoForwardIrpSynchronously

#endif


//++
//
// ULONG
// IoGetFunctionCodeFromCtlCode(
//     IN ULONG ControlCode
//     )
//
// Routine Description:
//
//     This routine extracts the function code from IOCTL and FSCTL function
//     control codes.
//     This routine should only be used by kernel mode code.
//
// Arguments:
//
//     ControlCode - A function control code (IOCTL or FSCTL) from which the
//         function code must be extracted.
//
// Return Value:
//
//     The extracted function code.
//
// Note:
//
//     The CTL_CODE macro, used to create IOCTL and FSCTL function control
//     codes, is defined in ntioapi.h
//
//--

#define IoGetFunctionCodeFromCtlCode( ControlCode ) (\
    ( ControlCode >> 2) & 0x00000FFF )

#if (NTDDI_VERSION >= NTDDI_WIN2K)
NTKERNELAPI
PVOID
IoGetInitialStack(
    VOID
    );
#endif

NTKERNELAPI
VOID
IoGetStackLimits (
    __out PULONG_PTR LowLimit,
    __out PULONG_PTR HighLimit
    );

#if (NTDDI_VERSION >= NTDDI_VISTA)
LOGICAL
IoWithinStackLimits(
    __in ULONG_PTR RegionStart,
    __in SIZE_T RegionSize
    );
#endif


#define IoCallDriverStackSafeDefault(a, b) IoCallDriver(a, b)

//
//  The following function is used to tell the caller how much stack is available
//

FORCEINLINE
ULONG_PTR
IoGetRemainingStackSize (
    VOID
    )
{
    ULONG_PTR Top;
    ULONG_PTR Bottom;

    IoGetStackLimits( &Bottom, &Top );
    return((ULONG_PTR)(&Top) - Bottom );
}

//++
//
// PIO_STACK_LOCATION
// IoGetNextIrpStackLocation(
//     IN PIRP Irp
//     )
//
// Routine Description:
//
//     This routine is invoked to return a pointer to the next stack location
//     in an I/O Request Packet (IRP).
//
// Arguments:
//
//     Irp - Pointer to the I/O Request Packet.
//
// Return Value:
//
//     The function value is a pointer to the next stack location in the packet.
//
//--

#define IoGetNextIrpStackLocation( Irp ) (\
    (Irp)->Tail.Overlay.CurrentStackLocation - 1 )

#if (NTDDI_VERSION >= NTDDI_WIN2K)
NTKERNELAPI
PDEVICE_OBJECT
IoGetRelatedDeviceObject(
    __in PFILE_OBJECT FileObject
    );
#endif


#if (NTDDI_VERSION >= NTDDI_WIN2K)
NTKERNELAPI
PIRP
IoGetTopLevelIrp(
    VOID
    );
#endif


//++
//
// VOID
// IoInitializeDpcRequest(
//     IN PDEVICE_OBJECT DeviceObject,
//     IN PIO_DPC_ROUTINE DpcRoutine
//     )
//
// Routine Description:
//
//     This routine is invoked to initialize the DPC in a device object for a
//     device driver during its initialization routine.  The DPC is used later
//     when the driver interrupt service routine requests that a DPC routine
//     be queued for later execution.
//
// Arguments:
//
//     DeviceObject - Pointer to the device object that the request is for.
//
//     DpcRoutine - Address of the driver's DPC routine to be executed when
//         the DPC is dequeued for processing.
//
// Return Value:
//
//     None.
//
//--


#define IoInitializeDpcRequest( DeviceObject, DpcRoutine ) (\
    KeInitializeDpc( &(DeviceObject)->Dpc,                  \
                     (PKDEFERRED_ROUTINE) (DpcRoutine),     \
                     (DeviceObject) ) )


#if (NTDDI_VERSION >= NTDDI_WIN2K)
NTKERNELAPI
VOID
IoInitializeIrp(
    __inout PIRP Irp,
    __in USHORT PacketSize,
    __in CCHAR StackSize
    );
#endif

#if (NTDDI_VERSION >= NTDDI_WIN2K)
NTKERNELAPI
NTSTATUS
IoInitializeTimer(
    __in PDEVICE_OBJECT DeviceObject,
    __in PIO_TIMER_ROUTINE TimerRoutine,
    __in_opt PVOID Context
    );
#endif


#if (NTDDI_VERSION >= NTDDI_WIN2K)
NTKERNELAPI
VOID
IoReuseIrp(
    __inout PIRP Irp,
    __in NTSTATUS Iostatus
    );
#endif


//++
//
// BOOLEAN
// IoIsErrorUserInduced(
//     IN NTSTATUS Status
//     )
//
// Routine Description:
//
//     This routine is invoked to determine if an error was as a
//     result of user actions.  Typically these error are related
//     to removable media and will result in a pop-up.
//
// Arguments:
//
//     Status - The status value to check.
//
// Return Value:
//     The function value is TRUE if the user induced the error,
//     otherwise FALSE is returned.
//
//--
#define IoIsErrorUserInduced( Status ) ((BOOLEAN)  \
    (((Status) == STATUS_DEVICE_NOT_READY) ||      \
     ((Status) == STATUS_IO_TIMEOUT) ||            \
     ((Status) == STATUS_MEDIA_WRITE_PROTECTED) || \
     ((Status) == STATUS_NO_MEDIA_IN_DEVICE) ||    \
     ((Status) == STATUS_VERIFY_REQUIRED) ||       \
     ((Status) == STATUS_UNRECOGNIZED_MEDIA) ||    \
     ((Status) == STATUS_WRONG_VOLUME)))


//++
//
// VOID
// IoMarkIrpPending(
//     IN OUT PIRP Irp
//     )
//
// Routine Description:
//
//     This routine marks the specified I/O Request Packet (IRP) to indicate
//     that an initial status of STATUS_PENDING was returned to the caller.
//     This is used so that I/O completion can determine whether or not to
//     fully complete the I/O operation requested by the packet.
//
// Arguments:
//
//     Irp - Pointer to the I/O Request Packet to be marked pending.
//
// Return Value:
//
//     None.
//
//--

#define IoMarkIrpPending( Irp ) ( \
    IoGetCurrentIrpStackLocation( (Irp) )->Control |= SL_PENDING_RETURNED )


#if (NTDDI_VERSION >= NTDDI_WIN2K)
NTKERNELAPI
NTSTATUS
IoRegisterShutdownNotification(
    __in PDEVICE_OBJECT DeviceObject
    );
#endif

#if (NTDDI_VERSION >= NTDDI_WIN2K)
NTKERNELAPI
NTSTATUS
IoRegisterLastChanceShutdownNotification(
    __in PDEVICE_OBJECT DeviceObject
    );
#endif

#if (NTDDI_VERSION >= NTDDI_WIN2K)
NTKERNELAPI
VOID
IoReleaseCancelSpinLock(
    __in KIRQL Irql
    );
#endif


#if (NTDDI_VERSION >= NTDDI_WIN2K)
NTKERNELAPI
VOID
IoRemoveShareAccess(
    __in PFILE_OBJECT FileObject,
    __inout PSHARE_ACCESS ShareAccess
    );
#endif


//++
//
// VOID
// IoRequestDpc(
//     IN PDEVICE_OBJECT DeviceObject,
//     IN PIRP Irp,
//     IN PVOID Context
//     )
//
// Routine Description:
//
//     This routine is invoked by the device driver's interrupt service routine
//     to request that a DPC routine be queued for later execution at a lower
//     IRQL.
//
// Arguments:
//
//     DeviceObject - Device object for which the request is being processed.
//
//     Irp - Pointer to the current I/O Request Packet (IRP) for the specified
//         device.
//
//     Context - Provides a general context parameter to be passed to the
//         DPC routine.
//
// Return Value:
//
//     None.
//
//--

#define IoRequestDpc( DeviceObject, Irp, Context ) ( \
    KeInsertQueueDpc( &(DeviceObject)->Dpc, (Irp), (Context) ) )

//++
//
// PDRIVER_CANCEL
// IoSetCancelRoutine(
//     IN PIRP Irp,
//     IN PDRIVER_CANCEL CancelRoutine
//     )
//
// Routine Description:
//
//     This routine is invoked to set the address of a cancel routine which
//     is to be invoked when an I/O packet has been canceled.
//
// Arguments:
//
//     Irp - Pointer to the I/O Request Packet itself.
//
//     CancelRoutine - Address of the cancel routine that is to be invoked
//         if the IRP is cancelled.
//
// Return Value:
//
//     Previous value of CancelRoutine field in the IRP.
//
//--

#define IoSetCancelRoutine( Irp, NewCancelRoutine ) (  \
    (PDRIVER_CANCEL) (ULONG_PTR) InterlockedExchangePointer( (PVOID *) &(Irp)->CancelRoutine, (PVOID) (ULONG_PTR)(NewCancelRoutine) ) )

FORCEINLINE
VOID
IoSetCompletionRoutine(
    __in PIRP Irp,
    __in_opt PIO_COMPLETION_ROUTINE CompletionRoutine,
    __in_opt PVOID Context,
    __in BOOLEAN InvokeOnSuccess,
    __in BOOLEAN InvokeOnError,
    __in BOOLEAN InvokeOnCancel
    )
//++
//
// Routine Description:
//
//     This routine is invoked to set the address of a completion routine which
//     is to be invoked when an I/O packet has been completed by a lower-level
//     driver.
//
// Arguments:
//
//     Irp - Pointer to the I/O Request Packet itself.
//
//     CompletionRoutine - Address of the completion routine that is to be
//         invoked once the next level driver completes the packet.
//
//     Context - Specifies a context parameter to be passed to the completion
//         routine.
//
//     InvokeOnSuccess - Specifies that the completion routine is invoked when the
//         operation is successfully completed.
//
//     InvokeOnError - Specifies that the completion routine is invoked when the
//         operation completes with an error status.
//
//     InvokeOnCancel - Specifies that the completion routine is invoked when the
//         operation is being canceled.
//
// Return Value:
//
//     None.
//
//--
{
    PIO_STACK_LOCATION irpSp;
    ASSERT( (InvokeOnSuccess || InvokeOnError || InvokeOnCancel) ? (CompletionRoutine != NULL) : TRUE );
    irpSp = IoGetNextIrpStackLocation(Irp);
    irpSp->CompletionRoutine = CompletionRoutine;
    irpSp->Context = Context;
    irpSp->Control = 0;

    if (InvokeOnSuccess) {
        irpSp->Control = SL_INVOKE_ON_SUCCESS;
    }

    if (InvokeOnError) {
        irpSp->Control |= SL_INVOKE_ON_ERROR;
    }

    if (InvokeOnCancel) {
        irpSp->Control |= SL_INVOKE_ON_CANCEL;
    }
}

#if (NTDDI_VERSION >= NTDDI_WINXP)
NTKERNELAPI
__checkReturn
NTSTATUS
IoSetCompletionRoutineEx(
    __in PDEVICE_OBJECT DeviceObject,
    __in PIRP Irp,
    __in PIO_COMPLETION_ROUTINE CompletionRoutine,
    __in_opt PVOID Context,
    __in BOOLEAN InvokeOnSuccess,
    __in BOOLEAN InvokeOnError,
    __in BOOLEAN InvokeOnCancel
    );
#endif


//++
//
// VOID
// IoSetNextIrpStackLocation (
//     IN OUT PIRP Irp
//     )
//
// Routine Description:
//
//     This routine is invoked to set the current IRP stack location to
//     the next stack location, i.e. it "pushes" the stack.
//
// Arguments:
//
//     Irp - Pointer to the I/O Request Packet (IRP).
//
// Return Value:
//
//     None.
//
//--

#define IoSetNextIrpStackLocation( Irp ) {      \
    (Irp)->CurrentLocation--;                   \
    (Irp)->Tail.Overlay.CurrentStackLocation--; }

//++
//
// VOID
// IoCopyCurrentIrpStackLocationToNext(
//     IN PIRP Irp
//     )
//
// Routine Description:
//
//     This routine is invoked to copy the IRP stack arguments and file
//     pointer from the current IrpStackLocation to the next
//     in an I/O Request Packet (IRP).
//
//     If the caller wants to call IoCallDriver with a completion routine
//     but does not wish to change the arguments otherwise,
//     the caller first calls IoCopyCurrentIrpStackLocationToNext,
//     then IoSetCompletionRoutine, then IoCallDriver.
//
// Arguments:
//
//     Irp - Pointer to the I/O Request Packet.
//
// Return Value:
//
//     None.
//
//--

#define IoCopyCurrentIrpStackLocationToNext( Irp ) { \
    PIO_STACK_LOCATION __irpSp; \
    PIO_STACK_LOCATION __nextIrpSp; \
    __irpSp = IoGetCurrentIrpStackLocation( (Irp) ); \
    __nextIrpSp = IoGetNextIrpStackLocation( (Irp) ); \
    RtlCopyMemory( __nextIrpSp, __irpSp, FIELD_OFFSET(IO_STACK_LOCATION, CompletionRoutine)); \
    __nextIrpSp->Control = 0; }

//++
//
// VOID
// IoSkipCurrentIrpStackLocation (
//     IN PIRP Irp
//     )
//
// Routine Description:
//
//     This routine is invoked to increment the current stack location of
//     a given IRP.
//
//     If the caller wishes to call the next driver in a stack, and does not
//     wish to change the arguments, nor does he wish to set a completion
//     routine, then the caller first calls IoSkipCurrentIrpStackLocation
//     and the calls IoCallDriver.
//
// Arguments:
//
//     Irp - Pointer to the I/O Request Packet.
//
// Return Value:
//
//     None
//
//--

#define IoSkipCurrentIrpStackLocation( Irp ) { \
    (Irp)->CurrentLocation++; \
    (Irp)->Tail.Overlay.CurrentStackLocation++; }


#if (NTDDI_VERSION >= NTDDI_WIN2K)
NTKERNELAPI
VOID
IoSetShareAccess(
    __in  ACCESS_MASK DesiredAccess,
    __in  ULONG DesiredShareAccess,
    __inout PFILE_OBJECT FileObject,
    __out PSHARE_ACCESS ShareAccess
    );
#endif

#if (NTDDI_VERSION >= NTDDI_VISTA)
NTKERNELAPI
VOID
IoSetShareAccessEx(
    __in  ACCESS_MASK DesiredAccess,
    __in  ULONG DesiredShareAccess,
    __inout PFILE_OBJECT FileObject,
    __out PSHARE_ACCESS ShareAccess,
    __in PBOOLEAN WritePermission
    );
#endif




#if (NTDDI_VERSION >= NTDDI_WIN2K)
NTKERNELAPI
VOID
IoSetTopLevelIrp(
    __in_opt PIRP Irp
    );
#endif





typedef struct _IO_REMOVE_LOCK_TRACKING_BLOCK * PIO_REMOVE_LOCK_TRACKING_BLOCK;

typedef struct _IO_REMOVE_LOCK_COMMON_BLOCK {
    BOOLEAN     Removed;
    BOOLEAN     Reserved [3];
    __volatile LONG        IoCount;
    KEVENT      RemoveEvent;

} IO_REMOVE_LOCK_COMMON_BLOCK;

typedef struct _IO_REMOVE_LOCK_DBG_BLOCK {
    LONG        Signature;
    ULONG       HighWatermark;
    LONGLONG    MaxLockedTicks;
    LONG        AllocateTag;
    LIST_ENTRY  LockList;
    KSPIN_LOCK  Spin;
    __volatile LONG        LowMemoryCount;
    ULONG       Reserved1[4];
    PVOID       Reserved2;
    PIO_REMOVE_LOCK_TRACKING_BLOCK Blocks;
} IO_REMOVE_LOCK_DBG_BLOCK;

typedef struct _IO_REMOVE_LOCK {
    IO_REMOVE_LOCK_COMMON_BLOCK Common;
#if DBG
    IO_REMOVE_LOCK_DBG_BLOCK Dbg;
#endif
} IO_REMOVE_LOCK, *PIO_REMOVE_LOCK;

#define IoInitializeRemoveLock(Lock, Tag, Maxmin, HighWater) \
        IoInitializeRemoveLockEx (Lock, Tag, Maxmin, HighWater, sizeof (IO_REMOVE_LOCK))

#if (NTDDI_VERSION >= NTDDI_WIN2K)
NTKERNELAPI
VOID
NTAPI
IoInitializeRemoveLockEx(
    __in PIO_REMOVE_LOCK Lock,
    __in ULONG  AllocateTag, // Used only on checked kernels
    __in ULONG  MaxLockedMinutes, // Used only on checked kernels
    __in ULONG  HighWatermark, // Used only on checked kernels
    __in ULONG  RemlockSize // are we checked or free
    );
#endif

//
//  Initialize a remove lock.
//
//  Note: Allocation for remove locks needs to be within the device extension,
//  so that the memory for this structure stays allocated until such time as the
//  device object itself is deallocated.
//

#if DBG
#define IoAcquireRemoveLock(RemoveLock, Tag) \
        IoAcquireRemoveLockEx(RemoveLock, Tag, __FILE__, __LINE__, sizeof (IO_REMOVE_LOCK))
#else
#define IoAcquireRemoveLock(RemoveLock, Tag) \
        IoAcquireRemoveLockEx(RemoveLock, Tag, "", 1, sizeof (IO_REMOVE_LOCK))
#endif

#if (NTDDI_VERSION >= NTDDI_WIN2K)
NTKERNELAPI
NTSTATUS
NTAPI
IoAcquireRemoveLockEx (
    __in PIO_REMOVE_LOCK RemoveLock,
    __in_opt PVOID      Tag, // Optional
    __in PCSTR          File,
    __in ULONG          Line,
    __in ULONG          RemlockSize // are we checked or free
    );
#endif

//
// Routine Description:
//
//    This routine is called to acquire the remove lock for a device object.
//    While the lock is held, the caller can assume that no pending pnp REMOVE
//    requests will be completed.
//
//    The lock should be acquired immediately upon entering a dispatch routine.
//    It should also be acquired before creating any new reference to the
//    device object if there's a chance of releasing the reference before the
//    new one is done, in addition to references to the driver code itself,
//    which is removed from memory when the last device object goes.
//
//    Arguments:
//
//    RemoveLock - A pointer to an initialized REMOVE_LOCK structure.
//
//    Tag - Used for tracking lock allocation and release.  The same tag
//          specified when acquiring the lock must be used to release the lock.
//          Tags are only checked in checked versions of the driver.
//
//    File - set to __FILE__ as the location in the code where the lock was taken.
//
//    Line - set to __LINE__.
//
// Return Value:
//
//    Returns whether or not the remove lock was obtained.
//    If successful the caller should continue with work calling
//    IoReleaseRemoveLock when finished.
//
//    If not successful the lock was not obtained.  The caller should abort the
//    work but not call IoReleaseRemoveLock.
//

#define IoReleaseRemoveLock(RemoveLock, Tag) \
        IoReleaseRemoveLockEx(RemoveLock, Tag, sizeof (IO_REMOVE_LOCK))

#if (NTDDI_VERSION >= NTDDI_WIN2K)
NTKERNELAPI
VOID
NTAPI
IoReleaseRemoveLockEx(
    __in PIO_REMOVE_LOCK RemoveLock,
    __in_opt PVOID       Tag, // Optional
    __in ULONG           RemlockSize // are we checked or free
    );
#endif

//
//
// Routine Description:
//
//    This routine is called to release the remove lock on the device object.  It
//    must be called when finished using a previously locked reference to the
//    device object.  If an Tag was specified when acquiring the lock then the
//    same Tag must be specified when releasing the lock.
//
//    When the lock count reduces to zero, this routine will signal the waiting
//    event to release the waiting thread deleting the device object protected
//    by this lock.
//
// Arguments:
//
//    DeviceObject - the device object to lock
//
//    Tag - The TAG (if any) specified when acquiring the lock.  This is used
//          for lock tracking purposes
//
// Return Value:
//
//    none
//

#define IoReleaseRemoveLockAndWait(RemoveLock, Tag) \
        IoReleaseRemoveLockAndWaitEx(RemoveLock, Tag, sizeof (IO_REMOVE_LOCK))

#if (NTDDI_VERSION >= NTDDI_WIN2K)
NTKERNELAPI
VOID
NTAPI
IoReleaseRemoveLockAndWaitEx(
    __in PIO_REMOVE_LOCK RemoveLock,
    __in_opt PVOID       Tag,
    __in ULONG           RemlockSize // are we checked or free
    );
#endif

//
//
// Routine Description:
//
//    This routine is called when the client would like to delete the
//    remove-locked resource.  This routine will block until all the remove
//    locks have released.
//
//    This routine MUST be called after acquiring the lock.
//
// Arguments:
//
//    RemoveLock
//
// Return Value:
//
//    none
//


//++
//
// USHORT
// IoSizeOfIrp(
//     IN CCHAR StackSize
//     )
//
// Routine Description:
//
//     Determines the size of an IRP given the number of stack locations
//     the IRP will have.
//
// Arguments:
//
//     StackSize - Number of stack locations for the IRP.
//
// Return Value:
//
//     Size in bytes of the IRP.
//
//--

#define IoSizeOfIrp( StackSize ) \
    ((USHORT) (sizeof( IRP ) + ((StackSize) * (sizeof( IO_STACK_LOCATION )))))

#if (NTDDI_VERSION >= NTDDI_WIN2K)
NTKERNELAPI
VOID
IoStartNextPacket(
    __in PDEVICE_OBJECT DeviceObject,
    __in BOOLEAN Cancelable
    );
#endif

#if (NTDDI_VERSION >= NTDDI_WIN2K)
NTKERNELAPI
VOID
IoStartNextPacketByKey(
    __in PDEVICE_OBJECT DeviceObject,
    __in BOOLEAN Cancelable,
    __in ULONG Key
    );
#endif

#if (NTDDI_VERSION >= NTDDI_WIN2K)
NTKERNELAPI
VOID
IoStartPacket(
    __in PDEVICE_OBJECT DeviceObject,
    __in PIRP Irp,
    __in_opt PULONG Key,
    __in_opt PDRIVER_CANCEL CancelFunction
    );
#endif

#if (NTDDI_VERSION >= NTDDI_WINXP)
VOID
IoSetStartIoAttributes(
    __in PDEVICE_OBJECT DeviceObject,
    __in BOOLEAN DeferredStartIo,
    __in BOOLEAN NonCancelable
    );
#endif

#if (NTDDI_VERSION >= NTDDI_WIN2K)
NTKERNELAPI
VOID
IoStartTimer(
    __in PDEVICE_OBJECT DeviceObject
    );
#endif

#if (NTDDI_VERSION >= NTDDI_WIN2K)
NTKERNELAPI
VOID
IoStopTimer(
    __in PDEVICE_OBJECT DeviceObject
    );
#endif


#if (NTDDI_VERSION >= NTDDI_WIN2K)
NTKERNELAPI
VOID
IoUnregisterShutdownNotification(
    __in PDEVICE_OBJECT DeviceObject
    );
#endif

#if (NTDDI_VERSION >= NTDDI_WIN2K)
NTKERNELAPI
VOID
IoUpdateShareAccess(
    __in PFILE_OBJECT FileObject,
    __inout PSHARE_ACCESS ShareAccess
    );
#endif

#if (NTDDI_VERSION >= NTDDI_WIN2K)              
NTKERNELAPI                                     
VOID                                            
IoWriteErrorLogEntry(                           
    __in PVOID ElEntry                          
    );                                          
#endif                                          

typedef struct _IO_WORKITEM *PIO_WORKITEM;

#if (NTDDI_VERSION >= NTDDI_VISTA)
ULONG
IoSizeofWorkItem(
    VOID
    );
#endif

#if (NTDDI_VERSION >= NTDDI_VISTA)
VOID
IoInitializeWorkItem(
    __in IN PVOID IoObject,
    __in IN PIO_WORKITEM IoWorkItem
    );
#endif

#if (NTDDI_VERSION >= NTDDI_VISTA)
VOID
IoUninitializeWorkItem(
    __in IN PIO_WORKITEM IoWorkItem
    );
#endif

typedef
VOID
IO_WORKITEM_ROUTINE (
    __in PDEVICE_OBJECT DeviceObject,
    __in_opt PVOID Context
    );

typedef IO_WORKITEM_ROUTINE *PIO_WORKITEM_ROUTINE;

typedef
VOID
IO_WORKITEM_ROUTINE_EX (
    __in PVOID IoObject,
    __in_opt PVOID Context,
    __in PIO_WORKITEM IoWorkItem
    );

typedef IO_WORKITEM_ROUTINE_EX *PIO_WORKITEM_ROUTINE_EX;

#if (NTDDI_VERSION >= NTDDI_WIN2K)
NTKERNELAPI
PIO_WORKITEM
IoAllocateWorkItem(
    __in PDEVICE_OBJECT DeviceObject
    );
#endif

#if (NTDDI_VERSION >= NTDDI_WIN2K)
NTKERNELAPI
VOID
IoFreeWorkItem(
    __in PIO_WORKITEM IoWorkItem
    );
#endif

#if (NTDDI_VERSION >= NTDDI_WIN2K)
NTKERNELAPI
VOID
IoQueueWorkItem(
    __in PIO_WORKITEM IoWorkItem,
    __in PIO_WORKITEM_ROUTINE WorkerRoutine,
    __in WORK_QUEUE_TYPE QueueType,
    __in_opt PVOID Context
    );
#endif

#if (NTDDI_VERSION >= NTDDI_VISTA)
VOID
IoQueueWorkItemEx(
    __in PIO_WORKITEM IoWorkItem,
    __in PIO_WORKITEM_ROUTINE_EX WorkerRoutine,
    __in WORK_QUEUE_TYPE QueueType,
    __in_opt PVOID Context
    );
#endif

#if (NTDDI_VERSION >= NTDDI_WIN2K)
NTKERNELAPI
NTSTATUS
IoWMIRegistrationControl(
    __in PDEVICE_OBJECT DeviceObject,
    __in ULONG Action
);
#endif

//
// Action code for IoWMIRegistrationControl api
//

#define WMIREG_ACTION_REGISTER      1
#define WMIREG_ACTION_DEREGISTER    2
#define WMIREG_ACTION_REREGISTER    3
#define WMIREG_ACTION_UPDATE_GUIDS  4
#define WMIREG_ACTION_BLOCK_IRPS    5

//
// Code passed in IRP_MN_REGINFO WMI irp
//

#define WMIREGISTER                 0
#define WMIUPDATE                   1

#if (NTDDI_VERSION >= NTDDI_WIN2K)
NTKERNELAPI
NTSTATUS
IoWMIAllocateInstanceIds(
    __in GUID *Guid,
    __in ULONG InstanceCount,
    __out ULONG *FirstInstanceId
    );
#endif

#if (NTDDI_VERSION >= NTDDI_WIN2K)
NTKERNELAPI
NTSTATUS
IoWMISuggestInstanceName(
    __in_opt PDEVICE_OBJECT PhysicalDeviceObject,
    __in_opt PUNICODE_STRING SymbolicLinkName,
    __in BOOLEAN CombineNames,
    __out PUNICODE_STRING SuggestedInstanceName
    );
#endif

#if (NTDDI_VERSION >= NTDDI_WIN2K)
NTKERNELAPI
NTSTATUS
IoWMIWriteEvent(
    __inout PVOID WnodeEventItem
    );
#endif

#if defined(_WIN64)
NTKERNELAPI
ULONG
IoWMIDeviceObjectToProviderId(
    __in PDEVICE_OBJECT DeviceObject
    );
#else
#define IoWMIDeviceObjectToProviderId(DeviceObject) ((ULONG)(DeviceObject))
#endif

#if (NTDDI_VERSION >= NTDDI_WINXP)
NTKERNELAPI
NTSTATUS
IoWMIOpenBlock(
    __in GUID *DataBlockGuid,
    __in ULONG DesiredAccess,
    __out PVOID *DataBlockObject
    );
#endif

#if (NTDDI_VERSION >= NTDDI_WINXP)
NTKERNELAPI
NTSTATUS
IoWMIQueryAllData(
    __in PVOID DataBlockObject,
    __inout ULONG *InOutBufferSize,
    __out_bcount_opt(*InOutBufferSize) /* non paged */ PVOID OutBuffer
    );
#endif

#if (NTDDI_VERSION >= NTDDI_WINXP)
NTKERNELAPI
NTSTATUS
IoWMIQueryAllDataMultiple(
    __in_ecount(ObjectCount) PVOID *DataBlockObjectList,
    __in ULONG ObjectCount,
    __inout ULONG *InOutBufferSize,
    __out_bcount_opt(*InOutBufferSize) /* non paged */ PVOID OutBuffer
    );
#endif

#if (NTDDI_VERSION >= NTDDI_WINXP)
NTKERNELAPI
NTSTATUS
IoWMIQuerySingleInstance(
    __in PVOID DataBlockObject,
    __in PUNICODE_STRING InstanceName,
    __inout ULONG *InOutBufferSize,
    __out_bcount_opt(*InOutBufferSize) /* non paged */ PVOID OutBuffer
    );
#endif

#if (NTDDI_VERSION >= NTDDI_WIN2K)
NTKERNELAPI
NTSTATUS
IoWMIQuerySingleInstanceMultiple(
    __in_ecount(ObjectCount) PVOID *DataBlockObjectList,
    __in_ecount(ObjectCount) PUNICODE_STRING InstanceNames,
    __in ULONG ObjectCount,
    __inout ULONG *InOutBufferSize,
    __out_bcount_opt(*InOutBufferSize) /* non paged */ PVOID OutBuffer
    );
#endif

#if (NTDDI_VERSION >= NTDDI_WINXP)
NTKERNELAPI
NTSTATUS
IoWMISetSingleInstance(
    __in PVOID DataBlockObject,
    __in PUNICODE_STRING InstanceName,
    __in ULONG Version,
    __in ULONG ValueBufferSize,
    __in_bcount(ValueBufferSize) PVOID ValueBuffer
    );
#endif

#if (NTDDI_VERSION >= NTDDI_WINXP)
NTKERNELAPI
NTSTATUS
IoWMISetSingleItem(
    __in PVOID DataBlockObject,
    __in PUNICODE_STRING InstanceName,
    __in ULONG DataItemId,
    __in ULONG Version,
    __in ULONG ValueBufferSize,
    __in_bcount(ValueBufferSize) PVOID ValueBuffer
    );
#endif

#if (NTDDI_VERSION >= NTDDI_WINXP)
NTKERNELAPI
NTSTATUS
IoWMIExecuteMethod(
    __in PVOID DataBlockObject,
    __in PUNICODE_STRING InstanceName,
    __in ULONG MethodId,
    __in ULONG InBufferSize,
    __inout PULONG OutBufferSize,
    __inout_bcount_part_opt(*OutBufferSize, InBufferSize) PUCHAR InOutBuffer
    );
#endif

typedef VOID (*WMI_NOTIFICATION_CALLBACK)(
    PVOID Wnode,
    PVOID Context
    );

#if (NTDDI_VERSION >= NTDDI_WINXP)
NTKERNELAPI
NTSTATUS
IoWMISetNotificationCallback(
    __inout PVOID Object,
    __in WMI_NOTIFICATION_CALLBACK Callback,
    __in_opt PVOID Context
    );
#endif

#if (NTDDI_VERSION >= NTDDI_WINXP)
NTKERNELAPI
NTSTATUS
IoWMIHandleToInstanceName(
    __in PVOID DataBlockObject,
    __in HANDLE FileHandle,
    __out PUNICODE_STRING InstanceName
    );
#endif

#if (NTDDI_VERSION >= NTDDI_WINXP)
NTKERNELAPI
NTSTATUS
IoWMIDeviceObjectToInstanceName(
    __in PVOID DataBlockObject,
    __in PDEVICE_OBJECT DeviceObject,
    __out PUNICODE_STRING InstanceName
    );
#endif


#if defined(_WIN64)

NTKERNELAPI
BOOLEAN
IoIs32bitProcess(
    __in PIRP Irp
    );

#endif


#if (NTDDI_VERSION >= NTDDI_WINXP)
NTKERNELAPI
VOID
IoFreeErrorLogEntry(
    __in PVOID ElEntry
    );
#endif

// Cancel SAFE API set start
//
// The following APIs are to help ease the pain of writing queue packages that
// handle the cancellation race well. The idea of this set of APIs is to not
// force a single queue data structure but allow the cancel logic to be hidden
// from the drivers. A driver implements a queue and as part of its header
// includes the IO_CSQ structure. In its initialization routine it calls
// IoInitializeCsq. Then in the dispatch routine when the driver wants to
// insert an IRP into the queue it calls IoCsqInsertIrp. When the driver wants
// to remove something from the queue it calls IoCsqRemoveIrp. Note that Insert
// can fail if the IRP was cancelled in the meantime. Remove can also fail if
// the IRP was already cancelled.
//
// There are typically two modes where drivers queue IRPs. These two modes are
// covered by the cancel safe queue API set.
//
// Mode 1:
// One is where the driver queues the IRP and at some later
// point in time dequeues an IRP and issues the IO request.
// For this mode the driver should use IoCsqInsertIrp and IoCsqRemoveNextIrp.
// The driver in this case is expected to pass NULL to the irp context
// parameter in IoInsertIrp.
//
// Mode 2:
// In this the driver queues theIRP, issues the IO request (like issuing a DMA
// request or writing to a register) and when the IO request completes (either
// using a DPC or timer) the driver dequeues the IRP and completes it. For this
// mode the driver should use IoCsqInsertIrp and IoCsqRemoveIrp. In this case
// the driver should allocate an IRP context and pass it in to IoCsqInsertIrp.
// The cancel API code creates an association between the IRP and the context
// and thus ensures that when the time comes to remove the IRP it can ascertain
// correctly.
//
// Note that the cancel API set assumes that the field DriverContext[3] is
// always available for use and that the driver does not use it.
//


//
// Bookkeeping structure. This should be opaque to drivers.
// Drivers typically include this as part of their queue headers.
// Given a CSQ pointer the driver should be able to get its
// queue header using CONTAINING_RECORD macro
//

typedef struct _IO_CSQ IO_CSQ, *PIO_CSQ;

#define IO_TYPE_CSQ_IRP_CONTEXT 1
#define IO_TYPE_CSQ             2
#define IO_TYPE_CSQ_EX          3

//
// IRP context structure. This structure is necessary if the driver is using
// the second mode.
//


typedef struct _IO_CSQ_IRP_CONTEXT {
    ULONG   Type;
    PIRP    Irp;
    PIO_CSQ Csq;
} IO_CSQ_IRP_CONTEXT, *PIO_CSQ_IRP_CONTEXT;

//
// Routines that insert/remove IRP
//

typedef VOID
(*PIO_CSQ_INSERT_IRP)(
    IN struct _IO_CSQ    *Csq,
    IN PIRP              Irp
    );

typedef NTSTATUS
(*PIO_CSQ_INSERT_IRP_EX)(
    IN struct _IO_CSQ    *Csq,
    IN PIRP              Irp,
    IN OUT PVOID         InsertContext
    );

typedef VOID
(*PIO_CSQ_REMOVE_IRP)(
    IN  PIO_CSQ Csq,
    IN  PIRP    Irp
    );

//
// Retrieves next entry after Irp from the queue.
// Returns NULL if there are no entries in the queue.
// If Irp is NUL, returns the entry in the head of the queue.
// This routine does not remove the IRP from the queue.
//


typedef PIRP
(*PIO_CSQ_PEEK_NEXT_IRP)(
    IN  PIO_CSQ Csq,
    IN  PIRP    Irp,
    IN  PVOID   PeekContext
    );

//
// Lock routine that protects the cancel safe queue.
//

typedef VOID
(*PIO_CSQ_ACQUIRE_LOCK)(
     IN  PIO_CSQ Csq,
     OUT PKIRQL  Irql
     );

typedef VOID
(*PIO_CSQ_RELEASE_LOCK)(
     IN PIO_CSQ Csq,
     IN KIRQL   Irql
     );


//
// Completes the IRP with STATUS_CANCELLED. IRP is guaranteed to be valid
// In most cases this routine just calls IoCompleteRequest(Irp, STATUS_CANCELLED);
//

typedef VOID
(*PIO_CSQ_COMPLETE_CANCELED_IRP)(
    IN  PIO_CSQ    Csq,
    IN  PIRP       Irp
    );

//
// Bookkeeping structure. This should be opaque to drivers.
// Drivers typically include this as part of their queue headers.
// Given a CSQ pointer the driver should be able to get its
// queue header using CONTAINING_RECORD macro
//

typedef struct _IO_CSQ {
    ULONG                            Type;
    PIO_CSQ_INSERT_IRP               CsqInsertIrp;
    PIO_CSQ_REMOVE_IRP               CsqRemoveIrp;
    PIO_CSQ_PEEK_NEXT_IRP            CsqPeekNextIrp;
    PIO_CSQ_ACQUIRE_LOCK             CsqAcquireLock;
    PIO_CSQ_RELEASE_LOCK             CsqReleaseLock;
    PIO_CSQ_COMPLETE_CANCELED_IRP    CsqCompleteCanceledIrp;
    PVOID                            ReservePointer;    // Future expansion
} IO_CSQ, *PIO_CSQ;

//
// Initializes the cancel queue structure.
//

#if (NTDDI_VERSION >= NTDDI_WINXP)
NTKERNELAPI
NTSTATUS
IoCsqInitialize(
    __in PIO_CSQ                        Csq,
    __in PIO_CSQ_INSERT_IRP             CsqInsertIrp,
    __in PIO_CSQ_REMOVE_IRP             CsqRemoveIrp,
    __in PIO_CSQ_PEEK_NEXT_IRP          CsqPeekNextIrp,
    __in PIO_CSQ_ACQUIRE_LOCK           CsqAcquireLock,
    __in PIO_CSQ_RELEASE_LOCK           CsqReleaseLock,
    __in PIO_CSQ_COMPLETE_CANCELED_IRP  CsqCompleteCanceledIrp
    );
#endif

#if (NTDDI_VERSION >= NTDDI_WS03)
NTKERNELAPI
NTSTATUS
IoCsqInitializeEx(
    __in PIO_CSQ                        Csq,
    __in PIO_CSQ_INSERT_IRP_EX          CsqInsertIrp,
    __in PIO_CSQ_REMOVE_IRP             CsqRemoveIrp,
    __in PIO_CSQ_PEEK_NEXT_IRP          CsqPeekNextIrp,
    __in PIO_CSQ_ACQUIRE_LOCK           CsqAcquireLock,
    __in PIO_CSQ_RELEASE_LOCK           CsqReleaseLock,
    __in PIO_CSQ_COMPLETE_CANCELED_IRP  CsqCompleteCanceledIrp
    );
#endif

//
// The caller calls this routine to insert the IRP and return STATUS_PENDING.
//

#if (NTDDI_VERSION >= NTDDI_WINXP)
NTKERNELAPI
VOID
IoCsqInsertIrp(
    __in PIO_CSQ                 Csq,
    __in PIRP                    Irp,
    __in_opt PIO_CSQ_IRP_CONTEXT Context
    );
#endif

#if (NTDDI_VERSION >= NTDDI_WS03)
NTKERNELAPI
NTSTATUS
IoCsqInsertIrpEx(
    __in PIO_CSQ                 Csq,
    __in PIRP                    Irp,
    __in_opt PIO_CSQ_IRP_CONTEXT Context,
    __in_opt PVOID               InsertContext
    );
#endif

//
// Returns an IRP if one can be found. NULL otherwise.
//

#if (NTDDI_VERSION >= NTDDI_WINXP)
NTKERNELAPI
PIRP
IoCsqRemoveNextIrp(
    __in     PIO_CSQ Csq,
    __in_opt PVOID   PeekContext
    );
#endif

//
// This routine is called from timeout or DPCs.
// The context is presumably part of the DPC or timer context.
// If succesfull returns the IRP associated with context.
//

#if (NTDDI_VERSION >= NTDDI_WINXP)
NTKERNELAPI
PIRP
IoCsqRemoveIrp(
    __in PIO_CSQ             Csq,
    __in PIO_CSQ_IRP_CONTEXT Context
    );
#endif

// Cancel SAFE API set end


#if (NTDDI_VERSION >= NTDDI_WINXPSP1)
NTKERNELAPI
NTSTATUS
IoValidateDeviceIoControlAccess(
    __in PIRP   Irp,
    __in ULONG  RequiredAccess
    );
#endif


#if (NTDDI_VERSION >= NTDDI_VISTA)
IO_PRIORITY_HINT
IoGetIoPriorityHint(
    __in PIRP Irp
    );
#endif

#if (NTDDI_VERSION >= NTDDI_VISTA)
NTSTATUS
IoSetIoPriorityHint(
    __in PIRP               Irp,
    __in IO_PRIORITY_HINT   PriorityHint
    );
#endif

#if (NTDDI_VERSION >= NTDDI_VISTA)
NTSTATUS
IoAllocateSfioStreamIdentifier(
    __in  PFILE_OBJECT  FileObject,
    __in  ULONG         Length,
    __in  PVOID         Signature,
    __out PVOID         *StreamIdentifier
    );
#endif

#if (NTDDI_VERSION >= NTDDI_VISTA)
PVOID
IoGetSfioStreamIdentifier(
    __in PFILE_OBJECT   FileObject,
    __in PVOID          Signature
    );
#endif

#if (NTDDI_VERSION >= NTDDI_VISTA)
NTSTATUS
IoFreeSfioStreamIdentifier(
    __in PFILE_OBJECT   FileObject,
    __in PVOID          Signature
    );
#endif

typedef enum _IO_ACCESS_TYPE {

    //
    // Indicates that the Io will
    // be comprised solely of reads
    //
    ReadAccess,

    //
    // Indicates that the Io will
    // be comprised solely of writes
    //
    WriteAccess,

    //
    // Indicates that the Io will be
    // comprised of reads and writes
    //
    ModifyAccess

} IO_ACCESS_TYPE;

typedef enum _IO_ACCESS_MODE {

    //
    // Indicates that the Io will be
    // sent down in a sequential order
    //
    SequentialAccess,

    //
    // Indicates that the Io might
    // not be in a predictable order
    //
    RandomAccess

} IO_ACCESS_MODE;



#ifdef RUN_WPP

#include <evntrace.h>
#include <stdarg.h>

#endif // #ifdef RUN_WPP


//
// Trace Provider APIs
//

#ifdef RUN_WPP

#if (NTDDI_VERSION >= NTDDI_WINXP)
NTKERNELAPI
NTSTATUS
WmiTraceMessage(
    IN TRACEHANDLE  LoggerHandle,
    IN ULONG        MessageFlags,
    IN LPGUID       MessageGuid,
    IN USHORT       MessageNumber,
    IN ...
    );
#endif

#if (NTDDI_VERSION >= NTDDI_WINXP)
NTKERNELAPI
NTSTATUS
WmiTraceMessageVa(
    IN TRACEHANDLE  LoggerHandle,
    IN ULONG        MessageFlags,
    __in IN LPGUID       MessageGuid,
    IN USHORT       MessageNumber,
    __in va_list      MessageArgList
    );
#endif

#endif // #ifdef RUN_WPP

#ifndef TRACE_INFORMATION_CLASS_DEFINE

typedef struct _ETW_TRACE_SESSION_SETTINGS {
    ULONG Version;
    ULONG BufferSize;
    ULONG MinimumBuffers;
    ULONG MaximumBuffers;
    ULONG LoggerMode;
    ULONG FlushTimer;
    ULONG FlushThreshold;
    ULONG ClockType;
} ETW_TRACE_SESSION_SETTINGS, *PETW_TRACE_SESSION_SETTINGS;

typedef enum _TRACE_INFORMATION_CLASS {
    TraceIdClass,
    TraceHandleClass,
    TraceEnableFlagsClass,
    TraceEnableLevelClass,
    GlobalLoggerHandleClass,
    EventLoggerHandleClass,
    AllLoggerHandlesClass,
    TraceHandleByNameClass,
    LoggerEventsLostClass,
    TraceSessionSettingsClass,
    MaxTraceInformationClass
} TRACE_INFORMATION_CLASS;

#if (NTDDI_VERSION >= NTDDI_WINXP)
NTKERNELAPI
NTSTATUS
WmiQueryTraceInformation(
    __in TRACE_INFORMATION_CLASS TraceInformationClass,
    __out_bcount(TraceInformationLength) PVOID TraceInformation,
    __in ULONG TraceInformationLength,
    __out_opt PULONG RequiredLength,
    __in_opt PVOID Buffer
    );
#endif 

#define TRACE_INFORMATION_CLASS_DEFINE
#endif // TRACE_INFOPRMATION_CLASS_DEFINE




#ifndef _ETW_KM_
#define _ETW_KM_
#endif

#include <evntprov.h>


//
// Optional callback function that users provide
//
typedef
VOID
(NTAPI *PETWENABLECALLBACK) (
    __in LPCGUID                      SourceId,
    __in ULONG                        IsEnabled,
    __in UCHAR                        Level,
    __in ULONGLONG                    MatchAnyKeyword,
    __in ULONGLONG                    MatchAllKeyword,
    __in_opt PEVENT_FILTER_DESCRIPTOR FilterData,
    __in_opt PVOID                    CallbackContext
    );



//
// Kernel Mode Registration APIs
//

#if (NTDDI_VERSION >= NTDDI_VISTA)
NTSTATUS
NTKERNELAPI
EtwRegister(
    __in  LPCGUID                   ProviderId,
    __in_opt PETWENABLECALLBACK     EnableCallback,
    __in_opt PVOID                  CallbackContext,
    __out PREGHANDLE                RegHandle
    );
#endif

#if (NTDDI_VERSION >= NTDDI_VISTA)
NTSTATUS
NTKERNELAPI
EtwUnregister(
    __in REGHANDLE                  RegHandle
    );
#endif

//
// Kernel Mode Control (Is Enabled) APIs
//

#if (NTDDI_VERSION >= NTDDI_VISTA)
BOOLEAN
NTKERNELAPI
EtwEventEnabled(
    __in REGHANDLE RegHandle,
    __in PCEVENT_DESCRIPTOR EventDescriptor
    );
#endif

#if (NTDDI_VERSION >= NTDDI_VISTA)
BOOLEAN
NTKERNELAPI
EtwProviderEnabled(
    __in REGHANDLE RegHandle,
    __in UCHAR Level,
    __in ULONGLONG Keyword
    );
#endif

#if (NTDDI_VERSION >= NTDDI_VISTA)
NTSTATUS 
NTKERNELAPI
EtwActivityIdControl(
    __in ULONG ControlCode,
    __inout_bcount(sizeof(GUID))LPGUID ActivityId
    );
#endif

//
// Kernel Mode Writing (Publishing/Logging) APIs
//

#if (NTDDI_VERSION >= NTDDI_VISTA)
NTSTATUS
NTKERNELAPI
EtwWrite(
    __in REGHANDLE RegHandle,
    __in PCEVENT_DESCRIPTOR EventDescriptor,
    __in_opt LPCGUID ActivityId,
    __in ULONG UserDataCount,
    __in_ecount_opt(UserDataCount) PEVENT_DATA_DESCRIPTOR  UserData
    );
#endif

#if (NTDDI_VERSION >= NTDDI_VISTA)
NTSTATUS
NTKERNELAPI
EtwWriteTransfer(
    __in REGHANDLE RegHandle,
    __in PCEVENT_DESCRIPTOR EventDescriptor,
    __in_opt LPCGUID ActivityId,
    __in LPCGUID RelatedActivityId,
    __in ULONG UserDataCount,
    __in_ecount_opt(UserDataCount) PEVENT_DATA_DESCRIPTOR UserData
    );
#endif

#if (NTDDI_VERSION >= NTDDI_VISTA)
NTSTATUS
NTKERNELAPI
EtwWriteString(
    __in REGHANDLE RegHandle,
    __in UCHAR Level,
    __in ULONGLONG Keyword,
    __in_opt LPCGUID ActivityId,
    __in PCWSTR String
    );
#endif


//
// Define PnP Device Property for IoGetDeviceProperty
//

typedef enum {
    DevicePropertyDeviceDescription,
    DevicePropertyHardwareID,
    DevicePropertyCompatibleIDs,
    DevicePropertyBootConfiguration,
    DevicePropertyBootConfigurationTranslated,
    DevicePropertyClassName,
    DevicePropertyClassGuid,
    DevicePropertyDriverKeyName,
    DevicePropertyManufacturer,
    DevicePropertyFriendlyName,
    DevicePropertyLocationInformation,
    DevicePropertyPhysicalDeviceObjectName,
    DevicePropertyBusTypeGuid,
    DevicePropertyLegacyBusType,
    DevicePropertyBusNumber,
    DevicePropertyEnumeratorName,
    DevicePropertyAddress,
    DevicePropertyUINumber,
    DevicePropertyInstallState,
    DevicePropertyRemovalPolicy,
    DevicePropertyResourceRequirements,
    DevicePropertyAllocatedResources
} DEVICE_REGISTRY_PROPERTY;

typedef BOOLEAN (*PTRANSLATE_BUS_ADDRESS)(
    __inout_opt PVOID Context,
    __in PHYSICAL_ADDRESS BusAddress,
    __in ULONG Length,
    __out PULONG AddressSpace,
    __out PPHYSICAL_ADDRESS TranslatedAddress
    );

typedef struct _DMA_ADAPTER *(*PGET_DMA_ADAPTER)(
    __inout_opt PVOID Context,
    __in struct _DEVICE_DESCRIPTION *DeviceDescriptor,
    __out PULONG NumberOfMapRegisters
    );

typedef ULONG (*PGET_SET_DEVICE_DATA)(
    __inout_opt PVOID Context,
    __in ULONG DataType,
    __inout_bcount(Length) PVOID Buffer,
    __in ULONG Offset,
    __in ULONG Length
    );

typedef enum _DEVICE_INSTALL_STATE {
    InstallStateInstalled,
    InstallStateNeedsReinstall,
    InstallStateFailedInstall,
    InstallStateFinishInstall
} DEVICE_INSTALL_STATE, *PDEVICE_INSTALL_STATE;

//
// Define structure returned in response to IRP_MN_QUERY_BUS_INFORMATION by a
// PDO indicating the type of bus the device exists on.
//

typedef struct _PNP_BUS_INFORMATION {
    GUID BusTypeGuid;
    INTERFACE_TYPE LegacyBusType;
    ULONG BusNumber;
} PNP_BUS_INFORMATION, *PPNP_BUS_INFORMATION;

//
// Define structure returned in response to IRP_MN_QUERY_LEGACY_BUS_INFORMATION
// by an FDO indicating the type of bus it is.  This is normally the same bus
// type as the device's children (i.e., as retrieved from the child PDO's via
// IRP_MN_QUERY_BUS_INFORMATION) except for cases like CardBus, which can
// support both 16-bit (PCMCIABus) and 32-bit (PCIBus) cards.
//

typedef struct _LEGACY_BUS_INFORMATION {
    GUID BusTypeGuid;
    INTERFACE_TYPE LegacyBusType;
    ULONG BusNumber;
} LEGACY_BUS_INFORMATION, *PLEGACY_BUS_INFORMATION;

//
// Defines for IoGetDeviceProperty(DevicePropertyRemovalPolicy).
//
typedef enum _DEVICE_REMOVAL_POLICY {

    RemovalPolicyExpectNoRemoval = 1,
    RemovalPolicyExpectOrderlyRemoval = 2,
    RemovalPolicyExpectSurpriseRemoval = 3

} DEVICE_REMOVAL_POLICY, *PDEVICE_REMOVAL_POLICY;



typedef struct _BUS_INTERFACE_STANDARD {
    //
    // generic interface header
    //
    USHORT Size;
    USHORT Version;
    PVOID Context;
    PINTERFACE_REFERENCE InterfaceReference;
    PINTERFACE_DEREFERENCE InterfaceDereference;
    //
    // standard bus interfaces
    //
    PTRANSLATE_BUS_ADDRESS TranslateBusAddress;
    PGET_DMA_ADAPTER GetDmaAdapter;
    PGET_SET_DEVICE_DATA SetBusData;
    PGET_SET_DEVICE_DATA GetBusData;

} BUS_INTERFACE_STANDARD, *PBUS_INTERFACE_STANDARD;

typedef
VOID
(*PREENUMERATE_SELF)(
    IN PVOID Context
    );

typedef struct _REENUMERATE_SELF_INTERFACE_STANDARD {
    //
    // generic interface header
    //
    USHORT Size;
    USHORT Version;
    PVOID Context;
    PINTERFACE_REFERENCE InterfaceReference;
    PINTERFACE_DEREFERENCE InterfaceDereference;
    //
    // Self-reenumeration interface
    //
    PREENUMERATE_SELF SurpriseRemoveAndReenumerateSelf;
} REENUMERATE_SELF_INTERFACE_STANDARD, *PREENUMERATE_SELF_INTERFACE_STANDARD;


//
// The following definitions are used in ACPI QueryInterface
//
typedef BOOLEAN (* PGPE_SERVICE_ROUTINE) (
                            PVOID,
                            PVOID);

typedef NTSTATUS (* PGPE_CONNECT_VECTOR) (
                            PDEVICE_OBJECT,
                            ULONG,
                            KINTERRUPT_MODE,
                            BOOLEAN,
                            PGPE_SERVICE_ROUTINE,
                            PVOID,
                            PVOID);

typedef NTSTATUS (* PGPE_DISCONNECT_VECTOR) (
                            PVOID);

typedef NTSTATUS (* PGPE_ENABLE_EVENT) (
                            PDEVICE_OBJECT,
                            PVOID);

typedef NTSTATUS (* PGPE_DISABLE_EVENT) (
                            PDEVICE_OBJECT,
                            PVOID);

typedef NTSTATUS (* PGPE_CLEAR_STATUS) (
                            PDEVICE_OBJECT,
                            PVOID);

typedef VOID (* PDEVICE_NOTIFY_CALLBACK) (
                            PVOID,
                            ULONG);

typedef NTSTATUS (* PREGISTER_FOR_DEVICE_NOTIFICATIONS) (
                            PDEVICE_OBJECT,
                            PDEVICE_NOTIFY_CALLBACK,
                            PVOID);

typedef void (* PUNREGISTER_FOR_DEVICE_NOTIFICATIONS) (
                            PDEVICE_OBJECT,
                            PDEVICE_NOTIFY_CALLBACK);

typedef struct _ACPI_INTERFACE_STANDARD {
    //
    // Generic interface header
    //
    USHORT                  Size;
    USHORT                  Version;
    PVOID                   Context;
    PINTERFACE_REFERENCE    InterfaceReference;
    PINTERFACE_DEREFERENCE  InterfaceDereference;
    //
    // ACPI interfaces
    //
    PGPE_CONNECT_VECTOR                     GpeConnectVector;
    PGPE_DISCONNECT_VECTOR                  GpeDisconnectVector;
    PGPE_ENABLE_EVENT                       GpeEnableEvent;
    PGPE_DISABLE_EVENT                      GpeDisableEvent;
    PGPE_CLEAR_STATUS                       GpeClearStatus;
    PREGISTER_FOR_DEVICE_NOTIFICATIONS      RegisterForDeviceNotifications;
    PUNREGISTER_FOR_DEVICE_NOTIFICATIONS    UnregisterForDeviceNotifications;

} ACPI_INTERFACE_STANDARD, *PACPI_INTERFACE_STANDARD;

//
// The following definitions are used in GUID_ACPI_INTERFACE_STANDARD2,
// The first version (above) passes in DEVICE_OBJECs, where this one
// is based on Contexts.
//

typedef
BOOLEAN
(*PGPE_SERVICE_ROUTINE2) (
    PVOID   ObjectContext,
    PVOID   ServiceContext
    );

typedef
NTSTATUS
(*PGPE_CONNECT_VECTOR2) (
    PVOID           Context,
    ULONG           GpeNumber,
    KINTERRUPT_MODE Mode,
    BOOLEAN         Shareable,
    PGPE_SERVICE_ROUTINE    ServiceRoutine,
    PVOID           ServiceContext,
    PVOID           *ObjectContext
    );

typedef
NTSTATUS
(*PGPE_DISCONNECT_VECTOR2) (
    PVOID   Context,
    PVOID   ObjectContext
    );

typedef
NTSTATUS
(*PGPE_ENABLE_EVENT2) (
    PVOID   Context,
    PVOID   ObjectContext
    );

typedef
NTSTATUS
(*PGPE_DISABLE_EVENT2) (
    PVOID   Context,
    PVOID   ObjectContext
    );

typedef
NTSTATUS
(*PGPE_CLEAR_STATUS2) (
    PVOID   Context,
    PVOID   ObjectContext
    );

typedef
VOID
(*PDEVICE_NOTIFY_CALLBACK2) (
    PVOID   NotificationContext,
    ULONG   NotifyCode
    );

typedef
NTSTATUS
(*PREGISTER_FOR_DEVICE_NOTIFICATIONS2) (
    PVOID   Context,
    PDEVICE_NOTIFY_CALLBACK2    NotificationHandler,
    PVOID   NotificationContext
    );

typedef
VOID
(*PUNREGISTER_FOR_DEVICE_NOTIFICATIONS2) (
    PVOID   Context
    );

typedef struct {
    //
    // Generic interface header
    //
    USHORT                  Size;
    USHORT                  Version;
    PVOID                   Context;
    PINTERFACE_REFERENCE    InterfaceReference;
    PINTERFACE_DEREFERENCE  InterfaceDereference;
    //
    // ACPI interfaces
    //
    PGPE_CONNECT_VECTOR2                    GpeConnectVector;
    PGPE_DISCONNECT_VECTOR2                 GpeDisconnectVector;
    PGPE_ENABLE_EVENT2                      GpeEnableEvent;
    PGPE_DISABLE_EVENT2                     GpeDisableEvent;
    PGPE_CLEAR_STATUS2                      GpeClearStatus;
    PREGISTER_FOR_DEVICE_NOTIFICATIONS2     RegisterForDeviceNotifications;
    PUNREGISTER_FOR_DEVICE_NOTIFICATIONS2   UnregisterForDeviceNotifications;

} ACPI_INTERFACE_STANDARD2, *PACPI_INTERFACE_STANDARD2;


#if (NTDDI_VERSION >= NTDDI_WIN2K)
NTKERNELAPI
VOID
IoInvalidateDeviceRelations(
    __in PDEVICE_OBJECT DeviceObject,
    __in DEVICE_RELATION_TYPE Type
    );
#endif

#if (NTDDI_VERSION >= NTDDI_WIN2K)
NTKERNELAPI
VOID
IoRequestDeviceEject(
    __in PDEVICE_OBJECT PhysicalDeviceObject
    );
#endif

typedef VOID (*PIO_DEVICE_EJECT_CALLBACK)(
    __in NTSTATUS Status,
    __inout_opt PVOID Context
    );

#if (NTDDI_VERSION >= NTDDI_VISTA)
NTKERNELAPI
NTSTATUS
IoRequestDeviceEjectEx(
    __in PDEVICE_OBJECT PhysicalDeviceObject,
    __in_opt PIO_DEVICE_EJECT_CALLBACK Callback,
    __in_opt PVOID Context,
    __in_opt PDRIVER_OBJECT DriverObject
    );
#endif

#if (NTDDI_VERSION >= NTDDI_WIN2K)
NTKERNELAPI
NTSTATUS
IoGetDeviceProperty(
    __in PDEVICE_OBJECT DeviceObject,
    __in DEVICE_REGISTRY_PROPERTY DeviceProperty,
    __in ULONG BufferLength,
    __out_bcount_opt(BufferLength) PVOID PropertyBuffer,
    __out PULONG ResultLength
    );
#endif

//
// The following definitions are used in IoOpenDeviceRegistryKey
//

#define PLUGPLAY_REGKEY_DEVICE  1
#define PLUGPLAY_REGKEY_DRIVER  2
#define PLUGPLAY_REGKEY_CURRENT_HWPROFILE 4

#if (NTDDI_VERSION >= NTDDI_WIN2K)
NTKERNELAPI
NTSTATUS
IoOpenDeviceRegistryKey(
    __in PDEVICE_OBJECT DeviceObject,
    __in ULONG DevInstKeyType,
    __in ACCESS_MASK DesiredAccess,
    __out PHANDLE DevInstRegKey
    );
#endif

#if (NTDDI_VERSION >= NTDDI_WIN2K)
NTKERNELAPI
NTSTATUS
NTAPI
IoRegisterDeviceInterface(
    __in PDEVICE_OBJECT PhysicalDeviceObject,
    __in CONST GUID *InterfaceClassGuid,
    __in_opt PUNICODE_STRING ReferenceString,
    __out PUNICODE_STRING SymbolicLinkName
    );
#endif

#if (NTDDI_VERSION >= NTDDI_WIN2K)
NTKERNELAPI
NTSTATUS
IoOpenDeviceInterfaceRegistryKey(
    __in PUNICODE_STRING SymbolicLinkName,
    __in ACCESS_MASK DesiredAccess,
    __out PHANDLE DeviceInterfaceKey
    );
#endif

#if (NTDDI_VERSION >= NTDDI_WIN2K)
NTKERNELAPI
NTSTATUS
IoSetDeviceInterfaceState(
    __in PUNICODE_STRING SymbolicLinkName,
    __in BOOLEAN Enable
    );
#endif

#if (NTDDI_VERSION >= NTDDI_WIN2K)
NTKERNELAPI
NTSTATUS
NTAPI
IoGetDeviceInterfaces(
    __in CONST GUID *InterfaceClassGuid,
    __in_opt PDEVICE_OBJECT PhysicalDeviceObject,
    __in ULONG Flags,
    __deref_out PWSTR *SymbolicLinkList
    );
#endif

#define DEVICE_INTERFACE_INCLUDE_NONACTIVE   0x00000001

#if (NTDDI_VERSION >= NTDDI_WIN2K)
NTKERNELAPI
NTSTATUS
NTAPI
IoGetDeviceInterfaceAlias(
    __in PUNICODE_STRING SymbolicLinkName,
    __in CONST GUID *AliasInterfaceClassGuid,
    __out PUNICODE_STRING AliasSymbolicLinkName
    );
#endif

//
// Define PnP notification event categories
//

typedef enum _IO_NOTIFICATION_EVENT_CATEGORY {
    EventCategoryReserved,
    EventCategoryHardwareProfileChange,
    EventCategoryDeviceInterfaceChange,
    EventCategoryTargetDeviceChange
} IO_NOTIFICATION_EVENT_CATEGORY;

//
// Define flags that modify the behavior of IoRegisterPlugPlayNotification
// for the various event categories...
//

#define PNPNOTIFY_DEVICE_INTERFACE_INCLUDE_EXISTING_INTERFACES    0x00000001

typedef
NTSTATUS
(*PDRIVER_NOTIFICATION_CALLBACK_ROUTINE) (
    __in PVOID NotificationStructure,
    __inout_opt PVOID Context
);


#if (NTDDI_VERSION >= NTDDI_WIN2K)
NTKERNELAPI
NTSTATUS
IoRegisterPlugPlayNotification(
    __in IO_NOTIFICATION_EVENT_CATEGORY EventCategory,
    __in ULONG EventCategoryFlags,
    __in_opt PVOID EventCategoryData,
    __in PDRIVER_OBJECT DriverObject,
    __in PDRIVER_NOTIFICATION_CALLBACK_ROUTINE CallbackRoutine,
    __inout_opt PVOID Context,
    __deref_out PVOID *NotificationEntry
    );
#endif

#if (NTDDI_VERSION >= NTDDI_WIN2K)
NTKERNELAPI
NTSTATUS
IoUnregisterPlugPlayNotification(
    __in PVOID NotificationEntry
    );
#endif

#if (NTDDI_VERSION >= NTDDI_WIN2K)
NTKERNELAPI
NTSTATUS
IoReportTargetDeviceChange(
    __in PDEVICE_OBJECT PhysicalDeviceObject,
    __in PVOID NotificationStructure  // always begins with a PLUGPLAY_NOTIFICATION_HEADER
    );
#endif

typedef
VOID
(*PDEVICE_CHANGE_COMPLETE_CALLBACK)(
    __inout_opt PVOID Context
    );

#if (NTDDI_VERSION >= NTDDI_WIN2K)
NTKERNELAPI
VOID
IoInvalidateDeviceState(
    __in PDEVICE_OBJECT PhysicalDeviceObject
    );
#endif

#define IoAdjustPagingPathCount(_count_,_paging_) {     \
    if (_paging_) {                                     \
        InterlockedIncrement(_count_);                  \
    } else {                                            \
        InterlockedDecrement(_count_);                  \
    }                                                   \
}

#if (NTDDI_VERSION >= NTDDI_WIN2K)
NTKERNELAPI
NTSTATUS
IoReportTargetDeviceChangeAsynchronous(
    __in PDEVICE_OBJECT PhysicalDeviceObject,
    __in PVOID NotificationStructure,  // always begins with a PLUGPLAY_NOTIFICATION_HEADER
    __in_opt PDEVICE_CHANGE_COMPLETE_CALLBACK Callback,
    __inout_opt PVOID Context
    );
#endif


//
// Header structure for all Plug&Play notification events...
//

typedef struct _PLUGPLAY_NOTIFICATION_HEADER {
    USHORT Version; // presently at version 1.
    USHORT Size;    // size (in bytes) of header + event-specific data.
    GUID Event;
    //
    // Event-specific stuff starts here.
    //
} PLUGPLAY_NOTIFICATION_HEADER, *PPLUGPLAY_NOTIFICATION_HEADER;

//
// Notification structure for all EventCategoryHardwareProfileChange events...
//

typedef struct _HWPROFILE_CHANGE_NOTIFICATION {
    USHORT Version;
    USHORT Size;
    GUID Event;
    //
    // (No event-specific data)
    //
} HWPROFILE_CHANGE_NOTIFICATION, *PHWPROFILE_CHANGE_NOTIFICATION;


//
// Notification structure for all EventCategoryDeviceInterfaceChange events...
//

typedef struct _DEVICE_INTERFACE_CHANGE_NOTIFICATION {
    USHORT Version;
    USHORT Size;
    GUID Event;
    //
    // Event-specific data
    //
    GUID InterfaceClassGuid;
    PUNICODE_STRING SymbolicLinkName;
} DEVICE_INTERFACE_CHANGE_NOTIFICATION, *PDEVICE_INTERFACE_CHANGE_NOTIFICATION;


//
// Notification structures for EventCategoryTargetDeviceChange...
//

//
// The following structure is used for TargetDeviceQueryRemove,
// TargetDeviceRemoveCancelled, and TargetDeviceRemoveComplete:
//
typedef struct _TARGET_DEVICE_REMOVAL_NOTIFICATION {
    USHORT Version;
    USHORT Size;
    GUID Event;
    //
    // Event-specific data
    //
    PFILE_OBJECT FileObject;
} TARGET_DEVICE_REMOVAL_NOTIFICATION, *PTARGET_DEVICE_REMOVAL_NOTIFICATION;

//
// The following structure header is used for all other (i.e., 3rd-party)
// target device change events.  The structure accommodates both a
// variable-length binary data buffer, and a variable-length unicode text
// buffer.  The header must indicate where the text buffer begins, so that
// the data can be delivered in the appropriate format (ANSI or Unicode)
// to user-mode recipients (i.e., that have registered for handle-based
// notification via RegisterDeviceNotification).
//

typedef struct _TARGET_DEVICE_CUSTOM_NOTIFICATION {
    USHORT Version;
    USHORT Size;
    GUID Event;
    //
    // Event-specific data
    //
    PFILE_OBJECT FileObject;    // This field must be set to NULL by callers of
                                // IoReportTargetDeviceChange.  Clients that
                                // have registered for target device change
                                // notification on the affected PDO will be
                                // called with this field set to the file object
                                // they specified during registration.
                                //
    LONG NameBufferOffset;      // offset (in bytes) from beginning of
                                // CustomDataBuffer where text begins (-1 if none)
                                //
    UCHAR CustomDataBuffer[1];  // variable-length buffer, containing (optionally)
                                // a binary data at the start of the buffer,
                                // followed by an optional unicode text buffer
                                // (word-aligned).
                                //
} TARGET_DEVICE_CUSTOM_NOTIFICATION, *PTARGET_DEVICE_CUSTOM_NOTIFICATION;

#if (NTDDI_VERSION >= NTDDI_VISTA)

//
// Custom device properties...
//

#include <devpropdef.h>

//
// Definitions of property flags.
//

#define PLUGPLAY_PROPERTY_PERSISTENT  0x00000001

#endif

#if (NTDDI_VERSION >= NTDDI_VISTA)
NTKERNELAPI
NTSTATUS
IoSetDevicePropertyData (
    __in PDEVICE_OBJECT     Pdo,
    __in CONST DEVPROPKEY   *PropertyKey,
    __in LCID               Lcid,
    __in ULONG              Flags,
    __in DEVPROPTYPE        Type,
    __in ULONG              Size,
    __in_opt PVOID          Data
    );
#endif

#if (NTDDI_VERSION >= NTDDI_VISTA)
NTKERNELAPI
NTSTATUS
IoGetDevicePropertyData (
    __in PDEVICE_OBJECT     Pdo,
    __in CONST DEVPROPKEY   *PropertyKey,
    __in LCID               Lcid,
    __reserved ULONG        Flags,
    __in ULONG              Size,
    __out PVOID             Data,
    __out PULONG            RequiredSize,
    __out PDEVPROPTYPE      Type
    );
#endif


#if (NTDDI_VERSION >= NTDDI_WS08)
NTKERNELAPI
NTSTATUS
NTAPI
IoReplacePartitionUnit (
    __in PDEVICE_OBJECT TargetPdo,
    __in PDEVICE_OBJECT SparePdo,
    __in ULONG Flags
    );
#endif


//
// Define replace driver entrypoint.
//

typedef struct _PNP_REPLACE_DRIVER_INTERFACE *PPNP_REPLACE_DRIVER_INTERFACE;

typedef
NTSTATUS
(*PREPLACE_DRIVER_INIT) (
    __inout PPNP_REPLACE_DRIVER_INTERFACE Interface,
    __in PVOID Unused
    );

//
// Define parameters to replace driver.
//

#define PNP_REPLACE_NO_MAP MAXLONGLONG

typedef
NTSTATUS
(*PREPLACE_MAP_MEMORY) (
    __in    PHYSICAL_ADDRESS    TargetPhysicalAddress,
    __in    PHYSICAL_ADDRESS    SparePhysicalAddress,
    __inout PLARGE_INTEGER      NumberOfBytes,
    __deref_out PVOID *TargetAddress,
    __deref_out PVOID *SpareAddress
    );

typedef struct _PNP_REPLACE_MEMORY_LIST {

    ULONG AllocatedCount;
    ULONG Count;
    ULONGLONG TotalLength;
    struct {
        PHYSICAL_ADDRESS Address;
        ULONGLONG Length;
    } Ranges[ANYSIZE_ARRAY];

} PNP_REPLACE_MEMORY_LIST, *PPNP_REPLACE_MEMORY_LIST;

typedef struct _PNP_REPLACE_PROCESSOR_LIST {

    KAFFINITY AffinityMask;
    ULONG AllocatedCount;
    ULONG Count;
    ULONG ApicIds[ANYSIZE_ARRAY];

} PNP_REPLACE_PROCESSOR_LIST, *PPNP_REPLACE_PROCESSOR_LIST;

#define PNP_REPLACE_PARAMETERS_VERSION 1

typedef struct _PNP_REPLACE_PARAMETERS {

    ULONG Size;
    ULONG Version;

    ULONG64 Target;
    ULONG64 Spare;
    PPNP_REPLACE_PROCESSOR_LIST TargetProcessors;
    PPNP_REPLACE_PROCESSOR_LIST SpareProcessors;
    PPNP_REPLACE_MEMORY_LIST TargetMemory;
    PPNP_REPLACE_MEMORY_LIST SpareMemory;

    PREPLACE_MAP_MEMORY MapMemory;

} PNP_REPLACE_PARAMETERS, *PPNP_REPLACE_PARAMETERS;

//
// Define replace driver interface.
//

typedef
VOID
(*PREPLACE_UNLOAD) (
    VOID
    );

typedef
NTSTATUS
(*PREPLACE_BEGIN) (
    __in PPNP_REPLACE_PARAMETERS Parameters,
    __deref_out PVOID *Context
);

typedef
NTSTATUS
(*PREPLACE_END) (
    __in PVOID Context
    );

typedef
NTSTATUS
(*PREPLACE_MIRROR_PHYSICAL_MEMORY) (
    __in PVOID Context,
    __in PHYSICAL_ADDRESS PhysicalAddress,
    __in LARGE_INTEGER ByteCount
    );

typedef
NTSTATUS
(*PREPLACE_SET_PROCESSOR_ID) (
    __in PVOID Context,
    __in ULONG ApicId,
    __in BOOLEAN Target
    );

typedef
NTSTATUS
(*PREPLACE_SWAP) (
    __in PVOID Context
    );

typedef
NTSTATUS
(*PREPLACE_INITIATE_HARDWARE_MIRROR) (
    __in PVOID Context
    );

typedef
NTSTATUS
(*PREPLACE_MIRROR_PLATFORM_MEMORY) (
    __in PVOID Context
    );

typedef
NTSTATUS
(*PREPLACE_GET_MEMORY_DESTINATION) (
    __in PVOID Context,
    __in PHYSICAL_ADDRESS SourceAddress,
    __out PPHYSICAL_ADDRESS DestinationAddress
    );

#define PNP_REPLACE_DRIVER_INTERFACE_VERSION 1
#define PNP_REPLACE_DRIVER_INTERFACE_MINIMUM_SIZE \
             FIELD_OFFSET(PNP_REPLACE_DRIVER_INTERFACE, InitiateHardwareMirror)

#define PNP_REPLACE_MEMORY_SUPPORTED            0x0001
#define PNP_REPLACE_PROCESSOR_SUPPORTED         0x0002
#define PNP_REPLACE_HARDWARE_MEMORY_MIRRORING   0x0004
#define PNP_REPLACE_HARDWARE_PAGE_COPY          0x0008

//
// Define interface structure.
//

typedef struct _PNP_REPLACE_DRIVER_INTERFACE {

    ULONG Size;
    ULONG Version;

    ULONG Flags;
    PREPLACE_UNLOAD Unload;
    PREPLACE_BEGIN BeginReplace;
    PREPLACE_END EndReplace;
    PREPLACE_MIRROR_PHYSICAL_MEMORY MirrorPhysicalMemory;
    PREPLACE_SET_PROCESSOR_ID SetProcessorId;
    PREPLACE_SWAP Swap;
    PREPLACE_INITIATE_HARDWARE_MIRROR InitiateHardwareMirror;
    PREPLACE_MIRROR_PLATFORM_MEMORY MirrorPlatformMemory;
    PREPLACE_GET_MEMORY_DESTINATION GetMemoryDestination;    

} PNP_REPLACE_DRIVER_INTERFACE, *PPNP_REPLACE_DRIVER_INTERFACE;

//
// Define the device description structure.
//

typedef struct _DEVICE_DESCRIPTION {
    ULONG Version;
    BOOLEAN Master;
    BOOLEAN ScatterGather;
    BOOLEAN DemandMode;
    BOOLEAN AutoInitialize;
    BOOLEAN Dma32BitAddresses;
    BOOLEAN IgnoreCount;
    BOOLEAN Reserved1;          // must be false
    BOOLEAN Dma64BitAddresses;
    ULONG BusNumber; // unused for WDM
    ULONG DmaChannel;
    INTERFACE_TYPE  InterfaceType;
    DMA_WIDTH DmaWidth;
    DMA_SPEED DmaSpeed;
    ULONG MaximumLength;
    ULONG DmaPort;
} DEVICE_DESCRIPTION, *PDEVICE_DESCRIPTION;

//
// Define the supported version numbers for the device description structure.
//

#define DEVICE_DESCRIPTION_VERSION  0
#define DEVICE_DESCRIPTION_VERSION1 1
#define DEVICE_DESCRIPTION_VERSION2 2

                                                

#if defined(_IA64_)
FORCEINLINE
VOID
KeFlushWriteBuffer (
    VOID
    )
{
    __mf ();
    return;
}

#else
NTHALAPI
VOID
KeFlushWriteBuffer (
    VOID
    );

#endif

//
// Performance counter function.
//

#if (NTDDI_VERSION >= NTDDI_WIN2K)
NTHALAPI
LARGE_INTEGER
KeQueryPerformanceCounter (
   __out_opt PLARGE_INTEGER PerformanceFrequency
   );
#endif


//
// Stall processor execution function.
//

#if (NTDDI_VERSION >= NTDDI_WIN2K)
NTHALAPI
VOID
KeStallExecutionProcessor (
    __in ULONG MicroSeconds
    );
#endif


typedef struct _SCATTER_GATHER_ELEMENT {
    PHYSICAL_ADDRESS Address;
    ULONG Length;
    ULONG_PTR Reserved;
} SCATTER_GATHER_ELEMENT, *PSCATTER_GATHER_ELEMENT;

#if defined(_MSC_EXTENSIONS)

#if _MSC_VER >= 1200
#pragma warning(push)
#endif
#pragma warning(disable:4200)
typedef struct _SCATTER_GATHER_LIST {
    ULONG NumberOfElements;
    ULONG_PTR Reserved;
    SCATTER_GATHER_ELEMENT Elements[];
} SCATTER_GATHER_LIST, *PSCATTER_GATHER_LIST;
#if _MSC_VER >= 1200
#pragma warning(pop)
#else
#pragma warning(default:4200)
#endif

#else

struct _SCATTER_GATHER_LIST;
typedef struct _SCATTER_GATHER_LIST SCATTER_GATHER_LIST, *PSCATTER_GATHER_LIST;

#endif



typedef struct _DMA_OPERATIONS *PDMA_OPERATIONS;

typedef struct _DMA_ADAPTER {
    USHORT Version;
    USHORT Size;
    PDMA_OPERATIONS DmaOperations;
    // Private Bus Device Driver data follows,
} DMA_ADAPTER, *PDMA_ADAPTER;



typedef VOID (*PPUT_DMA_ADAPTER)(
    PDMA_ADAPTER DmaAdapter
    );

typedef PVOID (*PALLOCATE_COMMON_BUFFER)(
    __in PDMA_ADAPTER DmaAdapter,
    __in ULONG Length,
    __out PPHYSICAL_ADDRESS LogicalAddress,
    __in BOOLEAN CacheEnabled
    );

typedef VOID (*PFREE_COMMON_BUFFER)(
    __in PDMA_ADAPTER DmaAdapter,
    __in ULONG Length,
    __in PHYSICAL_ADDRESS LogicalAddress,
    __in PVOID VirtualAddress,
    __in BOOLEAN CacheEnabled
    );

typedef NTSTATUS (*PALLOCATE_ADAPTER_CHANNEL)(
    __in PDMA_ADAPTER DmaAdapter,
    __in PDEVICE_OBJECT DeviceObject,
    __in ULONG NumberOfMapRegisters,
    __in PDRIVER_CONTROL ExecutionRoutine,
    __in PVOID Context
    );

typedef BOOLEAN (*PFLUSH_ADAPTER_BUFFERS)(
    __in PDMA_ADAPTER DmaAdapter,
    __in PMDL Mdl,
    __in PVOID MapRegisterBase,
    __in PVOID CurrentVa,
    __in ULONG Length,
    __in BOOLEAN WriteToDevice
    );

typedef VOID (*PFREE_ADAPTER_CHANNEL)(
    __in PDMA_ADAPTER DmaAdapter
    );

typedef VOID (*PFREE_MAP_REGISTERS)(
    __in PDMA_ADAPTER DmaAdapter,
    PVOID MapRegisterBase,
    ULONG NumberOfMapRegisters
    );

typedef PHYSICAL_ADDRESS (*PMAP_TRANSFER)(
    __in PDMA_ADAPTER DmaAdapter,
    __in PMDL Mdl,
    __in PVOID MapRegisterBase,
    __in PVOID CurrentVa,
    __inout PULONG Length,
    __in BOOLEAN WriteToDevice
    );

typedef ULONG (*PGET_DMA_ALIGNMENT)(
    __in PDMA_ADAPTER DmaAdapter
    );

typedef ULONG (*PREAD_DMA_COUNTER)(
    __in PDMA_ADAPTER DmaAdapter
    );

typedef VOID
(*PDRIVER_LIST_CONTROL)(
    __in struct _DEVICE_OBJECT *DeviceObject,
    __in struct _IRP *Irp,
    __in PSCATTER_GATHER_LIST ScatterGather,
    __in PVOID Context
    );

typedef NTSTATUS
(*PGET_SCATTER_GATHER_LIST)(
    __in PDMA_ADAPTER DmaAdapter,
    __in PDEVICE_OBJECT DeviceObject,
    __in PMDL Mdl,
    __in PVOID CurrentVa,
    __in ULONG Length,
    __in PDRIVER_LIST_CONTROL ExecutionRoutine,
    __in PVOID Context,
    __in BOOLEAN WriteToDevice
    );

typedef VOID
(*PPUT_SCATTER_GATHER_LIST)(
    __in PDMA_ADAPTER DmaAdapter,
    __in PSCATTER_GATHER_LIST ScatterGather,
    __in BOOLEAN WriteToDevice
    );

typedef NTSTATUS
(*PCALCULATE_SCATTER_GATHER_LIST_SIZE)(
     __in PDMA_ADAPTER DmaAdapter,
     __in OPTIONAL PMDL Mdl,
     __in PVOID CurrentVa,
     __in ULONG Length,
     __out PULONG  ScatterGatherListSize,
     __out OPTIONAL PULONG pNumberOfMapRegisters
     );

typedef NTSTATUS
(*PBUILD_SCATTER_GATHER_LIST)(
     __in PDMA_ADAPTER DmaAdapter,
     __in PDEVICE_OBJECT DeviceObject,
     __in PMDL Mdl,
     __in PVOID CurrentVa,
     __in ULONG Length,
     __in PDRIVER_LIST_CONTROL ExecutionRoutine,
     __in PVOID Context,
     __in BOOLEAN WriteToDevice,
     __in PVOID   ScatterGatherBuffer,
     __in ULONG   ScatterGatherLength
     );

typedef NTSTATUS
(*PBUILD_MDL_FROM_SCATTER_GATHER_LIST)(
    __in PDMA_ADAPTER DmaAdapter,
    __in PSCATTER_GATHER_LIST ScatterGather,
    __in PMDL OriginalMdl,
    __out PMDL *TargetMdl
    );


typedef struct _DMA_OPERATIONS {
    ULONG Size;
    PPUT_DMA_ADAPTER PutDmaAdapter;
    PALLOCATE_COMMON_BUFFER AllocateCommonBuffer;
    PFREE_COMMON_BUFFER FreeCommonBuffer;
    PALLOCATE_ADAPTER_CHANNEL AllocateAdapterChannel;
    PFLUSH_ADAPTER_BUFFERS FlushAdapterBuffers;
    PFREE_ADAPTER_CHANNEL FreeAdapterChannel;
    PFREE_MAP_REGISTERS FreeMapRegisters;
    PMAP_TRANSFER MapTransfer;
    PGET_DMA_ALIGNMENT GetDmaAlignment;
    PREAD_DMA_COUNTER ReadDmaCounter;
    PGET_SCATTER_GATHER_LIST GetScatterGatherList;
    PPUT_SCATTER_GATHER_LIST PutScatterGatherList;
    PCALCULATE_SCATTER_GATHER_LIST_SIZE CalculateScatterGatherList;
    PBUILD_SCATTER_GATHER_LIST BuildScatterGatherList;
    PBUILD_MDL_FROM_SCATTER_GATHER_LIST BuildMdlFromScatterGatherList;
} DMA_OPERATIONS;



#if defined(USE_DMA_MACROS) && !defined(_NTHAL_) && (defined(_NTDDK_) || defined(_NTDRIVER_)) || defined(_WDM_INCLUDED_) // ntddk

DECLSPEC_DEPRECATED_DDK                 // Use AllocateCommonBuffer
FORCEINLINE
PVOID
HalAllocateCommonBuffer(
    __in PDMA_ADAPTER DmaAdapter,
    __in ULONG Length,
    __out PPHYSICAL_ADDRESS LogicalAddress,
    __in BOOLEAN CacheEnabled
    ){

    PALLOCATE_COMMON_BUFFER allocateCommonBuffer;
    PVOID commonBuffer;

    allocateCommonBuffer = *(DmaAdapter)->DmaOperations->AllocateCommonBuffer;
    ASSERT( allocateCommonBuffer != NULL );

    commonBuffer = allocateCommonBuffer( DmaAdapter,
                                         Length,
                                         LogicalAddress,
                                         CacheEnabled );

    return commonBuffer;
}

DECLSPEC_DEPRECATED_DDK                 // Use FreeCommonBuffer
FORCEINLINE
VOID
HalFreeCommonBuffer(
    __in PDMA_ADAPTER DmaAdapter,
    __in ULONG Length,
    __in PHYSICAL_ADDRESS LogicalAddress,
    __in PVOID VirtualAddress,
    __in BOOLEAN CacheEnabled
    ){

    PFREE_COMMON_BUFFER freeCommonBuffer;

    freeCommonBuffer = *(DmaAdapter)->DmaOperations->FreeCommonBuffer;
    ASSERT( freeCommonBuffer != NULL );

    freeCommonBuffer( DmaAdapter,
                      Length,
                      LogicalAddress,
                      VirtualAddress,
                      CacheEnabled );
}

DECLSPEC_DEPRECATED_DDK                 // Use AllocateAdapterChannel
FORCEINLINE
NTSTATUS
IoAllocateAdapterChannel(
    __in PDMA_ADAPTER DmaAdapter,
    __in PDEVICE_OBJECT DeviceObject,
    __in ULONG NumberOfMapRegisters,
    __in PDRIVER_CONTROL ExecutionRoutine,
    __in PVOID Context
    ){

    PALLOCATE_ADAPTER_CHANNEL allocateAdapterChannel;
    NTSTATUS status;

    allocateAdapterChannel =
        *(DmaAdapter)->DmaOperations->AllocateAdapterChannel;

    ASSERT( allocateAdapterChannel != NULL );

    status = allocateAdapterChannel( DmaAdapter,
                                     DeviceObject,
                                     NumberOfMapRegisters,
                                     ExecutionRoutine,
                                     Context );

    return status;
}

DECLSPEC_DEPRECATED_DDK                 // Use FlushAdapterBuffers
FORCEINLINE
BOOLEAN
IoFlushAdapterBuffers(
    __in PDMA_ADAPTER DmaAdapter,
    __in PMDL Mdl,
    __in PVOID MapRegisterBase,
    __in PVOID CurrentVa,
    __in ULONG Length,
    __in BOOLEAN WriteToDevice
    ){

    PFLUSH_ADAPTER_BUFFERS flushAdapterBuffers;
    BOOLEAN result;

    flushAdapterBuffers = *(DmaAdapter)->DmaOperations->FlushAdapterBuffers;
    ASSERT( flushAdapterBuffers != NULL );

    result = flushAdapterBuffers( DmaAdapter,
                                  Mdl,
                                  MapRegisterBase,
                                  CurrentVa,
                                  Length,
                                  WriteToDevice );
    return result;
}

DECLSPEC_DEPRECATED_DDK                 // Use FreeAdapterChannel
FORCEINLINE
VOID
IoFreeAdapterChannel(
    __in PDMA_ADAPTER DmaAdapter
    ){

    PFREE_ADAPTER_CHANNEL freeAdapterChannel;

    freeAdapterChannel = *(DmaAdapter)->DmaOperations->FreeAdapterChannel;
    ASSERT( freeAdapterChannel != NULL );

    freeAdapterChannel( DmaAdapter );
}

DECLSPEC_DEPRECATED_DDK                 // Use FreeMapRegisters
FORCEINLINE
VOID
IoFreeMapRegisters(
    __in PDMA_ADAPTER DmaAdapter,
    __in PVOID MapRegisterBase,
    __in ULONG NumberOfMapRegisters
    ){

    PFREE_MAP_REGISTERS freeMapRegisters;

    freeMapRegisters = *(DmaAdapter)->DmaOperations->FreeMapRegisters;
    ASSERT( freeMapRegisters != NULL );

    freeMapRegisters( DmaAdapter,
                      MapRegisterBase,
                      NumberOfMapRegisters );
}


DECLSPEC_DEPRECATED_DDK                 // Use MapTransfer
FORCEINLINE
PHYSICAL_ADDRESS
IoMapTransfer(
    __in PDMA_ADAPTER DmaAdapter,
    __in PMDL Mdl,
    __in PVOID MapRegisterBase,
    __in PVOID CurrentVa,
    __inout PULONG Length,
    __in BOOLEAN WriteToDevice
    ){

    PHYSICAL_ADDRESS physicalAddress;
    PMAP_TRANSFER mapTransfer;

    mapTransfer = *(DmaAdapter)->DmaOperations->MapTransfer;
    ASSERT( mapTransfer != NULL );

    physicalAddress = mapTransfer( DmaAdapter,
                                   Mdl,
                                   MapRegisterBase,
                                   CurrentVa,
                                   Length,
                                   WriteToDevice );

    return physicalAddress;
}

DECLSPEC_DEPRECATED_DDK                 // Use GetDmaAlignment
FORCEINLINE
ULONG
HalGetDmaAlignment(
    __in PDMA_ADAPTER DmaAdapter
    )
{
    PGET_DMA_ALIGNMENT getDmaAlignment;
    ULONG alignment;

    getDmaAlignment = *(DmaAdapter)->DmaOperations->GetDmaAlignment;
    ASSERT( getDmaAlignment != NULL );

    alignment = getDmaAlignment( DmaAdapter );
    return alignment;
}

DECLSPEC_DEPRECATED_DDK                 // Use ReadDmaCounter
FORCEINLINE
ULONG
HalReadDmaCounter(
    __in PDMA_ADAPTER DmaAdapter
    )
{
    PREAD_DMA_COUNTER readDmaCounter;
    ULONG counter;

    readDmaCounter = *(DmaAdapter)->DmaOperations->ReadDmaCounter;
    ASSERT( readDmaCounter != NULL );

    counter = readDmaCounter( DmaAdapter );
    return counter;
}

#endif // USE_DMA_MACROS && (_NTDDK_ || _NTDRIVER_)


#if (NTDDI_VERSION >= NTDDI_WIN2K)
NTKERNELAPI
VOID
PoSetSystemState (
    __in EXECUTION_STATE Flags
    );
#endif



#if (NTDDI_VERSION >= NTDDI_WIN2K)
NTKERNELAPI
PVOID
PoRegisterSystemState (
    __inout_opt PVOID StateHandle,
    __in EXECUTION_STATE Flags
    );
#endif



typedef
VOID
(*PREQUEST_POWER_COMPLETE) (
    __in PDEVICE_OBJECT DeviceObject,
    __in UCHAR MinorFunction,
    __in POWER_STATE PowerState,
    __in_opt PVOID Context,
    __in PIO_STATUS_BLOCK IoStatus
    );

#if (NTDDI_VERSION >= NTDDI_WIN2K)
NTKERNELAPI
NTSTATUS
PoRequestPowerIrp (
    __in PDEVICE_OBJECT DeviceObject,
    __in UCHAR MinorFunction,
    __in POWER_STATE PowerState,
    __in_opt PREQUEST_POWER_COMPLETE CompletionFunction,
    __in_opt PVOID Context,
    __out_opt PIRP *Irp
    );
#endif

#if (NTDDI_VERSION >= NTDDI_VISTA)
VOID
PoSetSystemWake (
    __inout PIRP Irp
    );
#endif

#if (NTDDI_VERSION >= NTDDI_VISTA)
BOOLEAN
PoGetSystemWake (
    __in PIRP Irp
    );
#endif


#if (NTDDI_VERSION >= NTDDI_WIN2K)
NTKERNELAPI
VOID
PoUnregisterSystemState (
    __in PVOID StateHandle
    );
#endif



#if (NTDDI_VERSION >= NTDDI_WIN2K)
NTKERNELAPI
POWER_STATE
PoSetPowerState (
    __in PDEVICE_OBJECT   DeviceObject,
    __in POWER_STATE_TYPE Type,
    __in POWER_STATE      State
    );
#endif

#if (NTDDI_VERSION >= NTDDI_WIN2K)
NTKERNELAPI
NTSTATUS
PoCallDriver (
    __in PDEVICE_OBJECT DeviceObject,
    __inout PIRP        Irp
    );
#endif

#if (NTDDI_VERSION >= NTDDI_WIN2K)
NTKERNELAPI
VOID
PoStartNextPowerIrp(
    __in PIRP   Irp
    );
#endif

#if (NTDDI_VERSION >= NTDDI_WIN2K)
NTKERNELAPI
PULONG
PoRegisterDeviceForIdleDetection (
    __in PDEVICE_OBJECT     DeviceObject,
    __in ULONG              ConservationIdleTime,
    __in ULONG              PerformanceIdleTime,
    __in DEVICE_POWER_STATE State
    );
#endif

#define PoSetDeviceBusy(IdlePointer) \
    *IdlePointer = 0
    
#if (NTDDI_VERSION >= NTDDI_WIN6SP1)
NTKERNELAPI
VOID
PoSetDeviceBusyEx (
    __inout PULONG IdlePointer
    );
#endif

typedef NTSTATUS (*PPOWER_SETTING_CALLBACK) (  
    IN LPCGUID SettingGuid,
    IN PVOID Value,
    IN ULONG ValueLength,
    IN PVOID Context
);

#if (NTDDI_VERSION >= NTDDI_VISTA)
NTKERNELAPI
NTSTATUS
PoRegisterPowerSettingCallback (
    __in_opt PDEVICE_OBJECT         DeviceObject,
    __in LPCGUID                    SettingGuid,
    __in PPOWER_SETTING_CALLBACK    Callback,
    __in_opt PVOID                  Context,
    __out_opt PVOID                 * Handle
    );
#endif

#if (NTDDI_VERSION >= NTDDI_VISTA)
NTKERNELAPI
NTSTATUS
PoUnregisterPowerSettingCallback(
    __inout PVOID   Handle
    );
#endif

//
// \Callback\PowerState values
//

#define PO_CB_SYSTEM_POWER_POLICY       0
#define PO_CB_AC_STATUS                 1
#define PO_CB_BUTTON_COLLISION          2
#define PO_CB_SYSTEM_STATE_LOCK         3
#define PO_CB_LID_SWITCH_STATE          4
#define PO_CB_PROCESSOR_POWER_POLICY    5

//
// Object Manager types
//

typedef struct _OBJECT_HANDLE_INFORMATION {
    ULONG HandleAttributes;
    ACCESS_MASK GrantedAccess;
} OBJECT_HANDLE_INFORMATION, *POBJECT_HANDLE_INFORMATION;


#if (NTDDI_VERSION >= NTDDI_WIN2K)
NTKERNELAPI
NTSTATUS
ObReferenceObjectByHandle(
    __in HANDLE Handle,
    __in ACCESS_MASK DesiredAccess,
    __in_opt POBJECT_TYPE ObjectType,
    __in KPROCESSOR_MODE AccessMode,
    __out PVOID *Object,
    __out_opt POBJECT_HANDLE_INFORMATION HandleInformation
    );
#endif


#define ObDereferenceObject(a)                                     \
        ObfDereferenceObject(a)

#define ObReferenceObject(Object) ObfReferenceObject(Object)

#if (NTDDI_VERSION >= NTDDI_WIN2K)
NTKERNELAPI
LONG_PTR
FASTCALL
ObfReferenceObject(
    __in PVOID Object
    );
#endif

#if (NTDDI_VERSION >= NTDDI_WIN2K)
NTKERNELAPI
NTSTATUS
ObReferenceObjectByPointer(
    __in PVOID Object,
    __in ACCESS_MASK DesiredAccess,
    __in_opt POBJECT_TYPE ObjectType,
    __in KPROCESSOR_MODE AccessMode
    );
#endif

#if (NTDDI_VERSION >= NTDDI_WIN2K)
NTKERNELAPI
LONG_PTR
FASTCALL
ObfDereferenceObject(
    __in PVOID Object
    );
#endif


#if (NTDDI_VERSION >= NTDDI_WIN2K)
NTKERNELAPI
NTSTATUS
ObGetObjectSecurity(
    __in PVOID Object,
    __out PSECURITY_DESCRIPTOR *SecurityDescriptor,
    __out PBOOLEAN MemoryAllocated
    );
#endif

#if (NTDDI_VERSION >= NTDDI_WIN2K)
NTKERNELAPI
VOID
ObReleaseObjectSecurity(
    __in PSECURITY_DESCRIPTOR SecurityDescriptor,
    __in BOOLEAN MemoryAllocated
    );
#endif


//
// Registration version for Vista SP1 and Windows Server 2007
//
#define OB_FLT_REGISTRATION_VERSION_0100  0x0100

//
// This value should be used by filters for registration
//
#define OB_FLT_REGISTRATION_VERSION OB_FLT_REGISTRATION_VERSION_0100

typedef ULONG OB_OPERATION;

#define OB_OPERATION_HANDLE_CREATE              0x00000001
#define OB_OPERATION_HANDLE_DUPLICATE           0x00000002

typedef struct _OB_PRE_CREATE_HANDLE_INFORMATION {
    __inout ACCESS_MASK         DesiredAccess;
    __in ACCESS_MASK            OriginalDesiredAccess;
} OB_PRE_CREATE_HANDLE_INFORMATION, *POB_PRE_CREATE_HANDLE_INFORMATION;

typedef struct _OB_PRE_DUPLICATE_HANDLE_INFORMATION {
    __inout ACCESS_MASK         DesiredAccess;
    __in ACCESS_MASK            OriginalDesiredAccess;
    __in PVOID                  SourceProcess;
    __in PVOID                  TargetProcess;
} OB_PRE_DUPLICATE_HANDLE_INFORMATION, * POB_PRE_DUPLICATE_HANDLE_INFORMATION;

typedef union _OB_PRE_OPERATION_PARAMETERS {
    __inout OB_PRE_CREATE_HANDLE_INFORMATION        CreateHandleInformation;
    __inout OB_PRE_DUPLICATE_HANDLE_INFORMATION     DuplicateHandleInformation;
} OB_PRE_OPERATION_PARAMETERS, *POB_PRE_OPERATION_PARAMETERS;

typedef struct _OB_PRE_OPERATION_INFORMATION {
    __in OB_OPERATION           Operation;
    union {
        __in ULONG Flags;
        struct {
            __in ULONG KernelHandle:1;
            __in ULONG Reserved:31;
        };
    };
    __in PVOID                         Object;
    __in POBJECT_TYPE                  ObjectType;
    __out PVOID                        CallContext;
    __in POB_PRE_OPERATION_PARAMETERS  Parameters;
} OB_PRE_OPERATION_INFORMATION, *POB_PRE_OPERATION_INFORMATION;

typedef struct _OB_POST_CREATE_HANDLE_INFORMATION {
    __in ACCESS_MASK            GrantedAccess;
} OB_POST_CREATE_HANDLE_INFORMATION, *POB_POST_CREATE_HANDLE_INFORMATION;

typedef struct _OB_POST_DUPLICATE_HANDLE_INFORMATION {
    __in ACCESS_MASK            GrantedAccess;
} OB_POST_DUPLICATE_HANDLE_INFORMATION, * POB_POST_DUPLICATE_HANDLE_INFORMATION;

typedef union _OB_POST_OPERATION_PARAMETERS {
    __in OB_POST_CREATE_HANDLE_INFORMATION       CreateHandleInformation;
    __in OB_POST_DUPLICATE_HANDLE_INFORMATION    DuplicateHandleInformation;
} OB_POST_OPERATION_PARAMETERS, *POB_POST_OPERATION_PARAMETERS;

typedef struct _OB_POST_OPERATION_INFORMATION {
    __in OB_OPERATION  Operation;
    union {
        __in ULONG Flags;
        struct {
            __in ULONG KernelHandle:1;
            __in ULONG Reserved:31;
        };
    };
    __in PVOID                          Object;
    __in POBJECT_TYPE                   ObjectType;
    __in PVOID                          CallContext;
    __in NTSTATUS                       ReturnStatus;
    __in POB_POST_OPERATION_PARAMETERS  Parameters;
} OB_POST_OPERATION_INFORMATION,*POB_POST_OPERATION_INFORMATION;

typedef enum _OB_PREOP_CALLBACK_STATUS {
    OB_PREOP_SUCCESS
} OB_PREOP_CALLBACK_STATUS, *POB_PREOP_CALLBACK_STATUS;

typedef OB_PREOP_CALLBACK_STATUS
(*POB_PRE_OPERATION_CALLBACK) (
    __in PVOID RegistrationContext,
    __inout POB_PRE_OPERATION_INFORMATION OperationInformation
    );

typedef VOID
(*POB_POST_OPERATION_CALLBACK) (
    __in PVOID RegistrationContext,
    __in POB_POST_OPERATION_INFORMATION OperationInformation
    );

typedef struct _OB_OPERATION_REGISTRATION {
    __in POBJECT_TYPE                *ObjectType;
    __in OB_OPERATION                Operations;
    __in POB_PRE_OPERATION_CALLBACK  PreOperation;
    __in POB_POST_OPERATION_CALLBACK PostOperation;
} OB_OPERATION_REGISTRATION, *POB_OPERATION_REGISTRATION;

typedef struct _OB_CALLBACK_REGISTRATION {
    __in USHORT                     Version;
    __in USHORT                     OperationRegistrationCount;
    __in UNICODE_STRING             Altitude;
    __in PVOID                      RegistrationContext;
    __in OB_OPERATION_REGISTRATION  *OperationRegistration;
} OB_CALLBACK_REGISTRATION, *POB_CALLBACK_REGISTRATION;

#if (NTDDI_VERSION >= NTDDI_VISTASP1)
NTKERNELAPI
NTSTATUS
ObRegisterCallbacks (
    __in POB_CALLBACK_REGISTRATION CallbackRegistration,
    __deref_out PVOID *RegistrationHandle
    );

NTKERNELAPI
VOID
ObUnRegisterCallbacks (
    __in PVOID RegistrationHandle
    );

NTKERNELAPI
USHORT
ObGetFilterVersion ();
#endif

#ifndef _PCI_X_
#define _PCI_X_

//
// A PCI driver can read the complete 256 bytes of configuration
// information for any PCI device by calling:
//
//      ULONG
//      HalGetBusData (
//          IN BUS_DATA_TYPE        PCIConfiguration,
//          IN ULONG                PciBusNumber,
//          IN PCI_SLOT_NUMBER      VirtualSlotNumber,
//          IN PPCI_COMMON_CONFIG   &PCIDeviceConfig,
//          IN ULONG                sizeof (PCIDeviceConfig)
//      );
//
//      A return value of 0 means that the specified PCI bus does not exist.
//
//      A return value of 2, with a VendorID of PCI_INVALID_VENDORID means
//      that the PCI bus does exist, but there is no device at the specified
//      VirtualSlotNumber (PCI Device/Function number).
//
//



typedef struct _PCI_SLOT_NUMBER {
    union {
        struct {
            ULONG   DeviceNumber:5;
            ULONG   FunctionNumber:3;
            ULONG   Reserved:24;
        } bits;
        ULONG   AsULONG;
    } u;
} PCI_SLOT_NUMBER, *PPCI_SLOT_NUMBER;


#define PCI_TYPE0_ADDRESSES             6
#define PCI_TYPE1_ADDRESSES             2
#define PCI_TYPE2_ADDRESSES             5

typedef struct _PCI_COMMON_HEADER {
    USHORT  VendorID;                   // (ro)
    USHORT  DeviceID;                   // (ro)
    USHORT  Command;                    // Device control
    USHORT  Status;
    UCHAR   RevisionID;                 // (ro)
    UCHAR   ProgIf;                     // (ro)
    UCHAR   SubClass;                   // (ro)
    UCHAR   BaseClass;                  // (ro)
    UCHAR   CacheLineSize;              // (ro+)
    UCHAR   LatencyTimer;               // (ro+)
    UCHAR   HeaderType;                 // (ro)
    UCHAR   BIST;                       // Built in self test

    union {
        struct _PCI_HEADER_TYPE_0 {
            ULONG   BaseAddresses[PCI_TYPE0_ADDRESSES];
            ULONG   CIS;
            USHORT  SubVendorID;
            USHORT  SubSystemID;
            ULONG   ROMBaseAddress;
            UCHAR   CapabilitiesPtr;
            UCHAR   Reserved1[3];
            ULONG   Reserved2;
            UCHAR   InterruptLine;      //
            UCHAR   InterruptPin;       // (ro)
            UCHAR   MinimumGrant;       // (ro)
            UCHAR   MaximumLatency;     // (ro)
        } type0;



        //
        // PCI to PCI Bridge
        //

        struct _PCI_HEADER_TYPE_1 {
            ULONG   BaseAddresses[PCI_TYPE1_ADDRESSES];
            UCHAR   PrimaryBus;
            UCHAR   SecondaryBus;
            UCHAR   SubordinateBus;
            UCHAR   SecondaryLatency;
            UCHAR   IOBase;
            UCHAR   IOLimit;
            USHORT  SecondaryStatus;
            USHORT  MemoryBase;
            USHORT  MemoryLimit;
            USHORT  PrefetchBase;
            USHORT  PrefetchLimit;
            ULONG   PrefetchBaseUpper32;
            ULONG   PrefetchLimitUpper32;
            USHORT  IOBaseUpper16;
            USHORT  IOLimitUpper16;
            UCHAR   CapabilitiesPtr;
            UCHAR   Reserved1[3];
            ULONG   ROMBaseAddress;
            UCHAR   InterruptLine;
            UCHAR   InterruptPin;
            USHORT  BridgeControl;
        } type1;

        //
        // PCI to CARDBUS Bridge
        //

        struct _PCI_HEADER_TYPE_2 {
            ULONG   SocketRegistersBaseAddress;
            UCHAR   CapabilitiesPtr;
            UCHAR   Reserved;
            USHORT  SecondaryStatus;
            UCHAR   PrimaryBus;
            UCHAR   SecondaryBus;
            UCHAR   SubordinateBus;
            UCHAR   SecondaryLatency;
            struct  {
                ULONG   Base;
                ULONG   Limit;
            }       Range[PCI_TYPE2_ADDRESSES-1];
            UCHAR   InterruptLine;
            UCHAR   InterruptPin;
            USHORT  BridgeControl;
        } type2;



    } u;

} PCI_COMMON_HEADER, *PPCI_COMMON_HEADER;

#ifdef __cplusplus

typedef struct _PCI_COMMON_CONFIG : PCI_COMMON_HEADER {
    UCHAR   DeviceSpecific[192];
} PCI_COMMON_CONFIG, *PPCI_COMMON_CONFIG;

#else

typedef struct _PCI_COMMON_CONFIG {
    PCI_COMMON_HEADER DUMMYSTRUCTNAME;
    UCHAR   DeviceSpecific[192];
} PCI_COMMON_CONFIG, *PPCI_COMMON_CONFIG;

#endif

#define PCI_COMMON_HDR_LENGTH (FIELD_OFFSET (PCI_COMMON_CONFIG, DeviceSpecific))
#define PCI_EXTENDED_CONFIG_LENGTH          0x1000

#define PCI_MAX_DEVICES                     32
#define PCI_MAX_FUNCTION                    8
#define PCI_MAX_BRIDGE_NUMBER               0xFF

#define PCI_INVALID_VENDORID                0xFFFF

//
// Bit encodings for  PCI_COMMON_CONFIG.HeaderType
//

#define PCI_MULTIFUNCTION                   0x80
#define PCI_DEVICE_TYPE                     0x00
#define PCI_BRIDGE_TYPE                     0x01
#define PCI_CARDBUS_BRIDGE_TYPE             0x02

#define PCI_CONFIGURATION_TYPE(PciData) \
    (((PPCI_COMMON_CONFIG)(PciData))->HeaderType & ~PCI_MULTIFUNCTION)

#define PCI_MULTIFUNCTION_DEVICE(PciData) \
    ((((PPCI_COMMON_CONFIG)(PciData))->HeaderType & PCI_MULTIFUNCTION) != 0)

//
// Bit encodings for PCI_COMMON_CONFIG.Command
//

#define PCI_ENABLE_IO_SPACE                 0x0001
#define PCI_ENABLE_MEMORY_SPACE             0x0002
#define PCI_ENABLE_BUS_MASTER               0x0004
#define PCI_ENABLE_SPECIAL_CYCLES           0x0008
#define PCI_ENABLE_WRITE_AND_INVALIDATE     0x0010
#define PCI_ENABLE_VGA_COMPATIBLE_PALETTE   0x0020
#define PCI_ENABLE_PARITY                   0x0040  // (ro+)
#define PCI_ENABLE_WAIT_CYCLE               0x0080  // (ro+)
#define PCI_ENABLE_SERR                     0x0100  // (ro+)
#define PCI_ENABLE_FAST_BACK_TO_BACK        0x0200  // (ro)
#define PCI_DISABLE_LEVEL_INTERRUPT         0x0400

//
// Bit encodings for PCI_COMMON_CONFIG.Status
//

#define PCI_STATUS_INTERRUPT_PENDING        0x0008
#define PCI_STATUS_CAPABILITIES_LIST        0x0010  // (ro)
#define PCI_STATUS_66MHZ_CAPABLE            0x0020  // (ro)
#define PCI_STATUS_UDF_SUPPORTED            0x0040  // (ro)
#define PCI_STATUS_FAST_BACK_TO_BACK        0x0080  // (ro)
#define PCI_STATUS_DATA_PARITY_DETECTED     0x0100
#define PCI_STATUS_DEVSEL                   0x0600  // 2 bits wide
#define PCI_STATUS_SIGNALED_TARGET_ABORT    0x0800
#define PCI_STATUS_RECEIVED_TARGET_ABORT    0x1000
#define PCI_STATUS_RECEIVED_MASTER_ABORT    0x2000
#define PCI_STATUS_SIGNALED_SYSTEM_ERROR    0x4000
#define PCI_STATUS_DETECTED_PARITY_ERROR    0x8000

//
// The NT PCI Driver uses a WhichSpace parameter on its CONFIG_READ/WRITE
// routines.   The following values are defined-
//

#define PCI_WHICHSPACE_CONFIG               0x0
#define PCI_WHICHSPACE_ROM                  0x52696350

//
// PCI Capability IDs
//

#define PCI_CAPABILITY_ID_POWER_MANAGEMENT  0x01
#define PCI_CAPABILITY_ID_AGP               0x02
#define PCI_CAPABILITY_ID_VPD               0x03
#define PCI_CAPABILITY_ID_SLOT_ID           0x04
#define PCI_CAPABILITY_ID_MSI               0x05
#define PCI_CAPABILITY_ID_CPCI_HOTSWAP      0x06
#define PCI_CAPABILITY_ID_PCIX              0x07
#define PCI_CAPABILITY_ID_HYPERTRANSPORT    0x08
#define PCI_CAPABILITY_ID_VENDOR_SPECIFIC   0x09
#define PCI_CAPABILITY_ID_DEBUG_PORT        0x0A
#define PCI_CAPABILITY_ID_CPCI_RES_CTRL     0x0B
#define PCI_CAPABILITY_ID_SHPC              0x0C
#define PCI_CAPABILITY_ID_P2P_SSID          0x0D
#define PCI_CAPABILITY_ID_AGP_TARGET        0x0E
#define PCI_CAPABILITY_ID_SECURE            0x0F
#define PCI_CAPABILITY_ID_PCI_EXPRESS       0x10
#define PCI_CAPABILITY_ID_MSIX              0x11

//
// All PCI Capability structures have the following header.
//
// CapabilityID is used to identify the type of the structure (is
// one of the PCI_CAPABILITY_ID values above.
//
// Next is the offset in PCI Configuration space (0x40 - 0xfc) of the
// next capability structure in the list, or 0x00 if there are no more
// entries.
//
typedef struct _PCI_CAPABILITIES_HEADER {
    UCHAR   CapabilityID;
    UCHAR   Next;
} PCI_CAPABILITIES_HEADER, *PPCI_CAPABILITIES_HEADER;

//
// Power Management Capability
//

typedef struct _PCI_PMC {
    UCHAR       Version:3;
    UCHAR       PMEClock:1;
    UCHAR       Rsvd1:1;
    UCHAR       DeviceSpecificInitialization:1;
    UCHAR       Rsvd2:2;
    struct _PM_SUPPORT {
        UCHAR   Rsvd2:1;
        UCHAR   D1:1;
        UCHAR   D2:1;
        UCHAR   PMED0:1;
        UCHAR   PMED1:1;
        UCHAR   PMED2:1;
        UCHAR   PMED3Hot:1;
        UCHAR   PMED3Cold:1;
    } Support;
} PCI_PMC, *PPCI_PMC;

typedef struct _PCI_PMCSR {
    USHORT      PowerState:2;
    USHORT      Rsvd1:6;
    USHORT      PMEEnable:1;
    USHORT      DataSelect:4;
    USHORT      DataScale:2;
    USHORT      PMEStatus:1;
} PCI_PMCSR, *PPCI_PMCSR;


typedef struct _PCI_PMCSR_BSE {
    UCHAR       Rsvd1:6;
    UCHAR       D3HotSupportsStopClock:1;       // B2_B3#
    UCHAR       BusPowerClockControlEnabled:1;  // BPCC_EN
} PCI_PMCSR_BSE, *PPCI_PMCSR_BSE;


typedef struct _PCI_PM_CAPABILITY {

    PCI_CAPABILITIES_HEADER Header;

    //
    // Power Management Capabilities (Offset = 2)
    //

    union {
        PCI_PMC         Capabilities;
        USHORT          AsUSHORT;
    } PMC;

    //
    // Power Management Control/Status (Offset = 4)
    //

    union {
        PCI_PMCSR       ControlStatus;
        USHORT          AsUSHORT;
    } PMCSR;

    //
    // PMCSR PCI-PCI Bridge Support Extensions
    //

    union {
        PCI_PMCSR_BSE   BridgeSupport;
        UCHAR           AsUCHAR;
    } PMCSR_BSE;

    //
    // Optional read only 8 bit Data register.  Contents controlled by
    // DataSelect and DataScale in ControlStatus.
    //

    UCHAR   Data;

} PCI_PM_CAPABILITY, *PPCI_PM_CAPABILITY;


//
// PCI-X Capability
//

typedef struct {

    PCI_CAPABILITIES_HEADER Header;

    union {
        struct {
            USHORT  DataParityErrorRecoveryEnable:1;
            USHORT  EnableRelaxedOrdering:1;
            USHORT  MaxMemoryReadByteCount:2;
            USHORT  MaxOutstandingSplitTransactions:3;
            USHORT  Reserved:9;
        } bits;
        USHORT  AsUSHORT;
    } Command;

    union {
        struct {
            ULONG   FunctionNumber:3;
            ULONG   DeviceNumber:5;
            ULONG   BusNumber:8;
            ULONG   Device64Bit:1;
            ULONG   Capable133MHz:1;
            ULONG   SplitCompletionDiscarded:1;
            ULONG   UnexpectedSplitCompletion:1;
            ULONG   DeviceComplexity:1;
            ULONG   DesignedMaxMemoryReadByteCount:2;
            ULONG   DesignedMaxOutstandingSplitTransactions:3;
            ULONG   DesignedMaxCumulativeReadSize:3;
            ULONG   ReceivedSplitCompletionErrorMessage:1;
            ULONG   CapablePCIX266:1;
            ULONG   CapablePCIX533:1;
        } bits;
        ULONG   AsULONG;
    } Status;
} PCI_X_CAPABILITY, *PPCI_X_CAPABILITY;


//
// PCI Express Extended Capabilities.
//

#define PCI_EXPRESS_ADVANCED_ERROR_REPORTING_CAP_ID                     0x0001
#define PCI_EXPRESS_VIRTUAL_CHANNEL_CAP_ID                              0x0002
#define PCI_EXPRESS_DEVICE_SERIAL_NUMBER_CAP_ID                         0x0003
#define PCI_EXPRESS_POWER_BUDGETING_CAP_ID                              0x0004
#define PCI_EXPRESS_RC_LINK_DECLARATION_CAP_ID                          0x0005
#define PCI_EXPRESS_RC_INTERNAL_LINK_CONTROL_CAP_ID                     0x0006
#define PCI_EXPRESS_RC_EVENT_COLLECTOR_ENDPOINT_ASSOCIATION_CAP_ID      0x0007
#define PCI_EXPRESS_MFVC_CAP_ID                                         0x0008
#define PCI_EXPRESS_VC_AND_MFVC_CAP_ID                                  0x0009
#define PCI_EXPRESS_RCRB_HEADER_CAP_ID                                  0x000A

//
// All Enhanced capabilities have the following header.
//

typedef struct _PCI_EXPRESS_ENHANCED_CAPABILITY_HEADER {

    USHORT CapabilityID;
    USHORT Version:4;
    USHORT Next:12;

} PCI_EXPRESS_ENHANCED_CAPABILITY_HEADER, *PPCI_EXPRESS_ENHANCED_CAPABILITY_HEADER;

//
// Serial Number Capability.
//

typedef struct _PCI_EXPRESS_SERIAL_NUMBER_CAPABILITY {

    PCI_EXPRESS_ENHANCED_CAPABILITY_HEADER Header;

    ULONG LowSerialNumber;
    ULONG HighSerialNumber;

} PCI_EXPRESS_SERIAL_NUMBER_CAPABILITY, *PPCI_EXPRESS_SERIAL_NUMBER_CAPABILITY;

//
// PCI Express Advanced Error Reporting structures.
//

typedef union _PCI_EXPRESS_UNCORRECTABLE_ERROR_STATUS {

    struct {
        ULONG Undefined:1;
        ULONG Reserved1:3;
        ULONG DataLinkProtocolError:1;
        ULONG SurpriseDownError:1;
        ULONG Reserved2:6;
        ULONG PoisonedTLP:1;
        ULONG FlowControlProtocolError:1;
        ULONG CompletionTimeout:1;
        ULONG CompleterAbort:1;
        ULONG UnexpectedCompletion:1;
        ULONG ReceiverOverflow:1;
        ULONG MalformedTLP:1;
        ULONG ECRCError:1;
        ULONG UnsupportedRequestError:1;
        ULONG Reserved3:11;
    } DUMMYSTRUCTNAME;

    ULONG AsULONG;

} PCI_EXPRESS_UNCORRECTABLE_ERROR_STATUS, *PPCI_EXPRESS_UNCORRECTABLE_ERROR_STATUS;

typedef union _PCI_EXPRESS_UNCORRECTABLE_ERROR_MASK {

    struct {
        ULONG Undefined:1;
        ULONG Reserved1:3;
        ULONG DataLinkProtocolError:1;
        ULONG SurpriseDownError:1;
        ULONG Reserved2:6;
        ULONG PoisonedTLP:1;
        ULONG FlowControlProtocolError:1;
        ULONG CompletionTimeout:1;
        ULONG CompleterAbort:1;
        ULONG UnexpectedCompletion:1;
        ULONG ReceiverOverflow:1;
        ULONG MalformedTLP:1;
        ULONG ECRCError:1;
        ULONG UnsupportedRequestError:1;
        ULONG Reserved3:11;
    } DUMMYSTRUCTNAME;

    ULONG AsULONG;

} PCI_EXPRESS_UNCORRECTABLE_ERROR_MASK, *PPCI_EXPRESS_UNCORRECTABLE_ERROR_MASK;

typedef union _PCI_EXPRESS_UNCORRECTABLE_ERROR_SEVERITY {

    struct {
        ULONG Undefined:1;
        ULONG Reserved1:3;
        ULONG DataLinkProtocolError:1;
        ULONG SurpriseDownError:1;
        ULONG Reserved2:6;
        ULONG PoisonedTLP:1;
        ULONG FlowControlProtocolError:1;
        ULONG CompletionTimeout:1;
        ULONG CompleterAbort:1;
        ULONG UnexpectedCompletion:1;
        ULONG ReceiverOverflow:1;
        ULONG MalformedTLP:1;
        ULONG ECRCError:1;
        ULONG UnsupportedRequestError:1;
        ULONG Reserved3:11;
    } DUMMYSTRUCTNAME;

    ULONG AsULONG;
    
} PCI_EXPRESS_UNCORRECTABLE_ERROR_SEVERITY, *PPCI_EXPRESS_UNCORRECTABLE_ERROR_SEVERITY;

typedef union _PCI_EXPRESS_CORRECTABLE_ERROR_STATUS {

    struct {
        ULONG ReceiverError:1;
        ULONG Reserved1:5;
        ULONG BadTLP:1;
        ULONG BadDLLP:1;
        ULONG ReplayNumRollover:1;
        ULONG Reserved2:3;
        ULONG ReplayTimerTimeout:1;
        ULONG AdvisoryNonFatalError:1;
        ULONG Reserved3:18;
    } DUMMYSTRUCTNAME;

    ULONG AsULONG;

} PCI_EXPRESS_CORRECTABLE_ERROR_STATUS, *PPCI_CORRECTABLE_ERROR_STATUS;

typedef union _PCI_EXPRESS_CORRECTABLE_ERROR_MASK {

    struct {
        ULONG ReceiverError:1;
        ULONG Reserved1:5;
        ULONG BadTLP:1;
        ULONG BadDLLP:1;
        ULONG ReplayNumRollover:1;
        ULONG Reserved2:3;
        ULONG ReplayTimerTimeout:1;
        ULONG AdvisoryNonFatalError:1;
        ULONG Reserved3:18;
    } DUMMYSTRUCTNAME;

    ULONG AsULONG;

} PCI_EXPRESS_CORRECTABLE_ERROR_MASK, *PPCI_CORRECTABLE_ERROR_MASK;

typedef union _PCI_EXPRESS_AER_CAPABILITIES {

    struct {
        ULONG FirstErrorPointer:5;
        ULONG ECRCGenerationCapable:1;
        ULONG ECRCGenerationEnable:1;
        ULONG ECRCCheckCapable:1;
        ULONG ECRCCheckEnable:1;
        ULONG Reserved:23;
    } DUMMYSTRUCTNAME;

    ULONG AsULONG;

} PCI_EXPRESS_AER_CAPABILITIES, *PPCI_EXPRESS_AER_CAPABILITIES;

typedef union _PCI_EXPRESS_ROOT_ERROR_COMMAND {

    struct {
        ULONG CorrectableErrorReportingEnable:1;
        ULONG NonFatalErrorReportingEnable:1;
        ULONG FatalErrorReportingEnable:1;
        ULONG Reserved:29;
    } DUMMYSTRUCTNAME;

    ULONG AsULONG;
    
} PCI_EXPRESS_ROOT_ERROR_COMMAND, *PPCI_EXPRESS_ROOT_ERROR_COMMAND;

typedef union _PCI_EXPRESS_ROOT_ERROR_STATUS {

    struct {
        ULONG CorrectableErrorReceived:1;
        ULONG MultipleCorrectableErrorsReceived:1;
        ULONG UncorrectableErrorReceived:1;
        ULONG MultipleUncorrectableErrorsReceived:1;
        ULONG FirstUncorrectableFatal:1;
        ULONG NonFatalErrorMessagesReceived:1;
        ULONG FatalErrorMessagesReceived:1;
        ULONG Reserved:20;
        ULONG AdvancedErrorInterruptMessageNumber:5;
    } DUMMYSTRUCTNAME;

    ULONG AsULONG;

} PCI_EXPRESS_ROOT_ERROR_STATUS, *PPCI_EXPRESS_ROOT_ERROR_STATUS;

typedef union _PCI_EXPRESS_ERROR_SOURCE_ID {

    struct {
        USHORT CorrectableSourceIdFun:3;
        USHORT CorrectableSourceIdDev:5;
        USHORT CorrectableSourceIdBus:8;
        USHORT UncorrectableSourceIdFun:3;
        USHORT UncorrectableSourceIdDev:5;
        USHORT UncorrectableSourceIdBus:8;
    } DUMMYSTRUCTNAME;

    ULONG AsULONG;

} PCI_EXPRESS_ERROR_SOURCE_ID, *PPCI_EXPRESS_ERROR_SOURCE_ID;

typedef union _PCI_EXPRESS_SEC_UNCORRECTABLE_ERROR_STATUS {

    struct {
        ULONG TargetAbortOnSplitCompletion:1;
        ULONG MasterAbortOnSplitCompletion:1;
        ULONG ReceivedTargetAbort:1;
        ULONG ReceivedMasterAbort:1;
        ULONG RsvdZ:1;
        ULONG UnexpectedSplitCompletionError:1;
        ULONG UncorrectableSplitCompletion:1;
        ULONG UncorrectableDataError:1;
        ULONG UncorrectableAttributeError:1;
        ULONG UncorrectableAddressError:1;
        ULONG DelayedTransactionDiscardTimerExpired:1;
        ULONG PERRAsserted:1;
        ULONG SERRAsserted:1;
        ULONG InternalBridgeError:1;
        ULONG Reserved:18;
    } DUMMYSTRUCTNAME;

    ULONG AsULONG;

} PCI_EXPRESS_SEC_UNCORRECTABLE_ERROR_STATUS, 
  *PPCI_EXPRESS_SEC_UNCORRECTABLE_ERROR_STATUS;

typedef union _PCI_EXPRESS_SEC_UNCORRECTABLE_ERROR_MASK {

    struct {
        ULONG TargetAbortOnSplitCompletion:1;
        ULONG MasterAbortOnSplitCompletion:1;
        ULONG ReceivedTargetAbort:1;
        ULONG ReceivedMasterAbort:1;
        ULONG RsvdZ:1;
        ULONG UnexpectedSplitCompletionError:1;
        ULONG UncorrectableSplitCompletion:1;
        ULONG UncorrectableDataError:1;
        ULONG UncorrectableAttributeError:1;
        ULONG UncorrectableAddressError:1;
        ULONG DelayedTransactionDiscardTimerExpired:1;
        ULONG PERRAsserted:1;
        ULONG SERRAsserted:1;
        ULONG InternalBridgeError:1;
        ULONG Reserved:18;
    } DUMMYSTRUCTNAME;

    ULONG AsULONG;

} PCI_EXPRESS_SEC_UNCORRECTABLE_ERROR_MASK, 
  *PPCI_EXPRESS_SEC_UNCORRECTABLE_ERROR_MASK;

typedef union _PCI_EXPRESS_SEC_UNCORRECTABLE_ERROR_SEVERITY {

    struct {
        ULONG TargetAbortOnSplitCompletion:1;
        ULONG MasterAbortOnSplitCompletion:1;
        ULONG ReceivedTargetAbort:1;
        ULONG ReceivedMasterAbort:1;
        ULONG RsvdZ:1;
        ULONG UnexpectedSplitCompletionError:1;
        ULONG UncorrectableSplitCompletion:1;
        ULONG UncorrectableDataError:1;
        ULONG UncorrectableAttributeError:1;
        ULONG UncorrectableAddressError:1;
        ULONG DelayedTransactionDiscardTimerExpired:1;
        ULONG PERRAsserted:1;
        ULONG SERRAsserted:1;
        ULONG InternalBridgeError:1;
        ULONG Reserved:18;
    } DUMMYSTRUCTNAME;

    ULONG AsULONG;

} PCI_EXPRESS_SEC_UNCORRECTABLE_ERROR_SEVERITY,
  *PPCI_EXPRESS_SEC_UNCORRECTABLE_ERROR_SEVERITY;

typedef union _PCI_EXPRESS_SEC_AER_CAPABILITIES {

    struct {
        ULONG SecondaryUncorrectableFirstErrorPtr:5;
        ULONG Reserved:27;
    } DUMMYSTRUCTNAME;

    ULONG AsULONG;

} PCI_EXPRESS_SEC_AER_CAPABILITIES, *PPCI_EXPRESS_SEC_AER_CAPABILITIES;

#define ROOT_CMD_ENABLE_CORRECTABLE_ERROR_REPORTING  0x00000001
#define ROOT_CMD_ENABLE_NONFATAL_ERROR_REPORTING     0x00000002
#define ROOT_CMD_ENABLE_FATAL_ERROR_REPORTING        0x00000004

#define ROOT_CMD_ERROR_REPORTING_ENABLE_MASK \
    (ROOT_CMD_ENABLE_FATAL_ERROR_REPORTING | \
     ROOT_CMD_ENABLE_NONFATAL_ERROR_REPORTING | \
     ROOT_CMD_ENABLE_CORRECTABLE_ERROR_REPORTING)

//
// Advanced Error Reporting Capability structure.
//

typedef struct _PCI_EXPRESS_AER_CAPABILITY {

    PCI_EXPRESS_ENHANCED_CAPABILITY_HEADER Header;
    
    PCI_EXPRESS_UNCORRECTABLE_ERROR_STATUS UncorrectableErrorStatus;
    PCI_EXPRESS_UNCORRECTABLE_ERROR_MASK UncorrectableErrorMask;
    PCI_EXPRESS_UNCORRECTABLE_ERROR_SEVERITY UncorrectableErrorSeverity;
    PCI_EXPRESS_CORRECTABLE_ERROR_STATUS CorrectableErrorStatus;
    PCI_EXPRESS_CORRECTABLE_ERROR_MASK CorrectableErrorMask;
    PCI_EXPRESS_AER_CAPABILITIES CapabilitiesAndControl;
    ULONG HeaderLog[4];
    PCI_EXPRESS_SEC_UNCORRECTABLE_ERROR_STATUS SecUncorrectableErrorStatus;
    PCI_EXPRESS_SEC_UNCORRECTABLE_ERROR_MASK SecUncorrectableErrorMask;
    PCI_EXPRESS_SEC_UNCORRECTABLE_ERROR_SEVERITY SecUncorrectableErrorSeverity;
    PCI_EXPRESS_SEC_AER_CAPABILITIES SecCapabilitiesAndControl;
    ULONG SecHeaderLog[4];

} PCI_EXPRESS_AER_CAPABILITY, *PPCI_EXPRESS_AER_CAPABILITY;

//
// Advanced Error Reporting Capability structure for root port.
//

typedef struct _PCI_EXPRESS_ROOTPORT_AER_CAPABILITY {

    PCI_EXPRESS_ENHANCED_CAPABILITY_HEADER Header;
    
    PCI_EXPRESS_UNCORRECTABLE_ERROR_STATUS UncorrectableErrorStatus;
    PCI_EXPRESS_UNCORRECTABLE_ERROR_MASK UncorrectableErrorMask;
    PCI_EXPRESS_UNCORRECTABLE_ERROR_SEVERITY UncorrectableErrorSeverity;
    PCI_EXPRESS_CORRECTABLE_ERROR_STATUS CorrectableErrorStatus;
    PCI_EXPRESS_CORRECTABLE_ERROR_MASK CorrectableErrorMask;
    PCI_EXPRESS_AER_CAPABILITIES CapabilitiesAndControl;
    ULONG HeaderLog[4];
    PCI_EXPRESS_ROOT_ERROR_COMMAND RootErrorCommand;
    PCI_EXPRESS_ROOT_ERROR_STATUS RootErrorStatus;
    PCI_EXPRESS_ERROR_SOURCE_ID ErrorSourceId;

} PCI_EXPRESS_ROOTPORT_AER_CAPABILITY, *PPCI_EXPRESS_ROOTPORT_AER_CAPABILITY;

//
// Advanced Error Reporting Capability structure for root port.
//

typedef struct _PCI_EXPRESS_BRIDGE_AER_CAPABILITY {

    PCI_EXPRESS_ENHANCED_CAPABILITY_HEADER Header;
    
    PCI_EXPRESS_UNCORRECTABLE_ERROR_STATUS UncorrectableErrorStatus;
    PCI_EXPRESS_UNCORRECTABLE_ERROR_MASK UncorrectableErrorMask;
    PCI_EXPRESS_UNCORRECTABLE_ERROR_SEVERITY UncorrectableErrorSeverity;
    PCI_EXPRESS_CORRECTABLE_ERROR_STATUS CorrectableErrorStatus;
    PCI_EXPRESS_CORRECTABLE_ERROR_MASK CorrectableErrorMask;
    PCI_EXPRESS_AER_CAPABILITIES CapabilitiesAndControl;
    ULONG HeaderLog[4];
    PCI_EXPRESS_SEC_UNCORRECTABLE_ERROR_STATUS SecUncorrectableErrorStatus;
    PCI_EXPRESS_SEC_UNCORRECTABLE_ERROR_MASK SecUncorrectableErrorMask;
    PCI_EXPRESS_SEC_UNCORRECTABLE_ERROR_SEVERITY SecUncorrectableErrorSeverity;
    PCI_EXPRESS_SEC_AER_CAPABILITIES SecCapabilitiesAndControl;
    ULONG SecHeaderLog[4];

} PCI_EXPRESS_BRIDGE_AER_CAPABILITY, *PPCI_EXPRESS_BRIDGE_AER_CAPABILITY;

//
// Base Class Code encodings for Base Class (from PCI spec rev 2.1).
//

#define PCI_CLASS_PRE_20                    0x00
#define PCI_CLASS_MASS_STORAGE_CTLR         0x01
#define PCI_CLASS_NETWORK_CTLR              0x02
#define PCI_CLASS_DISPLAY_CTLR              0x03
#define PCI_CLASS_MULTIMEDIA_DEV            0x04
#define PCI_CLASS_MEMORY_CTLR               0x05
#define PCI_CLASS_BRIDGE_DEV                0x06
#define PCI_CLASS_SIMPLE_COMMS_CTLR         0x07
#define PCI_CLASS_BASE_SYSTEM_DEV           0x08
#define PCI_CLASS_INPUT_DEV                 0x09
#define PCI_CLASS_DOCKING_STATION           0x0a
#define PCI_CLASS_PROCESSOR                 0x0b
#define PCI_CLASS_SERIAL_BUS_CTLR           0x0c
#define PCI_CLASS_WIRELESS_CTLR             0x0d
#define PCI_CLASS_INTELLIGENT_IO_CTLR       0x0e
#define PCI_CLASS_SATELLITE_COMMS_CTLR      0x0f
#define PCI_CLASS_ENCRYPTION_DECRYPTION     0x10
#define PCI_CLASS_DATA_ACQ_SIGNAL_PROC      0x11

// 0d thru fe reserved

#define PCI_CLASS_NOT_DEFINED               0xff

//
// Sub Class Code encodings (PCI rev 2.1).
//

// Class 00 - PCI_CLASS_PRE_20

#define PCI_SUBCLASS_PRE_20_NON_VGA         0x00
#define PCI_SUBCLASS_PRE_20_VGA             0x01

// Class 01 - PCI_CLASS_MASS_STORAGE_CTLR

#define PCI_SUBCLASS_MSC_SCSI_BUS_CTLR      0x00
#define PCI_SUBCLASS_MSC_IDE_CTLR           0x01
#define PCI_SUBCLASS_MSC_FLOPPY_CTLR        0x02
#define PCI_SUBCLASS_MSC_IPI_CTLR           0x03
#define PCI_SUBCLASS_MSC_RAID_CTLR          0x04
#define PCI_SUBCLASS_MSC_OTHER              0x80

// Class 02 - PCI_CLASS_NETWORK_CTLR

#define PCI_SUBCLASS_NET_ETHERNET_CTLR      0x00
#define PCI_SUBCLASS_NET_TOKEN_RING_CTLR    0x01
#define PCI_SUBCLASS_NET_FDDI_CTLR          0x02
#define PCI_SUBCLASS_NET_ATM_CTLR           0x03
#define PCI_SUBCLASS_NET_ISDN_CTLR          0x04
#define PCI_SUBCLASS_NET_OTHER              0x80

// Class 03 - PCI_CLASS_DISPLAY_CTLR

// N.B. Sub Class 00 could be VGA or 8514 depending on Interface byte

#define PCI_SUBCLASS_VID_VGA_CTLR           0x00
#define PCI_SUBCLASS_VID_XGA_CTLR           0x01
#define PCI_SUBLCASS_VID_3D_CTLR            0x02
#define PCI_SUBCLASS_VID_OTHER              0x80

// Class 04 - PCI_CLASS_MULTIMEDIA_DEV

#define PCI_SUBCLASS_MM_VIDEO_DEV           0x00
#define PCI_SUBCLASS_MM_AUDIO_DEV           0x01
#define PCI_SUBCLASS_MM_TELEPHONY_DEV       0x02
#define PCI_SUBCLASS_MM_OTHER               0x80

// Class 05 - PCI_CLASS_MEMORY_CTLR

#define PCI_SUBCLASS_MEM_RAM                0x00
#define PCI_SUBCLASS_MEM_FLASH              0x01
#define PCI_SUBCLASS_MEM_OTHER              0x80

// Class 06 - PCI_CLASS_BRIDGE_DEV

#define PCI_SUBCLASS_BR_HOST                0x00
#define PCI_SUBCLASS_BR_ISA                 0x01
#define PCI_SUBCLASS_BR_EISA                0x02
#define PCI_SUBCLASS_BR_MCA                 0x03
#define PCI_SUBCLASS_BR_PCI_TO_PCI          0x04
#define PCI_SUBCLASS_BR_PCMCIA              0x05
#define PCI_SUBCLASS_BR_NUBUS               0x06
#define PCI_SUBCLASS_BR_CARDBUS             0x07
#define PCI_SUBCLASS_BR_RACEWAY             0x08
#define PCI_SUBCLASS_BR_OTHER               0x80

// Class 07 - PCI_CLASS_SIMPLE_COMMS_CTLR

// N.B. Sub Class 00 and 01 additional info in Interface byte

#define PCI_SUBCLASS_COM_SERIAL             0x00
#define PCI_SUBCLASS_COM_PARALLEL           0x01
#define PCI_SUBCLASS_COM_MULTIPORT          0x02
#define PCI_SUBCLASS_COM_MODEM              0x03
#define PCI_SUBCLASS_COM_OTHER              0x80

// Class 08 - PCI_CLASS_BASE_SYSTEM_DEV

// N.B. See Interface byte for additional info.

#define PCI_SUBCLASS_SYS_INTERRUPT_CTLR     0x00
#define PCI_SUBCLASS_SYS_DMA_CTLR           0x01
#define PCI_SUBCLASS_SYS_SYSTEM_TIMER       0x02
#define PCI_SUBCLASS_SYS_REAL_TIME_CLOCK    0x03
#define PCI_SUBCLASS_SYS_GEN_HOTPLUG_CTLR   0x04
#define PCI_SUBCLASS_SYS_SDIO_CTRL          0x05
#define PCI_SUBCLASS_SYS_OTHER              0x80

// Class 09 - PCI_CLASS_INPUT_DEV

#define PCI_SUBCLASS_INP_KEYBOARD           0x00
#define PCI_SUBCLASS_INP_DIGITIZER          0x01
#define PCI_SUBCLASS_INP_MOUSE              0x02
#define PCI_SUBCLASS_INP_SCANNER            0x03
#define PCI_SUBCLASS_INP_GAMEPORT           0x04
#define PCI_SUBCLASS_INP_OTHER              0x80

// Class 0a - PCI_CLASS_DOCKING_STATION

#define PCI_SUBCLASS_DOC_GENERIC            0x00
#define PCI_SUBCLASS_DOC_OTHER              0x80

// Class 0b - PCI_CLASS_PROCESSOR

#define PCI_SUBCLASS_PROC_386               0x00
#define PCI_SUBCLASS_PROC_486               0x01
#define PCI_SUBCLASS_PROC_PENTIUM           0x02
#define PCI_SUBCLASS_PROC_ALPHA             0x10
#define PCI_SUBCLASS_PROC_POWERPC           0x20
#define PCI_SUBCLASS_PROC_COPROCESSOR       0x40

// Class 0c - PCI_CLASS_SERIAL_BUS_CTLR

#define PCI_SUBCLASS_SB_IEEE1394            0x00
#define PCI_SUBCLASS_SB_ACCESS              0x01
#define PCI_SUBCLASS_SB_SSA                 0x02
#define PCI_SUBCLASS_SB_USB                 0x03
#define PCI_SUBCLASS_SB_FIBRE_CHANNEL       0x04
#define PCI_SUBCLASS_SB_SMBUS               0x05

// Class 0d - PCI_CLASS_WIRELESS_CTLR

#define PCI_SUBCLASS_WIRELESS_IRDA          0x00
#define PCI_SUBCLASS_WIRELESS_CON_IR        0x01
#define PCI_SUBCLASS_WIRELESS_RF            0x10
#define PCI_SUBCLASS_WIRELESS_OTHER         0x80

// Class 0e - PCI_CLASS_INTELLIGENT_IO_CTLR

#define PCI_SUBCLASS_INTIO_I2O              0x00

// Class 0f - PCI_CLASS_SATELLITE_CTLR

#define PCI_SUBCLASS_SAT_TV                 0x01
#define PCI_SUBCLASS_SAT_AUDIO              0x02
#define PCI_SUBCLASS_SAT_VOICE              0x03
#define PCI_SUBCLASS_SAT_DATA               0x04

// Class 10 - PCI_CLASS_ENCRYPTION_DECRYPTION

#define PCI_SUBCLASS_CRYPTO_NET_COMP        0x00
#define PCI_SUBCLASS_CRYPTO_ENTERTAINMENT   0x10
#define PCI_SUBCLASS_CRYPTO_OTHER           0x80

// Class 11 - PCI_CLASS_DATA_ACQ_SIGNAL_PROC

#define PCI_SUBCLASS_DASP_DPIO              0x00
#define PCI_SUBCLASS_DASP_OTHER             0x80



//
// Bit encodes for PCI_COMMON_CONFIG.u.type0.BaseAddresses
//

#define PCI_ADDRESS_IO_SPACE                0x00000001  // (ro)
#define PCI_ADDRESS_MEMORY_TYPE_MASK        0x00000006  // (ro)
#define PCI_ADDRESS_MEMORY_PREFETCHABLE     0x00000008  // (ro)

#define PCI_ADDRESS_IO_ADDRESS_MASK         0xfffffffc
#define PCI_ADDRESS_MEMORY_ADDRESS_MASK     0xfffffff0
#define PCI_ADDRESS_ROM_ADDRESS_MASK        0xfffff800

#define PCI_TYPE_32BIT      0
#define PCI_TYPE_20BIT      2
#define PCI_TYPE_64BIT      4

//
// Bit encodes for PCI_COMMON_CONFIG.u.type0.ROMBaseAddresses
//

#define PCI_ROMADDRESS_ENABLED              0x00000001


//
// Reference notes for PCI configuration fields:
//
// ro   these field are read only.  changes to these fields are ignored
//
// ro+  these field are intended to be read only and should be initialized
//      by the system to their proper values.  However, driver may change
//      these settings.
//
// ---
//
//      All resources comsumed by a PCI device start as unitialized
//      under NT.  An uninitialized memory or I/O base address can be
//      determined by checking it's corrisponding enabled bit in the
//      PCI_COMMON_CONFIG.Command value.  An InterruptLine is unitialized
//      if it contains the value of -1.
//


#endif // _PCI_X_


//
// Device Presence interface
//
#define PCI_DEVICE_PRESENT_INTERFACE_VERSION 1

//
// Flags for PCI_DEVICE_PRESENCE_PARAMETERS
//
#define PCI_USE_SUBSYSTEM_IDS   0x00000001
#define PCI_USE_REVISION        0x00000002
// The following flags are only valid for IsDevicePresentEx
#define PCI_USE_VENDEV_IDS      0x00000004
#define PCI_USE_CLASS_SUBCLASS  0x00000008
#define PCI_USE_PROGIF          0x00000010
#define PCI_USE_LOCAL_BUS       0x00000020
#define PCI_USE_LOCAL_DEVICE    0x00000040

//
// Search parameters structure for IsDevicePresentEx
//
typedef struct _PCI_DEVICE_PRESENCE_PARAMETERS {
    
    ULONG Size;
    ULONG Flags;

    USHORT VendorID;
    USHORT DeviceID;
    UCHAR RevisionID;
    USHORT SubVendorID;
    USHORT SubSystemID;
    UCHAR BaseClass;
    UCHAR SubClass;
    UCHAR ProgIf;

} PCI_DEVICE_PRESENCE_PARAMETERS, *PPCI_DEVICE_PRESENCE_PARAMETERS;

typedef
BOOLEAN
(*PPCI_IS_DEVICE_PRESENT) (
    IN USHORT VendorID,
    IN USHORT DeviceID,
    IN UCHAR RevisionID,
    IN USHORT SubVendorID,
    IN USHORT SubSystemID,
    IN ULONG Flags
);

typedef
BOOLEAN
(*PPCI_IS_DEVICE_PRESENT_EX) (
    IN PVOID Context,
    IN PPCI_DEVICE_PRESENCE_PARAMETERS Parameters
    );

typedef struct _PCI_DEVICE_PRESENT_INTERFACE {
    //
    // generic interface header
    //
    USHORT Size;
    USHORT Version;
    PVOID Context;
    PINTERFACE_REFERENCE InterfaceReference;
    PINTERFACE_DEREFERENCE InterfaceDereference;
    //
    // pci device info
    //
    PPCI_IS_DEVICE_PRESENT IsDevicePresent;
    
    PPCI_IS_DEVICE_PRESENT_EX IsDevicePresentEx;

} PCI_DEVICE_PRESENT_INTERFACE, *PPCI_DEVICE_PRESENT_INTERFACE;

//
// Pci Express Link Quiesce Interface
//

#define PCI_EXPRESS_LINK_QUIESCENT_INTERFACE_VERSION      1

typedef
NTSTATUS
(*PPCI_EXPRESS_ENTER_LINK_QUIESCENT_MODE) (
    __in PVOID Context
    );

typedef
NTSTATUS
(*PPCI_EXPRESS_EXIT_LINK_QUIESCENT_MODE) (
    __in PVOID Context
    );

typedef struct _PCI_EXPRESS_LINK_QUIESCENT_INTERFACE {

    USHORT Size;
    USHORT Version;
    PVOID Context;
    PINTERFACE_REFERENCE InterfaceReference;
    PINTERFACE_DEREFERENCE InterfaceDereference;
    
    PPCI_EXPRESS_ENTER_LINK_QUIESCENT_MODE PciExpressEnterLinkQuiescentMode;
    PPCI_EXPRESS_EXIT_LINK_QUIESCENT_MODE PciExpressExitLinkQuiescentMode;

} PCI_EXPRESS_LINK_QUIESCENT_INTERFACE, *PPCI_EXPRESS_LINK_QUIESCENT_INTERFACE;

//
// Pci Express Root Port Access Interface
//

#define PCI_EXPRESS_ROOT_PORT_INTERFACE_VERSION        1

typedef
ULONG
(*PPCI_EXPRESS_ROOT_PORT_READ_CONFIG_SPACE) (
    __in PVOID Context,
    __out PVOID Buffer,
    __in ULONG Offset,
    __in ULONG Length
    );
    
typedef
ULONG
(*PPCI_EXPRESS_ROOT_PORT_WRITE_CONFIG_SPACE) (
    __in PVOID Context,
    __in PVOID Buffer,
    __in ULONG Offset,
    __in ULONG Length
    );

typedef struct _PCI_EXPRESS_ROOT_PORT_INTERFACE {

    USHORT Size;
    USHORT Version;
    PVOID Context;
    PINTERFACE_REFERENCE InterfaceReference;
    PINTERFACE_DEREFERENCE InterfaceDereference;

    PPCI_EXPRESS_ROOT_PORT_READ_CONFIG_SPACE ReadConfigSpace;
    PPCI_EXPRESS_ROOT_PORT_WRITE_CONFIG_SPACE WriteConfigSpace;

} PCI_EXPRESS_ROOT_PORT_INTERFACE, *PPCI_EXPRESS_ROOT_PORT_INTERFACE;

//
// MSI-X interrupt table configuration interface
//

#define PCI_MSIX_TABLE_CONFIG_INTERFACE_VERSION 1

typedef
NTSTATUS
(*PPCI_MSIX_SET_ENTRY) (
    __in PVOID Context,
    __in ULONG TableEntry,  
    __in ULONG MessageNumber
    );

typedef
NTSTATUS
(*PPCI_MSIX_MASKUNMASK_ENTRY) (
    __in PVOID Context,
    __in ULONG TableEntry
    );

typedef struct _PCI_MSIX_TABLE_CONFIG_INTERFACE {
    USHORT Size;
    USHORT Version;
    PVOID Context;
    PINTERFACE_REFERENCE InterfaceReference;
    PINTERFACE_DEREFERENCE InterfaceDereference;

    PPCI_MSIX_SET_ENTRY SetTableEntry;
    PPCI_MSIX_MASKUNMASK_ENTRY MaskTableEntry;
    PPCI_MSIX_MASKUNMASK_ENTRY UnmaskTableEntry;
} PCI_MSIX_TABLE_CONFIG_INTERFACE, *PPCI_MSIX_TABLE_CONFIG_INTERFACE;

#if (NTDDI_VERSION >= NTDDI_WIN2K)
NTSYSAPI
NTSTATUS
NTAPI
ZwCreateFile(
    __out PHANDLE FileHandle,
    __in ACCESS_MASK DesiredAccess,
    __in POBJECT_ATTRIBUTES ObjectAttributes,
    __out PIO_STATUS_BLOCK IoStatusBlock,
    __in_opt PLARGE_INTEGER AllocationSize,
    __in ULONG FileAttributes,
    __in ULONG ShareAccess,
    __in ULONG CreateDisposition,
    __in ULONG CreateOptions,
    __in_bcount_opt(EaLength) PVOID EaBuffer,
    __in ULONG EaLength
    );
#endif

#if (NTDDI_VERSION >= NTDDI_WIN2K)
NTSYSAPI
NTSTATUS
NTAPI
ZwOpenFile(
    __out PHANDLE FileHandle,
    __in ACCESS_MASK DesiredAccess,
    __in POBJECT_ATTRIBUTES ObjectAttributes,
    __out PIO_STATUS_BLOCK IoStatusBlock,
    __in ULONG ShareAccess,
    __in ULONG OpenOptions
    );
#endif

#if (NTDDI_VERSION >= NTDDI_WIN2K)
NTSYSAPI
NTSTATUS
NTAPI
ZwLoadDriver(
    __in PUNICODE_STRING DriverServiceName
    );
#endif

#if (NTDDI_VERSION >= NTDDI_WIN2K)
NTSYSAPI
NTSTATUS
NTAPI
ZwUnloadDriver(
    __in PUNICODE_STRING DriverServiceName
    );
#endif

#if (NTDDI_VERSION >= NTDDI_WIN2K)
NTSYSAPI
NTSTATUS
NTAPI
ZwQueryInformationFile(
    __in HANDLE FileHandle,
    __out PIO_STATUS_BLOCK IoStatusBlock,
    __out_bcount(Length) PVOID FileInformation,
    __in ULONG Length,
    __in FILE_INFORMATION_CLASS FileInformationClass
    );
#endif

#if (NTDDI_VERSION >= NTDDI_WIN2K)
NTSYSAPI
NTSTATUS
NTAPI
ZwSetInformationFile(
    __in HANDLE FileHandle,
    __out PIO_STATUS_BLOCK IoStatusBlock,
    __in_bcount(Length) PVOID FileInformation,
    __in ULONG Length,
    __in FILE_INFORMATION_CLASS FileInformationClass
    );
#endif

#if (NTDDI_VERSION >= NTDDI_WIN2K)
NTSYSAPI
NTSTATUS
NTAPI
ZwReadFile(
    __in HANDLE FileHandle,
    __in_opt HANDLE Event,
    __in_opt PIO_APC_ROUTINE ApcRoutine,
    __in_opt PVOID ApcContext,
    __out PIO_STATUS_BLOCK IoStatusBlock,
    __out_bcount(Length) PVOID Buffer,
    __in ULONG Length,
    __in_opt PLARGE_INTEGER ByteOffset,
    __in_opt PULONG Key
    );
#endif

#if (NTDDI_VERSION >= NTDDI_WIN2K)
NTSYSAPI
NTSTATUS
NTAPI
ZwWriteFile(
    __in HANDLE FileHandle,
    __in_opt HANDLE Event,
    __in_opt PIO_APC_ROUTINE ApcRoutine,
    __in_opt PVOID ApcContext,
    __out PIO_STATUS_BLOCK IoStatusBlock,
    __in_bcount(Length) PVOID Buffer,
    __in ULONG Length,
    __in_opt PLARGE_INTEGER ByteOffset,
    __in_opt PULONG Key
    );
#endif

#if (NTDDI_VERSION >= NTDDI_WIN2K)
NTSYSAPI
NTSTATUS
NTAPI
ZwClose(
    __in HANDLE Handle
    );
#endif

#if (NTDDI_VERSION >= NTDDI_WIN2K)
NTSYSAPI
NTSTATUS
NTAPI
ZwCreateDirectoryObject(
    __out PHANDLE DirectoryHandle,
    __in ACCESS_MASK DesiredAccess,
    __in POBJECT_ATTRIBUTES ObjectAttributes
    );
#endif

#if (NTDDI_VERSION >= NTDDI_WIN2K)
NTSYSAPI
NTSTATUS
NTAPI
ZwMakeTemporaryObject(
    __in HANDLE Handle
    );
#endif

#if (NTDDI_VERSION >= NTDDI_WIN2K)
NTSYSAPI
NTSTATUS
NTAPI
ZwCreateSection (
    __out PHANDLE SectionHandle,
    __in ACCESS_MASK DesiredAccess,
    __in_opt POBJECT_ATTRIBUTES ObjectAttributes,
    __in_opt PLARGE_INTEGER MaximumSize,
    __in ULONG SectionPageProtection,
    __in ULONG AllocationAttributes,
    __in_opt HANDLE FileHandle
    );
#endif

#if (NTDDI_VERSION >= NTDDI_WIN2K)
NTSYSAPI
NTSTATUS
NTAPI
ZwOpenSection(
    __out PHANDLE SectionHandle,
    __in ACCESS_MASK DesiredAccess,
    __in POBJECT_ATTRIBUTES ObjectAttributes
    );
#endif

#if (NTDDI_VERSION >= NTDDI_WIN2K)
NTSYSAPI
NTSTATUS
NTAPI
ZwMapViewOfSection(
    __in HANDLE SectionHandle,
    __in HANDLE ProcessHandle,
    __inout PVOID *BaseAddress,
    __in ULONG_PTR ZeroBits,
    __in SIZE_T CommitSize,
    __inout_opt PLARGE_INTEGER SectionOffset,
    __inout PSIZE_T ViewSize,
    __in SECTION_INHERIT InheritDisposition,
    __in ULONG AllocationType,
    __in ULONG Win32Protect
    );
#endif

#if (NTDDI_VERSION >= NTDDI_WIN2K)
NTSYSAPI
NTSTATUS
NTAPI
ZwUnmapViewOfSection(
    __in HANDLE ProcessHandle,
    __in_opt PVOID BaseAddress
    );
#endif

#if (NTDDI_VERSION >= NTDDI_WIN2K)
NTSYSAPI
NTSTATUS
NTAPI
ZwCreateKey(
    __out PHANDLE KeyHandle,
    __in ACCESS_MASK DesiredAccess,
    __in POBJECT_ATTRIBUTES ObjectAttributes,
    __reserved ULONG TitleIndex,
    __in_opt PUNICODE_STRING Class,
    __in ULONG CreateOptions,
    __out_opt PULONG Disposition
    );
#endif

#if (NTDDI_VERSION >= NTDDI_VISTA)
NTSYSAPI
NTSTATUS
ZwCreateKeyTransacted(
    __out PHANDLE KeyHandle,
    __in ACCESS_MASK DesiredAccess,
    __in POBJECT_ATTRIBUTES ObjectAttributes,
    __reserved ULONG TitleIndex,
    __in_opt PUNICODE_STRING Class,
    __in ULONG CreateOptions,
    __in HANDLE TransactionHandle,
    __out_opt PULONG Disposition
    );
#endif

#if (NTDDI_VERSION >= NTDDI_WIN2K)
NTSYSAPI
NTSTATUS
NTAPI
ZwOpenKey(
    __out PHANDLE KeyHandle,
    __in ACCESS_MASK DesiredAccess,
    __in POBJECT_ATTRIBUTES ObjectAttributes
    );
#endif

#if (NTDDI_VERSION >= NTDDI_VISTA)
NTSYSAPI
NTSTATUS
ZwOpenKeyTransacted(
    __out PHANDLE KeyHandle,
    __in ACCESS_MASK DesiredAccess,
    __in POBJECT_ATTRIBUTES ObjectAttributes,
    __in HANDLE TransactionHandle
    );
#endif


#if (NTDDI_VERSION >= NTDDI_WIN2K)
NTSYSAPI
NTSTATUS
NTAPI
ZwDeleteKey(
    __in HANDLE KeyHandle
    );
#endif

#if (NTDDI_VERSION >= NTDDI_WIN2K)
NTSYSAPI
NTSTATUS
NTAPI
ZwDeleteValueKey(
    __in HANDLE KeyHandle,
    __in PUNICODE_STRING ValueName
    );
#endif

#if (NTDDI_VERSION >= NTDDI_WIN2K)
NTSYSAPI
NTSTATUS
NTAPI
ZwEnumerateKey(
    __in HANDLE KeyHandle,
    __in ULONG Index,
    __in KEY_INFORMATION_CLASS KeyInformationClass,
    __out_bcount_opt(Length) PVOID KeyInformation,
    __in ULONG Length,
    __out PULONG ResultLength
    );
#endif

#if (NTDDI_VERSION >= NTDDI_WIN2K)
NTSYSAPI
NTSTATUS
NTAPI
ZwEnumerateValueKey(
    __in HANDLE KeyHandle,
    __in ULONG Index,
    __in KEY_VALUE_INFORMATION_CLASS KeyValueInformationClass,
    __out_bcount_opt(Length) PVOID KeyValueInformation,
    __in ULONG Length,
    __out PULONG ResultLength
    );
#endif

#if (NTDDI_VERSION >= NTDDI_WIN2K)
NTSYSAPI
NTSTATUS
NTAPI
ZwFlushKey(
    __in HANDLE KeyHandle
    );
#endif

#if (NTDDI_VERSION >= NTDDI_WIN2K)
NTSYSAPI
NTSTATUS
NTAPI
ZwQueryKey(
    __in HANDLE KeyHandle,
    __in KEY_INFORMATION_CLASS KeyInformationClass,
    __out_bcount_opt(Length) PVOID KeyInformation,
    __in ULONG Length,
    __out PULONG ResultLength
    );
#endif

#if (NTDDI_VERSION >= NTDDI_WIN2K)
NTSYSAPI
NTSTATUS
NTAPI
ZwQueryValueKey(
    __in HANDLE KeyHandle,
    __in PUNICODE_STRING ValueName,
    __in KEY_VALUE_INFORMATION_CLASS KeyValueInformationClass,
    __out_bcount_opt(Length) PVOID KeyValueInformation,
    __in ULONG Length,
    __out PULONG ResultLength
    );
#endif

#if (NTDDI_VERSION >= NTDDI_WIN2K)
NTSYSAPI
NTSTATUS
NTAPI
ZwSetValueKey(
    __in HANDLE KeyHandle,
    __in PUNICODE_STRING ValueName,
    __in_opt ULONG TitleIndex,
    __in ULONG Type,
    __in_bcount_opt(DataSize) PVOID Data,
    __in ULONG DataSize
    );
#endif

#if (NTDDI_VERSION >= NTDDI_WIN2K)
NTSYSAPI
NTSTATUS
NTAPI
ZwOpenSymbolicLinkObject(
    __out PHANDLE LinkHandle,
    __in ACCESS_MASK DesiredAccess,
    __in POBJECT_ATTRIBUTES ObjectAttributes
    );
#endif

#if (NTDDI_VERSION >= NTDDI_WIN2K)
NTSYSAPI
NTSTATUS
NTAPI
ZwQuerySymbolicLinkObject(
    __in HANDLE LinkHandle,
    __inout PUNICODE_STRING LinkTarget,
    __out_opt PULONG ReturnedLength
    );
#endif

 #if (NTDDI_VERSION >= NTDDI_VISTA)
NTSYSCALLAPI
NTSTATUS
NTAPI
ZwCreateTransactionManager (
    __out PHANDLE TmHandle,
    __in ACCESS_MASK DesiredAccess,
    __in_opt POBJECT_ATTRIBUTES ObjectAttributes,
    __in_opt PUNICODE_STRING LogFileName,
    __in_opt ULONG CreateOptions,
    __in_opt ULONG CommitStrength
    );
#endif

#if (NTDDI_VERSION >= NTDDI_VISTA)
NTSYSCALLAPI
NTSTATUS
NTAPI
ZwOpenTransactionManager (
    __out PHANDLE TmHandle,
    __in ACCESS_MASK DesiredAccess,
    __in_opt POBJECT_ATTRIBUTES ObjectAttributes,
    __in_opt PUNICODE_STRING LogFileName,
    __in_opt LPGUID TmIdentity,
    __in_opt ULONG OpenOptions
    );
#endif


#if (NTDDI_VERSION >= NTDDI_VISTA)
NTSYSCALLAPI
NTSTATUS
NTAPI
ZwRollforwardTransactionManager (
    __in HANDLE TransactionManagerHandle,
    __in_opt PLARGE_INTEGER TmVirtualClock
    );
#endif

#if (NTDDI_VERSION >= NTDDI_VISTA)
NTSYSCALLAPI
NTSTATUS
NTAPI
ZwRecoverTransactionManager (
    __in HANDLE TransactionManagerHandle
    );
#endif

#if (NTDDI_VERSION >= NTDDI_VISTA)
NTSYSCALLAPI
NTSTATUS
NTAPI
ZwQueryInformationTransactionManager (
    __in HANDLE TransactionManagerHandle,
    __in TRANSACTIONMANAGER_INFORMATION_CLASS TransactionManagerInformationClass,
    __out_bcount(TransactionManagerInformationLength) PVOID TransactionManagerInformation,
    __in ULONG TransactionManagerInformationLength,
    __out_opt PULONG ReturnLength
    );
#endif

#if (NTDDI_VERSION >= NTDDI_VISTA)
NTSYSCALLAPI
NTSTATUS
NTAPI
ZwSetInformationTransactionManager (
    __in HANDLE TmHandle,
    __in TRANSACTIONMANAGER_INFORMATION_CLASS TransactionManagerInformationClass,
    __in PVOID TransactionManagerInformation,
    __in ULONG TransactionManagerInformationLength
    );
#endif

#if (NTDDI_VERSION >= NTDDI_VISTA)
NTSYSCALLAPI
NTSTATUS
NTAPI
ZwEnumerateTransactionObject (
    __in_opt HANDLE            RootObjectHandle,
    __in     KTMOBJECT_TYPE    QueryType,
    __inout_bcount(ObjectCursorLength) PKTMOBJECT_CURSOR ObjectCursor,
    __in     ULONG             ObjectCursorLength,
    __out    PULONG            ReturnLength
    );
#endif

#if (NTDDI_VERSION >= NTDDI_VISTA)
NTSYSCALLAPI
NTSTATUS
NTAPI
ZwCreateTransaction (
    __out PHANDLE TransactionHandle,
    __in ACCESS_MASK DesiredAccess,
    __in_opt POBJECT_ATTRIBUTES ObjectAttributes,
    __in_opt LPGUID Uow,
    __in_opt HANDLE TmHandle,
    __in_opt ULONG CreateOptions,
    __in_opt ULONG IsolationLevel,
    __in_opt ULONG IsolationFlags,
    __in_opt PLARGE_INTEGER Timeout,
    __in_opt PUNICODE_STRING Description
    );
#endif

#if (NTDDI_VERSION >= NTDDI_VISTA)
NTSYSCALLAPI
NTSTATUS
NTAPI
ZwOpenTransaction (
    __out PHANDLE TransactionHandle,
    __in ACCESS_MASK DesiredAccess,
    __in_opt POBJECT_ATTRIBUTES ObjectAttributes,
    __in LPGUID Uow,
    __in_opt HANDLE TmHandle
    );
#endif

#if (NTDDI_VERSION >= NTDDI_VISTA)
NTSYSCALLAPI
NTSTATUS
NTAPI
ZwQueryInformationTransaction (
    __in HANDLE TransactionHandle,
    __in TRANSACTION_INFORMATION_CLASS TransactionInformationClass,
    __out_bcount(TransactionInformationLength) PVOID TransactionInformation,
    __in ULONG TransactionInformationLength,
    __out_opt PULONG ReturnLength
    );
#endif

#if (NTDDI_VERSION >= NTDDI_VISTA)
NTSYSCALLAPI
NTSTATUS
NTAPI
ZwSetInformationTransaction (
    __in HANDLE TransactionHandle,
    __in TRANSACTION_INFORMATION_CLASS TransactionInformationClass,
    __in PVOID TransactionInformation,
    __in ULONG TransactionInformationLength
    );
#endif

#if (NTDDI_VERSION >= NTDDI_VISTA)
NTSYSCALLAPI
NTSTATUS
NTAPI
ZwCommitTransaction (
    __in HANDLE  TransactionHandle,
    __in BOOLEAN Wait
    );
#endif

#if (NTDDI_VERSION >= NTDDI_VISTA)
NTSYSCALLAPI
NTSTATUS
NTAPI
ZwRollbackTransaction (
    __in HANDLE  TransactionHandle,
    __in BOOLEAN Wait
    );
#endif

#if (NTDDI_VERSION >= NTDDI_VISTA)
NTSYSCALLAPI
NTSTATUS
NTAPI
ZwCreateResourceManager (
    __out PHANDLE ResourceManagerHandle,
    __in ACCESS_MASK DesiredAccess,
    __in HANDLE TmHandle,
    __in_opt LPGUID ResourceManagerGuid,
    __in_opt POBJECT_ATTRIBUTES ObjectAttributes,
    __in_opt ULONG CreateOptions,
    __in_opt PUNICODE_STRING Description
    );
#endif

#if (NTDDI_VERSION >= NTDDI_VISTA)
NTSYSCALLAPI
NTSTATUS
NTAPI
ZwOpenResourceManager (
    __out PHANDLE ResourceManagerHandle,
    __in ACCESS_MASK DesiredAccess,
    __in HANDLE TmHandle,
    __in LPGUID ResourceManagerGuid,
    __in_opt POBJECT_ATTRIBUTES ObjectAttributes
    );
#endif

#if (NTDDI_VERSION >= NTDDI_VISTA)
NTSYSCALLAPI
NTSTATUS
NTAPI
ZwRecoverResourceManager (
    __in HANDLE ResourceManagerHandle
    );
#endif

#if (NTDDI_VERSION >= NTDDI_VISTA)
NTSYSCALLAPI
NTSTATUS
NTAPI
ZwGetNotificationResourceManager (
    __in HANDLE             ResourceManagerHandle,
    __out PTRANSACTION_NOTIFICATION TransactionNotification,
    __in ULONG              NotificationLength,
    __in PLARGE_INTEGER         Timeout,
    __out_opt PULONG                    ReturnLength,
    __in ULONG                          Asynchronous,
    __in_opt ULONG_PTR                  AsynchronousContext
    );
#endif

#if (NTDDI_VERSION >= NTDDI_VISTA)
NTSYSCALLAPI
NTSTATUS
NTAPI
ZwQueryInformationResourceManager (
    __in HANDLE ResourceManagerHandle,
    __in RESOURCEMANAGER_INFORMATION_CLASS ResourceManagerInformationClass,
    __out_bcount(ResourceManagerInformationLength) PVOID ResourceManagerInformation,
    __in ULONG ResourceManagerInformationLength,
    __out_opt PULONG ReturnLength
    );
#endif

#if (NTDDI_VERSION >= NTDDI_VISTA)
NTSYSCALLAPI
NTSTATUS
NTAPI
ZwSetInformationResourceManager (
    __in HANDLE ResourceManagerHandle,
    __in RESOURCEMANAGER_INFORMATION_CLASS ResourceManagerInformationClass,
    __in PVOID ResourceManagerInformation,
    __in_bcount(ResourceManagerInformation) ULONG ResourceManagerInformationLength
    );
#endif

#if (NTDDI_VERSION >= NTDDI_VISTA)
NTSYSCALLAPI
NTSTATUS
NTAPI
ZwCreateEnlistment (
    __out PHANDLE EnlistmentHandle,
    __in ACCESS_MASK DesiredAccess,
    __in HANDLE ResourceManagerHandle,
    __in HANDLE TransactionHandle,
    __in_opt POBJECT_ATTRIBUTES ObjectAttributes,
    __in_opt ULONG CreateOptions,
    __in NOTIFICATION_MASK NotificationMask,
    __in_opt PVOID EnlistmentKey
    );
#endif

#if (NTDDI_VERSION >= NTDDI_VISTA)
NTSYSCALLAPI
NTSTATUS
NTAPI
ZwOpenEnlistment (
    __out PHANDLE EnlistmentHandle,
    __in ACCESS_MASK DesiredAccess,
    __in HANDLE RmHandle,
    __in LPGUID EnlistmentGuid,
    __in_opt POBJECT_ATTRIBUTES ObjectAttributes
    );
#endif

#if (NTDDI_VERSION >= NTDDI_VISTA)
NTSYSCALLAPI
NTSTATUS
NTAPI
ZwQueryInformationEnlistment (
    __in HANDLE EnlistmentHandle,
    __in ENLISTMENT_INFORMATION_CLASS EnlistmentInformationClass,
    __out_bcount(EnlistmentInformationLength) PVOID EnlistmentInformation,
    __in ULONG EnlistmentInformationLength,
    __out_opt PULONG ReturnLength
    );
#endif

#if (NTDDI_VERSION >= NTDDI_VISTA)
NTSYSCALLAPI
NTSTATUS
NTAPI
ZwSetInformationEnlistment (
    __in HANDLE EnlistmentHandle,
    __in ENLISTMENT_INFORMATION_CLASS EnlistmentInformationClass,
    __in_bcount(EnlistmentInformationLength) PVOID EnlistmentInformation,
    __in ULONG EnlistmentInformationLength
    );
#endif

#if (NTDDI_VERSION >= NTDDI_VISTA)
NTSYSCALLAPI
NTSTATUS
NTAPI
ZwRecoverEnlistment (
    __in HANDLE EnlistmentHandle,
    __in_opt PVOID EnlistmentKey
    );
#endif

#if (NTDDI_VERSION >= NTDDI_VISTA)
NTSYSCALLAPI
NTSTATUS
NTAPI
ZwPrePrepareEnlistment (
    __in HANDLE EnlistmentHandle,
    __in_opt PLARGE_INTEGER TmVirtualClock
    );
#endif

#if (NTDDI_VERSION >= NTDDI_VISTA)
NTSYSCALLAPI
NTSTATUS
NTAPI
ZwPrepareEnlistment (
    __in HANDLE EnlistmentHandle,
    __in_opt PLARGE_INTEGER TmVirtualClock
    );
#endif

#if (NTDDI_VERSION >= NTDDI_VISTA)
NTSYSCALLAPI
NTSTATUS
NTAPI
ZwCommitEnlistment (
    __in HANDLE EnlistmentHandle,
    __in_opt PLARGE_INTEGER TmVirtualClock
    );
#endif

#if (NTDDI_VERSION >= NTDDI_VISTA)
NTSYSCALLAPI
NTSTATUS
NTAPI
ZwRollbackEnlistment (
    __in HANDLE EnlistmentHandle,
    __in_opt PLARGE_INTEGER TmVirtualClock
    );
#endif

#if (NTDDI_VERSION >= NTDDI_VISTA)
NTSYSCALLAPI
NTSTATUS
NTAPI
ZwPrePrepareComplete (
    __in HANDLE            EnlistmentHandle,
    __in_opt PLARGE_INTEGER TmVirtualClock
    );
#endif

#if (NTDDI_VERSION >= NTDDI_VISTA)
NTSYSCALLAPI
NTSTATUS
NTAPI
ZwPrepareComplete (
    __in HANDLE            EnlistmentHandle,
    __in_opt PLARGE_INTEGER TmVirtualClock
    );
#endif

#if (NTDDI_VERSION >= NTDDI_VISTA)
NTSYSCALLAPI
NTSTATUS
NTAPI
ZwCommitComplete (
    __in HANDLE            EnlistmentHandle,
    __in_opt PLARGE_INTEGER TmVirtualClock
    );
#endif

#if (NTDDI_VERSION >= NTDDI_VISTA)
NTSYSCALLAPI
NTSTATUS
NTAPI
ZwReadOnlyEnlistment (
    __in HANDLE            EnlistmentHandle,
    __in_opt PLARGE_INTEGER TmVirtualClock
    );
#endif

#if (NTDDI_VERSION >= NTDDI_VISTA)
NTSYSCALLAPI
NTSTATUS
NTAPI
ZwRollbackComplete (
    __in HANDLE            EnlistmentHandle,
    __in_opt PLARGE_INTEGER TmVirtualClock
    );
#endif

#if (NTDDI_VERSION >= NTDDI_VISTA)
NTSYSCALLAPI
NTSTATUS
NTAPI
ZwSinglePhaseReject (
    __in HANDLE            EnlistmentHandle,
    __in_opt PLARGE_INTEGER TmVirtualClock
    );
#endif

#if (NTDDI_VERSION >= NTDDI_WIN2003)
NTSYSCALLAPI
NTSTATUS
NTAPI
ZwOpenEvent (
    __out PHANDLE EventHandle,
    __in ACCESS_MASK DesiredAccess,
    __in POBJECT_ATTRIBUTES ObjectAttributes
    );
#endif



//
// Enum for state of a EM rule
//
typedef
enum {
    STATE_FALSE,
    STATE_UNKNOWN,
    STATE_TRUE
} EM_RULE_STATE, *PEM_RULE_STATE;

//
// Define the entry data structure
//

typedef struct _EM_ENTRY_DATA {
    PVOID Data;
    ULONG DataLength;
} EM_ENTRY_DATA, *PEM_ENTRY_DATA;

//
// Define the Callback function pointer declaration
//

typedef
EM_RULE_STATE
(*EM_CALLBACK_FUNC) (
    __in_ecount_opt(NumberofEntries) EM_ENTRY_DATA **InputEntries,
    __in ULONG NumberofEntries,
    __in_ecount_opt(NumberofStrings) LPCSTR *InputStrings,
    __in ULONG NumberofStrings,
    __in_ecount_opt(NumberofNumerics) PULONG InputNumerics,
    __in ULONG NumberofNumerics,
    __in_opt PVOID Context
    );

//
// Define the lazy entry registration callback function
//

typedef
VOID
(*EM_LAZYENTRY_CALLBACK) (
    __in LPCGUID EntryGuid,
    __in_opt PVOID Context
    );

//
//  Define the Lazy Registration Structure
//

typedef struct _EM_ENTRY_REGISTRATION {
    LPCGUID EntryGuid;

    //
    // If LazyEntryCallback is provided, the Entry will be considered lazy
    //

    EM_LAZYENTRY_CALLBACK LazyEntryCallback;
    PVOID LazyCallbackContext;
} EM_ENTRY_REGISTRATION, *PEM_ENTRY_REGISTRATION;

//
// Define the Callback registration structure
//

typedef struct _EM_CALLBACK_REGISTRATION {
    LPCGUID CallbackGuid;
    EM_CALLBACK_FUNC CallbackFunction;
    PVOID Context;
} EM_CALLBACK_REGISTRATION, *PEM_CALLBACK_REGISTRATION;


//
// Define client rule notification function
//

typedef
VOID
(*EM_RULE_STATE_NOTIFY) (
    __in EM_RULE_STATE State,
    __in LPCGUID RuleId,
    __in_opt PVOID Context
    );



//
// Define client rule notification registration structure
//

typedef struct _EM_CLIENT_NOTIFICATION_REGISTRATION {
    LPCGUID RuleId;
    EM_RULE_STATE_NOTIFY RuleNotifyCallback;
    PVOID Context;
} EM_CLIENT_NOTIFICATION_REGISTRATION, *PEM_CLIENT_NOTIFICATION_REGISTRATION;

//
// Em Provider APIs
//

NTSTATUS
EmProviderRegister(
    __in PDRIVER_OBJECT DriverObject,
    __in_ecount_opt(NumberOfEntry) PEM_ENTRY_REGISTRATION EntryRegistration,
    __in ULONG NumberOfEntry,
    __in_ecount_opt(NumberOfCallback) PEM_CALLBACK_REGISTRATION CallbackRegistration,
    __in ULONG NumberOfCallback,
    __out PVOID *ProviderHandle
    );

VOID
EmProviderDeregister(
    __in PVOID ProviderHandle
    );

NTSTATUS
EmProviderRegisterEntry(
    __in PVOID ProviderHandle,
    __in LPCGUID EntryId,
    __in PEM_ENTRY_DATA EntryData,
    __out PVOID *EntryHandle
    );


VOID
EmProviderDeregisterEntry(
    __in PVOID EntryHandle
    );

//
// Em Client APIs
//

NTSTATUS
EmClientRuleEvaluate(
    __in LPCGUID RuleId,
    __in_ecount(NumberOfEntries) EM_ENTRY_DATA **InputEntries,
    __in ULONG NumberOfEntries,
    __out PEM_RULE_STATE State
    );

NTSTATUS
EmClientRuleRegisterNotification(
    __in PDRIVER_OBJECT DriverObject,
    __in_ecount(NumberOfNotificatoinRegistration) PEM_CLIENT_NOTIFICATION_REGISTRATION RuleNotificationsRegistration,
    __in ULONG NumberOfNotificatoinRegistration,
    __out PVOID *NotificationHandle
    );

VOID
EmClientRuleDeregisterNotification(
    __in PVOID NotificationHandle
    );

NTSTATUS
EmClientQueryRuleState(
    __in LPCGUID RuleId,
    __out PEM_RULE_STATE State
    );

#ifndef _CLFS_PUBLIC_H_
#define _CLFS_PUBLIC_H_
#define CLFSUSER_API

#if (NTDDI_VERSION >= NTDDI_WS03SP1) || (_WIN32_WINNT >= _WIN32_WINNT_WS03)

//
// FILE_ATTRIBUTE_DEDICATED is defined as FILE_ATTRIBUTE_TEMPORARY.
//

#define FILE_ATTRIBUTE_DEDICATED    FILE_ATTRIBUTE_TEMPORARY

//
// Container name and container size extended attribute entry names.
//

#define EA_CONTAINER_NAME           "ContainerName"
#define EA_CONTAINER_SIZE           "ContainerSize"

//
// Base log file name 3-letter extension.
//

#define CLFS_BASELOG_EXTENSION      L".blf"

//
// Common log file system public flags and constants.
//

#define CLFS_FLAG_NO_FLAGS              0x00000000      // No flags.
#define CLFS_FLAG_FORCE_APPEND          0x00000001      // Flag to force an append to log queue
#define CLFS_FLAG_FORCE_FLUSH           0x00000002      // Flag to force a log flush
#define CLFS_FLAG_USE_RESERVATION       0x00000004      // Flag to charge a data append to reservation
#define CLFS_FLAG_REENTRANT_FILE_SYSTEM 0x00000008      // Kernel mode create flag indicating a re-entrant file system.
#define CLFS_FLAG_NON_REENTRANT_FILTER  0x00000010      // Kernel mode create flag indicating non-reentrant filter.
#define CLFS_FLAG_REENTRANT_FILTER      0x00000020      // Kernel mode create flag indicating reentrant filter.
#define CLFS_FLAG_IGNORE_SHARE_ACCESS   0x00000040      // Kernel mode create flag indicating IO_IGNORE_SHARE_ACCESS_CHECK semantics.
#define CLFS_FLAG_READ_IN_PROGRESS      0x00000080      // Flag indicating read in progress and not completed.
#define CLFS_FLAG_MINIFILTER_LEVEL      0x00000100      // Kernel mode create flag indicating mini-filter target.
#define CLFS_FLAG_HIDDEN_SYSTEM_LOG     0x00000200      // Kernel mode create flag indicating the log and containers should be marked hidden & system.


//
// Flag indicating all CLFS I/O will be targeted to an intermediate level of the I/O stack
//

#define CLFS_FLAG_FILTER_INTERMEDIATE_LEVEL CLFS_FLAG_NON_REENTRANT_FILTER
    
//
// Flag indicating all CLFS I/O will be targeted to the top level of the I/O stack
//

#define CLFS_FLAG_FILTER_TOP_LEVEL          CLFS_FLAG_REENTRANT_FILTER

//
// CLFS_CONTAINER_INDEX
//
// Index into the container table.
//

typedef ULONG                       CLFS_CONTAINER_ID;
typedef CLFS_CONTAINER_ID           *PCLFS_CONTAINER_ID;
typedef CLFS_CONTAINER_ID           **PPCLFS_CONTAINER_ID;

#endif /* NTDDI_VERSION || _WIN32_WINNT */

#ifdef __CLFS_PRIVATE_LSN__

#include <clfslsn.h>

#else

#if (NTDDI_VERSION >= NTDDI_WS03SP1) || (_WIN32_WINNT >= _WIN32_WINNT_WS03)

//
// CLS_LSN
//

typedef struct _CLS_LSN
{

    ULONGLONG               Internal;

} CLS_LSN, *PCLS_LSN, **PPCLS_LSN;

#endif /* NTDDI_VERSION || _WIN32_WINNT */

#endif /* __CLFS_PRIVATE_LSN__ */

#if (NTDDI_VERSION >= NTDDI_WS03SP1) || (_WIN32_WINNT >= _WIN32_WINNT_WS03)

//
// Alias CLS prefixed types with CLFS prefixes.
//

typedef CLS_LSN CLFS_LSN;
typedef CLFS_LSN *PCLFS_LSN, **PPCLFS_LSN;

#endif /* NTDDI_VERSION || _WIN32_WINNT */

#ifdef __cplusplus
extern "C"
{
#endif /* __cplusplus */

#if (NTDDI_VERSION >= NTDDI_WS03SP1) || (_WIN32_WINNT >= _WIN32_WINNT_WS03)
extern __declspec(dllimport) const CLFS_LSN CLFS_LSN_INVALID;
extern __declspec(dllimport) const CLFS_LSN CLFS_LSN_NULL;
#endif /* NTDDI_VERSION || _WIN32_WINNT */

#ifdef __cplusplus
}
#endif /* __cplusplus */

#if (NTDDI_VERSION >= NTDDI_WS03SP1) || (_WIN32_WINNT >= _WIN32_WINNT_WS03)

//
// CLS_RECORD_TYPE
//
// Definition of record types.
//

#ifdef __cplusplus

const UCHAR  ClfsNullRecord          =   0x00;           // Null record type.        
const UCHAR  ClfsDataRecord          =   0x01;           // Client data record.
const UCHAR  ClfsRestartRecord       =   0x02;           // Restart record.


// Valid client records are restart and data records.

const UCHAR  ClfsClientRecord        =   0x03; 

#else

#define ClfsNullRecord                  0x00            // Null record type.        
#define ClfsDataRecord                  0x01            // Client data record.
#define ClfsRestartRecord               0x02            // Restart record.


// Valid client records are restart and data records.

#define ClfsClientRecord (ClfsDataRecord|ClfsRestartRecord) 

#endif /* _cplusplus */

#endif /* NTDDI_VERSION || _WIN32_WINNT */

#if (NTDDI_VERSION >= NTDDI_WS03SP1) || (_WIN32_WINNT >= _WIN32_WINNT_WS03)
//
// Log container path prefix indicating the log container's location is
// actually a stream inside of the BLF.
//

#ifdef _cplusplus

const LPCWSTR CLFS_CONTAINER_STREAM_PREFIX     = L"%BLF%:"

#else

#define CLFS_CONTAINER_STREAM_PREFIX             L"%BLF%:"

#endif /* _cplusplus */

#endif /* NTDDI_VERSION || _WIN32_WINNT */

#if (NTDDI_VERSION >= NTDDI_WS03SP1) || (_WIN32_WINNT >= _WIN32_WINNT_WS03)
//
// Log container path prefix indicating the log container's location is
// relative to the base log file (BLF) and not an absolute path.
// Paths which do not being with said prefix are absolute paths.
//

#ifdef _cplusplus

const LPCWSTR CLFS_CONTAINER_RELATIVE_PREFIX    = L"%BLF%\\"

#else

#define CLFS_CONTAINER_RELATIVE_PREFIX            L"%BLF%\\"

#endif /* _cplusplus */

#endif /* NTDDI_VERSION || _WIN32_WINNT */

#if (NTDDI_VERSION >= NTDDI_WS03SP1) || (_WIN32_WINNT >= _WIN32_WINNT_WS03)
//
// Alias CLS prefix with CLFS prefixes.
//

typedef UCHAR CLS_RECORD_TYPE, *PCLS_RECORD_TYPE, **PPCLS_RECORD_TYPE;
typedef CLS_RECORD_TYPE CLFS_RECORD_TYPE, *PCLFS_RECORD_TYPE, **PPCLFS_RECORD_TYPE;
#endif /* NTDDI_VERSION || _WIN32_WINNT */

#if (NTDDI_VERSION >= NTDDI_WS03SP1) || (_WIN32_WINNT >= _WIN32_WINNT_WS03)
//
// CLS_CONTEXT_MODE
//
// The context mode specifies the dirction and access methods used to scan the
// log file. 
//

typedef enum _CLS_CONTEXT_MODE
{
    ClsContextNone = 0x00,
    ClsContextUndoNext,
    ClsContextPrevious,
    ClsContextForward

} CLS_CONTEXT_MODE, *PCLS_CONTEXT_MODE, **PPCLS_CONTEXT_MODE;
#endif /* NTDDI_VERSION || _WIN32_WINNT */

#if (NTDDI_VERSION >= NTDDI_WS03SP1) || (_WIN32_WINNT >= _WIN32_WINNT_WS03)
//
// Alias all CLS prefixes with CLFS prefixes.
//

typedef enum _CLFS_CONTEXT_MODE
{
    ClfsContextNone = 0x00,
    ClfsContextUndoNext,
    ClfsContextPrevious,
    ClfsContextForward

} CLFS_CONTEXT_MODE, *PCLFS_CONTEXT_MODE, **PPCLFS_CONTEXT_MODE;
#endif /* NTDDI_VERSION || _WIN32_WINNT */


#if (NTDDI_VERSION >= NTDDI_WS03SP1) || (_WIN32_WINNT >= _WIN32_WINNT_WS03)
//
// CLFSD_NODE_ID
//
// Common log file system node identifier.  Every CLFS file system
// structure has a node identity and type.  The node type is a signature
// field while the size is used in for consistency checking.
//

typedef struct _CLFS_NODE_ID
{
    ULONG   cType;                                      // CLFS node type.
    ULONG   cbNode;                                     // CLFS node size.

} CLFS_NODE_ID, *PCLFS_NODE_ID;
#endif /* NTDDI_VERSION || _WIN32_WINNT */


#if (NTDDI_VERSION >= NTDDI_WS03SP1) || (_WIN32_WINNT >= _WIN32_WINNT_WS03)
//
//  CLS_WRITE_ENTRY
//
// Write entry specifying the contents of a user buffer and length that are
// marshalled in the space reservation and append interface of the CLS API.
//

typedef struct _CLS_WRITE_ENTRY
{
    PVOID Buffer;
    ULONG ByteLength;
} CLS_WRITE_ENTRY, *PCLS_WRITE_ENTRY, **PPCLS_WRITE_ENTRY;
#endif /* NTDDI_VERSION || _WIN32_WINNT */

#if (NTDDI_VERSION >= NTDDI_WS03SP1) || (_WIN32_WINNT >= _WIN32_WINNT_WS03)
//
// Alias all CLS prefixes with CLFS prefixes.
//

typedef CLS_WRITE_ENTRY CLFS_WRITE_ENTRY;
typedef CLFS_WRITE_ENTRY *PCLFS_WRITE_ENTRY, **PPCLFS_WRITE_ENTRY;
#endif /* NTDDI_VERSION || _WIN32_WINNT */

#if (NTDDI_VERSION >= NTDDI_WS03SP1) || (_WIN32_WINNT >= _WIN32_WINNT_WS03)
//
// CLFS_LOG_ID
// 
// A log identifier is a GUID that describes uniquely a physical log file.
//

typedef GUID CLFS_LOG_ID;
#endif /* NTDDI_VERSION || _WIN32_WINNT */

#if (NTDDI_VERSION >= NTDDI_WS03SP1) || (_WIN32_WINNT >= _WIN32_WINNT_WS03)
//
// CLFS_INFORMATION
//
// Logical log file information structure describing either virtual or physical log
// file data, depending on the type of information queried.
//

typedef struct _CLS_INFORMATION
{
    LONGLONG TotalAvailable;                            // Total log data space available.
    LONGLONG CurrentAvailable;                          // Useable space in the log file.
    LONGLONG TotalReservation;                       // Space reserved for UNDO's (aggregate for physical log)
    ULONGLONG BaseFileSize;                             // Size of the base log file.
    ULONGLONG ContainerSize;                            // Uniform size of log containers.
    ULONG TotalContainers;                              // Total number of containers.
    ULONG FreeContainers;                               // Number of containers not in active log.
    ULONG TotalClients;                                 // Total number of clients.
    ULONG Attributes;                                   // Log file attributes.
    ULONG FlushThreshold;                               // Log file flush threshold.
    ULONG SectorSize;                                   // Underlying container sector size.
    CLS_LSN MinArchiveTailLsn;                          // Marks the global archive tail.
    CLS_LSN BaseLsn;                                    // Start of the active log region.
    CLS_LSN LastFlushedLsn;                             // Last flushed LSN in active log.
    CLS_LSN LastLsn;                                    // End of active log region.
    CLS_LSN RestartLsn;                                 // Location of restart record.
    GUID Identity;                                      // Unique identifier for the log.
} CLS_INFORMATION, *PCLS_INFORMATION, *PPCLS_INFORMATION;
#endif /* NTDDI_VERSION || _WIN32_WINNT */

#if (NTDDI_VERSION >= NTDDI_WS03SP1) || (_WIN32_WINNT >= _WIN32_WINNT_WS03)
//
// Alias CLS prefixes with CLS prefixes.
//

typedef CLS_INFORMATION CLFS_INFORMATION;
typedef CLFS_INFORMATION *PCLFS_INFORMATION, *PPCLFS_INFORMATION;
#endif /* NTDDI_VERSION || _WIN32_WINNT */
/*
//
// CLFS_CLIENT_INFORMATION
// 
// The client information structure maintains client-based log metadata.
//

typedef struct _CLS_CLIENT_INFORMATION
{
    CLS_INFORMATION ClfsInfo;                           // Contains base log file information.
    ULONG ClientAttributes;                             // Virtual log file attributes.
    LONGLONG ClientUndoCommitment;                      // Max. undo commitment for client.
    CLS_LSN ClientArchiveTailLsn;                       // Marks the client archive tail.
    CLS_LSN ClientBaseLsn;                              // Min. client LSN in active log region.
    CLS_LSN ClientLastLsn;                              // Max. client LSN in active log region.
    CLS_LSN ClientRestartLsn;                           // Location of restart record.

} CLS_CLIENT_INFORMATION, *PCLS_CLIENT_INFORMATION, **PPCLS_CLIENT_INFORMATION;

//
// Alias CLS prefixes with CLS prefixes.
//

typedef CLS_CLIENT_INFORMATION CLFS_CLIENT_INFORMATION;
typedef CLFS_CLIENT_INFORMATION *PCLFS_CLIENT_INFORMATION, *PPCLFS_CLIENT_INFORMATION;
*/

#if (NTDDI_VERSION >= NTDDI_WS03SP1) || (_WIN32_WINNT >= _WIN32_WINNT_WS03)
//
// CLFS_LOG_NAME_INFORMATION
// 
// The client information structure stores the name of a log.  It is used
// to communicate ClfsLogNameInformation and ClfsLogPhysicalNameInformation.
//

typedef struct _CLFS_LOG_NAME_INFORMATION
{

    USHORT NameLengthInBytes;
    WCHAR  Name[1];

} CLFS_LOG_NAME_INFORMATION, *PCLFS_LOG_NAME_INFORMATION, **PPCLFS_LOG_NAME_INFORMATION;
#endif /* NTDDI_VERSION || _WIN32_WINNT */

#if (NTDDI_VERSION >= NTDDI_WS03SP1) || (_WIN32_WINNT >= _WIN32_WINNT_WS03)
//
// CLFS_STREAM_ID_INFORMATION
// 
// The client information structure provides a permanent identifier unique
// to the log for the stream in question.
//

typedef struct _CLFS_STREAM_ID_INFORMATION
{

    UCHAR StreamIdentifier;

} CLFS_STREAM_ID_INFORMATION, *PCLFS_STREAM_ID_INFORMATION, **PPCLFS_STREAM_ID_INFORMATION;
#endif /* NTDDI_VERSION || _WIN32_WINNT */

#if (NTDDI_VERSION >= NTDDI_VISTA) || (_WIN32_WINNT >= _WIN32_WINNT_LONGHORN)
//
// CLFS_PHYSICAL_LSN_INFORMATION
// 
// An information structure that describes a virtual:physical LSN pairing 
// for the stream identified in the structure.
//
#pragma pack (8)
typedef struct _CLFS_PHYSICAL_LSN_INFORMATION
{
    UCHAR          StreamIdentifier;
    CLFS_LSN       VirtualLsn;
    CLFS_LSN       PhysicalLsn;

} CLFS_PHYSICAL_LSN_INFORMATION, *PCLFS_PHYSICAL_LSN_INFORMATION;
#endif /* NTDDI_VERSION || _WIN32_WINNT */

#if (NTDDI_VERSION >= NTDDI_WS03SP1) || (_WIN32_WINNT >= _WIN32_WINNT_WS03)
//
// CLS_CONTAINER_STATE
//
// At any point in time a container could be inactive or unitialized, active,
// pending deletion from the list of free containers, pending archival, or 
// pending deletion while waiting to be archived.
//

typedef UINT32 CLS_CONTAINER_STATE, *PCLS_CONTAINER_STATE, *PPCLS_CONTAINER_STATE;
typedef CLS_CONTAINER_STATE  CLFS_CONTAINER_STATE, *PCLFS_CONTAINER_STATE, *PPCLFS_CONTAINER_STATE;
#endif /* NTDDI_VERSION || _WIN32_WINNT */

#ifdef __cplusplus

#if (NTDDI_VERSION >= NTDDI_WS03SP1) || (_WIN32_WINNT >= _WIN32_WINNT_WS03)
const CLFS_CONTAINER_STATE  ClsContainerInitializing            = 0x01;
const CLFS_CONTAINER_STATE  ClsContainerInactive                = 0x02;
const CLFS_CONTAINER_STATE  ClsContainerActive                  = 0x04;
const CLFS_CONTAINER_STATE  ClsContainerActivePendingDelete     = 0x08;
const CLFS_CONTAINER_STATE  ClsContainerPendingArchive          = 0x10;
const CLFS_CONTAINER_STATE  ClsContainerPendingArchiveAndDelete = 0x20;

const CLFS_CONTAINER_STATE  ClfsContainerInitializing           = 0x01;
const CLFS_CONTAINER_STATE  ClfsContainerInactive               = 0x02;
const CLFS_CONTAINER_STATE  ClfsContainerActive                 = 0x04;
const CLFS_CONTAINER_STATE  ClfsContainerActivePendingDelete    = 0x08;
const CLFS_CONTAINER_STATE  ClfsContainerPendingArchive         = 0x10;
const CLFS_CONTAINER_STATE  ClfsContainerPendingArchiveAndDelete= 0x20;
#endif /* NTDDI_VERSION || _WIN32_WINNT */

#else

#if (NTDDI_VERSION >= NTDDI_WS03SP1) || (_WIN32_WINNT >= _WIN32_WINNT_WS03)
#define ClsContainerInitializing                                  0x01
#define ClsContainerInactive                                      0x02
#define ClsContainerActive                                        0x04
#define ClsContainerActivePendingDelete                           0x08
#define ClsContainerPendingArchive                                0x10
#define ClsContainerPendingArchiveAndDelete                       0x20

#define ClfsContainerInitializing                                 0x01
#define ClfsContainerInactive                                     0x02
#define ClfsContainerActive                                       0x04
#define ClfsContainerActivePendingDelete                          0x08
#define ClfsContainerPendingArchive                               0x10
#define ClfsContainerPendingArchiveAndDelete                      0x20
#endif /* NTDDI_VERSION || _WIN32_WINNT */

#endif /* __cplusplus */

#if (NTDDI_VERSION >= NTDDI_WS03SP1) || (_WIN32_WINNT >= _WIN32_WINNT_WS03)
//
// CLFS_MAX_CONTAINER_INFO
//
// The maximum length, in bytes, of the FileName field in the CLFS
// container information structure.
//

#ifdef __cplusplus

const ULONG CLFS_MAX_CONTAINER_INFO = (256);

#else

#define CLFS_MAX_CONTAINER_INFO       (256)

#endif /* __cplusplus */

#endif /* NTDDI_VERSION || _WIN32_WINNT */


#if (NTDDI_VERSION >= NTDDI_WS03SP1) || (_WIN32_WINNT >= _WIN32_WINNT_WS03)
//
// CLS_CONTAINER_INFORMATION
//
// This structure defines a container descriptor.  The descriptor specifies the
// container's creation and access times, size, file system name, file system
// attributes, state, minimum, and maximum LSNs.
//

typedef struct _CLS_CONTAINER_INFORMATION
{
    ULONG FileAttributes;                    // File system attribute flag.
    ULONGLONG CreationTime;                  // File creation time.
    ULONGLONG LastAccessTime;                // Last time container was read/written.
    ULONGLONG LastWriteTime;                 // Last time container was written.
    LONGLONG ContainerSize;                  // Size of container in bytes.
    ULONG FileNameActualLength;              // Length of the actual file name.
    ULONG FileNameLength;                    // Length of file name in buffer
    WCHAR FileName [CLFS_MAX_CONTAINER_INFO];// File system name for container.
    CLFS_CONTAINER_STATE State;              // Current state of the container.
    CLFS_CONTAINER_ID PhysicalContainerId;   // Physical container identifier.
    CLFS_CONTAINER_ID LogicalContainerId;    // Logical container identifier.

} CLS_CONTAINER_INFORMATION, *PCLS_CONTAINER_INFORMATION, **PPCLS_CONTAINER_INFORMATION;

//
// Alias all CLS prefixes with CLFS prefixes.
//

typedef CLS_CONTAINER_INFORMATION CLFS_CONTAINER_INFORMATION;
typedef CLFS_CONTAINER_INFORMATION *PCLFS_CONTAINER_INFORMATION, **PPCLFS_CONTAINER_INFORMATION;
#endif /* NTDDI_VERSION || _WIN32_WINNT */


#if (NTDDI_VERSION >= NTDDI_WS03SP1) || (_WIN32_WINNT >= _WIN32_WINNT_WS03)
//
// CLFS_LOG_INFORMATION_CLASS
//
// The information class specifies the kind of information a caller
// wishes to query or set on a log file.
//

typedef enum _CLS_LOG_INFORMATION_CLASS
{

    ClfsLogBasicInformation = 0x00,         // For virtual or physical logs, indicates the respective basic information.
    ClfsLogBasicInformationPhysical,        // Always indicates physical log basic information.
    ClfsLogPhysicalNameInformation,         // Always indicates physical name information.
    ClfsLogStreamIdentifierInformation,     // Virtual/physical log agnostic.
#if (NTDDI_VERSION >= NTDDI_VISTA) || (_WIN32_WINNT >= _WIN32_WINNT_LONGHORN)
    ClfsLogSystemMarkingInformation,        // Count of system marking references.
    ClfsLogPhysicalLsnInformation           // Maps virtual LSNs to physical LSNs; only valid for physical logs.
#endif /* NTDDI_VERSION || _WIN32_WINNT */

} CLS_LOG_INFORMATION_CLASS, *PCLS_LOG_INFORMATION_CLASS, **PPCLS_LOG_INFORMATION_CLASS;

//
// Alias all CLS prefixes with CLFS prefixes.
//

typedef CLS_LOG_INFORMATION_CLASS CLFS_LOG_INFORMATION_CLASS;
typedef CLFS_LOG_INFORMATION_CLASS *PCLFS_LOG_INFORMATION_CLASS, **PPCLFS_LOG_INFORMATION_CLASS;
#endif /* NTDDI_VERSION || _WIN32_WINNT */

#if (NTDDI_VERSION >= NTDDI_WS03SP1) || (_WIN32_WINNT >= _WIN32_WINNT_WS03)
//
// CLS_IOSTATS_CLASS
//
// Enumerated type defining the class of I/O statistics.
//

typedef enum _CLS_IOSTATS_CLASS
{
    ClsIoStatsDefault = 0x0000,
    ClsIoStatsMax     = 0xFFFF

} CLS_IOSTATS_CLASS, *PCLS_IOSTATS_CLASS, **PPCLS_IOSTATS_CLASS;
#endif /* NTDDI_VERSION || _WIN32_WINNT */


#if (NTDDI_VERSION >= NTDDI_WS03SP1) || (_WIN32_WINNT >= _WIN32_WINNT_WS03)
//
// CLFS_IOSTATS_CLASS
//
// Alias all CLS prefixes with CLFS prefixes.
//

typedef enum _CLFS_IOSTATS_CLASS
{
    ClfsIoStatsDefault = 0x0000,
    ClfsIoStatsMax     = 0xFFFF

} CLFS_IOSTATS_CLASS, *PCLFS_IOSTATS_CLASS, **PPCLFS_IOSTATS_CLASS;
#endif /* NTDDI_VERSION || _WIN32_WINNT */


#if (NTDDI_VERSION >= NTDDI_WS03SP1) || (_WIN32_WINNT >= _WIN32_WINNT_WS03)
//
// CLS_IO_STATISTICS
//
// This structure defines I/O performance counters particular to a log file.  It consists
// of a header followed by the I/O statistics counters.  The header is being ignored for
// now.
//

typedef struct _CLS_IO_STATISTICS_HEADER
{
    UCHAR                ubMajorVersion;     // Major version of the statistics buffer.
    UCHAR                ubMinorVersion;     // Minor version of the statistics buffer.
    CLFS_IOSTATS_CLASS  eStatsClass;        // I/O statistics class.
    USHORT              cbLength;           // Length of the statistics buffer.                     
    ULONG               coffData;           // Offset of statistics counters.

} CLS_IO_STATISTICS_HEADER, *PCLS_IO_STATISTICS_HEADER, **PPCLS_IO_STATISTICS_HEADER;

//
// Alias all CLS prefixes with CLFS prefixes.
//

typedef CLS_IO_STATISTICS_HEADER CLFS_IO_STATISTICS_HEADER;
typedef CLFS_IO_STATISTICS_HEADER *PCLFS_IO_STATISTICS_HEADER, **PPCLFS_IO_STATISTICS_HEADER;
#endif /* NTDDI_VERSION || _WIN32_WINNT */


#if (NTDDI_VERSION >= NTDDI_WS03SP1) || (_WIN32_WINNT >= _WIN32_WINNT_WS03)
typedef struct _CLS_IO_STATISTICS
{
    CLS_IO_STATISTICS_HEADER hdrIoStats;    // Statistics buffer header.
    ULONGLONG cFlush;                       // Flush count.
    ULONGLONG cbFlush;                      // Cumulative number of bytes flushed.
    ULONGLONG cMetaFlush;                   // Metadata flush count.
    ULONGLONG cbMetaFlush;                  // Cumulative number of metadata bytes flushed.

} CLS_IO_STATISTICS, *PCLS_IO_STATISTICS, **PPCLS_IO_STATISTICS;

//
// Alias all CLS prefixes with CLFS prefixes.
//

typedef CLS_IO_STATISTICS CLFS_IO_STATISTICS;
typedef CLFS_IO_STATISTICS *PCLFS_IO_STATISTICS, **PPCLFS_IO_STATISTICS;
#endif /* NTDDI_VERSION || _WIN32_WINNT */

#if (NTDDI_VERSION >= NTDDI_WS03SP1) || (_WIN32_WINNT >= _WIN32_WINNT_WS03)
//
// CLFS_SCAN_MODE
//
// Container scan mode flags.
//

#ifdef __cplusplus

const   UCHAR CLFS_SCAN_INIT         =   0x01;
const   UCHAR CLFS_SCAN_FORWARD      =   0x02;
const   UCHAR CLFS_SCAN_BACKWARD     =   0x04;
const   UCHAR CLFS_SCAN_CLOSE        =   0x08;
const   UCHAR CLFS_SCAN_INITIALIZED  =   0x10;
const   UCHAR CLFS_SCAN_BUFFERED     =   0x20;

#else

#define CLFS_SCAN_INIT                  0x01
#define CLFS_SCAN_FORWARD               0x02
#define CLFS_SCAN_BACKWARD              0x04
#define CLFS_SCAN_CLOSE                 0x08
#define CLFS_SCAN_INITIALIZED           0x10
#define CLFS_SCAN_BUFFERED              0x20

#endif

typedef UCHAR CLFS_SCAN_MODE, *PCLFS_SCAN_MODE;
#endif /* NTDDI_VERSION || _WIN32_WINNT */


#if (NTDDI_VERSION >= NTDDI_WS03SP1) || (_WIN32_WINNT >= _WIN32_WINNT_WS03)

//
// CLFS_SCAN_CONTEXT
//
// Container scan context for scanning all containers in a given physical log
// file.
//

//
// The log file object wraps an NT file object and the size of the structure. 
// The log file object may be modified in the near future and there should be no
// dependencies on the size of the structure itself.
//

typedef FILE_OBJECT LOG_FILE_OBJECT, *PLOG_FILE_OBJECT, **PPLOG_FILE_OBJECT;

#if defined(_MSC_VER)
#if (_MSC_VER >= 1200)
#pragma warning(push)
#pragma warning(disable:4324) // structure padded due to __declspec(align())
#endif
#endif

typedef struct _CLS_SCAN_CONTEXT
{
    CLFS_NODE_ID cidNode;
    PLOG_FILE_OBJECT plfoLog;
    __declspec(align(8)) ULONG cIndex;
    __declspec(align(8)) ULONG cContainers;
    __declspec(align(8)) ULONG cContainersReturned;
    __declspec(align(8)) CLFS_SCAN_MODE eScanMode;
    __declspec(align(8)) PCLS_CONTAINER_INFORMATION pinfoContainer;
    
} CLS_SCAN_CONTEXT, *PCLS_SCAN_CONTEXT, **PPCLS_SCAN_CONTEXT;

#if defined(_MSC_VER)
#if (_MSC_VER >= 1200)
#pragma warning(pop)
#endif
#endif

#endif /* NTDDI_VERSION || _WIN32_WINNT */


#if (NTDDI_VERSION >= NTDDI_WS03SP1) || (_WIN32_WINNT >= _WIN32_WINNT_WS03)
//
// Alias all CLS prefixes with CLFS prefixes.
//

typedef CLS_SCAN_CONTEXT CLFS_SCAN_CONTEXT;
typedef CLFS_SCAN_CONTEXT *PCLFS_SCAN_CONTEXT, **PPCLFS_SCAN_CONTEXT;
#endif /* NTDDI_VERSION || _WIN32_WINNT */

#if (NTDDI_VERSION >= NTDDI_WS03SP1) || (_WIN32_WINNT >= _WIN32_WINNT_WS03)
//
// CLFS_ARCHIVE_DESCRIPTOR
//
// Log archive descriptors describe the set of discrete but logically
// contiguous disk extents comprising a snapshot of the active log when
// preparing for archival.  Log archive descriptors specify enough information
// for log archive clients directly access the relevant contents of containers
// for archiving and restoring a snapshot of the log.
//

typedef struct _CLS_ARCHIVE_DESCRIPTOR
{
    ULONGLONG coffLow;
    ULONGLONG coffHigh;
    CLS_CONTAINER_INFORMATION infoContainer;

} CLS_ARCHIVE_DESCRIPTOR, *PCLS_ARCHIVE_DESCRIPTOR, **PPCLS_ARCHIVE_DESCRIPTOR;

//
// Alias CLS prefixes with CLFS prefixes.
//

typedef CLS_ARCHIVE_DESCRIPTOR CLFS_ARCHIVE_DESCRIPTOR;
typedef CLFS_ARCHIVE_DESCRIPTOR *PCLFS_ARCHIVE_DESCRIPTOR, **PPCLFS_ARCHIVE_DESCRIPTOR;
#endif /* NTDDI_VERSION || _WIN32_WINNT */

#if (NTDDI_VERSION >= NTDDI_WS03SP1) || (_WIN32_WINNT >= _WIN32_WINNT_WS03)
//
// CLFS_ALLOCATION_ROUTINE
//
// Allocate a blocks for marshalled reads or writes
//

typedef PVOID (* CLFS_BLOCK_ALLOCATION) (ULONG cbBufferLength, PVOID pvUserContext);

//
// CLFS_DEALLOCATION_ROUTINE
//
// Deallocate buffers allocated by the CLFS_ALLOCATION_ROUTINE.
//

typedef void (* CLFS_BLOCK_DEALLOCATION) (PVOID pvBuffer, PVOID pvUserContext);
#endif /* NTDDI_VERSION || _WIN32_WINNT */

#if (NTDDI_VERSION >= NTDDI_WS03SP1) || (_WIN32_WINNT >= _WIN32_WINNT_WS03)
//
// CLFS_LOG_ARCHIVE_MODE
//
// Describes the archive support behavior for the log.
//

typedef enum _CLFS_LOG_ARCHIVE_MODE
{

    ClfsLogArchiveEnabled = 0x01,
    ClfsLogArchiveDisabled = 0x02

} CLFS_LOG_ARCHIVE_MODE, *PCLFS_LOG_ARCHIVE_MODE;
#endif /* NTDDI_VERSION || _WIN32_WINNT */


//-----------------------------------------------------------------------------
// LSN OPERATORS
//-----------------------------------------------------------------------------

#ifdef __cplusplus
extern "C"
{
#endif


#if (NTDDI_VERSION >= NTDDI_WS03SP1) || (_WIN32_WINNT >= _WIN32_WINNT_WS03)
//-----------------------------------------------------------------------------
// ClfsLsnEqual
//
//      Method Description:
//
//          Check for the equivalence of LSNs.
//
//      Arguments:
//
//          plsn1   -- first LSN comparator
//          plsn2   -- second LSN comparator
//          
//
//      Return Value:
//
//          TRUE if LSN values are equivalent and FALSE otherwise.
//
//-----------------------------------------------------------------------------

CLFSUSER_API BOOLEAN NTAPI
ClfsLsnEqual
(
    IN const CLFS_LSN* plsn1,
    IN const CLFS_LSN* plsn2
);
#endif /* NTDDI_VERSION || _WIN32_WINNT */


#if (NTDDI_VERSION >= NTDDI_WS03SP1) || (_WIN32_WINNT >= _WIN32_WINNT_WS03)
//-----------------------------------------------------------------------------
// ClfsLsnLess
//
//      Method Description:
//
//          Check if LSN1 is less than LSN2.
//
//      Arguments:
//
//          plsn1   -- first LSN comparator
//          plsn2   -- second LSN comparator
//          
//
//      Return Value:
//
//          TRUE if LSN1 is less than LSN2 and FALSE otherwise.
//
//-----------------------------------------------------------------------------

CLFSUSER_API BOOLEAN NTAPI
ClfsLsnLess
(
    IN const CLFS_LSN* plsn1,
    IN const CLFS_LSN* plsn2
);
#endif /* NTDDI_VERSION || _WIN32_WINNT */


#if (NTDDI_VERSION >= NTDDI_WS03SP1) || (_WIN32_WINNT >= _WIN32_WINNT_WS03)
//-----------------------------------------------------------------------------
// ClfsLsnGreater
//
//      Method Description:
//
//          Check if LSN1 is  greater than LSN2.
//
//      Arguments:
//
//          plsn1   -- first LSN comparator
//          plsn2   -- second LSN comparator
//          
//
//      Return Value:
//
//          TRUE if LSN1 is greater than LSN2 and FALSE otherwise.
//
//-----------------------------------------------------------------------------

CLFSUSER_API BOOLEAN NTAPI
ClfsLsnGreater
(
    IN const CLFS_LSN* plsn1,
    IN const CLFS_LSN* plsn2
);
#endif /* NTDDI_VERSION || _WIN32_WINNT */


#if (NTDDI_VERSION >= NTDDI_WS03SP1) || (_WIN32_WINNT >= _WIN32_WINNT_WS03)
//-----------------------------------------------------------------------------
// ClfsLsnNull (Inline)
//
//      Method Description:
//
//          Check whether or not an LSN is CLFS_LSN_NULL.
//
//      Arguments:
//
//          plsn    -- reference to LSN tested against the NULL value.
//          
//
//      Return Value:
//
//          TRUE if and only if an LSN is equivalent to CLFS_LSN_NULL.  
//          LSNs with the value CLFS_LSN_INVALID will return FALSE.
//
//-----------------------------------------------------------------------------

CLFSUSER_API BOOLEAN NTAPI
ClfsLsnNull
(
    IN const CLFS_LSN* plsn
);
#endif /* NTDDI_VERSION || _WIN32_WINNT */


#if (NTDDI_VERSION >= NTDDI_WS03SP1) || (_WIN32_WINNT >= _WIN32_WINNT_WS03)
//-----------------------------------------------------------------------------
// ClfsLsnContainer (Inline)
//
//      Routine Description:
//
//      Extract the container identifier from the LSN.
//
//      Arguments:
//
//          plsn -- get block offset from this LSN
//
//      Return Value:
//
//          Returns the container identifier for the LSN.
//
//-----------------------------------------------------------------------------

CLFSUSER_API CLFS_CONTAINER_ID NTAPI
ClfsLsnContainer
(
  IN const CLFS_LSN* plsn
);
#endif /* NTDDI_VERSION || _WIN32_WINNT */


#if (NTDDI_VERSION >= NTDDI_WS03SP1) || (_WIN32_WINNT >= _WIN32_WINNT_WS03)
//-----------------------------------------------------------------------------
// ClfsLsnCreate (Inline)
//
//      Routine Description:
//
//      Create an LSN given a log identifier, a container identifier, a block
//      offset and a bucket identifier.  Caller must test for invalid LSN after
//      making this call.
//
//      Arguments:
//
//          cidContainer    -- container identifier
//          offBlock        -- block offset
//          cRecord         -- ordinal number of the record in block
//
//      Return Value:
//
//          Returns a valid LSN if successful, otherwise it returns
//          CLFS_LSN_INVALID
//
//-----------------------------------------------------------------------------

CLFSUSER_API CLFS_LSN NTAPI
ClfsLsnCreate
(
    IN CLFS_CONTAINER_ID    cidContainer,
    IN ULONG                offBlock,
    IN ULONG                cRecord
);
#endif /* NTDDI_VERSION || _WIN32_WINNT */


#if (NTDDI_VERSION >= NTDDI_WS03SP1) || (_WIN32_WINNT >= _WIN32_WINNT_WS03)
//-----------------------------------------------------------------------------
// ClfsLsnBlockOffset (Inline)
//
//      Routine Description:
//
//      Extract the block offset from the LSN.
//
//      Arguments:
//
//          plsn -- get block offset from this LSN
//
//      Return Value:
//
//          Returns the block offset for the LSN.
//
//-----------------------------------------------------------------------------

CLFSUSER_API ULONG NTAPI
ClfsLsnBlockOffset
(
  IN const CLFS_LSN* plsn
);
#endif /* NTDDI_VERSION || _WIN32_WINNT */


#if (NTDDI_VERSION >= NTDDI_WS03SP1) || (_WIN32_WINNT >= _WIN32_WINNT_WS03)
//-----------------------------------------------------------------------------
// ClfsLsnRecordSequence (Inline)
//
//      Routine Description:
//
//          Extract the bucket identifier from the LSN.
//
//      Arguments:
//
//          plsn    -- get block offset from this LSN
//
//      Return Value:
//
//          Returns the bucket identifier for the LSN.
//
//-----------------------------------------------------------------------------

CLFSUSER_API ULONG NTAPI
ClfsLsnRecordSequence
(
    IN const CLFS_LSN* plsn
);
#endif /* NTDDI_VERSION || _WIN32_WINNT */


#if (NTDDI_VERSION >= NTDDI_WS03SP1) || (_WIN32_WINNT >= _WIN32_WINNT_WS03)
//-----------------------------------------------------------------------------
// ClfsLsnInvalid
//
//      Method Description:
//
//          Check whether or not an LSN is CLFS_LSN_INVALID.
//
//      Arguments:
//
//          plsn    -- reference to LSN tested against CLFS_LSN_INVALID.
//          
//
//      Return Value:
//
//          TRUE if and only if an LSN is equivalent to CLFS_LSN_INVALID.  
//          LSNs with the value CLFS_LSN_NULL will return FALSE.
//
//-----------------------------------------------------------------------------

CLFSUSER_API BOOLEAN NTAPI
ClfsLsnInvalid
(
    IN const CLFS_LSN* plsn
);
#endif /* NTDDI_VERSION || _WIN32_WINNT */


#if (NTDDI_VERSION >= NTDDI_WS03SP1) || (_WIN32_WINNT >= _WIN32_WINNT_WS03)
//-----------------------------------------------------------------------------
// ClfsLsnIncrement
//
//      Method Description:
//
//          Increment and LSN by 1
//
//      Arguments:
//
//          plsn -- LSN to be incremented.
//          
//
//      Return Value:
//
//          A valid LSN next in sequence to the input LSN, if successful.
//          Otherwise, this function returns CLFS_LSN_INVALID.
//
//-----------------------------------------------------------------------------

CLFSUSER_API CLFS_LSN NTAPI
ClfsLsnIncrement (IN PCLFS_LSN  plsn);
#endif /* NTDDI_VERSION || _WIN32_WINNT */


#ifdef __cplusplus
}
#endif

#ifdef __cplusplus

#ifdef CLFS_OPERATORS

#if (NTDDI_VERSION >= NTDDI_WS03SP1) || (_WIN32_WINNT >= _WIN32_WINNT_WS03)
//
// LSN arithmetic increment operator.
//

inline CLFS_LSN
operator++
(
    CLFS_LSN& refLsn
)
{
    //
    // Prefix increment operator.
    //

    refLsn = ClfsLsnIncrement (&refLsn);
    return refLsn;
}
#endif /* NTDDI_VERSION || _WIN32_WINNT */

#if (NTDDI_VERSION >= NTDDI_WS03SP1) || (_WIN32_WINNT >= _WIN32_WINNT_WS03)
//
// BOOLEAN LSN operators.
//

inline BOOLEAN      
operator<
(
    const CLFS_LSN& refLsn1, 
    const CLFS_LSN& refLsn2
)
{
    return (ClfsLsnLess ((PCLFS_LSN) &refLsn1, (PCLFS_LSN) &refLsn2));
}
#endif /* NTDDI_VERSION || _WIN32_WINNT */

#if (NTDDI_VERSION >= NTDDI_WS03SP1) || (_WIN32_WINNT >= _WIN32_WINNT_WS03)
inline BOOLEAN  
operator>
(
    const CLFS_LSN& refLsn1, 
    const CLFS_LSN& refLsn2
)
{
    return (ClfsLsnGreater ((PCLFS_LSN) &refLsn1, (PCLFS_LSN) &refLsn2));
}
#endif /* NTDDI_VERSION || _WIN32_WINNT */

#if (NTDDI_VERSION >= NTDDI_WS03SP1) || (_WIN32_WINNT >= _WIN32_WINNT_WS03)
inline BOOLEAN  
operator==
(
    const CLFS_LSN& refLsn1, 
    const CLFS_LSN& refLsn2
)
{
    return (ClfsLsnEqual ((PCLFS_LSN) &refLsn1, (PCLFS_LSN) &refLsn2));
}
#endif /* NTDDI_VERSION || _WIN32_WINNT */

#if (NTDDI_VERSION >= NTDDI_WS03SP1) || (_WIN32_WINNT >= _WIN32_WINNT_WS03)
inline BOOLEAN
operator!=
(
    const CLFS_LSN& refLsn1,
    const CLFS_LSN& refLsn2
)
{
    return (!ClfsLsnEqual ((PCLFS_LSN) &refLsn1, (PCLFS_LSN) &refLsn2));
}
#endif /* NTDDI_VERSION || _WIN32_WINNT */

#if (NTDDI_VERSION >= NTDDI_WS03SP1) || (_WIN32_WINNT >= _WIN32_WINNT_WS03)
inline BOOLEAN      
operator<=
(
    const CLFS_LSN& refLsn1, 
    const CLFS_LSN& refLsn2
)
{
    return (!ClfsLsnGreater ((PCLFS_LSN) &refLsn1, (PCLFS_LSN) &refLsn2));
}
#endif /* NTDDI_VERSION || _WIN32_WINNT */

#if (NTDDI_VERSION >= NTDDI_WS03SP1) || (_WIN32_WINNT >= _WIN32_WINNT_WS03)
inline BOOLEAN  
operator>=
(
    const CLFS_LSN& refLsn1, 
    const CLFS_LSN& refLsn2
)
{
    return (!ClfsLsnLess ((PCLFS_LSN) &refLsn1, (PCLFS_LSN) &refLsn2));
}
#endif /* NTDDI_VERSION || _WIN32_WINNT */

#endif /* CLFS_OPERATORS */

#endif /* __cplusplus */

#endif /* _CLFS_PUBLIC_H_ */

#ifdef __cplusplus
extern "C" {
#endif

#if (NTDDI_VERSION >= NTDDI_WS03SP1) || (_WIN32_WINNT >= _WIN32_WINNT_WS03)
//
// We start with the information that is shared
// between user and kernel mode.
//

typedef enum _CLFS_MGMT_POLICY_TYPE {

    ClfsMgmtPolicyMaximumSize = 0x0,
    ClfsMgmtPolicyMinimumSize,
    ClfsMgmtPolicyNewContainerSize,
    ClfsMgmtPolicyGrowthRate,
    ClfsMgmtPolicyLogTail,
    ClfsMgmtPolicyAutoShrink,
    ClfsMgmtPolicyAutoGrow,
    ClfsMgmtPolicyNewContainerPrefix,
    ClfsMgmtPolicyNewContainerSuffix,
    ClfsMgmtPolicyNewContainerExtension,

    ClfsMgmtPolicyInvalid

} CLFS_MGMT_POLICY_TYPE, *PCLFS_MGMT_POLICY_TYPE;
#endif /* NTDDI_VERSION || _WIN32_WINNT */

#if (NTDDI_VERSION >= NTDDI_WS03SP1) || (_WIN32_WINNT >= _WIN32_WINNT_WS03)
#define CLFS_MGMT_NUM_POLICIES ((ULONG)ClfsMgmtPolicyInvalid)
#endif /* NTDDI_VERSION || _WIN32_WINNT */


#if (NTDDI_VERSION >= NTDDI_WS03SP1) || (_WIN32_WINNT >= _WIN32_WINNT_WS03)
//
// Relative sizes used when explicitly setting log size.
//
#define CLFS_LOG_SIZE_MINIMUM ((ULONGLONG)(0))
#define CLFS_LOG_SIZE_MAXIMUM ((ULONGLONG)(-1))
#endif /* NTDDI_VERSION || _WIN32_WINNT */


#if (NTDDI_VERSION >= NTDDI_WS03SP1) || (_WIN32_WINNT >= _WIN32_WINNT_WS03)
//
// The version of a given policy structure.  See CLFS_MGMT_POLICY.
//
#define CLFS_MGMT_POLICY_VERSION (0x01)
#endif /* NTDDI_VERSION || _WIN32_WINNT */


#if (NTDDI_VERSION >= NTDDI_WS03SP1) || (_WIN32_WINNT >= _WIN32_WINNT_WS03)
//
// Log policy flags.
//
// LOG_POLICY_OVERWRITE: If set when adding a log policy, the previous
//                       policy of given type will be replaced.
//
// LOG_POLICY_PERSIST:   If set when adding a log policy, the policy
//                       will be persisted with the log metadata.
//
#define LOG_POLICY_OVERWRITE   (0x01)
#define LOG_POLICY_PERSIST     (0x02)
#endif /* NTDDI_VERSION || _WIN32_WINNT */


#if (NTDDI_VERSION >= NTDDI_WS03SP1) || (_WIN32_WINNT >= _WIN32_WINNT_WS03)
//
// CLFS_MGMT_POLICY
//
// This structure describes one particular policy that
// may be present on a log file.  These are installed
// via InstallLogPolicy (Win32) or ClfsMgmtInstallPolicy (kernel).
//
typedef struct _CLFS_MGMT_POLICY {

    //
    // Version of the structure.  Should be CLFS_MGMT_POLICY_VERSION.
    //
    ULONG                   Version;

    //
    // The entire length of the structure.
    //
    ULONG                   LengthInBytes;

    //
    // Flags which apply to all policies, such as LOG_POLICY_OVERWRITE
    // and LOG_POLICY_PERSIST.
    //
    ULONG                   PolicyFlags;

    //
    // Determines how PolicyParameters union is interpreted.
    //
    CLFS_MGMT_POLICY_TYPE   PolicyType;

    //
    // The way to interpret the PolicyParameters union is
    // determined by the value of PolicyType -- if it is
    // ClfsMgmtPolicyMaximumSize, for instance, then the
    // MaximumSize structure is the relevant one.
    //

    union {

        struct {
            ULONG       Containers;
        } MaximumSize;

        struct {
            ULONG       Containers;
        } MinimumSize;

        struct {
            ULONG       SizeInBytes;
        } NewContainerSize;

        struct {
            ULONG       AbsoluteGrowthInContainers;
            ULONG       RelativeGrowthPercentage;
        } GrowthRate;

        struct {
            ULONG       MinimumAvailablePercentage;
            ULONG       MinimumAvailableContainers;
        } LogTail;

        struct {
            ULONG       Percentage;
        } AutoShrink;

        struct {
            ULONG       Enabled;
        } AutoGrow;

        struct {
            USHORT      PrefixLengthInBytes;
            WCHAR       PrefixString[1]; // dynamic in length depending on PrefixLength
        } NewContainerPrefix;

        struct {
            ULONGLONG   NextContainerSuffix;
        } NewContainerSuffix;

        struct {
            USHORT      ExtensionLengthInBytes;
            WCHAR       ExtensionString[1]; // dynamic in length depending on ExtensionLengthInBytes
        } NewContainerExtension;

    } PolicyParameters;

    //
    // Nothing will be added down here since the structure above
    // can be of dynamic length.
    //

} CLFS_MGMT_POLICY, *PCLFS_MGMT_POLICY;
#endif /* NTDDI_VERSION || _WIN32_WINNT */


#if (NTDDI_VERSION >= NTDDI_WS03SP1) || (_WIN32_WINNT >= _WIN32_WINNT_WS03)
//
// CLFS_MGMT_NOTIFICATION_TYPE
// 
// The types of notifications given to either the callback proxy
// or to readers of notifications.
//

typedef enum _CLFS_MGMT_NOTIFICATION_TYPE
{

    //
    // Notification to advance base LSN.
    //

    ClfsMgmtAdvanceTailNotification = 0,

    //
    // Notification that a request to handle log full condition
    // has completed.
    //

    ClfsMgmtLogFullHandlerNotification,

    //
    // Notification that a previously pinned log is now considered
    // unpinned.
    //

    ClfsMgmtLogUnpinnedNotification,

    //
    // Notification that a non-zero number of bytes has been written
    // to the log.
    //

    ClfsMgmtLogWriteNotification

} CLFS_MGMT_NOTIFICATION_TYPE, *PCLFS_MGMT_NOTIFICATION_TYPE;
#endif /* NTDDI_VERSION || _WIN32_WINNT */


#if (NTDDI_VERSION >= NTDDI_WS03SP1) || (_WIN32_WINNT >= _WIN32_WINNT_WS03)
//
// CLFS_MGMT_NOTIFICATION
//
// A notification and associated parameters.
//

typedef struct _CLFS_MGMT_NOTIFICATION
{

    //
    // Nature of the notification.
    //

    CLFS_MGMT_NOTIFICATION_TYPE     Notification;
    
    //
    // Target LSN for base LSN advancement if the
    // notification type is ClfsMgmtAdvanceTailNotification.
    //

    CLFS_LSN                        Lsn;

    //
    // TRUE if the log is pinned, FALSE otherwise.
    // Especially meaningful when receiving an error
    // status for ClfsMgmtLogFullHandlerNotification.
    //

    USHORT                          LogIsPinned;

} CLFS_MGMT_NOTIFICATION, *PCLFS_MGMT_NOTIFICATION;
#endif /* NTDDI_VERSION || _WIN32_WINNT */


//
// Kernel interface described below.
//


#if (NTDDI_VERSION >= NTDDI_WS03SP1) || (_WIN32_WINNT >= _WIN32_WINNT_WS03)
//
// The advance tail callback is required when log clients 
// register for management.  It is invoked whenever the 
// management library decides that this client needs to 
// advance the tail of its log. Only minimal processing is 
// allowed.
//
typedef
NTSTATUS
(*PCLFS_CLIENT_ADVANCE_TAIL_CALLBACK) (
    IN PLOG_FILE_OBJECT LogFile,
    IN PCLFS_LSN        TargetLsn,
    IN PVOID            ClientData
    );
#endif /* NTDDI_VERSION || _WIN32_WINNT */

#if (NTDDI_VERSION >= NTDDI_WS03SP1) || (_WIN32_WINNT >= _WIN32_WINNT_WS03)
//
// The log file full handler complete callback is invoked upon
// completion of a log growth request (that is, via a call 
// to ClfsMgmtHandleLogFileFull).
//
typedef
VOID
(*PCLFS_CLIENT_LFF_HANDLER_COMPLETE_CALLBACK) (
    IN PLOG_FILE_OBJECT LogFile,
    IN NTSTATUS         OperationStatus,
    IN BOOLEAN          LogIsPinned,
    IN PVOID            ClientData
    );
#endif /* NTDDI_VERSION || _WIN32_WINNT */

#if (NTDDI_VERSION >= NTDDI_WS03SP1) || (_WIN32_WINNT >= _WIN32_WINNT_WS03)
//
// The log pinned callback is invoked when log space is freed up
// after a log file full handler completion callback indicates an 
// NT_ERROR status code and LogIsPinned = TRUE.
//

typedef
VOID
(*PCLFS_CLIENT_LOG_UNPINNED_CALLBACK) (
    IN PLOG_FILE_OBJECT LogFile,
    IN PVOID            ClientData
    );
#endif /* NTDDI_VERSION || _WIN32_WINNT */


#if (NTDDI_VERSION >= NTDDI_WS03SP1) || (_WIN32_WINNT >= _WIN32_WINNT_WS03)
//
// The log size complete callback is invoked whenever
// ClfsMgmtSetLogFileSize operation which returned
// STATUS_PENDING is completed.
//

typedef
VOID
(*PCLFS_SET_LOG_SIZE_COMPLETE_CALLBACK) (
    IN PLOG_FILE_OBJECT LogFile,
    IN NTSTATUS         OperationStatus,
    IN PVOID            ClientData
    );
#endif /* NTDDI_VERSION || _WIN32_WINNT */


#if (NTDDI_VERSION >= NTDDI_WS03SP1) || (_WIN32_WINNT >= _WIN32_WINNT_WS03)
//
// CLFS_MGMT_CLIENT_REGISTRATION
//
// This structure is given to the CLFS management infrastructure
// by clients who wish to be managed (via ClfsMgmtRegisterManagedClient).
// The CLFS_MGMT_CLIENT_REGISTRATION_VERSION value must be stored
// in the 'Version' field of the structure.
//

#define CLFS_MGMT_CLIENT_REGISTRATION_VERSION (0x1)

typedef struct _CLFS_MGMT_CLIENT_REGISTRATION {

    //
    // Initialize Version to CLFS_MGMT_CLIENT_REGISTRATION_VERSION.
    //

    ULONG   Version;  

    PCLFS_CLIENT_ADVANCE_TAIL_CALLBACK AdvanceTailCallback;
    PVOID                              AdvanceTailCallbackData;

    PCLFS_CLIENT_LFF_HANDLER_COMPLETE_CALLBACK LogGrowthCompleteCallback;
    PVOID                                      LogGrowthCompleteCallbackData;

    PCLFS_CLIENT_LOG_UNPINNED_CALLBACK LogUnpinnedCallback;
    PVOID                              LogUnpinnedCallbackData;

} CLFS_MGMT_CLIENT_REGISTRATION, *PCLFS_MGMT_CLIENT_REGISTRATION;
#endif /* NTDDI_VERSION || _WIN32_WINNT */


#if (NTDDI_VERSION >= NTDDI_WS03SP1) || (_WIN32_WINNT >= _WIN32_WINNT_WS03)
//
// CLFS_MGMT_CLIENT
//
// This is the cookie that clients are given when registering and
// must give back to the management infrastructure whenever 
// performing an operation.
//
typedef PVOID CLFS_MGMT_CLIENT, *PCLFS_MGMT_CLIENT;
#endif /* NTDDI_VERSION || _WIN32_WINNT */


#if (NTDDI_VERSION >= NTDDI_WS03SP1) || (_WIN32_WINNT >= _WIN32_WINNT_WS03)
NTSTATUS
ClfsMgmtRegisterManagedClient(
    IN  PLOG_FILE_OBJECT LogFile,
    IN  PCLFS_MGMT_CLIENT_REGISTRATION RegistrationData,
    OUT PCLFS_MGMT_CLIENT ClientCookie
    );
#endif /* NTDDI_VERSION || _WIN32_WINNT */

#if (NTDDI_VERSION >= NTDDI_WS03SP1) || (_WIN32_WINNT >= _WIN32_WINNT_WS03)
NTSTATUS
ClfsMgmtDeregisterManagedClient(
    IN CLFS_MGMT_CLIENT ClientCookie
    );
#endif /* NTDDI_VERSION || _WIN32_WINNT */

#if (NTDDI_VERSION >= NTDDI_WS03SP1) || (_WIN32_WINNT >= _WIN32_WINNT_WS03)
NTSTATUS
ClfsMgmtTailAdvanceFailure(
    IN CLFS_MGMT_CLIENT  Client,
    IN NTSTATUS          Reason
    );
#endif /* NTDDI_VERSION || _WIN32_WINNT */

#if (NTDDI_VERSION >= NTDDI_WS03SP1) || (_WIN32_WINNT >= _WIN32_WINNT_WS03)
NTSTATUS
ClfsMgmtHandleLogFileFull(
    IN CLFS_MGMT_CLIENT Client
    );
#endif /* NTDDI_VERSION || _WIN32_WINNT */

#if (NTDDI_VERSION >= NTDDI_WS03SP1) || (_WIN32_WINNT >= _WIN32_WINNT_WS03)
NTSTATUS
ClfsMgmtInstallPolicy(
    IN PLOG_FILE_OBJECT  LogFile,
    IN PCLFS_MGMT_POLICY Policy,
    IN ULONG             PolicyLength
    );
#endif /* NTDDI_VERSION || _WIN32_WINNT */

#if (NTDDI_VERSION >= NTDDI_WS03SP1) || (_WIN32_WINNT >= _WIN32_WINNT_WS03)
NTSTATUS
ClfsMgmtQueryPolicy(
    IN  PLOG_FILE_OBJECT      LogFile,
    IN  CLFS_MGMT_POLICY_TYPE PolicyType,
    OUT PCLFS_MGMT_POLICY     Policy,
    OUT PULONG                PolicyLength
    );
#endif /* NTDDI_VERSION || _WIN32_WINNT */

#if (NTDDI_VERSION >= NTDDI_WS03SP1) || (_WIN32_WINNT >= _WIN32_WINNT_WS03)
NTSTATUS
ClfsMgmtRemovePolicy(
    IN PLOG_FILE_OBJECT      LogFile,
    IN CLFS_MGMT_POLICY_TYPE PolicyType
    );
#endif /* NTDDI_VERSION || _WIN32_WINNT */

#if (NTDDI_VERSION >= NTDDI_WS03SP1) || (_WIN32_WINNT >= _WIN32_WINNT_WS03)
NTSTATUS
ClfsMgmtSetLogFileSize(
    IN  PLOG_FILE_OBJECT  LogFile,
    IN  PULONGLONG        NewSizeInContainers,
    OUT PULONGLONG        ResultingSizeInContainers,
    IN  PCLFS_SET_LOG_SIZE_COMPLETE_CALLBACK CompletionRoutine,
    IN  PVOID                                CompletionRoutineData
    );
#endif /* NTDDI_VERSION || _WIN32_WINNT */


#if (NTDDI_VERSION >= NTDDI_VISTA) || (_WIN32_WINNT >= _WIN32_WINNT_LONGHORN)
NTSTATUS
ClfsMgmtSetLogFileSizeAsClient(
    IN  PLOG_FILE_OBJECT  LogFile,
    IN  PCLFS_MGMT_CLIENT ClientCookie OPTIONAL,
    IN  PULONGLONG        NewSizeInContainers,
    OUT PULONGLONG        ResultingSizeInContainers,
    IN  PCLFS_SET_LOG_SIZE_COMPLETE_CALLBACK CompletionRoutine,
    IN  PVOID                                CompletionRoutineData
    );
#endif /* NTDDI_VERSION || _WIN32_WINNT */


#ifdef __cplusplus
} // extern "C"
#endif

#ifndef __CLFSPROC_H__
#define __CLFSPROC_H__

#ifdef __cplusplus
extern "C"
{
#endif /* __cplusplus */

#if (NTDDI_VERSION >= NTDDI_WS03SP1)
//------------------------------------------------------------------------------
// ClfsInitialize
//
// Utility to initialize CLFS global resources, lookaside lists, and memory.
//------------------------------------------------------------------------------

NTSTATUS ClfsInitialize (void);
#endif /* NTDDI_VERSION */

#if (NTDDI_VERSION >= NTDDI_WS03SP1)
//------------------------------------------------------------------------------
// ClfsFinalize
//
// Utility to cleanup CLFS global resources, lookaside lists, and memory.
//------------------------------------------------------------------------------

void ClfsFinalize (void);
#endif /* NTDDI_VERSION */


#if (NTDDI_VERSION >= NTDDI_WS03SP1)
//------------------------------------------------------------------------------
// ClfsCreateLogFile
//
// Entry point to create a physical log file consisting of uniformly sized
// containers lying in a given directory path.
//------------------------------------------------------------------------------

NTSTATUS ClfsCreateLogFile (
                    OUT PPLOG_FILE_OBJECT pplfoLog,
                    IN PUNICODE_STRING puszLogFileName,
                    IN ACCESS_MASK fDesiredAccess,
                    IN ULONG dwShareMode,
                    IN PSECURITY_DESCRIPTOR psdLogFile,
                    IN ULONG fCreateDisposition,
                    IN ULONG fCreateOptions,
                    IN ULONG fFlagsAndAttributes,
                    IN ULONG fLogOptionFlag,
                    IN PVOID pvContext OPTIONAL,
                    IN ULONG cbContext
                    );
#endif /* NTDDI_VERSION */

#if (NTDDI_VERSION >= NTDDI_WS03SP1)
//------------------------------------------------------------------------------
// ClfsDeleteLogByPointer
//
// Entry point to delete a physical log file and its underlying container
// storage referencing a log file object.
//------------------------------------------------------------------------------

NTSTATUS ClfsDeleteLogByPointer (IN PLOG_FILE_OBJECT plfoLog);
#endif /* NTDDI_VERSION */

#if (NTDDI_VERSION >= NTDDI_WS03SP1)
//------------------------------------------------------------------------------
// ClfsDeleteLogFile
//
// Entry point to delete a physical log file and its underlying container
// storage by name.
//------------------------------------------------------------------------------

NTSTATUS ClfsDeleteLogFile (
                    IN PUNICODE_STRING puszLogFileName,
                    IN PVOID pvReserved,
                    IN ULONG fLogOptionFlag,
                    IN PVOID pvContext OPTIONAL,
                    IN ULONG cbContext
                    );
#endif /* NTDDI_VERSION */

#if (NTDDI_VERSION >= NTDDI_WS03SP1)
//------------------------------------------------------------------------------
// ClfsAddLogContainer
//
// Adds a log container to a given physical file identified by the log
// file object pointer.
//------------------------------------------------------------------------------

NTSTATUS ClfsAddLogContainer (
                    IN PLOG_FILE_OBJECT plfoLog,
                    IN PULONGLONG pcbContainer,
                    IN PUNICODE_STRING puszContainerPath
                    );
#endif /* NTDDI_VERSION */

#if (NTDDI_VERSION >= NTDDI_WS03SP1)
//------------------------------------------------------------------------------
// ClfsAddLogContainerSet
//
// Adds a set of log containers to a given physical file identified by the log
// file object pointer.
//------------------------------------------------------------------------------

NTSTATUS ClfsAddLogContainerSet (
                    IN PLOG_FILE_OBJECT plfoLog,
                    IN USHORT cContainers,
                    IN PULONGLONG pcbContainer OPTIONAL,
                    IN PUNICODE_STRING rguszContainerPath
                    );
#endif /* NTDDI_VERSION */

#if (NTDDI_VERSION >= NTDDI_WS03SP1)
//------------------------------------------------------------------------------
// ClfsRemoveLogContainer
//
// Removes a log container from a physical log file identified by
// the log file object pointer.
//------------------------------------------------------------------------------

NTSTATUS ClfsRemoveLogContainer (
                    IN PLOG_FILE_OBJECT plfoLog,
                    IN PUNICODE_STRING puszContainerPath,
                    IN BOOLEAN fForce
                    );
#endif /* NTDDI_VERSION */

#if (NTDDI_VERSION >= NTDDI_WS03SP1)
//------------------------------------------------------------------------------
// ClfsRemoveLogContainerSet
//
// Removes a set of log containers from a physical log file identified by
// the log file object pointer.
//------------------------------------------------------------------------------

NTSTATUS ClfsRemoveLogContainerSet (
                    IN PLOG_FILE_OBJECT plfoLog,
                    IN USHORT cContainers,
                    IN PUNICODE_STRING rgwszContainerPath,
                    IN BOOLEAN fForce
                    );
#endif /* NTDDI_VERSION */

#if (NTDDI_VERSION >= NTDDI_WS03SP1)
//------------------------------------------------------------------------------
// ClfsSetArchiveTail
//
// Sets the archive tail for either a client or physical log file
// depending on the type of the log handle.
//------------------------------------------------------------------------------

NTSTATUS ClfsSetArchiveTail (
                    IN PLOG_FILE_OBJECT plfoLog,
                    IN PCLFS_LSN plsnArchiveTail
                    );
#endif /* NTDDI_VERSION */

#if (NTDDI_VERSION >= NTDDI_WS03SP1)
//------------------------------------------------------------------------------
// ClfsSetEndOfLog
//
// Sets the end of log for either a client or physical log file
// depending on the type of the log handle.
//------------------------------------------------------------------------------

NTSTATUS ClfsSetEndOfLog (
                    IN PLOG_FILE_OBJECT plfoLog,
                    IN PCLFS_LSN plsnEnd
                    );
#endif /* NTDDI_VERSION */

#if (NTDDI_VERSION >= NTDDI_WS03SP1)
//------------------------------------------------------------------------------
// ClfsCreateScanContext
//
// Create a scan context to enumerate scan descriptors for storage containers 
// that back the physical log file object.
//------------------------------------------------------------------------------

NTSTATUS ClfsCreateScanContext (
                    IN PLOG_FILE_OBJECT plfoLog,
                    IN ULONG cFromContainer,
                    IN ULONG cContainers,
                    IN CLFS_SCAN_MODE eScanMode,
                    IN OUT PCLFS_SCAN_CONTEXT pcxScan
                    );
#endif /* NTDDI_VERSION */

#if (NTDDI_VERSION >= NTDDI_WS03SP1)
//------------------------------------------------------------------------------
// ClfsScanLogContainers
//
// Scan descriptors for storage containers backing the physical
// log file stream.
//------------------------------------------------------------------------------

NTSTATUS ClfsScanLogContainers (
                    IN OUT PCLFS_SCAN_CONTEXT pcxScan,
                    IN CLFS_SCAN_MODE eScanMode
                    );
#endif /* NTDDI_VERSION */

#if (NTDDI_VERSION >= NTDDI_WS03SP1)
//------------------------------------------------------------------------------
// ClfsGetContainerName
//
// ClfsGetContainerName gets the full path name of a container given its logical
// container identifier.
//
//------------------------------------------------------------------------------

NTSTATUS ClfsGetContainerName (
                    IN PLOG_FILE_OBJECT plfoLog,
                    IN CLFS_CONTAINER_ID cidLogicalContainer,
                    IN OUT PUNICODE_STRING puszContainerName,
                    OUT PULONG pcActualLenContainerName OPTIONAL
                    );
#endif /* NTDDI_VERSION */

#if (NTDDI_VERSION >= NTDDI_WS03SP1)
//------------------------------------------------------------------------------
// ClfsGetLogFileInformation
//
// Get log file information for a physical log and client stream
// specific to the log file object pointer.
//
// Deprecated.  Use ClfsQueryLogFileInformation instead (it is equivalent
// to this call if ClfsLogBasicInformation is used as information class).
//
//------------------------------------------------------------------------------

NTSTATUS ClfsGetLogFileInformation (
                    IN PLOG_FILE_OBJECT plfoLog,
                    OUT PCLFS_INFORMATION pinfoBuffer,
                    IN OUT PULONG pcbBuffer
                    );
#endif /* NTDDI_VERSION */

#if (NTDDI_VERSION >= NTDDI_VISTA)
//------------------------------------------------------------------------------
// ClfsQueryLogFileInformation
//
// Get log file information for a physical log and client stream
// specific to the log file object pointer.
//------------------------------------------------------------------------------

NTSTATUS ClfsQueryLogFileInformation (
                    __in PLOG_FILE_OBJECT plfoLog,
                    __in CLFS_LOG_INFORMATION_CLASS eInformationClass,
                    __in_bcount_opt(cbinfoInputBuffer) PVOID pinfoInputBuffer,
                    __in_opt ULONG cbinfoInputBuffer,
                    __out_bcount(*pcbInfoBuffer) PVOID pinfoBuffer,
                    __inout PULONG pcbInfoBuffer
                    );
#endif /* NTDDI_VERSION */

#if (NTDDI_VERSION >= NTDDI_WS03SP1)
//------------------------------------------------------------------------------
// ClfsSetLogFileInformation
//
// Sets log file information for a physical log and client stream
// specific to the log file object pointer.
//------------------------------------------------------------------------------

NTSTATUS ClfsSetLogFileInformation (
                    IN PLOG_FILE_OBJECT plfoLog,
                    IN CLFS_LOG_INFORMATION_CLASS eInformationClass,
                    IN OUT PVOID pinfoBuffer,
                    IN ULONG cbBuffer
                    );
#endif /* NTDDI_VERSION */

#if (NTDDI_VERSION >= NTDDI_WS03SP1)
//------------------------------------------------------------------------------
// ClfsReadRestartArea
//
// Read the last restart area successfully written to a physical or 
// client log stream given a marshalling context.
//------------------------------------------------------------------------------

NTSTATUS ClfsReadRestartArea (
                    IN OUT PVOID pvMarshalContext,
                    OUT PVOID *ppvRestartBuffer,
                    OUT PULONG pcbRestartBuffer,
                    OUT PCLFS_LSN plsn,
                    OUT PVOID *ppvReadContext
                    );
#endif /* NTDDI_VERSION */

#if (NTDDI_VERSION >= NTDDI_WS03SP1)
//------------------------------------------------------------------------------
// ClfsReadPreviousRestartArea
//
// Read the previous restart area successfully written to a physical or 
// client log stream given the read context created by the a call to
// ClfsReadRestartArea.
//------------------------------------------------------------------------------

NTSTATUS ClfsReadPreviousRestartArea (
                    IN PVOID pvReadContext,
                    OUT PVOID *ppvRestartBuffer,
                    OUT PULONG pcbRestartBuffer,
                    OUT PCLFS_LSN plsnRestart
                    );
#endif /* NTDDI_VERSION */

#if (NTDDI_VERSION >= NTDDI_WS03SP1)
//------------------------------------------------------------------------------
// ClfsWriteRestartArea
//
// Write a new restart area to a physical or client log stream given a
// a marshalling context.
//------------------------------------------------------------------------------

NTSTATUS ClfsWriteRestartArea (
                    IN OUT PVOID pvMarshalContext,
                    IN PVOID pvRestartBuffer,
                    IN ULONG cbRestartBuffer,
                    IN PCLFS_LSN plsnBase,
                    IN ULONG fFlags,
                    OUT PULONG pcbWritten OPTIONAL,
                    OUT PCLFS_LSN plsnNext OPTIONAL
                    );
#endif /* NTDDI_VERSION */

#if (NTDDI_VERSION >= NTDDI_WS03SP1)
//------------------------------------------------------------------------------
// ClfsAdvanceLogBase
//
// Set a new log base LSN without writing a restart record.
//------------------------------------------------------------------------------

NTSTATUS ClfsAdvanceLogBase (
                    IN OUT PVOID pvMarshalContext,
                    IN PCLFS_LSN plsnBase,
                    IN ULONG fFlags
                    );
#endif /* NTDDI_VERSION */

#if (NTDDI_VERSION >= NTDDI_WS03SP1)
//------------------------------------------------------------------------------
// ClfsCloseAndResetLogFile
//
// Orderly shutdown of a physical or client log file stream given the log file
// object pointer.
//------------------------------------------------------------------------------

NTSTATUS ClfsCloseAndResetLogFile (IN PLOG_FILE_OBJECT plfoLog);
#endif /* NTDDI_VERSION */

#if (NTDDI_VERSION >= NTDDI_WS03SP1)
//------------------------------------------------------------------------------
// ClfsCloseLogFileObject
//
// Close a log file object without the orderly shutdown of the log.
//------------------------------------------------------------------------------

NTSTATUS  ClfsCloseLogFileObject (IN PLOG_FILE_OBJECT plfoLog);
#endif /* NTDDI_VERSION */

#if (NTDDI_VERSION >= NTDDI_WS03SP1)
//------------------------------------------------------------------------------
// ClfsCreateMarshallingArea
//
// Initalize a marshalling area for a physical or client log
// file stream given log file object pointer.
//------------------------------------------------------------------------------

NTSTATUS ClfsCreateMarshallingArea (
                    IN PLOG_FILE_OBJECT plfoLog,
                    IN POOL_TYPE ePoolType,
                    IN PALLOCATE_FUNCTION pfnAllocBuffer OPTIONAL,
                    IN PFREE_FUNCTION pfnFreeBuffer OPTIONAL,
                    IN ULONG cbMarshallingBuffer,
                    IN ULONG cMaxWriteBuffers,
                    IN ULONG cMaxReadBuffers,
                    OUT PVOID *ppvMarshalContext
                    );
#endif /* NTDDI_VERSION */

#if (NTDDI_VERSION >= NTDDI_WS03SP1)
//------------------------------------------------------------------------------
// ClfsDeleteMarshallingArea
//
// Delete a marshalling area for a physical or client log
// file stream.
//------------------------------------------------------------------------------

NTSTATUS ClfsDeleteMarshallingArea (IN PVOID pvMarshalContext);
#endif /* NTDDI_VERSION */

#if (NTDDI_VERSION >= NTDDI_WS03SP1)
//------------------------------------------------------------------------------
// ClfsReserveAndAppendLog
//
// Reserve space and append log buffers to a physical or client
// log stream.
//------------------------------------------------------------------------------

NTSTATUS ClfsReserveAndAppendLog (
                    IN PVOID pvMarshalContext,
                    IN PCLFS_WRITE_ENTRY rgWriteEntries OPTIONAL,
                    IN ULONG cWriteEntries,
                    IN PCLFS_LSN plsnUndoNext OPTIONAL,
                    IN PCLFS_LSN plsnPrevious OPTIONAL,
                    IN ULONG cReserveRecords,
                    IN OUT PLONGLONG rgcbReservation OPTIONAL,
                    IN ULONG fFlags,
                    OUT PCLFS_LSN plsn OPTIONAL
                    );
#endif /* NTDDI_VERSION */

#if (NTDDI_VERSION >= NTDDI_WS03SP1)
//------------------------------------------------------------------------------
// ClfsReserveAndAppendLogAligned
//
// Reserve space and append log buffers to a physical or client
// log stream, aligning each of the write entries according to
// the alignment specified.
//------------------------------------------------------------------------------

NTSTATUS ClfsReserveAndAppendLogAligned (
                    IN PVOID pvMarshalContext,
                    IN PCLFS_WRITE_ENTRY rgWriteEntries OPTIONAL,
                    IN ULONG cWriteEntries,
                    IN ULONG cbEntryAlignment,
                    IN PCLFS_LSN plsnUndoNext OPTIONAL,
                    IN PCLFS_LSN plsnPrevious OPTIONAL,
                    IN ULONG cReserveRecords,
                    IN OUT PLONGLONG rgcbReservation OPTIONAL,
                    IN ULONG fFlags,
                    OUT PCLFS_LSN plsn OPTIONAL
                    );
#endif /* NTDDI_VERSION */

#if (NTDDI_VERSION >= NTDDI_WS03SP1)
//------------------------------------------------------------------------------
// ClfsAlignReservedLog
//
// Given a valid marshalling context, allocate an aggregate number of reserved
// records and bytes.
//------------------------------------------------------------------------------

NTSTATUS ClfsAlignReservedLog (
                    IN PVOID pvMarshalContext,
                    IN ULONG cRecords,
                    IN LONGLONG rgcbReservation [],
                    OUT PLONGLONG pcbAlignReservation
                    );
#endif /* NTDDI_VERSION */

#if (NTDDI_VERSION >= NTDDI_WS03SP1)
//------------------------------------------------------------------------------
// ClfsAllocReservedLog
//
// Given a valid marshalling context, allocate an aggregate number of reserved
// records and bytes.
//------------------------------------------------------------------------------

NTSTATUS ClfsAllocReservedLog (
                    IN PVOID pvMarshalContext,
                    IN ULONG cRecords,
                    IN PLONGLONG pcbAdjustment
                    );
#endif /* NTDDI_VERSION */

#if (NTDDI_VERSION >= NTDDI_WS03SP1)
//------------------------------------------------------------------------------
// ClfsFreeReservedLog
//
// Set the reserved log space to a new size or specify a delta
// for the reserved space given log file.
//------------------------------------------------------------------------------

NTSTATUS ClfsFreeReservedLog (
                    IN PVOID pvMarshalContext,
                    IN ULONG cRecords,
                    IN PLONGLONG pcbAdjustment
                    );
#endif /* NTDDI_VERSION */

#if (NTDDI_VERSION >= NTDDI_WS03SP1)
//------------------------------------------------------------------------------
// ClfsFlushBuffers
// 
// Append all buffers in the marshalling area up to the flush queue and flush
// all buffers up to the disk.
//------------------------------------------------------------------------------

NTSTATUS ClfsFlushBuffers (IN PVOID pvMarshalContext);
#endif /* NTDDI_VERSION */

#if (NTDDI_VERSION >= NTDDI_WS03SP1)
//------------------------------------------------------------------------------
// ClfsFlushToLsn
// 
// Flush all buffers in the marshalling area up to a target LSN to the flush
// queue and flush all buffers up to the target LSN to the disk.
//------------------------------------------------------------------------------

NTSTATUS ClfsFlushToLsn (
                    IN PVOID pvMarshalContext,
                    IN PCLFS_LSN plsnFlush,
                    OUT PCLFS_LSN plsnLastFlushed OPTIONAL
                    );
#endif /* NTDDI_VERSION */

#if (NTDDI_VERSION >= NTDDI_WS03SP1)
//------------------------------------------------------------------------------
// ClfsReadLogRecord
//
// Read a log record from a physical or client log stream given
// a starting LSN.
//------------------------------------------------------------------------------

NTSTATUS ClfsReadLogRecord (
                    IN PVOID pvMarshalContext,
                    IN OUT PCLFS_LSN plsnFirst,
                    IN CLFS_CONTEXT_MODE peContextMode,
                    OUT PVOID *ppvReadBuffer,
                    OUT PULONG pcbReadBuffer,
                    OUT PCLFS_RECORD_TYPE peRecordType,
                    OUT PCLFS_LSN plsnUndoNext,
                    OUT PCLFS_LSN plsnPrevious,
                    OUT PVOID* ppvReadContext
                    );
#endif /* NTDDI_VERSION */

#if (NTDDI_VERSION >= NTDDI_WS03SP1)
//------------------------------------------------------------------------------
// ClfsReadNextLogRecord
//
// Read the next log record from a given marshalling context.
//------------------------------------------------------------------------------

NTSTATUS ClfsReadNextLogRecord (
                    IN OUT PVOID pvReadContext,
                    OUT PVOID *ppvBuffer,
                    OUT PULONG pcbBuffer,
                    IN OUT PCLFS_RECORD_TYPE peRecordType,
                    IN PCLFS_LSN plsnUser OPTIONAL,
                    OUT PCLFS_LSN plsnUndoNext,
                    OUT PCLFS_LSN plsnPrevious,
                    OUT PCLFS_LSN plsnRecord
                    );
#endif /* NTDDI_VERSION */

#if (NTDDI_VERSION >= NTDDI_WS03SP1)
//------------------------------------------------------------------------------
// ClfsTerminateReadLog
//
// Terminate the read context.
//------------------------------------------------------------------------------

NTSTATUS ClfsTerminateReadLog (IN PVOID pvCursorContext);
#endif /* NTDDI_VERSION */

#if (NTDDI_VERSION >= NTDDI_WS03SP1)
//------------------------------------------------------------------------------
// ClfsGetLastLsn
//
// Get the last used LSN.
//------------------------------------------------------------------------------

NTSTATUS ClfsGetLastLsn (
                    IN PLOG_FILE_OBJECT plfoLog,
                    OUT PCLFS_LSN plsnLast
                    );
#endif /* NTDDI_VERSION */

#if (NTDDI_VERSION >= NTDDI_WS03SP1)
//------------------------------------------------------------------------------
// ClfsGetIoStatistics
//
// Get I/O statistics on the CLFS log file.
//------------------------------------------------------------------------------

NTSTATUS ClfsGetIoStatistics (
                    IN PLOG_FILE_OBJECT plfoLog,
                    IN OUT PVOID pvStatsBuffer,
                    IN ULONG cbStatsBuffer,
                    IN CLFS_IOSTATS_CLASS eStatsClass,
                    OUT PULONG pcbStatsWritten OPTIONAL
                    );
#endif /* NTDDI_VERSION */

#if (NTDDI_VERSION >= NTDDI_WS03SP1)
//-----------------------------------------------------------------------------
// ClfsLaterLsn
//
//      Method Description:
//
//          Increment an LSN by 1
//
//      Arguments:
//
//          plsn -- LSN to be incremented.
//          
//
//      Return Value:
//
//          A valid LSN next in sequence to the input LSN, if successful.
//          Otherwise, this function returns CLFS_LSN_INVALID.
//
//-----------------------------------------------------------------------------

CLFS_LSN
ClfsLaterLsn (IN PCLFS_LSN plsn);
#endif /* NTDDI_VERSION */

#if (NTDDI_VERSION >= NTDDI_WS03SP1)
//-----------------------------------------------------------------------------
// ClfsEarlierLsn
//
//      Method Description:
//
//          Decrement an LSN by 1
//
//      Arguments:
//
//          plsn -- LSN to be decremented.
//          
//
//      Return Value:
//
//          A valid LSN next in sequence to the input LSN, if successful.
//          Otherwise, this function returns CLFS_LSN_INVALID.
//
//-----------------------------------------------------------------------------

CLFS_LSN
ClfsEarlierLsn (IN PCLFS_LSN plsn);
#endif /* NTDDI_VERSION */

#if (NTDDI_VERSION >= NTDDI_WS03SP1)
//----------------------------------------------------------------------------
// ClfsLsnDifference
//
//      Method Description:
//
//          Find the approximate number of bytes between two LSNs.
//
//      Arguments:
//
//          plsnStart       -- LSN start of the log file range
//          plsnFinish      -- LSN finish of the log file range
//          cbContainer     -- size of a container
//          cbMaxBlock      -- maximum size of an I/O block
//          pcbDifference   -- approximate number of bytes between two LSNs.
//          
//          
//
//      Return Value:
//
//          STATUS_SUCCESS if difference is succeeds and an error status
//          otherwise.
//
//-----------------------------------------------------------------------------

NTSTATUS
ClfsLsnDifference (
    IN PCLFS_LSN    plsnStart,
    IN PCLFS_LSN    plsnFinish,
    IN ULONG        cbContainer,
    IN ULONG        cbMaxBlock,
    OUT PLONGLONG   pcbDifference
    );
#endif /* NTDDI_VERSION */

#if (NTDDI_VERSION >= NTDDI_VISTA)
//----------------------------------------------------------------------------
// ClfsValidTopLevelContext
//
//      Method Description:
//
//          Check that the current top level context is a common log (CLFS)
//          context.
//
//      Arguments:
//
//          pirp            -- reference to top of top-level context stack      
//          
//      Return Value:
//
//          TRUE if this is a valid CLFS top-level context and FALSE otherwise.
//
//-----------------------------------------------------------------------------

BOOLEAN
ClfsValidTopLevelContext (IN PIRP pirpTopLevelContext);
#endif /* NTDDI_VERSION */


#ifdef __cplusplus
}
#endif /* __cplusplus */

#endif /* __CLFSPROC_H__ */

typedef struct _KTRANSACTION KTRANSACTION, *PKTRANSACTION, *RESTRICTED_POINTER PRKTRANSACTION;
typedef struct _KENLISTMENT KENLISTMENT, *PKENLISTMENT, *RESTRICTED_POINTER PRKENLISTMENT;
typedef struct _KRESOURCEMANAGER KRESOURCEMANAGER, *PKRESOURCEMANAGER, *RESTRICTED_POINTER PRKRESOURCEMANAGER;
typedef struct _KTM KTM, *PKTM, *RESTRICTED_POINTER PRKTM;

typedef GUID UOW, *PUOW;
typedef GUID *PGUID;

//
// Define ResourceManager Notification routine type.
//

typedef
NTSTATUS
(NTAPI *PTM_RM_NOTIFICATION) (
    IN     PKENLISTMENT EnlistmentObject,
    IN     PVOID RMContext,
    IN     PVOID TransactionContext,
    IN     ULONG TransactionNotification,
    IN OUT PLARGE_INTEGER TmVirtualClock,
    IN     ULONG ArgumentLength,
    IN     PVOID Argument
    );

//
// CRM Protocol object
//

typedef GUID KCRM_PROTOCOL_ID, *PKCRM_PROTOCOL_ID;

typedef
NTSTATUS
(NTAPI *PTM_PROPAGATE_ROUTINE) (
    IN PVOID    PropagationCookie,
    IN PVOID    CallbackData,
    IN NTSTATUS PropagationStatus,
    IN GUID     TransactionGuid
    );

//
// Tm-level Transaction APIs
//

NTKERNELAPI
NTSTATUS
NTAPI
TmInitializeTransactionManager (
    IN PRKTM TransactionManager,
    IN PCUNICODE_STRING LogFileName,
    IN PGUID TmId,
    IN ULONG CreateOptions OPTIONAL
    );


NTKERNELAPI
NTSTATUS
NTAPI
TmRenameTransactionManager (
    IN PUNICODE_STRING LogFileName,
    IN LPGUID ExistingTransactionManagerGuid
    );

NTKERNELAPI
NTSTATUS
NTAPI
TmRecoverTransactionManager (
    IN PKTM Tm,
    IN PLARGE_INTEGER TargetVirtualClock
    );

NTKERNELAPI
NTSTATUS
NTAPI
TmCommitTransaction (
    IN PKTRANSACTION Transaction,
    IN BOOLEAN       Wait
    );


NTKERNELAPI
NTSTATUS
NTAPI
TmRollbackTransaction (
    IN PKTRANSACTION Transaction,
    IN BOOLEAN       Wait
    );


NTKERNELAPI
NTSTATUS
NTAPI
TmCreateEnlistment (
    OUT PHANDLE           EnlistmentHandle,
    IN KPROCESSOR_MODE    PreviousMode,
    IN ACCESS_MASK        DesiredAccess,
    IN POBJECT_ATTRIBUTES ObjectAttributes,
    IN PRKRESOURCEMANAGER ResourceManager,
    IN PKTRANSACTION      Transaction,
    IN ULONG              CreateOptions OPTIONAL,
    IN NOTIFICATION_MASK  NotificationMask,
    IN PVOID              EnlistmentKey OPTIONAL
    );

NTKERNELAPI
NTSTATUS
NTAPI
TmRecoverEnlistment (
    IN PKENLISTMENT Enlistment,
    IN PVOID        EnlistmentKey
    );

NTKERNELAPI
NTSTATUS
NTAPI
TmPrePrepareEnlistment (
    IN PKENLISTMENT Enlistment,
    IN PLARGE_INTEGER TmVirtualClock
    );

NTKERNELAPI
NTSTATUS
NTAPI
TmPrepareEnlistment (
    IN PKENLISTMENT Enlistment,
    IN PLARGE_INTEGER TmVirtualClock
    );

NTKERNELAPI
NTSTATUS
NTAPI
TmCommitEnlistment (
    IN PKENLISTMENT Enlistment,
    IN PLARGE_INTEGER TmVirtualClock
    );

NTKERNELAPI
NTSTATUS
NTAPI
TmRollbackEnlistment (
    IN PKENLISTMENT Enlistment,
    IN PLARGE_INTEGER TmVirtualClock
    );

NTKERNELAPI
NTSTATUS
NTAPI
TmPrePrepareComplete (
    IN PKENLISTMENT Enlistment,
    IN PLARGE_INTEGER TmVirtualClock
    );

NTKERNELAPI
NTSTATUS
NTAPI
TmPrepareComplete (
    IN PKENLISTMENT Enlistment,
    IN PLARGE_INTEGER TmVirtualClock
    );

NTKERNELAPI
NTSTATUS
NTAPI
TmReadOnlyEnlistment (
    IN PKENLISTMENT Enlistment,
    IN PLARGE_INTEGER TmVirtualClock
    );

NTKERNELAPI
NTSTATUS
NTAPI
TmCommitComplete (
    IN PKENLISTMENT Enlistment,
    IN PLARGE_INTEGER TmVirtualClock
    );

NTKERNELAPI
NTSTATUS
NTAPI
TmRollbackComplete (
    IN PKENLISTMENT Enlistment,
    IN PLARGE_INTEGER TmVirtualClock
    );

NTKERNELAPI
NTSTATUS
NTAPI
TmReferenceEnlistmentKey (
    IN PKENLISTMENT Enlistment,
    OUT PVOID *Key
    );

NTKERNELAPI
NTSTATUS
NTAPI
TmDereferenceEnlistmentKey (
    IN PKENLISTMENT Enlistment,
    OUT BOOLEAN *LastReference OPTIONAL
    );

NTKERNELAPI
NTSTATUS
NTAPI
TmSinglePhaseReject (
    IN PKENLISTMENT Enlistment,
    IN PLARGE_INTEGER TmVirtualClock
    );

NTKERNELAPI
NTSTATUS
NTAPI
TmRequestOutcomeEnlistment (
    IN PKENLISTMENT Enlistment,
    IN PLARGE_INTEGER TmVirtualClock
    );


//
// ResourceManager APIs
//

NTKERNELAPI
NTSTATUS
NTAPI
TmEnableCallbacks (
    IN PKRESOURCEMANAGER ResourceManager,
    IN PTM_RM_NOTIFICATION CallbackRoutine,
    IN PVOID RMKey OPTIONAL
    );

NTKERNELAPI
NTSTATUS
NTAPI
TmRecoverResourceManager (
    IN PKRESOURCEMANAGER ResourceManager
    );

NTKERNELAPI
NTSTATUS
NTAPI
TmRegisterProtocolAddressInformation(
    IN PKRESOURCEMANAGER ResourceManager,
    IN PKCRM_PROTOCOL_ID ProtocolId,
    IN ULONG             ProtocolInformationSize,
    IN PVOID             ProtocolInformation
    );

NTKERNELAPI
NTSTATUS
NTAPI
TmPropagationComplete(
    IN  PKRESOURCEMANAGER ResourceManager,
    IN  ULONG             RequestCookie,
    IN  ULONG             BufferLength,
    IN  PVOID             Buffer
    );

NTKERNELAPI
NTSTATUS
NTAPI
TmPropagationFailed(
    IN  PKRESOURCEMANAGER ResourceManager,
    IN  ULONG             RequestCookie,
    IN  NTSTATUS          Status
    );

NTKERNELAPI
VOID
NTAPI
TmGetTransactionId(
    IN  PKTRANSACTION Transaction,
    OUT PUOW TransactionId
    );

NTKERNELAPI
BOOLEAN
NTAPI
TmIsTransactionActive (
    IN  PKTRANSACTION Transaction
    );



extern POBJECT_TYPE *IoFileObjectType;
extern POBJECT_TYPE *ExEventObjectType;
extern POBJECT_TYPE *ExSemaphoreObjectType;
extern POBJECT_TYPE *TmTransactionManagerObjectType;
extern POBJECT_TYPE *TmResourceManagerObjectType;
extern POBJECT_TYPE *TmEnlistmentObjectType;
extern POBJECT_TYPE *TmTransactionObjectType;
extern POBJECT_TYPE *PsProcessType;
extern POBJECT_TYPE *PsThreadType;


#ifdef __cplusplus
}
#endif

#if _MSC_VER >= 1200
#pragma warning(pop)
#else
#pragma warning(default:4115)
#pragma warning(default:4201)
#pragma warning(default:4214)
#endif

#endif // _WDMDDK_
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\win2k8\ddk\inc\wiamindr.h ===
#if (NTDDI_VERSION >= NTDDI_VISTA)
#include <wiamindr_lh.h>
#elif (NTDDI_VERSION >= NTDDI_WINXP)
#include <wiamindr_xp.h>
#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\win2k8\ddk\inc\wdmsec.h ===
/*++

Copyright (c) Microsoft Corporation. All rights reserved.

Module Name:

    wdmsec.h

Abstract:

    This header exposes secuity routines to drivers that need them.

Revision History:

--*/

#ifndef _WDMSEC_H_
#define _WDMSEC_H_
#pragma once

#ifdef __cplusplus
extern "C" {
#endif

//
// SDDL_DEVOBJ_KERNEL_ONLY is an "empty" ACL. User mode code (including
// processes running as system) cannot open the device.
//
// This could be used by a driver creating a raw WDM PDO. The INF would specify
// lighter security settings. Until the INF was processed, the device would
// be nonopenable by user mode code.
//
// Similarly, a legacy driver might use this ACL, and let its install app open
// the device up at runtime to individual users. The install app would update
// the class key with a very target ACL and reload the driver. The empty ACL
// would only kick in only if the driver was loaded without the appropriate
// security applied by the install app.
//
// In all of these cases, the default is strong security, lightened as
// necessary (just like chemistry, where the rule is "add acid to water,
// never water to acid").
//
// Example usage:
//     IoCreateDeviceSecure(..., &SDDL_DEVOBJ_KERNEL_ONLY, &Guid, ...);
//

/*
DECLARE_CONST_UNICODE_STRING(SDDL_DEVOBJ_KERNEL_ONLY, L"D:P");
*/
extern const UNICODE_STRING     SDDL_DEVOBJ_KERNEL_ONLY;

//
// IoCreateDeviceSecure can be used to create a WDM PDO that initially can be
// opened only by kernel mode, at least until an INF is supplied. Note that
// IoCreateDeviceSecure should *never* be used for an FDO!!!
//
#define SDDL_DEVOBJ_INF_SUPPLIED        SDDL_DEVOBJ_KERNEL_ONLY

//
// SDDL_DEVOBJ_SYS_ALL is similar to SDDL_DEVOBJ_KERNEL_ONLY, except that in
// addition to kernel code, user mode code running as *SYSTEM* is also allowed
// to open the device for any access.
//
// A legacy driver might use this ACL to start with tight security settings,
// and let its service open the device up at runtime to individual users via
// SetFileSecurity API. In this case, the service would have to be running as
// system.
//
// (Note that the DEVOBJ SDDL strings in this file don't specify any
// inheritance. This is because inheritance isn't a valid concept for things
// behind a device object, like a file. As such, these SDDL strings would have
// to be modified with inheritance tokens like "OICI" to be used for things
// like registry keys or file. See the SDK's documentation on SDDL strings for
// more information.)
//

/*
DECLARE_CONST_UNICODE_STRING(SDDL_DEVOBJ_SYS_ALL, L"D:P(A;;GA;;;SY)");
*/
extern const UNICODE_STRING     SDDL_DEVOBJ_SYS_ALL;


//
// SDDL_DEVOBJ_SYS_ALL_ADM_ALL allows the kernel, system, and admin complete
// control over the device. No other users may access the device
//

/*
DECLARE_CONST_UNICODE_STRING(
    SDDL_DEVOBJ_SYS_ALL_ADM_ALL,
    L"D:P(A;;GA;;;SY)(A;;GA;;;BA)"
    );
*/
extern const UNICODE_STRING     SDDL_DEVOBJ_SYS_ALL_ADM_ALL;


//
// SDDL_DEVOBJ_SYS_ALL_ADM_RX allows the kernel and system complete control
// over the device. By default the admin can only read from the device (the
// admin can of course override this manually).
//
// The X refers to traversal, meaning the access to the namespace *beneath* a
// device object. This only has an effect on storage stacks today. To lock down
// the namespace behind a device (for example, if the device doesn't _have_ a
// namespace), see the documentation on FILE_DEVICE_SECURE_OPEN flag to
// IoCreateDevice{Secure}.
//

/*
DECLARE_CONST_UNICODE_STRING(
    SDDL_DEVOBJ_SYS_ALL_ADM_RX,
    L"D:P(A;;GA;;;SY)(A;;GRGX;;;BA)"
    );
*/
extern const UNICODE_STRING     SDDL_DEVOBJ_SYS_ALL_ADM_RX;


//
// SDDL_DEVOBJ_SYS_ALL_ADM_RWX_WORLD_R allows the kernel and system complete
// control over the device. By default the admin can access the entire device,
// but cannot change the ACL (the admin must take control of the device first)
//
// Everyone (the WORLD SID) is given read access. "Untrusted" code *cannot*
// access the device (untrusted code might be code launched via the Run-As
// option in Explorer. By default, World does not cover Restricted code.)
//
// Also note that traversal access is not granted to normal users. As such,
// this might not be an appropriate descriptor for a storage device with a
// namespace.
//

/*
DECLARE_CONST_UNICODE_STRING(
    SDDL_DEVOBJ_SYS_ALL_ADM_RWX_WORLD_R,
    L"D:P(A;;GA;;;SY)(A;;GRGWGX;;;BA)(A;;GR;;;WD)"
    );
*/
extern const UNICODE_STRING     SDDL_DEVOBJ_SYS_ALL_ADM_RWX_WORLD_R;


//
// SDDL_DEVOBJ_SYS_ALL_ADM_RWX_WORLD_R_RES_R allows the kernel and system
// complete control over the device. By default the admin can access the entire
// device, but cannot change the ACL (the admin must take control of the device
// first)
//
// Everyone (the WORLD SID) is given read access. In addition, "restricted" or
// "untrusted" code (the RES SID) is also allowed to access code. Untrusted
// code might be code launched via the Run-As option in Explorer. By default,
// World does not cover Restricted code.
//
// (Odd implementation detail: Due to the mechanics of restricting SIDs, the
// RES SID in an ACL should never exist outside the World SID).
//
// Also note that traversal access is not granted to normal users. As such,
// this might not be an appropriate descriptor for a storage device with a
// namespace.
//

/*
DECLARE_CONST_UNICODE_STRING(
    SDDL_DEVOBJ_SYS_ALL_ADM_RWX_WORLD_R_RES_R,
    L"D:P(A;;GA;;;SY)(A;;GRGWGX;;;BA)(A;;GR;;;WD)(A;;GR;;;RC)"
    );
*/
extern const UNICODE_STRING     SDDL_DEVOBJ_SYS_ALL_ADM_RWX_WORLD_R_RES_R;


//
// SDDL_DEVOBJ_SYS_ALL_ADM_RWX_WORLD_RW_RES_R allows the kernel and system
// complete control over the device. By default the admin can access the entire
// device, but cannot change the ACL (the admin must take control of the device
// first)
//
// Everyone (the WORLD SID) can read or write to the device. However,
// "restricted" or "untrusted" code (the RES SID) can only read from the device.
//
// Also note that normal users are not given traversal accesss. It is probably
// unnecessary anyway, as most devices don't manage a seperate namespace
// (ie, they set FILE_DEVICE_SECURE_OPEN).
//

/*
DECLARE_CONST_UNICODE_STRING(
    SDDL_DEVOBJ_SYS_ALL_ADM_RWX_WORLD_RW_RES_R,
    L"D:P(A;;GA;;;SY)(A;;GRGWGX;;;BA)(A;;GRGW;;;WD)(A;;GR;;;RC)"
    );
*/
extern const UNICODE_STRING     SDDL_DEVOBJ_SYS_ALL_ADM_RWX_WORLD_RW_RES_R;


//
// SDDL_DEVOBJ_SYS_ALL_WORLD_RWX_RES_RWX allows the kernel and system complete
// control over the device. By default the admin can access the entire device,
// but cannot change the ACL (the admin must take control of the device first)
//
// Everyone else, including "restricted" or "untrusted" code can read or write
// to the device. Traversal beneath the device is also granted (removing it
// would only effect storage devices, except if the "bypass-traversal"
// privilege was revoked).
//

/*
DECLARE_CONST_UNICODE_STRING(
    SDDL_DEVOBJ_SYS_ALL_ADM_RWX_WORLD_RWX_RES_RWX,
    L"D:P(A;;GA;;;SY)(A;;GRGWGX;;;BA)(A;;GRGWGX;;;WD)(A;;GRGWGX;;;RC)"
    );
*/
extern const UNICODE_STRING     SDDL_DEVOBJ_SYS_ALL_ADM_RWX_WORLD_RWX_RES_RWX;


//
// SDDL_DEVOBJ_SYS_ALL_ADM_RWX_WORLD_A is listed for completeness. This allows the
// kernel and system complete control over the device. By default the admin
// can access the entire device, but cannot change the ACL (the admin must take
// control of the device first)
//
// Everyone (the WORLD SID) can *append* data to the device. "Restricted" or
// "untrusted" code (the RES SID) cannot access the device. See ntioapi.h for
// the individual bit definitions of device rights.
//
// Note also that normal users can send neither read nor write IOCTLs (The read
// device data right is bit 0, the write device data right is bit 1 - neither
// bits are set below).
//

/*
DECLARE_CONST_UNICODE_STRING(
    SDDL_DEVOBJ_SYS_ALL_ADM_RWX_WORLD_A,
    L"D:P(A;;GA;;;SY)(A;;GRGWGX;;;BA)(A;;0x0004;;;WD)"
    );

extern const UNICODE_STRING     SDDL_DEVOBJ_SYS_ALL_ADM_RWX_WORLD_A;
*/


//
// SDDL_DEVOBJ_SYS_ALL_ADM_ALL_WORLD_ALL_RES_ALL is listed for completeness.
// This ACL would give *any* user *total* access to the device, including the
// ability to change the ACL, locking out other users!!!!!
//
// As this ACL is really a *very* bad idea, it isn't exported by this library.
// Don't make an ACL like this!
//

/*
DECLARE_CONST_UNICODE_STING(
    SDDL_DEVOBJ_SYS_ALL_ADM_ALL_WORLD_ALL_RES_ALL,
    "D:P(A;;GA;;;SY)(A;;GA;;;BA)(A;;GA;;;WD)(A;;GA;;;RC)"
    );

extern const UNICODE_STRING     SDDL_DEVOBJ_SYS_ALL_ADM_ALL_WORLD_ALL_RES_ALL;
*/

/*

  The following SIDs represent *accounts* on the local machine:
  -------------------------------------------------------------

    System ("SY", S-1-5-18, SECURITY_NT_AUTHORITY:SECURITY_LOCAL_SYSTEM_RID)
        The OS itself (including its user mode components.)

    Local Service ("LS", S-1-5-19, SECURITY_NT_AUTHORITY:SECURITY_LOCAL_SERVICE_RID)
        A predefined account for services that presents user credentials for local
        resources and annonymous credentials for network access.
        Available on XP and later.

    Network Service ("NS", S-1-5-20, SECURITY_NT_AUTHORITY:SECURITY_NETWORK_SERVICE_RID)
        A predefined account for services that presents user credentials for local
        resources and the machine ID for network access.
        Available on XP and later.

    (A local *account* for a guest and a default administrator also exist, but
     the corresponding SDDL abbreviations are not supported by this library.
     Use the corresponding group SIDs instead.)



  The following SIDs represent *groups* on the local machine:
  -----------------------------------------------------------

    Administrators ("BA", S-1-5-32-544, SECURITY_NT_AUTHORITY:SECURITY_BUILTIN_DOMAIN_RID:DOMAIN_ALIAS_RID_ADMINS)
        The builtin administrators group on the machine. This is not the same
        as the builtin Administrator *account*.

    Builtin users group ("BU", S-1-5-32-545, SECURITY_NT_AUTHORITY:SECURITY_BUILTIN_DOMAIN_RID:DOMAIN_ALIAS_RID_USERS)
        Group covering all local user accounts, and users on the domain. 

    Builtin guests group ("BG", S-1-5-32-546, SECURITY_NT_AUTHORITY:SECURITY_BUILTIN_DOMAIN_RID:DOMAIN_ALIAS_RID_GUESTS)
        Group covering users logging in using the local or domain guest account.
        This is not the same as the builtin Guest *account*.



  The below SIDs describe the authenticity of the user's identity:
  ----------------------------------------------------------------

    Authenticated Users ("AU", S-1-5-11, SECURITY_NT_AUTHORITY:SECURITY_AUTHENTICATED_USER_RID)
        Any user recognized by the local machine or by a domain. Note that
        users logged in using the Builtin Guest account are not authenticated.
        However, members of the Guests group with individual accounts on the
        machine or domain are authenticated.

    Anonymous Logged-on User ("AN", S-1-5-7, SECURITY_NT_AUTHORITY:SECURITY_ANONYMOUS_LOGON_RID)
        Any user logged on without an identity, for instance via an anonymous
        network session. Note that users logged in using the Builtin Guest
        account are neither authenticated nor anonymous. Available on XP and
        later.

    World ("WD", S-1-1-0, SECURITY_WORLD_SID_AUTHORITY:SECURITY_WORLD_RID)
        Prior to Windows XP, this SID covers every session: authenticated,
        anonymous, and the Builtin Guest account.

        For Windows XP and later, this SID does not cover anonymous logon
        sessions - only authenticated and the Builtin Guest account.

        Note that untrusted or "restricted" code is also not covered by the
        World SID. See the Restricted Code SID description for more
        information.



  The below SIDs describe how the user logged into the machine:
  -------------------------------------------------------------

    Interactive Users ("IU", S-1-5-4, SECURITY_NT_AUTHORITY:SECURITY_INTERACTIVE_RID)
        Users who initally logged onto the machine "interactively", such as
        local logons and Remote Desktops logons.

    Network Logon User ("NU", S-1-5-2, SECURITY_NT_AUTHORITY:SECURITY_NETWORK_RID)
        Users accessing the machine remotely, without interactive desktop
        access (ie, file sharing or RPC calls).

    Terminal Server Users (---, S-1-5-14, SECURITY_NT_AUTHORITY:SECURITY_TERMINAL_SERVER_RID)
        Interactive Users who *initially* logged onto the machine specifically
        via Terminal Services or Remote Desktop.
        (NOTE: There is currently no SDDL token for this SID. Furthermore, the
        presence of the SID doesn't take into account fast user switching
        either.)



  The below SID deserves special mention:
  ---------------------------------------

    Restricted Code ("RC", S-1-5-12, SECURITY_NT_AUTHORITY:SECURITY_RESTRICTED_CODE_RID)
        This SID is used to control access by untrusted code.

        ACL validation against tokens with RC go through *two* checks, one
        against the token's normal list of SIDs (containing WD for instance),
        and one against a second list (typically containing RC and a subset of
        the original token SIDs). Only if both tests pass is access granted.
        As such, RC actually works in *combination* with other SIDs.

        When RC is paired with WD in an ACL, a *superset* of Everyone
        _including_ untrusted code is described. RC is thus rarely seen in
        ACL's without the WD token.

*/




//
// Supply overrideable library implementation of IoCreateDeviceSecure.
// This function is similar to IoCreateDevice, except that it only creates
// named device objects. This function would be used to create raw PnP PDOs and
// legacy device objects. The DefaultSDDLString specifies security while the
// ClassGuid allows the administrator to override the defaults. Every driver
// should pass in a ClassGuid (if no relevant Guid exists, just invent a new
// one with guidgen.exe). The classguid parameter is crucial as it allows the
// admin to tighten security (for instance, the admin might deny access to a
// specific user).
//
// Note: This function should *not* be used to create a WDM FDO or Filter. The
//       only type of device object in a WDM stack that can be created using
//       IoCreateDeviceSecure is a PDO!
//
// See DDK documentation for more details.
//
#undef IoCreateDeviceSecure
#define IoCreateDeviceSecure    WdmlibIoCreateDeviceSecure

NTSTATUS
WdmlibIoCreateDeviceSecure(
    IN  PDRIVER_OBJECT      DriverObject,
    IN  ULONG               DeviceExtensionSize,
    IN  PUNICODE_STRING     DeviceName              OPTIONAL,
    IN  DEVICE_TYPE         DeviceType,
    IN  ULONG               DeviceCharacteristics,
    IN  BOOLEAN             Exclusive,
    IN  PCUNICODE_STRING    DefaultSDDLString,
    IN  LPCGUID             DeviceClassGuid         OPTIONAL,
    OUT PDEVICE_OBJECT     *DeviceObject
    );

//
// Supply library internal implementation of RtlInitUnicodeStringEx
// This function is similar to RtlInitUnicodeString, except that it handles the
// case where a string exceeds UNICODE_STRING_MAX_CHARS (it does not probe or
// check alignments though).
//
// See DDK documentation for more details.
//
#undef RtlInitUnicodeStringEx
#define RtlInitUnicodeStringEx    WdmlibRtlInitUnicodeStringEx

NTSTATUS
WdmlibRtlInitUnicodeStringEx(
    OUT PUNICODE_STRING DestinationString,
    IN  PCWSTR          SourceString        OPTIONAL
    );

//
// Supply overrideable library implementation of IoValidateDeviceIoControlAccess
// This function allows a driver running on Server 2003 to process
// FILE_ANY_ACCESS IOCTLs as if they were FILE_READ_ACCESS, FILE_WRITE_ACCESS,
// or both.
//
// See DDK documentation for more details.
//
#undef IoValidateDeviceIoControlAccess
#define IoValidateDeviceIoControlAccess WdmlibIoValidateDeviceIoControlAccess

NTSTATUS
WdmlibIoValidateDeviceIoControlAccess(
    IN  PIRP    Irp,
    IN  ULONG   RequiredAccess
    );

#ifdef __cplusplus
} // extern "C"
#endif

#endif // _WDMSEC_H_
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\win2k8\ddk\inc\wheaevents.h ===
#pragma once
EXTERN_C __declspec(selectany) const GUID WHEA_ETW_PROVIDER = {0x7b563579, 0x53c8, 0x44e7, {0x82, 0x36,0x0f,0x87,0xb9,0xfe,0x65,0x94}};
#define WHEA_ETW_PROVIDER_CHANNEL_systemChannel 0x8
#define WHEA_CHANNEL 0x10
#define WHEA_ERROR_KEYWORD 0x800
EXTERN_C __declspec(selectany) const EVENT_DESCRIPTOR EVENT_WHEA_CORRECTED_ERROR = {0x1, 0x0, 0x8, 0x3, 0x0, 0x0, 0x8000000000000000};
#define EVENT_WHEA_CORRECTED_ERROR_value 0x1
EXTERN_C __declspec(selectany) const EVENT_DESCRIPTOR EVENT_WHEA_UNCORRECTED_ERROR = {0x2, 0x0, 0x8, 0x2, 0x0, 0x0, 0x8000000000000000};
#define EVENT_WHEA_UNCORRECTED_ERROR_value 0x2
EXTERN_C __declspec(selectany) const EVENT_DESCRIPTOR EVENT_WHEA_CORRECTED_ERROR_OP = {0x3, 0x0, 0x10, 0x3, 0x0, 0x0, 0x4000000000000000};
#define EVENT_WHEA_CORRECTED_ERROR_OP_value 0x3
EXTERN_C __declspec(selectany) const EVENT_DESCRIPTOR EVENT_WHEA_UNCORRECTED_ERROR_OP = {0x4, 0x0, 0x10, 0x2, 0x0, 0x0, 0x4000000000000000};
#define EVENT_WHEA_UNCORRECTED_ERROR_OP_value 0x4
EXTERN_C __declspec(selectany) const EVENT_DESCRIPTOR EVENT_WHEA_INIT_OP = {0x5, 0x0, 0x10, 0x4, 0x0, 0x0, 0x4000000000000000};
#define EVENT_WHEA_INIT_OP_value 0x5
EXTERN_C __declspec(selectany) const EVENT_DESCRIPTOR EVENT_WHEA_MEMHIERARCHY_ERROR = {0x6, 0x0, 0x8, 0x2, 0x0, 0x0, 0x8000000000000000};
#define EVENT_WHEA_MEMHIERARCHY_ERROR_value 0x6
EXTERN_C __declspec(selectany) const EVENT_DESCRIPTOR EVENT_WHEA_MEMHIERARCHY_WARNING = {0x7, 0x0, 0x10, 0x3, 0x0, 0x0, 0x4000000000000000};
#define EVENT_WHEA_MEMHIERARCHY_WARNING_value 0x7
EXTERN_C __declspec(selectany) const EVENT_DESCRIPTOR EVENT_WHEA_TLB_ERROR = {0x8, 0x0, 0x8, 0x2, 0x0, 0x0, 0x8000000000000000};
#define EVENT_WHEA_TLB_ERROR_value 0x8
EXTERN_C __declspec(selectany) const EVENT_DESCRIPTOR EVENT_WHEA_TLB_WARNING = {0x9, 0x0, 0x10, 0x3, 0x0, 0x0, 0x4000000000000000};
#define EVENT_WHEA_TLB_WARNING_value 0x9
EXTERN_C __declspec(selectany) const EVENT_DESCRIPTOR EVENT_WHEA_BUS_ERROR = {0xa, 0x0, 0x8, 0x2, 0x0, 0x0, 0x8000000000000000};
#define EVENT_WHEA_BUS_ERROR_value 0xa
EXTERN_C __declspec(selectany) const EVENT_DESCRIPTOR EVENT_WHEA_BUS_WARNING = {0xb, 0x0, 0x10, 0x3, 0x0, 0x0, 0x4000000000000000};
#define EVENT_WHEA_BUS_WARNING_value 0xb
EXTERN_C __declspec(selectany) const EVENT_DESCRIPTOR EVENT_WHEA_BUSTO_ERROR = {0xc, 0x0, 0x8, 0x2, 0x0, 0x0, 0x8000000000000000};
#define EVENT_WHEA_BUSTO_ERROR_value 0xc
EXTERN_C __declspec(selectany) const EVENT_DESCRIPTOR EVENT_WHEA_BUSTO_WARNING = {0xd, 0x0, 0x10, 0x3, 0x0, 0x0, 0x4000000000000000};
#define EVENT_WHEA_BUSTO_WARNING_value 0xd
EXTERN_C __declspec(selectany) const EVENT_DESCRIPTOR EVENT_WHEA_WDTO_ERROR = {0xe, 0x0, 0x8, 0x2, 0x0, 0x0, 0x8000000000000000};
#define EVENT_WHEA_WDTO_ERROR_value 0xe
EXTERN_C __declspec(selectany) const EVENT_DESCRIPTOR EVENT_WHEA_ROMPARITY_ERROR = {0xf, 0x0, 0x10, 0x2, 0x0, 0x0, 0x4000000000000000};
#define EVENT_WHEA_ROMPARITY_ERROR_value 0xf
EXTERN_C __declspec(selectany) const EVENT_DESCRIPTOR EVENT_WHEA_EXTERNAL_ERROR = {0x10, 0x0, 0x8, 0x2, 0x0, 0x0, 0x8000000000000000};
#define EVENT_WHEA_EXTERNAL_ERROR_value 0x10
EXTERN_C __declspec(selectany) const EVENT_DESCRIPTOR EVENT_WHEA_FRC_ERROR = {0x11, 0x0, 0x8, 0x2, 0x0, 0x0, 0x8000000000000000};
#define EVENT_WHEA_FRC_ERROR_value 0x11
EXTERN_C __declspec(selectany) const EVENT_DESCRIPTOR EVENT_WHEA_PCIE_ERROR = {0x12, 0x0, 0x8, 0x2, 0x0, 0x0, 0x8000000000000000};
#define EVENT_WHEA_PCIE_ERROR_value 0x12
EXTERN_C __declspec(selectany) const EVENT_DESCRIPTOR EVENT_WHEA_PCIE_WARNING = {0x13, 0x0, 0x10, 0x3, 0x0, 0x0, 0x4000000000000000};
#define EVENT_WHEA_PCIE_WARNING_value 0x13
EXTERN_C __declspec(selectany) const EVENT_DESCRIPTOR EVENT_WHEA_ERROR = {0x14, 0x0, 0x10, 0x4, 0x0, 0x0, 0x4000000000000800};
#define EVENT_WHEA_ERROR_value 0x14
#define MSG_CorrectedError_EventMessage  0xB0000001L

#define MSG_Init_EventMessage            0xB0000005L

#define MSG_MCABusErr_EventMessage       0xB000000AL

#define MSG_MCABusTOErr_EventMessage     0xB000000CL

#define MSG_MCABusTOWrn_EventMessage     0xB000000DL

#define MSG_MCABusWrn_EventMessage       0xB000000BL

#define MSG_MCAExternalErr_EventMessage  0xB0000010L

#define MSG_MCAFRCErr_EventMessage       0xB0000011L

#define MSG_MCAMemHierarchyErr_EventMessage 0xB0000006L

#define MSG_MCAMemHierarchyWrn_EventMessage 0xB0000007L

#define MSG_MCAROMParityErr_EventMessage 0xB000000FL

#define MSG_MCATLBErr_EventMessage       0xB0000008L

#define MSG_MCATLBWrn_EventMessage       0xB0000009L

#define MSG_MCAWDTOErr_EventMessage      0xB000000EL

#define MSG_PCIeErr_EventMessage         0xB0000012L

#define MSG_PCIeWrn_EventMessage         0xB0000013L

#define MSG_UncorrectedError_EventMessage 0xB0000002L

#define MSG_WHEA_EventMessage            0xB0000014L

#define MSG_WHEA_ERROR_KEYWORD_KeywordMessage 0x1000000CL

#define MSG_eventProviderName            0x90000001L
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\win2k8\ddk\inc\WindowsSideShow.h ===
//-----------------------------------------------------------------------
// <copyright file="WindowsSideShow.h" company="Microsoft">
//      Copyright (c) 2004-2005 Microsoft Corporation.  All rights
//  reserved.
// </copyright>
//
// Module:       
//        WindowsSideShow.h
//
// Description:
//        This file defines supporting structures and values used in
//        the Windows SideShow platform.
//
//-----------------------------------------------------------------------

#pragma once
#if (_WIN32_WINNT >= 0x0600) // Windows Vista and later 
#include "propkeydef.h"
/****************************************************************************
 * This section defines platform constants
 ****************************************************************************/

const   CONTENT_ID      CONTENT_ID_GLANCE = 0;

// Event IDs for ApplicationEvents fired by the device when the user enters/exits
// an application on the device.
const   DWORD           SIDESHOW_EVENTID_APPLICATION_ENTER  = 0xFFFF0000;
const   DWORD           SIDESHOW_EVENTID_APPLICATION_EXIT   = 0xFFFF0001;


/****************************************************************************
 * This section defines well-known device endpoints
 ****************************************************************************/

// {A9A5353F-2D4B-47ce-93EE-759F3A7DDA4F}
DEFINE_GUID(SIDESHOW_ENDPOINT_SIMPLE_CONTENT_FORMAT,    0xa9a5353f, 0x2d4b, 0x47ce, 0x93, 0xee, 0x75, 0x9f, 0x3a, 0x7d, 0xda, 0x4f);

// {4DFF36B5-9DDE-4F76-9A2A-96435047063D}
DEFINE_GUID(SIDESHOW_ENDPOINT_ICAL,                     0x4dff36b5, 0x9dde, 0x4f76, 0x9a, 0x2a, 0x96, 0x43, 0x50, 0x47, 0x06, 0x3d);


/****************************************************************************
 * This section defines well-known device capabilities
 ****************************************************************************/

// {8ABC88A8-857B-4ad7-A35A-B5942F492B99}
DEFINE_GUID(SIDESHOW_CAPABILITY_DEVICE_PROPERTIES,          0x8abc88a8, 0x857b, 0x4ad7, 0xa3, 0x5a, 0xb5, 0x94, 0x2f, 0x49, 0x2b, 0x99);

DEFINE_PROPERTYKEY(SIDESHOW_CAPABILITY_DEVICE_ID,           0x8abc88a8, 0x857b, 0x4ad7, 0xa3, 0x5a, 0xb5, 0x94, 0x2f, 0x49, 0x2b, 0x99, 1); // [ VT_LPWSTR ]
DEFINE_PROPERTYKEY(SIDESHOW_CAPABILITY_SCREEN_TYPE,         0x8abc88a8, 0x857b, 0x4ad7, 0xa3, 0x5a, 0xb5, 0x94, 0x2f, 0x49, 0x2b, 0x99, 2); // [ VT_I4 ]
DEFINE_PROPERTYKEY(SIDESHOW_CAPABILITY_SCREEN_WIDTH,        0x8abc88a8, 0x857b, 0x4ad7, 0xa3, 0x5a, 0xb5, 0x94, 0x2f, 0x49, 0x2b, 0x99, 3); // [ VT_UI2 ]
DEFINE_PROPERTYKEY(SIDESHOW_CAPABILITY_SCREEN_HEIGHT,       0x8abc88a8, 0x857b, 0x4ad7, 0xa3, 0x5a, 0xb5, 0x94, 0x2f, 0x49, 0x2b, 0x99, 4); // [ VT_UI2 ]
DEFINE_PROPERTYKEY(SIDESHOW_CAPABILITY_COLOR_DEPTH,         0x8abc88a8, 0x857b, 0x4ad7, 0xa3, 0x5a, 0xb5, 0x94, 0x2f, 0x49, 0x2b, 0x99, 5); // [ VT_UI2 ]
DEFINE_PROPERTYKEY(SIDESHOW_CAPABILITY_COLOR_TYPE,          0x8abc88a8, 0x857b, 0x4ad7, 0xa3, 0x5a, 0xb5, 0x94, 0x2f, 0x49, 0x2b, 0x99, 6); // [ VT_I4 ]
DEFINE_PROPERTYKEY(SIDESHOW_CAPABILITY_DATA_CACHE,          0x8abc88a8, 0x857b, 0x4ad7, 0xa3, 0x5a, 0xb5, 0x94, 0x2f, 0x49, 0x2b, 0x99, 7); // [ VT_BOOL ]
DEFINE_PROPERTYKEY(SIDESHOW_CAPABILITY_SUPPORTED_LANGUAGES, 0x8abc88a8, 0x857b, 0x4ad7, 0xa3, 0x5a, 0xb5, 0x94, 0x2f, 0x49, 0x2b, 0x99, 8); // [ VT_LPWSTR ]
DEFINE_PROPERTYKEY(SIDESHOW_CAPABILITY_CURRENT_LANGUAGE,    0x8abc88a8, 0x857b, 0x4ad7, 0xa3, 0x5a, 0xb5, 0x94, 0x2f, 0x49, 0x2b, 0x99, 9); // [ VT_LPWSTR ]
DEFINE_PROPERTYKEY(SIDESHOW_CAPABILITY_SUPPORTED_THEMES,    0x8abc88a8, 0x857b, 0x4ad7, 0xa3, 0x5a, 0xb5, 0x94, 0x2f, 0x49, 0x2b, 0x99, 10);// [ VT_LPWSTR ]
DEFINE_PROPERTYKEY(SIDESHOW_CAPABILITY_SUPPORTED_IMAGE_FORMATS, 0x8abc88a8, 0x857b, 0x4ad7, 0xa3, 0x5a, 0xb5, 0x94, 0x2f, 0x49, 0x2b, 0x99, 14);// [ VT_LPWSTR ]
DEFINE_PROPERTYKEY(SIDESHOW_CAPABILITY_CLIENT_AREA_WIDTH,   0x8abc88a8, 0x857b, 0x4ad7, 0xa3, 0x5a, 0xb5, 0x94, 0x2f, 0x49, 0x2b, 0x99, 15);// [ VT_UI2 ]
DEFINE_PROPERTYKEY(SIDESHOW_CAPABILITY_CLIENT_AREA_HEIGHT,  0x8abc88a8, 0x857b, 0x4ad7, 0xa3, 0x5a, 0xb5, 0x94, 0x2f, 0x49, 0x2b, 0x99, 16);// [ VT_UI2 ]

/****************************************************************************
 * This section defines enumerations used by the device capabilities
 ****************************************************************************/

// Used with SIDESHOW_CAPABILITY_SCREEN_TYPE
typedef enum tagSIDESHOW_SCREEN_TYPE
{
    SIDESHOW_SCREEN_TYPE_BITMAP  =   0,
    SIDESHOW_SCREEN_TYPE_TEXT    =   1,
} SIDESHOW_SCREEN_TYPE;

// Used with SIDESHOW_CAPABILITY_COLOR_TYPE
typedef enum tagSIDESHOW_COLOR_TYPE
{
    SIDESHOW_COLOR_TYPE_COLOR            = 0,
    SIDESHOW_COLOR_TYPE_GREYSCALE        = 1,
    SIDESHOW_COLOR_TYPE_BLACK_AND_WHITE  = 2,
} SIDESHOW_COLOR_TYPE;


/****************************************************************************
 * This section defines constants, structures and enumerations relating to
 * the Simple Content Format
 ****************************************************************************/

// The content id of the home page for a Simple Content Format application
const CONTENT_ID    CONTENT_ID_HOME     = 1;

// The ApplicationEvent event ids from the Simple Content Format device application
typedef enum tagSCF_EVENT_IDS
{
    SCF_EVENT_NAVIGATION        = 1,
    SCF_EVENT_MENUACTION        = 2,
    SCF_EVENT_CONTEXTMENU       = 3,
} SCF_EVENT_IDS;

// The button ids used in the Simple Content Format events
typedef enum tagSCF_BUTTON_IDS
{
    SCF_BUTTON_MENU     = 1,
    SCF_BUTTON_SELECT   = 2,   
    SCF_BUTTON_UP       = 3,
    SCF_BUTTON_DOWN     = 4,
    SCF_BUTTON_LEFT     = 5,
    SCF_BUTTON_RIGHT    = 6,
    SCF_BUTTON_PLAY     = 7,
    SCF_BUTTON_PAUSE    = 8,
    SCF_BUTTON_FASTFORWARD = 9,
    SCF_BUTTON_REWIND   = 10,
    SCF_BUTTON_STOP     = 11,
    SCF_BUTTON_BACK     = 65280, // 0xFF00
} SCF_BUTTON_IDS;

// A header structure that is common amongst all Simple Content Format event structures
typedef struct tagSCF_EVENT_HEADER
{
    CONTENT_ID  PreviousPage;
    CONTENT_ID  TargetPage;
} SCF_EVENT_HEADER, *PSCF_EVENT_HEADER;

// The data passed with an SCF_EVENT_NAVIGATION ApplicationEvent
typedef struct tagSCF_NAVIGATION_EVENT
{
    CONTENT_ID  PreviousPage;
    CONTENT_ID  TargetPage;
    UINT32      Button;
} SCF_NAVIGATION_EVENT, *PSCF_NAVIGATION_EVENT;

// The data passed with an SCF_EVENT_MENUACTION ApplicationEvent
typedef struct tagSCF_MENUACTION_EVENT
{
    CONTENT_ID  PreviousPage;
    CONTENT_ID  TargetPage;
    UINT32      Button;
    UINT32      ItemId;
} SCF_MENUACTION_EVENT, *PSCF_MENUACTION_EVENT;

// The data passed with an SCF_EVENT_CONTEXTMENU ApplicationEvent
typedef struct tagSCF_CONTEXTMENU_EVENT
{
    CONTENT_ID  PreviousPage;
    CONTENT_ID  TargetPage;
    UINT32      PreviousItemId;
    CONTENT_ID  MenuPage;
    UINT32      MenuItemId;
} SCF_CONTEXTMENU_EVENT, *PSCF_CONTEXTMENU_EVENT;

#endif // (_WIN32_WINNT >= 0x0600)
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\win2k8\ddk\inc\wiamindr_lh.h ===
/* this ALWAYS GENERATED file contains the definitions for the interfaces */


 /* File created by MIDL compiler version 7.00.0499 */
/* Compiler settings for wiamindr_lh.idl:
    Oicf, W1, Zp8, env=Win32 (32b run)
    protocol : dce , ms_ext, c_ext, robust
    error checks: allocation ref bounds_check enum stub_data 
    VC __declspec() decoration level: 
         __declspec(uuid()), __declspec(selectany), __declspec(novtable)
         DECLSPEC_UUID(), MIDL_INTERFACE()
*/
//@@MIDL_FILE_HEADING(  )

#pragma warning( disable: 4049 )  /* more than 64k source lines */


/* verify that the <rpcndr.h> version is high enough to compile this file*/
#ifndef __REQUIRED_RPCNDR_H_VERSION__
#define __REQUIRED_RPCNDR_H_VERSION__ 500
#endif

/* verify that the <rpcsal.h> version is high enough to compile this file*/
#ifndef __REQUIRED_RPCSAL_H_VERSION__
#define __REQUIRED_RPCSAL_H_VERSION__ 100
#endif

#include "rpc.h"
#include "rpcndr.h"

#ifndef __RPCNDR_H_VERSION__
#error this stub requires an updated version of <rpcndr.h>
#endif // __RPCNDR_H_VERSION__

#ifndef COM_NO_WINDOWS_H
#include "windows.h"
#include "ole2.h"
#endif /*COM_NO_WINDOWS_H*/

#ifndef __wiamindr_lh_h__
#define __wiamindr_lh_h__

#if defined(_MSC_VER) && (_MSC_VER >= 1020)
#pragma once
#endif

/* Forward Declarations */ 

#ifndef __IWiaMiniDrv_FWD_DEFINED__
#define __IWiaMiniDrv_FWD_DEFINED__
typedef interface IWiaMiniDrv IWiaMiniDrv;
#endif 	/* __IWiaMiniDrv_FWD_DEFINED__ */


#ifndef __IWiaMiniDrvCallBack_FWD_DEFINED__
#define __IWiaMiniDrvCallBack_FWD_DEFINED__
typedef interface IWiaMiniDrvCallBack IWiaMiniDrvCallBack;
#endif 	/* __IWiaMiniDrvCallBack_FWD_DEFINED__ */


#ifndef __IWiaMiniDrvTransferCallback_FWD_DEFINED__
#define __IWiaMiniDrvTransferCallback_FWD_DEFINED__
typedef interface IWiaMiniDrvTransferCallback IWiaMiniDrvTransferCallback;
#endif 	/* __IWiaMiniDrvTransferCallback_FWD_DEFINED__ */


#ifndef __IWiaDrvItem_FWD_DEFINED__
#define __IWiaDrvItem_FWD_DEFINED__
typedef interface IWiaDrvItem IWiaDrvItem;
#endif 	/* __IWiaDrvItem_FWD_DEFINED__ */


/* header files for imported files */
#include "unknwn.h"
#include "oaidl.h"
#include "propidl.h"
#include "wia_lh.h"

#ifdef __cplusplus
extern "C"{
#endif 


/* interface __MIDL_itf_wiamindr_lh_0000_0000 */
/* [local] */ 







typedef struct _MINIDRV_TRANSFER_CONTEXT
    {
    LONG lSize;
    LONG lWidthInPixels;
    LONG lLines;
    LONG lDepth;
    LONG lXRes;
    LONG lYRes;
    LONG lCompression;
    GUID guidFormatID;
    LONG tymed;
    LONG_PTR hFile;
    LONG cbOffset;
    LONG lBufferSize;
    LONG lActiveBuffer;
    LONG lNumBuffers;
    BYTE *pBaseBuffer;
    BYTE *pTransferBuffer;
    BOOL bTransferDataCB;
    BOOL bClassDrvAllocBuf;
    LONG_PTR lClientAddress;
    IWiaMiniDrvCallBack *pIWiaMiniDrvCallBack;
    LONG lImageSize;
    LONG lHeaderSize;
    LONG lItemSize;
    LONG cbWidthInBytes;
    LONG lPage;
    LONG lCurIfdOffset;
    LONG lPrevIfdOffset;
    } 	MINIDRV_TRANSFER_CONTEXT;

typedef struct _MINIDRV_TRANSFER_CONTEXT *PMINIDRV_TRANSFER_CONTEXT;

typedef struct _WIA_DEV_CAP_DRV
    {
    GUID *guid;
    ULONG ulFlags;
    LPOLESTR wszName;
    LPOLESTR wszDescription;
    LPOLESTR wszIcon;
    } 	WIA_DEV_CAP_DRV;

typedef struct _WIA_DEV_CAP_DRV *PWIA_DEV_CAP_DRV;



extern RPC_IF_HANDLE __MIDL_itf_wiamindr_lh_0000_0000_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_wiamindr_lh_0000_0000_v0_0_s_ifspec;

#ifndef __IWiaMiniDrv_INTERFACE_DEFINED__
#define __IWiaMiniDrv_INTERFACE_DEFINED__

/* interface IWiaMiniDrv */
/* [unique][helpstring][uuid][object] */ 


EXTERN_C const IID IID_IWiaMiniDrv;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("d8cdee14-3c6c-11d2-9a35-00c04fa36145")
    IWiaMiniDrv : public IUnknown
    {
    public:
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE drvInitializeWia( 
            /* [in] */ __RPC__in BYTE *__MIDL__IWiaMiniDrv0000,
            /* [in] */ LONG __MIDL__IWiaMiniDrv0001,
            /* [in] */ __RPC__in BSTR __MIDL__IWiaMiniDrv0002,
            /* [in] */ __RPC__in BSTR __MIDL__IWiaMiniDrv0003,
            /* [in] */ __RPC__in_opt IUnknown *__MIDL__IWiaMiniDrv0004,
            /* [in] */ __RPC__in_opt IUnknown *__MIDL__IWiaMiniDrv0005,
            /* [out] */ __RPC__deref_out_opt IWiaDrvItem **__MIDL__IWiaMiniDrv0006,
            /* [out] */ __RPC__deref_out_opt IUnknown **__MIDL__IWiaMiniDrv0007,
            /* [out] */ __RPC__out LONG *__MIDL__IWiaMiniDrv0008) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE drvAcquireItemData( 
            /* [in] */ __RPC__in BYTE *__MIDL__IWiaMiniDrv0009,
            /* [in] */ LONG __MIDL__IWiaMiniDrv0010,
            /* [out][in] */ __RPC__inout PMINIDRV_TRANSFER_CONTEXT __MIDL__IWiaMiniDrv0011,
            /* [out] */ __RPC__out LONG *__MIDL__IWiaMiniDrv0012) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE drvInitItemProperties( 
            /* [in] */ __RPC__in BYTE *__MIDL__IWiaMiniDrv0013,
            /* [in] */ LONG __MIDL__IWiaMiniDrv0014,
            /* [out] */ __RPC__out LONG *__MIDL__IWiaMiniDrv0015) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE drvValidateItemProperties( 
            /* [in] */ __RPC__in BYTE *__MIDL__IWiaMiniDrv0016,
            /* [in] */ LONG __MIDL__IWiaMiniDrv0017,
            /* [in] */ ULONG __MIDL__IWiaMiniDrv0018,
            /* [in] */ __RPC__in const PROPSPEC *__MIDL__IWiaMiniDrv0019,
            /* [out] */ __RPC__out LONG *__MIDL__IWiaMiniDrv0020) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE drvWriteItemProperties( 
            /* [in] */ __RPC__in BYTE *__MIDL__IWiaMiniDrv0021,
            /* [in] */ LONG __MIDL__IWiaMiniDrv0022,
            /* [in] */ __RPC__in PMINIDRV_TRANSFER_CONTEXT __MIDL__IWiaMiniDrv0023,
            /* [out] */ __RPC__out LONG *__MIDL__IWiaMiniDrv0024) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE drvReadItemProperties( 
            /* [in] */ __RPC__in BYTE *__MIDL__IWiaMiniDrv0025,
            /* [in] */ LONG __MIDL__IWiaMiniDrv0026,
            /* [in] */ ULONG __MIDL__IWiaMiniDrv0027,
            /* [in] */ __RPC__in const PROPSPEC *__MIDL__IWiaMiniDrv0028,
            /* [out] */ __RPC__out LONG *__MIDL__IWiaMiniDrv0029) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE drvLockWiaDevice( 
            /* [in] */ __RPC__in BYTE *__MIDL__IWiaMiniDrv0030,
            /* [in] */ LONG __MIDL__IWiaMiniDrv0031,
            /* [out] */ __RPC__out LONG *__MIDL__IWiaMiniDrv0032) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE drvUnLockWiaDevice( 
            /* [in] */ __RPC__in BYTE *__MIDL__IWiaMiniDrv0033,
            /* [in] */ LONG __MIDL__IWiaMiniDrv0034,
            /* [out] */ __RPC__out LONG *__MIDL__IWiaMiniDrv0035) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE drvAnalyzeItem( 
            /* [in] */ __RPC__in BYTE *__MIDL__IWiaMiniDrv0036,
            /* [in] */ LONG __MIDL__IWiaMiniDrv0037,
            /* [in] */ __RPC__in LONG *__MIDL__IWiaMiniDrv0038) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE drvGetDeviceErrorStr( 
            /* [in] */ LONG __MIDL__IWiaMiniDrv0039,
            /* [in] */ LONG __MIDL__IWiaMiniDrv0040,
            /* [string][out] */ __RPC__deref_out_opt_string LPOLESTR *__MIDL__IWiaMiniDrv0041,
            /* [out] */ __RPC__out LONG *__MIDL__IWiaMiniDrv0042) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE drvDeviceCommand( 
            /* [in] */ __RPC__in BYTE *__MIDL__IWiaMiniDrv0043,
            /* [in] */ LONG __MIDL__IWiaMiniDrv0044,
            /* [in] */ __RPC__in const GUID *__MIDL__IWiaMiniDrv0045,
            /* [out] */ __RPC__deref_out_opt IWiaDrvItem **__MIDL__IWiaMiniDrv0046,
            /* [out] */ __RPC__out LONG *__MIDL__IWiaMiniDrv0047) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE drvGetCapabilities( 
            /* [in] */ __RPC__in BYTE *__MIDL__IWiaMiniDrv0048,
            /* [in] */ LONG __MIDL__IWiaMiniDrv0049,
            /* [out] */ __RPC__out LONG *__MIDL__IWiaMiniDrv0050,
            /* [out] */ __RPC__deref_out_opt WIA_DEV_CAP_DRV **__MIDL__IWiaMiniDrv0051,
            /* [out] */ __RPC__out LONG *__MIDL__IWiaMiniDrv0052) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE drvDeleteItem( 
            /* [in] */ __RPC__in BYTE *__MIDL__IWiaMiniDrv0053,
            /* [in] */ LONG __MIDL__IWiaMiniDrv0054,
            /* [out] */ __RPC__out LONG *__MIDL__IWiaMiniDrv0055) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE drvFreeDrvItemContext( 
            /* [in] */ LONG __MIDL__IWiaMiniDrv0056,
            /* [in] */ __RPC__in BYTE *__MIDL__IWiaMiniDrv0057,
            /* [out] */ __RPC__out LONG *__MIDL__IWiaMiniDrv0058) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE drvGetWiaFormatInfo( 
            /* [in] */ __RPC__in BYTE *__MIDL__IWiaMiniDrv0059,
            /* [in] */ LONG __MIDL__IWiaMiniDrv0060,
            /* [out] */ __RPC__out LONG *__MIDL__IWiaMiniDrv0061,
            /* [out] */ __RPC__deref_out_opt WIA_FORMAT_INFO **__MIDL__IWiaMiniDrv0062,
            /* [out] */ __RPC__out LONG *__MIDL__IWiaMiniDrv0063) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE drvNotifyPnpEvent( 
            /* [in] */ __RPC__in const GUID *pEventGUID,
            /* [in] */ __RPC__in BSTR bstrDeviceID,
            /* [in] */ ULONG ulReserved) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE drvUnInitializeWia( 
            /* [in] */ __RPC__in BYTE *__MIDL__IWiaMiniDrv0064) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IWiaMiniDrvVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IWiaMiniDrv * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IWiaMiniDrv * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IWiaMiniDrv * This);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *drvInitializeWia )( 
            IWiaMiniDrv * This,
            /* [in] */ __RPC__in BYTE *__MIDL__IWiaMiniDrv0000,
            /* [in] */ LONG __MIDL__IWiaMiniDrv0001,
            /* [in] */ __RPC__in BSTR __MIDL__IWiaMiniDrv0002,
            /* [in] */ __RPC__in BSTR __MIDL__IWiaMiniDrv0003,
            /* [in] */ __RPC__in_opt IUnknown *__MIDL__IWiaMiniDrv0004,
            /* [in] */ __RPC__in_opt IUnknown *__MIDL__IWiaMiniDrv0005,
            /* [out] */ __RPC__deref_out_opt IWiaDrvItem **__MIDL__IWiaMiniDrv0006,
            /* [out] */ __RPC__deref_out_opt IUnknown **__MIDL__IWiaMiniDrv0007,
            /* [out] */ __RPC__out LONG *__MIDL__IWiaMiniDrv0008);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *drvAcquireItemData )( 
            IWiaMiniDrv * This,
            /* [in] */ __RPC__in BYTE *__MIDL__IWiaMiniDrv0009,
            /* [in] */ LONG __MIDL__IWiaMiniDrv0010,
            /* [out][in] */ __RPC__inout PMINIDRV_TRANSFER_CONTEXT __MIDL__IWiaMiniDrv0011,
            /* [out] */ __RPC__out LONG *__MIDL__IWiaMiniDrv0012);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *drvInitItemProperties )( 
            IWiaMiniDrv * This,
            /* [in] */ __RPC__in BYTE *__MIDL__IWiaMiniDrv0013,
            /* [in] */ LONG __MIDL__IWiaMiniDrv0014,
            /* [out] */ __RPC__out LONG *__MIDL__IWiaMiniDrv0015);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *drvValidateItemProperties )( 
            IWiaMiniDrv * This,
            /* [in] */ __RPC__in BYTE *__MIDL__IWiaMiniDrv0016,
            /* [in] */ LONG __MIDL__IWiaMiniDrv0017,
            /* [in] */ ULONG __MIDL__IWiaMiniDrv0018,
            /* [in] */ __RPC__in const PROPSPEC *__MIDL__IWiaMiniDrv0019,
            /* [out] */ __RPC__out LONG *__MIDL__IWiaMiniDrv0020);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *drvWriteItemProperties )( 
            IWiaMiniDrv * This,
            /* [in] */ __RPC__in BYTE *__MIDL__IWiaMiniDrv0021,
            /* [in] */ LONG __MIDL__IWiaMiniDrv0022,
            /* [in] */ __RPC__in PMINIDRV_TRANSFER_CONTEXT __MIDL__IWiaMiniDrv0023,
            /* [out] */ __RPC__out LONG *__MIDL__IWiaMiniDrv0024);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *drvReadItemProperties )( 
            IWiaMiniDrv * This,
            /* [in] */ __RPC__in BYTE *__MIDL__IWiaMiniDrv0025,
            /* [in] */ LONG __MIDL__IWiaMiniDrv0026,
            /* [in] */ ULONG __MIDL__IWiaMiniDrv0027,
            /* [in] */ __RPC__in const PROPSPEC *__MIDL__IWiaMiniDrv0028,
            /* [out] */ __RPC__out LONG *__MIDL__IWiaMiniDrv0029);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *drvLockWiaDevice )( 
            IWiaMiniDrv * This,
            /* [in] */ __RPC__in BYTE *__MIDL__IWiaMiniDrv0030,
            /* [in] */ LONG __MIDL__IWiaMiniDrv0031,
            /* [out] */ __RPC__out LONG *__MIDL__IWiaMiniDrv0032);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *drvUnLockWiaDevice )( 
            IWiaMiniDrv * This,
            /* [in] */ __RPC__in BYTE *__MIDL__IWiaMiniDrv0033,
            /* [in] */ LONG __MIDL__IWiaMiniDrv0034,
            /* [out] */ __RPC__out LONG *__MIDL__IWiaMiniDrv0035);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *drvAnalyzeItem )( 
            IWiaMiniDrv * This,
            /* [in] */ __RPC__in BYTE *__MIDL__IWiaMiniDrv0036,
            /* [in] */ LONG __MIDL__IWiaMiniDrv0037,
            /* [in] */ __RPC__in LONG *__MIDL__IWiaMiniDrv0038);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *drvGetDeviceErrorStr )( 
            IWiaMiniDrv * This,
            /* [in] */ LONG __MIDL__IWiaMiniDrv0039,
            /* [in] */ LONG __MIDL__IWiaMiniDrv0040,
            /* [string][out] */ __RPC__deref_out_opt_string LPOLESTR *__MIDL__IWiaMiniDrv0041,
            /* [out] */ __RPC__out LONG *__MIDL__IWiaMiniDrv0042);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *drvDeviceCommand )( 
            IWiaMiniDrv * This,
            /* [in] */ __RPC__in BYTE *__MIDL__IWiaMiniDrv0043,
            /* [in] */ LONG __MIDL__IWiaMiniDrv0044,
            /* [in] */ __RPC__in const GUID *__MIDL__IWiaMiniDrv0045,
            /* [out] */ __RPC__deref_out_opt IWiaDrvItem **__MIDL__IWiaMiniDrv0046,
            /* [out] */ __RPC__out LONG *__MIDL__IWiaMiniDrv0047);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *drvGetCapabilities )( 
            IWiaMiniDrv * This,
            /* [in] */ __RPC__in BYTE *__MIDL__IWiaMiniDrv0048,
            /* [in] */ LONG __MIDL__IWiaMiniDrv0049,
            /* [out] */ __RPC__out LONG *__MIDL__IWiaMiniDrv0050,
            /* [out] */ __RPC__deref_out_opt WIA_DEV_CAP_DRV **__MIDL__IWiaMiniDrv0051,
            /* [out] */ __RPC__out LONG *__MIDL__IWiaMiniDrv0052);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *drvDeleteItem )( 
            IWiaMiniDrv * This,
            /* [in] */ __RPC__in BYTE *__MIDL__IWiaMiniDrv0053,
            /* [in] */ LONG __MIDL__IWiaMiniDrv0054,
            /* [out] */ __RPC__out LONG *__MIDL__IWiaMiniDrv0055);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *drvFreeDrvItemContext )( 
            IWiaMiniDrv * This,
            /* [in] */ LONG __MIDL__IWiaMiniDrv0056,
            /* [in] */ __RPC__in BYTE *__MIDL__IWiaMiniDrv0057,
            /* [out] */ __RPC__out LONG *__MIDL__IWiaMiniDrv0058);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *drvGetWiaFormatInfo )( 
            IWiaMiniDrv * This,
            /* [in] */ __RPC__in BYTE *__MIDL__IWiaMiniDrv0059,
            /* [in] */ LONG __MIDL__IWiaMiniDrv0060,
            /* [out] */ __RPC__out LONG *__MIDL__IWiaMiniDrv0061,
            /* [out] */ __RPC__deref_out_opt WIA_FORMAT_INFO **__MIDL__IWiaMiniDrv0062,
            /* [out] */ __RPC__out LONG *__MIDL__IWiaMiniDrv0063);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *drvNotifyPnpEvent )( 
            IWiaMiniDrv * This,
            /* [in] */ __RPC__in const GUID *pEventGUID,
            /* [in] */ __RPC__in BSTR bstrDeviceID,
            /* [in] */ ULONG ulReserved);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *drvUnInitializeWia )( 
            IWiaMiniDrv * This,
            /* [in] */ __RPC__in BYTE *__MIDL__IWiaMiniDrv0064);
        
        END_INTERFACE
    } IWiaMiniDrvVtbl;

    interface IWiaMiniDrv
    {
        CONST_VTBL struct IWiaMiniDrvVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IWiaMiniDrv_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IWiaMiniDrv_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IWiaMiniDrv_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IWiaMiniDrv_drvInitializeWia(This,__MIDL__IWiaMiniDrv0000,__MIDL__IWiaMiniDrv0001,__MIDL__IWiaMiniDrv0002,__MIDL__IWiaMiniDrv0003,__MIDL__IWiaMiniDrv0004,__MIDL__IWiaMiniDrv0005,__MIDL__IWiaMiniDrv0006,__MIDL__IWiaMiniDrv0007,__MIDL__IWiaMiniDrv0008)	\
    ( (This)->lpVtbl -> drvInitializeWia(This,__MIDL__IWiaMiniDrv0000,__MIDL__IWiaMiniDrv0001,__MIDL__IWiaMiniDrv0002,__MIDL__IWiaMiniDrv0003,__MIDL__IWiaMiniDrv0004,__MIDL__IWiaMiniDrv0005,__MIDL__IWiaMiniDrv0006,__MIDL__IWiaMiniDrv0007,__MIDL__IWiaMiniDrv0008) ) 

#define IWiaMiniDrv_drvAcquireItemData(This,__MIDL__IWiaMiniDrv0009,__MIDL__IWiaMiniDrv0010,__MIDL__IWiaMiniDrv0011,__MIDL__IWiaMiniDrv0012)	\
    ( (This)->lpVtbl -> drvAcquireItemData(This,__MIDL__IWiaMiniDrv0009,__MIDL__IWiaMiniDrv0010,__MIDL__IWiaMiniDrv0011,__MIDL__IWiaMiniDrv0012) ) 

#define IWiaMiniDrv_drvInitItemProperties(This,__MIDL__IWiaMiniDrv0013,__MIDL__IWiaMiniDrv0014,__MIDL__IWiaMiniDrv0015)	\
    ( (This)->lpVtbl -> drvInitItemProperties(This,__MIDL__IWiaMiniDrv0013,__MIDL__IWiaMiniDrv0014,__MIDL__IWiaMiniDrv0015) ) 

#define IWiaMiniDrv_drvValidateItemProperties(This,__MIDL__IWiaMiniDrv0016,__MIDL__IWiaMiniDrv0017,__MIDL__IWiaMiniDrv0018,__MIDL__IWiaMiniDrv0019,__MIDL__IWiaMiniDrv0020)	\
    ( (This)->lpVtbl -> drvValidateItemProperties(This,__MIDL__IWiaMiniDrv0016,__MIDL__IWiaMiniDrv0017,__MIDL__IWiaMiniDrv0018,__MIDL__IWiaMiniDrv0019,__MIDL__IWiaMiniDrv0020) ) 

#define IWiaMiniDrv_drvWriteItemProperties(This,__MIDL__IWiaMiniDrv0021,__MIDL__IWiaMiniDrv0022,__MIDL__IWiaMiniDrv0023,__MIDL__IWiaMiniDrv0024)	\
    ( (This)->lpVtbl -> drvWriteItemProperties(This,__MIDL__IWiaMiniDrv0021,__MIDL__IWiaMiniDrv0022,__MIDL__IWiaMiniDrv0023,__MIDL__IWiaMiniDrv0024) ) 

#define IWiaMiniDrv_drvReadItemProperties(This,__MIDL__IWiaMiniDrv0025,__MIDL__IWiaMiniDrv0026,__MIDL__IWiaMiniDrv0027,__MIDL__IWiaMiniDrv0028,__MIDL__IWiaMiniDrv0029)	\
    ( (This)->lpVtbl -> drvReadItemProperties(This,__MIDL__IWiaMiniDrv0025,__MIDL__IWiaMiniDrv0026,__MIDL__IWiaMiniDrv0027,__MIDL__IWiaMiniDrv0028,__MIDL__IWiaMiniDrv0029) ) 

#define IWiaMiniDrv_drvLockWiaDevice(This,__MIDL__IWiaMiniDrv0030,__MIDL__IWiaMiniDrv0031,__MIDL__IWiaMiniDrv0032)	\
    ( (This)->lpVtbl -> drvLockWiaDevice(This,__MIDL__IWiaMiniDrv0030,__MIDL__IWiaMiniDrv0031,__MIDL__IWiaMiniDrv0032) ) 

#define IWiaMiniDrv_drvUnLockWiaDevice(This,__MIDL__IWiaMiniDrv0033,__MIDL__IWiaMiniDrv0034,__MIDL__IWiaMiniDrv0035)	\
    ( (This)->lpVtbl -> drvUnLockWiaDevice(This,__MIDL__IWiaMiniDrv0033,__MIDL__IWiaMiniDrv0034,__MIDL__IWiaMiniDrv0035) ) 

#define IWiaMiniDrv_drvAnalyzeItem(This,__MIDL__IWiaMiniDrv0036,__MIDL__IWiaMiniDrv0037,__MIDL__IWiaMiniDrv0038)	\
    ( (This)->lpVtbl -> drvAnalyzeItem(This,__MIDL__IWiaMiniDrv0036,__MIDL__IWiaMiniDrv0037,__MIDL__IWiaMiniDrv0038) ) 

#define IWiaMiniDrv_drvGetDeviceErrorStr(This,__MIDL__IWiaMiniDrv0039,__MIDL__IWiaMiniDrv0040,__MIDL__IWiaMiniDrv0041,__MIDL__IWiaMiniDrv0042)	\
    ( (This)->lpVtbl -> drvGetDeviceErrorStr(This,__MIDL__IWiaMiniDrv0039,__MIDL__IWiaMiniDrv0040,__MIDL__IWiaMiniDrv0041,__MIDL__IWiaMiniDrv0042) ) 

#define IWiaMiniDrv_drvDeviceCommand(This,__MIDL__IWiaMiniDrv0043,__MIDL__IWiaMiniDrv0044,__MIDL__IWiaMiniDrv0045,__MIDL__IWiaMiniDrv0046,__MIDL__IWiaMiniDrv0047)	\
    ( (This)->lpVtbl -> drvDeviceCommand(This,__MIDL__IWiaMiniDrv0043,__MIDL__IWiaMiniDrv0044,__MIDL__IWiaMiniDrv0045,__MIDL__IWiaMiniDrv0046,__MIDL__IWiaMiniDrv0047) ) 

#define IWiaMiniDrv_drvGetCapabilities(This,__MIDL__IWiaMiniDrv0048,__MIDL__IWiaMiniDrv0049,__MIDL__IWiaMiniDrv0050,__MIDL__IWiaMiniDrv0051,__MIDL__IWiaMiniDrv0052)	\
    ( (This)->lpVtbl -> drvGetCapabilities(This,__MIDL__IWiaMiniDrv0048,__MIDL__IWiaMiniDrv0049,__MIDL__IWiaMiniDrv0050,__MIDL__IWiaMiniDrv0051,__MIDL__IWiaMiniDrv0052) ) 

#define IWiaMiniDrv_drvDeleteItem(This,__MIDL__IWiaMiniDrv0053,__MIDL__IWiaMiniDrv0054,__MIDL__IWiaMiniDrv0055)	\
    ( (This)->lpVtbl -> drvDeleteItem(This,__MIDL__IWiaMiniDrv0053,__MIDL__IWiaMiniDrv0054,__MIDL__IWiaMiniDrv0055) ) 

#define IWiaMiniDrv_drvFreeDrvItemContext(This,__MIDL__IWiaMiniDrv0056,__MIDL__IWiaMiniDrv0057,__MIDL__IWiaMiniDrv0058)	\
    ( (This)->lpVtbl -> drvFreeDrvItemContext(This,__MIDL__IWiaMiniDrv0056,__MIDL__IWiaMiniDrv0057,__MIDL__IWiaMiniDrv0058) ) 

#define IWiaMiniDrv_drvGetWiaFormatInfo(This,__MIDL__IWiaMiniDrv0059,__MIDL__IWiaMiniDrv0060,__MIDL__IWiaMiniDrv0061,__MIDL__IWiaMiniDrv0062,__MIDL__IWiaMiniDrv0063)	\
    ( (This)->lpVtbl -> drvGetWiaFormatInfo(This,__MIDL__IWiaMiniDrv0059,__MIDL__IWiaMiniDrv0060,__MIDL__IWiaMiniDrv0061,__MIDL__IWiaMiniDrv0062,__MIDL__IWiaMiniDrv0063) ) 

#define IWiaMiniDrv_drvNotifyPnpEvent(This,pEventGUID,bstrDeviceID,ulReserved)	\
    ( (This)->lpVtbl -> drvNotifyPnpEvent(This,pEventGUID,bstrDeviceID,ulReserved) ) 

#define IWiaMiniDrv_drvUnInitializeWia(This,__MIDL__IWiaMiniDrv0064)	\
    ( (This)->lpVtbl -> drvUnInitializeWia(This,__MIDL__IWiaMiniDrv0064) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IWiaMiniDrv_INTERFACE_DEFINED__ */


#ifndef __IWiaMiniDrvCallBack_INTERFACE_DEFINED__
#define __IWiaMiniDrvCallBack_INTERFACE_DEFINED__

/* interface IWiaMiniDrvCallBack */
/* [unique][helpstring][uuid][object] */ 


EXTERN_C const IID IID_IWiaMiniDrvCallBack;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("33a57d5a-3de8-11d2-9a36-00c04fa36145")
    IWiaMiniDrvCallBack : public IUnknown
    {
    public:
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE MiniDrvCallback( 
            /* [in] */ LONG lReason,
            /* [in] */ LONG lStatus,
            /* [in] */ LONG lPercentComplete,
            /* [in] */ LONG lOffset,
            /* [in] */ LONG lLength,
            /* [in] */ __RPC__in PMINIDRV_TRANSFER_CONTEXT pTranCtx,
            /* [in] */ LONG lReserved) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IWiaMiniDrvCallBackVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IWiaMiniDrvCallBack * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IWiaMiniDrvCallBack * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IWiaMiniDrvCallBack * This);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *MiniDrvCallback )( 
            IWiaMiniDrvCallBack * This,
            /* [in] */ LONG lReason,
            /* [in] */ LONG lStatus,
            /* [in] */ LONG lPercentComplete,
            /* [in] */ LONG lOffset,
            /* [in] */ LONG lLength,
            /* [in] */ __RPC__in PMINIDRV_TRANSFER_CONTEXT pTranCtx,
            /* [in] */ LONG lReserved);
        
        END_INTERFACE
    } IWiaMiniDrvCallBackVtbl;

    interface IWiaMiniDrvCallBack
    {
        CONST_VTBL struct IWiaMiniDrvCallBackVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IWiaMiniDrvCallBack_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IWiaMiniDrvCallBack_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IWiaMiniDrvCallBack_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IWiaMiniDrvCallBack_MiniDrvCallback(This,lReason,lStatus,lPercentComplete,lOffset,lLength,pTranCtx,lReserved)	\
    ( (This)->lpVtbl -> MiniDrvCallback(This,lReason,lStatus,lPercentComplete,lOffset,lLength,pTranCtx,lReserved) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IWiaMiniDrvCallBack_INTERFACE_DEFINED__ */


#ifndef __IWiaMiniDrvTransferCallback_INTERFACE_DEFINED__
#define __IWiaMiniDrvTransferCallback_INTERFACE_DEFINED__

/* interface IWiaMiniDrvTransferCallback */
/* [unique][helpstring][uuid][object] */ 


EXTERN_C const IID IID_IWiaMiniDrvTransferCallback;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("a9d2ee89-2ce5-4ff0-8adb-c961d1d774ca")
    IWiaMiniDrvTransferCallback : public IUnknown
    {
    public:
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE GetNextStream( 
            /* [in] */ LONG lFlags,
            /* [in] */ __RPC__in BSTR bstrItemName,
            /* [in] */ __RPC__in BSTR bstrFullItemName,
            /* [out] */ __RPC__deref_out_opt IStream **ppIStream) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE SendMessage( 
            /* [in] */ LONG lFlags,
            /* [in] */ __RPC__in WiaTransferParams *pWiaTransferParams) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IWiaMiniDrvTransferCallbackVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IWiaMiniDrvTransferCallback * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IWiaMiniDrvTransferCallback * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IWiaMiniDrvTransferCallback * This);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *GetNextStream )( 
            IWiaMiniDrvTransferCallback * This,
            /* [in] */ LONG lFlags,
            /* [in] */ __RPC__in BSTR bstrItemName,
            /* [in] */ __RPC__in BSTR bstrFullItemName,
            /* [out] */ __RPC__deref_out_opt IStream **ppIStream);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *SendMessage )( 
            IWiaMiniDrvTransferCallback * This,
            /* [in] */ LONG lFlags,
            /* [in] */ __RPC__in WiaTransferParams *pWiaTransferParams);
        
        END_INTERFACE
    } IWiaMiniDrvTransferCallbackVtbl;

    interface IWiaMiniDrvTransferCallback
    {
        CONST_VTBL struct IWiaMiniDrvTransferCallbackVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IWiaMiniDrvTransferCallback_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IWiaMiniDrvTransferCallback_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IWiaMiniDrvTransferCallback_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IWiaMiniDrvTransferCallback_GetNextStream(This,lFlags,bstrItemName,bstrFullItemName,ppIStream)	\
    ( (This)->lpVtbl -> GetNextStream(This,lFlags,bstrItemName,bstrFullItemName,ppIStream) ) 

#define IWiaMiniDrvTransferCallback_SendMessage(This,lFlags,pWiaTransferParams)	\
    ( (This)->lpVtbl -> SendMessage(This,lFlags,pWiaTransferParams) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IWiaMiniDrvTransferCallback_INTERFACE_DEFINED__ */


#ifndef __IWiaDrvItem_INTERFACE_DEFINED__
#define __IWiaDrvItem_INTERFACE_DEFINED__

/* interface IWiaDrvItem */
/* [unique][helpstring][uuid][object] */ 


EXTERN_C const IID IID_IWiaDrvItem;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("1f02b5c5-b00c-11d2-a094-00c04f72dc3c")
    IWiaDrvItem : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE GetItemFlags( 
            /* [out] */ __RPC__out LONG *__MIDL__IWiaDrvItem0000) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetDeviceSpecContext( 
            /* [out] */ __RPC__deref_out_opt BYTE **__MIDL__IWiaDrvItem0001) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetFullItemName( 
            /* [out] */ __RPC__deref_out_opt BSTR *__MIDL__IWiaDrvItem0002) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetItemName( 
            /* [out] */ __RPC__deref_out_opt BSTR *__MIDL__IWiaDrvItem0003) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE AddItemToFolder( 
            /* [in] */ __RPC__in_opt IWiaDrvItem *__MIDL__IWiaDrvItem0004) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE UnlinkItemTree( 
            /* [in] */ LONG __MIDL__IWiaDrvItem0005) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE RemoveItemFromFolder( 
            /* [in] */ LONG __MIDL__IWiaDrvItem0006) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE FindItemByName( 
            /* [in] */ LONG __MIDL__IWiaDrvItem0007,
            /* [in] */ __RPC__in BSTR __MIDL__IWiaDrvItem0008,
            /* [out] */ __RPC__deref_out_opt IWiaDrvItem **__MIDL__IWiaDrvItem0009) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE FindChildItemByName( 
            /* [in] */ __RPC__in BSTR __MIDL__IWiaDrvItem0010,
            /* [out] */ __RPC__deref_out_opt IWiaDrvItem **__MIDL__IWiaDrvItem0011) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetParentItem( 
            /* [out] */ __RPC__deref_out_opt IWiaDrvItem **__MIDL__IWiaDrvItem0012) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetFirstChildItem( 
            /* [out] */ __RPC__deref_out_opt IWiaDrvItem **__MIDL__IWiaDrvItem0013) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetNextSiblingItem( 
            /* [out] */ __RPC__deref_out_opt IWiaDrvItem **__MIDL__IWiaDrvItem0014) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE DumpItemData( 
            /* [out] */ __RPC__deref_out_opt BSTR *__MIDL__IWiaDrvItem0015) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IWiaDrvItemVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IWiaDrvItem * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IWiaDrvItem * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IWiaDrvItem * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetItemFlags )( 
            IWiaDrvItem * This,
            /* [out] */ __RPC__out LONG *__MIDL__IWiaDrvItem0000);
        
        HRESULT ( STDMETHODCALLTYPE *GetDeviceSpecContext )( 
            IWiaDrvItem * This,
            /* [out] */ __RPC__deref_out_opt BYTE **__MIDL__IWiaDrvItem0001);
        
        HRESULT ( STDMETHODCALLTYPE *GetFullItemName )( 
            IWiaDrvItem * This,
            /* [out] */ __RPC__deref_out_opt BSTR *__MIDL__IWiaDrvItem0002);
        
        HRESULT ( STDMETHODCALLTYPE *GetItemName )( 
            IWiaDrvItem * This,
            /* [out] */ __RPC__deref_out_opt BSTR *__MIDL__IWiaDrvItem0003);
        
        HRESULT ( STDMETHODCALLTYPE *AddItemToFolder )( 
            IWiaDrvItem * This,
            /* [in] */ __RPC__in_opt IWiaDrvItem *__MIDL__IWiaDrvItem0004);
        
        HRESULT ( STDMETHODCALLTYPE *UnlinkItemTree )( 
            IWiaDrvItem * This,
            /* [in] */ LONG __MIDL__IWiaDrvItem0005);
        
        HRESULT ( STDMETHODCALLTYPE *RemoveItemFromFolder )( 
            IWiaDrvItem * This,
            /* [in] */ LONG __MIDL__IWiaDrvItem0006);
        
        HRESULT ( STDMETHODCALLTYPE *FindItemByName )( 
            IWiaDrvItem * This,
            /* [in] */ LONG __MIDL__IWiaDrvItem0007,
            /* [in] */ __RPC__in BSTR __MIDL__IWiaDrvItem0008,
            /* [out] */ __RPC__deref_out_opt IWiaDrvItem **__MIDL__IWiaDrvItem0009);
        
        HRESULT ( STDMETHODCALLTYPE *FindChildItemByName )( 
            IWiaDrvItem * This,
            /* [in] */ __RPC__in BSTR __MIDL__IWiaDrvItem0010,
            /* [out] */ __RPC__deref_out_opt IWiaDrvItem **__MIDL__IWiaDrvItem0011);
        
        HRESULT ( STDMETHODCALLTYPE *GetParentItem )( 
            IWiaDrvItem * This,
            /* [out] */ __RPC__deref_out_opt IWiaDrvItem **__MIDL__IWiaDrvItem0012);
        
        HRESULT ( STDMETHODCALLTYPE *GetFirstChildItem )( 
            IWiaDrvItem * This,
            /* [out] */ __RPC__deref_out_opt IWiaDrvItem **__MIDL__IWiaDrvItem0013);
        
        HRESULT ( STDMETHODCALLTYPE *GetNextSiblingItem )( 
            IWiaDrvItem * This,
            /* [out] */ __RPC__deref_out_opt IWiaDrvItem **__MIDL__IWiaDrvItem0014);
        
        HRESULT ( STDMETHODCALLTYPE *DumpItemData )( 
            IWiaDrvItem * This,
            /* [out] */ __RPC__deref_out_opt BSTR *__MIDL__IWiaDrvItem0015);
        
        END_INTERFACE
    } IWiaDrvItemVtbl;

    interface IWiaDrvItem
    {
        CONST_VTBL struct IWiaDrvItemVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IWiaDrvItem_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IWiaDrvItem_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IWiaDrvItem_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IWiaDrvItem_GetItemFlags(This,__MIDL__IWiaDrvItem0000)	\
    ( (This)->lpVtbl -> GetItemFlags(This,__MIDL__IWiaDrvItem0000) ) 

#define IWiaDrvItem_GetDeviceSpecContext(This,__MIDL__IWiaDrvItem0001)	\
    ( (This)->lpVtbl -> GetDeviceSpecContext(This,__MIDL__IWiaDrvItem0001) ) 

#define IWiaDrvItem_GetFullItemName(This,__MIDL__IWiaDrvItem0002)	\
    ( (This)->lpVtbl -> GetFullItemName(This,__MIDL__IWiaDrvItem0002) ) 

#define IWiaDrvItem_GetItemName(This,__MIDL__IWiaDrvItem0003)	\
    ( (This)->lpVtbl -> GetItemName(This,__MIDL__IWiaDrvItem0003) ) 

#define IWiaDrvItem_AddItemToFolder(This,__MIDL__IWiaDrvItem0004)	\
    ( (This)->lpVtbl -> AddItemToFolder(This,__MIDL__IWiaDrvItem0004) ) 

#define IWiaDrvItem_UnlinkItemTree(This,__MIDL__IWiaDrvItem0005)	\
    ( (This)->lpVtbl -> UnlinkItemTree(This,__MIDL__IWiaDrvItem0005) ) 

#define IWiaDrvItem_RemoveItemFromFolder(This,__MIDL__IWiaDrvItem0006)	\
    ( (This)->lpVtbl -> RemoveItemFromFolder(This,__MIDL__IWiaDrvItem0006) ) 

#define IWiaDrvItem_FindItemByName(This,__MIDL__IWiaDrvItem0007,__MIDL__IWiaDrvItem0008,__MIDL__IWiaDrvItem0009)	\
    ( (This)->lpVtbl -> FindItemByName(This,__MIDL__IWiaDrvItem0007,__MIDL__IWiaDrvItem0008,__MIDL__IWiaDrvItem0009) ) 

#define IWiaDrvItem_FindChildItemByName(This,__MIDL__IWiaDrvItem0010,__MIDL__IWiaDrvItem0011)	\
    ( (This)->lpVtbl -> FindChildItemByName(This,__MIDL__IWiaDrvItem0010,__MIDL__IWiaDrvItem0011) ) 

#define IWiaDrvItem_GetParentItem(This,__MIDL__IWiaDrvItem0012)	\
    ( (This)->lpVtbl -> GetParentItem(This,__MIDL__IWiaDrvItem0012) ) 

#define IWiaDrvItem_GetFirstChildItem(This,__MIDL__IWiaDrvItem0013)	\
    ( (This)->lpVtbl -> GetFirstChildItem(This,__MIDL__IWiaDrvItem0013) ) 

#define IWiaDrvItem_GetNextSiblingItem(This,__MIDL__IWiaDrvItem0014)	\
    ( (This)->lpVtbl -> GetNextSiblingItem(This,__MIDL__IWiaDrvItem0014) ) 

#define IWiaDrvItem_DumpItemData(This,__MIDL__IWiaDrvItem0015)	\
    ( (This)->lpVtbl -> DumpItemData(This,__MIDL__IWiaDrvItem0015) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IWiaDrvItem_INTERFACE_DEFINED__ */


/* interface __MIDL_itf_wiamindr_lh_0000_0004 */
/* [local] */ 

typedef struct _WIA_PROPERTY_INFO
    {
    ULONG lAccessFlags;
    VARTYPE vt;
    union 
        {
        struct 
            {
            LONG Min;
            LONG Nom;
            LONG Max;
            LONG Inc;
            } 	Range;
        struct 
            {
            DOUBLE Min;
            DOUBLE Nom;
            DOUBLE Max;
            DOUBLE Inc;
            } 	RangeFloat;
        struct 
            {
            LONG cNumList;
            LONG Nom;
            BYTE *pList;
            } 	List;
        struct 
            {
            LONG cNumList;
            DOUBLE Nom;
            BYTE *pList;
            } 	ListFloat;
        struct 
            {
            LONG cNumList;
            GUID Nom;
            GUID *pList;
            } 	ListGuid;
        struct 
            {
            LONG cNumList;
            BSTR Nom;
            BSTR *pList;
            } 	ListBStr;
        struct 
            {
            LONG Nom;
            LONG ValidBits;
            } 	Flag;
        struct 
            {
            LONG Dummy;
            } 	None;
        } 	ValidVal;
    } 	WIA_PROPERTY_INFO;

typedef struct _WIA_PROPERTY_INFO *PWIA_PROPERTY_INFO;

typedef struct _WIA_PROPERTY_CONTEXT
    {
    ULONG cProps;
    PROPID *pProps;
    BOOL *pChanged;
    } 	WIA_PROPERTY_CONTEXT;

typedef struct _WIA_PROPERTY_CONTEXT *PWIA_PROPERTY_CONTEXT;

typedef struct _WIAS_CHANGED_VALUE_INFO
    {
    BOOL bChanged;
    LONG vt;
    union 
        {
        LONG lVal;
        FLOAT fltVal;
        BSTR bstrVal;
        GUID guidVal;
        } 	Old;
    union 
        {
        LONG lVal;
        FLOAT fltVal;
        BSTR bstrVal;
        GUID guidVal;
        } 	Current;
    } 	WIAS_CHANGED_VALUE_INFO;

typedef struct _WIAS_CHANGED_VALUE_INFO *PWIAS_CHANGED_VALUE_INFO;

typedef struct _WIAS_DOWN_SAMPLE_INFO
    {
    ULONG ulOriginalWidth;
    ULONG ulOriginalHeight;
    ULONG ulBitsPerPixel;
    ULONG ulXRes;
    ULONG ulYRes;
    ULONG ulDownSampledWidth;
    ULONG ulDownSampledHeight;
    ULONG ulActualSize;
    ULONG ulDestBufSize;
    ULONG ulSrcBufSize;
    BYTE *pSrcBuffer;
    BYTE *pDestBuffer;
    } 	WIAS_DOWN_SAMPLE_INFO;

typedef struct _WIAS_DOWN_SAMPLE_INFO *PWIAS_DOWN_SAMPLE_INFO;

typedef struct _WIAS_ENDORSER_VALUE
    {
    LPWSTR wszTokenName;
    LPWSTR wszValue;
    } 	WIAS_ENDORSER_VALUE;

typedef struct _WIAS_ENDORSER_VALUE *PWIAS_ENDORSER_VALUE;

typedef struct _WIAS_ENDORSER_INFO
    {
    ULONG ulPageCount;
    ULONG ulNumEndorserValues;
    WIAS_ENDORSER_VALUE *pEndorserValues;
    } 	WIAS_ENDORSER_INFO;

typedef struct _WIAS_ENDORSER_INFO *PWIAS_ENDORSER_INFO;

#include "wiamdef.h"


extern RPC_IF_HANDLE __MIDL_itf_wiamindr_lh_0000_0004_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_wiamindr_lh_0000_0004_v0_0_s_ifspec;

/* Additional Prototypes for ALL interfaces */

unsigned long             __RPC_USER  BSTR_UserSize(     unsigned long *, unsigned long            , BSTR * ); 
unsigned char * __RPC_USER  BSTR_UserMarshal(  unsigned long *, unsigned char *, BSTR * ); 
unsigned char * __RPC_USER  BSTR_UserUnmarshal(unsigned long *, unsigned char *, BSTR * ); 
void                      __RPC_USER  BSTR_UserFree(     unsigned long *, BSTR * ); 

unsigned long             __RPC_USER  BSTR_UserSize64(     unsigned long *, unsigned long            , BSTR * ); 
unsigned char * __RPC_USER  BSTR_UserMarshal64(  unsigned long *, unsigned char *, BSTR * ); 
unsigned char * __RPC_USER  BSTR_UserUnmarshal64(unsigned long *, unsigned char *, BSTR * ); 
void                      __RPC_USER  BSTR_UserFree64(     unsigned long *, BSTR * ); 

/* end of Additional Prototypes */

#ifdef __cplusplus
}
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\win2k8\ddk\inc\wiautil.h ===
/****************************************************************************
*
*  (C) COPYRIGHT 2000, MICROSOFT CORP.
*
*  FILE:        wiautil.h
*
*  VERSION:     1.0
*
*  DATE:        11/17/2000
*
*  DESCRIPTION:
*    Definitions for WIA driver helper classes and functions.
*    NOTE: This header requires wiamindr.h to be included.
*
*****************************************************************************/

#if (_WIN32_WINNT >= 0x0501) // Windows XP and later

#pragma once

#define STRSAFE_NO_DEPRECATE
#include <strsafe.h>

/**************************************************************************\
* CWiauFormatConverter
*
*   Helper class for converting images to BMP format.
*
\**************************************************************************/

typedef struct _BMP_IMAGE_INFO
{
    INT     Width;      // Width of the image in pixels
    INT     Height;     // Height of the image in lines
    INT     ByteWidth;  // Width of the image in bytes
    INT     Size;       // Total size of the image, including headers
} BMP_IMAGE_INFO, *PBMP_IMAGE_INFO;

typedef enum
{
    SKIP_OFF,
    SKIP_FILEHDR,
    SKIP_BOTHHDR

} SKIP_AMOUNT;

class CWiauFormatConverter
{
public:
    CWiauFormatConverter();
    ~CWiauFormatConverter();

    /**************************************************************************\
    * Init
    *
    *   Intializes this class and GDI+ for converting images. This method
    *   should be called just once.
    *
    \**************************************************************************/

    HRESULT Init();


    /**************************************************************************\
    * IsFormatSupported
    *
    *   This method will verify that GDI+ supports the image format
    *   that is to be converted.
    *
    * Arguments:
    *
    *   pguidFormat - pointer to GUID format from gdiplusimaging.h
    *
    \**************************************************************************/

    BOOL IsFormatSupported(const GUID *pguidFormat);


    /**************************************************************************\
    * ConvertToBmp
    *
    *   This method will convert an image to BMP format. The caller can pass
    *   a result buffer in ppDest and the size in piDestSize. Alternatively
    *   the caller can set *ppDest to NULL and *piDestSize to zero to
    *   indicate that this method should allocate the memory. The caller is
    *   responsible for freeing the memory with "delete []".
    *
    * Arguments:
    *
    *    pSource         - pointer to memory location of source image
    *    iSourceSize     - size of source image
    *    ppDest          - location to receive memory location of result image
    *    piDestSize      - location to receive size of result image
    *    pBmpImageInfo   - location to receive stats about the BMP
    *    iSkipAmt        - Indicates how much of the BMP header to skip:
    *                       SKIP_OFF     = skip neither header
    *                       SKIP_FILEHDR = skip the file header
    *                       SKIP_BOTHHDR = skip the file and info headers
    *
    \**************************************************************************/

    HRESULT ConvertToBmp(BYTE *pSource, INT iSourceSize, BYTE **ppDest, INT *piDestSize,
                         BMP_IMAGE_INFO *pBmpImageInfo, SKIP_AMOUNT iSkipAmt = SKIP_OFF);


private:
    ULONG_PTR   m_Token;
    UINT        m_EncoderCount;
    BYTE       *m_pEncoderInfo;
    GUID        m_guidCodecBmp;
};


/**************************************************************************\
* CWiauPropertyList
*
*   Helper class for definining and initializing WIA properties
*
\**************************************************************************/

class CWiauPropertyList
{
private:

    int                  m_NumAlloc;    // number of slots allocated
    int                  m_NumProps;    // number of properties defined
    PROPID              *m_pId;         // property ids
    LPOLESTR            *m_pNames;      // property names
    PROPVARIANT         *m_pCurrent;    // current value
    PROPSPEC            *m_pPropSpec;   // property spec (used for WriteMultiple)
    WIA_PROPERTY_INFO   *m_pAttrib;     // property attributes

public:

    CWiauPropertyList();
    ~CWiauPropertyList();
    
    /**************************************************************************\
    * Init
    *
    *   Initializes the property info object.
    *
    * Arguments:
    *   NumProps - number of properties to reserve space for. This number can
    *              be larger than the actual number used, but cannot be smaller.
    *
    \**************************************************************************/
    
    HRESULT Init(INT NumProps);
    
    
    /**************************************************************************\
    * DefineProperty
    *
    *   Adds a property definition to the object.
    *
    * Arguments:
    *   index    - pointer to an int that will be set to the property index
    *              within the object, useful for passing to other property
    *              info methods
    *   PropId   - property ID constant
    *   PropName - property name string
    *   Access   - determines access to the property, usually either
    *              WIA_PROP_READ or WIA_PROP_RW
    *   SubType  - indicates subtype of the property, usually either
    *              WIA_PROP_NONE, WIA_PROP_FLAG, WIA_PROP_RANGE, or WIA_PROP_LIST
    *
    \**************************************************************************/

    HRESULT DefineProperty(int *pIdx, PROPID PropId, __in LPOLESTR PropName,
                           ULONG Access, ULONG SubType);
    
    
    /**************************************************************************\
    * SendToWia
    *
    *   Calls the WIA service to define all of the properties currently
    *   contained in the object. Should be called once after all properties
    *   are defined and set.
    *
    * Arguments:
    *   pWiasContext - pointer to the context passed into drvInitItemProperties
    *
    \**************************************************************************/
    
    HRESULT SendToWia(BYTE *pWiasContext);
    
    
    /**************************************************************************\
    * SetAccessSubType
    *
    *   Used to reset the access and subtype of a property.
    *
    * Arguments:
    *   index   - the property index, from DefineProperty
    *   Access  - determines access to the property, usually either
    *             WIA_PROP_READ or WIA_PROP_RW
    *   SubType - indicates subtype of the property, usually either
    *             WIA_PROP_NONE, WIA_PROP_FLAG, WIA_PROP_RANGE, or WIA_PROP_LIST
    *
    \**************************************************************************/

#if (_WIN32_WINNT == 0x0501)
    void SetAccessSubType(INT index, ULONG Access, ULONG SubType);
#else
    HRESULT SetAccessSubType(INT index, ULONG Access, ULONG SubType);
#endif

    
    /**************************************************************************\
    * SetValidValues (flag)
    *
    *   Sets the type and current, default, and valid values of a property.
    *   Also sets property type to VT_I4 and subtype to WIA_PROP_FLAG.
    *
    * Arguments:
    *   index        - the property index, from DefineProperty
    *   defaultValue - default setting of this property on the device
    *   currentValue - current setting of this property on the device
    *   validFlags   - combination of all valid flags
    *
    \**************************************************************************/

#if (_WIN32_WINNT == 0x0501)
    void SetValidValues(INT index, LONG defaultValue, LONG currentValue, LONG validFlags);
#else
    HRESULT SetValidValues(INT index, LONG defaultValue, LONG currentValue, LONG validFlags);
#endif

    
    /**************************************************************************\
    * SetValidValues (signed long, range)
    *
    *   Sets the type and current, default, and valid values of a property.
    *   Also sets property type to VT_I4 and subtype to WIA_PROP_RANGE.
    *
    * Arguments:
    *   index        - the property index, from DefineProperty
    *   defaultValue - default setting of this property on the device
    *   currentValue - current setting of this property on the device
    *   minValue     - minimum value for the range
    *   maxValue     - maximum value for the range
    *   stepValue    - step value for the range
    *
    \**************************************************************************/

#if (_WIN32_WINNT == 0x0501)
    void SetValidValues(INT index, LONG defaultValue, LONG currentValue,
                           LONG minValue, LONG maxValue, LONG stepValue);
#else
    HRESULT SetValidValues(INT index, LONG defaultValue, LONG currentValue,
                           LONG minValue, LONG maxValue, LONG stepValue);
#endif
    
    
    /**************************************************************************\
    * SetValidValues (signed long, list)
    *
    *   Sets the type and current, default, and valid values of a property.
    *   Also sets property type to VT_I4 and subtype to WIA_PROP_LIST.
    *
    * Arguments:
    *   index        - the property index, from DefineProperty
    *   defaultValue - default setting of this property on the device
    *   currentValue - current setting of this property on the device
    *   numValues    - number of values in the list
    *   pValues      - pointer to the value list (must be valid until SendToWia
    *                  is called)
    *
    \**************************************************************************/

#if (_WIN32_WINNT == 0x0501)
    void SetValidValues(INT index, LONG defaultValue, LONG currentValue,
                           INT numValues, PLONG pValues);
#else
    HRESULT SetValidValues(INT index, LONG defaultValue, LONG currentValue,
                           INT numValues, PLONG pValues);
#endif

    
    /**************************************************************************\
    * SetValidValues (BSTR, list)
    *
    *   Sets the type and current, default, and valid values of a property.
    *   Also sets property type to VT_BSTR and subtype to WIA_PROP_LIST.
    *
    * Arguments:
    *   index        - the property index, from DefineProperty
    *   defaultValue - default setting of this property on the device
    *   currentValue - current setting of this property on the device
    *   numValues    - number of values in the list
    *   pValues      - pointer to the value list (must be valid until SendToWia
    *                  is called)
    *
    \**************************************************************************/

#if (_WIN32_WINNT == 0x0501)
    void SetValidValues(INT index, BSTR defaultValue, BSTR currentValue,
                           INT numValues, BSTR *pValues);
#else
    HRESULT SetValidValues(INT index, BSTR defaultValue, BSTR currentValue,
                           INT numValues, BSTR *pValues);
#endif

    
    /**************************************************************************\
    * SetValidValues (float, range)
    *
    *   Sets the type and current, default, and valid values of a property.
    *   Also sets property type to VT_R4 and subtype to WIA_PROP_RANGE.
    *
    * Arguments:
    *   index        - the property index, from DefineProperty
    *   defaultValue - default setting of this property on the device
    *   currentValue - current setting of this property on the device
    *   minValue     - minimum value for the range
    *   maxValue     - maximum value for the range
    *   stepValue    - step value for the range
    *
    \**************************************************************************/

#if (_WIN32_WINNT == 0x0501)
    void SetValidValues(INT index, FLOAT defaultValue, FLOAT currentValue,
                           FLOAT minValue, FLOAT maxValue, FLOAT stepValue);
#else
    HRESULT SetValidValues(INT index, FLOAT defaultValue, FLOAT currentValue,
                           FLOAT minValue, FLOAT maxValue, FLOAT stepValue);
#endif
    
    
    /**************************************************************************\
    * SetValidValues (float, list)
    *
    *   Sets the type and current, default, and valid values of a property.
    *   Also sets property type to VT_R4 and subtype to WIA_PROP_LIST.
    *
    * Arguments:
    *   index        - the property index, from DefineProperty
    *   defaultValue - default setting of this property on the device
    *   currentValue - current setting of this property on the device
    *   numValues    - number of values in the list
    *   pValues      - pointer to the value list (must be valid until SendToWia
    *                  is called)
    *
    \**************************************************************************/

#if (_WIN32_WINNT == 0x0501)
    void SetValidValues(INT index, FLOAT defaultValue, FLOAT currentValue,
                           INT numValues, PFLOAT pValues);
#else
    HRESULT SetValidValues(INT index, FLOAT defaultValue, FLOAT currentValue,
                           INT numValues, PFLOAT pValues);
#endif
    
    
    /**************************************************************************\
    * SetValidValues (CLSID, list)
    *
    *   Sets the type and current, default, and valid values of a property.
    *   Also sets property type to VT_CLSID and subtype to WIA_PROP_LIST.
    *
    * Arguments:
    *   index        - the property index, from DefineProperty
    *   defaultValue - default setting of this property on the device
    *   currentValue - current setting of this property on the device
    *   numValues    - number of values in the list
    *   pValues      - pointer to the value list (must be valid until SendToWia
    *                  is called)
    *
    \**************************************************************************/

#if (_WIN32_WINNT == 0x0501)
    void SetValidValues(INT index, CLSID *defaultValue, CLSID *currentValue,
                           INT numValues, CLSID **pValues);
#else
    HRESULT SetValidValues(INT index, CLSID *defaultValue, CLSID *currentValue,
                           INT numValues, CLSID **pValues);
#endif
    
    
    /**************************************************************************\
    * SetCurrentValue (signed long)
    *
    *   Sets the current value for a property. Also sets the type to VT_I4.
    *
    * Arguments:
    *   index  - the property index, from DefineProperty
    *   value  - current setting of this property on the device
    *
    \**************************************************************************/

#if (_WIN32_WINNT == 0x0501)
    void SetCurrentValue(INT index, LONG value);
#else
    HRESULT SetCurrentValue(INT index, LONG value);
#endif
    
    
    /**************************************************************************\
    * SetCurrentValue (BSTR)
    *
    *   Sets the current value for a property. Also sets the type to VT_BSTR.
    *
    * Arguments:
    *   index  - the property index, from DefineProperty
    *   value  - current setting of this property on the device
    *            (must be valid until SendToWia is called)
    *
    \**************************************************************************/
    
#if (_WIN32_WINNT == 0x0501)
    void  SetCurrentValue(INT index, BSTR value);
#else
    HRESULT SetCurrentValue(INT index, BSTR value);
#endif
    
    
    /**************************************************************************\
    * SetCurrentValue (float)
    *
    *   Sets the current value for a property. Also sets the type to VT_R4.
    *
    * Arguments:
    *   index  - the property index, from DefineProperty
    *   value  - current setting of this property on the device
    *
    \**************************************************************************/
    
#if (_WIN32_WINNT == 0x0501)
    void SetCurrentValue(INT index, FLOAT value);
#else
    HRESULT SetCurrentValue(INT index, FLOAT value);
#endif
    
    
    /**************************************************************************\
    * SetCurrentValue (CLSID)
    *
    *   Sets the current value for a property. Also sets the type to VT_CLSID.
    *
    * Arguments:
    *   index  - the property index, from DefineProperty
    *   value  - current setting of this property on the device
    *            (must be valid until SendToWia is called)
    *
    \**************************************************************************/
    
#if (_WIN32_WINNT == 0x0501)
    void SetCurrentValue(INT index, CLSID *pValue);
#else
    HRESULT SetCurrentValue(INT index, CLSID *pValue);
#endif
    
    
    /**************************************************************************\
    * SetCurrentValue (SYSTEMTIME)
    *
    *   Sets the current value for a property. Also sets the type to
    *   VT_UI2 | VT_VECTOR.
    *
    * Arguments:
    *   index  - the property index, from DefineProperty
    *   value  - current setting of this property on the device
    *            (must be valid until SendToWia is called)
    *
    \**************************************************************************/
    
#if (_WIN32_WINNT == 0x0501)
    void SetCurrentValue(INT index, PSYSTEMTIME value);
#else
    HRESULT SetCurrentValue(INT index, PSYSTEMTIME value);
#endif
    
    
    /**************************************************************************\
    * SetCurrentValue (byte array)
    *
    *   Sets the current value for a property. Also sets the type to
    *   VT_UI1 | VT_VECTOR.
    *
    * Arguments:
    *   index  - the property index, from DefineProperty
    *   value  - pointer to current setting of this property on the device
    *            (must be valid until SendToWia is called)
    *
    \**************************************************************************/
    
#if (_WIN32_WINNT == 0x0501)
    void SetCurrentValue(INT index, BYTE *value, INT size);
#else
    HRESULT SetCurrentValue(INT index, BYTE *value, INT size);
#endif

    
    /**************************************************************************\
    * GetPropId
    *
    *   Returns the property id given a property index.
    *
    \**************************************************************************/
    
    PROPID GetPropId(INT index) { return m_pId[index]; }
    
    
    /**************************************************************************\
    * LookupPropId
    *
    *   Finds the property index given a property ID.
    *
    \**************************************************************************/
    
    INT LookupPropId(PROPID PropId);
};


/**************************************************************************\
* wiauGetDrvItemContext
*
*   This helper function gets the driver item context, and optionally
*   return the driver item
*
* Arguments:
*
*   pWiasContext - pointer to the item context
*   ppItemCtx    - location to store pointer to driver item context
*   ppDrvItem    - location to store pointer to driver item (can be NULL)
*
\**************************************************************************/

#if (_WIN32_WINNT == 0x0501)
    HRESULT wiauGetDrvItemContext(BYTE *pWiasContext, VOID **ppItemCtx, IWiaDrvItem **ppDrvItem = NULL);
#else
    HRESULT _stdcall wiauGetDrvItemContext(BYTE *pWiasContext, VOID **ppItemCtx, IWiaDrvItem **ppDrvItem = NULL);
#endif


/**************************************************************************\
* wiauSetImageItemSize
*
*   Calulates the size and width in bytes for an image based on the current
*   WIA_IPA_FORMAT setting, and writes the new values to the appropriate
*   properties. If the format is not BMP, this function assumes that the
*   value passed in lSize is correct for the current format.
*
* Arguments:
*
*   pWiasContext    - pointer to item context
*   lWidth          - width of the image in pixels
*   lHeight         - height of the image in lines
*   lDepth          - depth of the image in bits
*   lSize           - size of the image as stored on the device
*   pwszExt         - optional pointer to the 3 letter extension for the
*                     item's native format (if this is NULL, the extension
*                     property won't be updated)
*
\**************************************************************************/

#if (_WIN32_WINNT == 0x0501)
    HRESULT wiauSetImageItemSize(BYTE *pWiasContext, LONG lWidth, LONG lHeight, LONG lDepth,
        LONG lSize, __in_opt PWSTR pwszExt = NULL);
#else
    HRESULT _stdcall wiauSetImageItemSize(BYTE *pWiasContext, LONG lWidth, LONG lHeight, LONG lDepth,
                                 LONG lSize, __in_opt PWSTR pwszExt = NULL);
#endif


/**************************************************************************\
* wiauPropsInPropSpec
*
*   Returns true if one or more of the property ids in pProps are
*   contained in pPropSpecs.
*
* Arguments:
*
*   NumPropSpecs - number of property specs in the array
*   pPropSpecs   - the property specs array
*   NumProps     - number of property ids to search for
*   pProps       - pointer to the array of property ids to search for
*
\**************************************************************************/

#if (_WIN32_WINNT == 0x0501)
    BOOL wiauPropsInPropSpec(LONG NumPropSpecs, __in_ecount(NumPropSpecs) const PROPSPEC *pPropSpecs, int NumProps, __in_ecount(NumProps) PROPID *pProps);
#else
    BOOL _stdcall wiauPropsInPropSpec(LONG NumPropSpecs, __in_ecount(NumPropSpecs) const PROPSPEC *pPropSpecs, int NumProps, __in_ecount(NumProps) PROPID *pProps);
#endif


/**************************************************************************\
* wiauPropInPropSpec
*
*   Returns true if the PropId property ID is in the passed pPropSpecs
*   array. Optionally will return the index of where the ID was found.
*
* Arguments:
*
*   NumPropSpecs - number of property specs in the array
*   pPropSpecs   - the property specs array
*   PropId       - property id to search for
*   pIdx         - optional pointer to the location to store the index
*
\**************************************************************************/

#if (_WIN32_WINNT == 0x0501)
    BOOL wiauPropInPropSpec(LONG NumPropSpecs, __in_ecount(NumPropSpecs) const PROPSPEC *pPropSpecs, PROPID PropId, int *pIdx = NULL);
#else
    BOOL _stdcall wiauPropInPropSpec(LONG NumPropSpecs, __in_ecount(NumPropSpecs) const PROPSPEC *pPropSpecs, PROPID PropId, int *pIdx = NULL);
#endif


/**************************************************************************\
* wiauGetValidFormats
*
*   Calls drvGetWiaFormatInfo and makes a list of valid formats given
*   a tymed value. Caller is responsible for freeing the format array
*   with []delete.
*
* Arguments:
*
*   pDrv          - Pointer to WIA minidriver object (use "this")
*   pWiasContext  - WIA service context
*   TymedValue    - tymed value to search for
*   pNumFormats   - pointer to value to receive number of formats
*   ppFormatArray - pointer to a location to receive array address
*
\**************************************************************************/

#if (_WIN32_WINNT == 0x0501)
    HRESULT wiauGetValidFormats(IWiaMiniDrv *pDrv, BYTE *pWiasContext, LONG TymedValue,
                                int *pNumFormats, GUID **ppFormatArray);
#else
    HRESULT _stdcall wiauGetValidFormats(IWiaMiniDrv *pDrv, BYTE *pWiasContext, LONG TymedValue,
                                int *pNumFormats, GUID **ppFormatArray);
#endif


/**************************************************************************\
* wiauGetResourceString
*
*   This helper gets a resource string and returns it as a BSTR
*
* Arguments:
*
*   hInst       - Handle to module instance
*   lResourceID - Resource ID of the target BSTR value
*   pbstrStr    - Location to store the retrieved string (caller must
*                 free this string with SysFreeString())
*
\**************************************************************************/

#if (_WIN32_WINNT == 0x0501)
    HRESULT wiauGetResourceString(HINSTANCE hInst, LONG lResourceID, BSTR *pbstrStr);
#else
    HRESULT _stdcall wiauGetResourceString(HINSTANCE hInst, LONG lResourceID, BSTR *pbstrStr);
#endif


/**************************************************************************\
* wiauRegOpenDataW
*
*   Opens the DeviceData key. Call this function only in the STI Initialize
*   function. Call RegCloseKey when finished.
*
* Arguments:
*
*   hkeyAncestor    - HKey of parent (use hkey passed into Initialize)
*   phkeyDeviceData - Location to store opened hkey
*
\**************************************************************************/
#if (_WIN32_WINNT == 0x0501)
    HRESULT wiauRegOpenDataW(HKEY hkeyAncestor, HKEY *phkeyDeviceData);
#else
    HRESULT _stdcall wiauRegOpenDataW(HKEY hkeyAncestor, HKEY *phkeyDeviceData);
#endif


/**************************************************************************\
* wiauRegOpenDataA
*
*   Opens the DeviceData key. Call this function only in the STI Initialize
*   function. Call RegCloseKey when finished.
*
* Arguments:
*
*   hkeyAncestor    - HKey of parent (use hkey passed into Initialize)
*   phkeyDeviceData - Location to store opened hkey
*
\**************************************************************************/
#if (_WIN32_WINNT == 0x0501)
    HRESULT wiauRegOpenDataA(HKEY hkeyAncestor, HKEY *phkeyDeviceData);
#else
    HRESULT _stdcall wiauRegOpenDataA(HKEY hkeyAncestor, HKEY *phkeyDeviceData);
#endif


/**************************************************************************\
* wiauRegGetStrW
*
*   Use to get string value from the DeviceData section of the registry.
*
* Arguments:
*
*   hkey          - Use hkey returned from wiauRegOpenData
*   pwszValueName - Name of registry entry
*   pwszValue     - Location to store returned string
*   pdwLength     - Size of location in bytes
*
\**************************************************************************/
#if (_WIN32_WINNT == 0x0501)
    HRESULT wiauRegGetStrW(HKEY hkKey, __in PCWSTR pwszValueName, __out_bcount(*pdwLength) PWSTR pwszValue, DWORD *pdwLength);
#else
    HRESULT _stdcall wiauRegGetStrW(HKEY hkKey, __in PCWSTR pwszValueName, __out_bcount(*pdwLength) PWSTR pwszValue, DWORD *pdwLength);
#endif


/**************************************************************************\
* wiauRegGetStrA
*
*   Use to get string value from the DeviceData section of the registry.
*
* Arguments:
*
*   hkey          - Use hkey returned from wiauRegOpenData
*   pszValueName  - Name of registry entry
*   pszValue      - Location to store returned string
*   pdwLength     - Size of location in bytes
*
\**************************************************************************/
#if (_WIN32_WINNT == 0x0501)
    HRESULT wiauRegGetStrA(__in HKEY hkKey, __in PCSTR pszValueName, __out_bcount(*pdwLength) PSTR pszValue, __inout DWORD *pdwLength);
#else
    HRESULT _stdcall wiauRegGetStrA(__in HKEY hkKey, __in PCSTR pszValueName, __out_bcount(*pdwLength) PSTR pszValue, __inout DWORD *pdwLength);
#endif


/**************************************************************************\
* wiauRegGetDwordW
*
*   Use to get DWORD value from the DeviceData section of the registry.
*
* Arguments:
*
*   hkey          - Use hkey returned from wiauRegOpenData
*   pwszValueName - Name of registry entry
*   pdwValue      - Location to store returned DWORD
*
\**************************************************************************/
#if (_WIN32_WINNT == 0x0501)
    HRESULT wiauRegGetDwordW(HKEY hkKey, PCWSTR pwszValueName, DWORD *pdwValue);
#else
    HRESULT _stdcall wiauRegGetDwordW(HKEY hkKey, PCWSTR pwszValueName, DWORD *pdwValue);
#endif


/**************************************************************************\
* wiauRegGetDwordA
*
*   Use to get DWORD value from the DeviceData section of the registry.
*
* Arguments:
*
*   hkey          - Use hkey returned from wiauRegOpenData
*   pszValueName  - Name of registry entry
*   pdwValue      - Location to store returned DWORD
*
\**************************************************************************/
#if (_WIN32_WINNT == 0x0501)
    HRESULT wiauRegGetDwordA(HKEY hkKey, PCSTR pszValueName, DWORD *pdwValue);
#else
    HRESULT _stdcall wiauRegGetDwordA(HKEY hkKey, PCSTR pszValueName, DWORD *pdwValue);
#endif


/**************************************************************************\
* WiauStrW2C
*
*   Converts a wide character string to an ANSI character string
*
* Arguments:
*   pwszSrc - wide character string to be converted
*   pszDst  - location to store the ANSI conversion
*   iSize   - size of the buffer pointed to by pszDst, in bytes
*
\**************************************************************************/
#if (_WIN32_WINNT == 0x0501)
    HRESULT wiauStrW2C(__in_ecount(iSize) WCHAR *pwszSrc, __out_ecount(iSize) CHAR *pszDst, INT iSize);
#else
    HRESULT _stdcall wiauStrW2C(__in_ecount(iSize) WCHAR *pwszSrc, __out_ecount(iSize) CHAR *pszDst, INT iSize);
#endif

/**************************************************************************\
* WiauStrC2W
*
*   Converts an ANSI character string to a wide character string
*
* Arguments:
*   pszSrc  - ANSI string to convert
*   wpszDst - location to store the wide string
*   iSize   - size of the buffer pointed to by wpszDst, in bytes
*
\**************************************************************************/
#if (_WIN32_WINNT == 0x0501)
    HRESULT wiauStrC2W(__in CHAR *pszSrc, __out_bcount(iSize) WCHAR *pwszDst, INT iSize);
#else
    HRESULT _stdcall wiauStrC2W(__in CHAR *pszSrc, __out_bcount(iSize) WCHAR *pwszDst, INT iSize);
#endif


/**************************************************************************\
* WiauStrW2W
*
*   Copies a wide character string to another wide character string
*
* Arguments:
*   pwszSrc - wide character string to be copied
*   pwszDst - location to copy to
*   iSize   - size of the buffer pointed to by pwszDst, in bytes
*
\**************************************************************************/

#if (_WIN32_WINNT == 0x0501)
    HRESULT wiauStrW2W(__in WCHAR *pwszSrc, __out_bcount(iSize) WCHAR *pwszDst, INT iSize);
#else
    HRESULT _stdcall wiauStrW2W(__in WCHAR *pwszSrc, __out_bcount(iSize) WCHAR *pwszDst, INT iSize);
#endif


/**************************************************************************\
* WiauStrC2C
*
*   Copies an ANSI character string to another ANSI character string
*
* Arguments:
*   pszSrc - ANSI string to be copied
*   pszDst - location to copy to
*   iSize  - size of the buffer pointed to by pszDst, in bytes
*
\**************************************************************************/

#if (_WIN32_WINNT == 0x0501)
    HRESULT wiauStrC2C(__in CHAR *pszSrc, __out_bcount(iSize) CHAR *pszDst, INT iSize);
#else
    HRESULT _stdcall wiauStrC2C(__in CHAR *pszSrc, __out_bcount(iSize) CHAR *pszDst, INT iSize);
#endif


#ifdef UNICODE

#define wiauRegOpenData wiauRegOpenDataW
#define wiauRegGetStr wiauRegGetStrW
#define wiauRegGetDword wiauRegGetDwordW

#define wiauStrT2C wiauStrW2C
#define wiauStrC2T wiauStrC2W
#define wiauStrT2W wiauStrW2W
#define wiauStrW2T wiauStrW2W
#define WIAU_DEBUG_TSTR "S"

#else

#define wiauRegOpenData wiauRegOpenDataA
#define wiauRegGetStr wiauRegGetStrA
#define wiauRegGetDword wiauRegGetDwordA

#define wiauStrT2C wiauStrC2C
#define wiauStrC2T wiauStrC2C
#define wiauStrT2W wiauStrC2W
#define wiauStrW2T wiauStrW2C
#define WIAU_DEBUG_TSTR "s"

#endif // UNICODE


/**************************************************************************\
* WIA Debugging
*
*   Definitions for debug messages. To use WIA debugging:
*   1. Set registry HKLM\System\CurrentControlSet\Control\StillImage\Debug\<ModuleName>,
*      DWORD value "DebugFlags" to the combination of the WIAUDBG_* flags
*      desired. The application and possibly the WIA service will need to be
*      restarted to pick up the new settings. The key is auto created the
*      first time the module is executed. (Note: <ModuleName> above is the
*      name of the DLL or EXE, e.g. wiavusd.dll has a registry key of
*      "HKLM\System\CurrentControlSet\Control\StillImage\Debug\wiavusd.dll".)
*   2. Or in the debugger, set g_dwDebugFlags to the combination of the
*      WIAUDBG_* flags desired. This can be done anytime during the debug
*      session.
*   3. From the module, call wiauDbgSetFlags(<flags>), where <flags> is the
*      combination of the WIAUDBG_* flags desired.
*
*   Messages will be logged to the debugger and the file
*   %systemroot%\\wiadebug.log, unless the WIAUDBG_DONT_LOG_* flags are set.
*   Setting both flags will turn off all messages.
*
*   All strings should be ASCII. Use %S in the format string to print a
*   Unicode string.
*
\**************************************************************************/

#define _STIDEBUG_H_ // WIA debugging is incompatible with stidebug.h, so don't include it

//
// Predefined debug flags
//

const DWORD WIAUDBG_ERRORS                = 0x00000001;
const DWORD WIAUDBG_WARNINGS              = 0x00000002;
const DWORD WIAUDBG_TRACES                = 0x00000004;
const DWORD WIAUDBG_FNS                   = 0x00000008;  // Function entry and exit
const DWORD WIAUDBG_DUMP                  = 0x00000010;  // Dump data
const DWORD WIAUDBG_PRINT_TIME            = 0x08000000;  // Prints time for each message
const DWORD WIAUDBG_PRINT_INFO            = 0x10000000;  // Turns on thread, file, line info
const DWORD WIAUDBG_DONT_LOG_TO_DEBUGGER  = 0x20000000;
const DWORD WIAUDBG_DONT_LOG_TO_FILE      = 0x40000000;
const DWORD WIAUDBG_BREAK_ON_ERRORS       = 0x80000000;  // Do DebugBreak on errors

//
// Don't log at all
//
const DWORD WIAUDBG_DONT_LOG = WIAUDBG_DONT_LOG_TO_FILE | WIAUDBG_DONT_LOG_TO_DEBUGGER;

//
// Set default flags
//
#ifdef DEBUG
const DWORD WIAUDBG_DEFAULT_FLAGS = WIAUDBG_ERRORS;
#else
const DWORD WIAUDBG_DEFAULT_FLAGS = WIAUDBG_DONT_LOG;
#endif

//
// FormatMessage flags
//
const DWORD WIAUDBG_MFMT_FLAGS = FORMAT_MESSAGE_IGNORE_INSERTS |
                                 FORMAT_MESSAGE_FROM_SYSTEM |
                                 FORMAT_MESSAGE_MAX_WIDTH_MASK;

#ifdef __cplusplus
extern "C" {
#endif

//
// WIA Debugging has very little overhead and should be put into retail
// code for drivers. If it's really desired to remove it, define NO_WIA_DEBUG.
//

#ifdef NO_WIA_DEBUG

#define g_dwDebugFlags 0
#define wiauDbgInit(a)
#define wiauDbgHelper(a,b,c,d)
#define wiauDbgHelper2  wiauNull3
#define wiauDbgFlags    wiauNull4
#define wiauDbgError    wiauNull2
#define wiauDbgErrorHr  wiauNull3hr
#define wiauDbgWarning  wiauNull2
#define wiauDbgTrace    wiauNull2
#define wiauDbgDump     wiauNull2
#define wiauDbgSetFlags(a) 0
#define wiauDbgLegacyError      wiauNull1
#define wiauDbgLegacyWarning    wiauNull1
#define wiauDbgLegacyTrace      wiauNull1
#define wiauDbgLegacyError2     wiauNull2h
#define wiauDbgLegacyTrace2     wiauNull2h
#define wiauDbgLegacyHresult2   wiauNullHHr

inline void wiauNull1(LPCSTR a, ...) {}
inline void wiauNull2(LPCSTR a, LPCSTR b,...) {}
inline void wiauNull2h(HINSTANCE hInstance, LPCSTR b,...) {}
inline void wiauNull3(LPCSTR a, LPCSTR b, LPCSTR c, ...) {}
inline void wiauNull3hr(HRESULT a, LPCSTR b, LPCSTR c, ...) {}
inline void wiauNull4(DWORD a, LPCSTR b, LPCSTR c, LPCSTR d, ...) {}
inline void wiauNullHHr(HINSTANCE hInstance, HRESULT hr) {}


#else // NO_WIA_DEBUG

extern DWORD  g_dwDebugFlags; 
extern HANDLE g_hDebugFile;
extern DWORD  g_dwDebugFileSizeLimit;
extern BOOL   g_bDebugInited;


/**************************************************************************\
* wiauDbgInit
*
*   Call to initialize WIA debugging. If it's not called, all DLLs will
*   inherit the debug flags of the process that creates them.
*
* Arguments:
*
*   hInstance - DLL instance handle
*
\**************************************************************************/

void __stdcall wiauDbgInit(HINSTANCE hInstance);
void __stdcall wiauDbgHelper(LPCSTR prefix, LPCSTR fname, LPCSTR fmt, va_list marker);
void __stdcall wiauDbgHelper2(LPCSTR prefix, LPCSTR fname, LPCSTR fmt, ...);

inline void __stdcall wiauDbgFlags(DWORD flags, LPCSTR prefix,
                                   LPCSTR fname, LPCSTR fmt, ...)
{
    va_list marker;

    //
    // See if log messages are enabled and the flag is enabled
    //
    if (((g_dwDebugFlags & WIAUDBG_DONT_LOG) ^ WIAUDBG_DONT_LOG) &&
        (g_dwDebugFlags & flags)) {

        va_start(marker, fmt);
        wiauDbgHelper(prefix, fname, fmt, marker);
        va_end(marker);
    }
}

inline void __stdcall wiauDbgError(LPCSTR fname, LPCSTR fmt, ...)
{
    va_list marker;

    //
    // See if log messages are enabled and error messages are turned on
    //
    if (((g_dwDebugFlags & WIAUDBG_DONT_LOG) ^ WIAUDBG_DONT_LOG) &&
        (g_dwDebugFlags & WIAUDBG_ERRORS)) {

        va_start(marker, fmt);
        wiauDbgHelper("ERROR ", fname, fmt, marker);
        va_end(marker);
    }

    if (g_dwDebugFlags & WIAUDBG_BREAK_ON_ERRORS) {
        DebugBreak();
    }
}

inline void __stdcall wiauDbgErrorHr(HRESULT hr, LPCSTR fname, LPCSTR fmt, ...)
{
    va_list marker;

    //
    // See if log messages are enabled and error messages are turned on
    //
    if (((g_dwDebugFlags & WIAUDBG_DONT_LOG) ^ WIAUDBG_DONT_LOG) &&
        (g_dwDebugFlags & WIAUDBG_ERRORS)) {

        va_start(marker, fmt);
        wiauDbgHelper("ERROR ", fname, fmt, marker);
        va_end(marker);

        CHAR szError[MAX_PATH]; \
        if(!FormatMessageA(WIAUDBG_MFMT_FLAGS, NULL, hr, 0, szError, MAX_PATH, NULL))
        {
            StringCchCopyA(szError, ARRAYSIZE(szError), "Unknown HRESULT");
        }
        wiauDbgHelper2("ERROR ", fname, "HRESULT = 0x%08x, %s", hr, szError);
    }

    if (g_dwDebugFlags & WIAUDBG_BREAK_ON_ERRORS) {
        DebugBreak();
    }
}

inline void __stdcall wiauDbgWarning(LPCSTR fname, LPCSTR fmt, ...)
{
    va_list marker;

    //
    // See if log messages are enabled and warning messages are turned on
    //
    if (((g_dwDebugFlags & WIAUDBG_DONT_LOG) ^ WIAUDBG_DONT_LOG) &&
        (g_dwDebugFlags & WIAUDBG_WARNINGS)) {

        va_start(marker, fmt);
        wiauDbgHelper("WARN  ", fname, fmt, marker);
        va_end(marker);
    }
}

inline void __stdcall wiauDbgTrace(LPCSTR fname, LPCSTR fmt, ...)
{
    va_list marker;

    //
    // See if log messages are enabled and trace messages are turned on
    //
    if (((g_dwDebugFlags & WIAUDBG_DONT_LOG) ^ WIAUDBG_DONT_LOG) &&
        (g_dwDebugFlags & WIAUDBG_TRACES)) {

        va_start(marker, fmt);
        wiauDbgHelper("      ", fname, fmt, marker);
        va_end(marker);
    }
}

inline void __stdcall wiauDbgDump(LPCSTR fname, LPCSTR fmt, ...)
{
    va_list marker;

    //
    // See if log messages are enabled and trace messages are turned on
    //
    if (((g_dwDebugFlags & WIAUDBG_DONT_LOG) ^ WIAUDBG_DONT_LOG) &&
        (g_dwDebugFlags & WIAUDBG_DUMP)) {

        va_start(marker, fmt);
        wiauDbgHelper("      ", fname, fmt, marker);
        va_end(marker);
    }
}

inline DWORD __stdcall wiauDbgSetFlags(DWORD flags)
{
    DWORD dwOld = g_dwDebugFlags;
    g_dwDebugFlags = flags;
    return dwOld;
}


inline void __stdcall wiauDbgLegacyError(LPCSTR fmt, ...)
{
    va_list marker;

    //
    // See if log messages are enabled and error messages are turned on
    //
    if (((g_dwDebugFlags & WIAUDBG_DONT_LOG) ^ WIAUDBG_DONT_LOG) &&
        (g_dwDebugFlags & WIAUDBG_ERRORS)) {

        va_start(marker, fmt);
        wiauDbgHelper("ERROR ", "", fmt, marker);
        va_end(marker);
    }

    if (g_dwDebugFlags & WIAUDBG_BREAK_ON_ERRORS) {
        DebugBreak();
    }
}

inline void __stdcall wiauDbgLegacyWarning(LPCSTR fmt, ...)
{
    va_list marker;

    //
    // See if log messages are enabled and warning messages are turned on
    //
    if (((g_dwDebugFlags & WIAUDBG_DONT_LOG) ^ WIAUDBG_DONT_LOG) &&
        (g_dwDebugFlags & WIAUDBG_WARNINGS)) {

        va_start(marker, fmt);
        wiauDbgHelper("WARN  ", "", fmt, marker);
        va_end(marker);
    }
}

inline void __stdcall wiauDbgLegacyTrace(LPCSTR fmt, ...)
{
    va_list marker;

    //
    // See if log messages are enabled and trace messages are turned on
    //
    if (((g_dwDebugFlags & WIAUDBG_DONT_LOG) ^ WIAUDBG_DONT_LOG) &&
        (g_dwDebugFlags & WIAUDBG_TRACES)) {

        va_start(marker, fmt);
        wiauDbgHelper("      ", "", fmt, marker);
        va_end(marker);
    }
}

inline void __stdcall wiauDbgLegacyError2(HINSTANCE hInstance, LPCSTR fmt, ...)
{
    va_list marker;

    //
    // See if log messages are enabled and error messages are turned on
    //
    if (((g_dwDebugFlags & WIAUDBG_DONT_LOG) ^ WIAUDBG_DONT_LOG) &&
        (g_dwDebugFlags & WIAUDBG_ERRORS)) {

        va_start(marker, fmt);
        wiauDbgHelper("ERROR ", "", fmt, marker);
        va_end(marker);
    }

    if (g_dwDebugFlags & WIAUDBG_BREAK_ON_ERRORS) {
        DebugBreak();
    }
}

inline void __stdcall wiauDbgLegacyTrace2(HINSTANCE hInstance, LPCSTR fmt, ...)
{
    va_list marker;

    //
    // See if log messages are enabled and trace messages are turned on
    //
    if (((g_dwDebugFlags & WIAUDBG_DONT_LOG) ^ WIAUDBG_DONT_LOG) &&
        (g_dwDebugFlags & WIAUDBG_TRACES)) {

        va_start(marker, fmt);
        wiauDbgHelper("      ", "", fmt, marker);
        va_end(marker);
    }
}

inline void __stdcall wiauDbgLegacyHresult2(HINSTANCE hInstance, HRESULT hr)
{
    wiauDbgErrorHr(hr, "", "");
}

#endif // NO_WIA_DEBUG


//
// Macros for mapping the old WIA logging to the new system
//
#ifdef WIA_MAP_OLD_DEBUG

#define CWiaLogProc
#define WIAS_LOGPROC(x, y, z, fname) CWiauDbgFn __CWiauDbgFnObject(fname)
#define WIAS_LERROR(x,y,params) wiauDbgLegacyError ## params
#define WIAS_LWARNING(x,y,params) wiauDbgLegacyWarning ## params
#define WIAS_LTRACE(x,y,z,params) wiauDbgLegacyTrace ## params
#define WIAS_LHRESULT(x,y) wiauDbgErrorHr(y, "", "")

#define WIAS_TRACE(x) wiauDbgLegacyTrace2 ## x
#define WIAS_ERROR(x) wiauDbgLegacyError2 ## x
#define WIAS_HRESULT(x) wiauDbgLegacyHresult2 ## x
#define WIAS_ASSERT(x, y) \
        if (!(y)) { \
            WIAS_ERROR((x, (char*) TEXT("ASSERTION FAILED: %hs(%d): %hs"), __FILE__,__LINE__,#x)); \
            DebugBreak(); \
        }
        
#endif // WIA_MAP_OLD_DEBUG


//
// Macros for checking return values and common error conditions
//

#define REQUIRE_SUCCESS(hr, fname, msg) \
    if (FAILED(hr)) { \
        if (g_dwDebugFlags & WIAUDBG_PRINT_INFO) { \
            DWORD threadId = GetCurrentThreadId(); \
            wiauDbgError(fname, "[%s(%d): Thread 0x%X (%d)]", __FILE__, __LINE__, threadId, threadId); \
        } \
        wiauDbgErrorHr(hr, fname, msg); \
        goto Cleanup; \
    }

#define REQUIRE_OK(hr, fname, msg) \
    if ((hr) != S_OK) { \
        if (g_dwDebugFlags & WIAUDBG_PRINT_INFO) { \
            DWORD threadId = GetCurrentThreadId(); \
            wiauDbgError(fname, "[%s(%d): Thread 0x%X (%d)]", __FILE__, __LINE__, threadId, threadId); \
        } \
        wiauDbgErrorHr(hr, fname, msg); \
        goto Cleanup; \
    }

#define REQUIRE_ARGS(args, hr, fname) \
    if (args) { \
        if (g_dwDebugFlags & WIAUDBG_PRINT_INFO) { \
            DWORD threadId = GetCurrentThreadId(); \
            wiauDbgError(fname, "[%s(%d): Thread 0x%X (%d)]", __FILE__, __LINE__, threadId, threadId); \
        } \
        wiauDbgError(fname, "Invalid arg"); \
        hr = E_INVALIDARG; \
        goto Cleanup; \
    }

#define REQUIRE_ALLOC(var, hr, fname) \
    if (!(var)) { \
        if (g_dwDebugFlags & WIAUDBG_PRINT_INFO) { \
            DWORD threadId = GetCurrentThreadId(); \
            wiauDbgError(fname, "[%s(%d): Thread 0x%X (%d)]", __FILE__, __LINE__, threadId, threadId); \
        } \
        wiauDbgError(fname, "Memory allocation failed on " #var); \
        hr = E_OUTOFMEMORY; \
        goto Cleanup; \
    }

#define REQUIRE_FILEHANDLE(handle, hr, fname, msg) \
    if ((handle) == NULL || (handle) == INVALID_HANDLE_VALUE) { \
        hr = HRESULT_FROM_WIN32(::GetLastError()); \
        if (g_dwDebugFlags & WIAUDBG_PRINT_INFO) { \
            DWORD threadId = GetCurrentThreadId(); \
            wiauDbgError(fname, "[%s(%d): Thread 0x%X (%d)]", __FILE__, __LINE__, threadId, threadId); \
        } \
        wiauDbgErrorHr(hr, fname, msg); \
        goto Cleanup; \
    }

#define REQUIRE_FILEIO(ret, hr, fname, msg) \
    if (!(ret)) { \
        hr = HRESULT_FROM_WIN32(::GetLastError()); \
        if (g_dwDebugFlags & WIAUDBG_PRINT_INFO) { \
            DWORD threadId = GetCurrentThreadId(); \
            wiauDbgError(fname, "[%s(%d): Thread 0x%X (%d)]", __FILE__, __LINE__, threadId, threadId); \
        } \
        wiauDbgErrorHr(hr, fname, msg); \
        goto Cleanup; \
    }

#define REQUIRE_WIN32(err, hr, fname, msg) \
    if ((err) != ERROR_SUCCESS) { \
        hr = HRESULT_FROM_WIN32(err); \
        if (g_dwDebugFlags & WIAUDBG_PRINT_INFO) { \
            DWORD threadId = GetCurrentThreadId(); \
            wiauDbgError(fname, "[%s(%d): Thread 0x%X (%d)]", __FILE__, __LINE__, threadId, threadId); \
        } \
        wiauDbgErrorHr(hr, fname, msg); \
        goto Cleanup; \
    }


//
// Macro and class for entry/exit point tracing
//

#ifdef __cplusplus

#ifdef NO_WIA_DEBUG

#define DBG_FN(fname)

#else // NO_WIA_DEBUG

#define DBG_FN(fname) CWiauDbgFn __CWiauDbgFnObject(fname)

class CWiauDbgFn {
public:

    CWiauDbgFn(LPCSTR fname)
    { 
        m_fname = fname;
        m_threadId = GetCurrentThreadId();
        wiauDbgFlags(WIAUDBG_FNS, "      ", m_fname, "Entering, thread 0x%x (%d)",
                     m_threadId, m_threadId);

    } 
    
    ~CWiauDbgFn() 
    { 
        wiauDbgFlags(WIAUDBG_FNS, "      ", m_fname, "Exiting, thread 0x%x (%d)",
                     m_threadId, m_threadId);
    }

private:
    LPCSTR m_fname;
    DWORD  m_threadId;
};
#endif // NO_WIA_DEBUG

}

#else // __cplusplus

#define DBG_FN(fname) wiauDbgFlags(WIAUDBG_FNS, "      ", fname, "Entering");
#endif // __cplusplus

#endif //#if (_WIN32_WINNT >= 0x0501)
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\win2k8\ddk\inc\wiatwcmp.h ===
/****************************************************************************
*
*  (C) COPYRIGHT 1998-2001, MICROSOFT CORP.
*
*  FILE:        wiatwcmp.h
*
*  VERSION:     1.0
*
*  DATE:        6/01/2001
*
*  DESCRIPTION:
*    Defines TWAIN Compatibility Layer - Capability pass-through constants.
*    To support existing TWAIN applications that have private capabilities,
*    WIA drivers can utilize the Pass-through functionality.
*
*****************************************************************************/

#if (_WIN32_WINNT >= 0x0501) // Windows XP and later

#ifndef _WIATWCMP_H_
#define _WIATWCMP_H_

#define WiaItemTypeTwainCapabilityPassThrough   0x00020000

//**************************************************************************
//
// TWAIN capability pass-through
//
//**************************************************************************

//
// Escape code ranges 2001 - 3000 are reserved for future ESC_ commands
//

#define ESC_TWAIN_CAPABILITY                2001    // private TWAIN capability negotiation
#define ESC_TWAIN_PRIVATE_SUPPORTED_CAPS    2002    // query for supported private capabilities

typedef struct _TWAIN_CAPABILITY {
    LONG  lSize;    // size of TWAIN_CAPABILITY structure
    LONG  lMSG;     // TWAIN Message, MSG_GET, MSG_GETCURRENT, MSG_SET, etc..
    LONG  lCapID;   // id of capability to set or get
    LONG  lConType; // container type of capability
    LONG  lRC;      // TWAIN return code, TWRC_SUCCESS, TWRC_FAILURE, etc..
    LONG  lCC;      // TWAIN condition code, TWCC_SUCCESS, TWCC_BUMMER, etc..
    LONG  lDataSize;// data size
    BYTE  Data[1];  // first BYTE of data
}TWAIN_CAPABILITY,*PTWAIN_CAPABILITY;

#endif

#endif //#if (_WIN32_WINNT >= 0x0501)
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\win2k8\ddk\inc\wiamindr_xp.h ===
/* this ALWAYS GENERATED file contains the definitions for the interfaces */


 /* File created by MIDL compiler version 7.00.0499 */
/* Compiler settings for wiamindr_xp.idl:
    Oicf, W1, Zp8, env=Win32 (32b run)
    protocol : dce , ms_ext, c_ext, robust
    error checks: allocation ref bounds_check enum stub_data 
    VC __declspec() decoration level: 
         __declspec(uuid()), __declspec(selectany), __declspec(novtable)
         DECLSPEC_UUID(), MIDL_INTERFACE()
*/
//@@MIDL_FILE_HEADING(  )

#pragma warning( disable: 4049 )  /* more than 64k source lines */


/* verify that the <rpcndr.h> version is high enough to compile this file*/
#ifndef __REQUIRED_RPCNDR_H_VERSION__
#define __REQUIRED_RPCNDR_H_VERSION__ 500
#endif

/* verify that the <rpcsal.h> version is high enough to compile this file*/
#ifndef __REQUIRED_RPCSAL_H_VERSION__
#define __REQUIRED_RPCSAL_H_VERSION__ 100
#endif

#include "rpc.h"
#include "rpcndr.h"

#ifndef __RPCNDR_H_VERSION__
#error this stub requires an updated version of <rpcndr.h>
#endif // __RPCNDR_H_VERSION__

#ifndef COM_NO_WINDOWS_H
#include "windows.h"
#include "ole2.h"
#endif /*COM_NO_WINDOWS_H*/

#ifndef __wiamindr_xp_h__
#define __wiamindr_xp_h__

#if defined(_MSC_VER) && (_MSC_VER >= 1020)
#pragma once
#endif

/* Forward Declarations */ 

#ifndef __IWiaMiniDrv_FWD_DEFINED__
#define __IWiaMiniDrv_FWD_DEFINED__
typedef interface IWiaMiniDrv IWiaMiniDrv;
#endif 	/* __IWiaMiniDrv_FWD_DEFINED__ */


#ifndef __IWiaMiniDrvCallBack_FWD_DEFINED__
#define __IWiaMiniDrvCallBack_FWD_DEFINED__
typedef interface IWiaMiniDrvCallBack IWiaMiniDrvCallBack;
#endif 	/* __IWiaMiniDrvCallBack_FWD_DEFINED__ */


#ifndef __IWiaDrvItem_FWD_DEFINED__
#define __IWiaDrvItem_FWD_DEFINED__
typedef interface IWiaDrvItem IWiaDrvItem;
#endif 	/* __IWiaDrvItem_FWD_DEFINED__ */


/* header files for imported files */
#include "unknwn.h"
#include "oaidl.h"
#include "propidl.h"
#include "wia_xp.h"

#ifdef __cplusplus
extern "C"{
#endif 


/* interface __MIDL_itf_wiamindr_xp_0000_0000 */
/* [local] */ 






typedef struct _MINIDRV_TRANSFER_CONTEXT
    {
    LONG lSize;
    LONG lWidthInPixels;
    LONG lLines;
    LONG lDepth;
    LONG lXRes;
    LONG lYRes;
    LONG lCompression;
    GUID guidFormatID;
    LONG tymed;
    LONG_PTR hFile;
    LONG cbOffset;
    LONG lBufferSize;
    LONG lActiveBuffer;
    LONG lNumBuffers;
    BYTE *pBaseBuffer;
    BYTE *pTransferBuffer;
    BOOL bTransferDataCB;
    BOOL bClassDrvAllocBuf;
    LONG_PTR lClientAddress;
    IWiaMiniDrvCallBack *pIWiaMiniDrvCallBack;
    LONG lImageSize;
    LONG lHeaderSize;
    LONG lItemSize;
    LONG cbWidthInBytes;
    LONG lPage;
    LONG lCurIfdOffset;
    LONG lPrevIfdOffset;
    } 	MINIDRV_TRANSFER_CONTEXT;

typedef struct _MINIDRV_TRANSFER_CONTEXT *PMINIDRV_TRANSFER_CONTEXT;

typedef struct _WIA_DEV_CAP_DRV
    {
    GUID *guid;
    ULONG ulFlags;
    LPOLESTR wszName;
    LPOLESTR wszDescription;
    LPOLESTR wszIcon;
    } 	WIA_DEV_CAP_DRV;

typedef struct _WIA_DEV_CAP_DRV *PWIA_DEV_CAP_DRV;



extern RPC_IF_HANDLE __MIDL_itf_wiamindr_xp_0000_0000_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_wiamindr_xp_0000_0000_v0_0_s_ifspec;

#ifndef __IWiaMiniDrv_INTERFACE_DEFINED__
#define __IWiaMiniDrv_INTERFACE_DEFINED__

/* interface IWiaMiniDrv */
/* [unique][helpstring][uuid][object] */ 


EXTERN_C const IID IID_IWiaMiniDrv;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("d8cdee14-3c6c-11d2-9a35-00c04fa36145")
    IWiaMiniDrv : public IUnknown
    {
    public:
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE drvInitializeWia( 
            /* [in] */ __RPC__in BYTE *__MIDL__IWiaMiniDrv0000,
            /* [in] */ LONG __MIDL__IWiaMiniDrv0001,
            /* [in] */ __RPC__in BSTR __MIDL__IWiaMiniDrv0002,
            /* [in] */ __RPC__in BSTR __MIDL__IWiaMiniDrv0003,
            /* [in] */ __RPC__in_opt IUnknown *__MIDL__IWiaMiniDrv0004,
            /* [in] */ __RPC__in_opt IUnknown *__MIDL__IWiaMiniDrv0005,
            /* [out] */ __RPC__deref_out_opt IWiaDrvItem **__MIDL__IWiaMiniDrv0006,
            /* [out] */ __RPC__deref_out_opt IUnknown **__MIDL__IWiaMiniDrv0007,
            /* [out] */ __RPC__out LONG *__MIDL__IWiaMiniDrv0008) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE drvAcquireItemData( 
            /* [in] */ __RPC__in BYTE *__MIDL__IWiaMiniDrv0009,
            /* [in] */ LONG __MIDL__IWiaMiniDrv0010,
            /* [out][in] */ __RPC__inout PMINIDRV_TRANSFER_CONTEXT __MIDL__IWiaMiniDrv0011,
            /* [out] */ __RPC__out LONG *__MIDL__IWiaMiniDrv0012) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE drvInitItemProperties( 
            /* [in] */ __RPC__in BYTE *__MIDL__IWiaMiniDrv0013,
            /* [in] */ LONG __MIDL__IWiaMiniDrv0014,
            /* [out] */ __RPC__out LONG *__MIDL__IWiaMiniDrv0015) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE drvValidateItemProperties( 
            /* [in] */ __RPC__in BYTE *__MIDL__IWiaMiniDrv0016,
            /* [in] */ LONG __MIDL__IWiaMiniDrv0017,
            /* [in] */ ULONG __MIDL__IWiaMiniDrv0018,
            /* [in] */ __RPC__in const PROPSPEC *__MIDL__IWiaMiniDrv0019,
            /* [out] */ __RPC__out LONG *__MIDL__IWiaMiniDrv0020) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE drvWriteItemProperties( 
            /* [in] */ __RPC__in BYTE *__MIDL__IWiaMiniDrv0021,
            /* [in] */ LONG __MIDL__IWiaMiniDrv0022,
            /* [in] */ __RPC__in PMINIDRV_TRANSFER_CONTEXT __MIDL__IWiaMiniDrv0023,
            /* [out] */ __RPC__out LONG *__MIDL__IWiaMiniDrv0024) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE drvReadItemProperties( 
            /* [in] */ __RPC__in BYTE *__MIDL__IWiaMiniDrv0025,
            /* [in] */ LONG __MIDL__IWiaMiniDrv0026,
            /* [in] */ ULONG __MIDL__IWiaMiniDrv0027,
            /* [in] */ __RPC__in const PROPSPEC *__MIDL__IWiaMiniDrv0028,
            /* [out] */ __RPC__out LONG *__MIDL__IWiaMiniDrv0029) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE drvLockWiaDevice( 
            /* [in] */ __RPC__in BYTE *__MIDL__IWiaMiniDrv0030,
            /* [in] */ LONG __MIDL__IWiaMiniDrv0031,
            /* [out] */ __RPC__out LONG *__MIDL__IWiaMiniDrv0032) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE drvUnLockWiaDevice( 
            /* [in] */ __RPC__in BYTE *__MIDL__IWiaMiniDrv0033,
            /* [in] */ LONG __MIDL__IWiaMiniDrv0034,
            /* [out] */ __RPC__out LONG *__MIDL__IWiaMiniDrv0035) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE drvAnalyzeItem( 
            /* [in] */ __RPC__in BYTE *__MIDL__IWiaMiniDrv0036,
            /* [in] */ LONG __MIDL__IWiaMiniDrv0037,
            /* [in] */ __RPC__in LONG *__MIDL__IWiaMiniDrv0038) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE drvGetDeviceErrorStr( 
            /* [in] */ LONG __MIDL__IWiaMiniDrv0039,
            /* [in] */ LONG __MIDL__IWiaMiniDrv0040,
            /* [out] */ __RPC__deref_out_opt LPOLESTR *__MIDL__IWiaMiniDrv0041,
            /* [out] */ __RPC__out LONG *__MIDL__IWiaMiniDrv0042) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE drvDeviceCommand( 
            /* [in] */ __RPC__in BYTE *__MIDL__IWiaMiniDrv0043,
            /* [in] */ LONG __MIDL__IWiaMiniDrv0044,
            /* [in] */ __RPC__in const GUID *__MIDL__IWiaMiniDrv0045,
            /* [out] */ __RPC__deref_out_opt IWiaDrvItem **__MIDL__IWiaMiniDrv0046,
            /* [out] */ __RPC__out LONG *__MIDL__IWiaMiniDrv0047) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE drvGetCapabilities( 
            /* [in] */ __RPC__in BYTE *__MIDL__IWiaMiniDrv0048,
            /* [in] */ LONG __MIDL__IWiaMiniDrv0049,
            /* [out] */ __RPC__out LONG *__MIDL__IWiaMiniDrv0050,
            /* [out] */ __RPC__deref_out_opt WIA_DEV_CAP_DRV **__MIDL__IWiaMiniDrv0051,
            /* [out] */ __RPC__out LONG *__MIDL__IWiaMiniDrv0052) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE drvDeleteItem( 
            /* [in] */ __RPC__in BYTE *__MIDL__IWiaMiniDrv0053,
            /* [in] */ LONG __MIDL__IWiaMiniDrv0054,
            /* [out] */ __RPC__out LONG *__MIDL__IWiaMiniDrv0055) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE drvFreeDrvItemContext( 
            /* [in] */ LONG __MIDL__IWiaMiniDrv0056,
            /* [in] */ __RPC__in BYTE *__MIDL__IWiaMiniDrv0057,
            /* [out] */ __RPC__out LONG *__MIDL__IWiaMiniDrv0058) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE drvGetWiaFormatInfo( 
            /* [in] */ __RPC__in BYTE *__MIDL__IWiaMiniDrv0059,
            /* [in] */ LONG __MIDL__IWiaMiniDrv0060,
            /* [out] */ __RPC__out LONG *__MIDL__IWiaMiniDrv0061,
            /* [out] */ __RPC__deref_out_opt WIA_FORMAT_INFO **__MIDL__IWiaMiniDrv0062,
            /* [out] */ __RPC__out LONG *__MIDL__IWiaMiniDrv0063) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE drvNotifyPnpEvent( 
            /* [in] */ __RPC__in const GUID *pEventGUID,
            /* [in] */ __RPC__in BSTR bstrDeviceID,
            /* [in] */ ULONG ulReserved) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE drvUnInitializeWia( 
            /* [in] */ __RPC__in BYTE *__MIDL__IWiaMiniDrv0064) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IWiaMiniDrvVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IWiaMiniDrv * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IWiaMiniDrv * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IWiaMiniDrv * This);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *drvInitializeWia )( 
            IWiaMiniDrv * This,
            /* [in] */ __RPC__in BYTE *__MIDL__IWiaMiniDrv0000,
            /* [in] */ LONG __MIDL__IWiaMiniDrv0001,
            /* [in] */ __RPC__in BSTR __MIDL__IWiaMiniDrv0002,
            /* [in] */ __RPC__in BSTR __MIDL__IWiaMiniDrv0003,
            /* [in] */ __RPC__in_opt IUnknown *__MIDL__IWiaMiniDrv0004,
            /* [in] */ __RPC__in_opt IUnknown *__MIDL__IWiaMiniDrv0005,
            /* [out] */ __RPC__deref_out_opt IWiaDrvItem **__MIDL__IWiaMiniDrv0006,
            /* [out] */ __RPC__deref_out_opt IUnknown **__MIDL__IWiaMiniDrv0007,
            /* [out] */ __RPC__out LONG *__MIDL__IWiaMiniDrv0008);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *drvAcquireItemData )( 
            IWiaMiniDrv * This,
            /* [in] */ __RPC__in BYTE *__MIDL__IWiaMiniDrv0009,
            /* [in] */ LONG __MIDL__IWiaMiniDrv0010,
            /* [out][in] */ __RPC__inout PMINIDRV_TRANSFER_CONTEXT __MIDL__IWiaMiniDrv0011,
            /* [out] */ __RPC__out LONG *__MIDL__IWiaMiniDrv0012);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *drvInitItemProperties )( 
            IWiaMiniDrv * This,
            /* [in] */ __RPC__in BYTE *__MIDL__IWiaMiniDrv0013,
            /* [in] */ LONG __MIDL__IWiaMiniDrv0014,
            /* [out] */ __RPC__out LONG *__MIDL__IWiaMiniDrv0015);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *drvValidateItemProperties )( 
            IWiaMiniDrv * This,
            /* [in] */ __RPC__in BYTE *__MIDL__IWiaMiniDrv0016,
            /* [in] */ LONG __MIDL__IWiaMiniDrv0017,
            /* [in] */ ULONG __MIDL__IWiaMiniDrv0018,
            /* [in] */ __RPC__in const PROPSPEC *__MIDL__IWiaMiniDrv0019,
            /* [out] */ __RPC__out LONG *__MIDL__IWiaMiniDrv0020);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *drvWriteItemProperties )( 
            IWiaMiniDrv * This,
            /* [in] */ __RPC__in BYTE *__MIDL__IWiaMiniDrv0021,
            /* [in] */ LONG __MIDL__IWiaMiniDrv0022,
            /* [in] */ __RPC__in PMINIDRV_TRANSFER_CONTEXT __MIDL__IWiaMiniDrv0023,
            /* [out] */ __RPC__out LONG *__MIDL__IWiaMiniDrv0024);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *drvReadItemProperties )( 
            IWiaMiniDrv * This,
            /* [in] */ __RPC__in BYTE *__MIDL__IWiaMiniDrv0025,
            /* [in] */ LONG __MIDL__IWiaMiniDrv0026,
            /* [in] */ ULONG __MIDL__IWiaMiniDrv0027,
            /* [in] */ __RPC__in const PROPSPEC *__MIDL__IWiaMiniDrv0028,
            /* [out] */ __RPC__out LONG *__MIDL__IWiaMiniDrv0029);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *drvLockWiaDevice )( 
            IWiaMiniDrv * This,
            /* [in] */ __RPC__in BYTE *__MIDL__IWiaMiniDrv0030,
            /* [in] */ LONG __MIDL__IWiaMiniDrv0031,
            /* [out] */ __RPC__out LONG *__MIDL__IWiaMiniDrv0032);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *drvUnLockWiaDevice )( 
            IWiaMiniDrv * This,
            /* [in] */ __RPC__in BYTE *__MIDL__IWiaMiniDrv0033,
            /* [in] */ LONG __MIDL__IWiaMiniDrv0034,
            /* [out] */ __RPC__out LONG *__MIDL__IWiaMiniDrv0035);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *drvAnalyzeItem )( 
            IWiaMiniDrv * This,
            /* [in] */ __RPC__in BYTE *__MIDL__IWiaMiniDrv0036,
            /* [in] */ LONG __MIDL__IWiaMiniDrv0037,
            /* [in] */ __RPC__in LONG *__MIDL__IWiaMiniDrv0038);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *drvGetDeviceErrorStr )( 
            IWiaMiniDrv * This,
            /* [in] */ LONG __MIDL__IWiaMiniDrv0039,
            /* [in] */ LONG __MIDL__IWiaMiniDrv0040,
            /* [out] */ __RPC__deref_out_opt LPOLESTR *__MIDL__IWiaMiniDrv0041,
            /* [out] */ __RPC__out LONG *__MIDL__IWiaMiniDrv0042);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *drvDeviceCommand )( 
            IWiaMiniDrv * This,
            /* [in] */ __RPC__in BYTE *__MIDL__IWiaMiniDrv0043,
            /* [in] */ LONG __MIDL__IWiaMiniDrv0044,
            /* [in] */ __RPC__in const GUID *__MIDL__IWiaMiniDrv0045,
            /* [out] */ __RPC__deref_out_opt IWiaDrvItem **__MIDL__IWiaMiniDrv0046,
            /* [out] */ __RPC__out LONG *__MIDL__IWiaMiniDrv0047);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *drvGetCapabilities )( 
            IWiaMiniDrv * This,
            /* [in] */ __RPC__in BYTE *__MIDL__IWiaMiniDrv0048,
            /* [in] */ LONG __MIDL__IWiaMiniDrv0049,
            /* [out] */ __RPC__out LONG *__MIDL__IWiaMiniDrv0050,
            /* [out] */ __RPC__deref_out_opt WIA_DEV_CAP_DRV **__MIDL__IWiaMiniDrv0051,
            /* [out] */ __RPC__out LONG *__MIDL__IWiaMiniDrv0052);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *drvDeleteItem )( 
            IWiaMiniDrv * This,
            /* [in] */ __RPC__in BYTE *__MIDL__IWiaMiniDrv0053,
            /* [in] */ LONG __MIDL__IWiaMiniDrv0054,
            /* [out] */ __RPC__out LONG *__MIDL__IWiaMiniDrv0055);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *drvFreeDrvItemContext )( 
            IWiaMiniDrv * This,
            /* [in] */ LONG __MIDL__IWiaMiniDrv0056,
            /* [in] */ __RPC__in BYTE *__MIDL__IWiaMiniDrv0057,
            /* [out] */ __RPC__out LONG *__MIDL__IWiaMiniDrv0058);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *drvGetWiaFormatInfo )( 
            IWiaMiniDrv * This,
            /* [in] */ __RPC__in BYTE *__MIDL__IWiaMiniDrv0059,
            /* [in] */ LONG __MIDL__IWiaMiniDrv0060,
            /* [out] */ __RPC__out LONG *__MIDL__IWiaMiniDrv0061,
            /* [out] */ __RPC__deref_out_opt WIA_FORMAT_INFO **__MIDL__IWiaMiniDrv0062,
            /* [out] */ __RPC__out LONG *__MIDL__IWiaMiniDrv0063);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *drvNotifyPnpEvent )( 
            IWiaMiniDrv * This,
            /* [in] */ __RPC__in const GUID *pEventGUID,
            /* [in] */ __RPC__in BSTR bstrDeviceID,
            /* [in] */ ULONG ulReserved);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *drvUnInitializeWia )( 
            IWiaMiniDrv * This,
            /* [in] */ __RPC__in BYTE *__MIDL__IWiaMiniDrv0064);
        
        END_INTERFACE
    } IWiaMiniDrvVtbl;

    interface IWiaMiniDrv
    {
        CONST_VTBL struct IWiaMiniDrvVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IWiaMiniDrv_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IWiaMiniDrv_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IWiaMiniDrv_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IWiaMiniDrv_drvInitializeWia(This,__MIDL__IWiaMiniDrv0000,__MIDL__IWiaMiniDrv0001,__MIDL__IWiaMiniDrv0002,__MIDL__IWiaMiniDrv0003,__MIDL__IWiaMiniDrv0004,__MIDL__IWiaMiniDrv0005,__MIDL__IWiaMiniDrv0006,__MIDL__IWiaMiniDrv0007,__MIDL__IWiaMiniDrv0008)	\
    ( (This)->lpVtbl -> drvInitializeWia(This,__MIDL__IWiaMiniDrv0000,__MIDL__IWiaMiniDrv0001,__MIDL__IWiaMiniDrv0002,__MIDL__IWiaMiniDrv0003,__MIDL__IWiaMiniDrv0004,__MIDL__IWiaMiniDrv0005,__MIDL__IWiaMiniDrv0006,__MIDL__IWiaMiniDrv0007,__MIDL__IWiaMiniDrv0008) ) 

#define IWiaMiniDrv_drvAcquireItemData(This,__MIDL__IWiaMiniDrv0009,__MIDL__IWiaMiniDrv0010,__MIDL__IWiaMiniDrv0011,__MIDL__IWiaMiniDrv0012)	\
    ( (This)->lpVtbl -> drvAcquireItemData(This,__MIDL__IWiaMiniDrv0009,__MIDL__IWiaMiniDrv0010,__MIDL__IWiaMiniDrv0011,__MIDL__IWiaMiniDrv0012) ) 

#define IWiaMiniDrv_drvInitItemProperties(This,__MIDL__IWiaMiniDrv0013,__MIDL__IWiaMiniDrv0014,__MIDL__IWiaMiniDrv0015)	\
    ( (This)->lpVtbl -> drvInitItemProperties(This,__MIDL__IWiaMiniDrv0013,__MIDL__IWiaMiniDrv0014,__MIDL__IWiaMiniDrv0015) ) 

#define IWiaMiniDrv_drvValidateItemProperties(This,__MIDL__IWiaMiniDrv0016,__MIDL__IWiaMiniDrv0017,__MIDL__IWiaMiniDrv0018,__MIDL__IWiaMiniDrv0019,__MIDL__IWiaMiniDrv0020)	\
    ( (This)->lpVtbl -> drvValidateItemProperties(This,__MIDL__IWiaMiniDrv0016,__MIDL__IWiaMiniDrv0017,__MIDL__IWiaMiniDrv0018,__MIDL__IWiaMiniDrv0019,__MIDL__IWiaMiniDrv0020) ) 

#define IWiaMiniDrv_drvWriteItemProperties(This,__MIDL__IWiaMiniDrv0021,__MIDL__IWiaMiniDrv0022,__MIDL__IWiaMiniDrv0023,__MIDL__IWiaMiniDrv0024)	\
    ( (This)->lpVtbl -> drvWriteItemProperties(This,__MIDL__IWiaMiniDrv0021,__MIDL__IWiaMiniDrv0022,__MIDL__IWiaMiniDrv0023,__MIDL__IWiaMiniDrv0024) ) 

#define IWiaMiniDrv_drvReadItemProperties(This,__MIDL__IWiaMiniDrv0025,__MIDL__IWiaMiniDrv0026,__MIDL__IWiaMiniDrv0027,__MIDL__IWiaMiniDrv0028,__MIDL__IWiaMiniDrv0029)	\
    ( (This)->lpVtbl -> drvReadItemProperties(This,__MIDL__IWiaMiniDrv0025,__MIDL__IWiaMiniDrv0026,__MIDL__IWiaMiniDrv0027,__MIDL__IWiaMiniDrv0028,__MIDL__IWiaMiniDrv0029) ) 

#define IWiaMiniDrv_drvLockWiaDevice(This,__MIDL__IWiaMiniDrv0030,__MIDL__IWiaMiniDrv0031,__MIDL__IWiaMiniDrv0032)	\
    ( (This)->lpVtbl -> drvLockWiaDevice(This,__MIDL__IWiaMiniDrv0030,__MIDL__IWiaMiniDrv0031,__MIDL__IWiaMiniDrv0032) ) 

#define IWiaMiniDrv_drvUnLockWiaDevice(This,__MIDL__IWiaMiniDrv0033,__MIDL__IWiaMiniDrv0034,__MIDL__IWiaMiniDrv0035)	\
    ( (This)->lpVtbl -> drvUnLockWiaDevice(This,__MIDL__IWiaMiniDrv0033,__MIDL__IWiaMiniDrv0034,__MIDL__IWiaMiniDrv0035) ) 

#define IWiaMiniDrv_drvAnalyzeItem(This,__MIDL__IWiaMiniDrv0036,__MIDL__IWiaMiniDrv0037,__MIDL__IWiaMiniDrv0038)	\
    ( (This)->lpVtbl -> drvAnalyzeItem(This,__MIDL__IWiaMiniDrv0036,__MIDL__IWiaMiniDrv0037,__MIDL__IWiaMiniDrv0038) ) 

#define IWiaMiniDrv_drvGetDeviceErrorStr(This,__MIDL__IWiaMiniDrv0039,__MIDL__IWiaMiniDrv0040,__MIDL__IWiaMiniDrv0041,__MIDL__IWiaMiniDrv0042)	\
    ( (This)->lpVtbl -> drvGetDeviceErrorStr(This,__MIDL__IWiaMiniDrv0039,__MIDL__IWiaMiniDrv0040,__MIDL__IWiaMiniDrv0041,__MIDL__IWiaMiniDrv0042) ) 

#define IWiaMiniDrv_drvDeviceCommand(This,__MIDL__IWiaMiniDrv0043,__MIDL__IWiaMiniDrv0044,__MIDL__IWiaMiniDrv0045,__MIDL__IWiaMiniDrv0046,__MIDL__IWiaMiniDrv0047)	\
    ( (This)->lpVtbl -> drvDeviceCommand(This,__MIDL__IWiaMiniDrv0043,__MIDL__IWiaMiniDrv0044,__MIDL__IWiaMiniDrv0045,__MIDL__IWiaMiniDrv0046,__MIDL__IWiaMiniDrv0047) ) 

#define IWiaMiniDrv_drvGetCapabilities(This,__MIDL__IWiaMiniDrv0048,__MIDL__IWiaMiniDrv0049,__MIDL__IWiaMiniDrv0050,__MIDL__IWiaMiniDrv0051,__MIDL__IWiaMiniDrv0052)	\
    ( (This)->lpVtbl -> drvGetCapabilities(This,__MIDL__IWiaMiniDrv0048,__MIDL__IWiaMiniDrv0049,__MIDL__IWiaMiniDrv0050,__MIDL__IWiaMiniDrv0051,__MIDL__IWiaMiniDrv0052) ) 

#define IWiaMiniDrv_drvDeleteItem(This,__MIDL__IWiaMiniDrv0053,__MIDL__IWiaMiniDrv0054,__MIDL__IWiaMiniDrv0055)	\
    ( (This)->lpVtbl -> drvDeleteItem(This,__MIDL__IWiaMiniDrv0053,__MIDL__IWiaMiniDrv0054,__MIDL__IWiaMiniDrv0055) ) 

#define IWiaMiniDrv_drvFreeDrvItemContext(This,__MIDL__IWiaMiniDrv0056,__MIDL__IWiaMiniDrv0057,__MIDL__IWiaMiniDrv0058)	\
    ( (This)->lpVtbl -> drvFreeDrvItemContext(This,__MIDL__IWiaMiniDrv0056,__MIDL__IWiaMiniDrv0057,__MIDL__IWiaMiniDrv0058) ) 

#define IWiaMiniDrv_drvGetWiaFormatInfo(This,__MIDL__IWiaMiniDrv0059,__MIDL__IWiaMiniDrv0060,__MIDL__IWiaMiniDrv0061,__MIDL__IWiaMiniDrv0062,__MIDL__IWiaMiniDrv0063)	\
    ( (This)->lpVtbl -> drvGetWiaFormatInfo(This,__MIDL__IWiaMiniDrv0059,__MIDL__IWiaMiniDrv0060,__MIDL__IWiaMiniDrv0061,__MIDL__IWiaMiniDrv0062,__MIDL__IWiaMiniDrv0063) ) 

#define IWiaMiniDrv_drvNotifyPnpEvent(This,pEventGUID,bstrDeviceID,ulReserved)	\
    ( (This)->lpVtbl -> drvNotifyPnpEvent(This,pEventGUID,bstrDeviceID,ulReserved) ) 

#define IWiaMiniDrv_drvUnInitializeWia(This,__MIDL__IWiaMiniDrv0064)	\
    ( (This)->lpVtbl -> drvUnInitializeWia(This,__MIDL__IWiaMiniDrv0064) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IWiaMiniDrv_INTERFACE_DEFINED__ */


#ifndef __IWiaMiniDrvCallBack_INTERFACE_DEFINED__
#define __IWiaMiniDrvCallBack_INTERFACE_DEFINED__

/* interface IWiaMiniDrvCallBack */
/* [unique][helpstring][uuid][object] */ 


EXTERN_C const IID IID_IWiaMiniDrvCallBack;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("33a57d5a-3de8-11d2-9a36-00c04fa36145")
    IWiaMiniDrvCallBack : public IUnknown
    {
    public:
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE MiniDrvCallback( 
            /* [in] */ LONG lReason,
            /* [in] */ LONG lStatus,
            /* [in] */ LONG lPercentComplete,
            /* [in] */ LONG lOffset,
            /* [in] */ LONG lLength,
            /* [in] */ __RPC__in PMINIDRV_TRANSFER_CONTEXT pTranCtx,
            /* [in] */ LONG lReserved) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IWiaMiniDrvCallBackVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IWiaMiniDrvCallBack * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IWiaMiniDrvCallBack * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IWiaMiniDrvCallBack * This);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *MiniDrvCallback )( 
            IWiaMiniDrvCallBack * This,
            /* [in] */ LONG lReason,
            /* [in] */ LONG lStatus,
            /* [in] */ LONG lPercentComplete,
            /* [in] */ LONG lOffset,
            /* [in] */ LONG lLength,
            /* [in] */ __RPC__in PMINIDRV_TRANSFER_CONTEXT pTranCtx,
            /* [in] */ LONG lReserved);
        
        END_INTERFACE
    } IWiaMiniDrvCallBackVtbl;

    interface IWiaMiniDrvCallBack
    {
        CONST_VTBL struct IWiaMiniDrvCallBackVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IWiaMiniDrvCallBack_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IWiaMiniDrvCallBack_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IWiaMiniDrvCallBack_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IWiaMiniDrvCallBack_MiniDrvCallback(This,lReason,lStatus,lPercentComplete,lOffset,lLength,pTranCtx,lReserved)	\
    ( (This)->lpVtbl -> MiniDrvCallback(This,lReason,lStatus,lPercentComplete,lOffset,lLength,pTranCtx,lReserved) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IWiaMiniDrvCallBack_INTERFACE_DEFINED__ */


#ifndef __IWiaDrvItem_INTERFACE_DEFINED__
#define __IWiaDrvItem_INTERFACE_DEFINED__

/* interface IWiaDrvItem */
/* [unique][helpstring][uuid][object] */ 


EXTERN_C const IID IID_IWiaDrvItem;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("1f02b5c5-b00c-11d2-a094-00c04f72dc3c")
    IWiaDrvItem : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE GetItemFlags( 
            /* [out] */ __RPC__out LONG *__MIDL__IWiaDrvItem0000) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetDeviceSpecContext( 
            /* [out] */ __RPC__deref_out_opt BYTE **__MIDL__IWiaDrvItem0001) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetFullItemName( 
            /* [out] */ __RPC__deref_out_opt BSTR *__MIDL__IWiaDrvItem0002) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetItemName( 
            /* [out] */ __RPC__deref_out_opt BSTR *__MIDL__IWiaDrvItem0003) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE AddItemToFolder( 
            /* [in] */ __RPC__in_opt IWiaDrvItem *__MIDL__IWiaDrvItem0004) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE UnlinkItemTree( 
            /* [in] */ LONG __MIDL__IWiaDrvItem0005) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE RemoveItemFromFolder( 
            /* [in] */ LONG __MIDL__IWiaDrvItem0006) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE FindItemByName( 
            /* [in] */ LONG __MIDL__IWiaDrvItem0007,
            /* [in] */ __RPC__in BSTR __MIDL__IWiaDrvItem0008,
            /* [out] */ __RPC__deref_out_opt IWiaDrvItem **__MIDL__IWiaDrvItem0009) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE FindChildItemByName( 
            /* [in] */ __RPC__in BSTR __MIDL__IWiaDrvItem0010,
            /* [out] */ __RPC__deref_out_opt IWiaDrvItem **__MIDL__IWiaDrvItem0011) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetParentItem( 
            /* [out] */ __RPC__deref_out_opt IWiaDrvItem **__MIDL__IWiaDrvItem0012) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetFirstChildItem( 
            /* [out] */ __RPC__deref_out_opt IWiaDrvItem **__MIDL__IWiaDrvItem0013) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetNextSiblingItem( 
            /* [out] */ __RPC__deref_out_opt IWiaDrvItem **__MIDL__IWiaDrvItem0014) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE DumpItemData( 
            /* [out] */ __RPC__deref_out_opt BSTR *__MIDL__IWiaDrvItem0015) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IWiaDrvItemVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IWiaDrvItem * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IWiaDrvItem * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IWiaDrvItem * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetItemFlags )( 
            IWiaDrvItem * This,
            /* [out] */ __RPC__out LONG *__MIDL__IWiaDrvItem0000);
        
        HRESULT ( STDMETHODCALLTYPE *GetDeviceSpecContext )( 
            IWiaDrvItem * This,
            /* [out] */ __RPC__deref_out_opt BYTE **__MIDL__IWiaDrvItem0001);
        
        HRESULT ( STDMETHODCALLTYPE *GetFullItemName )( 
            IWiaDrvItem * This,
            /* [out] */ __RPC__deref_out_opt BSTR *__MIDL__IWiaDrvItem0002);
        
        HRESULT ( STDMETHODCALLTYPE *GetItemName )( 
            IWiaDrvItem * This,
            /* [out] */ __RPC__deref_out_opt BSTR *__MIDL__IWiaDrvItem0003);
        
        HRESULT ( STDMETHODCALLTYPE *AddItemToFolder )( 
            IWiaDrvItem * This,
            /* [in] */ __RPC__in_opt IWiaDrvItem *__MIDL__IWiaDrvItem0004);
        
        HRESULT ( STDMETHODCALLTYPE *UnlinkItemTree )( 
            IWiaDrvItem * This,
            /* [in] */ LONG __MIDL__IWiaDrvItem0005);
        
        HRESULT ( STDMETHODCALLTYPE *RemoveItemFromFolder )( 
            IWiaDrvItem * This,
            /* [in] */ LONG __MIDL__IWiaDrvItem0006);
        
        HRESULT ( STDMETHODCALLTYPE *FindItemByName )( 
            IWiaDrvItem * This,
            /* [in] */ LONG __MIDL__IWiaDrvItem0007,
            /* [in] */ __RPC__in BSTR __MIDL__IWiaDrvItem0008,
            /* [out] */ __RPC__deref_out_opt IWiaDrvItem **__MIDL__IWiaDrvItem0009);
        
        HRESULT ( STDMETHODCALLTYPE *FindChildItemByName )( 
            IWiaDrvItem * This,
            /* [in] */ __RPC__in BSTR __MIDL__IWiaDrvItem0010,
            /* [out] */ __RPC__deref_out_opt IWiaDrvItem **__MIDL__IWiaDrvItem0011);
        
        HRESULT ( STDMETHODCALLTYPE *GetParentItem )( 
            IWiaDrvItem * This,
            /* [out] */ __RPC__deref_out_opt IWiaDrvItem **__MIDL__IWiaDrvItem0012);
        
        HRESULT ( STDMETHODCALLTYPE *GetFirstChildItem )( 
            IWiaDrvItem * This,
            /* [out] */ __RPC__deref_out_opt IWiaDrvItem **__MIDL__IWiaDrvItem0013);
        
        HRESULT ( STDMETHODCALLTYPE *GetNextSiblingItem )( 
            IWiaDrvItem * This,
            /* [out] */ __RPC__deref_out_opt IWiaDrvItem **__MIDL__IWiaDrvItem0014);
        
        HRESULT ( STDMETHODCALLTYPE *DumpItemData )( 
            IWiaDrvItem * This,
            /* [out] */ __RPC__deref_out_opt BSTR *__MIDL__IWiaDrvItem0015);
        
        END_INTERFACE
    } IWiaDrvItemVtbl;

    interface IWiaDrvItem
    {
        CONST_VTBL struct IWiaDrvItemVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IWiaDrvItem_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IWiaDrvItem_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IWiaDrvItem_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IWiaDrvItem_GetItemFlags(This,__MIDL__IWiaDrvItem0000)	\
    ( (This)->lpVtbl -> GetItemFlags(This,__MIDL__IWiaDrvItem0000) ) 

#define IWiaDrvItem_GetDeviceSpecContext(This,__MIDL__IWiaDrvItem0001)	\
    ( (This)->lpVtbl -> GetDeviceSpecContext(This,__MIDL__IWiaDrvItem0001) ) 

#define IWiaDrvItem_GetFullItemName(This,__MIDL__IWiaDrvItem0002)	\
    ( (This)->lpVtbl -> GetFullItemName(This,__MIDL__IWiaDrvItem0002) ) 

#define IWiaDrvItem_GetItemName(This,__MIDL__IWiaDrvItem0003)	\
    ( (This)->lpVtbl -> GetItemName(This,__MIDL__IWiaDrvItem0003) ) 

#define IWiaDrvItem_AddItemToFolder(This,__MIDL__IWiaDrvItem0004)	\
    ( (This)->lpVtbl -> AddItemToFolder(This,__MIDL__IWiaDrvItem0004) ) 

#define IWiaDrvItem_UnlinkItemTree(This,__MIDL__IWiaDrvItem0005)	\
    ( (This)->lpVtbl -> UnlinkItemTree(This,__MIDL__IWiaDrvItem0005) ) 

#define IWiaDrvItem_RemoveItemFromFolder(This,__MIDL__IWiaDrvItem0006)	\
    ( (This)->lpVtbl -> RemoveItemFromFolder(This,__MIDL__IWiaDrvItem0006) ) 

#define IWiaDrvItem_FindItemByName(This,__MIDL__IWiaDrvItem0007,__MIDL__IWiaDrvItem0008,__MIDL__IWiaDrvItem0009)	\
    ( (This)->lpVtbl -> FindItemByName(This,__MIDL__IWiaDrvItem0007,__MIDL__IWiaDrvItem0008,__MIDL__IWiaDrvItem0009) ) 

#define IWiaDrvItem_FindChildItemByName(This,__MIDL__IWiaDrvItem0010,__MIDL__IWiaDrvItem0011)	\
    ( (This)->lpVtbl -> FindChildItemByName(This,__MIDL__IWiaDrvItem0010,__MIDL__IWiaDrvItem0011) ) 

#define IWiaDrvItem_GetParentItem(This,__MIDL__IWiaDrvItem0012)	\
    ( (This)->lpVtbl -> GetParentItem(This,__MIDL__IWiaDrvItem0012) ) 

#define IWiaDrvItem_GetFirstChildItem(This,__MIDL__IWiaDrvItem0013)	\
    ( (This)->lpVtbl -> GetFirstChildItem(This,__MIDL__IWiaDrvItem0013) ) 

#define IWiaDrvItem_GetNextSiblingItem(This,__MIDL__IWiaDrvItem0014)	\
    ( (This)->lpVtbl -> GetNextSiblingItem(This,__MIDL__IWiaDrvItem0014) ) 

#define IWiaDrvItem_DumpItemData(This,__MIDL__IWiaDrvItem0015)	\
    ( (This)->lpVtbl -> DumpItemData(This,__MIDL__IWiaDrvItem0015) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IWiaDrvItem_INTERFACE_DEFINED__ */


/* interface __MIDL_itf_wiamindr_xp_0000_0003 */
/* [local] */ 

typedef struct _WIA_PROPERTY_INFO
    {
    ULONG lAccessFlags;
    VARTYPE vt;
    union 
        {
        struct 
            {
            LONG Min;
            LONG Nom;
            LONG Max;
            LONG Inc;
            } 	Range;
        struct 
            {
            DOUBLE Min;
            DOUBLE Nom;
            DOUBLE Max;
            DOUBLE Inc;
            } 	RangeFloat;
        struct 
            {
            LONG cNumList;
            LONG Nom;
            BYTE *pList;
            } 	List;
        struct 
            {
            LONG cNumList;
            DOUBLE Nom;
            BYTE *pList;
            } 	ListFloat;
        struct 
            {
            LONG cNumList;
            GUID Nom;
            GUID *pList;
            } 	ListGuid;
        struct 
            {
            LONG cNumList;
            BSTR Nom;
            BSTR *pList;
            } 	ListBStr;
        struct 
            {
            LONG Nom;
            LONG ValidBits;
            } 	Flag;
        struct 
            {
            LONG Dummy;
            } 	None;
        } 	ValidVal;
    } 	WIA_PROPERTY_INFO;

typedef struct _WIA_PROPERTY_INFO *PWIA_PROPERTY_INFO;

typedef struct _WIA_PROPERTY_CONTEXT
    {
    ULONG cProps;
    PROPID *pProps;
    BOOL *pChanged;
    } 	WIA_PROPERTY_CONTEXT;

typedef struct _WIA_PROPERTY_CONTEXT *PWIA_PROPERTY_CONTEXT;

typedef struct _WIAS_CHANGED_VALUE_INFO
    {
    BOOL bChanged;
    LONG vt;
    union 
        {
        LONG lVal;
        FLOAT fltVal;
        BSTR bstrVal;
        GUID guidVal;
        } 	Old;
    union 
        {
        LONG lVal;
        FLOAT fltVal;
        BSTR bstrVal;
        GUID guidVal;
        } 	Current;
    } 	WIAS_CHANGED_VALUE_INFO;

typedef struct _WIAS_CHANGED_VALUE_INFO *PWIAS_CHANGED_VALUE_INFO;

typedef struct _WIAS_DOWN_SAMPLE_INFO
    {
    ULONG ulOriginalWidth;
    ULONG ulOriginalHeight;
    ULONG ulBitsPerPixel;
    ULONG ulXRes;
    ULONG ulYRes;
    ULONG ulDownSampledWidth;
    ULONG ulDownSampledHeight;
    ULONG ulActualSize;
    ULONG ulDestBufSize;
    ULONG ulSrcBufSize;
    BYTE *pSrcBuffer;
    BYTE *pDestBuffer;
    } 	WIAS_DOWN_SAMPLE_INFO;

typedef struct _WIAS_DOWN_SAMPLE_INFO *PWIAS_DOWN_SAMPLE_INFO;

typedef struct _WIAS_ENDORSER_VALUE
    {
    LPWSTR wszTokenName;
    LPWSTR wszValue;
    } 	WIAS_ENDORSER_VALUE;

typedef struct _WIAS_ENDORSER_VALUE *PWIAS_ENDORSER_VALUE;

typedef struct _WIAS_ENDORSER_INFO
    {
    ULONG ulPageCount;
    ULONG ulNumEndorserValues;
    WIAS_ENDORSER_VALUE *pEndorserValues;
    } 	WIAS_ENDORSER_INFO;

typedef struct _WIAS_ENDORSER_INFO *PWIAS_ENDORSER_INFO;

#include "wiamdef.h"


extern RPC_IF_HANDLE __MIDL_itf_wiamindr_xp_0000_0003_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_wiamindr_xp_0000_0003_v0_0_s_ifspec;

/* Additional Prototypes for ALL interfaces */

unsigned long             __RPC_USER  BSTR_UserSize(     unsigned long *, unsigned long            , BSTR * ); 
unsigned char * __RPC_USER  BSTR_UserMarshal(  unsigned long *, unsigned char *, BSTR * ); 
unsigned char * __RPC_USER  BSTR_UserUnmarshal(unsigned long *, unsigned char *, BSTR * ); 
void                      __RPC_USER  BSTR_UserFree(     unsigned long *, BSTR * ); 

unsigned long             __RPC_USER  BSTR_UserSize64(     unsigned long *, unsigned long            , BSTR * ); 
unsigned char * __RPC_USER  BSTR_UserMarshal64(  unsigned long *, unsigned char *, BSTR * ); 
unsigned char * __RPC_USER  BSTR_UserUnmarshal64(unsigned long *, unsigned char *, BSTR * ); 
void                      __RPC_USER  BSTR_UserFree64(     unsigned long *, BSTR * ); 

/* end of Additional Prototypes */

#ifdef __cplusplus
}
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\win2k8\ddk\inc\wia_xp.h ===
/* this ALWAYS GENERATED file contains the definitions for the interfaces */


 /* File created by MIDL compiler version 7.00.0499 */
/* Compiler settings for wia_xp.idl, wia_xp.acf:
    Oicf, W1, Zp8, env=Win32 (32b run)
    protocol : dce , ms_ext, c_ext, robust
    error checks: allocation ref bounds_check enum stub_data 
    VC __declspec() decoration level: 
         __declspec(uuid()), __declspec(selectany), __declspec(novtable)
         DECLSPEC_UUID(), MIDL_INTERFACE()
*/
//@@MIDL_FILE_HEADING(  )

#pragma warning( disable: 4049 )  /* more than 64k source lines */


/* verify that the <rpcndr.h> version is high enough to compile this file*/
#ifndef __REQUIRED_RPCNDR_H_VERSION__
#define __REQUIRED_RPCNDR_H_VERSION__ 500
#endif

/* verify that the <rpcsal.h> version is high enough to compile this file*/
#ifndef __REQUIRED_RPCSAL_H_VERSION__
#define __REQUIRED_RPCSAL_H_VERSION__ 100
#endif

#include "rpc.h"
#include "rpcndr.h"

#ifndef __RPCNDR_H_VERSION__
#error this stub requires an updated version of <rpcndr.h>
#endif // __RPCNDR_H_VERSION__

#ifndef COM_NO_WINDOWS_H
#include "windows.h"
#include "ole2.h"
#endif /*COM_NO_WINDOWS_H*/

#ifndef __wia_xp_h__
#define __wia_xp_h__

#if defined(_MSC_VER) && (_MSC_VER >= 1020)
#pragma once
#endif

/* Forward Declarations */ 

#ifndef __IWiaDevMgr_FWD_DEFINED__
#define __IWiaDevMgr_FWD_DEFINED__
typedef interface IWiaDevMgr IWiaDevMgr;
#endif 	/* __IWiaDevMgr_FWD_DEFINED__ */


#ifndef __IEnumWIA_DEV_INFO_FWD_DEFINED__
#define __IEnumWIA_DEV_INFO_FWD_DEFINED__
typedef interface IEnumWIA_DEV_INFO IEnumWIA_DEV_INFO;
#endif 	/* __IEnumWIA_DEV_INFO_FWD_DEFINED__ */


#ifndef __IWiaEventCallback_FWD_DEFINED__
#define __IWiaEventCallback_FWD_DEFINED__
typedef interface IWiaEventCallback IWiaEventCallback;
#endif 	/* __IWiaEventCallback_FWD_DEFINED__ */


#ifndef __IWiaDataCallback_FWD_DEFINED__
#define __IWiaDataCallback_FWD_DEFINED__
typedef interface IWiaDataCallback IWiaDataCallback;
#endif 	/* __IWiaDataCallback_FWD_DEFINED__ */


#ifndef __IWiaDataTransfer_FWD_DEFINED__
#define __IWiaDataTransfer_FWD_DEFINED__
typedef interface IWiaDataTransfer IWiaDataTransfer;
#endif 	/* __IWiaDataTransfer_FWD_DEFINED__ */


#ifndef __IWiaItem_FWD_DEFINED__
#define __IWiaItem_FWD_DEFINED__
typedef interface IWiaItem IWiaItem;
#endif 	/* __IWiaItem_FWD_DEFINED__ */


#ifndef __IWiaPropertyStorage_FWD_DEFINED__
#define __IWiaPropertyStorage_FWD_DEFINED__
typedef interface IWiaPropertyStorage IWiaPropertyStorage;
#endif 	/* __IWiaPropertyStorage_FWD_DEFINED__ */


#ifndef __IEnumWiaItem_FWD_DEFINED__
#define __IEnumWiaItem_FWD_DEFINED__
typedef interface IEnumWiaItem IEnumWiaItem;
#endif 	/* __IEnumWiaItem_FWD_DEFINED__ */


#ifndef __IEnumWIA_DEV_CAPS_FWD_DEFINED__
#define __IEnumWIA_DEV_CAPS_FWD_DEFINED__
typedef interface IEnumWIA_DEV_CAPS IEnumWIA_DEV_CAPS;
#endif 	/* __IEnumWIA_DEV_CAPS_FWD_DEFINED__ */


#ifndef __IEnumWIA_FORMAT_INFO_FWD_DEFINED__
#define __IEnumWIA_FORMAT_INFO_FWD_DEFINED__
typedef interface IEnumWIA_FORMAT_INFO IEnumWIA_FORMAT_INFO;
#endif 	/* __IEnumWIA_FORMAT_INFO_FWD_DEFINED__ */


#ifndef __IWiaLog_FWD_DEFINED__
#define __IWiaLog_FWD_DEFINED__
typedef interface IWiaLog IWiaLog;
#endif 	/* __IWiaLog_FWD_DEFINED__ */


#ifndef __IWiaLogEx_FWD_DEFINED__
#define __IWiaLogEx_FWD_DEFINED__
typedef interface IWiaLogEx IWiaLogEx;
#endif 	/* __IWiaLogEx_FWD_DEFINED__ */


#ifndef __IWiaNotifyDevMgr_FWD_DEFINED__
#define __IWiaNotifyDevMgr_FWD_DEFINED__
typedef interface IWiaNotifyDevMgr IWiaNotifyDevMgr;
#endif 	/* __IWiaNotifyDevMgr_FWD_DEFINED__ */


#ifndef __IWiaItemExtras_FWD_DEFINED__
#define __IWiaItemExtras_FWD_DEFINED__
typedef interface IWiaItemExtras IWiaItemExtras;
#endif 	/* __IWiaItemExtras_FWD_DEFINED__ */


#ifndef __WiaDevMgr_FWD_DEFINED__
#define __WiaDevMgr_FWD_DEFINED__

#ifdef __cplusplus
typedef class WiaDevMgr WiaDevMgr;
#else
typedef struct WiaDevMgr WiaDevMgr;
#endif /* __cplusplus */

#endif 	/* __WiaDevMgr_FWD_DEFINED__ */


#ifndef __WiaLog_FWD_DEFINED__
#define __WiaLog_FWD_DEFINED__

#ifdef __cplusplus
typedef class WiaLog WiaLog;
#else
typedef struct WiaLog WiaLog;
#endif /* __cplusplus */

#endif 	/* __WiaLog_FWD_DEFINED__ */


/* header files for imported files */
#include "unknwn.h"
#include "oaidl.h"
#include "propidl.h"

#ifdef __cplusplus
extern "C"{
#endif 


/* interface __MIDL_itf_wia_xp_0000_0000 */
/* [local] */ 











typedef struct _WIA_DITHER_PATTERN_DATA
    {
    LONG lSize;
    BSTR bstrPatternName;
    LONG lPatternWidth;
    LONG lPatternLength;
    LONG cbPattern;
    BYTE *pbPattern;
    } 	WIA_DITHER_PATTERN_DATA;

typedef struct _WIA_DITHER_PATTERN_DATA *PWIA_DITHER_PATTERN_DATA;

typedef struct _WIA_PROPID_TO_NAME
    {
    PROPID propid;
    LPOLESTR pszName;
    } 	WIA_PROPID_TO_NAME;

typedef struct _WIA_PROPID_TO_NAME *PWIA_PROPID_TO_NAME;

typedef struct _WIA_FORMAT_INFO
    {
    GUID guidFormatID;
    LONG lTymed;
    } 	WIA_FORMAT_INFO;

typedef struct _WIA_FORMAT_INFO *PWIA_FORMAT_INFO;

#include "wiadef.h"


extern RPC_IF_HANDLE __MIDL_itf_wia_xp_0000_0000_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_wia_xp_0000_0000_v0_0_s_ifspec;

#ifndef __IWiaDevMgr_INTERFACE_DEFINED__
#define __IWiaDevMgr_INTERFACE_DEFINED__

/* interface IWiaDevMgr */
/* [unique][helpstring][uuid][object] */ 


EXTERN_C const IID IID_IWiaDevMgr;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("5eb2502a-8cf1-11d1-bf92-0060081ed811")
    IWiaDevMgr : public IUnknown
    {
    public:
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE EnumDeviceInfo( 
            /* [in] */ LONG lFlag,
            /* [retval][out] */ __RPC__deref_out_opt IEnumWIA_DEV_INFO **ppIEnum) = 0;
        
        virtual /* [local] */ HRESULT STDMETHODCALLTYPE CreateDevice( 
            /* [in] */ BSTR bstrDeviceID,
            /* [out] */ IWiaItem **ppWiaItemRoot) = 0;
        
        virtual /* [local] */ HRESULT STDMETHODCALLTYPE SelectDeviceDlg( 
            /* [in] */ HWND hwndParent,
            /* [in] */ LONG lDeviceType,
            /* [in] */ LONG lFlags,
            /* [out][in] */ BSTR *pbstrDeviceID,
            /* [retval][out] */ IWiaItem **ppItemRoot) = 0;
        
        virtual /* [local] */ HRESULT STDMETHODCALLTYPE SelectDeviceDlgID( 
            /* [in] */ HWND hwndParent,
            /* [in] */ LONG lDeviceType,
            /* [in] */ LONG lFlags,
            /* [retval][out] */ BSTR *pbstrDeviceID) = 0;
        
        virtual /* [local] */ HRESULT STDMETHODCALLTYPE GetImageDlg( 
            /* [in] */ HWND hwndParent,
            /* [in] */ LONG lDeviceType,
            /* [in] */ LONG lFlags,
            /* [in] */ LONG lIntent,
            /* [in] */ IWiaItem *pItemRoot,
            /* [in] */ BSTR bstrFilename,
            /* [out][in] */ GUID *pguidFormat) = 0;
        
        virtual /* [local] */ HRESULT STDMETHODCALLTYPE RegisterEventCallbackProgram( 
            /* [in] */ LONG lFlags,
            /* [in] */ BSTR bstrDeviceID,
            /* [in] */ const GUID *pEventGUID,
            /* [in] */ BSTR bstrCommandline,
            /* [in] */ BSTR bstrName,
            /* [in] */ BSTR bstrDescription,
            /* [in] */ BSTR bstrIcon) = 0;
        
        virtual /* [local] */ HRESULT STDMETHODCALLTYPE RegisterEventCallbackInterface( 
            /* [in] */ LONG lFlags,
            /* [in] */ BSTR bstrDeviceID,
            /* [in] */ const GUID *pEventGUID,
            /* [unique][in] */ IWiaEventCallback *pIWiaEventCallback,
            /* [out] */ IUnknown **pEventObject) = 0;
        
        virtual /* [local] */ HRESULT STDMETHODCALLTYPE RegisterEventCallbackCLSID( 
            /* [in] */ LONG lFlags,
            /* [in] */ BSTR bstrDeviceID,
            /* [in] */ const GUID *pEventGUID,
            /* [unique][in] */ const GUID *pClsID,
            /* [in] */ BSTR bstrName,
            /* [in] */ BSTR bstrDescription,
            /* [in] */ BSTR bstrIcon) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE AddDeviceDlg( 
            /* [in] */ __RPC__in HWND hwndParent,
            /* [in] */ LONG lFlags) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IWiaDevMgrVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IWiaDevMgr * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IWiaDevMgr * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IWiaDevMgr * This);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *EnumDeviceInfo )( 
            IWiaDevMgr * This,
            /* [in] */ LONG lFlag,
            /* [retval][out] */ __RPC__deref_out_opt IEnumWIA_DEV_INFO **ppIEnum);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE *CreateDevice )( 
            IWiaDevMgr * This,
            /* [in] */ BSTR bstrDeviceID,
            /* [out] */ IWiaItem **ppWiaItemRoot);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE *SelectDeviceDlg )( 
            IWiaDevMgr * This,
            /* [in] */ HWND hwndParent,
            /* [in] */ LONG lDeviceType,
            /* [in] */ LONG lFlags,
            /* [out][in] */ BSTR *pbstrDeviceID,
            /* [retval][out] */ IWiaItem **ppItemRoot);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE *SelectDeviceDlgID )( 
            IWiaDevMgr * This,
            /* [in] */ HWND hwndParent,
            /* [in] */ LONG lDeviceType,
            /* [in] */ LONG lFlags,
            /* [retval][out] */ BSTR *pbstrDeviceID);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE *GetImageDlg )( 
            IWiaDevMgr * This,
            /* [in] */ HWND hwndParent,
            /* [in] */ LONG lDeviceType,
            /* [in] */ LONG lFlags,
            /* [in] */ LONG lIntent,
            /* [in] */ IWiaItem *pItemRoot,
            /* [in] */ BSTR bstrFilename,
            /* [out][in] */ GUID *pguidFormat);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE *RegisterEventCallbackProgram )( 
            IWiaDevMgr * This,
            /* [in] */ LONG lFlags,
            /* [in] */ BSTR bstrDeviceID,
            /* [in] */ const GUID *pEventGUID,
            /* [in] */ BSTR bstrCommandline,
            /* [in] */ BSTR bstrName,
            /* [in] */ BSTR bstrDescription,
            /* [in] */ BSTR bstrIcon);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE *RegisterEventCallbackInterface )( 
            IWiaDevMgr * This,
            /* [in] */ LONG lFlags,
            /* [in] */ BSTR bstrDeviceID,
            /* [in] */ const GUID *pEventGUID,
            /* [unique][in] */ IWiaEventCallback *pIWiaEventCallback,
            /* [out] */ IUnknown **pEventObject);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE *RegisterEventCallbackCLSID )( 
            IWiaDevMgr * This,
            /* [in] */ LONG lFlags,
            /* [in] */ BSTR bstrDeviceID,
            /* [in] */ const GUID *pEventGUID,
            /* [unique][in] */ const GUID *pClsID,
            /* [in] */ BSTR bstrName,
            /* [in] */ BSTR bstrDescription,
            /* [in] */ BSTR bstrIcon);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *AddDeviceDlg )( 
            IWiaDevMgr * This,
            /* [in] */ __RPC__in HWND hwndParent,
            /* [in] */ LONG lFlags);
        
        END_INTERFACE
    } IWiaDevMgrVtbl;

    interface IWiaDevMgr
    {
        CONST_VTBL struct IWiaDevMgrVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IWiaDevMgr_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IWiaDevMgr_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IWiaDevMgr_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IWiaDevMgr_EnumDeviceInfo(This,lFlag,ppIEnum)	\
    ( (This)->lpVtbl -> EnumDeviceInfo(This,lFlag,ppIEnum) ) 

#define IWiaDevMgr_CreateDevice(This,bstrDeviceID,ppWiaItemRoot)	\
    ( (This)->lpVtbl -> CreateDevice(This,bstrDeviceID,ppWiaItemRoot) ) 

#define IWiaDevMgr_SelectDeviceDlg(This,hwndParent,lDeviceType,lFlags,pbstrDeviceID,ppItemRoot)	\
    ( (This)->lpVtbl -> SelectDeviceDlg(This,hwndParent,lDeviceType,lFlags,pbstrDeviceID,ppItemRoot) ) 

#define IWiaDevMgr_SelectDeviceDlgID(This,hwndParent,lDeviceType,lFlags,pbstrDeviceID)	\
    ( (This)->lpVtbl -> SelectDeviceDlgID(This,hwndParent,lDeviceType,lFlags,pbstrDeviceID) ) 

#define IWiaDevMgr_GetImageDlg(This,hwndParent,lDeviceType,lFlags,lIntent,pItemRoot,bstrFilename,pguidFormat)	\
    ( (This)->lpVtbl -> GetImageDlg(This,hwndParent,lDeviceType,lFlags,lIntent,pItemRoot,bstrFilename,pguidFormat) ) 

#define IWiaDevMgr_RegisterEventCallbackProgram(This,lFlags,bstrDeviceID,pEventGUID,bstrCommandline,bstrName,bstrDescription,bstrIcon)	\
    ( (This)->lpVtbl -> RegisterEventCallbackProgram(This,lFlags,bstrDeviceID,pEventGUID,bstrCommandline,bstrName,bstrDescription,bstrIcon) ) 

#define IWiaDevMgr_RegisterEventCallbackInterface(This,lFlags,bstrDeviceID,pEventGUID,pIWiaEventCallback,pEventObject)	\
    ( (This)->lpVtbl -> RegisterEventCallbackInterface(This,lFlags,bstrDeviceID,pEventGUID,pIWiaEventCallback,pEventObject) ) 

#define IWiaDevMgr_RegisterEventCallbackCLSID(This,lFlags,bstrDeviceID,pEventGUID,pClsID,bstrName,bstrDescription,bstrIcon)	\
    ( (This)->lpVtbl -> RegisterEventCallbackCLSID(This,lFlags,bstrDeviceID,pEventGUID,pClsID,bstrName,bstrDescription,bstrIcon) ) 

#define IWiaDevMgr_AddDeviceDlg(This,hwndParent,lFlags)	\
    ( (This)->lpVtbl -> AddDeviceDlg(This,hwndParent,lFlags) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [helpstring][call_as] */ HRESULT STDMETHODCALLTYPE IWiaDevMgr_LocalCreateDevice_Proxy( 
    IWiaDevMgr * This,
    /* [in] */ __RPC__in BSTR bstrDeviceID,
    /* [out] */ __RPC__deref_out_opt IWiaItem **ppWiaItemRoot);


void __RPC_STUB IWiaDevMgr_LocalCreateDevice_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [nocode][helpstring][call_as] */ HRESULT STDMETHODCALLTYPE IWiaDevMgr_LocalSelectDeviceDlg_Proxy( 
    IWiaDevMgr * This,
    /* [in] */ __RPC__in HWND hwndParent,
    /* [in] */ LONG lDeviceType,
    /* [in] */ LONG lFlags,
    /* [out][in] */ __RPC__deref_inout_opt BSTR *pbstrDeviceID,
    /* [retval][out] */ __RPC__deref_out_opt IWiaItem **ppItemRoot);


void __RPC_STUB IWiaDevMgr_LocalSelectDeviceDlg_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [nocode][helpstring][call_as] */ HRESULT STDMETHODCALLTYPE IWiaDevMgr_LocalSelectDeviceDlgID_Proxy( 
    IWiaDevMgr * This,
    /* [in] */ __RPC__in HWND hwndParent,
    /* [in] */ LONG lDeviceType,
    /* [in] */ LONG lFlags,
    /* [retval][out] */ __RPC__deref_out_opt BSTR *pbstrDeviceID);


void __RPC_STUB IWiaDevMgr_LocalSelectDeviceDlgID_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [nocode][helpstring][call_as] */ HRESULT STDMETHODCALLTYPE IWiaDevMgr_LocalGetImageDlg_Proxy( 
    IWiaDevMgr * This,
    /* [in] */ __RPC__in HWND hwndParent,
    /* [in] */ LONG lDeviceType,
    /* [in] */ LONG lFlags,
    /* [in] */ LONG lIntent,
    /* [in] */ __RPC__in_opt IWiaItem *pItemRoot,
    /* [in] */ __RPC__in BSTR bstrFilename,
    /* [out][in] */ __RPC__inout GUID *pguidFormat);


void __RPC_STUB IWiaDevMgr_LocalGetImageDlg_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][call_as] */ HRESULT STDMETHODCALLTYPE IWiaDevMgr_LocalRegisterEventCallbackProgram_Proxy( 
    IWiaDevMgr * This,
    /* [in] */ LONG lFlags,
    /* [in] */ __RPC__in BSTR bstrDeviceID,
    /* [in] */ __RPC__in const GUID *pEventGUID,
    /* [in] */ __RPC__in BSTR bstrCommandline,
    /* [in] */ __RPC__in BSTR bstrName,
    /* [in] */ __RPC__in BSTR bstrDescription,
    /* [in] */ __RPC__in BSTR bstrIcon);


void __RPC_STUB IWiaDevMgr_LocalRegisterEventCallbackProgram_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][call_as] */ HRESULT STDMETHODCALLTYPE IWiaDevMgr_LocalRegisterEventCallbackInterface_Proxy( 
    IWiaDevMgr * This,
    /* [in] */ LONG lFlags,
    /* [in] */ __RPC__in BSTR bstrDeviceID,
    /* [in] */ __RPC__in const GUID *pEventGUID,
    /* [unique][in] */ __RPC__in_opt IWiaEventCallback *pIWiaEventCallback,
    /* [out] */ __RPC__deref_out_opt IUnknown **pEventObject);


void __RPC_STUB IWiaDevMgr_LocalRegisterEventCallbackInterface_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][call_as] */ HRESULT STDMETHODCALLTYPE IWiaDevMgr_LocalRegisterEventCallbackCLSID_Proxy( 
    IWiaDevMgr * This,
    /* [in] */ LONG lFlags,
    /* [in] */ __RPC__in BSTR bstrDeviceID,
    /* [in] */ __RPC__in const GUID *pEventGUID,
    /* [unique][in] */ __RPC__in_opt const GUID *pClsID,
    /* [in] */ __RPC__in BSTR bstrName,
    /* [in] */ __RPC__in BSTR bstrDescription,
    /* [in] */ __RPC__in BSTR bstrIcon);


void __RPC_STUB IWiaDevMgr_LocalRegisterEventCallbackCLSID_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IWiaDevMgr_INTERFACE_DEFINED__ */


#ifndef __IEnumWIA_DEV_INFO_INTERFACE_DEFINED__
#define __IEnumWIA_DEV_INFO_INTERFACE_DEFINED__

/* interface IEnumWIA_DEV_INFO */
/* [unique][helpstring][uuid][object] */ 


EXTERN_C const IID IID_IEnumWIA_DEV_INFO;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("5e38b83c-8cf1-11d1-bf92-0060081ed811")
    IEnumWIA_DEV_INFO : public IUnknown
    {
    public:
        virtual /* [local] */ HRESULT STDMETHODCALLTYPE Next( 
            /* [in] */ ULONG celt,
            /* [length_is][size_is][out] */ IWiaPropertyStorage **rgelt,
            /* [unique][out][in] */ ULONG *pceltFetched) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE Skip( 
            /* [in] */ ULONG celt) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE Reset( void) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE Clone( 
            /* [out] */ __RPC__deref_out_opt IEnumWIA_DEV_INFO **ppIEnum) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE GetCount( 
            /* [out] */ __RPC__out ULONG *celt) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IEnumWIA_DEV_INFOVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IEnumWIA_DEV_INFO * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IEnumWIA_DEV_INFO * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IEnumWIA_DEV_INFO * This);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE *Next )( 
            IEnumWIA_DEV_INFO * This,
            /* [in] */ ULONG celt,
            /* [length_is][size_is][out] */ IWiaPropertyStorage **rgelt,
            /* [unique][out][in] */ ULONG *pceltFetched);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *Skip )( 
            IEnumWIA_DEV_INFO * This,
            /* [in] */ ULONG celt);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *Reset )( 
            IEnumWIA_DEV_INFO * This);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *Clone )( 
            IEnumWIA_DEV_INFO * This,
            /* [out] */ __RPC__deref_out_opt IEnumWIA_DEV_INFO **ppIEnum);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *GetCount )( 
            IEnumWIA_DEV_INFO * This,
            /* [out] */ __RPC__out ULONG *celt);
        
        END_INTERFACE
    } IEnumWIA_DEV_INFOVtbl;

    interface IEnumWIA_DEV_INFO
    {
        CONST_VTBL struct IEnumWIA_DEV_INFOVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IEnumWIA_DEV_INFO_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IEnumWIA_DEV_INFO_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IEnumWIA_DEV_INFO_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IEnumWIA_DEV_INFO_Next(This,celt,rgelt,pceltFetched)	\
    ( (This)->lpVtbl -> Next(This,celt,rgelt,pceltFetched) ) 

#define IEnumWIA_DEV_INFO_Skip(This,celt)	\
    ( (This)->lpVtbl -> Skip(This,celt) ) 

#define IEnumWIA_DEV_INFO_Reset(This)	\
    ( (This)->lpVtbl -> Reset(This) ) 

#define IEnumWIA_DEV_INFO_Clone(This,ppIEnum)	\
    ( (This)->lpVtbl -> Clone(This,ppIEnum) ) 

#define IEnumWIA_DEV_INFO_GetCount(This,celt)	\
    ( (This)->lpVtbl -> GetCount(This,celt) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [helpstring][call_as] */ HRESULT STDMETHODCALLTYPE IEnumWIA_DEV_INFO_RemoteNext_Proxy( 
    IEnumWIA_DEV_INFO * This,
    /* [in] */ ULONG celt,
    /* [length_is][size_is][out] */ __RPC__out_ecount_part(celt, *pceltFetched) IWiaPropertyStorage **rgelt,
    /* [unique][out][in] */ __RPC__inout_opt ULONG *pceltFetched);


void __RPC_STUB IEnumWIA_DEV_INFO_RemoteNext_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IEnumWIA_DEV_INFO_INTERFACE_DEFINED__ */


#ifndef __IWiaEventCallback_INTERFACE_DEFINED__
#define __IWiaEventCallback_INTERFACE_DEFINED__

/* interface IWiaEventCallback */
/* [unique][helpstring][uuid][object] */ 


EXTERN_C const IID IID_IWiaEventCallback;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("ae6287b0-0084-11d2-973b-00a0c9068f2e")
    IWiaEventCallback : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE ImageEventCallback( 
            /* [in] */ __RPC__in const GUID *pEventGUID,
            /* [in] */ __RPC__in BSTR bstrEventDescription,
            /* [in] */ __RPC__in BSTR bstrDeviceID,
            /* [in] */ __RPC__in BSTR bstrDeviceDescription,
            /* [in] */ DWORD dwDeviceType,
            /* [in] */ __RPC__in BSTR bstrFullItemName,
            /* [out][in] */ __RPC__inout ULONG *pulEventType,
            /* [in] */ ULONG ulReserved) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IWiaEventCallbackVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IWiaEventCallback * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IWiaEventCallback * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IWiaEventCallback * This);
        
        HRESULT ( STDMETHODCALLTYPE *ImageEventCallback )( 
            IWiaEventCallback * This,
            /* [in] */ __RPC__in const GUID *pEventGUID,
            /* [in] */ __RPC__in BSTR bstrEventDescription,
            /* [in] */ __RPC__in BSTR bstrDeviceID,
            /* [in] */ __RPC__in BSTR bstrDeviceDescription,
            /* [in] */ DWORD dwDeviceType,
            /* [in] */ __RPC__in BSTR bstrFullItemName,
            /* [out][in] */ __RPC__inout ULONG *pulEventType,
            /* [in] */ ULONG ulReserved);
        
        END_INTERFACE
    } IWiaEventCallbackVtbl;

    interface IWiaEventCallback
    {
        CONST_VTBL struct IWiaEventCallbackVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IWiaEventCallback_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IWiaEventCallback_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IWiaEventCallback_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IWiaEventCallback_ImageEventCallback(This,pEventGUID,bstrEventDescription,bstrDeviceID,bstrDeviceDescription,dwDeviceType,bstrFullItemName,pulEventType,ulReserved)	\
    ( (This)->lpVtbl -> ImageEventCallback(This,pEventGUID,bstrEventDescription,bstrDeviceID,bstrDeviceDescription,dwDeviceType,bstrFullItemName,pulEventType,ulReserved) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IWiaEventCallback_INTERFACE_DEFINED__ */


/* interface __MIDL_itf_wia_xp_0000_0003 */
/* [local] */ 

typedef struct _WIA_DATA_CALLBACK_HEADER
    {
    LONG lSize;
    GUID guidFormatID;
    LONG lBufferSize;
    LONG lPageCount;
    } 	WIA_DATA_CALLBACK_HEADER;

typedef struct _WIA_DATA_CALLBACK_HEADER *PWIA_DATA_CALLBACK_HEADER;



extern RPC_IF_HANDLE __MIDL_itf_wia_xp_0000_0003_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_wia_xp_0000_0003_v0_0_s_ifspec;

#ifndef __IWiaDataCallback_INTERFACE_DEFINED__
#define __IWiaDataCallback_INTERFACE_DEFINED__

/* interface IWiaDataCallback */
/* [unique][helpstring][uuid][object] */ 


EXTERN_C const IID IID_IWiaDataCallback;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("a558a866-a5b0-11d2-a08f-00c04f72dc3c")
    IWiaDataCallback : public IUnknown
    {
    public:
        virtual /* [local] */ HRESULT STDMETHODCALLTYPE BandedDataCallback( 
            /* [in] */ LONG lMessage,
            /* [in] */ LONG lStatus,
            /* [in] */ LONG lPercentComplete,
            /* [in] */ LONG lOffset,
            /* [in] */ LONG lLength,
            /* [in] */ LONG lReserved,
            /* [in] */ LONG lResLength,
            /* [size_is][in] */ BYTE *pbBuffer) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IWiaDataCallbackVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IWiaDataCallback * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IWiaDataCallback * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IWiaDataCallback * This);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE *BandedDataCallback )( 
            IWiaDataCallback * This,
            /* [in] */ LONG lMessage,
            /* [in] */ LONG lStatus,
            /* [in] */ LONG lPercentComplete,
            /* [in] */ LONG lOffset,
            /* [in] */ LONG lLength,
            /* [in] */ LONG lReserved,
            /* [in] */ LONG lResLength,
            /* [size_is][in] */ BYTE *pbBuffer);
        
        END_INTERFACE
    } IWiaDataCallbackVtbl;

    interface IWiaDataCallback
    {
        CONST_VTBL struct IWiaDataCallbackVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IWiaDataCallback_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IWiaDataCallback_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IWiaDataCallback_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IWiaDataCallback_BandedDataCallback(This,lMessage,lStatus,lPercentComplete,lOffset,lLength,lReserved,lResLength,pbBuffer)	\
    ( (This)->lpVtbl -> BandedDataCallback(This,lMessage,lStatus,lPercentComplete,lOffset,lLength,lReserved,lResLength,pbBuffer) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [helpstring][call_as] */ HRESULT STDMETHODCALLTYPE IWiaDataCallback_RemoteBandedDataCallback_Proxy( 
    IWiaDataCallback * This,
    /* [in] */ LONG lMessage,
    /* [in] */ LONG lStatus,
    /* [in] */ LONG lPercentComplete,
    /* [in] */ LONG lOffset,
    /* [in] */ LONG lLength,
    /* [in] */ LONG lReserved,
    /* [in] */ LONG lResLength,
    /* [unique][size_is][in] */ __RPC__in_ecount_full_opt(lResLength) BYTE *pbBuffer);


void __RPC_STUB IWiaDataCallback_RemoteBandedDataCallback_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IWiaDataCallback_INTERFACE_DEFINED__ */


/* interface __MIDL_itf_wia_xp_0000_0004 */
/* [local] */ 

typedef struct _WIA_DATA_TRANSFER_INFO
    {
    ULONG ulSize;
    ULONG ulSection;
    ULONG ulBufferSize;
    BOOL bDoubleBuffer;
    ULONG ulReserved1;
    ULONG ulReserved2;
    ULONG ulReserved3;
    } 	WIA_DATA_TRANSFER_INFO;

typedef struct _WIA_DATA_TRANSFER_INFO *PWIA_DATA_TRANSFER_INFO;

typedef struct _WIA_EXTENDED_TRANSFER_INFO
    {
    ULONG ulSize;
    ULONG ulMinBufferSize;
    ULONG ulOptimalBufferSize;
    ULONG ulMaxBufferSize;
    ULONG ulNumBuffers;
    } 	WIA_EXTENDED_TRANSFER_INFO;

typedef struct _WIA_EXTENDED_TRANSFER_INFO *PWIA_EXTENDED_TRANSFER_INFO;



extern RPC_IF_HANDLE __MIDL_itf_wia_xp_0000_0004_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_wia_xp_0000_0004_v0_0_s_ifspec;

#ifndef __IWiaDataTransfer_INTERFACE_DEFINED__
#define __IWiaDataTransfer_INTERFACE_DEFINED__

/* interface IWiaDataTransfer */
/* [unique][helpstring][uuid][object] */ 


EXTERN_C const IID IID_IWiaDataTransfer;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("a6cef998-a5b0-11d2-a08f-00c04f72dc3c")
    IWiaDataTransfer : public IUnknown
    {
    public:
        virtual /* [local] */ HRESULT STDMETHODCALLTYPE idtGetData( 
            /* [out][in] */ LPSTGMEDIUM pMedium,
            /* [unique][in] */ IWiaDataCallback *pIWiaDataCallback) = 0;
        
        virtual /* [local] */ HRESULT STDMETHODCALLTYPE idtGetBandedData( 
            /* [unique][in] */ PWIA_DATA_TRANSFER_INFO pWiaDataTransInfo,
            /* [unique][in] */ IWiaDataCallback *pIWiaDataCallback) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE idtQueryGetData( 
            /* [unique][in] */ __RPC__in_opt WIA_FORMAT_INFO *pfe) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE idtEnumWIA_FORMAT_INFO( 
            /* [out] */ __RPC__deref_out_opt IEnumWIA_FORMAT_INFO **ppEnum) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE idtGetExtendedTransferInfo( 
            /* [out] */ __RPC__out PWIA_EXTENDED_TRANSFER_INFO pExtendedTransferInfo) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IWiaDataTransferVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IWiaDataTransfer * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IWiaDataTransfer * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IWiaDataTransfer * This);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE *idtGetData )( 
            IWiaDataTransfer * This,
            /* [out][in] */ LPSTGMEDIUM pMedium,
            /* [unique][in] */ IWiaDataCallback *pIWiaDataCallback);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE *idtGetBandedData )( 
            IWiaDataTransfer * This,
            /* [unique][in] */ PWIA_DATA_TRANSFER_INFO pWiaDataTransInfo,
            /* [unique][in] */ IWiaDataCallback *pIWiaDataCallback);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *idtQueryGetData )( 
            IWiaDataTransfer * This,
            /* [unique][in] */ __RPC__in_opt WIA_FORMAT_INFO *pfe);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *idtEnumWIA_FORMAT_INFO )( 
            IWiaDataTransfer * This,
            /* [out] */ __RPC__deref_out_opt IEnumWIA_FORMAT_INFO **ppEnum);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *idtGetExtendedTransferInfo )( 
            IWiaDataTransfer * This,
            /* [out] */ __RPC__out PWIA_EXTENDED_TRANSFER_INFO pExtendedTransferInfo);
        
        END_INTERFACE
    } IWiaDataTransferVtbl;

    interface IWiaDataTransfer
    {
        CONST_VTBL struct IWiaDataTransferVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IWiaDataTransfer_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IWiaDataTransfer_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IWiaDataTransfer_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IWiaDataTransfer_idtGetData(This,pMedium,pIWiaDataCallback)	\
    ( (This)->lpVtbl -> idtGetData(This,pMedium,pIWiaDataCallback) ) 

#define IWiaDataTransfer_idtGetBandedData(This,pWiaDataTransInfo,pIWiaDataCallback)	\
    ( (This)->lpVtbl -> idtGetBandedData(This,pWiaDataTransInfo,pIWiaDataCallback) ) 

#define IWiaDataTransfer_idtQueryGetData(This,pfe)	\
    ( (This)->lpVtbl -> idtQueryGetData(This,pfe) ) 

#define IWiaDataTransfer_idtEnumWIA_FORMAT_INFO(This,ppEnum)	\
    ( (This)->lpVtbl -> idtEnumWIA_FORMAT_INFO(This,ppEnum) ) 

#define IWiaDataTransfer_idtGetExtendedTransferInfo(This,pExtendedTransferInfo)	\
    ( (This)->lpVtbl -> idtGetExtendedTransferInfo(This,pExtendedTransferInfo) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [helpstring][call_as] */ HRESULT STDMETHODCALLTYPE IWiaDataTransfer_idtGetDataEx_Proxy( 
    IWiaDataTransfer * This,
    /* [out][in] */ __RPC__inout LPSTGMEDIUM pMedium,
    /* [unique][in] */ __RPC__in_opt IWiaDataCallback *pIWiaDataCallback);


void __RPC_STUB IWiaDataTransfer_idtGetDataEx_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][call_as] */ HRESULT STDMETHODCALLTYPE IWiaDataTransfer_idtGetBandedDataEx_Proxy( 
    IWiaDataTransfer * This,
    /* [unique][in] */ __RPC__in_opt PWIA_DATA_TRANSFER_INFO pWiaDataTransInfo,
    /* [unique][in] */ __RPC__in_opt IWiaDataCallback *pIWiaDataCallback);


void __RPC_STUB IWiaDataTransfer_idtGetBandedDataEx_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IWiaDataTransfer_INTERFACE_DEFINED__ */


#ifndef __IWiaItem_INTERFACE_DEFINED__
#define __IWiaItem_INTERFACE_DEFINED__

/* interface IWiaItem */
/* [unique][helpstring][uuid][object] */ 


EXTERN_C const IID IID_IWiaItem;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("4db1ad10-3391-11d2-9a33-00c04fa36145")
    IWiaItem : public IUnknown
    {
    public:
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE GetItemType( 
            /* [out] */ __RPC__out LONG *pItemType) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE AnalyzeItem( 
            /* [in] */ LONG lFlags) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE EnumChildItems( 
            /* [out] */ __RPC__deref_out_opt IEnumWiaItem **ppIEnumWiaItem) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE DeleteItem( 
            /* [in] */ LONG lFlags) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE CreateChildItem( 
            /* [in] */ LONG lFlags,
            /* [in] */ __RPC__in BSTR bstrItemName,
            /* [in] */ __RPC__in BSTR bstrFullItemName,
            /* [out] */ __RPC__deref_out_opt IWiaItem **ppIWiaItem) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE EnumRegisterEventInfo( 
            /* [in] */ LONG lFlags,
            /* [in] */ __RPC__in const GUID *pEventGUID,
            /* [out] */ __RPC__deref_out_opt IEnumWIA_DEV_CAPS **ppIEnum) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE FindItemByName( 
            /* [in] */ LONG lFlags,
            /* [in] */ __RPC__in BSTR bstrFullItemName,
            /* [out] */ __RPC__deref_out_opt IWiaItem **ppIWiaItem) = 0;
        
        virtual /* [local] */ HRESULT STDMETHODCALLTYPE DeviceDlg( 
            /* [in] */ HWND hwndParent,
            /* [in] */ LONG lFlags,
            /* [in] */ LONG lIntent,
            /* [out] */ LONG *plItemCount,
            /* [out] */ IWiaItem ***ppIWiaItem) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE DeviceCommand( 
            /* [in] */ LONG lFlags,
            /* [in] */ __RPC__in const GUID *pCmdGUID,
            /* [out][in] */ __RPC__deref_inout_opt IWiaItem **pIWiaItem) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE GetRootItem( 
            /* [out] */ __RPC__deref_out_opt IWiaItem **ppIWiaItem) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE EnumDeviceCapabilities( 
            /* [in] */ LONG lFlags,
            /* [out] */ __RPC__deref_out_opt IEnumWIA_DEV_CAPS **ppIEnumWIA_DEV_CAPS) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE DumpItemData( 
            /* [out] */ __RPC__deref_out_opt BSTR *bstrData) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE DumpDrvItemData( 
            /* [out] */ __RPC__deref_out_opt BSTR *bstrData) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE DumpTreeItemData( 
            /* [out] */ __RPC__deref_out_opt BSTR *bstrData) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE Diagnostic( 
            /* [in] */ ULONG ulSize,
            /* [size_is][in] */ __RPC__in_ecount_full(ulSize) BYTE *pBuffer) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IWiaItemVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IWiaItem * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IWiaItem * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IWiaItem * This);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *GetItemType )( 
            IWiaItem * This,
            /* [out] */ __RPC__out LONG *pItemType);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *AnalyzeItem )( 
            IWiaItem * This,
            /* [in] */ LONG lFlags);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *EnumChildItems )( 
            IWiaItem * This,
            /* [out] */ __RPC__deref_out_opt IEnumWiaItem **ppIEnumWiaItem);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *DeleteItem )( 
            IWiaItem * This,
            /* [in] */ LONG lFlags);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *CreateChildItem )( 
            IWiaItem * This,
            /* [in] */ LONG lFlags,
            /* [in] */ __RPC__in BSTR bstrItemName,
            /* [in] */ __RPC__in BSTR bstrFullItemName,
            /* [out] */ __RPC__deref_out_opt IWiaItem **ppIWiaItem);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *EnumRegisterEventInfo )( 
            IWiaItem * This,
            /* [in] */ LONG lFlags,
            /* [in] */ __RPC__in const GUID *pEventGUID,
            /* [out] */ __RPC__deref_out_opt IEnumWIA_DEV_CAPS **ppIEnum);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *FindItemByName )( 
            IWiaItem * This,
            /* [in] */ LONG lFlags,
            /* [in] */ __RPC__in BSTR bstrFullItemName,
            /* [out] */ __RPC__deref_out_opt IWiaItem **ppIWiaItem);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE *DeviceDlg )( 
            IWiaItem * This,
            /* [in] */ HWND hwndParent,
            /* [in] */ LONG lFlags,
            /* [in] */ LONG lIntent,
            /* [out] */ LONG *plItemCount,
            /* [out] */ IWiaItem ***ppIWiaItem);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *DeviceCommand )( 
            IWiaItem * This,
            /* [in] */ LONG lFlags,
            /* [in] */ __RPC__in const GUID *pCmdGUID,
            /* [out][in] */ __RPC__deref_inout_opt IWiaItem **pIWiaItem);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *GetRootItem )( 
            IWiaItem * This,
            /* [out] */ __RPC__deref_out_opt IWiaItem **ppIWiaItem);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *EnumDeviceCapabilities )( 
            IWiaItem * This,
            /* [in] */ LONG lFlags,
            /* [out] */ __RPC__deref_out_opt IEnumWIA_DEV_CAPS **ppIEnumWIA_DEV_CAPS);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *DumpItemData )( 
            IWiaItem * This,
            /* [out] */ __RPC__deref_out_opt BSTR *bstrData);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *DumpDrvItemData )( 
            IWiaItem * This,
            /* [out] */ __RPC__deref_out_opt BSTR *bstrData);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *DumpTreeItemData )( 
            IWiaItem * This,
            /* [out] */ __RPC__deref_out_opt BSTR *bstrData);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *Diagnostic )( 
            IWiaItem * This,
            /* [in] */ ULONG ulSize,
            /* [size_is][in] */ __RPC__in_ecount_full(ulSize) BYTE *pBuffer);
        
        END_INTERFACE
    } IWiaItemVtbl;

    interface IWiaItem
    {
        CONST_VTBL struct IWiaItemVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IWiaItem_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IWiaItem_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IWiaItem_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IWiaItem_GetItemType(This,pItemType)	\
    ( (This)->lpVtbl -> GetItemType(This,pItemType) ) 

#define IWiaItem_AnalyzeItem(This,lFlags)	\
    ( (This)->lpVtbl -> AnalyzeItem(This,lFlags) ) 

#define IWiaItem_EnumChildItems(This,ppIEnumWiaItem)	\
    ( (This)->lpVtbl -> EnumChildItems(This,ppIEnumWiaItem) ) 

#define IWiaItem_DeleteItem(This,lFlags)	\
    ( (This)->lpVtbl -> DeleteItem(This,lFlags) ) 

#define IWiaItem_CreateChildItem(This,lFlags,bstrItemName,bstrFullItemName,ppIWiaItem)	\
    ( (This)->lpVtbl -> CreateChildItem(This,lFlags,bstrItemName,bstrFullItemName,ppIWiaItem) ) 

#define IWiaItem_EnumRegisterEventInfo(This,lFlags,pEventGUID,ppIEnum)	\
    ( (This)->lpVtbl -> EnumRegisterEventInfo(This,lFlags,pEventGUID,ppIEnum) ) 

#define IWiaItem_FindItemByName(This,lFlags,bstrFullItemName,ppIWiaItem)	\
    ( (This)->lpVtbl -> FindItemByName(This,lFlags,bstrFullItemName,ppIWiaItem) ) 

#define IWiaItem_DeviceDlg(This,hwndParent,lFlags,lIntent,plItemCount,ppIWiaItem)	\
    ( (This)->lpVtbl -> DeviceDlg(This,hwndParent,lFlags,lIntent,plItemCount,ppIWiaItem) ) 

#define IWiaItem_DeviceCommand(This,lFlags,pCmdGUID,pIWiaItem)	\
    ( (This)->lpVtbl -> DeviceCommand(This,lFlags,pCmdGUID,pIWiaItem) ) 

#define IWiaItem_GetRootItem(This,ppIWiaItem)	\
    ( (This)->lpVtbl -> GetRootItem(This,ppIWiaItem) ) 

#define IWiaItem_EnumDeviceCapabilities(This,lFlags,ppIEnumWIA_DEV_CAPS)	\
    ( (This)->lpVtbl -> EnumDeviceCapabilities(This,lFlags,ppIEnumWIA_DEV_CAPS) ) 

#define IWiaItem_DumpItemData(This,bstrData)	\
    ( (This)->lpVtbl -> DumpItemData(This,bstrData) ) 

#define IWiaItem_DumpDrvItemData(This,bstrData)	\
    ( (This)->lpVtbl -> DumpDrvItemData(This,bstrData) ) 

#define IWiaItem_DumpTreeItemData(This,bstrData)	\
    ( (This)->lpVtbl -> DumpTreeItemData(This,bstrData) ) 

#define IWiaItem_Diagnostic(This,ulSize,pBuffer)	\
    ( (This)->lpVtbl -> Diagnostic(This,ulSize,pBuffer) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [nocode][helpstring][call_as] */ HRESULT STDMETHODCALLTYPE IWiaItem_LocalDeviceDlg_Proxy( 
    IWiaItem * This,
    /* [in] */ __RPC__in HWND hwndParent,
    /* [in] */ LONG lFlags,
    /* [in] */ LONG lIntent,
    /* [out] */ __RPC__out LONG *plItemCount,
    /* [out] */ __RPC__deref_out_opt IWiaItem ***pIWiaItem);


void __RPC_STUB IWiaItem_LocalDeviceDlg_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IWiaItem_INTERFACE_DEFINED__ */


#ifndef __IWiaPropertyStorage_INTERFACE_DEFINED__
#define __IWiaPropertyStorage_INTERFACE_DEFINED__

/* interface IWiaPropertyStorage */
/* [unique][helpstring][uuid][object] */ 


EXTERN_C const IID IID_IWiaPropertyStorage;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("98B5E8A0-29CC-491a-AAC0-E6DB4FDCCEB6")
    IWiaPropertyStorage : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE ReadMultiple( 
            /* [in] */ ULONG cpspec,
            /* [size_is][in] */ __RPC__in_ecount_full(cpspec) const PROPSPEC rgpspec[  ],
            /* [size_is][out] */ __RPC__out_ecount_full(cpspec) PROPVARIANT rgpropvar[  ]) = 0;
        
        virtual /* [local] */ HRESULT STDMETHODCALLTYPE WriteMultiple( 
            /* [in] */ ULONG cpspec,
            /* [size_is][in] */ const PROPSPEC rgpspec[  ],
            /* [size_is][in] */ const PROPVARIANT rgpropvar[  ],
            /* [in] */ PROPID propidNameFirst) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE DeleteMultiple( 
            /* [in] */ ULONG cpspec,
            /* [size_is][in] */ __RPC__in_ecount_full(cpspec) const PROPSPEC rgpspec[  ]) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE ReadPropertyNames( 
            /* [in] */ ULONG cpropid,
            /* [size_is][in] */ __RPC__in_ecount_full(cpropid) const PROPID rgpropid[  ],
            /* [size_is][out] */ __RPC__out_ecount_full(cpropid) LPOLESTR rglpwstrName[  ]) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE WritePropertyNames( 
            /* [in] */ ULONG cpropid,
            /* [size_is][in] */ __RPC__in_ecount_full(cpropid) const PROPID rgpropid[  ],
            /* [size_is][in] */ __RPC__in_ecount_full(cpropid) const LPOLESTR rglpwstrName[  ]) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE DeletePropertyNames( 
            /* [in] */ ULONG cpropid,
            /* [size_is][in] */ __RPC__in_ecount_full(cpropid) const PROPID rgpropid[  ]) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Commit( 
            /* [in] */ DWORD grfCommitFlags) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Revert( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Enum( 
            /* [out] */ __RPC__deref_out_opt IEnumSTATPROPSTG **ppenum) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetTimes( 
            /* [in] */ __RPC__in const FILETIME *pctime,
            /* [in] */ __RPC__in const FILETIME *patime,
            /* [in] */ __RPC__in const FILETIME *pmtime) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetClass( 
            /* [in] */ __RPC__in REFCLSID clsid) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Stat( 
            /* [out] */ __RPC__out STATPROPSETSTG *pstatpsstg) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE GetPropertyAttributes( 
            /* [in] */ ULONG cpspec,
            /* [size_is][in] */ __RPC__in_ecount_full(cpspec) PROPSPEC rgpspec[  ],
            /* [size_is][out] */ __RPC__out_ecount_full(cpspec) ULONG rgflags[  ],
            /* [size_is][out] */ __RPC__out_ecount_full(cpspec) PROPVARIANT rgpropvar[  ]) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE GetCount( 
            /* [out] */ __RPC__out ULONG *pulNumProps) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE GetPropertyStream( 
            /* [out] */ __RPC__out GUID *pCompatibilityId,
            /* [out] */ __RPC__deref_out_opt IStream **ppIStream) = 0;
        
        virtual /* [local] */ HRESULT STDMETHODCALLTYPE SetPropertyStream( 
            /* [in] */ GUID *pCompatibilityId,
            /* [unique][in] */ IStream *pIStream) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IWiaPropertyStorageVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IWiaPropertyStorage * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IWiaPropertyStorage * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IWiaPropertyStorage * This);
        
        HRESULT ( STDMETHODCALLTYPE *ReadMultiple )( 
            IWiaPropertyStorage * This,
            /* [in] */ ULONG cpspec,
            /* [size_is][in] */ __RPC__in_ecount_full(cpspec) const PROPSPEC rgpspec[  ],
            /* [size_is][out] */ __RPC__out_ecount_full(cpspec) PROPVARIANT rgpropvar[  ]);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE *WriteMultiple )( 
            IWiaPropertyStorage * This,
            /* [in] */ ULONG cpspec,
            /* [size_is][in] */ const PROPSPEC rgpspec[  ],
            /* [size_is][in] */ const PROPVARIANT rgpropvar[  ],
            /* [in] */ PROPID propidNameFirst);
        
        HRESULT ( STDMETHODCALLTYPE *DeleteMultiple )( 
            IWiaPropertyStorage * This,
            /* [in] */ ULONG cpspec,
            /* [size_is][in] */ __RPC__in_ecount_full(cpspec) const PROPSPEC rgpspec[  ]);
        
        HRESULT ( STDMETHODCALLTYPE *ReadPropertyNames )( 
            IWiaPropertyStorage * This,
            /* [in] */ ULONG cpropid,
            /* [size_is][in] */ __RPC__in_ecount_full(cpropid) const PROPID rgpropid[  ],
            /* [size_is][out] */ __RPC__out_ecount_full(cpropid) LPOLESTR rglpwstrName[  ]);
        
        HRESULT ( STDMETHODCALLTYPE *WritePropertyNames )( 
            IWiaPropertyStorage * This,
            /* [in] */ ULONG cpropid,
            /* [size_is][in] */ __RPC__in_ecount_full(cpropid) const PROPID rgpropid[  ],
            /* [size_is][in] */ __RPC__in_ecount_full(cpropid) const LPOLESTR rglpwstrName[  ]);
        
        HRESULT ( STDMETHODCALLTYPE *DeletePropertyNames )( 
            IWiaPropertyStorage * This,
            /* [in] */ ULONG cpropid,
            /* [size_is][in] */ __RPC__in_ecount_full(cpropid) const PROPID rgpropid[  ]);
        
        HRESULT ( STDMETHODCALLTYPE *Commit )( 
            IWiaPropertyStorage * This,
            /* [in] */ DWORD grfCommitFlags);
        
        HRESULT ( STDMETHODCALLTYPE *Revert )( 
            IWiaPropertyStorage * This);
        
        HRESULT ( STDMETHODCALLTYPE *Enum )( 
            IWiaPropertyStorage * This,
            /* [out] */ __RPC__deref_out_opt IEnumSTATPROPSTG **ppenum);
        
        HRESULT ( STDMETHODCALLTYPE *SetTimes )( 
            IWiaPropertyStorage * This,
            /* [in] */ __RPC__in const FILETIME *pctime,
            /* [in] */ __RPC__in const FILETIME *patime,
            /* [in] */ __RPC__in const FILETIME *pmtime);
        
        HRESULT ( STDMETHODCALLTYPE *SetClass )( 
            IWiaPropertyStorage * This,
            /* [in] */ __RPC__in REFCLSID clsid);
        
        HRESULT ( STDMETHODCALLTYPE *Stat )( 
            IWiaPropertyStorage * This,
            /* [out] */ __RPC__out STATPROPSETSTG *pstatpsstg);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *GetPropertyAttributes )( 
            IWiaPropertyStorage * This,
            /* [in] */ ULONG cpspec,
            /* [size_is][in] */ __RPC__in_ecount_full(cpspec) PROPSPEC rgpspec[  ],
            /* [size_is][out] */ __RPC__out_ecount_full(cpspec) ULONG rgflags[  ],
            /* [size_is][out] */ __RPC__out_ecount_full(cpspec) PROPVARIANT rgpropvar[  ]);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *GetCount )( 
            IWiaPropertyStorage * This,
            /* [out] */ __RPC__out ULONG *pulNumProps);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *GetPropertyStream )( 
            IWiaPropertyStorage * This,
            /* [out] */ __RPC__out GUID *pCompatibilityId,
            /* [out] */ __RPC__deref_out_opt IStream **ppIStream);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE *SetPropertyStream )( 
            IWiaPropertyStorage * This,
            /* [in] */ GUID *pCompatibilityId,
            /* [unique][in] */ IStream *pIStream);
        
        END_INTERFACE
    } IWiaPropertyStorageVtbl;

    interface IWiaPropertyStorage
    {
        CONST_VTBL struct IWiaPropertyStorageVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IWiaPropertyStorage_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IWiaPropertyStorage_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IWiaPropertyStorage_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IWiaPropertyStorage_ReadMultiple(This,cpspec,rgpspec,rgpropvar)	\
    ( (This)->lpVtbl -> ReadMultiple(This,cpspec,rgpspec,rgpropvar) ) 

#define IWiaPropertyStorage_WriteMultiple(This,cpspec,rgpspec,rgpropvar,propidNameFirst)	\
    ( (This)->lpVtbl -> WriteMultiple(This,cpspec,rgpspec,rgpropvar,propidNameFirst) ) 

#define IWiaPropertyStorage_DeleteMultiple(This,cpspec,rgpspec)	\
    ( (This)->lpVtbl -> DeleteMultiple(This,cpspec,rgpspec) ) 

#define IWiaPropertyStorage_ReadPropertyNames(This,cpropid,rgpropid,rglpwstrName)	\
    ( (This)->lpVtbl -> ReadPropertyNames(This,cpropid,rgpropid,rglpwstrName) ) 

#define IWiaPropertyStorage_WritePropertyNames(This,cpropid,rgpropid,rglpwstrName)	\
    ( (This)->lpVtbl -> WritePropertyNames(This,cpropid,rgpropid,rglpwstrName) ) 

#define IWiaPropertyStorage_DeletePropertyNames(This,cpropid,rgpropid)	\
    ( (This)->lpVtbl -> DeletePropertyNames(This,cpropid,rgpropid) ) 

#define IWiaPropertyStorage_Commit(This,grfCommitFlags)	\
    ( (This)->lpVtbl -> Commit(This,grfCommitFlags) ) 

#define IWiaPropertyStorage_Revert(This)	\
    ( (This)->lpVtbl -> Revert(This) ) 

#define IWiaPropertyStorage_Enum(This,ppenum)	\
    ( (This)->lpVtbl -> Enum(This,ppenum) ) 

#define IWiaPropertyStorage_SetTimes(This,pctime,patime,pmtime)	\
    ( (This)->lpVtbl -> SetTimes(This,pctime,patime,pmtime) ) 

#define IWiaPropertyStorage_SetClass(This,clsid)	\
    ( (This)->lpVtbl -> SetClass(This,clsid) ) 

#define IWiaPropertyStorage_Stat(This,pstatpsstg)	\
    ( (This)->lpVtbl -> Stat(This,pstatpsstg) ) 

#define IWiaPropertyStorage_GetPropertyAttributes(This,cpspec,rgpspec,rgflags,rgpropvar)	\
    ( (This)->lpVtbl -> GetPropertyAttributes(This,cpspec,rgpspec,rgflags,rgpropvar) ) 

#define IWiaPropertyStorage_GetCount(This,pulNumProps)	\
    ( (This)->lpVtbl -> GetCount(This,pulNumProps) ) 

#define IWiaPropertyStorage_GetPropertyStream(This,pCompatibilityId,ppIStream)	\
    ( (This)->lpVtbl -> GetPropertyStream(This,pCompatibilityId,ppIStream) ) 

#define IWiaPropertyStorage_SetPropertyStream(This,pCompatibilityId,pIStream)	\
    ( (This)->lpVtbl -> SetPropertyStream(This,pCompatibilityId,pIStream) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [call_as] */ HRESULT STDMETHODCALLTYPE IWiaPropertyStorage_RemoteWriteMultiple_Proxy( 
    IWiaPropertyStorage * This,
    /* [in] */ ULONG cpspec,
    /* [size_is][in] */ __RPC__in_ecount_full(cpspec) const PROPSPEC *rgpspec,
    /* [size_is][in] */ __RPC__in_ecount_full(cpspec) const PROPVARIANT *rgpropvar,
    /* [in] */ PROPID propidNameFirst);


void __RPC_STUB IWiaPropertyStorage_RemoteWriteMultiple_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][call_as] */ HRESULT STDMETHODCALLTYPE IWiaPropertyStorage_RemoteSetPropertyStream_Proxy( 
    IWiaPropertyStorage * This,
    /* [in] */ __RPC__in GUID *pCompatibilityId,
    /* [unique][in] */ __RPC__in_opt IStream *pIStream);


void __RPC_STUB IWiaPropertyStorage_RemoteSetPropertyStream_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IWiaPropertyStorage_INTERFACE_DEFINED__ */


#ifndef __IEnumWiaItem_INTERFACE_DEFINED__
#define __IEnumWiaItem_INTERFACE_DEFINED__

/* interface IEnumWiaItem */
/* [unique][helpstring][uuid][object] */ 


EXTERN_C const IID IID_IEnumWiaItem;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("5e8383fc-3391-11d2-9a33-00c04fa36145")
    IEnumWiaItem : public IUnknown
    {
    public:
        virtual /* [local] */ HRESULT STDMETHODCALLTYPE Next( 
            /* [in] */ ULONG celt,
            /* [length_is][size_is][out] */ IWiaItem **ppIWiaItem,
            /* [unique][out][in] */ ULONG *pceltFetched) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE Skip( 
            /* [in] */ ULONG celt) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE Reset( void) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE Clone( 
            /* [out] */ __RPC__deref_out_opt IEnumWiaItem **ppIEnum) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE GetCount( 
            /* [out] */ __RPC__out ULONG *celt) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IEnumWiaItemVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IEnumWiaItem * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IEnumWiaItem * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IEnumWiaItem * This);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE *Next )( 
            IEnumWiaItem * This,
            /* [in] */ ULONG celt,
            /* [length_is][size_is][out] */ IWiaItem **ppIWiaItem,
            /* [unique][out][in] */ ULONG *pceltFetched);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *Skip )( 
            IEnumWiaItem * This,
            /* [in] */ ULONG celt);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *Reset )( 
            IEnumWiaItem * This);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *Clone )( 
            IEnumWiaItem * This,
            /* [out] */ __RPC__deref_out_opt IEnumWiaItem **ppIEnum);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *GetCount )( 
            IEnumWiaItem * This,
            /* [out] */ __RPC__out ULONG *celt);
        
        END_INTERFACE
    } IEnumWiaItemVtbl;

    interface IEnumWiaItem
    {
        CONST_VTBL struct IEnumWiaItemVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IEnumWiaItem_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IEnumWiaItem_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IEnumWiaItem_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IEnumWiaItem_Next(This,celt,ppIWiaItem,pceltFetched)	\
    ( (This)->lpVtbl -> Next(This,celt,ppIWiaItem,pceltFetched) ) 

#define IEnumWiaItem_Skip(This,celt)	\
    ( (This)->lpVtbl -> Skip(This,celt) ) 

#define IEnumWiaItem_Reset(This)	\
    ( (This)->lpVtbl -> Reset(This) ) 

#define IEnumWiaItem_Clone(This,ppIEnum)	\
    ( (This)->lpVtbl -> Clone(This,ppIEnum) ) 

#define IEnumWiaItem_GetCount(This,celt)	\
    ( (This)->lpVtbl -> GetCount(This,celt) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [helpstring][call_as] */ HRESULT STDMETHODCALLTYPE IEnumWiaItem_RemoteNext_Proxy( 
    IEnumWiaItem * This,
    /* [in] */ ULONG celt,
    /* [length_is][size_is][out] */ __RPC__out_ecount_part(celt, *pceltFetched) IWiaItem **ppIWiaItem,
    /* [unique][out][in] */ __RPC__inout_opt ULONG *pceltFetched);


void __RPC_STUB IEnumWiaItem_RemoteNext_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IEnumWiaItem_INTERFACE_DEFINED__ */


/* interface __MIDL_itf_wia_xp_0000_0008 */
/* [local] */ 

typedef struct _WIA_DEV_CAP
    {
    GUID guid;
    ULONG ulFlags;
    BSTR bstrName;
    BSTR bstrDescription;
    BSTR bstrIcon;
    BSTR bstrCommandline;
    } 	WIA_DEV_CAP;

typedef struct _WIA_DEV_CAP *PWIA_DEV_CAP;

typedef struct _WIA_DEV_CAP WIA_EVENT_HANDLER;

typedef struct _WIA_DEV_CAP *PWIA_EVENT_HANDLER;



extern RPC_IF_HANDLE __MIDL_itf_wia_xp_0000_0008_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_wia_xp_0000_0008_v0_0_s_ifspec;

#ifndef __IEnumWIA_DEV_CAPS_INTERFACE_DEFINED__
#define __IEnumWIA_DEV_CAPS_INTERFACE_DEFINED__

/* interface IEnumWIA_DEV_CAPS */
/* [unique][helpstring][uuid][object] */ 


EXTERN_C const IID IID_IEnumWIA_DEV_CAPS;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("1fcc4287-aca6-11d2-a093-00c04f72dc3c")
    IEnumWIA_DEV_CAPS : public IUnknown
    {
    public:
        virtual /* [local] */ HRESULT STDMETHODCALLTYPE Next( 
            /* [in] */ ULONG celt,
            /* [length_is][size_is][out] */ WIA_DEV_CAP *rgelt,
            /* [unique][out][in] */ ULONG *pceltFetched) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE Skip( 
            /* [in] */ ULONG celt) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE Reset( void) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE Clone( 
            /* [out] */ __RPC__deref_out_opt IEnumWIA_DEV_CAPS **ppIEnum) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE GetCount( 
            /* [out] */ __RPC__out ULONG *pcelt) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IEnumWIA_DEV_CAPSVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IEnumWIA_DEV_CAPS * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IEnumWIA_DEV_CAPS * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IEnumWIA_DEV_CAPS * This);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE *Next )( 
            IEnumWIA_DEV_CAPS * This,
            /* [in] */ ULONG celt,
            /* [length_is][size_is][out] */ WIA_DEV_CAP *rgelt,
            /* [unique][out][in] */ ULONG *pceltFetched);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *Skip )( 
            IEnumWIA_DEV_CAPS * This,
            /* [in] */ ULONG celt);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *Reset )( 
            IEnumWIA_DEV_CAPS * This);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *Clone )( 
            IEnumWIA_DEV_CAPS * This,
            /* [out] */ __RPC__deref_out_opt IEnumWIA_DEV_CAPS **ppIEnum);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *GetCount )( 
            IEnumWIA_DEV_CAPS * This,
            /* [out] */ __RPC__out ULONG *pcelt);
        
        END_INTERFACE
    } IEnumWIA_DEV_CAPSVtbl;

    interface IEnumWIA_DEV_CAPS
    {
        CONST_VTBL struct IEnumWIA_DEV_CAPSVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IEnumWIA_DEV_CAPS_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IEnumWIA_DEV_CAPS_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IEnumWIA_DEV_CAPS_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IEnumWIA_DEV_CAPS_Next(This,celt,rgelt,pceltFetched)	\
    ( (This)->lpVtbl -> Next(This,celt,rgelt,pceltFetched) ) 

#define IEnumWIA_DEV_CAPS_Skip(This,celt)	\
    ( (This)->lpVtbl -> Skip(This,celt) ) 

#define IEnumWIA_DEV_CAPS_Reset(This)	\
    ( (This)->lpVtbl -> Reset(This) ) 

#define IEnumWIA_DEV_CAPS_Clone(This,ppIEnum)	\
    ( (This)->lpVtbl -> Clone(This,ppIEnum) ) 

#define IEnumWIA_DEV_CAPS_GetCount(This,pcelt)	\
    ( (This)->lpVtbl -> GetCount(This,pcelt) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [helpstring][call_as] */ HRESULT STDMETHODCALLTYPE IEnumWIA_DEV_CAPS_RemoteNext_Proxy( 
    IEnumWIA_DEV_CAPS * This,
    /* [in] */ ULONG celt,
    /* [length_is][size_is][out] */ __RPC__out_ecount_part(celt, *pceltFetched) WIA_DEV_CAP *rgelt,
    /* [unique][out][in] */ __RPC__inout_opt ULONG *pceltFetched);


void __RPC_STUB IEnumWIA_DEV_CAPS_RemoteNext_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IEnumWIA_DEV_CAPS_INTERFACE_DEFINED__ */


#ifndef __IEnumWIA_FORMAT_INFO_INTERFACE_DEFINED__
#define __IEnumWIA_FORMAT_INFO_INTERFACE_DEFINED__

/* interface IEnumWIA_FORMAT_INFO */
/* [unique][helpstring][uuid][object] */ 


EXTERN_C const IID IID_IEnumWIA_FORMAT_INFO;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("81BEFC5B-656D-44f1-B24C-D41D51B4DC81")
    IEnumWIA_FORMAT_INFO : public IUnknown
    {
    public:
        virtual /* [local] */ HRESULT STDMETHODCALLTYPE Next( 
            /* [in] */ ULONG celt,
            /* [length_is][size_is][out] */ WIA_FORMAT_INFO *rgelt,
            /* [unique][out][in] */ ULONG *pceltFetched) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE Skip( 
            /* [in] */ ULONG celt) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE Reset( void) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE Clone( 
            /* [out] */ __RPC__deref_out_opt IEnumWIA_FORMAT_INFO **ppIEnum) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE GetCount( 
            /* [out] */ __RPC__out ULONG *pcelt) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IEnumWIA_FORMAT_INFOVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IEnumWIA_FORMAT_INFO * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IEnumWIA_FORMAT_INFO * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IEnumWIA_FORMAT_INFO * This);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE *Next )( 
            IEnumWIA_FORMAT_INFO * This,
            /* [in] */ ULONG celt,
            /* [length_is][size_is][out] */ WIA_FORMAT_INFO *rgelt,
            /* [unique][out][in] */ ULONG *pceltFetched);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *Skip )( 
            IEnumWIA_FORMAT_INFO * This,
            /* [in] */ ULONG celt);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *Reset )( 
            IEnumWIA_FORMAT_INFO * This);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *Clone )( 
            IEnumWIA_FORMAT_INFO * This,
            /* [out] */ __RPC__deref_out_opt IEnumWIA_FORMAT_INFO **ppIEnum);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *GetCount )( 
            IEnumWIA_FORMAT_INFO * This,
            /* [out] */ __RPC__out ULONG *pcelt);
        
        END_INTERFACE
    } IEnumWIA_FORMAT_INFOVtbl;

    interface IEnumWIA_FORMAT_INFO
    {
        CONST_VTBL struct IEnumWIA_FORMAT_INFOVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IEnumWIA_FORMAT_INFO_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IEnumWIA_FORMAT_INFO_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IEnumWIA_FORMAT_INFO_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IEnumWIA_FORMAT_INFO_Next(This,celt,rgelt,pceltFetched)	\
    ( (This)->lpVtbl -> Next(This,celt,rgelt,pceltFetched) ) 

#define IEnumWIA_FORMAT_INFO_Skip(This,celt)	\
    ( (This)->lpVtbl -> Skip(This,celt) ) 

#define IEnumWIA_FORMAT_INFO_Reset(This)	\
    ( (This)->lpVtbl -> Reset(This) ) 

#define IEnumWIA_FORMAT_INFO_Clone(This,ppIEnum)	\
    ( (This)->lpVtbl -> Clone(This,ppIEnum) ) 

#define IEnumWIA_FORMAT_INFO_GetCount(This,pcelt)	\
    ( (This)->lpVtbl -> GetCount(This,pcelt) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [helpstring][call_as] */ HRESULT STDMETHODCALLTYPE IEnumWIA_FORMAT_INFO_RemoteNext_Proxy( 
    IEnumWIA_FORMAT_INFO * This,
    /* [in] */ ULONG celt,
    /* [length_is][size_is][out] */ __RPC__out_ecount_part(celt, *pceltFetched) WIA_FORMAT_INFO *rgelt,
    /* [unique][out][in] */ __RPC__inout_opt ULONG *pceltFetched);


void __RPC_STUB IEnumWIA_FORMAT_INFO_RemoteNext_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IEnumWIA_FORMAT_INFO_INTERFACE_DEFINED__ */


#ifndef __IWiaLog_INTERFACE_DEFINED__
#define __IWiaLog_INTERFACE_DEFINED__

/* interface IWiaLog */
/* [unique][helpstring][uuid][object] */ 


EXTERN_C const IID IID_IWiaLog;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("A00C10B6-82A1-452f-8B6C-86062AAD6890")
    IWiaLog : public IUnknown
    {
    public:
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE InitializeLog( 
            /* [in] */ LONG hInstance) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE hResult( 
            /* [in] */ HRESULT hResult) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE Log( 
            /* [in] */ LONG lFlags,
            /* [in] */ LONG lResID,
            /* [in] */ LONG lDetail,
            /* [in] */ __RPC__in BSTR bstrText) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IWiaLogVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IWiaLog * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IWiaLog * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IWiaLog * This);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *InitializeLog )( 
            IWiaLog * This,
            /* [in] */ LONG hInstance);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *hResult )( 
            IWiaLog * This,
            /* [in] */ HRESULT hResult);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *Log )( 
            IWiaLog * This,
            /* [in] */ LONG lFlags,
            /* [in] */ LONG lResID,
            /* [in] */ LONG lDetail,
            /* [in] */ __RPC__in BSTR bstrText);
        
        END_INTERFACE
    } IWiaLogVtbl;

    interface IWiaLog
    {
        CONST_VTBL struct IWiaLogVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IWiaLog_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IWiaLog_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IWiaLog_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IWiaLog_InitializeLog(This,hInstance)	\
    ( (This)->lpVtbl -> InitializeLog(This,hInstance) ) 

#define IWiaLog_hResult(This,hResult)	\
    ( (This)->lpVtbl -> hResult(This,hResult) ) 

#define IWiaLog_Log(This,lFlags,lResID,lDetail,bstrText)	\
    ( (This)->lpVtbl -> Log(This,lFlags,lResID,lDetail,bstrText) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IWiaLog_INTERFACE_DEFINED__ */


#ifndef __IWiaLogEx_INTERFACE_DEFINED__
#define __IWiaLogEx_INTERFACE_DEFINED__

/* interface IWiaLogEx */
/* [unique][helpstring][uuid][object] */ 


EXTERN_C const IID IID_IWiaLogEx;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("AF1F22AC-7A40-4787-B421-AEb47A1FBD0B")
    IWiaLogEx : public IUnknown
    {
    public:
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE InitializeLogEx( 
            /* [in] */ __RPC__in BYTE *hInstance) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE hResult( 
            /* [in] */ HRESULT hResult) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE Log( 
            /* [in] */ LONG lFlags,
            /* [in] */ LONG lResID,
            /* [in] */ LONG lDetail,
            /* [in] */ __RPC__in BSTR bstrText) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE hResultEx( 
            /* [in] */ LONG lMethodId,
            /* [in] */ HRESULT hResult) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE LogEx( 
            /* [in] */ LONG lMethodId,
            /* [in] */ LONG lFlags,
            /* [in] */ LONG lResID,
            /* [in] */ LONG lDetail,
            /* [in] */ __RPC__in BSTR bstrText) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IWiaLogExVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IWiaLogEx * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IWiaLogEx * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IWiaLogEx * This);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *InitializeLogEx )( 
            IWiaLogEx * This,
            /* [in] */ __RPC__in BYTE *hInstance);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *hResult )( 
            IWiaLogEx * This,
            /* [in] */ HRESULT hResult);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *Log )( 
            IWiaLogEx * This,
            /* [in] */ LONG lFlags,
            /* [in] */ LONG lResID,
            /* [in] */ LONG lDetail,
            /* [in] */ __RPC__in BSTR bstrText);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *hResultEx )( 
            IWiaLogEx * This,
            /* [in] */ LONG lMethodId,
            /* [in] */ HRESULT hResult);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *LogEx )( 
            IWiaLogEx * This,
            /* [in] */ LONG lMethodId,
            /* [in] */ LONG lFlags,
            /* [in] */ LONG lResID,
            /* [in] */ LONG lDetail,
            /* [in] */ __RPC__in BSTR bstrText);
        
        END_INTERFACE
    } IWiaLogExVtbl;

    interface IWiaLogEx
    {
        CONST_VTBL struct IWiaLogExVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IWiaLogEx_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IWiaLogEx_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IWiaLogEx_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IWiaLogEx_InitializeLogEx(This,hInstance)	\
    ( (This)->lpVtbl -> InitializeLogEx(This,hInstance) ) 

#define IWiaLogEx_hResult(This,hResult)	\
    ( (This)->lpVtbl -> hResult(This,hResult) ) 

#define IWiaLogEx_Log(This,lFlags,lResID,lDetail,bstrText)	\
    ( (This)->lpVtbl -> Log(This,lFlags,lResID,lDetail,bstrText) ) 

#define IWiaLogEx_hResultEx(This,lMethodId,hResult)	\
    ( (This)->lpVtbl -> hResultEx(This,lMethodId,hResult) ) 

#define IWiaLogEx_LogEx(This,lMethodId,lFlags,lResID,lDetail,bstrText)	\
    ( (This)->lpVtbl -> LogEx(This,lMethodId,lFlags,lResID,lDetail,bstrText) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IWiaLogEx_INTERFACE_DEFINED__ */


#ifndef __IWiaNotifyDevMgr_INTERFACE_DEFINED__
#define __IWiaNotifyDevMgr_INTERFACE_DEFINED__

/* interface IWiaNotifyDevMgr */
/* [unique][helpstring][uuid][object] */ 


EXTERN_C const IID IID_IWiaNotifyDevMgr;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("70681EA0-E7BF-4291-9FB1-4E8813A3F78E")
    IWiaNotifyDevMgr : public IUnknown
    {
    public:
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE NewDeviceArrival( void) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IWiaNotifyDevMgrVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IWiaNotifyDevMgr * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IWiaNotifyDevMgr * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IWiaNotifyDevMgr * This);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *NewDeviceArrival )( 
            IWiaNotifyDevMgr * This);
        
        END_INTERFACE
    } IWiaNotifyDevMgrVtbl;

    interface IWiaNotifyDevMgr
    {
        CONST_VTBL struct IWiaNotifyDevMgrVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IWiaNotifyDevMgr_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IWiaNotifyDevMgr_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IWiaNotifyDevMgr_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IWiaNotifyDevMgr_NewDeviceArrival(This)	\
    ( (This)->lpVtbl -> NewDeviceArrival(This) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IWiaNotifyDevMgr_INTERFACE_DEFINED__ */


#ifndef __IWiaItemExtras_INTERFACE_DEFINED__
#define __IWiaItemExtras_INTERFACE_DEFINED__

/* interface IWiaItemExtras */
/* [unique][helpstring][uuid][object] */ 


EXTERN_C const IID IID_IWiaItemExtras;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("6291ef2c-36ef-4532-876a-8e132593778d")
    IWiaItemExtras : public IUnknown
    {
    public:
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE GetExtendedErrorInfo( 
            /* [out] */ __RPC__deref_out_opt BSTR *bstrErrorText) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE Escape( 
            /* [in] */ DWORD dwEscapeCode,
            /* [size_is][in] */ __RPC__in_ecount_full(cbInDataSize) BYTE *lpInData,
            /* [in] */ DWORD cbInDataSize,
            /* [length_is][size_is][out] */ __RPC__out_ecount_part(dwOutDataSize, pdwActualDataSize ? *pdwActualDataSize : dwOutDataSize) BYTE *pOutData,
            /* [in] */ DWORD dwOutDataSize,
            /* [out] */ __RPC__out DWORD *pdwActualDataSize) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE CancelPendingIO( void) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IWiaItemExtrasVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IWiaItemExtras * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IWiaItemExtras * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IWiaItemExtras * This);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *GetExtendedErrorInfo )( 
            IWiaItemExtras * This,
            /* [out] */ __RPC__deref_out_opt BSTR *bstrErrorText);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *Escape )( 
            IWiaItemExtras * This,
            /* [in] */ DWORD dwEscapeCode,
            /* [size_is][in] */ __RPC__in_ecount_full(cbInDataSize) BYTE *lpInData,
            /* [in] */ DWORD cbInDataSize,
            /* [length_is][size_is][out] */ __RPC__out_ecount_part(dwOutDataSize, pdwActualDataSize ? *pdwActualDataSize : dwOutDataSize) BYTE *pOutData,
            /* [in] */ DWORD dwOutDataSize,
            /* [out] */ __RPC__out DWORD *pdwActualDataSize);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *CancelPendingIO )( 
            IWiaItemExtras * This);
        
        END_INTERFACE
    } IWiaItemExtrasVtbl;

    interface IWiaItemExtras
    {
        CONST_VTBL struct IWiaItemExtrasVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IWiaItemExtras_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IWiaItemExtras_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IWiaItemExtras_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IWiaItemExtras_GetExtendedErrorInfo(This,bstrErrorText)	\
    ( (This)->lpVtbl -> GetExtendedErrorInfo(This,bstrErrorText) ) 

#define IWiaItemExtras_Escape(This,dwEscapeCode,lpInData,cbInDataSize,pOutData,dwOutDataSize,pdwActualDataSize)	\
    ( (This)->lpVtbl -> Escape(This,dwEscapeCode,lpInData,cbInDataSize,pOutData,dwOutDataSize,pdwActualDataSize) ) 

#define IWiaItemExtras_CancelPendingIO(This)	\
    ( (This)->lpVtbl -> CancelPendingIO(This) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IWiaItemExtras_INTERFACE_DEFINED__ */



#ifndef __WiaDevMgr_LIBRARY_DEFINED__
#define __WiaDevMgr_LIBRARY_DEFINED__

/* library WiaDevMgr */
/* [helpstring][version][uuid] */ 


EXTERN_C const IID LIBID_WiaDevMgr;

EXTERN_C const CLSID CLSID_WiaDevMgr;

#ifdef __cplusplus

class DECLSPEC_UUID("a1f4e726-8cf1-11d1-bf92-0060081ed811")
WiaDevMgr;
#endif

EXTERN_C const CLSID CLSID_WiaLog;

#ifdef __cplusplus

class DECLSPEC_UUID("A1E75357-881A-419e-83E2-BB16DB197C68")
WiaLog;
#endif
#endif /* __WiaDevMgr_LIBRARY_DEFINED__ */

/* Additional Prototypes for ALL interfaces */

unsigned long             __RPC_USER  BSTR_UserSize(     unsigned long *, unsigned long            , BSTR * ); 
unsigned char * __RPC_USER  BSTR_UserMarshal(  unsigned long *, unsigned char *, BSTR * ); 
unsigned char * __RPC_USER  BSTR_UserUnmarshal(unsigned long *, unsigned char *, BSTR * ); 
void                      __RPC_USER  BSTR_UserFree(     unsigned long *, BSTR * ); 

unsigned long             __RPC_USER  HWND_UserSize(     unsigned long *, unsigned long            , HWND * ); 
unsigned char * __RPC_USER  HWND_UserMarshal(  unsigned long *, unsigned char *, HWND * ); 
unsigned char * __RPC_USER  HWND_UserUnmarshal(unsigned long *, unsigned char *, HWND * ); 
void                      __RPC_USER  HWND_UserFree(     unsigned long *, HWND * ); 

unsigned long             __RPC_USER  LPSAFEARRAY_UserSize(     unsigned long *, unsigned long            , LPSAFEARRAY * ); 
unsigned char * __RPC_USER  LPSAFEARRAY_UserMarshal(  unsigned long *, unsigned char *, LPSAFEARRAY * ); 
unsigned char * __RPC_USER  LPSAFEARRAY_UserUnmarshal(unsigned long *, unsigned char *, LPSAFEARRAY * ); 
void                      __RPC_USER  LPSAFEARRAY_UserFree(     unsigned long *, LPSAFEARRAY * ); 

unsigned long             __RPC_USER  STGMEDIUM_UserSize(     unsigned long *, unsigned long            , STGMEDIUM * ); 
unsigned char * __RPC_USER  STGMEDIUM_UserMarshal(  unsigned long *, unsigned char *, STGMEDIUM * ); 
unsigned char * __RPC_USER  STGMEDIUM_UserUnmarshal(unsigned long *, unsigned char *, STGMEDIUM * ); 
void                      __RPC_USER  STGMEDIUM_UserFree(     unsigned long *, STGMEDIUM * ); 

unsigned long             __RPC_USER  BSTR_UserSize64(     unsigned long *, unsigned long            , BSTR * ); 
unsigned char * __RPC_USER  BSTR_UserMarshal64(  unsigned long *, unsigned char *, BSTR * ); 
unsigned char * __RPC_USER  BSTR_UserUnmarshal64(unsigned long *, unsigned char *, BSTR * ); 
void                      __RPC_USER  BSTR_UserFree64(     unsigned long *, BSTR * ); 

unsigned long             __RPC_USER  HWND_UserSize64(     unsigned long *, unsigned long            , HWND * ); 
unsigned char * __RPC_USER  HWND_UserMarshal64(  unsigned long *, unsigned char *, HWND * ); 
unsigned char * __RPC_USER  HWND_UserUnmarshal64(unsigned long *, unsigned char *, HWND * ); 
void                      __RPC_USER  HWND_UserFree64(     unsigned long *, HWND * ); 

unsigned long             __RPC_USER  LPSAFEARRAY_UserSize64(     unsigned long *, unsigned long            , LPSAFEARRAY * ); 
unsigned char * __RPC_USER  LPSAFEARRAY_UserMarshal64(  unsigned long *, unsigned char *, LPSAFEARRAY * ); 
unsigned char * __RPC_USER  LPSAFEARRAY_UserUnmarshal64(unsigned long *, unsigned char *, LPSAFEARRAY * ); 
void                      __RPC_USER  LPSAFEARRAY_UserFree64(     unsigned long *, LPSAFEARRAY * ); 

unsigned long             __RPC_USER  STGMEDIUM_UserSize64(     unsigned long *, unsigned long            , STGMEDIUM * ); 
unsigned char * __RPC_USER  STGMEDIUM_UserMarshal64(  unsigned long *, unsigned char *, STGMEDIUM * ); 
unsigned char * __RPC_USER  STGMEDIUM_UserUnmarshal64(unsigned long *, unsigned char *, STGMEDIUM * ); 
void                      __RPC_USER  STGMEDIUM_UserFree64(     unsigned long *, STGMEDIUM * ); 

/* [local] */ HRESULT STDMETHODCALLTYPE IWiaDevMgr_CreateDevice_Proxy( 
    IWiaDevMgr * This,
    /* [in] */ BSTR bstrDeviceID,
    /* [out] */ IWiaItem **ppWiaItemRoot);


/* [helpstring][call_as] */ HRESULT STDMETHODCALLTYPE IWiaDevMgr_CreateDevice_Stub( 
    IWiaDevMgr * This,
    /* [in] */ __RPC__in BSTR bstrDeviceID,
    /* [out] */ __RPC__deref_out_opt IWiaItem **ppWiaItemRoot);

/* [local] */ HRESULT STDMETHODCALLTYPE IWiaDevMgr_SelectDeviceDlg_Proxy( 
    IWiaDevMgr * This,
    /* [in] */ HWND hwndParent,
    /* [in] */ LONG lDeviceType,
    /* [in] */ LONG lFlags,
    /* [out][in] */ BSTR *pbstrDeviceID,
    /* [retval][out] */ IWiaItem **ppItemRoot);


/* [nocode][helpstring][call_as] */ HRESULT STDMETHODCALLTYPE IWiaDevMgr_SelectDeviceDlg_Stub( 
    IWiaDevMgr * This,
    /* [in] */ __RPC__in HWND hwndParent,
    /* [in] */ LONG lDeviceType,
    /* [in] */ LONG lFlags,
    /* [out][in] */ __RPC__deref_inout_opt BSTR *pbstrDeviceID,
    /* [retval][out] */ __RPC__deref_out_opt IWiaItem **ppItemRoot);

/* [local] */ HRESULT STDMETHODCALLTYPE IWiaDevMgr_SelectDeviceDlgID_Proxy( 
    IWiaDevMgr * This,
    /* [in] */ HWND hwndParent,
    /* [in] */ LONG lDeviceType,
    /* [in] */ LONG lFlags,
    /* [retval][out] */ BSTR *pbstrDeviceID);


/* [nocode][helpstring][call_as] */ HRESULT STDMETHODCALLTYPE IWiaDevMgr_SelectDeviceDlgID_Stub( 
    IWiaDevMgr * This,
    /* [in] */ __RPC__in HWND hwndParent,
    /* [in] */ LONG lDeviceType,
    /* [in] */ LONG lFlags,
    /* [retval][out] */ __RPC__deref_out_opt BSTR *pbstrDeviceID);

/* [local] */ HRESULT STDMETHODCALLTYPE IWiaDevMgr_GetImageDlg_Proxy( 
    IWiaDevMgr * This,
    /* [in] */ HWND hwndParent,
    /* [in] */ LONG lDeviceType,
    /* [in] */ LONG lFlags,
    /* [in] */ LONG lIntent,
    /* [in] */ IWiaItem *pItemRoot,
    /* [in] */ BSTR bstrFilename,
    /* [out][in] */ GUID *pguidFormat);


/* [nocode][helpstring][call_as] */ HRESULT STDMETHODCALLTYPE IWiaDevMgr_GetImageDlg_Stub( 
    IWiaDevMgr * This,
    /* [in] */ __RPC__in HWND hwndParent,
    /* [in] */ LONG lDeviceType,
    /* [in] */ LONG lFlags,
    /* [in] */ LONG lIntent,
    /* [in] */ __RPC__in_opt IWiaItem *pItemRoot,
    /* [in] */ __RPC__in BSTR bstrFilename,
    /* [out][in] */ __RPC__inout GUID *pguidFormat);

/* [local] */ HRESULT STDMETHODCALLTYPE IWiaDevMgr_RegisterEventCallbackProgram_Proxy( 
    IWiaDevMgr * This,
    /* [in] */ LONG lFlags,
    /* [in] */ BSTR bstrDeviceID,
    /* [in] */ const GUID *pEventGUID,
    /* [in] */ BSTR bstrCommandline,
    /* [in] */ BSTR bstrName,
    /* [in] */ BSTR bstrDescription,
    /* [in] */ BSTR bstrIcon);


/* [helpstring][call_as] */ HRESULT STDMETHODCALLTYPE IWiaDevMgr_RegisterEventCallbackProgram_Stub( 
    IWiaDevMgr * This,
    /* [in] */ LONG lFlags,
    /* [in] */ __RPC__in BSTR bstrDeviceID,
    /* [in] */ __RPC__in const GUID *pEventGUID,
    /* [in] */ __RPC__in BSTR bstrCommandline,
    /* [in] */ __RPC__in BSTR bstrName,
    /* [in] */ __RPC__in BSTR bstrDescription,
    /* [in] */ __RPC__in BSTR bstrIcon);

/* [local] */ HRESULT STDMETHODCALLTYPE IWiaDevMgr_RegisterEventCallbackInterface_Proxy( 
    IWiaDevMgr * This,
    /* [in] */ LONG lFlags,
    /* [in] */ BSTR bstrDeviceID,
    /* [in] */ const GUID *pEventGUID,
    /* [unique][in] */ IWiaEventCallback *pIWiaEventCallback,
    /* [out] */ IUnknown **pEventObject);


/* [helpstring][call_as] */ HRESULT STDMETHODCALLTYPE IWiaDevMgr_RegisterEventCallbackInterface_Stub( 
    IWiaDevMgr * This,
    /* [in] */ LONG lFlags,
    /* [in] */ __RPC__in BSTR bstrDeviceID,
    /* [in] */ __RPC__in const GUID *pEventGUID,
    /* [unique][in] */ __RPC__in_opt IWiaEventCallback *pIWiaEventCallback,
    /* [out] */ __RPC__deref_out_opt IUnknown **pEventObject);

/* [local] */ HRESULT STDMETHODCALLTYPE IWiaDevMgr_RegisterEventCallbackCLSID_Proxy( 
    IWiaDevMgr * This,
    /* [in] */ LONG lFlags,
    /* [in] */ BSTR bstrDeviceID,
    /* [in] */ const GUID *pEventGUID,
    /* [unique][in] */ const GUID *pClsID,
    /* [in] */ BSTR bstrName,
    /* [in] */ BSTR bstrDescription,
    /* [in] */ BSTR bstrIcon);


/* [helpstring][call_as] */ HRESULT STDMETHODCALLTYPE IWiaDevMgr_RegisterEventCallbackCLSID_Stub( 
    IWiaDevMgr * This,
    /* [in] */ LONG lFlags,
    /* [in] */ __RPC__in BSTR bstrDeviceID,
    /* [in] */ __RPC__in const GUID *pEventGUID,
    /* [unique][in] */ __RPC__in_opt const GUID *pClsID,
    /* [in] */ __RPC__in BSTR bstrName,
    /* [in] */ __RPC__in BSTR bstrDescription,
    /* [in] */ __RPC__in BSTR bstrIcon);

/* [local] */ HRESULT STDMETHODCALLTYPE IEnumWIA_DEV_INFO_Next_Proxy( 
    IEnumWIA_DEV_INFO * This,
    /* [in] */ ULONG celt,
    /* [length_is][size_is][out] */ IWiaPropertyStorage **rgelt,
    /* [unique][out][in] */ ULONG *pceltFetched);


/* [helpstring][call_as] */ HRESULT STDMETHODCALLTYPE IEnumWIA_DEV_INFO_Next_Stub( 
    IEnumWIA_DEV_INFO * This,
    /* [in] */ ULONG celt,
    /* [length_is][size_is][out] */ __RPC__out_ecount_part(celt, *pceltFetched) IWiaPropertyStorage **rgelt,
    /* [unique][out][in] */ __RPC__inout_opt ULONG *pceltFetched);

/* [local] */ HRESULT STDMETHODCALLTYPE IWiaDataCallback_BandedDataCallback_Proxy( 
    IWiaDataCallback * This,
    /* [in] */ LONG lMessage,
    /* [in] */ LONG lStatus,
    /* [in] */ LONG lPercentComplete,
    /* [in] */ LONG lOffset,
    /* [in] */ LONG lLength,
    /* [in] */ LONG lReserved,
    /* [in] */ LONG lResLength,
    /* [size_is][in] */ BYTE *pbBuffer);


/* [helpstring][call_as] */ HRESULT STDMETHODCALLTYPE IWiaDataCallback_BandedDataCallback_Stub( 
    IWiaDataCallback * This,
    /* [in] */ LONG lMessage,
    /* [in] */ LONG lStatus,
    /* [in] */ LONG lPercentComplete,
    /* [in] */ LONG lOffset,
    /* [in] */ LONG lLength,
    /* [in] */ LONG lReserved,
    /* [in] */ LONG lResLength,
    /* [unique][size_is][in] */ __RPC__in_ecount_full_opt(lResLength) BYTE *pbBuffer);

/* [local] */ HRESULT STDMETHODCALLTYPE IWiaDataTransfer_idtGetData_Proxy( 
    IWiaDataTransfer * This,
    /* [out][in] */ LPSTGMEDIUM pMedium,
    /* [unique][in] */ IWiaDataCallback *pIWiaDataCallback);


/* [helpstring][call_as] */ HRESULT STDMETHODCALLTYPE IWiaDataTransfer_idtGetData_Stub( 
    IWiaDataTransfer * This,
    /* [out][in] */ __RPC__inout LPSTGMEDIUM pMedium,
    /* [unique][in] */ __RPC__in_opt IWiaDataCallback *pIWiaDataCallback);

/* [local] */ HRESULT STDMETHODCALLTYPE IWiaDataTransfer_idtGetBandedData_Proxy( 
    IWiaDataTransfer * This,
    /* [unique][in] */ PWIA_DATA_TRANSFER_INFO pWiaDataTransInfo,
    /* [unique][in] */ IWiaDataCallback *pIWiaDataCallback);


/* [helpstring][call_as] */ HRESULT STDMETHODCALLTYPE IWiaDataTransfer_idtGetBandedData_Stub( 
    IWiaDataTransfer * This,
    /* [unique][in] */ __RPC__in_opt PWIA_DATA_TRANSFER_INFO pWiaDataTransInfo,
    /* [unique][in] */ __RPC__in_opt IWiaDataCallback *pIWiaDataCallback);

/* [local] */ HRESULT STDMETHODCALLTYPE IWiaItem_DeviceDlg_Proxy( 
    IWiaItem * This,
    /* [in] */ HWND hwndParent,
    /* [in] */ LONG lFlags,
    /* [in] */ LONG lIntent,
    /* [out] */ LONG *plItemCount,
    /* [out] */ IWiaItem ***ppIWiaItem);


/* [nocode][helpstring][call_as] */ HRESULT STDMETHODCALLTYPE IWiaItem_DeviceDlg_Stub( 
    IWiaItem * This,
    /* [in] */ __RPC__in HWND hwndParent,
    /* [in] */ LONG lFlags,
    /* [in] */ LONG lIntent,
    /* [out] */ __RPC__out LONG *plItemCount,
    /* [out] */ __RPC__deref_out_opt IWiaItem ***pIWiaItem);

/* [local] */ HRESULT STDMETHODCALLTYPE IWiaPropertyStorage_WriteMultiple_Proxy( 
    IWiaPropertyStorage * This,
    /* [in] */ ULONG cpspec,
    /* [size_is][in] */ const PROPSPEC rgpspec[  ],
    /* [size_is][in] */ const PROPVARIANT rgpropvar[  ],
    /* [in] */ PROPID propidNameFirst);


/* [call_as] */ HRESULT STDMETHODCALLTYPE IWiaPropertyStorage_WriteMultiple_Stub( 
    IWiaPropertyStorage * This,
    /* [in] */ ULONG cpspec,
    /* [size_is][in] */ __RPC__in_ecount_full(cpspec) const PROPSPEC *rgpspec,
    /* [size_is][in] */ __RPC__in_ecount_full(cpspec) const PROPVARIANT *rgpropvar,
    /* [in] */ PROPID propidNameFirst);

/* [local] */ HRESULT STDMETHODCALLTYPE IWiaPropertyStorage_SetPropertyStream_Proxy( 
    IWiaPropertyStorage * This,
    /* [in] */ GUID *pCompatibilityId,
    /* [unique][in] */ IStream *pIStream);


/* [helpstring][call_as] */ HRESULT STDMETHODCALLTYPE IWiaPropertyStorage_SetPropertyStream_Stub( 
    IWiaPropertyStorage * This,
    /* [in] */ __RPC__in GUID *pCompatibilityId,
    /* [unique][in] */ __RPC__in_opt IStream *pIStream);

/* [local] */ HRESULT STDMETHODCALLTYPE IEnumWiaItem_Next_Proxy( 
    IEnumWiaItem * This,
    /* [in] */ ULONG celt,
    /* [length_is][size_is][out] */ IWiaItem **ppIWiaItem,
    /* [unique][out][in] */ ULONG *pceltFetched);


/* [helpstring][call_as] */ HRESULT STDMETHODCALLTYPE IEnumWiaItem_Next_Stub( 
    IEnumWiaItem * This,
    /* [in] */ ULONG celt,
    /* [length_is][size_is][out] */ __RPC__out_ecount_part(celt, *pceltFetched) IWiaItem **ppIWiaItem,
    /* [unique][out][in] */ __RPC__inout_opt ULONG *pceltFetched);

/* [local] */ HRESULT STDMETHODCALLTYPE IEnumWIA_DEV_CAPS_Next_Proxy( 
    IEnumWIA_DEV_CAPS * This,
    /* [in] */ ULONG celt,
    /* [length_is][size_is][out] */ WIA_DEV_CAP *rgelt,
    /* [unique][out][in] */ ULONG *pceltFetched);


/* [helpstring][call_as] */ HRESULT STDMETHODCALLTYPE IEnumWIA_DEV_CAPS_Next_Stub( 
    IEnumWIA_DEV_CAPS * This,
    /* [in] */ ULONG celt,
    /* [length_is][size_is][out] */ __RPC__out_ecount_part(celt, *pceltFetched) WIA_DEV_CAP *rgelt,
    /* [unique][out][in] */ __RPC__inout_opt ULONG *pceltFetched);

/* [local] */ HRESULT STDMETHODCALLTYPE IEnumWIA_FORMAT_INFO_Next_Proxy( 
    IEnumWIA_FORMAT_INFO * This,
    /* [in] */ ULONG celt,
    /* [length_is][size_is][out] */ WIA_FORMAT_INFO *rgelt,
    /* [unique][out][in] */ ULONG *pceltFetched);


/* [helpstring][call_as] */ HRESULT STDMETHODCALLTYPE IEnumWIA_FORMAT_INFO_Next_Stub( 
    IEnumWIA_FORMAT_INFO * This,
    /* [in] */ ULONG celt,
    /* [length_is][size_is][out] */ __RPC__out_ecount_part(celt, *pceltFetched) WIA_FORMAT_INFO *rgelt,
    /* [unique][out][in] */ __RPC__inout_opt ULONG *pceltFetched);



/* end of Additional Prototypes */

#ifdef __cplusplus
}
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\win2k8\ddk\inc\WindowsSideShowClassExtension.h ===
/* this ALWAYS GENERATED file contains the definitions for the interfaces */


 /* File created by MIDL compiler version 7.00.0499 */
/* Compiler settings for windowssideshowclassextension.idl:
    Oicf, W1, Zp8, env=Win32 (32b run)
    protocol : dce , ms_ext, c_ext, robust
    error checks: allocation ref bounds_check enum stub_data 
    VC __declspec() decoration level: 
         __declspec(uuid()), __declspec(selectany), __declspec(novtable)
         DECLSPEC_UUID(), MIDL_INTERFACE()
*/
//@@MIDL_FILE_HEADING(  )

#pragma warning( disable: 4049 )  /* more than 64k source lines */


/* verify that the <rpcndr.h> version is high enough to compile this file*/
#ifndef __REQUIRED_RPCNDR_H_VERSION__
#define __REQUIRED_RPCNDR_H_VERSION__ 500
#endif

/* verify that the <rpcsal.h> version is high enough to compile this file*/
#ifndef __REQUIRED_RPCSAL_H_VERSION__
#define __REQUIRED_RPCSAL_H_VERSION__ 100
#endif

#include "rpc.h"
#include "rpcndr.h"

#ifndef __RPCNDR_H_VERSION__
#error this stub requires an updated version of <rpcndr.h>
#endif // __RPCNDR_H_VERSION__

#ifndef COM_NO_WINDOWS_H
#include "windows.h"
#include "ole2.h"
#endif /*COM_NO_WINDOWS_H*/

#ifndef __windowssideshowclassextension_h__
#define __windowssideshowclassextension_h__

#if defined(_MSC_VER) && (_MSC_VER >= 1020)
#pragma once
#endif

/* Forward Declarations */ 

#ifndef __ISideShowDriver_FWD_DEFINED__
#define __ISideShowDriver_FWD_DEFINED__
typedef interface ISideShowDriver ISideShowDriver;
#endif 	/* __ISideShowDriver_FWD_DEFINED__ */


#ifndef __ISideShowClassExtension_FWD_DEFINED__
#define __ISideShowClassExtension_FWD_DEFINED__
typedef interface ISideShowClassExtension ISideShowClassExtension;
#endif 	/* __ISideShowClassExtension_FWD_DEFINED__ */


#ifndef __SideShowClassExtension_FWD_DEFINED__
#define __SideShowClassExtension_FWD_DEFINED__

#ifdef __cplusplus
typedef class SideShowClassExtension SideShowClassExtension;
#else
typedef struct SideShowClassExtension SideShowClassExtension;
#endif /* __cplusplus */

#endif 	/* __SideShowClassExtension_FWD_DEFINED__ */


/* header files for imported files */
#include "propidl.h"
#include "wudfddi.h"

#ifdef __cplusplus
extern "C"{
#endif 


/* interface __MIDL_itf_windowssideshowclassextension_0000_0000 */
/* [local] */ 

#if (_WIN32_WINNT >= 0x0600) // Windows Vista and later
typedef struct _SIDESHOW_TIME_ZONE_INFORMATION
    {
    LONG Bias;
    WCHAR StandardName[ 32 ];
    SYSTEMTIME StandardDate;
    LONG StandardBias;
    WCHAR DaylightName[ 32 ];
    SYSTEMTIME DaylightDate;
    LONG DaylightBias;
    } 	SIDESHOW_TIME_ZONE_INFORMATION;

typedef 
enum tagUSER_STATE
    {	AVAILABLE	= 0,
	UNAVAILABLE	= 1
    } 	USER_STATE;

typedef GUID APPLICATION_ID;

typedef GUID ENDPOINT_ID;

typedef LPWSTR DEVICE_ID;

typedef REFGUID REFAPPLICATION_ID;

typedef REFGUID REFENDPOINT_ID;

typedef ENDPOINT_ID *PENDPOINT_ID;

typedef APPLICATION_ID *PAPPLICATION_ID;

typedef DEVICE_ID *PDEVICE_ID;

typedef unsigned long CONTENT_ID;

typedef CONTENT_ID *PCONTENT_ID;

typedef unsigned long NOTIFICATION_ID;

typedef NOTIFICATION_ID *PNOTIFICATION_ID;



extern RPC_IF_HANDLE __MIDL_itf_windowssideshowclassextension_0000_0000_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_windowssideshowclassextension_0000_0000_v0_0_s_ifspec;

#ifndef __ISideShowDriver_INTERFACE_DEFINED__
#define __ISideShowDriver_INTERFACE_DEFINED__

/* interface ISideShowDriver */
/* [unique][helpstring][uuid][object] */ 


EXTERN_C const IID IID_ISideShowDriver;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("2082260d-0e28-4c57-b5c2-67fa091daa91")
    ISideShowDriver : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE OnGetDeviceName( 
            /* [string][out] */ __RPC__deref_out_opt_string LPWSTR *ppwszName) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE OnGetDeviceManufacturer( 
            /* [string][out] */ __RPC__deref_out_opt_string LPWSTR *ppwszManufacturer) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE OnGetDeviceFirmwareVersion( 
            /* [string][out] */ __RPC__deref_out_opt_string LPWSTR *ppwszVersion) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE OnSetTime( 
            /* [in] */ const FILETIME FileTime) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE OnSetTimeZone( 
            /* [in] */ __RPC__in const SIDESHOW_TIME_ZONE_INFORMATION *pTimeZoneInformation) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE OnSetCurrentUser( 
            /* [in] */ __RPC__in const SID *pUserSid) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE OnGetCurrentUser( 
            /* [out] */ __RPC__deref_out_opt SID **ppUserSid) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE OnSetUserState( 
            /* [in] */ __RPC__in const SID *pUserSid,
            /* [in] */ const USER_STATE state) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE OnSetShortDateFormat( 
            /* [in] */ __RPC__in const SID *pUserSid,
            /* [string][in] */ __RPC__in LPCWSTR pwszDateFormat) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE OnSetLongDateFormat( 
            /* [in] */ __RPC__in const SID *pUserSid,
            /* [string][in] */ __RPC__in LPCWSTR pwszDateFormat) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE OnSetShortTimeFormat( 
            /* [in] */ __RPC__in const SID *pUserSid,
            /* [string][in] */ __RPC__in LPCWSTR pwszTimeFormat) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE OnSetLongTimeFormat( 
            /* [in] */ __RPC__in const SID *pUserSid,
            /* [string][in] */ __RPC__in LPCWSTR pwszTimeFormat) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE OnSetLanguage( 
            /* [in] */ __RPC__in const SID *pUserSid,
            /* [in] */ __RPC__in LPCWSTR pwszLanguage) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE OnGetDeviceEndpoints( 
            /* [size_is][size_is][out] */ __RPC__deref_out_ecount_full_opt(*pcEndpoints) ENDPOINT_ID **rgEndpoints,
            /* [out] */ __RPC__out DWORD *pcEndpoints) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE OnGetDeviceCapabilities( 
            /* [in] */ __RPC__in const PROPERTYKEY *pKey,
            /* [out] */ __RPC__out PROPVARIANT *pvValue) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE OnGetPreEnabledApplications( 
            /* [size_is][size_is][out] */ __RPC__deref_out_ecount_full_opt(*pcApplications) APPLICATION_ID **ppApplicationIds,
            /* [size_is][size_is][out] */ __RPC__deref_out_ecount_full_opt(*pcApplications) ENDPOINT_ID **ppEndpointIds,
            /* [out] */ __RPC__out DWORD *pcApplications) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE OnSetApplicationOrder( 
            /* [size_is][in] */ __RPC__in_ecount_full(cApplicationIds) const APPLICATION_ID *pApplicationIds,
            /* [in] */ const DWORD cApplicationIds) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE OnGetApplicationOrder( 
            /* [size_is][size_is][out] */ __RPC__deref_out_ecount_full_opt(*pcApplicationIds) APPLICATION_ID **ppApplicationIds,
            /* [out] */ __RPC__out DWORD *pcApplicationIds) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE OnAddApplication( 
            /* [in] */ __RPC__in const SID *pUserSid,
            /* [in] */ __RPC__in REFAPPLICATION_ID ApplicationId,
            /* [in] */ __RPC__in REFENDPOINT_ID EndPointId,
            /* [string][in] */ __RPC__in LPCWSTR pcwszName,
            /* [in] */ const DWORD dwCachePolicy,
            /* [in] */ const DWORD dwOnlineOnly,
            /* [size_is][in] */ __RPC__in_ecount_full(cbLargeIcon) const unsigned char *pbLargeIcon,
            /* [in] */ const DWORD cbLargeIcon,
            /* [size_is][in] */ __RPC__in_ecount_full(cbMediumIcon) const unsigned char *pbMediumIcon,
            /* [in] */ const DWORD cbMediumIcon,
            /* [size_is][in] */ __RPC__in_ecount_full(cbSmallIcon) const unsigned char *pbSmallIcon,
            /* [in] */ const DWORD cbSmallIcon) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE OnRemoveApplication( 
            /* [in] */ __RPC__in const SID *pUserSid,
            /* [in] */ __RPC__in REFAPPLICATION_ID ApplicationId) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE OnRemoveAllApplications( 
            /* [in] */ __RPC__in const SID *pUserSid) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE OnAddContent( 
            /* [in] */ __RPC__in const SID *pUserSid,
            /* [in] */ __RPC__in REFAPPLICATION_ID ApplicationId,
            /* [in] */ __RPC__in REFENDPOINT_ID EndpointId,
            /* [in] */ const CONTENT_ID ContentId,
            /* [size_is][in] */ __RPC__in_ecount_full(cbData) const unsigned char *pData,
            /* [in] */ const DWORD cbData) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE OnRemoveContent( 
            /* [in] */ __RPC__in const SID *pUserSid,
            /* [in] */ __RPC__in REFAPPLICATION_ID ApplicationId,
            /* [in] */ __RPC__in REFENDPOINT_ID EndpointId,
            /* [in] */ const CONTENT_ID ContentId) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE OnRemoveAllContent( 
            /* [in] */ __RPC__in const SID *pUserSid,
            /* [in] */ __RPC__in REFAPPLICATION_ID ApplicationId,
            /* [in] */ __RPC__in REFENDPOINT_ID EndpointId) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE OnAddNotification( 
            /* [in] */ __RPC__in const SID *pUserSid,
            /* [in] */ __RPC__in REFAPPLICATION_ID ApplicationId,
            /* [in] */ const NOTIFICATION_ID NotificationId,
            /* [in] */ const FILETIME ftExpiration,
            /* [string][in] */ __RPC__in LPCWSTR pcwszTitle,
            /* [string][in] */ __RPC__in LPCWSTR pcwszMessage,
            /* [size_is][in] */ __RPC__in_ecount_full(cbImage) const unsigned char *pbImage,
            /* [in] */ const DWORD cbImage) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE OnRemoveNotification( 
            /* [in] */ __RPC__in const SID *pUserSid,
            /* [in] */ __RPC__in REFAPPLICATION_ID ApplicationId,
            /* [in] */ const NOTIFICATION_ID NotificationId) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE OnRemoveAllNotifications( 
            /* [in] */ __RPC__in const SID *pUserSid,
            /* [in] */ __RPC__in REFAPPLICATION_ID ApplicationId) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE OnSetNotificationsEnabled( 
            /* [in] */ __RPC__in const SID *pUserSid,
            /* [in] */ const BOOL fIsEnabled) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE OnProcessWpdMessage( 
            /* [in] */ __RPC__in_opt IUnknown *pPortableDeviceValuesParams,
            /* [in] */ __RPC__in_opt IUnknown *pPortableDeviceValuesResults) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct ISideShowDriverVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            ISideShowDriver * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            ISideShowDriver * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            ISideShowDriver * This);
        
        HRESULT ( STDMETHODCALLTYPE *OnGetDeviceName )( 
            ISideShowDriver * This,
            /* [string][out] */ __RPC__deref_out_opt_string LPWSTR *ppwszName);
        
        HRESULT ( STDMETHODCALLTYPE *OnGetDeviceManufacturer )( 
            ISideShowDriver * This,
            /* [string][out] */ __RPC__deref_out_opt_string LPWSTR *ppwszManufacturer);
        
        HRESULT ( STDMETHODCALLTYPE *OnGetDeviceFirmwareVersion )( 
            ISideShowDriver * This,
            /* [string][out] */ __RPC__deref_out_opt_string LPWSTR *ppwszVersion);
        
        HRESULT ( STDMETHODCALLTYPE *OnSetTime )( 
            ISideShowDriver * This,
            /* [in] */ const FILETIME FileTime);
        
        HRESULT ( STDMETHODCALLTYPE *OnSetTimeZone )( 
            ISideShowDriver * This,
            /* [in] */ __RPC__in const SIDESHOW_TIME_ZONE_INFORMATION *pTimeZoneInformation);
        
        HRESULT ( STDMETHODCALLTYPE *OnSetCurrentUser )( 
            ISideShowDriver * This,
            /* [in] */ __RPC__in const SID *pUserSid);
        
        HRESULT ( STDMETHODCALLTYPE *OnGetCurrentUser )( 
            ISideShowDriver * This,
            /* [out] */ __RPC__deref_out_opt SID **ppUserSid);
        
        HRESULT ( STDMETHODCALLTYPE *OnSetUserState )( 
            ISideShowDriver * This,
            /* [in] */ __RPC__in const SID *pUserSid,
            /* [in] */ const USER_STATE state);
        
        HRESULT ( STDMETHODCALLTYPE *OnSetShortDateFormat )( 
            ISideShowDriver * This,
            /* [in] */ __RPC__in const SID *pUserSid,
            /* [string][in] */ __RPC__in LPCWSTR pwszDateFormat);
        
        HRESULT ( STDMETHODCALLTYPE *OnSetLongDateFormat )( 
            ISideShowDriver * This,
            /* [in] */ __RPC__in const SID *pUserSid,
            /* [string][in] */ __RPC__in LPCWSTR pwszDateFormat);
        
        HRESULT ( STDMETHODCALLTYPE *OnSetShortTimeFormat )( 
            ISideShowDriver * This,
            /* [in] */ __RPC__in const SID *pUserSid,
            /* [string][in] */ __RPC__in LPCWSTR pwszTimeFormat);
        
        HRESULT ( STDMETHODCALLTYPE *OnSetLongTimeFormat )( 
            ISideShowDriver * This,
            /* [in] */ __RPC__in const SID *pUserSid,
            /* [string][in] */ __RPC__in LPCWSTR pwszTimeFormat);
        
        HRESULT ( STDMETHODCALLTYPE *OnSetLanguage )( 
            ISideShowDriver * This,
            /* [in] */ __RPC__in const SID *pUserSid,
            /* [in] */ __RPC__in LPCWSTR pwszLanguage);
        
        HRESULT ( STDMETHODCALLTYPE *OnGetDeviceEndpoints )( 
            ISideShowDriver * This,
            /* [size_is][size_is][out] */ __RPC__deref_out_ecount_full_opt(*pcEndpoints) ENDPOINT_ID **rgEndpoints,
            /* [out] */ __RPC__out DWORD *pcEndpoints);
        
        HRESULT ( STDMETHODCALLTYPE *OnGetDeviceCapabilities )( 
            ISideShowDriver * This,
            /* [in] */ __RPC__in const PROPERTYKEY *pKey,
            /* [out] */ __RPC__out PROPVARIANT *pvValue);
        
        HRESULT ( STDMETHODCALLTYPE *OnGetPreEnabledApplications )( 
            ISideShowDriver * This,
            /* [size_is][size_is][out] */ __RPC__deref_out_ecount_full_opt(*pcApplications) APPLICATION_ID **ppApplicationIds,
            /* [size_is][size_is][out] */ __RPC__deref_out_ecount_full_opt(*pcApplications) ENDPOINT_ID **ppEndpointIds,
            /* [out] */ __RPC__out DWORD *pcApplications);
        
        HRESULT ( STDMETHODCALLTYPE *OnSetApplicationOrder )( 
            ISideShowDriver * This,
            /* [size_is][in] */ __RPC__in_ecount_full(cApplicationIds) const APPLICATION_ID *pApplicationIds,
            /* [in] */ const DWORD cApplicationIds);
        
        HRESULT ( STDMETHODCALLTYPE *OnGetApplicationOrder )( 
            ISideShowDriver * This,
            /* [size_is][size_is][out] */ __RPC__deref_out_ecount_full_opt(*pcApplicationIds) APPLICATION_ID **ppApplicationIds,
            /* [out] */ __RPC__out DWORD *pcApplicationIds);
        
        HRESULT ( STDMETHODCALLTYPE *OnAddApplication )( 
            ISideShowDriver * This,
            /* [in] */ __RPC__in const SID *pUserSid,
            /* [in] */ __RPC__in REFAPPLICATION_ID ApplicationId,
            /* [in] */ __RPC__in REFENDPOINT_ID EndPointId,
            /* [string][in] */ __RPC__in LPCWSTR pcwszName,
            /* [in] */ const DWORD dwCachePolicy,
            /* [in] */ const DWORD dwOnlineOnly,
            /* [size_is][in] */ __RPC__in_ecount_full(cbLargeIcon) const unsigned char *pbLargeIcon,
            /* [in] */ const DWORD cbLargeIcon,
            /* [size_is][in] */ __RPC__in_ecount_full(cbMediumIcon) const unsigned char *pbMediumIcon,
            /* [in] */ const DWORD cbMediumIcon,
            /* [size_is][in] */ __RPC__in_ecount_full(cbSmallIcon) const unsigned char *pbSmallIcon,
            /* [in] */ const DWORD cbSmallIcon);
        
        HRESULT ( STDMETHODCALLTYPE *OnRemoveApplication )( 
            ISideShowDriver * This,
            /* [in] */ __RPC__in const SID *pUserSid,
            /* [in] */ __RPC__in REFAPPLICATION_ID ApplicationId);
        
        HRESULT ( STDMETHODCALLTYPE *OnRemoveAllApplications )( 
            ISideShowDriver * This,
            /* [in] */ __RPC__in const SID *pUserSid);
        
        HRESULT ( STDMETHODCALLTYPE *OnAddContent )( 
            ISideShowDriver * This,
            /* [in] */ __RPC__in const SID *pUserSid,
            /* [in] */ __RPC__in REFAPPLICATION_ID ApplicationId,
            /* [in] */ __RPC__in REFENDPOINT_ID EndpointId,
            /* [in] */ const CONTENT_ID ContentId,
            /* [size_is][in] */ __RPC__in_ecount_full(cbData) const unsigned char *pData,
            /* [in] */ const DWORD cbData);
        
        HRESULT ( STDMETHODCALLTYPE *OnRemoveContent )( 
            ISideShowDriver * This,
            /* [in] */ __RPC__in const SID *pUserSid,
            /* [in] */ __RPC__in REFAPPLICATION_ID ApplicationId,
            /* [in] */ __RPC__in REFENDPOINT_ID EndpointId,
            /* [in] */ const CONTENT_ID ContentId);
        
        HRESULT ( STDMETHODCALLTYPE *OnRemoveAllContent )( 
            ISideShowDriver * This,
            /* [in] */ __RPC__in const SID *pUserSid,
            /* [in] */ __RPC__in REFAPPLICATION_ID ApplicationId,
            /* [in] */ __RPC__in REFENDPOINT_ID EndpointId);
        
        HRESULT ( STDMETHODCALLTYPE *OnAddNotification )( 
            ISideShowDriver * This,
            /* [in] */ __RPC__in const SID *pUserSid,
            /* [in] */ __RPC__in REFAPPLICATION_ID ApplicationId,
            /* [in] */ const NOTIFICATION_ID NotificationId,
            /* [in] */ const FILETIME ftExpiration,
            /* [string][in] */ __RPC__in LPCWSTR pcwszTitle,
            /* [string][in] */ __RPC__in LPCWSTR pcwszMessage,
            /* [size_is][in] */ __RPC__in_ecount_full(cbImage) const unsigned char *pbImage,
            /* [in] */ const DWORD cbImage);
        
        HRESULT ( STDMETHODCALLTYPE *OnRemoveNotification )( 
            ISideShowDriver * This,
            /* [in] */ __RPC__in const SID *pUserSid,
            /* [in] */ __RPC__in REFAPPLICATION_ID ApplicationId,
            /* [in] */ const NOTIFICATION_ID NotificationId);
        
        HRESULT ( STDMETHODCALLTYPE *OnRemoveAllNotifications )( 
            ISideShowDriver * This,
            /* [in] */ __RPC__in const SID *pUserSid,
            /* [in] */ __RPC__in REFAPPLICATION_ID ApplicationId);
        
        HRESULT ( STDMETHODCALLTYPE *OnSetNotificationsEnabled )( 
            ISideShowDriver * This,
            /* [in] */ __RPC__in const SID *pUserSid,
            /* [in] */ const BOOL fIsEnabled);
        
        HRESULT ( STDMETHODCALLTYPE *OnProcessWpdMessage )( 
            ISideShowDriver * This,
            /* [in] */ __RPC__in_opt IUnknown *pPortableDeviceValuesParams,
            /* [in] */ __RPC__in_opt IUnknown *pPortableDeviceValuesResults);
        
        END_INTERFACE
    } ISideShowDriverVtbl;

    interface ISideShowDriver
    {
        CONST_VTBL struct ISideShowDriverVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define ISideShowDriver_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define ISideShowDriver_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define ISideShowDriver_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define ISideShowDriver_OnGetDeviceName(This,ppwszName)	\
    ( (This)->lpVtbl -> OnGetDeviceName(This,ppwszName) ) 

#define ISideShowDriver_OnGetDeviceManufacturer(This,ppwszManufacturer)	\
    ( (This)->lpVtbl -> OnGetDeviceManufacturer(This,ppwszManufacturer) ) 

#define ISideShowDriver_OnGetDeviceFirmwareVersion(This,ppwszVersion)	\
    ( (This)->lpVtbl -> OnGetDeviceFirmwareVersion(This,ppwszVersion) ) 

#define ISideShowDriver_OnSetTime(This,FileTime)	\
    ( (This)->lpVtbl -> OnSetTime(This,FileTime) ) 

#define ISideShowDriver_OnSetTimeZone(This,pTimeZoneInformation)	\
    ( (This)->lpVtbl -> OnSetTimeZone(This,pTimeZoneInformation) ) 

#define ISideShowDriver_OnSetCurrentUser(This,pUserSid)	\
    ( (This)->lpVtbl -> OnSetCurrentUser(This,pUserSid) ) 

#define ISideShowDriver_OnGetCurrentUser(This,ppUserSid)	\
    ( (This)->lpVtbl -> OnGetCurrentUser(This,ppUserSid) ) 

#define ISideShowDriver_OnSetUserState(This,pUserSid,state)	\
    ( (This)->lpVtbl -> OnSetUserState(This,pUserSid,state) ) 

#define ISideShowDriver_OnSetShortDateFormat(This,pUserSid,pwszDateFormat)	\
    ( (This)->lpVtbl -> OnSetShortDateFormat(This,pUserSid,pwszDateFormat) ) 

#define ISideShowDriver_OnSetLongDateFormat(This,pUserSid,pwszDateFormat)	\
    ( (This)->lpVtbl -> OnSetLongDateFormat(This,pUserSid,pwszDateFormat) ) 

#define ISideShowDriver_OnSetShortTimeFormat(This,pUserSid,pwszTimeFormat)	\
    ( (This)->lpVtbl -> OnSetShortTimeFormat(This,pUserSid,pwszTimeFormat) ) 

#define ISideShowDriver_OnSetLongTimeFormat(This,pUserSid,pwszTimeFormat)	\
    ( (This)->lpVtbl -> OnSetLongTimeFormat(This,pUserSid,pwszTimeFormat) ) 

#define ISideShowDriver_OnSetLanguage(This,pUserSid,pwszLanguage)	\
    ( (This)->lpVtbl -> OnSetLanguage(This,pUserSid,pwszLanguage) ) 

#define ISideShowDriver_OnGetDeviceEndpoints(This,rgEndpoints,pcEndpoints)	\
    ( (This)->lpVtbl -> OnGetDeviceEndpoints(This,rgEndpoints,pcEndpoints) ) 

#define ISideShowDriver_OnGetDeviceCapabilities(This,pKey,pvValue)	\
    ( (This)->lpVtbl -> OnGetDeviceCapabilities(This,pKey,pvValue) ) 

#define ISideShowDriver_OnGetPreEnabledApplications(This,ppApplicationIds,ppEndpointIds,pcApplications)	\
    ( (This)->lpVtbl -> OnGetPreEnabledApplications(This,ppApplicationIds,ppEndpointIds,pcApplications) ) 

#define ISideShowDriver_OnSetApplicationOrder(This,pApplicationIds,cApplicationIds)	\
    ( (This)->lpVtbl -> OnSetApplicationOrder(This,pApplicationIds,cApplicationIds) ) 

#define ISideShowDriver_OnGetApplicationOrder(This,ppApplicationIds,pcApplicationIds)	\
    ( (This)->lpVtbl -> OnGetApplicationOrder(This,ppApplicationIds,pcApplicationIds) ) 

#define ISideShowDriver_OnAddApplication(This,pUserSid,ApplicationId,EndPointId,pcwszName,dwCachePolicy,dwOnlineOnly,pbLargeIcon,cbLargeIcon,pbMediumIcon,cbMediumIcon,pbSmallIcon,cbSmallIcon)	\
    ( (This)->lpVtbl -> OnAddApplication(This,pUserSid,ApplicationId,EndPointId,pcwszName,dwCachePolicy,dwOnlineOnly,pbLargeIcon,cbLargeIcon,pbMediumIcon,cbMediumIcon,pbSmallIcon,cbSmallIcon) ) 

#define ISideShowDriver_OnRemoveApplication(This,pUserSid,ApplicationId)	\
    ( (This)->lpVtbl -> OnRemoveApplication(This,pUserSid,ApplicationId) ) 

#define ISideShowDriver_OnRemoveAllApplications(This,pUserSid)	\
    ( (This)->lpVtbl -> OnRemoveAllApplications(This,pUserSid) ) 

#define ISideShowDriver_OnAddContent(This,pUserSid,ApplicationId,EndpointId,ContentId,pData,cbData)	\
    ( (This)->lpVtbl -> OnAddContent(This,pUserSid,ApplicationId,EndpointId,ContentId,pData,cbData) ) 

#define ISideShowDriver_OnRemoveContent(This,pUserSid,ApplicationId,EndpointId,ContentId)	\
    ( (This)->lpVtbl -> OnRemoveContent(This,pUserSid,ApplicationId,EndpointId,ContentId) ) 

#define ISideShowDriver_OnRemoveAllContent(This,pUserSid,ApplicationId,EndpointId)	\
    ( (This)->lpVtbl -> OnRemoveAllContent(This,pUserSid,ApplicationId,EndpointId) ) 

#define ISideShowDriver_OnAddNotification(This,pUserSid,ApplicationId,NotificationId,ftExpiration,pcwszTitle,pcwszMessage,pbImage,cbImage)	\
    ( (This)->lpVtbl -> OnAddNotification(This,pUserSid,ApplicationId,NotificationId,ftExpiration,pcwszTitle,pcwszMessage,pbImage,cbImage) ) 

#define ISideShowDriver_OnRemoveNotification(This,pUserSid,ApplicationId,NotificationId)	\
    ( (This)->lpVtbl -> OnRemoveNotification(This,pUserSid,ApplicationId,NotificationId) ) 

#define ISideShowDriver_OnRemoveAllNotifications(This,pUserSid,ApplicationId)	\
    ( (This)->lpVtbl -> OnRemoveAllNotifications(This,pUserSid,ApplicationId) ) 

#define ISideShowDriver_OnSetNotificationsEnabled(This,pUserSid,fIsEnabled)	\
    ( (This)->lpVtbl -> OnSetNotificationsEnabled(This,pUserSid,fIsEnabled) ) 

#define ISideShowDriver_OnProcessWpdMessage(This,pPortableDeviceValuesParams,pPortableDeviceValuesResults)	\
    ( (This)->lpVtbl -> OnProcessWpdMessage(This,pPortableDeviceValuesParams,pPortableDeviceValuesResults) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __ISideShowDriver_INTERFACE_DEFINED__ */


#ifndef __ISideShowClassExtension_INTERFACE_DEFINED__
#define __ISideShowClassExtension_INTERFACE_DEFINED__

/* interface ISideShowClassExtension */
/* [unique][helpstring][uuid][object] */ 


EXTERN_C const IID IID_ISideShowClassExtension;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("27E78451-41C1-47fd-A50D-4D3E97D35B30")
    ISideShowClassExtension : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE Initialize( 
            /* [in] */ __RPC__in_opt IUnknown *pWdfDeviceUnknown,
            /* [in] */ __RPC__in_opt IUnknown *pSideShowDriverUnknown) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Uninitialize( 
            /* [in] */ __RPC__in_opt IUnknown *pWdfDeviceUnknown) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE OnProcessIoControl( 
            /* [in] */ __RPC__in_opt IWDFIoQueue *pWdfQueue,
            /* [in] */ __RPC__in_opt IWDFIoRequest *pWdfRequest,
            /* [in] */ ULONG ControlCode,
            /* [in] */ SIZE_T InputBufferSizeInBytes,
            /* [in] */ SIZE_T OutputBufferSizeInBytes,
            /* [out] */ __RPC__out DWORD *pcbWritten) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct ISideShowClassExtensionVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            ISideShowClassExtension * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            ISideShowClassExtension * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            ISideShowClassExtension * This);
        
        HRESULT ( STDMETHODCALLTYPE *Initialize )( 
            ISideShowClassExtension * This,
            /* [in] */ __RPC__in_opt IUnknown *pWdfDeviceUnknown,
            /* [in] */ __RPC__in_opt IUnknown *pSideShowDriverUnknown);
        
        HRESULT ( STDMETHODCALLTYPE *Uninitialize )( 
            ISideShowClassExtension * This,
            /* [in] */ __RPC__in_opt IUnknown *pWdfDeviceUnknown);
        
        HRESULT ( STDMETHODCALLTYPE *OnProcessIoControl )( 
            ISideShowClassExtension * This,
            /* [in] */ __RPC__in_opt IWDFIoQueue *pWdfQueue,
            /* [in] */ __RPC__in_opt IWDFIoRequest *pWdfRequest,
            /* [in] */ ULONG ControlCode,
            /* [in] */ SIZE_T InputBufferSizeInBytes,
            /* [in] */ SIZE_T OutputBufferSizeInBytes,
            /* [out] */ __RPC__out DWORD *pcbWritten);
        
        END_INTERFACE
    } ISideShowClassExtensionVtbl;

    interface ISideShowClassExtension
    {
        CONST_VTBL struct ISideShowClassExtensionVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define ISideShowClassExtension_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define ISideShowClassExtension_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define ISideShowClassExtension_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define ISideShowClassExtension_Initialize(This,pWdfDeviceUnknown,pSideShowDriverUnknown)	\
    ( (This)->lpVtbl -> Initialize(This,pWdfDeviceUnknown,pSideShowDriverUnknown) ) 

#define ISideShowClassExtension_Uninitialize(This,pWdfDeviceUnknown)	\
    ( (This)->lpVtbl -> Uninitialize(This,pWdfDeviceUnknown) ) 

#define ISideShowClassExtension_OnProcessIoControl(This,pWdfQueue,pWdfRequest,ControlCode,InputBufferSizeInBytes,OutputBufferSizeInBytes,pcbWritten)	\
    ( (This)->lpVtbl -> OnProcessIoControl(This,pWdfQueue,pWdfRequest,ControlCode,InputBufferSizeInBytes,OutputBufferSizeInBytes,pcbWritten) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __ISideShowClassExtension_INTERFACE_DEFINED__ */



#ifndef __WindowsSideShowDriverLibrary_LIBRARY_DEFINED__
#define __WindowsSideShowDriverLibrary_LIBRARY_DEFINED__

/* library WindowsSideShowDriverLibrary */
/* [helpstring][version][uuid] */ 


EXTERN_C const IID LIBID_WindowsSideShowDriverLibrary;

EXTERN_C const CLSID CLSID_SideShowClassExtension;

#ifdef __cplusplus

class DECLSPEC_UUID("76EFD608-E0CE-4887-98E2-F931363C4BC5")
SideShowClassExtension;
#endif
#endif /* __WindowsSideShowDriverLibrary_LIBRARY_DEFINED__ */

/* interface __MIDL_itf_windowssideshowclassextension_0000_0002 */
/* [local] */ 

#endif // (_WIN32_WINNT >= 0x0600)


extern RPC_IF_HANDLE __MIDL_itf_windowssideshowclassextension_0000_0002_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_windowssideshowclassextension_0000_0002_v0_0_s_ifspec;

/* Additional Prototypes for ALL interfaces */

unsigned long             __RPC_USER  BSTR_UserSize(     unsigned long *, unsigned long            , BSTR * ); 
unsigned char * __RPC_USER  BSTR_UserMarshal(  unsigned long *, unsigned char *, BSTR * ); 
unsigned char * __RPC_USER  BSTR_UserUnmarshal(unsigned long *, unsigned char *, BSTR * ); 
void                      __RPC_USER  BSTR_UserFree(     unsigned long *, BSTR * ); 

unsigned long             __RPC_USER  LPSAFEARRAY_UserSize(     unsigned long *, unsigned long            , LPSAFEARRAY * ); 
unsigned char * __RPC_USER  LPSAFEARRAY_UserMarshal(  unsigned long *, unsigned char *, LPSAFEARRAY * ); 
unsigned char * __RPC_USER  LPSAFEARRAY_UserUnmarshal(unsigned long *, unsigned char *, LPSAFEARRAY * ); 
void                      __RPC_USER  LPSAFEARRAY_UserFree(     unsigned long *, LPSAFEARRAY * ); 

unsigned long             __RPC_USER  BSTR_UserSize64(     unsigned long *, unsigned long            , BSTR * ); 
unsigned char * __RPC_USER  BSTR_UserMarshal64(  unsigned long *, unsigned char *, BSTR * ); 
unsigned char * __RPC_USER  BSTR_UserUnmarshal64(unsigned long *, unsigned char *, BSTR * ); 
void                      __RPC_USER  BSTR_UserFree64(     unsigned long *, BSTR * ); 

unsigned long             __RPC_USER  LPSAFEARRAY_UserSize64(     unsigned long *, unsigned long            , LPSAFEARRAY * ); 
unsigned char * __RPC_USER  LPSAFEARRAY_UserMarshal64(  unsigned long *, unsigned char *, LPSAFEARRAY * ); 
unsigned char * __RPC_USER  LPSAFEARRAY_UserUnmarshal64(unsigned long *, unsigned char *, LPSAFEARRAY * ); 
void                      __RPC_USER  LPSAFEARRAY_UserFree64(     unsigned long *, LPSAFEARRAY * ); 

/* end of Additional Prototypes */

#ifdef __cplusplus
}
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\win2k8\ddk\inc\WindowsSideShowDriverEvents.h ===
//-----------------------------------------------------------------------
// <copyright file="WindowsSideShowDriverEvents.h" company="Microsoft">
//      Copyright (c) 2005 Microsoft Corporation.  All rights
//  reserved.
// </copyright>
//
// Module:
//      WindowsSideShowDriverEvents.h
//
// Description:
//      This header contains structures and values related to events
//      that can be sent by Windows SideShow drivers.
//
// Comments:
//      They are currently intended to be used by the UMDF PnP eventing
//      mechanism.
//
//-----------------------------------------------------------------------

#pragma once
#if (_WIN32_WINNT >= 0x0600) // Windows Vista and later 

//////////////////////////////////////////////////////////////////////////////
//
// This section defines the device functional interface GUIDs for
// Windows SideShow-compatible devices.
//
//////////////////////////////////////////////////////////////////////////////

// {152E5811-FEB9-4B00-90F4-D32947AE1681}
DEFINE_GUID(GUID_DEVINTERFACE_SIDESHOW,         0x152e5811, 0xfeb9, 0x4b00, 0x90, 0xf4, 0xd3, 0x29, 0x47, 0xae, 0x16, 0x81);
            
//////////////////////////////////////////////////////////////////////////////
//
// This section defines the GUIDs associated with the various event types.
//
//////////////////////////////////////////////////////////////////////////////

// {5007FBA8-D313-439f-BEA2-A50201D3E9A8}
DEFINE_GUID(SIDESHOW_CONTENT_MISSING_EVENT,     0x5007fba8, 0xd313, 0x439f, 0xbe, 0xa2, 0xa5, 0x02, 0x01, 0xd3, 0xe9, 0xa8);

// {4CB572FA-1D3B-49b3-A17A-2E6BFF052854}
DEFINE_GUID(SIDESHOW_APPLICATION_EVENT,         0x4cb572fa, 0x1d3b, 0x49b3, 0xa1, 0x7a, 0x2e, 0x6b, 0xff, 0x05, 0x28, 0x54);

// {5009673c-3f7d-4c7e-9971-eaa2e91f1575}
DEFINE_GUID(SIDESHOW_USER_CHANGE_REQUEST_EVENT, 0x5009673c, 0x3f7d, 0x4c7e, 0x99, 0x71, 0xea, 0xa2, 0xe9, 0x1f, 0x15, 0x75);


//////////////////////////////////////////////////////////////////////////////
//
// This section defines the data associated with each event.
//
//////////////////////////////////////////////////////////////////////////////

#pragma pack(push, WindowsSideShowEvents, 1)

//////////////////////////////////////////////////////////////////////////////
//
// This event is posted in response to Content Missing Event on the device.  The
// struct contains the parameters that identify which device the event came
// from, which application/endpoint it is for, and the content id of the
// requested content.
//
////////////////////////////////////////////////////////////////////////////////
typedef struct _CONTENT_MISSING_EVENT_DATA
{
    DWORD           cbContentMissingEventData;
    APPLICATION_ID  ApplicationId;
    ENDPOINT_ID     EndpointId;
    CONTENT_ID      ContentId;
} CONTENT_MISSING_EVENT_DATA, *PCONTENT_MISSING_EVENT_DATA;

//////////////////////////////////////////////////////////////////////////////
//
// This struct contains an event sent by an application on the device.
// The data is determined by the application and the event id.  Since
// the data can be variable size, we store the size of the data and then
// the first byte of it.  This struct should always be allocated as
// offsetof(APPLICATION_EVENT_DATA, bEventData) + <event data size>, and this
// size should be set in cbApplicationEventData.  The cbEventData
// member should contain just <event data size>.
//
//////////////////////////////////////////////////////////////////////////////
typedef struct _APPLICATION_EVENT_DATA
{
    DWORD           cbApplicationEventData;    
    APPLICATION_ID  ApplicationId;
    ENDPOINT_ID     EndpointId;
    DWORD           dwEventId;
    DWORD           cbEventData;
    BYTE            bEventData[1];
} APPLICATION_EVENT_DATA, *PAPPLICATION_EVENT_DATA;


//////////////////////////////////////////////////////////////////////////////
//
// This struct contains an event sent by the driver to the platform.  Shared
// devices can use this event in their driver to signal to the platform that a
// a request for a new user to take ownership of the device has been made.  The
// platform will set the current user on the device in response to the message,
// and upon success, will notify gadgets as if a device add had taken place.
// When posting this event to request that the active user of the device be
// changed, drivers should set wszUser to the SID of the user that is the new
// requested owner of the device.
//
//////////////////////////////////////////////////////////////////////////////
typedef struct _DEVICE_USER_CHANGE_EVENT_DATA
{
    DWORD                       cbDeviceUserChangeEventData;
    WCHAR                       wszUser;    // First character of user name (sid) string.
} DEVICE_USER_CHANGE_EVENT_DATA, *PDEVICE_USER_CHANGE_EVENT_DATA;


#pragma pack(pop, WindowsSideShowEvents)

#endif // (_WIN32_WINNT >= 0x0600)
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\win2k8\ddk\inc\wia_lh.h ===
/* this ALWAYS GENERATED file contains the definitions for the interfaces */


 /* File created by MIDL compiler version 7.00.0499 */
/* Compiler settings for wia_lh.idl, wia_lh.acf:
    Oicf, W1, Zp8, env=Win32 (32b run)
    protocol : dce , ms_ext, c_ext, robust
    error checks: allocation ref bounds_check enum stub_data 
    VC __declspec() decoration level: 
         __declspec(uuid()), __declspec(selectany), __declspec(novtable)
         DECLSPEC_UUID(), MIDL_INTERFACE()
*/
//@@MIDL_FILE_HEADING(  )

#pragma warning( disable: 4049 )  /* more than 64k source lines */


/* verify that the <rpcndr.h> version is high enough to compile this file*/
#ifndef __REQUIRED_RPCNDR_H_VERSION__
#define __REQUIRED_RPCNDR_H_VERSION__ 500
#endif

/* verify that the <rpcsal.h> version is high enough to compile this file*/
#ifndef __REQUIRED_RPCSAL_H_VERSION__
#define __REQUIRED_RPCSAL_H_VERSION__ 100
#endif

#include "rpc.h"
#include "rpcndr.h"

#ifndef __RPCNDR_H_VERSION__
#error this stub requires an updated version of <rpcndr.h>
#endif // __RPCNDR_H_VERSION__

#ifndef COM_NO_WINDOWS_H
#include "windows.h"
#include "ole2.h"
#endif /*COM_NO_WINDOWS_H*/

#ifndef __wia_lh_h__
#define __wia_lh_h__

#if defined(_MSC_VER) && (_MSC_VER >= 1020)
#pragma once
#endif

/* Forward Declarations */ 

#ifndef __IWiaDevMgr_FWD_DEFINED__
#define __IWiaDevMgr_FWD_DEFINED__
typedef interface IWiaDevMgr IWiaDevMgr;
#endif 	/* __IWiaDevMgr_FWD_DEFINED__ */


#ifndef __IEnumWIA_DEV_INFO_FWD_DEFINED__
#define __IEnumWIA_DEV_INFO_FWD_DEFINED__
typedef interface IEnumWIA_DEV_INFO IEnumWIA_DEV_INFO;
#endif 	/* __IEnumWIA_DEV_INFO_FWD_DEFINED__ */


#ifndef __IWiaEventCallback_FWD_DEFINED__
#define __IWiaEventCallback_FWD_DEFINED__
typedef interface IWiaEventCallback IWiaEventCallback;
#endif 	/* __IWiaEventCallback_FWD_DEFINED__ */


#ifndef __IWiaDataCallback_FWD_DEFINED__
#define __IWiaDataCallback_FWD_DEFINED__
typedef interface IWiaDataCallback IWiaDataCallback;
#endif 	/* __IWiaDataCallback_FWD_DEFINED__ */


#ifndef __IWiaDataTransfer_FWD_DEFINED__
#define __IWiaDataTransfer_FWD_DEFINED__
typedef interface IWiaDataTransfer IWiaDataTransfer;
#endif 	/* __IWiaDataTransfer_FWD_DEFINED__ */


#ifndef __IWiaItem_FWD_DEFINED__
#define __IWiaItem_FWD_DEFINED__
typedef interface IWiaItem IWiaItem;
#endif 	/* __IWiaItem_FWD_DEFINED__ */


#ifndef __IWiaPropertyStorage_FWD_DEFINED__
#define __IWiaPropertyStorage_FWD_DEFINED__
typedef interface IWiaPropertyStorage IWiaPropertyStorage;
#endif 	/* __IWiaPropertyStorage_FWD_DEFINED__ */


#ifndef __IEnumWiaItem_FWD_DEFINED__
#define __IEnumWiaItem_FWD_DEFINED__
typedef interface IEnumWiaItem IEnumWiaItem;
#endif 	/* __IEnumWiaItem_FWD_DEFINED__ */


#ifndef __IEnumWIA_DEV_CAPS_FWD_DEFINED__
#define __IEnumWIA_DEV_CAPS_FWD_DEFINED__
typedef interface IEnumWIA_DEV_CAPS IEnumWIA_DEV_CAPS;
#endif 	/* __IEnumWIA_DEV_CAPS_FWD_DEFINED__ */


#ifndef __IEnumWIA_FORMAT_INFO_FWD_DEFINED__
#define __IEnumWIA_FORMAT_INFO_FWD_DEFINED__
typedef interface IEnumWIA_FORMAT_INFO IEnumWIA_FORMAT_INFO;
#endif 	/* __IEnumWIA_FORMAT_INFO_FWD_DEFINED__ */


#ifndef __IWiaLog_FWD_DEFINED__
#define __IWiaLog_FWD_DEFINED__
typedef interface IWiaLog IWiaLog;
#endif 	/* __IWiaLog_FWD_DEFINED__ */


#ifndef __IWiaLogEx_FWD_DEFINED__
#define __IWiaLogEx_FWD_DEFINED__
typedef interface IWiaLogEx IWiaLogEx;
#endif 	/* __IWiaLogEx_FWD_DEFINED__ */


#ifndef __IWiaNotifyDevMgr_FWD_DEFINED__
#define __IWiaNotifyDevMgr_FWD_DEFINED__
typedef interface IWiaNotifyDevMgr IWiaNotifyDevMgr;
#endif 	/* __IWiaNotifyDevMgr_FWD_DEFINED__ */


#ifndef __IWiaItemExtras_FWD_DEFINED__
#define __IWiaItemExtras_FWD_DEFINED__
typedef interface IWiaItemExtras IWiaItemExtras;
#endif 	/* __IWiaItemExtras_FWD_DEFINED__ */


#ifndef __IWiaAppErrorHandler_FWD_DEFINED__
#define __IWiaAppErrorHandler_FWD_DEFINED__
typedef interface IWiaAppErrorHandler IWiaAppErrorHandler;
#endif 	/* __IWiaAppErrorHandler_FWD_DEFINED__ */


#ifndef __IWiaErrorHandler_FWD_DEFINED__
#define __IWiaErrorHandler_FWD_DEFINED__
typedef interface IWiaErrorHandler IWiaErrorHandler;
#endif 	/* __IWiaErrorHandler_FWD_DEFINED__ */


#ifndef __IWiaTransfer_FWD_DEFINED__
#define __IWiaTransfer_FWD_DEFINED__
typedef interface IWiaTransfer IWiaTransfer;
#endif 	/* __IWiaTransfer_FWD_DEFINED__ */


#ifndef __IWiaTransferCallback_FWD_DEFINED__
#define __IWiaTransferCallback_FWD_DEFINED__
typedef interface IWiaTransferCallback IWiaTransferCallback;
#endif 	/* __IWiaTransferCallback_FWD_DEFINED__ */


#ifndef __IWiaSegmentationFilter_FWD_DEFINED__
#define __IWiaSegmentationFilter_FWD_DEFINED__
typedef interface IWiaSegmentationFilter IWiaSegmentationFilter;
#endif 	/* __IWiaSegmentationFilter_FWD_DEFINED__ */


#ifndef __IWiaImageFilter_FWD_DEFINED__
#define __IWiaImageFilter_FWD_DEFINED__
typedef interface IWiaImageFilter IWiaImageFilter;
#endif 	/* __IWiaImageFilter_FWD_DEFINED__ */


#ifndef __IWiaPreview_FWD_DEFINED__
#define __IWiaPreview_FWD_DEFINED__
typedef interface IWiaPreview IWiaPreview;
#endif 	/* __IWiaPreview_FWD_DEFINED__ */


#ifndef __IEnumWiaItem2_FWD_DEFINED__
#define __IEnumWiaItem2_FWD_DEFINED__
typedef interface IEnumWiaItem2 IEnumWiaItem2;
#endif 	/* __IEnumWiaItem2_FWD_DEFINED__ */


#ifndef __IWiaItem2_FWD_DEFINED__
#define __IWiaItem2_FWD_DEFINED__
typedef interface IWiaItem2 IWiaItem2;
#endif 	/* __IWiaItem2_FWD_DEFINED__ */


#ifndef __IWiaDevMgr2_FWD_DEFINED__
#define __IWiaDevMgr2_FWD_DEFINED__
typedef interface IWiaDevMgr2 IWiaDevMgr2;
#endif 	/* __IWiaDevMgr2_FWD_DEFINED__ */


#ifndef __WiaDevMgr_FWD_DEFINED__
#define __WiaDevMgr_FWD_DEFINED__

#ifdef __cplusplus
typedef class WiaDevMgr WiaDevMgr;
#else
typedef struct WiaDevMgr WiaDevMgr;
#endif /* __cplusplus */

#endif 	/* __WiaDevMgr_FWD_DEFINED__ */


#ifndef __WiaDevMgr2_FWD_DEFINED__
#define __WiaDevMgr2_FWD_DEFINED__

#ifdef __cplusplus
typedef class WiaDevMgr2 WiaDevMgr2;
#else
typedef struct WiaDevMgr2 WiaDevMgr2;
#endif /* __cplusplus */

#endif 	/* __WiaDevMgr2_FWD_DEFINED__ */


#ifndef __WiaLog_FWD_DEFINED__
#define __WiaLog_FWD_DEFINED__

#ifdef __cplusplus
typedef class WiaLog WiaLog;
#else
typedef struct WiaLog WiaLog;
#endif /* __cplusplus */

#endif 	/* __WiaLog_FWD_DEFINED__ */


/* header files for imported files */
#include "unknwn.h"
#include "oaidl.h"
#include "propidl.h"

#ifdef __cplusplus
extern "C"{
#endif 


/* interface __MIDL_itf_wia_lh_0000_0000 */
/* [local] */ 


















typedef struct _WIA_DITHER_PATTERN_DATA
    {
    LONG lSize;
    BSTR bstrPatternName;
    LONG lPatternWidth;
    LONG lPatternLength;
    LONG cbPattern;
    BYTE *pbPattern;
    } 	WIA_DITHER_PATTERN_DATA;

typedef struct _WIA_DITHER_PATTERN_DATA *PWIA_DITHER_PATTERN_DATA;

typedef struct _WIA_PROPID_TO_NAME
    {
    PROPID propid;
    LPOLESTR pszName;
    } 	WIA_PROPID_TO_NAME;

typedef struct _WIA_PROPID_TO_NAME *PWIA_PROPID_TO_NAME;

typedef struct _WIA_FORMAT_INFO
    {
    GUID guidFormatID;
    LONG lTymed;
    } 	WIA_FORMAT_INFO;

typedef struct _WIA_FORMAT_INFO *PWIA_FORMAT_INFO;

#include "wiadef.h"


extern RPC_IF_HANDLE __MIDL_itf_wia_lh_0000_0000_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_wia_lh_0000_0000_v0_0_s_ifspec;

#ifndef __IWiaDevMgr_INTERFACE_DEFINED__
#define __IWiaDevMgr_INTERFACE_DEFINED__

/* interface IWiaDevMgr */
/* [unique][helpstring][uuid][object] */ 


EXTERN_C const IID IID_IWiaDevMgr;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("5eb2502a-8cf1-11d1-bf92-0060081ed811")
    IWiaDevMgr : public IUnknown
    {
    public:
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE EnumDeviceInfo( 
            /* [in] */ LONG lFlag,
            /* [retval][out] */ __RPC__deref_out_opt IEnumWIA_DEV_INFO **ppIEnum) = 0;
        
        virtual /* [local] */ HRESULT STDMETHODCALLTYPE CreateDevice( 
            /* [in] */ BSTR bstrDeviceID,
            /* [out] */ IWiaItem **ppWiaItemRoot) = 0;
        
        virtual /* [local] */ HRESULT STDMETHODCALLTYPE SelectDeviceDlg( 
            /* [in] */ HWND hwndParent,
            /* [in] */ LONG lDeviceType,
            /* [in] */ LONG lFlags,
            /* [out][in] */ BSTR *pbstrDeviceID,
            /* [retval][out] */ IWiaItem **ppItemRoot) = 0;
        
        virtual /* [local] */ HRESULT STDMETHODCALLTYPE SelectDeviceDlgID( 
            /* [in] */ HWND hwndParent,
            /* [in] */ LONG lDeviceType,
            /* [in] */ LONG lFlags,
            /* [retval][out] */ BSTR *pbstrDeviceID) = 0;
        
        virtual /* [local] */ HRESULT STDMETHODCALLTYPE GetImageDlg( 
            /* [in] */ HWND hwndParent,
            /* [in] */ LONG lDeviceType,
            /* [in] */ LONG lFlags,
            /* [in] */ LONG lIntent,
            /* [in] */ IWiaItem *pItemRoot,
            /* [in] */ BSTR bstrFilename,
            /* [out][in] */ GUID *pguidFormat) = 0;
        
        virtual /* [local] */ HRESULT STDMETHODCALLTYPE RegisterEventCallbackProgram( 
            /* [in] */ LONG lFlags,
            /* [in] */ BSTR bstrDeviceID,
            /* [in] */ const GUID *pEventGUID,
            /* [in] */ BSTR bstrCommandline,
            /* [in] */ BSTR bstrName,
            /* [in] */ BSTR bstrDescription,
            /* [in] */ BSTR bstrIcon) = 0;
        
        virtual /* [local] */ HRESULT STDMETHODCALLTYPE RegisterEventCallbackInterface( 
            /* [in] */ LONG lFlags,
            /* [in] */ BSTR bstrDeviceID,
            /* [in] */ const GUID *pEventGUID,
            /* [unique][in] */ IWiaEventCallback *pIWiaEventCallback,
            /* [out] */ IUnknown **pEventObject) = 0;
        
        virtual /* [local] */ HRESULT STDMETHODCALLTYPE RegisterEventCallbackCLSID( 
            /* [in] */ LONG lFlags,
            /* [in] */ BSTR bstrDeviceID,
            /* [in] */ const GUID *pEventGUID,
            /* [unique][in] */ const GUID *pClsID,
            /* [in] */ BSTR bstrName,
            /* [in] */ BSTR bstrDescription,
            /* [in] */ BSTR bstrIcon) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE AddDeviceDlg( 
            /* [in] */ __RPC__in HWND hwndParent,
            /* [in] */ LONG lFlags) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IWiaDevMgrVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IWiaDevMgr * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IWiaDevMgr * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IWiaDevMgr * This);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *EnumDeviceInfo )( 
            IWiaDevMgr * This,
            /* [in] */ LONG lFlag,
            /* [retval][out] */ __RPC__deref_out_opt IEnumWIA_DEV_INFO **ppIEnum);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE *CreateDevice )( 
            IWiaDevMgr * This,
            /* [in] */ BSTR bstrDeviceID,
            /* [out] */ IWiaItem **ppWiaItemRoot);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE *SelectDeviceDlg )( 
            IWiaDevMgr * This,
            /* [in] */ HWND hwndParent,
            /* [in] */ LONG lDeviceType,
            /* [in] */ LONG lFlags,
            /* [out][in] */ BSTR *pbstrDeviceID,
            /* [retval][out] */ IWiaItem **ppItemRoot);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE *SelectDeviceDlgID )( 
            IWiaDevMgr * This,
            /* [in] */ HWND hwndParent,
            /* [in] */ LONG lDeviceType,
            /* [in] */ LONG lFlags,
            /* [retval][out] */ BSTR *pbstrDeviceID);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE *GetImageDlg )( 
            IWiaDevMgr * This,
            /* [in] */ HWND hwndParent,
            /* [in] */ LONG lDeviceType,
            /* [in] */ LONG lFlags,
            /* [in] */ LONG lIntent,
            /* [in] */ IWiaItem *pItemRoot,
            /* [in] */ BSTR bstrFilename,
            /* [out][in] */ GUID *pguidFormat);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE *RegisterEventCallbackProgram )( 
            IWiaDevMgr * This,
            /* [in] */ LONG lFlags,
            /* [in] */ BSTR bstrDeviceID,
            /* [in] */ const GUID *pEventGUID,
            /* [in] */ BSTR bstrCommandline,
            /* [in] */ BSTR bstrName,
            /* [in] */ BSTR bstrDescription,
            /* [in] */ BSTR bstrIcon);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE *RegisterEventCallbackInterface )( 
            IWiaDevMgr * This,
            /* [in] */ LONG lFlags,
            /* [in] */ BSTR bstrDeviceID,
            /* [in] */ const GUID *pEventGUID,
            /* [unique][in] */ IWiaEventCallback *pIWiaEventCallback,
            /* [out] */ IUnknown **pEventObject);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE *RegisterEventCallbackCLSID )( 
            IWiaDevMgr * This,
            /* [in] */ LONG lFlags,
            /* [in] */ BSTR bstrDeviceID,
            /* [in] */ const GUID *pEventGUID,
            /* [unique][in] */ const GUID *pClsID,
            /* [in] */ BSTR bstrName,
            /* [in] */ BSTR bstrDescription,
            /* [in] */ BSTR bstrIcon);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *AddDeviceDlg )( 
            IWiaDevMgr * This,
            /* [in] */ __RPC__in HWND hwndParent,
            /* [in] */ LONG lFlags);
        
        END_INTERFACE
    } IWiaDevMgrVtbl;

    interface IWiaDevMgr
    {
        CONST_VTBL struct IWiaDevMgrVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IWiaDevMgr_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IWiaDevMgr_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IWiaDevMgr_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IWiaDevMgr_EnumDeviceInfo(This,lFlag,ppIEnum)	\
    ( (This)->lpVtbl -> EnumDeviceInfo(This,lFlag,ppIEnum) ) 

#define IWiaDevMgr_CreateDevice(This,bstrDeviceID,ppWiaItemRoot)	\
    ( (This)->lpVtbl -> CreateDevice(This,bstrDeviceID,ppWiaItemRoot) ) 

#define IWiaDevMgr_SelectDeviceDlg(This,hwndParent,lDeviceType,lFlags,pbstrDeviceID,ppItemRoot)	\
    ( (This)->lpVtbl -> SelectDeviceDlg(This,hwndParent,lDeviceType,lFlags,pbstrDeviceID,ppItemRoot) ) 

#define IWiaDevMgr_SelectDeviceDlgID(This,hwndParent,lDeviceType,lFlags,pbstrDeviceID)	\
    ( (This)->lpVtbl -> SelectDeviceDlgID(This,hwndParent,lDeviceType,lFlags,pbstrDeviceID) ) 

#define IWiaDevMgr_GetImageDlg(This,hwndParent,lDeviceType,lFlags,lIntent,pItemRoot,bstrFilename,pguidFormat)	\
    ( (This)->lpVtbl -> GetImageDlg(This,hwndParent,lDeviceType,lFlags,lIntent,pItemRoot,bstrFilename,pguidFormat) ) 

#define IWiaDevMgr_RegisterEventCallbackProgram(This,lFlags,bstrDeviceID,pEventGUID,bstrCommandline,bstrName,bstrDescription,bstrIcon)	\
    ( (This)->lpVtbl -> RegisterEventCallbackProgram(This,lFlags,bstrDeviceID,pEventGUID,bstrCommandline,bstrName,bstrDescription,bstrIcon) ) 

#define IWiaDevMgr_RegisterEventCallbackInterface(This,lFlags,bstrDeviceID,pEventGUID,pIWiaEventCallback,pEventObject)	\
    ( (This)->lpVtbl -> RegisterEventCallbackInterface(This,lFlags,bstrDeviceID,pEventGUID,pIWiaEventCallback,pEventObject) ) 

#define IWiaDevMgr_RegisterEventCallbackCLSID(This,lFlags,bstrDeviceID,pEventGUID,pClsID,bstrName,bstrDescription,bstrIcon)	\
    ( (This)->lpVtbl -> RegisterEventCallbackCLSID(This,lFlags,bstrDeviceID,pEventGUID,pClsID,bstrName,bstrDescription,bstrIcon) ) 

#define IWiaDevMgr_AddDeviceDlg(This,hwndParent,lFlags)	\
    ( (This)->lpVtbl -> AddDeviceDlg(This,hwndParent,lFlags) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [helpstring][call_as] */ HRESULT STDMETHODCALLTYPE IWiaDevMgr_LocalCreateDevice_Proxy( 
    IWiaDevMgr * This,
    /* [in] */ __RPC__in BSTR bstrDeviceID,
    /* [out] */ __RPC__deref_out_opt IWiaItem **ppWiaItemRoot);


void __RPC_STUB IWiaDevMgr_LocalCreateDevice_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [nocode][helpstring][call_as] */ HRESULT STDMETHODCALLTYPE IWiaDevMgr_LocalSelectDeviceDlg_Proxy( 
    IWiaDevMgr * This,
    /* [in] */ __RPC__in HWND hwndParent,
    /* [in] */ LONG lDeviceType,
    /* [in] */ LONG lFlags,
    /* [out][in] */ __RPC__deref_inout_opt BSTR *pbstrDeviceID,
    /* [retval][out] */ __RPC__deref_out_opt IWiaItem **ppItemRoot);


void __RPC_STUB IWiaDevMgr_LocalSelectDeviceDlg_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [nocode][helpstring][call_as] */ HRESULT STDMETHODCALLTYPE IWiaDevMgr_LocalSelectDeviceDlgID_Proxy( 
    IWiaDevMgr * This,
    /* [in] */ __RPC__in HWND hwndParent,
    /* [in] */ LONG lDeviceType,
    /* [in] */ LONG lFlags,
    /* [retval][out] */ __RPC__deref_out_opt BSTR *pbstrDeviceID);


void __RPC_STUB IWiaDevMgr_LocalSelectDeviceDlgID_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [nocode][helpstring][call_as] */ HRESULT STDMETHODCALLTYPE IWiaDevMgr_LocalGetImageDlg_Proxy( 
    IWiaDevMgr * This,
    /* [in] */ __RPC__in HWND hwndParent,
    /* [in] */ LONG lDeviceType,
    /* [in] */ LONG lFlags,
    /* [in] */ LONG lIntent,
    /* [in] */ __RPC__in_opt IWiaItem *pItemRoot,
    /* [in] */ __RPC__in BSTR bstrFilename,
    /* [out][in] */ __RPC__inout GUID *pguidFormat);


void __RPC_STUB IWiaDevMgr_LocalGetImageDlg_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][call_as] */ HRESULT STDMETHODCALLTYPE IWiaDevMgr_LocalRegisterEventCallbackProgram_Proxy( 
    IWiaDevMgr * This,
    /* [in] */ LONG lFlags,
    /* [in] */ __RPC__in BSTR bstrDeviceID,
    /* [in] */ __RPC__in const GUID *pEventGUID,
    /* [in] */ __RPC__in BSTR bstrCommandline,
    /* [in] */ __RPC__in BSTR bstrName,
    /* [in] */ __RPC__in BSTR bstrDescription,
    /* [in] */ __RPC__in BSTR bstrIcon);


void __RPC_STUB IWiaDevMgr_LocalRegisterEventCallbackProgram_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][call_as] */ HRESULT STDMETHODCALLTYPE IWiaDevMgr_LocalRegisterEventCallbackInterface_Proxy( 
    IWiaDevMgr * This,
    /* [in] */ LONG lFlags,
    /* [in] */ __RPC__in BSTR bstrDeviceID,
    /* [in] */ __RPC__in const GUID *pEventGUID,
    /* [unique][in] */ __RPC__in_opt IWiaEventCallback *pIWiaEventCallback,
    /* [out] */ __RPC__deref_out_opt IUnknown **pEventObject);


void __RPC_STUB IWiaDevMgr_LocalRegisterEventCallbackInterface_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][call_as] */ HRESULT STDMETHODCALLTYPE IWiaDevMgr_LocalRegisterEventCallbackCLSID_Proxy( 
    IWiaDevMgr * This,
    /* [in] */ LONG lFlags,
    /* [in] */ __RPC__in BSTR bstrDeviceID,
    /* [in] */ __RPC__in const GUID *pEventGUID,
    /* [unique][in] */ __RPC__in_opt const GUID *pClsID,
    /* [in] */ __RPC__in BSTR bstrName,
    /* [in] */ __RPC__in BSTR bstrDescription,
    /* [in] */ __RPC__in BSTR bstrIcon);


void __RPC_STUB IWiaDevMgr_LocalRegisterEventCallbackCLSID_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IWiaDevMgr_INTERFACE_DEFINED__ */


#ifndef __IEnumWIA_DEV_INFO_INTERFACE_DEFINED__
#define __IEnumWIA_DEV_INFO_INTERFACE_DEFINED__

/* interface IEnumWIA_DEV_INFO */
/* [unique][helpstring][uuid][object] */ 


EXTERN_C const IID IID_IEnumWIA_DEV_INFO;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("5e38b83c-8cf1-11d1-bf92-0060081ed811")
    IEnumWIA_DEV_INFO : public IUnknown
    {
    public:
        virtual /* [local] */ HRESULT STDMETHODCALLTYPE Next( 
            /* [in] */ ULONG celt,
            /* [length_is][size_is][out] */ IWiaPropertyStorage **rgelt,
            /* [unique][out][in] */ ULONG *pceltFetched) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE Skip( 
            /* [in] */ ULONG celt) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE Reset( void) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE Clone( 
            /* [out] */ __RPC__deref_out_opt IEnumWIA_DEV_INFO **ppIEnum) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE GetCount( 
            /* [out] */ __RPC__out ULONG *celt) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IEnumWIA_DEV_INFOVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IEnumWIA_DEV_INFO * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IEnumWIA_DEV_INFO * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IEnumWIA_DEV_INFO * This);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE *Next )( 
            IEnumWIA_DEV_INFO * This,
            /* [in] */ ULONG celt,
            /* [length_is][size_is][out] */ IWiaPropertyStorage **rgelt,
            /* [unique][out][in] */ ULONG *pceltFetched);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *Skip )( 
            IEnumWIA_DEV_INFO * This,
            /* [in] */ ULONG celt);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *Reset )( 
            IEnumWIA_DEV_INFO * This);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *Clone )( 
            IEnumWIA_DEV_INFO * This,
            /* [out] */ __RPC__deref_out_opt IEnumWIA_DEV_INFO **ppIEnum);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *GetCount )( 
            IEnumWIA_DEV_INFO * This,
            /* [out] */ __RPC__out ULONG *celt);
        
        END_INTERFACE
    } IEnumWIA_DEV_INFOVtbl;

    interface IEnumWIA_DEV_INFO
    {
        CONST_VTBL struct IEnumWIA_DEV_INFOVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IEnumWIA_DEV_INFO_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IEnumWIA_DEV_INFO_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IEnumWIA_DEV_INFO_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IEnumWIA_DEV_INFO_Next(This,celt,rgelt,pceltFetched)	\
    ( (This)->lpVtbl -> Next(This,celt,rgelt,pceltFetched) ) 

#define IEnumWIA_DEV_INFO_Skip(This,celt)	\
    ( (This)->lpVtbl -> Skip(This,celt) ) 

#define IEnumWIA_DEV_INFO_Reset(This)	\
    ( (This)->lpVtbl -> Reset(This) ) 

#define IEnumWIA_DEV_INFO_Clone(This,ppIEnum)	\
    ( (This)->lpVtbl -> Clone(This,ppIEnum) ) 

#define IEnumWIA_DEV_INFO_GetCount(This,celt)	\
    ( (This)->lpVtbl -> GetCount(This,celt) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [helpstring][call_as] */ HRESULT STDMETHODCALLTYPE IEnumWIA_DEV_INFO_RemoteNext_Proxy( 
    IEnumWIA_DEV_INFO * This,
    /* [in] */ ULONG celt,
    /* [length_is][size_is][out] */ __RPC__out_ecount_part(celt, *pceltFetched) IWiaPropertyStorage **rgelt,
    /* [unique][out][in] */ __RPC__inout_opt ULONG *pceltFetched);


void __RPC_STUB IEnumWIA_DEV_INFO_RemoteNext_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IEnumWIA_DEV_INFO_INTERFACE_DEFINED__ */


#ifndef __IWiaEventCallback_INTERFACE_DEFINED__
#define __IWiaEventCallback_INTERFACE_DEFINED__

/* interface IWiaEventCallback */
/* [unique][helpstring][uuid][object] */ 


EXTERN_C const IID IID_IWiaEventCallback;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("ae6287b0-0084-11d2-973b-00a0c9068f2e")
    IWiaEventCallback : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE ImageEventCallback( 
            /* [in] */ __RPC__in const GUID *pEventGUID,
            /* [in] */ __RPC__in BSTR bstrEventDescription,
            /* [in] */ __RPC__in BSTR bstrDeviceID,
            /* [in] */ __RPC__in BSTR bstrDeviceDescription,
            /* [in] */ DWORD dwDeviceType,
            /* [in] */ __RPC__in BSTR bstrFullItemName,
            /* [out][in] */ __RPC__inout ULONG *pulEventType,
            /* [in] */ ULONG ulReserved) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IWiaEventCallbackVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IWiaEventCallback * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IWiaEventCallback * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IWiaEventCallback * This);
        
        HRESULT ( STDMETHODCALLTYPE *ImageEventCallback )( 
            IWiaEventCallback * This,
            /* [in] */ __RPC__in const GUID *pEventGUID,
            /* [in] */ __RPC__in BSTR bstrEventDescription,
            /* [in] */ __RPC__in BSTR bstrDeviceID,
            /* [in] */ __RPC__in BSTR bstrDeviceDescription,
            /* [in] */ DWORD dwDeviceType,
            /* [in] */ __RPC__in BSTR bstrFullItemName,
            /* [out][in] */ __RPC__inout ULONG *pulEventType,
            /* [in] */ ULONG ulReserved);
        
        END_INTERFACE
    } IWiaEventCallbackVtbl;

    interface IWiaEventCallback
    {
        CONST_VTBL struct IWiaEventCallbackVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IWiaEventCallback_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IWiaEventCallback_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IWiaEventCallback_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IWiaEventCallback_ImageEventCallback(This,pEventGUID,bstrEventDescription,bstrDeviceID,bstrDeviceDescription,dwDeviceType,bstrFullItemName,pulEventType,ulReserved)	\
    ( (This)->lpVtbl -> ImageEventCallback(This,pEventGUID,bstrEventDescription,bstrDeviceID,bstrDeviceDescription,dwDeviceType,bstrFullItemName,pulEventType,ulReserved) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IWiaEventCallback_INTERFACE_DEFINED__ */


/* interface __MIDL_itf_wia_lh_0000_0003 */
/* [local] */ 

typedef struct _WIA_DATA_CALLBACK_HEADER
    {
    LONG lSize;
    GUID guidFormatID;
    LONG lBufferSize;
    LONG lPageCount;
    } 	WIA_DATA_CALLBACK_HEADER;

typedef struct _WIA_DATA_CALLBACK_HEADER *PWIA_DATA_CALLBACK_HEADER;



extern RPC_IF_HANDLE __MIDL_itf_wia_lh_0000_0003_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_wia_lh_0000_0003_v0_0_s_ifspec;

#ifndef __IWiaDataCallback_INTERFACE_DEFINED__
#define __IWiaDataCallback_INTERFACE_DEFINED__

/* interface IWiaDataCallback */
/* [unique][helpstring][uuid][object] */ 


EXTERN_C const IID IID_IWiaDataCallback;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("a558a866-a5b0-11d2-a08f-00c04f72dc3c")
    IWiaDataCallback : public IUnknown
    {
    public:
        virtual /* [local] */ HRESULT STDMETHODCALLTYPE BandedDataCallback( 
            /* [in] */ LONG lMessage,
            /* [in] */ LONG lStatus,
            /* [in] */ LONG lPercentComplete,
            /* [in] */ LONG lOffset,
            /* [in] */ LONG lLength,
            /* [in] */ LONG lReserved,
            /* [in] */ LONG lResLength,
            /* [size_is][in] */ BYTE *pbBuffer) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IWiaDataCallbackVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IWiaDataCallback * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IWiaDataCallback * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IWiaDataCallback * This);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE *BandedDataCallback )( 
            IWiaDataCallback * This,
            /* [in] */ LONG lMessage,
            /* [in] */ LONG lStatus,
            /* [in] */ LONG lPercentComplete,
            /* [in] */ LONG lOffset,
            /* [in] */ LONG lLength,
            /* [in] */ LONG lReserved,
            /* [in] */ LONG lResLength,
            /* [size_is][in] */ BYTE *pbBuffer);
        
        END_INTERFACE
    } IWiaDataCallbackVtbl;

    interface IWiaDataCallback
    {
        CONST_VTBL struct IWiaDataCallbackVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IWiaDataCallback_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IWiaDataCallback_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IWiaDataCallback_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IWiaDataCallback_BandedDataCallback(This,lMessage,lStatus,lPercentComplete,lOffset,lLength,lReserved,lResLength,pbBuffer)	\
    ( (This)->lpVtbl -> BandedDataCallback(This,lMessage,lStatus,lPercentComplete,lOffset,lLength,lReserved,lResLength,pbBuffer) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [helpstring][call_as] */ HRESULT STDMETHODCALLTYPE IWiaDataCallback_RemoteBandedDataCallback_Proxy( 
    IWiaDataCallback * This,
    /* [in] */ LONG lMessage,
    /* [in] */ LONG lStatus,
    /* [in] */ LONG lPercentComplete,
    /* [in] */ LONG lOffset,
    /* [in] */ LONG lLength,
    /* [in] */ LONG lReserved,
    /* [in] */ LONG lResLength,
    /* [unique][size_is][in] */ __RPC__in_ecount_full_opt(lResLength) BYTE *pbBuffer);


void __RPC_STUB IWiaDataCallback_RemoteBandedDataCallback_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IWiaDataCallback_INTERFACE_DEFINED__ */


/* interface __MIDL_itf_wia_lh_0000_0004 */
/* [local] */ 

typedef struct _WIA_DATA_TRANSFER_INFO
    {
    ULONG ulSize;
    ULONG ulSection;
    ULONG ulBufferSize;
    BOOL bDoubleBuffer;
    ULONG ulReserved1;
    ULONG ulReserved2;
    ULONG ulReserved3;
    } 	WIA_DATA_TRANSFER_INFO;

typedef struct _WIA_DATA_TRANSFER_INFO *PWIA_DATA_TRANSFER_INFO;

typedef struct _WIA_EXTENDED_TRANSFER_INFO
    {
    ULONG ulSize;
    ULONG ulMinBufferSize;
    ULONG ulOptimalBufferSize;
    ULONG ulMaxBufferSize;
    ULONG ulNumBuffers;
    } 	WIA_EXTENDED_TRANSFER_INFO;

typedef struct _WIA_EXTENDED_TRANSFER_INFO *PWIA_EXTENDED_TRANSFER_INFO;



extern RPC_IF_HANDLE __MIDL_itf_wia_lh_0000_0004_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_wia_lh_0000_0004_v0_0_s_ifspec;

#ifndef __IWiaDataTransfer_INTERFACE_DEFINED__
#define __IWiaDataTransfer_INTERFACE_DEFINED__

/* interface IWiaDataTransfer */
/* [unique][helpstring][uuid][object] */ 


EXTERN_C const IID IID_IWiaDataTransfer;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("a6cef998-a5b0-11d2-a08f-00c04f72dc3c")
    IWiaDataTransfer : public IUnknown
    {
    public:
        virtual /* [local] */ HRESULT STDMETHODCALLTYPE idtGetData( 
            /* [out][in] */ LPSTGMEDIUM pMedium,
            /* [unique][in] */ IWiaDataCallback *pIWiaDataCallback) = 0;
        
        virtual /* [local] */ HRESULT STDMETHODCALLTYPE idtGetBandedData( 
            /* [unique][in] */ PWIA_DATA_TRANSFER_INFO pWiaDataTransInfo,
            /* [unique][in] */ IWiaDataCallback *pIWiaDataCallback) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE idtQueryGetData( 
            /* [unique][in] */ __RPC__in_opt WIA_FORMAT_INFO *pfe) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE idtEnumWIA_FORMAT_INFO( 
            /* [out] */ __RPC__deref_out_opt IEnumWIA_FORMAT_INFO **ppEnum) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE idtGetExtendedTransferInfo( 
            /* [out] */ __RPC__out PWIA_EXTENDED_TRANSFER_INFO pExtendedTransferInfo) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IWiaDataTransferVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IWiaDataTransfer * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IWiaDataTransfer * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IWiaDataTransfer * This);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE *idtGetData )( 
            IWiaDataTransfer * This,
            /* [out][in] */ LPSTGMEDIUM pMedium,
            /* [unique][in] */ IWiaDataCallback *pIWiaDataCallback);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE *idtGetBandedData )( 
            IWiaDataTransfer * This,
            /* [unique][in] */ PWIA_DATA_TRANSFER_INFO pWiaDataTransInfo,
            /* [unique][in] */ IWiaDataCallback *pIWiaDataCallback);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *idtQueryGetData )( 
            IWiaDataTransfer * This,
            /* [unique][in] */ __RPC__in_opt WIA_FORMAT_INFO *pfe);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *idtEnumWIA_FORMAT_INFO )( 
            IWiaDataTransfer * This,
            /* [out] */ __RPC__deref_out_opt IEnumWIA_FORMAT_INFO **ppEnum);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *idtGetExtendedTransferInfo )( 
            IWiaDataTransfer * This,
            /* [out] */ __RPC__out PWIA_EXTENDED_TRANSFER_INFO pExtendedTransferInfo);
        
        END_INTERFACE
    } IWiaDataTransferVtbl;

    interface IWiaDataTransfer
    {
        CONST_VTBL struct IWiaDataTransferVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IWiaDataTransfer_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IWiaDataTransfer_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IWiaDataTransfer_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IWiaDataTransfer_idtGetData(This,pMedium,pIWiaDataCallback)	\
    ( (This)->lpVtbl -> idtGetData(This,pMedium,pIWiaDataCallback) ) 

#define IWiaDataTransfer_idtGetBandedData(This,pWiaDataTransInfo,pIWiaDataCallback)	\
    ( (This)->lpVtbl -> idtGetBandedData(This,pWiaDataTransInfo,pIWiaDataCallback) ) 

#define IWiaDataTransfer_idtQueryGetData(This,pfe)	\
    ( (This)->lpVtbl -> idtQueryGetData(This,pfe) ) 

#define IWiaDataTransfer_idtEnumWIA_FORMAT_INFO(This,ppEnum)	\
    ( (This)->lpVtbl -> idtEnumWIA_FORMAT_INFO(This,ppEnum) ) 

#define IWiaDataTransfer_idtGetExtendedTransferInfo(This,pExtendedTransferInfo)	\
    ( (This)->lpVtbl -> idtGetExtendedTransferInfo(This,pExtendedTransferInfo) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [helpstring][call_as] */ HRESULT STDMETHODCALLTYPE IWiaDataTransfer_idtGetDataEx_Proxy( 
    IWiaDataTransfer * This,
    /* [out][in] */ __RPC__inout LPSTGMEDIUM pMedium,
    /* [unique][in] */ __RPC__in_opt IWiaDataCallback *pIWiaDataCallback);


void __RPC_STUB IWiaDataTransfer_idtGetDataEx_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][call_as] */ HRESULT STDMETHODCALLTYPE IWiaDataTransfer_idtGetBandedDataEx_Proxy( 
    IWiaDataTransfer * This,
    /* [unique][in] */ __RPC__in_opt PWIA_DATA_TRANSFER_INFO pWiaDataTransInfo,
    /* [unique][in] */ __RPC__in_opt IWiaDataCallback *pIWiaDataCallback);


void __RPC_STUB IWiaDataTransfer_idtGetBandedDataEx_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IWiaDataTransfer_INTERFACE_DEFINED__ */


#ifndef __IWiaItem_INTERFACE_DEFINED__
#define __IWiaItem_INTERFACE_DEFINED__

/* interface IWiaItem */
/* [unique][helpstring][uuid][object] */ 


EXTERN_C const IID IID_IWiaItem;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("4db1ad10-3391-11d2-9a33-00c04fa36145")
    IWiaItem : public IUnknown
    {
    public:
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE GetItemType( 
            /* [out] */ __RPC__out LONG *pItemType) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE AnalyzeItem( 
            /* [in] */ LONG lFlags) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE EnumChildItems( 
            /* [out] */ __RPC__deref_out_opt IEnumWiaItem **ppIEnumWiaItem) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE DeleteItem( 
            /* [in] */ LONG lFlags) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE CreateChildItem( 
            /* [in] */ LONG lFlags,
            /* [in] */ __RPC__in BSTR bstrItemName,
            /* [in] */ __RPC__in BSTR bstrFullItemName,
            /* [out] */ __RPC__deref_out_opt IWiaItem **ppIWiaItem) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE EnumRegisterEventInfo( 
            /* [in] */ LONG lFlags,
            /* [in] */ __RPC__in const GUID *pEventGUID,
            /* [out] */ __RPC__deref_out_opt IEnumWIA_DEV_CAPS **ppIEnum) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE FindItemByName( 
            /* [in] */ LONG lFlags,
            /* [in] */ __RPC__in BSTR bstrFullItemName,
            /* [out] */ __RPC__deref_out_opt IWiaItem **ppIWiaItem) = 0;
        
        virtual /* [local] */ HRESULT STDMETHODCALLTYPE DeviceDlg( 
            /* [in] */ HWND hwndParent,
            /* [in] */ LONG lFlags,
            /* [in] */ LONG lIntent,
            /* [out] */ LONG *plItemCount,
            /* [out] */ IWiaItem ***ppIWiaItem) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE DeviceCommand( 
            /* [in] */ LONG lFlags,
            /* [in] */ __RPC__in const GUID *pCmdGUID,
            /* [out][in] */ __RPC__deref_inout_opt IWiaItem **pIWiaItem) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE GetRootItem( 
            /* [out] */ __RPC__deref_out_opt IWiaItem **ppIWiaItem) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE EnumDeviceCapabilities( 
            /* [in] */ LONG lFlags,
            /* [out] */ __RPC__deref_out_opt IEnumWIA_DEV_CAPS **ppIEnumWIA_DEV_CAPS) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE DumpItemData( 
            /* [out] */ __RPC__deref_out_opt BSTR *bstrData) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE DumpDrvItemData( 
            /* [out] */ __RPC__deref_out_opt BSTR *bstrData) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE DumpTreeItemData( 
            /* [out] */ __RPC__deref_out_opt BSTR *bstrData) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE Diagnostic( 
            /* [in] */ ULONG ulSize,
            /* [size_is][in] */ __RPC__in_ecount_full(ulSize) BYTE *pBuffer) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IWiaItemVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IWiaItem * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IWiaItem * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IWiaItem * This);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *GetItemType )( 
            IWiaItem * This,
            /* [out] */ __RPC__out LONG *pItemType);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *AnalyzeItem )( 
            IWiaItem * This,
            /* [in] */ LONG lFlags);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *EnumChildItems )( 
            IWiaItem * This,
            /* [out] */ __RPC__deref_out_opt IEnumWiaItem **ppIEnumWiaItem);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *DeleteItem )( 
            IWiaItem * This,
            /* [in] */ LONG lFlags);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *CreateChildItem )( 
            IWiaItem * This,
            /* [in] */ LONG lFlags,
            /* [in] */ __RPC__in BSTR bstrItemName,
            /* [in] */ __RPC__in BSTR bstrFullItemName,
            /* [out] */ __RPC__deref_out_opt IWiaItem **ppIWiaItem);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *EnumRegisterEventInfo )( 
            IWiaItem * This,
            /* [in] */ LONG lFlags,
            /* [in] */ __RPC__in const GUID *pEventGUID,
            /* [out] */ __RPC__deref_out_opt IEnumWIA_DEV_CAPS **ppIEnum);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *FindItemByName )( 
            IWiaItem * This,
            /* [in] */ LONG lFlags,
            /* [in] */ __RPC__in BSTR bstrFullItemName,
            /* [out] */ __RPC__deref_out_opt IWiaItem **ppIWiaItem);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE *DeviceDlg )( 
            IWiaItem * This,
            /* [in] */ HWND hwndParent,
            /* [in] */ LONG lFlags,
            /* [in] */ LONG lIntent,
            /* [out] */ LONG *plItemCount,
            /* [out] */ IWiaItem ***ppIWiaItem);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *DeviceCommand )( 
            IWiaItem * This,
            /* [in] */ LONG lFlags,
            /* [in] */ __RPC__in const GUID *pCmdGUID,
            /* [out][in] */ __RPC__deref_inout_opt IWiaItem **pIWiaItem);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *GetRootItem )( 
            IWiaItem * This,
            /* [out] */ __RPC__deref_out_opt IWiaItem **ppIWiaItem);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *EnumDeviceCapabilities )( 
            IWiaItem * This,
            /* [in] */ LONG lFlags,
            /* [out] */ __RPC__deref_out_opt IEnumWIA_DEV_CAPS **ppIEnumWIA_DEV_CAPS);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *DumpItemData )( 
            IWiaItem * This,
            /* [out] */ __RPC__deref_out_opt BSTR *bstrData);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *DumpDrvItemData )( 
            IWiaItem * This,
            /* [out] */ __RPC__deref_out_opt BSTR *bstrData);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *DumpTreeItemData )( 
            IWiaItem * This,
            /* [out] */ __RPC__deref_out_opt BSTR *bstrData);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *Diagnostic )( 
            IWiaItem * This,
            /* [in] */ ULONG ulSize,
            /* [size_is][in] */ __RPC__in_ecount_full(ulSize) BYTE *pBuffer);
        
        END_INTERFACE
    } IWiaItemVtbl;

    interface IWiaItem
    {
        CONST_VTBL struct IWiaItemVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IWiaItem_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IWiaItem_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IWiaItem_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IWiaItem_GetItemType(This,pItemType)	\
    ( (This)->lpVtbl -> GetItemType(This,pItemType) ) 

#define IWiaItem_AnalyzeItem(This,lFlags)	\
    ( (This)->lpVtbl -> AnalyzeItem(This,lFlags) ) 

#define IWiaItem_EnumChildItems(This,ppIEnumWiaItem)	\
    ( (This)->lpVtbl -> EnumChildItems(This,ppIEnumWiaItem) ) 

#define IWiaItem_DeleteItem(This,lFlags)	\
    ( (This)->lpVtbl -> DeleteItem(This,lFlags) ) 

#define IWiaItem_CreateChildItem(This,lFlags,bstrItemName,bstrFullItemName,ppIWiaItem)	\
    ( (This)->lpVtbl -> CreateChildItem(This,lFlags,bstrItemName,bstrFullItemName,ppIWiaItem) ) 

#define IWiaItem_EnumRegisterEventInfo(This,lFlags,pEventGUID,ppIEnum)	\
    ( (This)->lpVtbl -> EnumRegisterEventInfo(This,lFlags,pEventGUID,ppIEnum) ) 

#define IWiaItem_FindItemByName(This,lFlags,bstrFullItemName,ppIWiaItem)	\
    ( (This)->lpVtbl -> FindItemByName(This,lFlags,bstrFullItemName,ppIWiaItem) ) 

#define IWiaItem_DeviceDlg(This,hwndParent,lFlags,lIntent,plItemCount,ppIWiaItem)	\
    ( (This)->lpVtbl -> DeviceDlg(This,hwndParent,lFlags,lIntent,plItemCount,ppIWiaItem) ) 

#define IWiaItem_DeviceCommand(This,lFlags,pCmdGUID,pIWiaItem)	\
    ( (This)->lpVtbl -> DeviceCommand(This,lFlags,pCmdGUID,pIWiaItem) ) 

#define IWiaItem_GetRootItem(This,ppIWiaItem)	\
    ( (This)->lpVtbl -> GetRootItem(This,ppIWiaItem) ) 

#define IWiaItem_EnumDeviceCapabilities(This,lFlags,ppIEnumWIA_DEV_CAPS)	\
    ( (This)->lpVtbl -> EnumDeviceCapabilities(This,lFlags,ppIEnumWIA_DEV_CAPS) ) 

#define IWiaItem_DumpItemData(This,bstrData)	\
    ( (This)->lpVtbl -> DumpItemData(This,bstrData) ) 

#define IWiaItem_DumpDrvItemData(This,bstrData)	\
    ( (This)->lpVtbl -> DumpDrvItemData(This,bstrData) ) 

#define IWiaItem_DumpTreeItemData(This,bstrData)	\
    ( (This)->lpVtbl -> DumpTreeItemData(This,bstrData) ) 

#define IWiaItem_Diagnostic(This,ulSize,pBuffer)	\
    ( (This)->lpVtbl -> Diagnostic(This,ulSize,pBuffer) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [nocode][helpstring][call_as] */ HRESULT STDMETHODCALLTYPE IWiaItem_LocalDeviceDlg_Proxy( 
    IWiaItem * This,
    /* [in] */ __RPC__in HWND hwndParent,
    /* [in] */ LONG lFlags,
    /* [in] */ LONG lIntent,
    /* [out] */ __RPC__out LONG *plItemCount,
    /* [out] */ __RPC__deref_out_opt IWiaItem ***pIWiaItem);


void __RPC_STUB IWiaItem_LocalDeviceDlg_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IWiaItem_INTERFACE_DEFINED__ */


#ifndef __IWiaPropertyStorage_INTERFACE_DEFINED__
#define __IWiaPropertyStorage_INTERFACE_DEFINED__

/* interface IWiaPropertyStorage */
/* [unique][helpstring][uuid][object] */ 


EXTERN_C const IID IID_IWiaPropertyStorage;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("98B5E8A0-29CC-491a-AAC0-E6DB4FDCCEB6")
    IWiaPropertyStorage : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE ReadMultiple( 
            /* [in] */ ULONG cpspec,
            /* [size_is][in] */ __RPC__in_ecount_full(cpspec) const PROPSPEC rgpspec[  ],
            /* [size_is][out] */ __RPC__out_ecount_full(cpspec) PROPVARIANT rgpropvar[  ]) = 0;
        
        virtual /* [local] */ HRESULT STDMETHODCALLTYPE WriteMultiple( 
            /* [in] */ ULONG cpspec,
            /* [size_is][in] */ const PROPSPEC rgpspec[  ],
            /* [size_is][in] */ const PROPVARIANT rgpropvar[  ],
            /* [in] */ PROPID propidNameFirst) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE DeleteMultiple( 
            /* [in] */ ULONG cpspec,
            /* [size_is][in] */ __RPC__in_ecount_full(cpspec) const PROPSPEC rgpspec[  ]) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE ReadPropertyNames( 
            /* [in] */ ULONG cpropid,
            /* [size_is][in] */ __RPC__in_ecount_full(cpropid) const PROPID rgpropid[  ],
            /* [size_is][out] */ __RPC__out_ecount_full(cpropid) LPOLESTR rglpwstrName[  ]) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE WritePropertyNames( 
            /* [in] */ ULONG cpropid,
            /* [size_is][in] */ __RPC__in_ecount_full(cpropid) const PROPID rgpropid[  ],
            /* [size_is][in] */ __RPC__in_ecount_full(cpropid) const LPOLESTR rglpwstrName[  ]) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE DeletePropertyNames( 
            /* [in] */ ULONG cpropid,
            /* [size_is][in] */ __RPC__in_ecount_full(cpropid) const PROPID rgpropid[  ]) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Commit( 
            /* [in] */ DWORD grfCommitFlags) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Revert( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Enum( 
            /* [out] */ __RPC__deref_out_opt IEnumSTATPROPSTG **ppenum) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetTimes( 
            /* [in] */ __RPC__in const FILETIME *pctime,
            /* [in] */ __RPC__in const FILETIME *patime,
            /* [in] */ __RPC__in const FILETIME *pmtime) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetClass( 
            /* [in] */ __RPC__in REFCLSID clsid) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Stat( 
            /* [out] */ __RPC__out STATPROPSETSTG *pstatpsstg) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE GetPropertyAttributes( 
            /* [in] */ ULONG cpspec,
            /* [size_is][in] */ __RPC__in_ecount_full(cpspec) PROPSPEC rgpspec[  ],
            /* [size_is][out] */ __RPC__out_ecount_full(cpspec) ULONG rgflags[  ],
            /* [size_is][out] */ __RPC__out_ecount_full(cpspec) PROPVARIANT rgpropvar[  ]) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE GetCount( 
            /* [out] */ __RPC__out ULONG *pulNumProps) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE GetPropertyStream( 
            /* [out] */ __RPC__out GUID *pCompatibilityId,
            /* [out] */ __RPC__deref_out_opt IStream **ppIStream) = 0;
        
        virtual /* [local] */ HRESULT STDMETHODCALLTYPE SetPropertyStream( 
            /* [in] */ GUID *pCompatibilityId,
            /* [unique][in] */ IStream *pIStream) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IWiaPropertyStorageVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IWiaPropertyStorage * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IWiaPropertyStorage * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IWiaPropertyStorage * This);
        
        HRESULT ( STDMETHODCALLTYPE *ReadMultiple )( 
            IWiaPropertyStorage * This,
            /* [in] */ ULONG cpspec,
            /* [size_is][in] */ __RPC__in_ecount_full(cpspec) const PROPSPEC rgpspec[  ],
            /* [size_is][out] */ __RPC__out_ecount_full(cpspec) PROPVARIANT rgpropvar[  ]);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE *WriteMultiple )( 
            IWiaPropertyStorage * This,
            /* [in] */ ULONG cpspec,
            /* [size_is][in] */ const PROPSPEC rgpspec[  ],
            /* [size_is][in] */ const PROPVARIANT rgpropvar[  ],
            /* [in] */ PROPID propidNameFirst);
        
        HRESULT ( STDMETHODCALLTYPE *DeleteMultiple )( 
            IWiaPropertyStorage * This,
            /* [in] */ ULONG cpspec,
            /* [size_is][in] */ __RPC__in_ecount_full(cpspec) const PROPSPEC rgpspec[  ]);
        
        HRESULT ( STDMETHODCALLTYPE *ReadPropertyNames )( 
            IWiaPropertyStorage * This,
            /* [in] */ ULONG cpropid,
            /* [size_is][in] */ __RPC__in_ecount_full(cpropid) const PROPID rgpropid[  ],
            /* [size_is][out] */ __RPC__out_ecount_full(cpropid) LPOLESTR rglpwstrName[  ]);
        
        HRESULT ( STDMETHODCALLTYPE *WritePropertyNames )( 
            IWiaPropertyStorage * This,
            /* [in] */ ULONG cpropid,
            /* [size_is][in] */ __RPC__in_ecount_full(cpropid) const PROPID rgpropid[  ],
            /* [size_is][in] */ __RPC__in_ecount_full(cpropid) const LPOLESTR rglpwstrName[  ]);
        
        HRESULT ( STDMETHODCALLTYPE *DeletePropertyNames )( 
            IWiaPropertyStorage * This,
            /* [in] */ ULONG cpropid,
            /* [size_is][in] */ __RPC__in_ecount_full(cpropid) const PROPID rgpropid[  ]);
        
        HRESULT ( STDMETHODCALLTYPE *Commit )( 
            IWiaPropertyStorage * This,
            /* [in] */ DWORD grfCommitFlags);
        
        HRESULT ( STDMETHODCALLTYPE *Revert )( 
            IWiaPropertyStorage * This);
        
        HRESULT ( STDMETHODCALLTYPE *Enum )( 
            IWiaPropertyStorage * This,
            /* [out] */ __RPC__deref_out_opt IEnumSTATPROPSTG **ppenum);
        
        HRESULT ( STDMETHODCALLTYPE *SetTimes )( 
            IWiaPropertyStorage * This,
            /* [in] */ __RPC__in const FILETIME *pctime,
            /* [in] */ __RPC__in const FILETIME *patime,
            /* [in] */ __RPC__in const FILETIME *pmtime);
        
        HRESULT ( STDMETHODCALLTYPE *SetClass )( 
            IWiaPropertyStorage * This,
            /* [in] */ __RPC__in REFCLSID clsid);
        
        HRESULT ( STDMETHODCALLTYPE *Stat )( 
            IWiaPropertyStorage * This,
            /* [out] */ __RPC__out STATPROPSETSTG *pstatpsstg);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *GetPropertyAttributes )( 
            IWiaPropertyStorage * This,
            /* [in] */ ULONG cpspec,
            /* [size_is][in] */ __RPC__in_ecount_full(cpspec) PROPSPEC rgpspec[  ],
            /* [size_is][out] */ __RPC__out_ecount_full(cpspec) ULONG rgflags[  ],
            /* [size_is][out] */ __RPC__out_ecount_full(cpspec) PROPVARIANT rgpropvar[  ]);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *GetCount )( 
            IWiaPropertyStorage * This,
            /* [out] */ __RPC__out ULONG *pulNumProps);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *GetPropertyStream )( 
            IWiaPropertyStorage * This,
            /* [out] */ __RPC__out GUID *pCompatibilityId,
            /* [out] */ __RPC__deref_out_opt IStream **ppIStream);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE *SetPropertyStream )( 
            IWiaPropertyStorage * This,
            /* [in] */ GUID *pCompatibilityId,
            /* [unique][in] */ IStream *pIStream);
        
        END_INTERFACE
    } IWiaPropertyStorageVtbl;

    interface IWiaPropertyStorage
    {
        CONST_VTBL struct IWiaPropertyStorageVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IWiaPropertyStorage_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IWiaPropertyStorage_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IWiaPropertyStorage_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IWiaPropertyStorage_ReadMultiple(This,cpspec,rgpspec,rgpropvar)	\
    ( (This)->lpVtbl -> ReadMultiple(This,cpspec,rgpspec,rgpropvar) ) 

#define IWiaPropertyStorage_WriteMultiple(This,cpspec,rgpspec,rgpropvar,propidNameFirst)	\
    ( (This)->lpVtbl -> WriteMultiple(This,cpspec,rgpspec,rgpropvar,propidNameFirst) ) 

#define IWiaPropertyStorage_DeleteMultiple(This,cpspec,rgpspec)	\
    ( (This)->lpVtbl -> DeleteMultiple(This,cpspec,rgpspec) ) 

#define IWiaPropertyStorage_ReadPropertyNames(This,cpropid,rgpropid,rglpwstrName)	\
    ( (This)->lpVtbl -> ReadPropertyNames(This,cpropid,rgpropid,rglpwstrName) ) 

#define IWiaPropertyStorage_WritePropertyNames(This,cpropid,rgpropid,rglpwstrName)	\
    ( (This)->lpVtbl -> WritePropertyNames(This,cpropid,rgpropid,rglpwstrName) ) 

#define IWiaPropertyStorage_DeletePropertyNames(This,cpropid,rgpropid)	\
    ( (This)->lpVtbl -> DeletePropertyNames(This,cpropid,rgpropid) ) 

#define IWiaPropertyStorage_Commit(This,grfCommitFlags)	\
    ( (This)->lpVtbl -> Commit(This,grfCommitFlags) ) 

#define IWiaPropertyStorage_Revert(This)	\
    ( (This)->lpVtbl -> Revert(This) ) 

#define IWiaPropertyStorage_Enum(This,ppenum)	\
    ( (This)->lpVtbl -> Enum(This,ppenum) ) 

#define IWiaPropertyStorage_SetTimes(This,pctime,patime,pmtime)	\
    ( (This)->lpVtbl -> SetTimes(This,pctime,patime,pmtime) ) 

#define IWiaPropertyStorage_SetClass(This,clsid)	\
    ( (This)->lpVtbl -> SetClass(This,clsid) ) 

#define IWiaPropertyStorage_Stat(This,pstatpsstg)	\
    ( (This)->lpVtbl -> Stat(This,pstatpsstg) ) 

#define IWiaPropertyStorage_GetPropertyAttributes(This,cpspec,rgpspec,rgflags,rgpropvar)	\
    ( (This)->lpVtbl -> GetPropertyAttributes(This,cpspec,rgpspec,rgflags,rgpropvar) ) 

#define IWiaPropertyStorage_GetCount(This,pulNumProps)	\
    ( (This)->lpVtbl -> GetCount(This,pulNumProps) ) 

#define IWiaPropertyStorage_GetPropertyStream(This,pCompatibilityId,ppIStream)	\
    ( (This)->lpVtbl -> GetPropertyStream(This,pCompatibilityId,ppIStream) ) 

#define IWiaPropertyStorage_SetPropertyStream(This,pCompatibilityId,pIStream)	\
    ( (This)->lpVtbl -> SetPropertyStream(This,pCompatibilityId,pIStream) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [call_as] */ HRESULT STDMETHODCALLTYPE IWiaPropertyStorage_RemoteWriteMultiple_Proxy( 
    IWiaPropertyStorage * This,
    /* [in] */ ULONG cpspec,
    /* [size_is][in] */ __RPC__in_ecount_full(cpspec) const PROPSPEC *rgpspec,
    /* [size_is][in] */ __RPC__in_ecount_full(cpspec) const PROPVARIANT *rgpropvar,
    /* [in] */ PROPID propidNameFirst);


void __RPC_STUB IWiaPropertyStorage_RemoteWriteMultiple_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][call_as] */ HRESULT STDMETHODCALLTYPE IWiaPropertyStorage_RemoteSetPropertyStream_Proxy( 
    IWiaPropertyStorage * This,
    /* [in] */ __RPC__in GUID *pCompatibilityId,
    /* [unique][in] */ __RPC__in_opt IStream *pIStream);


void __RPC_STUB IWiaPropertyStorage_RemoteSetPropertyStream_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IWiaPropertyStorage_INTERFACE_DEFINED__ */


#ifndef __IEnumWiaItem_INTERFACE_DEFINED__
#define __IEnumWiaItem_INTERFACE_DEFINED__

/* interface IEnumWiaItem */
/* [unique][helpstring][uuid][object] */ 


EXTERN_C const IID IID_IEnumWiaItem;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("5e8383fc-3391-11d2-9a33-00c04fa36145")
    IEnumWiaItem : public IUnknown
    {
    public:
        virtual /* [local] */ HRESULT STDMETHODCALLTYPE Next( 
            /* [in] */ ULONG celt,
            /* [length_is][size_is][out] */ IWiaItem **ppIWiaItem,
            /* [unique][out][in] */ ULONG *pceltFetched) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE Skip( 
            /* [in] */ ULONG celt) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE Reset( void) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE Clone( 
            /* [out] */ __RPC__deref_out_opt IEnumWiaItem **ppIEnum) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE GetCount( 
            /* [out] */ __RPC__out ULONG *celt) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IEnumWiaItemVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IEnumWiaItem * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IEnumWiaItem * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IEnumWiaItem * This);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE *Next )( 
            IEnumWiaItem * This,
            /* [in] */ ULONG celt,
            /* [length_is][size_is][out] */ IWiaItem **ppIWiaItem,
            /* [unique][out][in] */ ULONG *pceltFetched);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *Skip )( 
            IEnumWiaItem * This,
            /* [in] */ ULONG celt);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *Reset )( 
            IEnumWiaItem * This);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *Clone )( 
            IEnumWiaItem * This,
            /* [out] */ __RPC__deref_out_opt IEnumWiaItem **ppIEnum);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *GetCount )( 
            IEnumWiaItem * This,
            /* [out] */ __RPC__out ULONG *celt);
        
        END_INTERFACE
    } IEnumWiaItemVtbl;

    interface IEnumWiaItem
    {
        CONST_VTBL struct IEnumWiaItemVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IEnumWiaItem_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IEnumWiaItem_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IEnumWiaItem_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IEnumWiaItem_Next(This,celt,ppIWiaItem,pceltFetched)	\
    ( (This)->lpVtbl -> Next(This,celt,ppIWiaItem,pceltFetched) ) 

#define IEnumWiaItem_Skip(This,celt)	\
    ( (This)->lpVtbl -> Skip(This,celt) ) 

#define IEnumWiaItem_Reset(This)	\
    ( (This)->lpVtbl -> Reset(This) ) 

#define IEnumWiaItem_Clone(This,ppIEnum)	\
    ( (This)->lpVtbl -> Clone(This,ppIEnum) ) 

#define IEnumWiaItem_GetCount(This,celt)	\
    ( (This)->lpVtbl -> GetCount(This,celt) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [helpstring][call_as] */ HRESULT STDMETHODCALLTYPE IEnumWiaItem_RemoteNext_Proxy( 
    IEnumWiaItem * This,
    /* [in] */ ULONG celt,
    /* [length_is][size_is][out] */ __RPC__out_ecount_part(celt, *pceltFetched) IWiaItem **ppIWiaItem,
    /* [unique][out][in] */ __RPC__inout_opt ULONG *pceltFetched);


void __RPC_STUB IEnumWiaItem_RemoteNext_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IEnumWiaItem_INTERFACE_DEFINED__ */


/* interface __MIDL_itf_wia_lh_0000_0008 */
/* [local] */ 

typedef struct _WIA_DEV_CAP
    {
    GUID guid;
    ULONG ulFlags;
    BSTR bstrName;
    BSTR bstrDescription;
    BSTR bstrIcon;
    BSTR bstrCommandline;
    } 	WIA_DEV_CAP;

typedef struct _WIA_DEV_CAP *PWIA_DEV_CAP;

typedef struct _WIA_DEV_CAP WIA_EVENT_HANDLER;

typedef struct _WIA_DEV_CAP *PWIA_EVENT_HANDLER;



extern RPC_IF_HANDLE __MIDL_itf_wia_lh_0000_0008_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_wia_lh_0000_0008_v0_0_s_ifspec;

#ifndef __IEnumWIA_DEV_CAPS_INTERFACE_DEFINED__
#define __IEnumWIA_DEV_CAPS_INTERFACE_DEFINED__

/* interface IEnumWIA_DEV_CAPS */
/* [unique][helpstring][uuid][object] */ 


EXTERN_C const IID IID_IEnumWIA_DEV_CAPS;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("1fcc4287-aca6-11d2-a093-00c04f72dc3c")
    IEnumWIA_DEV_CAPS : public IUnknown
    {
    public:
        virtual /* [local] */ HRESULT STDMETHODCALLTYPE Next( 
            /* [in] */ ULONG celt,
            /* [length_is][size_is][out] */ WIA_DEV_CAP *rgelt,
            /* [unique][out][in] */ ULONG *pceltFetched) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE Skip( 
            /* [in] */ ULONG celt) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE Reset( void) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE Clone( 
            /* [out] */ __RPC__deref_out_opt IEnumWIA_DEV_CAPS **ppIEnum) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE GetCount( 
            /* [out] */ __RPC__out ULONG *pcelt) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IEnumWIA_DEV_CAPSVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IEnumWIA_DEV_CAPS * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IEnumWIA_DEV_CAPS * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IEnumWIA_DEV_CAPS * This);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE *Next )( 
            IEnumWIA_DEV_CAPS * This,
            /* [in] */ ULONG celt,
            /* [length_is][size_is][out] */ WIA_DEV_CAP *rgelt,
            /* [unique][out][in] */ ULONG *pceltFetched);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *Skip )( 
            IEnumWIA_DEV_CAPS * This,
            /* [in] */ ULONG celt);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *Reset )( 
            IEnumWIA_DEV_CAPS * This);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *Clone )( 
            IEnumWIA_DEV_CAPS * This,
            /* [out] */ __RPC__deref_out_opt IEnumWIA_DEV_CAPS **ppIEnum);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *GetCount )( 
            IEnumWIA_DEV_CAPS * This,
            /* [out] */ __RPC__out ULONG *pcelt);
        
        END_INTERFACE
    } IEnumWIA_DEV_CAPSVtbl;

    interface IEnumWIA_DEV_CAPS
    {
        CONST_VTBL struct IEnumWIA_DEV_CAPSVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IEnumWIA_DEV_CAPS_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IEnumWIA_DEV_CAPS_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IEnumWIA_DEV_CAPS_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IEnumWIA_DEV_CAPS_Next(This,celt,rgelt,pceltFetched)	\
    ( (This)->lpVtbl -> Next(This,celt,rgelt,pceltFetched) ) 

#define IEnumWIA_DEV_CAPS_Skip(This,celt)	\
    ( (This)->lpVtbl -> Skip(This,celt) ) 

#define IEnumWIA_DEV_CAPS_Reset(This)	\
    ( (This)->lpVtbl -> Reset(This) ) 

#define IEnumWIA_DEV_CAPS_Clone(This,ppIEnum)	\
    ( (This)->lpVtbl -> Clone(This,ppIEnum) ) 

#define IEnumWIA_DEV_CAPS_GetCount(This,pcelt)	\
    ( (This)->lpVtbl -> GetCount(This,pcelt) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [helpstring][call_as] */ HRESULT STDMETHODCALLTYPE IEnumWIA_DEV_CAPS_RemoteNext_Proxy( 
    IEnumWIA_DEV_CAPS * This,
    /* [in] */ ULONG celt,
    /* [length_is][size_is][out] */ __RPC__out_ecount_part(celt, *pceltFetched) WIA_DEV_CAP *rgelt,
    /* [unique][out][in] */ __RPC__inout_opt ULONG *pceltFetched);


void __RPC_STUB IEnumWIA_DEV_CAPS_RemoteNext_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IEnumWIA_DEV_CAPS_INTERFACE_DEFINED__ */


#ifndef __IEnumWIA_FORMAT_INFO_INTERFACE_DEFINED__
#define __IEnumWIA_FORMAT_INFO_INTERFACE_DEFINED__

/* interface IEnumWIA_FORMAT_INFO */
/* [unique][helpstring][uuid][object] */ 


EXTERN_C const IID IID_IEnumWIA_FORMAT_INFO;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("81BEFC5B-656D-44f1-B24C-D41D51B4DC81")
    IEnumWIA_FORMAT_INFO : public IUnknown
    {
    public:
        virtual /* [local] */ HRESULT STDMETHODCALLTYPE Next( 
            /* [in] */ ULONG celt,
            /* [length_is][size_is][out] */ WIA_FORMAT_INFO *rgelt,
            /* [unique][out][in] */ ULONG *pceltFetched) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE Skip( 
            /* [in] */ ULONG celt) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE Reset( void) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE Clone( 
            /* [out] */ __RPC__deref_out_opt IEnumWIA_FORMAT_INFO **ppIEnum) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE GetCount( 
            /* [out] */ __RPC__out ULONG *pcelt) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IEnumWIA_FORMAT_INFOVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IEnumWIA_FORMAT_INFO * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IEnumWIA_FORMAT_INFO * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IEnumWIA_FORMAT_INFO * This);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE *Next )( 
            IEnumWIA_FORMAT_INFO * This,
            /* [in] */ ULONG celt,
            /* [length_is][size_is][out] */ WIA_FORMAT_INFO *rgelt,
            /* [unique][out][in] */ ULONG *pceltFetched);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *Skip )( 
            IEnumWIA_FORMAT_INFO * This,
            /* [in] */ ULONG celt);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *Reset )( 
            IEnumWIA_FORMAT_INFO * This);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *Clone )( 
            IEnumWIA_FORMAT_INFO * This,
            /* [out] */ __RPC__deref_out_opt IEnumWIA_FORMAT_INFO **ppIEnum);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *GetCount )( 
            IEnumWIA_FORMAT_INFO * This,
            /* [out] */ __RPC__out ULONG *pcelt);
        
        END_INTERFACE
    } IEnumWIA_FORMAT_INFOVtbl;

    interface IEnumWIA_FORMAT_INFO
    {
        CONST_VTBL struct IEnumWIA_FORMAT_INFOVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IEnumWIA_FORMAT_INFO_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IEnumWIA_FORMAT_INFO_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IEnumWIA_FORMAT_INFO_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IEnumWIA_FORMAT_INFO_Next(This,celt,rgelt,pceltFetched)	\
    ( (This)->lpVtbl -> Next(This,celt,rgelt,pceltFetched) ) 

#define IEnumWIA_FORMAT_INFO_Skip(This,celt)	\
    ( (This)->lpVtbl -> Skip(This,celt) ) 

#define IEnumWIA_FORMAT_INFO_Reset(This)	\
    ( (This)->lpVtbl -> Reset(This) ) 

#define IEnumWIA_FORMAT_INFO_Clone(This,ppIEnum)	\
    ( (This)->lpVtbl -> Clone(This,ppIEnum) ) 

#define IEnumWIA_FORMAT_INFO_GetCount(This,pcelt)	\
    ( (This)->lpVtbl -> GetCount(This,pcelt) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [helpstring][call_as] */ HRESULT STDMETHODCALLTYPE IEnumWIA_FORMAT_INFO_RemoteNext_Proxy( 
    IEnumWIA_FORMAT_INFO * This,
    /* [in] */ ULONG celt,
    /* [length_is][size_is][out] */ __RPC__out_ecount_part(celt, *pceltFetched) WIA_FORMAT_INFO *rgelt,
    /* [unique][out][in] */ __RPC__inout_opt ULONG *pceltFetched);


void __RPC_STUB IEnumWIA_FORMAT_INFO_RemoteNext_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IEnumWIA_FORMAT_INFO_INTERFACE_DEFINED__ */


#ifndef __IWiaLog_INTERFACE_DEFINED__
#define __IWiaLog_INTERFACE_DEFINED__

/* interface IWiaLog */
/* [unique][helpstring][uuid][object] */ 


EXTERN_C const IID IID_IWiaLog;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("A00C10B6-82A1-452f-8B6C-86062AAD6890")
    IWiaLog : public IUnknown
    {
    public:
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE InitializeLog( 
            /* [in] */ LONG hInstance) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE hResult( 
            /* [in] */ HRESULT hResult) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE Log( 
            /* [in] */ LONG lFlags,
            /* [in] */ LONG lResID,
            /* [in] */ LONG lDetail,
            /* [in] */ __RPC__in BSTR bstrText) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IWiaLogVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IWiaLog * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IWiaLog * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IWiaLog * This);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *InitializeLog )( 
            IWiaLog * This,
            /* [in] */ LONG hInstance);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *hResult )( 
            IWiaLog * This,
            /* [in] */ HRESULT hResult);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *Log )( 
            IWiaLog * This,
            /* [in] */ LONG lFlags,
            /* [in] */ LONG lResID,
            /* [in] */ LONG lDetail,
            /* [in] */ __RPC__in BSTR bstrText);
        
        END_INTERFACE
    } IWiaLogVtbl;

    interface IWiaLog
    {
        CONST_VTBL struct IWiaLogVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IWiaLog_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IWiaLog_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IWiaLog_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IWiaLog_InitializeLog(This,hInstance)	\
    ( (This)->lpVtbl -> InitializeLog(This,hInstance) ) 

#define IWiaLog_hResult(This,hResult)	\
    ( (This)->lpVtbl -> hResult(This,hResult) ) 

#define IWiaLog_Log(This,lFlags,lResID,lDetail,bstrText)	\
    ( (This)->lpVtbl -> Log(This,lFlags,lResID,lDetail,bstrText) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IWiaLog_INTERFACE_DEFINED__ */


#ifndef __IWiaLogEx_INTERFACE_DEFINED__
#define __IWiaLogEx_INTERFACE_DEFINED__

/* interface IWiaLogEx */
/* [unique][helpstring][uuid][object] */ 


EXTERN_C const IID IID_IWiaLogEx;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("AF1F22AC-7A40-4787-B421-AEb47A1FBD0B")
    IWiaLogEx : public IUnknown
    {
    public:
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE InitializeLogEx( 
            /* [in] */ __RPC__in BYTE *hInstance) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE hResult( 
            /* [in] */ HRESULT hResult) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE Log( 
            /* [in] */ LONG lFlags,
            /* [in] */ LONG lResID,
            /* [in] */ LONG lDetail,
            /* [in] */ __RPC__in BSTR bstrText) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE hResultEx( 
            /* [in] */ LONG lMethodId,
            /* [in] */ HRESULT hResult) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE LogEx( 
            /* [in] */ LONG lMethodId,
            /* [in] */ LONG lFlags,
            /* [in] */ LONG lResID,
            /* [in] */ LONG lDetail,
            /* [in] */ __RPC__in BSTR bstrText) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IWiaLogExVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IWiaLogEx * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IWiaLogEx * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IWiaLogEx * This);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *InitializeLogEx )( 
            IWiaLogEx * This,
            /* [in] */ __RPC__in BYTE *hInstance);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *hResult )( 
            IWiaLogEx * This,
            /* [in] */ HRESULT hResult);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *Log )( 
            IWiaLogEx * This,
            /* [in] */ LONG lFlags,
            /* [in] */ LONG lResID,
            /* [in] */ LONG lDetail,
            /* [in] */ __RPC__in BSTR bstrText);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *hResultEx )( 
            IWiaLogEx * This,
            /* [in] */ LONG lMethodId,
            /* [in] */ HRESULT hResult);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *LogEx )( 
            IWiaLogEx * This,
            /* [in] */ LONG lMethodId,
            /* [in] */ LONG lFlags,
            /* [in] */ LONG lResID,
            /* [in] */ LONG lDetail,
            /* [in] */ __RPC__in BSTR bstrText);
        
        END_INTERFACE
    } IWiaLogExVtbl;

    interface IWiaLogEx
    {
        CONST_VTBL struct IWiaLogExVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IWiaLogEx_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IWiaLogEx_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IWiaLogEx_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IWiaLogEx_InitializeLogEx(This,hInstance)	\
    ( (This)->lpVtbl -> InitializeLogEx(This,hInstance) ) 

#define IWiaLogEx_hResult(This,hResult)	\
    ( (This)->lpVtbl -> hResult(This,hResult) ) 

#define IWiaLogEx_Log(This,lFlags,lResID,lDetail,bstrText)	\
    ( (This)->lpVtbl -> Log(This,lFlags,lResID,lDetail,bstrText) ) 

#define IWiaLogEx_hResultEx(This,lMethodId,hResult)	\
    ( (This)->lpVtbl -> hResultEx(This,lMethodId,hResult) ) 

#define IWiaLogEx_LogEx(This,lMethodId,lFlags,lResID,lDetail,bstrText)	\
    ( (This)->lpVtbl -> LogEx(This,lMethodId,lFlags,lResID,lDetail,bstrText) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IWiaLogEx_INTERFACE_DEFINED__ */


#ifndef __IWiaNotifyDevMgr_INTERFACE_DEFINED__
#define __IWiaNotifyDevMgr_INTERFACE_DEFINED__

/* interface IWiaNotifyDevMgr */
/* [unique][helpstring][uuid][object] */ 


EXTERN_C const IID IID_IWiaNotifyDevMgr;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("70681EA0-E7BF-4291-9FB1-4E8813A3F78E")
    IWiaNotifyDevMgr : public IUnknown
    {
    public:
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE NewDeviceArrival( void) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IWiaNotifyDevMgrVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IWiaNotifyDevMgr * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IWiaNotifyDevMgr * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IWiaNotifyDevMgr * This);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *NewDeviceArrival )( 
            IWiaNotifyDevMgr * This);
        
        END_INTERFACE
    } IWiaNotifyDevMgrVtbl;

    interface IWiaNotifyDevMgr
    {
        CONST_VTBL struct IWiaNotifyDevMgrVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IWiaNotifyDevMgr_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IWiaNotifyDevMgr_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IWiaNotifyDevMgr_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IWiaNotifyDevMgr_NewDeviceArrival(This)	\
    ( (This)->lpVtbl -> NewDeviceArrival(This) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IWiaNotifyDevMgr_INTERFACE_DEFINED__ */


#ifndef __IWiaItemExtras_INTERFACE_DEFINED__
#define __IWiaItemExtras_INTERFACE_DEFINED__

/* interface IWiaItemExtras */
/* [unique][helpstring][uuid][object] */ 


EXTERN_C const IID IID_IWiaItemExtras;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("6291ef2c-36ef-4532-876a-8e132593778d")
    IWiaItemExtras : public IUnknown
    {
    public:
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE GetExtendedErrorInfo( 
            /* [out] */ __RPC__deref_out_opt BSTR *bstrErrorText) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE Escape( 
            /* [in] */ DWORD dwEscapeCode,
            /* [size_is][in] */ __RPC__in_ecount_full(cbInDataSize) BYTE *lpInData,
            /* [in] */ DWORD cbInDataSize,
            /* [length_is][size_is][out] */ __RPC__out_ecount_part(dwOutDataSize, pdwActualDataSize ? *pdwActualDataSize : dwOutDataSize) BYTE *pOutData,
            /* [in] */ DWORD dwOutDataSize,
            /* [out] */ __RPC__out DWORD *pdwActualDataSize) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE CancelPendingIO( void) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IWiaItemExtrasVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IWiaItemExtras * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IWiaItemExtras * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IWiaItemExtras * This);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *GetExtendedErrorInfo )( 
            IWiaItemExtras * This,
            /* [out] */ __RPC__deref_out_opt BSTR *bstrErrorText);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *Escape )( 
            IWiaItemExtras * This,
            /* [in] */ DWORD dwEscapeCode,
            /* [size_is][in] */ __RPC__in_ecount_full(cbInDataSize) BYTE *lpInData,
            /* [in] */ DWORD cbInDataSize,
            /* [length_is][size_is][out] */ __RPC__out_ecount_part(dwOutDataSize, pdwActualDataSize ? *pdwActualDataSize : dwOutDataSize) BYTE *pOutData,
            /* [in] */ DWORD dwOutDataSize,
            /* [out] */ __RPC__out DWORD *pdwActualDataSize);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *CancelPendingIO )( 
            IWiaItemExtras * This);
        
        END_INTERFACE
    } IWiaItemExtrasVtbl;

    interface IWiaItemExtras
    {
        CONST_VTBL struct IWiaItemExtrasVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IWiaItemExtras_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IWiaItemExtras_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IWiaItemExtras_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IWiaItemExtras_GetExtendedErrorInfo(This,bstrErrorText)	\
    ( (This)->lpVtbl -> GetExtendedErrorInfo(This,bstrErrorText) ) 

#define IWiaItemExtras_Escape(This,dwEscapeCode,lpInData,cbInDataSize,pOutData,dwOutDataSize,pdwActualDataSize)	\
    ( (This)->lpVtbl -> Escape(This,dwEscapeCode,lpInData,cbInDataSize,pOutData,dwOutDataSize,pdwActualDataSize) ) 

#define IWiaItemExtras_CancelPendingIO(This)	\
    ( (This)->lpVtbl -> CancelPendingIO(This) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IWiaItemExtras_INTERFACE_DEFINED__ */


#ifndef __IWiaAppErrorHandler_INTERFACE_DEFINED__
#define __IWiaAppErrorHandler_INTERFACE_DEFINED__

/* interface IWiaAppErrorHandler */
/* [unique][helpstring][uuid][object] */ 


EXTERN_C const IID IID_IWiaAppErrorHandler;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("6C16186C-D0A6-400c-80F4-D26986A0E734")
    IWiaAppErrorHandler : public IUnknown
    {
    public:
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE GetWindow( 
            /* [out] */ __RPC__deref_out_opt HWND *phwnd) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE ReportStatus( 
            /* [in] */ LONG lFlags,
            /* [in] */ __RPC__in_opt IWiaItem2 *pWiaItem2,
            /* [in] */ HRESULT hrStatus,
            /* [in] */ LONG lPercentComplete) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IWiaAppErrorHandlerVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IWiaAppErrorHandler * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IWiaAppErrorHandler * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IWiaAppErrorHandler * This);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *GetWindow )( 
            IWiaAppErrorHandler * This,
            /* [out] */ __RPC__deref_out_opt HWND *phwnd);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *ReportStatus )( 
            IWiaAppErrorHandler * This,
            /* [in] */ LONG lFlags,
            /* [in] */ __RPC__in_opt IWiaItem2 *pWiaItem2,
            /* [in] */ HRESULT hrStatus,
            /* [in] */ LONG lPercentComplete);
        
        END_INTERFACE
    } IWiaAppErrorHandlerVtbl;

    interface IWiaAppErrorHandler
    {
        CONST_VTBL struct IWiaAppErrorHandlerVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IWiaAppErrorHandler_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IWiaAppErrorHandler_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IWiaAppErrorHandler_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IWiaAppErrorHandler_GetWindow(This,phwnd)	\
    ( (This)->lpVtbl -> GetWindow(This,phwnd) ) 

#define IWiaAppErrorHandler_ReportStatus(This,lFlags,pWiaItem2,hrStatus,lPercentComplete)	\
    ( (This)->lpVtbl -> ReportStatus(This,lFlags,pWiaItem2,hrStatus,lPercentComplete) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IWiaAppErrorHandler_INTERFACE_DEFINED__ */


#ifndef __IWiaErrorHandler_INTERFACE_DEFINED__
#define __IWiaErrorHandler_INTERFACE_DEFINED__

/* interface IWiaErrorHandler */
/* [unique][helpstring][uuid][object] */ 


EXTERN_C const IID IID_IWiaErrorHandler;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("0e4a51b1-bc1f-443d-a835-72e890759ef3")
    IWiaErrorHandler : public IUnknown
    {
    public:
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE ReportStatus( 
            /* [in] */ LONG lFlags,
            /* [in] */ __RPC__in HWND hwndParent,
            /* [in] */ __RPC__in_opt IWiaItem2 *pWiaItem2,
            /* [in] */ HRESULT hrStatus,
            /* [in] */ LONG lPercentComplete) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE GetStatusDescription( 
            /* [in] */ LONG lFlags,
            /* [in] */ __RPC__in_opt IWiaItem2 *pWiaItem2,
            /* [in] */ HRESULT hrStatus,
            /* [out] */ __RPC__deref_out_opt BSTR *pbstrDescription) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IWiaErrorHandlerVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IWiaErrorHandler * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IWiaErrorHandler * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IWiaErrorHandler * This);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *ReportStatus )( 
            IWiaErrorHandler * This,
            /* [in] */ LONG lFlags,
            /* [in] */ __RPC__in HWND hwndParent,
            /* [in] */ __RPC__in_opt IWiaItem2 *pWiaItem2,
            /* [in] */ HRESULT hrStatus,
            /* [in] */ LONG lPercentComplete);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *GetStatusDescription )( 
            IWiaErrorHandler * This,
            /* [in] */ LONG lFlags,
            /* [in] */ __RPC__in_opt IWiaItem2 *pWiaItem2,
            /* [in] */ HRESULT hrStatus,
            /* [out] */ __RPC__deref_out_opt BSTR *pbstrDescription);
        
        END_INTERFACE
    } IWiaErrorHandlerVtbl;

    interface IWiaErrorHandler
    {
        CONST_VTBL struct IWiaErrorHandlerVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IWiaErrorHandler_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IWiaErrorHandler_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IWiaErrorHandler_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IWiaErrorHandler_ReportStatus(This,lFlags,hwndParent,pWiaItem2,hrStatus,lPercentComplete)	\
    ( (This)->lpVtbl -> ReportStatus(This,lFlags,hwndParent,pWiaItem2,hrStatus,lPercentComplete) ) 

#define IWiaErrorHandler_GetStatusDescription(This,lFlags,pWiaItem2,hrStatus,pbstrDescription)	\
    ( (This)->lpVtbl -> GetStatusDescription(This,lFlags,pWiaItem2,hrStatus,pbstrDescription) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IWiaErrorHandler_INTERFACE_DEFINED__ */


#ifndef __IWiaTransfer_INTERFACE_DEFINED__
#define __IWiaTransfer_INTERFACE_DEFINED__

/* interface IWiaTransfer */
/* [helpstring][uuid][object] */ 


EXTERN_C const IID IID_IWiaTransfer;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("c39d6942-2f4e-4d04-92fe-4ef4d3a1de5a")
    IWiaTransfer : public IUnknown
    {
    public:
        virtual /* [helpstring][local] */ HRESULT STDMETHODCALLTYPE Download( 
            /* [in] */ LONG lFlags,
            /* [in] */ IWiaTransferCallback *pIWiaTransferCallback) = 0;
        
        virtual /* [helpstring][local] */ HRESULT STDMETHODCALLTYPE Upload( 
            /* [in] */ LONG lFlags,
            /* [in] */ IStream *pSource,
            /* [in] */ IWiaTransferCallback *pIWiaTransferCallback) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE Cancel( void) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE EnumWIA_FORMAT_INFO( 
            /* [out] */ __RPC__deref_out_opt IEnumWIA_FORMAT_INFO **ppEnum) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IWiaTransferVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IWiaTransfer * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IWiaTransfer * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IWiaTransfer * This);
        
        /* [helpstring][local] */ HRESULT ( STDMETHODCALLTYPE *Download )( 
            IWiaTransfer * This,
            /* [in] */ LONG lFlags,
            /* [in] */ IWiaTransferCallback *pIWiaTransferCallback);
        
        /* [helpstring][local] */ HRESULT ( STDMETHODCALLTYPE *Upload )( 
            IWiaTransfer * This,
            /* [in] */ LONG lFlags,
            /* [in] */ IStream *pSource,
            /* [in] */ IWiaTransferCallback *pIWiaTransferCallback);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *Cancel )( 
            IWiaTransfer * This);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *EnumWIA_FORMAT_INFO )( 
            IWiaTransfer * This,
            /* [out] */ __RPC__deref_out_opt IEnumWIA_FORMAT_INFO **ppEnum);
        
        END_INTERFACE
    } IWiaTransferVtbl;

    interface IWiaTransfer
    {
        CONST_VTBL struct IWiaTransferVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IWiaTransfer_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IWiaTransfer_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IWiaTransfer_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IWiaTransfer_Download(This,lFlags,pIWiaTransferCallback)	\
    ( (This)->lpVtbl -> Download(This,lFlags,pIWiaTransferCallback) ) 

#define IWiaTransfer_Upload(This,lFlags,pSource,pIWiaTransferCallback)	\
    ( (This)->lpVtbl -> Upload(This,lFlags,pSource,pIWiaTransferCallback) ) 

#define IWiaTransfer_Cancel(This)	\
    ( (This)->lpVtbl -> Cancel(This) ) 

#define IWiaTransfer_EnumWIA_FORMAT_INFO(This,ppEnum)	\
    ( (This)->lpVtbl -> EnumWIA_FORMAT_INFO(This,ppEnum) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [call_as] */ HRESULT STDMETHODCALLTYPE IWiaTransfer_RemoteDownload_Proxy( 
    IWiaTransfer * This,
    /* [in] */ LONG lFlags,
    /* [in] */ __RPC__in_opt IWiaTransferCallback *pIWiaTransferCallback);


void __RPC_STUB IWiaTransfer_RemoteDownload_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [call_as] */ HRESULT STDMETHODCALLTYPE IWiaTransfer_RemoteUpload_Proxy( 
    IWiaTransfer * This,
    /* [in] */ LONG lFlags,
    /* [in] */ __RPC__in_opt IStream *pSource,
    /* [in] */ __RPC__in_opt IWiaTransferCallback *pIWiaTransferCallback);


void __RPC_STUB IWiaTransfer_RemoteUpload_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IWiaTransfer_INTERFACE_DEFINED__ */


/* interface __MIDL_itf_wia_lh_0000_0017 */
/* [local] */ 

typedef struct _WiaTransferParams
    {
    LONG lMessage;
    LONG lPercentComplete;
    ULONG64 ulTransferredBytes;
    HRESULT hrErrorStatus;
    } 	WiaTransferParams;



extern RPC_IF_HANDLE __MIDL_itf_wia_lh_0000_0017_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_wia_lh_0000_0017_v0_0_s_ifspec;

#ifndef __IWiaTransferCallback_INTERFACE_DEFINED__
#define __IWiaTransferCallback_INTERFACE_DEFINED__

/* interface IWiaTransferCallback */
/* [helpstring][uuid][object] */ 


EXTERN_C const IID IID_IWiaTransferCallback;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("27d4eaaf-28a6-4ca5-9aab-e678168b9527")
    IWiaTransferCallback : public IUnknown
    {
    public:
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE TransferCallback( 
            /* [in] */ LONG lFlags,
            /* [in] */ __RPC__in WiaTransferParams *pWiaTransferParams) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE GetNextStream( 
            /* [in] */ LONG lFlags,
            /* [in] */ __RPC__in BSTR bstrItemName,
            /* [in] */ __RPC__in BSTR bstrFullItemName,
            /* [out] */ __RPC__deref_out_opt IStream **ppDestination) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IWiaTransferCallbackVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IWiaTransferCallback * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IWiaTransferCallback * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IWiaTransferCallback * This);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *TransferCallback )( 
            IWiaTransferCallback * This,
            /* [in] */ LONG lFlags,
            /* [in] */ __RPC__in WiaTransferParams *pWiaTransferParams);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *GetNextStream )( 
            IWiaTransferCallback * This,
            /* [in] */ LONG lFlags,
            /* [in] */ __RPC__in BSTR bstrItemName,
            /* [in] */ __RPC__in BSTR bstrFullItemName,
            /* [out] */ __RPC__deref_out_opt IStream **ppDestination);
        
        END_INTERFACE
    } IWiaTransferCallbackVtbl;

    interface IWiaTransferCallback
    {
        CONST_VTBL struct IWiaTransferCallbackVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IWiaTransferCallback_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IWiaTransferCallback_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IWiaTransferCallback_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IWiaTransferCallback_TransferCallback(This,lFlags,pWiaTransferParams)	\
    ( (This)->lpVtbl -> TransferCallback(This,lFlags,pWiaTransferParams) ) 

#define IWiaTransferCallback_GetNextStream(This,lFlags,bstrItemName,bstrFullItemName,ppDestination)	\
    ( (This)->lpVtbl -> GetNextStream(This,lFlags,bstrItemName,bstrFullItemName,ppDestination) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IWiaTransferCallback_INTERFACE_DEFINED__ */


#ifndef __IWiaSegmentationFilter_INTERFACE_DEFINED__
#define __IWiaSegmentationFilter_INTERFACE_DEFINED__

/* interface IWiaSegmentationFilter */
/* [helpstring][uuid][object] */ 


EXTERN_C const IID IID_IWiaSegmentationFilter;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("EC46A697-AC04-4447-8F65-FF63D5154B21")
    IWiaSegmentationFilter : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE DetectRegions( 
            /* [in] */ LONG lFlags,
            /* [in] */ __RPC__in_opt IStream *pInputStream,
            /* [in] */ __RPC__in_opt IWiaItem2 *pWiaItem2) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IWiaSegmentationFilterVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IWiaSegmentationFilter * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IWiaSegmentationFilter * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IWiaSegmentationFilter * This);
        
        HRESULT ( STDMETHODCALLTYPE *DetectRegions )( 
            IWiaSegmentationFilter * This,
            /* [in] */ LONG lFlags,
            /* [in] */ __RPC__in_opt IStream *pInputStream,
            /* [in] */ __RPC__in_opt IWiaItem2 *pWiaItem2);
        
        END_INTERFACE
    } IWiaSegmentationFilterVtbl;

    interface IWiaSegmentationFilter
    {
        CONST_VTBL struct IWiaSegmentationFilterVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IWiaSegmentationFilter_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IWiaSegmentationFilter_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IWiaSegmentationFilter_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IWiaSegmentationFilter_DetectRegions(This,lFlags,pInputStream,pWiaItem2)	\
    ( (This)->lpVtbl -> DetectRegions(This,lFlags,pInputStream,pWiaItem2) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IWiaSegmentationFilter_INTERFACE_DEFINED__ */


#ifndef __IWiaImageFilter_INTERFACE_DEFINED__
#define __IWiaImageFilter_INTERFACE_DEFINED__

/* interface IWiaImageFilter */
/* [helpstring][uuid][object] */ 


EXTERN_C const IID IID_IWiaImageFilter;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("A8A79FFA-450B-41f1-8F87-849CCD94EBF6")
    IWiaImageFilter : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE InitializeFilter( 
            /* [in] */ __RPC__in_opt IWiaItem2 *pWiaItem2,
            /* [in] */ __RPC__in_opt IWiaTransferCallback *pWiaTransferCallback) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetNewCallback( 
            /* [in] */ __RPC__in_opt IWiaTransferCallback *pWiaTransferCallback) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE FilterPreviewImage( 
            /* [in] */ LONG lFlags,
            /* [in] */ __RPC__in_opt IWiaItem2 *pWiaChildItem2,
            /* [in] */ RECT InputImageExtents,
            /* [in] */ __RPC__in_opt IStream *pInputStream) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE ApplyProperties( 
            /* [in] */ __RPC__in_opt IWiaPropertyStorage *pWiaPropertyStorage) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IWiaImageFilterVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IWiaImageFilter * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IWiaImageFilter * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IWiaImageFilter * This);
        
        HRESULT ( STDMETHODCALLTYPE *InitializeFilter )( 
            IWiaImageFilter * This,
            /* [in] */ __RPC__in_opt IWiaItem2 *pWiaItem2,
            /* [in] */ __RPC__in_opt IWiaTransferCallback *pWiaTransferCallback);
        
        HRESULT ( STDMETHODCALLTYPE *SetNewCallback )( 
            IWiaImageFilter * This,
            /* [in] */ __RPC__in_opt IWiaTransferCallback *pWiaTransferCallback);
        
        HRESULT ( STDMETHODCALLTYPE *FilterPreviewImage )( 
            IWiaImageFilter * This,
            /* [in] */ LONG lFlags,
            /* [in] */ __RPC__in_opt IWiaItem2 *pWiaChildItem2,
            /* [in] */ RECT InputImageExtents,
            /* [in] */ __RPC__in_opt IStream *pInputStream);
        
        HRESULT ( STDMETHODCALLTYPE *ApplyProperties )( 
            IWiaImageFilter * This,
            /* [in] */ __RPC__in_opt IWiaPropertyStorage *pWiaPropertyStorage);
        
        END_INTERFACE
    } IWiaImageFilterVtbl;

    interface IWiaImageFilter
    {
        CONST_VTBL struct IWiaImageFilterVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IWiaImageFilter_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IWiaImageFilter_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IWiaImageFilter_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IWiaImageFilter_InitializeFilter(This,pWiaItem2,pWiaTransferCallback)	\
    ( (This)->lpVtbl -> InitializeFilter(This,pWiaItem2,pWiaTransferCallback) ) 

#define IWiaImageFilter_SetNewCallback(This,pWiaTransferCallback)	\
    ( (This)->lpVtbl -> SetNewCallback(This,pWiaTransferCallback) ) 

#define IWiaImageFilter_FilterPreviewImage(This,lFlags,pWiaChildItem2,InputImageExtents,pInputStream)	\
    ( (This)->lpVtbl -> FilterPreviewImage(This,lFlags,pWiaChildItem2,InputImageExtents,pInputStream) ) 

#define IWiaImageFilter_ApplyProperties(This,pWiaPropertyStorage)	\
    ( (This)->lpVtbl -> ApplyProperties(This,pWiaPropertyStorage) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IWiaImageFilter_INTERFACE_DEFINED__ */


#ifndef __IWiaPreview_INTERFACE_DEFINED__
#define __IWiaPreview_INTERFACE_DEFINED__

/* interface IWiaPreview */
/* [helpstring][uuid][object] */ 


EXTERN_C const IID IID_IWiaPreview;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("95C2B4FD-33F2-4d86-AD40-9431F0DF08F7")
    IWiaPreview : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE GetNewPreview( 
            /* [in] */ LONG lFlags,
            /* [in] */ __RPC__in_opt IWiaItem2 *pWiaItem2,
            /* [in] */ __RPC__in_opt IWiaTransferCallback *pWiaTransferCallback) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE UpdatePreview( 
            /* [in] */ LONG lFlags,
            /* [in] */ __RPC__in_opt IWiaItem2 *pChildWiaItem2,
            /* [in] */ __RPC__in_opt IWiaTransferCallback *pWiaTransferCallback) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE DetectRegions( 
            /* [in] */ LONG lFlags) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Clear( void) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IWiaPreviewVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IWiaPreview * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IWiaPreview * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IWiaPreview * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetNewPreview )( 
            IWiaPreview * This,
            /* [in] */ LONG lFlags,
            /* [in] */ __RPC__in_opt IWiaItem2 *pWiaItem2,
            /* [in] */ __RPC__in_opt IWiaTransferCallback *pWiaTransferCallback);
        
        HRESULT ( STDMETHODCALLTYPE *UpdatePreview )( 
            IWiaPreview * This,
            /* [in] */ LONG lFlags,
            /* [in] */ __RPC__in_opt IWiaItem2 *pChildWiaItem2,
            /* [in] */ __RPC__in_opt IWiaTransferCallback *pWiaTransferCallback);
        
        HRESULT ( STDMETHODCALLTYPE *DetectRegions )( 
            IWiaPreview * This,
            /* [in] */ LONG lFlags);
        
        HRESULT ( STDMETHODCALLTYPE *Clear )( 
            IWiaPreview * This);
        
        END_INTERFACE
    } IWiaPreviewVtbl;

    interface IWiaPreview
    {
        CONST_VTBL struct IWiaPreviewVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IWiaPreview_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IWiaPreview_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IWiaPreview_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IWiaPreview_GetNewPreview(This,lFlags,pWiaItem2,pWiaTransferCallback)	\
    ( (This)->lpVtbl -> GetNewPreview(This,lFlags,pWiaItem2,pWiaTransferCallback) ) 

#define IWiaPreview_UpdatePreview(This,lFlags,pChildWiaItem2,pWiaTransferCallback)	\
    ( (This)->lpVtbl -> UpdatePreview(This,lFlags,pChildWiaItem2,pWiaTransferCallback) ) 

#define IWiaPreview_DetectRegions(This,lFlags)	\
    ( (This)->lpVtbl -> DetectRegions(This,lFlags) ) 

#define IWiaPreview_Clear(This)	\
    ( (This)->lpVtbl -> Clear(This) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IWiaPreview_INTERFACE_DEFINED__ */


#ifndef __IEnumWiaItem2_INTERFACE_DEFINED__
#define __IEnumWiaItem2_INTERFACE_DEFINED__

/* interface IEnumWiaItem2 */
/* [unique][helpstring][uuid][object] */ 


EXTERN_C const IID IID_IEnumWiaItem2;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("59970AF4-CD0D-44d9-AB24-52295630E582")
    IEnumWiaItem2 : public IUnknown
    {
    public:
        virtual /* [local] */ HRESULT STDMETHODCALLTYPE Next( 
            /* [in] */ ULONG cElt,
            /* [length_is][size_is][out] */ IWiaItem2 **ppIWiaItem2,
            /* [unique][out][in] */ ULONG *pcEltFetched) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE Skip( 
            /* [in] */ ULONG cElt) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE Reset( void) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE Clone( 
            /* [out] */ __RPC__deref_out_opt IEnumWiaItem2 **ppIEnum) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE GetCount( 
            /* [out] */ __RPC__out ULONG *cElt) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IEnumWiaItem2Vtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IEnumWiaItem2 * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IEnumWiaItem2 * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IEnumWiaItem2 * This);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE *Next )( 
            IEnumWiaItem2 * This,
            /* [in] */ ULONG cElt,
            /* [length_is][size_is][out] */ IWiaItem2 **ppIWiaItem2,
            /* [unique][out][in] */ ULONG *pcEltFetched);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *Skip )( 
            IEnumWiaItem2 * This,
            /* [in] */ ULONG cElt);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *Reset )( 
            IEnumWiaItem2 * This);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *Clone )( 
            IEnumWiaItem2 * This,
            /* [out] */ __RPC__deref_out_opt IEnumWiaItem2 **ppIEnum);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *GetCount )( 
            IEnumWiaItem2 * This,
            /* [out] */ __RPC__out ULONG *cElt);
        
        END_INTERFACE
    } IEnumWiaItem2Vtbl;

    interface IEnumWiaItem2
    {
        CONST_VTBL struct IEnumWiaItem2Vtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IEnumWiaItem2_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IEnumWiaItem2_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IEnumWiaItem2_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IEnumWiaItem2_Next(This,cElt,ppIWiaItem2,pcEltFetched)	\
    ( (This)->lpVtbl -> Next(This,cElt,ppIWiaItem2,pcEltFetched) ) 

#define IEnumWiaItem2_Skip(This,cElt)	\
    ( (This)->lpVtbl -> Skip(This,cElt) ) 

#define IEnumWiaItem2_Reset(This)	\
    ( (This)->lpVtbl -> Reset(This) ) 

#define IEnumWiaItem2_Clone(This,ppIEnum)	\
    ( (This)->lpVtbl -> Clone(This,ppIEnum) ) 

#define IEnumWiaItem2_GetCount(This,cElt)	\
    ( (This)->lpVtbl -> GetCount(This,cElt) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [helpstring][call_as] */ HRESULT STDMETHODCALLTYPE IEnumWiaItem2_RemoteNext_Proxy( 
    IEnumWiaItem2 * This,
    /* [in] */ ULONG cElt,
    /* [length_is][size_is][out] */ __RPC__out_ecount_part(cElt, *pcEltFetched) IWiaItem2 **ppIWiaItem2,
    /* [unique][out][in] */ __RPC__inout_opt ULONG *pcEltFetched);


void __RPC_STUB IEnumWiaItem2_RemoteNext_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IEnumWiaItem2_INTERFACE_DEFINED__ */


#ifndef __IWiaItem2_INTERFACE_DEFINED__
#define __IWiaItem2_INTERFACE_DEFINED__

/* interface IWiaItem2 */
/* [unique][helpstring][uuid][object] */ 


EXTERN_C const IID IID_IWiaItem2;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("6CBA0075-1287-407d-9B77-CF0E030435CC")
    IWiaItem2 : public IUnknown
    {
    public:
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE CreateChildItem( 
            /* [in] */ LONG lItemFlags,
            /* [in] */ LONG lCreationFlags,
            /* [in] */ __RPC__in BSTR bstrItemName,
            /* [out] */ __RPC__deref_out_opt IWiaItem2 **ppIWiaItem2) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE DeleteItem( 
            /* [in] */ LONG lFlags) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE EnumChildItems( 
            /* [unique][in] */ __RPC__in_opt const GUID *pCategoryGUID,
            /* [out] */ __RPC__deref_out_opt IEnumWiaItem2 **ppIEnumWiaItem2) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE FindItemByName( 
            /* [in] */ LONG lFlags,
            /* [in] */ __RPC__in BSTR bstrFullItemName,
            /* [out] */ __RPC__deref_out_opt IWiaItem2 **ppIWiaItem2) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE GetItemCategory( 
            /* [out] */ __RPC__out GUID *pItemCategoryGUID) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE GetItemType( 
            /* [out] */ __RPC__out LONG *pItemType) = 0;
        
        virtual /* [local] */ HRESULT STDMETHODCALLTYPE DeviceDlg( 
            /* [in] */ LONG lFlags,
            /* [in] */ HWND hwndParent,
            /* [in] */ BSTR bstrFolderName,
            /* [in] */ BSTR bstrFilename,
            /* [in] */ LONG *plNumFiles,
            /* [in] */ BSTR **ppbstrFilePaths,
            /* [out][in] */ IWiaItem2 **ppItem) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE DeviceCommand( 
            /* [in] */ LONG lFlags,
            /* [in] */ __RPC__in const GUID *pCmdGUID,
            /* [out][in] */ __RPC__deref_inout_opt IWiaItem2 **ppIWiaItem2) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE EnumDeviceCapabilities( 
            /* [in] */ LONG lFlags,
            /* [out] */ __RPC__deref_out_opt IEnumWIA_DEV_CAPS **ppIEnumWIA_DEV_CAPS) = 0;
        
        virtual /* [local] */ HRESULT STDMETHODCALLTYPE CheckExtension( 
            /* [in] */ LONG lFlags,
            /* [in] */ BSTR bstrName,
            /* [in] */ REFIID riidExtensionInterface,
            /* [out] */ BOOL *pbExtensionExists) = 0;
        
        virtual /* [local] */ HRESULT STDMETHODCALLTYPE GetExtension( 
            /* [in] */ LONG lFlags,
            /* [in] */ BSTR bstrName,
            /* [in] */ REFIID riidExtensionInterface,
            /* [iid_is][out] */ void **ppOut) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE GetParentItem( 
            /* [out] */ __RPC__deref_out_opt IWiaItem2 **ppIWiaItem2) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE GetRootItem( 
            /* [out] */ __RPC__deref_out_opt IWiaItem2 **ppIWiaItem2) = 0;
        
        virtual /* [local] */ HRESULT STDMETHODCALLTYPE GetPreviewComponent( 
            /* [in] */ LONG lFlags,
            /* [out] */ IWiaPreview **ppWiaPreview) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE EnumRegisterEventInfo( 
            /* [in] */ LONG lFlags,
            /* [in] */ __RPC__in const GUID *pEventGUID,
            /* [out] */ __RPC__deref_out_opt IEnumWIA_DEV_CAPS **ppIEnum) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE Diagnostic( 
            /* [in] */ ULONG ulSize,
            /* [size_is][in] */ __RPC__in_ecount_full(ulSize) BYTE *pBuffer) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IWiaItem2Vtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IWiaItem2 * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IWiaItem2 * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IWiaItem2 * This);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *CreateChildItem )( 
            IWiaItem2 * This,
            /* [in] */ LONG lItemFlags,
            /* [in] */ LONG lCreationFlags,
            /* [in] */ __RPC__in BSTR bstrItemName,
            /* [out] */ __RPC__deref_out_opt IWiaItem2 **ppIWiaItem2);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *DeleteItem )( 
            IWiaItem2 * This,
            /* [in] */ LONG lFlags);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *EnumChildItems )( 
            IWiaItem2 * This,
            /* [unique][in] */ __RPC__in_opt const GUID *pCategoryGUID,
            /* [out] */ __RPC__deref_out_opt IEnumWiaItem2 **ppIEnumWiaItem2);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *FindItemByName )( 
            IWiaItem2 * This,
            /* [in] */ LONG lFlags,
            /* [in] */ __RPC__in BSTR bstrFullItemName,
            /* [out] */ __RPC__deref_out_opt IWiaItem2 **ppIWiaItem2);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *GetItemCategory )( 
            IWiaItem2 * This,
            /* [out] */ __RPC__out GUID *pItemCategoryGUID);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *GetItemType )( 
            IWiaItem2 * This,
            /* [out] */ __RPC__out LONG *pItemType);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE *DeviceDlg )( 
            IWiaItem2 * This,
            /* [in] */ LONG lFlags,
            /* [in] */ HWND hwndParent,
            /* [in] */ BSTR bstrFolderName,
            /* [in] */ BSTR bstrFilename,
            /* [in] */ LONG *plNumFiles,
            /* [in] */ BSTR **ppbstrFilePaths,
            /* [out][in] */ IWiaItem2 **ppItem);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *DeviceCommand )( 
            IWiaItem2 * This,
            /* [in] */ LONG lFlags,
            /* [in] */ __RPC__in const GUID *pCmdGUID,
            /* [out][in] */ __RPC__deref_inout_opt IWiaItem2 **ppIWiaItem2);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *EnumDeviceCapabilities )( 
            IWiaItem2 * This,
            /* [in] */ LONG lFlags,
            /* [out] */ __RPC__deref_out_opt IEnumWIA_DEV_CAPS **ppIEnumWIA_DEV_CAPS);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE *CheckExtension )( 
            IWiaItem2 * This,
            /* [in] */ LONG lFlags,
            /* [in] */ BSTR bstrName,
            /* [in] */ REFIID riidExtensionInterface,
            /* [out] */ BOOL *pbExtensionExists);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE *GetExtension )( 
            IWiaItem2 * This,
            /* [in] */ LONG lFlags,
            /* [in] */ BSTR bstrName,
            /* [in] */ REFIID riidExtensionInterface,
            /* [iid_is][out] */ void **ppOut);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *GetParentItem )( 
            IWiaItem2 * This,
            /* [out] */ __RPC__deref_out_opt IWiaItem2 **ppIWiaItem2);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *GetRootItem )( 
            IWiaItem2 * This,
            /* [out] */ __RPC__deref_out_opt IWiaItem2 **ppIWiaItem2);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE *GetPreviewComponent )( 
            IWiaItem2 * This,
            /* [in] */ LONG lFlags,
            /* [out] */ IWiaPreview **ppWiaPreview);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *EnumRegisterEventInfo )( 
            IWiaItem2 * This,
            /* [in] */ LONG lFlags,
            /* [in] */ __RPC__in const GUID *pEventGUID,
            /* [out] */ __RPC__deref_out_opt IEnumWIA_DEV_CAPS **ppIEnum);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *Diagnostic )( 
            IWiaItem2 * This,
            /* [in] */ ULONG ulSize,
            /* [size_is][in] */ __RPC__in_ecount_full(ulSize) BYTE *pBuffer);
        
        END_INTERFACE
    } IWiaItem2Vtbl;

    interface IWiaItem2
    {
        CONST_VTBL struct IWiaItem2Vtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IWiaItem2_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IWiaItem2_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IWiaItem2_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IWiaItem2_CreateChildItem(This,lItemFlags,lCreationFlags,bstrItemName,ppIWiaItem2)	\
    ( (This)->lpVtbl -> CreateChildItem(This,lItemFlags,lCreationFlags,bstrItemName,ppIWiaItem2) ) 

#define IWiaItem2_DeleteItem(This,lFlags)	\
    ( (This)->lpVtbl -> DeleteItem(This,lFlags) ) 

#define IWiaItem2_EnumChildItems(This,pCategoryGUID,ppIEnumWiaItem2)	\
    ( (This)->lpVtbl -> EnumChildItems(This,pCategoryGUID,ppIEnumWiaItem2) ) 

#define IWiaItem2_FindItemByName(This,lFlags,bstrFullItemName,ppIWiaItem2)	\
    ( (This)->lpVtbl -> FindItemByName(This,lFlags,bstrFullItemName,ppIWiaItem2) ) 

#define IWiaItem2_GetItemCategory(This,pItemCategoryGUID)	\
    ( (This)->lpVtbl -> GetItemCategory(This,pItemCategoryGUID) ) 

#define IWiaItem2_GetItemType(This,pItemType)	\
    ( (This)->lpVtbl -> GetItemType(This,pItemType) ) 

#define IWiaItem2_DeviceDlg(This,lFlags,hwndParent,bstrFolderName,bstrFilename,plNumFiles,ppbstrFilePaths,ppItem)	\
    ( (This)->lpVtbl -> DeviceDlg(This,lFlags,hwndParent,bstrFolderName,bstrFilename,plNumFiles,ppbstrFilePaths,ppItem) ) 

#define IWiaItem2_DeviceCommand(This,lFlags,pCmdGUID,ppIWiaItem2)	\
    ( (This)->lpVtbl -> DeviceCommand(This,lFlags,pCmdGUID,ppIWiaItem2) ) 

#define IWiaItem2_EnumDeviceCapabilities(This,lFlags,ppIEnumWIA_DEV_CAPS)	\
    ( (This)->lpVtbl -> EnumDeviceCapabilities(This,lFlags,ppIEnumWIA_DEV_CAPS) ) 

#define IWiaItem2_CheckExtension(This,lFlags,bstrName,riidExtensionInterface,pbExtensionExists)	\
    ( (This)->lpVtbl -> CheckExtension(This,lFlags,bstrName,riidExtensionInterface,pbExtensionExists) ) 

#define IWiaItem2_GetExtension(This,lFlags,bstrName,riidExtensionInterface,ppOut)	\
    ( (This)->lpVtbl -> GetExtension(This,lFlags,bstrName,riidExtensionInterface,ppOut) ) 

#define IWiaItem2_GetParentItem(This,ppIWiaItem2)	\
    ( (This)->lpVtbl -> GetParentItem(This,ppIWiaItem2) ) 

#define IWiaItem2_GetRootItem(This,ppIWiaItem2)	\
    ( (This)->lpVtbl -> GetRootItem(This,ppIWiaItem2) ) 

#define IWiaItem2_GetPreviewComponent(This,lFlags,ppWiaPreview)	\
    ( (This)->lpVtbl -> GetPreviewComponent(This,lFlags,ppWiaPreview) ) 

#define IWiaItem2_EnumRegisterEventInfo(This,lFlags,pEventGUID,ppIEnum)	\
    ( (This)->lpVtbl -> EnumRegisterEventInfo(This,lFlags,pEventGUID,ppIEnum) ) 

#define IWiaItem2_Diagnostic(This,ulSize,pBuffer)	\
    ( (This)->lpVtbl -> Diagnostic(This,ulSize,pBuffer) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [nocode][helpstring][call_as] */ HRESULT STDMETHODCALLTYPE IWiaItem2_LocalDeviceDlg_Proxy( 
    IWiaItem2 * This,
    /* [in] */ LONG lFlags,
    /* [in] */ __RPC__in HWND hwndParent,
    /* [in] */ __RPC__in BSTR bstrFolderName,
    /* [in] */ __RPC__in BSTR bstrFilename,
    /* [in] */ __RPC__in LONG *plNumFiles,
    /* [in] */ __RPC__deref_in_opt BSTR **ppbstrFilePaths,
    /* [out][in] */ __RPC__deref_inout_opt IWiaItem2 **ppItem);


void __RPC_STUB IWiaItem2_LocalDeviceDlg_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][call_as] */ HRESULT STDMETHODCALLTYPE IWiaItem2_RemoteCheckExtension_Proxy( 
    IWiaItem2 * This,
    /* [in] */ LONG lFlags,
    /* [in] */ __RPC__in BSTR bstrName,
    /* [in] */ __RPC__in REFIID riidExtensionInterface,
    /* [out] */ __RPC__out BOOL *pbExtensionExists);


void __RPC_STUB IWiaItem2_RemoteCheckExtension_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][call_as] */ HRESULT STDMETHODCALLTYPE IWiaItem2_RemoteGetExtension_Proxy( 
    IWiaItem2 * This,
    /* [in] */ LONG lFlags,
    /* [in] */ __RPC__in BSTR bstrName,
    /* [in] */ __RPC__in REFIID riidExtensionInterface,
    /* [iid_is][out] */ __RPC__deref_out_opt void **ppOut);


void __RPC_STUB IWiaItem2_RemoteGetExtension_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][call_as] */ HRESULT STDMETHODCALLTYPE IWiaItem2_RemoteGetPreviewComponent_Proxy( 
    IWiaItem2 * This,
    /* [in] */ LONG lFlags,
    /* [out] */ __RPC__deref_out_opt IWiaPreview **ppWiaPreview);


void __RPC_STUB IWiaItem2_RemoteGetPreviewComponent_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IWiaItem2_INTERFACE_DEFINED__ */


#ifndef __IWiaDevMgr2_INTERFACE_DEFINED__
#define __IWiaDevMgr2_INTERFACE_DEFINED__

/* interface IWiaDevMgr2 */
/* [unique][helpstring][uuid][object] */ 


EXTERN_C const IID IID_IWiaDevMgr2;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("79C07CF1-CBDD-41ee-8EC3-F00080CADA7A")
    IWiaDevMgr2 : public IUnknown
    {
    public:
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE EnumDeviceInfo( 
            /* [in] */ LONG lFlags,
            /* [retval][out] */ __RPC__deref_out_opt IEnumWIA_DEV_INFO **ppIEnum) = 0;
        
        virtual /* [local] */ HRESULT STDMETHODCALLTYPE CreateDevice( 
            /* [in] */ LONG lFlags,
            /* [in] */ BSTR bstrDeviceID,
            /* [out] */ IWiaItem2 **ppWiaItem2Root) = 0;
        
        virtual /* [local] */ HRESULT STDMETHODCALLTYPE SelectDeviceDlg( 
            /* [in] */ HWND hwndParent,
            /* [in] */ LONG lDeviceType,
            /* [in] */ LONG lFlags,
            /* [out][in] */ BSTR *pbstrDeviceID,
            /* [retval][out] */ IWiaItem2 **ppItemRoot) = 0;
        
        virtual /* [local] */ HRESULT STDMETHODCALLTYPE SelectDeviceDlgID( 
            /* [in] */ HWND hwndParent,
            /* [in] */ LONG lDeviceType,
            /* [in] */ LONG lFlags,
            /* [retval][out] */ BSTR *pbstrDeviceID) = 0;
        
        virtual /* [local] */ HRESULT STDMETHODCALLTYPE RegisterEventCallbackInterface( 
            /* [in] */ LONG lFlags,
            /* [in] */ BSTR bstrDeviceID,
            /* [in] */ const GUID *pEventGUID,
            /* [unique][in] */ IWiaEventCallback *pIWiaEventCallback,
            /* [out] */ IUnknown **pEventObject) = 0;
        
        virtual /* [local] */ HRESULT STDMETHODCALLTYPE RegisterEventCallbackProgram( 
            /* [in] */ LONG lFlags,
            /* [in] */ BSTR bstrDeviceID,
            /* [in] */ const GUID *pEventGUID,
            /* [in] */ BSTR bstrFullAppName,
            /* [in] */ BSTR bstrCommandLineArg,
            /* [in] */ BSTR bstrName,
            /* [in] */ BSTR bstrDescription,
            /* [in] */ BSTR bstrIcon) = 0;
        
        virtual /* [local] */ HRESULT STDMETHODCALLTYPE RegisterEventCallbackCLSID( 
            /* [in] */ LONG lFlags,
            /* [in] */ BSTR bstrDeviceID,
            /* [in] */ const GUID *pEventGUID,
            /* [unique][in] */ const GUID *pClsID,
            /* [in] */ BSTR bstrName,
            /* [in] */ BSTR bstrDescription,
            /* [in] */ BSTR bstrIcon) = 0;
        
        virtual /* [local] */ HRESULT STDMETHODCALLTYPE GetImageDlg( 
            /* [in] */ LONG lFlags,
            /* [in] */ BSTR bstrDeviceID,
            /* [in] */ HWND hwndParent,
            /* [in] */ BSTR bstrFolderName,
            /* [in] */ BSTR bstrFilename,
            /* [in] */ LONG *plNumFiles,
            /* [in] */ BSTR **ppbstrFilePaths,
            /* [out][in] */ IWiaItem2 **ppItem) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IWiaDevMgr2Vtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IWiaDevMgr2 * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IWiaDevMgr2 * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IWiaDevMgr2 * This);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *EnumDeviceInfo )( 
            IWiaDevMgr2 * This,
            /* [in] */ LONG lFlags,
            /* [retval][out] */ __RPC__deref_out_opt IEnumWIA_DEV_INFO **ppIEnum);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE *CreateDevice )( 
            IWiaDevMgr2 * This,
            /* [in] */ LONG lFlags,
            /* [in] */ BSTR bstrDeviceID,
            /* [out] */ IWiaItem2 **ppWiaItem2Root);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE *SelectDeviceDlg )( 
            IWiaDevMgr2 * This,
            /* [in] */ HWND hwndParent,
            /* [in] */ LONG lDeviceType,
            /* [in] */ LONG lFlags,
            /* [out][in] */ BSTR *pbstrDeviceID,
            /* [retval][out] */ IWiaItem2 **ppItemRoot);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE *SelectDeviceDlgID )( 
            IWiaDevMgr2 * This,
            /* [in] */ HWND hwndParent,
            /* [in] */ LONG lDeviceType,
            /* [in] */ LONG lFlags,
            /* [retval][out] */ BSTR *pbstrDeviceID);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE *RegisterEventCallbackInterface )( 
            IWiaDevMgr2 * This,
            /* [in] */ LONG lFlags,
            /* [in] */ BSTR bstrDeviceID,
            /* [in] */ const GUID *pEventGUID,
            /* [unique][in] */ IWiaEventCallback *pIWiaEventCallback,
            /* [out] */ IUnknown **pEventObject);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE *RegisterEventCallbackProgram )( 
            IWiaDevMgr2 * This,
            /* [in] */ LONG lFlags,
            /* [in] */ BSTR bstrDeviceID,
            /* [in] */ const GUID *pEventGUID,
            /* [in] */ BSTR bstrFullAppName,
            /* [in] */ BSTR bstrCommandLineArg,
            /* [in] */ BSTR bstrName,
            /* [in] */ BSTR bstrDescription,
            /* [in] */ BSTR bstrIcon);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE *RegisterEventCallbackCLSID )( 
            IWiaDevMgr2 * This,
            /* [in] */ LONG lFlags,
            /* [in] */ BSTR bstrDeviceID,
            /* [in] */ const GUID *pEventGUID,
            /* [unique][in] */ const GUID *pClsID,
            /* [in] */ BSTR bstrName,
            /* [in] */ BSTR bstrDescription,
            /* [in] */ BSTR bstrIcon);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE *GetImageDlg )( 
            IWiaDevMgr2 * This,
            /* [in] */ LONG lFlags,
            /* [in] */ BSTR bstrDeviceID,
            /* [in] */ HWND hwndParent,
            /* [in] */ BSTR bstrFolderName,
            /* [in] */ BSTR bstrFilename,
            /* [in] */ LONG *plNumFiles,
            /* [in] */ BSTR **ppbstrFilePaths,
            /* [out][in] */ IWiaItem2 **ppItem);
        
        END_INTERFACE
    } IWiaDevMgr2Vtbl;

    interface IWiaDevMgr2
    {
        CONST_VTBL struct IWiaDevMgr2Vtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IWiaDevMgr2_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IWiaDevMgr2_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IWiaDevMgr2_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IWiaDevMgr2_EnumDeviceInfo(This,lFlags,ppIEnum)	\
    ( (This)->lpVtbl -> EnumDeviceInfo(This,lFlags,ppIEnum) ) 

#define IWiaDevMgr2_CreateDevice(This,lFlags,bstrDeviceID,ppWiaItem2Root)	\
    ( (This)->lpVtbl -> CreateDevice(This,lFlags,bstrDeviceID,ppWiaItem2Root) ) 

#define IWiaDevMgr2_SelectDeviceDlg(This,hwndParent,lDeviceType,lFlags,pbstrDeviceID,ppItemRoot)	\
    ( (This)->lpVtbl -> SelectDeviceDlg(This,hwndParent,lDeviceType,lFlags,pbstrDeviceID,ppItemRoot) ) 

#define IWiaDevMgr2_SelectDeviceDlgID(This,hwndParent,lDeviceType,lFlags,pbstrDeviceID)	\
    ( (This)->lpVtbl -> SelectDeviceDlgID(This,hwndParent,lDeviceType,lFlags,pbstrDeviceID) ) 

#define IWiaDevMgr2_RegisterEventCallbackInterface(This,lFlags,bstrDeviceID,pEventGUID,pIWiaEventCallback,pEventObject)	\
    ( (This)->lpVtbl -> RegisterEventCallbackInterface(This,lFlags,bstrDeviceID,pEventGUID,pIWiaEventCallback,pEventObject) ) 

#define IWiaDevMgr2_RegisterEventCallbackProgram(This,lFlags,bstrDeviceID,pEventGUID,bstrFullAppName,bstrCommandLineArg,bstrName,bstrDescription,bstrIcon)	\
    ( (This)->lpVtbl -> RegisterEventCallbackProgram(This,lFlags,bstrDeviceID,pEventGUID,bstrFullAppName,bstrCommandLineArg,bstrName,bstrDescription,bstrIcon) ) 

#define IWiaDevMgr2_RegisterEventCallbackCLSID(This,lFlags,bstrDeviceID,pEventGUID,pClsID,bstrName,bstrDescription,bstrIcon)	\
    ( (This)->lpVtbl -> RegisterEventCallbackCLSID(This,lFlags,bstrDeviceID,pEventGUID,pClsID,bstrName,bstrDescription,bstrIcon) ) 

#define IWiaDevMgr2_GetImageDlg(This,lFlags,bstrDeviceID,hwndParent,bstrFolderName,bstrFilename,plNumFiles,ppbstrFilePaths,ppItem)	\
    ( (This)->lpVtbl -> GetImageDlg(This,lFlags,bstrDeviceID,hwndParent,bstrFolderName,bstrFilename,plNumFiles,ppbstrFilePaths,ppItem) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [helpstring][call_as] */ HRESULT STDMETHODCALLTYPE IWiaDevMgr2_LocalCreateDevice_Proxy( 
    IWiaDevMgr2 * This,
    /* [in] */ LONG lFlags,
    /* [in] */ __RPC__in BSTR bstrDeviceID,
    /* [out] */ __RPC__deref_out_opt IWiaItem2 **ppWiaItem2Root);


void __RPC_STUB IWiaDevMgr2_LocalCreateDevice_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [nocode][helpstring][call_as] */ HRESULT STDMETHODCALLTYPE IWiaDevMgr2_LocalSelectDeviceDlg_Proxy( 
    IWiaDevMgr2 * This,
    /* [in] */ __RPC__in HWND hwndParent,
    /* [in] */ LONG lDeviceType,
    /* [in] */ LONG lFlags,
    /* [out][in] */ __RPC__deref_inout_opt BSTR *pbstrDeviceID,
    /* [retval][out] */ __RPC__deref_out_opt IWiaItem2 **ppItemRoot);


void __RPC_STUB IWiaDevMgr2_LocalSelectDeviceDlg_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [nocode][helpstring][call_as] */ HRESULT STDMETHODCALLTYPE IWiaDevMgr2_LocalSelectDeviceDlgID_Proxy( 
    IWiaDevMgr2 * This,
    /* [in] */ __RPC__in HWND hwndParent,
    /* [in] */ LONG lDeviceType,
    /* [in] */ LONG lFlags,
    /* [retval][out] */ __RPC__deref_out_opt BSTR *pbstrDeviceID);


void __RPC_STUB IWiaDevMgr2_LocalSelectDeviceDlgID_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][call_as] */ HRESULT STDMETHODCALLTYPE IWiaDevMgr2_LocalRegisterEventCallbackInterface_Proxy( 
    IWiaDevMgr2 * This,
    /* [in] */ LONG lFlags,
    /* [in] */ __RPC__in BSTR bstrDeviceID,
    /* [in] */ __RPC__in const GUID *pEventGUID,
    /* [unique][in] */ __RPC__in_opt IWiaEventCallback *pIWiaEventCallback,
    /* [out] */ __RPC__deref_out_opt IUnknown **pEventObject);


void __RPC_STUB IWiaDevMgr2_LocalRegisterEventCallbackInterface_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][call_as] */ HRESULT STDMETHODCALLTYPE IWiaDevMgr2_LocalRegisterEventCallbackProgram_Proxy( 
    IWiaDevMgr2 * This,
    /* [in] */ LONG lFlags,
    /* [in] */ __RPC__in BSTR bstrDeviceID,
    /* [in] */ __RPC__in const GUID *pEventGUID,
    /* [in] */ __RPC__in BSTR bstrFullAppName,
    /* [in] */ __RPC__in BSTR bstrCommandLineArg,
    /* [in] */ __RPC__in BSTR bstrName,
    /* [in] */ __RPC__in BSTR bstrDescription,
    /* [in] */ __RPC__in BSTR bstrIcon);


void __RPC_STUB IWiaDevMgr2_LocalRegisterEventCallbackProgram_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][call_as] */ HRESULT STDMETHODCALLTYPE IWiaDevMgr2_LocalRegisterEventCallbackCLSID_Proxy( 
    IWiaDevMgr2 * This,
    /* [in] */ LONG lFlags,
    /* [in] */ __RPC__in BSTR bstrDeviceID,
    /* [in] */ __RPC__in const GUID *pEventGUID,
    /* [unique][in] */ __RPC__in_opt const GUID *pClsID,
    /* [in] */ __RPC__in BSTR bstrName,
    /* [in] */ __RPC__in BSTR bstrDescription,
    /* [in] */ __RPC__in BSTR bstrIcon);


void __RPC_STUB IWiaDevMgr2_LocalRegisterEventCallbackCLSID_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][call_as] */ HRESULT STDMETHODCALLTYPE IWiaDevMgr2_LocalGetImageDlg_Proxy( 
    IWiaDevMgr2 * This,
    /* [in] */ LONG lFlags,
    /* [in] */ __RPC__in BSTR bstrDeviceID,
    /* [in] */ __RPC__in HWND hwndParent,
    /* [in] */ __RPC__in BSTR bstrFolderName,
    /* [in] */ __RPC__in BSTR bstrFilename,
    /* [in] */ __RPC__in LONG *plNumFiles,
    /* [in] */ __RPC__deref_in_opt BSTR **ppbstrFilePaths,
    /* [out][in] */ __RPC__deref_inout_opt IWiaItem2 **ppItem);


void __RPC_STUB IWiaDevMgr2_LocalGetImageDlg_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IWiaDevMgr2_INTERFACE_DEFINED__ */



#ifndef __WiaDevMgr_LIBRARY_DEFINED__
#define __WiaDevMgr_LIBRARY_DEFINED__

/* library WiaDevMgr */
/* [helpstring][version][uuid] */ 


EXTERN_C const IID LIBID_WiaDevMgr;

EXTERN_C const CLSID CLSID_WiaDevMgr;

#ifdef __cplusplus

class DECLSPEC_UUID("a1f4e726-8cf1-11d1-bf92-0060081ed811")
WiaDevMgr;
#endif

EXTERN_C const CLSID CLSID_WiaDevMgr2;

#ifdef __cplusplus

class DECLSPEC_UUID("B6C292BC-7C88-41ee-8B54-8EC92617E599")
WiaDevMgr2;
#endif

EXTERN_C const CLSID CLSID_WiaLog;

#ifdef __cplusplus

class DECLSPEC_UUID("A1E75357-881A-419e-83E2-BB16DB197C68")
WiaLog;
#endif
#endif /* __WiaDevMgr_LIBRARY_DEFINED__ */

/* Additional Prototypes for ALL interfaces */

unsigned long             __RPC_USER  BSTR_UserSize(     unsigned long *, unsigned long            , BSTR * ); 
unsigned char * __RPC_USER  BSTR_UserMarshal(  unsigned long *, unsigned char *, BSTR * ); 
unsigned char * __RPC_USER  BSTR_UserUnmarshal(unsigned long *, unsigned char *, BSTR * ); 
void                      __RPC_USER  BSTR_UserFree(     unsigned long *, BSTR * ); 

unsigned long             __RPC_USER  HWND_UserSize(     unsigned long *, unsigned long            , HWND * ); 
unsigned char * __RPC_USER  HWND_UserMarshal(  unsigned long *, unsigned char *, HWND * ); 
unsigned char * __RPC_USER  HWND_UserUnmarshal(unsigned long *, unsigned char *, HWND * ); 
void                      __RPC_USER  HWND_UserFree(     unsigned long *, HWND * ); 

unsigned long             __RPC_USER  LPSAFEARRAY_UserSize(     unsigned long *, unsigned long            , LPSAFEARRAY * ); 
unsigned char * __RPC_USER  LPSAFEARRAY_UserMarshal(  unsigned long *, unsigned char *, LPSAFEARRAY * ); 
unsigned char * __RPC_USER  LPSAFEARRAY_UserUnmarshal(unsigned long *, unsigned char *, LPSAFEARRAY * ); 
void                      __RPC_USER  LPSAFEARRAY_UserFree(     unsigned long *, LPSAFEARRAY * ); 

unsigned long             __RPC_USER  STGMEDIUM_UserSize(     unsigned long *, unsigned long            , STGMEDIUM * ); 
unsigned char * __RPC_USER  STGMEDIUM_UserMarshal(  unsigned long *, unsigned char *, STGMEDIUM * ); 
unsigned char * __RPC_USER  STGMEDIUM_UserUnmarshal(unsigned long *, unsigned char *, STGMEDIUM * ); 
void                      __RPC_USER  STGMEDIUM_UserFree(     unsigned long *, STGMEDIUM * ); 

unsigned long             __RPC_USER  BSTR_UserSize64(     unsigned long *, unsigned long            , BSTR * ); 
unsigned char * __RPC_USER  BSTR_UserMarshal64(  unsigned long *, unsigned char *, BSTR * ); 
unsigned char * __RPC_USER  BSTR_UserUnmarshal64(unsigned long *, unsigned char *, BSTR * ); 
void                      __RPC_USER  BSTR_UserFree64(     unsigned long *, BSTR * ); 

unsigned long             __RPC_USER  HWND_UserSize64(     unsigned long *, unsigned long            , HWND * ); 
unsigned char * __RPC_USER  HWND_UserMarshal64(  unsigned long *, unsigned char *, HWND * ); 
unsigned char * __RPC_USER  HWND_UserUnmarshal64(unsigned long *, unsigned char *, HWND * ); 
void                      __RPC_USER  HWND_UserFree64(     unsigned long *, HWND * ); 

unsigned long             __RPC_USER  LPSAFEARRAY_UserSize64(     unsigned long *, unsigned long            , LPSAFEARRAY * ); 
unsigned char * __RPC_USER  LPSAFEARRAY_UserMarshal64(  unsigned long *, unsigned char *, LPSAFEARRAY * ); 
unsigned char * __RPC_USER  LPSAFEARRAY_UserUnmarshal64(unsigned long *, unsigned char *, LPSAFEARRAY * ); 
void                      __RPC_USER  LPSAFEARRAY_UserFree64(     unsigned long *, LPSAFEARRAY * ); 

unsigned long             __RPC_USER  STGMEDIUM_UserSize64(     unsigned long *, unsigned long            , STGMEDIUM * ); 
unsigned char * __RPC_USER  STGMEDIUM_UserMarshal64(  unsigned long *, unsigned char *, STGMEDIUM * ); 
unsigned char * __RPC_USER  STGMEDIUM_UserUnmarshal64(unsigned long *, unsigned char *, STGMEDIUM * ); 
void                      __RPC_USER  STGMEDIUM_UserFree64(     unsigned long *, STGMEDIUM * ); 

/* [local] */ HRESULT STDMETHODCALLTYPE IWiaDevMgr_CreateDevice_Proxy( 
    IWiaDevMgr * This,
    /* [in] */ BSTR bstrDeviceID,
    /* [out] */ IWiaItem **ppWiaItemRoot);


/* [helpstring][call_as] */ HRESULT STDMETHODCALLTYPE IWiaDevMgr_CreateDevice_Stub( 
    IWiaDevMgr * This,
    /* [in] */ __RPC__in BSTR bstrDeviceID,
    /* [out] */ __RPC__deref_out_opt IWiaItem **ppWiaItemRoot);

/* [local] */ HRESULT STDMETHODCALLTYPE IWiaDevMgr_SelectDeviceDlg_Proxy( 
    IWiaDevMgr * This,
    /* [in] */ HWND hwndParent,
    /* [in] */ LONG lDeviceType,
    /* [in] */ LONG lFlags,
    /* [out][in] */ BSTR *pbstrDeviceID,
    /* [retval][out] */ IWiaItem **ppItemRoot);


/* [nocode][helpstring][call_as] */ HRESULT STDMETHODCALLTYPE IWiaDevMgr_SelectDeviceDlg_Stub( 
    IWiaDevMgr * This,
    /* [in] */ __RPC__in HWND hwndParent,
    /* [in] */ LONG lDeviceType,
    /* [in] */ LONG lFlags,
    /* [out][in] */ __RPC__deref_inout_opt BSTR *pbstrDeviceID,
    /* [retval][out] */ __RPC__deref_out_opt IWiaItem **ppItemRoot);

/* [local] */ HRESULT STDMETHODCALLTYPE IWiaDevMgr_SelectDeviceDlgID_Proxy( 
    IWiaDevMgr * This,
    /* [in] */ HWND hwndParent,
    /* [in] */ LONG lDeviceType,
    /* [in] */ LONG lFlags,
    /* [retval][out] */ BSTR *pbstrDeviceID);


/* [nocode][helpstring][call_as] */ HRESULT STDMETHODCALLTYPE IWiaDevMgr_SelectDeviceDlgID_Stub( 
    IWiaDevMgr * This,
    /* [in] */ __RPC__in HWND hwndParent,
    /* [in] */ LONG lDeviceType,
    /* [in] */ LONG lFlags,
    /* [retval][out] */ __RPC__deref_out_opt BSTR *pbstrDeviceID);

/* [local] */ HRESULT STDMETHODCALLTYPE IWiaDevMgr_GetImageDlg_Proxy( 
    IWiaDevMgr * This,
    /* [in] */ HWND hwndParent,
    /* [in] */ LONG lDeviceType,
    /* [in] */ LONG lFlags,
    /* [in] */ LONG lIntent,
    /* [in] */ IWiaItem *pItemRoot,
    /* [in] */ BSTR bstrFilename,
    /* [out][in] */ GUID *pguidFormat);


/* [nocode][helpstring][call_as] */ HRESULT STDMETHODCALLTYPE IWiaDevMgr_GetImageDlg_Stub( 
    IWiaDevMgr * This,
    /* [in] */ __RPC__in HWND hwndParent,
    /* [in] */ LONG lDeviceType,
    /* [in] */ LONG lFlags,
    /* [in] */ LONG lIntent,
    /* [in] */ __RPC__in_opt IWiaItem *pItemRoot,
    /* [in] */ __RPC__in BSTR bstrFilename,
    /* [out][in] */ __RPC__inout GUID *pguidFormat);

/* [local] */ HRESULT STDMETHODCALLTYPE IWiaDevMgr_RegisterEventCallbackProgram_Proxy( 
    IWiaDevMgr * This,
    /* [in] */ LONG lFlags,
    /* [in] */ BSTR bstrDeviceID,
    /* [in] */ const GUID *pEventGUID,
    /* [in] */ BSTR bstrCommandline,
    /* [in] */ BSTR bstrName,
    /* [in] */ BSTR bstrDescription,
    /* [in] */ BSTR bstrIcon);


/* [helpstring][call_as] */ HRESULT STDMETHODCALLTYPE IWiaDevMgr_RegisterEventCallbackProgram_Stub( 
    IWiaDevMgr * This,
    /* [in] */ LONG lFlags,
    /* [in] */ __RPC__in BSTR bstrDeviceID,
    /* [in] */ __RPC__in const GUID *pEventGUID,
    /* [in] */ __RPC__in BSTR bstrCommandline,
    /* [in] */ __RPC__in BSTR bstrName,
    /* [in] */ __RPC__in BSTR bstrDescription,
    /* [in] */ __RPC__in BSTR bstrIcon);

/* [local] */ HRESULT STDMETHODCALLTYPE IWiaDevMgr_RegisterEventCallbackInterface_Proxy( 
    IWiaDevMgr * This,
    /* [in] */ LONG lFlags,
    /* [in] */ BSTR bstrDeviceID,
    /* [in] */ const GUID *pEventGUID,
    /* [unique][in] */ IWiaEventCallback *pIWiaEventCallback,
    /* [out] */ IUnknown **pEventObject);


/* [helpstring][call_as] */ HRESULT STDMETHODCALLTYPE IWiaDevMgr_RegisterEventCallbackInterface_Stub( 
    IWiaDevMgr * This,
    /* [in] */ LONG lFlags,
    /* [in] */ __RPC__in BSTR bstrDeviceID,
    /* [in] */ __RPC__in const GUID *pEventGUID,
    /* [unique][in] */ __RPC__in_opt IWiaEventCallback *pIWiaEventCallback,
    /* [out] */ __RPC__deref_out_opt IUnknown **pEventObject);

/* [local] */ HRESULT STDMETHODCALLTYPE IWiaDevMgr_RegisterEventCallbackCLSID_Proxy( 
    IWiaDevMgr * This,
    /* [in] */ LONG lFlags,
    /* [in] */ BSTR bstrDeviceID,
    /* [in] */ const GUID *pEventGUID,
    /* [unique][in] */ const GUID *pClsID,
    /* [in] */ BSTR bstrName,
    /* [in] */ BSTR bstrDescription,
    /* [in] */ BSTR bstrIcon);


/* [helpstring][call_as] */ HRESULT STDMETHODCALLTYPE IWiaDevMgr_RegisterEventCallbackCLSID_Stub( 
    IWiaDevMgr * This,
    /* [in] */ LONG lFlags,
    /* [in] */ __RPC__in BSTR bstrDeviceID,
    /* [in] */ __RPC__in const GUID *pEventGUID,
    /* [unique][in] */ __RPC__in_opt const GUID *pClsID,
    /* [in] */ __RPC__in BSTR bstrName,
    /* [in] */ __RPC__in BSTR bstrDescription,
    /* [in] */ __RPC__in BSTR bstrIcon);

/* [local] */ HRESULT STDMETHODCALLTYPE IEnumWIA_DEV_INFO_Next_Proxy( 
    IEnumWIA_DEV_INFO * This,
    /* [in] */ ULONG celt,
    /* [length_is][size_is][out] */ IWiaPropertyStorage **rgelt,
    /* [unique][out][in] */ ULONG *pceltFetched);


/* [helpstring][call_as] */ HRESULT STDMETHODCALLTYPE IEnumWIA_DEV_INFO_Next_Stub( 
    IEnumWIA_DEV_INFO * This,
    /* [in] */ ULONG celt,
    /* [length_is][size_is][out] */ __RPC__out_ecount_part(celt, *pceltFetched) IWiaPropertyStorage **rgelt,
    /* [unique][out][in] */ __RPC__inout_opt ULONG *pceltFetched);

/* [local] */ HRESULT STDMETHODCALLTYPE IWiaDataCallback_BandedDataCallback_Proxy( 
    IWiaDataCallback * This,
    /* [in] */ LONG lMessage,
    /* [in] */ LONG lStatus,
    /* [in] */ LONG lPercentComplete,
    /* [in] */ LONG lOffset,
    /* [in] */ LONG lLength,
    /* [in] */ LONG lReserved,
    /* [in] */ LONG lResLength,
    /* [size_is][in] */ BYTE *pbBuffer);


/* [helpstring][call_as] */ HRESULT STDMETHODCALLTYPE IWiaDataCallback_BandedDataCallback_Stub( 
    IWiaDataCallback * This,
    /* [in] */ LONG lMessage,
    /* [in] */ LONG lStatus,
    /* [in] */ LONG lPercentComplete,
    /* [in] */ LONG lOffset,
    /* [in] */ LONG lLength,
    /* [in] */ LONG lReserved,
    /* [in] */ LONG lResLength,
    /* [unique][size_is][in] */ __RPC__in_ecount_full_opt(lResLength) BYTE *pbBuffer);

/* [local] */ HRESULT STDMETHODCALLTYPE IWiaDataTransfer_idtGetData_Proxy( 
    IWiaDataTransfer * This,
    /* [out][in] */ LPSTGMEDIUM pMedium,
    /* [unique][in] */ IWiaDataCallback *pIWiaDataCallback);


/* [helpstring][call_as] */ HRESULT STDMETHODCALLTYPE IWiaDataTransfer_idtGetData_Stub( 
    IWiaDataTransfer * This,
    /* [out][in] */ __RPC__inout LPSTGMEDIUM pMedium,
    /* [unique][in] */ __RPC__in_opt IWiaDataCallback *pIWiaDataCallback);

/* [local] */ HRESULT STDMETHODCALLTYPE IWiaDataTransfer_idtGetBandedData_Proxy( 
    IWiaDataTransfer * This,
    /* [unique][in] */ PWIA_DATA_TRANSFER_INFO pWiaDataTransInfo,
    /* [unique][in] */ IWiaDataCallback *pIWiaDataCallback);


/* [helpstring][call_as] */ HRESULT STDMETHODCALLTYPE IWiaDataTransfer_idtGetBandedData_Stub( 
    IWiaDataTransfer * This,
    /* [unique][in] */ __RPC__in_opt PWIA_DATA_TRANSFER_INFO pWiaDataTransInfo,
    /* [unique][in] */ __RPC__in_opt IWiaDataCallback *pIWiaDataCallback);

/* [local] */ HRESULT STDMETHODCALLTYPE IWiaItem_DeviceDlg_Proxy( 
    IWiaItem * This,
    /* [in] */ HWND hwndParent,
    /* [in] */ LONG lFlags,
    /* [in] */ LONG lIntent,
    /* [out] */ LONG *plItemCount,
    /* [out] */ IWiaItem ***ppIWiaItem);


/* [nocode][helpstring][call_as] */ HRESULT STDMETHODCALLTYPE IWiaItem_DeviceDlg_Stub( 
    IWiaItem * This,
    /* [in] */ __RPC__in HWND hwndParent,
    /* [in] */ LONG lFlags,
    /* [in] */ LONG lIntent,
    /* [out] */ __RPC__out LONG *plItemCount,
    /* [out] */ __RPC__deref_out_opt IWiaItem ***pIWiaItem);

/* [local] */ HRESULT STDMETHODCALLTYPE IWiaPropertyStorage_WriteMultiple_Proxy( 
    IWiaPropertyStorage * This,
    /* [in] */ ULONG cpspec,
    /* [size_is][in] */ const PROPSPEC rgpspec[  ],
    /* [size_is][in] */ const PROPVARIANT rgpropvar[  ],
    /* [in] */ PROPID propidNameFirst);


/* [call_as] */ HRESULT STDMETHODCALLTYPE IWiaPropertyStorage_WriteMultiple_Stub( 
    IWiaPropertyStorage * This,
    /* [in] */ ULONG cpspec,
    /* [size_is][in] */ __RPC__in_ecount_full(cpspec) const PROPSPEC *rgpspec,
    /* [size_is][in] */ __RPC__in_ecount_full(cpspec) const PROPVARIANT *rgpropvar,
    /* [in] */ PROPID propidNameFirst);

/* [local] */ HRESULT STDMETHODCALLTYPE IWiaPropertyStorage_SetPropertyStream_Proxy( 
    IWiaPropertyStorage * This,
    /* [in] */ GUID *pCompatibilityId,
    /* [unique][in] */ IStream *pIStream);


/* [helpstring][call_as] */ HRESULT STDMETHODCALLTYPE IWiaPropertyStorage_SetPropertyStream_Stub( 
    IWiaPropertyStorage * This,
    /* [in] */ __RPC__in GUID *pCompatibilityId,
    /* [unique][in] */ __RPC__in_opt IStream *pIStream);

/* [local] */ HRESULT STDMETHODCALLTYPE IEnumWiaItem_Next_Proxy( 
    IEnumWiaItem * This,
    /* [in] */ ULONG celt,
    /* [length_is][size_is][out] */ IWiaItem **ppIWiaItem,
    /* [unique][out][in] */ ULONG *pceltFetched);


/* [helpstring][call_as] */ HRESULT STDMETHODCALLTYPE IEnumWiaItem_Next_Stub( 
    IEnumWiaItem * This,
    /* [in] */ ULONG celt,
    /* [length_is][size_is][out] */ __RPC__out_ecount_part(celt, *pceltFetched) IWiaItem **ppIWiaItem,
    /* [unique][out][in] */ __RPC__inout_opt ULONG *pceltFetched);

/* [local] */ HRESULT STDMETHODCALLTYPE IEnumWIA_DEV_CAPS_Next_Proxy( 
    IEnumWIA_DEV_CAPS * This,
    /* [in] */ ULONG celt,
    /* [length_is][size_is][out] */ WIA_DEV_CAP *rgelt,
    /* [unique][out][in] */ ULONG *pceltFetched);


/* [helpstring][call_as] */ HRESULT STDMETHODCALLTYPE IEnumWIA_DEV_CAPS_Next_Stub( 
    IEnumWIA_DEV_CAPS * This,
    /* [in] */ ULONG celt,
    /* [length_is][size_is][out] */ __RPC__out_ecount_part(celt, *pceltFetched) WIA_DEV_CAP *rgelt,
    /* [unique][out][in] */ __RPC__inout_opt ULONG *pceltFetched);

/* [local] */ HRESULT STDMETHODCALLTYPE IEnumWIA_FORMAT_INFO_Next_Proxy( 
    IEnumWIA_FORMAT_INFO * This,
    /* [in] */ ULONG celt,
    /* [length_is][size_is][out] */ WIA_FORMAT_INFO *rgelt,
    /* [unique][out][in] */ ULONG *pceltFetched);


/* [helpstring][call_as] */ HRESULT STDMETHODCALLTYPE IEnumWIA_FORMAT_INFO_Next_Stub( 
    IEnumWIA_FORMAT_INFO * This,
    /* [in] */ ULONG celt,
    /* [length_is][size_is][out] */ __RPC__out_ecount_part(celt, *pceltFetched) WIA_FORMAT_INFO *rgelt,
    /* [unique][out][in] */ __RPC__inout_opt ULONG *pceltFetched);

/* [helpstring][local] */ HRESULT STDMETHODCALLTYPE IWiaTransfer_Download_Proxy( 
    IWiaTransfer * This,
    /* [in] */ LONG lFlags,
    /* [in] */ IWiaTransferCallback *pIWiaTransferCallback);


/* [call_as] */ HRESULT STDMETHODCALLTYPE IWiaTransfer_Download_Stub( 
    IWiaTransfer * This,
    /* [in] */ LONG lFlags,
    /* [in] */ __RPC__in_opt IWiaTransferCallback *pIWiaTransferCallback);

/* [helpstring][local] */ HRESULT STDMETHODCALLTYPE IWiaTransfer_Upload_Proxy( 
    IWiaTransfer * This,
    /* [in] */ LONG lFlags,
    /* [in] */ IStream *pSource,
    /* [in] */ IWiaTransferCallback *pIWiaTransferCallback);


/* [call_as] */ HRESULT STDMETHODCALLTYPE IWiaTransfer_Upload_Stub( 
    IWiaTransfer * This,
    /* [in] */ LONG lFlags,
    /* [in] */ __RPC__in_opt IStream *pSource,
    /* [in] */ __RPC__in_opt IWiaTransferCallback *pIWiaTransferCallback);

/* [local] */ HRESULT STDMETHODCALLTYPE IEnumWiaItem2_Next_Proxy( 
    IEnumWiaItem2 * This,
    /* [in] */ ULONG cElt,
    /* [length_is][size_is][out] */ IWiaItem2 **ppIWiaItem2,
    /* [unique][out][in] */ ULONG *pcEltFetched);


/* [helpstring][call_as] */ HRESULT STDMETHODCALLTYPE IEnumWiaItem2_Next_Stub( 
    IEnumWiaItem2 * This,
    /* [in] */ ULONG cElt,
    /* [length_is][size_is][out] */ __RPC__out_ecount_part(cElt, *pcEltFetched) IWiaItem2 **ppIWiaItem2,
    /* [unique][out][in] */ __RPC__inout_opt ULONG *pcEltFetched);

/* [local] */ HRESULT STDMETHODCALLTYPE IWiaItem2_DeviceDlg_Proxy( 
    IWiaItem2 * This,
    /* [in] */ LONG lFlags,
    /* [in] */ HWND hwndParent,
    /* [in] */ BSTR bstrFolderName,
    /* [in] */ BSTR bstrFilename,
    /* [in] */ LONG *plNumFiles,
    /* [in] */ BSTR **ppbstrFilePaths,
    /* [out][in] */ IWiaItem2 **ppItem);


/* [nocode][helpstring][call_as] */ HRESULT STDMETHODCALLTYPE IWiaItem2_DeviceDlg_Stub( 
    IWiaItem2 * This,
    /* [in] */ LONG lFlags,
    /* [in] */ __RPC__in HWND hwndParent,
    /* [in] */ __RPC__in BSTR bstrFolderName,
    /* [in] */ __RPC__in BSTR bstrFilename,
    /* [in] */ __RPC__in LONG *plNumFiles,
    /* [in] */ __RPC__deref_in_opt BSTR **ppbstrFilePaths,
    /* [out][in] */ __RPC__deref_inout_opt IWiaItem2 **ppItem);

/* [local] */ HRESULT STDMETHODCALLTYPE IWiaItem2_CheckExtension_Proxy( 
    IWiaItem2 * This,
    /* [in] */ LONG lFlags,
    /* [in] */ BSTR bstrName,
    /* [in] */ REFIID riidExtensionInterface,
    /* [out] */ BOOL *pbExtensionExists);


/* [helpstring][call_as] */ HRESULT STDMETHODCALLTYPE IWiaItem2_CheckExtension_Stub( 
    IWiaItem2 * This,
    /* [in] */ LONG lFlags,
    /* [in] */ __RPC__in BSTR bstrName,
    /* [in] */ __RPC__in REFIID riidExtensionInterface,
    /* [out] */ __RPC__out BOOL *pbExtensionExists);

/* [local] */ HRESULT STDMETHODCALLTYPE IWiaItem2_GetExtension_Proxy( 
    IWiaItem2 * This,
    /* [in] */ LONG lFlags,
    /* [in] */ BSTR bstrName,
    /* [in] */ REFIID riidExtensionInterface,
    /* [iid_is][out] */ void **ppOut);


/* [helpstring][call_as] */ HRESULT STDMETHODCALLTYPE IWiaItem2_GetExtension_Stub( 
    IWiaItem2 * This,
    /* [in] */ LONG lFlags,
    /* [in] */ __RPC__in BSTR bstrName,
    /* [in] */ __RPC__in REFIID riidExtensionInterface,
    /* [iid_is][out] */ __RPC__deref_out_opt void **ppOut);

/* [local] */ HRESULT STDMETHODCALLTYPE IWiaItem2_GetPreviewComponent_Proxy( 
    IWiaItem2 * This,
    /* [in] */ LONG lFlags,
    /* [out] */ IWiaPreview **ppWiaPreview);


/* [helpstring][call_as] */ HRESULT STDMETHODCALLTYPE IWiaItem2_GetPreviewComponent_Stub( 
    IWiaItem2 * This,
    /* [in] */ LONG lFlags,
    /* [out] */ __RPC__deref_out_opt IWiaPreview **ppWiaPreview);

/* [local] */ HRESULT STDMETHODCALLTYPE IWiaDevMgr2_CreateDevice_Proxy( 
    IWiaDevMgr2 * This,
    /* [in] */ LONG lFlags,
    /* [in] */ BSTR bstrDeviceID,
    /* [out] */ IWiaItem2 **ppWiaItem2Root);


/* [helpstring][call_as] */ HRESULT STDMETHODCALLTYPE IWiaDevMgr2_CreateDevice_Stub( 
    IWiaDevMgr2 * This,
    /* [in] */ LONG lFlags,
    /* [in] */ __RPC__in BSTR bstrDeviceID,
    /* [out] */ __RPC__deref_out_opt IWiaItem2 **ppWiaItem2Root);

/* [local] */ HRESULT STDMETHODCALLTYPE IWiaDevMgr2_SelectDeviceDlg_Proxy( 
    IWiaDevMgr2 * This,
    /* [in] */ HWND hwndParent,
    /* [in] */ LONG lDeviceType,
    /* [in] */ LONG lFlags,
    /* [out][in] */ BSTR *pbstrDeviceID,
    /* [retval][out] */ IWiaItem2 **ppItemRoot);


/* [nocode][helpstring][call_as] */ HRESULT STDMETHODCALLTYPE IWiaDevMgr2_SelectDeviceDlg_Stub( 
    IWiaDevMgr2 * This,
    /* [in] */ __RPC__in HWND hwndParent,
    /* [in] */ LONG lDeviceType,
    /* [in] */ LONG lFlags,
    /* [out][in] */ __RPC__deref_inout_opt BSTR *pbstrDeviceID,
    /* [retval][out] */ __RPC__deref_out_opt IWiaItem2 **ppItemRoot);

/* [local] */ HRESULT STDMETHODCALLTYPE IWiaDevMgr2_SelectDeviceDlgID_Proxy( 
    IWiaDevMgr2 * This,
    /* [in] */ HWND hwndParent,
    /* [in] */ LONG lDeviceType,
    /* [in] */ LONG lFlags,
    /* [retval][out] */ BSTR *pbstrDeviceID);


/* [nocode][helpstring][call_as] */ HRESULT STDMETHODCALLTYPE IWiaDevMgr2_SelectDeviceDlgID_Stub( 
    IWiaDevMgr2 * This,
    /* [in] */ __RPC__in HWND hwndParent,
    /* [in] */ LONG lDeviceType,
    /* [in] */ LONG lFlags,
    /* [retval][out] */ __RPC__deref_out_opt BSTR *pbstrDeviceID);

/* [local] */ HRESULT STDMETHODCALLTYPE IWiaDevMgr2_RegisterEventCallbackInterface_Proxy( 
    IWiaDevMgr2 * This,
    /* [in] */ LONG lFlags,
    /* [in] */ BSTR bstrDeviceID,
    /* [in] */ const GUID *pEventGUID,
    /* [unique][in] */ IWiaEventCallback *pIWiaEventCallback,
    /* [out] */ IUnknown **pEventObject);


/* [helpstring][call_as] */ HRESULT STDMETHODCALLTYPE IWiaDevMgr2_RegisterEventCallbackInterface_Stub( 
    IWiaDevMgr2 * This,
    /* [in] */ LONG lFlags,
    /* [in] */ __RPC__in BSTR bstrDeviceID,
    /* [in] */ __RPC__in const GUID *pEventGUID,
    /* [unique][in] */ __RPC__in_opt IWiaEventCallback *pIWiaEventCallback,
    /* [out] */ __RPC__deref_out_opt IUnknown **pEventObject);

/* [local] */ HRESULT STDMETHODCALLTYPE IWiaDevMgr2_RegisterEventCallbackProgram_Proxy( 
    IWiaDevMgr2 * This,
    /* [in] */ LONG lFlags,
    /* [in] */ BSTR bstrDeviceID,
    /* [in] */ const GUID *pEventGUID,
    /* [in] */ BSTR bstrFullAppName,
    /* [in] */ BSTR bstrCommandLineArg,
    /* [in] */ BSTR bstrName,
    /* [in] */ BSTR bstrDescription,
    /* [in] */ BSTR bstrIcon);


/* [helpstring][call_as] */ HRESULT STDMETHODCALLTYPE IWiaDevMgr2_RegisterEventCallbackProgram_Stub( 
    IWiaDevMgr2 * This,
    /* [in] */ LONG lFlags,
    /* [in] */ __RPC__in BSTR bstrDeviceID,
    /* [in] */ __RPC__in const GUID *pEventGUID,
    /* [in] */ __RPC__in BSTR bstrFullAppName,
    /* [in] */ __RPC__in BSTR bstrCommandLineArg,
    /* [in] */ __RPC__in BSTR bstrName,
    /* [in] */ __RPC__in BSTR bstrDescription,
    /* [in] */ __RPC__in BSTR bstrIcon);

/* [local] */ HRESULT STDMETHODCALLTYPE IWiaDevMgr2_RegisterEventCallbackCLSID_Proxy( 
    IWiaDevMgr2 * This,
    /* [in] */ LONG lFlags,
    /* [in] */ BSTR bstrDeviceID,
    /* [in] */ const GUID *pEventGUID,
    /* [unique][in] */ const GUID *pClsID,
    /* [in] */ BSTR bstrName,
    /* [in] */ BSTR bstrDescription,
    /* [in] */ BSTR bstrIcon);


/* [helpstring][call_as] */ HRESULT STDMETHODCALLTYPE IWiaDevMgr2_RegisterEventCallbackCLSID_Stub( 
    IWiaDevMgr2 * This,
    /* [in] */ LONG lFlags,
    /* [in] */ __RPC__in BSTR bstrDeviceID,
    /* [in] */ __RPC__in const GUID *pEventGUID,
    /* [unique][in] */ __RPC__in_opt const GUID *pClsID,
    /* [in] */ __RPC__in BSTR bstrName,
    /* [in] */ __RPC__in BSTR bstrDescription,
    /* [in] */ __RPC__in BSTR bstrIcon);

/* [local] */ HRESULT STDMETHODCALLTYPE IWiaDevMgr2_GetImageDlg_Proxy( 
    IWiaDevMgr2 * This,
    /* [in] */ LONG lFlags,
    /* [in] */ BSTR bstrDeviceID,
    /* [in] */ HWND hwndParent,
    /* [in] */ BSTR bstrFolderName,
    /* [in] */ BSTR bstrFilename,
    /* [in] */ LONG *plNumFiles,
    /* [in] */ BSTR **ppbstrFilePaths,
    /* [out][in] */ IWiaItem2 **ppItem);


/* [helpstring][call_as] */ HRESULT STDMETHODCALLTYPE IWiaDevMgr2_GetImageDlg_Stub( 
    IWiaDevMgr2 * This,
    /* [in] */ LONG lFlags,
    /* [in] */ __RPC__in BSTR bstrDeviceID,
    /* [in] */ __RPC__in HWND hwndParent,
    /* [in] */ __RPC__in BSTR bstrFolderName,
    /* [in] */ __RPC__in BSTR bstrFilename,
    /* [in] */ __RPC__in LONG *plNumFiles,
    /* [in] */ __RPC__deref_in_opt BSTR **ppbstrFilePaths,
    /* [out][in] */ __RPC__deref_inout_opt IWiaItem2 **ppItem);



/* end of Additional Prototypes */

#ifdef __cplusplus
}
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\win2k8\ddk\inc\winhv.h ===
/*++

Copyright (c) Microsoft Corporation

Module Name:

    winhv.h

Abstract:

    Declaration of WinHv interfaces.


--*/

#ifndef _WINHV_
#define _WINHV_

#if _MSC_VER > 1000
#pragma once
#endif

#if _MSC_VER >= 1200
#pragma warning(push)
#endif

#pragma warning(disable:4201) // nameless struct/union

#ifdef __cplusplus
extern "C"
{
#endif

#ifdef _NTDDK_
#if(NTDDI_VERSION >= NTDDI_WS08) // available in Windows Server 2008 and above
#define WINHV_CURRENT_DDI_VERSION     1
#endif // available in Windows Server 2008 and above
#endif

#include <hvgdk.h>
#include <guiddef.h>

#if !defined(_WINHV_DRIVER_)
#define WINHVAPI DECLSPEC_IMPORT
#else
#define WINHVAPI
#endif

#if defined(_NTDDK_)
#define _WINHV_KERNEL_MODE_
#endif

//
// Typedefs Used By WinHv Interfaces
//

typedef enum _WINHV_FEATURE
{
    WinHvFeatureMaximum
} WINHV_FEATURE, *PWINHV_FEATURE;

typedef struct _WINHV_SERVICE_SET
{
    ULONG64 ExactlyMainlineVersionNumber;
    ULONG64 ServiceVersionNumber;
} WINHV_SERVICE_SET, *PWINHV_SERVICE_SET;

//
// These two definitions replicate the NODE_REQUIREMENT and
// MM_ANY_NODE_OK definitions, because components which include
// winhv.h do not necessarily have those definitions.
//
typedef ULONG WINHV_NODE_REQUIREMENT;
#define WINHV_ANY_NODE_OK (0x80000000)

typedef VOID NTAPI WINHV_ISR_INTERCEPT_ROUTINE(
    __inout PVOID                Context,
    __in    volatile HV_MESSAGE* Message
    );

typedef WINHV_ISR_INTERCEPT_ROUTINE *PWINHV_ISR_INTERCEPT_ROUTINE;

typedef VOID NTAPI WINHV_SINT_ISR(
    __in PVOID                          Context,
    __in HV_MESSAGE*                    Message,
    __in volatile HV_SYNIC_EVENT_FLAGS* EventFlags
    );

typedef WINHV_SINT_ISR *PWINHV_SINT_ISR;

typedef NTSTATUS NTAPI WINHV_LOW_MEMORY_POLICY_ROUTINE(
    __inout_opt PVOID                  Context,
    __in        HV_PARTITION_ID        PartitionId,
    __in        WINHV_NODE_REQUIREMENT NodeRequirement,
    __in        NTSTATUS               HypercallStatus,
    __in        HV_CALL_CODE           CallInProgress,
    __in        ULONG                  Iteration
    );

typedef WINHV_LOW_MEMORY_POLICY_ROUTINE *PWINHV_LOW_MEMORY_POLICY_ROUTINE;

typedef struct _WINHV_TIMER *PWINHV_TIMER;

typedef VOID NTAPI WINHV_ISR_TIMER_ROUTINE(
    __inout PVOID           Context,
    __inout PWINHV_TIMER    Timer,
    __in    HV_NANO100_TIME CurrentTime
    );

typedef WINHV_ISR_TIMER_ROUTINE *PWINHV_ISR_TIMER_ROUTINE;

typedef ULONG64 WINHV_REP_COUNT, *PWINHV_REP_COUNT;

#define MAX_WINHV_REP_COUNT MAXULONG64

typedef VOID (NTAPI *PWINHV_EVENTLOG_COMPLETED_NOTIFICATION_ROUTINE)(
    __in    HV_EVENTLOG_TYPE   EventLogType,
    __in    UINT32             BufferIndex
    );

#ifdef _WINHV_KERNEL_MODE_

//
// WinHv interrupt support
//

typedef struct _WINHV_INTERRUPT_COOKIE* PWINHV_INTERRUPT_COOKIE;

WINHVAPI
NTSTATUS
NTAPI
WinHvSupplyInterruptVector(
    __out PWINHV_INTERRUPT_COOKIE* Cookie,
    __in  ULONG                    Vector,
    __in  KAFFINITY                Affinity,
    __in  BOOLEAN                  UseAutoEoi
    );

WINHVAPI
VOID
NTAPI
WinHvReclaimInterruptVector(
    __in PWINHV_INTERRUPT_COOKIE Cookie
    );

BOOLEAN
NTAPI
WinHvOnInterrupt(
    __in_opt PKINTERRUPT Interrupt,
    __in_opt PVOID       Context
    );

//
// WinHv Management Interfaces
//

WINHVAPI
NTSTATUS
NTAPI
WinHvReportPresentHypervisor(
    VOID
    );

//
// Feature Management Interfaces
//

WINHVAPI
VOID
NTAPI
WinHvQueryFeaturesState(
    __out_opt PULONG64 AvailableFeatureMask,
    __out_opt PULONG64 EnabledFeatureMask
    );

WINHVAPI
NTSTATUS
NTAPI
WinHvQueryFeatureInformation(
    __in      WINHV_FEATURE Feature,
    __in      SIZE_T        InformationLength,
    __out_bcount_part(InformationLength, *ReturnLength)
              PVOID         Information,
    __out_opt PSIZE_T       ReturnLength
    );

WINHVAPI
NTSTATUS
NTAPI
WinHvAdjustFeaturesState(
    __in      ULONG64  FeaturesToAdjustMask,
    __in      ULONG64  EnableDisableMask,
    __out_opt PULONG64 EnabledFeatureMask
    );

//
// Versioning Interfaces
//

WINHVAPI
NTSTATUS
NTAPI
WinHvIsCompatibleHypervisorImplementation(
    __in  ULONG64  MainlineVersionNumber,
    __out PBOOLEAN IsCompatible
    );

WINHVAPI
NTSTATUS
NTAPI
WinHvIsCompatibleWinHvImplementation(
    __in  ULONG64  MainlineVersionNumber,
    __out PBOOLEAN IsCompatible
    );

WINHVAPI
NTSTATUS
NTAPI
WinHvIsCompatibleServicedHypervisorImplementation(
    __in_opt  ULONG64            SameOrBetterMainlineVersionNumber,
    __in      ULONG              Count,
    __in_ecount(Count)
              PWINHV_SERVICE_SET ServiceSet,
    __out     PBOOLEAN           IsCompatible
    );

WINHVAPI
NTSTATUS
NTAPI
WinHvIsCompatibleServicedWinHvImplementation(
    __in_opt  ULONG64            SameOrBetterMainlineVersionNumber,
    __in      ULONG              Count,
    __in_ecount(Count)
              PWINHV_SERVICE_SET ServiceSet,
    __out     PBOOLEAN           IsCompatible
    );

WINHVAPI
NTSTATUS
NTAPI
WinHvGetIdentifierString(
    __out_bcount(BufferLength)
              PWCHAR            Buffer,
    __in      SIZE_T            BufferLength,
    __out_opt PSIZE_T           RequiredLength
    );

//
// WinHv-provided low memory policies, for use with
// WinHvCreatePartition.  Note that callers may supply their own
// policies.
//

NTSTATUS
NTAPI
WinHvLowMemoryPolicyAutoDeposit(
    __inout_opt PVOID                  Context,
    __in        HV_PARTITION_ID        PartitionId,
    __in        WINHV_NODE_REQUIREMENT NodeRequirement,
    __in        NTSTATUS               HypercallStatus,
    __in        HV_CALL_CODE           CallInProgress,
    __in        ULONG                  Iteration
    );

NTSTATUS
NTAPI
WinHvLowMemoryPolicyReturnStatus(
    __inout_opt PVOID                  Context,
    __in        HV_PARTITION_ID        PartitionId,
    __in        WINHV_NODE_REQUIREMENT NodeRequirement,
    __in        NTSTATUS               HypercallStatus,
    __in        HV_CALL_CODE           CallInProgress,
    __in        ULONG                  Iteration
    );

NTSTATUS
NTAPI
WinHvLowMemoryPolicyRaiseException(
    __inout_opt PVOID                  Context,
    __in        HV_PARTITION_ID        PartitionId,
    __in        WINHV_NODE_REQUIREMENT NodeRequirement,
    __in        NTSTATUS               HypercallStatus,
    __in        HV_CALL_CODE           CallInProgress,
    __in        ULONG                  Iteration
    );

//
// SINT Management Interfaces
//

WINHVAPI
NTSTATUS
NTAPI
WinHvAllocatePartitionSintIndex(
    __in  ULONG                InitialIdtVector,
    __in  BOOLEAN              InitiallyMasked,
    __out PHV_SYNIC_SINT_INDEX SintIndex
    );

WINHVAPI
VOID
NTAPI
WinHvFreePartitionSintIndex(
    __in HV_SYNIC_SINT_INDEX SintIndex
    );

WINHVAPI
NTSTATUS
NTAPI
WinHvAllocateSingleSintIndex(
    __in  ULONG                InitialIdtVector,
    __in  BOOLEAN              InitiallyMasked,
    __out PHV_SYNIC_SINT_INDEX SintIndex,
    __out PULONG               NtProcessorNumber
    );

WINHVAPI
VOID
NTAPI
WinHvFreeSingleSintIndex(
    __in HV_SYNIC_SINT_INDEX SintIndex,
    __in ULONG               NtProcessorNumber
    );

//
// Synthetic interrupt register interfaces
//

WINHVAPI
VOID
NTAPI
WinHvSetSint(
    __in HV_SYNIC_SINT_INDEX SintIndex,
    __in ULONG               IdtVector,
    __in BOOLEAN             Masked,
    __in BOOLEAN             AutoEoi,
    __in KAFFINITY           ProcessorMask
    );

WINHVAPI
VOID
NTAPI
WinHvSetSintOnCurrentProcessor(
    __in HV_SYNIC_SINT_INDEX SintIndex,
    __in ULONG               IdtVector,
    __in BOOLEAN             Masked,
    __in BOOLEAN             AutoEoi
    );

WINHVAPI
volatile HV_MESSAGE *
NTAPI
WinHvGetSintMessage(
    __in HV_SYNIC_SINT_INDEX SintIndex
    );

WINHVAPI
volatile HV_SYNIC_EVENT_FLAGS *
NTAPI
WinHvGetSintEventFlags(
    __in HV_SYNIC_SINT_INDEX SintIndex
    );

WINHVAPI
VOID
NTAPI
WinHvSetEndOfMessage(
    VOID
    );

//
// NT Processor/VP Relationship Interfaces
//

WINHVAPI
NTSTATUS
NTAPI
WinHvGetCurrentVpIndex(
    __out HV_VP_INDEX *VpIndex
    );

WINHVAPI
NTSTATUS
NTAPI
WinHvNtProcessorToVpIndex(
    __in  ULONG        NtProcessorNumber,
    __out HV_VP_INDEX *VpIndex
    );

//
// PortID interfaces
//

WINHVAPI
NTSTATUS
NTAPI
WinHvAllocatePortId(
    __in_opt PVOID       Cookie,
    __out    PHV_PORT_ID PortId
    );

WINHVAPI
VOID
NTAPI
WinHvFreePortId(
    __in HV_PORT_ID PortId
    );

WINHVAPI
NTSTATUS
NTAPI
WinHvLookupPortId(
    __in            HV_PORT_ID Port,
    __deref_out_opt PVOID*     PortContext
    );

//
// Timer Interfaces
//

WINHVAPI
HV_NANO100_TIME
NTAPI
WinHvQueryReferenceCounter(
    VOID
    );

WINHVAPI
NTSTATUS
NTAPI
WinHvCreateTimer(
    __deref_out PWINHV_TIMER             *Timer,
    __in        PWINHV_ISR_TIMER_ROUTINE  TimerIsr,
    __inout     PVOID                     IsrContext
    );

WINHVAPI
BOOLEAN
NTAPI
WinHvSetAbsoluteTimer(
    __inout PWINHV_TIMER    Timer,
    __in    HV_NANO100_TIME Expiration
    );

WINHVAPI
VOID
NTAPI
WinHvCancelTimer(
    __inout PWINHV_TIMER Timer
    );

WINHVAPI
VOID
NTAPI
WinHvDeleteTimer(
    __inout PWINHV_TIMER Timer
    );

//
// Sch Power Management interfaces.
//

WINHVAPI
NTSTATUS
NTAPI
WinHvSetLogicalProcessorRunTimeGroup(
    __in ULONG64 Flags,
    __in ULONG64 ProcessorMask
    );

WINHVAPI
NTSTATUS
NTAPI
WinHvClearLogicalProcessorRunTimeGroup(
    __in HV_VP_INDEX VirtualProcessor
    );

WINHVAPI
NTSTATUS
NTAPI
WinHvGetLogicalProcessorRunTime(
    __out PHV_NANO100_TIME     GlobalTime,
    __out PHV_NANO100_TIME     LocalRunTime,
    __out_opt PHV_NANO100_TIME GroupRunTime,
    __out_opt PHV_NANO100_TIME HypervisorTime
    );

//
// Partition Management Interfaces
//

WINHVAPI
NTSTATUS
NTAPI
WinHvCreatePartition(
    __in    ULONG64                          Flags,
    __in    WINHV_NODE_REQUIREMENT           NodeRequirement,
    __out   PHV_PARTITION_ID                 NewPartitionId,
    __in    PWINHV_ISR_INTERCEPT_ROUTINE     InterceptRoutine,
    __inout PVOID                            InterceptContext,
    __in    PWINHV_LOW_MEMORY_POLICY_ROUTINE LowMemoryPolicyRoutine,
    __inout PVOID                            LowMemoryPolicyContext
    );

WINHVAPI
NTSTATUS
NTAPI
WinHvInitializePartition(
    __in HV_PARTITION_ID PartitionId
    );

WINHVAPI
NTSTATUS
NTAPI
WinHvSuspendPartition(
    __in HV_PARTITION_ID PartitionId
    );

WINHVAPI
NTSTATUS
NTAPI
WinHvResumePartition(
    __in HV_PARTITION_ID PartitionId
    );

WINHVAPI
NTSTATUS
NTAPI
WinHvTerminatePartition(
    __in HV_PARTITION_ID PartitionId
    );

WINHVAPI
NTSTATUS
NTAPI
WinHvFinalizePartition(
    __in HV_PARTITION_ID PartitionId
    );

WINHVAPI
NTSTATUS
NTAPI
WinHvDeletePartition(
    __in HV_PARTITION_ID PartitionId
    );

WINHVAPI
NTSTATUS
NTAPI
WinHvGetPartitionId(
    __out PHV_PARTITION_ID PartitionId
    );

WINHVAPI
NTSTATUS
NTAPI
WinHvGetNextChildPartition(
    __in  HV_PARTITION_ID  ParentId,
    __in  HV_PARTITION_ID  PreviousChildId,
    __out PHV_PARTITION_ID NextChildId
    );

WINHVAPI
NTSTATUS
NTAPI
WinHvGetPartitionProperty(
    __in  HV_PARTITION_ID            PartitionId,
    __in  HV_PARTITION_PROPERTY_CODE PropertyCode,
    __out PHV_PARTITION_PROPERTY     PropertyValue
    );

WINHVAPI
NTSTATUS
NTAPI
WinHvSetPartitionProperty(
    __in HV_PARTITION_ID            PartitionId,
    __in HV_PARTITION_PROPERTY_CODE PropertyCode,
    __in HV_PARTITION_PROPERTY      PropertyValue
    );

WINHVAPI
KIRQL
NTAPI
WinHvQueryInterceptIrql(
    VOID
    );

//
// Interception Interfaces
//

WINHVAPI
NTSTATUS
NTAPI
WinHvInstallIntercept(
    __in HV_PARTITION_ID               PartitionId,
    __in HV_INTERCEPT_ACCESS_TYPE_MASK AccessType,
    __in PCHV_INTERCEPT_DESCRIPTOR     Descriptor
    );

//
// GPA Management Interfaces
//

WINHVAPI
NTSTATUS
NTAPI
WinHvMapGpaPages(
    __in  HV_PARTITION_ID     TargetPartitionId,
    __in  HV_GPA_PAGE_NUMBER  TargetGpaBase,
    __in  HV_MAP_GPA_FLAGS    MapFlags,
    __in  WINHV_REP_COUNT     PageCount,
    __in_ecount(PageCount)
          PHV_GPA_PAGE_NUMBER SourceGpaPageList,
    __out PWINHV_REP_COUNT    PagesProcessed
    );

WINHVAPI
NTSTATUS
NTAPI
WinHvUnmapGpaPages(
    __in  HV_PARTITION_ID    TargetPartitionId,
    __in  HV_GPA_PAGE_NUMBER TargetGpaBase,
    __in  WINHV_REP_COUNT    PageCount,
    __out PWINHV_REP_COUNT   PagesProcessed
    );

//
// Resource Management Interfaces
//

WINHVAPI
NTSTATUS
NTAPI
WinHvDepositMemory(
    __in  HV_PARTITION_ID        PartitionId,
    __in  WINHV_REP_COUNT        PageCount,
    __in  WINHV_NODE_REQUIREMENT NodeRequirement,
    __out PWINHV_REP_COUNT       PagesProcessed
    );

WINHVAPI
NTSTATUS
NTAPI
WinHvWithdrawMemory(
    __in  HV_PARTITION_ID        PartitionId,
    __in  WINHV_REP_COUNT        PageCount,
    __in  WINHV_NODE_REQUIREMENT NodeRequirement,
    __out PWINHV_REP_COUNT       PagesProcessed
    );

WINHVAPI
NTSTATUS
NTAPI
WinHvGetMemoryBalance(
    __in  HV_PARTITION_ID        PartitionId,
    __in  WINHV_NODE_REQUIREMENT NodeRequirement,
    __out PULONG64               PagesAvailable,
    __out PULONG64               PagesInUse
    );

//
// Virtual Processor Management Interfaces
//

WINHVAPI
NTSTATUS
NTAPI
WinHvCreateVp(
    __in HV_PARTITION_ID        PartitionId,
    __in WINHV_NODE_REQUIREMENT NodeRequirement,
    __in HV_VP_INDEX            VpIndex,
    __in ULONG64                Flags
    );

WINHVAPI
NTSTATUS
NTAPI
WinHvDeleteVp(
    __in HV_PARTITION_ID PartitionId,
    __in HV_VP_INDEX     VpIndex
    );

WINHVAPI
NTSTATUS
NTAPI
WinHvGetVpRegisters(
    __in  HV_PARTITION_ID    PartitionId,
    __in  HV_VP_INDEX        VpIndex,
    __in  ULONG              RegisterCount,
    __in_ecount(RegisterCount)
          PCHV_REGISTER_NAME RegisterCodeList,
    __out PWINHV_REP_COUNT   RegistersProcessed,
    __out_ecount_part(RegisterCount, *RegistersProcessed)
          PHV_REGISTER_VALUE RegisterValueList
    );

WINHVAPI
NTSTATUS
NTAPI
WinHvSetVpRegisters(
    __in  HV_PARTITION_ID     PartitionId,
    __in  HV_VP_INDEX         VpIndex,
    __in  ULONG               RegisterCount,
    __in_ecount(RegisterCount)
          PCHV_REGISTER_NAME  RegisterNameList,
    __in_ecount(RegisterCount)
          PCHV_REGISTER_VALUE RegisterValueList,
    __out PWINHV_REP_COUNT    RegistersProcessed
    );

//
// Virtual MMU Interfaces
//

WINHVAPI
NTSTATUS
NTAPI
WinHvTranslateVirtualAddress(
    __in  HV_PARTITION_ID     PartitionId,
    __in  HV_VP_INDEX         VpIndex,
    __in  HV_TRANSLATE_GVA_CONTROL_FLAGS
                              ControlFlags,
    __in  HV_GVA_PAGE_NUMBER  GvaPage,
    __out PHV_TRANSLATE_GVA_RESULT
                              TranslationResult,
    __out PHV_GPA_PAGE_NUMBER GpaPage
    );

WINHVAPI
NTSTATUS
NTAPI
WinHvReadGpa(
    __in  HV_PARTITION_ID PartitionId,
    __in  HV_VP_INDEX     VpIndex,
    __in  HV_GPA          BaseGpa,
    __in  ULONG           ByteCount,
    __in  HV_ACCESS_GPA_CONTROL_FLAGS
                          ControlFlags,
    __out PHV_ACCESS_GPA_RESULT
                          AccessResult,
    __out_bcount(ByteCount)
          PVOID           DataBuffer
    );

WINHVAPI
NTSTATUS
NTAPI
WinHvWriteGpa(
    __in  HV_PARTITION_ID PartitionId,
    __in  HV_VP_INDEX     VpIndex,
    __in  HV_GPA          BaseGpa,
    __in  ULONG           ByteCount,
    __in  HV_ACCESS_GPA_CONTROL_FLAGS
                          ControlFlags,
    __in_bcount(ByteCount)
          PVOID           DataBuffer,
    __out PHV_ACCESS_GPA_RESULT
                          AccessResult
    );

//
// SynIC Interfaces
//

WINHVAPI
NTSTATUS
NTAPI
WinHvAssertVirtualInterrupt(
    __in  HV_PARTITION_ID       TargetPartition,
    __in  HV_INTERRUPT_CONTROL  InterruptControl,
    __in  UINT64                DestinationAddress,
    __in  HV_INTERRUPT_VECTOR   RequestedVector
    );

WINHVAPI
NTSTATUS
NTAPI
WinHvClearVirtualInterrupt(
    __in  HV_PARTITION_ID       TargetPartition
    );

//
// Inter-Partition Communication Interfaces
//

WINHVAPI
NTSTATUS
NTAPI
WinHvCreatePort(
    __in HV_PARTITION_ID PortPartition,
    __in HV_PORT_ID      PortId,
    __in HV_PARTITION_ID ConnectionPartition,
    __in PCHV_PORT_INFO  PortInfo
    );

WINHVAPI
NTSTATUS
NTAPI
WinHvDeletePort(
    __in HV_PARTITION_ID PortPartition,
    __in HV_PORT_ID      PortId
    );

WINHVAPI
NTSTATUS
NTAPI
WinHvConnectPort(
    __in HV_PARTITION_ID      ConnectionPartition,
    __in HV_CONNECTION_ID     ConnectionId,
    __in HV_PARTITION_ID      PortPartition,
    __in HV_PORT_ID           PortId,
    __in PCHV_CONNECTION_INFO ConnectionInfo
    );

WINHVAPI
NTSTATUS
NTAPI
WinHvDisconnectPort(
    __in HV_PARTITION_ID  ConnectionPartition,
    __in HV_CONNECTION_ID ConnectionId
    );

WINHVAPI
NTSTATUS
NTAPI
WinHvAdjustMessageBufferCount(
    __in  HV_PARTITION_ID PartitionId,
    __in  ULONG           BufferCountAdjustment,
    __out PULONG          BufferCount
    );

WINHVAPI
NTSTATUS
NTAPI
WinHvCancelMessage(
    __in HV_CONNECTION_ID ConnectionId
    );

WINHVAPI
NTSTATUS
NTAPI
WinHvPostMessage(
    __in    HV_CONNECTION_ID  ConnectionId,
    __in    HV_MESSAGE_TYPE   MessageType,
    __in_bcount(PayloadSize)
            PVOID             Payload,
    __in_range(0, HV_MESSAGE_PAYLOAD_BYTE_COUNT)
            SIZE_T            PayloadSize
    );

WINHVAPI
NTSTATUS
NTAPI
WinHvSignalEvent(
    __in HV_CONNECTION_ID  ConnectionId,
    __in_range(0, HV_EVENT_FLAGS_COUNT - 1)
         USHORT            FlagNumber
    );

WINHVAPI
NTSTATUS
NTAPI
WinHvGetPortProperty(
    __in  HV_PARTITION_ID       PortPartition,
    __in  HV_PORT_ID            PortId,
    __in  HV_PORT_PROPERTY_CODE PropertyCode,
    __out PHV_PORT_PROPERTY     PropertyValue
    );

//
// Scheduler Interfaces
//

WINHVAPI
NTSTATUS
NTAPI
WinHvSpecifyPreferredAffinity(
    __in HV_PARTITION_ID            PartitionId,
    __in HV_VP_INDEX                VpIndex,
    __in HV_LOGICAL_PROCESSOR_INDEX PreferredAffinity
    );

//
// Partition Save & Restore Interfaces
//

#define WINHV_MINIMUM_SAVE_BUFFER_LENGTH (4080)

WINHVAPI
NTSTATUS
NTAPI
WinHvSavePartitionState(
    __in  HV_PARTITION_ID               PartitionId,
    __in  HV_SAVE_RESTORE_STATE_FLAGS   Flags,
    __in  ULONG                         BufferLength,
    __out_bcount_part(BufferLength, *SaveDataCount)
          PCHAR                         SaveData,
    __deref_out_range(0, BufferLength)
          PULONG                        SaveDataCount,
    __out PHV_SAVE_RESTORE_STATE_RESULT SaveState
    );

WINHVAPI
NTSTATUS
NTAPI
WinHvRestorePartitionState(
    __in  HV_PARTITION_ID               PartitionId,
    __in  HV_SAVE_RESTORE_STATE_FLAGS   Flags,
    __in  ULONG                         RestoreDataCount,
    __in_bcount_opt(RestoreDataCount)
          PCHAR                         RestoreData,
    __out PULONG                        RestoreDataConsumed,
    __out PHV_SAVE_RESTORE_STATE_RESULT RestoreState
    );

//
// Eventlog Interfaces
//

WINHVAPI
VOID
NTAPI
WinHvSetEventLogCompletedNotificationRoutine(
    __in PWINHV_EVENTLOG_COMPLETED_NOTIFICATION_ROUTINE NotificationRoutine
    );

WINHVAPI
NTSTATUS
NTAPI
WinHvInitializeEventLogBufferGroup(
    __in HV_EVENTLOG_TYPE             EventLogType,
    __in UINT32                       MaximumBufferCount,
    __in UINT32                       BufferSizeInPages,
    __in UINT32                       Threshold,
    __in HV_EVENTLOG_ENTRY_TIME_BASIS TimeBasis
    );

WINHVAPI
NTSTATUS
NTAPI
WinHvFinalizeEventLogBufferGroup(
    __in HV_EVENTLOG_TYPE EventLogType
    );

WINHVAPI
NTSTATUS
NTAPI
WinHvMapEventLogBuffer(
    __in              HV_EVENTLOG_TYPE         EventLogType,
    __in              HV_EVENTLOG_BUFFER_INDEX BufferIndex,
    __out_ecount(512) PHV_GPA_PAGE_NUMBER      GpaPages
    );

WINHVAPI
NTSTATUS
NTAPI
WinHvUnmapEventLogBuffer(
    __in HV_EVENTLOG_TYPE         EventLogType,
    __in HV_EVENTLOG_BUFFER_INDEX BufferIndex
    );

WINHVAPI
NTSTATUS
NTAPI
WinHvCreateEventLogBuffer(
    __in HV_EVENTLOG_TYPE         EventLogType,
    __in HV_EVENTLOG_BUFFER_INDEX BufferIndex,
    __in WINHV_NODE_REQUIREMENT   NodeRequirement
    );

WINHVAPI
NTSTATUS
NTAPI
WinHvDeleteEventLogBuffer(
    __in HV_EVENTLOG_TYPE         EventLogType,
    __in HV_EVENTLOG_BUFFER_INDEX BufferIndex
    );

WINHVAPI
NTSTATUS
NTAPI
WinHvReleaseEventLogBuffer(
    __in HV_EVENTLOG_TYPE         EventLogType,
    __in HV_EVENTLOG_BUFFER_INDEX BufferIndex
    );

WINHVAPI
NTSTATUS
NTAPI
WinHvFlushEventLogBuffer(
    __in HV_EVENTLOG_TYPE EventLogType,
    __in UINT32           BufferIndex
    );

WINHVAPI
NTSTATUS
NTAPI
WinHvSetEventLogGroupSources(
    __in HV_EVENTLOG_TYPE EventLogType,
    __in ULONG64          TraceEnableFlags
    );

//
// Statistics Interfaces
//

typedef struct _WINHV_MAP_STATS_COOKIE* PWINHV_MAP_STATS_COOKIE;

WINHVAPI
NTSTATUS
NTAPI
WinHvMapStatsPage(
    __in  HV_STATS_OBJECT_TYPE       StatsType,
    __in  PCHV_STATS_OBJECT_IDENTITY ObjectIdentity,
    __deref_out_bcount_full(PAGE_SIZE)
          PVOID*                     MapLocation,
    __out PWINHV_MAP_STATS_COOKIE*   Cookie
    );

WINHVAPI
VOID
NTAPI
WinHvUnmapStatsPage(
    __in PWINHV_MAP_STATS_COOKIE Cookie
    );

#endif // ifdef _WINHV_KERNEL_MODE_

#ifdef __cplusplus
}
#endif

#if _MSC_VER >= 1200
#pragma warning(pop)
#else
#pragma warning(default:4201) // nameless struct/union
#endif

#endif // _WINHV_
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\win2k8\ddk\inc\WINUSB.H ===
/*++

Copyright (c) 2002 Microsoft Corporation

Module Name:

        wusb.h

Abstract:

        Public interface to winusb.dll

Environment:

        Kernel Mode Only

Notes:

        THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
        KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
        IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
        PURPOSE.

        Copyright (c) 2001 Microsoft Corporation.  All Rights Reserved.


Revision History:

        11/19/2002 : created

Authors:

--*/

#ifndef __WUSB_H__
#define __WUSB_H__

#ifdef __cplusplus
extern "C" {
#endif

#include <winusbio.h>


typedef PVOID WINUSB_INTERFACE_HANDLE, *PWINUSB_INTERFACE_HANDLE;

   
#pragma pack(1)

typedef struct _WINUSB_SETUP_PACKET {
    UCHAR   RequestType;
    UCHAR   Request;
    USHORT  Value;
    USHORT  Index;
    USHORT  Length;
} WINUSB_SETUP_PACKET, *PWINUSB_SETUP_PACKET;

#pragma pack()



BOOL __stdcall
WinUsb_Initialize(
    IN HANDLE DeviceHandle,
    OUT PWINUSB_INTERFACE_HANDLE InterfaceHandle
    );


BOOL __stdcall
WinUsb_Free(
    IN  WINUSB_INTERFACE_HANDLE InterfaceHandle
    );


BOOL __stdcall
WinUsb_GetAssociatedInterface(
    IN WINUSB_INTERFACE_HANDLE InterfaceHandle,
    IN UCHAR AssociatedInterfaceIndex,
    OUT PWINUSB_INTERFACE_HANDLE AssociatedInterfaceHandle
    );



BOOL __stdcall
WinUsb_GetDescriptor(
    IN  WINUSB_INTERFACE_HANDLE InterfaceHandle,
    IN  UCHAR DescriptorType,
    IN  UCHAR Index,
    IN  USHORT LanguageID,
    OUT PUCHAR Buffer,
    IN  ULONG BufferLength,
    OUT PULONG LengthTransferred
    );

BOOL __stdcall
WinUsb_QueryInterfaceSettings(
    IN WINUSB_INTERFACE_HANDLE InterfaceHandle,
    IN UCHAR AlternateInterfaceNumber,
    OUT PUSB_INTERFACE_DESCRIPTOR UsbAltInterfaceDescriptor
    );

BOOL __stdcall
WinUsb_QueryDeviceInformation(
    IN WINUSB_INTERFACE_HANDLE InterfaceHandle,
    IN ULONG InformationType,
    IN OUT PULONG BufferLength,
    OUT PVOID Buffer
    );

BOOL __stdcall
WinUsb_SetCurrentAlternateSetting(
    IN  WINUSB_INTERFACE_HANDLE InterfaceHandle,
    IN  UCHAR SettingNumber
    );

BOOL __stdcall
WinUsb_GetCurrentAlternateSetting(
    IN  WINUSB_INTERFACE_HANDLE InterfaceHandle,
    OUT PUCHAR SettingNumber
    );


BOOL __stdcall
WinUsb_QueryPipe(
    IN  WINUSB_INTERFACE_HANDLE InterfaceHandle,
    IN  UCHAR AlternateInterfaceNumber,
    IN  UCHAR PipeIndex,
    OUT PWINUSB_PIPE_INFORMATION PipeInformation
    );


BOOL __stdcall
WinUsb_SetPipePolicy(
    IN  WINUSB_INTERFACE_HANDLE InterfaceHandle,
    IN  UCHAR PipeID,
    IN  ULONG PolicyType,
    IN  ULONG ValueLength,
    IN  PVOID Value
    );

BOOL __stdcall
WinUsb_GetPipePolicy(
    IN WINUSB_INTERFACE_HANDLE InterfaceHandle,
    IN UCHAR PipeID,
    IN ULONG PolicyType,
    IN OUT PULONG ValueLength,
    OUT PVOID Value
    );

BOOL __stdcall
WinUsb_ReadPipe(
    IN  WINUSB_INTERFACE_HANDLE InterfaceHandle,
    IN  UCHAR PipeID,
    IN  PUCHAR Buffer,
    IN  ULONG BufferLength,
    OUT PULONG LengthTransferred,
    IN  LPOVERLAPPED Overlapped
    );

BOOL __stdcall
WinUsb_WritePipe(
    IN  WINUSB_INTERFACE_HANDLE InterfaceHandle,
    IN  UCHAR PipeID,
    IN  PUCHAR Buffer,
    IN  ULONG BufferLength,
    OUT PULONG LengthTransferred,
    IN  LPOVERLAPPED Overlapped    
    );

BOOL __stdcall
WinUsb_ControlTransfer(
    IN  WINUSB_INTERFACE_HANDLE InterfaceHandle,
    IN  WINUSB_SETUP_PACKET SetupPacket,
    IN  PUCHAR Buffer,
    IN  ULONG BufferLength,
    OUT PULONG LengthTransferred,
    IN  LPOVERLAPPED Overlapped    
    );

BOOL __stdcall
WinUsb_ResetPipe(
    IN  WINUSB_INTERFACE_HANDLE InterfaceHandle,
    IN  UCHAR PipeID
    );

BOOL __stdcall
WinUsb_AbortPipe(
    IN  WINUSB_INTERFACE_HANDLE InterfaceHandle,
    IN  UCHAR PipeID
    );

BOOL __stdcall
WinUsb_FlushPipe(
    IN  WINUSB_INTERFACE_HANDLE InterfaceHandle,
    IN  UCHAR PipeID
    );

BOOL __stdcall
WinUsb_SetPowerPolicy(
    IN  WINUSB_INTERFACE_HANDLE InterfaceHandle,
    IN  ULONG PolicyType,
    IN  ULONG ValueLength,
    IN  PVOID Value
    );

BOOL __stdcall
WinUsb_GetPowerPolicy(
    IN WINUSB_INTERFACE_HANDLE InterfaceHandle,
    IN ULONG PolicyType,
    IN OUT PULONG ValueLength,
    OUT PVOID Value
    );

BOOL __stdcall
WinUsb_GetOverlappedResult(
    IN WINUSB_INTERFACE_HANDLE InterfaceHandle,
    IN LPOVERLAPPED lpOverlapped,
    OUT LPDWORD lpNumberOfBytesTransferred,
    BOOL bWait
    );
    

PUSB_INTERFACE_DESCRIPTOR __stdcall
WinUsb_ParseConfigurationDescriptor(
    IN PUSB_CONFIGURATION_DESCRIPTOR ConfigurationDescriptor,
    IN PVOID StartPosition,
    IN LONG InterfaceNumber,
    IN LONG AlternateSetting,
    IN LONG InterfaceClass,
    IN LONG InterfaceSubClass,
    IN LONG InterfaceProtocol
    );

PUSB_COMMON_DESCRIPTOR __stdcall
WinUsb_ParseDescriptors(
    IN PVOID    DescriptorBuffer,
    IN ULONG    TotalLength,
    IN PVOID    StartPosition,
    IN LONG     DescriptorType
    );


#ifdef __cplusplus
}
#endif

                   
#endif //__WUSB_H__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\win2k8\ddk\inc\WINUSBIO.H ===
/***************************************************************************

Copyright (c) 2002 Microsoft Corporation

Module Name:

        wusbio.h

Abstract:

        Public header for WINUSB

Environment:

        User and Kernel Mode

Notes:

        THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
        KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
        IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
        PURPOSE.

        Copyright (c) 2001 Microsoft Corporation.  All Rights Reserved.


Revision History:

        11/12/2002 : created


****************************************************************************/

#ifndef __WUSBIO_H__
#define __WUSBIO_H__

#include <usb.h>
                 
// Pipe policy types
#define SHORT_PACKET_TERMINATE  0x01
#define AUTO_CLEAR_STALL        0x02
#define PIPE_TRANSFER_TIMEOUT   0x03
#define IGNORE_SHORT_PACKETS    0x04
#define ALLOW_PARTIAL_READS     0x05
#define AUTO_FLUSH              0x06
#define RAW_IO                  0x07
#define MAXIMUM_TRANSFER_SIZE   0x08

// Power policy types
//
// Add 0x80 for Power policy types in order to prevent overlap with 
// Pipe policy types to prevent "accidentally" setting the wrong value for the 
// wrong type.
//
#define AUTO_SUSPEND            0x81
#define SUSPEND_DELAY           0x83

// Device Information types
#define DEVICE_SPEED            0x01

// Device Speeds
#define LowSpeed                0x01
#define FullSpeed               0x02
#define HighSpeed               0x03 

// {DA812BFF-12C3-46a2-8E2B-DBD3B7834C43}
#include <initguid.h>
DEFINE_GUID(WinUSB_TestGuid, 0xda812bff, 0x12c3, 0x46a2, 0x8e, 0x2b, 0xdb, 0xd3, 0xb7, 0x83, 0x4c, 0x43);

                   
typedef struct _WINUSB_PIPE_INFORMATION {
    USBD_PIPE_TYPE  PipeType;
    UCHAR           PipeId;
    USHORT          MaximumPacketSize;
    UCHAR           Interval;
} WINUSB_PIPE_INFORMATION, *PWINUSB_PIPE_INFORMATION;

#endif // __WUSBIO_H__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\win2k8\ddk\inc\wmidata.h ===
#ifndef _wmidata_h_
#define _wmidata_h_

// MSWmi_MofData - MSWmi_MofData
#define MSWmi_MofDataGuid \
    { 0x05901221,0xd566,0x11d1, { 0xb2,0xf0,0x00,0xa0,0xc9,0x06,0x29,0x10 } }

#if ! (defined(MIDL_PASS))
DEFINE_GUID(MSWmi_MofData_GUID, \
            0x05901221,0xd566,0x11d1,0xb2,0xf0,0x00,0xa0,0xc9,0x06,0x29,0x10);
#endif


typedef struct _MSWmi_MofData
{
    // 
    ULONG Unused1;
    #define MSWmi_MofData_Unused1_SIZE sizeof(ULONG)
    #define MSWmi_MofData_Unused1_ID 1

    // 
    ULONG Unused2;
    #define MSWmi_MofData_Unused2_SIZE sizeof(ULONG)
    #define MSWmi_MofData_Unused2_ID 2

    // 
    ULONG Size;
    #define MSWmi_MofData_Size_SIZE sizeof(ULONG)
    #define MSWmi_MofData_Size_ID 3

    // 
    ULONG Unused4;
    #define MSWmi_MofData_Unused4_SIZE sizeof(ULONG)
    #define MSWmi_MofData_Unused4_ID 4

    // 
    UCHAR BinaryMofData[1];
    #define MSWmi_MofData_BinaryMofData_ID 5

} MSWmi_MofData, *PMSWmi_MofData;

// MSWmi_ProviderInfo - MSWmi_ProviderInfo
#define MSWmi_ProviderInfoGuid \
    { 0xc7bf35d0,0xaadb,0x11d1, { 0xbf,0x4a,0x00,0xa0,0xc9,0x06,0x29,0x10 } }

#if ! (defined(MIDL_PASS))
DEFINE_GUID(MSWmi_ProviderInfo_GUID, \
            0xc7bf35d0,0xaadb,0x11d1,0xbf,0x4a,0x00,0xa0,0xc9,0x06,0x29,0x10);
#endif


// Warning: Header for class MSWmi_ProviderInfo cannot be created
typedef struct _MSWmi_ProviderInfo
{
    char VariableData[1];

} MSWmi_ProviderInfo, *PMSWmi_ProviderInfo;

// MSWmi_PnPDeviceId - MSWmi_PnPDeviceId
#define DATA_PROVIDER_PNPID_GUID \
    { 0xc7bf35d2,0xaadb,0x11d1, { 0xbf,0x4a,0x00,0xa0,0xc9,0x06,0x29,0x10 } }

#if ! (defined(MIDL_PASS))
DEFINE_GUID(MSWmi_PnPDeviceId_GUID, \
            0xc7bf35d2,0xaadb,0x11d1,0xbf,0x4a,0x00,0xa0,0xc9,0x06,0x29,0x10);
#endif


typedef struct _MSWmi_PnPDeviceId
{
    // 
    CHAR VariableData[1];
    #define MSWmi_PnPDeviceId_PnPDeviceId_ID 1

} MSWmi_PnPDeviceId, *PMSWmi_PnPDeviceId;

// MSWmi_PnPInstanceNames - MSWmi_PnPInstanceNames
#define DATA_PROVIDER_PNPID_INSTANCE_NAMES_GUID \
    { 0xc7bf35d3,0xaadb,0x11d1, { 0xbf,0x4a,0x00,0xa0,0xc9,0x06,0x29,0x10 } }

#if ! (defined(MIDL_PASS))
DEFINE_GUID(MSWmi_PnPInstanceNames_GUID, \
            0xc7bf35d3,0xaadb,0x11d1,0xbf,0x4a,0x00,0xa0,0xc9,0x06,0x29,0x10);
#endif


typedef struct _MSWmi_PnPInstanceNames
{
    // 
    ULONG Count;
    #define MSWmi_PnPInstanceNames_Count_SIZE sizeof(ULONG)
    #define MSWmi_PnPInstanceNames_Count_ID 1

    // 
    WCHAR InstanceNameList[1];
    #define MSWmi_PnPInstanceNames_InstanceNameList_ID 2

} MSWmi_PnPInstanceNames, *PMSWmi_PnPInstanceNames;

// MSWmi_Guid - MSWmi_Guid
#define MSWmi_GuidGuid \
    { 0xf8c60aed,0xef8d,0x4f95, { 0x9e,0xa8,0xf0,0x43,0x18,0xa0,0x0f,0x30 } }

#if ! (defined(MIDL_PASS))
DEFINE_GUID(MSWmi_Guid_GUID, \
            0xf8c60aed,0xef8d,0x4f95,0x9e,0xa8,0xf0,0x43,0x18,0xa0,0x0f,0x30);
#endif


typedef struct _MSWmi_Guid
{
    // 
    UCHAR Guid[16];
    #define MSWmi_Guid_Guid_SIZE sizeof(UCHAR[16])
    #define MSWmi_Guid_Guid_ID 1

} MSWmi_Guid, *PMSWmi_Guid;

#define MSWmi_Guid_SIZE (FIELD_OFFSET(MSWmi_Guid, Guid) + MSWmi_Guid_Guid_SIZE)

// MSWmi_GuidRegistrationInfo - MSWmi_GuidRegistrationInfo
#define MSWmi_GuidRegistrationInfoGuid \
    { 0xb48d49a1,0xe777,0x11d0, { 0xa5,0x0c,0x00,0xa0,0xc9,0x06,0x29,0x10 } }

#if ! (defined(MIDL_PASS))
DEFINE_GUID(MSWmi_GuidRegistrationInfo_GUID, \
            0xb48d49a1,0xe777,0x11d0,0xa5,0x0c,0x00,0xa0,0xc9,0x06,0x29,0x10);
#endif


typedef struct _MSWmi_GuidRegistrationInfo
{
    // 
    ULONG Operation;
    #define MSWmi_GuidRegistrationInfo_Operation_SIZE sizeof(ULONG)
    #define MSWmi_GuidRegistrationInfo_Operation_ID 1

    // 
    ULONG GuidCount;
    #define MSWmi_GuidRegistrationInfo_GuidCount_SIZE sizeof(ULONG)
    #define MSWmi_GuidRegistrationInfo_GuidCount_ID 2

    // 
    MSWmi_Guid GuidList[1];
    #define MSWmi_GuidRegistrationInfo_GuidList_ID 3

} MSWmi_GuidRegistrationInfo, *PMSWmi_GuidRegistrationInfo;

// MSAcpiInfo - MSAcpiInfo
#define MSAcpiInfoGuid \
    { 0x5daf38ae,0xf6f8,0x4d90, { 0x81,0x99,0xeb,0xde,0x68,0x00,0xec,0x3b } }

#if ! (defined(MIDL_PASS))
DEFINE_GUID(MSAcpiInfo_GUID, \
            0x5daf38ae,0xf6f8,0x4d90,0x81,0x99,0xeb,0xde,0x68,0x00,0xec,0x3b);
#endif


typedef struct _MSAcpiInfo
{
    // 
    ULONG BootArchitecture;
    #define MSAcpiInfo_BootArchitecture_SIZE sizeof(ULONG)
    #define MSAcpiInfo_BootArchitecture_ID 1

    // 
    ULONG PreferredProfile;
    #define MSAcpiInfo_PreferredProfile_SIZE sizeof(ULONG)
    #define MSAcpiInfo_PreferredProfile_ID 2

    // 
    ULONG Capabilities;
    #define MSAcpiInfo_Capabilities_SIZE sizeof(ULONG)
    #define MSAcpiInfo_Capabilities_ID 3

} MSAcpiInfo, *PMSAcpiInfo;

#define MSAcpiInfo_SIZE (FIELD_OFFSET(MSAcpiInfo, Capabilities) + MSAcpiInfo_Capabilities_SIZE)

// WHEAErrorInjectionMethods - WHEAErrorInjectionMethods
#define WHEAErrorInjectionMethodsGuid \
    { 0xe808ff73,0x2093,0x472a, { 0xa5,0xcc,0xdf,0x24,0xf0,0x31,0xb0,0x35 } }

#if ! (defined(MIDL_PASS))
DEFINE_GUID(WHEAErrorInjectionMethods_GUID, \
            0xe808ff73,0x2093,0x472a,0xa5,0xcc,0xdf,0x24,0xf0,0x31,0xb0,0x35);
#endif

//
// Method id definitions for WHEAErrorInjectionMethods
#define GetErrorInjectionCapabilitiesRtn     1
typedef struct _GET_INJECTION_CAPABILITIES_OUT
{
    // 
    ULONG Status;
    #define GET_INJECTION_CAPABILITIES_OUT_Status_SIZE sizeof(ULONG)
    #define GET_INJECTION_CAPABILITIES_OUT_Status_ID 1

    // 
    ULONG Capabilities;
    #define GET_INJECTION_CAPABILITIES_OUT_Capabilities_SIZE sizeof(ULONG)
    #define GET_INJECTION_CAPABILITIES_OUT_Capabilities_ID 2

} GET_INJECTION_CAPABILITIES_OUT, *PGET_INJECTION_CAPABILITIES_OUT;

#define GET_INJECTION_CAPABILITIES_OUT_SIZE (FIELD_OFFSET(GET_INJECTION_CAPABILITIES_OUT, Capabilities) + GET_INJECTION_CAPABILITIES_OUT_Capabilities_SIZE)

#define InjectErrorRtn     2
typedef struct _INJECT_HARDWARE_ERROR_IN
{
    // 
    ULONG ErrorType;
    #define INJECT_HARDWARE_ERROR_IN_ErrorType_SIZE sizeof(ULONG)
    #define INJECT_HARDWARE_ERROR_IN_ErrorType_ID 1

    // 
    ULONGLONG Parameter1;
    #define INJECT_HARDWARE_ERROR_IN_Parameter1_SIZE sizeof(ULONGLONG)
    #define INJECT_HARDWARE_ERROR_IN_Parameter1_ID 2

    // 
    ULONGLONG Parameter2;
    #define INJECT_HARDWARE_ERROR_IN_Parameter2_SIZE sizeof(ULONGLONG)
    #define INJECT_HARDWARE_ERROR_IN_Parameter2_ID 3

    // 
    ULONGLONG Parameter3;
    #define INJECT_HARDWARE_ERROR_IN_Parameter3_SIZE sizeof(ULONGLONG)
    #define INJECT_HARDWARE_ERROR_IN_Parameter3_ID 4

    // 
    ULONGLONG Parameter4;
    #define INJECT_HARDWARE_ERROR_IN_Parameter4_SIZE sizeof(ULONGLONG)
    #define INJECT_HARDWARE_ERROR_IN_Parameter4_ID 5

} INJECT_HARDWARE_ERROR_IN, *PINJECT_HARDWARE_ERROR_IN;

#define INJECT_HARDWARE_ERROR_IN_SIZE (FIELD_OFFSET(INJECT_HARDWARE_ERROR_IN, Parameter4) + INJECT_HARDWARE_ERROR_IN_Parameter4_SIZE)

typedef struct _INJECT_HARDWARE_ERROR_OUT
{
    // 
    ULONG Status;
    #define INJECT_HARDWARE_ERROR_OUT_Status_SIZE sizeof(ULONG)
    #define INJECT_HARDWARE_ERROR_OUT_Status_ID 6

} INJECT_HARDWARE_ERROR_OUT, *PINJECT_HARDWARE_ERROR_OUT;

#define INJECT_HARDWARE_ERROR_OUT_SIZE (FIELD_OFFSET(INJECT_HARDWARE_ERROR_OUT, Status) + INJECT_HARDWARE_ERROR_OUT_Status_SIZE)


// WHEAErrorSourceMethods - WHEAErrorSourceMethods
#define WHEAErrorSourceMethodsGuid \
    { 0x91c3c007,0x185d,0x4d78, { 0xa7,0x51,0xbf,0xcb,0x31,0xc2,0xc6,0x4d } }

#if ! (defined(MIDL_PASS))
DEFINE_GUID(WHEAErrorSourceMethods_GUID, \
            0x91c3c007,0x185d,0x4d78,0xa7,0x51,0xbf,0xcb,0x31,0xc2,0xc6,0x4d);
#endif

//
// Method id definitions for WHEAErrorSourceMethods
#define GetAllErrorSourcesRtn     1
typedef struct _GET_ALL_ERROR_SOURCES_OUT
{
    // 
    ULONG Status;
    #define GET_ALL_ERROR_SOURCES_OUT_Status_SIZE sizeof(ULONG)
    #define GET_ALL_ERROR_SOURCES_OUT_Status_ID 1

    // 
    ULONG Count;
    #define GET_ALL_ERROR_SOURCES_OUT_Count_SIZE sizeof(ULONG)
    #define GET_ALL_ERROR_SOURCES_OUT_Count_ID 2

    // 
    ULONG Length;
    #define GET_ALL_ERROR_SOURCES_OUT_Length_SIZE sizeof(ULONG)
    #define GET_ALL_ERROR_SOURCES_OUT_Length_ID 3

    // 
    UCHAR ErrorSourceArray[1];
    #define GET_ALL_ERROR_SOURCES_OUT_ErrorSourceArray_ID 4

} GET_ALL_ERROR_SOURCES_OUT, *PGET_ALL_ERROR_SOURCES_OUT;

#define GetErrorSourceInfoRtn     2
typedef struct _GET_ERROR_SOURCE_INFO_IN
{
    // 
    ULONG ErrorSourceId;
    #define GET_ERROR_SOURCE_INFO_IN_ErrorSourceId_SIZE sizeof(ULONG)
    #define GET_ERROR_SOURCE_INFO_IN_ErrorSourceId_ID 2

} GET_ERROR_SOURCE_INFO_IN, *PGET_ERROR_SOURCE_INFO_IN;

#define GET_ERROR_SOURCE_INFO_IN_SIZE (FIELD_OFFSET(GET_ERROR_SOURCE_INFO_IN, ErrorSourceId) + GET_ERROR_SOURCE_INFO_IN_ErrorSourceId_SIZE)

typedef struct _GET_ERROR_SOURCE_INFO_OUT
{
    // 
    ULONG Status;
    #define GET_ERROR_SOURCE_INFO_OUT_Status_SIZE sizeof(ULONG)
    #define GET_ERROR_SOURCE_INFO_OUT_Status_ID 1

    // 
    ULONG Length;
    #define GET_ERROR_SOURCE_INFO_OUT_Length_SIZE sizeof(ULONG)
    #define GET_ERROR_SOURCE_INFO_OUT_Length_ID 3

    // 
    UCHAR ErrorSourceInfo[1];
    #define GET_ERROR_SOURCE_INFO_OUT_ErrorSourceInfo_ID 4

} GET_ERROR_SOURCE_INFO_OUT, *PGET_ERROR_SOURCE_INFO_OUT;

#define SetErrorSourceInfoRtn     3
typedef struct _SET_ERROR_SOURCE_INFO_IN
{
    // 
    ULONG Length;
    #define SET_ERROR_SOURCE_INFO_IN_Length_SIZE sizeof(ULONG)
    #define SET_ERROR_SOURCE_INFO_IN_Length_ID 2

    // 
    UCHAR ErrorSourceInfo[1];
    #define SET_ERROR_SOURCE_INFO_IN_ErrorSourceInfo_ID 3

} SET_ERROR_SOURCE_INFO_IN, *PSET_ERROR_SOURCE_INFO_IN;

typedef struct _SET_ERROR_SOURCE_INFO_OUT
{
    // 
    ULONG Status;
    #define SET_ERROR_SOURCE_INFO_OUT_Status_SIZE sizeof(ULONG)
    #define SET_ERROR_SOURCE_INFO_OUT_Status_ID 1

} SET_ERROR_SOURCE_INFO_OUT, *PSET_ERROR_SOURCE_INFO_OUT;

#define SET_ERROR_SOURCE_INFO_OUT_SIZE (FIELD_OFFSET(SET_ERROR_SOURCE_INFO_OUT, Status) + SET_ERROR_SOURCE_INFO_OUT_Status_SIZE)

#define EnableErrorSourceRtn     4
typedef struct _ENABLE_ERROR_SOURCE_IN
{
    // 
    ULONG ErrorSourceId;
    #define ENABLE_ERROR_SOURCE_IN_ErrorSourceId_SIZE sizeof(ULONG)
    #define ENABLE_ERROR_SOURCE_IN_ErrorSourceId_ID 2

} ENABLE_ERROR_SOURCE_IN, *PENABLE_ERROR_SOURCE_IN;

#define ENABLE_ERROR_SOURCE_IN_SIZE (FIELD_OFFSET(ENABLE_ERROR_SOURCE_IN, ErrorSourceId) + ENABLE_ERROR_SOURCE_IN_ErrorSourceId_SIZE)

typedef struct _ENABLE_ERROR_SOURCE_OUT
{
    // 
    ULONG Status;
    #define ENABLE_ERROR_SOURCE_OUT_Status_SIZE sizeof(ULONG)
    #define ENABLE_ERROR_SOURCE_OUT_Status_ID 1

} ENABLE_ERROR_SOURCE_OUT, *PENABLE_ERROR_SOURCE_OUT;

#define ENABLE_ERROR_SOURCE_OUT_SIZE (FIELD_OFFSET(ENABLE_ERROR_SOURCE_OUT, Status) + ENABLE_ERROR_SOURCE_OUT_Status_SIZE)

#define DisableErrorSourceRtn     5
typedef struct _DISABLE_ERROR_SOURCE_IN
{
    // 
    ULONG ErrorSourceId;
    #define DISABLE_ERROR_SOURCE_IN_ErrorSourceId_SIZE sizeof(ULONG)
    #define DISABLE_ERROR_SOURCE_IN_ErrorSourceId_ID 2

} DISABLE_ERROR_SOURCE_IN, *PDISABLE_ERROR_SOURCE_IN;

#define DISABLE_ERROR_SOURCE_IN_SIZE (FIELD_OFFSET(DISABLE_ERROR_SOURCE_IN, ErrorSourceId) + DISABLE_ERROR_SOURCE_IN_ErrorSourceId_SIZE)

typedef struct _DISABLE_ERROR_SOURCE_OUT
{
    // 
    ULONG Status;
    #define DISABLE_ERROR_SOURCE_OUT_Status_SIZE sizeof(ULONG)
    #define DISABLE_ERROR_SOURCE_OUT_Status_ID 1

} DISABLE_ERROR_SOURCE_OUT, *PDISABLE_ERROR_SOURCE_OUT;

#define DISABLE_ERROR_SOURCE_OUT_SIZE (FIELD_OFFSET(DISABLE_ERROR_SOURCE_OUT, Status) + DISABLE_ERROR_SOURCE_OUT_Status_SIZE)


// MSSmBios_RawSMBiosTables - MSSmBios_RawSMBiosTables
#define MSSmBios_RawSMBiosTablesGuid \
    { 0x8f680850,0xa584,0x11d1, { 0xbf,0x38,0x00,0xa0,0xc9,0x06,0x29,0x10 } }

#if ! (defined(MIDL_PASS))
DEFINE_GUID(MSSmBios_RawSMBiosTables_GUID, \
            0x8f680850,0xa584,0x11d1,0xbf,0x38,0x00,0xa0,0xc9,0x06,0x29,0x10);
#endif


typedef struct _MSSmBios_RawSMBiosTables
{
    // 
    BOOLEAN Used20CallingMethod;
    #define MSSmBios_RawSMBiosTables_Used20CallingMethod_SIZE sizeof(BOOLEAN)
    #define MSSmBios_RawSMBiosTables_Used20CallingMethod_ID 1

    // 
    UCHAR SmbiosMajorVersion;
    #define MSSmBios_RawSMBiosTables_SmbiosMajorVersion_SIZE sizeof(UCHAR)
    #define MSSmBios_RawSMBiosTables_SmbiosMajorVersion_ID 2

    // 
    UCHAR SmbiosMinorVersion;
    #define MSSmBios_RawSMBiosTables_SmbiosMinorVersion_SIZE sizeof(UCHAR)
    #define MSSmBios_RawSMBiosTables_SmbiosMinorVersion_ID 3

    // 
    UCHAR DmiRevision;
    #define MSSmBios_RawSMBiosTables_DmiRevision_SIZE sizeof(UCHAR)
    #define MSSmBios_RawSMBiosTables_DmiRevision_ID 4

    // 
    ULONG Size;
    #define MSSmBios_RawSMBiosTables_Size_SIZE sizeof(ULONG)
    #define MSSmBios_RawSMBiosTables_Size_ID 5

    // 
    UCHAR SMBiosData[1];
    #define MSSmBios_RawSMBiosTables_SMBiosData_ID 6

} MSSmBios_RawSMBiosTables, *PMSSmBios_RawSMBiosTables;

// MSSmBios_SMBiosEventlog - MSSmBios_SMBiosEventlog
#define MSSmBios_SMBiosEventlogGuid \
    { 0x8f680851,0xa584,0x11d1, { 0xbf,0x38,0x00,0xa0,0xc9,0x06,0x29,0x10 } }

#if ! (defined(MIDL_PASS))
DEFINE_GUID(MSSmBios_SMBiosEventlog_GUID, \
            0x8f680851,0xa584,0x11d1,0xbf,0x38,0x00,0xa0,0xc9,0x06,0x29,0x10);
#endif


// Warning: Header for class MSSmBios_SMBiosEventlog cannot be created
typedef struct _MSSmBios_SMBiosEventlog
{
    char VariableData[1];

} MSSmBios_SMBiosEventlog, *PMSSmBios_SMBiosEventlog;

// MSSmBios_SysidUUID - SYSID_UUID
#define MSSmBios_SysidUUIDGuid \
    { 0x8f680852,0xa584,0x11d1, { 0xbf,0x38,0x00,0xa0,0xc9,0x06,0x29,0x10 } }

#if ! (defined(MIDL_PASS))
DEFINE_GUID(MSSmBios_SysidUUID_GUID, \
            0x8f680852,0xa584,0x11d1,0xbf,0x38,0x00,0xa0,0xc9,0x06,0x29,0x10);
#endif


typedef struct _SYSID_UUID
{
    // 
    UCHAR Uuid[16];
    #define SYSID_UUID_Uuid_SIZE sizeof(UCHAR[16])
    #define SYSID_UUID_Uuid_ID 1

} SYSID_UUID, *PSYSID_UUID;

#define SYSID_UUID_SIZE (FIELD_OFFSET(SYSID_UUID, Uuid) + SYSID_UUID_Uuid_SIZE)

// MSSmBios_SysidUUIDList - MSSmBios_SysidUUIDList
#define SYSID_UUID_DATA_GUID \
    { 0x8f680853,0xa584,0x11d1, { 0xbf,0x38,0x00,0xa0,0xc9,0x06,0x29,0x10 } }

#if ! (defined(MIDL_PASS))
DEFINE_GUID(MSSmBios_SysidUUIDList_GUID, \
            0x8f680853,0xa584,0x11d1,0xbf,0x38,0x00,0xa0,0xc9,0x06,0x29,0x10);
#endif


typedef struct _MSSmBios_SysidUUIDList
{
    // 
    ULONG Count;
    #define MSSmBios_SysidUUIDList_Count_SIZE sizeof(ULONG)
    #define MSSmBios_SysidUUIDList_Count_ID 1

    // 
    SYSID_UUID List[1];
    #define MSSmBios_SysidUUIDList_List_ID 2

} MSSmBios_SysidUUIDList, *PMSSmBios_SysidUUIDList;

// MSSmBios_Sysid1394 - SYSID_1394
#define MSSmBios_Sysid1394Guid \
    { 0x8f680854,0xa584,0x11d1, { 0xbf,0x38,0x00,0xa0,0xc9,0x06,0x29,0x10 } }

#if ! (defined(MIDL_PASS))
DEFINE_GUID(MSSmBios_Sysid1394_GUID, \
            0x8f680854,0xa584,0x11d1,0xbf,0x38,0x00,0xa0,0xc9,0x06,0x29,0x10);
#endif


typedef struct _SYSID_1394
{
    // 
    UCHAR x1394[8];
    #define SYSID_1394_x1394_SIZE sizeof(UCHAR[8])
    #define SYSID_1394_x1394_ID 1

} SYSID_1394, *PSYSID_1394;

#define SYSID_1394_SIZE (FIELD_OFFSET(SYSID_1394, x1394) + SYSID_1394_x1394_SIZE)

// MSSmBios_Sysid1394List - MSSmBios_Sysid1394List
#define SYSID_1394_DATA_GUID \
    { 0x8f680855,0xa584,0x11d1, { 0xbf,0x38,0x00,0xa0,0xc9,0x06,0x29,0x10 } }

#if ! (defined(MIDL_PASS))
DEFINE_GUID(MSSmBios_Sysid1394List_GUID, \
            0x8f680855,0xa584,0x11d1,0xbf,0x38,0x00,0xa0,0xc9,0x06,0x29,0x10);
#endif


typedef struct _MSSmBios_Sysid1394List
{
    // 
    ULONG Count;
    #define MSSmBios_Sysid1394List_Count_SIZE sizeof(ULONG)
    #define MSSmBios_Sysid1394List_Count_ID 1

    // 
    SYSID_1394 List[1];
    #define MSSmBios_Sysid1394List_List_ID 2

} MSSmBios_Sysid1394List, *PMSSmBios_Sysid1394List;

// MSMCAEvent_SwitchToCMCPolling - MSMCAEvent_SwitchToCMCPolling
#define MSMCAEvent_SwitchToCMCPollingGuid \
    { 0x39c14290,0xf036,0x4999, { 0xb8,0xa1,0xb6,0xf8,0x71,0xfb,0x32,0x9e } }

#if ! (defined(MIDL_PASS))
DEFINE_GUID(MSMCAEvent_SwitchToCMCPolling_GUID, \
            0x39c14290,0xf036,0x4999,0xb8,0xa1,0xb6,0xf8,0x71,0xfb,0x32,0x9e);
#endif


// MSMCAEvent_SwitchToCPEPolling - MSMCAEvent_SwitchToCPEPolling
#define MSMCAEvent_SwitchToCPEPollingGuid \
    { 0xd5c870ce,0x4ed0,0x4fdc, { 0xbb,0x54,0x8b,0x45,0x2c,0x18,0x79,0x7e } }

#if ! (defined(MIDL_PASS))
DEFINE_GUID(MSMCAEvent_SwitchToCPEPolling_GUID, \
            0xd5c870ce,0x4ed0,0x4fdc,0xbb,0x54,0x8b,0x45,0x2c,0x18,0x79,0x7e);
#endif


// MSMCAEvent_Header - MSMCAEvent_Header
#define MSMCAEvent_HeaderGuid \
    { 0x6381c27f,0xc8fa,0x4da7, { 0x89,0x53,0xb8,0x68,0x33,0x73,0x6e,0x15 } }

#if ! (defined(MIDL_PASS))
DEFINE_GUID(MSMCAEvent_Header_GUID, \
            0x6381c27f,0xc8fa,0x4da7,0x89,0x53,0xb8,0x68,0x33,0x73,0x6e,0x15);
#endif


typedef struct _MSMCAEvent_Header
{
    // 
    ULONGLONG RecordId;
    #define MSMCAEvent_Header_RecordId_SIZE sizeof(ULONGLONG)
    #define MSMCAEvent_Header_RecordId_ID 1

    // 
    UCHAR ErrorSeverity;
    #define MSMCAEvent_Header_ErrorSeverity_SIZE sizeof(UCHAR)
    #define MSMCAEvent_Header_ErrorSeverity_ID 2

    // 
    ULONG Type;
    #define MSMCAEvent_Header_Type_SIZE sizeof(ULONG)
    #define MSMCAEvent_Header_Type_ID 3

    // 
    ULONG Cpu;
    #define MSMCAEvent_Header_Cpu_SIZE sizeof(ULONG)
    #define MSMCAEvent_Header_Cpu_ID 4

    // 
    ULONG AdditionalErrors;
    #define MSMCAEvent_Header_AdditionalErrors_SIZE sizeof(ULONG)
    #define MSMCAEvent_Header_AdditionalErrors_ID 5

    // 
    ULONG LogToEventlog;
    #define MSMCAEvent_Header_LogToEventlog_SIZE sizeof(ULONG)
    #define MSMCAEvent_Header_LogToEventlog_ID 6

} MSMCAEvent_Header, *PMSMCAEvent_Header;

#define MSMCAEvent_Header_SIZE (FIELD_OFFSET(MSMCAEvent_Header, LogToEventlog) + MSMCAEvent_Header_LogToEventlog_SIZE)

// MSMCAEvent_BusError - MSMCAEvent_BusError
#define MSMCAEvent_BusErrorGuid \
    { 0x1ee17050,0x0039,0x40f7, { 0x9e,0xad,0x14,0xad,0x51,0x61,0x2c,0xb2 } }

#if ! (defined(MIDL_PASS))
DEFINE_GUID(MSMCAEvent_BusError_GUID, \
            0x1ee17050,0x0039,0x40f7,0x9e,0xad,0x14,0xad,0x51,0x61,0x2c,0xb2);
#endif


typedef struct _MSMCAEvent_BusError
{
    // 
    ULONGLONG RecordId;
    #define MSMCAEvent_BusError_RecordId_SIZE sizeof(ULONGLONG)
    #define MSMCAEvent_BusError_RecordId_ID 1

    // 
    UCHAR ErrorSeverity;
    #define MSMCAEvent_BusError_ErrorSeverity_SIZE sizeof(UCHAR)
    #define MSMCAEvent_BusError_ErrorSeverity_ID 2

    // 
    ULONG Type;
    #define MSMCAEvent_BusError_Type_SIZE sizeof(ULONG)
    #define MSMCAEvent_BusError_Type_ID 3

    // 
    ULONG Cpu;
    #define MSMCAEvent_BusError_Cpu_SIZE sizeof(ULONG)
    #define MSMCAEvent_BusError_Cpu_ID 4

    // 
    ULONG AdditionalErrors;
    #define MSMCAEvent_BusError_AdditionalErrors_SIZE sizeof(ULONG)
    #define MSMCAEvent_BusError_AdditionalErrors_ID 5

    // 
    ULONG LogToEventlog;
    #define MSMCAEvent_BusError_LogToEventlog_SIZE sizeof(ULONG)
    #define MSMCAEvent_BusError_LogToEventlog_ID 6

    // 
    ULONG Participation;
    #define MSMCAEvent_BusError_Participation_SIZE sizeof(ULONG)
    #define MSMCAEvent_BusError_Participation_ID 7

    // 
    ULONG MemoryHierarchyLevel;
    #define MSMCAEvent_BusError_MemoryHierarchyLevel_SIZE sizeof(ULONG)
    #define MSMCAEvent_BusError_MemoryHierarchyLevel_ID 8

    // 
    ULONG RequestType;
    #define MSMCAEvent_BusError_RequestType_SIZE sizeof(ULONG)
    #define MSMCAEvent_BusError_RequestType_ID 9

    // 
    ULONG MemOrIo;
    #define MSMCAEvent_BusError_MemOrIo_SIZE sizeof(ULONG)
    #define MSMCAEvent_BusError_MemOrIo_ID 10

    // The address at which the error occurred.
    ULONGLONG Address;
    #define MSMCAEvent_BusError_Address_SIZE sizeof(ULONGLONG)
    #define MSMCAEvent_BusError_Address_ID 11

    // 
    ULONG Size;
    #define MSMCAEvent_BusError_Size_SIZE sizeof(ULONG)
    #define MSMCAEvent_BusError_Size_ID 12

    // 
    UCHAR RawRecord[1];
    #define MSMCAEvent_BusError_RawRecord_ID 13

} MSMCAEvent_BusError, *PMSMCAEvent_BusError;

// MSMCAEvent_TLBError - MSMCAEvent_TLBError
#define MSMCAEvent_TLBErrorGuid \
    { 0xb161eeab,0xac03,0x4c2b, { 0xae,0x7a,0x5a,0x37,0x68,0xf7,0x0e,0x85 } }

#if ! (defined(MIDL_PASS))
DEFINE_GUID(MSMCAEvent_TLBError_GUID, \
            0xb161eeab,0xac03,0x4c2b,0xae,0x7a,0x5a,0x37,0x68,0xf7,0x0e,0x85);
#endif


typedef struct _MSMCAEvent_TLBError
{
    // 
    ULONGLONG RecordId;
    #define MSMCAEvent_TLBError_RecordId_SIZE sizeof(ULONGLONG)
    #define MSMCAEvent_TLBError_RecordId_ID 1

    // 
    UCHAR ErrorSeverity;
    #define MSMCAEvent_TLBError_ErrorSeverity_SIZE sizeof(UCHAR)
    #define MSMCAEvent_TLBError_ErrorSeverity_ID 2

    // 
    ULONG Type;
    #define MSMCAEvent_TLBError_Type_SIZE sizeof(ULONG)
    #define MSMCAEvent_TLBError_Type_ID 3

    // 
    ULONG Cpu;
    #define MSMCAEvent_TLBError_Cpu_SIZE sizeof(ULONG)
    #define MSMCAEvent_TLBError_Cpu_ID 4

    // 
    ULONG AdditionalErrors;
    #define MSMCAEvent_TLBError_AdditionalErrors_SIZE sizeof(ULONG)
    #define MSMCAEvent_TLBError_AdditionalErrors_ID 5

    // 
    ULONG LogToEventlog;
    #define MSMCAEvent_TLBError_LogToEventlog_SIZE sizeof(ULONG)
    #define MSMCAEvent_TLBError_LogToEventlog_ID 6

    // 
    ULONG TransactionType;
    #define MSMCAEvent_TLBError_TransactionType_SIZE sizeof(ULONG)
    #define MSMCAEvent_TLBError_TransactionType_ID 7

    // 
    ULONG MemoryHierarchyLevel;
    #define MSMCAEvent_TLBError_MemoryHierarchyLevel_SIZE sizeof(ULONG)
    #define MSMCAEvent_TLBError_MemoryHierarchyLevel_ID 8

    // The address at which the error occurred.
    ULONGLONG Address;
    #define MSMCAEvent_TLBError_Address_SIZE sizeof(ULONGLONG)
    #define MSMCAEvent_TLBError_Address_ID 9

    // 
    ULONG Size;
    #define MSMCAEvent_TLBError_Size_SIZE sizeof(ULONG)
    #define MSMCAEvent_TLBError_Size_ID 10

    // 
    UCHAR RawRecord[1];
    #define MSMCAEvent_TLBError_RawRecord_ID 11

} MSMCAEvent_TLBError, *PMSMCAEvent_TLBError;

// MSMCAEvent_MemoryHierarchyError - MSMCAEvent_MemoryHierarchyError
#define MSMCAEvent_MemoryHierarchyErrorGuid \
    { 0xcede75a0,0xa77f,0x452b, { 0x8f,0x2f,0x54,0x1f,0x92,0x6d,0xb0,0xf9 } }

#if ! (defined(MIDL_PASS))
DEFINE_GUID(MSMCAEvent_MemoryHierarchyError_GUID, \
            0xcede75a0,0xa77f,0x452b,0x8f,0x2f,0x54,0x1f,0x92,0x6d,0xb0,0xf9);
#endif


typedef struct _MSMCAEvent_MemoryHierarchyError
{
    // 
    ULONGLONG RecordId;
    #define MSMCAEvent_MemoryHierarchyError_RecordId_SIZE sizeof(ULONGLONG)
    #define MSMCAEvent_MemoryHierarchyError_RecordId_ID 1

    // 
    UCHAR ErrorSeverity;
    #define MSMCAEvent_MemoryHierarchyError_ErrorSeverity_SIZE sizeof(UCHAR)
    #define MSMCAEvent_MemoryHierarchyError_ErrorSeverity_ID 2

    // 
    ULONG Type;
    #define MSMCAEvent_MemoryHierarchyError_Type_SIZE sizeof(ULONG)
    #define MSMCAEvent_MemoryHierarchyError_Type_ID 3

    // 
    ULONG Cpu;
    #define MSMCAEvent_MemoryHierarchyError_Cpu_SIZE sizeof(ULONG)
    #define MSMCAEvent_MemoryHierarchyError_Cpu_ID 4

    // 
    ULONG AdditionalErrors;
    #define MSMCAEvent_MemoryHierarchyError_AdditionalErrors_SIZE sizeof(ULONG)
    #define MSMCAEvent_MemoryHierarchyError_AdditionalErrors_ID 5

    // 
    ULONG LogToEventlog;
    #define MSMCAEvent_MemoryHierarchyError_LogToEventlog_SIZE sizeof(ULONG)
    #define MSMCAEvent_MemoryHierarchyError_LogToEventlog_ID 6

    // 
    ULONG TransactionType;
    #define MSMCAEvent_MemoryHierarchyError_TransactionType_SIZE sizeof(ULONG)
    #define MSMCAEvent_MemoryHierarchyError_TransactionType_ID 7

    // 
    ULONG MemoryHierarchyLevel;
    #define MSMCAEvent_MemoryHierarchyError_MemoryHierarchyLevel_SIZE sizeof(ULONG)
    #define MSMCAEvent_MemoryHierarchyError_MemoryHierarchyLevel_ID 8

    // 
    ULONG RequestType;
    #define MSMCAEvent_MemoryHierarchyError_RequestType_SIZE sizeof(ULONG)
    #define MSMCAEvent_MemoryHierarchyError_RequestType_ID 9

    // The address at which the error occurred.
    ULONGLONG Address;
    #define MSMCAEvent_MemoryHierarchyError_Address_SIZE sizeof(ULONGLONG)
    #define MSMCAEvent_MemoryHierarchyError_Address_ID 10

    // 
    ULONG Size;
    #define MSMCAEvent_MemoryHierarchyError_Size_SIZE sizeof(ULONG)
    #define MSMCAEvent_MemoryHierarchyError_Size_ID 11

    // 
    UCHAR RawRecord[1];
    #define MSMCAEvent_MemoryHierarchyError_RawRecord_ID 12

} MSMCAEvent_MemoryHierarchyError, *PMSMCAEvent_MemoryHierarchyError;

// MSMCAEvent_CPUError - MSMCAEvent_CPUError
#define MSMCAEvent_CPUErrorGuid \
    { 0x5ce27cde,0xd179,0x4c68, { 0x93,0x7f,0xa0,0x7b,0x8c,0xc2,0xea,0x39 } }

#if ! (defined(MIDL_PASS))
DEFINE_GUID(MSMCAEvent_CPUError_GUID, \
            0x5ce27cde,0xd179,0x4c68,0x93,0x7f,0xa0,0x7b,0x8c,0xc2,0xea,0x39);
#endif


typedef struct _MSMCAEvent_CPUError
{
    // 
    ULONGLONG RecordId;
    #define MSMCAEvent_CPUError_RecordId_SIZE sizeof(ULONGLONG)
    #define MSMCAEvent_CPUError_RecordId_ID 1

    // 
    UCHAR ErrorSeverity;
    #define MSMCAEvent_CPUError_ErrorSeverity_SIZE sizeof(UCHAR)
    #define MSMCAEvent_CPUError_ErrorSeverity_ID 2

    // 
    ULONG Type;
    #define MSMCAEvent_CPUError_Type_SIZE sizeof(ULONG)
    #define MSMCAEvent_CPUError_Type_ID 3

    // 
    ULONG Cpu;
    #define MSMCAEvent_CPUError_Cpu_SIZE sizeof(ULONG)
    #define MSMCAEvent_CPUError_Cpu_ID 4

    // 
    ULONG AdditionalErrors;
    #define MSMCAEvent_CPUError_AdditionalErrors_SIZE sizeof(ULONG)
    #define MSMCAEvent_CPUError_AdditionalErrors_ID 5

    // 
    ULONG LogToEventlog;
    #define MSMCAEvent_CPUError_LogToEventlog_SIZE sizeof(ULONG)
    #define MSMCAEvent_CPUError_LogToEventlog_ID 6


// Cache
#define MCACpuCacheError 0
// TLB
#define MCACpuTlbError 1
// Bus
#define MCACpuBusError 2
// Register File
#define MCACpuRegFileError 3
// Microarchitecture
#define MCACpuMSError 4

    // 
    ULONG MajorErrorType;
    #define MSMCAEvent_CPUError_MajorErrorType_SIZE sizeof(ULONG)
    #define MSMCAEvent_CPUError_MajorErrorType_ID 7

    // 
    ULONG Level;
    #define MSMCAEvent_CPUError_Level_SIZE sizeof(ULONG)
    #define MSMCAEvent_CPUError_Level_ID 8

    // 
    ULONG CacheOp;
    #define MSMCAEvent_CPUError_CacheOp_SIZE sizeof(ULONG)
    #define MSMCAEvent_CPUError_CacheOp_ID 9

    // 
    ULONG CacheMesi;
    #define MSMCAEvent_CPUError_CacheMesi_SIZE sizeof(ULONG)
    #define MSMCAEvent_CPUError_CacheMesi_ID 10

    // 
    ULONG TLBOp;
    #define MSMCAEvent_CPUError_TLBOp_SIZE sizeof(ULONG)
    #define MSMCAEvent_CPUError_TLBOp_ID 11

    // 
    ULONG BusType;
    #define MSMCAEvent_CPUError_BusType_SIZE sizeof(ULONG)
    #define MSMCAEvent_CPUError_BusType_ID 12

    // 
    ULONG BusSev;
    #define MSMCAEvent_CPUError_BusSev_SIZE sizeof(ULONG)
    #define MSMCAEvent_CPUError_BusSev_ID 13

    // 
    ULONG RegFileId;
    #define MSMCAEvent_CPUError_RegFileId_SIZE sizeof(ULONG)
    #define MSMCAEvent_CPUError_RegFileId_ID 14

    // 
    ULONG RegFileOp;
    #define MSMCAEvent_CPUError_RegFileOp_SIZE sizeof(ULONG)
    #define MSMCAEvent_CPUError_RegFileOp_ID 15

    // 
    ULONG MSSid;
    #define MSMCAEvent_CPUError_MSSid_SIZE sizeof(ULONG)
    #define MSMCAEvent_CPUError_MSSid_ID 16

    // 
    ULONG MSOp;
    #define MSMCAEvent_CPUError_MSOp_SIZE sizeof(ULONG)
    #define MSMCAEvent_CPUError_MSOp_ID 17

    // 
    ULONG MSArrayId;
    #define MSMCAEvent_CPUError_MSArrayId_SIZE sizeof(ULONG)
    #define MSMCAEvent_CPUError_MSArrayId_ID 18

    // 
    ULONG MSIndex;
    #define MSMCAEvent_CPUError_MSIndex_SIZE sizeof(ULONG)
    #define MSMCAEvent_CPUError_MSIndex_ID 19

    // 
    ULONG Size;
    #define MSMCAEvent_CPUError_Size_SIZE sizeof(ULONG)
    #define MSMCAEvent_CPUError_Size_ID 20

    // 
    UCHAR RawRecord[1];
    #define MSMCAEvent_CPUError_RawRecord_ID 21

} MSMCAEvent_CPUError, *PMSMCAEvent_CPUError;

// MSMCAEvent_MemoryError - MSMCAEvent_MemoryError
#define MSMCAEvent_MemoryErrorGuid \
    { 0x433eea38,0xc1a7,0x48f1, { 0x88,0x4f,0xb6,0x87,0x5f,0x17,0x6c,0xc7 } }

#if ! (defined(MIDL_PASS))
DEFINE_GUID(MSMCAEvent_MemoryError_GUID, \
            0x433eea38,0xc1a7,0x48f1,0x88,0x4f,0xb6,0x87,0x5f,0x17,0x6c,0xc7);
#endif


typedef struct _MSMCAEvent_MemoryError
{
    // 
    ULONGLONG RecordId;
    #define MSMCAEvent_MemoryError_RecordId_SIZE sizeof(ULONGLONG)
    #define MSMCAEvent_MemoryError_RecordId_ID 1

    // 
    UCHAR ErrorSeverity;
    #define MSMCAEvent_MemoryError_ErrorSeverity_SIZE sizeof(UCHAR)
    #define MSMCAEvent_MemoryError_ErrorSeverity_ID 2

    // 
    ULONG Type;
    #define MSMCAEvent_MemoryError_Type_SIZE sizeof(ULONG)
    #define MSMCAEvent_MemoryError_Type_ID 3

    // 
    ULONG Cpu;
    #define MSMCAEvent_MemoryError_Cpu_SIZE sizeof(ULONG)
    #define MSMCAEvent_MemoryError_Cpu_ID 4

    // 
    ULONG AdditionalErrors;
    #define MSMCAEvent_MemoryError_AdditionalErrors_SIZE sizeof(ULONG)
    #define MSMCAEvent_MemoryError_AdditionalErrors_ID 5

    // 
    ULONG LogToEventlog;
    #define MSMCAEvent_MemoryError_LogToEventlog_SIZE sizeof(ULONG)
    #define MSMCAEvent_MemoryError_LogToEventlog_ID 6

    // 
    ULONGLONG VALIDATION_BITS;
    #define MSMCAEvent_MemoryError_VALIDATION_BITS_SIZE sizeof(ULONGLONG)
    #define MSMCAEvent_MemoryError_VALIDATION_BITS_ID 7

    // 
    ULONGLONG MEM_ERROR_STATUS;
    #define MSMCAEvent_MemoryError_MEM_ERROR_STATUS_SIZE sizeof(ULONGLONG)
    #define MSMCAEvent_MemoryError_MEM_ERROR_STATUS_ID 8

    // 
    ULONGLONG MEM_PHYSICAL_ADDR;
    #define MSMCAEvent_MemoryError_MEM_PHYSICAL_ADDR_SIZE sizeof(ULONGLONG)
    #define MSMCAEvent_MemoryError_MEM_PHYSICAL_ADDR_ID 9

    // 
    ULONGLONG MEM_PHYSICAL_MASK;
    #define MSMCAEvent_MemoryError_MEM_PHYSICAL_MASK_SIZE sizeof(ULONGLONG)
    #define MSMCAEvent_MemoryError_MEM_PHYSICAL_MASK_ID 10

    // 
    ULONGLONG RESPONDER_ID;
    #define MSMCAEvent_MemoryError_RESPONDER_ID_SIZE sizeof(ULONGLONG)
    #define MSMCAEvent_MemoryError_RESPONDER_ID_ID 11

    // 
    ULONGLONG TARGET_ID;
    #define MSMCAEvent_MemoryError_TARGET_ID_SIZE sizeof(ULONGLONG)
    #define MSMCAEvent_MemoryError_TARGET_ID_ID 12

    // 
    ULONGLONG REQUESTOR_ID;
    #define MSMCAEvent_MemoryError_REQUESTOR_ID_SIZE sizeof(ULONGLONG)
    #define MSMCAEvent_MemoryError_REQUESTOR_ID_ID 13

    // 
    ULONGLONG BUS_SPECIFIC_DATA;
    #define MSMCAEvent_MemoryError_BUS_SPECIFIC_DATA_SIZE sizeof(ULONGLONG)
    #define MSMCAEvent_MemoryError_BUS_SPECIFIC_DATA_ID 14

    // 
    USHORT MEM_NODE;
    #define MSMCAEvent_MemoryError_MEM_NODE_SIZE sizeof(USHORT)
    #define MSMCAEvent_MemoryError_MEM_NODE_ID 15

    // 
    USHORT MEM_CARD;
    #define MSMCAEvent_MemoryError_MEM_CARD_SIZE sizeof(USHORT)
    #define MSMCAEvent_MemoryError_MEM_CARD_ID 16

    // 
    USHORT MEM_BANK;
    #define MSMCAEvent_MemoryError_MEM_BANK_SIZE sizeof(USHORT)
    #define MSMCAEvent_MemoryError_MEM_BANK_ID 17

    // 
    USHORT xMEM_DEVICE;
    #define MSMCAEvent_MemoryError_xMEM_DEVICE_SIZE sizeof(USHORT)
    #define MSMCAEvent_MemoryError_xMEM_DEVICE_ID 18

    // 
    USHORT MEM_MODULE;
    #define MSMCAEvent_MemoryError_MEM_MODULE_SIZE sizeof(USHORT)
    #define MSMCAEvent_MemoryError_MEM_MODULE_ID 19

    // 
    USHORT MEM_ROW;
    #define MSMCAEvent_MemoryError_MEM_ROW_SIZE sizeof(USHORT)
    #define MSMCAEvent_MemoryError_MEM_ROW_ID 20

    // 
    USHORT MEM_COLUMN;
    #define MSMCAEvent_MemoryError_MEM_COLUMN_SIZE sizeof(USHORT)
    #define MSMCAEvent_MemoryError_MEM_COLUMN_ID 21

    // 
    USHORT MEM_BIT_POSITION;
    #define MSMCAEvent_MemoryError_MEM_BIT_POSITION_SIZE sizeof(USHORT)
    #define MSMCAEvent_MemoryError_MEM_BIT_POSITION_ID 22

    // 
    ULONG Size;
    #define MSMCAEvent_MemoryError_Size_SIZE sizeof(ULONG)
    #define MSMCAEvent_MemoryError_Size_ID 23

    // 
    UCHAR RawRecord[1];
    #define MSMCAEvent_MemoryError_RawRecord_ID 24

} MSMCAEvent_MemoryError, *PMSMCAEvent_MemoryError;

// MSMCAEvent_PCIBusError - MSMCAEvent_PCIBusError
#define MSMCAEvent_PCIBusErrorGuid \
    { 0xa14a5594,0x25de,0x410e, { 0x9b,0x92,0x80,0xf0,0x80,0x1a,0xec,0x07 } }

#if ! (defined(MIDL_PASS))
DEFINE_GUID(MSMCAEvent_PCIBusError_GUID, \
            0xa14a5594,0x25de,0x410e,0x9b,0x92,0x80,0xf0,0x80,0x1a,0xec,0x07);
#endif


typedef struct _MSMCAEvent_PCIBusError
{
    // 
    ULONGLONG RecordId;
    #define MSMCAEvent_PCIBusError_RecordId_SIZE sizeof(ULONGLONG)
    #define MSMCAEvent_PCIBusError_RecordId_ID 1

    // 
    UCHAR ErrorSeverity;
    #define MSMCAEvent_PCIBusError_ErrorSeverity_SIZE sizeof(UCHAR)
    #define MSMCAEvent_PCIBusError_ErrorSeverity_ID 2

    // 
    ULONG Type;
    #define MSMCAEvent_PCIBusError_Type_SIZE sizeof(ULONG)
    #define MSMCAEvent_PCIBusError_Type_ID 3

    // 
    ULONG Cpu;
    #define MSMCAEvent_PCIBusError_Cpu_SIZE sizeof(ULONG)
    #define MSMCAEvent_PCIBusError_Cpu_ID 4

    // 
    ULONG AdditionalErrors;
    #define MSMCAEvent_PCIBusError_AdditionalErrors_SIZE sizeof(ULONG)
    #define MSMCAEvent_PCIBusError_AdditionalErrors_ID 5

    // 
    ULONG LogToEventlog;
    #define MSMCAEvent_PCIBusError_LogToEventlog_SIZE sizeof(ULONG)
    #define MSMCAEvent_PCIBusError_LogToEventlog_ID 6

    // 
    ULONGLONG VALIDATION_BITS;
    #define MSMCAEvent_PCIBusError_VALIDATION_BITS_SIZE sizeof(ULONGLONG)
    #define MSMCAEvent_PCIBusError_VALIDATION_BITS_ID 7

    // 
    ULONGLONG PCI_BUS_ERROR_STATUS;
    #define MSMCAEvent_PCIBusError_PCI_BUS_ERROR_STATUS_SIZE sizeof(ULONGLONG)
    #define MSMCAEvent_PCIBusError_PCI_BUS_ERROR_STATUS_ID 8

    // 
    ULONGLONG PCI_BUS_ADDRESS;
    #define MSMCAEvent_PCIBusError_PCI_BUS_ADDRESS_SIZE sizeof(ULONGLONG)
    #define MSMCAEvent_PCIBusError_PCI_BUS_ADDRESS_ID 9

    // 
    ULONGLONG PCI_BUS_DATA;
    #define MSMCAEvent_PCIBusError_PCI_BUS_DATA_SIZE sizeof(ULONGLONG)
    #define MSMCAEvent_PCIBusError_PCI_BUS_DATA_ID 10

    // 
    ULONGLONG PCI_BUS_CMD;
    #define MSMCAEvent_PCIBusError_PCI_BUS_CMD_SIZE sizeof(ULONGLONG)
    #define MSMCAEvent_PCIBusError_PCI_BUS_CMD_ID 11

    // 
    ULONGLONG PCI_BUS_REQUESTOR_ID;
    #define MSMCAEvent_PCIBusError_PCI_BUS_REQUESTOR_ID_SIZE sizeof(ULONGLONG)
    #define MSMCAEvent_PCIBusError_PCI_BUS_REQUESTOR_ID_ID 12

    // 
    ULONGLONG PCI_BUS_RESPONDER_ID;
    #define MSMCAEvent_PCIBusError_PCI_BUS_RESPONDER_ID_SIZE sizeof(ULONGLONG)
    #define MSMCAEvent_PCIBusError_PCI_BUS_RESPONDER_ID_ID 13

    // 
    ULONGLONG PCI_BUS_TARGET_ID;
    #define MSMCAEvent_PCIBusError_PCI_BUS_TARGET_ID_SIZE sizeof(ULONGLONG)
    #define MSMCAEvent_PCIBusError_PCI_BUS_TARGET_ID_ID 14

    // 
    USHORT PCI_BUS_ERROR_TYPE;
    #define MSMCAEvent_PCIBusError_PCI_BUS_ERROR_TYPE_SIZE sizeof(USHORT)
    #define MSMCAEvent_PCIBusError_PCI_BUS_ERROR_TYPE_ID 15

    // 
    UCHAR PCI_BUS_ID_BusNumber;
    #define MSMCAEvent_PCIBusError_PCI_BUS_ID_BusNumber_SIZE sizeof(UCHAR)
    #define MSMCAEvent_PCIBusError_PCI_BUS_ID_BusNumber_ID 16

    // 
    UCHAR PCI_BUS_ID_SegmentNumber;
    #define MSMCAEvent_PCIBusError_PCI_BUS_ID_SegmentNumber_SIZE sizeof(UCHAR)
    #define MSMCAEvent_PCIBusError_PCI_BUS_ID_SegmentNumber_ID 17

    // 
    ULONG Size;
    #define MSMCAEvent_PCIBusError_Size_SIZE sizeof(ULONG)
    #define MSMCAEvent_PCIBusError_Size_ID 18

    // 
    UCHAR RawRecord[1];
    #define MSMCAEvent_PCIBusError_RawRecord_ID 19

} MSMCAEvent_PCIBusError, *PMSMCAEvent_PCIBusError;

// MSMCAEvent_PCIComponentError - MSMCAEvent_PCIComponentError
#define MSMCAEvent_PCIComponentErrorGuid \
    { 0x805caf4e,0x336c,0x4eb2, { 0x8c,0x0c,0x02,0xf3,0x51,0xcb,0xf1,0x3c } }

#if ! (defined(MIDL_PASS))
DEFINE_GUID(MSMCAEvent_PCIComponentError_GUID, \
            0x805caf4e,0x336c,0x4eb2,0x8c,0x0c,0x02,0xf3,0x51,0xcb,0xf1,0x3c);
#endif


typedef struct _MSMCAEvent_PCIComponentError
{
    // 
    ULONGLONG RecordId;
    #define MSMCAEvent_PCIComponentError_RecordId_SIZE sizeof(ULONGLONG)
    #define MSMCAEvent_PCIComponentError_RecordId_ID 1

    // 
    UCHAR ErrorSeverity;
    #define MSMCAEvent_PCIComponentError_ErrorSeverity_SIZE sizeof(UCHAR)
    #define MSMCAEvent_PCIComponentError_ErrorSeverity_ID 2

    // 
    ULONG Type;
    #define MSMCAEvent_PCIComponentError_Type_SIZE sizeof(ULONG)
    #define MSMCAEvent_PCIComponentError_Type_ID 3

    // 
    ULONG Cpu;
    #define MSMCAEvent_PCIComponentError_Cpu_SIZE sizeof(ULONG)
    #define MSMCAEvent_PCIComponentError_Cpu_ID 4

    // 
    ULONG AdditionalErrors;
    #define MSMCAEvent_PCIComponentError_AdditionalErrors_SIZE sizeof(ULONG)
    #define MSMCAEvent_PCIComponentError_AdditionalErrors_ID 5

    // 
    ULONG LogToEventlog;
    #define MSMCAEvent_PCIComponentError_LogToEventlog_SIZE sizeof(ULONG)
    #define MSMCAEvent_PCIComponentError_LogToEventlog_ID 6

    // 
    ULONGLONG VALIDATION_BITS;
    #define MSMCAEvent_PCIComponentError_VALIDATION_BITS_SIZE sizeof(ULONGLONG)
    #define MSMCAEvent_PCIComponentError_VALIDATION_BITS_ID 7

    // 
    ULONGLONG PCI_COMP_ERROR_STATUS;
    #define MSMCAEvent_PCIComponentError_PCI_COMP_ERROR_STATUS_SIZE sizeof(ULONGLONG)
    #define MSMCAEvent_PCIComponentError_PCI_COMP_ERROR_STATUS_ID 8

    // 
    USHORT PCI_COMP_INFO_VendorId;
    #define MSMCAEvent_PCIComponentError_PCI_COMP_INFO_VendorId_SIZE sizeof(USHORT)
    #define MSMCAEvent_PCIComponentError_PCI_COMP_INFO_VendorId_ID 9

    // 
    USHORT PCI_COMP_INFO_DeviceId;
    #define MSMCAEvent_PCIComponentError_PCI_COMP_INFO_DeviceId_SIZE sizeof(USHORT)
    #define MSMCAEvent_PCIComponentError_PCI_COMP_INFO_DeviceId_ID 10

    // 
    UCHAR PCI_COMP_INFO_ClassCodeInterface;
    #define MSMCAEvent_PCIComponentError_PCI_COMP_INFO_ClassCodeInterface_SIZE sizeof(UCHAR)
    #define MSMCAEvent_PCIComponentError_PCI_COMP_INFO_ClassCodeInterface_ID 11

    // 
    UCHAR PCI_COMP_INFO_ClassCodeSubClass;
    #define MSMCAEvent_PCIComponentError_PCI_COMP_INFO_ClassCodeSubClass_SIZE sizeof(UCHAR)
    #define MSMCAEvent_PCIComponentError_PCI_COMP_INFO_ClassCodeSubClass_ID 12

    // 
    UCHAR PCI_COMP_INFO_ClassCodeBaseClass;
    #define MSMCAEvent_PCIComponentError_PCI_COMP_INFO_ClassCodeBaseClass_SIZE sizeof(UCHAR)
    #define MSMCAEvent_PCIComponentError_PCI_COMP_INFO_ClassCodeBaseClass_ID 13

    // 
    UCHAR PCI_COMP_INFO_FunctionNumber;
    #define MSMCAEvent_PCIComponentError_PCI_COMP_INFO_FunctionNumber_SIZE sizeof(UCHAR)
    #define MSMCAEvent_PCIComponentError_PCI_COMP_INFO_FunctionNumber_ID 14

    // 
    UCHAR PCI_COMP_INFO_DeviceNumber;
    #define MSMCAEvent_PCIComponentError_PCI_COMP_INFO_DeviceNumber_SIZE sizeof(UCHAR)
    #define MSMCAEvent_PCIComponentError_PCI_COMP_INFO_DeviceNumber_ID 15

    // 
    UCHAR PCI_COMP_INFO_BusNumber;
    #define MSMCAEvent_PCIComponentError_PCI_COMP_INFO_BusNumber_SIZE sizeof(UCHAR)
    #define MSMCAEvent_PCIComponentError_PCI_COMP_INFO_BusNumber_ID 16

    // 
    UCHAR PCI_COMP_INFO_SegmentNumber;
    #define MSMCAEvent_PCIComponentError_PCI_COMP_INFO_SegmentNumber_SIZE sizeof(UCHAR)
    #define MSMCAEvent_PCIComponentError_PCI_COMP_INFO_SegmentNumber_ID 17

    // 
    ULONG Size;
    #define MSMCAEvent_PCIComponentError_Size_SIZE sizeof(ULONG)
    #define MSMCAEvent_PCIComponentError_Size_ID 18

    // 
    UCHAR RawRecord[1];
    #define MSMCAEvent_PCIComponentError_RawRecord_ID 19

} MSMCAEvent_PCIComponentError, *PMSMCAEvent_PCIComponentError;

// MSMCAEvent_SystemEventError - MSMCAEvent_SystemEventError
#define MSMCAEvent_SystemEventErrorGuid \
    { 0xbdba4b12,0x8d00,0x4570, { 0xb9,0xb2,0x3f,0xde,0xcf,0x1d,0x56,0x61 } }

#if ! (defined(MIDL_PASS))
DEFINE_GUID(MSMCAEvent_SystemEventError_GUID, \
            0xbdba4b12,0x8d00,0x4570,0xb9,0xb2,0x3f,0xde,0xcf,0x1d,0x56,0x61);
#endif


typedef struct _MSMCAEvent_SystemEventError
{
    // 
    ULONGLONG RecordId;
    #define MSMCAEvent_SystemEventError_RecordId_SIZE sizeof(ULONGLONG)
    #define MSMCAEvent_SystemEventError_RecordId_ID 1

    // 
    UCHAR ErrorSeverity;
    #define MSMCAEvent_SystemEventError_ErrorSeverity_SIZE sizeof(UCHAR)
    #define MSMCAEvent_SystemEventError_ErrorSeverity_ID 2

    // 
    ULONG Type;
    #define MSMCAEvent_SystemEventError_Type_SIZE sizeof(ULONG)
    #define MSMCAEvent_SystemEventError_Type_ID 3

    // 
    ULONG Cpu;
    #define MSMCAEvent_SystemEventError_Cpu_SIZE sizeof(ULONG)
    #define MSMCAEvent_SystemEventError_Cpu_ID 4

    // 
    ULONG AdditionalErrors;
    #define MSMCAEvent_SystemEventError_AdditionalErrors_SIZE sizeof(ULONG)
    #define MSMCAEvent_SystemEventError_AdditionalErrors_ID 5

    // 
    ULONG LogToEventlog;
    #define MSMCAEvent_SystemEventError_LogToEventlog_SIZE sizeof(ULONG)
    #define MSMCAEvent_SystemEventError_LogToEventlog_ID 6

    // 
    ULONGLONG VALIDATION_BITS;
    #define MSMCAEvent_SystemEventError_VALIDATION_BITS_SIZE sizeof(ULONGLONG)
    #define MSMCAEvent_SystemEventError_VALIDATION_BITS_ID 7

    // 
    ULONGLONG SEL_TIME_STAMP;
    #define MSMCAEvent_SystemEventError_SEL_TIME_STAMP_SIZE sizeof(ULONGLONG)
    #define MSMCAEvent_SystemEventError_SEL_TIME_STAMP_ID 8

    // 
    USHORT SEL_RECORD_ID;
    #define MSMCAEvent_SystemEventError_SEL_RECORD_ID_SIZE sizeof(USHORT)
    #define MSMCAEvent_SystemEventError_SEL_RECORD_ID_ID 9

    // 
    USHORT SEL_GENERATOR_ID;
    #define MSMCAEvent_SystemEventError_SEL_GENERATOR_ID_SIZE sizeof(USHORT)
    #define MSMCAEvent_SystemEventError_SEL_GENERATOR_ID_ID 10

    // 
    UCHAR SEL_RECORD_TYPE;
    #define MSMCAEvent_SystemEventError_SEL_RECORD_TYPE_SIZE sizeof(UCHAR)
    #define MSMCAEvent_SystemEventError_SEL_RECORD_TYPE_ID 11

    // 
    UCHAR SEL_EVM_REV;
    #define MSMCAEvent_SystemEventError_SEL_EVM_REV_SIZE sizeof(UCHAR)
    #define MSMCAEvent_SystemEventError_SEL_EVM_REV_ID 12

    // 
    UCHAR SEL_SENSOR_TYPE;
    #define MSMCAEvent_SystemEventError_SEL_SENSOR_TYPE_SIZE sizeof(UCHAR)
    #define MSMCAEvent_SystemEventError_SEL_SENSOR_TYPE_ID 13

    // 
    UCHAR SEL_SENSOR_NUM;
    #define MSMCAEvent_SystemEventError_SEL_SENSOR_NUM_SIZE sizeof(UCHAR)
    #define MSMCAEvent_SystemEventError_SEL_SENSOR_NUM_ID 14

    // 
    UCHAR SEL_EVENT_DIR_TYPE;
    #define MSMCAEvent_SystemEventError_SEL_EVENT_DIR_TYPE_SIZE sizeof(UCHAR)
    #define MSMCAEvent_SystemEventError_SEL_EVENT_DIR_TYPE_ID 15

    // 
    UCHAR SEL_DATA1;
    #define MSMCAEvent_SystemEventError_SEL_DATA1_SIZE sizeof(UCHAR)
    #define MSMCAEvent_SystemEventError_SEL_DATA1_ID 16

    // 
    UCHAR SEL_DATA2;
    #define MSMCAEvent_SystemEventError_SEL_DATA2_SIZE sizeof(UCHAR)
    #define MSMCAEvent_SystemEventError_SEL_DATA2_ID 17

    // 
    UCHAR SEL_DATA3;
    #define MSMCAEvent_SystemEventError_SEL_DATA3_SIZE sizeof(UCHAR)
    #define MSMCAEvent_SystemEventError_SEL_DATA3_ID 18

    // 
    ULONG Size;
    #define MSMCAEvent_SystemEventError_Size_SIZE sizeof(ULONG)
    #define MSMCAEvent_SystemEventError_Size_ID 19

    // 
    UCHAR RawRecord[1];
    #define MSMCAEvent_SystemEventError_RawRecord_ID 20

} MSMCAEvent_SystemEventError, *PMSMCAEvent_SystemEventError;

// MSMCAEvent_SMBIOSError - MSMCAEvent_SMBIOSError
#define MSMCAEvent_SMBIOSErrorGuid \
    { 0x4184df1b,0xedfe,0x406b, { 0xb1,0x72,0x54,0xc9,0x1f,0xbd,0x9b,0xaf } }

#if ! (defined(MIDL_PASS))
DEFINE_GUID(MSMCAEvent_SMBIOSError_GUID, \
            0x4184df1b,0xedfe,0x406b,0xb1,0x72,0x54,0xc9,0x1f,0xbd,0x9b,0xaf);
#endif


typedef struct _MSMCAEvent_SMBIOSError
{
    // 
    ULONGLONG RecordId;
    #define MSMCAEvent_SMBIOSError_RecordId_SIZE sizeof(ULONGLONG)
    #define MSMCAEvent_SMBIOSError_RecordId_ID 1

    // 
    UCHAR ErrorSeverity;
    #define MSMCAEvent_SMBIOSError_ErrorSeverity_SIZE sizeof(UCHAR)
    #define MSMCAEvent_SMBIOSError_ErrorSeverity_ID 2

    // 
    ULONG Type;
    #define MSMCAEvent_SMBIOSError_Type_SIZE sizeof(ULONG)
    #define MSMCAEvent_SMBIOSError_Type_ID 3

    // 
    ULONG Cpu;
    #define MSMCAEvent_SMBIOSError_Cpu_SIZE sizeof(ULONG)
    #define MSMCAEvent_SMBIOSError_Cpu_ID 4

    // 
    ULONG AdditionalErrors;
    #define MSMCAEvent_SMBIOSError_AdditionalErrors_SIZE sizeof(ULONG)
    #define MSMCAEvent_SMBIOSError_AdditionalErrors_ID 5

    // 
    ULONG LogToEventlog;
    #define MSMCAEvent_SMBIOSError_LogToEventlog_SIZE sizeof(ULONG)
    #define MSMCAEvent_SMBIOSError_LogToEventlog_ID 6

    // 
    ULONGLONG VALIDATION_BITS;
    #define MSMCAEvent_SMBIOSError_VALIDATION_BITS_SIZE sizeof(ULONGLONG)
    #define MSMCAEvent_SMBIOSError_VALIDATION_BITS_ID 7

    // 
    UCHAR SMBIOS_EVENT_TYPE;
    #define MSMCAEvent_SMBIOSError_SMBIOS_EVENT_TYPE_SIZE sizeof(UCHAR)
    #define MSMCAEvent_SMBIOSError_SMBIOS_EVENT_TYPE_ID 8

    // 
    ULONG Size;
    #define MSMCAEvent_SMBIOSError_Size_SIZE sizeof(ULONG)
    #define MSMCAEvent_SMBIOSError_Size_ID 9

    // 
    UCHAR RawRecord[1];
    #define MSMCAEvent_SMBIOSError_RawRecord_ID 10

} MSMCAEvent_SMBIOSError, *PMSMCAEvent_SMBIOSError;

// MSMCAEvent_PlatformSpecificError - MSMCAEvent_PlatformSpecificError
#define MSMCAEvent_PlatformSpecificErrorGuid \
    { 0x2d2434aa,0xef83,0x4200, { 0xba,0x24,0xde,0x36,0x6c,0x41,0x5f,0x7b } }

#if ! (defined(MIDL_PASS))
DEFINE_GUID(MSMCAEvent_PlatformSpecificError_GUID, \
            0x2d2434aa,0xef83,0x4200,0xba,0x24,0xde,0x36,0x6c,0x41,0x5f,0x7b);
#endif


typedef struct _MSMCAEvent_PlatformSpecificError
{
    // 
    ULONGLONG RecordId;
    #define MSMCAEvent_PlatformSpecificError_RecordId_SIZE sizeof(ULONGLONG)
    #define MSMCAEvent_PlatformSpecificError_RecordId_ID 1

    // 
    UCHAR ErrorSeverity;
    #define MSMCAEvent_PlatformSpecificError_ErrorSeverity_SIZE sizeof(UCHAR)
    #define MSMCAEvent_PlatformSpecificError_ErrorSeverity_ID 2

    // 
    ULONG Type;
    #define MSMCAEvent_PlatformSpecificError_Type_SIZE sizeof(ULONG)
    #define MSMCAEvent_PlatformSpecificError_Type_ID 3

    // 
    ULONG Cpu;
    #define MSMCAEvent_PlatformSpecificError_Cpu_SIZE sizeof(ULONG)
    #define MSMCAEvent_PlatformSpecificError_Cpu_ID 4

    // 
    ULONG AdditionalErrors;
    #define MSMCAEvent_PlatformSpecificError_AdditionalErrors_SIZE sizeof(ULONG)
    #define MSMCAEvent_PlatformSpecificError_AdditionalErrors_ID 5

    // 
    ULONG LogToEventlog;
    #define MSMCAEvent_PlatformSpecificError_LogToEventlog_SIZE sizeof(ULONG)
    #define MSMCAEvent_PlatformSpecificError_LogToEventlog_ID 6

    // 
    ULONGLONG VALIDATION_BITS;
    #define MSMCAEvent_PlatformSpecificError_VALIDATION_BITS_SIZE sizeof(ULONGLONG)
    #define MSMCAEvent_PlatformSpecificError_VALIDATION_BITS_ID 7

    // 
    ULONGLONG PLATFORM_ERROR_STATUS;
    #define MSMCAEvent_PlatformSpecificError_PLATFORM_ERROR_STATUS_SIZE sizeof(ULONGLONG)
    #define MSMCAEvent_PlatformSpecificError_PLATFORM_ERROR_STATUS_ID 8

    // 
    ULONGLONG PLATFORM_REQUESTOR_ID;
    #define MSMCAEvent_PlatformSpecificError_PLATFORM_REQUESTOR_ID_SIZE sizeof(ULONGLONG)
    #define MSMCAEvent_PlatformSpecificError_PLATFORM_REQUESTOR_ID_ID 9

    // 
    ULONGLONG PLATFORM_RESPONDER_ID;
    #define MSMCAEvent_PlatformSpecificError_PLATFORM_RESPONDER_ID_SIZE sizeof(ULONGLONG)
    #define MSMCAEvent_PlatformSpecificError_PLATFORM_RESPONDER_ID_ID 10

    // 
    ULONGLONG PLATFORM_TARGET_ID;
    #define MSMCAEvent_PlatformSpecificError_PLATFORM_TARGET_ID_SIZE sizeof(ULONGLONG)
    #define MSMCAEvent_PlatformSpecificError_PLATFORM_TARGET_ID_ID 11

    // 
    ULONGLONG PLATFORM_BUS_SPECIFIC_DATA;
    #define MSMCAEvent_PlatformSpecificError_PLATFORM_BUS_SPECIFIC_DATA_SIZE sizeof(ULONGLONG)
    #define MSMCAEvent_PlatformSpecificError_PLATFORM_BUS_SPECIFIC_DATA_ID 12

    // 
    UCHAR OEM_COMPONENT_ID[16];
    #define MSMCAEvent_PlatformSpecificError_OEM_COMPONENT_ID_SIZE sizeof(UCHAR[16])
    #define MSMCAEvent_PlatformSpecificError_OEM_COMPONENT_ID_ID 13

    // 
    ULONG Size;
    #define MSMCAEvent_PlatformSpecificError_Size_SIZE sizeof(ULONG)
    #define MSMCAEvent_PlatformSpecificError_Size_ID 14

    // 
    UCHAR RawRecord[1];
    #define MSMCAEvent_PlatformSpecificError_RawRecord_ID 15

} MSMCAEvent_PlatformSpecificError, *PMSMCAEvent_PlatformSpecificError;

// MSMCAEvent_InvalidError - MSMCAEvent_InvalidError
#define MSMCAEvent_InvalidErrorGuid \
    { 0x477b769b,0x785c,0x48dd, { 0xa0,0x2e,0x57,0xe0,0x51,0xbe,0x7b,0x85 } }

#if ! (defined(MIDL_PASS))
DEFINE_GUID(MSMCAEvent_InvalidError_GUID, \
            0x477b769b,0x785c,0x48dd,0xa0,0x2e,0x57,0xe0,0x51,0xbe,0x7b,0x85);
#endif


typedef struct _MSMCAEvent_InvalidError
{
    // 
    ULONGLONG RecordId;
    #define MSMCAEvent_InvalidError_RecordId_SIZE sizeof(ULONGLONG)
    #define MSMCAEvent_InvalidError_RecordId_ID 1

    // 
    UCHAR ErrorSeverity;
    #define MSMCAEvent_InvalidError_ErrorSeverity_SIZE sizeof(UCHAR)
    #define MSMCAEvent_InvalidError_ErrorSeverity_ID 2

    // 
    ULONG Type;
    #define MSMCAEvent_InvalidError_Type_SIZE sizeof(ULONG)
    #define MSMCAEvent_InvalidError_Type_ID 3

    // 
    ULONG Cpu;
    #define MSMCAEvent_InvalidError_Cpu_SIZE sizeof(ULONG)
    #define MSMCAEvent_InvalidError_Cpu_ID 4

    // 
    ULONG AdditionalErrors;
    #define MSMCAEvent_InvalidError_AdditionalErrors_SIZE sizeof(ULONG)
    #define MSMCAEvent_InvalidError_AdditionalErrors_ID 5

    // 
    ULONG LogToEventlog;
    #define MSMCAEvent_InvalidError_LogToEventlog_SIZE sizeof(ULONG)
    #define MSMCAEvent_InvalidError_LogToEventlog_ID 6

    // 
    ULONG Size;
    #define MSMCAEvent_InvalidError_Size_SIZE sizeof(ULONG)
    #define MSMCAEvent_InvalidError_Size_ID 7

    // 
    UCHAR RawRecord[1];
    #define MSMCAEvent_InvalidError_RawRecord_ID 8

} MSMCAEvent_InvalidError, *PMSMCAEvent_InvalidError;

// MSMCAEvent_MemoryPageRemoved - MSMCAEvent_MemoryPageRemoved
#define MSMCAEvent_MemoryPageRemovedGuid \
    { 0x84e9ddb6,0xe233,0x4dfc, { 0x98,0x8c,0x74,0x12,0xc8,0x75,0x4f,0xec } }

#if ! (defined(MIDL_PASS))
DEFINE_GUID(MSMCAEvent_MemoryPageRemoved_GUID, \
            0x84e9ddb6,0xe233,0x4dfc,0x98,0x8c,0x74,0x12,0xc8,0x75,0x4f,0xec);
#endif


typedef struct _MSMCAEvent_MemoryPageRemoved
{
    // 
    ULONGLONG PhysicalAddress;
    #define MSMCAEvent_MemoryPageRemoved_PhysicalAddress_SIZE sizeof(ULONGLONG)
    #define MSMCAEvent_MemoryPageRemoved_PhysicalAddress_ID 1

} MSMCAEvent_MemoryPageRemoved, *PMSMCAEvent_MemoryPageRemoved;

#define MSMCAEvent_MemoryPageRemoved_SIZE (FIELD_OFFSET(MSMCAEvent_MemoryPageRemoved, PhysicalAddress) + MSMCAEvent_MemoryPageRemoved_PhysicalAddress_SIZE)

// MSMCAInfo_Entry - MSMCAInfo_Entry
#define MSMCAInfo_EntryGuid \
    { 0x9e77a308,0x6b82,0x4fc1, { 0xab,0x41,0x0a,0x55,0x86,0x7c,0x35,0xc2 } }

#if ! (defined(MIDL_PASS))
DEFINE_GUID(MSMCAInfo_Entry_GUID, \
            0x9e77a308,0x6b82,0x4fc1,0xab,0x41,0x0a,0x55,0x86,0x7c,0x35,0xc2);
#endif


typedef struct _MSMCAInfo_Entry
{
    // 
    ULONG Length;
    #define MSMCAInfo_Entry_Length_SIZE sizeof(ULONG)
    #define MSMCAInfo_Entry_Length_ID 1

    // 
    UCHAR Data[1];
    #define MSMCAInfo_Entry_Data_ID 2

} MSMCAInfo_Entry, *PMSMCAInfo_Entry;

// MSMCAInfo_RawMCAData - MSMCAInfo_RawMCAData
#define MSMCAInfo_RawMCADataGuid \
    { 0x23602a8a,0xdadd,0x462f, { 0x9a,0xe5,0x30,0xfa,0x2c,0x37,0xdd,0x5b } }

#if ! (defined(MIDL_PASS))
DEFINE_GUID(MSMCAInfo_RawMCAData_GUID, \
            0x23602a8a,0xdadd,0x462f,0x9a,0xe5,0x30,0xfa,0x2c,0x37,0xdd,0x5b);
#endif


typedef struct _MSMCAInfo_RawMCAData
{
    // 
    ULONG Count;
    #define MSMCAInfo_RawMCAData_Count_SIZE sizeof(ULONG)
    #define MSMCAInfo_RawMCAData_Count_ID 1

    // 
    MSMCAInfo_Entry Records[1];
    #define MSMCAInfo_RawMCAData_Records_ID 2

} MSMCAInfo_RawMCAData, *PMSMCAInfo_RawMCAData;

// MSMCAInfo_RawCMCEvent - MSMCAInfo_RawCMCEvent
#define MSMCAInfo_RawCMCEventGuid \
    { 0x2f1a8a9d,0x7988,0x457f, { 0xa1,0x7a,0x89,0x79,0xe8,0x20,0x43,0xc5 } }

#if ! (defined(MIDL_PASS))
DEFINE_GUID(MSMCAInfo_RawCMCEvent_GUID, \
            0x2f1a8a9d,0x7988,0x457f,0xa1,0x7a,0x89,0x79,0xe8,0x20,0x43,0xc5);
#endif


typedef struct _MSMCAInfo_RawCMCEvent
{
    // 
    ULONG Count;
    #define MSMCAInfo_RawCMCEvent_Count_SIZE sizeof(ULONG)
    #define MSMCAInfo_RawCMCEvent_Count_ID 1

    // 
    MSMCAInfo_Entry Records[1];
    #define MSMCAInfo_RawCMCEvent_Records_ID 2

} MSMCAInfo_RawCMCEvent, *PMSMCAInfo_RawCMCEvent;

// MSMCAInfo_RawMCAEvent - MSMCAInfo_RawMCAEvent
#define MSMCAInfo_RawMCAEventGuid \
    { 0x2f1a8a9f,0x7988,0x457f, { 0xa1,0x7a,0x89,0x79,0xe8,0x20,0x43,0xc5 } }

#if ! (defined(MIDL_PASS))
DEFINE_GUID(MSMCAInfo_RawMCAEvent_GUID, \
            0x2f1a8a9f,0x7988,0x457f,0xa1,0x7a,0x89,0x79,0xe8,0x20,0x43,0xc5);
#endif


typedef struct _MSMCAInfo_RawMCAEvent
{
    // 
    ULONG Count;
    #define MSMCAInfo_RawMCAEvent_Count_SIZE sizeof(ULONG)
    #define MSMCAInfo_RawMCAEvent_Count_ID 1

    // 
    MSMCAInfo_Entry Records[1];
    #define MSMCAInfo_RawMCAEvent_Records_ID 2

} MSMCAInfo_RawMCAEvent, *PMSMCAInfo_RawMCAEvent;

// MSMCAInfo_RawCorrectedPlatformEvent - MSMCAInfo_RawCorrectedPlatformEvent
#define MSMCAInfo_RawCorrectedPlatformEventGuid \
    { 0x6b629d5e,0xe63c,0x48a3, { 0x9e,0xbb,0x97,0x42,0x27,0x07,0x52,0x65 } }

#if ! (defined(MIDL_PASS))
DEFINE_GUID(MSMCAInfo_RawCorrectedPlatformEvent_GUID, \
            0x6b629d5e,0xe63c,0x48a3,0x9e,0xbb,0x97,0x42,0x27,0x07,0x52,0x65);
#endif


typedef struct _MSMCAInfo_RawCorrectedPlatformEvent
{
    // 
    ULONG Count;
    #define MSMCAInfo_RawCorrectedPlatformEvent_Count_SIZE sizeof(ULONG)
    #define MSMCAInfo_RawCorrectedPlatformEvent_Count_ID 1

    // 
    MSMCAInfo_Entry Records[1];
    #define MSMCAInfo_RawCorrectedPlatformEvent_Records_ID 2

} MSMCAInfo_RawCorrectedPlatformEvent, *PMSMCAInfo_RawCorrectedPlatformEvent;

// MSPower_DeviceEnable - MSPower_DeviceEnable
#define MSPower_DeviceEnableGuid \
    { 0x827c0a6f,0xfeb0,0x11d0, { 0xbd,0x26,0x00,0xaa,0x00,0xb7,0xb3,0x2a } }

#if ! (defined(MIDL_PASS))
DEFINE_GUID(MSPower_DeviceEnable_GUID, \
            0x827c0a6f,0xfeb0,0x11d0,0xbd,0x26,0x00,0xaa,0x00,0xb7,0xb3,0x2a);
#endif


typedef struct _MSPower_DeviceEnable
{
    // 
    BOOLEAN Enable;
    #define MSPower_DeviceEnable_Enable_SIZE sizeof(BOOLEAN)
    #define MSPower_DeviceEnable_Enable_ID 1

} MSPower_DeviceEnable, *PMSPower_DeviceEnable;

#define MSPower_DeviceEnable_SIZE (FIELD_OFFSET(MSPower_DeviceEnable, Enable) + MSPower_DeviceEnable_Enable_SIZE)

// MSPower_DeviceWakeEnable - MSPower_DeviceWakeEnable
#define MSPower_DeviceWakeEnableGuid \
    { 0xa9546a82,0xfeb0,0x11d0, { 0xbd,0x26,0x00,0xaa,0x00,0xb7,0xb3,0x2a } }

#if ! (defined(MIDL_PASS))
DEFINE_GUID(MSPower_DeviceWakeEnable_GUID, \
            0xa9546a82,0xfeb0,0x11d0,0xbd,0x26,0x00,0xaa,0x00,0xb7,0xb3,0x2a);
#endif


typedef struct _MSPower_DeviceWakeEnable
{
    // 
    BOOLEAN Enable;
    #define MSPower_DeviceWakeEnable_Enable_SIZE sizeof(BOOLEAN)
    #define MSPower_DeviceWakeEnable_Enable_ID 1

} MSPower_DeviceWakeEnable, *PMSPower_DeviceWakeEnable;

#define MSPower_DeviceWakeEnable_SIZE (FIELD_OFFSET(MSPower_DeviceWakeEnable, Enable) + MSPower_DeviceWakeEnable_Enable_SIZE)

// MSNdis_NetworkAddress - MSNdis_NetworkAddress
#define MSNdis_NetworkAddressGuid \
    { 0xb5bd98b7,0x0201,0x11d1, { 0xa5,0x0e,0x00,0xa0,0xc9,0x06,0x29,0x10 } }

#if ! (defined(MIDL_PASS))
DEFINE_GUID(MSNdis_NetworkAddress_GUID, \
            0xb5bd98b7,0x0201,0x11d1,0xa5,0x0e,0x00,0xa0,0xc9,0x06,0x29,0x10);
#endif


typedef struct _MSNdis_NetworkAddress
{
    // 
    UCHAR Address[6];
    #define MSNdis_NetworkAddress_Address_SIZE sizeof(UCHAR[6])
    #define MSNdis_NetworkAddress_Address_ID 1

} MSNdis_NetworkAddress, *PMSNdis_NetworkAddress;

#define MSNdis_NetworkAddress_SIZE (FIELD_OFFSET(MSNdis_NetworkAddress, Address) + MSNdis_NetworkAddress_Address_SIZE)

// MSNdis_NetworkShortAddress - MSNdis_NetworkShortAddress
#define MSNdis_NetworkShortAddressGuid \
    { 0xb5bd98b8,0x0201,0x11d1, { 0xa5,0x0e,0x00,0xa0,0xc9,0x06,0x29,0x10 } }

#if ! (defined(MIDL_PASS))
DEFINE_GUID(MSNdis_NetworkShortAddress_GUID, \
            0xb5bd98b8,0x0201,0x11d1,0xa5,0x0e,0x00,0xa0,0xc9,0x06,0x29,0x10);
#endif


typedef struct _MSNdis_NetworkShortAddress
{
    // 
    UCHAR Address[2];
    #define MSNdis_NetworkShortAddress_Address_SIZE sizeof(UCHAR[2])
    #define MSNdis_NetworkShortAddress_Address_ID 1

} MSNdis_NetworkShortAddress, *PMSNdis_NetworkShortAddress;

#define MSNdis_NetworkShortAddress_SIZE (FIELD_OFFSET(MSNdis_NetworkShortAddress, Address) + MSNdis_NetworkShortAddress_Address_SIZE)

// MSNdis_NetworkLinkSpeed - MSNdis_NetworkLinkSpeed
#define MSNdis_NetworkLinkSpeedGuid \
    { 0x60fc6b57,0x0f66,0x11d1, { 0x96,0xa7,0x00,0xc0,0x4f,0xc3,0x35,0x8c } }

#if ! (defined(MIDL_PASS))
DEFINE_GUID(MSNdis_NetworkLinkSpeed_GUID, \
            0x60fc6b57,0x0f66,0x11d1,0x96,0xa7,0x00,0xc0,0x4f,0xc3,0x35,0x8c);
#endif


typedef struct _MSNdis_NetworkLinkSpeed
{
    // 
    ULONG Outbound;
    #define MSNdis_NetworkLinkSpeed_Outbound_SIZE sizeof(ULONG)
    #define MSNdis_NetworkLinkSpeed_Outbound_ID 1

    // 
    ULONG Inbound;
    #define MSNdis_NetworkLinkSpeed_Inbound_SIZE sizeof(ULONG)
    #define MSNdis_NetworkLinkSpeed_Inbound_ID 2

} MSNdis_NetworkLinkSpeed, *PMSNdis_NetworkLinkSpeed;

#define MSNdis_NetworkLinkSpeed_SIZE (FIELD_OFFSET(MSNdis_NetworkLinkSpeed, Inbound) + MSNdis_NetworkLinkSpeed_Inbound_SIZE)

// MSNdis_EnumerateAdapter - MSNdis_EnumerateAdapter
#define MSNdis_EnumerateAdapterGuid \
    { 0x981f2d7f,0xb1f3,0x11d0, { 0x8d,0xd7,0x00,0xc0,0x4f,0xc3,0x35,0x8c } }

#if ! (defined(MIDL_PASS))
DEFINE_GUID(MSNdis_EnumerateAdapter_GUID, \
            0x981f2d7f,0xb1f3,0x11d0,0x8d,0xd7,0x00,0xc0,0x4f,0xc3,0x35,0x8c);
#endif


typedef struct _MSNdis_EnumerateAdapter
{
    // 
    CHAR VariableData[1];
    #define MSNdis_EnumerateAdapter_DeviceName_ID 1

} MSNdis_EnumerateAdapter, *PMSNdis_EnumerateAdapter;

// MSNdis_NotifyAdapterRemoval - MSNdis_NotifyAdapterRemoval
#define MSNdis_NotifyAdapterRemovalGuid \
    { 0x981f2d80,0xb1f3,0x11d0, { 0x8d,0xd7,0x00,0xc0,0x4f,0xc3,0x35,0x8c } }

#if ! (defined(MIDL_PASS))
DEFINE_GUID(MSNdis_NotifyAdapterRemoval_GUID, \
            0x981f2d80,0xb1f3,0x11d0,0x8d,0xd7,0x00,0xc0,0x4f,0xc3,0x35,0x8c);
#endif


typedef struct _MSNdis_NotifyAdapterRemoval
{
    // 
    CHAR VariableData[1];
    #define MSNdis_NotifyAdapterRemoval_DeviceName_ID 1

} MSNdis_NotifyAdapterRemoval, *PMSNdis_NotifyAdapterRemoval;

// MSNdis_NotifyAdapterArrival - MSNdis_NotifyAdapterArrival
#define MSNdis_NotifyAdapterArrivalGuid \
    { 0x981f2d81,0xb1f3,0x11d0, { 0x8d,0xd7,0x00,0xc0,0x4f,0xc3,0x35,0x8c } }

#if ! (defined(MIDL_PASS))
DEFINE_GUID(MSNdis_NotifyAdapterArrival_GUID, \
            0x981f2d81,0xb1f3,0x11d0,0x8d,0xd7,0x00,0xc0,0x4f,0xc3,0x35,0x8c);
#endif


typedef struct _MSNdis_NotifyAdapterArrival
{
    // 
    CHAR VariableData[1];
    #define MSNdis_NotifyAdapterArrival_DeviceName_ID 1

} MSNdis_NotifyAdapterArrival, *PMSNdis_NotifyAdapterArrival;

// MSNdis_NdisEnumerateVc - MSNdis_NdisEnumerateVc
#define MSNdis_NdisEnumerateVcGuid \
    { 0x981f2d82,0xb1f3,0x11d0, { 0x8d,0xd7,0x00,0xc0,0x4f,0xc3,0x35,0x8c } }

#if ! (defined(MIDL_PASS))
DEFINE_GUID(MSNdis_NdisEnumerateVc_GUID, \
            0x981f2d82,0xb1f3,0x11d0,0x8d,0xd7,0x00,0xc0,0x4f,0xc3,0x35,0x8c);
#endif


// MSNdis_NotifyVcRemoval - MSNdis_NotifyVcRemoval
#define MSNdis_NotifyVcRemovalGuid \
    { 0x981f2d79,0xb1f3,0x11d0, { 0x8d,0xd7,0x00,0xc0,0x4f,0xc3,0x35,0x8c } }

#if ! (defined(MIDL_PASS))
DEFINE_GUID(MSNdis_NotifyVcRemoval_GUID, \
            0x981f2d79,0xb1f3,0x11d0,0x8d,0xd7,0x00,0xc0,0x4f,0xc3,0x35,0x8c);
#endif


// MSNdis_NotifyVcArrival - MSNdis_NotifyVcArrival
#define MSNdis_NotifyVcArrivalGuid \
    { 0x182f9e0c,0xb1f3,0x11d0, { 0x8d,0xd7,0x00,0xc0,0x4f,0xc3,0x35,0x8c } }

#if ! (defined(MIDL_PASS))
DEFINE_GUID(MSNdis_NotifyVcArrival_GUID, \
            0x182f9e0c,0xb1f3,0x11d0,0x8d,0xd7,0x00,0xc0,0x4f,0xc3,0x35,0x8c);
#endif


// MSNdis_NotifyFilterRemoval - MSNdis_NotifyFilterRemoval
#define MSNdis_NotifyFilterRemovalGuid \
    { 0x1f177cd9,0x5955,0x4721, { 0x9f,0x6a,0x78,0xeb,0xdf,0xae,0xf8,0x89 } }

#if ! (defined(MIDL_PASS))
DEFINE_GUID(MSNdis_NotifyFilterRemoval_GUID, \
            0x1f177cd9,0x5955,0x4721,0x9f,0x6a,0x78,0xeb,0xdf,0xae,0xf8,0x89);
#endif


// MSNdis_NotifyFilterArrival - MSNdis_NotifyFilterArrival
#define MSNdis_NotifyFilterArrivalGuid \
    { 0x0b6d3c89,0x5917,0x43ca, { 0xb5,0x78,0xd0,0x1a,0x79,0x67,0xc4,0x1c } }

#if ! (defined(MIDL_PASS))
DEFINE_GUID(MSNdis_NotifyFilterArrival_GUID, \
            0x0b6d3c89,0x5917,0x43ca,0xb5,0x78,0xd0,0x1a,0x79,0x67,0xc4,0x1c);
#endif


// MSNdis_DeviceWakeOnMagicPacketOnly - MSNdis_DeviceWakeOnMagicPacketOnly
#define MSNdis_DeviceWakeOnMagicPacketOnlyGuid \
    { 0xa14f1c97,0x8839,0x4f8a, { 0x99,0x96,0xa2,0x89,0x96,0xeb,0xbf,0x1d } }

#if ! (defined(MIDL_PASS))
DEFINE_GUID(MSNdis_DeviceWakeOnMagicPacketOnly_GUID, \
            0xa14f1c97,0x8839,0x4f8a,0x99,0x96,0xa2,0x89,0x96,0xeb,0xbf,0x1d);
#endif


typedef struct _MSNdis_DeviceWakeOnMagicPacketOnly
{
    // 
    BOOLEAN EnableWakeOnMagicPacketOnly;
    #define MSNdis_DeviceWakeOnMagicPacketOnly_EnableWakeOnMagicPacketOnly_SIZE sizeof(BOOLEAN)
    #define MSNdis_DeviceWakeOnMagicPacketOnly_EnableWakeOnMagicPacketOnly_ID 1

} MSNdis_DeviceWakeOnMagicPacketOnly, *PMSNdis_DeviceWakeOnMagicPacketOnly;

#define MSNdis_DeviceWakeOnMagicPacketOnly_SIZE (FIELD_OFFSET(MSNdis_DeviceWakeOnMagicPacketOnly, EnableWakeOnMagicPacketOnly) + MSNdis_DeviceWakeOnMagicPacketOnly_EnableWakeOnMagicPacketOnly_SIZE)

// MSNdis_HardwareStatus - MSNdis_HardwareStatus
#define MSNdis_HardwareStatusGuid \
    { 0x5ec10354,0xa61a,0x11d0, { 0x8d,0xd4,0x00,0xc0,0x4f,0xc3,0x35,0x8c } }

#if ! (defined(MIDL_PASS))
DEFINE_GUID(MSNdis_HardwareStatus_GUID, \
            0x5ec10354,0xa61a,0x11d0,0x8d,0xd4,0x00,0xc0,0x4f,0xc3,0x35,0x8c);
#endif


typedef struct _MSNdis_HardwareStatus
{
    // 
    ULONG NdisHardwareStatus;
    #define MSNdis_HardwareStatus_NdisHardwareStatus_SIZE sizeof(ULONG)
    #define MSNdis_HardwareStatus_NdisHardwareStatus_ID 1

} MSNdis_HardwareStatus, *PMSNdis_HardwareStatus;

#define MSNdis_HardwareStatus_SIZE (FIELD_OFFSET(MSNdis_HardwareStatus, NdisHardwareStatus) + MSNdis_HardwareStatus_NdisHardwareStatus_SIZE)

// MSNdis_MediaSupported - MSNdis_MediaSupported
#define MSNdis_MediaSupportedGuid \
    { 0x5ec10355,0xa61a,0x11d0, { 0x8d,0xd4,0x00,0xc0,0x4f,0xc3,0x35,0x8c } }

#if ! (defined(MIDL_PASS))
DEFINE_GUID(MSNdis_MediaSupported_GUID, \
            0x5ec10355,0xa61a,0x11d0,0x8d,0xd4,0x00,0xc0,0x4f,0xc3,0x35,0x8c);
#endif


typedef struct _MSNdis_MediaSupported
{
    // 
    ULONG NumberElements;
    #define MSNdis_MediaSupported_NumberElements_SIZE sizeof(ULONG)
    #define MSNdis_MediaSupported_NumberElements_ID 1

    // 
    ULONG NdisMediaSupported[1];
    #define MSNdis_MediaSupported_NdisMediaSupported_ID 2

} MSNdis_MediaSupported, *PMSNdis_MediaSupported;

// MSNdis_MediaInUse - MSNdis_MediaInUse
#define MSNdis_MediaInUseGuid \
    { 0x5ec10356,0xa61a,0x11d0, { 0x8d,0xd4,0x00,0xc0,0x4f,0xc3,0x35,0x8c } }

#if ! (defined(MIDL_PASS))
DEFINE_GUID(MSNdis_MediaInUse_GUID, \
            0x5ec10356,0xa61a,0x11d0,0x8d,0xd4,0x00,0xc0,0x4f,0xc3,0x35,0x8c);
#endif


typedef struct _MSNdis_MediaInUse
{
    // 
    ULONG NumberElements;
    #define MSNdis_MediaInUse_NumberElements_SIZE sizeof(ULONG)
    #define MSNdis_MediaInUse_NumberElements_ID 1

    // 
    ULONG NdisMediaInUse[1];
    #define MSNdis_MediaInUse_NdisMediaInUse_ID 2

} MSNdis_MediaInUse, *PMSNdis_MediaInUse;

// MSNdis_MaximumLookahead - MSNdis_MaximumLookahead
#define MSNdis_MaximumLookaheadGuid \
    { 0x5ec10357,0xa61a,0x11d0, { 0x8d,0xd4,0x00,0xc0,0x4f,0xc3,0x35,0x8c } }

#if ! (defined(MIDL_PASS))
DEFINE_GUID(MSNdis_MaximumLookahead_GUID, \
            0x5ec10357,0xa61a,0x11d0,0x8d,0xd4,0x00,0xc0,0x4f,0xc3,0x35,0x8c);
#endif


typedef struct _MSNdis_MaximumLookahead
{
    // 
    ULONG NdisMaximumLookahead;
    #define MSNdis_MaximumLookahead_NdisMaximumLookahead_SIZE sizeof(ULONG)
    #define MSNdis_MaximumLookahead_NdisMaximumLookahead_ID 1

} MSNdis_MaximumLookahead, *PMSNdis_MaximumLookahead;

#define MSNdis_MaximumLookahead_SIZE (FIELD_OFFSET(MSNdis_MaximumLookahead, NdisMaximumLookahead) + MSNdis_MaximumLookahead_NdisMaximumLookahead_SIZE)

// MSNdis_MaximumFrameSize - MSNdis_MaximumFrameSize
#define MSNdis_MaximumFrameSizeGuid \
    { 0x5ec10358,0xa61a,0x11d0, { 0x8d,0xd4,0x00,0xc0,0x4f,0xc3,0x35,0x8c } }

#if ! (defined(MIDL_PASS))
DEFINE_GUID(MSNdis_MaximumFrameSize_GUID, \
            0x5ec10358,0xa61a,0x11d0,0x8d,0xd4,0x00,0xc0,0x4f,0xc3,0x35,0x8c);
#endif


typedef struct _MSNdis_MaximumFrameSize
{
    // 
    ULONG NdisMaximumFrameSize;
    #define MSNdis_MaximumFrameSize_NdisMaximumFrameSize_SIZE sizeof(ULONG)
    #define MSNdis_MaximumFrameSize_NdisMaximumFrameSize_ID 1

} MSNdis_MaximumFrameSize, *PMSNdis_MaximumFrameSize;

#define MSNdis_MaximumFrameSize_SIZE (FIELD_OFFSET(MSNdis_MaximumFrameSize, NdisMaximumFrameSize) + MSNdis_MaximumFrameSize_NdisMaximumFrameSize_SIZE)

// MSNdis_LinkSpeed - MSNdis_LinkSpeed
#define MSNdis_LinkSpeedGuid \
    { 0x5ec10359,0xa61a,0x11d0, { 0x8d,0xd4,0x00,0xc0,0x4f,0xc3,0x35,0x8c } }

#if ! (defined(MIDL_PASS))
DEFINE_GUID(MSNdis_LinkSpeed_GUID, \
            0x5ec10359,0xa61a,0x11d0,0x8d,0xd4,0x00,0xc0,0x4f,0xc3,0x35,0x8c);
#endif


typedef struct _MSNdis_LinkSpeed
{
    // 
    ULONG NdisLinkSpeed;
    #define MSNdis_LinkSpeed_NdisLinkSpeed_SIZE sizeof(ULONG)
    #define MSNdis_LinkSpeed_NdisLinkSpeed_ID 1

} MSNdis_LinkSpeed, *PMSNdis_LinkSpeed;

#define MSNdis_LinkSpeed_SIZE (FIELD_OFFSET(MSNdis_LinkSpeed, NdisLinkSpeed) + MSNdis_LinkSpeed_NdisLinkSpeed_SIZE)

// MSNdis_TransmitBufferSpace - MSNdis_TransmitBufferSpace
#define MSNdis_TransmitBufferSpaceGuid \
    { 0x5ec1035a,0xa61a,0x11d0, { 0x8d,0xd4,0x00,0xc0,0x4f,0xc3,0x35,0x8c } }

#if ! (defined(MIDL_PASS))
DEFINE_GUID(MSNdis_TransmitBufferSpace_GUID, \
            0x5ec1035a,0xa61a,0x11d0,0x8d,0xd4,0x00,0xc0,0x4f,0xc3,0x35,0x8c);
#endif


typedef struct _MSNdis_TransmitBufferSpace
{
    // 
    ULONG NdisTransmitBufferSpace;
    #define MSNdis_TransmitBufferSpace_NdisTransmitBufferSpace_SIZE sizeof(ULONG)
    #define MSNdis_TransmitBufferSpace_NdisTransmitBufferSpace_ID 1

} MSNdis_TransmitBufferSpace, *PMSNdis_TransmitBufferSpace;

#define MSNdis_TransmitBufferSpace_SIZE (FIELD_OFFSET(MSNdis_TransmitBufferSpace, NdisTransmitBufferSpace) + MSNdis_TransmitBufferSpace_NdisTransmitBufferSpace_SIZE)

// MSNdis_ReceiveBufferSpace - MSNdis_ReceiveBufferSpace
#define MSNdis_ReceiveBufferSpaceGuid \
    { 0x5ec1035b,0xa61a,0x11d0, { 0x8d,0xd4,0x00,0xc0,0x4f,0xc3,0x35,0x8c } }

#if ! (defined(MIDL_PASS))
DEFINE_GUID(MSNdis_ReceiveBufferSpace_GUID, \
            0x5ec1035b,0xa61a,0x11d0,0x8d,0xd4,0x00,0xc0,0x4f,0xc3,0x35,0x8c);
#endif


typedef struct _MSNdis_ReceiveBufferSpace
{
    // 
    ULONG NdisReceiveBufferSpace;
    #define MSNdis_ReceiveBufferSpace_NdisReceiveBufferSpace_SIZE sizeof(ULONG)
    #define MSNdis_ReceiveBufferSpace_NdisReceiveBufferSpace_ID 1

} MSNdis_ReceiveBufferSpace, *PMSNdis_ReceiveBufferSpace;

#define MSNdis_ReceiveBufferSpace_SIZE (FIELD_OFFSET(MSNdis_ReceiveBufferSpace, NdisReceiveBufferSpace) + MSNdis_ReceiveBufferSpace_NdisReceiveBufferSpace_SIZE)

// MSNdis_TransmitBlockSize - MSNdis_TransmitBlockSize
#define MSNdis_TransmitBlockSizeGuid \
    { 0x5ec1035c,0xa61a,0x11d0, { 0x8d,0xd4,0x00,0xc0,0x4f,0xc3,0x35,0x8c } }

#if ! (defined(MIDL_PASS))
DEFINE_GUID(MSNdis_TransmitBlockSize_GUID, \
            0x5ec1035c,0xa61a,0x11d0,0x8d,0xd4,0x00,0xc0,0x4f,0xc3,0x35,0x8c);
#endif


typedef struct _MSNdis_TransmitBlockSize
{
    // 
    ULONG NdisTransmitBlockSize;
    #define MSNdis_TransmitBlockSize_NdisTransmitBlockSize_SIZE sizeof(ULONG)
    #define MSNdis_TransmitBlockSize_NdisTransmitBlockSize_ID 1

} MSNdis_TransmitBlockSize, *PMSNdis_TransmitBlockSize;

#define MSNdis_TransmitBlockSize_SIZE (FIELD_OFFSET(MSNdis_TransmitBlockSize, NdisTransmitBlockSize) + MSNdis_TransmitBlockSize_NdisTransmitBlockSize_SIZE)

// MSNdis_ReceiveBlockSize - MSNdis_ReceiveBlockSize
#define MSNdis_ReceiveBlockSizeGuid \
    { 0x5ec1035d,0xa61a,0x11d0, { 0x8d,0xd4,0x00,0xc0,0x4f,0xc3,0x35,0x8c } }

#if ! (defined(MIDL_PASS))
DEFINE_GUID(MSNdis_ReceiveBlockSize_GUID, \
            0x5ec1035d,0xa61a,0x11d0,0x8d,0xd4,0x00,0xc0,0x4f,0xc3,0x35,0x8c);
#endif


typedef struct _MSNdis_ReceiveBlockSize
{
    // 
    ULONG NdisReceiveBlockSize;
    #define MSNdis_ReceiveBlockSize_NdisReceiveBlockSize_SIZE sizeof(ULONG)
    #define MSNdis_ReceiveBlockSize_NdisReceiveBlockSize_ID 1

} MSNdis_ReceiveBlockSize, *PMSNdis_ReceiveBlockSize;

#define MSNdis_ReceiveBlockSize_SIZE (FIELD_OFFSET(MSNdis_ReceiveBlockSize, NdisReceiveBlockSize) + MSNdis_ReceiveBlockSize_NdisReceiveBlockSize_SIZE)

// MSNdis_VendorID - MSNdis_VendorID
#define MSNdis_VendorIDGuid \
    { 0x5ec1035e,0xa61a,0x11d0, { 0x8d,0xd4,0x00,0xc0,0x4f,0xc3,0x35,0x8c } }

#if ! (defined(MIDL_PASS))
DEFINE_GUID(MSNdis_VendorID_GUID, \
            0x5ec1035e,0xa61a,0x11d0,0x8d,0xd4,0x00,0xc0,0x4f,0xc3,0x35,0x8c);
#endif


typedef struct _MSNdis_VendorID
{
    // 
    ULONG NdisVendorID;
    #define MSNdis_VendorID_NdisVendorID_SIZE sizeof(ULONG)
    #define MSNdis_VendorID_NdisVendorID_ID 1

} MSNdis_VendorID, *PMSNdis_VendorID;

#define MSNdis_VendorID_SIZE (FIELD_OFFSET(MSNdis_VendorID, NdisVendorID) + MSNdis_VendorID_NdisVendorID_SIZE)

// MSNdis_VendorDescription - MSNdis_VendorDescription
#define MSNdis_VendorDescriptionGuid \
    { 0x5ec1035f,0xa61a,0x11d0, { 0x8d,0xd4,0x00,0xc0,0x4f,0xc3,0x35,0x8c } }

#if ! (defined(MIDL_PASS))
DEFINE_GUID(MSNdis_VendorDescription_GUID, \
            0x5ec1035f,0xa61a,0x11d0,0x8d,0xd4,0x00,0xc0,0x4f,0xc3,0x35,0x8c);
#endif


typedef struct _MSNdis_VendorDescription
{
    // 
    CHAR VariableData[1];
    #define MSNdis_VendorDescription_NdisVendorDescription_ID 1

} MSNdis_VendorDescription, *PMSNdis_VendorDescription;

// MSNdis_CurrentPacketFilter - MSNdis_CurrentPacketFilter
#define MSNdis_CurrentPacketFilterGuid \
    { 0x5ec10360,0xa61a,0x11d0, { 0x8d,0xd4,0x00,0xc0,0x4f,0xc3,0x35,0x8c } }

#if ! (defined(MIDL_PASS))
DEFINE_GUID(MSNdis_CurrentPacketFilter_GUID, \
            0x5ec10360,0xa61a,0x11d0,0x8d,0xd4,0x00,0xc0,0x4f,0xc3,0x35,0x8c);
#endif


typedef struct _MSNdis_CurrentPacketFilter
{
    // 
    ULONG NdisCurrentPacketFilter;
    #define MSNdis_CurrentPacketFilter_NdisCurrentPacketFilter_SIZE sizeof(ULONG)
    #define MSNdis_CurrentPacketFilter_NdisCurrentPacketFilter_ID 1

} MSNdis_CurrentPacketFilter, *PMSNdis_CurrentPacketFilter;

#define MSNdis_CurrentPacketFilter_SIZE (FIELD_OFFSET(MSNdis_CurrentPacketFilter, NdisCurrentPacketFilter) + MSNdis_CurrentPacketFilter_NdisCurrentPacketFilter_SIZE)

// MSNdis_CurrentLookahead - MSNdis_CurrentLookahead
#define MSNdis_CurrentLookaheadGuid \
    { 0x5ec10361,0xa61a,0x11d0, { 0x8d,0xd4,0x00,0xc0,0x4f,0xc3,0x35,0x8c } }

#if ! (defined(MIDL_PASS))
DEFINE_GUID(MSNdis_CurrentLookahead_GUID, \
            0x5ec10361,0xa61a,0x11d0,0x8d,0xd4,0x00,0xc0,0x4f,0xc3,0x35,0x8c);
#endif


typedef struct _MSNdis_CurrentLookahead
{
    // 
    ULONG NdisCurrentLookahead;
    #define MSNdis_CurrentLookahead_NdisCurrentLookahead_SIZE sizeof(ULONG)
    #define MSNdis_CurrentLookahead_NdisCurrentLookahead_ID 1

} MSNdis_CurrentLookahead, *PMSNdis_CurrentLookahead;

#define MSNdis_CurrentLookahead_SIZE (FIELD_OFFSET(MSNdis_CurrentLookahead, NdisCurrentLookahead) + MSNdis_CurrentLookahead_NdisCurrentLookahead_SIZE)

// MSNdis_DriverVersion - MSNdis_DriverVersion
#define MSNdis_DriverVersionGuid \
    { 0x5ec10362,0xa61a,0x11d0, { 0x8d,0xd4,0x00,0xc0,0x4f,0xc3,0x35,0x8c } }

#if ! (defined(MIDL_PASS))
DEFINE_GUID(MSNdis_DriverVersion_GUID, \
            0x5ec10362,0xa61a,0x11d0,0x8d,0xd4,0x00,0xc0,0x4f,0xc3,0x35,0x8c);
#endif


typedef struct _MSNdis_DriverVersion
{
    // 
    USHORT NdisDriverVersion;
    #define MSNdis_DriverVersion_NdisDriverVersion_SIZE sizeof(USHORT)
    #define MSNdis_DriverVersion_NdisDriverVersion_ID 1

} MSNdis_DriverVersion, *PMSNdis_DriverVersion;

#define MSNdis_DriverVersion_SIZE (FIELD_OFFSET(MSNdis_DriverVersion, NdisDriverVersion) + MSNdis_DriverVersion_NdisDriverVersion_SIZE)

// MSNdis_MaximumTotalSize - MSNdis_MaximumTotalSize
#define MSNdis_MaximumTotalSizeGuid \
    { 0x5ec10363,0xa61a,0x11d0, { 0x8d,0xd4,0x00,0xc0,0x4f,0xc3,0x35,0x8c } }

#if ! (defined(MIDL_PASS))
DEFINE_GUID(MSNdis_MaximumTotalSize_GUID, \
            0x5ec10363,0xa61a,0x11d0,0x8d,0xd4,0x00,0xc0,0x4f,0xc3,0x35,0x8c);
#endif


typedef struct _MSNdis_MaximumTotalSize
{
    // 
    ULONG NdisMaximumTotalSize;
    #define MSNdis_MaximumTotalSize_NdisMaximumTotalSize_SIZE sizeof(ULONG)
    #define MSNdis_MaximumTotalSize_NdisMaximumTotalSize_ID 1

} MSNdis_MaximumTotalSize, *PMSNdis_MaximumTotalSize;

#define MSNdis_MaximumTotalSize_SIZE (FIELD_OFFSET(MSNdis_MaximumTotalSize, NdisMaximumTotalSize) + MSNdis_MaximumTotalSize_NdisMaximumTotalSize_SIZE)

// MSNdis_MacOptions - MSNdis_MacOptions
#define MSNdis_MacOptionsGuid \
    { 0x5ec10365,0xa61a,0x11d0, { 0x8d,0xd4,0x00,0xc0,0x4f,0xc3,0x35,0x8c } }

#if ! (defined(MIDL_PASS))
DEFINE_GUID(MSNdis_MacOptions_GUID, \
            0x5ec10365,0xa61a,0x11d0,0x8d,0xd4,0x00,0xc0,0x4f,0xc3,0x35,0x8c);
#endif


typedef struct _MSNdis_MacOptions
{
    // 
    ULONG NdisMacOptions;
    #define MSNdis_MacOptions_NdisMacOptions_SIZE sizeof(ULONG)
    #define MSNdis_MacOptions_NdisMacOptions_ID 1

} MSNdis_MacOptions, *PMSNdis_MacOptions;

#define MSNdis_MacOptions_SIZE (FIELD_OFFSET(MSNdis_MacOptions, NdisMacOptions) + MSNdis_MacOptions_NdisMacOptions_SIZE)

// MSNdis_MediaConnectStatus - MSNdis_MediaConnectStatus
#define MSNdis_MediaConnectStatusGuid \
    { 0x5ec10366,0xa61a,0x11d0, { 0x8d,0xd4,0x00,0xc0,0x4f,0xc3,0x35,0x8c } }

#if ! (defined(MIDL_PASS))
DEFINE_GUID(MSNdis_MediaConnectStatus_GUID, \
            0x5ec10366,0xa61a,0x11d0,0x8d,0xd4,0x00,0xc0,0x4f,0xc3,0x35,0x8c);
#endif


typedef struct _MSNdis_MediaConnectStatus
{
    // 
    ULONG NdisMediaConnectStatus;
    #define MSNdis_MediaConnectStatus_NdisMediaConnectStatus_SIZE sizeof(ULONG)
    #define MSNdis_MediaConnectStatus_NdisMediaConnectStatus_ID 1

} MSNdis_MediaConnectStatus, *PMSNdis_MediaConnectStatus;

#define MSNdis_MediaConnectStatus_SIZE (FIELD_OFFSET(MSNdis_MediaConnectStatus, NdisMediaConnectStatus) + MSNdis_MediaConnectStatus_NdisMediaConnectStatus_SIZE)

// MSNdis_MaximumSendPackets - MSNdis_MaximumSendPackets
#define MSNdis_MaximumSendPacketsGuid \
    { 0x5ec10367,0xa61a,0x11d0, { 0x8d,0xd4,0x00,0xc0,0x4f,0xc3,0x35,0x8c } }

#if ! (defined(MIDL_PASS))
DEFINE_GUID(MSNdis_MaximumSendPackets_GUID, \
            0x5ec10367,0xa61a,0x11d0,0x8d,0xd4,0x00,0xc0,0x4f,0xc3,0x35,0x8c);
#endif


typedef struct _MSNdis_MaximumSendPackets
{
    // 
    ULONG NdisMaximumSendPackets;
    #define MSNdis_MaximumSendPackets_NdisMaximumSendPackets_SIZE sizeof(ULONG)
    #define MSNdis_MaximumSendPackets_NdisMaximumSendPackets_ID 1

} MSNdis_MaximumSendPackets, *PMSNdis_MaximumSendPackets;

#define MSNdis_MaximumSendPackets_SIZE (FIELD_OFFSET(MSNdis_MaximumSendPackets, NdisMaximumSendPackets) + MSNdis_MaximumSendPackets_NdisMaximumSendPackets_SIZE)

// MSNdis_VendorDriverVersion - MSNdis_VendorDriverVersion
#define MSNdis_VendorDriverVersionGuid \
    { 0x447956f9,0xa61b,0x11d0, { 0x8d,0xd4,0x00,0xc0,0x4f,0xc3,0x35,0x8c } }

#if ! (defined(MIDL_PASS))
DEFINE_GUID(MSNdis_VendorDriverVersion_GUID, \
            0x447956f9,0xa61b,0x11d0,0x8d,0xd4,0x00,0xc0,0x4f,0xc3,0x35,0x8c);
#endif


typedef struct _MSNdis_VendorDriverVersion
{
    // 
    ULONG NdisVendorDriverVersion;
    #define MSNdis_VendorDriverVersion_NdisVendorDriverVersion_SIZE sizeof(ULONG)
    #define MSNdis_VendorDriverVersion_NdisVendorDriverVersion_ID 1

} MSNdis_VendorDriverVersion, *PMSNdis_VendorDriverVersion;

#define MSNdis_VendorDriverVersion_SIZE (FIELD_OFFSET(MSNdis_VendorDriverVersion, NdisVendorDriverVersion) + MSNdis_VendorDriverVersion_NdisVendorDriverVersion_SIZE)

// MSNdis_VlanIdentifier - MSNdis_VlanIdentifier
#define MSNdis_VlanIdentifierGuid \
    { 0x765dc702,0xc5e8,0x4b67, { 0x84,0x3b,0x3f,0x5a,0x4f,0xf2,0x64,0x8b } }

#if ! (defined(MIDL_PASS))
DEFINE_GUID(MSNdis_VlanIdentifier_GUID, \
            0x765dc702,0xc5e8,0x4b67,0x84,0x3b,0x3f,0x5a,0x4f,0xf2,0x64,0x8b);
#endif


typedef struct _MSNdis_VlanIdentifier
{
    // 
    ULONG NdisVlanId;
    #define MSNdis_VlanIdentifier_NdisVlanId_SIZE sizeof(ULONG)
    #define MSNdis_VlanIdentifier_NdisVlanId_ID 1

} MSNdis_VlanIdentifier, *PMSNdis_VlanIdentifier;

#define MSNdis_VlanIdentifier_SIZE (FIELD_OFFSET(MSNdis_VlanIdentifier, NdisVlanId) + MSNdis_VlanIdentifier_NdisVlanId_SIZE)

// MSNdis_PhysicalMediumType - MSNdis_PhysicalMediumType
#define MSNdis_PhysicalMediumTypeGuid \
    { 0x418ca16d,0x3937,0x4208, { 0x94,0x0a,0xec,0x61,0x96,0x27,0x80,0x85 } }

#if ! (defined(MIDL_PASS))
DEFINE_GUID(MSNdis_PhysicalMediumType_GUID, \
            0x418ca16d,0x3937,0x4208,0x94,0x0a,0xec,0x61,0x96,0x27,0x80,0x85);
#endif


typedef struct _MSNdis_PhysicalMediumType
{
    // 
    ULONG NdisPhysicalMediumType;
    #define MSNdis_PhysicalMediumType_NdisPhysicalMediumType_SIZE sizeof(ULONG)
    #define MSNdis_PhysicalMediumType_NdisPhysicalMediumType_ID 1

} MSNdis_PhysicalMediumType, *PMSNdis_PhysicalMediumType;

#define MSNdis_PhysicalMediumType_SIZE (FIELD_OFFSET(MSNdis_PhysicalMediumType, NdisPhysicalMediumType) + MSNdis_PhysicalMediumType_NdisPhysicalMediumType_SIZE)

// MSNdis_TransmitsOk - MSNdis_TransmitsOk
#define MSNdis_TransmitsOkGuid \
    { 0x447956fa,0xa61b,0x11d0, { 0x8d,0xd4,0x00,0xc0,0x4f,0xc3,0x35,0x8c } }

#if ! (defined(MIDL_PASS))
DEFINE_GUID(MSNdis_TransmitsOk_GUID, \
            0x447956fa,0xa61b,0x11d0,0x8d,0xd4,0x00,0xc0,0x4f,0xc3,0x35,0x8c);
#endif


typedef struct _MSNdis_TransmitsOk
{
    // 
    ULONGLONG NdisTransmitsOk;
    #define MSNdis_TransmitsOk_NdisTransmitsOk_SIZE sizeof(ULONGLONG)
    #define MSNdis_TransmitsOk_NdisTransmitsOk_ID 1

} MSNdis_TransmitsOk, *PMSNdis_TransmitsOk;

#define MSNdis_TransmitsOk_SIZE (FIELD_OFFSET(MSNdis_TransmitsOk, NdisTransmitsOk) + MSNdis_TransmitsOk_NdisTransmitsOk_SIZE)

// MSNdis_ReceivesOk - MSNdis_ReceivesOk
#define MSNdis_ReceivesOkGuid \
    { 0x447956fb,0xa61b,0x11d0, { 0x8d,0xd4,0x00,0xc0,0x4f,0xc3,0x35,0x8c } }

#if ! (defined(MIDL_PASS))
DEFINE_GUID(MSNdis_ReceivesOk_GUID, \
            0x447956fb,0xa61b,0x11d0,0x8d,0xd4,0x00,0xc0,0x4f,0xc3,0x35,0x8c);
#endif


typedef struct _MSNdis_ReceivesOk
{
    // 
    ULONGLONG NdisReceivesOk;
    #define MSNdis_ReceivesOk_NdisReceivesOk_SIZE sizeof(ULONGLONG)
    #define MSNdis_ReceivesOk_NdisReceivesOk_ID 1

} MSNdis_ReceivesOk, *PMSNdis_ReceivesOk;

#define MSNdis_ReceivesOk_SIZE (FIELD_OFFSET(MSNdis_ReceivesOk, NdisReceivesOk) + MSNdis_ReceivesOk_NdisReceivesOk_SIZE)

// MSNdis_TransmitsError - MSNdis_TransmitsError
#define MSNdis_TransmitsErrorGuid \
    { 0x447956fc,0xa61b,0x11d0, { 0x8d,0xd4,0x00,0xc0,0x4f,0xc3,0x35,0x8c } }

#if ! (defined(MIDL_PASS))
DEFINE_GUID(MSNdis_TransmitsError_GUID, \
            0x447956fc,0xa61b,0x11d0,0x8d,0xd4,0x00,0xc0,0x4f,0xc3,0x35,0x8c);
#endif


typedef struct _MSNdis_TransmitsError
{
    // 
    ULONG NdisTransmitsError;
    #define MSNdis_TransmitsError_NdisTransmitsError_SIZE sizeof(ULONG)
    #define MSNdis_TransmitsError_NdisTransmitsError_ID 1

} MSNdis_TransmitsError, *PMSNdis_TransmitsError;

#define MSNdis_TransmitsError_SIZE (FIELD_OFFSET(MSNdis_TransmitsError, NdisTransmitsError) + MSNdis_TransmitsError_NdisTransmitsError_SIZE)

// MSNdis_ReceiveError - MSNdis_ReceiveError
#define MSNdis_ReceiveErrorGuid \
    { 0x447956fd,0xa61b,0x11d0, { 0x8d,0xd4,0x00,0xc0,0x4f,0xc3,0x35,0x8c } }

#if ! (defined(MIDL_PASS))
DEFINE_GUID(MSNdis_ReceiveError_GUID, \
            0x447956fd,0xa61b,0x11d0,0x8d,0xd4,0x00,0xc0,0x4f,0xc3,0x35,0x8c);
#endif


typedef struct _MSNdis_ReceiveError
{
    // 
    ULONG NdisReceiveError;
    #define MSNdis_ReceiveError_NdisReceiveError_SIZE sizeof(ULONG)
    #define MSNdis_ReceiveError_NdisReceiveError_ID 1

} MSNdis_ReceiveError, *PMSNdis_ReceiveError;

#define MSNdis_ReceiveError_SIZE (FIELD_OFFSET(MSNdis_ReceiveError, NdisReceiveError) + MSNdis_ReceiveError_NdisReceiveError_SIZE)

// MSNdis_ReceiveNoBuffer - MSNdis_ReceiveNoBuffer
#define MSNdis_ReceiveNoBufferGuid \
    { 0x447956fe,0xa61b,0x11d0, { 0x8d,0xd4,0x00,0xc0,0x4f,0xc3,0x35,0x8c } }

#if ! (defined(MIDL_PASS))
DEFINE_GUID(MSNdis_ReceiveNoBuffer_GUID, \
            0x447956fe,0xa61b,0x11d0,0x8d,0xd4,0x00,0xc0,0x4f,0xc3,0x35,0x8c);
#endif


typedef struct _MSNdis_ReceiveNoBuffer
{
    // 
    ULONG NdisReceiveNoBuffer;
    #define MSNdis_ReceiveNoBuffer_NdisReceiveNoBuffer_SIZE sizeof(ULONG)
    #define MSNdis_ReceiveNoBuffer_NdisReceiveNoBuffer_ID 1

} MSNdis_ReceiveNoBuffer, *PMSNdis_ReceiveNoBuffer;

#define MSNdis_ReceiveNoBuffer_SIZE (FIELD_OFFSET(MSNdis_ReceiveNoBuffer, NdisReceiveNoBuffer) + MSNdis_ReceiveNoBuffer_NdisReceiveNoBuffer_SIZE)

// MSNdis_CoHardwareStatus - MSNdis_CoHardwareStatus
#define MSNdis_CoHardwareStatusGuid \
    { 0x791ad192,0xe35c,0x11d0, { 0x96,0x92,0x00,0xc0,0x4f,0xc3,0x35,0x8c } }

#if ! (defined(MIDL_PASS))
DEFINE_GUID(MSNdis_CoHardwareStatus_GUID, \
            0x791ad192,0xe35c,0x11d0,0x96,0x92,0x00,0xc0,0x4f,0xc3,0x35,0x8c);
#endif


typedef struct _MSNdis_CoHardwareStatus
{
    // 
    ULONG NdisCoHardwareStatus;
    #define MSNdis_CoHardwareStatus_NdisCoHardwareStatus_SIZE sizeof(ULONG)
    #define MSNdis_CoHardwareStatus_NdisCoHardwareStatus_ID 1

} MSNdis_CoHardwareStatus, *PMSNdis_CoHardwareStatus;

#define MSNdis_CoHardwareStatus_SIZE (FIELD_OFFSET(MSNdis_CoHardwareStatus, NdisCoHardwareStatus) + MSNdis_CoHardwareStatus_NdisCoHardwareStatus_SIZE)

// MSNdis_CoMediaSupported - MSNdis_CoMediaSupported
#define MSNdis_CoMediaSupportedGuid \
    { 0x791ad193,0xe35c,0x11d0, { 0x96,0x92,0x00,0xc0,0x4f,0xc3,0x35,0x8c } }

#if ! (defined(MIDL_PASS))
DEFINE_GUID(MSNdis_CoMediaSupported_GUID, \
            0x791ad193,0xe35c,0x11d0,0x96,0x92,0x00,0xc0,0x4f,0xc3,0x35,0x8c);
#endif


typedef struct _MSNdis_CoMediaSupported
{
    // 
    ULONG NumberElements;
    #define MSNdis_CoMediaSupported_NumberElements_SIZE sizeof(ULONG)
    #define MSNdis_CoMediaSupported_NumberElements_ID 1

    // 
    ULONG NdisCoMediaSupported[1];
    #define MSNdis_CoMediaSupported_NdisCoMediaSupported_ID 2

} MSNdis_CoMediaSupported, *PMSNdis_CoMediaSupported;

// MSNdis_CoMediaInUse - MSNdis_CoMediaInUse
#define MSNdis_CoMediaInUseGuid \
    { 0x791ad194,0xe35c,0x11d0, { 0x96,0x92,0x00,0xc0,0x4f,0xc3,0x35,0x8c } }

#if ! (defined(MIDL_PASS))
DEFINE_GUID(MSNdis_CoMediaInUse_GUID, \
            0x791ad194,0xe35c,0x11d0,0x96,0x92,0x00,0xc0,0x4f,0xc3,0x35,0x8c);
#endif


typedef struct _MSNdis_CoMediaInUse
{
    // 
    ULONG NumberElements;
    #define MSNdis_CoMediaInUse_NumberElements_SIZE sizeof(ULONG)
    #define MSNdis_CoMediaInUse_NumberElements_ID 1

    // 
    ULONG NdisCoMediaInUse[1];
    #define MSNdis_CoMediaInUse_NdisCoMediaInUse_ID 2

} MSNdis_CoMediaInUse, *PMSNdis_CoMediaInUse;

// MSNdis_CoLinkSpeed - MSNdis_CoLinkSpeed
#define MSNdis_CoLinkSpeedGuid \
    { 0x791ad195,0xe35c,0x11d0, { 0x96,0x92,0x00,0xc0,0x4f,0xc3,0x35,0x8c } }

#if ! (defined(MIDL_PASS))
DEFINE_GUID(MSNdis_CoLinkSpeed_GUID, \
            0x791ad195,0xe35c,0x11d0,0x96,0x92,0x00,0xc0,0x4f,0xc3,0x35,0x8c);
#endif


typedef struct _MSNdis_CoLinkSpeed
{
    // 
    MSNdis_NetworkLinkSpeed NdisCoLinkSpeed;
    #define MSNdis_CoLinkSpeed_NdisCoLinkSpeed_SIZE sizeof(MSNdis_NetworkLinkSpeed)
    #define MSNdis_CoLinkSpeed_NdisCoLinkSpeed_ID 1

} MSNdis_CoLinkSpeed, *PMSNdis_CoLinkSpeed;

#define MSNdis_CoLinkSpeed_SIZE (FIELD_OFFSET(MSNdis_CoLinkSpeed, NdisCoLinkSpeed) + MSNdis_CoLinkSpeed_NdisCoLinkSpeed_SIZE)

// MSNdis_CoVendorId - MSNdis_CoVendorId
#define MSNdis_CoVendorIdGuid \
    { 0x791ad196,0xe35c,0x11d0, { 0x96,0x92,0x00,0xc0,0x4f,0xc3,0x35,0x8c } }

#if ! (defined(MIDL_PASS))
DEFINE_GUID(MSNdis_CoVendorId_GUID, \
            0x791ad196,0xe35c,0x11d0,0x96,0x92,0x00,0xc0,0x4f,0xc3,0x35,0x8c);
#endif


typedef struct _MSNdis_CoVendorId
{
    // 
    ULONG NdisCoVendorID;
    #define MSNdis_CoVendorId_NdisCoVendorID_SIZE sizeof(ULONG)
    #define MSNdis_CoVendorId_NdisCoVendorID_ID 1

} MSNdis_CoVendorId, *PMSNdis_CoVendorId;

#define MSNdis_CoVendorId_SIZE (FIELD_OFFSET(MSNdis_CoVendorId, NdisCoVendorID) + MSNdis_CoVendorId_NdisCoVendorID_SIZE)

// MSNdis_CoVendorDescription - MSNdis_CoVendorDescription
#define MSNdis_CoVendorDescriptionGuid \
    { 0x791ad197,0xe35c,0x11d0, { 0x96,0x92,0x00,0xc0,0x4f,0xc3,0x35,0x8c } }

#if ! (defined(MIDL_PASS))
DEFINE_GUID(MSNdis_CoVendorDescription_GUID, \
            0x791ad197,0xe35c,0x11d0,0x96,0x92,0x00,0xc0,0x4f,0xc3,0x35,0x8c);
#endif


typedef struct _MSNdis_CoVendorDescription
{
    // 
    CHAR VariableData[1];
    #define MSNdis_CoVendorDescription_NdisCoVendorDescription_ID 1

} MSNdis_CoVendorDescription, *PMSNdis_CoVendorDescription;

// MSNdis_CoDriverVersion - MSNdis_CoDriverVersion
#define MSNdis_CoDriverVersionGuid \
    { 0x791ad198,0xe35c,0x11d0, { 0x96,0x92,0x00,0xc0,0x4f,0xc3,0x35,0x8c } }

#if ! (defined(MIDL_PASS))
DEFINE_GUID(MSNdis_CoDriverVersion_GUID, \
            0x791ad198,0xe35c,0x11d0,0x96,0x92,0x00,0xc0,0x4f,0xc3,0x35,0x8c);
#endif


typedef struct _MSNdis_CoDriverVersion
{
    // 
    USHORT NdisCoDriverVersion;
    #define MSNdis_CoDriverVersion_NdisCoDriverVersion_SIZE sizeof(USHORT)
    #define MSNdis_CoDriverVersion_NdisCoDriverVersion_ID 1

} MSNdis_CoDriverVersion, *PMSNdis_CoDriverVersion;

#define MSNdis_CoDriverVersion_SIZE (FIELD_OFFSET(MSNdis_CoDriverVersion, NdisCoDriverVersion) + MSNdis_CoDriverVersion_NdisCoDriverVersion_SIZE)

// MSNdis_CoMacOptions - MSNdis_CoMacOptions
#define MSNdis_CoMacOptionsGuid \
    { 0x791ad19a,0xe35c,0x11d0, { 0x96,0x92,0x00,0xc0,0x4f,0xc3,0x35,0x8c } }

#if ! (defined(MIDL_PASS))
DEFINE_GUID(MSNdis_CoMacOptions_GUID, \
            0x791ad19a,0xe35c,0x11d0,0x96,0x92,0x00,0xc0,0x4f,0xc3,0x35,0x8c);
#endif


typedef struct _MSNdis_CoMacOptions
{
    // 
    ULONG NdisCoMacOptions;
    #define MSNdis_CoMacOptions_NdisCoMacOptions_SIZE sizeof(ULONG)
    #define MSNdis_CoMacOptions_NdisCoMacOptions_ID 1

} MSNdis_CoMacOptions, *PMSNdis_CoMacOptions;

#define MSNdis_CoMacOptions_SIZE (FIELD_OFFSET(MSNdis_CoMacOptions, NdisCoMacOptions) + MSNdis_CoMacOptions_NdisCoMacOptions_SIZE)

// MSNdis_CoMediaConnectStatus - MSNdis_CoMediaConnectStatus
#define MSNdis_CoMediaConnectStatusGuid \
    { 0x791ad19b,0xe35c,0x11d0, { 0x96,0x92,0x00,0xc0,0x4f,0xc3,0x35,0x8c } }

#if ! (defined(MIDL_PASS))
DEFINE_GUID(MSNdis_CoMediaConnectStatus_GUID, \
            0x791ad19b,0xe35c,0x11d0,0x96,0x92,0x00,0xc0,0x4f,0xc3,0x35,0x8c);
#endif


typedef struct _MSNdis_CoMediaConnectStatus
{
    // 
    ULONG NdisCoMediaConnectStatus;
    #define MSNdis_CoMediaConnectStatus_NdisCoMediaConnectStatus_SIZE sizeof(ULONG)
    #define MSNdis_CoMediaConnectStatus_NdisCoMediaConnectStatus_ID 1

} MSNdis_CoMediaConnectStatus, *PMSNdis_CoMediaConnectStatus;

#define MSNdis_CoMediaConnectStatus_SIZE (FIELD_OFFSET(MSNdis_CoMediaConnectStatus, NdisCoMediaConnectStatus) + MSNdis_CoMediaConnectStatus_NdisCoMediaConnectStatus_SIZE)

// MSNdis_CoVendorDriverVersion - MSNdis_CoVendorDriverVersion
#define MSNdis_CoVendorDriverVersionGuid \
    { 0x791ad19c,0xe35c,0x11d0, { 0x96,0x92,0x00,0xc0,0x4f,0xc3,0x35,0x8c } }

#if ! (defined(MIDL_PASS))
DEFINE_GUID(MSNdis_CoVendorDriverVersion_GUID, \
            0x791ad19c,0xe35c,0x11d0,0x96,0x92,0x00,0xc0,0x4f,0xc3,0x35,0x8c);
#endif


typedef struct _MSNdis_CoVendorDriverVersion
{
    // 
    ULONG NdisCoVendorDriverVersion;
    #define MSNdis_CoVendorDriverVersion_NdisCoVendorDriverVersion_SIZE sizeof(ULONG)
    #define MSNdis_CoVendorDriverVersion_NdisCoVendorDriverVersion_ID 1

} MSNdis_CoVendorDriverVersion, *PMSNdis_CoVendorDriverVersion;

#define MSNdis_CoVendorDriverVersion_SIZE (FIELD_OFFSET(MSNdis_CoVendorDriverVersion, NdisCoVendorDriverVersion) + MSNdis_CoVendorDriverVersion_NdisCoVendorDriverVersion_SIZE)

// MSNdis_CoMinimumLinkSpeed - MSNdis_CoMinimumLinkSpeed
#define MSNdis_CoMinimumLinkSpeedGuid \
    { 0x791ad19d,0xe35c,0x11d0, { 0x96,0x92,0x00,0xc0,0x4f,0xc3,0x35,0x8c } }

#if ! (defined(MIDL_PASS))
DEFINE_GUID(MSNdis_CoMinimumLinkSpeed_GUID, \
            0x791ad19d,0xe35c,0x11d0,0x96,0x92,0x00,0xc0,0x4f,0xc3,0x35,0x8c);
#endif


typedef struct _MSNdis_CoMinimumLinkSpeed
{
    // 
    MSNdis_NetworkLinkSpeed NdisCoMinimumLinkSpeed;
    #define MSNdis_CoMinimumLinkSpeed_NdisCoMinimumLinkSpeed_SIZE sizeof(MSNdis_NetworkLinkSpeed)
    #define MSNdis_CoMinimumLinkSpeed_NdisCoMinimumLinkSpeed_ID 1

} MSNdis_CoMinimumLinkSpeed, *PMSNdis_CoMinimumLinkSpeed;

#define MSNdis_CoMinimumLinkSpeed_SIZE (FIELD_OFFSET(MSNdis_CoMinimumLinkSpeed, NdisCoMinimumLinkSpeed) + MSNdis_CoMinimumLinkSpeed_NdisCoMinimumLinkSpeed_SIZE)

// MSNdis_CoTransmitPdusOk - MSNdis_CoTransmitPdusOk
#define MSNdis_CoTransmitPdusOkGuid \
    { 0x0a214805,0xe35f,0x11d0, { 0x96,0x92,0x00,0xc0,0x4f,0xc3,0x35,0x8c } }

#if ! (defined(MIDL_PASS))
DEFINE_GUID(MSNdis_CoTransmitPdusOk_GUID, \
            0x0a214805,0xe35f,0x11d0,0x96,0x92,0x00,0xc0,0x4f,0xc3,0x35,0x8c);
#endif


typedef struct _MSNdis_CoTransmitPdusOk
{
    // 
    ULONGLONG NdisCoTransmitPdusOk;
    #define MSNdis_CoTransmitPdusOk_NdisCoTransmitPdusOk_SIZE sizeof(ULONGLONG)
    #define MSNdis_CoTransmitPdusOk_NdisCoTransmitPdusOk_ID 1

} MSNdis_CoTransmitPdusOk, *PMSNdis_CoTransmitPdusOk;

#define MSNdis_CoTransmitPdusOk_SIZE (FIELD_OFFSET(MSNdis_CoTransmitPdusOk, NdisCoTransmitPdusOk) + MSNdis_CoTransmitPdusOk_NdisCoTransmitPdusOk_SIZE)

// MSNdis_CoReceivePdusOk - MSNdis_CoReceivePdusOk
#define MSNdis_CoReceivePdusOkGuid \
    { 0x0a214806,0xe35f,0x11d0, { 0x96,0x92,0x00,0xc0,0x4f,0xc3,0x35,0x8c } }

#if ! (defined(MIDL_PASS))
DEFINE_GUID(MSNdis_CoReceivePdusOk_GUID, \
            0x0a214806,0xe35f,0x11d0,0x96,0x92,0x00,0xc0,0x4f,0xc3,0x35,0x8c);
#endif


typedef struct _MSNdis_CoReceivePdusOk
{
    // 
    ULONGLONG NdisCoReceivePdusOk;
    #define MSNdis_CoReceivePdusOk_NdisCoReceivePdusOk_SIZE sizeof(ULONGLONG)
    #define MSNdis_CoReceivePdusOk_NdisCoReceivePdusOk_ID 1

} MSNdis_CoReceivePdusOk, *PMSNdis_CoReceivePdusOk;

#define MSNdis_CoReceivePdusOk_SIZE (FIELD_OFFSET(MSNdis_CoReceivePdusOk, NdisCoReceivePdusOk) + MSNdis_CoReceivePdusOk_NdisCoReceivePdusOk_SIZE)

// MSNdis_CoTransmitPduErrors - MSNdis_CoTransmitPduErrors
#define MSNdis_CoTransmitPduErrorsGuid \
    { 0x0a214807,0xe35f,0x11d0, { 0x96,0x92,0x00,0xc0,0x4f,0xc3,0x35,0x8c } }

#if ! (defined(MIDL_PASS))
DEFINE_GUID(MSNdis_CoTransmitPduErrors_GUID, \
            0x0a214807,0xe35f,0x11d0,0x96,0x92,0x00,0xc0,0x4f,0xc3,0x35,0x8c);
#endif


typedef struct _MSNdis_CoTransmitPduErrors
{
    // 
    ULONG NdisCoTransmitPduErrors;
    #define MSNdis_CoTransmitPduErrors_NdisCoTransmitPduErrors_SIZE sizeof(ULONG)
    #define MSNdis_CoTransmitPduErrors_NdisCoTransmitPduErrors_ID 1

} MSNdis_CoTransmitPduErrors, *PMSNdis_CoTransmitPduErrors;

#define MSNdis_CoTransmitPduErrors_SIZE (FIELD_OFFSET(MSNdis_CoTransmitPduErrors, NdisCoTransmitPduErrors) + MSNdis_CoTransmitPduErrors_NdisCoTransmitPduErrors_SIZE)

// MSNdis_CoReceivePduErrors - MSNdis_CoReceivePduErrors
#define MSNdis_CoReceivePduErrorsGuid \
    { 0x0a214808,0xe35f,0x11d0, { 0x96,0x92,0x00,0xc0,0x4f,0xc3,0x35,0x8c } }

#if ! (defined(MIDL_PASS))
DEFINE_GUID(MSNdis_CoReceivePduErrors_GUID, \
            0x0a214808,0xe35f,0x11d0,0x96,0x92,0x00,0xc0,0x4f,0xc3,0x35,0x8c);
#endif


typedef struct _MSNdis_CoReceivePduErrors
{
    // 
    ULONG NdisCoReceivePduErrors;
    #define MSNdis_CoReceivePduErrors_NdisCoReceivePduErrors_SIZE sizeof(ULONG)
    #define MSNdis_CoReceivePduErrors_NdisCoReceivePduErrors_ID 1

} MSNdis_CoReceivePduErrors, *PMSNdis_CoReceivePduErrors;

#define MSNdis_CoReceivePduErrors_SIZE (FIELD_OFFSET(MSNdis_CoReceivePduErrors, NdisCoReceivePduErrors) + MSNdis_CoReceivePduErrors_NdisCoReceivePduErrors_SIZE)

// MSNdis_CoReceivePdusNoBuffer - MSNdis_CoReceivePdusNoBuffer
#define MSNdis_CoReceivePdusNoBufferGuid \
    { 0x0a214809,0xe35f,0x11d0, { 0x96,0x92,0x00,0xc0,0x4f,0xc3,0x35,0x8c } }

#if ! (defined(MIDL_PASS))
DEFINE_GUID(MSNdis_CoReceivePdusNoBuffer_GUID, \
            0x0a214809,0xe35f,0x11d0,0x96,0x92,0x00,0xc0,0x4f,0xc3,0x35,0x8c);
#endif


typedef struct _MSNdis_CoReceivePdusNoBuffer
{
    // 
    ULONG NdisCoReceivePdusNoBuffer;
    #define MSNdis_CoReceivePdusNoBuffer_NdisCoReceivePdusNoBuffer_SIZE sizeof(ULONG)
    #define MSNdis_CoReceivePdusNoBuffer_NdisCoReceivePdusNoBuffer_ID 1

} MSNdis_CoReceivePdusNoBuffer, *PMSNdis_CoReceivePdusNoBuffer;

#define MSNdis_CoReceivePdusNoBuffer_SIZE (FIELD_OFFSET(MSNdis_CoReceivePdusNoBuffer, NdisCoReceivePdusNoBuffer) + MSNdis_CoReceivePdusNoBuffer_NdisCoReceivePdusNoBuffer_SIZE)

// MSNdis_AtmSupportedVcRates - MSNdis_AtmSupportedVcRates
#define MSNdis_AtmSupportedVcRatesGuid \
    { 0x791ad19e,0xe35c,0x11d0, { 0x96,0x92,0x00,0xc0,0x4f,0xc3,0x35,0x8c } }

#if ! (defined(MIDL_PASS))
DEFINE_GUID(MSNdis_AtmSupportedVcRates_GUID, \
            0x791ad19e,0xe35c,0x11d0,0x96,0x92,0x00,0xc0,0x4f,0xc3,0x35,0x8c);
#endif


typedef struct _MSNdis_AtmSupportedVcRates
{
    // 
    ULONG MinCellRate;
    #define MSNdis_AtmSupportedVcRates_MinCellRate_SIZE sizeof(ULONG)
    #define MSNdis_AtmSupportedVcRates_MinCellRate_ID 1

    // 
    ULONG MaxCellRate;
    #define MSNdis_AtmSupportedVcRates_MaxCellRate_SIZE sizeof(ULONG)
    #define MSNdis_AtmSupportedVcRates_MaxCellRate_ID 2

} MSNdis_AtmSupportedVcRates, *PMSNdis_AtmSupportedVcRates;

#define MSNdis_AtmSupportedVcRates_SIZE (FIELD_OFFSET(MSNdis_AtmSupportedVcRates, MaxCellRate) + MSNdis_AtmSupportedVcRates_MaxCellRate_SIZE)

// MSNdis_AtmSupportedServiceCategory - MSNdis_AtmSupportedServiceCategory
#define MSNdis_AtmSupportedServiceCategoryGuid \
    { 0x791ad19f,0xe35c,0x11d0, { 0x96,0x92,0x00,0xc0,0x4f,0xc3,0x35,0x8c } }

#if ! (defined(MIDL_PASS))
DEFINE_GUID(MSNdis_AtmSupportedServiceCategory_GUID, \
            0x791ad19f,0xe35c,0x11d0,0x96,0x92,0x00,0xc0,0x4f,0xc3,0x35,0x8c);
#endif


typedef struct _MSNdis_AtmSupportedServiceCategory
{
    // 
    ULONG NdisAtmSupportedServiceCategory;
    #define MSNdis_AtmSupportedServiceCategory_NdisAtmSupportedServiceCategory_SIZE sizeof(ULONG)
    #define MSNdis_AtmSupportedServiceCategory_NdisAtmSupportedServiceCategory_ID 1

} MSNdis_AtmSupportedServiceCategory, *PMSNdis_AtmSupportedServiceCategory;

#define MSNdis_AtmSupportedServiceCategory_SIZE (FIELD_OFFSET(MSNdis_AtmSupportedServiceCategory, NdisAtmSupportedServiceCategory) + MSNdis_AtmSupportedServiceCategory_NdisAtmSupportedServiceCategory_SIZE)

// MSNdis_AtmSupportedAalTypes - MSNdis_AtmSupportedAalTypes
#define MSNdis_AtmSupportedAalTypesGuid \
    { 0x791ad1a0,0xe35c,0x11d0, { 0x96,0x92,0x00,0xc0,0x4f,0xc3,0x35,0x8c } }

#if ! (defined(MIDL_PASS))
DEFINE_GUID(MSNdis_AtmSupportedAalTypes_GUID, \
            0x791ad1a0,0xe35c,0x11d0,0x96,0x92,0x00,0xc0,0x4f,0xc3,0x35,0x8c);
#endif


typedef struct _MSNdis_AtmSupportedAalTypes
{
    // 
    ULONG NdisAtmSupportedAalTypes;
    #define MSNdis_AtmSupportedAalTypes_NdisAtmSupportedAalTypes_SIZE sizeof(ULONG)
    #define MSNdis_AtmSupportedAalTypes_NdisAtmSupportedAalTypes_ID 1

} MSNdis_AtmSupportedAalTypes, *PMSNdis_AtmSupportedAalTypes;

#define MSNdis_AtmSupportedAalTypes_SIZE (FIELD_OFFSET(MSNdis_AtmSupportedAalTypes, NdisAtmSupportedAalTypes) + MSNdis_AtmSupportedAalTypes_NdisAtmSupportedAalTypes_SIZE)

// MSNdis_AtmHardwareCurrentAddress - MSNdis_AtmHardwareCurrentAddress
#define MSNdis_AtmHardwareCurrentAddressGuid \
    { 0x791ad1a1,0xe35c,0x11d0, { 0x96,0x92,0x00,0xc0,0x4f,0xc3,0x35,0x8c } }

#if ! (defined(MIDL_PASS))
DEFINE_GUID(MSNdis_AtmHardwareCurrentAddress_GUID, \
            0x791ad1a1,0xe35c,0x11d0,0x96,0x92,0x00,0xc0,0x4f,0xc3,0x35,0x8c);
#endif


typedef struct _MSNdis_AtmHardwareCurrentAddress
{
    // 
    MSNdis_NetworkAddress NdisAtmHardwareCurrentAddress;
    #define MSNdis_AtmHardwareCurrentAddress_NdisAtmHardwareCurrentAddress_SIZE sizeof(MSNdis_NetworkAddress)
    #define MSNdis_AtmHardwareCurrentAddress_NdisAtmHardwareCurrentAddress_ID 1

} MSNdis_AtmHardwareCurrentAddress, *PMSNdis_AtmHardwareCurrentAddress;

#define MSNdis_AtmHardwareCurrentAddress_SIZE (FIELD_OFFSET(MSNdis_AtmHardwareCurrentAddress, NdisAtmHardwareCurrentAddress) + MSNdis_AtmHardwareCurrentAddress_NdisAtmHardwareCurrentAddress_SIZE)

// MSNdis_AtmMaxActiveVcs - MSNdis_AtmMaxActiveVcs
#define MSNdis_AtmMaxActiveVcsGuid \
    { 0x791ad1a2,0xe35c,0x11d0, { 0x96,0x92,0x00,0xc0,0x4f,0xc3,0x35,0x8c } }

#if ! (defined(MIDL_PASS))
DEFINE_GUID(MSNdis_AtmMaxActiveVcs_GUID, \
            0x791ad1a2,0xe35c,0x11d0,0x96,0x92,0x00,0xc0,0x4f,0xc3,0x35,0x8c);
#endif


typedef struct _MSNdis_AtmMaxActiveVcs
{
    // 
    ULONG NdisAtmMaxActiveVcs;
    #define MSNdis_AtmMaxActiveVcs_NdisAtmMaxActiveVcs_SIZE sizeof(ULONG)
    #define MSNdis_AtmMaxActiveVcs_NdisAtmMaxActiveVcs_ID 1

} MSNdis_AtmMaxActiveVcs, *PMSNdis_AtmMaxActiveVcs;

#define MSNdis_AtmMaxActiveVcs_SIZE (FIELD_OFFSET(MSNdis_AtmMaxActiveVcs, NdisAtmMaxActiveVcs) + MSNdis_AtmMaxActiveVcs_NdisAtmMaxActiveVcs_SIZE)

// MSNdis_AtmMaxActiveVciBits - MSNdis_AtmMaxActiveVciBits
#define MSNdis_AtmMaxActiveVciBitsGuid \
    { 0x791ad1a3,0xe35c,0x11d0, { 0x96,0x92,0x00,0xc0,0x4f,0xc3,0x35,0x8c } }

#if ! (defined(MIDL_PASS))
DEFINE_GUID(MSNdis_AtmMaxActiveVciBits_GUID, \
            0x791ad1a3,0xe35c,0x11d0,0x96,0x92,0x00,0xc0,0x4f,0xc3,0x35,0x8c);
#endif


typedef struct _MSNdis_AtmMaxActiveVciBits
{
    // 
    ULONG NdisAtmMaxActiveVciBits;
    #define MSNdis_AtmMaxActiveVciBits_NdisAtmMaxActiveVciBits_SIZE sizeof(ULONG)
    #define MSNdis_AtmMaxActiveVciBits_NdisAtmMaxActiveVciBits_ID 1

} MSNdis_AtmMaxActiveVciBits, *PMSNdis_AtmMaxActiveVciBits;

#define MSNdis_AtmMaxActiveVciBits_SIZE (FIELD_OFFSET(MSNdis_AtmMaxActiveVciBits, NdisAtmMaxActiveVciBits) + MSNdis_AtmMaxActiveVciBits_NdisAtmMaxActiveVciBits_SIZE)

// MSNdis_AtmMaxActiveVpiBits - MSNdis_AtmMaxActiveVpiBits
#define MSNdis_AtmMaxActiveVpiBitsGuid \
    { 0x791ad1a4,0xe35c,0x11d0, { 0x96,0x92,0x00,0xc0,0x4f,0xc3,0x35,0x8c } }

#if ! (defined(MIDL_PASS))
DEFINE_GUID(MSNdis_AtmMaxActiveVpiBits_GUID, \
            0x791ad1a4,0xe35c,0x11d0,0x96,0x92,0x00,0xc0,0x4f,0xc3,0x35,0x8c);
#endif


typedef struct _MSNdis_AtmMaxActiveVpiBits
{
    // 
    ULONG NdisAtmMaxActiveVpiBits;
    #define MSNdis_AtmMaxActiveVpiBits_NdisAtmMaxActiveVpiBits_SIZE sizeof(ULONG)
    #define MSNdis_AtmMaxActiveVpiBits_NdisAtmMaxActiveVpiBits_ID 1

} MSNdis_AtmMaxActiveVpiBits, *PMSNdis_AtmMaxActiveVpiBits;

#define MSNdis_AtmMaxActiveVpiBits_SIZE (FIELD_OFFSET(MSNdis_AtmMaxActiveVpiBits, NdisAtmMaxActiveVpiBits) + MSNdis_AtmMaxActiveVpiBits_NdisAtmMaxActiveVpiBits_SIZE)

// MSNdis_AtmMaxAal0PacketSize - MSNdis_AtmMaxAal0PacketSize
#define MSNdis_AtmMaxAal0PacketSizeGuid \
    { 0x791ad1a5,0xe35c,0x11d0, { 0x96,0x92,0x00,0xc0,0x4f,0xc3,0x35,0x8c } }

#if ! (defined(MIDL_PASS))
DEFINE_GUID(MSNdis_AtmMaxAal0PacketSize_GUID, \
            0x791ad1a5,0xe35c,0x11d0,0x96,0x92,0x00,0xc0,0x4f,0xc3,0x35,0x8c);
#endif


typedef struct _MSNdis_AtmMaxAal0PacketSize
{
    // 
    ULONG NdisAtmMaxAal0PacketSize;
    #define MSNdis_AtmMaxAal0PacketSize_NdisAtmMaxAal0PacketSize_SIZE sizeof(ULONG)
    #define MSNdis_AtmMaxAal0PacketSize_NdisAtmMaxAal0PacketSize_ID 1

} MSNdis_AtmMaxAal0PacketSize, *PMSNdis_AtmMaxAal0PacketSize;

#define MSNdis_AtmMaxAal0PacketSize_SIZE (FIELD_OFFSET(MSNdis_AtmMaxAal0PacketSize, NdisAtmMaxAal0PacketSize) + MSNdis_AtmMaxAal0PacketSize_NdisAtmMaxAal0PacketSize_SIZE)

// MSNdis_AtmMaxAal1PacketSize - MSNdis_AtmMaxAal1PacketSize
#define MSNdis_AtmMaxAal1PacketSizeGuid \
    { 0x791ad1a6,0xe35c,0x11d0, { 0x96,0x92,0x00,0xc0,0x4f,0xc3,0x35,0x8c } }

#if ! (defined(MIDL_PASS))
DEFINE_GUID(MSNdis_AtmMaxAal1PacketSize_GUID, \
            0x791ad1a6,0xe35c,0x11d0,0x96,0x92,0x00,0xc0,0x4f,0xc3,0x35,0x8c);
#endif


typedef struct _MSNdis_AtmMaxAal1PacketSize
{
    // 
    ULONG NdisAtmMaxAal1PacketSize;
    #define MSNdis_AtmMaxAal1PacketSize_NdisAtmMaxAal1PacketSize_SIZE sizeof(ULONG)
    #define MSNdis_AtmMaxAal1PacketSize_NdisAtmMaxAal1PacketSize_ID 1

} MSNdis_AtmMaxAal1PacketSize, *PMSNdis_AtmMaxAal1PacketSize;

#define MSNdis_AtmMaxAal1PacketSize_SIZE (FIELD_OFFSET(MSNdis_AtmMaxAal1PacketSize, NdisAtmMaxAal1PacketSize) + MSNdis_AtmMaxAal1PacketSize_NdisAtmMaxAal1PacketSize_SIZE)

// MSNdis_AtmMaxAal34PacketSize - MSNdis_AtmMaxAal34PacketSize
#define MSNdis_AtmMaxAal34PacketSizeGuid \
    { 0x791ad1a7,0xe35c,0x11d0, { 0x96,0x92,0x00,0xc0,0x4f,0xc3,0x35,0x8c } }

#if ! (defined(MIDL_PASS))
DEFINE_GUID(MSNdis_AtmMaxAal34PacketSize_GUID, \
            0x791ad1a7,0xe35c,0x11d0,0x96,0x92,0x00,0xc0,0x4f,0xc3,0x35,0x8c);
#endif


typedef struct _MSNdis_AtmMaxAal34PacketSize
{
    // 
    ULONG NdisAtmMaxAal34PacketSize;
    #define MSNdis_AtmMaxAal34PacketSize_NdisAtmMaxAal34PacketSize_SIZE sizeof(ULONG)
    #define MSNdis_AtmMaxAal34PacketSize_NdisAtmMaxAal34PacketSize_ID 1

} MSNdis_AtmMaxAal34PacketSize, *PMSNdis_AtmMaxAal34PacketSize;

#define MSNdis_AtmMaxAal34PacketSize_SIZE (FIELD_OFFSET(MSNdis_AtmMaxAal34PacketSize, NdisAtmMaxAal34PacketSize) + MSNdis_AtmMaxAal34PacketSize_NdisAtmMaxAal34PacketSize_SIZE)

// MSNdis_AtmMaxAal5PacketSize - MSNdis_AtmMaxAal5PacketSize
#define MSNdis_AtmMaxAal5PacketSizeGuid \
    { 0x791ad191,0xe35c,0x11d0, { 0x96,0x92,0x00,0xc0,0x4f,0xc3,0x35,0x8c } }

#if ! (defined(MIDL_PASS))
DEFINE_GUID(MSNdis_AtmMaxAal5PacketSize_GUID, \
            0x791ad191,0xe35c,0x11d0,0x96,0x92,0x00,0xc0,0x4f,0xc3,0x35,0x8c);
#endif


typedef struct _MSNdis_AtmMaxAal5PacketSize
{
    // 
    ULONG NdisAtmMaxAal5PacketSize;
    #define MSNdis_AtmMaxAal5PacketSize_NdisAtmMaxAal5PacketSize_SIZE sizeof(ULONG)
    #define MSNdis_AtmMaxAal5PacketSize_NdisAtmMaxAal5PacketSize_ID 1

} MSNdis_AtmMaxAal5PacketSize, *PMSNdis_AtmMaxAal5PacketSize;

#define MSNdis_AtmMaxAal5PacketSize_SIZE (FIELD_OFFSET(MSNdis_AtmMaxAal5PacketSize, NdisAtmMaxAal5PacketSize) + MSNdis_AtmMaxAal5PacketSize_NdisAtmMaxAal5PacketSize_SIZE)

// MSNdis_AtmReceiveCellsOk - MSNdis_AtmReceiveCellsOk
#define MSNdis_AtmReceiveCellsOkGuid \
    { 0x0a21480a,0xe35f,0x11d0, { 0x96,0x92,0x00,0xc0,0x4f,0xc3,0x35,0x8c } }

#if ! (defined(MIDL_PASS))
DEFINE_GUID(MSNdis_AtmReceiveCellsOk_GUID, \
            0x0a21480a,0xe35f,0x11d0,0x96,0x92,0x00,0xc0,0x4f,0xc3,0x35,0x8c);
#endif


typedef struct _MSNdis_AtmReceiveCellsOk
{
    // 
    ULONGLONG NdisAtmReceiveCellsOk;
    #define MSNdis_AtmReceiveCellsOk_NdisAtmReceiveCellsOk_SIZE sizeof(ULONGLONG)
    #define MSNdis_AtmReceiveCellsOk_NdisAtmReceiveCellsOk_ID 1

} MSNdis_AtmReceiveCellsOk, *PMSNdis_AtmReceiveCellsOk;

#define MSNdis_AtmReceiveCellsOk_SIZE (FIELD_OFFSET(MSNdis_AtmReceiveCellsOk, NdisAtmReceiveCellsOk) + MSNdis_AtmReceiveCellsOk_NdisAtmReceiveCellsOk_SIZE)

// MSNdis_AtmTransmitCellsOk - MSNdis_AtmTransmitCellsOk
#define MSNdis_AtmTransmitCellsOkGuid \
    { 0x0a21480b,0xe35f,0x11d0, { 0x96,0x92,0x00,0xc0,0x4f,0xc3,0x35,0x8c } }

#if ! (defined(MIDL_PASS))
DEFINE_GUID(MSNdis_AtmTransmitCellsOk_GUID, \
            0x0a21480b,0xe35f,0x11d0,0x96,0x92,0x00,0xc0,0x4f,0xc3,0x35,0x8c);
#endif


typedef struct _MSNdis_AtmTransmitCellsOk
{
    // 
    ULONGLONG NdisAtmTransmitCellsOk;
    #define MSNdis_AtmTransmitCellsOk_NdisAtmTransmitCellsOk_SIZE sizeof(ULONGLONG)
    #define MSNdis_AtmTransmitCellsOk_NdisAtmTransmitCellsOk_ID 1

} MSNdis_AtmTransmitCellsOk, *PMSNdis_AtmTransmitCellsOk;

#define MSNdis_AtmTransmitCellsOk_SIZE (FIELD_OFFSET(MSNdis_AtmTransmitCellsOk, NdisAtmTransmitCellsOk) + MSNdis_AtmTransmitCellsOk_NdisAtmTransmitCellsOk_SIZE)

// MSNdis_AtmReceiveCellsDropped - MSNdis_AtmReceiveCellsDropped
#define MSNdis_AtmReceiveCellsDroppedGuid \
    { 0x0a21480c,0xe35f,0x11d0, { 0x96,0x92,0x00,0xc0,0x4f,0xc3,0x35,0x8c } }

#if ! (defined(MIDL_PASS))
DEFINE_GUID(MSNdis_AtmReceiveCellsDropped_GUID, \
            0x0a21480c,0xe35f,0x11d0,0x96,0x92,0x00,0xc0,0x4f,0xc3,0x35,0x8c);
#endif


typedef struct _MSNdis_AtmReceiveCellsDropped
{
    // 
    ULONGLONG NdisAtmReceiveCellsDropped;
    #define MSNdis_AtmReceiveCellsDropped_NdisAtmReceiveCellsDropped_SIZE sizeof(ULONGLONG)
    #define MSNdis_AtmReceiveCellsDropped_NdisAtmReceiveCellsDropped_ID 1

} MSNdis_AtmReceiveCellsDropped, *PMSNdis_AtmReceiveCellsDropped;

#define MSNdis_AtmReceiveCellsDropped_SIZE (FIELD_OFFSET(MSNdis_AtmReceiveCellsDropped, NdisAtmReceiveCellsDropped) + MSNdis_AtmReceiveCellsDropped_NdisAtmReceiveCellsDropped_SIZE)

// MSNdis_EthernetPermanentAddress - MSNdis_EthernetPermanentAddress
#define MSNdis_EthernetPermanentAddressGuid \
    { 0x447956ff,0xa61b,0x11d0, { 0x8d,0xd4,0x00,0xc0,0x4f,0xc3,0x35,0x8c } }

#if ! (defined(MIDL_PASS))
DEFINE_GUID(MSNdis_EthernetPermanentAddress_GUID, \
            0x447956ff,0xa61b,0x11d0,0x8d,0xd4,0x00,0xc0,0x4f,0xc3,0x35,0x8c);
#endif


typedef struct _MSNdis_EthernetPermanentAddress
{
    // 
    MSNdis_NetworkAddress NdisPermanentAddress;
    #define MSNdis_EthernetPermanentAddress_NdisPermanentAddress_SIZE sizeof(MSNdis_NetworkAddress)
    #define MSNdis_EthernetPermanentAddress_NdisPermanentAddress_ID 1

} MSNdis_EthernetPermanentAddress, *PMSNdis_EthernetPermanentAddress;

#define MSNdis_EthernetPermanentAddress_SIZE (FIELD_OFFSET(MSNdis_EthernetPermanentAddress, NdisPermanentAddress) + MSNdis_EthernetPermanentAddress_NdisPermanentAddress_SIZE)

// MSNdis_EthernetCurrentAddress - MSNdis_EthernetCurrentAddress
#define MSNdis_EthernetCurrentAddressGuid \
    { 0x44795700,0xa61b,0x11d0, { 0x8d,0xd4,0x00,0xc0,0x4f,0xc3,0x35,0x8c } }

#if ! (defined(MIDL_PASS))
DEFINE_GUID(MSNdis_EthernetCurrentAddress_GUID, \
            0x44795700,0xa61b,0x11d0,0x8d,0xd4,0x00,0xc0,0x4f,0xc3,0x35,0x8c);
#endif


typedef struct _MSNdis_EthernetCurrentAddress
{
    // 
    MSNdis_NetworkAddress NdisCurrentAddress;
    #define MSNdis_EthernetCurrentAddress_NdisCurrentAddress_SIZE sizeof(MSNdis_NetworkAddress)
    #define MSNdis_EthernetCurrentAddress_NdisCurrentAddress_ID 1

} MSNdis_EthernetCurrentAddress, *PMSNdis_EthernetCurrentAddress;

#define MSNdis_EthernetCurrentAddress_SIZE (FIELD_OFFSET(MSNdis_EthernetCurrentAddress, NdisCurrentAddress) + MSNdis_EthernetCurrentAddress_NdisCurrentAddress_SIZE)

// MSNdis_EthernetMulticastList - MSNdis_EthernetMulticastList
#define MSNdis_EthernetMulticastListGuid \
    { 0x44795701,0xa61b,0x11d0, { 0x8d,0xd4,0x00,0xc0,0x4f,0xc3,0x35,0x8c } }

#if ! (defined(MIDL_PASS))
DEFINE_GUID(MSNdis_EthernetMulticastList_GUID, \
            0x44795701,0xa61b,0x11d0,0x8d,0xd4,0x00,0xc0,0x4f,0xc3,0x35,0x8c);
#endif


typedef struct _MSNdis_EthernetMulticastList
{
    // 
    ULONG NumberElements;
    #define MSNdis_EthernetMulticastList_NumberElements_SIZE sizeof(ULONG)
    #define MSNdis_EthernetMulticastList_NumberElements_ID 1

    // 
    MSNdis_NetworkAddress NdisMulticastList[1];
    #define MSNdis_EthernetMulticastList_NdisMulticastList_ID 2

} MSNdis_EthernetMulticastList, *PMSNdis_EthernetMulticastList;

// MSNdis_EthernetMaximumMulticastListSize - MSNdis_EthernetMaximumMulticastListSize
#define MSNdis_EthernetMaximumMulticastListSizeGuid \
    { 0x44795702,0xa61b,0x11d0, { 0x8d,0xd4,0x00,0xc0,0x4f,0xc3,0x35,0x8c } }

#if ! (defined(MIDL_PASS))
DEFINE_GUID(MSNdis_EthernetMaximumMulticastListSize_GUID, \
            0x44795702,0xa61b,0x11d0,0x8d,0xd4,0x00,0xc0,0x4f,0xc3,0x35,0x8c);
#endif


typedef struct _MSNdis_EthernetMaximumMulticastListSize
{
    // 
    ULONG NdisEthernetMaximumMulticastListSize;
    #define MSNdis_EthernetMaximumMulticastListSize_NdisEthernetMaximumMulticastListSize_SIZE sizeof(ULONG)
    #define MSNdis_EthernetMaximumMulticastListSize_NdisEthernetMaximumMulticastListSize_ID 1

} MSNdis_EthernetMaximumMulticastListSize, *PMSNdis_EthernetMaximumMulticastListSize;

#define MSNdis_EthernetMaximumMulticastListSize_SIZE (FIELD_OFFSET(MSNdis_EthernetMaximumMulticastListSize, NdisEthernetMaximumMulticastListSize) + MSNdis_EthernetMaximumMulticastListSize_NdisEthernetMaximumMulticastListSize_SIZE)

// MSNdis_EthernetMacOptions - MSNdis_EthernetMacOptions
#define MSNdis_EthernetMacOptionsGuid \
    { 0x44795703,0xa61b,0x11d0, { 0x8d,0xd4,0x00,0xc0,0x4f,0xc3,0x35,0x8c } }

#if ! (defined(MIDL_PASS))
DEFINE_GUID(MSNdis_EthernetMacOptions_GUID, \
            0x44795703,0xa61b,0x11d0,0x8d,0xd4,0x00,0xc0,0x4f,0xc3,0x35,0x8c);
#endif


typedef struct _MSNdis_EthernetMacOptions
{
    // 
    ULONG NdisEthernetMacOptions;
    #define MSNdis_EthernetMacOptions_NdisEthernetMacOptions_SIZE sizeof(ULONG)
    #define MSNdis_EthernetMacOptions_NdisEthernetMacOptions_ID 1

} MSNdis_EthernetMacOptions, *PMSNdis_EthernetMacOptions;

#define MSNdis_EthernetMacOptions_SIZE (FIELD_OFFSET(MSNdis_EthernetMacOptions, NdisEthernetMacOptions) + MSNdis_EthernetMacOptions_NdisEthernetMacOptions_SIZE)

// MSNdis_EthernetReceiveErrorAlignment - MSNdis_EthernetReceiveErrorAlignment
#define MSNdis_EthernetReceiveErrorAlignmentGuid \
    { 0x44795704,0xa61b,0x11d0, { 0x8d,0xd4,0x00,0xc0,0x4f,0xc3,0x35,0x8c } }

#if ! (defined(MIDL_PASS))
DEFINE_GUID(MSNdis_EthernetReceiveErrorAlignment_GUID, \
            0x44795704,0xa61b,0x11d0,0x8d,0xd4,0x00,0xc0,0x4f,0xc3,0x35,0x8c);
#endif


typedef struct _MSNdis_EthernetReceiveErrorAlignment
{
    // 
    ULONG NdisEthernetReceiveErrorAlignment;
    #define MSNdis_EthernetReceiveErrorAlignment_NdisEthernetReceiveErrorAlignment_SIZE sizeof(ULONG)
    #define MSNdis_EthernetReceiveErrorAlignment_NdisEthernetReceiveErrorAlignment_ID 1

} MSNdis_EthernetReceiveErrorAlignment, *PMSNdis_EthernetReceiveErrorAlignment;

#define MSNdis_EthernetReceiveErrorAlignment_SIZE (FIELD_OFFSET(MSNdis_EthernetReceiveErrorAlignment, NdisEthernetReceiveErrorAlignment) + MSNdis_EthernetReceiveErrorAlignment_NdisEthernetReceiveErrorAlignment_SIZE)

// MSNdis_EthernetOneTransmitCollision - MSNdis_EthernetOneTransmitCollision
#define MSNdis_EthernetOneTransmitCollisionGuid \
    { 0x44795705,0xa61b,0x11d0, { 0x8d,0xd4,0x00,0xc0,0x4f,0xc3,0x35,0x8c } }

#if ! (defined(MIDL_PASS))
DEFINE_GUID(MSNdis_EthernetOneTransmitCollision_GUID, \
            0x44795705,0xa61b,0x11d0,0x8d,0xd4,0x00,0xc0,0x4f,0xc3,0x35,0x8c);
#endif


typedef struct _MSNdis_EthernetOneTransmitCollision
{
    // 
    ULONG NdisEthernetOneTransmitCollision;
    #define MSNdis_EthernetOneTransmitCollision_NdisEthernetOneTransmitCollision_SIZE sizeof(ULONG)
    #define MSNdis_EthernetOneTransmitCollision_NdisEthernetOneTransmitCollision_ID 1

} MSNdis_EthernetOneTransmitCollision, *PMSNdis_EthernetOneTransmitCollision;

#define MSNdis_EthernetOneTransmitCollision_SIZE (FIELD_OFFSET(MSNdis_EthernetOneTransmitCollision, NdisEthernetOneTransmitCollision) + MSNdis_EthernetOneTransmitCollision_NdisEthernetOneTransmitCollision_SIZE)

// MSNdis_EthernetMoreTransmitCollisions - MSNdis_EthernetMoreTransmitCollisions
#define MSNdis_EthernetMoreTransmitCollisionsGuid \
    { 0x44795706,0xa61b,0x11d0, { 0x8d,0xd4,0x00,0xc0,0x4f,0xc3,0x35,0x8c } }

#if ! (defined(MIDL_PASS))
DEFINE_GUID(MSNdis_EthernetMoreTransmitCollisions_GUID, \
            0x44795706,0xa61b,0x11d0,0x8d,0xd4,0x00,0xc0,0x4f,0xc3,0x35,0x8c);
#endif


typedef struct _MSNdis_EthernetMoreTransmitCollisions
{
    // 
    ULONG NdisEthernetMoreTransmitCollisions;
    #define MSNdis_EthernetMoreTransmitCollisions_NdisEthernetMoreTransmitCollisions_SIZE sizeof(ULONG)
    #define MSNdis_EthernetMoreTransmitCollisions_NdisEthernetMoreTransmitCollisions_ID 1

} MSNdis_EthernetMoreTransmitCollisions, *PMSNdis_EthernetMoreTransmitCollisions;

#define MSNdis_EthernetMoreTransmitCollisions_SIZE (FIELD_OFFSET(MSNdis_EthernetMoreTransmitCollisions, NdisEthernetMoreTransmitCollisions) + MSNdis_EthernetMoreTransmitCollisions_NdisEthernetMoreTransmitCollisions_SIZE)

// MSNdis_TokenRingPermanentAddress - MSNdis_TokenRingPermanentAddress
#define MSNdis_TokenRingPermanentAddressGuid \
    { 0x44795707,0xa61b,0x11d0, { 0x8d,0xd4,0x00,0xc0,0x4f,0xc3,0x35,0x8c } }

#if ! (defined(MIDL_PASS))
DEFINE_GUID(MSNdis_TokenRingPermanentAddress_GUID, \
            0x44795707,0xa61b,0x11d0,0x8d,0xd4,0x00,0xc0,0x4f,0xc3,0x35,0x8c);
#endif


typedef struct _MSNdis_TokenRingPermanentAddress
{
    // 
    MSNdis_NetworkAddress NdisPermanentAddress;
    #define MSNdis_TokenRingPermanentAddress_NdisPermanentAddress_SIZE sizeof(MSNdis_NetworkAddress)
    #define MSNdis_TokenRingPermanentAddress_NdisPermanentAddress_ID 1

} MSNdis_TokenRingPermanentAddress, *PMSNdis_TokenRingPermanentAddress;

#define MSNdis_TokenRingPermanentAddress_SIZE (FIELD_OFFSET(MSNdis_TokenRingPermanentAddress, NdisPermanentAddress) + MSNdis_TokenRingPermanentAddress_NdisPermanentAddress_SIZE)

// MSNdis_TokenRingCurrentAddress - MSNdis_TokenRingCurrentAddress
#define MSNdis_TokenRingCurrentAddressGuid \
    { 0x44795708,0xa61b,0x11d0, { 0x8d,0xd4,0x00,0xc0,0x4f,0xc3,0x35,0x8c } }

#if ! (defined(MIDL_PASS))
DEFINE_GUID(MSNdis_TokenRingCurrentAddress_GUID, \
            0x44795708,0xa61b,0x11d0,0x8d,0xd4,0x00,0xc0,0x4f,0xc3,0x35,0x8c);
#endif


typedef struct _MSNdis_TokenRingCurrentAddress
{
    // 
    MSNdis_NetworkAddress NdisCurrentAddress;
    #define MSNdis_TokenRingCurrentAddress_NdisCurrentAddress_SIZE sizeof(MSNdis_NetworkAddress)
    #define MSNdis_TokenRingCurrentAddress_NdisCurrentAddress_ID 1

} MSNdis_TokenRingCurrentAddress, *PMSNdis_TokenRingCurrentAddress;

#define MSNdis_TokenRingCurrentAddress_SIZE (FIELD_OFFSET(MSNdis_TokenRingCurrentAddress, NdisCurrentAddress) + MSNdis_TokenRingCurrentAddress_NdisCurrentAddress_SIZE)

// MSNdis_TokenRingCurrentFunctional - MSNdis_TokenRingCurrentFunctional
#define MSNdis_TokenRingCurrentFunctionalGuid \
    { 0x44795709,0xa61b,0x11d0, { 0x8d,0xd4,0x00,0xc0,0x4f,0xc3,0x35,0x8c } }

#if ! (defined(MIDL_PASS))
DEFINE_GUID(MSNdis_TokenRingCurrentFunctional_GUID, \
            0x44795709,0xa61b,0x11d0,0x8d,0xd4,0x00,0xc0,0x4f,0xc3,0x35,0x8c);
#endif


typedef struct _MSNdis_TokenRingCurrentFunctional
{
    // 
    ULONG NdisTokenRingCurrentFunctional;
    #define MSNdis_TokenRingCurrentFunctional_NdisTokenRingCurrentFunctional_SIZE sizeof(ULONG)
    #define MSNdis_TokenRingCurrentFunctional_NdisTokenRingCurrentFunctional_ID 1

} MSNdis_TokenRingCurrentFunctional, *PMSNdis_TokenRingCurrentFunctional;

#define MSNdis_TokenRingCurrentFunctional_SIZE (FIELD_OFFSET(MSNdis_TokenRingCurrentFunctional, NdisTokenRingCurrentFunctional) + MSNdis_TokenRingCurrentFunctional_NdisTokenRingCurrentFunctional_SIZE)

// MSNdis_TokenRingCurrentGroup - MSNdis_TokenRingCurrentGroup
#define MSNdis_TokenRingCurrentGroupGuid \
    { 0x4479570a,0xa61b,0x11d0, { 0x8d,0xd4,0x00,0xc0,0x4f,0xc3,0x35,0x8c } }

#if ! (defined(MIDL_PASS))
DEFINE_GUID(MSNdis_TokenRingCurrentGroup_GUID, \
            0x4479570a,0xa61b,0x11d0,0x8d,0xd4,0x00,0xc0,0x4f,0xc3,0x35,0x8c);
#endif


typedef struct _MSNdis_TokenRingCurrentGroup
{
    // 
    ULONG NdisTokenRingCurrentGroup;
    #define MSNdis_TokenRingCurrentGroup_NdisTokenRingCurrentGroup_SIZE sizeof(ULONG)
    #define MSNdis_TokenRingCurrentGroup_NdisTokenRingCurrentGroup_ID 1

} MSNdis_TokenRingCurrentGroup, *PMSNdis_TokenRingCurrentGroup;

#define MSNdis_TokenRingCurrentGroup_SIZE (FIELD_OFFSET(MSNdis_TokenRingCurrentGroup, NdisTokenRingCurrentGroup) + MSNdis_TokenRingCurrentGroup_NdisTokenRingCurrentGroup_SIZE)

// MSNdis_TokenRingLastOpenStatus - MSNdis_TokenRingLastOpenStatus
#define MSNdis_TokenRingLastOpenStatusGuid \
    { 0x4479570b,0xa61b,0x11d0, { 0x8d,0xd4,0x00,0xc0,0x4f,0xc3,0x35,0x8c } }

#if ! (defined(MIDL_PASS))
DEFINE_GUID(MSNdis_TokenRingLastOpenStatus_GUID, \
            0x4479570b,0xa61b,0x11d0,0x8d,0xd4,0x00,0xc0,0x4f,0xc3,0x35,0x8c);
#endif


typedef struct _MSNdis_TokenRingLastOpenStatus
{
    // 
    ULONG NdisTokenRingLastOpenStatus;
    #define MSNdis_TokenRingLastOpenStatus_NdisTokenRingLastOpenStatus_SIZE sizeof(ULONG)
    #define MSNdis_TokenRingLastOpenStatus_NdisTokenRingLastOpenStatus_ID 1

} MSNdis_TokenRingLastOpenStatus, *PMSNdis_TokenRingLastOpenStatus;

#define MSNdis_TokenRingLastOpenStatus_SIZE (FIELD_OFFSET(MSNdis_TokenRingLastOpenStatus, NdisTokenRingLastOpenStatus) + MSNdis_TokenRingLastOpenStatus_NdisTokenRingLastOpenStatus_SIZE)

// MSNdis_TokenRingCurrentRingStatus - MSNdis_TokenRingCurrentRingStatus
#define MSNdis_TokenRingCurrentRingStatusGuid \
    { 0x890a36ec,0xa61c,0x11d0, { 0x8d,0xd4,0x00,0xc0,0x4f,0xc3,0x35,0x8c } }

#if ! (defined(MIDL_PASS))
DEFINE_GUID(MSNdis_TokenRingCurrentRingStatus_GUID, \
            0x890a36ec,0xa61c,0x11d0,0x8d,0xd4,0x00,0xc0,0x4f,0xc3,0x35,0x8c);
#endif


typedef struct _MSNdis_TokenRingCurrentRingStatus
{
    // 
    ULONG NdisTokenRingCurrentRingStatus;
    #define MSNdis_TokenRingCurrentRingStatus_NdisTokenRingCurrentRingStatus_SIZE sizeof(ULONG)
    #define MSNdis_TokenRingCurrentRingStatus_NdisTokenRingCurrentRingStatus_ID 1

} MSNdis_TokenRingCurrentRingStatus, *PMSNdis_TokenRingCurrentRingStatus;

#define MSNdis_TokenRingCurrentRingStatus_SIZE (FIELD_OFFSET(MSNdis_TokenRingCurrentRingStatus, NdisTokenRingCurrentRingStatus) + MSNdis_TokenRingCurrentRingStatus_NdisTokenRingCurrentRingStatus_SIZE)

// MSNdis_TokenRingCurrentRingState - MSNdis_TokenRingCurrentRingState
#define MSNdis_TokenRingCurrentRingStateGuid \
    { 0xacf14032,0xa61c,0x11d0, { 0x8d,0xd4,0x00,0xc0,0x4f,0xc3,0x35,0x8c } }

#if ! (defined(MIDL_PASS))
DEFINE_GUID(MSNdis_TokenRingCurrentRingState_GUID, \
            0xacf14032,0xa61c,0x11d0,0x8d,0xd4,0x00,0xc0,0x4f,0xc3,0x35,0x8c);
#endif


typedef struct _MSNdis_TokenRingCurrentRingState
{
    // 
    ULONG NdisTokenRingCurrentRingState;
    #define MSNdis_TokenRingCurrentRingState_NdisTokenRingCurrentRingState_SIZE sizeof(ULONG)
    #define MSNdis_TokenRingCurrentRingState_NdisTokenRingCurrentRingState_ID 1

} MSNdis_TokenRingCurrentRingState, *PMSNdis_TokenRingCurrentRingState;

#define MSNdis_TokenRingCurrentRingState_SIZE (FIELD_OFFSET(MSNdis_TokenRingCurrentRingState, NdisTokenRingCurrentRingState) + MSNdis_TokenRingCurrentRingState_NdisTokenRingCurrentRingState_SIZE)

// MSNdis_TokenRingLineErrors - MSNdis_TokenRingLineErrors
#define MSNdis_TokenRingLineErrorsGuid \
    { 0xacf14033,0xa61c,0x11d0, { 0x8d,0xd4,0x00,0xc0,0x4f,0xc3,0x35,0x8c } }

#if ! (defined(MIDL_PASS))
DEFINE_GUID(MSNdis_TokenRingLineErrors_GUID, \
            0xacf14033,0xa61c,0x11d0,0x8d,0xd4,0x00,0xc0,0x4f,0xc3,0x35,0x8c);
#endif


typedef struct _MSNdis_TokenRingLineErrors
{
    // 
    ULONG NdisTokenRingLineErrors;
    #define MSNdis_TokenRingLineErrors_NdisTokenRingLineErrors_SIZE sizeof(ULONG)
    #define MSNdis_TokenRingLineErrors_NdisTokenRingLineErrors_ID 1

} MSNdis_TokenRingLineErrors, *PMSNdis_TokenRingLineErrors;

#define MSNdis_TokenRingLineErrors_SIZE (FIELD_OFFSET(MSNdis_TokenRingLineErrors, NdisTokenRingLineErrors) + MSNdis_TokenRingLineErrors_NdisTokenRingLineErrors_SIZE)

// MSNdis_TokenRingLostFrames - MSNdis_TokenRingLostFrames
#define MSNdis_TokenRingLostFramesGuid \
    { 0xacf14034,0xa61c,0x11d0, { 0x8d,0xd4,0x00,0xc0,0x4f,0xc3,0x35,0x8c } }

#if ! (defined(MIDL_PASS))
DEFINE_GUID(MSNdis_TokenRingLostFrames_GUID, \
            0xacf14034,0xa61c,0x11d0,0x8d,0xd4,0x00,0xc0,0x4f,0xc3,0x35,0x8c);
#endif


typedef struct _MSNdis_TokenRingLostFrames
{
    // 
    ULONG NdisTokenRingLostFrames;
    #define MSNdis_TokenRingLostFrames_NdisTokenRingLostFrames_SIZE sizeof(ULONG)
    #define MSNdis_TokenRingLostFrames_NdisTokenRingLostFrames_ID 1

} MSNdis_TokenRingLostFrames, *PMSNdis_TokenRingLostFrames;

#define MSNdis_TokenRingLostFrames_SIZE (FIELD_OFFSET(MSNdis_TokenRingLostFrames, NdisTokenRingLostFrames) + MSNdis_TokenRingLostFrames_NdisTokenRingLostFrames_SIZE)

// MSNdis_FddiLongPermanentAddress - MSNdis_FddiLongPermanentAddress
#define MSNdis_FddiLongPermanentAddressGuid \
    { 0xacf14035,0xa61c,0x11d0, { 0x8d,0xd4,0x00,0xc0,0x4f,0xc3,0x35,0x8c } }

#if ! (defined(MIDL_PASS))
DEFINE_GUID(MSNdis_FddiLongPermanentAddress_GUID, \
            0xacf14035,0xa61c,0x11d0,0x8d,0xd4,0x00,0xc0,0x4f,0xc3,0x35,0x8c);
#endif


typedef struct _MSNdis_FddiLongPermanentAddress
{
    // 
    MSNdis_NetworkAddress NdisPermanentAddress;
    #define MSNdis_FddiLongPermanentAddress_NdisPermanentAddress_SIZE sizeof(MSNdis_NetworkAddress)
    #define MSNdis_FddiLongPermanentAddress_NdisPermanentAddress_ID 1

} MSNdis_FddiLongPermanentAddress, *PMSNdis_FddiLongPermanentAddress;

#define MSNdis_FddiLongPermanentAddress_SIZE (FIELD_OFFSET(MSNdis_FddiLongPermanentAddress, NdisPermanentAddress) + MSNdis_FddiLongPermanentAddress_NdisPermanentAddress_SIZE)

// MSNdis_FddiLongCurrentAddress - MSNdis_FddiLongCurrentAddress
#define MSNdis_FddiLongCurrentAddressGuid \
    { 0xacf14036,0xa61c,0x11d0, { 0x8d,0xd4,0x00,0xc0,0x4f,0xc3,0x35,0x8c } }

#if ! (defined(MIDL_PASS))
DEFINE_GUID(MSNdis_FddiLongCurrentAddress_GUID, \
            0xacf14036,0xa61c,0x11d0,0x8d,0xd4,0x00,0xc0,0x4f,0xc3,0x35,0x8c);
#endif


typedef struct _MSNdis_FddiLongCurrentAddress
{
    // 
    MSNdis_NetworkAddress NdisCurrentAddress;
    #define MSNdis_FddiLongCurrentAddress_NdisCurrentAddress_SIZE sizeof(MSNdis_NetworkAddress)
    #define MSNdis_FddiLongCurrentAddress_NdisCurrentAddress_ID 1

} MSNdis_FddiLongCurrentAddress, *PMSNdis_FddiLongCurrentAddress;

#define MSNdis_FddiLongCurrentAddress_SIZE (FIELD_OFFSET(MSNdis_FddiLongCurrentAddress, NdisCurrentAddress) + MSNdis_FddiLongCurrentAddress_NdisCurrentAddress_SIZE)

// MSNdis_FddiLongMulticastList - MSNdis_FddiLongMulticastList
#define MSNdis_FddiLongMulticastListGuid \
    { 0xacf14037,0xa61c,0x11d0, { 0x8d,0xd4,0x00,0xc0,0x4f,0xc3,0x35,0x8c } }

#if ! (defined(MIDL_PASS))
DEFINE_GUID(MSNdis_FddiLongMulticastList_GUID, \
            0xacf14037,0xa61c,0x11d0,0x8d,0xd4,0x00,0xc0,0x4f,0xc3,0x35,0x8c);
#endif


typedef struct _MSNdis_FddiLongMulticastList
{
    // 
    ULONG NumberElements;
    #define MSNdis_FddiLongMulticastList_NumberElements_SIZE sizeof(ULONG)
    #define MSNdis_FddiLongMulticastList_NumberElements_ID 1

    // 
    MSNdis_NetworkAddress NdisMulticastList[1];
    #define MSNdis_FddiLongMulticastList_NdisMulticastList_ID 2

} MSNdis_FddiLongMulticastList, *PMSNdis_FddiLongMulticastList;

// MSNdis_FddiLongMaximumListSize - MSNdis_FddiLongMaximumListSize
#define MSNdis_FddiLongMaximumListSizeGuid \
    { 0xacf14038,0xa61c,0x11d0, { 0x8d,0xd4,0x00,0xc0,0x4f,0xc3,0x35,0x8c } }

#if ! (defined(MIDL_PASS))
DEFINE_GUID(MSNdis_FddiLongMaximumListSize_GUID, \
            0xacf14038,0xa61c,0x11d0,0x8d,0xd4,0x00,0xc0,0x4f,0xc3,0x35,0x8c);
#endif


typedef struct _MSNdis_FddiLongMaximumListSize
{
    // 
    ULONG NdisFddiLongMaximumListSize;
    #define MSNdis_FddiLongMaximumListSize_NdisFddiLongMaximumListSize_SIZE sizeof(ULONG)
    #define MSNdis_FddiLongMaximumListSize_NdisFddiLongMaximumListSize_ID 1

} MSNdis_FddiLongMaximumListSize, *PMSNdis_FddiLongMaximumListSize;

#define MSNdis_FddiLongMaximumListSize_SIZE (FIELD_OFFSET(MSNdis_FddiLongMaximumListSize, NdisFddiLongMaximumListSize) + MSNdis_FddiLongMaximumListSize_NdisFddiLongMaximumListSize_SIZE)

// MSNdis_FddiShortPermanentAddress - MSNdis_FddiShortPermanentAddress
#define MSNdis_FddiShortPermanentAddressGuid \
    { 0xacf14039,0xa61c,0x11d0, { 0x8d,0xd4,0x00,0xc0,0x4f,0xc3,0x35,0x8c } }

#if ! (defined(MIDL_PASS))
DEFINE_GUID(MSNdis_FddiShortPermanentAddress_GUID, \
            0xacf14039,0xa61c,0x11d0,0x8d,0xd4,0x00,0xc0,0x4f,0xc3,0x35,0x8c);
#endif


typedef struct _MSNdis_FddiShortPermanentAddress
{
    // 
    MSNdis_NetworkShortAddress NdisPermanentAddress;
    #define MSNdis_FddiShortPermanentAddress_NdisPermanentAddress_SIZE sizeof(MSNdis_NetworkShortAddress)
    #define MSNdis_FddiShortPermanentAddress_NdisPermanentAddress_ID 1

} MSNdis_FddiShortPermanentAddress, *PMSNdis_FddiShortPermanentAddress;

#define MSNdis_FddiShortPermanentAddress_SIZE (FIELD_OFFSET(MSNdis_FddiShortPermanentAddress, NdisPermanentAddress) + MSNdis_FddiShortPermanentAddress_NdisPermanentAddress_SIZE)

// MSNdis_FddiShortCurrentAddress - MSNdis_FddiShortCurrentAddress
#define MSNdis_FddiShortCurrentAddressGuid \
    { 0xacf1403a,0xa61c,0x11d0, { 0x8d,0xd4,0x00,0xc0,0x4f,0xc3,0x35,0x8c } }

#if ! (defined(MIDL_PASS))
DEFINE_GUID(MSNdis_FddiShortCurrentAddress_GUID, \
            0xacf1403a,0xa61c,0x11d0,0x8d,0xd4,0x00,0xc0,0x4f,0xc3,0x35,0x8c);
#endif


typedef struct _MSNdis_FddiShortCurrentAddress
{
    // 
    MSNdis_NetworkShortAddress NdisCurrentAddress;
    #define MSNdis_FddiShortCurrentAddress_NdisCurrentAddress_SIZE sizeof(MSNdis_NetworkShortAddress)
    #define MSNdis_FddiShortCurrentAddress_NdisCurrentAddress_ID 1

} MSNdis_FddiShortCurrentAddress, *PMSNdis_FddiShortCurrentAddress;

#define MSNdis_FddiShortCurrentAddress_SIZE (FIELD_OFFSET(MSNdis_FddiShortCurrentAddress, NdisCurrentAddress) + MSNdis_FddiShortCurrentAddress_NdisCurrentAddress_SIZE)

// MSNdis_FddiShortMulticastList - MSNdis_FddiShortMulticastList
#define MSNdis_FddiShortMulticastListGuid \
    { 0xacf1403b,0xa61c,0x11d0, { 0x8d,0xd4,0x00,0xc0,0x4f,0xc3,0x35,0x8c } }

#if ! (defined(MIDL_PASS))
DEFINE_GUID(MSNdis_FddiShortMulticastList_GUID, \
            0xacf1403b,0xa61c,0x11d0,0x8d,0xd4,0x00,0xc0,0x4f,0xc3,0x35,0x8c);
#endif


typedef struct _MSNdis_FddiShortMulticastList
{
    // 
    ULONG NumberElements;
    #define MSNdis_FddiShortMulticastList_NumberElements_SIZE sizeof(ULONG)
    #define MSNdis_FddiShortMulticastList_NumberElements_ID 1

    // 
    MSNdis_NetworkShortAddress NdisMulticastList[1];
    #define MSNdis_FddiShortMulticastList_NdisMulticastList_ID 2

} MSNdis_FddiShortMulticastList, *PMSNdis_FddiShortMulticastList;

// MSNdis_FddiShortMaximumListSize - MSNdis_FddiShortMaximumListSize
#define MSNdis_FddiShortMaximumListSizeGuid \
    { 0xacf1403c,0xa61c,0x11d0, { 0x8d,0xd4,0x00,0xc0,0x4f,0xc3,0x35,0x8c } }

#if ! (defined(MIDL_PASS))
DEFINE_GUID(MSNdis_FddiShortMaximumListSize_GUID, \
            0xacf1403c,0xa61c,0x11d0,0x8d,0xd4,0x00,0xc0,0x4f,0xc3,0x35,0x8c);
#endif


typedef struct _MSNdis_FddiShortMaximumListSize
{
    // 
    ULONG NdisFddiShortMaximumListSize;
    #define MSNdis_FddiShortMaximumListSize_NdisFddiShortMaximumListSize_SIZE sizeof(ULONG)
    #define MSNdis_FddiShortMaximumListSize_NdisFddiShortMaximumListSize_ID 1

} MSNdis_FddiShortMaximumListSize, *PMSNdis_FddiShortMaximumListSize;

#define MSNdis_FddiShortMaximumListSize_SIZE (FIELD_OFFSET(MSNdis_FddiShortMaximumListSize, NdisFddiShortMaximumListSize) + MSNdis_FddiShortMaximumListSize_NdisFddiShortMaximumListSize_SIZE)

// MSNdis_FddiAttachmentType - MSNdis_FddiAttachmentType
#define MSNdis_FddiAttachmentTypeGuid \
    { 0xacf1403d,0xa61c,0x11d0, { 0x8d,0xd4,0x00,0xc0,0x4f,0xc3,0x35,0x8c } }

#if ! (defined(MIDL_PASS))
DEFINE_GUID(MSNdis_FddiAttachmentType_GUID, \
            0xacf1403d,0xa61c,0x11d0,0x8d,0xd4,0x00,0xc0,0x4f,0xc3,0x35,0x8c);
#endif


typedef struct _MSNdis_FddiAttachmentType
{
    // 
    ULONG NdisFddiAttachmentType;
    #define MSNdis_FddiAttachmentType_NdisFddiAttachmentType_SIZE sizeof(ULONG)
    #define MSNdis_FddiAttachmentType_NdisFddiAttachmentType_ID 1

} MSNdis_FddiAttachmentType, *PMSNdis_FddiAttachmentType;

#define MSNdis_FddiAttachmentType_SIZE (FIELD_OFFSET(MSNdis_FddiAttachmentType, NdisFddiAttachmentType) + MSNdis_FddiAttachmentType_NdisFddiAttachmentType_SIZE)

// MSNdis_FddiUpstreamNodeLong - MSNdis_FddiUpstreamNodeLong
#define MSNdis_FddiUpstreamNodeLongGuid \
    { 0xacf1403e,0xa61c,0x11d0, { 0x8d,0xd4,0x00,0xc0,0x4f,0xc3,0x35,0x8c } }

#if ! (defined(MIDL_PASS))
DEFINE_GUID(MSNdis_FddiUpstreamNodeLong_GUID, \
            0xacf1403e,0xa61c,0x11d0,0x8d,0xd4,0x00,0xc0,0x4f,0xc3,0x35,0x8c);
#endif


typedef struct _MSNdis_FddiUpstreamNodeLong
{
    // 
    MSNdis_NetworkAddress NdisFddiUpstreamNodeLong;
    #define MSNdis_FddiUpstreamNodeLong_NdisFddiUpstreamNodeLong_SIZE sizeof(MSNdis_NetworkAddress)
    #define MSNdis_FddiUpstreamNodeLong_NdisFddiUpstreamNodeLong_ID 1

} MSNdis_FddiUpstreamNodeLong, *PMSNdis_FddiUpstreamNodeLong;

#define MSNdis_FddiUpstreamNodeLong_SIZE (FIELD_OFFSET(MSNdis_FddiUpstreamNodeLong, NdisFddiUpstreamNodeLong) + MSNdis_FddiUpstreamNodeLong_NdisFddiUpstreamNodeLong_SIZE)

// MSNdis_FddiDownstreamNodeLong - MSNdis_FddiDownstreamNodeLong
#define MSNdis_FddiDownstreamNodeLongGuid \
    { 0xacf1403f,0xa61c,0x11d0, { 0x8d,0xd4,0x00,0xc0,0x4f,0xc3,0x35,0x8c } }

#if ! (defined(MIDL_PASS))
DEFINE_GUID(MSNdis_FddiDownstreamNodeLong_GUID, \
            0xacf1403f,0xa61c,0x11d0,0x8d,0xd4,0x00,0xc0,0x4f,0xc3,0x35,0x8c);
#endif


typedef struct _MSNdis_FddiDownstreamNodeLong
{
    // 
    MSNdis_NetworkAddress NdisFddiDownstreamNodeLong;
    #define MSNdis_FddiDownstreamNodeLong_NdisFddiDownstreamNodeLong_SIZE sizeof(MSNdis_NetworkAddress)
    #define MSNdis_FddiDownstreamNodeLong_NdisFddiDownstreamNodeLong_ID 1

} MSNdis_FddiDownstreamNodeLong, *PMSNdis_FddiDownstreamNodeLong;

#define MSNdis_FddiDownstreamNodeLong_SIZE (FIELD_OFFSET(MSNdis_FddiDownstreamNodeLong, NdisFddiDownstreamNodeLong) + MSNdis_FddiDownstreamNodeLong_NdisFddiDownstreamNodeLong_SIZE)

// MSNdis_FddiFrameErrors - MSNdis_FddiFrameErrors
#define MSNdis_FddiFrameErrorsGuid \
    { 0xacf14040,0xa61c,0x11d0, { 0x8d,0xd4,0x00,0xc0,0x4f,0xc3,0x35,0x8c } }

#if ! (defined(MIDL_PASS))
DEFINE_GUID(MSNdis_FddiFrameErrors_GUID, \
            0xacf14040,0xa61c,0x11d0,0x8d,0xd4,0x00,0xc0,0x4f,0xc3,0x35,0x8c);
#endif


typedef struct _MSNdis_FddiFrameErrors
{
    // 
    ULONG NdisFddiFrameErrors;
    #define MSNdis_FddiFrameErrors_NdisFddiFrameErrors_SIZE sizeof(ULONG)
    #define MSNdis_FddiFrameErrors_NdisFddiFrameErrors_ID 1

} MSNdis_FddiFrameErrors, *PMSNdis_FddiFrameErrors;

#define MSNdis_FddiFrameErrors_SIZE (FIELD_OFFSET(MSNdis_FddiFrameErrors, NdisFddiFrameErrors) + MSNdis_FddiFrameErrors_NdisFddiFrameErrors_SIZE)

// MSNdis_FddiFramesLost - MSNdis_FddiFramesLost
#define MSNdis_FddiFramesLostGuid \
    { 0xacf14041,0xa61c,0x11d0, { 0x8d,0xd4,0x00,0xc0,0x4f,0xc3,0x35,0x8c } }

#if ! (defined(MIDL_PASS))
DEFINE_GUID(MSNdis_FddiFramesLost_GUID, \
            0xacf14041,0xa61c,0x11d0,0x8d,0xd4,0x00,0xc0,0x4f,0xc3,0x35,0x8c);
#endif


typedef struct _MSNdis_FddiFramesLost
{
    // 
    ULONG NdisFddiFramesLost;
    #define MSNdis_FddiFramesLost_NdisFddiFramesLost_SIZE sizeof(ULONG)
    #define MSNdis_FddiFramesLost_NdisFddiFramesLost_ID 1

} MSNdis_FddiFramesLost, *PMSNdis_FddiFramesLost;

#define MSNdis_FddiFramesLost_SIZE (FIELD_OFFSET(MSNdis_FddiFramesLost, NdisFddiFramesLost) + MSNdis_FddiFramesLost_NdisFddiFramesLost_SIZE)

// MSNdis_FddiRingManagmentState - MSNdis_FddiRingManagmentState
#define MSNdis_FddiRingManagmentStateGuid \
    { 0xacf14042,0xa61c,0x11d0, { 0x8d,0xd4,0x00,0xc0,0x4f,0xc3,0x35,0x8c } }

#if ! (defined(MIDL_PASS))
DEFINE_GUID(MSNdis_FddiRingManagmentState_GUID, \
            0xacf14042,0xa61c,0x11d0,0x8d,0xd4,0x00,0xc0,0x4f,0xc3,0x35,0x8c);
#endif


typedef struct _MSNdis_FddiRingManagmentState
{
    // 
    ULONG NdisFddiRingManagmentState;
    #define MSNdis_FddiRingManagmentState_NdisFddiRingManagmentState_SIZE sizeof(ULONG)
    #define MSNdis_FddiRingManagmentState_NdisFddiRingManagmentState_ID 1

} MSNdis_FddiRingManagmentState, *PMSNdis_FddiRingManagmentState;

#define MSNdis_FddiRingManagmentState_SIZE (FIELD_OFFSET(MSNdis_FddiRingManagmentState, NdisFddiRingManagmentState) + MSNdis_FddiRingManagmentState_NdisFddiRingManagmentState_SIZE)

// MSNdis_FddiLctFailures - MSNdis_FddiLctFailures
#define MSNdis_FddiLctFailuresGuid \
    { 0xacf14043,0xa61c,0x11d0, { 0x8d,0xd4,0x00,0xc0,0x4f,0xc3,0x35,0x8c } }

#if ! (defined(MIDL_PASS))
DEFINE_GUID(MSNdis_FddiLctFailures_GUID, \
            0xacf14043,0xa61c,0x11d0,0x8d,0xd4,0x00,0xc0,0x4f,0xc3,0x35,0x8c);
#endif


typedef struct _MSNdis_FddiLctFailures
{
    // 
    ULONG NdisFddiLctFailures;
    #define MSNdis_FddiLctFailures_NdisFddiLctFailures_SIZE sizeof(ULONG)
    #define MSNdis_FddiLctFailures_NdisFddiLctFailures_ID 1

} MSNdis_FddiLctFailures, *PMSNdis_FddiLctFailures;

#define MSNdis_FddiLctFailures_SIZE (FIELD_OFFSET(MSNdis_FddiLctFailures, NdisFddiLctFailures) + MSNdis_FddiLctFailures_NdisFddiLctFailures_SIZE)

// MSNdis_FddiLemRejects - MSNdis_FddiLemRejects
#define MSNdis_FddiLemRejectsGuid \
    { 0xacf14044,0xa61c,0x11d0, { 0x8d,0xd4,0x00,0xc0,0x4f,0xc3,0x35,0x8c } }

#if ! (defined(MIDL_PASS))
DEFINE_GUID(MSNdis_FddiLemRejects_GUID, \
            0xacf14044,0xa61c,0x11d0,0x8d,0xd4,0x00,0xc0,0x4f,0xc3,0x35,0x8c);
#endif


typedef struct _MSNdis_FddiLemRejects
{
    // 
    ULONG NdisFddiLemRejects;
    #define MSNdis_FddiLemRejects_NdisFddiLemRejects_SIZE sizeof(ULONG)
    #define MSNdis_FddiLemRejects_NdisFddiLemRejects_ID 1

} MSNdis_FddiLemRejects, *PMSNdis_FddiLemRejects;

#define MSNdis_FddiLemRejects_SIZE (FIELD_OFFSET(MSNdis_FddiLemRejects, NdisFddiLemRejects) + MSNdis_FddiLemRejects_NdisFddiLemRejects_SIZE)

// MSNdis_FddiLConnectionState - MSNdis_FddiLConnectionState
#define MSNdis_FddiLConnectionStateGuid \
    { 0xacf14045,0xa61c,0x11d0, { 0x8d,0xd4,0x00,0xc0,0x4f,0xc3,0x35,0x8c } }

#if ! (defined(MIDL_PASS))
DEFINE_GUID(MSNdis_FddiLConnectionState_GUID, \
            0xacf14045,0xa61c,0x11d0,0x8d,0xd4,0x00,0xc0,0x4f,0xc3,0x35,0x8c);
#endif


typedef struct _MSNdis_FddiLConnectionState
{
    // 
    ULONG NdisFddiLConnectionState;
    #define MSNdis_FddiLConnectionState_NdisFddiLConnectionState_SIZE sizeof(ULONG)
    #define MSNdis_FddiLConnectionState_NdisFddiLConnectionState_ID 1

} MSNdis_FddiLConnectionState, *PMSNdis_FddiLConnectionState;

#define MSNdis_FddiLConnectionState_SIZE (FIELD_OFFSET(MSNdis_FddiLConnectionState, NdisFddiLConnectionState) + MSNdis_FddiLConnectionState_NdisFddiLConnectionState_SIZE)

// MSNdis_ObjectHeader - MSNdis_ObjectHeader
#define MSNdis_ObjectHeaderGuid \
    { 0x2b1831b2,0x2216,0x4ede, { 0xa4,0x69,0x9f,0xe3,0xdd,0x6d,0x5a,0x7e } }

#if ! (defined(MIDL_PASS))
DEFINE_GUID(MSNdis_ObjectHeader_GUID, \
            0x2b1831b2,0x2216,0x4ede,0xa4,0x69,0x9f,0xe3,0xdd,0x6d,0x5a,0x7e);
#endif


typedef struct _MSNdis_ObjectHeader
{
    // 
    UCHAR Type;
    #define MSNdis_ObjectHeader_Type_SIZE sizeof(UCHAR)
    #define MSNdis_ObjectHeader_Type_ID 1

    // 
    UCHAR Revision;
    #define MSNdis_ObjectHeader_Revision_SIZE sizeof(UCHAR)
    #define MSNdis_ObjectHeader_Revision_ID 2

    // 
    USHORT Size;
    #define MSNdis_ObjectHeader_Size_SIZE sizeof(USHORT)
    #define MSNdis_ObjectHeader_Size_ID 3

} MSNdis_ObjectHeader, *PMSNdis_ObjectHeader;

#define MSNdis_ObjectHeader_SIZE (FIELD_OFFSET(MSNdis_ObjectHeader, Size) + MSNdis_ObjectHeader_Size_SIZE)

// MSNdis_WmiMethodHeader - MSNdis_WmiMethodHeader
#define MSNdis_WmiMethodHeaderGuid \
    { 0xe3eac9dd,0x2fd3,0x4963, { 0xbf,0xfd,0xb4,0x69,0x28,0x88,0xc0,0xd4 } }

#if ! (defined(MIDL_PASS))
DEFINE_GUID(MSNdis_WmiMethodHeader_GUID, \
            0xe3eac9dd,0x2fd3,0x4963,0xbf,0xfd,0xb4,0x69,0x28,0x88,0xc0,0xd4);
#endif


typedef struct _MSNdis_WmiMethodHeader
{
    // 
    MSNdis_ObjectHeader Header;
    #define MSNdis_WmiMethodHeader_Header_SIZE sizeof(MSNdis_ObjectHeader)
    #define MSNdis_WmiMethodHeader_Header_ID 1

    // 
    ULONG PortNumber;
    #define MSNdis_WmiMethodHeader_PortNumber_SIZE sizeof(ULONG)
    #define MSNdis_WmiMethodHeader_PortNumber_ID 2

    // 
    ULONGLONG NetLuid;
    #define MSNdis_WmiMethodHeader_NetLuid_SIZE sizeof(ULONGLONG)
    #define MSNdis_WmiMethodHeader_NetLuid_ID 3

    // 
    ULONGLONG RequestId;
    #define MSNdis_WmiMethodHeader_RequestId_SIZE sizeof(ULONGLONG)
    #define MSNdis_WmiMethodHeader_RequestId_ID 4

    // 
    ULONG Timeout;
    #define MSNdis_WmiMethodHeader_Timeout_SIZE sizeof(ULONG)
    #define MSNdis_WmiMethodHeader_Timeout_ID 5

    // 
    ULONG Padding;
    #define MSNdis_WmiMethodHeader_Padding_SIZE sizeof(ULONG)
    #define MSNdis_WmiMethodHeader_Padding_ID 6

} MSNdis_WmiMethodHeader, *PMSNdis_WmiMethodHeader;

#define MSNdis_WmiMethodHeader_SIZE (FIELD_OFFSET(MSNdis_WmiMethodHeader, Padding) + MSNdis_WmiMethodHeader_Padding_SIZE)

// MSNdis_WmiSetHeader - MSNdis_WmiSetHeader
#define MSNdis_WmiSetHeaderGuid \
    { 0x3b5605d8,0x1aaf,0x4ff6, { 0x85,0xb9,0xbc,0x5f,0xb9,0x73,0xdc,0x54 } }

#if ! (defined(MIDL_PASS))
DEFINE_GUID(MSNdis_WmiSetHeader_GUID, \
            0x3b5605d8,0x1aaf,0x4ff6,0x85,0xb9,0xbc,0x5f,0xb9,0x73,0xdc,0x54);
#endif


typedef struct _MSNdis_WmiSetHeader
{
    // 
    MSNdis_ObjectHeader Header;
    #define MSNdis_WmiSetHeader_Header_SIZE sizeof(MSNdis_ObjectHeader)
    #define MSNdis_WmiSetHeader_Header_ID 1

    // 
    ULONG PortNumber;
    #define MSNdis_WmiSetHeader_PortNumber_SIZE sizeof(ULONG)
    #define MSNdis_WmiSetHeader_PortNumber_ID 2

    // 
    ULONGLONG NetLuid;
    #define MSNdis_WmiSetHeader_NetLuid_SIZE sizeof(ULONGLONG)
    #define MSNdis_WmiSetHeader_NetLuid_ID 3

    // 
    ULONGLONG RequestId;
    #define MSNdis_WmiSetHeader_RequestId_SIZE sizeof(ULONGLONG)
    #define MSNdis_WmiSetHeader_RequestId_ID 4

    // 
    ULONG Timeout;
    #define MSNdis_WmiSetHeader_Timeout_SIZE sizeof(ULONG)
    #define MSNdis_WmiSetHeader_Timeout_ID 5

    // 
    ULONG Padding;
    #define MSNdis_WmiSetHeader_Padding_SIZE sizeof(ULONG)
    #define MSNdis_WmiSetHeader_Padding_ID 6

} MSNdis_WmiSetHeader, *PMSNdis_WmiSetHeader;

#define MSNdis_WmiSetHeader_SIZE (FIELD_OFFSET(MSNdis_WmiSetHeader, Padding) + MSNdis_WmiSetHeader_Padding_SIZE)

// MSNdis_WmiOutputInfo - MSNdis_WmiOutputInfo
#define MSNdis_WmiOutputInfoGuid \
    { 0x7510bb9d,0xdf70,0x4f7e, { 0xba,0x07,0xe2,0x9d,0x33,0x0b,0x3c,0xc5 } }

#if ! (defined(MIDL_PASS))
DEFINE_GUID(MSNdis_WmiOutputInfo_GUID, \
            0x7510bb9d,0xdf70,0x4f7e,0xba,0x07,0xe2,0x9d,0x33,0x0b,0x3c,0xc5);
#endif


typedef struct _MSNdis_WmiOutputInfo
{
    // 
    MSNdis_ObjectHeader Header;
    #define MSNdis_WmiOutputInfo_Header_SIZE sizeof(MSNdis_ObjectHeader)
    #define MSNdis_WmiOutputInfo_Header_ID 1

    // 
    ULONG Flags;
    #define MSNdis_WmiOutputInfo_Flags_SIZE sizeof(ULONG)
    #define MSNdis_WmiOutputInfo_Flags_ID 2

    // 
    UCHAR SupportedRevision;
    #define MSNdis_WmiOutputInfo_SupportedRevision_SIZE sizeof(UCHAR)
    #define MSNdis_WmiOutputInfo_SupportedRevision_ID 3

    // 
    UCHAR Padding1;
    #define MSNdis_WmiOutputInfo_Padding1_SIZE sizeof(UCHAR)
    #define MSNdis_WmiOutputInfo_Padding1_ID 4

    // 
    USHORT Padding2;
    #define MSNdis_WmiOutputInfo_Padding2_SIZE sizeof(USHORT)
    #define MSNdis_WmiOutputInfo_Padding2_ID 5

    // 
    ULONG DataOffset;
    #define MSNdis_WmiOutputInfo_DataOffset_SIZE sizeof(ULONG)
    #define MSNdis_WmiOutputInfo_DataOffset_ID 6

} MSNdis_WmiOutputInfo, *PMSNdis_WmiOutputInfo;

#define MSNdis_WmiOutputInfo_SIZE (FIELD_OFFSET(MSNdis_WmiOutputInfo, DataOffset) + MSNdis_WmiOutputInfo_DataOffset_SIZE)

// MSNdis_WmiEnumAdapter - MSNdis_WmiEnumAdapter
#define MSNdis_WmiEnumAdapterGuid \
    { 0xe7001b59,0xc3d6,0x4537, { 0xb4,0x0e,0xa1,0x63,0xd5,0x16,0xe4,0xa3 } }

#if ! (defined(MIDL_PASS))
DEFINE_GUID(MSNdis_WmiEnumAdapter_GUID, \
            0xe7001b59,0xc3d6,0x4537,0xb4,0x0e,0xa1,0x63,0xd5,0x16,0xe4,0xa3);
#endif


typedef struct _MSNdis_WmiEnumAdapter
{
    // 
    MSNdis_ObjectHeader Header;
    #define MSNdis_WmiEnumAdapter_Header_SIZE sizeof(MSNdis_ObjectHeader)
    #define MSNdis_WmiEnumAdapter_Header_ID 1

    // 
    ULONG IfIndex;
    #define MSNdis_WmiEnumAdapter_IfIndex_SIZE sizeof(ULONG)
    #define MSNdis_WmiEnumAdapter_IfIndex_ID 2

    // 
    ULONGLONG NetLuid;
    #define MSNdis_WmiEnumAdapter_NetLuid_SIZE sizeof(ULONGLONG)
    #define MSNdis_WmiEnumAdapter_NetLuid_ID 3

    // 
    CHAR VariableData[1];
    #define MSNdis_WmiEnumAdapter_DeviceName_ID 4

} MSNdis_WmiEnumAdapter, *PMSNdis_WmiEnumAdapter;

// MSNdis_LinkStateData - MSNdis_LinkStateData
#define MSNdis_LinkStateDataGuid \
    { 0x5b26b94f,0x0272,0x4d4c, { 0x87,0x44,0xbd,0x84,0xbe,0x42,0x1f,0x3b } }

#if ! (defined(MIDL_PASS))
DEFINE_GUID(MSNdis_LinkStateData_GUID, \
            0x5b26b94f,0x0272,0x4d4c,0x87,0x44,0xbd,0x84,0xbe,0x42,0x1f,0x3b);
#endif


typedef struct _MSNdis_LinkStateData
{
    // 
    MSNdis_ObjectHeader Header;
    #define MSNdis_LinkStateData_Header_SIZE sizeof(MSNdis_ObjectHeader)
    #define MSNdis_LinkStateData_Header_ID 1

    // 
    ULONG MediaConnectState;
    #define MSNdis_LinkStateData_MediaConnectState_SIZE sizeof(ULONG)
    #define MSNdis_LinkStateData_MediaConnectState_ID 2

    // 
    ULONG MediaDuplexState;
    #define MSNdis_LinkStateData_MediaDuplexState_SIZE sizeof(ULONG)
    #define MSNdis_LinkStateData_MediaDuplexState_ID 3

    // 
    ULONGLONG XmitLinkSpeed;
    #define MSNdis_LinkStateData_XmitLinkSpeed_SIZE sizeof(ULONGLONG)
    #define MSNdis_LinkStateData_XmitLinkSpeed_ID 4

    // 
    ULONGLONG RcvLinkSpeed;
    #define MSNdis_LinkStateData_RcvLinkSpeed_SIZE sizeof(ULONGLONG)
    #define MSNdis_LinkStateData_RcvLinkSpeed_ID 5

    // 
    ULONG PauseFunctions;
    #define MSNdis_LinkStateData_PauseFunctions_SIZE sizeof(ULONG)
    #define MSNdis_LinkStateData_PauseFunctions_ID 6

    // 
    ULONG AutoNegotiationFlags;
    #define MSNdis_LinkStateData_AutoNegotiationFlags_SIZE sizeof(ULONG)
    #define MSNdis_LinkStateData_AutoNegotiationFlags_ID 7

} MSNdis_LinkStateData, *PMSNdis_LinkStateData;

#define MSNdis_LinkStateData_SIZE (FIELD_OFFSET(MSNdis_LinkStateData, AutoNegotiationFlags) + MSNdis_LinkStateData_AutoNegotiationFlags_SIZE)

// MSNdis_LinkParameters - MSNdis_LinkParameters
#define MSNdis_LinkParametersGuid \
    { 0x29380131,0xa312,0x4400, { 0xbe,0x0c,0x53,0x87,0x7a,0x41,0xc4,0x65 } }

#if ! (defined(MIDL_PASS))
DEFINE_GUID(MSNdis_LinkParameters_GUID, \
            0x29380131,0xa312,0x4400,0xbe,0x0c,0x53,0x87,0x7a,0x41,0xc4,0x65);
#endif


typedef struct _MSNdis_LinkParameters
{
    // 
    MSNdis_ObjectHeader Header;
    #define MSNdis_LinkParameters_Header_SIZE sizeof(MSNdis_ObjectHeader)
    #define MSNdis_LinkParameters_Header_ID 1

    // 
    ULONG MediaDuplexState;
    #define MSNdis_LinkParameters_MediaDuplexState_SIZE sizeof(ULONG)
    #define MSNdis_LinkParameters_MediaDuplexState_ID 2

    // 
    ULONGLONG XmitLinkSpeed;
    #define MSNdis_LinkParameters_XmitLinkSpeed_SIZE sizeof(ULONGLONG)
    #define MSNdis_LinkParameters_XmitLinkSpeed_ID 3

    // 
    ULONGLONG RcvLinkSpeed;
    #define MSNdis_LinkParameters_RcvLinkSpeed_SIZE sizeof(ULONGLONG)
    #define MSNdis_LinkParameters_RcvLinkSpeed_ID 4

    // 
    ULONG PauseFunctions;
    #define MSNdis_LinkParameters_PauseFunctions_SIZE sizeof(ULONG)
    #define MSNdis_LinkParameters_PauseFunctions_ID 5

    // 
    ULONG AutoNegotiationFlags;
    #define MSNdis_LinkParameters_AutoNegotiationFlags_SIZE sizeof(ULONG)
    #define MSNdis_LinkParameters_AutoNegotiationFlags_ID 6

} MSNdis_LinkParameters, *PMSNdis_LinkParameters;

#define MSNdis_LinkParameters_SIZE (FIELD_OFFSET(MSNdis_LinkParameters, AutoNegotiationFlags) + MSNdis_LinkParameters_AutoNegotiationFlags_SIZE)

// MSNdis_InterruptModerationParameters - MSNdis_InterruptModerationParameters
#define MSNdis_InterruptModerationParametersGuid \
    { 0x09f58643,0x31fb,0x45b5, { 0x85,0x2b,0x09,0xb4,0xd3,0xff,0x37,0x65 } }

#if ! (defined(MIDL_PASS))
DEFINE_GUID(MSNdis_InterruptModerationParameters_GUID, \
            0x09f58643,0x31fb,0x45b5,0x85,0x2b,0x09,0xb4,0xd3,0xff,0x37,0x65);
#endif


typedef struct _MSNdis_InterruptModerationParameters
{
    // 
    MSNdis_ObjectHeader Header;
    #define MSNdis_InterruptModerationParameters_Header_SIZE sizeof(MSNdis_ObjectHeader)
    #define MSNdis_InterruptModerationParameters_Header_ID 1

    // 
    ULONG Flags;
    #define MSNdis_InterruptModerationParameters_Flags_SIZE sizeof(ULONG)
    #define MSNdis_InterruptModerationParameters_Flags_ID 2

    // 
    ULONG InterruptModeration;
    #define MSNdis_InterruptModerationParameters_InterruptModeration_SIZE sizeof(ULONG)
    #define MSNdis_InterruptModerationParameters_InterruptModeration_ID 3

} MSNdis_InterruptModerationParameters, *PMSNdis_InterruptModerationParameters;

#define MSNdis_InterruptModerationParameters_SIZE (FIELD_OFFSET(MSNdis_InterruptModerationParameters, InterruptModeration) + MSNdis_InterruptModerationParameters_InterruptModeration_SIZE)

// MSNdis_StatisticsInfo - MSNdis_StatisticsInfo
#define MSNdis_StatisticsInfoGuid \
    { 0x8ecc74e1,0xba85,0x482e, { 0xaf,0xaf,0xb4,0xf8,0xb0,0x87,0xc0,0x6b } }

#if ! (defined(MIDL_PASS))
DEFINE_GUID(MSNdis_StatisticsInfo_GUID, \
            0x8ecc74e1,0xba85,0x482e,0xaf,0xaf,0xb4,0xf8,0xb0,0x87,0xc0,0x6b);
#endif


typedef struct _MSNdis_StatisticsInfo
{
    // 
    MSNdis_ObjectHeader Header;
    #define MSNdis_StatisticsInfo_Header_SIZE sizeof(MSNdis_ObjectHeader)
    #define MSNdis_StatisticsInfo_Header_ID 1

    // 
    ULONG SupportedStatistics;
    #define MSNdis_StatisticsInfo_SupportedStatistics_SIZE sizeof(ULONG)
    #define MSNdis_StatisticsInfo_SupportedStatistics_ID 2

    // 
    ULONGLONG ifInDiscards;
    #define MSNdis_StatisticsInfo_ifInDiscards_SIZE sizeof(ULONGLONG)
    #define MSNdis_StatisticsInfo_ifInDiscards_ID 3

    // 
    ULONGLONG ifInErrors;
    #define MSNdis_StatisticsInfo_ifInErrors_SIZE sizeof(ULONGLONG)
    #define MSNdis_StatisticsInfo_ifInErrors_ID 4

    // 
    ULONGLONG ifHCInOctets;
    #define MSNdis_StatisticsInfo_ifHCInOctets_SIZE sizeof(ULONGLONG)
    #define MSNdis_StatisticsInfo_ifHCInOctets_ID 5

    // 
    ULONGLONG ifHCInUcastPkts;
    #define MSNdis_StatisticsInfo_ifHCInUcastPkts_SIZE sizeof(ULONGLONG)
    #define MSNdis_StatisticsInfo_ifHCInUcastPkts_ID 6

    // 
    ULONGLONG ifHCInMulticastPkts;
    #define MSNdis_StatisticsInfo_ifHCInMulticastPkts_SIZE sizeof(ULONGLONG)
    #define MSNdis_StatisticsInfo_ifHCInMulticastPkts_ID 7

    // 
    ULONGLONG ifHCInBroadcastPkts;
    #define MSNdis_StatisticsInfo_ifHCInBroadcastPkts_SIZE sizeof(ULONGLONG)
    #define MSNdis_StatisticsInfo_ifHCInBroadcastPkts_ID 8

    // 
    ULONGLONG ifHCOutOctets;
    #define MSNdis_StatisticsInfo_ifHCOutOctets_SIZE sizeof(ULONGLONG)
    #define MSNdis_StatisticsInfo_ifHCOutOctets_ID 9

    // 
    ULONGLONG ifHCOutUcastPkts;
    #define MSNdis_StatisticsInfo_ifHCOutUcastPkts_SIZE sizeof(ULONGLONG)
    #define MSNdis_StatisticsInfo_ifHCOutUcastPkts_ID 10

    // 
    ULONGLONG ifHCOutMulticastPkts;
    #define MSNdis_StatisticsInfo_ifHCOutMulticastPkts_SIZE sizeof(ULONGLONG)
    #define MSNdis_StatisticsInfo_ifHCOutMulticastPkts_ID 11

    // 
    ULONGLONG ifHCOutBroadcastPkts;
    #define MSNdis_StatisticsInfo_ifHCOutBroadcastPkts_SIZE sizeof(ULONGLONG)
    #define MSNdis_StatisticsInfo_ifHCOutBroadcastPkts_ID 12

    // 
    ULONGLONG ifOutErrors;
    #define MSNdis_StatisticsInfo_ifOutErrors_SIZE sizeof(ULONGLONG)
    #define MSNdis_StatisticsInfo_ifOutErrors_ID 13

    // 
    ULONGLONG ifOutDiscards;
    #define MSNdis_StatisticsInfo_ifOutDiscards_SIZE sizeof(ULONGLONG)
    #define MSNdis_StatisticsInfo_ifOutDiscards_ID 14

    // 
    ULONGLONG ifHCInUcastOctets;
    #define MSNdis_StatisticsInfo_ifHCInUcastOctets_SIZE sizeof(ULONGLONG)
    #define MSNdis_StatisticsInfo_ifHCInUcastOctets_ID 15

    // 
    ULONGLONG ifHCInMulticastOctets;
    #define MSNdis_StatisticsInfo_ifHCInMulticastOctets_SIZE sizeof(ULONGLONG)
    #define MSNdis_StatisticsInfo_ifHCInMulticastOctets_ID 16

    // 
    ULONGLONG ifHCInBroadcastOctets;
    #define MSNdis_StatisticsInfo_ifHCInBroadcastOctets_SIZE sizeof(ULONGLONG)
    #define MSNdis_StatisticsInfo_ifHCInBroadcastOctets_ID 17

    // 
    ULONGLONG ifHCOutUcastOctets;
    #define MSNdis_StatisticsInfo_ifHCOutUcastOctets_SIZE sizeof(ULONGLONG)
    #define MSNdis_StatisticsInfo_ifHCOutUcastOctets_ID 18

    // 
    ULONGLONG ifHCOutMulticastOctets;
    #define MSNdis_StatisticsInfo_ifHCOutMulticastOctets_SIZE sizeof(ULONGLONG)
    #define MSNdis_StatisticsInfo_ifHCOutMulticastOctets_ID 19

    // 
    ULONGLONG ifHCOutBroadcastOctets;
    #define MSNdis_StatisticsInfo_ifHCOutBroadcastOctets_SIZE sizeof(ULONGLONG)
    #define MSNdis_StatisticsInfo_ifHCOutBroadcastOctets_ID 20

} MSNdis_StatisticsInfo, *PMSNdis_StatisticsInfo;

#define MSNdis_StatisticsInfo_SIZE (FIELD_OFFSET(MSNdis_StatisticsInfo, ifHCOutBroadcastOctets) + MSNdis_StatisticsInfo_ifHCOutBroadcastOctets_SIZE)

// MSNdis_PortStateData - MSNdis_PortStateData
#define MSNdis_PortStateDataGuid \
    { 0x8feae2c6,0xee28,0x469f, { 0x8b,0x5d,0x9f,0x74,0x3b,0xab,0x21,0xaa } }

#if ! (defined(MIDL_PASS))
DEFINE_GUID(MSNdis_PortStateData_GUID, \
            0x8feae2c6,0xee28,0x469f,0x8b,0x5d,0x9f,0x74,0x3b,0xab,0x21,0xaa);
#endif


typedef struct _MSNdis_PortStateData
{
    // 
    MSNdis_ObjectHeader Header;
    #define MSNdis_PortStateData_Header_SIZE sizeof(MSNdis_ObjectHeader)
    #define MSNdis_PortStateData_Header_ID 1

    // 
    ULONG MediaConnectState;
    #define MSNdis_PortStateData_MediaConnectState_SIZE sizeof(ULONG)
    #define MSNdis_PortStateData_MediaConnectState_ID 2

    // 
    ULONGLONG XmitLinkSpeed;
    #define MSNdis_PortStateData_XmitLinkSpeed_SIZE sizeof(ULONGLONG)
    #define MSNdis_PortStateData_XmitLinkSpeed_ID 3

    // 
    ULONGLONG RcvLinkSpeed;
    #define MSNdis_PortStateData_RcvLinkSpeed_SIZE sizeof(ULONGLONG)
    #define MSNdis_PortStateData_RcvLinkSpeed_ID 4

    // 
    ULONG Direction;
    #define MSNdis_PortStateData_Direction_SIZE sizeof(ULONG)
    #define MSNdis_PortStateData_Direction_ID 5

    // 
    ULONG SendControlState;
    #define MSNdis_PortStateData_SendControlState_SIZE sizeof(ULONG)
    #define MSNdis_PortStateData_SendControlState_ID 6

    // 
    ULONG RcvControlState;
    #define MSNdis_PortStateData_RcvControlState_SIZE sizeof(ULONG)
    #define MSNdis_PortStateData_RcvControlState_ID 7

    // 
    ULONG SendAuthorizationState;
    #define MSNdis_PortStateData_SendAuthorizationState_SIZE sizeof(ULONG)
    #define MSNdis_PortStateData_SendAuthorizationState_ID 8

    // 
    ULONG RcvAuthorizationState;
    #define MSNdis_PortStateData_RcvAuthorizationState_SIZE sizeof(ULONG)
    #define MSNdis_PortStateData_RcvAuthorizationState_ID 9

    // 
    ULONG Flags;
    #define MSNdis_PortStateData_Flags_SIZE sizeof(ULONG)
    #define MSNdis_PortStateData_Flags_ID 10

} MSNdis_PortStateData, *PMSNdis_PortStateData;

#define MSNdis_PortStateData_SIZE (FIELD_OFFSET(MSNdis_PortStateData, Flags) + MSNdis_PortStateData_Flags_SIZE)

// MSNdis_PortAuthParameters - MSNdis_PortAuthParameters
#define MSNdis_PortAuthParametersGuid \
    { 0x5c3bda24,0x8b64,0x4829, { 0xa5,0x87,0x8c,0xe7,0x19,0x15,0x2f,0xe2 } }

#if ! (defined(MIDL_PASS))
DEFINE_GUID(MSNdis_PortAuthParameters_GUID, \
            0x5c3bda24,0x8b64,0x4829,0xa5,0x87,0x8c,0xe7,0x19,0x15,0x2f,0xe2);
#endif


typedef struct _MSNdis_PortAuthParameters
{
    // 
    MSNdis_ObjectHeader Header;
    #define MSNdis_PortAuthParameters_Header_SIZE sizeof(MSNdis_ObjectHeader)
    #define MSNdis_PortAuthParameters_Header_ID 1

    // 
    ULONG SendControlState;
    #define MSNdis_PortAuthParameters_SendControlState_SIZE sizeof(ULONG)
    #define MSNdis_PortAuthParameters_SendControlState_ID 2

    // 
    ULONG RcvControlState;
    #define MSNdis_PortAuthParameters_RcvControlState_SIZE sizeof(ULONG)
    #define MSNdis_PortAuthParameters_RcvControlState_ID 3

    // 
    ULONG SendAuthorizationState;
    #define MSNdis_PortAuthParameters_SendAuthorizationState_SIZE sizeof(ULONG)
    #define MSNdis_PortAuthParameters_SendAuthorizationState_ID 4

    // 
    ULONG RcvAuthorizationState;
    #define MSNdis_PortAuthParameters_RcvAuthorizationState_SIZE sizeof(ULONG)
    #define MSNdis_PortAuthParameters_RcvAuthorizationState_ID 5

} MSNdis_PortAuthParameters, *PMSNdis_PortAuthParameters;

#define MSNdis_PortAuthParameters_SIZE (FIELD_OFFSET(MSNdis_PortAuthParameters, RcvAuthorizationState) + MSNdis_PortAuthParameters_RcvAuthorizationState_SIZE)

// MSNdis_PortChar - MSNdis_PortChar
#define MSNdis_PortCharGuid \
    { 0xf5b7d202,0xe594,0x4aa3, { 0xbe,0x43,0x49,0x76,0x83,0x3c,0x78,0x40 } }

#if ! (defined(MIDL_PASS))
DEFINE_GUID(MSNdis_PortChar_GUID, \
            0xf5b7d202,0xe594,0x4aa3,0xbe,0x43,0x49,0x76,0x83,0x3c,0x78,0x40);
#endif


typedef struct _MSNdis_PortChar
{
    // 
    MSNdis_ObjectHeader Header;
    #define MSNdis_PortChar_Header_SIZE sizeof(MSNdis_ObjectHeader)
    #define MSNdis_PortChar_Header_ID 1

    // 
    ULONG PortNumber;
    #define MSNdis_PortChar_PortNumber_SIZE sizeof(ULONG)
    #define MSNdis_PortChar_PortNumber_ID 2

    // 
    ULONG Flags;
    #define MSNdis_PortChar_Flags_SIZE sizeof(ULONG)
    #define MSNdis_PortChar_Flags_ID 3

    // 
    ULONG Type;
    #define MSNdis_PortChar_Type_SIZE sizeof(ULONG)
    #define MSNdis_PortChar_Type_ID 4

    // 
    ULONG MediaConnectState;
    #define MSNdis_PortChar_MediaConnectState_SIZE sizeof(ULONG)
    #define MSNdis_PortChar_MediaConnectState_ID 5

    // 
    ULONGLONG XmitLinkSpeed;
    #define MSNdis_PortChar_XmitLinkSpeed_SIZE sizeof(ULONGLONG)
    #define MSNdis_PortChar_XmitLinkSpeed_ID 6

    // 
    ULONGLONG RcvLinkSpeed;
    #define MSNdis_PortChar_RcvLinkSpeed_SIZE sizeof(ULONGLONG)
    #define MSNdis_PortChar_RcvLinkSpeed_ID 7

    // 
    ULONG Direction;
    #define MSNdis_PortChar_Direction_SIZE sizeof(ULONG)
    #define MSNdis_PortChar_Direction_ID 8

    // 
    ULONG SendControlState;
    #define MSNdis_PortChar_SendControlState_SIZE sizeof(ULONG)
    #define MSNdis_PortChar_SendControlState_ID 9

    // 
    ULONG RcvControlState;
    #define MSNdis_PortChar_RcvControlState_SIZE sizeof(ULONG)
    #define MSNdis_PortChar_RcvControlState_ID 10

    // 
    ULONG SendAuthorizationState;
    #define MSNdis_PortChar_SendAuthorizationState_SIZE sizeof(ULONG)
    #define MSNdis_PortChar_SendAuthorizationState_ID 11

    // 
    ULONG RcvAuthorizationState;
    #define MSNdis_PortChar_RcvAuthorizationState_SIZE sizeof(ULONG)
    #define MSNdis_PortChar_RcvAuthorizationState_ID 12

} MSNdis_PortChar, *PMSNdis_PortChar;

#define MSNdis_PortChar_SIZE (FIELD_OFFSET(MSNdis_PortChar, RcvAuthorizationState) + MSNdis_PortChar_RcvAuthorizationState_SIZE)

// MSNdis_PortArray - MSNdis_PortArray
#define MSNdis_PortArrayGuid \
    { 0x0fee8708,0xdf65,0x456e, { 0xb4,0xca,0xfa,0x62,0x32,0x66,0xa1,0x2a } }

#if ! (defined(MIDL_PASS))
DEFINE_GUID(MSNdis_PortArray_GUID, \
            0x0fee8708,0xdf65,0x456e,0xb4,0xca,0xfa,0x62,0x32,0x66,0xa1,0x2a);
#endif


typedef struct _MSNdis_PortArray
{
    // 
    MSNdis_ObjectHeader Header;
    #define MSNdis_PortArray_Header_SIZE sizeof(MSNdis_ObjectHeader)
    #define MSNdis_PortArray_Header_ID 1

    // 
    ULONG NumberOfPorts;
    #define MSNdis_PortArray_NumberOfPorts_SIZE sizeof(ULONG)
    #define MSNdis_PortArray_NumberOfPorts_ID 2

    // 
    ULONG OffsetFirstPort;
    #define MSNdis_PortArray_OffsetFirstPort_SIZE sizeof(ULONG)
    #define MSNdis_PortArray_OffsetFirstPort_ID 3

    // 
    ULONG ElementSize;
    #define MSNdis_PortArray_ElementSize_SIZE sizeof(ULONG)
    #define MSNdis_PortArray_ElementSize_ID 4

    // 
    MSNdis_PortChar Port[1];
    #define MSNdis_PortArray_Port_ID 5

} MSNdis_PortArray, *PMSNdis_PortArray;

// MSNdis_PciDeviceProperty - MSNdis_PciDeviceProperty
#define MSNdis_PciDevicePropertyGuid \
    { 0x0573f70f,0xded8,0x401c, { 0x8b,0x56,0xa6,0x2b,0xb5,0x28,0xc0,0xe2 } }

#if ! (defined(MIDL_PASS))
DEFINE_GUID(MSNdis_PciDeviceProperty_GUID, \
            0x0573f70f,0xded8,0x401c,0x8b,0x56,0xa6,0x2b,0xb5,0x28,0xc0,0xe2);
#endif


typedef struct _MSNdis_PciDeviceProperty
{
    // 
    MSNdis_ObjectHeader Header;
    #define MSNdis_PciDeviceProperty_Header_SIZE sizeof(MSNdis_ObjectHeader)
    #define MSNdis_PciDeviceProperty_Header_ID 1

    // 
    ULONG DeviceType;
    #define MSNdis_PciDeviceProperty_DeviceType_SIZE sizeof(ULONG)
    #define MSNdis_PciDeviceProperty_DeviceType_ID 2

    // 
    ULONG CurrentSpeedAndMode;
    #define MSNdis_PciDeviceProperty_CurrentSpeedAndMode_SIZE sizeof(ULONG)
    #define MSNdis_PciDeviceProperty_CurrentSpeedAndMode_ID 3

    // 
    ULONG CurrentPayloadSize;
    #define MSNdis_PciDeviceProperty_CurrentPayloadSize_SIZE sizeof(ULONG)
    #define MSNdis_PciDeviceProperty_CurrentPayloadSize_ID 4

    // 
    ULONG MaxPayloadSize;
    #define MSNdis_PciDeviceProperty_MaxPayloadSize_SIZE sizeof(ULONG)
    #define MSNdis_PciDeviceProperty_MaxPayloadSize_ID 5

    // 
    ULONG MaxReadRequestSize;
    #define MSNdis_PciDeviceProperty_MaxReadRequestSize_SIZE sizeof(ULONG)
    #define MSNdis_PciDeviceProperty_MaxReadRequestSize_ID 6

    // 
    ULONG CurrentLinkSpeed;
    #define MSNdis_PciDeviceProperty_CurrentLinkSpeed_SIZE sizeof(ULONG)
    #define MSNdis_PciDeviceProperty_CurrentLinkSpeed_ID 7

    // 
    ULONG CurrentLinkWidth;
    #define MSNdis_PciDeviceProperty_CurrentLinkWidth_SIZE sizeof(ULONG)
    #define MSNdis_PciDeviceProperty_CurrentLinkWidth_ID 8

    // 
    ULONG MaxLinkSpeed;
    #define MSNdis_PciDeviceProperty_MaxLinkSpeed_SIZE sizeof(ULONG)
    #define MSNdis_PciDeviceProperty_MaxLinkSpeed_ID 9

    // 
    ULONG MaxLinkWidth;
    #define MSNdis_PciDeviceProperty_MaxLinkWidth_SIZE sizeof(ULONG)
    #define MSNdis_PciDeviceProperty_MaxLinkWidth_ID 10

} MSNdis_PciDeviceProperty, *PMSNdis_PciDeviceProperty;

#define MSNdis_PciDeviceProperty_SIZE (FIELD_OFFSET(MSNdis_PciDeviceProperty, MaxLinkWidth) + MSNdis_PciDeviceProperty_MaxLinkWidth_SIZE)

// MSNdis_WmiTcpLargeSendOffloadV1_IPv4 - MSNdis_WmiTcpLargeSendOffloadV1_IPv4
#define MSNdis_WmiTcpLargeSendOffloadV1_IPv4Guid \
    { 0xd7673b11,0xe892,0x4a9d, { 0x8b,0xd8,0x76,0x1f,0xf2,0x56,0xed,0xd9 } }

#if ! (defined(MIDL_PASS))
DEFINE_GUID(MSNdis_WmiTcpLargeSendOffloadV1_IPv4_GUID, \
            0xd7673b11,0xe892,0x4a9d,0x8b,0xd8,0x76,0x1f,0xf2,0x56,0xed,0xd9);
#endif


typedef struct _MSNdis_WmiTcpLargeSendOffloadV1_IPv4
{
    // 
    ULONG Encapsulation;
    #define MSNdis_WmiTcpLargeSendOffloadV1_IPv4_Encapsulation_SIZE sizeof(ULONG)
    #define MSNdis_WmiTcpLargeSendOffloadV1_IPv4_Encapsulation_ID 1

    // 
    ULONG MaxOffLoadSize;
    #define MSNdis_WmiTcpLargeSendOffloadV1_IPv4_MaxOffLoadSize_SIZE sizeof(ULONG)
    #define MSNdis_WmiTcpLargeSendOffloadV1_IPv4_MaxOffLoadSize_ID 2

    // 
    ULONG MinSegmentCount;
    #define MSNdis_WmiTcpLargeSendOffloadV1_IPv4_MinSegmentCount_SIZE sizeof(ULONG)
    #define MSNdis_WmiTcpLargeSendOffloadV1_IPv4_MinSegmentCount_ID 3

    // 
    ULONG TcpOptions;
    #define MSNdis_WmiTcpLargeSendOffloadV1_IPv4_TcpOptions_SIZE sizeof(ULONG)
    #define MSNdis_WmiTcpLargeSendOffloadV1_IPv4_TcpOptions_ID 4

    // 
    ULONG IpOptions;
    #define MSNdis_WmiTcpLargeSendOffloadV1_IPv4_IpOptions_SIZE sizeof(ULONG)
    #define MSNdis_WmiTcpLargeSendOffloadV1_IPv4_IpOptions_ID 5

} MSNdis_WmiTcpLargeSendOffloadV1_IPv4, *PMSNdis_WmiTcpLargeSendOffloadV1_IPv4;

#define MSNdis_WmiTcpLargeSendOffloadV1_IPv4_SIZE (FIELD_OFFSET(MSNdis_WmiTcpLargeSendOffloadV1_IPv4, IpOptions) + MSNdis_WmiTcpLargeSendOffloadV1_IPv4_IpOptions_SIZE)

// MSNdis_WmiTcpLargeSendOffloadV1 - MSNdis_WmiTcpLargeSendOffloadV1
#define MSNdis_WmiTcpLargeSendOffloadV1Guid \
    { 0xb9e4e2f9,0xee89,0x4756, { 0xb0,0x57,0x38,0xf9,0xd9,0xb5,0x9a,0x92 } }

#if ! (defined(MIDL_PASS))
DEFINE_GUID(MSNdis_WmiTcpLargeSendOffloadV1_GUID, \
            0xb9e4e2f9,0xee89,0x4756,0xb0,0x57,0x38,0xf9,0xd9,0xb5,0x9a,0x92);
#endif


typedef struct _MSNdis_WmiTcpLargeSendOffloadV1
{
    // 
    MSNdis_WmiTcpLargeSendOffloadV1_IPv4 WmiIPv4;
    #define MSNdis_WmiTcpLargeSendOffloadV1_WmiIPv4_SIZE sizeof(MSNdis_WmiTcpLargeSendOffloadV1_IPv4)
    #define MSNdis_WmiTcpLargeSendOffloadV1_WmiIPv4_ID 1

} MSNdis_WmiTcpLargeSendOffloadV1, *PMSNdis_WmiTcpLargeSendOffloadV1;

#define MSNdis_WmiTcpLargeSendOffloadV1_SIZE (FIELD_OFFSET(MSNdis_WmiTcpLargeSendOffloadV1, WmiIPv4) + MSNdis_WmiTcpLargeSendOffloadV1_WmiIPv4_SIZE)

// MSNdis_WmiTcpIpChecksumOffload_IPv4TransmitReceive - MSNdis_WmiTcpIpChecksumOffload_IPv4TransmitReceive
#define MSNdis_WmiTcpIpChecksumOffload_IPv4TransmitReceiveGuid \
    { 0xd63d537a,0x59c1,0x4fae, { 0x8f,0x9b,0xcd,0x9f,0xbb,0xec,0xb8,0x5a } }

#if ! (defined(MIDL_PASS))
DEFINE_GUID(MSNdis_WmiTcpIpChecksumOffload_IPv4TransmitReceive_GUID, \
            0xd63d537a,0x59c1,0x4fae,0x8f,0x9b,0xcd,0x9f,0xbb,0xec,0xb8,0x5a);
#endif


typedef struct _MSNdis_WmiTcpIpChecksumOffload_IPv4TransmitReceive
{
    // 
    ULONG Encapsulation;
    #define MSNdis_WmiTcpIpChecksumOffload_IPv4TransmitReceive_Encapsulation_SIZE sizeof(ULONG)
    #define MSNdis_WmiTcpIpChecksumOffload_IPv4TransmitReceive_Encapsulation_ID 1

    // 
    ULONG IpOptionsSupported;
    #define MSNdis_WmiTcpIpChecksumOffload_IPv4TransmitReceive_IpOptionsSupported_SIZE sizeof(ULONG)
    #define MSNdis_WmiTcpIpChecksumOffload_IPv4TransmitReceive_IpOptionsSupported_ID 2

    // 
    ULONG TcpOptionsSupported;
    #define MSNdis_WmiTcpIpChecksumOffload_IPv4TransmitReceive_TcpOptionsSupported_SIZE sizeof(ULONG)
    #define MSNdis_WmiTcpIpChecksumOffload_IPv4TransmitReceive_TcpOptionsSupported_ID 3

    // 
    ULONG TcpChecksum;
    #define MSNdis_WmiTcpIpChecksumOffload_IPv4TransmitReceive_TcpChecksum_SIZE sizeof(ULONG)
    #define MSNdis_WmiTcpIpChecksumOffload_IPv4TransmitReceive_TcpChecksum_ID 4

    // 
    ULONG UdpChecksum;
    #define MSNdis_WmiTcpIpChecksumOffload_IPv4TransmitReceive_UdpChecksum_SIZE sizeof(ULONG)
    #define MSNdis_WmiTcpIpChecksumOffload_IPv4TransmitReceive_UdpChecksum_ID 5

    // 
    ULONG IpChecksum;
    #define MSNdis_WmiTcpIpChecksumOffload_IPv4TransmitReceive_IpChecksum_SIZE sizeof(ULONG)
    #define MSNdis_WmiTcpIpChecksumOffload_IPv4TransmitReceive_IpChecksum_ID 6

} MSNdis_WmiTcpIpChecksumOffload_IPv4TransmitReceive, *PMSNdis_WmiTcpIpChecksumOffload_IPv4TransmitReceive;

#define MSNdis_WmiTcpIpChecksumOffload_IPv4TransmitReceive_SIZE (FIELD_OFFSET(MSNdis_WmiTcpIpChecksumOffload_IPv4TransmitReceive, IpChecksum) + MSNdis_WmiTcpIpChecksumOffload_IPv4TransmitReceive_IpChecksum_SIZE)

// MSNdis_WmiTcpIpChecksumOffload_IPv6TransmitReceive - MSNdis_WmiTcpIpChecksumOffload_IPv6TransmitReceive
#define MSNdis_WmiTcpIpChecksumOffload_IPv6TransmitReceiveGuid \
    { 0xb9760e75,0x6662,0x49e4, { 0xaa,0x6c,0xf0,0x28,0xbe,0xfe,0xc8,0xee } }

#if ! (defined(MIDL_PASS))
DEFINE_GUID(MSNdis_WmiTcpIpChecksumOffload_IPv6TransmitReceive_GUID, \
            0xb9760e75,0x6662,0x49e4,0xaa,0x6c,0xf0,0x28,0xbe,0xfe,0xc8,0xee);
#endif


typedef struct _MSNdis_WmiTcpIpChecksumOffload_IPv6TransmitReceive
{
    // 
    ULONG Encapsulation;
    #define MSNdis_WmiTcpIpChecksumOffload_IPv6TransmitReceive_Encapsulation_SIZE sizeof(ULONG)
    #define MSNdis_WmiTcpIpChecksumOffload_IPv6TransmitReceive_Encapsulation_ID 1

    // 
    ULONG IpExtensionHeadersSupported;
    #define MSNdis_WmiTcpIpChecksumOffload_IPv6TransmitReceive_IpExtensionHeadersSupported_SIZE sizeof(ULONG)
    #define MSNdis_WmiTcpIpChecksumOffload_IPv6TransmitReceive_IpExtensionHeadersSupported_ID 2

    // 
    ULONG TcpOptionsSupported;
    #define MSNdis_WmiTcpIpChecksumOffload_IPv6TransmitReceive_TcpOptionsSupported_SIZE sizeof(ULONG)
    #define MSNdis_WmiTcpIpChecksumOffload_IPv6TransmitReceive_TcpOptionsSupported_ID 3

    // 
    ULONG TcpChecksum;
    #define MSNdis_WmiTcpIpChecksumOffload_IPv6TransmitReceive_TcpChecksum_SIZE sizeof(ULONG)
    #define MSNdis_WmiTcpIpChecksumOffload_IPv6TransmitReceive_TcpChecksum_ID 4

    // 
    ULONG UdpChecksum;
    #define MSNdis_WmiTcpIpChecksumOffload_IPv6TransmitReceive_UdpChecksum_SIZE sizeof(ULONG)
    #define MSNdis_WmiTcpIpChecksumOffload_IPv6TransmitReceive_UdpChecksum_ID 5

} MSNdis_WmiTcpIpChecksumOffload_IPv6TransmitReceive, *PMSNdis_WmiTcpIpChecksumOffload_IPv6TransmitReceive;

#define MSNdis_WmiTcpIpChecksumOffload_IPv6TransmitReceive_SIZE (FIELD_OFFSET(MSNdis_WmiTcpIpChecksumOffload_IPv6TransmitReceive, UdpChecksum) + MSNdis_WmiTcpIpChecksumOffload_IPv6TransmitReceive_UdpChecksum_SIZE)

// MSNdis_WmiTcpIpChecksumOffload - MSNdis_WmiTcpIpChecksumOffload
#define MSNdis_WmiTcpIpChecksumOffloadGuid \
    { 0x189d4015,0x1b25,0x4d8e, { 0xa4,0xa9,0xf9,0xeb,0xa8,0x21,0x97,0xc7 } }

#if ! (defined(MIDL_PASS))
DEFINE_GUID(MSNdis_WmiTcpIpChecksumOffload_GUID, \
            0x189d4015,0x1b25,0x4d8e,0xa4,0xa9,0xf9,0xeb,0xa8,0x21,0x97,0xc7);
#endif


typedef struct _MSNdis_WmiTcpIpChecksumOffload
{
    // 
    MSNdis_WmiTcpIpChecksumOffload_IPv4TransmitReceive IPv4Transmit;
    #define MSNdis_WmiTcpIpChecksumOffload_IPv4Transmit_SIZE sizeof(MSNdis_WmiTcpIpChecksumOffload_IPv4TransmitReceive)
    #define MSNdis_WmiTcpIpChecksumOffload_IPv4Transmit_ID 1

    // 
    MSNdis_WmiTcpIpChecksumOffload_IPv4TransmitReceive IPv4Receive;
    #define MSNdis_WmiTcpIpChecksumOffload_IPv4Receive_SIZE sizeof(MSNdis_WmiTcpIpChecksumOffload_IPv4TransmitReceive)
    #define MSNdis_WmiTcpIpChecksumOffload_IPv4Receive_ID 2

    // 
    MSNdis_WmiTcpIpChecksumOffload_IPv6TransmitReceive IPv6Transmit;
    #define MSNdis_WmiTcpIpChecksumOffload_IPv6Transmit_SIZE sizeof(MSNdis_WmiTcpIpChecksumOffload_IPv6TransmitReceive)
    #define MSNdis_WmiTcpIpChecksumOffload_IPv6Transmit_ID 3

    // 
    MSNdis_WmiTcpIpChecksumOffload_IPv6TransmitReceive IPv6Receive;
    #define MSNdis_WmiTcpIpChecksumOffload_IPv6Receive_SIZE sizeof(MSNdis_WmiTcpIpChecksumOffload_IPv6TransmitReceive)
    #define MSNdis_WmiTcpIpChecksumOffload_IPv6Receive_ID 4

} MSNdis_WmiTcpIpChecksumOffload, *PMSNdis_WmiTcpIpChecksumOffload;

#define MSNdis_WmiTcpIpChecksumOffload_SIZE (FIELD_OFFSET(MSNdis_WmiTcpIpChecksumOffload, IPv6Receive) + MSNdis_WmiTcpIpChecksumOffload_IPv6Receive_SIZE)

// MSNdis_WmiIPSecOffloadV1_Supported - MSNdis_WmiIPSecOffloadV1_Supported
#define MSNdis_WmiIPSecOffloadV1_SupportedGuid \
    { 0xf86676b9,0xd9fa,0x4d26, { 0x95,0xce,0xbf,0xbc,0x77,0xd8,0x05,0x96 } }

#if ! (defined(MIDL_PASS))
DEFINE_GUID(MSNdis_WmiIPSecOffloadV1_Supported_GUID, \
            0xf86676b9,0xd9fa,0x4d26,0x95,0xce,0xbf,0xbc,0x77,0xd8,0x05,0x96);
#endif


typedef struct _MSNdis_WmiIPSecOffloadV1_Supported
{
    // 
    ULONG Encapsulation;
    #define MSNdis_WmiIPSecOffloadV1_Supported_Encapsulation_SIZE sizeof(ULONG)
    #define MSNdis_WmiIPSecOffloadV1_Supported_Encapsulation_ID 1

    // 
    ULONG AhEspCombined;
    #define MSNdis_WmiIPSecOffloadV1_Supported_AhEspCombined_SIZE sizeof(ULONG)
    #define MSNdis_WmiIPSecOffloadV1_Supported_AhEspCombined_ID 2

    // 
    ULONG TransportTunnelCombined;
    #define MSNdis_WmiIPSecOffloadV1_Supported_TransportTunnelCombined_SIZE sizeof(ULONG)
    #define MSNdis_WmiIPSecOffloadV1_Supported_TransportTunnelCombined_ID 3

    // 
    ULONG IPv4Options;
    #define MSNdis_WmiIPSecOffloadV1_Supported_IPv4Options_SIZE sizeof(ULONG)
    #define MSNdis_WmiIPSecOffloadV1_Supported_IPv4Options_ID 4

    // 
    ULONG Flags;
    #define MSNdis_WmiIPSecOffloadV1_Supported_Flags_SIZE sizeof(ULONG)
    #define MSNdis_WmiIPSecOffloadV1_Supported_Flags_ID 5

} MSNdis_WmiIPSecOffloadV1_Supported, *PMSNdis_WmiIPSecOffloadV1_Supported;

#define MSNdis_WmiIPSecOffloadV1_Supported_SIZE (FIELD_OFFSET(MSNdis_WmiIPSecOffloadV1_Supported, Flags) + MSNdis_WmiIPSecOffloadV1_Supported_Flags_SIZE)

// MSNdis_WmiIPSecOffloadV1_IPv4AH - MSNdis_WmiIPSecOffloadV1_IPv4AH
#define MSNdis_WmiIPSecOffloadV1_IPv4AHGuid \
    { 0x29bacfdd,0xf063,0x48d8, { 0x95,0x2c,0xd3,0xdc,0x93,0x30,0x0f,0x15 } }

#if ! (defined(MIDL_PASS))
DEFINE_GUID(MSNdis_WmiIPSecOffloadV1_IPv4AH_GUID, \
            0x29bacfdd,0xf063,0x48d8,0x95,0x2c,0xd3,0xdc,0x93,0x30,0x0f,0x15);
#endif


typedef struct _MSNdis_WmiIPSecOffloadV1_IPv4AH
{
    // 
    ULONG Md5;
    #define MSNdis_WmiIPSecOffloadV1_IPv4AH_Md5_SIZE sizeof(ULONG)
    #define MSNdis_WmiIPSecOffloadV1_IPv4AH_Md5_ID 1

    // 
    ULONG Sha_1;
    #define MSNdis_WmiIPSecOffloadV1_IPv4AH_Sha_1_SIZE sizeof(ULONG)
    #define MSNdis_WmiIPSecOffloadV1_IPv4AH_Sha_1_ID 2

    // 
    ULONG Transport;
    #define MSNdis_WmiIPSecOffloadV1_IPv4AH_Transport_SIZE sizeof(ULONG)
    #define MSNdis_WmiIPSecOffloadV1_IPv4AH_Transport_ID 3

    // 
    ULONG Tunnel;
    #define MSNdis_WmiIPSecOffloadV1_IPv4AH_Tunnel_SIZE sizeof(ULONG)
    #define MSNdis_WmiIPSecOffloadV1_IPv4AH_Tunnel_ID 4

    // 
    ULONG Send;
    #define MSNdis_WmiIPSecOffloadV1_IPv4AH_Send_SIZE sizeof(ULONG)
    #define MSNdis_WmiIPSecOffloadV1_IPv4AH_Send_ID 5

    // 
    ULONG Receive;
    #define MSNdis_WmiIPSecOffloadV1_IPv4AH_Receive_SIZE sizeof(ULONG)
    #define MSNdis_WmiIPSecOffloadV1_IPv4AH_Receive_ID 6

} MSNdis_WmiIPSecOffloadV1_IPv4AH, *PMSNdis_WmiIPSecOffloadV1_IPv4AH;

#define MSNdis_WmiIPSecOffloadV1_IPv4AH_SIZE (FIELD_OFFSET(MSNdis_WmiIPSecOffloadV1_IPv4AH, Receive) + MSNdis_WmiIPSecOffloadV1_IPv4AH_Receive_SIZE)

// MSNdis_WmiIPSecOffloadV1_IPv4ESP - MSNdis_WmiIPSecOffloadV1_IPv4ESP
#define MSNdis_WmiIPSecOffloadV1_IPv4ESPGuid \
    { 0x86522023,0x4536,0x4b58, { 0xa1,0xf4,0x25,0x38,0x94,0x1a,0xce,0x43 } }

#if ! (defined(MIDL_PASS))
DEFINE_GUID(MSNdis_WmiIPSecOffloadV1_IPv4ESP_GUID, \
            0x86522023,0x4536,0x4b58,0xa1,0xf4,0x25,0x38,0x94,0x1a,0xce,0x43);
#endif


typedef struct _MSNdis_WmiIPSecOffloadV1_IPv4ESP
{
    // 
    ULONG Des;
    #define MSNdis_WmiIPSecOffloadV1_IPv4ESP_Des_SIZE sizeof(ULONG)
    #define MSNdis_WmiIPSecOffloadV1_IPv4ESP_Des_ID 1

    // 
    ULONG Reserved;
    #define MSNdis_WmiIPSecOffloadV1_IPv4ESP_Reserved_SIZE sizeof(ULONG)
    #define MSNdis_WmiIPSecOffloadV1_IPv4ESP_Reserved_ID 2

    // 
    ULONG TripleDes;
    #define MSNdis_WmiIPSecOffloadV1_IPv4ESP_TripleDes_SIZE sizeof(ULONG)
    #define MSNdis_WmiIPSecOffloadV1_IPv4ESP_TripleDes_ID 3

    // 
    ULONG NullEsp;
    #define MSNdis_WmiIPSecOffloadV1_IPv4ESP_NullEsp_SIZE sizeof(ULONG)
    #define MSNdis_WmiIPSecOffloadV1_IPv4ESP_NullEsp_ID 4

    // 
    ULONG Transport;
    #define MSNdis_WmiIPSecOffloadV1_IPv4ESP_Transport_SIZE sizeof(ULONG)
    #define MSNdis_WmiIPSecOffloadV1_IPv4ESP_Transport_ID 5

    // 
    ULONG Tunnel;
    #define MSNdis_WmiIPSecOffloadV1_IPv4ESP_Tunnel_SIZE sizeof(ULONG)
    #define MSNdis_WmiIPSecOffloadV1_IPv4ESP_Tunnel_ID 6

    // 
    ULONG Send;
    #define MSNdis_WmiIPSecOffloadV1_IPv4ESP_Send_SIZE sizeof(ULONG)
    #define MSNdis_WmiIPSecOffloadV1_IPv4ESP_Send_ID 7

    // 
    ULONG Receive;
    #define MSNdis_WmiIPSecOffloadV1_IPv4ESP_Receive_SIZE sizeof(ULONG)
    #define MSNdis_WmiIPSecOffloadV1_IPv4ESP_Receive_ID 8

} MSNdis_WmiIPSecOffloadV1_IPv4ESP, *PMSNdis_WmiIPSecOffloadV1_IPv4ESP;

#define MSNdis_WmiIPSecOffloadV1_IPv4ESP_SIZE (FIELD_OFFSET(MSNdis_WmiIPSecOffloadV1_IPv4ESP, Receive) + MSNdis_WmiIPSecOffloadV1_IPv4ESP_Receive_SIZE)

// MSNdis_WmiIPSecOffloadV1 - MSNdis_WmiIPSecOffloadV1
#define MSNdis_WmiIPSecOffloadV1Guid \
    { 0x4ec63447,0x2238,0x43a7, { 0xac,0x33,0x11,0xc7,0xcc,0x7d,0x86,0x65 } }

#if ! (defined(MIDL_PASS))
DEFINE_GUID(MSNdis_WmiIPSecOffloadV1_GUID, \
            0x4ec63447,0x2238,0x43a7,0xac,0x33,0x11,0xc7,0xcc,0x7d,0x86,0x65);
#endif


typedef struct _MSNdis_WmiIPSecOffloadV1
{
    // 
    MSNdis_WmiIPSecOffloadV1_Supported WmiSupported;
    #define MSNdis_WmiIPSecOffloadV1_WmiSupported_SIZE sizeof(MSNdis_WmiIPSecOffloadV1_Supported)
    #define MSNdis_WmiIPSecOffloadV1_WmiSupported_ID 1

    // 
    MSNdis_WmiIPSecOffloadV1_IPv4AH WmiIPv4AH;
    #define MSNdis_WmiIPSecOffloadV1_WmiIPv4AH_SIZE sizeof(MSNdis_WmiIPSecOffloadV1_IPv4AH)
    #define MSNdis_WmiIPSecOffloadV1_WmiIPv4AH_ID 2

    // 
    MSNdis_WmiIPSecOffloadV1_IPv4ESP WmiIPv4ESP;
    #define MSNdis_WmiIPSecOffloadV1_WmiIPv4ESP_SIZE sizeof(MSNdis_WmiIPSecOffloadV1_IPv4ESP)
    #define MSNdis_WmiIPSecOffloadV1_WmiIPv4ESP_ID 3

} MSNdis_WmiIPSecOffloadV1, *PMSNdis_WmiIPSecOffloadV1;

#define MSNdis_WmiIPSecOffloadV1_SIZE (FIELD_OFFSET(MSNdis_WmiIPSecOffloadV1, WmiIPv4ESP) + MSNdis_WmiIPSecOffloadV1_WmiIPv4ESP_SIZE)

// MSNdis_WmiTcpLargeSendOffloadV2_IPv4 - MSNdis_WmiTcpLargeSendOffloadV2_IPv4
#define MSNdis_WmiTcpLargeSendOffloadV2_IPv4Guid \
    { 0x8823d030,0xfa30,0x4b73, { 0xb3,0x39,0xdb,0x19,0x20,0x7f,0x0d,0x81 } }

#if ! (defined(MIDL_PASS))
DEFINE_GUID(MSNdis_WmiTcpLargeSendOffloadV2_IPv4_GUID, \
            0x8823d030,0xfa30,0x4b73,0xb3,0x39,0xdb,0x19,0x20,0x7f,0x0d,0x81);
#endif


typedef struct _MSNdis_WmiTcpLargeSendOffloadV2_IPv4
{
    // 
    ULONG Encapsulation;
    #define MSNdis_WmiTcpLargeSendOffloadV2_IPv4_Encapsulation_SIZE sizeof(ULONG)
    #define MSNdis_WmiTcpLargeSendOffloadV2_IPv4_Encapsulation_ID 1

    // 
    ULONG MaxOffLoadSize;
    #define MSNdis_WmiTcpLargeSendOffloadV2_IPv4_MaxOffLoadSize_SIZE sizeof(ULONG)
    #define MSNdis_WmiTcpLargeSendOffloadV2_IPv4_MaxOffLoadSize_ID 2

    // 
    ULONG MinSegmentCount;
    #define MSNdis_WmiTcpLargeSendOffloadV2_IPv4_MinSegmentCount_SIZE sizeof(ULONG)
    #define MSNdis_WmiTcpLargeSendOffloadV2_IPv4_MinSegmentCount_ID 3

} MSNdis_WmiTcpLargeSendOffloadV2_IPv4, *PMSNdis_WmiTcpLargeSendOffloadV2_IPv4;

#define MSNdis_WmiTcpLargeSendOffloadV2_IPv4_SIZE (FIELD_OFFSET(MSNdis_WmiTcpLargeSendOffloadV2_IPv4, MinSegmentCount) + MSNdis_WmiTcpLargeSendOffloadV2_IPv4_MinSegmentCount_SIZE)

// MSNdis_WmiTcpLargeSendOffloadV2_IPv6 - MSNdis_WmiTcpLargeSendOffloadV2_IPv6
#define MSNdis_WmiTcpLargeSendOffloadV2_IPv6Guid \
    { 0xa7a9597c,0x2f8e,0x410b, { 0x9b,0xb3,0x5c,0x3a,0x50,0x79,0x2b,0xfc } }

#if ! (defined(MIDL_PASS))
DEFINE_GUID(MSNdis_WmiTcpLargeSendOffloadV2_IPv6_GUID, \
            0xa7a9597c,0x2f8e,0x410b,0x9b,0xb3,0x5c,0x3a,0x50,0x79,0x2b,0xfc);
#endif


typedef struct _MSNdis_WmiTcpLargeSendOffloadV2_IPv6
{
    // 
    ULONG Encapsulation;
    #define MSNdis_WmiTcpLargeSendOffloadV2_IPv6_Encapsulation_SIZE sizeof(ULONG)
    #define MSNdis_WmiTcpLargeSendOffloadV2_IPv6_Encapsulation_ID 1

    // 
    ULONG MaxOffLoadSize;
    #define MSNdis_WmiTcpLargeSendOffloadV2_IPv6_MaxOffLoadSize_SIZE sizeof(ULONG)
    #define MSNdis_WmiTcpLargeSendOffloadV2_IPv6_MaxOffLoadSize_ID 2

    // 
    ULONG MinSegmentCount;
    #define MSNdis_WmiTcpLargeSendOffloadV2_IPv6_MinSegmentCount_SIZE sizeof(ULONG)
    #define MSNdis_WmiTcpLargeSendOffloadV2_IPv6_MinSegmentCount_ID 3

    // 
    ULONG IpExtensionHeadersSupported;
    #define MSNdis_WmiTcpLargeSendOffloadV2_IPv6_IpExtensionHeadersSupported_SIZE sizeof(ULONG)
    #define MSNdis_WmiTcpLargeSendOffloadV2_IPv6_IpExtensionHeadersSupported_ID 4

    // 
    ULONG TcpOptionsSupported;
    #define MSNdis_WmiTcpLargeSendOffloadV2_IPv6_TcpOptionsSupported_SIZE sizeof(ULONG)
    #define MSNdis_WmiTcpLargeSendOffloadV2_IPv6_TcpOptionsSupported_ID 5

} MSNdis_WmiTcpLargeSendOffloadV2_IPv6, *PMSNdis_WmiTcpLargeSendOffloadV2_IPv6;

#define MSNdis_WmiTcpLargeSendOffloadV2_IPv6_SIZE (FIELD_OFFSET(MSNdis_WmiTcpLargeSendOffloadV2_IPv6, TcpOptionsSupported) + MSNdis_WmiTcpLargeSendOffloadV2_IPv6_TcpOptionsSupported_SIZE)

// MSNdis_WmiTcpLargeSendOffloadV2 - MSNdis_WmiTcpLargeSendOffloadV2
#define MSNdis_WmiTcpLargeSendOffloadV2Guid \
    { 0x592977c2,0xcfbe,0x462c, { 0xb5,0xcf,0x1a,0x76,0x79,0xfe,0x1c,0xba } }

#if ! (defined(MIDL_PASS))
DEFINE_GUID(MSNdis_WmiTcpLargeSendOffloadV2_GUID, \
            0x592977c2,0xcfbe,0x462c,0xb5,0xcf,0x1a,0x76,0x79,0xfe,0x1c,0xba);
#endif


typedef struct _MSNdis_WmiTcpLargeSendOffloadV2
{
    // 
    MSNdis_WmiTcpLargeSendOffloadV2_IPv4 WmiIPv4;
    #define MSNdis_WmiTcpLargeSendOffloadV2_WmiIPv4_SIZE sizeof(MSNdis_WmiTcpLargeSendOffloadV2_IPv4)
    #define MSNdis_WmiTcpLargeSendOffloadV2_WmiIPv4_ID 1

    // 
    MSNdis_WmiTcpLargeSendOffloadV2_IPv6 WmiIPv6;
    #define MSNdis_WmiTcpLargeSendOffloadV2_WmiIPv6_SIZE sizeof(MSNdis_WmiTcpLargeSendOffloadV2_IPv6)
    #define MSNdis_WmiTcpLargeSendOffloadV2_WmiIPv6_ID 2

} MSNdis_WmiTcpLargeSendOffloadV2, *PMSNdis_WmiTcpLargeSendOffloadV2;

#define MSNdis_WmiTcpLargeSendOffloadV2_SIZE (FIELD_OFFSET(MSNdis_WmiTcpLargeSendOffloadV2, WmiIPv6) + MSNdis_WmiTcpLargeSendOffloadV2_WmiIPv6_SIZE)

// MSNdis_WmiOffload - MSNdis_WmiOffload
#define MSNdis_WmiOffloadGuid \
    { 0x7a877086,0x2204,0x4a8a, { 0x92,0xa4,0xe3,0xe8,0xab,0x62,0x66,0x29 } }

#if ! (defined(MIDL_PASS))
DEFINE_GUID(MSNdis_WmiOffload_GUID, \
            0x7a877086,0x2204,0x4a8a,0x92,0xa4,0xe3,0xe8,0xab,0x62,0x66,0x29);
#endif


typedef struct _MSNdis_WmiOffload
{
    // 
    MSNdis_ObjectHeader Header;
    #define MSNdis_WmiOffload_Header_SIZE sizeof(MSNdis_ObjectHeader)
    #define MSNdis_WmiOffload_Header_ID 1

    // 
    MSNdis_WmiTcpIpChecksumOffload Checksum;
    #define MSNdis_WmiOffload_Checksum_SIZE sizeof(MSNdis_WmiTcpIpChecksumOffload)
    #define MSNdis_WmiOffload_Checksum_ID 2

    // 
    MSNdis_WmiTcpLargeSendOffloadV1 LsoV1;
    #define MSNdis_WmiOffload_LsoV1_SIZE sizeof(MSNdis_WmiTcpLargeSendOffloadV1)
    #define MSNdis_WmiOffload_LsoV1_ID 3

    // 
    MSNdis_WmiIPSecOffloadV1 IPsecV1;
    #define MSNdis_WmiOffload_IPsecV1_SIZE sizeof(MSNdis_WmiIPSecOffloadV1)
    #define MSNdis_WmiOffload_IPsecV1_ID 4

    // 
    MSNdis_WmiTcpLargeSendOffloadV2 LsoV2;
    #define MSNdis_WmiOffload_LsoV2_SIZE sizeof(MSNdis_WmiTcpLargeSendOffloadV2)
    #define MSNdis_WmiOffload_LsoV2_ID 5

    // 
    ULONG Flags;
    #define MSNdis_WmiOffload_Flags_SIZE sizeof(ULONG)
    #define MSNdis_WmiOffload_Flags_ID 6

} MSNdis_WmiOffload, *PMSNdis_WmiOffload;

#define MSNdis_WmiOffload_SIZE (FIELD_OFFSET(MSNdis_WmiOffload, Flags) + MSNdis_WmiOffload_Flags_SIZE)

// MSNdis_TcpOffloadParameters - MSNdis_TcpOffloadParameters
#define MSNdis_TcpOffloadParametersGuid \
    { 0x43fe82d8,0x3468,0x497e, { 0x9d,0xcf,0xf8,0xff,0xc0,0x13,0x37,0x44 } }

#if ! (defined(MIDL_PASS))
DEFINE_GUID(MSNdis_TcpOffloadParameters_GUID, \
            0x43fe82d8,0x3468,0x497e,0x9d,0xcf,0xf8,0xff,0xc0,0x13,0x37,0x44);
#endif


typedef struct _MSNdis_TcpOffloadParameters
{
    // 
    MSNdis_ObjectHeader Header;
    #define MSNdis_TcpOffloadParameters_Header_SIZE sizeof(MSNdis_ObjectHeader)
    #define MSNdis_TcpOffloadParameters_Header_ID 1

    // 
    UCHAR IPv4Checksum;
    #define MSNdis_TcpOffloadParameters_IPv4Checksum_SIZE sizeof(UCHAR)
    #define MSNdis_TcpOffloadParameters_IPv4Checksum_ID 2

    // 
    UCHAR TCPIPv4Checksum;
    #define MSNdis_TcpOffloadParameters_TCPIPv4Checksum_SIZE sizeof(UCHAR)
    #define MSNdis_TcpOffloadParameters_TCPIPv4Checksum_ID 3

    // 
    UCHAR UDPIPv4Checksum;
    #define MSNdis_TcpOffloadParameters_UDPIPv4Checksum_SIZE sizeof(UCHAR)
    #define MSNdis_TcpOffloadParameters_UDPIPv4Checksum_ID 4

    // 
    UCHAR TCPIPv6Checksum;
    #define MSNdis_TcpOffloadParameters_TCPIPv6Checksum_SIZE sizeof(UCHAR)
    #define MSNdis_TcpOffloadParameters_TCPIPv6Checksum_ID 5

    // 
    UCHAR UDPIPv6Checksum;
    #define MSNdis_TcpOffloadParameters_UDPIPv6Checksum_SIZE sizeof(UCHAR)
    #define MSNdis_TcpOffloadParameters_UDPIPv6Checksum_ID 6

    // 
    UCHAR LsoV1;
    #define MSNdis_TcpOffloadParameters_LsoV1_SIZE sizeof(UCHAR)
    #define MSNdis_TcpOffloadParameters_LsoV1_ID 7

    // 
    UCHAR IPsec;
    #define MSNdis_TcpOffloadParameters_IPsec_SIZE sizeof(UCHAR)
    #define MSNdis_TcpOffloadParameters_IPsec_ID 8

    // 
    UCHAR LsoV2IPv4;
    #define MSNdis_TcpOffloadParameters_LsoV2IPv4_SIZE sizeof(UCHAR)
    #define MSNdis_TcpOffloadParameters_LsoV2IPv4_ID 9

    // 
    UCHAR LsoV2IPv6;
    #define MSNdis_TcpOffloadParameters_LsoV2IPv6_SIZE sizeof(UCHAR)
    #define MSNdis_TcpOffloadParameters_LsoV2IPv6_ID 10

    // 
    UCHAR TcpConnectionIPv4;
    #define MSNdis_TcpOffloadParameters_TcpConnectionIPv4_SIZE sizeof(UCHAR)
    #define MSNdis_TcpOffloadParameters_TcpConnectionIPv4_ID 11

    // 
    UCHAR TcpConnectionIPv6;
    #define MSNdis_TcpOffloadParameters_TcpConnectionIPv6_SIZE sizeof(UCHAR)
    #define MSNdis_TcpOffloadParameters_TcpConnectionIPv6_ID 12

    // 
    ULONG Flags;
    #define MSNdis_TcpOffloadParameters_Flags_SIZE sizeof(ULONG)
    #define MSNdis_TcpOffloadParameters_Flags_ID 13

} MSNdis_TcpOffloadParameters, *PMSNdis_TcpOffloadParameters;

#define MSNdis_TcpOffloadParameters_SIZE (FIELD_OFFSET(MSNdis_TcpOffloadParameters, Flags) + MSNdis_TcpOffloadParameters_Flags_SIZE)

// MSNdis_WmiTcpConnectionOffload - MSNdis_WmiTcpConnectionOffload
#define MSNdis_WmiTcpConnectionOffloadGuid \
    { 0x93cfcd3f,0x6228,0x455c, { 0x90,0x5e,0x3a,0xb8,0x0a,0x2f,0xf0,0x90 } }

#if ! (defined(MIDL_PASS))
DEFINE_GUID(MSNdis_WmiTcpConnectionOffload_GUID, \
            0x93cfcd3f,0x6228,0x455c,0x90,0x5e,0x3a,0xb8,0x0a,0x2f,0xf0,0x90);
#endif


typedef struct _MSNdis_WmiTcpConnectionOffload
{
    // 
    MSNdis_ObjectHeader Header;
    #define MSNdis_WmiTcpConnectionOffload_Header_SIZE sizeof(MSNdis_ObjectHeader)
    #define MSNdis_WmiTcpConnectionOffload_Header_ID 1

    // 
    ULONG Encapsulation;
    #define MSNdis_WmiTcpConnectionOffload_Encapsulation_SIZE sizeof(ULONG)
    #define MSNdis_WmiTcpConnectionOffload_Encapsulation_ID 2

    // 
    ULONG SupportIp4;
    #define MSNdis_WmiTcpConnectionOffload_SupportIp4_SIZE sizeof(ULONG)
    #define MSNdis_WmiTcpConnectionOffload_SupportIp4_ID 3

    // 
    ULONG SupportIp6;
    #define MSNdis_WmiTcpConnectionOffload_SupportIp6_SIZE sizeof(ULONG)
    #define MSNdis_WmiTcpConnectionOffload_SupportIp6_ID 4

    // 
    ULONG SupportIp6ExtensionHeaders;
    #define MSNdis_WmiTcpConnectionOffload_SupportIp6ExtensionHeaders_SIZE sizeof(ULONG)
    #define MSNdis_WmiTcpConnectionOffload_SupportIp6ExtensionHeaders_ID 5

    // 
    ULONG SupportSack;
    #define MSNdis_WmiTcpConnectionOffload_SupportSack_SIZE sizeof(ULONG)
    #define MSNdis_WmiTcpConnectionOffload_SupportSack_ID 6

    // 
    ULONG TcpConnectionOffloadCapacity;
    #define MSNdis_WmiTcpConnectionOffload_TcpConnectionOffloadCapacity_SIZE sizeof(ULONG)
    #define MSNdis_WmiTcpConnectionOffload_TcpConnectionOffloadCapacity_ID 7

    // 
    ULONG Flags;
    #define MSNdis_WmiTcpConnectionOffload_Flags_SIZE sizeof(ULONG)
    #define MSNdis_WmiTcpConnectionOffload_Flags_ID 8

} MSNdis_WmiTcpConnectionOffload, *PMSNdis_WmiTcpConnectionOffload;

#define MSNdis_WmiTcpConnectionOffload_SIZE (FIELD_OFFSET(MSNdis_WmiTcpConnectionOffload, Flags) + MSNdis_WmiTcpConnectionOffload_Flags_SIZE)

// MSNdis_WmiHDSplitCurrentConfig - MSNdis_WmiHDSplitCurrentConfig
#define MSNdis_WmiHDSplitCurrentConfigGuid \
    { 0x34ff16bf,0x30ca,0x4a2a, { 0xa4,0x6d,0xc7,0xee,0x74,0xbc,0x35,0x82 } }

#if ! (defined(MIDL_PASS))
DEFINE_GUID(MSNdis_WmiHDSplitCurrentConfig_GUID, \
            0x34ff16bf,0x30ca,0x4a2a,0xa4,0x6d,0xc7,0xee,0x74,0xbc,0x35,0x82);
#endif


typedef struct _MSNdis_WmiHDSplitCurrentConfig
{
    // 
    MSNdis_ObjectHeader Header;
    #define MSNdis_WmiHDSplitCurrentConfig_Header_SIZE sizeof(MSNdis_ObjectHeader)
    #define MSNdis_WmiHDSplitCurrentConfig_Header_ID 1

    // 
    ULONG HardwareCapabilities;
    #define MSNdis_WmiHDSplitCurrentConfig_HardwareCapabilities_SIZE sizeof(ULONG)
    #define MSNdis_WmiHDSplitCurrentConfig_HardwareCapabilities_ID 2

    // 
    ULONG CurrentCapabilities;
    #define MSNdis_WmiHDSplitCurrentConfig_CurrentCapabilities_SIZE sizeof(ULONG)
    #define MSNdis_WmiHDSplitCurrentConfig_CurrentCapabilities_ID 3

    // 
    ULONG HDSplitFlags;
    #define MSNdis_WmiHDSplitCurrentConfig_HDSplitFlags_SIZE sizeof(ULONG)
    #define MSNdis_WmiHDSplitCurrentConfig_HDSplitFlags_ID 4

    // 
    ULONG HDSplitCombineFlags;
    #define MSNdis_WmiHDSplitCurrentConfig_HDSplitCombineFlags_SIZE sizeof(ULONG)
    #define MSNdis_WmiHDSplitCurrentConfig_HDSplitCombineFlags_ID 5

    // 
    ULONG BackfillSize;
    #define MSNdis_WmiHDSplitCurrentConfig_BackfillSize_SIZE sizeof(ULONG)
    #define MSNdis_WmiHDSplitCurrentConfig_BackfillSize_ID 6

    // 
    ULONG MaxHeaderSize;
    #define MSNdis_WmiHDSplitCurrentConfig_MaxHeaderSize_SIZE sizeof(ULONG)
    #define MSNdis_WmiHDSplitCurrentConfig_MaxHeaderSize_ID 7

} MSNdis_WmiHDSplitCurrentConfig, *PMSNdis_WmiHDSplitCurrentConfig;

#define MSNdis_WmiHDSplitCurrentConfig_SIZE (FIELD_OFFSET(MSNdis_WmiHDSplitCurrentConfig, MaxHeaderSize) + MSNdis_WmiHDSplitCurrentConfig_MaxHeaderSize_SIZE)

// MSNdis_HDSplitParameters - MSNdis_HDSplitParameters
#define MSNdis_HDSplitParametersGuid \
    { 0x1131c56a,0x0a5a,0x4d79, { 0x8d,0xde,0x1e,0x6f,0x17,0x80,0x05,0xee } }

#if ! (defined(MIDL_PASS))
DEFINE_GUID(MSNdis_HDSplitParameters_GUID, \
            0x1131c56a,0x0a5a,0x4d79,0x8d,0xde,0x1e,0x6f,0x17,0x80,0x05,0xee);
#endif


typedef struct _MSNdis_HDSplitParameters
{
    // 
    MSNdis_ObjectHeader Header;
    #define MSNdis_HDSplitParameters_Header_SIZE sizeof(MSNdis_ObjectHeader)
    #define MSNdis_HDSplitParameters_Header_ID 1

    // 
    ULONG HDSplitCombineFlags;
    #define MSNdis_HDSplitParameters_HDSplitCombineFlags_SIZE sizeof(ULONG)
    #define MSNdis_HDSplitParameters_HDSplitCombineFlags_ID 2

} MSNdis_HDSplitParameters, *PMSNdis_HDSplitParameters;

#define MSNdis_HDSplitParameters_SIZE (FIELD_OFFSET(MSNdis_HDSplitParameters, HDSplitCombineFlags) + MSNdis_HDSplitParameters_HDSplitCombineFlags_SIZE)

// MSNdis_LinkState - MSNdis_LinkState
#define MSNdis_LinkStateGuid \
    { 0xba1f4c14,0xa945,0x4762, { 0xb9,0x16,0x0b,0x55,0x15,0xb6,0xf4,0x3a } }

#if ! (defined(MIDL_PASS))
DEFINE_GUID(MSNdis_LinkState_GUID, \
            0xba1f4c14,0xa945,0x4762,0xb9,0x16,0x0b,0x55,0x15,0xb6,0xf4,0x3a);
#endif

//
// Method id definitions for MSNdis_LinkState
#define WmiQueryLinkState     1
typedef struct _WmiQueryLinkState_IN
{
    // 
    MSNdis_WmiMethodHeader Header;
    #define WmiQueryLinkState_IN_Header_SIZE sizeof(MSNdis_WmiMethodHeader)
    #define WmiQueryLinkState_IN_Header_ID 1

} WmiQueryLinkState_IN, *PWmiQueryLinkState_IN;

#define WmiQueryLinkState_IN_SIZE (FIELD_OFFSET(WmiQueryLinkState_IN, Header) + WmiQueryLinkState_IN_Header_SIZE)

typedef struct _WmiQueryLinkState_OUT
{
    // 
    MSNdis_LinkStateData LinkState;
    #define WmiQueryLinkState_OUT_LinkState_SIZE sizeof(MSNdis_LinkStateData)
    #define WmiQueryLinkState_OUT_LinkState_ID 2

} WmiQueryLinkState_OUT, *PWmiQueryLinkState_OUT;

#define WmiQueryLinkState_OUT_SIZE (FIELD_OFFSET(WmiQueryLinkState_OUT, LinkState) + WmiQueryLinkState_OUT_LinkState_SIZE)


// MSNdis_QueryInterruptModeration - MSNdis_QueryInterruptModeration
#define MSNdis_QueryInterruptModerationGuid \
    { 0xd9c8eea5,0xf16e,0x467c, { 0x84,0xd5,0x63,0x45,0xa2,0x2c,0xe2,0x13 } }

#if ! (defined(MIDL_PASS))
DEFINE_GUID(MSNdis_QueryInterruptModeration_GUID, \
            0xd9c8eea5,0xf16e,0x467c,0x84,0xd5,0x63,0x45,0xa2,0x2c,0xe2,0x13);
#endif

//
// Method id definitions for MSNdis_QueryInterruptModeration
#define WmiQueryInterruptModeration     1
typedef struct _WmiQueryInterruptModeration_IN
{
    // 
    MSNdis_WmiMethodHeader Header;
    #define WmiQueryInterruptModeration_IN_Header_SIZE sizeof(MSNdis_WmiMethodHeader)
    #define WmiQueryInterruptModeration_IN_Header_ID 1

} WmiQueryInterruptModeration_IN, *PWmiQueryInterruptModeration_IN;

#define WmiQueryInterruptModeration_IN_SIZE (FIELD_OFFSET(WmiQueryInterruptModeration_IN, Header) + WmiQueryInterruptModeration_IN_Header_SIZE)

typedef struct _WmiQueryInterruptModeration_OUT
{
    // 
    MSNdis_InterruptModerationParameters InterruptModeration;
    #define WmiQueryInterruptModeration_OUT_InterruptModeration_SIZE sizeof(MSNdis_InterruptModerationParameters)
    #define WmiQueryInterruptModeration_OUT_InterruptModeration_ID 2

} WmiQueryInterruptModeration_OUT, *PWmiQueryInterruptModeration_OUT;

#define WmiQueryInterruptModeration_OUT_SIZE (FIELD_OFFSET(WmiQueryInterruptModeration_OUT, InterruptModeration) + WmiQueryInterruptModeration_OUT_InterruptModeration_SIZE)


// MSNdis_SetInterruptModeration - MSNdis_SetInterruptModeration
#define MSNdis_SetInterruptModerationGuid \
    { 0xd789adfa,0x9c56,0x433b, { 0xad,0x01,0x75,0x74,0xf3,0xce,0xdb,0xe9 } }

#if ! (defined(MIDL_PASS))
DEFINE_GUID(MSNdis_SetInterruptModeration_GUID, \
            0xd789adfa,0x9c56,0x433b,0xad,0x01,0x75,0x74,0xf3,0xce,0xdb,0xe9);
#endif

//
// Method id definitions for MSNdis_SetInterruptModeration
#define WmiSetInterruptModeration     1
typedef struct _WmiSetInterruptModeration_IN
{
    // 
    MSNdis_WmiMethodHeader MethodHeader;
    #define WmiSetInterruptModeration_IN_MethodHeader_SIZE sizeof(MSNdis_WmiMethodHeader)
    #define WmiSetInterruptModeration_IN_MethodHeader_ID 1

    // 
    MSNdis_InterruptModerationParameters InterruptModeration;
    #define WmiSetInterruptModeration_IN_InterruptModeration_SIZE sizeof(MSNdis_InterruptModerationParameters)
    #define WmiSetInterruptModeration_IN_InterruptModeration_ID 2

} WmiSetInterruptModeration_IN, *PWmiSetInterruptModeration_IN;

#define WmiSetInterruptModeration_IN_SIZE (FIELD_OFFSET(WmiSetInterruptModeration_IN, InterruptModeration) + WmiSetInterruptModeration_IN_InterruptModeration_SIZE)

typedef struct _WmiSetInterruptModeration_OUT
{
    // 
    MSNdis_WmiOutputInfo OutputInfo;
    #define WmiSetInterruptModeration_OUT_OutputInfo_SIZE sizeof(MSNdis_WmiOutputInfo)
    #define WmiSetInterruptModeration_OUT_OutputInfo_ID 3

} WmiSetInterruptModeration_OUT, *PWmiSetInterruptModeration_OUT;

#define WmiSetInterruptModeration_OUT_SIZE (FIELD_OFFSET(WmiSetInterruptModeration_OUT, OutputInfo) + WmiSetInterruptModeration_OUT_OutputInfo_SIZE)


// MSNdis_SetLinkParameters - MSNdis_SetLinkParameters
#define MSNdis_SetLinkParametersGuid \
    { 0x8c7d3579,0x252b,0x4614, { 0x82,0xc5,0xa6,0x50,0xda,0xa1,0x50,0x49 } }

#if ! (defined(MIDL_PASS))
DEFINE_GUID(MSNdis_SetLinkParameters_GUID, \
            0x8c7d3579,0x252b,0x4614,0x82,0xc5,0xa6,0x50,0xda,0xa1,0x50,0x49);
#endif

//
// Method id definitions for MSNdis_SetLinkParameters
#define WmiSetLinkParameters     1
typedef struct _WmiSetLinkParameters_IN
{
    // 
    MSNdis_WmiMethodHeader MethodHeader;
    #define WmiSetLinkParameters_IN_MethodHeader_SIZE sizeof(MSNdis_WmiMethodHeader)
    #define WmiSetLinkParameters_IN_MethodHeader_ID 1

    // 
    MSNdis_LinkParameters LinkParameters;
    #define WmiSetLinkParameters_IN_LinkParameters_SIZE sizeof(MSNdis_LinkParameters)
    #define WmiSetLinkParameters_IN_LinkParameters_ID 2

} WmiSetLinkParameters_IN, *PWmiSetLinkParameters_IN;

#define WmiSetLinkParameters_IN_SIZE (FIELD_OFFSET(WmiSetLinkParameters_IN, LinkParameters) + WmiSetLinkParameters_IN_LinkParameters_SIZE)

typedef struct _WmiSetLinkParameters_OUT
{
    // 
    MSNdis_WmiOutputInfo OutputInfo;
    #define WmiSetLinkParameters_OUT_OutputInfo_SIZE sizeof(MSNdis_WmiOutputInfo)
    #define WmiSetLinkParameters_OUT_OutputInfo_ID 3

} WmiSetLinkParameters_OUT, *PWmiSetLinkParameters_OUT;

#define WmiSetLinkParameters_OUT_SIZE (FIELD_OFFSET(WmiSetLinkParameters_OUT, OutputInfo) + WmiSetLinkParameters_OUT_OutputInfo_SIZE)


// MSNdis_QueryStatisticsInfo - MSNdis_QueryStatisticsInfo
#define MSNdis_QueryStatisticsInfoGuid \
    { 0x368c45b5,0xc129,0x43c1, { 0x93,0x9e,0x7e,0xdc,0x2d,0x7f,0xe6,0x21 } }

#if ! (defined(MIDL_PASS))
DEFINE_GUID(MSNdis_QueryStatisticsInfo_GUID, \
            0x368c45b5,0xc129,0x43c1,0x93,0x9e,0x7e,0xdc,0x2d,0x7f,0xe6,0x21);
#endif

//
// Method id definitions for MSNdis_QueryStatisticsInfo
#define WmiQueryStatisticsInfo     1
typedef struct _WmiQueryStatisticsInfo_IN
{
    // 
    MSNdis_WmiMethodHeader Header;
    #define WmiQueryStatisticsInfo_IN_Header_SIZE sizeof(MSNdis_WmiMethodHeader)
    #define WmiQueryStatisticsInfo_IN_Header_ID 1

} WmiQueryStatisticsInfo_IN, *PWmiQueryStatisticsInfo_IN;

#define WmiQueryStatisticsInfo_IN_SIZE (FIELD_OFFSET(WmiQueryStatisticsInfo_IN, Header) + WmiQueryStatisticsInfo_IN_Header_SIZE)

typedef struct _WmiQueryStatisticsInfo_OUT
{
    // 
    MSNdis_StatisticsInfo StatisticsInfo;
    #define WmiQueryStatisticsInfo_OUT_StatisticsInfo_SIZE sizeof(MSNdis_StatisticsInfo)
    #define WmiQueryStatisticsInfo_OUT_StatisticsInfo_ID 2

} WmiQueryStatisticsInfo_OUT, *PWmiQueryStatisticsInfo_OUT;

#define WmiQueryStatisticsInfo_OUT_SIZE (FIELD_OFFSET(WmiQueryStatisticsInfo_OUT, StatisticsInfo) + WmiQueryStatisticsInfo_OUT_StatisticsInfo_SIZE)


// MSNdis_QueryPortState - MSNdis_QueryPortState
#define MSNdis_QueryPortStateGuid \
    { 0x6fbf2a5f,0x8b8f,0x4920, { 0x81,0x43,0xe6,0xc4,0x60,0xf5,0x25,0x24 } }

#if ! (defined(MIDL_PASS))
DEFINE_GUID(MSNdis_QueryPortState_GUID, \
            0x6fbf2a5f,0x8b8f,0x4920,0x81,0x43,0xe6,0xc4,0x60,0xf5,0x25,0x24);
#endif

//
// Method id definitions for MSNdis_QueryPortState
#define WmiQueryPortState     1
typedef struct _WmiQueryPortState_IN
{
    // 
    MSNdis_WmiMethodHeader Header;
    #define WmiQueryPortState_IN_Header_SIZE sizeof(MSNdis_WmiMethodHeader)
    #define WmiQueryPortState_IN_Header_ID 1

} WmiQueryPortState_IN, *PWmiQueryPortState_IN;

#define WmiQueryPortState_IN_SIZE (FIELD_OFFSET(WmiQueryPortState_IN, Header) + WmiQueryPortState_IN_Header_SIZE)

typedef struct _WmiQueryPortState_OUT
{
    // 
    MSNdis_PortStateData PortState;
    #define WmiQueryPortState_OUT_PortState_SIZE sizeof(MSNdis_PortStateData)
    #define WmiQueryPortState_OUT_PortState_ID 2

} WmiQueryPortState_OUT, *PWmiQueryPortState_OUT;

#define WmiQueryPortState_OUT_SIZE (FIELD_OFFSET(WmiQueryPortState_OUT, PortState) + WmiQueryPortState_OUT_PortState_SIZE)


// MSNdis_EnumeratePorts - MSNdis_EnumeratePorts
#define MSNdis_EnumeratePortsGuid \
    { 0xf1d6abe8,0x15e4,0x4407, { 0x81,0xb7,0x6b,0x83,0x0c,0x77,0x7c,0xd9 } }

#if ! (defined(MIDL_PASS))
DEFINE_GUID(MSNdis_EnumeratePorts_GUID, \
            0xf1d6abe8,0x15e4,0x4407,0x81,0xb7,0x6b,0x83,0x0c,0x77,0x7c,0xd9);
#endif

//
// Method id definitions for MSNdis_EnumeratePorts
#define WmiEnumeratePorts     1
typedef struct _WmiEnumeratePorts_IN
{
    // 
    MSNdis_WmiMethodHeader Header;
    #define WmiEnumeratePorts_IN_Header_SIZE sizeof(MSNdis_WmiMethodHeader)
    #define WmiEnumeratePorts_IN_Header_ID 1

} WmiEnumeratePorts_IN, *PWmiEnumeratePorts_IN;

#define WmiEnumeratePorts_IN_SIZE (FIELD_OFFSET(WmiEnumeratePorts_IN, Header) + WmiEnumeratePorts_IN_Header_SIZE)

typedef struct _WmiEnumeratePorts_OUT
{
    // 
    MSNdis_PortArray Ports;
    #define WmiEnumeratePorts_OUT_Ports_SIZE sizeof(MSNdis_PortArray)
    #define WmiEnumeratePorts_OUT_Ports_ID 2

} WmiEnumeratePorts_OUT, *PWmiEnumeratePorts_OUT;

#define WmiEnumeratePorts_OUT_SIZE (FIELD_OFFSET(WmiEnumeratePorts_OUT, Ports) + WmiEnumeratePorts_OUT_Ports_SIZE)


// MSNdis_SetPortParameters - MSNdis_SetPortParameters
#define MSNdis_SetPortParametersGuid \
    { 0xaab6ac31,0x86fb,0x48fb, { 0x8b,0x48,0x63,0xdb,0x23,0x5a,0xce,0x16 } }

#if ! (defined(MIDL_PASS))
DEFINE_GUID(MSNdis_SetPortParameters_GUID, \
            0xaab6ac31,0x86fb,0x48fb,0x8b,0x48,0x63,0xdb,0x23,0x5a,0xce,0x16);
#endif

//
// Method id definitions for MSNdis_SetPortParameters
#define WmiSetPortParameters     1
typedef struct _WmiSetPortParameters_IN
{
    // 
    MSNdis_WmiMethodHeader MethodHeader;
    #define WmiSetPortParameters_IN_MethodHeader_SIZE sizeof(MSNdis_WmiMethodHeader)
    #define WmiSetPortParameters_IN_MethodHeader_ID 1

    // 
    MSNdis_PortAuthParameters PortParameters;
    #define WmiSetPortParameters_IN_PortParameters_SIZE sizeof(MSNdis_PortAuthParameters)
    #define WmiSetPortParameters_IN_PortParameters_ID 2

} WmiSetPortParameters_IN, *PWmiSetPortParameters_IN;

#define WmiSetPortParameters_IN_SIZE (FIELD_OFFSET(WmiSetPortParameters_IN, PortParameters) + WmiSetPortParameters_IN_PortParameters_SIZE)

typedef struct _WmiSetPortParameters_OUT
{
    // 
    MSNdis_WmiOutputInfo OutputInfo;
    #define WmiSetPortParameters_OUT_OutputInfo_SIZE sizeof(MSNdis_WmiOutputInfo)
    #define WmiSetPortParameters_OUT_OutputInfo_ID 3

} WmiSetPortParameters_OUT, *PWmiSetPortParameters_OUT;

#define WmiSetPortParameters_OUT_SIZE (FIELD_OFFSET(WmiSetPortParameters_OUT, OutputInfo) + WmiSetPortParameters_OUT_OutputInfo_SIZE)


// MSNdis_QueryPciDeviceCustomProperty - MSNdis_QueryPciDeviceCustomProperty
#define MSNdis_QueryPciDeviceCustomPropertyGuid \
    { 0xaa39f5ab,0xe260,0x4d01, { 0x82,0xb0,0xb7,0x37,0xc8,0x80,0xea,0x05 } }

#if ! (defined(MIDL_PASS))
DEFINE_GUID(MSNdis_QueryPciDeviceCustomProperty_GUID, \
            0xaa39f5ab,0xe260,0x4d01,0x82,0xb0,0xb7,0x37,0xc8,0x80,0xea,0x05);
#endif

//
// Method id definitions for MSNdis_QueryPciDeviceCustomProperty
#define WmiQueryPciDeviceCustomProperty     1
typedef struct _WmiQueryPciDeviceCustomProperty_IN
{
    // 
    MSNdis_WmiMethodHeader Header;
    #define WmiQueryPciDeviceCustomProperty_IN_Header_SIZE sizeof(MSNdis_WmiMethodHeader)
    #define WmiQueryPciDeviceCustomProperty_IN_Header_ID 1

} WmiQueryPciDeviceCustomProperty_IN, *PWmiQueryPciDeviceCustomProperty_IN;

#define WmiQueryPciDeviceCustomProperty_IN_SIZE (FIELD_OFFSET(WmiQueryPciDeviceCustomProperty_IN, Header) + WmiQueryPciDeviceCustomProperty_IN_Header_SIZE)

typedef struct _WmiQueryPciDeviceCustomProperty_OUT
{
    // 
    MSNdis_PciDeviceProperty PciDeviceProperty;
    #define WmiQueryPciDeviceCustomProperty_OUT_PciDeviceProperty_SIZE sizeof(MSNdis_PciDeviceProperty)
    #define WmiQueryPciDeviceCustomProperty_OUT_PciDeviceProperty_ID 2

} WmiQueryPciDeviceCustomProperty_OUT, *PWmiQueryPciDeviceCustomProperty_OUT;

#define WmiQueryPciDeviceCustomProperty_OUT_SIZE (FIELD_OFFSET(WmiQueryPciDeviceCustomProperty_OUT, PciDeviceProperty) + WmiQueryPciDeviceCustomProperty_OUT_PciDeviceProperty_SIZE)


// MSNdis_EnumerateAdapterEx - MSNdis_EnumerateAdapterEx
#define MSNdis_EnumerateAdapterExGuid \
    { 0x16716917,0x4306,0x4be4, { 0x9b,0x5a,0x38,0x09,0xae,0x44,0xb1,0x25 } }

#if ! (defined(MIDL_PASS))
DEFINE_GUID(MSNdis_EnumerateAdapterEx_GUID, \
            0x16716917,0x4306,0x4be4,0x9b,0x5a,0x38,0x09,0xae,0x44,0xb1,0x25);
#endif


typedef struct _MSNdis_EnumerateAdapterEx
{
    // 
    MSNdis_WmiEnumAdapter EnumerateAdapter;
    #define MSNdis_EnumerateAdapterEx_EnumerateAdapter_SIZE sizeof(MSNdis_WmiEnumAdapter)
    #define MSNdis_EnumerateAdapterEx_EnumerateAdapter_ID 1

} MSNdis_EnumerateAdapterEx, *PMSNdis_EnumerateAdapterEx;

#define MSNdis_EnumerateAdapterEx_SIZE (FIELD_OFFSET(MSNdis_EnumerateAdapterEx, EnumerateAdapter) + MSNdis_EnumerateAdapterEx_EnumerateAdapter_SIZE)

// MSNdis_TcpOffloadCurrentConfig - MSNdis_TcpOffloadCurrentConfig
#define MSNdis_TcpOffloadCurrentConfigGuid \
    { 0x68542fed,0x5c74,0x461e, { 0x89,0x34,0x91,0xc6,0xf9,0xc6,0x09,0x60 } }

#if ! (defined(MIDL_PASS))
DEFINE_GUID(MSNdis_TcpOffloadCurrentConfig_GUID, \
            0x68542fed,0x5c74,0x461e,0x89,0x34,0x91,0xc6,0xf9,0xc6,0x09,0x60);
#endif

//
// Method id definitions for MSNdis_TcpOffloadCurrentConfig
#define WmiQueryCurrentOffloadConfig     1
typedef struct _WmiQueryCurrentOffloadConfig_IN
{
    // 
    MSNdis_WmiMethodHeader Header;
    #define WmiQueryCurrentOffloadConfig_IN_Header_SIZE sizeof(MSNdis_WmiMethodHeader)
    #define WmiQueryCurrentOffloadConfig_IN_Header_ID 1

} WmiQueryCurrentOffloadConfig_IN, *PWmiQueryCurrentOffloadConfig_IN;

#define WmiQueryCurrentOffloadConfig_IN_SIZE (FIELD_OFFSET(WmiQueryCurrentOffloadConfig_IN, Header) + WmiQueryCurrentOffloadConfig_IN_Header_SIZE)

typedef struct _WmiQueryCurrentOffloadConfig_OUT
{
    // 
    MSNdis_WmiOffload Offload;
    #define WmiQueryCurrentOffloadConfig_OUT_Offload_SIZE sizeof(MSNdis_WmiOffload)
    #define WmiQueryCurrentOffloadConfig_OUT_Offload_ID 2

} WmiQueryCurrentOffloadConfig_OUT, *PWmiQueryCurrentOffloadConfig_OUT;

#define WmiQueryCurrentOffloadConfig_OUT_SIZE (FIELD_OFFSET(WmiQueryCurrentOffloadConfig_OUT, Offload) + WmiQueryCurrentOffloadConfig_OUT_Offload_SIZE)


// MSNdis_TcpOffloadHardwareConfig - MSNdis_TcpOffloadHardwareConfig
#define MSNdis_TcpOffloadHardwareConfigGuid \
    { 0xcd5f1102,0x590f,0x4ada, { 0xab,0x65,0x5b,0x31,0xb1,0xdc,0x01,0x72 } }

#if ! (defined(MIDL_PASS))
DEFINE_GUID(MSNdis_TcpOffloadHardwareConfig_GUID, \
            0xcd5f1102,0x590f,0x4ada,0xab,0x65,0x5b,0x31,0xb1,0xdc,0x01,0x72);
#endif

//
// Method id definitions for MSNdis_TcpOffloadHardwareConfig
#define WmiQueryHardwareOffloadConfig     1
typedef struct _WmiQueryHardwareOffloadConfig_IN
{
    // 
    MSNdis_WmiMethodHeader Header;
    #define WmiQueryHardwareOffloadConfig_IN_Header_SIZE sizeof(MSNdis_WmiMethodHeader)
    #define WmiQueryHardwareOffloadConfig_IN_Header_ID 1

} WmiQueryHardwareOffloadConfig_IN, *PWmiQueryHardwareOffloadConfig_IN;

#define WmiQueryHardwareOffloadConfig_IN_SIZE (FIELD_OFFSET(WmiQueryHardwareOffloadConfig_IN, Header) + WmiQueryHardwareOffloadConfig_IN_Header_SIZE)

typedef struct _WmiQueryHardwareOffloadConfig_OUT
{
    // 
    MSNdis_WmiOffload Offload;
    #define WmiQueryHardwareOffloadConfig_OUT_Offload_SIZE sizeof(MSNdis_WmiOffload)
    #define WmiQueryHardwareOffloadConfig_OUT_Offload_ID 2

} WmiQueryHardwareOffloadConfig_OUT, *PWmiQueryHardwareOffloadConfig_OUT;

#define WmiQueryHardwareOffloadConfig_OUT_SIZE (FIELD_OFFSET(WmiQueryHardwareOffloadConfig_OUT, Offload) + WmiQueryHardwareOffloadConfig_OUT_Offload_SIZE)


// MSNdis_SetTcpOffloadParameters - MSNdis_SetTcpOffloadParameters
#define MSNdis_SetTcpOffloadParametersGuid \
    { 0x8ead9a22,0x7f69,0x4bc6, { 0x94,0x9a,0xc8,0x18,0x7b,0x07,0x4e,0x61 } }

#if ! (defined(MIDL_PASS))
DEFINE_GUID(MSNdis_SetTcpOffloadParameters_GUID, \
            0x8ead9a22,0x7f69,0x4bc6,0x94,0x9a,0xc8,0x18,0x7b,0x07,0x4e,0x61);
#endif

//
// Method id definitions for MSNdis_SetTcpOffloadParameters
#define WmiSetTcpOffloadParameters     1
typedef struct _WmiSetTcpOffloadParameters_IN
{
    // 
    MSNdis_WmiMethodHeader MethodHeader;
    #define WmiSetTcpOffloadParameters_IN_MethodHeader_SIZE sizeof(MSNdis_WmiMethodHeader)
    #define WmiSetTcpOffloadParameters_IN_MethodHeader_ID 1

    // 
    MSNdis_TcpOffloadParameters TcpOffloadParameters;
    #define WmiSetTcpOffloadParameters_IN_TcpOffloadParameters_SIZE sizeof(MSNdis_TcpOffloadParameters)
    #define WmiSetTcpOffloadParameters_IN_TcpOffloadParameters_ID 2

} WmiSetTcpOffloadParameters_IN, *PWmiSetTcpOffloadParameters_IN;

#define WmiSetTcpOffloadParameters_IN_SIZE (FIELD_OFFSET(WmiSetTcpOffloadParameters_IN, TcpOffloadParameters) + WmiSetTcpOffloadParameters_IN_TcpOffloadParameters_SIZE)

typedef struct _WmiSetTcpOffloadParameters_OUT
{
    // 
    MSNdis_WmiOutputInfo OutputInfo;
    #define WmiSetTcpOffloadParameters_OUT_OutputInfo_SIZE sizeof(MSNdis_WmiOutputInfo)
    #define WmiSetTcpOffloadParameters_OUT_OutputInfo_ID 3

} WmiSetTcpOffloadParameters_OUT, *PWmiSetTcpOffloadParameters_OUT;

#define WmiSetTcpOffloadParameters_OUT_SIZE (FIELD_OFFSET(WmiSetTcpOffloadParameters_OUT, OutputInfo) + WmiSetTcpOffloadParameters_OUT_OutputInfo_SIZE)


// MSNdis_TcpConnectionOffloadCurrentConfig - MSNdis_TcpConnectionOffloadCurrentConfig
#define MSNdis_TcpConnectionOffloadCurrentConfigGuid \
    { 0x2ee6aef1,0x0851,0x458b, { 0xbf,0x0d,0x79,0x23,0x43,0xd1,0xcd,0xe1 } }

#if ! (defined(MIDL_PASS))
DEFINE_GUID(MSNdis_TcpConnectionOffloadCurrentConfig_GUID, \
            0x2ee6aef1,0x0851,0x458b,0xbf,0x0d,0x79,0x23,0x43,0xd1,0xcd,0xe1);
#endif

//
// Method id definitions for MSNdis_TcpConnectionOffloadCurrentConfig
#define WmiQueryTcpConnectionOffloadCurrentConfig     1
typedef struct _WmiQueryTcpConnectionOffloadCurrentConfig_IN
{
    // 
    MSNdis_WmiMethodHeader Header;
    #define WmiQueryTcpConnectionOffloadCurrentConfig_IN_Header_SIZE sizeof(MSNdis_WmiMethodHeader)
    #define WmiQueryTcpConnectionOffloadCurrentConfig_IN_Header_ID 1

} WmiQueryTcpConnectionOffloadCurrentConfig_IN, *PWmiQueryTcpConnectionOffloadCurrentConfig_IN;

#define WmiQueryTcpConnectionOffloadCurrentConfig_IN_SIZE (FIELD_OFFSET(WmiQueryTcpConnectionOffloadCurrentConfig_IN, Header) + WmiQueryTcpConnectionOffloadCurrentConfig_IN_Header_SIZE)

typedef struct _WmiQueryTcpConnectionOffloadCurrentConfig_OUT
{
    // 
    MSNdis_WmiTcpConnectionOffload Offload;
    #define WmiQueryTcpConnectionOffloadCurrentConfig_OUT_Offload_SIZE sizeof(MSNdis_WmiTcpConnectionOffload)
    #define WmiQueryTcpConnectionOffloadCurrentConfig_OUT_Offload_ID 2

} WmiQueryTcpConnectionOffloadCurrentConfig_OUT, *PWmiQueryTcpConnectionOffloadCurrentConfig_OUT;

#define WmiQueryTcpConnectionOffloadCurrentConfig_OUT_SIZE (FIELD_OFFSET(WmiQueryTcpConnectionOffloadCurrentConfig_OUT, Offload) + WmiQueryTcpConnectionOffloadCurrentConfig_OUT_Offload_SIZE)


// MSNdis_TcpConnectionOffloadHardwareConfig - MSNdis_TcpConnectionOffloadHardwareConfig
#define MSNdis_TcpConnectionOffloadHardwareConfigGuid \
    { 0x8ce71f2c,0xd63a,0x4390, { 0xa4,0x87,0x18,0xfa,0x47,0x26,0x2c,0xeb } }

#if ! (defined(MIDL_PASS))
DEFINE_GUID(MSNdis_TcpConnectionOffloadHardwareConfig_GUID, \
            0x8ce71f2c,0xd63a,0x4390,0xa4,0x87,0x18,0xfa,0x47,0x26,0x2c,0xeb);
#endif

//
// Method id definitions for MSNdis_TcpConnectionOffloadHardwareConfig
#define WmiQueryTcpConnectionOffloadHardwareConfig     1
typedef struct _WmiQueryTcpConnectionOffloadHardwareConfig_IN
{
    // 
    MSNdis_WmiMethodHeader Header;
    #define WmiQueryTcpConnectionOffloadHardwareConfig_IN_Header_SIZE sizeof(MSNdis_WmiMethodHeader)
    #define WmiQueryTcpConnectionOffloadHardwareConfig_IN_Header_ID 1

} WmiQueryTcpConnectionOffloadHardwareConfig_IN, *PWmiQueryTcpConnectionOffloadHardwareConfig_IN;

#define WmiQueryTcpConnectionOffloadHardwareConfig_IN_SIZE (FIELD_OFFSET(WmiQueryTcpConnectionOffloadHardwareConfig_IN, Header) + WmiQueryTcpConnectionOffloadHardwareConfig_IN_Header_SIZE)

typedef struct _WmiQueryTcpConnectionOffloadHardwareConfig_OUT
{
    // 
    MSNdis_WmiTcpConnectionOffload Offload;
    #define WmiQueryTcpConnectionOffloadHardwareConfig_OUT_Offload_SIZE sizeof(MSNdis_WmiTcpConnectionOffload)
    #define WmiQueryTcpConnectionOffloadHardwareConfig_OUT_Offload_ID 2

} WmiQueryTcpConnectionOffloadHardwareConfig_OUT, *PWmiQueryTcpConnectionOffloadHardwareConfig_OUT;

#define WmiQueryTcpConnectionOffloadHardwareConfig_OUT_SIZE (FIELD_OFFSET(WmiQueryTcpConnectionOffloadHardwareConfig_OUT, Offload) + WmiQueryTcpConnectionOffloadHardwareConfig_OUT_Offload_SIZE)


// MSNdis_HDSplitCurrentConfig - MSNdis_HDSplitCurrentConfig
#define MSNdis_HDSplitCurrentConfigGuid \
    { 0x81d1303c,0xab00,0x4e49, { 0x80,0xb1,0x5e,0x6e,0x0b,0xf9,0xbe,0x53 } }

#if ! (defined(MIDL_PASS))
DEFINE_GUID(MSNdis_HDSplitCurrentConfig_GUID, \
            0x81d1303c,0xab00,0x4e49,0x80,0xb1,0x5e,0x6e,0x0b,0xf9,0xbe,0x53);
#endif

//
// Method id definitions for MSNdis_HDSplitCurrentConfig
#define WmiQueryHDSplitCurrentConfig     1
typedef struct _WmiQueryHDSplitCurrentConfig_IN
{
    // 
    MSNdis_WmiMethodHeader Header;
    #define WmiQueryHDSplitCurrentConfig_IN_Header_SIZE sizeof(MSNdis_WmiMethodHeader)
    #define WmiQueryHDSplitCurrentConfig_IN_Header_ID 1

} WmiQueryHDSplitCurrentConfig_IN, *PWmiQueryHDSplitCurrentConfig_IN;

#define WmiQueryHDSplitCurrentConfig_IN_SIZE (FIELD_OFFSET(WmiQueryHDSplitCurrentConfig_IN, Header) + WmiQueryHDSplitCurrentConfig_IN_Header_SIZE)

typedef struct _WmiQueryHDSplitCurrentConfig_OUT
{
    // 
    MSNdis_WmiHDSplitCurrentConfig HdSplitCurrentConfig;
    #define WmiQueryHDSplitCurrentConfig_OUT_HdSplitCurrentConfig_SIZE sizeof(MSNdis_WmiHDSplitCurrentConfig)
    #define WmiQueryHDSplitCurrentConfig_OUT_HdSplitCurrentConfig_ID 2

} WmiQueryHDSplitCurrentConfig_OUT, *PWmiQueryHDSplitCurrentConfig_OUT;

#define WmiQueryHDSplitCurrentConfig_OUT_SIZE (FIELD_OFFSET(WmiQueryHDSplitCurrentConfig_OUT, HdSplitCurrentConfig) + WmiQueryHDSplitCurrentConfig_OUT_HdSplitCurrentConfig_SIZE)


// MSNdis_SetHDSplitParameters - MSNdis_SetHDSplitParameters
#define MSNdis_SetHDSplitParametersGuid \
    { 0x8c048bea,0x2913,0x4458, { 0xb6,0x8e,0x17,0xf6,0xc1,0xe5,0xc6,0x0e } }

#if ! (defined(MIDL_PASS))
DEFINE_GUID(MSNdis_SetHDSplitParameters_GUID, \
            0x8c048bea,0x2913,0x4458,0xb6,0x8e,0x17,0xf6,0xc1,0xe5,0xc6,0x0e);
#endif

//
// Method id definitions for MSNdis_SetHDSplitParameters
#define WmiSetHDSplitParameters     1
typedef struct _WmiSetHDSplitParameters_IN
{
    // 
    MSNdis_WmiMethodHeader MethodHeader;
    #define WmiSetHDSplitParameters_IN_MethodHeader_SIZE sizeof(MSNdis_WmiMethodHeader)
    #define WmiSetHDSplitParameters_IN_MethodHeader_ID 1

    // 
    MSNdis_HDSplitParameters HDSplitParameters;
    #define WmiSetHDSplitParameters_IN_HDSplitParameters_SIZE sizeof(MSNdis_HDSplitParameters)
    #define WmiSetHDSplitParameters_IN_HDSplitParameters_ID 2

} WmiSetHDSplitParameters_IN, *PWmiSetHDSplitParameters_IN;

#define WmiSetHDSplitParameters_IN_SIZE (FIELD_OFFSET(WmiSetHDSplitParameters_IN, HDSplitParameters) + WmiSetHDSplitParameters_IN_HDSplitParameters_SIZE)

typedef struct _WmiSetHDSplitParameters_OUT
{
    // 
    MSNdis_WmiOutputInfo OutputInfo;
    #define WmiSetHDSplitParameters_OUT_OutputInfo_SIZE sizeof(MSNdis_WmiOutputInfo)
    #define WmiSetHDSplitParameters_OUT_OutputInfo_ID 3

} WmiSetHDSplitParameters_OUT, *PWmiSetHDSplitParameters_OUT;

#define WmiSetHDSplitParameters_OUT_SIZE (FIELD_OFFSET(WmiSetHDSplitParameters_OUT, OutputInfo) + WmiSetHDSplitParameters_OUT_OutputInfo_SIZE)


// MSNdis_80211_BaseServiceSetIdentifier - MSNdis_80211_BaseServiceSetIdentifier
#define MSNdis_80211_BaseServiceSetIdentifierGuid \
    { 0x2504b6c2,0x1fa5,0x11d4, { 0x97,0xeb,0x00,0xc0,0x4f,0x79,0xc4,0x03 } }

#if ! (defined(MIDL_PASS))
DEFINE_GUID(MSNdis_80211_BaseServiceSetIdentifier_GUID, \
            0x2504b6c2,0x1fa5,0x11d4,0x97,0xeb,0x00,0xc0,0x4f,0x79,0xc4,0x03);
#endif


typedef struct _MSNdis_80211_BaseServiceSetIdentifier
{
    // 
    UCHAR Ndis80211MacAddress[6];
    #define MSNdis_80211_BaseServiceSetIdentifier_Ndis80211MacAddress_SIZE sizeof(UCHAR[6])
    #define MSNdis_80211_BaseServiceSetIdentifier_Ndis80211MacAddress_ID 1

} MSNdis_80211_BaseServiceSetIdentifier, *PMSNdis_80211_BaseServiceSetIdentifier;

#define MSNdis_80211_BaseServiceSetIdentifier_SIZE (FIELD_OFFSET(MSNdis_80211_BaseServiceSetIdentifier, Ndis80211MacAddress) + MSNdis_80211_BaseServiceSetIdentifier_Ndis80211MacAddress_SIZE)

// MSNdis_80211_ServiceSetIdentifier - MSNdis_80211_ServiceSetIdentifier
#define MSNdis_80211_ServiceSetIdentifierGuid \
    { 0x7d2a90ea,0x2041,0x11d4, { 0x97,0xeb,0x00,0xc0,0x4f,0x79,0xc4,0x03 } }

#if ! (defined(MIDL_PASS))
DEFINE_GUID(MSNdis_80211_ServiceSetIdentifier_GUID, \
            0x7d2a90ea,0x2041,0x11d4,0x97,0xeb,0x00,0xc0,0x4f,0x79,0xc4,0x03);
#endif


typedef struct _MSNdis_80211_ServiceSetIdentifier
{
    // 
    UCHAR Ndis80211SsId[33];
    #define MSNdis_80211_ServiceSetIdentifier_Ndis80211SsId_SIZE sizeof(UCHAR[33])
    #define MSNdis_80211_ServiceSetIdentifier_Ndis80211SsId_ID 1

} MSNdis_80211_ServiceSetIdentifier, *PMSNdis_80211_ServiceSetIdentifier;

#define MSNdis_80211_ServiceSetIdentifier_SIZE (FIELD_OFFSET(MSNdis_80211_ServiceSetIdentifier, Ndis80211SsId) + MSNdis_80211_ServiceSetIdentifier_Ndis80211SsId_SIZE)

// MSNdis_80211_NetworkType - MSNdis_80211_NetworkType
#define MSNdis_80211_NetworkTypeGuid \
    { 0xe779ab61,0xb9ab,0x11d4, { 0xb6,0x75,0x00,0x20,0x48,0x57,0x03,0x37 } }

#if ! (defined(MIDL_PASS))
DEFINE_GUID(MSNdis_80211_NetworkType_GUID, \
            0xe779ab61,0xb9ab,0x11d4,0xb6,0x75,0x00,0x20,0x48,0x57,0x03,0x37);
#endif


typedef struct _MSNdis_80211_NetworkType
{
    // 
    ULONG Ndis80211NetworkType;
    #define MSNdis_80211_NetworkType_Ndis80211NetworkType_SIZE sizeof(ULONG)
    #define MSNdis_80211_NetworkType_Ndis80211NetworkType_ID 1

} MSNdis_80211_NetworkType, *PMSNdis_80211_NetworkType;

#define MSNdis_80211_NetworkType_SIZE (FIELD_OFFSET(MSNdis_80211_NetworkType, Ndis80211NetworkType) + MSNdis_80211_NetworkType_Ndis80211NetworkType_SIZE)

// MSNdis_80211_NetworkTypesSupported - MSNdis_80211_NetworkTypesSupported
#define MSNdis_80211_NetworkTypesSupportedGuid \
    { 0x8531d6e6,0x2041,0x11d4, { 0x97,0xeb,0x00,0xc0,0x4f,0x79,0xc4,0x03 } }

#if ! (defined(MIDL_PASS))
DEFINE_GUID(MSNdis_80211_NetworkTypesSupported_GUID, \
            0x8531d6e6,0x2041,0x11d4,0x97,0xeb,0x00,0xc0,0x4f,0x79,0xc4,0x03);
#endif


typedef struct _MSNdis_80211_NetworkTypesSupported
{
    // 
    ULONG NumberOfItems;
    #define MSNdis_80211_NetworkTypesSupported_NumberOfItems_SIZE sizeof(ULONG)
    #define MSNdis_80211_NetworkTypesSupported_NumberOfItems_ID 1

    // 
    MSNdis_80211_NetworkType Ndis80211NetworkTypes[1];
    #define MSNdis_80211_NetworkTypesSupported_Ndis80211NetworkTypes_ID 2

} MSNdis_80211_NetworkTypesSupported, *PMSNdis_80211_NetworkTypesSupported;

// MSNdis_80211_NetworkTypeInUse - MSNdis_80211_NetworkTypeInUse
#define MSNdis_80211_NetworkTypeInUseGuid \
    { 0x857e2326,0x2041,0x11d4, { 0x97,0xeb,0x00,0xc0,0x4f,0x79,0xc4,0x03 } }

#if ! (defined(MIDL_PASS))
DEFINE_GUID(MSNdis_80211_NetworkTypeInUse_GUID, \
            0x857e2326,0x2041,0x11d4,0x97,0xeb,0x00,0xc0,0x4f,0x79,0xc4,0x03);
#endif


typedef struct _MSNdis_80211_NetworkTypeInUse
{
    // 
    MSNdis_80211_NetworkType Ndis80211NetworkTypeInUse;
    #define MSNdis_80211_NetworkTypeInUse_Ndis80211NetworkTypeInUse_SIZE sizeof(MSNdis_80211_NetworkType)
    #define MSNdis_80211_NetworkTypeInUse_Ndis80211NetworkTypeInUse_ID 1

} MSNdis_80211_NetworkTypeInUse, *PMSNdis_80211_NetworkTypeInUse;

#define MSNdis_80211_NetworkTypeInUse_SIZE (FIELD_OFFSET(MSNdis_80211_NetworkTypeInUse, Ndis80211NetworkTypeInUse) + MSNdis_80211_NetworkTypeInUse_Ndis80211NetworkTypeInUse_SIZE)

// MSNdis_80211_PowerMode - MSNdis_80211_PowerMode
#define MSNdis_80211_PowerModeGuid \
    { 0x85be837c,0x2041,0x11d4, { 0x97,0xeb,0x00,0xc0,0x4f,0x79,0xc4,0x03 } }

#if ! (defined(MIDL_PASS))
DEFINE_GUID(MSNdis_80211_PowerMode_GUID, \
            0x85be837c,0x2041,0x11d4,0x97,0xeb,0x00,0xc0,0x4f,0x79,0xc4,0x03);
#endif


typedef struct _MSNdis_80211_PowerMode
{
    // 
    ULONG Ndis80211PowerMode;
    #define MSNdis_80211_PowerMode_Ndis80211PowerMode_SIZE sizeof(ULONG)
    #define MSNdis_80211_PowerMode_Ndis80211PowerMode_ID 1

} MSNdis_80211_PowerMode, *PMSNdis_80211_PowerMode;

#define MSNdis_80211_PowerMode_SIZE (FIELD_OFFSET(MSNdis_80211_PowerMode, Ndis80211PowerMode) + MSNdis_80211_PowerMode_Ndis80211PowerMode_SIZE)

// MSNdis_80211_TransmitPowerLevel - MSNdis_80211_TransmitPowerLevel
#define MSNdis_80211_TransmitPowerLevelGuid \
    { 0x11e6ba76,0x2053,0x11d4, { 0x97,0xeb,0x00,0xc0,0x4f,0x79,0xc4,0x03 } }

#if ! (defined(MIDL_PASS))
DEFINE_GUID(MSNdis_80211_TransmitPowerLevel_GUID, \
            0x11e6ba76,0x2053,0x11d4,0x97,0xeb,0x00,0xc0,0x4f,0x79,0xc4,0x03);
#endif


typedef struct _MSNdis_80211_TransmitPowerLevel
{
    // 
    ULONG Ndis80211TransmitPowerLevel;
    #define MSNdis_80211_TransmitPowerLevel_Ndis80211TransmitPowerLevel_SIZE sizeof(ULONG)
    #define MSNdis_80211_TransmitPowerLevel_Ndis80211TransmitPowerLevel_ID 1

} MSNdis_80211_TransmitPowerLevel, *PMSNdis_80211_TransmitPowerLevel;

#define MSNdis_80211_TransmitPowerLevel_SIZE (FIELD_OFFSET(MSNdis_80211_TransmitPowerLevel, Ndis80211TransmitPowerLevel) + MSNdis_80211_TransmitPowerLevel_Ndis80211TransmitPowerLevel_SIZE)

// MSNdis_80211_ReceivedSignalStrength - MSNdis_80211_ReceivedSignalStrength
#define MSNdis_80211_ReceivedSignalStrengthGuid \
    { 0x1507db16,0x2053,0x11d4, { 0x97,0xeb,0x00,0xc0,0x4f,0x79,0xc4,0x03 } }

#if ! (defined(MIDL_PASS))
DEFINE_GUID(MSNdis_80211_ReceivedSignalStrength_GUID, \
            0x1507db16,0x2053,0x11d4,0x97,0xeb,0x00,0xc0,0x4f,0x79,0xc4,0x03);
#endif


typedef struct _MSNdis_80211_ReceivedSignalStrength
{
    // 
    LONG Ndis80211ReceivedSignalStrength;
    #define MSNdis_80211_ReceivedSignalStrength_Ndis80211ReceivedSignalStrength_SIZE sizeof(LONG)
    #define MSNdis_80211_ReceivedSignalStrength_Ndis80211ReceivedSignalStrength_ID 1

} MSNdis_80211_ReceivedSignalStrength, *PMSNdis_80211_ReceivedSignalStrength;

#define MSNdis_80211_ReceivedSignalStrength_SIZE (FIELD_OFFSET(MSNdis_80211_ReceivedSignalStrength, Ndis80211ReceivedSignalStrength) + MSNdis_80211_ReceivedSignalStrength_Ndis80211ReceivedSignalStrength_SIZE)

// MSNdis_80211_ReceivedSignalStrengthEventTrigger - MSNdis_80211_ReceivedSignalStrengthEventTrigger
#define MSNdis_80211_ReceivedSignalStrengthEventTriggerGuid \
    { 0x155689b8,0x2053,0x11d4, { 0x97,0xeb,0x00,0xc0,0x4f,0x79,0xc4,0x03 } }

#if ! (defined(MIDL_PASS))
DEFINE_GUID(MSNdis_80211_ReceivedSignalStrengthEventTrigger_GUID, \
            0x155689b8,0x2053,0x11d4,0x97,0xeb,0x00,0xc0,0x4f,0x79,0xc4,0x03);
#endif


typedef struct _MSNdis_80211_ReceivedSignalStrengthEventTrigger
{
    // 
    LONG Ndis80211ReceivedSignalStrengthTrigger;
    #define MSNdis_80211_ReceivedSignalStrengthEventTrigger_Ndis80211ReceivedSignalStrengthTrigger_SIZE sizeof(LONG)
    #define MSNdis_80211_ReceivedSignalStrengthEventTrigger_Ndis80211ReceivedSignalStrengthTrigger_ID 1

} MSNdis_80211_ReceivedSignalStrengthEventTrigger, *PMSNdis_80211_ReceivedSignalStrengthEventTrigger;

#define MSNdis_80211_ReceivedSignalStrengthEventTrigger_SIZE (FIELD_OFFSET(MSNdis_80211_ReceivedSignalStrengthEventTrigger, Ndis80211ReceivedSignalStrengthTrigger) + MSNdis_80211_ReceivedSignalStrengthEventTrigger_Ndis80211ReceivedSignalStrengthTrigger_SIZE)

// MSNdis_80211_NetworkInfrastructure - MSNdis_80211_NetworkInfrastructure
#define MSNdis_80211_NetworkInfrastructureGuid \
    { 0x34e1fa48,0xb9b6,0x11d4, { 0xb6,0x75,0x00,0x20,0x48,0x57,0x03,0x37 } }

#if ! (defined(MIDL_PASS))
DEFINE_GUID(MSNdis_80211_NetworkInfrastructure_GUID, \
            0x34e1fa48,0xb9b6,0x11d4,0xb6,0x75,0x00,0x20,0x48,0x57,0x03,0x37);
#endif


typedef struct _MSNdis_80211_NetworkInfrastructure
{
    // 
    ULONG Ndis80211NetworkInfrastructure;
    #define MSNdis_80211_NetworkInfrastructure_Ndis80211NetworkInfrastructure_SIZE sizeof(ULONG)
    #define MSNdis_80211_NetworkInfrastructure_Ndis80211NetworkInfrastructure_ID 1

} MSNdis_80211_NetworkInfrastructure, *PMSNdis_80211_NetworkInfrastructure;

#define MSNdis_80211_NetworkInfrastructure_SIZE (FIELD_OFFSET(MSNdis_80211_NetworkInfrastructure, Ndis80211NetworkInfrastructure) + MSNdis_80211_NetworkInfrastructure_Ndis80211NetworkInfrastructure_SIZE)

// MSNdis_80211_ConfigurationFH - MSNdis_80211_ConfigurationFH
#define MSNdis_80211_ConfigurationFHGuid \
    { 0x4a800b8c,0x2068,0x11d4, { 0x97,0xeb,0x00,0xc0,0x4f,0x79,0xc4,0x03 } }

#if ! (defined(MIDL_PASS))
DEFINE_GUID(MSNdis_80211_ConfigurationFH_GUID, \
            0x4a800b8c,0x2068,0x11d4,0x97,0xeb,0x00,0xc0,0x4f,0x79,0xc4,0x03);
#endif


typedef struct _MSNdis_80211_ConfigurationFH
{
    // 
    ULONG FHLength;
    #define MSNdis_80211_ConfigurationFH_FHLength_SIZE sizeof(ULONG)
    #define MSNdis_80211_ConfigurationFH_FHLength_ID 1

    // 
    ULONG HopPattern;
    #define MSNdis_80211_ConfigurationFH_HopPattern_SIZE sizeof(ULONG)
    #define MSNdis_80211_ConfigurationFH_HopPattern_ID 2

    // 
    ULONG HopSet;
    #define MSNdis_80211_ConfigurationFH_HopSet_SIZE sizeof(ULONG)
    #define MSNdis_80211_ConfigurationFH_HopSet_ID 3

    // 
    ULONG DwellTime;
    #define MSNdis_80211_ConfigurationFH_DwellTime_SIZE sizeof(ULONG)
    #define MSNdis_80211_ConfigurationFH_DwellTime_ID 4

} MSNdis_80211_ConfigurationFH, *PMSNdis_80211_ConfigurationFH;

#define MSNdis_80211_ConfigurationFH_SIZE (FIELD_OFFSET(MSNdis_80211_ConfigurationFH, DwellTime) + MSNdis_80211_ConfigurationFH_DwellTime_SIZE)

// MSNdis_80211_ConfigurationInfo - MSNdis_80211_ConfigurationInfo
#define MSNdis_80211_ConfigurationInfoGuid \
    { 0x220c16fc,0xb9a8,0x11d4, { 0xb6,0x75,0x00,0x20,0x48,0x57,0x03,0x37 } }

#if ! (defined(MIDL_PASS))
DEFINE_GUID(MSNdis_80211_ConfigurationInfo_GUID, \
            0x220c16fc,0xb9a8,0x11d4,0xb6,0x75,0x00,0x20,0x48,0x57,0x03,0x37);
#endif


typedef struct _MSNdis_80211_ConfigurationInfo
{
    // 
    ULONG ConfigLength;
    #define MSNdis_80211_ConfigurationInfo_ConfigLength_SIZE sizeof(ULONG)
    #define MSNdis_80211_ConfigurationInfo_ConfigLength_ID 1

    // 
    ULONG BeaconPeriod;
    #define MSNdis_80211_ConfigurationInfo_BeaconPeriod_SIZE sizeof(ULONG)
    #define MSNdis_80211_ConfigurationInfo_BeaconPeriod_ID 2

    // 
    ULONG ATIMWindow;
    #define MSNdis_80211_ConfigurationInfo_ATIMWindow_SIZE sizeof(ULONG)
    #define MSNdis_80211_ConfigurationInfo_ATIMWindow_ID 3

    // 
    ULONG DSConfig;
    #define MSNdis_80211_ConfigurationInfo_DSConfig_SIZE sizeof(ULONG)
    #define MSNdis_80211_ConfigurationInfo_DSConfig_ID 4

    // 
    MSNdis_80211_ConfigurationFH FHConfig;
    #define MSNdis_80211_ConfigurationInfo_FHConfig_SIZE sizeof(MSNdis_80211_ConfigurationFH)
    #define MSNdis_80211_ConfigurationInfo_FHConfig_ID 5

} MSNdis_80211_ConfigurationInfo, *PMSNdis_80211_ConfigurationInfo;

#define MSNdis_80211_ConfigurationInfo_SIZE (FIELD_OFFSET(MSNdis_80211_ConfigurationInfo, FHConfig) + MSNdis_80211_ConfigurationInfo_FHConfig_SIZE)

// MSNdis_80211_WLanBssId - MSNdis_80211_WLanBssId
#define MSNdis_80211_WLanBssIdGuid \
    { 0x6929e718,0x2062,0x11d4, { 0x97,0xeb,0x00,0xc0,0x4f,0x79,0xc4,0x03 } }

#if ! (defined(MIDL_PASS))
DEFINE_GUID(MSNdis_80211_WLanBssId_GUID, \
            0x6929e718,0x2062,0x11d4,0x97,0xeb,0x00,0xc0,0x4f,0x79,0xc4,0x03);
#endif


typedef struct _MSNdis_80211_WLanBssId
{
    // 
    ULONG Ndis80211WLanBssIdLength;
    #define MSNdis_80211_WLanBssId_Ndis80211WLanBssIdLength_SIZE sizeof(ULONG)
    #define MSNdis_80211_WLanBssId_Ndis80211WLanBssIdLength_ID 1

    // 
    UCHAR Ndis80211MacAddress[6];
    #define MSNdis_80211_WLanBssId_Ndis80211MacAddress_SIZE sizeof(UCHAR[6])
    #define MSNdis_80211_WLanBssId_Ndis80211MacAddress_ID 2

    // 
    USHORT Reserved;
    #define MSNdis_80211_WLanBssId_Reserved_SIZE sizeof(USHORT)
    #define MSNdis_80211_WLanBssId_Reserved_ID 3

    // 
    ULONG Ndis80211SsIdLength;
    #define MSNdis_80211_WLanBssId_Ndis80211SsIdLength_SIZE sizeof(ULONG)
    #define MSNdis_80211_WLanBssId_Ndis80211SsIdLength_ID 4

    // 
    UCHAR Ndis80211SsId[32];
    #define MSNdis_80211_WLanBssId_Ndis80211SsId_SIZE sizeof(UCHAR[32])
    #define MSNdis_80211_WLanBssId_Ndis80211SsId_ID 5

    // 
    ULONG Ndis80211Privacy;
    #define MSNdis_80211_WLanBssId_Ndis80211Privacy_SIZE sizeof(ULONG)
    #define MSNdis_80211_WLanBssId_Ndis80211Privacy_ID 6

    // 
    ULONG Ndis80211Rssi;
    #define MSNdis_80211_WLanBssId_Ndis80211Rssi_SIZE sizeof(ULONG)
    #define MSNdis_80211_WLanBssId_Ndis80211Rssi_ID 7

    // 
    MSNdis_80211_NetworkType Ndis80211NetworkTypeInUse;
    #define MSNdis_80211_WLanBssId_Ndis80211NetworkTypeInUse_SIZE sizeof(MSNdis_80211_NetworkType)
    #define MSNdis_80211_WLanBssId_Ndis80211NetworkTypeInUse_ID 8

    // 
    MSNdis_80211_ConfigurationInfo Ndis80211Configuration;
    #define MSNdis_80211_WLanBssId_Ndis80211Configuration_SIZE sizeof(MSNdis_80211_ConfigurationInfo)
    #define MSNdis_80211_WLanBssId_Ndis80211Configuration_ID 9

    // 
    MSNdis_80211_NetworkInfrastructure Ndis80211InfrastructureMode;
    #define MSNdis_80211_WLanBssId_Ndis80211InfrastructureMode_SIZE sizeof(MSNdis_80211_NetworkInfrastructure)
    #define MSNdis_80211_WLanBssId_Ndis80211InfrastructureMode_ID 10

    // 
    UCHAR Ndis80211SupportedRate[8];
    #define MSNdis_80211_WLanBssId_Ndis80211SupportedRate_SIZE sizeof(UCHAR[8])
    #define MSNdis_80211_WLanBssId_Ndis80211SupportedRate_ID 11

} MSNdis_80211_WLanBssId, *PMSNdis_80211_WLanBssId;

#define MSNdis_80211_WLanBssId_SIZE (FIELD_OFFSET(MSNdis_80211_WLanBssId, Ndis80211SupportedRate) + MSNdis_80211_WLanBssId_Ndis80211SupportedRate_SIZE)

// MSNdis_80211_BSSIList - MSNdis_80211_BSSIList
#define MSNdis_80211_BSSIListGuid \
    { 0x69526f9a,0x2062,0x11d4, { 0x97,0xeb,0x00,0xc0,0x4f,0x79,0xc4,0x03 } }

#if ! (defined(MIDL_PASS))
DEFINE_GUID(MSNdis_80211_BSSIList_GUID, \
            0x69526f9a,0x2062,0x11d4,0x97,0xeb,0x00,0xc0,0x4f,0x79,0xc4,0x03);
#endif


typedef struct _MSNdis_80211_BSSIList
{
    // 
    ULONG NumberOfItems;
    #define MSNdis_80211_BSSIList_NumberOfItems_SIZE sizeof(ULONG)
    #define MSNdis_80211_BSSIList_NumberOfItems_ID 1

    // 
    MSNdis_80211_WLanBssId Ndis80211BSSIList[1];
    #define MSNdis_80211_BSSIList_Ndis80211BSSIList_ID 2

} MSNdis_80211_BSSIList, *PMSNdis_80211_BSSIList;

// MSNdis_80211_InfrastructureMode - MSNdis_80211_InfrastructureMode
#define MSNdis_80211_InfrastructureModeGuid \
    { 0x697d5a7e,0x2062,0x11d4, { 0x97,0xeb,0x00,0xc0,0x4f,0x79,0xc4,0x03 } }

#if ! (defined(MIDL_PASS))
DEFINE_GUID(MSNdis_80211_InfrastructureMode_GUID, \
            0x697d5a7e,0x2062,0x11d4,0x97,0xeb,0x00,0xc0,0x4f,0x79,0xc4,0x03);
#endif


typedef struct _MSNdis_80211_InfrastructureMode
{
    // 
    MSNdis_80211_NetworkInfrastructure Ndis80211InfrastructureMode;
    #define MSNdis_80211_InfrastructureMode_Ndis80211InfrastructureMode_SIZE sizeof(MSNdis_80211_NetworkInfrastructure)
    #define MSNdis_80211_InfrastructureMode_Ndis80211InfrastructureMode_ID 1

} MSNdis_80211_InfrastructureMode, *PMSNdis_80211_InfrastructureMode;

#define MSNdis_80211_InfrastructureMode_SIZE (FIELD_OFFSET(MSNdis_80211_InfrastructureMode, Ndis80211InfrastructureMode) + MSNdis_80211_InfrastructureMode_Ndis80211InfrastructureMode_SIZE)

// MSNdis_80211_FragmentationThreshold - MSNdis_80211_FragmentationThreshold
#define MSNdis_80211_FragmentationThresholdGuid \
    { 0x69aaa7c4,0x2062,0x11d4, { 0x97,0xeb,0x00,0xc0,0x4f,0x79,0xc4,0x03 } }

#if ! (defined(MIDL_PASS))
DEFINE_GUID(MSNdis_80211_FragmentationThreshold_GUID, \
            0x69aaa7c4,0x2062,0x11d4,0x97,0xeb,0x00,0xc0,0x4f,0x79,0xc4,0x03);
#endif


typedef struct _MSNdis_80211_FragmentationThreshold
{
    // 
    ULONG Ndis80211FragmentationThreshold;
    #define MSNdis_80211_FragmentationThreshold_Ndis80211FragmentationThreshold_SIZE sizeof(ULONG)
    #define MSNdis_80211_FragmentationThreshold_Ndis80211FragmentationThreshold_ID 1

} MSNdis_80211_FragmentationThreshold, *PMSNdis_80211_FragmentationThreshold;

#define MSNdis_80211_FragmentationThreshold_SIZE (FIELD_OFFSET(MSNdis_80211_FragmentationThreshold, Ndis80211FragmentationThreshold) + MSNdis_80211_FragmentationThreshold_Ndis80211FragmentationThreshold_SIZE)

// MSNdis_80211_RTSThreshold - MSNdis_80211_RTSThreshold
#define MSNdis_80211_RTSThresholdGuid \
    { 0x0134d07e,0x2064,0x11d4, { 0x97,0xeb,0x00,0xc0,0x4f,0x79,0xc4,0x03 } }

#if ! (defined(MIDL_PASS))
DEFINE_GUID(MSNdis_80211_RTSThreshold_GUID, \
            0x0134d07e,0x2064,0x11d4,0x97,0xeb,0x00,0xc0,0x4f,0x79,0xc4,0x03);
#endif


typedef struct _MSNdis_80211_RTSThreshold
{
    // 
    ULONG Ndis80211RTSThreshold;
    #define MSNdis_80211_RTSThreshold_Ndis80211RTSThreshold_SIZE sizeof(ULONG)
    #define MSNdis_80211_RTSThreshold_Ndis80211RTSThreshold_ID 1

} MSNdis_80211_RTSThreshold, *PMSNdis_80211_RTSThreshold;

#define MSNdis_80211_RTSThreshold_SIZE (FIELD_OFFSET(MSNdis_80211_RTSThreshold, Ndis80211RTSThreshold) + MSNdis_80211_RTSThreshold_Ndis80211RTSThreshold_SIZE)

// MSNdis_80211_NumberOfAntennas - MSNdis_80211_NumberOfAntennas
#define MSNdis_80211_NumberOfAntennasGuid \
    { 0x01779336,0x2064,0x11d4, { 0x97,0xeb,0x00,0xc0,0x4f,0x79,0xc4,0x03 } }

#if ! (defined(MIDL_PASS))
DEFINE_GUID(MSNdis_80211_NumberOfAntennas_GUID, \
            0x01779336,0x2064,0x11d4,0x97,0xeb,0x00,0xc0,0x4f,0x79,0xc4,0x03);
#endif


typedef struct _MSNdis_80211_NumberOfAntennas
{
    // 
    ULONG Ndis80211NumberOfAntennas;
    #define MSNdis_80211_NumberOfAntennas_Ndis80211NumberOfAntennas_SIZE sizeof(ULONG)
    #define MSNdis_80211_NumberOfAntennas_Ndis80211NumberOfAntennas_ID 1

} MSNdis_80211_NumberOfAntennas, *PMSNdis_80211_NumberOfAntennas;

#define MSNdis_80211_NumberOfAntennas_SIZE (FIELD_OFFSET(MSNdis_80211_NumberOfAntennas, Ndis80211NumberOfAntennas) + MSNdis_80211_NumberOfAntennas_Ndis80211NumberOfAntennas_SIZE)

// MSNdis_80211_ReceiveAntennaSelected - MSNdis_80211_ReceiveAntennaSelected
#define MSNdis_80211_ReceiveAntennaSelectedGuid \
    { 0x01ac07a2,0x2064,0x11d4, { 0x97,0xeb,0x00,0xc0,0x4f,0x79,0xc4,0x03 } }

#if ! (defined(MIDL_PASS))
DEFINE_GUID(MSNdis_80211_ReceiveAntennaSelected_GUID, \
            0x01ac07a2,0x2064,0x11d4,0x97,0xeb,0x00,0xc0,0x4f,0x79,0xc4,0x03);
#endif


typedef struct _MSNdis_80211_ReceiveAntennaSelected
{
    // 
    ULONG Ndis80211ReceiveAntennaSelected;
    #define MSNdis_80211_ReceiveAntennaSelected_Ndis80211ReceiveAntennaSelected_SIZE sizeof(ULONG)
    #define MSNdis_80211_ReceiveAntennaSelected_Ndis80211ReceiveAntennaSelected_ID 1

} MSNdis_80211_ReceiveAntennaSelected, *PMSNdis_80211_ReceiveAntennaSelected;

#define MSNdis_80211_ReceiveAntennaSelected_SIZE (FIELD_OFFSET(MSNdis_80211_ReceiveAntennaSelected, Ndis80211ReceiveAntennaSelected) + MSNdis_80211_ReceiveAntennaSelected_Ndis80211ReceiveAntennaSelected_SIZE)

// MSNdis_80211_TransmitAntennaSelected - MSNdis_80211_TransmitAntennaSelected
#define MSNdis_80211_TransmitAntennaSelectedGuid \
    { 0x01dbb74a,0x2064,0x11d4, { 0x97,0xeb,0x00,0xc0,0x4f,0x79,0xc4,0x03 } }

#if ! (defined(MIDL_PASS))
DEFINE_GUID(MSNdis_80211_TransmitAntennaSelected_GUID, \
            0x01dbb74a,0x2064,0x11d4,0x97,0xeb,0x00,0xc0,0x4f,0x79,0xc4,0x03);
#endif


typedef struct _MSNdis_80211_TransmitAntennaSelected
{
    // 
    ULONG Ndis80211TransmitAntennaSelected;
    #define MSNdis_80211_TransmitAntennaSelected_Ndis80211TransmitAntennaSelected_SIZE sizeof(ULONG)
    #define MSNdis_80211_TransmitAntennaSelected_Ndis80211TransmitAntennaSelected_ID 1

} MSNdis_80211_TransmitAntennaSelected, *PMSNdis_80211_TransmitAntennaSelected;

#define MSNdis_80211_TransmitAntennaSelected_SIZE (FIELD_OFFSET(MSNdis_80211_TransmitAntennaSelected, Ndis80211TransmitAntennaSelected) + MSNdis_80211_TransmitAntennaSelected_Ndis80211TransmitAntennaSelected_SIZE)

// MSNdis_80211_DataRates - MSNdis_80211_DataRates
#define MSNdis_80211_DataRatesGuid \
    { 0x49db8722,0x2068,0x11d4, { 0x97,0xeb,0x00,0xc0,0x4f,0x79,0xc4,0x03 } }

#if ! (defined(MIDL_PASS))
DEFINE_GUID(MSNdis_80211_DataRates_GUID, \
            0x49db8722,0x2068,0x11d4,0x97,0xeb,0x00,0xc0,0x4f,0x79,0xc4,0x03);
#endif


typedef struct _MSNdis_80211_DataRates
{
    // 
    UCHAR Ndis80211DataRate[8];
    #define MSNdis_80211_DataRates_Ndis80211DataRate_SIZE sizeof(UCHAR[8])
    #define MSNdis_80211_DataRates_Ndis80211DataRate_ID 1

} MSNdis_80211_DataRates, *PMSNdis_80211_DataRates;

#define MSNdis_80211_DataRates_SIZE (FIELD_OFFSET(MSNdis_80211_DataRates, Ndis80211DataRate) + MSNdis_80211_DataRates_Ndis80211DataRate_SIZE)

// MSNdis_80211_DesiredDataRates - MSNdis_80211_DesiredDataRates
#define MSNdis_80211_DesiredDataRatesGuid \
    { 0x452ee08e,0x2536,0x11d4, { 0x97,0xeb,0x00,0xc0,0x4f,0x79,0xc4,0x03 } }

#if ! (defined(MIDL_PASS))
DEFINE_GUID(MSNdis_80211_DesiredDataRates_GUID, \
            0x452ee08e,0x2536,0x11d4,0x97,0xeb,0x00,0xc0,0x4f,0x79,0xc4,0x03);
#endif


typedef struct _MSNdis_80211_DesiredDataRates
{
    // 
    UCHAR Ndis80211DesiredRate[8];
    #define MSNdis_80211_DesiredDataRates_Ndis80211DesiredRate_SIZE sizeof(UCHAR[8])
    #define MSNdis_80211_DesiredDataRates_Ndis80211DesiredRate_ID 1

} MSNdis_80211_DesiredDataRates, *PMSNdis_80211_DesiredDataRates;

#define MSNdis_80211_DesiredDataRates_SIZE (FIELD_OFFSET(MSNdis_80211_DesiredDataRates, Ndis80211DesiredRate) + MSNdis_80211_DesiredDataRates_Ndis80211DesiredRate_SIZE)

// MSNdis_80211_Configuration - MSNdis_80211_Configuration
#define MSNdis_80211_ConfigurationGuid \
    { 0x4a4df982,0x2068,0x11d4, { 0x97,0xeb,0x00,0xc0,0x4f,0x79,0xc4,0x03 } }

#if ! (defined(MIDL_PASS))
DEFINE_GUID(MSNdis_80211_Configuration_GUID, \
            0x4a4df982,0x2068,0x11d4,0x97,0xeb,0x00,0xc0,0x4f,0x79,0xc4,0x03);
#endif


typedef struct _MSNdis_80211_Configuration
{
    // 
    MSNdis_80211_ConfigurationInfo Ndis80211Config;
    #define MSNdis_80211_Configuration_Ndis80211Config_SIZE sizeof(MSNdis_80211_ConfigurationInfo)
    #define MSNdis_80211_Configuration_Ndis80211Config_ID 1

} MSNdis_80211_Configuration, *PMSNdis_80211_Configuration;

#define MSNdis_80211_Configuration_SIZE (FIELD_OFFSET(MSNdis_80211_Configuration, Ndis80211Config) + MSNdis_80211_Configuration_Ndis80211Config_SIZE)

// MSNdis_80211_Statistics - MSNdis_80211_Statistics
#define MSNdis_80211_StatisticsGuid \
    { 0x42bb73b0,0x2129,0x11d4, { 0x97,0xeb,0x00,0xc0,0x4f,0x79,0xc4,0x03 } }

#if ! (defined(MIDL_PASS))
DEFINE_GUID(MSNdis_80211_Statistics_GUID, \
            0x42bb73b0,0x2129,0x11d4,0x97,0xeb,0x00,0xc0,0x4f,0x79,0xc4,0x03);
#endif


typedef struct _MSNdis_80211_Statistics
{
    // 
    ULONG StatisticsLength;
    #define MSNdis_80211_Statistics_StatisticsLength_SIZE sizeof(ULONG)
    #define MSNdis_80211_Statistics_StatisticsLength_ID 1

    // 
    ULONGLONG TransmittedFragmentCount;
    #define MSNdis_80211_Statistics_TransmittedFragmentCount_SIZE sizeof(ULONGLONG)
    #define MSNdis_80211_Statistics_TransmittedFragmentCount_ID 2

    // 
    ULONGLONG MulticastTransmittedFrameCount;
    #define MSNdis_80211_Statistics_MulticastTransmittedFrameCount_SIZE sizeof(ULONGLONG)
    #define MSNdis_80211_Statistics_MulticastTransmittedFrameCount_ID 3

    // 
    ULONGLONG FailedCount;
    #define MSNdis_80211_Statistics_FailedCount_SIZE sizeof(ULONGLONG)
    #define MSNdis_80211_Statistics_FailedCount_ID 4

    // 
    ULONGLONG RetryCount;
    #define MSNdis_80211_Statistics_RetryCount_SIZE sizeof(ULONGLONG)
    #define MSNdis_80211_Statistics_RetryCount_ID 5

    // 
    ULONGLONG MultipleRetryCount;
    #define MSNdis_80211_Statistics_MultipleRetryCount_SIZE sizeof(ULONGLONG)
    #define MSNdis_80211_Statistics_MultipleRetryCount_ID 6

    // 
    ULONGLONG RTSSuccessCount;
    #define MSNdis_80211_Statistics_RTSSuccessCount_SIZE sizeof(ULONGLONG)
    #define MSNdis_80211_Statistics_RTSSuccessCount_ID 7

    // 
    ULONGLONG RTSFailureCount;
    #define MSNdis_80211_Statistics_RTSFailureCount_SIZE sizeof(ULONGLONG)
    #define MSNdis_80211_Statistics_RTSFailureCount_ID 8

    // 
    ULONGLONG ACKFailureCount;
    #define MSNdis_80211_Statistics_ACKFailureCount_SIZE sizeof(ULONGLONG)
    #define MSNdis_80211_Statistics_ACKFailureCount_ID 9

    // 
    ULONGLONG FrameDuplicateCount;
    #define MSNdis_80211_Statistics_FrameDuplicateCount_SIZE sizeof(ULONGLONG)
    #define MSNdis_80211_Statistics_FrameDuplicateCount_ID 10

    // 
    ULONGLONG ReceivedFragmentCount;
    #define MSNdis_80211_Statistics_ReceivedFragmentCount_SIZE sizeof(ULONGLONG)
    #define MSNdis_80211_Statistics_ReceivedFragmentCount_ID 11

    // 
    ULONGLONG MulticastReceivedFrameCount;
    #define MSNdis_80211_Statistics_MulticastReceivedFrameCount_SIZE sizeof(ULONGLONG)
    #define MSNdis_80211_Statistics_MulticastReceivedFrameCount_ID 12

    // 
    ULONGLONG FCSErrorCount;
    #define MSNdis_80211_Statistics_FCSErrorCount_SIZE sizeof(ULONGLONG)
    #define MSNdis_80211_Statistics_FCSErrorCount_ID 13

} MSNdis_80211_Statistics, *PMSNdis_80211_Statistics;

#define MSNdis_80211_Statistics_SIZE (FIELD_OFFSET(MSNdis_80211_Statistics, FCSErrorCount) + MSNdis_80211_Statistics_FCSErrorCount_SIZE)

// MSNdis_80211_AddWEP - MSNdis_80211_AddWEP
#define MSNdis_80211_AddWEPGuid \
    { 0x4307bff0,0x2129,0x11d4, { 0x97,0xeb,0x00,0xc0,0x4f,0x79,0xc4,0x03 } }

#if ! (defined(MIDL_PASS))
DEFINE_GUID(MSNdis_80211_AddWEP_GUID, \
            0x4307bff0,0x2129,0x11d4,0x97,0xeb,0x00,0xc0,0x4f,0x79,0xc4,0x03);
#endif


typedef struct _MSNdis_80211_AddWEP
{
    // 
    ULONG Length;
    #define MSNdis_80211_AddWEP_Length_SIZE sizeof(ULONG)
    #define MSNdis_80211_AddWEP_Length_ID 1

    // 
    ULONG KeyIndex;
    #define MSNdis_80211_AddWEP_KeyIndex_SIZE sizeof(ULONG)
    #define MSNdis_80211_AddWEP_KeyIndex_ID 2

    // 
    ULONG KeyLength;
    #define MSNdis_80211_AddWEP_KeyLength_SIZE sizeof(ULONG)
    #define MSNdis_80211_AddWEP_KeyLength_ID 3

    // 
    UCHAR KeyMaterial[1];
    #define MSNdis_80211_AddWEP_KeyMaterial_ID 4

} MSNdis_80211_AddWEP, *PMSNdis_80211_AddWEP;

// MSNdis_80211_RemoveWEP - MSNdis_80211_RemoveWEP
#define MSNdis_80211_RemoveWEPGuid \
    { 0x433c345c,0x2129,0x11d4, { 0x97,0xeb,0x00,0xc0,0x4f,0x79,0xc4,0x03 } }

#if ! (defined(MIDL_PASS))
DEFINE_GUID(MSNdis_80211_RemoveWEP_GUID, \
            0x433c345c,0x2129,0x11d4,0x97,0xeb,0x00,0xc0,0x4f,0x79,0xc4,0x03);
#endif


typedef struct _MSNdis_80211_RemoveWEP
{
    // 
    ULONG Ndis80211KeyIndex;
    #define MSNdis_80211_RemoveWEP_Ndis80211KeyIndex_SIZE sizeof(ULONG)
    #define MSNdis_80211_RemoveWEP_Ndis80211KeyIndex_ID 1

} MSNdis_80211_RemoveWEP, *PMSNdis_80211_RemoveWEP;

#define MSNdis_80211_RemoveWEP_SIZE (FIELD_OFFSET(MSNdis_80211_RemoveWEP, Ndis80211KeyIndex) + MSNdis_80211_RemoveWEP_Ndis80211KeyIndex_SIZE)

// MSNdis_80211_Disassociate - MSNdis_80211_Disassociate
#define MSNdis_80211_DisassociateGuid \
    { 0x43671f40,0x2129,0x11d4, { 0x97,0xeb,0x00,0xc0,0x4f,0x79,0xc4,0x03 } }

#if ! (defined(MIDL_PASS))
DEFINE_GUID(MSNdis_80211_Disassociate_GUID, \
            0x43671f40,0x2129,0x11d4,0x97,0xeb,0x00,0xc0,0x4f,0x79,0xc4,0x03);
#endif


typedef struct _MSNdis_80211_Disassociate
{
    // 
    ULONG UnusedParameter;
    #define MSNdis_80211_Disassociate_UnusedParameter_SIZE sizeof(ULONG)
    #define MSNdis_80211_Disassociate_UnusedParameter_ID 1

} MSNdis_80211_Disassociate, *PMSNdis_80211_Disassociate;

#define MSNdis_80211_Disassociate_SIZE (FIELD_OFFSET(MSNdis_80211_Disassociate, UnusedParameter) + MSNdis_80211_Disassociate_UnusedParameter_SIZE)

// MSNdis_80211_BssIdListScan - MSNdis_80211_BssIdListScan
#define MSNdis_80211_BssIdListScanGuid \
    { 0x0d9e01e1,0xba70,0x11d4, { 0xb6,0x75,0x00,0x20,0x48,0x57,0x03,0x37 } }

#if ! (defined(MIDL_PASS))
DEFINE_GUID(MSNdis_80211_BssIdListScan_GUID, \
            0x0d9e01e1,0xba70,0x11d4,0xb6,0x75,0x00,0x20,0x48,0x57,0x03,0x37);
#endif


typedef struct _MSNdis_80211_BssIdListScan
{
    // 
    ULONG UnusedParameter;
    #define MSNdis_80211_BssIdListScan_UnusedParameter_SIZE sizeof(ULONG)
    #define MSNdis_80211_BssIdListScan_UnusedParameter_ID 1

} MSNdis_80211_BssIdListScan, *PMSNdis_80211_BssIdListScan;

#define MSNdis_80211_BssIdListScan_SIZE (FIELD_OFFSET(MSNdis_80211_BssIdListScan, UnusedParameter) + MSNdis_80211_BssIdListScan_UnusedParameter_SIZE)

// MSNdis_80211_AuthenticationMode - MSNdis_80211_AuthenticationMode
#define MSNdis_80211_AuthenticationModeGuid \
    { 0x43920a24,0x2129,0x11d4, { 0x97,0xeb,0x00,0xc0,0x4f,0x79,0xc4,0x03 } }

#if ! (defined(MIDL_PASS))
DEFINE_GUID(MSNdis_80211_AuthenticationMode_GUID, \
            0x43920a24,0x2129,0x11d4,0x97,0xeb,0x00,0xc0,0x4f,0x79,0xc4,0x03);
#endif


typedef struct _MSNdis_80211_AuthenticationMode
{
    // 
    ULONG Ndis80211AuthenticationMode;
    #define MSNdis_80211_AuthenticationMode_Ndis80211AuthenticationMode_SIZE sizeof(ULONG)
    #define MSNdis_80211_AuthenticationMode_Ndis80211AuthenticationMode_ID 1

} MSNdis_80211_AuthenticationMode, *PMSNdis_80211_AuthenticationMode;

#define MSNdis_80211_AuthenticationMode_SIZE (FIELD_OFFSET(MSNdis_80211_AuthenticationMode, Ndis80211AuthenticationMode) + MSNdis_80211_AuthenticationMode_Ndis80211AuthenticationMode_SIZE)

// MSNdis_80211_PrivacyFilter - MSNdis_80211_PrivacyFilter
#define MSNdis_80211_PrivacyFilterGuid \
    { 0x6733c4e9,0x4792,0x11d4, { 0x97,0xf1,0x00,0xc0,0x4f,0x79,0xc4,0x03 } }

#if ! (defined(MIDL_PASS))
DEFINE_GUID(MSNdis_80211_PrivacyFilter_GUID, \
            0x6733c4e9,0x4792,0x11d4,0x97,0xf1,0x00,0xc0,0x4f,0x79,0xc4,0x03);
#endif


typedef struct _MSNdis_80211_PrivacyFilter
{
    // 
    ULONG Ndis80211PrivacyFilter;
    #define MSNdis_80211_PrivacyFilter_Ndis80211PrivacyFilter_SIZE sizeof(ULONG)
    #define MSNdis_80211_PrivacyFilter_Ndis80211PrivacyFilter_ID 1

} MSNdis_80211_PrivacyFilter, *PMSNdis_80211_PrivacyFilter;

#define MSNdis_80211_PrivacyFilter_SIZE (FIELD_OFFSET(MSNdis_80211_PrivacyFilter, Ndis80211PrivacyFilter) + MSNdis_80211_PrivacyFilter_Ndis80211PrivacyFilter_SIZE)

// MSNdis_80211_WEPStatus - MSNdis_80211_WEPStatus
#define MSNdis_80211_WEPStatusGuid \
    { 0xb027a21f,0x3cfa,0x4125, { 0x80,0x0b,0x3f,0x7a,0x18,0xfd,0xdc,0xdc } }

#if ! (defined(MIDL_PASS))
DEFINE_GUID(MSNdis_80211_WEPStatus_GUID, \
            0xb027a21f,0x3cfa,0x4125,0x80,0x0b,0x3f,0x7a,0x18,0xfd,0xdc,0xdc);
#endif


typedef struct _MSNdis_80211_WEPStatus
{
    // 
    ULONG Ndis80211WEPStatus;
    #define MSNdis_80211_WEPStatus_Ndis80211WEPStatus_SIZE sizeof(ULONG)
    #define MSNdis_80211_WEPStatus_Ndis80211WEPStatus_ID 1

} MSNdis_80211_WEPStatus, *PMSNdis_80211_WEPStatus;

#define MSNdis_80211_WEPStatus_SIZE (FIELD_OFFSET(MSNdis_80211_WEPStatus, Ndis80211WEPStatus) + MSNdis_80211_WEPStatus_Ndis80211WEPStatus_SIZE)

// MSNdis_80211_ReloadDefaults - MSNdis_80211_ReloadDefaults
#define MSNdis_80211_ReloadDefaultsGuid \
    { 0x748b14e8,0x32ee,0x4425, { 0xb9,0x1b,0xc9,0x84,0x8c,0x58,0xb5,0x5a } }

#if ! (defined(MIDL_PASS))
DEFINE_GUID(MSNdis_80211_ReloadDefaults_GUID, \
            0x748b14e8,0x32ee,0x4425,0xb9,0x1b,0xc9,0x84,0x8c,0x58,0xb5,0x5a);
#endif


typedef struct _MSNdis_80211_ReloadDefaults
{
    // 
    ULONG Ndis80211ReloadDefaults;
    #define MSNdis_80211_ReloadDefaults_Ndis80211ReloadDefaults_SIZE sizeof(ULONG)
    #define MSNdis_80211_ReloadDefaults_Ndis80211ReloadDefaults_ID 1

} MSNdis_80211_ReloadDefaults, *PMSNdis_80211_ReloadDefaults;

#define MSNdis_80211_ReloadDefaults_SIZE (FIELD_OFFSET(MSNdis_80211_ReloadDefaults, Ndis80211ReloadDefaults) + MSNdis_80211_ReloadDefaults_Ndis80211ReloadDefaults_SIZE)

// MSNdis_StatusResetStart - MSNdis_StatusResetStart
#define MSNdis_StatusResetStartGuid \
    { 0x981f2d76,0xb1f3,0x11d0, { 0x8d,0xd7,0x00,0xc0,0x4f,0xc3,0x35,0x8c } }

#if ! (defined(MIDL_PASS))
DEFINE_GUID(MSNdis_StatusResetStart_GUID, \
            0x981f2d76,0xb1f3,0x11d0,0x8d,0xd7,0x00,0xc0,0x4f,0xc3,0x35,0x8c);
#endif


// MSNdis_StatusResetEnd - MSNdis_StatusResetEnd
#define MSNdis_StatusResetEndGuid \
    { 0x981f2d77,0xb1f3,0x11d0, { 0x8d,0xd7,0x00,0xc0,0x4f,0xc3,0x35,0x8c } }

#if ! (defined(MIDL_PASS))
DEFINE_GUID(MSNdis_StatusResetEnd_GUID, \
            0x981f2d77,0xb1f3,0x11d0,0x8d,0xd7,0x00,0xc0,0x4f,0xc3,0x35,0x8c);
#endif


// MSNdis_StatusMediaConnect - MSNdis_StatusMediaConnect
#define MSNdis_StatusMediaConnectGuid \
    { 0x981f2d7d,0xb1f3,0x11d0, { 0x8d,0xd7,0x00,0xc0,0x4f,0xc3,0x35,0x8c } }

#if ! (defined(MIDL_PASS))
DEFINE_GUID(MSNdis_StatusMediaConnect_GUID, \
            0x981f2d7d,0xb1f3,0x11d0,0x8d,0xd7,0x00,0xc0,0x4f,0xc3,0x35,0x8c);
#endif


// MSNdis_StatusMediaDisconnect - MSNdis_StatusMediaDisconnect
#define MSNdis_StatusMediaDisconnectGuid \
    { 0x981f2d7e,0xb1f3,0x11d0, { 0x8d,0xd7,0x00,0xc0,0x4f,0xc3,0x35,0x8c } }

#if ! (defined(MIDL_PASS))
DEFINE_GUID(MSNdis_StatusMediaDisconnect_GUID, \
            0x981f2d7e,0xb1f3,0x11d0,0x8d,0xd7,0x00,0xc0,0x4f,0xc3,0x35,0x8c);
#endif


// MSNdis_StatusMediaSpecificIndication - MSNdis_StatusMediaSpecificIndication
#define MSNdis_StatusMediaSpecificIndicationGuid \
    { 0x981f2d84,0xb1f3,0x11d0, { 0x8d,0xd7,0x00,0xc0,0x4f,0xc3,0x35,0x8c } }

#if ! (defined(MIDL_PASS))
DEFINE_GUID(MSNdis_StatusMediaSpecificIndication_GUID, \
            0x981f2d84,0xb1f3,0x11d0,0x8d,0xd7,0x00,0xc0,0x4f,0xc3,0x35,0x8c);
#endif


typedef struct _MSNdis_StatusMediaSpecificIndication
{
    // 
    ULONG NumberElements;
    #define MSNdis_StatusMediaSpecificIndication_NumberElements_SIZE sizeof(ULONG)
    #define MSNdis_StatusMediaSpecificIndication_NumberElements_ID 1

    // 
    UCHAR NdisStatusMediaSpecificIndication[1];
    #define MSNdis_StatusMediaSpecificIndication_NdisStatusMediaSpecificIndication_ID 2

} MSNdis_StatusMediaSpecificIndication, *PMSNdis_StatusMediaSpecificIndication;

// MSNdis_StatusLinkSpeedChange - MSNdis_StatusLinkSpeedChange
#define MSNdis_StatusLinkSpeedChangeGuid \
    { 0x981f2d85,0xb1f3,0x11d0, { 0x8d,0xd7,0x00,0xc0,0x4f,0xc3,0x35,0x8c } }

#if ! (defined(MIDL_PASS))
DEFINE_GUID(MSNdis_StatusLinkSpeedChange_GUID, \
            0x981f2d85,0xb1f3,0x11d0,0x8d,0xd7,0x00,0xc0,0x4f,0xc3,0x35,0x8c);
#endif


typedef struct _MSNdis_StatusLinkSpeedChange
{
    // 
    MSNdis_NetworkLinkSpeed NdisStatusLinkSpeedChange;
    #define MSNdis_StatusLinkSpeedChange_NdisStatusLinkSpeedChange_SIZE sizeof(MSNdis_NetworkLinkSpeed)
    #define MSNdis_StatusLinkSpeedChange_NdisStatusLinkSpeedChange_ID 1

} MSNdis_StatusLinkSpeedChange, *PMSNdis_StatusLinkSpeedChange;

#define MSNdis_StatusLinkSpeedChange_SIZE (FIELD_OFFSET(MSNdis_StatusLinkSpeedChange, NdisStatusLinkSpeedChange) + MSNdis_StatusLinkSpeedChange_NdisStatusLinkSpeedChange_SIZE)

// MSNdis_StatusProtocolBind - MSNdis_StatusProtocolBind
#define MSNdis_StatusProtocolBindGuid \
    { 0x5413531c,0xb1f3,0x11d0, { 0xd7,0x8d,0x00,0xc0,0x4f,0xc3,0x35,0x8c } }

#if ! (defined(MIDL_PASS))
DEFINE_GUID(MSNdis_StatusProtocolBind_GUID, \
            0x5413531c,0xb1f3,0x11d0,0xd7,0x8d,0x00,0xc0,0x4f,0xc3,0x35,0x8c);
#endif


typedef struct _MSNdis_StatusProtocolBind
{
    // 
    CHAR VariableData[1];
    #define MSNdis_StatusProtocolBind_Transport_ID 1

} MSNdis_StatusProtocolBind, *PMSNdis_StatusProtocolBind;

// MSNdis_StatusProtocolUnbind - MSNdis_StatusProtocolUnbind
#define MSNdis_StatusProtocolUnbindGuid \
    { 0x6e3ce1ec,0xb1f3,0x11d0, { 0xd7,0x8d,0x00,0xc0,0x4f,0xc3,0x35,0x8c } }

#if ! (defined(MIDL_PASS))
DEFINE_GUID(MSNdis_StatusProtocolUnbind_GUID, \
            0x6e3ce1ec,0xb1f3,0x11d0,0xd7,0x8d,0x00,0xc0,0x4f,0xc3,0x35,0x8c);
#endif


typedef struct _MSNdis_StatusProtocolUnbind
{
    // 
    CHAR VariableData[1];
    #define MSNdis_StatusProtocolUnbind_Transport_ID 1

} MSNdis_StatusProtocolUnbind, *PMSNdis_StatusProtocolUnbind;

// MSNdis_StatusDevicePowerOn - MSNdis_StatusDevicePowerOn
#define MSNdis_StatusDevicePowerOnGuid \
    { 0x5f81cfd0,0xf046,0x4342, { 0x61,0xaf,0x89,0x5a,0xce,0xda,0xef,0xd9 } }

#if ! (defined(MIDL_PASS))
DEFINE_GUID(MSNdis_StatusDevicePowerOn_GUID, \
            0x5f81cfd0,0xf046,0x4342,0x61,0xaf,0x89,0x5a,0xce,0xda,0xef,0xd9);
#endif


typedef struct _MSNdis_StatusDevicePowerOn
{
    // 
    CHAR VariableData[1];
    #define MSNdis_StatusDevicePowerOn_Device_ID 1

} MSNdis_StatusDevicePowerOn, *PMSNdis_StatusDevicePowerOn;

// MSNdis_StatusDevicePowerOff - MSNdis_StatusDevicePowerOff
#define MSNdis_StatusDevicePowerOffGuid \
    { 0x81bc8189,0xb026,0x46ab, { 0x64,0xb9,0xf1,0x82,0xe3,0x42,0x93,0x4e } }

#if ! (defined(MIDL_PASS))
DEFINE_GUID(MSNdis_StatusDevicePowerOff_GUID, \
            0x81bc8189,0xb026,0x46ab,0x64,0xb9,0xf1,0x82,0xe3,0x42,0x93,0x4e);
#endif


typedef struct _MSNdis_StatusDevicePowerOff
{
    // 
    CHAR VariableData[1];
    #define MSNdis_StatusDevicePowerOff_Device_ID 1

} MSNdis_StatusDevicePowerOff, *PMSNdis_StatusDevicePowerOff;

// MSNdis_StatusTaskOffloadChange - MSNdis_StatusTaskOffloadChange
#define MSNdis_StatusTaskOffloadChangeGuid \
    { 0x45049fc6,0x54d8,0x40c8, { 0x9c,0x3d,0xb0,0x11,0xc4,0xe7,0x15,0xbc } }

#if ! (defined(MIDL_PASS))
DEFINE_GUID(MSNdis_StatusTaskOffloadChange_GUID, \
            0x45049fc6,0x54d8,0x40c8,0x9c,0x3d,0xb0,0x11,0xc4,0xe7,0x15,0xbc);
#endif


typedef struct _MSNdis_StatusTaskOffloadChange
{
    // 
    ULONG NumberElements;
    #define MSNdis_StatusTaskOffloadChange_NumberElements_SIZE sizeof(ULONG)
    #define MSNdis_StatusTaskOffloadChange_NumberElements_ID 1

    // 
    UCHAR TaskOffloadCapabilities[1];
    #define MSNdis_StatusTaskOffloadChange_TaskOffloadCapabilities_ID 2

} MSNdis_StatusTaskOffloadChange, *PMSNdis_StatusTaskOffloadChange;

// MSNdis_StatusPacketFilterChange - MSNdis_StatusPacketFilterChange
#define MSNdis_StatusPacketFilterChangeGuid \
    { 0xd47c5407,0x2e75,0x46dd, { 0x81,0x46,0x1d,0x7e,0xd2,0xd6,0xab,0x1d } }

#if ! (defined(MIDL_PASS))
DEFINE_GUID(MSNdis_StatusPacketFilterChange_GUID, \
            0xd47c5407,0x2e75,0x46dd,0x81,0x46,0x1d,0x7e,0xd2,0xd6,0xab,0x1d);
#endif


typedef struct _MSNdis_StatusPacketFilterChange
{
    // 
    ULONG NumberElements;
    #define MSNdis_StatusPacketFilterChange_NumberElements_SIZE sizeof(ULONG)
    #define MSNdis_StatusPacketFilterChange_NumberElements_ID 1

    // 
    UCHAR NdisPacketFilterStatusIndication[1];
    #define MSNdis_StatusPacketFilterChange_NdisPacketFilterStatusIndication_ID 2

} MSNdis_StatusPacketFilterChange, *PMSNdis_StatusPacketFilterChange;

// MSNdis_StatusNetworkChange - MSNdis_StatusNetworkChange
#define MSNdis_StatusNetworkChangeGuid \
    { 0xca8a56f9,0xce81,0x40e6, { 0xa7,0x0f,0xa0,0x67,0xa4,0x76,0xe9,0xe9 } }

#if ! (defined(MIDL_PASS))
DEFINE_GUID(MSNdis_StatusNetworkChange_GUID, \
            0xca8a56f9,0xce81,0x40e6,0xa7,0x0f,0xa0,0x67,0xa4,0x76,0xe9,0xe9);
#endif


typedef struct _MSNdis_StatusNetworkChange
{
    // 
    ULONG NumberElements;
    #define MSNdis_StatusNetworkChange_NumberElements_SIZE sizeof(ULONG)
    #define MSNdis_StatusNetworkChange_NumberElements_ID 1

    // 
    UCHAR NdisNetworkChangeStatusIndication[1];
    #define MSNdis_StatusNetworkChange_NdisNetworkChangeStatusIndication_ID 2

} MSNdis_StatusNetworkChange, *PMSNdis_StatusNetworkChange;

// MSNdis_StatusOperationalStatus - MSNdis_StatusOperationalStatus
#define MSNdis_StatusOperationalStatusGuid \
    { 0xf917b663,0x845e,0x4d3d, { 0xb6,0xd4,0x15,0xeb,0x27,0xaf,0x81,0xc5 } }

#if ! (defined(MIDL_PASS))
DEFINE_GUID(MSNdis_StatusOperationalStatus_GUID, \
            0xf917b663,0x845e,0x4d3d,0xb6,0xd4,0x15,0xeb,0x27,0xaf,0x81,0xc5);
#endif


typedef struct _MSNdis_StatusOperationalStatus
{
    // 
    ULONG NumberElements;
    #define MSNdis_StatusOperationalStatus_NumberElements_SIZE sizeof(ULONG)
    #define MSNdis_StatusOperationalStatus_NumberElements_ID 1

    // 
    UCHAR NdisOperationalStatusStatusIndication[1];
    #define MSNdis_StatusOperationalStatus_NdisOperationalStatusStatusIndication_ID 2

} MSNdis_StatusOperationalStatus, *PMSNdis_StatusOperationalStatus;

// MSNdis_StatusLinkState - MSNdis_StatusLinkState
#define MSNdis_StatusLinkStateGuid \
    { 0x64c6f797,0x878c,0x4311, { 0x92,0x46,0x65,0xdb,0xa8,0x9c,0x3a,0x61 } }

#if ! (defined(MIDL_PASS))
DEFINE_GUID(MSNdis_StatusLinkState_GUID, \
            0x64c6f797,0x878c,0x4311,0x92,0x46,0x65,0xdb,0xa8,0x9c,0x3a,0x61);
#endif


typedef struct _MSNdis_StatusLinkState
{
    // 
    ULONG NumberElements;
    #define MSNdis_StatusLinkState_NumberElements_SIZE sizeof(ULONG)
    #define MSNdis_StatusLinkState_NumberElements_ID 1

    // 
    UCHAR NdisLinkStateStatusIndication[1];
    #define MSNdis_StatusLinkState_NdisLinkStateStatusIndication_ID 2

} MSNdis_StatusLinkState, *PMSNdis_StatusLinkState;

// MSNdis_StatusPortState - MSNdis_StatusPortState
#define MSNdis_StatusPortStateGuid \
    { 0x1dac0dfe,0x43e5,0x44b7, { 0xb7,0x59,0x7b,0xf4,0x6d,0xe3,0x2e,0x81 } }

#if ! (defined(MIDL_PASS))
DEFINE_GUID(MSNdis_StatusPortState_GUID, \
            0x1dac0dfe,0x43e5,0x44b7,0xb7,0x59,0x7b,0xf4,0x6d,0xe3,0x2e,0x81);
#endif


typedef struct _MSNdis_StatusPortState
{
    // 
    ULONG NumberElements;
    #define MSNdis_StatusPortState_NumberElements_SIZE sizeof(ULONG)
    #define MSNdis_StatusPortState_NumberElements_ID 1

    // 
    UCHAR NdisPortStateStatusIndication[1];
    #define MSNdis_StatusPortState_NdisPortStateStatusIndication_ID 2

} MSNdis_StatusPortState, *PMSNdis_StatusPortState;

// MSNdis_StatusMediaSpecificIndicationEx - MSNdis_StatusMediaSpecificIndicationEx
#define MSNdis_StatusMediaSpecificIndicationExGuid \
    { 0xaaacfca7,0x954a,0x4632, { 0xa1,0x6e,0xa8,0xa6,0x37,0x93,0xa9,0xe5 } }

#if ! (defined(MIDL_PASS))
DEFINE_GUID(MSNdis_StatusMediaSpecificIndicationEx_GUID, \
            0xaaacfca7,0x954a,0x4632,0xa1,0x6e,0xa8,0xa6,0x37,0x93,0xa9,0xe5);
#endif


typedef struct _MSNdis_StatusMediaSpecificIndicationEx
{
    // 
    ULONG NumberElements;
    #define MSNdis_StatusMediaSpecificIndicationEx_NumberElements_SIZE sizeof(ULONG)
    #define MSNdis_StatusMediaSpecificIndicationEx_NumberElements_ID 1

    // 
    UCHAR NdisStatusMediaSpecificIndication[1];
    #define MSNdis_StatusMediaSpecificIndicationEx_NdisStatusMediaSpecificIndication_ID 2

} MSNdis_StatusMediaSpecificIndicationEx, *PMSNdis_StatusMediaSpecificIndicationEx;

// MSNdis_StatusHDSplitCurrentConfig - MSNdis_StatusHDSplitCurrentConfig
#define MSNdis_StatusHDSplitCurrentConfigGuid \
    { 0x6c744b0e,0xee9c,0x4205, { 0x90,0xa2,0x01,0x5f,0x6d,0x65,0xf4,0x03 } }

#if ! (defined(MIDL_PASS))
DEFINE_GUID(MSNdis_StatusHDSplitCurrentConfig_GUID, \
            0x6c744b0e,0xee9c,0x4205,0x90,0xa2,0x01,0x5f,0x6d,0x65,0xf4,0x03);
#endif


typedef struct _MSNdis_StatusHDSplitCurrentConfig
{
    // 
    ULONG NumberElements;
    #define MSNdis_StatusHDSplitCurrentConfig_NumberElements_SIZE sizeof(ULONG)
    #define MSNdis_StatusHDSplitCurrentConfig_NumberElements_ID 1

    // 
    UCHAR HDSplitCurrentConfig[1];
    #define MSNdis_StatusHDSplitCurrentConfig_HDSplitCurrentConfig_ID 2

} MSNdis_StatusHDSplitCurrentConfig, *PMSNdis_StatusHDSplitCurrentConfig;

// MSNdis_StatusDot11ScanConfirm - MSNdis_StatusDot11ScanConfirm
#define MSNdis_StatusDot11ScanConfirmGuid \
    { 0x8500591e,0xa0c7,0x4efb, { 0x93,0x42,0xb6,0x74,0xb0,0x02,0xcb,0xe6 } }

#if ! (defined(MIDL_PASS))
DEFINE_GUID(MSNdis_StatusDot11ScanConfirm_GUID, \
            0x8500591e,0xa0c7,0x4efb,0x93,0x42,0xb6,0x74,0xb0,0x02,0xcb,0xe6);
#endif


typedef struct _MSNdis_StatusDot11ScanConfirm
{
    // 
    ULONG NumberElements;
    #define MSNdis_StatusDot11ScanConfirm_NumberElements_SIZE sizeof(ULONG)
    #define MSNdis_StatusDot11ScanConfirm_NumberElements_ID 1

    // 
    UCHAR NdisStatusDot11ScanConfirmIndication[1];
    #define MSNdis_StatusDot11ScanConfirm_NdisStatusDot11ScanConfirmIndication_ID 2

} MSNdis_StatusDot11ScanConfirm, *PMSNdis_StatusDot11ScanConfirm;

// MSNdis_StatusDot11MPDUMaxLengthChange - MSNdis_StatusDot11MPDUMaxLengthChange
#define MSNdis_StatusDot11MPDUMaxLengthChangeGuid \
    { 0x1d6560ec,0x8e48,0x4a3e, { 0x9f,0xd5,0xa0,0x1b,0x69,0x8d,0xb6,0xc5 } }

#if ! (defined(MIDL_PASS))
DEFINE_GUID(MSNdis_StatusDot11MPDUMaxLengthChange_GUID, \
            0x1d6560ec,0x8e48,0x4a3e,0x9f,0xd5,0xa0,0x1b,0x69,0x8d,0xb6,0xc5);
#endif


typedef struct _MSNdis_StatusDot11MPDUMaxLengthChange
{
    // 
    ULONG NumberElements;
    #define MSNdis_StatusDot11MPDUMaxLengthChange_NumberElements_SIZE sizeof(ULONG)
    #define MSNdis_StatusDot11MPDUMaxLengthChange_NumberElements_ID 1

    // 
    UCHAR NdisStatusDot11MPDUMaxLengthChangeIndication[1];
    #define MSNdis_StatusDot11MPDUMaxLengthChange_NdisStatusDot11MPDUMaxLengthChangeIndication_ID 2

} MSNdis_StatusDot11MPDUMaxLengthChange, *PMSNdis_StatusDot11MPDUMaxLengthChange;

// MSNdis_StatusDot11AssociationStart - MSNdis_StatusDot11AssociationStart
#define MSNdis_StatusDot11AssociationStartGuid \
    { 0x3927843b,0x6980,0x4b48, { 0xb1,0x5b,0x4d,0xe5,0x09,0x77,0xac,0x40 } }

#if ! (defined(MIDL_PASS))
DEFINE_GUID(MSNdis_StatusDot11AssociationStart_GUID, \
            0x3927843b,0x6980,0x4b48,0xb1,0x5b,0x4d,0xe5,0x09,0x77,0xac,0x40);
#endif


typedef struct _MSNdis_StatusDot11AssociationStart
{
    // 
    ULONG NumberElements;
    #define MSNdis_StatusDot11AssociationStart_NumberElements_SIZE sizeof(ULONG)
    #define MSNdis_StatusDot11AssociationStart_NumberElements_ID 1

    // 
    UCHAR NdisStatusDot11AssociationStartIndication[1];
    #define MSNdis_StatusDot11AssociationStart_NdisStatusDot11AssociationStartIndication_ID 2

} MSNdis_StatusDot11AssociationStart, *PMSNdis_StatusDot11AssociationStart;

// MSNdis_StatusDot11AssociationCompletion - MSNdis_StatusDot11AssociationCompletion
#define MSNdis_StatusDot11AssociationCompletionGuid \
    { 0x458bbea7,0x45a4,0x4ae2, { 0xb1,0x76,0xe5,0x1f,0x96,0xfc,0x05,0x68 } }

#if ! (defined(MIDL_PASS))
DEFINE_GUID(MSNdis_StatusDot11AssociationCompletion_GUID, \
            0x458bbea7,0x45a4,0x4ae2,0xb1,0x76,0xe5,0x1f,0x96,0xfc,0x05,0x68);
#endif


typedef struct _MSNdis_StatusDot11AssociationCompletion
{
    // 
    ULONG NumberElements;
    #define MSNdis_StatusDot11AssociationCompletion_NumberElements_SIZE sizeof(ULONG)
    #define MSNdis_StatusDot11AssociationCompletion_NumberElements_ID 1

    // 
    UCHAR NdisStatusDot11AssociationCompletionIndication[1];
    #define MSNdis_StatusDot11AssociationCompletion_NdisStatusDot11AssociationCompletionIndication_ID 2

} MSNdis_StatusDot11AssociationCompletion, *PMSNdis_StatusDot11AssociationCompletion;

// MSNdis_StatusDot11ConnectionStart - MSNdis_StatusDot11ConnectionStart
#define MSNdis_StatusDot11ConnectionStartGuid \
    { 0x7b74299d,0x998f,0x4454, { 0xad,0x08,0xc5,0xaf,0x28,0x57,0x6d,0x1b } }

#if ! (defined(MIDL_PASS))
DEFINE_GUID(MSNdis_StatusDot11ConnectionStart_GUID, \
            0x7b74299d,0x998f,0x4454,0xad,0x08,0xc5,0xaf,0x28,0x57,0x6d,0x1b);
#endif


typedef struct _MSNdis_StatusDot11ConnectionStart
{
    // 
    ULONG NumberElements;
    #define MSNdis_StatusDot11ConnectionStart_NumberElements_SIZE sizeof(ULONG)
    #define MSNdis_StatusDot11ConnectionStart_NumberElements_ID 1

    // 
    UCHAR NdisStatusDot11ConnectionStartIndication[1];
    #define MSNdis_StatusDot11ConnectionStart_NdisStatusDot11ConnectionStartIndication_ID 2

} MSNdis_StatusDot11ConnectionStart, *PMSNdis_StatusDot11ConnectionStart;

// MSNdis_StatusDot11ConnectionCompletion - MSNdis_StatusDot11ConnectionCompletion
#define MSNdis_StatusDot11ConnectionCompletionGuid \
    { 0x96efd9c9,0x7f1b,0x4a89, { 0xbc,0x04,0x3e,0x9e,0x27,0x17,0x65,0xf1 } }

#if ! (defined(MIDL_PASS))
DEFINE_GUID(MSNdis_StatusDot11ConnectionCompletion_GUID, \
            0x96efd9c9,0x7f1b,0x4a89,0xbc,0x04,0x3e,0x9e,0x27,0x17,0x65,0xf1);
#endif


typedef struct _MSNdis_StatusDot11ConnectionCompletion
{
    // 
    ULONG NumberElements;
    #define MSNdis_StatusDot11ConnectionCompletion_NumberElements_SIZE sizeof(ULONG)
    #define MSNdis_StatusDot11ConnectionCompletion_NumberElements_ID 1

    // 
    UCHAR NdisStatusDot11ConnectionCompletionIndication[1];
    #define MSNdis_StatusDot11ConnectionCompletion_NdisStatusDot11ConnectionCompletionIndication_ID 2

} MSNdis_StatusDot11ConnectionCompletion, *PMSNdis_StatusDot11ConnectionCompletion;

// MSNdis_StatusDot11RoamingStart - MSNdis_StatusDot11RoamingStart
#define MSNdis_StatusDot11RoamingStartGuid \
    { 0xb2412d0d,0x26c8,0x4f4e, { 0x93,0xdf,0xf7,0xb7,0x05,0xa0,0xb4,0x33 } }

#if ! (defined(MIDL_PASS))
DEFINE_GUID(MSNdis_StatusDot11RoamingStart_GUID, \
            0xb2412d0d,0x26c8,0x4f4e,0x93,0xdf,0xf7,0xb7,0x05,0xa0,0xb4,0x33);
#endif


typedef struct _MSNdis_StatusDot11RoamingStart
{
    // 
    ULONG NumberElements;
    #define MSNdis_StatusDot11RoamingStart_NumberElements_SIZE sizeof(ULONG)
    #define MSNdis_StatusDot11RoamingStart_NumberElements_ID 1

    // 
    UCHAR NdisStatusDot11RoamingStartIndication[1];
    #define MSNdis_StatusDot11RoamingStart_NdisStatusDot11RoamingStartIndication_ID 2

} MSNdis_StatusDot11RoamingStart, *PMSNdis_StatusDot11RoamingStart;

// MSNdis_StatusDot11RoamingCompletion - MSNdis_StatusDot11RoamingCompletion
#define MSNdis_StatusDot11RoamingCompletionGuid \
    { 0xdd9d47d1,0x282b,0x41e4, { 0xb9,0x24,0x66,0x36,0x88,0x17,0xfc,0xd3 } }

#if ! (defined(MIDL_PASS))
DEFINE_GUID(MSNdis_StatusDot11RoamingCompletion_GUID, \
            0xdd9d47d1,0x282b,0x41e4,0xb9,0x24,0x66,0x36,0x88,0x17,0xfc,0xd3);
#endif


typedef struct _MSNdis_StatusDot11RoamingCompletion
{
    // 
    ULONG NumberElements;
    #define MSNdis_StatusDot11RoamingCompletion_NumberElements_SIZE sizeof(ULONG)
    #define MSNdis_StatusDot11RoamingCompletion_NumberElements_ID 1

    // 
    UCHAR NdisStatusDot11RoamingCompletionIndication[1];
    #define MSNdis_StatusDot11RoamingCompletion_NdisStatusDot11RoamingCompletionIndication_ID 2

} MSNdis_StatusDot11RoamingCompletion, *PMSNdis_StatusDot11RoamingCompletion;

// MSNdis_StatusDot11Disassociation - MSNdis_StatusDot11Disassociation
#define MSNdis_StatusDot11DisassociationGuid \
    { 0x3fbeb6fc,0x0fe2,0x43fd, { 0xb2,0xad,0xbd,0x99,0xb5,0xf9,0x3e,0x13 } }

#if ! (defined(MIDL_PASS))
DEFINE_GUID(MSNdis_StatusDot11Disassociation_GUID, \
            0x3fbeb6fc,0x0fe2,0x43fd,0xb2,0xad,0xbd,0x99,0xb5,0xf9,0x3e,0x13);
#endif


typedef struct _MSNdis_StatusDot11Disassociation
{
    // 
    ULONG NumberElements;
    #define MSNdis_StatusDot11Disassociation_NumberElements_SIZE sizeof(ULONG)
    #define MSNdis_StatusDot11Disassociation_NumberElements_ID 1

    // 
    UCHAR NdisStatusDot11DisassociationIndication[1];
    #define MSNdis_StatusDot11Disassociation_NdisStatusDot11DisassociationIndication_ID 2

} MSNdis_StatusDot11Disassociation, *PMSNdis_StatusDot11Disassociation;

// MSNdis_StatusDot11TkipmicFailure - MSNdis_StatusDot11TkipmicFailure
#define MSNdis_StatusDot11TkipmicFailureGuid \
    { 0x442c2ae4,0x9bc5,0x4b90, { 0xa8,0x89,0x45,0x5e,0xf2,0x20,0xf4,0xee } }

#if ! (defined(MIDL_PASS))
DEFINE_GUID(MSNdis_StatusDot11TkipmicFailure_GUID, \
            0x442c2ae4,0x9bc5,0x4b90,0xa8,0x89,0x45,0x5e,0xf2,0x20,0xf4,0xee);
#endif


typedef struct _MSNdis_StatusDot11TkipmicFailure
{
    // 
    ULONG NumberElements;
    #define MSNdis_StatusDot11TkipmicFailure_NumberElements_SIZE sizeof(ULONG)
    #define MSNdis_StatusDot11TkipmicFailure_NumberElements_ID 1

    // 
    UCHAR NdisStatusDot11TkipmicFailureIndication[1];
    #define MSNdis_StatusDot11TkipmicFailure_NdisStatusDot11TkipmicFailureIndication_ID 2

} MSNdis_StatusDot11TkipmicFailure, *PMSNdis_StatusDot11TkipmicFailure;

// MSNdis_StatusDot11PmkidCandidateList - MSNdis_StatusDot11PmkidCandidateList
#define MSNdis_StatusDot11PmkidCandidateListGuid \
    { 0x26d8b8f6,0xdb82,0x49eb, { 0x8b,0xf3,0x4c,0x13,0x0e,0xf0,0x69,0x50 } }

#if ! (defined(MIDL_PASS))
DEFINE_GUID(MSNdis_StatusDot11PmkidCandidateList_GUID, \
            0x26d8b8f6,0xdb82,0x49eb,0x8b,0xf3,0x4c,0x13,0x0e,0xf0,0x69,0x50);
#endif


typedef struct _MSNdis_StatusDot11PmkidCandidateList
{
    // 
    ULONG NumberElements;
    #define MSNdis_StatusDot11PmkidCandidateList_NumberElements_SIZE sizeof(ULONG)
    #define MSNdis_StatusDot11PmkidCandidateList_NumberElements_ID 1

    // 
    UCHAR NdisStatusDot11PmkidCandidateListIndication[1];
    #define MSNdis_StatusDot11PmkidCandidateList_NdisStatusDot11PmkidCandidateListIndication_ID 2

} MSNdis_StatusDot11PmkidCandidateList, *PMSNdis_StatusDot11PmkidCandidateList;

// MSNdis_StatusDot11PhyStateChange - MSNdis_StatusDot11PhyStateChange
#define MSNdis_StatusDot11PhyStateChangeGuid \
    { 0xdeb45316,0x71b5,0x4736, { 0xbd,0xef,0x0a,0x9e,0x9f,0x4e,0x62,0xdc } }

#if ! (defined(MIDL_PASS))
DEFINE_GUID(MSNdis_StatusDot11PhyStateChange_GUID, \
            0xdeb45316,0x71b5,0x4736,0xbd,0xef,0x0a,0x9e,0x9f,0x4e,0x62,0xdc);
#endif


typedef struct _MSNdis_StatusDot11PhyStateChange
{
    // 
    ULONG NumberElements;
    #define MSNdis_StatusDot11PhyStateChange_NumberElements_SIZE sizeof(ULONG)
    #define MSNdis_StatusDot11PhyStateChange_NumberElements_ID 1

    // 
    UCHAR NdisStatusDot11PhyStateChangeIndication[1];
    #define MSNdis_StatusDot11PhyStateChange_NdisStatusDot11PhyStateChangeIndication_ID 2

} MSNdis_StatusDot11PhyStateChange, *PMSNdis_StatusDot11PhyStateChange;

// MSNdis_StatusDot11LinkQuality - MSNdis_StatusDot11LinkQuality
#define MSNdis_StatusDot11LinkQualityGuid \
    { 0xa3285184,0xea99,0x48ed, { 0x82,0x5e,0xa4,0x26,0xb1,0x1c,0x27,0x54 } }

#if ! (defined(MIDL_PASS))
DEFINE_GUID(MSNdis_StatusDot11LinkQuality_GUID, \
            0xa3285184,0xea99,0x48ed,0x82,0x5e,0xa4,0x26,0xb1,0x1c,0x27,0x54);
#endif


typedef struct _MSNdis_StatusDot11LinkQuality
{
    // 
    ULONG NumberElements;
    #define MSNdis_StatusDot11LinkQuality_NumberElements_SIZE sizeof(ULONG)
    #define MSNdis_StatusDot11LinkQuality_NumberElements_ID 1

    // 
    UCHAR NdisStatusDot11LinkQualityIndication[1];
    #define MSNdis_StatusDot11LinkQuality_NdisStatusDot11LinkQualityIndication_ID 2

} MSNdis_StatusDot11LinkQuality, *PMSNdis_StatusDot11LinkQuality;

// MSKeyboard_PortInformation - KEYBOARD_PORT_WMI_STD_DATA
#define KEYBOARD_PORT_WMI_STD_DATA_GUID \
    { 0x4731f89a,0x71cb,0x11d1, { 0xa5,0x2c,0x00,0xa0,0xc9,0x06,0x29,0x10 } }

#if ! (defined(MIDL_PASS))
DEFINE_GUID(MSKeyboard_PortInformation_GUID, \
            0x4731f89a,0x71cb,0x11d1,0xa5,0x2c,0x00,0xa0,0xc9,0x06,0x29,0x10);
#endif


typedef struct _KEYBOARD_PORT_WMI_STD_DATA
{

#define KEYBOARD_PORT_WMI_STD_I8042 0
#define KEYBOARD_PORT_WMI_STD_SERIAL 1
#define KEYBOARD_PORT_WMI_STD_USB 2

    // 
    ULONG ConnectorType;
    #define KEYBOARD_PORT_WMI_STD_DATA_ConnectorType_SIZE sizeof(ULONG)
    #define KEYBOARD_PORT_WMI_STD_DATA_ConnectorType_ID 1

    // 
    ULONG DataQueueSize;
    #define KEYBOARD_PORT_WMI_STD_DATA_DataQueueSize_SIZE sizeof(ULONG)
    #define KEYBOARD_PORT_WMI_STD_DATA_DataQueueSize_ID 2

    // 
    ULONG ErrorCount;
    #define KEYBOARD_PORT_WMI_STD_DATA_ErrorCount_SIZE sizeof(ULONG)
    #define KEYBOARD_PORT_WMI_STD_DATA_ErrorCount_ID 3

    // 
    ULONG FunctionKeys;
    #define KEYBOARD_PORT_WMI_STD_DATA_FunctionKeys_SIZE sizeof(ULONG)
    #define KEYBOARD_PORT_WMI_STD_DATA_FunctionKeys_ID 4

    // 
    ULONG Indicators;
    #define KEYBOARD_PORT_WMI_STD_DATA_Indicators_SIZE sizeof(ULONG)
    #define KEYBOARD_PORT_WMI_STD_DATA_Indicators_ID 5

} KEYBOARD_PORT_WMI_STD_DATA, *PKEYBOARD_PORT_WMI_STD_DATA;

#define KEYBOARD_PORT_WMI_STD_DATA_SIZE (FIELD_OFFSET(KEYBOARD_PORT_WMI_STD_DATA, Indicators) + KEYBOARD_PORT_WMI_STD_DATA_Indicators_SIZE)

// MSKeyboard_ExtendedID - KEYBOARD_ID_EX
#define KEYBOARD_PORT_WMI_EXTENDED_ID \
    { 0x6ac4e23d,0xa950,0x4518, { 0x8b,0x2b,0xaa,0x4d,0xcd,0x5f,0xe1,0x4a } }

#if ! (defined(MIDL_PASS))
DEFINE_GUID(MSKeyboard_ExtendedID_GUID, \
            0x6ac4e23d,0xa950,0x4518,0x8b,0x2b,0xaa,0x4d,0xcd,0x5f,0xe1,0x4a);
#endif


typedef struct _KEYBOARD_ID_EX
{
    // 
    ULONG Type;
    #define KEYBOARD_ID_EX_Type_SIZE sizeof(ULONG)
    #define KEYBOARD_ID_EX_Type_ID 1

    // 
    ULONG Subtype;
    #define KEYBOARD_ID_EX_Subtype_SIZE sizeof(ULONG)
    #define KEYBOARD_ID_EX_Subtype_ID 2

} KEYBOARD_ID_EX, *PKEYBOARD_ID_EX;

#define KEYBOARD_ID_EX_SIZE (FIELD_OFFSET(KEYBOARD_ID_EX, Subtype) + KEYBOARD_ID_EX_Subtype_SIZE)

// MSMouse_PortInformation - POINTER_PORT_WMI_STD_DATA
#define POINTER_PORT_WMI_STD_DATA_GUID \
    { 0x4731f89c,0x71cb,0x11d1, { 0xa5,0x2c,0x00,0xa0,0xc9,0x06,0x29,0x10 } }

#if ! (defined(MIDL_PASS))
DEFINE_GUID(MSMouse_PortInformation_GUID, \
            0x4731f89c,0x71cb,0x11d1,0xa5,0x2c,0x00,0xa0,0xc9,0x06,0x29,0x10);
#endif


typedef struct _POINTER_PORT_WMI_STD_DATA
{

#define POINTER_PORT_WMI_STD_I8042 0
#define POINTER_PORT_WMI_STD_SERIAL 1
#define POINTER_PORT_WMI_STD_USB 2

    // 
    ULONG ConnectorType;
    #define POINTER_PORT_WMI_STD_DATA_ConnectorType_SIZE sizeof(ULONG)
    #define POINTER_PORT_WMI_STD_DATA_ConnectorType_ID 1

    // 
    ULONG DataQueueSize;
    #define POINTER_PORT_WMI_STD_DATA_DataQueueSize_SIZE sizeof(ULONG)
    #define POINTER_PORT_WMI_STD_DATA_DataQueueSize_ID 2

    // 
    ULONG ErrorCount;
    #define POINTER_PORT_WMI_STD_DATA_ErrorCount_SIZE sizeof(ULONG)
    #define POINTER_PORT_WMI_STD_DATA_ErrorCount_ID 3

    // 
    ULONG Buttons;
    #define POINTER_PORT_WMI_STD_DATA_Buttons_SIZE sizeof(ULONG)
    #define POINTER_PORT_WMI_STD_DATA_Buttons_ID 4


#define POINTER_PORT_WMI_STD_MOUSE 0
#define POINTER_PORT_WMI_STD_POINTER 1
#define POINTER_PORT_WMI_ABSOLUTE_POINTER 2
#define POINTER_PORT_WMI_TABLET 3
#define POINTER_PORT_WMI_TOUCH_SCRENE 4
#define POINTER_PORT_WMI_PEN 5
#define POINTER_PORT_WMI_TRACK_BALL 6
#define POINTER_PORT_WMI_OTHER 256

    // 
    ULONG HardwareType;
    #define POINTER_PORT_WMI_STD_DATA_HardwareType_SIZE sizeof(ULONG)
    #define POINTER_PORT_WMI_STD_DATA_HardwareType_ID 5

} POINTER_PORT_WMI_STD_DATA, *PPOINTER_PORT_WMI_STD_DATA;

#define POINTER_PORT_WMI_STD_DATA_SIZE (FIELD_OFFSET(POINTER_PORT_WMI_STD_DATA, HardwareType) + POINTER_PORT_WMI_STD_DATA_HardwareType_SIZE)

// MSMouse_ClassInformation - MSMouse_ClassInformation
#define MSMouse_ClassInformationGuid \
    { 0x4731f89b,0x71cb,0x11d1, { 0xa5,0x2c,0x00,0xa0,0xc9,0x06,0x29,0x10 } }

#if ! (defined(MIDL_PASS))
DEFINE_GUID(MSMouse_ClassInformation_GUID, \
            0x4731f89b,0x71cb,0x11d1,0xa5,0x2c,0x00,0xa0,0xc9,0x06,0x29,0x10);
#endif


typedef struct _MSMouse_ClassInformation
{
    // 
    ULONGLONG DeviceId;
    #define MSMouse_ClassInformation_DeviceId_SIZE sizeof(ULONGLONG)
    #define MSMouse_ClassInformation_DeviceId_ID 1

} MSMouse_ClassInformation, *PMSMouse_ClassInformation;

#define MSMouse_ClassInformation_SIZE (FIELD_OFFSET(MSMouse_ClassInformation, DeviceId) + MSMouse_ClassInformation_DeviceId_SIZE)

// MSKeyboard_ClassInformation - MSKeyboard_ClassInformation
#define MSKeyboard_ClassInformationGuid \
    { 0x4731f899,0x71cb,0x11d1, { 0xa5,0x2c,0x00,0xa0,0xc9,0x06,0x29,0x10 } }

#if ! (defined(MIDL_PASS))
DEFINE_GUID(MSKeyboard_ClassInformation_GUID, \
            0x4731f899,0x71cb,0x11d1,0xa5,0x2c,0x00,0xa0,0xc9,0x06,0x29,0x10);
#endif


typedef struct _MSKeyboard_ClassInformation
{
    // 
    ULONGLONG DeviceId;
    #define MSKeyboard_ClassInformation_DeviceId_SIZE sizeof(ULONGLONG)
    #define MSKeyboard_ClassInformation_DeviceId_ID 1

} MSKeyboard_ClassInformation, *PMSKeyboard_ClassInformation;

#define MSKeyboard_ClassInformation_SIZE (FIELD_OFFSET(MSKeyboard_ClassInformation, DeviceId) + MSKeyboard_ClassInformation_DeviceId_SIZE)

// MSAgp_Information - AGP_STD_DATA
#define AGP_WMI_STD_DATA_GUID \
    { 0x8c27fbed,0x1c7b,0x47e4, { 0xa6,0x49,0x0e,0x38,0x9d,0x3a,0xda,0x4f } }

#if ! (defined(MIDL_PASS))
DEFINE_GUID(MSAgp_Information_GUID, \
            0x8c27fbed,0x1c7b,0x47e4,0xa6,0x49,0x0e,0x38,0x9d,0x3a,0xda,0x4f);
#endif


typedef struct _AGP_STD_DATA
{
    // 
    ULONGLONG ApertureBase;
    #define AGP_STD_DATA_ApertureBase_SIZE sizeof(ULONGLONG)
    #define AGP_STD_DATA_ApertureBase_ID 1

    // 
    ULONG ApertureLength;
    #define AGP_STD_DATA_ApertureLength_SIZE sizeof(ULONG)
    #define AGP_STD_DATA_ApertureLength_ID 2

    // 
    ULONG AgpStatus;
    #define AGP_STD_DATA_AgpStatus_SIZE sizeof(ULONG)
    #define AGP_STD_DATA_AgpStatus_ID 3

    // 
    ULONG AgpCommand;
    #define AGP_STD_DATA_AgpCommand_SIZE sizeof(ULONG)
    #define AGP_STD_DATA_AgpCommand_ID 4

} AGP_STD_DATA, *PAGP_STD_DATA;

#define AGP_STD_DATA_SIZE (FIELD_OFFSET(AGP_STD_DATA, AgpCommand) + AGP_STD_DATA_AgpCommand_SIZE)

// MSAcpi_ThermalZoneTemperature - MSAcpi_ThermalZoneTemperature
#define MSAcpi_ThermalZoneTemperatureGuid \
    { 0xa1bc18c0,0xa7c8,0x11d1, { 0xbf,0x3c,0x00,0xa0,0xc9,0x06,0x29,0x10 } }

#if ! (defined(MIDL_PASS))
DEFINE_GUID(MSAcpi_ThermalZoneTemperature_GUID, \
            0xa1bc18c0,0xa7c8,0x11d1,0xbf,0x3c,0x00,0xa0,0xc9,0x06,0x29,0x10);
#endif


typedef struct _MSAcpi_ThermalZoneTemperature
{
    // 
    ULONG ThermalStamp;
    #define MSAcpi_ThermalZoneTemperature_ThermalStamp_SIZE sizeof(ULONG)
    #define MSAcpi_ThermalZoneTemperature_ThermalStamp_ID 1

    // 
    ULONG ThermalConstant1;
    #define MSAcpi_ThermalZoneTemperature_ThermalConstant1_SIZE sizeof(ULONG)
    #define MSAcpi_ThermalZoneTemperature_ThermalConstant1_ID 2

    // 
    ULONG ThermalConstant2;
    #define MSAcpi_ThermalZoneTemperature_ThermalConstant2_SIZE sizeof(ULONG)
    #define MSAcpi_ThermalZoneTemperature_ThermalConstant2_ID 3

    // 
    ULONG Reserved;
    #define MSAcpi_ThermalZoneTemperature_Reserved_SIZE sizeof(ULONG)
    #define MSAcpi_ThermalZoneTemperature_Reserved_ID 4

    // 
    ULONG SamplingPeriod;
    #define MSAcpi_ThermalZoneTemperature_SamplingPeriod_SIZE sizeof(ULONG)
    #define MSAcpi_ThermalZoneTemperature_SamplingPeriod_ID 5

    // 
    ULONG CurrentTemperature;
    #define MSAcpi_ThermalZoneTemperature_CurrentTemperature_SIZE sizeof(ULONG)
    #define MSAcpi_ThermalZoneTemperature_CurrentTemperature_ID 6

    // 
    ULONG PassiveTripPoint;
    #define MSAcpi_ThermalZoneTemperature_PassiveTripPoint_SIZE sizeof(ULONG)
    #define MSAcpi_ThermalZoneTemperature_PassiveTripPoint_ID 7

    // 
    ULONG CriticalTripPoint;
    #define MSAcpi_ThermalZoneTemperature_CriticalTripPoint_SIZE sizeof(ULONG)
    #define MSAcpi_ThermalZoneTemperature_CriticalTripPoint_ID 8

    // 
    ULONG ActiveTripPointCount;
    #define MSAcpi_ThermalZoneTemperature_ActiveTripPointCount_SIZE sizeof(ULONG)
    #define MSAcpi_ThermalZoneTemperature_ActiveTripPointCount_ID 9

    // 
    ULONG ActiveTripPoint[10];
    #define MSAcpi_ThermalZoneTemperature_ActiveTripPoint_SIZE sizeof(ULONG[10])
    #define MSAcpi_ThermalZoneTemperature_ActiveTripPoint_ID 10

} MSAcpi_ThermalZoneTemperature, *PMSAcpi_ThermalZoneTemperature;

#define MSAcpi_ThermalZoneTemperature_SIZE (FIELD_OFFSET(MSAcpi_ThermalZoneTemperature, ActiveTripPoint) + MSAcpi_ThermalZoneTemperature_ActiveTripPoint_SIZE)

// MSDiskDriver_Geometry - WMI_DISK_GEOMETRY
#define MSDiskDriver_GeometryGuid \
    { 0x25007f51,0x57c2,0x11d1, { 0xa5,0x28,0x00,0xa0,0xc9,0x06,0x29,0x10 } }

#if ! (defined(MIDL_PASS))
DEFINE_GUID(MSDiskDriver_Geometry_GUID, \
            0x25007f51,0x57c2,0x11d1,0xa5,0x28,0x00,0xa0,0xc9,0x06,0x29,0x10);
#endif


typedef struct _WMI_DISK_GEOMETRY
{
    // 
    LONGLONG Cylinders;
    #define WMI_DISK_GEOMETRY_Cylinders_SIZE sizeof(LONGLONG)
    #define WMI_DISK_GEOMETRY_Cylinders_ID 1

    // 
    ULONG MediaType;
    #define WMI_DISK_GEOMETRY_MediaType_SIZE sizeof(ULONG)
    #define WMI_DISK_GEOMETRY_MediaType_ID 2

    // 
    ULONG TracksPerCylinder;
    #define WMI_DISK_GEOMETRY_TracksPerCylinder_SIZE sizeof(ULONG)
    #define WMI_DISK_GEOMETRY_TracksPerCylinder_ID 3

    // 
    ULONG SectorsPerTrack;
    #define WMI_DISK_GEOMETRY_SectorsPerTrack_SIZE sizeof(ULONG)
    #define WMI_DISK_GEOMETRY_SectorsPerTrack_ID 4

    // 
    ULONG BytesPerSector;
    #define WMI_DISK_GEOMETRY_BytesPerSector_SIZE sizeof(ULONG)
    #define WMI_DISK_GEOMETRY_BytesPerSector_ID 5

} WMI_DISK_GEOMETRY, *PWMI_DISK_GEOMETRY;

#define WMI_DISK_GEOMETRY_SIZE (FIELD_OFFSET(WMI_DISK_GEOMETRY, BytesPerSector) + WMI_DISK_GEOMETRY_BytesPerSector_SIZE)

// MSDiskDriver_PerformanceData - WMI_DISK_PERFORMANCE
#define MSDiskDriver_PerformanceDataGuid \
    { 0xbdd865d2,0xd7c1,0x11d0, { 0xa5,0x01,0x00,0xa0,0xc9,0x06,0x29,0x10 } }

#if ! (defined(MIDL_PASS))
DEFINE_GUID(MSDiskDriver_PerformanceData_GUID, \
            0xbdd865d2,0xd7c1,0x11d0,0xa5,0x01,0x00,0xa0,0xc9,0x06,0x29,0x10);
#endif


typedef struct _WMI_DISK_PERFORMANCE
{
    // 
    LONGLONG BytesRead;
    #define WMI_DISK_PERFORMANCE_BytesRead_SIZE sizeof(LONGLONG)
    #define WMI_DISK_PERFORMANCE_BytesRead_ID 1

    // 
    LONGLONG BytesWritten;
    #define WMI_DISK_PERFORMANCE_BytesWritten_SIZE sizeof(LONGLONG)
    #define WMI_DISK_PERFORMANCE_BytesWritten_ID 2

    // 
    LONGLONG ReadTime;
    #define WMI_DISK_PERFORMANCE_ReadTime_SIZE sizeof(LONGLONG)
    #define WMI_DISK_PERFORMANCE_ReadTime_ID 3

    // 
    LONGLONG WriteTime;
    #define WMI_DISK_PERFORMANCE_WriteTime_SIZE sizeof(LONGLONG)
    #define WMI_DISK_PERFORMANCE_WriteTime_ID 4

    // 
    LONGLONG IdleTime;
    #define WMI_DISK_PERFORMANCE_IdleTime_SIZE sizeof(LONGLONG)
    #define WMI_DISK_PERFORMANCE_IdleTime_ID 5

    // 
    ULONG ReadCount;
    #define WMI_DISK_PERFORMANCE_ReadCount_SIZE sizeof(ULONG)
    #define WMI_DISK_PERFORMANCE_ReadCount_ID 6

    // 
    ULONG WriteCount;
    #define WMI_DISK_PERFORMANCE_WriteCount_SIZE sizeof(ULONG)
    #define WMI_DISK_PERFORMANCE_WriteCount_ID 7

    // 
    ULONG QueueDepth;
    #define WMI_DISK_PERFORMANCE_QueueDepth_SIZE sizeof(ULONG)
    #define WMI_DISK_PERFORMANCE_QueueDepth_ID 8

    // 
    ULONG SplitCount;
    #define WMI_DISK_PERFORMANCE_SplitCount_SIZE sizeof(ULONG)
    #define WMI_DISK_PERFORMANCE_SplitCount_ID 9

    // 
    LONGLONG QueryTime;
    #define WMI_DISK_PERFORMANCE_QueryTime_SIZE sizeof(LONGLONG)
    #define WMI_DISK_PERFORMANCE_QueryTime_ID 10

    // 
    ULONG StorageDeviceNumber;
    #define WMI_DISK_PERFORMANCE_StorageDeviceNumber_SIZE sizeof(ULONG)
    #define WMI_DISK_PERFORMANCE_StorageDeviceNumber_ID 11

    // 
    USHORT StorageManagerName[8];
    #define WMI_DISK_PERFORMANCE_StorageManagerName_SIZE sizeof(USHORT[8])
    #define WMI_DISK_PERFORMANCE_StorageManagerName_ID 12

} WMI_DISK_PERFORMANCE, *PWMI_DISK_PERFORMANCE;

#define WMI_DISK_PERFORMANCE_SIZE (FIELD_OFFSET(WMI_DISK_PERFORMANCE, StorageManagerName) + WMI_DISK_PERFORMANCE_StorageManagerName_SIZE)

// MSDiskDriver_Performance - MSDiskDriver_Performance
#define MSDiskDriver_PerformanceGuid \
    { 0xbdd865d1,0xd7c1,0x11d0, { 0xa5,0x01,0x00,0xa0,0xc9,0x06,0x29,0x10 } }

#if ! (defined(MIDL_PASS))
DEFINE_GUID(MSDiskDriver_Performance_GUID, \
            0xbdd865d1,0xd7c1,0x11d0,0xa5,0x01,0x00,0xa0,0xc9,0x06,0x29,0x10);
#endif


typedef struct _MSDiskDriver_Performance
{
    // 
    WMI_DISK_PERFORMANCE PerfData;
    #define MSDiskDriver_Performance_PerfData_SIZE sizeof(WMI_DISK_PERFORMANCE)
    #define MSDiskDriver_Performance_PerfData_ID 1

    // 
    CHAR VariableData[1];
    #define MSDiskDriver_Performance_DeviceName_ID 2

} MSDiskDriver_Performance, *PMSDiskDriver_Performance;

// MSStorageDriver_FailurePredictStatus - STORAGE_FAILURE_PREDICT_STATUS
#define WMI_STORAGE_FAILURE_PREDICT_STATUS_GUID \
    { 0x78ebc102,0x4cf9,0x11d2, { 0xba,0x4a,0x00,0xa0,0xc9,0x06,0x29,0x10 } }

#if ! (defined(MIDL_PASS))
DEFINE_GUID(MSStorageDriver_FailurePredictStatus_GUID, \
            0x78ebc102,0x4cf9,0x11d2,0xba,0x4a,0x00,0xa0,0xc9,0x06,0x29,0x10);
#endif


typedef struct _STORAGE_FAILURE_PREDICT_STATUS
{
    // 
    ULONG Reason;
    #define STORAGE_FAILURE_PREDICT_STATUS_Reason_SIZE sizeof(ULONG)
    #define STORAGE_FAILURE_PREDICT_STATUS_Reason_ID 1

    // 
    BOOLEAN PredictFailure;
    #define STORAGE_FAILURE_PREDICT_STATUS_PredictFailure_SIZE sizeof(BOOLEAN)
    #define STORAGE_FAILURE_PREDICT_STATUS_PredictFailure_ID 2

} STORAGE_FAILURE_PREDICT_STATUS, *PSTORAGE_FAILURE_PREDICT_STATUS;

#define STORAGE_FAILURE_PREDICT_STATUS_SIZE (FIELD_OFFSET(STORAGE_FAILURE_PREDICT_STATUS, PredictFailure) + STORAGE_FAILURE_PREDICT_STATUS_PredictFailure_SIZE)

// MSStorageDriver_FailurePredictData - STORAGE_FAILURE_PREDICT_DATA
#define WMI_STORAGE_FAILURE_PREDICT_DATA_GUID \
    { 0x78ebc103,0x4cf9,0x11d2, { 0xba,0x4a,0x00,0xa0,0xc9,0x06,0x29,0x10 } }

#if ! (defined(MIDL_PASS))
DEFINE_GUID(MSStorageDriver_FailurePredictData_GUID, \
            0x78ebc103,0x4cf9,0x11d2,0xba,0x4a,0x00,0xa0,0xc9,0x06,0x29,0x10);
#endif


typedef struct _STORAGE_FAILURE_PREDICT_DATA
{
    // 
    ULONG Length;
    #define STORAGE_FAILURE_PREDICT_DATA_Length_SIZE sizeof(ULONG)
    #define STORAGE_FAILURE_PREDICT_DATA_Length_ID 1

    // 
    UCHAR VendorSpecific[512];
    #define STORAGE_FAILURE_PREDICT_DATA_VendorSpecific_SIZE sizeof(UCHAR[512])
    #define STORAGE_FAILURE_PREDICT_DATA_VendorSpecific_ID 2

} STORAGE_FAILURE_PREDICT_DATA, *PSTORAGE_FAILURE_PREDICT_DATA;

#define STORAGE_FAILURE_PREDICT_DATA_SIZE (FIELD_OFFSET(STORAGE_FAILURE_PREDICT_DATA, VendorSpecific) + STORAGE_FAILURE_PREDICT_DATA_VendorSpecific_SIZE)

// MSStorageDriver_ATAPISmartData - ATAPI_FAILURE_PREDICT_DATA
#define WMI_ATAPI_FAILURE_PREDICT_DATA_GUID \
    { 0x78ebc103,0x4cf9,0x11d2, { 0xba,0x4a,0x00,0xa0,0xc9,0x06,0x29,0x10 } }

#if ! (defined(MIDL_PASS))
DEFINE_GUID(MSStorageDriver_ATAPISmartData_GUID, \
            0x78ebc103,0x4cf9,0x11d2,0xba,0x4a,0x00,0xa0,0xc9,0x06,0x29,0x10);
#endif


typedef struct _ATAPI_FAILURE_PREDICT_DATA
{
    // 
    ULONG Length;
    #define ATAPI_FAILURE_PREDICT_DATA_Length_SIZE sizeof(ULONG)
    #define ATAPI_FAILURE_PREDICT_DATA_Length_ID 1

    // 
    UCHAR VendorSpecific[362];
    #define ATAPI_FAILURE_PREDICT_DATA_VendorSpecific_SIZE sizeof(UCHAR[362])
    #define ATAPI_FAILURE_PREDICT_DATA_VendorSpecific_ID 2

    // 
    UCHAR OfflineCollectionStatus;
    #define ATAPI_FAILURE_PREDICT_DATA_OfflineCollectionStatus_SIZE sizeof(UCHAR)
    #define ATAPI_FAILURE_PREDICT_DATA_OfflineCollectionStatus_ID 3

    // 
    UCHAR SelfTestStatus;
    #define ATAPI_FAILURE_PREDICT_DATA_SelfTestStatus_SIZE sizeof(UCHAR)
    #define ATAPI_FAILURE_PREDICT_DATA_SelfTestStatus_ID 4

    // 
    USHORT TotalTime;
    #define ATAPI_FAILURE_PREDICT_DATA_TotalTime_SIZE sizeof(USHORT)
    #define ATAPI_FAILURE_PREDICT_DATA_TotalTime_ID 5

    // 
    UCHAR VendorSpecific2;
    #define ATAPI_FAILURE_PREDICT_DATA_VendorSpecific2_SIZE sizeof(UCHAR)
    #define ATAPI_FAILURE_PREDICT_DATA_VendorSpecific2_ID 6

    // 
    UCHAR OfflineCollectCapability;
    #define ATAPI_FAILURE_PREDICT_DATA_OfflineCollectCapability_SIZE sizeof(UCHAR)
    #define ATAPI_FAILURE_PREDICT_DATA_OfflineCollectCapability_ID 7

    // 
    USHORT SmartCapability;
    #define ATAPI_FAILURE_PREDICT_DATA_SmartCapability_SIZE sizeof(USHORT)
    #define ATAPI_FAILURE_PREDICT_DATA_SmartCapability_ID 8

    // 
    UCHAR ErrorLogCapability;
    #define ATAPI_FAILURE_PREDICT_DATA_ErrorLogCapability_SIZE sizeof(UCHAR)
    #define ATAPI_FAILURE_PREDICT_DATA_ErrorLogCapability_ID 9

    // 
    UCHAR VendorSpecific3;
    #define ATAPI_FAILURE_PREDICT_DATA_VendorSpecific3_SIZE sizeof(UCHAR)
    #define ATAPI_FAILURE_PREDICT_DATA_VendorSpecific3_ID 10

    // 
    UCHAR ShortPollTimeInMinutes;
    #define ATAPI_FAILURE_PREDICT_DATA_ShortPollTimeInMinutes_SIZE sizeof(UCHAR)
    #define ATAPI_FAILURE_PREDICT_DATA_ShortPollTimeInMinutes_ID 11

    // 
    UCHAR ExtendedPollTimeInMinutes;
    #define ATAPI_FAILURE_PREDICT_DATA_ExtendedPollTimeInMinutes_SIZE sizeof(UCHAR)
    #define ATAPI_FAILURE_PREDICT_DATA_ExtendedPollTimeInMinutes_ID 12

    // Reserved
    UCHAR Reserved[12];
    #define ATAPI_FAILURE_PREDICT_DATA_Reserved_SIZE sizeof(UCHAR[12])
    #define ATAPI_FAILURE_PREDICT_DATA_Reserved_ID 13

    // 
    UCHAR VendorSpecific4[125];
    #define ATAPI_FAILURE_PREDICT_DATA_VendorSpecific4_SIZE sizeof(UCHAR[125])
    #define ATAPI_FAILURE_PREDICT_DATA_VendorSpecific4_ID 14

    // 
    UCHAR Checksum;
    #define ATAPI_FAILURE_PREDICT_DATA_Checksum_SIZE sizeof(UCHAR)
    #define ATAPI_FAILURE_PREDICT_DATA_Checksum_ID 15

} ATAPI_FAILURE_PREDICT_DATA, *PATAPI_FAILURE_PREDICT_DATA;

#define ATAPI_FAILURE_PREDICT_DATA_SIZE (FIELD_OFFSET(ATAPI_FAILURE_PREDICT_DATA, Checksum) + ATAPI_FAILURE_PREDICT_DATA_Checksum_SIZE)

// MSStorageDriver_FailurePredictThresholds - STORAGE_FAILURE_PREDICT_THRESHOLDS
#define WMI_STORAGE_FAILURE_PREDICT_THRESHOLDS_GUID \
    { 0xdae10783,0xcc31,0x4d2a, { 0x8a,0x0f,0x86,0x1c,0x04,0x07,0x7a,0x95 } }

#if ! (defined(MIDL_PASS))
DEFINE_GUID(MSStorageDriver_FailurePredictThresholds_GUID, \
            0xdae10783,0xcc31,0x4d2a,0x8a,0x0f,0x86,0x1c,0x04,0x07,0x7a,0x95);
#endif


typedef struct _STORAGE_FAILURE_PREDICT_THRESHOLDS
{
    // 
    UCHAR VendorSpecific[512];
    #define STORAGE_FAILURE_PREDICT_THRESHOLDS_VendorSpecific_SIZE sizeof(UCHAR[512])
    #define STORAGE_FAILURE_PREDICT_THRESHOLDS_VendorSpecific_ID 1

} STORAGE_FAILURE_PREDICT_THRESHOLDS, *PSTORAGE_FAILURE_PREDICT_THRESHOLDS;

#define STORAGE_FAILURE_PREDICT_THRESHOLDS_SIZE (FIELD_OFFSET(STORAGE_FAILURE_PREDICT_THRESHOLDS, VendorSpecific) + STORAGE_FAILURE_PREDICT_THRESHOLDS_VendorSpecific_SIZE)

// MSStorageDriver_FailurePredictEvent - STORAGE_FAILURE_PREDICT_EVENT
#define WMI_STORAGE_PREDICT_FAILURE_EVENT_GUID \
    { 0x78ebc104,0x4cf9,0x11d2, { 0xba,0x4a,0x00,0xa0,0xc9,0x06,0x29,0x10 } }

#if ! (defined(MIDL_PASS))
DEFINE_GUID(MSStorageDriver_FailurePredictEvent_GUID, \
            0x78ebc104,0x4cf9,0x11d2,0xba,0x4a,0x00,0xa0,0xc9,0x06,0x29,0x10);
#endif


typedef struct _STORAGE_FAILURE_PREDICT_EVENT
{
    // 
    ULONG Length;
    #define STORAGE_FAILURE_PREDICT_EVENT_Length_SIZE sizeof(ULONG)
    #define STORAGE_FAILURE_PREDICT_EVENT_Length_ID 1

    // 
    UCHAR VendorSpecific[1];
    #define STORAGE_FAILURE_PREDICT_EVENT_VendorSpecific_ID 2

} STORAGE_FAILURE_PREDICT_EVENT, *PSTORAGE_FAILURE_PREDICT_EVENT;

// MSStorageDriver_FailurePredictFunction - STORAGE_FAILURE_PREDICT_FUNCTION
#define WMI_STORAGE_FAILURE_PREDICT_FUNCTION_GUID \
    { 0x78ebc105,0x4cf9,0x11d2, { 0xba,0x4a,0x00,0xa0,0xc9,0x06,0x29,0x10 } }

#if ! (defined(MIDL_PASS))
DEFINE_GUID(MSStorageDriver_FailurePredictFunction_GUID, \
            0x78ebc105,0x4cf9,0x11d2,0xba,0x4a,0x00,0xa0,0xc9,0x06,0x29,0x10);
#endif

//
// Method id definitions for MSStorageDriver_FailurePredictFunction
#define AllowPerformanceHit     1
typedef struct _ALLOW_PERFORMANCE_HIT_IN
{
    // 
    BOOLEAN Allow;
    #define ALLOW_PERFORMANCE_HIT_IN_Allow_SIZE sizeof(BOOLEAN)
    #define ALLOW_PERFORMANCE_HIT_IN_Allow_ID 1

} ALLOW_PERFORMANCE_HIT_IN, *PALLOW_PERFORMANCE_HIT_IN;

#define ALLOW_PERFORMANCE_HIT_IN_SIZE (FIELD_OFFSET(ALLOW_PERFORMANCE_HIT_IN, Allow) + ALLOW_PERFORMANCE_HIT_IN_Allow_SIZE)

#define EnableDisableHardwareFailurePrediction     2
typedef struct _ENABLE_DISABLE_FP_IN
{
    // 
    BOOLEAN Enable;
    #define ENABLE_DISABLE_FP_IN_Enable_SIZE sizeof(BOOLEAN)
    #define ENABLE_DISABLE_FP_IN_Enable_ID 1

} ENABLE_DISABLE_FP_IN, *PENABLE_DISABLE_FP_IN;

#define ENABLE_DISABLE_FP_IN_SIZE (FIELD_OFFSET(ENABLE_DISABLE_FP_IN, Enable) + ENABLE_DISABLE_FP_IN_Enable_SIZE)

#define EnableDisableFailurePredictionPolling     3
typedef struct _ENABLE_DISABLE_FP_POLLING_IN
{
    // 
    ULONG Period;
    #define ENABLE_DISABLE_FP_POLLING_IN_Period_SIZE sizeof(ULONG)
    #define ENABLE_DISABLE_FP_POLLING_IN_Period_ID 1

    // 
    BOOLEAN Enable;
    #define ENABLE_DISABLE_FP_POLLING_IN_Enable_SIZE sizeof(BOOLEAN)
    #define ENABLE_DISABLE_FP_POLLING_IN_Enable_ID 2

} ENABLE_DISABLE_FP_POLLING_IN, *PENABLE_DISABLE_FP_POLLING_IN;

#define ENABLE_DISABLE_FP_POLLING_IN_SIZE (FIELD_OFFSET(ENABLE_DISABLE_FP_POLLING_IN, Enable) + ENABLE_DISABLE_FP_POLLING_IN_Enable_SIZE)

#define GetFailurePredictionCapability     4
typedef struct _GET_FP_CAPABILITY_OUT
{
    // 
    ULONG Capability;
    #define GET_FP_CAPABILITY_OUT_Capability_SIZE sizeof(ULONG)
    #define GET_FP_CAPABILITY_OUT_Capability_ID 1

} GET_FP_CAPABILITY_OUT, *PGET_FP_CAPABILITY_OUT;

#define GET_FP_CAPABILITY_OUT_SIZE (FIELD_OFFSET(GET_FP_CAPABILITY_OUT, Capability) + GET_FP_CAPABILITY_OUT_Capability_SIZE)

#define EnableOfflineDiags     5
typedef struct _ENABLE_OFFLINE_DIAGS_OUT
{
    // 
    BOOLEAN Success;
    #define ENABLE_OFFLINE_DIAGS_OUT_Success_SIZE sizeof(BOOLEAN)
    #define ENABLE_OFFLINE_DIAGS_OUT_Success_ID 1

} ENABLE_OFFLINE_DIAGS_OUT, *PENABLE_OFFLINE_DIAGS_OUT;

#define ENABLE_OFFLINE_DIAGS_OUT_SIZE (FIELD_OFFSET(ENABLE_OFFLINE_DIAGS_OUT, Success) + ENABLE_OFFLINE_DIAGS_OUT_Success_SIZE)

#define ReadLogSectors     6
typedef struct _READ_LOG_SECTORS_IN
{
    // 
    UCHAR LogAddress;
    #define READ_LOG_SECTORS_IN_LogAddress_SIZE sizeof(UCHAR)
    #define READ_LOG_SECTORS_IN_LogAddress_ID 1

    // 
    UCHAR SectorCount;
    #define READ_LOG_SECTORS_IN_SectorCount_SIZE sizeof(UCHAR)
    #define READ_LOG_SECTORS_IN_SectorCount_ID 2

} READ_LOG_SECTORS_IN, *PREAD_LOG_SECTORS_IN;

#define READ_LOG_SECTORS_IN_SIZE (FIELD_OFFSET(READ_LOG_SECTORS_IN, SectorCount) + READ_LOG_SECTORS_IN_SectorCount_SIZE)

typedef struct _READ_LOG_SECTORS_OUT
{
    // 
    ULONG Length;
    #define READ_LOG_SECTORS_OUT_Length_SIZE sizeof(ULONG)
    #define READ_LOG_SECTORS_OUT_Length_ID 3

    // 
    UCHAR LogSectors[1];
    #define READ_LOG_SECTORS_OUT_LogSectors_ID 4

} READ_LOG_SECTORS_OUT, *PREAD_LOG_SECTORS_OUT;

#define WriteLogSectors     7
typedef struct _WRITE_LOG_SECTORS_IN
{
    // 
    UCHAR LogAddress;
    #define WRITE_LOG_SECTORS_IN_LogAddress_SIZE sizeof(UCHAR)
    #define WRITE_LOG_SECTORS_IN_LogAddress_ID 1

    // 
    UCHAR SectorCount;
    #define WRITE_LOG_SECTORS_IN_SectorCount_SIZE sizeof(UCHAR)
    #define WRITE_LOG_SECTORS_IN_SectorCount_ID 2

    // 
    ULONG Length;
    #define WRITE_LOG_SECTORS_IN_Length_SIZE sizeof(ULONG)
    #define WRITE_LOG_SECTORS_IN_Length_ID 3

    // 
    UCHAR LogSectors[1];
    #define WRITE_LOG_SECTORS_IN_LogSectors_ID 4

} WRITE_LOG_SECTORS_IN, *PWRITE_LOG_SECTORS_IN;

typedef struct _WRITE_LOG_SECTORS_OUT
{
    // 
    BOOLEAN Success;
    #define WRITE_LOG_SECTORS_OUT_Success_SIZE sizeof(BOOLEAN)
    #define WRITE_LOG_SECTORS_OUT_Success_ID 5

} WRITE_LOG_SECTORS_OUT, *PWRITE_LOG_SECTORS_OUT;

#define WRITE_LOG_SECTORS_OUT_SIZE (FIELD_OFFSET(WRITE_LOG_SECTORS_OUT, Success) + WRITE_LOG_SECTORS_OUT_Success_SIZE)

#define ExecuteSelfTest     8
typedef struct _EXECUTE_SELF_TEST_IN
{
    // 
    UCHAR Subcommand;
    #define EXECUTE_SELF_TEST_IN_Subcommand_SIZE sizeof(UCHAR)
    #define EXECUTE_SELF_TEST_IN_Subcommand_ID 1

} EXECUTE_SELF_TEST_IN, *PEXECUTE_SELF_TEST_IN;

#define EXECUTE_SELF_TEST_IN_SIZE (FIELD_OFFSET(EXECUTE_SELF_TEST_IN, Subcommand) + EXECUTE_SELF_TEST_IN_Subcommand_SIZE)

typedef struct _EXECUTE_SELF_TEST_OUT
{
    // 
    ULONG ReturnCode;
    #define EXECUTE_SELF_TEST_OUT_ReturnCode_SIZE sizeof(ULONG)
    #define EXECUTE_SELF_TEST_OUT_ReturnCode_ID 2

} EXECUTE_SELF_TEST_OUT, *PEXECUTE_SELF_TEST_OUT;

#define EXECUTE_SELF_TEST_OUT_SIZE (FIELD_OFFSET(EXECUTE_SELF_TEST_OUT, ReturnCode) + EXECUTE_SELF_TEST_OUT_ReturnCode_SIZE)


// MSStorageDriver_ScsiInfoExceptions - STORAGE_SCSI_INFO_EXCEPTIONS
#define WMI_STORAGE_SCSI_INFO_EXCEPTIONS_GUID \
    { 0x1101d829,0x167b,0x4ebf, { 0xac,0xae,0x28,0xca,0xb7,0xc3,0x48,0x02 } }

#if ! (defined(MIDL_PASS))
DEFINE_GUID(MSStorageDriver_ScsiInfoExceptions_GUID, \
            0x1101d829,0x167b,0x4ebf,0xac,0xae,0x28,0xca,0xb7,0xc3,0x48,0x02);
#endif


typedef struct _STORAGE_SCSI_INFO_EXCEPTIONS
{
    // 
    BOOLEAN PageSavable;
    #define STORAGE_SCSI_INFO_EXCEPTIONS_PageSavable_SIZE sizeof(BOOLEAN)
    #define STORAGE_SCSI_INFO_EXCEPTIONS_PageSavable_ID 1

    // 
    UCHAR Flags;
    #define STORAGE_SCSI_INFO_EXCEPTIONS_Flags_SIZE sizeof(UCHAR)
    #define STORAGE_SCSI_INFO_EXCEPTIONS_Flags_ID 2

    // 
    UCHAR MRIE;
    #define STORAGE_SCSI_INFO_EXCEPTIONS_MRIE_SIZE sizeof(UCHAR)
    #define STORAGE_SCSI_INFO_EXCEPTIONS_MRIE_ID 3

    // 
    UCHAR Padding;
    #define STORAGE_SCSI_INFO_EXCEPTIONS_Padding_SIZE sizeof(UCHAR)
    #define STORAGE_SCSI_INFO_EXCEPTIONS_Padding_ID 4

    // 
    ULONG IntervalTimer;
    #define STORAGE_SCSI_INFO_EXCEPTIONS_IntervalTimer_SIZE sizeof(ULONG)
    #define STORAGE_SCSI_INFO_EXCEPTIONS_IntervalTimer_ID 5

    // 
    ULONG ReportCount;
    #define STORAGE_SCSI_INFO_EXCEPTIONS_ReportCount_SIZE sizeof(ULONG)
    #define STORAGE_SCSI_INFO_EXCEPTIONS_ReportCount_ID 6

} STORAGE_SCSI_INFO_EXCEPTIONS, *PSTORAGE_SCSI_INFO_EXCEPTIONS;

#define STORAGE_SCSI_INFO_EXCEPTIONS_SIZE (FIELD_OFFSET(STORAGE_SCSI_INFO_EXCEPTIONS, ReportCount) + STORAGE_SCSI_INFO_EXCEPTIONS_ReportCount_SIZE)

// MSIde_PortDeviceInfo - MSIde_PortDeviceInfo
#define MSIde_PortDeviceInfoGuid \
    { 0x53f5630f,0xb6bf,0x11d0, { 0x94,0xf2,0x00,0xa0,0xc9,0x1e,0xfb,0x8b } }

#if ! (defined(MIDL_PASS))
DEFINE_GUID(MSIde_PortDeviceInfo_GUID, \
            0x53f5630f,0xb6bf,0x11d0,0x94,0xf2,0x00,0xa0,0xc9,0x1e,0xfb,0x8b);
#endif


typedef struct _MSIde_PortDeviceInfo
{
    // 
    UCHAR Bus;
    #define MSIde_PortDeviceInfo_Bus_SIZE sizeof(UCHAR)
    #define MSIde_PortDeviceInfo_Bus_ID 1

    // 
    UCHAR Target;
    #define MSIde_PortDeviceInfo_Target_SIZE sizeof(UCHAR)
    #define MSIde_PortDeviceInfo_Target_ID 2

    // 
    UCHAR Lun;
    #define MSIde_PortDeviceInfo_Lun_SIZE sizeof(UCHAR)
    #define MSIde_PortDeviceInfo_Lun_ID 3

} MSIde_PortDeviceInfo, *PMSIde_PortDeviceInfo;

#define MSIde_PortDeviceInfo_SIZE (FIELD_OFFSET(MSIde_PortDeviceInfo, Lun) + MSIde_PortDeviceInfo_Lun_SIZE)

// MSSerial_PortName - MSSerial_PortName
#define SERIAL_PORT_WMI_NAME_GUID \
    { 0xa0ec11a8,0xb16c,0x11d1, { 0xbd,0x98,0x00,0xa0,0xc9,0x06,0xbe,0x2d } }

#if ! (defined(MIDL_PASS))
DEFINE_GUID(MSSerial_PortName_GUID, \
            0xa0ec11a8,0xb16c,0x11d1,0xbd,0x98,0x00,0xa0,0xc9,0x06,0xbe,0x2d);
#endif


typedef struct _MSSerial_PortName
{
    // 
    CHAR VariableData[1];
    #define MSSerial_PortName_PortName_ID 1

} MSSerial_PortName, *PMSSerial_PortName;

// MSSerial_CommInfo - SERIAL_WMI_COMM_DATA
#define SERIAL_PORT_WMI_COMM_GUID \
    { 0xedb16a62,0xb16c,0x11d1, { 0xbd,0x98,0x00,0xa0,0xc9,0x06,0xbe,0x2d } }

#if ! (defined(MIDL_PASS))
DEFINE_GUID(MSSerial_CommInfo_GUID, \
            0xedb16a62,0xb16c,0x11d1,0xbd,0x98,0x00,0xa0,0xc9,0x06,0xbe,0x2d);
#endif


typedef struct _SERIAL_WMI_COMM_DATA
{
    // 
    ULONG BaudRate;
    #define SERIAL_WMI_COMM_DATA_BaudRate_SIZE sizeof(ULONG)
    #define SERIAL_WMI_COMM_DATA_BaudRate_ID 1

    // 
    ULONG BitsPerByte;
    #define SERIAL_WMI_COMM_DATA_BitsPerByte_SIZE sizeof(ULONG)
    #define SERIAL_WMI_COMM_DATA_BitsPerByte_ID 2


#define SERIAL_WMI_PARITY_NONE 0
#define SERIAL_WMI_PARITY_ODD 1
#define SERIAL_WMI_PARITY_EVEN 2
#define SERIAL_WMI_PARITY_SPACE 3
#define SERIAL_WMI_PARITY_MARK 4

    // 
    ULONG Parity;
    #define SERIAL_WMI_COMM_DATA_Parity_SIZE sizeof(ULONG)
    #define SERIAL_WMI_COMM_DATA_Parity_ID 3

    // 
    BOOLEAN ParityCheckEnable;
    #define SERIAL_WMI_COMM_DATA_ParityCheckEnable_SIZE sizeof(BOOLEAN)
    #define SERIAL_WMI_COMM_DATA_ParityCheckEnable_ID 4


#define SERIAL_WMI_STOP_1 0
#define SERIAL_WMI_STOP_1_5 1
#define SERIAL_WMI_STOP_2 2

    // 
    ULONG StopBits;
    #define SERIAL_WMI_COMM_DATA_StopBits_SIZE sizeof(ULONG)
    #define SERIAL_WMI_COMM_DATA_StopBits_ID 5

    // 
    ULONG XoffCharacter;
    #define SERIAL_WMI_COMM_DATA_XoffCharacter_SIZE sizeof(ULONG)
    #define SERIAL_WMI_COMM_DATA_XoffCharacter_ID 6

    // 
    ULONG XoffXmitThreshold;
    #define SERIAL_WMI_COMM_DATA_XoffXmitThreshold_SIZE sizeof(ULONG)
    #define SERIAL_WMI_COMM_DATA_XoffXmitThreshold_ID 7

    // 
    ULONG XonCharacter;
    #define SERIAL_WMI_COMM_DATA_XonCharacter_SIZE sizeof(ULONG)
    #define SERIAL_WMI_COMM_DATA_XonCharacter_ID 8

    // 
    ULONG XonXmitThreshold;
    #define SERIAL_WMI_COMM_DATA_XonXmitThreshold_SIZE sizeof(ULONG)
    #define SERIAL_WMI_COMM_DATA_XonXmitThreshold_ID 9

    // 
    ULONG MaximumBaudRate;
    #define SERIAL_WMI_COMM_DATA_MaximumBaudRate_SIZE sizeof(ULONG)
    #define SERIAL_WMI_COMM_DATA_MaximumBaudRate_ID 10

    // 
    ULONG MaximumOutputBufferSize;
    #define SERIAL_WMI_COMM_DATA_MaximumOutputBufferSize_SIZE sizeof(ULONG)
    #define SERIAL_WMI_COMM_DATA_MaximumOutputBufferSize_ID 11

    // 
    ULONG MaximumInputBufferSize;
    #define SERIAL_WMI_COMM_DATA_MaximumInputBufferSize_SIZE sizeof(ULONG)
    #define SERIAL_WMI_COMM_DATA_MaximumInputBufferSize_ID 12

    // 
    BOOLEAN Support16BitMode;
    #define SERIAL_WMI_COMM_DATA_Support16BitMode_SIZE sizeof(BOOLEAN)
    #define SERIAL_WMI_COMM_DATA_Support16BitMode_ID 13

    // 
    BOOLEAN SupportDTRDSR;
    #define SERIAL_WMI_COMM_DATA_SupportDTRDSR_SIZE sizeof(BOOLEAN)
    #define SERIAL_WMI_COMM_DATA_SupportDTRDSR_ID 14

    // 
    BOOLEAN SupportIntervalTimeouts;
    #define SERIAL_WMI_COMM_DATA_SupportIntervalTimeouts_SIZE sizeof(BOOLEAN)
    #define SERIAL_WMI_COMM_DATA_SupportIntervalTimeouts_ID 15

    // 
    BOOLEAN SupportParityCheck;
    #define SERIAL_WMI_COMM_DATA_SupportParityCheck_SIZE sizeof(BOOLEAN)
    #define SERIAL_WMI_COMM_DATA_SupportParityCheck_ID 16

    // 
    BOOLEAN SupportRTSCTS;
    #define SERIAL_WMI_COMM_DATA_SupportRTSCTS_SIZE sizeof(BOOLEAN)
    #define SERIAL_WMI_COMM_DATA_SupportRTSCTS_ID 17

    // 
    BOOLEAN SupportXonXoff;
    #define SERIAL_WMI_COMM_DATA_SupportXonXoff_SIZE sizeof(BOOLEAN)
    #define SERIAL_WMI_COMM_DATA_SupportXonXoff_ID 18

    // 
    BOOLEAN SettableBaudRate;
    #define SERIAL_WMI_COMM_DATA_SettableBaudRate_SIZE sizeof(BOOLEAN)
    #define SERIAL_WMI_COMM_DATA_SettableBaudRate_ID 19

    // 
    BOOLEAN SettableDataBits;
    #define SERIAL_WMI_COMM_DATA_SettableDataBits_SIZE sizeof(BOOLEAN)
    #define SERIAL_WMI_COMM_DATA_SettableDataBits_ID 20

    // 
    BOOLEAN SettableFlowControl;
    #define SERIAL_WMI_COMM_DATA_SettableFlowControl_SIZE sizeof(BOOLEAN)
    #define SERIAL_WMI_COMM_DATA_SettableFlowControl_ID 21

    // 
    BOOLEAN SettableParity;
    #define SERIAL_WMI_COMM_DATA_SettableParity_SIZE sizeof(BOOLEAN)
    #define SERIAL_WMI_COMM_DATA_SettableParity_ID 22

    // 
    BOOLEAN SettableParityCheck;
    #define SERIAL_WMI_COMM_DATA_SettableParityCheck_SIZE sizeof(BOOLEAN)
    #define SERIAL_WMI_COMM_DATA_SettableParityCheck_ID 23

    // 
    BOOLEAN SettableStopBits;
    #define SERIAL_WMI_COMM_DATA_SettableStopBits_SIZE sizeof(BOOLEAN)
    #define SERIAL_WMI_COMM_DATA_SettableStopBits_ID 24

    // 
    BOOLEAN IsBusy;
    #define SERIAL_WMI_COMM_DATA_IsBusy_SIZE sizeof(BOOLEAN)
    #define SERIAL_WMI_COMM_DATA_IsBusy_ID 25

} SERIAL_WMI_COMM_DATA, *PSERIAL_WMI_COMM_DATA;

#define SERIAL_WMI_COMM_DATA_SIZE (FIELD_OFFSET(SERIAL_WMI_COMM_DATA, IsBusy) + SERIAL_WMI_COMM_DATA_IsBusy_SIZE)

// MSSerial_HardwareConfiguration - SERIAL_WMI_HW_DATA
#define SERIAL_PORT_WMI_HW_GUID \
    { 0x270b9b86,0xb16d,0x11d1, { 0xbd,0x98,0x00,0xa0,0xc9,0x06,0xbe,0x2d } }

#if ! (defined(MIDL_PASS))
DEFINE_GUID(MSSerial_HardwareConfiguration_GUID, \
            0x270b9b86,0xb16d,0x11d1,0xbd,0x98,0x00,0xa0,0xc9,0x06,0xbe,0x2d);
#endif


typedef struct _SERIAL_WMI_HW_DATA
{
    // 
    ULONG IrqNumber;
    #define SERIAL_WMI_HW_DATA_IrqNumber_SIZE sizeof(ULONG)
    #define SERIAL_WMI_HW_DATA_IrqNumber_ID 1

    // 
    ULONG IrqVector;
    #define SERIAL_WMI_HW_DATA_IrqVector_SIZE sizeof(ULONG)
    #define SERIAL_WMI_HW_DATA_IrqVector_ID 2

    // 
    ULONG IrqLevel;
    #define SERIAL_WMI_HW_DATA_IrqLevel_SIZE sizeof(ULONG)
    #define SERIAL_WMI_HW_DATA_IrqLevel_ID 3

    // 
    ULONGLONG IrqAffinityMask;
    #define SERIAL_WMI_HW_DATA_IrqAffinityMask_SIZE sizeof(ULONGLONG)
    #define SERIAL_WMI_HW_DATA_IrqAffinityMask_ID 4


#define SERIAL_WMI_INTTYPE_LATCHED 0
#define SERIAL_WMI_INTTYPE_LEVEL 1

    // 
    ULONG InterruptType;
    #define SERIAL_WMI_HW_DATA_InterruptType_SIZE sizeof(ULONG)
    #define SERIAL_WMI_HW_DATA_InterruptType_ID 5

    // 
    ULONGLONG BaseIOAddress;
    #define SERIAL_WMI_HW_DATA_BaseIOAddress_SIZE sizeof(ULONGLONG)
    #define SERIAL_WMI_HW_DATA_BaseIOAddress_ID 6

} SERIAL_WMI_HW_DATA, *PSERIAL_WMI_HW_DATA;

#define SERIAL_WMI_HW_DATA_SIZE (FIELD_OFFSET(SERIAL_WMI_HW_DATA, BaseIOAddress) + SERIAL_WMI_HW_DATA_BaseIOAddress_SIZE)

// MSSerial_PerformanceInformation - SERIAL_WMI_PERF_DATA
#define SERIAL_PORT_WMI_PERF_GUID \
    { 0x56415acc,0xb16d,0x11d1, { 0xbd,0x98,0x00,0xa0,0xc9,0x06,0xbe,0x2d } }

#if ! (defined(MIDL_PASS))
DEFINE_GUID(MSSerial_PerformanceInformation_GUID, \
            0x56415acc,0xb16d,0x11d1,0xbd,0x98,0x00,0xa0,0xc9,0x06,0xbe,0x2d);
#endif


typedef struct _SERIAL_WMI_PERF_DATA
{
    // 
    ULONG ReceivedCount;
    #define SERIAL_WMI_PERF_DATA_ReceivedCount_SIZE sizeof(ULONG)
    #define SERIAL_WMI_PERF_DATA_ReceivedCount_ID 1

    // 
    ULONG TransmittedCount;
    #define SERIAL_WMI_PERF_DATA_TransmittedCount_SIZE sizeof(ULONG)
    #define SERIAL_WMI_PERF_DATA_TransmittedCount_ID 2

    // 
    ULONG FrameErrorCount;
    #define SERIAL_WMI_PERF_DATA_FrameErrorCount_SIZE sizeof(ULONG)
    #define SERIAL_WMI_PERF_DATA_FrameErrorCount_ID 3

    // 
    ULONG SerialOverrunErrorCount;
    #define SERIAL_WMI_PERF_DATA_SerialOverrunErrorCount_SIZE sizeof(ULONG)
    #define SERIAL_WMI_PERF_DATA_SerialOverrunErrorCount_ID 4

    // 
    ULONG BufferOverrunErrorCount;
    #define SERIAL_WMI_PERF_DATA_BufferOverrunErrorCount_SIZE sizeof(ULONG)
    #define SERIAL_WMI_PERF_DATA_BufferOverrunErrorCount_ID 5

    // 
    ULONG ParityErrorCount;
    #define SERIAL_WMI_PERF_DATA_ParityErrorCount_SIZE sizeof(ULONG)
    #define SERIAL_WMI_PERF_DATA_ParityErrorCount_ID 6

} SERIAL_WMI_PERF_DATA, *PSERIAL_WMI_PERF_DATA;

#define SERIAL_WMI_PERF_DATA_SIZE (FIELD_OFFSET(SERIAL_WMI_PERF_DATA, ParityErrorCount) + SERIAL_WMI_PERF_DATA_ParityErrorCount_SIZE)

// MSSerial_CommProperties - SERIAL_WMI_COMMPROP
#define SERIAL_PORT_WMI_PROPERTIES_GUID \
    { 0x8209ec2a,0x2d6b,0x11d2, { 0xba,0x49,0x00,0xa0,0xc9,0x06,0x29,0x10 } }

#if ! (defined(MIDL_PASS))
DEFINE_GUID(MSSerial_CommProperties_GUID, \
            0x8209ec2a,0x2d6b,0x11d2,0xba,0x49,0x00,0xa0,0xc9,0x06,0x29,0x10);
#endif


typedef struct _SERIAL_WMI_COMMPROP
{
    // 
    USHORT wPacketLength;
    #define SERIAL_WMI_COMMPROP_wPacketLength_SIZE sizeof(USHORT)
    #define SERIAL_WMI_COMMPROP_wPacketLength_ID 1

    // 
    USHORT wPacketVersion;
    #define SERIAL_WMI_COMMPROP_wPacketVersion_SIZE sizeof(USHORT)
    #define SERIAL_WMI_COMMPROP_wPacketVersion_ID 2

    // 
    ULONG dwServiceMask;
    #define SERIAL_WMI_COMMPROP_dwServiceMask_SIZE sizeof(ULONG)
    #define SERIAL_WMI_COMMPROP_dwServiceMask_ID 3

    // 
    ULONG dwReserved1;
    #define SERIAL_WMI_COMMPROP_dwReserved1_SIZE sizeof(ULONG)
    #define SERIAL_WMI_COMMPROP_dwReserved1_ID 4

    // 
    ULONG dwMaxTxQueue;
    #define SERIAL_WMI_COMMPROP_dwMaxTxQueue_SIZE sizeof(ULONG)
    #define SERIAL_WMI_COMMPROP_dwMaxTxQueue_ID 5

    // 
    ULONG dwMaxRxQueue;
    #define SERIAL_WMI_COMMPROP_dwMaxRxQueue_SIZE sizeof(ULONG)
    #define SERIAL_WMI_COMMPROP_dwMaxRxQueue_ID 6

    // 
    ULONG dwMaxBaud;
    #define SERIAL_WMI_COMMPROP_dwMaxBaud_SIZE sizeof(ULONG)
    #define SERIAL_WMI_COMMPROP_dwMaxBaud_ID 7

    // 
    ULONG dwProvSubType;
    #define SERIAL_WMI_COMMPROP_dwProvSubType_SIZE sizeof(ULONG)
    #define SERIAL_WMI_COMMPROP_dwProvSubType_ID 8

    // 
    ULONG dwProvCapabilities;
    #define SERIAL_WMI_COMMPROP_dwProvCapabilities_SIZE sizeof(ULONG)
    #define SERIAL_WMI_COMMPROP_dwProvCapabilities_ID 9

    // 
    ULONG dwSettableParams;
    #define SERIAL_WMI_COMMPROP_dwSettableParams_SIZE sizeof(ULONG)
    #define SERIAL_WMI_COMMPROP_dwSettableParams_ID 10

    // 
    ULONG dwSettableBaud;
    #define SERIAL_WMI_COMMPROP_dwSettableBaud_SIZE sizeof(ULONG)
    #define SERIAL_WMI_COMMPROP_dwSettableBaud_ID 11

    // 
    USHORT wSettableData;
    #define SERIAL_WMI_COMMPROP_wSettableData_SIZE sizeof(USHORT)
    #define SERIAL_WMI_COMMPROP_wSettableData_ID 12

    // 
    USHORT wSettableStopParity;
    #define SERIAL_WMI_COMMPROP_wSettableStopParity_SIZE sizeof(USHORT)
    #define SERIAL_WMI_COMMPROP_wSettableStopParity_ID 13

    // 
    ULONG dwCurrentTxQueue;
    #define SERIAL_WMI_COMMPROP_dwCurrentTxQueue_SIZE sizeof(ULONG)
    #define SERIAL_WMI_COMMPROP_dwCurrentTxQueue_ID 14

    // 
    ULONG dwCurrentRxQueue;
    #define SERIAL_WMI_COMMPROP_dwCurrentRxQueue_SIZE sizeof(ULONG)
    #define SERIAL_WMI_COMMPROP_dwCurrentRxQueue_ID 15

    // 
    ULONG dwProvSpec1;
    #define SERIAL_WMI_COMMPROP_dwProvSpec1_SIZE sizeof(ULONG)
    #define SERIAL_WMI_COMMPROP_dwProvSpec1_ID 16

    // 
    ULONG dwProvSpec2;
    #define SERIAL_WMI_COMMPROP_dwProvSpec2_SIZE sizeof(ULONG)
    #define SERIAL_WMI_COMMPROP_dwProvSpec2_ID 17

    // 
    ULONG dwProvCharSize;
    #define SERIAL_WMI_COMMPROP_dwProvCharSize_SIZE sizeof(ULONG)
    #define SERIAL_WMI_COMMPROP_dwProvCharSize_ID 18

    // 
    UCHAR wcProvChar[1];
    #define SERIAL_WMI_COMMPROP_wcProvChar_ID 19

} SERIAL_WMI_COMMPROP, *PSERIAL_WMI_COMMPROP;

// MSParallel_AllocFreeCounts - PARPORT_WMI_ALLOC_FREE_COUNTS
#define PARPORT_WMI_ALLOCATE_FREE_COUNTS_GUID \
    { 0x4bbb69ea,0x6853,0x11d2, { 0x8e,0xce,0x00,0xc0,0x4f,0x8e,0xf4,0x81 } }

#if ! (defined(MIDL_PASS))
DEFINE_GUID(MSParallel_AllocFreeCounts_GUID, \
            0x4bbb69ea,0x6853,0x11d2,0x8e,0xce,0x00,0xc0,0x4f,0x8e,0xf4,0x81);
#endif


typedef struct _PARPORT_WMI_ALLOC_FREE_COUNTS
{
    // 
    ULONG PortAllocates;
    #define PARPORT_WMI_ALLOC_FREE_COUNTS_PortAllocates_SIZE sizeof(ULONG)
    #define PARPORT_WMI_ALLOC_FREE_COUNTS_PortAllocates_ID 1

    // 
    ULONG PortFrees;
    #define PARPORT_WMI_ALLOC_FREE_COUNTS_PortFrees_SIZE sizeof(ULONG)
    #define PARPORT_WMI_ALLOC_FREE_COUNTS_PortFrees_ID 2

} PARPORT_WMI_ALLOC_FREE_COUNTS, *PPARPORT_WMI_ALLOC_FREE_COUNTS;

#define PARPORT_WMI_ALLOC_FREE_COUNTS_SIZE (FIELD_OFFSET(PARPORT_WMI_ALLOC_FREE_COUNTS, PortFrees) + PARPORT_WMI_ALLOC_FREE_COUNTS_PortFrees_SIZE)

// MSParallel_DeviceBytesTransferred - PARALLEL_WMI_LOG_INFO
#define PARALLEL_WMI_BYTES_TRANSFERRED_GUID \
    { 0x89fef2d6,0x654b,0x11d2, { 0x9e,0x15,0x00,0xc0,0x4f,0x8e,0xf4,0x81 } }

#if ! (defined(MIDL_PASS))
DEFINE_GUID(MSParallel_DeviceBytesTransferred_GUID, \
            0x89fef2d6,0x654b,0x11d2,0x9e,0x15,0x00,0xc0,0x4f,0x8e,0xf4,0x81);
#endif


typedef struct _PARALLEL_WMI_LOG_INFO
{
    // 
    ULONG Flags1;
    #define PARALLEL_WMI_LOG_INFO_Flags1_SIZE sizeof(ULONG)
    #define PARALLEL_WMI_LOG_INFO_Flags1_ID 1

    // 
    ULONG Flags2;
    #define PARALLEL_WMI_LOG_INFO_Flags2_SIZE sizeof(ULONG)
    #define PARALLEL_WMI_LOG_INFO_Flags2_ID 2

    // 
    ULONG spare[2];
    #define PARALLEL_WMI_LOG_INFO_spare_SIZE sizeof(ULONG[2])
    #define PARALLEL_WMI_LOG_INFO_spare_ID 3

    // 
    LONGLONG SppWriteCount;
    #define PARALLEL_WMI_LOG_INFO_SppWriteCount_SIZE sizeof(LONGLONG)
    #define PARALLEL_WMI_LOG_INFO_SppWriteCount_ID 4

    // 
    LONGLONG NibbleReadCount;
    #define PARALLEL_WMI_LOG_INFO_NibbleReadCount_SIZE sizeof(LONGLONG)
    #define PARALLEL_WMI_LOG_INFO_NibbleReadCount_ID 5

    // 
    LONGLONG BoundedEcpWriteCount;
    #define PARALLEL_WMI_LOG_INFO_BoundedEcpWriteCount_SIZE sizeof(LONGLONG)
    #define PARALLEL_WMI_LOG_INFO_BoundedEcpWriteCount_ID 6

    // 
    LONGLONG BoundedEcpReadCount;
    #define PARALLEL_WMI_LOG_INFO_BoundedEcpReadCount_SIZE sizeof(LONGLONG)
    #define PARALLEL_WMI_LOG_INFO_BoundedEcpReadCount_ID 7

    // 
    LONGLONG HwEcpWriteCount;
    #define PARALLEL_WMI_LOG_INFO_HwEcpWriteCount_SIZE sizeof(LONGLONG)
    #define PARALLEL_WMI_LOG_INFO_HwEcpWriteCount_ID 8

    // 
    LONGLONG HwEcpReadCount;
    #define PARALLEL_WMI_LOG_INFO_HwEcpReadCount_SIZE sizeof(LONGLONG)
    #define PARALLEL_WMI_LOG_INFO_HwEcpReadCount_ID 9

    // 
    LONGLONG SwEcpWriteCount;
    #define PARALLEL_WMI_LOG_INFO_SwEcpWriteCount_SIZE sizeof(LONGLONG)
    #define PARALLEL_WMI_LOG_INFO_SwEcpWriteCount_ID 10

    // 
    LONGLONG SwEcpReadCount;
    #define PARALLEL_WMI_LOG_INFO_SwEcpReadCount_SIZE sizeof(LONGLONG)
    #define PARALLEL_WMI_LOG_INFO_SwEcpReadCount_ID 11

    // 
    LONGLONG HwEppWriteCount;
    #define PARALLEL_WMI_LOG_INFO_HwEppWriteCount_SIZE sizeof(LONGLONG)
    #define PARALLEL_WMI_LOG_INFO_HwEppWriteCount_ID 12

    // 
    LONGLONG HwEppReadCount;
    #define PARALLEL_WMI_LOG_INFO_HwEppReadCount_SIZE sizeof(LONGLONG)
    #define PARALLEL_WMI_LOG_INFO_HwEppReadCount_ID 13

    // 
    LONGLONG SwEppWriteCount;
    #define PARALLEL_WMI_LOG_INFO_SwEppWriteCount_SIZE sizeof(LONGLONG)
    #define PARALLEL_WMI_LOG_INFO_SwEppWriteCount_ID 14

    // 
    LONGLONG SwEppReadCount;
    #define PARALLEL_WMI_LOG_INFO_SwEppReadCount_SIZE sizeof(LONGLONG)
    #define PARALLEL_WMI_LOG_INFO_SwEppReadCount_ID 15

    // 
    LONGLONG ByteReadCount;
    #define PARALLEL_WMI_LOG_INFO_ByteReadCount_SIZE sizeof(LONGLONG)
    #define PARALLEL_WMI_LOG_INFO_ByteReadCount_ID 16

    // 
    LONGLONG ChannelNibbleReadCount;
    #define PARALLEL_WMI_LOG_INFO_ChannelNibbleReadCount_SIZE sizeof(LONGLONG)
    #define PARALLEL_WMI_LOG_INFO_ChannelNibbleReadCount_ID 17

} PARALLEL_WMI_LOG_INFO, *PPARALLEL_WMI_LOG_INFO;

#define PARALLEL_WMI_LOG_INFO_SIZE (FIELD_OFFSET(PARALLEL_WMI_LOG_INFO, ChannelNibbleReadCount) + PARALLEL_WMI_LOG_INFO_ChannelNibbleReadCount_SIZE)

// MSRedbook_DriverInformation - REDBOOK_WMI_STD_DATA
#define GUID_REDBOOK_WMI_STD_DATA \
    { 0xb90550e7,0xae0a,0x11d1, { 0xa5,0x71,0x00,0xc0,0x4f,0xa3,0x47,0x30 } }

#if ! (defined(MIDL_PASS))
DEFINE_GUID(MSRedbook_DriverInformationGuid, \
            0xb90550e7,0xae0a,0x11d1,0xa5,0x71,0x00,0xc0,0x4f,0xa3,0x47,0x30);
#endif


typedef struct _REDBOOK_WMI_STD_DATA
{
    // 
    ULONG NumberOfBuffers;
    #define REDBOOK_WMI_NUMBER_OF_BUFFERS_SIZE sizeof(ULONG)
    #define REDBOOK_WMI_NUMBER_OF_BUFFERS_ID 1

    // 
    ULONG SectorsPerRead;
    #define REDBOOK_WMI_SECTORS_PER_READ_SIZE sizeof(ULONG)
    #define REDBOOK_WMI_SECTORS_PER_READ_ID 2

    // 
    ULONG SectorsPerReadMask;
    #define REDBOOK_WMI_SECTORS_PER_READ_MASK_SIZE sizeof(ULONG)
    #define REDBOOK_WMI_SECTORS_PER_READ_MASK_ID 3

    // 
    ULONG MaximumSectorsPerRead;
    #define REDBOOK_WMI_MAX_SECTORS_PER_READ_SIZE sizeof(ULONG)
    #define REDBOOK_WMI_MAX_SECTORS_PER_READ_ID 4

    // 
    BOOLEAN PlayEnabled;
    #define REDBOOK_WMI_PLAY_ENABLED_SIZE sizeof(BOOLEAN)
    #define REDBOOK_WMI_PLAY_ENABLED_ID 5

    // 
    BOOLEAN CDDASupported;
    #define REDBOOK_WMI_CDDA_SUPPORTED_SIZE sizeof(BOOLEAN)
    #define REDBOOK_WMI_CDDA_SUPPORTED_ID 6

    // 
    BOOLEAN CDDAAccurate;
    #define REDBOOK_WMI_CDDA_ACCURATE_SIZE sizeof(BOOLEAN)
    #define REDBOOK_WMI_CDDA_ACCURATE_ID 7

    // 
    BOOLEAN Reserved1;
    #define REDBOOK_WMI_STD_DATA_Reserved1_SIZE sizeof(BOOLEAN)
    #define REDBOOK_WMI_STD_DATA_Reserved1_ID 8

} REDBOOK_WMI_STD_DATA, *PREDBOOK_WMI_STD_DATA;

#define REDBOOK_WMI_STD_DATA_SIZE (FIELD_OFFSET(REDBOOK_WMI_STD_DATA, Reserved1) + REDBOOK_WMI_STD_DATA_Reserved1_SIZE)

// MSRedbook_Performance - REDBOOK_WMI_PERF_DATA
#define GUID_REDBOOK_WMI_PERF_DATA \
    { 0xb90550e8,0xae0a,0x11d1, { 0xa5,0x71,0x00,0xc0,0x4f,0xa3,0x47,0x30 } }

#if ! (defined(MIDL_PASS))
DEFINE_GUID(MSRedbook_PerformanceGuid, \
            0xb90550e8,0xae0a,0x11d1,0xa5,0x71,0x00,0xc0,0x4f,0xa3,0x47,0x30);
#endif


typedef struct _REDBOOK_WMI_PERF_DATA
{
    // 
    LONGLONG TimeReadDelay;
    #define REDBOOK_WMI_PERF_TIME_READING_DELAY_SIZE sizeof(LONGLONG)
    #define REDBOOK_WMI_PERF_TIME_READING_DELAY_ID 1

    // 
    LONGLONG TimeReading;
    #define REDBOOK_WMI_PERF_TIME_READING_SIZE sizeof(LONGLONG)
    #define REDBOOK_WMI_PERF_TIME_READING_ID 2

    // 
    LONGLONG TimeStreamDelay;
    #define REDBOOK_WMI_PERF_TIME_STREAMING_DELAY_SIZE sizeof(LONGLONG)
    #define REDBOOK_WMI_PERF_TIME_STREAMING_DELAY_ID 3

    // 
    LONGLONG TimeStreaming;
    #define REDBOOK_WMI_PERF_TIME_STREAMING_SIZE sizeof(LONGLONG)
    #define REDBOOK_WMI_PERF_TIME_STREAMING_ID 4

    // 
    LONGLONG DataProcessed;
    #define REDBOOK_WMI_PERF_DATA_PROCESSED_SIZE sizeof(LONGLONG)
    #define REDBOOK_WMI_PERF_DATA_PROCESSED_ID 5

    // 
    ULONG StreamPausedCount;
    #define REDBOOK_WMI_PERF_STREAM_PAUSED_COUNT_SIZE sizeof(ULONG)
    #define REDBOOK_WMI_PERF_STREAM_PAUSED_COUNT_ID 6

} REDBOOK_WMI_PERF_DATA, *PREDBOOK_WMI_PERF_DATA;

#define REDBOOK_WMI_PERF_DATA_SIZE (FIELD_OFFSET(REDBOOK_WMI_PERF_DATA, StreamPausedCount) + REDBOOK_WMI_PERF_DATA_StreamPausedCount_SIZE)

// RegisteredGuids - RegisteredGuids
#define RegisteredGuidsGuid \
    { 0xe3dff7bd,0x3915,0x11d2, { 0x91,0x03,0x00,0xc0,0x4f,0xb9,0x98,0xa2 } }

#if ! (defined(MIDL_PASS))
DEFINE_GUID(RegisteredGuids_GUID, \
            0xe3dff7bd,0x3915,0x11d2,0x91,0x03,0x00,0xc0,0x4f,0xb9,0x98,0xa2);
#endif


typedef struct _RegisteredGuids
{
    // 
    ULONG GuidType;
    #define RegisteredGuids_GuidType_SIZE sizeof(ULONG)
    #define RegisteredGuids_GuidType_ID 1

    // 
    ULONG LoggerId;
    #define RegisteredGuids_LoggerId_SIZE sizeof(ULONG)
    #define RegisteredGuids_LoggerId_ID 2

    // 
    ULONG EnableLevel;
    #define RegisteredGuids_EnableLevel_SIZE sizeof(ULONG)
    #define RegisteredGuids_EnableLevel_ID 3

    // 
    ULONG EnableFlags;
    #define RegisteredGuids_EnableFlags_SIZE sizeof(ULONG)
    #define RegisteredGuids_EnableFlags_ID 4

    // 
    BOOLEAN IsEnabled;
    #define RegisteredGuids_IsEnabled_SIZE sizeof(BOOLEAN)
    #define RegisteredGuids_IsEnabled_ID 5

} RegisteredGuids, *PRegisteredGuids;

#define RegisteredGuids_SIZE (FIELD_OFFSET(RegisteredGuids, IsEnabled) + RegisteredGuids_IsEnabled_SIZE)

// MSTapeDriveParam - WMI_TAPE_DRIVE_PARAMETERS
#define WMI_TAPE_DRIVE_PARAMETERS_GUID \
    { 0xb9a8cfd5,0x8d72,0x47a4, { 0xac,0x0e,0x28,0x4a,0x32,0x00,0xf4,0xfb } }

#if ! (defined(MIDL_PASS))
DEFINE_GUID(MSTapeDriveParam_GUID, \
            0xb9a8cfd5,0x8d72,0x47a4,0xac,0x0e,0x28,0x4a,0x32,0x00,0xf4,0xfb);
#endif


typedef struct _WMI_TAPE_DRIVE_PARAMETERS
{
    // 
    ULONG MaximumBlockSize;
    #define WMI_TAPE_DRIVE_PARAMETERS_MaximumBlockSize_SIZE sizeof(ULONG)
    #define WMI_TAPE_DRIVE_PARAMETERS_MaximumBlockSize_ID 1

    // 
    ULONG MinimumBlockSize;
    #define WMI_TAPE_DRIVE_PARAMETERS_MinimumBlockSize_SIZE sizeof(ULONG)
    #define WMI_TAPE_DRIVE_PARAMETERS_MinimumBlockSize_ID 2

    // 
    ULONG DefaultBlockSize;
    #define WMI_TAPE_DRIVE_PARAMETERS_DefaultBlockSize_SIZE sizeof(ULONG)
    #define WMI_TAPE_DRIVE_PARAMETERS_DefaultBlockSize_ID 3

    // 
    ULONG MaximumPartitionCount;
    #define WMI_TAPE_DRIVE_PARAMETERS_MaximumPartitionCount_SIZE sizeof(ULONG)
    #define WMI_TAPE_DRIVE_PARAMETERS_MaximumPartitionCount_ID 4

    // 
    BOOLEAN CompressionCapable;
    #define WMI_TAPE_DRIVE_PARAMETERS_CompressionCapable_SIZE sizeof(BOOLEAN)
    #define WMI_TAPE_DRIVE_PARAMETERS_CompressionCapable_ID 5

    // 
    BOOLEAN CompressionEnabled;
    #define WMI_TAPE_DRIVE_PARAMETERS_CompressionEnabled_SIZE sizeof(BOOLEAN)
    #define WMI_TAPE_DRIVE_PARAMETERS_CompressionEnabled_ID 6

    // 
    BOOLEAN ReportSetmarks;
    #define WMI_TAPE_DRIVE_PARAMETERS_ReportSetmarks_SIZE sizeof(BOOLEAN)
    #define WMI_TAPE_DRIVE_PARAMETERS_ReportSetmarks_ID 7

    // 
    BOOLEAN HardwareErrorCorrection;
    #define WMI_TAPE_DRIVE_PARAMETERS_HardwareErrorCorrection_SIZE sizeof(BOOLEAN)
    #define WMI_TAPE_DRIVE_PARAMETERS_HardwareErrorCorrection_ID 8

} WMI_TAPE_DRIVE_PARAMETERS, *PWMI_TAPE_DRIVE_PARAMETERS;

#define WMI_TAPE_DRIVE_PARAMETERS_SIZE (FIELD_OFFSET(WMI_TAPE_DRIVE_PARAMETERS, HardwareErrorCorrection) + WMI_TAPE_DRIVE_PARAMETERS_HardwareErrorCorrection_SIZE)

// MSTapeMediaCapacity - WMI_TAPE_MEDIA_PARAMETERS
#define WMI_TAPE_MEDIA_PARAMETERS_GUID \
    { 0x8c2147a4,0xff29,0x4336, { 0xb8,0xa4,0x22,0x7b,0x54,0xcc,0x09,0x66 } }

#if ! (defined(MIDL_PASS))
DEFINE_GUID(MSTapeMediaCapacity_GUID, \
            0x8c2147a4,0xff29,0x4336,0xb8,0xa4,0x22,0x7b,0x54,0xcc,0x09,0x66);
#endif


typedef struct _WMI_TAPE_MEDIA_PARAMETERS
{
    // 
    ULONGLONG MaximumCapacity;
    #define WMI_TAPE_MEDIA_PARAMETERS_MaximumCapacity_SIZE sizeof(ULONGLONG)
    #define WMI_TAPE_MEDIA_PARAMETERS_MaximumCapacity_ID 1

    // 
    ULONGLONG AvailableCapacity;
    #define WMI_TAPE_MEDIA_PARAMETERS_AvailableCapacity_SIZE sizeof(ULONGLONG)
    #define WMI_TAPE_MEDIA_PARAMETERS_AvailableCapacity_ID 2

    // 
    ULONG BlockSize;
    #define WMI_TAPE_MEDIA_PARAMETERS_BlockSize_SIZE sizeof(ULONG)
    #define WMI_TAPE_MEDIA_PARAMETERS_BlockSize_ID 3

    // 
    ULONG PartitionCount;
    #define WMI_TAPE_MEDIA_PARAMETERS_PartitionCount_SIZE sizeof(ULONG)
    #define WMI_TAPE_MEDIA_PARAMETERS_PartitionCount_ID 4

    // 
    BOOLEAN MediaWriteProtected;
    #define WMI_TAPE_MEDIA_PARAMETERS_MediaWriteProtected_SIZE sizeof(BOOLEAN)
    #define WMI_TAPE_MEDIA_PARAMETERS_MediaWriteProtected_ID 5

} WMI_TAPE_MEDIA_PARAMETERS, *PWMI_TAPE_MEDIA_PARAMETERS;

#define WMI_TAPE_MEDIA_PARAMETERS_SIZE (FIELD_OFFSET(WMI_TAPE_MEDIA_PARAMETERS, MediaWriteProtected) + WMI_TAPE_MEDIA_PARAMETERS_MediaWriteProtected_SIZE)

// MSTapeSymbolicName - WMI_TAPE_SYMBOLIC_NAME
#define WMI_TAPE_SYMBOLIC_NAME_GUID \
    { 0x3fb828f7,0xf119,0x4066, { 0xb1,0xe6,0xdb,0x40,0x7c,0xe9,0xde,0x91 } }

#if ! (defined(MIDL_PASS))
DEFINE_GUID(MSTapeSymbolicName_GUID, \
            0x3fb828f7,0xf119,0x4066,0xb1,0xe6,0xdb,0x40,0x7c,0xe9,0xde,0x91);
#endif


typedef struct _WMI_TAPE_SYMBOLIC_NAME
{
    // 
    CHAR VariableData[1];
    #define WMI_TAPE_SYMBOLIC_NAME_TapeSymbolicName_ID 1

} WMI_TAPE_SYMBOLIC_NAME, *PWMI_TAPE_SYMBOLIC_NAME;

// MSTapeDriveProblemEvent - WMI_TAPE_PROBLEM_WARNING
#define WMI_TAPE_PROBLEM_WARNING_GUID \
    { 0xbc4dd36c,0xfa66,0x4080, { 0x87,0xa0,0x0c,0x59,0x22,0xeb,0x78,0x87 } }

#if ! (defined(MIDL_PASS))
DEFINE_GUID(MSTapeDriveProblemEvent_GUID, \
            0xbc4dd36c,0xfa66,0x4080,0x87,0xa0,0x0c,0x59,0x22,0xeb,0x78,0x87);
#endif


typedef struct _WMI_TAPE_PROBLEM_WARNING
{
    // 
    ULONG DriveProblemType;
    #define WMI_TAPE_PROBLEM_WARNING_DriveProblemType_SIZE sizeof(ULONG)
    #define WMI_TAPE_PROBLEM_WARNING_DriveProblemType_ID 1

    // 
    UCHAR TapeData[512];
    #define WMI_TAPE_PROBLEM_WARNING_TapeData_SIZE sizeof(UCHAR[512])
    #define WMI_TAPE_PROBLEM_WARNING_TapeData_ID 2

} WMI_TAPE_PROBLEM_WARNING, *PWMI_TAPE_PROBLEM_WARNING;

#define WMI_TAPE_PROBLEM_WARNING_SIZE (FIELD_OFFSET(WMI_TAPE_PROBLEM_WARNING, TapeData) + WMI_TAPE_PROBLEM_WARNING_TapeData_SIZE)

// MSTapeProblemIoError - WMI_TAPE_PROBLEM_IO_ERROR
#define WMI_TAPE_PROBLEM_IO_ERROR_GUID \
    { 0x58fd29f9,0xb516,0x40fd, { 0x87,0x1a,0x7e,0xe7,0x6d,0x5b,0xb5,0x3e } }

#if ! (defined(MIDL_PASS))
DEFINE_GUID(MSTapeProblemIoError_GUID, \
            0x58fd29f9,0xb516,0x40fd,0x87,0x1a,0x7e,0xe7,0x6d,0x5b,0xb5,0x3e);
#endif


typedef struct _WMI_TAPE_PROBLEM_IO_ERROR
{
    // 
    ULONG ReadCorrectedWithoutDelay;
    #define WMI_TAPE_PROBLEM_IO_ERROR_ReadCorrectedWithoutDelay_SIZE sizeof(ULONG)
    #define WMI_TAPE_PROBLEM_IO_ERROR_ReadCorrectedWithoutDelay_ID 1

    // 
    ULONG ReadCorrectedWithDelay;
    #define WMI_TAPE_PROBLEM_IO_ERROR_ReadCorrectedWithDelay_SIZE sizeof(ULONG)
    #define WMI_TAPE_PROBLEM_IO_ERROR_ReadCorrectedWithDelay_ID 2

    // 
    ULONG ReadTotalErrors;
    #define WMI_TAPE_PROBLEM_IO_ERROR_ReadTotalErrors_SIZE sizeof(ULONG)
    #define WMI_TAPE_PROBLEM_IO_ERROR_ReadTotalErrors_ID 3

    // 
    ULONG ReadTotalCorrectedErrors;
    #define WMI_TAPE_PROBLEM_IO_ERROR_ReadTotalCorrectedErrors_SIZE sizeof(ULONG)
    #define WMI_TAPE_PROBLEM_IO_ERROR_ReadTotalCorrectedErrors_ID 4

    // 
    ULONG ReadTotalUncorrectedErrors;
    #define WMI_TAPE_PROBLEM_IO_ERROR_ReadTotalUncorrectedErrors_SIZE sizeof(ULONG)
    #define WMI_TAPE_PROBLEM_IO_ERROR_ReadTotalUncorrectedErrors_ID 5

    // 
    ULONG ReadCorrectionAlgorithmProcessed;
    #define WMI_TAPE_PROBLEM_IO_ERROR_ReadCorrectionAlgorithmProcessed_SIZE sizeof(ULONG)
    #define WMI_TAPE_PROBLEM_IO_ERROR_ReadCorrectionAlgorithmProcessed_ID 6

    // 
    ULONG WriteCorrectedWithoutDelay;
    #define WMI_TAPE_PROBLEM_IO_ERROR_WriteCorrectedWithoutDelay_SIZE sizeof(ULONG)
    #define WMI_TAPE_PROBLEM_IO_ERROR_WriteCorrectedWithoutDelay_ID 7

    // 
    ULONG WriteCorrectedWithDelay;
    #define WMI_TAPE_PROBLEM_IO_ERROR_WriteCorrectedWithDelay_SIZE sizeof(ULONG)
    #define WMI_TAPE_PROBLEM_IO_ERROR_WriteCorrectedWithDelay_ID 8

    // 
    ULONG WriteTotalErrors;
    #define WMI_TAPE_PROBLEM_IO_ERROR_WriteTotalErrors_SIZE sizeof(ULONG)
    #define WMI_TAPE_PROBLEM_IO_ERROR_WriteTotalErrors_ID 9

    // 
    ULONG WriteTotalCorrectedErrors;
    #define WMI_TAPE_PROBLEM_IO_ERROR_WriteTotalCorrectedErrors_SIZE sizeof(ULONG)
    #define WMI_TAPE_PROBLEM_IO_ERROR_WriteTotalCorrectedErrors_ID 10

    // 
    ULONG WriteTotalUncorrectedErrors;
    #define WMI_TAPE_PROBLEM_IO_ERROR_WriteTotalUncorrectedErrors_SIZE sizeof(ULONG)
    #define WMI_TAPE_PROBLEM_IO_ERROR_WriteTotalUncorrectedErrors_ID 11

    // 
    ULONG WriteCorrectionAlgorithmProcessed;
    #define WMI_TAPE_PROBLEM_IO_ERROR_WriteCorrectionAlgorithmProcessed_SIZE sizeof(ULONG)
    #define WMI_TAPE_PROBLEM_IO_ERROR_WriteCorrectionAlgorithmProcessed_ID 12

    // 
    ULONG NonMediumErrors;
    #define WMI_TAPE_PROBLEM_IO_ERROR_NonMediumErrors_SIZE sizeof(ULONG)
    #define WMI_TAPE_PROBLEM_IO_ERROR_NonMediumErrors_ID 13

} WMI_TAPE_PROBLEM_IO_ERROR, *PWMI_TAPE_PROBLEM_IO_ERROR;

#define WMI_TAPE_PROBLEM_IO_ERROR_SIZE (FIELD_OFFSET(WMI_TAPE_PROBLEM_IO_ERROR, NonMediumErrors) + WMI_TAPE_PROBLEM_IO_ERROR_NonMediumErrors_SIZE)

// MSTapeProblemDeviceError - WMI_TAPE_PROBLEM_DEVICE_ERROR
#define WMI_TAPE_PROBLEM_DEVICE_ERROR_GUID \
    { 0x43ec6b13,0x10bb,0x4bf6, { 0xb7,0x16,0x1c,0x1e,0x2f,0x10,0xbb,0x5f } }

#if ! (defined(MIDL_PASS))
DEFINE_GUID(MSTapeProblemDeviceError_GUID, \
            0x43ec6b13,0x10bb,0x4bf6,0xb7,0x16,0x1c,0x1e,0x2f,0x10,0xbb,0x5f);
#endif


typedef struct _WMI_TAPE_PROBLEM_DEVICE_ERROR
{
    // 
    BOOLEAN ReadWarning;
    #define WMI_TAPE_PROBLEM_DEVICE_ERROR_ReadWarning_SIZE sizeof(BOOLEAN)
    #define WMI_TAPE_PROBLEM_DEVICE_ERROR_ReadWarning_ID 1

    // 
    BOOLEAN WriteWarning;
    #define WMI_TAPE_PROBLEM_DEVICE_ERROR_WriteWarning_SIZE sizeof(BOOLEAN)
    #define WMI_TAPE_PROBLEM_DEVICE_ERROR_WriteWarning_ID 2

    // 
    BOOLEAN HardError;
    #define WMI_TAPE_PROBLEM_DEVICE_ERROR_HardError_SIZE sizeof(BOOLEAN)
    #define WMI_TAPE_PROBLEM_DEVICE_ERROR_HardError_ID 3

    // 
    BOOLEAN ReadFailure;
    #define WMI_TAPE_PROBLEM_DEVICE_ERROR_ReadFailure_SIZE sizeof(BOOLEAN)
    #define WMI_TAPE_PROBLEM_DEVICE_ERROR_ReadFailure_ID 4

    // 
    BOOLEAN WriteFailure;
    #define WMI_TAPE_PROBLEM_DEVICE_ERROR_WriteFailure_SIZE sizeof(BOOLEAN)
    #define WMI_TAPE_PROBLEM_DEVICE_ERROR_WriteFailure_ID 5

    // 
    BOOLEAN UnsupportedFormat;
    #define WMI_TAPE_PROBLEM_DEVICE_ERROR_UnsupportedFormat_SIZE sizeof(BOOLEAN)
    #define WMI_TAPE_PROBLEM_DEVICE_ERROR_UnsupportedFormat_ID 6

    // 
    BOOLEAN TapeSnapped;
    #define WMI_TAPE_PROBLEM_DEVICE_ERROR_TapeSnapped_SIZE sizeof(BOOLEAN)
    #define WMI_TAPE_PROBLEM_DEVICE_ERROR_TapeSnapped_ID 7

    // 
    BOOLEAN DriveRequiresCleaning;
    #define WMI_TAPE_PROBLEM_DEVICE_ERROR_DriveRequiresCleaning_SIZE sizeof(BOOLEAN)
    #define WMI_TAPE_PROBLEM_DEVICE_ERROR_DriveRequiresCleaning_ID 8

    // 
    BOOLEAN TimetoCleanDrive;
    #define WMI_TAPE_PROBLEM_DEVICE_ERROR_TimetoCleanDrive_SIZE sizeof(BOOLEAN)
    #define WMI_TAPE_PROBLEM_DEVICE_ERROR_TimetoCleanDrive_ID 9

    // 
    BOOLEAN DriveHardwareError;
    #define WMI_TAPE_PROBLEM_DEVICE_ERROR_DriveHardwareError_SIZE sizeof(BOOLEAN)
    #define WMI_TAPE_PROBLEM_DEVICE_ERROR_DriveHardwareError_ID 10

    // 
    BOOLEAN ScsiInterfaceError;
    #define WMI_TAPE_PROBLEM_DEVICE_ERROR_ScsiInterfaceError_SIZE sizeof(BOOLEAN)
    #define WMI_TAPE_PROBLEM_DEVICE_ERROR_ScsiInterfaceError_ID 11

    // 
    BOOLEAN MediaLife;
    #define WMI_TAPE_PROBLEM_DEVICE_ERROR_MediaLife_SIZE sizeof(BOOLEAN)
    #define WMI_TAPE_PROBLEM_DEVICE_ERROR_MediaLife_ID 12

} WMI_TAPE_PROBLEM_DEVICE_ERROR, *PWMI_TAPE_PROBLEM_DEVICE_ERROR;

#define WMI_TAPE_PROBLEM_DEVICE_ERROR_SIZE (FIELD_OFFSET(WMI_TAPE_PROBLEM_DEVICE_ERROR, MediaLife) + WMI_TAPE_PROBLEM_DEVICE_ERROR_MediaLife_SIZE)

// MSChangerParameters - WMI_CHANGER_PARAMETERS
#define WMI_CHANGER_PARAMETERS_GUID \
    { 0x24eb52ac,0x7c77,0x438b, { 0xab,0x61,0xd0,0x24,0xda,0xb0,0xc0,0x3a } }

#if ! (defined(MIDL_PASS))
DEFINE_GUID(MSChangerParameters_GUID, \
            0x24eb52ac,0x7c77,0x438b,0xab,0x61,0xd0,0x24,0xda,0xb0,0xc0,0x3a);
#endif


typedef struct _WMI_CHANGER_PARAMETERS
{
    // 
    ULONG NumberOfSlots;
    #define WMI_CHANGER_PARAMETERS_NumberOfSlots_SIZE sizeof(ULONG)
    #define WMI_CHANGER_PARAMETERS_NumberOfSlots_ID 1

    // 
    ULONG NumberOfDrives;
    #define WMI_CHANGER_PARAMETERS_NumberOfDrives_SIZE sizeof(ULONG)
    #define WMI_CHANGER_PARAMETERS_NumberOfDrives_ID 2

    // 
    ULONG NumberOfIEPorts;
    #define WMI_CHANGER_PARAMETERS_NumberOfIEPorts_SIZE sizeof(ULONG)
    #define WMI_CHANGER_PARAMETERS_NumberOfIEPorts_ID 3

    // 
    ULONG NumberOfTransports;
    #define WMI_CHANGER_PARAMETERS_NumberOfTransports_SIZE sizeof(ULONG)
    #define WMI_CHANGER_PARAMETERS_NumberOfTransports_ID 4

    // 
    ULONG NumberOfDoors;
    #define WMI_CHANGER_PARAMETERS_NumberOfDoors_SIZE sizeof(ULONG)
    #define WMI_CHANGER_PARAMETERS_NumberOfDoors_ID 5

    // 
    ULONG NumberOfCleanerSlots;
    #define WMI_CHANGER_PARAMETERS_NumberOfCleanerSlots_SIZE sizeof(ULONG)
    #define WMI_CHANGER_PARAMETERS_NumberOfCleanerSlots_ID 6

    // 
    ULONG MagazineSize;
    #define WMI_CHANGER_PARAMETERS_MagazineSize_SIZE sizeof(ULONG)
    #define WMI_CHANGER_PARAMETERS_MagazineSize_ID 7

} WMI_CHANGER_PARAMETERS, *PWMI_CHANGER_PARAMETERS;

#define WMI_CHANGER_PARAMETERS_SIZE (FIELD_OFFSET(WMI_CHANGER_PARAMETERS, MagazineSize) + WMI_CHANGER_PARAMETERS_MagazineSize_SIZE)

// MSChangerProblemEvent - WMI_CHANGER_PROBLEM_WARNING
#define WMI_CHANGER_PROBLEM_WARNING_GUID \
    { 0x45db06a5,0x20d5,0x4de3, { 0xa3,0x6c,0x3a,0xb9,0x74,0x60,0x0a,0x4c } }

#if ! (defined(MIDL_PASS))
DEFINE_GUID(MSChangerProblemEvent_GUID, \
            0x45db06a5,0x20d5,0x4de3,0xa3,0x6c,0x3a,0xb9,0x74,0x60,0x0a,0x4c);
#endif


typedef struct _WMI_CHANGER_PROBLEM_WARNING
{
    // 
    ULONG ChangerProblemType;
    #define WMI_CHANGER_PROBLEM_WARNING_ChangerProblemType_SIZE sizeof(ULONG)
    #define WMI_CHANGER_PROBLEM_WARNING_ChangerProblemType_ID 1

    // 
    UCHAR ChangerData[512];
    #define WMI_CHANGER_PROBLEM_WARNING_ChangerData_SIZE sizeof(UCHAR[512])
    #define WMI_CHANGER_PROBLEM_WARNING_ChangerData_ID 2

} WMI_CHANGER_PROBLEM_WARNING, *PWMI_CHANGER_PROBLEM_WARNING;

#define WMI_CHANGER_PROBLEM_WARNING_SIZE (FIELD_OFFSET(WMI_CHANGER_PROBLEM_WARNING, ChangerData) + WMI_CHANGER_PROBLEM_WARNING_ChangerData_SIZE)

// MSChangerProblemDeviceError - WMI_CHANGER_PROBLEM_DEVICE_ERROR
#define WMI_CHANGER_PROBLEM_DEVICE_ERROR_GUID \
    { 0x56b396a8,0x0b95,0x42fe, { 0xbb,0xce,0xd3,0x6f,0xda,0x90,0x4f,0x8e } }

#if ! (defined(MIDL_PASS))
DEFINE_GUID(MSChangerProblemDeviceError_GUID, \
            0x56b396a8,0x0b95,0x42fe,0xbb,0xce,0xd3,0x6f,0xda,0x90,0x4f,0x8e);
#endif


typedef struct _WMI_CHANGER_PROBLEM_DEVICE_ERROR
{
    // 
    ULONG ChangerProblemType;
    #define WMI_CHANGER_PROBLEM_DEVICE_ERROR_ChangerProblemType_SIZE sizeof(ULONG)
    #define WMI_CHANGER_PROBLEM_DEVICE_ERROR_ChangerProblemType_ID 1

} WMI_CHANGER_PROBLEM_DEVICE_ERROR, *PWMI_CHANGER_PROBLEM_DEVICE_ERROR;

#define WMI_CHANGER_PROBLEM_DEVICE_ERROR_SIZE (FIELD_OFFSET(WMI_CHANGER_PROBLEM_DEVICE_ERROR, ChangerProblemType) + WMI_CHANGER_PROBLEM_DEVICE_ERROR_ChangerProblemType_SIZE)

// MSDeviceUI_FirmwareRevision - DEVICE_UI_FIRMWARE_REVISION
#define DEVICE_UI_FIRMWARE_REVISION_GUID \
    { 0x4504b1d4,0xc5ee,0x4df6, { 0x95,0x1f,0x16,0x18,0x0e,0x3d,0xd8,0x15 } }

#if ! (defined(MIDL_PASS))
DEFINE_GUID(MSDeviceUI_FirmwareRevision_GUID, \
            0x4504b1d4,0xc5ee,0x4df6,0x95,0x1f,0x16,0x18,0x0e,0x3d,0xd8,0x15);
#endif


typedef struct _DEVICE_UI_FIRMWARE_REVISION
{
    // 
    CHAR VariableData[1];
    #define DEVICE_UI_FIRMWARE_REVISION_FirmwareRevision_ID 1

} DEVICE_UI_FIRMWARE_REVISION, *PDEVICE_UI_FIRMWARE_REVISION;

// MSVerifierIrpLogEntry - MSVerifierIrpLogEntry
#define MSVerifierIrpLogEntryGuid \
    { 0x45068237,0x595d,0x4c7d, { 0xbd,0x80,0xf8,0x4a,0xdc,0x02,0x57,0xf8 } }

#if ! (defined(MIDL_PASS))
DEFINE_GUID(MSVerifierIrpLogEntry_GUID, \
            0x45068237,0x595d,0x4c7d,0xbd,0x80,0xf8,0x4a,0xdc,0x02,0x57,0xf8);
#endif


typedef struct _MSVerifierIrpLogEntry
{
    // Count
    ULONG Count;
    #define MSVerifierIrpLogEntry_Count_SIZE sizeof(ULONG)
    #define MSVerifierIrpLogEntry_Count_ID 1

    // Major Function
    UCHAR Major;
    #define MSVerifierIrpLogEntry_Major_SIZE sizeof(UCHAR)
    #define MSVerifierIrpLogEntry_Major_ID 2

    // Minor Function
    UCHAR Minor;
    #define MSVerifierIrpLogEntry_Minor_SIZE sizeof(UCHAR)
    #define MSVerifierIrpLogEntry_Minor_ID 3

    // Flags
    UCHAR Flags;
    #define MSVerifierIrpLogEntry_Flags_SIZE sizeof(UCHAR)
    #define MSVerifierIrpLogEntry_Flags_ID 4

    // Control
    UCHAR Control;
    #define MSVerifierIrpLogEntry_Control_SIZE sizeof(UCHAR)
    #define MSVerifierIrpLogEntry_Control_ID 5

    // Arg1
    ULONGLONG Arg1;
    #define MSVerifierIrpLogEntry_Arg1_SIZE sizeof(ULONGLONG)
    #define MSVerifierIrpLogEntry_Arg1_ID 6

    // Arg2
    ULONGLONG Arg2;
    #define MSVerifierIrpLogEntry_Arg2_SIZE sizeof(ULONGLONG)
    #define MSVerifierIrpLogEntry_Arg2_ID 7

    // Arg3
    ULONGLONG Arg3;
    #define MSVerifierIrpLogEntry_Arg3_SIZE sizeof(ULONGLONG)
    #define MSVerifierIrpLogEntry_Arg3_ID 8

    // Arg4
    ULONGLONG Arg4;
    #define MSVerifierIrpLogEntry_Arg4_SIZE sizeof(ULONGLONG)
    #define MSVerifierIrpLogEntry_Arg4_ID 9

} MSVerifierIrpLogEntry, *PMSVerifierIrpLogEntry;

#define MSVerifierIrpLogEntry_SIZE (FIELD_OFFSET(MSVerifierIrpLogEntry, Arg4) + MSVerifierIrpLogEntry_Arg4_SIZE)

// MSVerifierIrpLogInformation - MSVerifierIrpLogInformation
// Verifier kernel information
#define MSVerifierIrpLogInformationGuid \
    { 0x1e2c2980,0xf7db,0x46aa, { 0x82,0x0e,0x87,0x34,0xfc,0xc2,0x1f,0x4c } }

#if ! (defined(MIDL_PASS))
DEFINE_GUID(MSVerifierIrpLogInformation_GUID, \
            0x1e2c2980,0xf7db,0x46aa,0x82,0x0e,0x87,0x34,0xfc,0xc2,0x1f,0x4c);
#endif


typedef struct _MSVerifierIrpLogInformation
{
    // DeviceType
    ULONG DeviceType;
    #define MSVerifierIrpLogInformation_DeviceType_SIZE sizeof(ULONG)
    #define MSVerifierIrpLogInformation_DeviceType_ID 1

    // 
    ULONG EntryCount;
    #define MSVerifierIrpLogInformation_EntryCount_SIZE sizeof(ULONG)
    #define MSVerifierIrpLogInformation_EntryCount_ID 2

    // 
    MSVerifierIrpLogEntry Entries[1];
    #define MSVerifierIrpLogInformation_Entries_ID 3

} MSVerifierIrpLogInformation, *PMSVerifierIrpLogInformation;

// WmiMonitorBrightness - WmiMonitorBrightness
#define WmiMonitorBrightnessGuid \
    { 0xd43412ac,0x67f9,0x4fbb, { 0xa0,0x81,0x17,0x52,0xa2,0xc3,0x3e,0x84 } }

#if ! (defined(MIDL_PASS))
DEFINE_GUID(WmiMonitorBrightness_GUID, \
            0xd43412ac,0x67f9,0x4fbb,0xa0,0x81,0x17,0x52,0xa2,0xc3,0x3e,0x84);
#endif


typedef struct _WmiMonitorBrightness
{
    // 
    UCHAR CurrentBrightness;
    #define WmiMonitorBrightness_CurrentBrightness_SIZE sizeof(UCHAR)
    #define WmiMonitorBrightness_CurrentBrightness_ID 1

    // 
    ULONG Levels;
    #define WmiMonitorBrightness_Levels_SIZE sizeof(ULONG)
    #define WmiMonitorBrightness_Levels_ID 2

    // 
    UCHAR Level[1];
    #define WmiMonitorBrightness_Level_ID 3

} WmiMonitorBrightness, *PWmiMonitorBrightness;

// WmiMonitorBrightnessMethods - WmiMonitorBrightnessMethods
#define WmiMonitorBrightnessMethodsGuid \
    { 0x479b20b4,0x5559,0x46fe, { 0xbe,0x97,0x7d,0x22,0x21,0x54,0x42,0x1f } }

#if ! (defined(MIDL_PASS))
DEFINE_GUID(WmiMonitorBrightnessMethods_GUID, \
            0x479b20b4,0x5559,0x46fe,0xbe,0x97,0x7d,0x22,0x21,0x54,0x42,0x1f);
#endif

//
// Method id definitions for WmiMonitorBrightnessMethods
#define WmiSetBrightness     1
typedef struct _WmiSetBrightness_IN
{
    // 
    ULONG Timeout;
    #define WmiSetBrightness_IN_Timeout_SIZE sizeof(ULONG)
    #define WmiSetBrightness_IN_Timeout_ID 1

    // 
    UCHAR Brightness;
    #define WmiSetBrightness_IN_Brightness_SIZE sizeof(UCHAR)
    #define WmiSetBrightness_IN_Brightness_ID 2

} WmiSetBrightness_IN, *PWmiSetBrightness_IN;

#define WmiSetBrightness_IN_SIZE (FIELD_OFFSET(WmiSetBrightness_IN, Brightness) + WmiSetBrightness_IN_Brightness_SIZE)

#define WmiRevertToPolicyBrightness     2
#define WmiSetALSBrightnessState     3
typedef struct _WmiSetALSBrightnessState_IN
{
    // 
    BOOLEAN State;
    #define WmiSetALSBrightnessState_IN_State_SIZE sizeof(BOOLEAN)
    #define WmiSetALSBrightnessState_IN_State_ID 1

} WmiSetALSBrightnessState_IN, *PWmiSetALSBrightnessState_IN;

#define WmiSetALSBrightnessState_IN_SIZE (FIELD_OFFSET(WmiSetALSBrightnessState_IN, State) + WmiSetALSBrightnessState_IN_State_SIZE)

#define WmiSetALSBrightness     4
typedef struct _WmiSetALSBrightness_IN
{
    // 
    UCHAR Brightness;
    #define WmiSetALSBrightness_IN_Brightness_SIZE sizeof(UCHAR)
    #define WmiSetALSBrightness_IN_Brightness_ID 1

} WmiSetALSBrightness_IN, *PWmiSetALSBrightness_IN;

#define WmiSetALSBrightness_IN_SIZE (FIELD_OFFSET(WmiSetALSBrightness_IN, Brightness) + WmiSetALSBrightness_IN_Brightness_SIZE)


// WmiMonitorBrightnessEvent - WmiMonitorBrightnessEvent
// Monitor brightness change event
#define WmiMonitorBrightnessEventGuid \
    { 0x123c80d2,0x937f,0x4cfe, { 0x80,0xf4,0xc4,0x0d,0x59,0x6e,0x48,0xb7 } }

#if ! (defined(MIDL_PASS))
DEFINE_GUID(WmiMonitorBrightnessEvent_GUID, \
            0x123c80d2,0x937f,0x4cfe,0x80,0xf4,0xc4,0x0d,0x59,0x6e,0x48,0xb7);
#endif


typedef struct _WmiMonitorBrightnessEvent
{
    // 
    UCHAR Brightness;
    #define WmiMonitorBrightnessEvent_Brightness_SIZE sizeof(UCHAR)
    #define WmiMonitorBrightnessEvent_Brightness_ID 1

} WmiMonitorBrightnessEvent, *PWmiMonitorBrightnessEvent;

#define WmiMonitorBrightnessEvent_SIZE (FIELD_OFFSET(WmiMonitorBrightnessEvent, Brightness) + WmiMonitorBrightnessEvent_Brightness_SIZE)

// WmiMonitorRawEEdidV1Block - WmiMonitorRawEEdidV1Block
#define WmiMonitorRawEEdidV1BlockGuid \
    { 0xfaee1471,0x5149,0x4a68, { 0xac,0x2c,0xbf,0x96,0xec,0x09,0xf0,0x04 } }

#if ! (defined(MIDL_PASS))
DEFINE_GUID(WmiMonitorRawEEdidV1Block_GUID, \
            0xfaee1471,0x5149,0x4a68,0xac,0x2c,0xbf,0x96,0xec,0x09,0xf0,0x04);
#endif


typedef struct _WmiMonitorRawEEdidV1Block
{
    // 
    UCHAR Id;
    #define WmiMonitorRawEEdidV1Block_Id_SIZE sizeof(UCHAR)
    #define WmiMonitorRawEEdidV1Block_Id_ID 1

    // 
    UCHAR Type;
    #define WmiMonitorRawEEdidV1Block_Type_SIZE sizeof(UCHAR)
    #define WmiMonitorRawEEdidV1Block_Type_ID 2

    // 
    UCHAR Content[128];
    #define WmiMonitorRawEEdidV1Block_Content_SIZE sizeof(UCHAR[128])
    #define WmiMonitorRawEEdidV1Block_Content_ID 3

} WmiMonitorRawEEdidV1Block, *PWmiMonitorRawEEdidV1Block;

#define WmiMonitorRawEEdidV1Block_SIZE (FIELD_OFFSET(WmiMonitorRawEEdidV1Block, Content) + WmiMonitorRawEEdidV1Block_Content_SIZE)

// WmiMonitorDescriptorMethods - WmiMonitorDescriptorMethods
#define WmiMonitorDescriptorMethodsGuid \
    { 0x5341576e,0x75c4,0x4aeb, { 0xa8,0x2b,0x87,0x3c,0xd3,0xc6,0xb3,0x84 } }

#if ! (defined(MIDL_PASS))
DEFINE_GUID(WmiMonitorDescriptorMethods_GUID, \
            0x5341576e,0x75c4,0x4aeb,0xa8,0x2b,0x87,0x3c,0xd3,0xc6,0xb3,0x84);
#endif

//
// Method id definitions for WmiMonitorDescriptorMethods
#define WmiGetMonitorRawEEdidV1Block     1
typedef struct _WmiGetMonitorRawEEdidV1Block_IN
{
    // 
    UCHAR BlockId;
    #define WmiGetMonitorRawEEdidV1Block_IN_BlockId_SIZE sizeof(UCHAR)
    #define WmiGetMonitorRawEEdidV1Block_IN_BlockId_ID 1

} WmiGetMonitorRawEEdidV1Block_IN, *PWmiGetMonitorRawEEdidV1Block_IN;

#define WmiGetMonitorRawEEdidV1Block_IN_SIZE (FIELD_OFFSET(WmiGetMonitorRawEEdidV1Block_IN, BlockId) + WmiGetMonitorRawEEdidV1Block_IN_BlockId_SIZE)

typedef struct _WmiGetMonitorRawEEdidV1Block_OUT
{
    // 
    UCHAR BlockType;
    #define WmiGetMonitorRawEEdidV1Block_OUT_BlockType_SIZE sizeof(UCHAR)
    #define WmiGetMonitorRawEEdidV1Block_OUT_BlockType_ID 2

    // 
    UCHAR BlockContent[128];
    #define WmiGetMonitorRawEEdidV1Block_OUT_BlockContent_SIZE sizeof(UCHAR[128])
    #define WmiGetMonitorRawEEdidV1Block_OUT_BlockContent_ID 3

} WmiGetMonitorRawEEdidV1Block_OUT, *PWmiGetMonitorRawEEdidV1Block_OUT;

#define WmiGetMonitorRawEEdidV1Block_OUT_SIZE (FIELD_OFFSET(WmiGetMonitorRawEEdidV1Block_OUT, BlockContent) + WmiGetMonitorRawEEdidV1Block_OUT_BlockContent_SIZE)


// WmiMonitorID - WmiMonitorID
#define WmiMonitorIDGuid \
    { 0x671a8285,0x4edb,0x4cae, { 0x99,0xfe,0x69,0xa1,0x5c,0x48,0xc0,0xbc } }

#if ! (defined(MIDL_PASS))
DEFINE_GUID(WmiMonitorID_GUID, \
            0x671a8285,0x4edb,0x4cae,0x99,0xfe,0x69,0xa1,0x5c,0x48,0xc0,0xbc);
#endif


typedef struct _WmiMonitorID
{
    // 
    USHORT ProductCodeID[16];
    #define WmiMonitorID_ProductCodeID_SIZE sizeof(USHORT[16])
    #define WmiMonitorID_ProductCodeID_ID 1

    // 
    USHORT SerialNumberID[16];
    #define WmiMonitorID_SerialNumberID_SIZE sizeof(USHORT[16])
    #define WmiMonitorID_SerialNumberID_ID 2

    // 
    USHORT ManufacturerName[16];
    #define WmiMonitorID_ManufacturerName_SIZE sizeof(USHORT[16])
    #define WmiMonitorID_ManufacturerName_ID 3

    // 
    UCHAR WeekOfManufacture;
    #define WmiMonitorID_WeekOfManufacture_SIZE sizeof(UCHAR)
    #define WmiMonitorID_WeekOfManufacture_ID 4

    // 
    USHORT YearOfManufacture;
    #define WmiMonitorID_YearOfManufacture_SIZE sizeof(USHORT)
    #define WmiMonitorID_YearOfManufacture_ID 5

    // 
    USHORT UserFriendlyNameLength;
    #define WmiMonitorID_UserFriendlyNameLength_SIZE sizeof(USHORT)
    #define WmiMonitorID_UserFriendlyNameLength_ID 6

    // 
    USHORT UserFriendlyName[1];
    #define WmiMonitorID_UserFriendlyName_ID 7

} WmiMonitorID, *PWmiMonitorID;

// WmiMonitorSupportedDisplayFeatures - WmiMonitorSupportedDisplayFeatures
#define WmiMonitorSupportedDisplayFeaturesGuid \
    { 0x9fa9c28b,0x5e5c,0x4035, { 0xa5,0xf8,0x67,0xd4,0x55,0x4f,0x8d,0x04 } }

#if ! (defined(MIDL_PASS))
DEFINE_GUID(WmiMonitorSupportedDisplayFeatures_GUID, \
            0x9fa9c28b,0x5e5c,0x4035,0xa5,0xf8,0x67,0xd4,0x55,0x4f,0x8d,0x04);
#endif


typedef struct _WmiMonitorSupportedDisplayFeatures
{
    // 
    BOOLEAN StandbySupported;
    #define WmiMonitorSupportedDisplayFeatures_StandbySupported_SIZE sizeof(BOOLEAN)
    #define WmiMonitorSupportedDisplayFeatures_StandbySupported_ID 1

    // 
    BOOLEAN SuspendSupported;
    #define WmiMonitorSupportedDisplayFeatures_SuspendSupported_SIZE sizeof(BOOLEAN)
    #define WmiMonitorSupportedDisplayFeatures_SuspendSupported_ID 2

    // 
    BOOLEAN ActiveOffSupported;
    #define WmiMonitorSupportedDisplayFeatures_ActiveOffSupported_SIZE sizeof(BOOLEAN)
    #define WmiMonitorSupportedDisplayFeatures_ActiveOffSupported_ID 3

    // 
    UCHAR DisplayType;
    #define WmiMonitorSupportedDisplayFeatures_DisplayType_SIZE sizeof(UCHAR)
    #define WmiMonitorSupportedDisplayFeatures_DisplayType_ID 4

    // 
    BOOLEAN sRGBSupported;
    #define WmiMonitorSupportedDisplayFeatures_sRGBSupported_SIZE sizeof(BOOLEAN)
    #define WmiMonitorSupportedDisplayFeatures_sRGBSupported_ID 5

    // 
    BOOLEAN HasPreferredTimingMode;
    #define WmiMonitorSupportedDisplayFeatures_HasPreferredTimingMode_SIZE sizeof(BOOLEAN)
    #define WmiMonitorSupportedDisplayFeatures_HasPreferredTimingMode_ID 6

    // 
    BOOLEAN GTFSupported;
    #define WmiMonitorSupportedDisplayFeatures_GTFSupported_SIZE sizeof(BOOLEAN)
    #define WmiMonitorSupportedDisplayFeatures_GTFSupported_ID 7

} WmiMonitorSupportedDisplayFeatures, *PWmiMonitorSupportedDisplayFeatures;

#define WmiMonitorSupportedDisplayFeatures_SIZE (FIELD_OFFSET(WmiMonitorSupportedDisplayFeatures, GTFSupported) + WmiMonitorSupportedDisplayFeatures_GTFSupported_SIZE)

// WmiMonitorBasicDisplayParams - WmiMonitorBasicDisplayParams
#define WmiMonitorBasicDisplayParamsGuid \
    { 0x9831b7e6,0x09ac,0x491f, { 0x8d,0x07,0x3c,0x3d,0x64,0x9d,0x82,0x40 } }

#if ! (defined(MIDL_PASS))
DEFINE_GUID(WmiMonitorBasicDisplayParams_GUID, \
            0x9831b7e6,0x09ac,0x491f,0x8d,0x07,0x3c,0x3d,0x64,0x9d,0x82,0x40);
#endif


typedef struct _WmiMonitorBasicDisplayParams
{
    // 
    UCHAR VideoInputType;
    #define WmiMonitorBasicDisplayParams_VideoInputType_SIZE sizeof(UCHAR)
    #define WmiMonitorBasicDisplayParams_VideoInputType_ID 1

    // 
    UCHAR MaxHorizontalImageSize;
    #define WmiMonitorBasicDisplayParams_MaxHorizontalImageSize_SIZE sizeof(UCHAR)
    #define WmiMonitorBasicDisplayParams_MaxHorizontalImageSize_ID 2

    // 
    UCHAR MaxVerticalImageSize;
    #define WmiMonitorBasicDisplayParams_MaxVerticalImageSize_SIZE sizeof(UCHAR)
    #define WmiMonitorBasicDisplayParams_MaxVerticalImageSize_ID 3

    // 
    UCHAR DisplayTransferCharacteristic;
    #define WmiMonitorBasicDisplayParams_DisplayTransferCharacteristic_SIZE sizeof(UCHAR)
    #define WmiMonitorBasicDisplayParams_DisplayTransferCharacteristic_ID 4

    // 
    WmiMonitorSupportedDisplayFeatures SupportedDisplayFeatures;
    #define WmiMonitorBasicDisplayParams_SupportedDisplayFeatures_SIZE sizeof(WmiMonitorSupportedDisplayFeatures)
    #define WmiMonitorBasicDisplayParams_SupportedDisplayFeatures_ID 5

} WmiMonitorBasicDisplayParams, *PWmiMonitorBasicDisplayParams;

#define WmiMonitorBasicDisplayParams_SIZE (FIELD_OFFSET(WmiMonitorBasicDisplayParams, SupportedDisplayFeatures) + WmiMonitorBasicDisplayParams_SupportedDisplayFeatures_SIZE)

// WmiMonitorConnectionParams - WmiMonitorConnectionParams
#define WmiMonitorConnectionParamsGuid \
    { 0x2e2d2463,0xb537,0x4da7, { 0x8e,0xee,0x51,0x30,0x6f,0x1f,0x48,0x2f } }

#if ! (defined(MIDL_PASS))
DEFINE_GUID(WmiMonitorConnectionParams_GUID, \
            0x2e2d2463,0xb537,0x4da7,0x8e,0xee,0x51,0x30,0x6f,0x1f,0x48,0x2f);
#endif


typedef struct _WmiMonitorConnectionParams
{
    // 
    ULONG VideoOutputTechnology;
    #define WmiMonitorConnectionParams_VideoOutputTechnology_SIZE sizeof(ULONG)
    #define WmiMonitorConnectionParams_VideoOutputTechnology_ID 1

} WmiMonitorConnectionParams, *PWmiMonitorConnectionParams;

#define WmiMonitorConnectionParams_SIZE (FIELD_OFFSET(WmiMonitorConnectionParams, VideoOutputTechnology) + WmiMonitorConnectionParams_VideoOutputTechnology_SIZE)

// WmiMonitorAnalogVideoInputParams - WmiMonitorAnalogVideoInputParams
#define WmiMonitorAnalogVideoInputParamsGuid \
    { 0xa56dbcf9,0xc4f0,0x44a8, { 0x9c,0x1b,0xbb,0x3b,0x3f,0x77,0x4b,0x4d } }

#if ! (defined(MIDL_PASS))
DEFINE_GUID(WmiMonitorAnalogVideoInputParams_GUID, \
            0xa56dbcf9,0xc4f0,0x44a8,0x9c,0x1b,0xbb,0x3b,0x3f,0x77,0x4b,0x4d);
#endif


typedef struct _WmiMonitorAnalogVideoInputParams
{
    // 
    UCHAR SignalLevelStandard;
    #define WmiMonitorAnalogVideoInputParams_SignalLevelStandard_SIZE sizeof(UCHAR)
    #define WmiMonitorAnalogVideoInputParams_SignalLevelStandard_ID 1

    // 
    UCHAR SetupExpected;
    #define WmiMonitorAnalogVideoInputParams_SetupExpected_SIZE sizeof(UCHAR)
    #define WmiMonitorAnalogVideoInputParams_SetupExpected_ID 2

    // 
    UCHAR SeparateSyncsSupported;
    #define WmiMonitorAnalogVideoInputParams_SeparateSyncsSupported_SIZE sizeof(UCHAR)
    #define WmiMonitorAnalogVideoInputParams_SeparateSyncsSupported_ID 3

    // 
    UCHAR CompositeSyncSupported;
    #define WmiMonitorAnalogVideoInputParams_CompositeSyncSupported_SIZE sizeof(UCHAR)
    #define WmiMonitorAnalogVideoInputParams_CompositeSyncSupported_ID 4

    // 
    UCHAR SyncOnGreenVideoSupported;
    #define WmiMonitorAnalogVideoInputParams_SyncOnGreenVideoSupported_SIZE sizeof(UCHAR)
    #define WmiMonitorAnalogVideoInputParams_SyncOnGreenVideoSupported_ID 5

    // 
    UCHAR SerrationOfVsyncRequired;
    #define WmiMonitorAnalogVideoInputParams_SerrationOfVsyncRequired_SIZE sizeof(UCHAR)
    #define WmiMonitorAnalogVideoInputParams_SerrationOfVsyncRequired_ID 6

} WmiMonitorAnalogVideoInputParams, *PWmiMonitorAnalogVideoInputParams;

#define WmiMonitorAnalogVideoInputParams_SIZE (FIELD_OFFSET(WmiMonitorAnalogVideoInputParams, SerrationOfVsyncRequired) + WmiMonitorAnalogVideoInputParams_SerrationOfVsyncRequired_SIZE)

// WmiMonitorDigitalVideoInputParams - WmiMonitorDigitalVideoInputParams
#define WmiMonitorDigitalVideoInputParamsGuid \
    { 0x51565945,0x498a,0x4a77, { 0xac,0xc6,0x15,0x1b,0xec,0xc8,0x05,0xca } }

#if ! (defined(MIDL_PASS))
DEFINE_GUID(WmiMonitorDigitalVideoInputParams_GUID, \
            0x51565945,0x498a,0x4a77,0xac,0xc6,0x15,0x1b,0xec,0xc8,0x05,0xca);
#endif


typedef struct _WmiMonitorDigitalVideoInputParams
{
    // 
    BOOLEAN IsDFP1xCompatible;
    #define WmiMonitorDigitalVideoInputParams_IsDFP1xCompatible_SIZE sizeof(BOOLEAN)
    #define WmiMonitorDigitalVideoInputParams_IsDFP1xCompatible_ID 1

} WmiMonitorDigitalVideoInputParams, *PWmiMonitorDigitalVideoInputParams;

#define WmiMonitorDigitalVideoInputParams_SIZE (FIELD_OFFSET(WmiMonitorDigitalVideoInputParams, IsDFP1xCompatible) + WmiMonitorDigitalVideoInputParams_IsDFP1xCompatible_SIZE)

// WmiMonitorColorXYZinCIE - WmiMonitorColorXYZinCIE
#define WmiMonitorColorXYZinCIEGuid \
    { 0x01faf041,0x842c,0x4230, { 0xa3,0x1e,0x13,0x35,0x42,0x8c,0xd8,0xf0 } }

#if ! (defined(MIDL_PASS))
DEFINE_GUID(WmiMonitorColorXYZinCIE_GUID, \
            0x01faf041,0x842c,0x4230,0xa3,0x1e,0x13,0x35,0x42,0x8c,0xd8,0xf0);
#endif


typedef struct _WmiMonitorColorXYZinCIE
{
    // 
    USHORT X;
    #define WmiMonitorColorXYZinCIE_X_SIZE sizeof(USHORT)
    #define WmiMonitorColorXYZinCIE_X_ID 1

    // 
    USHORT Y;
    #define WmiMonitorColorXYZinCIE_Y_SIZE sizeof(USHORT)
    #define WmiMonitorColorXYZinCIE_Y_ID 2

} WmiMonitorColorXYZinCIE, *PWmiMonitorColorXYZinCIE;

#define WmiMonitorColorXYZinCIE_SIZE (FIELD_OFFSET(WmiMonitorColorXYZinCIE, Y) + WmiMonitorColorXYZinCIE_Y_SIZE)

// WmiMonitorColorCharacteristics - WmiMonitorColorCharacteristics
#define WmiMonitorColorCharacteristicsGuid \
    { 0xea324793,0x51bb,0x486a, { 0xaa,0x9d,0x0f,0x55,0x52,0x35,0x34,0x13 } }

#if ! (defined(MIDL_PASS))
DEFINE_GUID(WmiMonitorColorCharacteristics_GUID, \
            0xea324793,0x51bb,0x486a,0xaa,0x9d,0x0f,0x55,0x52,0x35,0x34,0x13);
#endif


typedef struct _WmiMonitorColorCharacteristics
{
    // 
    WmiMonitorColorXYZinCIE Red;
    #define WmiMonitorColorCharacteristics_Red_SIZE sizeof(WmiMonitorColorXYZinCIE)
    #define WmiMonitorColorCharacteristics_Red_ID 1

    // 
    WmiMonitorColorXYZinCIE Blue;
    #define WmiMonitorColorCharacteristics_Blue_SIZE sizeof(WmiMonitorColorXYZinCIE)
    #define WmiMonitorColorCharacteristics_Blue_ID 2

    // 
    WmiMonitorColorXYZinCIE Green;
    #define WmiMonitorColorCharacteristics_Green_SIZE sizeof(WmiMonitorColorXYZinCIE)
    #define WmiMonitorColorCharacteristics_Green_ID 3

    // 
    WmiMonitorColorXYZinCIE DefaultWhite;
    #define WmiMonitorColorCharacteristics_DefaultWhite_SIZE sizeof(WmiMonitorColorXYZinCIE)
    #define WmiMonitorColorCharacteristics_DefaultWhite_ID 4

} WmiMonitorColorCharacteristics, *PWmiMonitorColorCharacteristics;

#define WmiMonitorColorCharacteristics_SIZE (FIELD_OFFSET(WmiMonitorColorCharacteristics, DefaultWhite) + WmiMonitorColorCharacteristics_DefaultWhite_SIZE)

// VideoModeDescriptor - VideoModeDescriptor
#define VideoModeDescriptorGuid \
    { 0x4a97ed30,0xbfaa,0x491a, { 0x9d,0xfd,0xb4,0x3a,0xde,0xdb,0xf8,0xe3 } }

#if ! (defined(MIDL_PASS))
DEFINE_GUID(VideoModeDescriptor_GUID, \
            0x4a97ed30,0xbfaa,0x491a,0x9d,0xfd,0xb4,0x3a,0xde,0xdb,0xf8,0xe3);
#endif


typedef struct _VideoModeDescriptor
{
    // 
    ULONG PixelClockRate;
    #define VideoModeDescriptor_PixelClockRate_SIZE sizeof(ULONG)
    #define VideoModeDescriptor_PixelClockRate_ID 1

    // 
    ULONG VerticalRefreshRateNumerator;
    #define VideoModeDescriptor_VerticalRefreshRateNumerator_SIZE sizeof(ULONG)
    #define VideoModeDescriptor_VerticalRefreshRateNumerator_ID 2

    // 
    ULONG VerticalRefreshRateDenominator;
    #define VideoModeDescriptor_VerticalRefreshRateDenominator_SIZE sizeof(ULONG)
    #define VideoModeDescriptor_VerticalRefreshRateDenominator_ID 3

    // 
    ULONG HorizontalRefreshRateNumerator;
    #define VideoModeDescriptor_HorizontalRefreshRateNumerator_SIZE sizeof(ULONG)
    #define VideoModeDescriptor_HorizontalRefreshRateNumerator_ID 4

    // 
    ULONG HorizontalRefreshRateDenominator;
    #define VideoModeDescriptor_HorizontalRefreshRateDenominator_SIZE sizeof(ULONG)
    #define VideoModeDescriptor_HorizontalRefreshRateDenominator_ID 5

    // 
    USHORT HorizontalActivePixels;
    #define VideoModeDescriptor_HorizontalActivePixels_SIZE sizeof(USHORT)
    #define VideoModeDescriptor_HorizontalActivePixels_ID 6

    // 
    USHORT VerticalActivePixels;
    #define VideoModeDescriptor_VerticalActivePixels_SIZE sizeof(USHORT)
    #define VideoModeDescriptor_VerticalActivePixels_ID 7

    // 
    USHORT HorizontalBlankingPixels;
    #define VideoModeDescriptor_HorizontalBlankingPixels_SIZE sizeof(USHORT)
    #define VideoModeDescriptor_HorizontalBlankingPixels_ID 8

    // 
    USHORT VerticalBlankingPixels;
    #define VideoModeDescriptor_VerticalBlankingPixels_SIZE sizeof(USHORT)
    #define VideoModeDescriptor_VerticalBlankingPixels_ID 9

    // 
    USHORT HorizontalSyncOffset;
    #define VideoModeDescriptor_HorizontalSyncOffset_SIZE sizeof(USHORT)
    #define VideoModeDescriptor_HorizontalSyncOffset_ID 10

    // 
    USHORT VerticalSyncOffset;
    #define VideoModeDescriptor_VerticalSyncOffset_SIZE sizeof(USHORT)
    #define VideoModeDescriptor_VerticalSyncOffset_ID 11

    // 
    USHORT HorizontalSyncPulseWidth;
    #define VideoModeDescriptor_HorizontalSyncPulseWidth_SIZE sizeof(USHORT)
    #define VideoModeDescriptor_HorizontalSyncPulseWidth_ID 12

    // 
    USHORT VerticalSyncPulseWidth;
    #define VideoModeDescriptor_VerticalSyncPulseWidth_SIZE sizeof(USHORT)
    #define VideoModeDescriptor_VerticalSyncPulseWidth_ID 13

    // 
    USHORT HorizontalImageSize;
    #define VideoModeDescriptor_HorizontalImageSize_SIZE sizeof(USHORT)
    #define VideoModeDescriptor_HorizontalImageSize_ID 14

    // 
    USHORT VerticalImageSize;
    #define VideoModeDescriptor_VerticalImageSize_SIZE sizeof(USHORT)
    #define VideoModeDescriptor_VerticalImageSize_ID 15

    // 
    USHORT HorizontalBorder;
    #define VideoModeDescriptor_HorizontalBorder_SIZE sizeof(USHORT)
    #define VideoModeDescriptor_HorizontalBorder_ID 16

    // 
    USHORT VerticalBorder;
    #define VideoModeDescriptor_VerticalBorder_SIZE sizeof(USHORT)
    #define VideoModeDescriptor_VerticalBorder_ID 17

    // 
    BOOLEAN IsInterlaced;
    #define VideoModeDescriptor_IsInterlaced_SIZE sizeof(BOOLEAN)
    #define VideoModeDescriptor_IsInterlaced_ID 18

    // 
    UCHAR StereoModeType;
    #define VideoModeDescriptor_StereoModeType_SIZE sizeof(UCHAR)
    #define VideoModeDescriptor_StereoModeType_ID 19

    // 
    UCHAR SyncSignalType;
    #define VideoModeDescriptor_SyncSignalType_SIZE sizeof(UCHAR)
    #define VideoModeDescriptor_SyncSignalType_ID 20

    // 
    UCHAR IsSerrationRequired;
    #define VideoModeDescriptor_IsSerrationRequired_SIZE sizeof(UCHAR)
    #define VideoModeDescriptor_IsSerrationRequired_ID 21

    // 
    UCHAR IsSyncOnRGB;
    #define VideoModeDescriptor_IsSyncOnRGB_SIZE sizeof(UCHAR)
    #define VideoModeDescriptor_IsSyncOnRGB_ID 22

    // 
    UCHAR CompositePolarityType;
    #define VideoModeDescriptor_CompositePolarityType_SIZE sizeof(UCHAR)
    #define VideoModeDescriptor_CompositePolarityType_ID 23

    // 
    UCHAR VerticalPolarityType;
    #define VideoModeDescriptor_VerticalPolarityType_SIZE sizeof(UCHAR)
    #define VideoModeDescriptor_VerticalPolarityType_ID 24

    // 
    UCHAR HorizontalPolarityType;
    #define VideoModeDescriptor_HorizontalPolarityType_SIZE sizeof(UCHAR)
    #define VideoModeDescriptor_HorizontalPolarityType_ID 25

    // 
    UCHAR VideoStandardType;
    #define VideoModeDescriptor_VideoStandardType_SIZE sizeof(UCHAR)
    #define VideoModeDescriptor_VideoStandardType_ID 26

    // 
    UCHAR Origin;
    #define VideoModeDescriptor_Origin_SIZE sizeof(UCHAR)
    #define VideoModeDescriptor_Origin_ID 27

    // 
    UCHAR TimingType;
    #define VideoModeDescriptor_TimingType_SIZE sizeof(UCHAR)
    #define VideoModeDescriptor_TimingType_ID 28

} VideoModeDescriptor, *PVideoModeDescriptor;

#define VideoModeDescriptor_SIZE (FIELD_OFFSET(VideoModeDescriptor, TimingType) + VideoModeDescriptor_TimingType_SIZE)

// WmiMonitorListedSupportedSourceModes - WmiMonitorListedSupportedSourceModes
#define WmiMonitorListedSupportedSourceModesGuid \
    { 0x6dc76655,0x063c,0x4524, { 0xa8,0x62,0xb8,0x41,0x0c,0x26,0x28,0x1b } }

#if ! (defined(MIDL_PASS))
DEFINE_GUID(WmiMonitorListedSupportedSourceModes_GUID, \
            0x6dc76655,0x063c,0x4524,0xa8,0x62,0xb8,0x41,0x0c,0x26,0x28,0x1b);
#endif


typedef struct _WmiMonitorListedSupportedSourceModes
{
    // 
    USHORT NumOfMonitorSourceModes;
    #define WmiMonitorListedSupportedSourceModes_NumOfMonitorSourceModes_SIZE sizeof(USHORT)
    #define WmiMonitorListedSupportedSourceModes_NumOfMonitorSourceModes_ID 1

    // 
    USHORT PreferredMonitorSourceModeIndex;
    #define WmiMonitorListedSupportedSourceModes_PreferredMonitorSourceModeIndex_SIZE sizeof(USHORT)
    #define WmiMonitorListedSupportedSourceModes_PreferredMonitorSourceModeIndex_ID 2

    // 
    VideoModeDescriptor MonitorSourceModes[1];
    #define WmiMonitorListedSupportedSourceModes_MonitorSourceModes_ID 3

} WmiMonitorListedSupportedSourceModes, *PWmiMonitorListedSupportedSourceModes;

// FrequencyRangeDescriptor - FrequencyRangeDescriptor
#define FrequencyRangeDescriptorGuid \
    { 0xf4546078,0xf3b2,0x417e, { 0x94,0xcd,0x47,0xea,0x30,0x6c,0x57,0x51 } }

#if ! (defined(MIDL_PASS))
DEFINE_GUID(FrequencyRangeDescriptor_GUID, \
            0xf4546078,0xf3b2,0x417e,0x94,0xcd,0x47,0xea,0x30,0x6c,0x57,0x51);
#endif


typedef struct _FrequencyRangeDescriptor
{
    // 
    UCHAR Origin;
    #define FrequencyRangeDescriptor_Origin_SIZE sizeof(UCHAR)
    #define FrequencyRangeDescriptor_Origin_ID 1

    // 
    ULONG MinVSyncNumerator;
    #define FrequencyRangeDescriptor_MinVSyncNumerator_SIZE sizeof(ULONG)
    #define FrequencyRangeDescriptor_MinVSyncNumerator_ID 2

    // 
    ULONG MinVSyncDenominator;
    #define FrequencyRangeDescriptor_MinVSyncDenominator_SIZE sizeof(ULONG)
    #define FrequencyRangeDescriptor_MinVSyncDenominator_ID 3

    // 
    ULONG MaxVSyncNumerator;
    #define FrequencyRangeDescriptor_MaxVSyncNumerator_SIZE sizeof(ULONG)
    #define FrequencyRangeDescriptor_MaxVSyncNumerator_ID 4

    // 
    ULONG MaxVSyncDenominator;
    #define FrequencyRangeDescriptor_MaxVSyncDenominator_SIZE sizeof(ULONG)
    #define FrequencyRangeDescriptor_MaxVSyncDenominator_ID 5

    // 
    ULONG MinHSyncNumerator;
    #define FrequencyRangeDescriptor_MinHSyncNumerator_SIZE sizeof(ULONG)
    #define FrequencyRangeDescriptor_MinHSyncNumerator_ID 6

    // 
    ULONG MinHSyncDenominator;
    #define FrequencyRangeDescriptor_MinHSyncDenominator_SIZE sizeof(ULONG)
    #define FrequencyRangeDescriptor_MinHSyncDenominator_ID 7

    // 
    ULONG MaxHSyncNumerator;
    #define FrequencyRangeDescriptor_MaxHSyncNumerator_SIZE sizeof(ULONG)
    #define FrequencyRangeDescriptor_MaxHSyncNumerator_ID 8

    // 
    ULONG MaxHSyncDenominator;
    #define FrequencyRangeDescriptor_MaxHSyncDenominator_SIZE sizeof(ULONG)
    #define FrequencyRangeDescriptor_MaxHSyncDenominator_ID 9

    // 
    ULONG ConstraintType;
    #define FrequencyRangeDescriptor_ConstraintType_SIZE sizeof(ULONG)
    #define FrequencyRangeDescriptor_ConstraintType_ID 10

    // 
    ULONG ActiveWidth;
    #define FrequencyRangeDescriptor_ActiveWidth_SIZE sizeof(ULONG)
    #define FrequencyRangeDescriptor_ActiveWidth_ID 11

    // 
    ULONG ActiveHeight;
    #define FrequencyRangeDescriptor_ActiveHeight_SIZE sizeof(ULONG)
    #define FrequencyRangeDescriptor_ActiveHeight_ID 12

    // 
    ULONG MaxPixelRate;
    #define FrequencyRangeDescriptor_MaxPixelRate_SIZE sizeof(ULONG)
    #define FrequencyRangeDescriptor_MaxPixelRate_ID 13

} FrequencyRangeDescriptor, *PFrequencyRangeDescriptor;

#define FrequencyRangeDescriptor_SIZE (FIELD_OFFSET(FrequencyRangeDescriptor, MaxPixelRate) + FrequencyRangeDescriptor_MaxPixelRate_SIZE)

// WmiMonitorListedFrequencyRanges - WmiMonitorListedFrequencyRanges
#define WmiMonitorListedFrequencyRangesGuid \
    { 0xe86e9525,0x65b6,0x4b85, { 0x95,0xc5,0x00,0xbe,0xac,0xc9,0x75,0xed } }

#if ! (defined(MIDL_PASS))
DEFINE_GUID(WmiMonitorListedFrequencyRanges_GUID, \
            0xe86e9525,0x65b6,0x4b85,0x95,0xc5,0x00,0xbe,0xac,0xc9,0x75,0xed);
#endif


typedef struct _WmiMonitorListedFrequencyRanges
{
    // 
    USHORT NumOfMonitorFreqRanges;
    #define WmiMonitorListedFrequencyRanges_NumOfMonitorFreqRanges_SIZE sizeof(USHORT)
    #define WmiMonitorListedFrequencyRanges_NumOfMonitorFreqRanges_ID 1

    // 
    FrequencyRangeDescriptor MonitorFreqRanges[1];
    #define WmiMonitorListedFrequencyRanges_MonitorFreqRanges_ID 2

} WmiMonitorListedFrequencyRanges, *PWmiMonitorListedFrequencyRanges;

// KernelPerfState - KernelPerfState
#define KernelPerfStateGuid \
    { 0x8c7980e1,0xf62b,0x419e, { 0xaa,0x82,0x27,0x6c,0x8d,0x06,0x4a,0x1f } }

#if ! (defined(MIDL_PASS))
DEFINE_GUID(KernelPerfState_GUID, \
            0x8c7980e1,0xf62b,0x419e,0xaa,0x82,0x27,0x6c,0x8d,0x06,0x4a,0x1f);
#endif


typedef struct _KernelPerfState
{
    // 
    ULONG Frequency;
    #define KernelPerfState_Frequency_SIZE sizeof(ULONG)
    #define KernelPerfState_Frequency_ID 1

    // 
    ULONG Power;
    #define KernelPerfState_Power_SIZE sizeof(ULONG)
    #define KernelPerfState_Power_ID 2

    // 
    UCHAR PercentFrequency;
    #define KernelPerfState_PercentFrequency_SIZE sizeof(UCHAR)
    #define KernelPerfState_PercentFrequency_ID 3

    // 
    UCHAR IncreaseLevel;
    #define KernelPerfState_IncreaseLevel_SIZE sizeof(UCHAR)
    #define KernelPerfState_IncreaseLevel_ID 4

    // 
    UCHAR DecreaseLevel;
    #define KernelPerfState_DecreaseLevel_SIZE sizeof(UCHAR)
    #define KernelPerfState_DecreaseLevel_ID 5

    // 
    UCHAR Type;
    #define KernelPerfState_Type_SIZE sizeof(UCHAR)
    #define KernelPerfState_Type_ID 6

    // 
    ULONG IncreaseTime;
    #define KernelPerfState_IncreaseTime_SIZE sizeof(ULONG)
    #define KernelPerfState_IncreaseTime_ID 7

    // 
    ULONG DecreaseTime;
    #define KernelPerfState_DecreaseTime_SIZE sizeof(ULONG)
    #define KernelPerfState_DecreaseTime_ID 8

    // 
    ULONGLONG Control;
    #define KernelPerfState_Control_SIZE sizeof(ULONGLONG)
    #define KernelPerfState_Control_ID 9

    // 
    ULONGLONG Status;
    #define KernelPerfState_Status_SIZE sizeof(ULONGLONG)
    #define KernelPerfState_Status_ID 10

    // 
    ULONG HitCount;
    #define KernelPerfState_HitCount_SIZE sizeof(ULONG)
    #define KernelPerfState_HitCount_ID 11

    // 
    ULONG Reserved1;
    #define KernelPerfState_Reserved1_SIZE sizeof(ULONG)
    #define KernelPerfState_Reserved1_ID 12

    // 
    ULONGLONG Reserved2;
    #define KernelPerfState_Reserved2_SIZE sizeof(ULONGLONG)
    #define KernelPerfState_Reserved2_ID 13

    // 
    ULONGLONG Reserved3;
    #define KernelPerfState_Reserved3_SIZE sizeof(ULONGLONG)
    #define KernelPerfState_Reserved3_ID 14

} KernelPerfState, *PKernelPerfState;

#define KernelPerfState_SIZE (FIELD_OFFSET(KernelPerfState, Reserved3) + KernelPerfState_Reserved3_SIZE)

// KernelPerfStates - KernelPerfStates
#define KernelPerfStatesGuid \
    { 0x5708cc20,0x7d40,0x4bf4, { 0xb4,0xaa,0x2b,0x01,0x33,0x8d,0x01,0x26 } }

#if ! (defined(MIDL_PASS))
DEFINE_GUID(KernelPerfStates_GUID, \
            0x5708cc20,0x7d40,0x4bf4,0xb4,0xaa,0x2b,0x01,0x33,0x8d,0x01,0x26);
#endif


typedef struct _KernelPerfStates
{
    // 
    ULONG Count;
    #define KernelPerfStates_Count_SIZE sizeof(ULONG)
    #define KernelPerfStates_Count_ID 1

    // 
    ULONG MaxFrequency;
    #define KernelPerfStates_MaxFrequency_SIZE sizeof(ULONG)
    #define KernelPerfStates_MaxFrequency_ID 2

    // 
    ULONG CurrentState;
    #define KernelPerfStates_CurrentState_SIZE sizeof(ULONG)
    #define KernelPerfStates_CurrentState_ID 3

    // 
    ULONG MaxPerfState;
    #define KernelPerfStates_MaxPerfState_SIZE sizeof(ULONG)
    #define KernelPerfStates_MaxPerfState_ID 4

    // 
    ULONG MinPerfState;
    #define KernelPerfStates_MinPerfState_SIZE sizeof(ULONG)
    #define KernelPerfStates_MinPerfState_ID 5

    // 
    ULONG LowestPerfState;
    #define KernelPerfStates_LowestPerfState_SIZE sizeof(ULONG)
    #define KernelPerfStates_LowestPerfState_ID 6

    // 
    ULONG ThermalConstraint;
    #define KernelPerfStates_ThermalConstraint_SIZE sizeof(ULONG)
    #define KernelPerfStates_ThermalConstraint_ID 7

    // 
    UCHAR BusyAdjThreshold;
    #define KernelPerfStates_BusyAdjThreshold_SIZE sizeof(UCHAR)
    #define KernelPerfStates_BusyAdjThreshold_ID 8

    // 
    UCHAR PolicyType;
    #define KernelPerfStates_PolicyType_SIZE sizeof(UCHAR)
    #define KernelPerfStates_PolicyType_ID 9

    // 
    UCHAR Type;
    #define KernelPerfStates_Type_SIZE sizeof(UCHAR)
    #define KernelPerfStates_Type_ID 10

    // 
    UCHAR Reserved;
    #define KernelPerfStates_Reserved_SIZE sizeof(UCHAR)
    #define KernelPerfStates_Reserved_ID 11

    // 
    ULONG TimerInterval;
    #define KernelPerfStates_TimerInterval_SIZE sizeof(ULONG)
    #define KernelPerfStates_TimerInterval_ID 12

    // 
    ULONGLONG TargetProcessors;
    #define KernelPerfStates_TargetProcessors_SIZE sizeof(ULONGLONG)
    #define KernelPerfStates_TargetProcessors_ID 13

    // 
    ULONG PStateHandler;
    #define KernelPerfStates_PStateHandler_SIZE sizeof(ULONG)
    #define KernelPerfStates_PStateHandler_ID 14

    // 
    ULONG PStateContext;
    #define KernelPerfStates_PStateContext_SIZE sizeof(ULONG)
    #define KernelPerfStates_PStateContext_ID 15

    // 
    ULONG TStateHandler;
    #define KernelPerfStates_TStateHandler_SIZE sizeof(ULONG)
    #define KernelPerfStates_TStateHandler_ID 16

    // 
    ULONG TStateContext;
    #define KernelPerfStates_TStateContext_SIZE sizeof(ULONG)
    #define KernelPerfStates_TStateContext_ID 17

    // 
    ULONG FeedbackHandler;
    #define KernelPerfStates_FeedbackHandler_SIZE sizeof(ULONG)
    #define KernelPerfStates_FeedbackHandler_ID 18

    // 
    ULONG Reserved1;
    #define KernelPerfStates_Reserved1_SIZE sizeof(ULONG)
    #define KernelPerfStates_Reserved1_ID 19

    // 
    ULONGLONG Reserved2;
    #define KernelPerfStates_Reserved2_SIZE sizeof(ULONGLONG)
    #define KernelPerfStates_Reserved2_ID 20

    // 
    KernelPerfState State[1];
    #define KernelPerfStates_State_ID 21

} KernelPerfStates, *PKernelPerfStates;

// KernelIdleState - KernelIdleState
#define KernelIdleStateGuid \
    { 0x46bdcf4a,0xe076,0x4550, { 0x82,0xb2,0x9f,0x32,0xed,0xed,0x3e,0x7f } }

#if ! (defined(MIDL_PASS))
DEFINE_GUID(KernelIdleState_GUID, \
            0x46bdcf4a,0xe076,0x4550,0x82,0xb2,0x9f,0x32,0xed,0xed,0x3e,0x7f);
#endif


typedef struct _KernelIdleState
{
    // 
    ULONG Latency;
    #define KernelIdleState_Latency_SIZE sizeof(ULONG)
    #define KernelIdleState_Latency_ID 1

    // 
    ULONG Power;
    #define KernelIdleState_Power_SIZE sizeof(ULONG)
    #define KernelIdleState_Power_ID 2

    // 
    ULONG TimeCheck;
    #define KernelIdleState_TimeCheck_SIZE sizeof(ULONG)
    #define KernelIdleState_TimeCheck_ID 3

    // 
    UCHAR PromotePercent;
    #define KernelIdleState_PromotePercent_SIZE sizeof(UCHAR)
    #define KernelIdleState_PromotePercent_ID 4

    // 
    UCHAR DemotePercent;
    #define KernelIdleState_DemotePercent_SIZE sizeof(UCHAR)
    #define KernelIdleState_DemotePercent_ID 5

    // 
    UCHAR StateType;
    #define KernelIdleState_StateType_SIZE sizeof(UCHAR)
    #define KernelIdleState_StateType_ID 6

    // 
    UCHAR Reserved;
    #define KernelIdleState_Reserved_SIZE sizeof(UCHAR)
    #define KernelIdleState_Reserved_ID 7

    // 
    ULONG StateFlags;
    #define KernelIdleState_StateFlags_SIZE sizeof(ULONG)
    #define KernelIdleState_StateFlags_ID 8

    // 
    ULONG Context;
    #define KernelIdleState_Context_SIZE sizeof(ULONG)
    #define KernelIdleState_Context_ID 9

    // 
    ULONG IdleHandler;
    #define KernelIdleState_IdleHandler_SIZE sizeof(ULONG)
    #define KernelIdleState_IdleHandler_ID 10

    // 
    ULONG Reserved1;
    #define KernelIdleState_Reserved1_SIZE sizeof(ULONG)
    #define KernelIdleState_Reserved1_ID 11

} KernelIdleState, *PKernelIdleState;

#define KernelIdleState_SIZE (FIELD_OFFSET(KernelIdleState, Reserved1) + KernelIdleState_Reserved1_SIZE)

// KernelIdleStates - KernelIdleStates
#define KernelIdleStatesGuid \
    { 0xba138e10,0xe250,0x4ad7, { 0x86,0x16,0xcf,0x1a,0x7a,0xd4,0x10,0xe7 } }

#if ! (defined(MIDL_PASS))
DEFINE_GUID(KernelIdleStates_GUID, \
            0xba138e10,0xe250,0x4ad7,0x86,0x16,0xcf,0x1a,0x7a,0xd4,0x10,0xe7);
#endif


typedef struct _KernelIdleStates
{
    // 
    ULONG Type;
    #define KernelIdleStates_Type_SIZE sizeof(ULONG)
    #define KernelIdleStates_Type_ID 1

    // 
    ULONG Count;
    #define KernelIdleStates_Count_SIZE sizeof(ULONG)
    #define KernelIdleStates_Count_ID 2

    // 
    ULONG TargetState;
    #define KernelIdleStates_TargetState_SIZE sizeof(ULONG)
    #define KernelIdleStates_TargetState_ID 3

    // 
    ULONG OldState;
    #define KernelIdleStates_OldState_SIZE sizeof(ULONG)
    #define KernelIdleStates_OldState_ID 4

    // 
    ULONGLONG TargetProcessors;
    #define KernelIdleStates_TargetProcessors_SIZE sizeof(ULONGLONG)
    #define KernelIdleStates_TargetProcessors_ID 5

    // 
    KernelIdleState State[1];
    #define KernelIdleStates_State_ID 6

} KernelIdleStates, *PKernelIdleStates;

// KernelPerfStateChange - KernelPerfStateChange
// Kernel Perf State Transition Event
#define KernelPerfStateChangeGuid \
    { 0xa5b32ddd,0x7f39,0x4abc, { 0xb8,0x92,0x90,0x0e,0x43,0xb5,0x9e,0xbb } }

#if ! (defined(MIDL_PASS))
DEFINE_GUID(KernelPerfStateChange_GUID, \
            0xa5b32ddd,0x7f39,0x4abc,0xb8,0x92,0x90,0x0e,0x43,0xb5,0x9e,0xbb);
#endif


typedef struct _KernelPerfStateChange
{
    // 
    ULONG State;
    #define KernelPerfStateChange_State_SIZE sizeof(ULONG)
    #define KernelPerfStateChange_State_ID 1

    // 
    ULONG Status;
    #define KernelPerfStateChange_Status_SIZE sizeof(ULONG)
    #define KernelPerfStateChange_Status_ID 2

    // 
    ULONG Latency;
    #define KernelPerfStateChange_Latency_SIZE sizeof(ULONG)
    #define KernelPerfStateChange_Latency_ID 3

    // 
    ULONG Speed;
    #define KernelPerfStateChange_Speed_SIZE sizeof(ULONG)
    #define KernelPerfStateChange_Speed_ID 4

    // 
    ULONG Processor;
    #define KernelPerfStateChange_Processor_SIZE sizeof(ULONG)
    #define KernelPerfStateChange_Processor_ID 5

} KernelPerfStateChange, *PKernelPerfStateChange;

#define KernelPerfStateChange_SIZE (FIELD_OFFSET(KernelPerfStateChange, Processor) + KernelPerfStateChange_Processor_SIZE)

// KernelPerfStateDomainChange - KernelPerfStateDomainChange
// Kernel Perf State Domain Transition Event
#define KernelPerfStateDomainChangeGuid \
    { 0x995e6b7f,0xd653,0x497a, { 0xb9,0x78,0x36,0xa3,0x0c,0x29,0xbf,0x01 } }

#if ! (defined(MIDL_PASS))
DEFINE_GUID(KernelPerfStateDomainChange_GUID, \
            0x995e6b7f,0xd653,0x497a,0xb9,0x78,0x36,0xa3,0x0c,0x29,0xbf,0x01);
#endif


typedef struct _KernelPerfStateDomainChange
{
    // 
    ULONG State;
    #define KernelPerfStateDomainChange_State_SIZE sizeof(ULONG)
    #define KernelPerfStateDomainChange_State_ID 1

    // 
    ULONG Latency;
    #define KernelPerfStateDomainChange_Latency_SIZE sizeof(ULONG)
    #define KernelPerfStateDomainChange_Latency_ID 2

    // 
    ULONG Speed;
    #define KernelPerfStateDomainChange_Speed_SIZE sizeof(ULONG)
    #define KernelPerfStateDomainChange_Speed_ID 3

    // 
    ULONGLONG Processors;
    #define KernelPerfStateDomainChange_Processors_SIZE sizeof(ULONGLONG)
    #define KernelPerfStateDomainChange_Processors_ID 4

} KernelPerfStateDomainChange, *PKernelPerfStateDomainChange;

#define KernelPerfStateDomainChange_SIZE (FIELD_OFFSET(KernelPerfStateDomainChange, Processors) + KernelPerfStateDomainChange_Processors_SIZE)

// KernelIdleStateChange - KernelIdleStateChange
// Kernel Idle State Change Event
#define KernelIdleStateChangeGuid \
    { 0x4838fe4f,0xf71c,0x4e51, { 0x9e,0xcc,0x84,0x30,0xa7,0xac,0x4c,0x6c } }

#if ! (defined(MIDL_PASS))
DEFINE_GUID(KernelIdleStateChange_GUID, \
            0x4838fe4f,0xf71c,0x4e51,0x9e,0xcc,0x84,0x30,0xa7,0xac,0x4c,0x6c);
#endif


typedef struct _KernelIdleStateChange
{
    // 
    ULONG NewState;
    #define KernelIdleStateChange_NewState_SIZE sizeof(ULONG)
    #define KernelIdleStateChange_NewState_ID 1

    // 
    ULONG OldState;
    #define KernelIdleStateChange_OldState_SIZE sizeof(ULONG)
    #define KernelIdleStateChange_OldState_ID 2

    // 
    ULONGLONG Processors;
    #define KernelIdleStateChange_Processors_SIZE sizeof(ULONGLONG)
    #define KernelIdleStateChange_Processors_ID 3

} KernelIdleStateChange, *PKernelIdleStateChange;

#define KernelIdleStateChange_SIZE (FIELD_OFFSET(KernelIdleStateChange, Processors) + KernelIdleStateChange_Processors_SIZE)

// KernelThermalConstraintChange - KernelThermalConstraintChange
// Kernel Thermal Event
#define KernelThermalConstraintChangeGuid \
    { 0xa852c2c8,0x1a4c,0x423b, { 0x8c,0x2c,0xf3,0x0d,0x82,0x93,0x1a,0x88 } }

#if ! (defined(MIDL_PASS))
DEFINE_GUID(KernelThermalConstraintChange_GUID, \
            0xa852c2c8,0x1a4c,0x423b,0x8c,0x2c,0xf3,0x0d,0x82,0x93,0x1a,0x88);
#endif


typedef struct _KernelThermalConstraintChange
{
    // 
    ULONG ThermalConstraint;
    #define KernelThermalConstraintChange_ThermalConstraint_SIZE sizeof(ULONG)
    #define KernelThermalConstraintChange_ThermalConstraint_ID 1

    // 
    ULONGLONG Processors;
    #define KernelThermalConstraintChange_Processors_SIZE sizeof(ULONGLONG)
    #define KernelThermalConstraintChange_Processors_ID 2

} KernelThermalConstraintChange, *PKernelThermalConstraintChange;

#define KernelThermalConstraintChange_SIZE (FIELD_OFFSET(KernelThermalConstraintChange, Processors) + KernelThermalConstraintChange_Processors_SIZE)

// IdleStateAccounting - IdleStateAccounting
#define IdleStateAccountingGuid \
    { 0x5280028a,0xc24f,0x43ec, { 0xb2,0x7d,0xa9,0x60,0xa7,0x0e,0x31,0x9a } }

#if ! (defined(MIDL_PASS))
DEFINE_GUID(IdleStateAccounting_GUID, \
            0x5280028a,0xc24f,0x43ec,0xb2,0x7d,0xa9,0x60,0xa7,0x0e,0x31,0x9a);
#endif


typedef struct _IdleStateAccounting
{
    // 
    ULONG IdleTransitions;
    #define IdleStateAccounting_IdleTransitions_SIZE sizeof(ULONG)
    #define IdleStateAccounting_IdleTransitions_ID 1

    // 
    ULONG FailedTransitions;
    #define IdleStateAccounting_FailedTransitions_SIZE sizeof(ULONG)
    #define IdleStateAccounting_FailedTransitions_ID 2

    // 
    ULONG IdleTimeBuckets[6];
    #define IdleStateAccounting_IdleTimeBuckets_SIZE sizeof(ULONG[6])
    #define IdleStateAccounting_IdleTimeBuckets_ID 3

} IdleStateAccounting, *PIdleStateAccounting;

#define IdleStateAccounting_SIZE (FIELD_OFFSET(IdleStateAccounting, IdleTimeBuckets) + IdleStateAccounting_IdleTimeBuckets_SIZE)

// IdleAccounting - IdleAccounting
#define IdleAccountingGuid \
    { 0xe2a26f78,0xae07,0x4ee0, { 0xa3,0x0f,0xce,0x35,0x4f,0x5a,0x94,0xcd } }

#if ! (defined(MIDL_PASS))
DEFINE_GUID(IdleAccounting_GUID, \
            0xe2a26f78,0xae07,0x4ee0,0xa3,0x0f,0xce,0x35,0x4f,0x5a,0x94,0xcd);
#endif


typedef struct _IdleAccounting
{
    // 
    ULONG StateCount;
    #define IdleAccounting_StateCount_SIZE sizeof(ULONG)
    #define IdleAccounting_StateCount_ID 1

    // 
    ULONG TotalTransitions;
    #define IdleAccounting_TotalTransitions_SIZE sizeof(ULONG)
    #define IdleAccounting_TotalTransitions_ID 2

    // 
    ULONG ResetCount;
    #define IdleAccounting_ResetCount_SIZE sizeof(ULONG)
    #define IdleAccounting_ResetCount_ID 3

    // 
    ULONGLONG StartTime;
    #define IdleAccounting_StartTime_SIZE sizeof(ULONGLONG)
    #define IdleAccounting_StartTime_ID 4

    // 
    IdleStateAccounting State[1];
    #define IdleAccounting_State_ID 5

} IdleAccounting, *PIdleAccounting;

// KernelThermalPolicyChange - KernelThermalPolicyChange
// Kernel Thermal Policy Event
#define KernelThermalPolicyChangeGuid \
    { 0xaca5a8f7,0x96ca,0x4397, { 0xba,0xde,0x43,0xbe,0x2f,0x57,0x7d,0x51 } }

#if ! (defined(MIDL_PASS))
DEFINE_GUID(KernelThermalPolicyChange_GUID, \
            0xaca5a8f7,0x96ca,0x4397,0xba,0xde,0x43,0xbe,0x2f,0x57,0x7d,0x51);
#endif


typedef struct _KernelThermalPolicyChange
{
    // 
    UCHAR CoolingMode;
    #define KernelThermalPolicyChange_CoolingMode_SIZE sizeof(UCHAR)
    #define KernelThermalPolicyChange_CoolingMode_ID 1

    // 
    ULONGLONG Processors;
    #define KernelThermalPolicyChange_Processors_SIZE sizeof(ULONGLONG)
    #define KernelThermalPolicyChange_Processors_ID 2

} KernelThermalPolicyChange, *PKernelThermalPolicyChange;

#define KernelThermalPolicyChange_SIZE (FIELD_OFFSET(KernelThermalPolicyChange, Processors) + KernelThermalPolicyChange_Processors_SIZE)

// ProcessorPerformance - ProcessorPerformance
#define ProcessorPerformanceGuid \
    { 0x7fd18652,0x0cfe,0x40d2, { 0xb0,0xa1,0x0b,0x06,0x6a,0x87,0x75,0x9e } }

#if ! (defined(MIDL_PASS))
DEFINE_GUID(ProcessorPerformance_GUID, \
            0x7fd18652,0x0cfe,0x40d2,0xb0,0xa1,0x0b,0x06,0x6a,0x87,0x75,0x9e);
#endif


typedef struct _ProcessorPerformance
{
    // 
    ULONG frequency;
    #define ProcessorPerformance_frequency_SIZE sizeof(ULONG)
    #define ProcessorPerformance_frequency_ID 1

    // 
    ULONG power;
    #define ProcessorPerformance_power_SIZE sizeof(ULONG)
    #define ProcessorPerformance_power_ID 2

    // 
    ULONG percentage;
    #define ProcessorPerformance_percentage_SIZE sizeof(ULONG)
    #define ProcessorPerformance_percentage_ID 3

} ProcessorPerformance, *PProcessorPerformance;

#define ProcessorPerformance_SIZE (FIELD_OFFSET(ProcessorPerformance, percentage) + ProcessorPerformance_percentage_SIZE)

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\win2k8\ddk\inc\wmilib.h ===
/*++

Copyright (c) 1998  Microsoft Corporation

Module Name:

    wmilib.h

Abstract:

    This module contains the internal structure definitions and APIs used by
    the WMILIB helper functions

Author:

    AlanWar


Revision History:

--*/

#ifndef _WMILIB_
#define _WMILIB_

#if defined (_MSC_VER) && (_MSC_VER >= 1020)
#pragma once
#endif

#ifdef __cplusplus
extern "C" {
#endif

#if (NTDDI_VERSION >= NTDDI_WIN2K)

//
// This defines a guid to be registered with WMI. Memory for this structure
// may be Paged.
typedef struct
{
    LPCGUID Guid;            // Guid to registered
    ULONG InstanceCount;     // Count of Instances of Datablock
    ULONG Flags;             // Additional flags (see WMIREGINFO in wmistr.h)
} WMIGUIDREGINFO, *PWMIGUIDREGINFO;

#endif // (NTDDI_VERSION >= NTDDI_WIN2K)
#if (NTDDI_VERSION >= NTDDI_WIN2K)

typedef
NTSTATUS
(*PWMI_QUERY_REGINFO) (
    IN PDEVICE_OBJECT DeviceObject,
    OUT PULONG RegFlags,
    OUT PUNICODE_STRING InstanceName,
    OUT PUNICODE_STRING *RegistryPath,
    OUT PUNICODE_STRING MofResourceName,
    OUT PDEVICE_OBJECT *Pdo
    );
/*++

Routine Description:

    This routine is a callback into the driver to retrieve information about
    the guids being registered.
	
    Implementations of this routine may be in paged memory

Arguments:

    DeviceObject is the device whose registration information is needed

    *RegFlags returns with a set of flags that describe all of the guids being
        registered for this device. If the device wants enable and disable
        collection callbacks before receiving queries for the registered
        guids then it should return the WMIREG_FLAG_EXPENSIVE flag. Also the
        returned flags may specify WMIREG_FLAG_INSTANCE_PDO in which case
        the instance name is determined from the PDO associated with the
        device object. Note that the PDO must have an associated devnode. If
        WMIREG_FLAG_INSTANCE_PDO is not set then Name must return a unique
        name for the device. These flags are ORed into the flags specified
        by the GUIDREGINFO for each guid.		

    InstanceName returns with the instance name for the guids if
        WMIREG_FLAG_INSTANCE_PDO is not set in the returned *RegFlags. The
        caller will call ExFreePool with the buffer returned.

    *RegistryPath returns with the registry path of the driver. This is
        required
		
    MofResourceName returns with the name of the MOF resource attached to
        the binary file. If the driver does not have a mof resource attached
        then this can be returned unmodified. If a value is returned then
        it is NOT freed.
		
    *Pdo returns with the device object for the PDO associated with this
        device if the WMIREG_FLAG_INSTANCE_PDO flag is retured in
        *RegFlags.

Return Value:

    status

--*/

#endif // (NTDDI_VERSION >= NTDDI_WIN2K)
#if (NTDDI_VERSION >= NTDDI_WIN2K)

typedef
NTSTATUS
(*PWMI_QUERY_DATABLOCK) (
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp,
    IN ULONG GuidIndex,
    IN ULONG InstanceIndex,
    IN ULONG InstanceCount,
    IN OUT PULONG InstanceLengthArray,
    IN ULONG BufferAvail,
    OUT PUCHAR Buffer
    );
/*++

Routine Description:

    This routine is a callback into the driver to query for the contents of
    one or more instances of a data block. When the driver has finished
    filling the
    data block it must call WmiCompleteRequest to complete the irp. The
    driver can return STATUS_PENDING if the irp cannot be completed
    immediately.

    Implementations of this routine may be in paged memory

Arguments:

    DeviceObject is the device whose data block is being queried

    Irp is the Irp that makes this request

    GuidIndex is the index into the list of guids provided when the
        device registered

    InstanceIndex is the index that denotes which instance of the data block
        is being queried.

    InstanceCount is the number of instnaces expected to be returned for
        the data block.

    InstanceLengthArray is a pointer to an array of ULONG that returns the
        lengths of each instance of the data block. If this is NULL then
        there was not enough space in the output buffer to fufill the request
        so the irp should be completed with the buffer needed.

    BufferAvail on entry has the maximum size available to write the data
        blocks.

    Buffer on return is filled with the returned data blocks. Note that each
        instance of the data block must be aligned on a 8 byte boundry. If
        this is NULL then there was not enough space in the output buffer
	to fufill the request so the irp should be completed with the buffer
        needed.


Return Value:

    status

--*/

#endif // (NTDDI_VERSION >= NTDDI_WIN2K)
#if (NTDDI_VERSION >= NTDDI_WIN2K)

typedef
NTSTATUS
(*PWMI_SET_DATABLOCK) (
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp,
    IN ULONG GuidIndex,
    IN ULONG InstanceIndex,
    IN ULONG BufferSize,
    IN PUCHAR Buffer
    );
/*++

Routine Description:

    This routine is a callback into the driver to query for the contents of
    a data block. When the driver has finished filling the data block it
    must call WmiCompleteRequest to complete the irp. The driver can
    return STATUS_PENDING if the irp cannot be completed immediately.

    Implementations of this routine may be in paged memory

Arguments:

    DeviceObject is the device whose data block is being queried

    Irp is the Irp that makes this request

    GuidIndex is the index into the list of guids provided when the
        device registered

    InstanceIndex is the index that denotes which instance of the data block
        is being set.

    BufferSize has the size of the data block passed

    Buffer has the new values for the data block


Return Value:

    status

--*/

#endif // (NTDDI_VERSION >= NTDDI_WIN2K)
#if (NTDDI_VERSION >= NTDDI_WIN2K)

typedef
NTSTATUS
(*PWMI_SET_DATAITEM) (
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp,
    IN ULONG GuidIndex,
    IN ULONG InstanceIndex,
    IN ULONG DataItemId,
    IN ULONG BufferSize,
    IN PUCHAR Buffer
    );
/*++

Routine Description:

    This routine is a callback into the driver to query for the contents of
    a data block. When the driver has finished filling the data block it
    must call WmiCompleteRequest to complete the irp. The driver can
    return STATUS_PENDING if the irp cannot be completed immediately.

    Implementations of this routine may be in paged memory

Arguments:

    DeviceObject is the device whose data block is being queried

    Irp is the Irp that makes this request

    GuidIndex is the index into the list of guids provided when the
        device registered

    InstanceIndex is the index that denotes which instance of the data block
        is being set.

    DataItemId has the id of the data item being set

    BufferSize has the size of the data item passed

    Buffer has the new values for the data item


Return Value:

    status

--*/

#endif // (NTDDI_VERSION >= NTDDI_WIN2K)
#if (NTDDI_VERSION >= NTDDI_WIN2K)

typedef
NTSTATUS
(*PWMI_EXECUTE_METHOD) (
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp,
    IN ULONG GuidIndex,
    IN ULONG InstanceIndex,
    IN ULONG MethodId,
    IN ULONG InBufferSize,
    IN ULONG OutBufferSize,
    IN OUT PUCHAR Buffer
    );
/*++

Routine Description:

    This routine is a callback into the driver to execute a method. When the
    driver has finished filling the data block it must call
    WmiCompleteRequest to complete the irp. The driver can
    return STATUS_PENDING if the irp cannot be completed immediately.

    Implementations of this routine may be in paged memory

Arguments:

    DeviceObject is the device whose data block is being queried

    Irp is the Irp that makes this request

    GuidIndex is the index into the list of guids provided when the
        device registered

    InstanceIndex is the index that denotes which instance of the data block
        is being called.

    MethodId has the id of the method being called

    InBufferSize has the size of the data block passed in as the input to
        the method.

    OutBufferSize on entry has the maximum size available to write the
        returned data block.

    Buffer on entry has the input data block and on return has the output
        output data block.


Return Value:

    status

--*/

#endif // (NTDDI_VERSION >= NTDDI_WIN2K)
#if (NTDDI_VERSION >= NTDDI_WIN2K)

typedef enum
{
    WmiEventControl,       // Enable or disable an event
    WmiDataBlockControl    // Enable or disable data block collection
} WMIENABLEDISABLECONTROL;

#endif // (NTDDI_VERSION >= NTDDI_WIN2K)
#if (NTDDI_VERSION >= NTDDI_WIN2K)

typedef
NTSTATUS
(*PWMI_FUNCTION_CONTROL) (
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp,
    IN ULONG GuidIndex,
    IN WMIENABLEDISABLECONTROL Function,
    IN BOOLEAN Enable
    );
/*++

Routine Description:

    This routine is a callback into the driver to enabled or disable event
    generation or data block collection. A device should only expect a
    single enable when the first event or data consumer enables events or
    data collection and a single disable when the last event or data
    consumer disables events or data collection. Data blocks will only
    receive collection enable/disable if they were registered as requiring
    it.

    Implementations of this routine may be in paged memory

Arguments:

    DeviceObject is the device whose data block is being queried

    GuidIndex is the index into the list of guids provided when the
        device registered

    Function specifies which functionality is being enabled or disabled

    Enable is TRUE then the function is being enabled else disabled

Return Value:

    status

--*/

#endif // (NTDDI_VERSION >= NTDDI_WIN2K)
#if (NTDDI_VERSION >= NTDDI_WIN2K)

//
// This structure supplies context information for WMILIB to process the
// WMI irps. Memory for this structure may be paged.
typedef struct _WMILIB_CONTEXT
{
    //
    // WMI data block guid registration info
    ULONG GuidCount;
    PWMIGUIDREGINFO GuidList;

    //
    // WMI functionality callbacks
    PWMI_QUERY_REGINFO       QueryWmiRegInfo;
    PWMI_QUERY_DATABLOCK     QueryWmiDataBlock;
    PWMI_SET_DATABLOCK       SetWmiDataBlock;
    PWMI_SET_DATAITEM        SetWmiDataItem;
    PWMI_EXECUTE_METHOD      ExecuteWmiMethod;
    PWMI_FUNCTION_CONTROL    WmiFunctionControl;
} WMILIB_CONTEXT, *PWMILIB_CONTEXT;

#endif // (NTDDI_VERSION >= NTDDI_WIN2K)
#if (NTDDI_VERSION >= NTDDI_WIN2K)

NTSTATUS
WmiCompleteRequest(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp,
    IN NTSTATUS Status,
    IN ULONG BufferUsed,
    IN CCHAR PriorityBoost
    );
/*++

Routine Description:


    This routine will do the work of completing a WMI irp. Depending upon the
    the WMI request this routine will fixup the returned WNODE appropriately.

    This may be called at DPC level
Arguments:

    DeviceObject - Supplies a pointer to the device object for this request.

    Irp - Supplies the Irp making the request.

    Status has the return status code for the IRP

    BufferUsed has the number of bytes needed by the device to return the
       data requested in any query. In the case that the buffer passed to
       the device is too small this has the number of bytes needed for the
       return data. If the buffer passed is large enough then this has the
       number of bytes actually used by the device.

    PriorityBoost is the value used for the IoCompleteRequest call.

Return Value:

    status

--*/

#endif // (NTDDI_VERSION >= NTDDI_WIN2K)
#if (NTDDI_VERSION >= NTDDI_WIN2K)

typedef enum
{
    IrpProcessed,    // Irp was processed and possibly completed
    IrpNotCompleted, // Irp was process and NOT completed
    IrpNotWmi,       // Irp is not a WMI irp
    IrpForward       // Irp is wmi irp, but targeted at another device object
} SYSCTL_IRP_DISPOSITION, *PSYSCTL_IRP_DISPOSITION;

#endif // (NTDDI_VERSION >= NTDDI_WIN2K)
#if (NTDDI_VERSION >= NTDDI_WIN2K)

NTSTATUS
WmiSystemControl(
    IN PWMILIB_CONTEXT WmiLibInfo,
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp,
    OUT PSYSCTL_IRP_DISPOSITION IrpDisposition
    );
/*++

Routine Description:

    Dispatch helper routine for IRP_MJ_SYSTEM_CONTROL. This routine will
    determine if the irp passed contains a WMI request and if so process it
    by invoking the appropriate callback in the WMILIB structure.

    This routine may only be called at passive level

Arguments:

    WmiLibInfo has the WMI information control block

    DeviceObject - Supplies a pointer to the device object for this request.

    Irp - Supplies the Irp making the request.

    IrpDisposition - Returns a value that specifies how the irp was handled.

Return Value:

    status

--*/

#endif // (NTDDI_VERSION >= NTDDI_WIN2K)
#if (NTDDI_VERSION >= NTDDI_WIN2K)

NTSTATUS
WmiFireEvent(
    IN PDEVICE_OBJECT DeviceObject,
    IN LPGUID Guid,
    IN ULONG InstanceIndex,
    IN ULONG EventDataSize,
    IN PVOID EventData
    );
/*++

Routine Description:

    This routine will fire a WMI event using the data buffer passed. This
    routine may be called at or below DPC level

Arguments:

    DeviceObject - Supplies a pointer to the device object for this event

    Guid is pointer to the GUID that represents the event

    InstanceIndex is the index of the instance of the event

    EventDataSize is the number of bytes of data that is being fired with
       with the event

    EventData is the data that is fired with the events. This may be NULL
        if there is no data associated with the event


Return Value:

    status

--*/

#endif // (NTDDI_VERSION >= NTDDI_WIN2K)

#ifdef __cplusplus
}
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\win2k8\ddk\inc\wmiguid.h ===
/*++

Copyright (c) Microsoft Corporation.  All rights reserved.

Module Name:

    wmiguid.h

Abstract:

    Defines GUIDs that represent data blocks that can be retrieved via WMI

--*/

#include <guiddef.h>

#if (NTDDI_VERSION >= NTDDI_WIN2K)

//
// This is WMI guid used to return disk performance information from
// diskperf.sys (see DISK_PERFORMANCE data structure)

DEFINE_GUID (DiskPerfGuid, 0xBDD865D1,0xD7C1,0x11d0,0xA5,0x01,0x00,0xA0,0xC9,0x06,0x29,0x10);

#endif // (NTDDI_VERSION >= NTDDI_WIN2K)
#if (NTDDI_VERSION >= NTDDI_WIN2K)

//
// This guid will return additional information about a data provider
// {5494DFDC-A98A-11d1-BF43-00A0C9062910}
#define DATA_PROVIDER_INFO_GUID \
   {0x5494dfdc, 0xa98a, 0x11d1, 0xbf, 0x43, 0x0, 0xa0, 0xc9, 0x6, 0x29, 0x10}

#endif // (NTDDI_VERSION >= NTDDI_WIN2K)
#if (NTDDI_VERSION >= NTDDI_WIN2K)

//
// This wmi guid is used to return the entire SMBIOS data table
// {8F680850-A584-11d1-BF38-00A0C9062910}
#define SMBIOS_DATA_GUID \
   {0x8f680850, 0xa584, 0x11d1, 0xbf, 0x38, 0x0, 0xa0, 0xc9, 0x6, 0x29, 0x10}

#endif // (NTDDI_VERSION >= NTDDI_WIN2K)
#if (NTDDI_VERSION >= NTDDI_WIN2K)

//
// This wmi guid is used to return thermal information
// {A1BC18C0-A7C8-11d1-BF3C-00A0C9062910}
DEFINE_GUID(THERMAL_ZONE_GUID,  \
   0xa1bc18c0, 0xa7c8, 0x11d1, 0xbf, 0x3c, 0x0, 0xa0, 0xc9, 0x6, 0x29, 0x10);

#endif // (NTDDI_VERSION >= NTDDI_WIN2K)
#if (NTDDI_VERSION >= NTDDI_WIN2K)

//
// This wmi guid is used to return additional information about the provider
// of an instance name. Note that only QuerySingleInstance is supported.
// {C7BF35D0-AADB-11d1-BF4A-00A0C9062910}
#define INSTANCE_INFO_GUID \
    {0xc7bf35d0, 0xaadb, 0x11d1, 0xbf, 0x4a, 0x0, 0xa0, 0xc9, 0x6, 0x29, 0x10}
    
#endif // (NTDDI_VERSION >= NTDDI_WIN2K)
#if (NTDDI_VERSION >= NTDDI_WIN2K)

#define BINARY_MOF_GUID \
    {0x05901221, 0xD566, 0x11d1, 0xB2, 0xF0, 0x00, 0xA0, 0xC9, 0x06, 0x29, 0x10}
    
#endif // (NTDDI_VERSION >= NTDDI_WIN2K)
#if (NTDDI_VERSION >= NTDDI_WIN2K)

#define ENUMERATE_GUIDS_GUID \
    {0xe3dff7bd, 0x3915, 0x11d2, 0x91, 0x03, 0x00, 0xc0, 0x4f, 0xb9, 0x98, 0xa2}
    
#endif // (NTDDI_VERSION >= NTDDI_WIN2K)
#if (NTDDI_VERSION >= NTDDI_WIN2K)

//
// Global WMI Logger GUID
//

DEFINE_GUID ( /* e8908abc-aa84-11d2-9a93-00805f85d7c6 */
    GlobalLoggerGuid,
    0xe8908abc,
    0xaa84,
    0x11d2,
    0x9a, 0x93, 0x00, 0x80, 0x5f, 0x85, 0xd7, 0xc6
  );

#endif // (NTDDI_VERSION >= NTDDI_WIN2K)
#if (NTDDI_VERSION >= NTDDI_WIN2K)

DEFINE_GUID ( /* 8d40301f-ab4a-11d2-9a93-00805f85d7c6 */
    GenericMessageGuid,
    0x8d40301f,
    0xab4a,
    0x11d2,
    0x9a, 0x93, 0x00, 0x80, 0x5f, 0x85, 0xd7, 0xc6
  );

#endif // (NTDDI_VERSION >= NTDDI_WIN2K)

//
// Event Trace GUIDs
//

#if (NTDDI_VERSION >= NTDDI_WIN2K)

DEFINE_GUID ( /* 3d6fa8d0-fe05-11d0-9dda-00c04fd7ba7c */
    ProcessGuid,
    0x3d6fa8d0,
    0xfe05,
    0x11d0,
    0x9d, 0xda, 0x00, 0xc0, 0x4f, 0xd7, 0xba, 0x7c
  );

#endif // (NTDDI_VERSION >= NTDDI_WIN2K)
#if (NTDDI_VERSION >= NTDDI_WIN2K)

DEFINE_GUID ( /* 3d6fa8d1-fe05-11d0-9dda-00c04fd7ba7c */
    ThreadGuid,
    0x3d6fa8d1,
    0xfe05,
    0x11d0,
    0x9d, 0xda, 0x00, 0xc0, 0x4f, 0xd7, 0xba, 0x7c
  );

#endif // (NTDDI_VERSION >= NTDDI_WIN2K)
#if (NTDDI_VERSION >= NTDDI_WIN2K)

DEFINE_GUID ( /* 3d6fa8d3-fe05-11d0-9dda-00c04fd7ba7c */
    PageFaultGuid,
    0x3d6fa8d3,
    0xfe05,
    0x11d0,
    0x9d, 0xda, 0x00, 0xc0, 0x4f, 0xd7, 0xba, 0x7c
  );

#endif // (NTDDI_VERSION >= NTDDI_WIN2K)
#if (NTDDI_VERSION >= NTDDI_WIN2K)

DEFINE_GUID ( /* 3d6fa8d4-fe05-11d0-9dda-00c04fd7ba7c */
    DiskIoGuid,
    0x3d6fa8d4,
    0xfe05,
    0x11d0,
    0x9d, 0xda, 0x00, 0xc0, 0x4f, 0xd7, 0xba, 0x7c
  );

#endif // (NTDDI_VERSION >= NTDDI_WIN2K)
#if (NTDDI_VERSION >= NTDDI_WIN2K)

DEFINE_GUID ( /* 90cbdc39-4a3e-11d1-84f4-0000f80464e3 */
    FileIoGuid,
    0x90cbdc39,
    0x4a3e,
    0x11d1,
    0x84, 0xf4, 0x00, 0x00, 0xf8, 0x04, 0x64, 0xe3
  );

#endif // (NTDDI_VERSION >= NTDDI_WIN2K)
#if (NTDDI_VERSION >= NTDDI_WIN2K)

DEFINE_GUID ( /* 9a280ac0-c8e0-11d1-84e2-00c04fb998a2 */
    TcpIpGuid,
    0x9a280ac0,
    0xc8e0,
    0x11d1,
    0x84, 0xe2, 0x00, 0xc0, 0x4f, 0xb9, 0x98, 0xa2
  );

#endif // (NTDDI_VERSION >= NTDDI_WIN2K)
#if (NTDDI_VERSION >= NTDDI_WIN2K)

DEFINE_GUID ( /* bf3a50c5-a9c9-4988-a005-2df0b7c80f80 */
    UdpIpGuid,
    0xbf3a50c5,
    0xa9c9,
    0x4988,
    0xa0, 0x05, 0x2d, 0xf0, 0xb7, 0xc8, 0x0f, 0x80
  );

#endif // (NTDDI_VERSION >= NTDDI_WIN2K)
#if (NTDDI_VERSION >= NTDDI_WIN2K)

DEFINE_GUID ( /* 2cb15d1d-5fc1-11d2-abe1-00a0c911f518 */
    ImageLoadGuid,
    0x2cb15d1d,
    0x5fc1,
    0x11d2,
    0xab, 0xe1, 0x00, 0xa0, 0xc9, 0x11, 0xf5, 0x18
  );

#endif // (NTDDI_VERSION >= NTDDI_WIN2K)
#if (NTDDI_VERSION >= NTDDI_WIN2K)

DEFINE_GUID ( /* AE53722E-C863-11d2-8659-00C04FA321A1 */
    RegistryGuid, 
    0xae53722e,
    0xc863,
    0x11d2,
    0x86, 0x59, 0x0, 0xc0, 0x4f, 0xa3, 0x21, 0xa1
);

#endif // (NTDDI_VERSION >= NTDDI_WIN2K)

//
// Special WMI events
//

#if (NTDDI_VERSION >= NTDDI_WIN2K)

DEFINE_GUID ( /* 398191dc-2da7-11d3-8b98-00805f85d7c6 */
    TraceErrorGuid,
    0x398191dc,
    0x2da7,
    0x11d3,
    0x8b, 0x98, 0x00, 0x80, 0x5f, 0x85, 0xd7, 0xc6
  );

#endif // (NTDDI_VERSION >= NTDDI_WIN2K)
#if ((NTDDI_VERSION >= NTDDI_WIN2K) && (NTDDI_VERSION < NTDDI_VISTA))

DEFINE_GUID ( /* 3d6fa8d2-fe05-11d0-9dda-00c04fd7ba7c */ /* Not used */
    HardFaultGuid,
    0x3d6fa8d2,
    0xfe05,
    0x11d0,
    0x9d, 0xda, 0x00, 0xc0, 0x4f, 0xd7, 0xba, 0x7c
  );

#endif // ((NTDDI_VERSION >= NTDDI_WIN2K) && (NTDDI_VERSION < NTDDI_VISTA))
#if (NTDDI_VERSION >= NTDDI_WINXP)

DEFINE_GUID ( /* 44608a51-1851-4456-98b2-b300e931ee41 */
    WmiEventLoggerGuid,
    0x44608a51,
    0x1851,
    0x4456,
    0x98, 0xb2, 0xb3, 0x00, 0xe9, 0x31, 0xee, 0x41
  );

#endif // (NTDDI_VERSION >= NTDDI_WINXP)
#if (NTDDI_VERSION >= NTDDI_WINXP)

//
// This wmi guid is used to return the SMBIOS Identifer data
// {98A2B9D7-94DD-496a-847E-67A5557A59F2}
//
// MS_SystemInformation - MS_SystemInformation
#define MS_SYSTEM_INFORMATIONGUID \
    { 0x98a2b9d7,0x94dd,0x496a, { 0x84,0x7e,0x67,0xa5,0x55,0x7a,0x59,0xf2 } }

DEFINE_GUID(MS_SYSTEM_INFORMATION_GUID, \
            0x98a2b9d7,0x94dd,0x496a,0x84,0x7e,0x67,0xa5,0x55,0x7a,0x59,0xf2);

#endif // (NTDDI_VERSION >= NTDDI_WINXP)
#if (NTDDI_VERSION >= NTDDI_WINXP)

DEFINE_GUID( /* 13976D09-A327-438c-950B-7F03192815C7  */
    DbgPrintGuid,
    0x13976d09,
    0xa327,
    0x438c,
    0x95, 0xb, 0x7f, 0x3, 0x19, 0x28, 0x15, 0xc7
    );

#endif // (NTDDI_VERSION >= NTDDI_WINXP)
#if (NTDDI_VERSION >= NTDDI_VISTA)

//
// Event Log Logger GUID
//
DEFINE_GUID( /* b16f9f5e-bcda-4027-9318-adf2b79df73b */
	EventLogGuid,
	0xb16f9f5e, 
	0xb3da, 
	0x4027, 
	0x93, 0x18, 0xad, 0xf2, 0xb7, 0x9d, 0xf7, 0x3b 
  );

#endif // (NTDDI_VERSION >= NTDDI_VISTA)
#if (NTDDI_VERSION >= NTDDI_VISTA)

//
// Driver Verifier Events
//

DEFINE_GUID ( /* D56CA431-61BF-4904-A621-00E0381E4DDE */
    DriverVerifierGuid, 
    0xd56ca431, 
    0x61bf, 
    0x4904, 
    0xa6, 0x21, 0x0, 0xe0, 0x38, 0x1e, 0x4d, 0xde
    );

#endif // (NTDDI_VERSION >= NTDDI_VISTA)
#if (NTDDI_VERSION >= NTDDI_VISTA)

//
// Application Verifier Events
//

DEFINE_GUID( /* 78d14f17-0105-46d7-bfff-6fbea2f3f358 */
    ApplicationVerifierGuid,
    0x78d14f17,
    0x0105,
    0x46d7,
    0xbf, 0xff, 0x6f, 0xbe, 0xa2, 0xf3, 0xf3, 0x58
    );

#endif // (NTDDI_VERSION >= NTDDI_VISTA)
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\win2k8\ddk\inc\xfilter.h ===
/*++

Copyright (c) Microsoft Corporation. All rights reserved.

Module Name:

    xfilter.h

Abstract:

    Header file for the address filtering library for NDIS MAC's.

Author:

Environment:

Notes:

    None.

Revision History:

--*/

#ifndef _X_FILTER_DEFS_
#define _X_FILTER_DEFS_

#pragma once

#define ETH_LENGTH_OF_ADDRESS 6


//
// ZZZ This is a little-endian specific check.
//
#define ETH_IS_MULTICAST(Address) \
    (BOOLEAN)(((PUCHAR)(Address))[0] & ((UCHAR)0x01))


//
// Check whether an address is broadcast.
//
#define ETH_IS_BROADCAST(Address)               \
    ((((PUCHAR)(Address))[0] == ((UCHAR)0xff)) && (((PUCHAR)(Address))[1] == ((UCHAR)0xff)) && (((PUCHAR)(Address))[2] == ((UCHAR)0xff)) && (((PUCHAR)(Address))[3] == ((UCHAR)0xff)) && (((PUCHAR)(Address))[4] == ((UCHAR)0xff)) && (((PUCHAR)(Address))[5] == ((UCHAR)0xff)))


//
// This macro will compare network addresses.
//
//  A - Is a network address.
//
//  B - Is a network address.
//
//  Result - The result of comparing two network address.
//
//  Result < 0 Implies the B address is greater.
//  Result > 0 Implies the A element is greater.
//  Result = 0 Implies equality.
//
// Note that this is an arbitrary ordering.  There is not
// defined relation on network addresses.  This is ad-hoc!
//
//
#define ETH_COMPARE_NETWORK_ADDRESSES(_A, _B, _Result)          \
{                                                               \
    if (*(ULONG UNALIGNED *)&(_A)[2] >                          \
         *(ULONG UNALIGNED *)&(_B)[2])                          \
    {                                                           \
        *(_Result) = 1;                                         \
    }                                                           \
    else if (*(ULONG UNALIGNED *)&(_A)[2] <                     \
                *(ULONG UNALIGNED *)&(_B)[2])                   \
    {                                                           \
        *(_Result) = (UINT)-1;                                  \
    }                                                           \
    else if (*(USHORT UNALIGNED *)(_A) >                        \
                *(USHORT UNALIGNED *)(_B))                      \
    {                                                           \
        *(_Result) = 1;                                         \
    }                                                           \
    else if (*(USHORT UNALIGNED *)(_A) <                        \
                *(USHORT UNALIGNED *)(_B))                      \
    {                                                           \
        *(_Result) = (UINT)-1;                                  \
    }                                                           \
    else                                                        \
    {                                                           \
        *(_Result) = 0;                                         \
    }                                                           \
}

//
// This macro will compare network addresses.
//
//  A - Is a network address.
//
//  B - Is a network address.
//
//  Result - The result of comparing two network address.
//
//  Result != 0 Implies inequality.
//  Result == 0 Implies equality.
//
//
#define ETH_COMPARE_NETWORK_ADDRESSES_EQ(_A,_B, _Result)        \
{                                                               \
    if ((*(ULONG UNALIGNED *)&(_A)[2] ==                        \
            *(ULONG UNALIGNED *)&(_B)[2]) &&                    \
         (*(USHORT UNALIGNED *)(_A) ==                          \
            *(USHORT UNALIGNED *)(_B)))                         \
    {                                                           \
        *(_Result) = 0;                                         \
    }                                                           \
    else                                                        \
    {                                                           \
        *(_Result) = 1;                                         \
    }                                                           \
}


//
// This macro is used to copy from one network address to
// another.
//
#define ETH_COPY_NETWORK_ADDRESS(_D, _S) \
{ \
    *((ULONG UNALIGNED *)(_D)) = *((ULONG UNALIGNED *)(_S)); \
    *((USHORT UNALIGNED *)((UCHAR *)(_D)+4)) = *((USHORT UNALIGNED *)((UCHAR *)(_S)+4)); \
}

#define TR_LENGTH_OF_FUNCTIONAL     4
#define TR_LENGTH_OF_ADDRESS        6


//
// Only the low 32 bits of the functional/group address
// are needed since the upper 16 bits is always c0-00.
//
typedef ULONG TR_FUNCTIONAL_ADDRESS;
typedef ULONG TR_GROUP_ADDRESS;


#define TR_IS_NOT_DIRECTED(_Address, _Result)                               \
{                                                                           \
    *(_Result) = (BOOLEAN)((_Address)[0] & 0x80);                           \
}

#define TR_IS_FUNCTIONAL(_Address, _Result)                                 \
{                                                                           \
    *(_Result) = (BOOLEAN)(((_Address)[0] & 0x80) &&                        \
                          !((_Address)[2] & 0x80));                         \
}

//
//
#define TR_IS_GROUP(_Address, _Result)                                      \
{                                                                           \
    *(_Result) = (BOOLEAN)((_Address)[0] & (_Address)[2] & 0x80);           \
}

//
//
#define TR_IS_SOURCE_ROUTING(_Address, _Result)                             \
{                                                                           \
    *(_Result) = (BOOLEAN)((_Address)[0] & 0x80);                           \
}

//
//  Check for NDIS_PACKET_TYPE_MAC_FRAME
//
#define TR_IS_MAC_FRAME(_PacketHeader)  ((((PUCHAR)_PacketHeader)[1] & 0xFC) == 0)


//
// Check whether an address is broadcast. This is a little-endian check.
//
#define TR_IS_BROADCAST(_Address, _Result)                                      \
{                                                                               \
    *(_Result) = (BOOLEAN)(((*(UNALIGNED USHORT *)&(_Address)[0] == 0xFFFF) ||  \
                            (*(UNALIGNED USHORT *)&(_Address)[0] == 0x00C0)) && \
                            (*(UNALIGNED ULONG  *)&(_Address)[2] == 0xFFFFFFFF));\
}


//
// This macro will compare network addresses.
//
//  A - Is a network address.
//
//  B - Is a network address.
//
//  Result - The result of comparing two network address.
//
//  Result < 0 Implies the B address is greater.
//  Result > 0 Implies the A element is greater.
//  Result = 0 Implies equality.
//
// Note that this is an arbitrary ordering.  There is not
// defined relation on network addresses.  This is ad-hoc!
//
//
#define TR_COMPARE_NETWORK_ADDRESSES(_A, _B, _Result)           \
{                                                               \
    if (*(ULONG UNALIGNED *)&(_A)[2] >                          \
        *(ULONG UNALIGNED *)&(_B)[2])                           \
    {                                                           \
        *(_Result) = 1;                                         \
    }                                                           \
    else if (*(ULONG UNALIGNED *)&(_A)[2] <                     \
             *(ULONG UNALIGNED *)&(_B)[2])                      \
    {                                                           \
        *(_Result) = (UINT)-1;                                  \
    }                                                           \
    else if (*(USHORT UNALIGNED *)(_A) >                        \
             *(USHORT UNALIGNED *)(_B))                         \
    {                                                           \
        *(_Result) = 1;                                         \
    }                                                           \
    else if (*(USHORT UNALIGNED *)(_A) <                        \
             *(USHORT UNALIGNED *)(_B))                         \
    {                                                           \
        *(_Result) = (UINT)-1;                                  \
    }                                                           \
    else                                                        \
    {                                                           \
        *(_Result) = 0;                                         \
    }                                                           \
}

//
// This macro will compare network addresses.
//
//  A - Is a network address.
//
//  B - Is a network address.
//
//  Result - The result of comparing two network address.
//
//  Result != 0 Implies inequality.
//  Result == 0 Implies equality.
//
//
#define TR_COMPARE_NETWORK_ADDRESSES_EQ(_A, _B, _Result)                    \
{                                                                           \
    if ((*(ULONG UNALIGNED  *)&(_A)[2] == *(ULONG UNALIGNED  *)&(_B)[2]) && \
        (*(USHORT UNALIGNED *)&(_A)[0] == *(USHORT UNALIGNED *)&(_B)[0]))   \
    {                                                                       \
        *(_Result) = 0;                                                     \
    }                                                                       \
    else                                                                    \
    {                                                                       \
        *(_Result) = 1;                                                     \
    }                                                                       \
}


//
// This macro is used to copy from one network address to
// another.
//
#define TR_COPY_NETWORK_ADDRESS(_D, _S)                                     \
{                                                                           \
    *((ULONG UNALIGNED *)(_D)) = *((ULONG UNALIGNED *)(_S));                \
    *((USHORT UNALIGNED *)((UCHAR *)(_D)+4)) =                              \
                            *((USHORT UNALIGNED *)((UCHAR *)(_S)+4));       \
}

#endif // _X_FILTER_DEFS_
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\win2k8\ddk\inc\wdf\kmdf\1.7\wdf.h ===
/*++

Copyright (c) Microsoft Corporation.  All rights reserved.

Module Name:

    wdf.h

Abstract:

    Main header file for Windows Driver Frameworks

Environment:

    kernel mode only

Revision History:

--*/

#ifndef _WDF_H_
#define _WDF_H_



#ifdef __cplusplus
  #define WDF_EXTERN_C       extern "C"
  #define WDF_EXTERN_C_START extern "C" {
  #define WDF_EXTERN_C_END   }
#else
  #define WDF_EXTERN_C
  #define WDF_EXTERN_C_START
  #define WDF_EXTERN_C_END
#endif

WDF_EXTERN_C_START




typedef VOID (*WDFFUNC) (VOID);
extern WDFFUNC WdfFunctions [];

#ifndef __drv_dispatchType
#include <driverspecs.h>
#endif

// Basic definitions
#include "wdftypes.h"
#include "wdfglobals.h"
#include "wdffuncenum.h"
#include "wdfstatus.h"
#include "wdfassert.h"
#include "wdfverifier.h"
#include "wdfpool.h"

// generic object
#include "wdfobject.h"

// Synchronization
#include "wdfsync.h"

#include "wdfcore.h"

#include "wdfdriver.h"

// Objects
#include "WdfQueryInterface.h"
#include "wdfmemory.h"
#include "wdfchildlist.h"
#include "wdffileobject.h"
#include "wdfdevice.h"
#include "wdfcollection.h"
#include "wdfdpc.h"
#include "wdftimer.h"
#include "wdfworkitem.h"
#include "wdfinterrupt.h"
#include "wdfresource.h"

// I/O
#include "wdfrequest.h"
#include "wdfiotarget.h"
#include "wdfio.h"

// particular device types
#include "wdffdo.h"
#include "wdfpdo.h"
#include "wdfcontrol.h"

#include "WdfWMI.h"

#include "wdfstring.h"
#include "wdfregistry.h"

// Dma
#include "wdfDmaEnabler.h"
#include "wdfDmaTransaction.h"
#include "wdfCommonBuffer.h"

#include "wdfbugcodes.h"
#include "wdfroletypes.h"

WDF_EXTERN_C_END

#endif // _WDF_H_
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\win2k8\ddk\inc\ws2san.h ===
/*++

Copyright (c) Microsoft Corporation. All rights reserved.

Module Name:

    ws2san.h

Abstract:

    This module contains the Microsoft-specific extensions to the Windows
    Sockets SPI for WinSock Direct (SAN) support.

Revision History:

--*/

#ifndef _WS2SAN_H_
#define _WS2SAN_H_

#pragma once

#ifdef __cplusplus
extern "C" {
#endif

/*
 * Option for getting maximum RDMA transfer size supported by provider
 */
#define SO_MAX_RDMA_SIZE                 0x700D

/*
 * Option for getting minimum RDMA transfer size feasible (performance-wise)
 * for the provider
 */
#define SO_RDMA_THRESHOLD_SIZE           0x700E

/*
 * The upcall table. This structure is passed by value to the service
 * provider's WSPStartup() entrypoint.
 */

typedef struct _WSPUPCALLTABLEEX {

    LPWPUCLOSEEVENT               lpWPUCloseEvent;
    LPWPUCLOSESOCKETHANDLE        lpWPUCloseSocketHandle;
    LPWPUCREATEEVENT              lpWPUCreateEvent;
    LPWPUCREATESOCKETHANDLE       lpWPUCreateSocketHandle;
    LPWPUFDISSET                  lpWPUFDIsSet;
    LPWPUGETPROVIDERPATH          lpWPUGetProviderPath;
    LPWPUMODIFYIFSHANDLE          lpWPUModifyIFSHandle;
    LPWPUPOSTMESSAGE              lpWPUPostMessage;
    LPWPUQUERYBLOCKINGCALLBACK    lpWPUQueryBlockingCallback;
    LPWPUQUERYSOCKETHANDLECONTEXT lpWPUQuerySocketHandleContext;
    LPWPUQUEUEAPC                 lpWPUQueueApc;
    LPWPURESETEVENT               lpWPUResetEvent;
    LPWPUSETEVENT                 lpWPUSetEvent;
    LPWPUOPENCURRENTTHREAD        lpWPUOpenCurrentThread;
    LPWPUCLOSETHREAD              lpWPUCloseThread;
    LPWPUCOMPLETEOVERLAPPEDREQUEST lpWPUCompleteOverlappedRequest;

} WSPUPCALLTABLEEX, FAR * LPWSPUPCALLTABLEEX;

/*
 *  An extended WSABUF, that includes a registration handle
 */

typedef struct _WSABUFEX {
    u_long      len;     /* the length of the buffer */
    char FAR *  buf;     /* the pointer to the buffer */
    HANDLE  handle; /*  The handle returned by WSPRegisterMemory */
} WSABUFEX, FAR * LPWSABUFEX;


/*
 *  WinSock 2 SPI socket function prototypes
 */

int
WSPAPI
WSPStartupEx(
    IN WORD wVersionRequested,
    OUT LPWSPDATA lpWSPData,
    IN LPWSAPROTOCOL_INFOW lpProtocolInfo,
    IN LPWSPUPCALLTABLEEX lpUpcallTable,
    OUT LPWSPPROC_TABLE lpProcTable
    );

typedef
int
(WSPAPI * LPWSPSTARTUPEX)(
    WORD wVersionRequested,
    LPWSPDATA lpWSPData,
    LPWSAPROTOCOL_INFOW lpProtocolInfo,
    LPWSPUPCALLTABLEEX lpUpcallTable,
    LPWSPPROC_TABLE lpProcTable
    );

#define WSAID_REGISTERMEMORY \
        {0xC0B422F5,0xF58C,0x11d1,{0xAD,0x6C,0x00,0xC0,0x4F,0xA3,0x4A,0x2D}}

#define WSAID_DEREGISTERMEMORY \
        {0xC0B422F6,0xF58C,0x11d1,{0xAD,0x6C,0x00,0xC0,0x4F,0xA3,0x4A,0x2D}}

#define WSAID_REGISTERRDMAMEMORY \
        {0xC0B422F7,0xF58C,0x11d1,{0xAD,0x6C,0x00,0xC0,0x4F,0xA3,0x4A,0x2D}}

#define WSAID_DEREGISTERRDMAMEMORY \
        {0xC0B422F8,0xF58C,0x11d1,{0xAD,0x6C,0x00,0xC0,0x4F,0xA3,0x4A,0x2D}}

#define WSAID_RDMAWRITE \
        {0xC0B422F9,0xF58C,0x11d1,{0xAD,0x6C,0x00,0xC0,0x4F,0xA3,0x4A,0x2D}}

#define WSAID_RDMAREAD \
        {0xC0B422FA,0xF58C,0x11d1,{0xAD,0x6C,0x00,0xC0,0x4F,0xA3,0x4A,0x2D}}

#if(_WIN32_WINNT >= 0x0501)
#define WSAID_MEMORYREGISTRATIONCACHECALLBACK \
        {0xE5DA4AF8,0xD824,0x48CD,{0xA7,0x99,0x63,0x37,0xA9,0x8E,0xD2,0xAF}}
#endif //(_WIN32_WINNT >= 0x0501)

#define MEM_READ        1
#define MEM_WRITE       2
#define MEM_READWRITE   3


HANDLE WSPAPI
WSPRegisterMemory(
    IN SOCKET s,
    __in_bcount(dwBufferLength) PVOID lpBuffer,
    IN DWORD dwBufferLength,
    IN DWORD dwFlags,
    OUT LPINT lpErrno
    );

int WSPAPI
WSPDeregisterMemory(
    IN SOCKET s,
    IN HANDLE handle,
    OUT LPINT lpErrno
    );

int WSPAPI
WSPRegisterRdmaMemory(
    IN SOCKET s,
    __in_bcount(dwBufferLength) PVOID lpBuffer,
    IN DWORD dwBufferLength,
    IN DWORD dwFlags,
    __out_bcount(*lpdwDescriptorLength) LPVOID lpRdmaBufferDescriptor,
    IN OUT LPDWORD lpdwDescriptorLength,
    OUT LPINT lpErrno
    );

int WSPAPI
WSPDeregisterRdmaMemory(
    IN SOCKET s,
    __in_bcount(dwDescriptorLength) LPVOID lpRdmaBufferDescriptor,
    IN DWORD dwDescriptorLength,
    OUT LPINT lpErrno
    );

int WSPAPI
WSPRdmaWrite(
    IN SOCKET s,
    __in_ecount(dwBufferCount) LPWSABUFEX lpBuffers,
    IN DWORD dwBufferCount,
    __in_bcount(dwTargetDescriptorLength) LPVOID lpTargetBufferDescriptor,
    IN DWORD dwTargetDescriptorLength,
    IN DWORD dwTargetBufferOffset,
    OUT LPDWORD lpdwNumberOfBytesWritten,
    IN DWORD dwFlags,
    __in LPWSAOVERLAPPED lpOverlapped,
    __in_opt LPWSAOVERLAPPED_COMPLETION_ROUTINE lpCompletionRoutine,
    IN LPWSATHREADID lpThreadId,
    OUT LPINT lpErrno
    );

int WSPAPI
WSPRdmaRead(
    IN SOCKET s,
    __in_ecount(dwBufferCount) LPWSABUFEX lpBuffers,
    IN DWORD dwBufferCount,
    __in_bcount(dwTargetDescriptorLength) LPVOID lpTargetBufferDescriptor,
    IN DWORD dwTargetDescriptorLength,
    IN DWORD dwTargetBufferOffset,
    OUT LPDWORD lpdwNumberOfBytesRead,
    IN DWORD dwFlags,
    __in LPWSAOVERLAPPED lpOverlapped,
    __in_opt LPWSAOVERLAPPED_COMPLETION_ROUTINE lpCompletionRoutine,
    IN LPWSATHREADID lpThreadId,
    OUT LPINT lpErrno
    );

#if(_WIN32_WINNT >= 0x0501)
int WSPAPI
WSPMemoryRegistrationCacheCallback(
    __in_bcount(Size) LPVOID lpvAddress,                             
    IN SIZE_T Size,                               
    OUT LPINT lpErrno                
    );
#endif //(_WIN32_WINNT >= 0x0501)

/*
 * "QueryInterface" versions of the above APIs.
 */

typedef
HANDLE
(WSPAPI * LPFN_WSPREGISTERMEMORY)(
    IN SOCKET s,
    IN PVOID lpBuffer,
    IN DWORD dwBufferLength,
    IN DWORD dwFlags,
    OUT LPINT lpErrno
    );

typedef
int
(WSPAPI * LPFN_WSPDEREGISTERMEMORY)(
    IN SOCKET s,
    IN HANDLE handle,
    OUT LPINT lpErrno
    );

typedef
BOOL
(WSPAPI * LPFN_WSPREGISTERRDMAMEMORY)(
    IN SOCKET s,
    IN PVOID lpBuffer,
    IN DWORD dwBufferLength,
    IN DWORD dwFlags,
    OUT LPVOID lpRdmaBufferDescriptor,
    IN OUT LPDWORD lpdwDescriptorLength,
    OUT LPINT lpErrno
    );

typedef
int
(WSPAPI * LPFN_WSPDEREGISTERRDMAMEMORY)(
    IN SOCKET s,
    IN LPVOID lpRdmaBufferDescriptor,
    IN DWORD dwDescriptorLength,
    OUT LPINT lpErrno
    );

typedef
int
(WSPAPI * LPFN_WSPRDMAWRITE)(
    IN SOCKET s,
    IN LPWSABUFEX lpBuffers,
    IN DWORD dwBufferCount,
    IN LPVOID lpTargetBufferDescriptor,
    IN DWORD dwTargetDescriptorLength,
    IN DWORD dwTargetBufferOffset,
    OUT LPDWORD lpdwNumberOfBytesWritten,
    IN DWORD dwFlags,
    IN LPWSAOVERLAPPED lpOverlapped,
    IN LPWSAOVERLAPPED_COMPLETION_ROUTINE lpCompletionRoutine,
    IN LPWSATHREADID lpThreadId,
    OUT LPINT lpErrno
    );

typedef
int
(WSPAPI * LPFN_WSPRDMAREAD)(
    IN SOCKET s,
    IN LPWSABUFEX lpBuffers,
    IN DWORD dwBufferCount,
    IN LPVOID lpTargetBufferDescriptor,
    IN DWORD dwTargetDescriptorLength,
    IN DWORD dwTargetBufferOffset,
    OUT LPDWORD lpdwNumberOfBytesRead,
    IN DWORD dwFlags,
    IN LPWSAOVERLAPPED lpOverlapped,
    IN LPWSAOVERLAPPED_COMPLETION_ROUTINE lpCompletionRoutine,
    IN LPWSATHREADID lpThreadId,
    OUT LPINT lpErrno
    );

#if(_WIN32_WINNT >= 0x0501)
typedef
int 
(WSPAPI * LPFN_WSPMEMORYREGISTRATIONCACHECALLBACK)(
    IN LPVOID lpvAddress,                             
    IN SIZE_T Size,                               
    OUT LPINT lpErrno                
    );
#endif //(_WIN32_WINNT >= 0x0501)

#ifdef __cplusplus
}
#endif

#endif // _WS2SAN_H_
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\win2k8\ddk\inc\wsk.h ===
/*++

Copyright (c) Microsoft Corporation. All rights reserved.

Module Name:

    wsk.h

Abstract:

    This module contains the definitions and structures for
    the Windows Sockets Kernel-Mode Interface.

Environment:

    Kernel-Mode only

--*/

#ifndef _WSK_
#define _WSK_

#pragma once

#ifdef __cplusplus
extern "C" {
#endif

#include <netioddk.h>
#include <ws2def.h>
#include <mswsockdef.h>

//
// Socket object. 
//
// 'Dispatch' can be one of 4 types depending on the socket type:
// PWSK_PROVIDER_BASIC_DISPATCH, PWSK_PROVIDER_LISTEN_DISPATCH,
// PWSK_PROVIDER_DATAGRAM_DISPATCH, PWSK_PROVIDER_CONNECTION_DISPATCH
//

typedef struct _WSK_SOCKET {
    CONST VOID        *Dispatch;
} WSK_SOCKET, *PWSK_SOCKET;

//
// Client object
//
typedef PVOID PWSK_CLIENT;

//
// WSK API calling convention
//
#define WSKAPI NTAPI

//
// WSK Interface ID
//
extern CONST NPIID NPI_WSK_INTERFACE_ID;

//
// WSK client must use the following macro to initialize the Version field
// in its WSK_CLIENT_DISPATCH structure.
//
#define MAKE_WSK_VERSION(Mj, Mn) ((USHORT)((Mj) << 8) | (USHORT)((Mn) & 0xff))

//
// WSK client must use the following macros to extract the Major and Minor
// version numbers from the HighestVersion and LowestVersion fields of the
// WSK_PROVIDER_CHARACTERISTICS structure, and the Version field of the
// WSK_PROVIDER_DISPATCH structure.
//
#define WSK_MAJOR_VERSION(V) ((UCHAR)((V) >> 8))
#define WSK_MINOR_VERSION(V) ((UCHAR)(V))

//
// WSK Provider characteristics determine the range of versions of the WSK
// interface supported by the WSK provider
//

typedef struct _WSK_PROVIDER_CHARACTERISTICS {
    USHORT HighestVersion;
    USHORT LowestVersion;
} WSK_PROVIDER_CHARACTERISTICS, *PWSK_PROVIDER_CHARACTERISTICS;

//
// Transport information structure
//

typedef struct _WSK_TRANSPORT {
    USHORT         Version; // Version of the transport
    USHORT         SocketType;
    ULONG          Protocol;
    ADDRESS_FAMILY AddressFamily;
    GUID           ProviderId; 
} WSK_TRANSPORT, *PWSK_TRANSPORT;

//
// Buffer structure used for sending/receiving data.
// Mdl points to a chain of memory descriptors (scatter/gather list).
// The data described begin at 'Offset' and extend for 'Length' bytes.
// N.B. 'Offset' is required to lie entirely within the first MDL in 
// the chain.
//

typedef struct _WSK_BUF {
    PMDL          Mdl;    // Locked MDL chain
    ULONG         Offset; // Offset into the "first" Mdl in the chain
    SIZE_T        Length; // Length of data starting from Offset
} WSK_BUF, *PWSK_BUF;

//
// Data Indication structure used for indicating incoming data buffers
// on connection-oriented sockets.
//

typedef struct _WSK_DATA_INDICATION {
    struct _WSK_DATA_INDICATION *Next;
    WSK_BUF                      Buffer;
} WSK_DATA_INDICATION, *PWSK_DATA_INDICATION;

//
// Datagram Indication structure used for indicating incoming datagrams
// on datagram sockets.
//

typedef struct _WSK_DATAGRAM_INDICATION {
    struct _WSK_DATAGRAM_INDICATION *Next;
    WSK_BUF                          Buffer;
    PCMSGHDR                         ControlInfo;
    ULONG                            ControlInfoLength;
    PSOCKADDR                        RemoteAddress;
} WSK_DATAGRAM_INDICATION, *PWSK_DATAGRAM_INDICATION;

//
// Identification structure used for conditional-accept.
//

typedef struct _WSK_INSPECT_ID {
    ULONG_PTR Key;
    ULONG SerialNumber;
} WSK_INSPECT_ID, *PWSK_INSPECT_ID;

//
// Actions that can be taken for connect request inspection
// on a conditional-accept listening socket.
//

typedef enum {
    WskInspectReject, // reject the connection request
    WskInspectAccept, // proceed with accept
    WskInspectPend,   // delay the decision (use WskInspectComplete later)
    WskInspectMax
} WSK_INSPECT_ACTION, *PWSK_INSPECT_ACTION;

//
// Flag used by some callback routines to indicate that the callback was
// invoked at DISPATCH_LEVEL IRQL.
//

#define WSK_FLAG_AT_DISPATCH_LEVEL 0x00000008

//
// Event indication callbacks
//
// Event indications are delivered in arbitrary thread context.
//

typedef
NTSTATUS
(WSKAPI * PFN_WSK_CLIENT_EVENT) (
    IN  PVOID  ClientContext,
    IN  ULONG  EventType,
    IN  PVOID  Information OPTIONAL,
    IN  SIZE_T InformationLength
    );
/*
 * Indicates client-specific control event. 
 *
 * Parameters:
 *  ClientContext - ClientContext value that was passed to WskRegister
 *  EventType - No event types are currently defined.
 *  Information - Optional event specific information. 
 *  InformationLength - Length of information.
 * Returns:
 *  STATUS_SUCCESS unless otherwise is specified by specific EventTypes.
 */

typedef
NTSTATUS
(WSKAPI * PFN_WSK_RECEIVE_FROM_EVENT) (
    IN  PVOID              SocketContext,
    IN  ULONG              Flags,
    IN  PWSK_DATAGRAM_INDICATION DataIndication OPTIONAL
    );
/*
 * Indicates that one or more datagrams have arrived on one of the datagram 
 * socket objects created by the client
 *
 * Parameters:
 *  SocketContext - Context value associated with the socket on which 
 *     datagram(s) were received.
 *  Flags - MSG_BCAST, MSG_MCAST, WSK_FLAG_AT_DISPATCH_LEVEL
 *  DataIndication - List of one or more datagrams.
 *     NULL denotes that socket needs to be closed.
 * Returns:
 *  STATUS_SUCCESS - Datagram(s) were consumed and further indication should be
 *     made when new datagrams arrive.
 *  STATUS_PENDING - Datagram(s) were retained by the client and the data must 
 *     remain valid until released by the client. Further indication should be
 *     made when new datagrams arrive.
 *  STATUS_DATA_NOT_ACCEPTED - Datagram(s) could not be processed and should be
 *     buffered by the transport if possible or required by the 
 *     protocol. No further indication should be made until 
 *     message indication callbacks are specifically re-enabled. 
 */

//
// Forward declaration for connected socket callback table
//
typedef struct _WSK_CLIENT_CONNECTION_DISPATCH 
    WSK_CLIENT_CONNECTION_DISPATCH, *PWSK_CLIENT_CONNECTION_DISPATCH;

typedef
NTSTATUS
(WSKAPI * PFN_WSK_ACCEPT_EVENT) (
    IN  PVOID       SocketContext,
    IN  ULONG       Flags,
    IN  PSOCKADDR   LocalAddress,
    IN  PSOCKADDR   RemoteAddress,
    IN  PWSK_SOCKET AcceptSocket OPTIONAL,
    OUT PVOID      *AcceptSocketContext,
    OUT CONST WSK_CLIENT_CONNECTION_DISPATCH **AcceptSocketDispatch
    );
/*
 * Indicates that a connection request has arrived on one of the listening 
 * sockets created by the client. Note that when this callback is made,  
 * connection setup handshake with the remote party have already taken place.
 *
 * Parameters:
 *  SocketContext - Context value associated with the listening socket 
 *     on which connection request has been received.
 *  Flags - WSK_FLAG_AT_DISPATCH_LEVEL
 *  LocalAddress - Local transport address this connection request arrived on.
 *     Useful if the listening socket is bound to the wildcard address.
 *  RemoteAddress - Transport address of the remote party.
 *  AcceptSocket - New connected socket object that represent the connection.
 *     NULL denotes that listening socket must be closed. 
 *  AcceptSocketContext - OUT parameter through which the client passes the
 *     SocketContext for the new socket to WSK. WSK client must initialize
 *     this parameter before enabling event callbacks via
 *     SO_WSK_EVENT_CALLBACK option.
 *  AcceptSocketDispatch - OUT parameter through which the client passes the  
 *     callback routines for the new socket to WSK. WSK client must  
 *     initialize this parameter before enabling callbacks via 
 *     SO_WSK_EVENT_CALLBACK option.
 * Returns:
 *  STATUS_SUCCESS - Client accepted the connection.
 *  STATUS_REQUEST_NOT_ACCEPTED - Client rejected the connection. WSK provider
 *     will close the socket. Client should not touch the socket any more.
 */

typedef
WSK_INSPECT_ACTION
(WSKAPI * PFN_WSK_INSPECT_EVENT) (
    IN  PVOID           SocketContext,
    IN  PSOCKADDR       LocalAddress,
    IN  PSOCKADDR       RemoteAddress,
    IN  PWSK_INSPECT_ID InspectID OPTIONAL
    );
/*
 * Indicates that a connection request has arrived on a conditional-accept 
 * listening socket. This callback is used only for conditional-accept sockets.
 * This indication allows the client to decide if it wants to proceed with 
 * regular connection acceptance before any actual connection setup handshake
 * with the remote party takes place. If the client decides to proceed with
 * regular acceptance than the WskAcceptEvent callback will be invoked later
 * if/when the connectin setup handshake with the remote party is performed
 * successfully.
 *
 * Parameters:
 *  SocketContext - Context value associated with the listening socket 
 *                  on which connection request has been received.
 *  LocalAddress - Local transport address this connection request arrived on.
 *              Useful if the listening socket is bound to the wildcard address.
 *  RemoteAddress - Transport address of the remote party.
 *  InspectID - Pointer to the inspect ID structure. The connection request
 *              is identified via the contents of this structure (NOT via the 
 *              pointer to the structure) until the WskAcceptEvent callback 
 *              happens. If the client wants to preserve the inspect ID then it
 *              needs to copy this structure to its own memory before returning
 *              from this callback.
 *              NULL InspectID denotes that listening socket is to be closed.
 * Returns:
 *   WskInspectReject - Reject the connection request immediately. Neither
 *                      WskAcceptEvent nor WskAbortEvent will be invoked.
 *   WskInspectAccept - Proceed with regular acceptance. WskAcceptEvent
 *                      or WskAbortEvent may be invoked.
 *   WskInspectPend - Delay the decision. Client may invoke WskInspectComplete later to
 *                    convey its decision. WskAbortEvent may be invoked in
 *                    the meantime.
 */

typedef
NTSTATUS
(WSKAPI * PFN_WSK_ABORT_EVENT) (
    IN  PVOID           SocketContext,
    IN  PWSK_INSPECT_ID InspectID
    );
/*
 * Indicates that a previous connection request indicated by WskInspectEvent
 * callback is dropped. This callback is used only for conditional-accept 
 * sockets.
 *
 * Parameters:
 *  SocketContext - Context value associated with the listening socket 
 *                  on which connection request was received.
 *  InspectID - Pointer to the inspect ID structure. The connection request
 *              is identified via the contents of this structure (NOT via the
 *              pointer to the structure.) If the client wants to preserve the
 *              inspect ID then it needs to copy this sturcture to its own 
 *              memory before returning from this callback.
 * Returns:
 *  STATUS_SUCCESS - This is the only allowed return value.
 */

typedef
NTSTATUS
(WSKAPI * PFN_WSK_SEND_BACKLOG_EVENT) (
    IN  PVOID  SocketContext,
    IN  SIZE_T IdealBacklogSize
    );
/*
 * Indicates that the ideal send backlog size has changed for the connection.
 * The ideal send backlog size denotes the optimal amount of send data that
 * needs to be kept outstanding (passed to the WSK provider, but not completed
 * by the WSK provider yet) in order to keep the data pipe full at all times.
 *
 * Parameters:
 *  SocketContext - Context value associated with the socket object.
 *  IdealBacklogSize - Ideal send backlog size
 * Returns:
 *  STATUS_SUCCESS - This is the only allowed return value.
 */

//
// Flag that denotes that the indicated buffers should NOT be
// retained by the client indefinitely. The client should
// avoid retaining such buffers, but if it does retain, then
// it has to release them ASAP.
//

#define WSK_FLAG_RELEASE_ASAP 0x00000002

#define WSK_FLAG_ENTIRE_MESSAGE 0x00000004

typedef
NTSTATUS
(WSKAPI * PFN_WSK_RECEIVE_EVENT) (
    IN  PVOID              SocketContext,
    IN  ULONG              Flags,
    IN  PWSK_DATA_INDICATION DataIndication OPTIONAL,
    IN  SIZE_T             BytesIndicated,
    OUT SIZE_T            *BytesAccepted
    );
/*
 * Indicates that data has arrived on one of the connected socket objects
 * created by the client
 *
 * Parameters:
 *  SocketContext - Context value associated with the socket object on which
 *     data was received.
 *  Flags - WSK_FLAG_RELEASE_ASAP, WSK_FLAG_ENTIRE_MESSAGE,
 *          WSK_FLAG_AT_DISPATCH_LEVEL
 *  DataIndication - List of one or more data buffers
 *    NULL denotes that socket needs to be closed.
 *  BytesIndicated - Total number of bytes being indicated.
 *  BytesAccepted - Number of bytes client accepted. Client needs to set this
 *    OUT parameter only if it wishes to accept a data indication partially.
 *    This OUT parameter is ignored if client returns STATUS_DATA_NOT_ACCEPTED
 *    or STATUS_PENDING. The parameter is meaningful only when client returns
 *    STATUS_SUCCESS. If the client wants to fully accept the indicated buffers
 *    then it does NOT have to set this parameter, i.e. returning STATUS_SUCCESS
 *    without touching this parameter means full acceptance.
 * Returns:
 *  STATUS_SUCCESS - Data buffer(s) were fully or partially consumed. If 
 *     indication was fully consumed, further indication should be made when
 *     more data arrives. If indication was partially consumed, i.e. client
 *     sets the BytesAccepted parameter to a number smaller than BytesIndicated,
 *     then no further indications will be made until the client posts a 
 *     WskReceive request and it gets completed.
 *  STATUS_PENDING - Data buffer(s) were retained by the client and the data 
 *     must remain valid until released. Further indications should be made
 *     when more data arrives.
 *  STATUS_DATA_NOT_ACCEPTED - Data buffer(s) could not be processed and should
 *     be buffered by the transport if possible or required by the protocol.
 *     No further indications will be made until the client posts a WskReceive
 *     request and it gets completed.
 */

//
// Flags for indicating abortive/graceful connection teardown
//

#define WSK_FLAG_ABORTIVE 0x00000001

typedef
NTSTATUS
(WSKAPI * PFN_WSK_DISCONNECT_EVENT) (
    IN  PVOID         SocketContext,
    IN  ULONG         Flags
    );
/*
 * Indicates that peer of the connection has initiated disconnect sequence.
 *
 * Parameters:
 *  SocketContext - Context associated with the connected socket object.
 *  Flags - indicates whether disconnect is graceful or abortive (if the
 *     WSK_FLAG_ABORTIVE flag is set, it's abortive, otherwise it's graceful.)
 *     WSK_FLAG_AT_DISPATCH_LEVEL
 * Returns:
 *  STATUS_SUCCESS - This is the only allowed return value.
 */

//
// Flags denoting WSK socket types
//

#define WSK_FLAG_BASIC_SOCKET        0x00000000
#define WSK_FLAG_LISTEN_SOCKET       0x00000001
#define WSK_FLAG_CONNECTION_SOCKET   0x00000002
#define WSK_FLAG_DATAGRAM_SOCKET     0x00000004

typedef
NTSTATUS
(WSKAPI * PFN_WSK_SOCKET) (
    IN  PWSK_CLIENT          Client,
    IN  ADDRESS_FAMILY       AddressFamily,
    IN  USHORT               SocketType,
    IN  ULONG                Protocol,
    IN  ULONG                Flags,
    IN  PVOID                SocketContext OPTIONAL,
    IN  CONST VOID          *Dispatch OPTIONAL,
    IN  PEPROCESS            OwningProcess OPTIONAL,
    IN  PETHREAD             OwningThread OPTIONAL,
    IN  PSECURITY_DESCRIPTOR SecurityDescriptor OPTIONAL,
    IN  PIRP                 Irp
    );
/*
 * Creates socket object
 *
 * Parameters:
 *
 *  Client - Pointer to the Client object returned by WskCaptureProviderNPI 
 *  AddressFamily - address family, e.g. AF_INET, AF_INET6
 *  SocketType - socket type, e.g. SOCK_STREAM, SOCK_DGRAM
 *  Protocol - protocol, e.g. IPPROTO_TCP, IPPROTO_UDP
 *  Flags - WSK_FLAG_LISTEN_SOCKET - This socket will be used for listening for
 *                                   incoming connection requests.
 *          WSK_FLAG_CONNECTION_SOCKET - This socket will be for connecting
 *                                       to a remote party.
 *          WSK_FLAG_DATAGRAM_SOCKET - This socket will be used for sending and
 *                                     receiving datagrams. 
 *          WSK_FLAG_BASIC_SOCKET - This socket will be used for basic control 
 *                                  operations.
 *  SocketContext - Context value to pass in event callbacks
 *  Dispatch - pointer to a constant structure that contains pointers to 
 *            callback routines. OPTIONAL if client won't be enabling callbacks.
 *            Client must provide the right callback table based on socket type:
 *            WSK_CLIENT_LISTEN_DISPATCH for WSK_FLAG_LISTEN_SOCKET,
 *            WSK_CLIENT_CONNECTION_DISPATCH for WSK_FLAG_CONNECTION_SOCKET,
 *            WSK_CLIENT_DATAGRAM_DISPATCH for WSK_FLAG_DATAGRAM_SOCKET,
 *            NULL for WSK_FLAG_BASIC_SOCKET.
 *  OwningProcess - The process to retrieve the security context from. If this
 *                  is set to NULL then the current process is assumed. This is
 *                  used for implementing transport address security during bind.
 *  OwningThread  - The thread to retrieve the security context from. This is
 *                  useful only if an impersonation token is in effect and used
 *                  for implementing transport address security during bind.
 *  SecurityDescriptor - Optional security descriptor to protect the transport 
 *                       address that this socket will be bound to. Only the
 *                       security descriptors obtained from the NT object 
 *                       manager's security descriptor cache can be specified.
 *  Irp - IRP for async completion of the request
 *
 * Returns:
 *
 *  If the request is completed succesfully, the Irp.IoStatus.Information
 *  field will be holding a pointer to the new socket (PWSK_SOCKET)
 *
 *  SUCCESS - request succeeded
 *  PENDING - request will be completed later
 *  FAILURES - request failed
 */

typedef
NTSTATUS
(WSKAPI * PFN_WSK_SOCKET_CONNECT) (
    IN  PWSK_CLIENT                      Client,
    IN  USHORT                           SocketType,
    IN  ULONG                            Protocol,
    IN  PSOCKADDR                        LocalAddress,
    IN  PSOCKADDR                        RemoteAddress,
    IN  ULONG                            Flags,
    IN  PVOID                            SocketContext OPTIONAL,
    IN  CONST WSK_CLIENT_CONNECTION_DISPATCH  *Dispatch OPTIONAL,
    IN  PEPROCESS                        OwningProcess OPTIONAL,
    IN  PETHREAD                         OwningThread OPTIONAL,
    IN  PSECURITY_DESCRIPTOR             SecurityDescriptor OPTIONAL,
    IN  PIRP                             Irp
    );
/*
 * Creates, binds, and connects a socket object.
 *
 * Parameters:
 *  Client - Pointer to the Client object returned by WskCaptureProviderNPI
 *  SocketType - socket type, e.g. SOCK_STREAM, SOCK_DGRAM
 *  Protocol - protocol, e.g. IPPROTO_TCP, IPPROTO_UDP
 *  LocalAddress - Local address to bind the socket to.
 *  RemoteAddress - Remote address to connect to.
 *  Flags - Reserved. (Must be 0)
 *  SocketContext - Context value to pass in event callbacks
 *  Dispatch - pointer to a constant structure that contains pointers to 
 *     callback routines. OPTIONAL if client won't be enabling callbacks.
 *  OwningProcess - The process to retrieve the security context from. If this
 *                  is set to NULL then the current process is assumed. This is
 *                  used for implementing transport address security during bind.
 *  OwningThread  - The thread to retrieve the security context from. This is
 *                  useful only if an impersonation token is in effect and used
 *                  for implementing transport address security during bind.
 *  SecurityDescriptor - Optional security descriptor to protect the transport 
 *                       address that this socket will be bound to. Only the
 *                       security descriptors obtained from the NT object 
 *                       manager's security descriptor cache can be specified.
 *  Irp - IRP for async completion of the request
 *
 * Returns:
 *
 *  If the request is completed succesfully, the Irp.IoStatus.Information
 *  field will be holding a pointer to the new socket (PWSK_SOCKET)
 *
 *  SUCCESS - request succeeded
 *  PENDING - request will be completed later
 *  FAILURES - request failed
 */

//
// Client Level Control Codes
//

#define WSK_TRANSPORT_LIST_QUERY 2
#define WSK_TRANSPORT_LIST_CHANGE 3
#define WSK_CACHE_SD 4
#define WSK_RELEASE_SD 5
#define WSK_TDI_DEVICENAME_MAPPING 6
#define WSK_SET_STATIC_EVENT_CALLBACKS 7
#define WSK_TDI_BEHAVIOR 8

//
// Structures used with WSK_TDI_DEVICENAME_MAPPING control request
//

typedef struct _WSK_TDI_MAP {
    USHORT         SocketType;
    ADDRESS_FAMILY AddressFamily;
    ULONG          Protocol;
    PCWSTR         TdiDeviceName;
} WSK_TDI_MAP, *PWSK_TDI_MAP;

typedef struct _WSK_TDI_MAP_INFO {
    CONST ULONG        ElementCount;
    CONST WSK_TDI_MAP *Map;
} WSK_TDI_MAP_INFO, *PWSK_TDI_MAP_INFO;

//
// Flag used with WSK_TDI_BEHAVIOR control request
//
#define WSK_TDI_BEHAVIOR_BYPASS_TDI 0x00000001

typedef
NTSTATUS
(WSKAPI * PFN_WSK_CONTROL_CLIENT) (
    IN  PWSK_CLIENT    Client,
    IN  ULONG          ControlCode,
    IN  SIZE_T         InputSize,
    IN  PVOID          InputBuffer OPTIONAL,
    IN  SIZE_T         OutputSize,
    OUT PVOID          OutputBuffer OPTIONAL,
    OUT SIZE_T        *OutputSizeReturned OPTIONAL,
    IN  PIRP           Irp OPTIONAL
    );
/*
 * Issues control request to WSK subsystem, e.g., registration for protocol 
 * change notifications, etc.
 *
 * Parameters:
 *  Client - Pointer to the Client object returned by WskCaptureProviderNPI
 *  ControlCode - request code. currently defined codes are:
 *               WSK_TRANSPORT_LIST_QUERY - Retrieves the array of transports
 *               into the OutputBuffer. InputSize and InputBuffer parameters
 *               are ignored. Irp must be NULL and pOutputSize must be Non-NULL.
 *               WSK_TRANSPORT_LIST_CHANGE - Notifies the client when a 
 *               transport is added or removed. InputSize/InputBuffer, 
 *               OutputSize/OutputBuffer, and pOutputSize parameters are
 *               ignored. Irp must be specified. 
 *  InputSize - size of the input data residing in InputBuffer
 *  InputBuffer - buffer that holds input data
 *  OutputSize - size of the OutputBuffer
 *  OutputBuffer - buffer that will hold output data
 *  OutputSizeReturned - address of a variable that will contain the actual size
 *                of data copied into the OutputBuffer. This parameter is
 *                ignored if the Irp parameter is specified.
 *  Irp - IRP for the asynchronous completion of the request. Upon completion,
 *        Irp->Iostatus.Information will hold the actual size of data copied
 *        into the OutputBuffer.
 *
 * Returns:
 *
 *  SUCCESS - request succeeded
 *  PENDING - request will be completed later (Irp was specified.)
 *  FAILURES - request failed
 */

typedef
NTSTATUS
(WSKAPI * PFN_WSK_BIND) (
    IN  PWSK_SOCKET     Socket,
    IN  PSOCKADDR       LocalAddress,
    IN  ULONG           Flags,
    IN  PIRP            Irp
    );
/*
 * Bind local (unicast or multicast) tranport address to a socket 
 *
 * Parameters:
 *  Socket - socket object to bind address to
 *  LocalAddress - transport address specification
 *  Flags  - Reserved. (Must be 0)
 *  Irp    - IRP for async completion
 *
 * Returns:
 *
 *  SUCCESS - request succeeded
 *  PENDING - request will be completed later
 *  FAILURES - request failed
 */

typedef
NTSTATUS
(WSKAPI * PFN_WSK_CONNECT) (
    IN  PWSK_SOCKET     Socket,
    IN  PSOCKADDR       RemoteAddress,
    IN  ULONG           Flags,
    IN  PIRP            Irp
    );
/*
 * Establish comunication with the entity or group specified by the transport
 * address by means appropriate for the protocol (e.g. run protocol to 
 * establish a VC and/or make sure the address is reachable and/or
 * cache the routing entry, etc)
 *
 * Parameters:
 *  Socket - socket object to establish connection for
 *  RemoteAddress - transport address specification
 *  Flags - Reserved. (Must be 0)
 *  Irp - IRP for async completion
 *
 * Returns:
 *
 *  SUCCESS - request succeeded
 *  PENDING - request will be completed later
 *  FAILURES - request failed
 */

//
// Option/IOCTL Levels
//

//
// Socket Level Options specific to WSK
// (Standard socket level options are defined in ws2def.h)
//

#define SO_WSK_SECURITY        (WSK_SO_BASE+1)
#define SO_WSK_EVENT_CALLBACK  (WSK_SO_BASE+2)

//
// Flags for enabling event callbacks via WskControlSocket call with 
// SO_WSK_EVENT_CALLBACK option.
//

#define WSK_EVENT_RECEIVE_FROM     0x00000100 // Datagram sockets
#define WSK_EVENT_ACCEPT           0x00000200 // Listen sockets
#define WSK_EVENT_SEND_BACKLOG     0x00000010 // Connection and Listen sockets
#define WSK_EVENT_RECEIVE          0x00000040 // Connection and Listen sockets
#define WSK_EVENT_DISCONNECT       0x00000080 // Connection and Listen sockets

//
// Flag for disabling a given event callback via WskControlSocket call with 
// SO_WSK_EVENT_CALLBACK option.
//
#define WSK_EVENT_DISABLE       0x80000000

//
// Structure used with SO_WSK_EVENT_CALLBACK to enable/disable event callbacks
//
typedef struct _WSK_EVENT_CALLBACK_CONTROL {
    PNPIID NpiId;
    ULONG  EventMask;
} WSK_EVENT_CALLBACK_CONTROL, *PWSK_EVENT_CALLBACK_CONTROL;

//
// IOCTL codes specific to WSK
//

#define SIO_WSK_SET_REMOTE_ADDRESS        _WSAIOW(IOC_WSK,0x1)
#define SIO_WSK_REGISTER_EXTENSION        _WSAIORW(IOC_WSK,0x2)
#define SIO_WSK_QUERY_IDEAL_SEND_BACKLOG  _WSAIOR(IOC_WSK,0x3)
#define SIO_WSK_QUERY_RECEIVE_BACKLOG     _WSAIOR(IOC_WSK,0x4)
#define SIO_WSK_QUERY_INSPECT_ID          _WSAIOR(IOC_WSK,0x5)
#define SIO_WSK_SET_SENDTO_ADDRESS        _WSAIOW(IOC_WSK,0x6)

//
// Input structure used with SIO_WSK_REGISTER_EXTENSION
//
typedef struct _WSK_EXTENSION_CONTROL_IN {
    PNPIID      NpiId;
    PVOID       ClientContext;
    CONST VOID* ClientDispatch;
} WSK_EXTENSION_CONTROL_IN, *PWSK_EXTENSION_CONTROL_IN;

//
// Output structure used with SIO_WSK_REGISTER_EXTENSION
//
typedef struct _WSK_EXTENSION_CONTROL_OUT {
    PVOID       ProviderContext;
    CONST VOID* ProviderDispatch;
} WSK_EXTENSION_CONTROL_OUT, *PWSK_EXTENSION_CONTROL_OUT;


typedef enum {
    WskSetOption, // set socket option
    WskGetOption, // get socket option
    WskIoctl,     // socket IOCTL
    WskControlMax
} WSK_CONTROL_SOCKET_TYPE, *PWSK_CONTROL_SOCKET_TYPE;

typedef
NTSTATUS
(WSKAPI * PFN_WSK_CONTROL_SOCKET) (
    IN  PWSK_SOCKET             Socket,
    IN  WSK_CONTROL_SOCKET_TYPE RequestType,
    IN  ULONG                   ControlCode,
    IN  ULONG                   Level,
    IN  SIZE_T                  InputSize,
    IN  PVOID                   InputBuffer OPTIONAL,
    IN  SIZE_T                  OutputSize,
    OUT PVOID                   OutputBuffer OPTIONAL,
    OUT SIZE_T                 *OutputSizeReturned OPTIONAL,
    IN  PIRP                    Irp OPTIONAL
    );
/*
 *
 * Parameters:
 *  Socket - socket object
 *  RequestType - WskSetOption, WskGetOption, or WskIoctl
 *  ControlCode - what kind of the request
 *  Level - SOL_SOCKET for socket-level options,
 *          Protocol number for transport/network specific options
 *  InputSize - size of the input data residing in InputBuffer
 *  InputBuffer - buffer that holds input data
 *  OutputSize - size of the OutputBuffer
 *  OutputBuffer - buffer that will hold output data
 *  OutputSizeReturned - if Irp is NULL for a ControlCode than this parameter
 *                must be specified to store the number of bytes written
 *                into OutputBuffer upon in-line completion of the request.
 *  Irp - IRP for the asynchronous completion of the request. Upon completion,
 *        Irp->Iostatus.Information will hold the actual size of data copied
 *        into the OutputBuffer. This will be either a required parameter or
 *        ignored (and must be NULL), or optional based on the ControlCode.
 *
 * Returns:
 *
 *  SUCCESS - request succeeded
 *  STATUS_REQUEST_NOT_ACCEPTED - Inline completion is not possible.
 *  PENDING - request will be completed later (Irp was specified.)
 *  FAILURES - request failed
 */

typedef
NTSTATUS
(WSKAPI * PFN_WSK_CLOSE_SOCKET) (
    IN  PWSK_SOCKET       Socket,
    IN  PIRP              Irp
    );
/*
 * Invalidates socket object, initiates cancellation of
 * all outstanding requests. Once WskCloseSocket is invoked on a socket,
 * it is illegal to issue any further calls on that socket. It's also illegal
 * to call WskCloseSocket when there are one or more WSK calls on the socket
 * that have not yet returned control to the client.
 *
 * Parameters:
 *  Socket - Socket to be closed.
 *  Irp - notification method to trigger when operation completes. 
 *     This is a required parameter.
 *
 * Returns:
 *
 *  SUCCESS - request succeeded
 *  PENDING - request will be completed later
 *  FAILURES - request failed
 */

typedef
NTSTATUS
(WSKAPI * PFN_WSK_ACCEPT) (
    IN  PWSK_SOCKET                     ListenSocket,
    IN  ULONG                           Flags,
    IN  PVOID                           AcceptSocketContext OPTIONAL,
    IN  CONST WSK_CLIENT_CONNECTION_DISPATCH *AcceptSocketDispatch OPTIONAL,
    OUT PSOCKADDR                       LocalAddress OPTIONAL,
    OUT PSOCKADDR                       RemoteAddress OPTIONAL,
    IN  PIRP                            Irp
    );
/*
 * Dequeue (pend if it is not there) and return incoming connection request
 * on the specified listening socket. 
 *
 * Parameters:
 *  ListenSocket - listening socket to dequeue request from
 *  Flags - Reserved. (Must be 0)
 *  AcceptSocketContext - context to be associated with the accepted socket
 *                object. This is passed as a parameter in event callbacks.
 *  AcceptSocketDispatch - pointer to a constant structure containining pointers
 *         to callback routines. OPTIONAL if client won't be enabling callbacks.
 *  LocalAddress - Optional buffer to return the local address on which
 *              this connection request arrived. Useful if listening socket is
 *              bound to the wildcard address. 
 *  RemoteAddress - Optional buffer to return the remote party's address. 
 *  Irp - IRP for async completion of the request
 *
 * Returns:
 *
 *  If the request is completed succesfully, the Irp.IoStatus.Information
 *  field will be holding a pointer to the accepted socket (PWSK_SOCKET)
 *
 *  SUCCESS - request succeeded
 *  PENDING - request will be completed later
 *  FAILURES - request failed
 */

typedef
NTSTATUS
(WSKAPI * PFN_WSK_INSPECT_COMPLETE) (
    IN  PWSK_SOCKET                     ListenSocket,
    IN  PWSK_INSPECT_ID                 InspectID,
    IN  WSK_INSPECT_ACTION              Action,
    IN  PIRP                            Irp
    );
/*
 * Resume a previously pended inspect operation. This routine is valid only
 * for conditional-accept sockets.
 * 
 * Parameters:
 *  ListenSocket - listening socket on which the inspect action was pended for 
 *                 the connection request identified by the structure pointed
 *                 by pInspectID.
 *  InspectID - Pointer to the inspect ID structure that identified the pended
 *              connection request.
 *  Action - Only one of the following two actions is allowed:
 *
 *    WskInspectReject - Reject the connection request. WskAcceptEvent won't
 *                       be invoked. WskAbortEvent may be invoked if the
 *                       connection request is dropped during WskInspectComplete call.
 *
 *    WskInspectAccept - Proceed with regular acceptance. WskAcceptEvent
 *                       or WskAbortEvent may be invoked.
 *
 *  Irp    - IRP for asynchronous completion of this operation. This is a
 *           required parameter.
 *
 * Returns:
 *
 *  STATUS_SUCCESS - request succeeded
 */

typedef
NTSTATUS
(WSKAPI * PFN_WSK_SEND_TO) (
    IN  PWSK_SOCKET     Socket,
    IN  PWSK_BUF        Buffer,
    IN  ULONG           Flags,
    IN  PSOCKADDR       RemoteAddress OPTIONAL,
    IN  ULONG           ControlInfoLength,
    IN  PCMSGHDR        ControlInfo OPTIONAL,
    IN  PIRP            Irp
    );
/*
 * Send to the specified remote entity or group from the specified
 * datagram socket. Socket must have been bound to a local address.
 *
 * Parameters:
 *  Socket  - datagram socket object to send from
 *  Buffer  - data to send
 *  Flags   - Reserved. (Must be 0)
 *  RemoteAddress - remote transport address
 *  ControlInfo - additional information to pass to the remote party. 
 *                Might not be supported by all transports.
 *  ControlInfoLength - length of control info
 *  Irp - notification method to trigger when operation completes
 *
 * Returns:
 *
 *  SUCCESS - request succeeded
 *  PENDING - request will be completed later
 *  FAILURES - request failed
 */

typedef
NTSTATUS
(WSKAPI * PFN_WSK_RECEIVE_FROM) (
    IN  PWSK_SOCKET     Socket,
    IN OUT PWSK_BUF     Buffer,
    IN  ULONG           Flags,
    OUT PSOCKADDR       RemoteAddress OPTIONAL,
    IN OUT PULONG       ControlLength OPTIONAL,
    OUT PCMSGHDR        ControlInfo OPTIONAL,
    OUT PULONG          ControlFlags OPTIONAL,
    IN  PIRP            Irp
    );
/*
 * Dequeue (pend if it is not there) and return incoming data packet on the
 * specified datagram socket.
 *
 * Parameters:
 *  Socket  - socket to dequeue packet from
 *  Buffer  - place to put incoming data into
 *  Flags   - Reserved. (Must be 0)
 *  RemoteAddress - OUT parameter to return the transport address of the remote
 *     party that sent the packet
 *  ControlLength - Pointer to a ULONG that specifies the length of buffer 
 *     pointed by ControlInfo on input, and the length of actual control data
 *     copied into ControlInfo buffer on output. If ControlLength is NULL
 *     then ControlInfo and ControlFlags parameters are ignored. 
 *     If ControlLength is non-NULL then ControlLength should be pointing to
 *     valid memory until the request completes. 
 *  ControlInfo - Pointer to a buffer into which WSK copies the control data 
 *     received with the datagram. This parameter is ignored if 
 *     ControlLength parameter is NULL. Otherwise, if ControlInfo should 
 *     be pointing to valid memory until the request completes. 
 *  ControlFlags - Pointer to a ULONG through which WSK may pass the following
 *     flags when the request completes: MSG_MCAST, MSG_BCAST, MSG_TRUNC, 
 *     MSG_CTRUNC. This parameter is ignored if it is NULL.
 *     Otherwise, ControlFlags should be pointing to valid memory until the 
 *     request completes.  
 *  Irp - notification method to trigger when operation completes
 *
 * Returns:
 *
 *  SUCCESS - request succeeded
 *  PENDING - request will be completed later
 *  FAILURES - request failed
 */

typedef
NTSTATUS
(WSKAPI * PFN_WSK_GET_LOCAL_ADDRESS) (
    IN  PWSK_SOCKET     Socket,
    OUT PSOCKADDR       LocalAddress,
    IN  PIRP            Irp
    );
/*
 * Retrieve the transport address associated with this Socket object. This is
 * useful for retrieveing the specific transport address chosen by the transport
 * when a socket is bound to the wildcard transport address by the client.
 *
 * Parameters:
 *  Socket - Socket whose local address is being queried
 *  LocalAddress - local transport address
 *  Irp - Irp for async completion. 
 *
 * Returns:
 *
 *  SUCCESS - request succeeded
 *  PENDING - request will be completed later
 *  FAILURES - request failed
 */

typedef
NTSTATUS
(WSKAPI * PFN_WSK_GET_REMOTE_ADDRESS) (
    IN  PWSK_SOCKET     Socket,
    OUT PSOCKADDR       RemoteAddress,
    IN  PIRP            Irp
    );
/*
 * Retrieve the transport address of the peer to which the socket is connected. 
 * Clients are always informed -- upon connection setup -- of the peer's 
 * address, so this call is useful if a socket is being shared between multiple
 * components of the client application. If one component set up the connection
 * and another component wishes to determine the peer address, it can do so via
 * this call.
 *
 * Parameters:
 *  Socket - Socket whose local address is being queried
 *  RemoteAddress - remote party's transport address
 *  Irp - Irp for async completion. 
 *
 * Returns:
 *
 *  SUCCESS - request succeeded
 *  PENDING - request will be completed later
 *  FAILURES - request failed
 */

typedef
NTSTATUS
(WSKAPI * PFN_WSK_RELEASE_DATA_INDICATION_LIST) (
    IN  PWSK_SOCKET          Socket,
    IN  PWSK_DATA_INDICATION DataIndication
    );
/*
 * Release data indications that were previously retained by returning 
 * STATUS_PENDING from the receive event callback on connection-oriented
 * socket.
 *
 * Parameters:
 *  Socket - Socket on which buffers were received
 *  DataIndication  - list of data indication elements
 *
 * Returns:
 *  SUCCESS - request succeeded
 *  FAILURES - request failed
 */

typedef
NTSTATUS
(WSKAPI * PFN_WSK_RELEASE_DATAGRAM_INDICATION_LIST) (
    IN  PWSK_SOCKET              Socket,
    IN  PWSK_DATAGRAM_INDICATION DatagramIndication
    );
/*
 * Release datagram indications that were previously retained by returning 
 * STATUS_PENDING from the receive-from event callback on datagram socket.
 *
 * Parameters:
 *  Socket - Socket on which datagrams was received
 *  DatagramIndication  - list of datagram indication elements
 *
 * Returns:
 *  SUCCESS - request succeeded
 *  FAILURES - request failed
 */

//
// Flag used for denoting that the send request (along with any previously 
// queued send requests, if any) should be sent out without further delay.
//

#define WSK_FLAG_NODELAY 0x00000002

typedef
NTSTATUS
(WSKAPI * PFN_WSK_SEND) (
    IN  PWSK_SOCKET     Socket,
    IN  PWSK_BUF        Buffer,
    IN  ULONG           Flags,
    IN  PIRP            Irp 
    );
/*
 * Send on the specified connected socket
 *
 * Parameters:
 *  Socket  - Socket to send on. Must have been connected or accepted
 *  Buffer  - data to send
 *  Flags   - WSK_FLAG_NODELAY: Must send without delaying
 *  Irp - notification method to trigger when operation completes
 *
 * Returns:
 *
 *  SUCCESS - request succeeded
 *  PENDING - request will be completed later
 *  FAILURES - request failed
 */

#define WSK_FLAG_WAITALL 0x00000002
#define WSK_FLAG_DRAIN   0x00000004

typedef
NTSTATUS
(WSKAPI * PFN_WSK_RECEIVE) (
    IN  PWSK_SOCKET     Socket,
    IN OUT PWSK_BUF     Buffer,
    IN  ULONG           Flags,
    IN  PIRP            Irp
    );
/*
 * Dequeue (wait if it is not there) and return incoming data packet on the
 * specified connected socket
 *
 * Parameters:
 *  Socket  - Socket to dequeue data from. Must have been connected or accepted
 *  Buffer  - place to put incoming data into
 *  Flags   - WSK_FLAG_WAITALL: Wait until the receive buffer is filled up
 *            WSK_FLAG_DRAIN: Discard any existing and future incoming data
 *  Irp - notification method to trigger when operation completes
 *
 * Returns:
 *
 *  SUCCESS - request succeeded
 *  PENDING - request will be completed later
 *  FAILURES - request failed
 */

typedef
NTSTATUS
(WSKAPI * PFN_WSK_DISCONNECT) (
    IN  PWSK_SOCKET     Socket,
    IN  PWSK_BUF        Buffer OPTIONAL,
    IN  ULONG           Flags,
    IN  PIRP            Irp
    );
/*
 * Send disconnect notification on specified connected socket
 * with optional data.
 *
 * Parameters:
 *  Socket - Socket to disconnect. Must have been connected or accepted.
 *  Buffer - Optional data to send along with graceful disconnect.
 *  Flags - If WSK_FLAG_ABORTIVE is specified then perform abortive disconnect.
 *          Otherwise, perform graceful disconnect.
 *  Irp - notification method to trigger when operation completes. (Required)
 *
 * Returns:
 *
 *  SUCCESS - request succeeded
 *  PENDING - request will be completed later
 *  FAILURES - request failed
 */




//
// WSK Dispatch tables.
// WSK interface consists of routines implemented by both 
// the client and the provider. These routines operate
// at either client/provider level or socket level.
// Client/provider level function pointers are exchanged 
// during WSK registration.
// Socket level function pointers are exchanged during
// socket creation.
//

//
// Client level callback table
//

typedef struct _WSK_CLIENT_DISPATCH {
    USHORT               Version;
    USHORT               Reserved;
    PFN_WSK_CLIENT_EVENT WskClientEvent;
} WSK_CLIENT_DISPATCH, *PWSK_CLIENT_DISPATCH;

//
// Socket level callbacks for listening sockets
//

typedef struct _WSK_CLIENT_LISTEN_DISPATCH {
    PFN_WSK_ACCEPT_EVENT        WskAcceptEvent;
    PFN_WSK_INSPECT_EVENT       WskInspectEvent;
    PFN_WSK_ABORT_EVENT         WskAbortEvent;
} WSK_CLIENT_LISTEN_DISPATCH, *PWSK_CLIENT_LISTEN_DISPATCH;

//
// Socket level callbacks for datagram sockets
//

typedef struct _WSK_CLIENT_DATAGRAM_DISPATCH {
    PFN_WSK_RECEIVE_FROM_EVENT  WskReceiveFromEvent;
} WSK_CLIENT_DATAGRAM_DISPATCH, *PWSK_CLIENT_DATAGRAM_DISPATCH;

//
// Socket level callbacks for connected sockets
//

typedef struct _WSK_CLIENT_CONNECTION_DISPATCH {
    PFN_WSK_RECEIVE_EVENT       WskReceiveEvent;
    PFN_WSK_DISCONNECT_EVENT    WskDisconnectEvent;
    PFN_WSK_SEND_BACKLOG_EVENT  WskSendBacklogEvent;
} WSK_CLIENT_CONNECTION_DISPATCH, *PWSK_CLIENT_CONNECTION_DISPATCH;


//
// Provider level downcall table
//

typedef struct _WSK_PROVIDER_DISPATCH {
    USHORT                    Version;
    USHORT                    Reserved;
    PFN_WSK_SOCKET            WskSocket;
    PFN_WSK_SOCKET_CONNECT    WskSocketConnect;
    PFN_WSK_CONTROL_CLIENT    WskControlClient;
} WSK_PROVIDER_DISPATCH, *PWSK_PROVIDER_DISPATCH;

//
// Basic socket downcalls
// These routines are supported for all socket types.
//

typedef struct _WSK_PROVIDER_BASIC_DISPATCH {
    PFN_WSK_CONTROL_SOCKET       WskControlSocket;
    PFN_WSK_CLOSE_SOCKET         WskCloseSocket;
} WSK_PROVIDER_BASIC_DISPATCH, *PWSK_PROVIDER_BASIC_DISPATCH;

//
// Listening socket downcalls
//

typedef struct _WSK_PROVIDER_LISTEN_DISPATCH {
#ifdef __cplusplus
    WSK_PROVIDER_BASIC_DISPATCH Basic;
#else
    WSK_PROVIDER_BASIC_DISPATCH;
#endif
    PFN_WSK_BIND       WskBind;
    PFN_WSK_ACCEPT     WskAccept;
    PFN_WSK_INSPECT_COMPLETE WskInspectComplete;
    PFN_WSK_GET_LOCAL_ADDRESS WskGetLocalAddress;
} WSK_PROVIDER_LISTEN_DISPATCH, *PWSK_PROVIDER_LISTEN_DISPATCH;

//
// Datagram socket downcalls
//

typedef struct _WSK_PROVIDER_DATAGRAM_DISPATCH {
#ifdef __cplusplus
    WSK_PROVIDER_BASIC_DISPATCH Basic;
#else
    WSK_PROVIDER_BASIC_DISPATCH;
#endif
    PFN_WSK_BIND                WskBind;
    PFN_WSK_SEND_TO             WskSendTo;
    PFN_WSK_RECEIVE_FROM        WskReceiveFrom;
    PFN_WSK_RELEASE_DATAGRAM_INDICATION_LIST WskRelease;
    PFN_WSK_GET_LOCAL_ADDRESS   WskGetLocalAddress;
} WSK_PROVIDER_DATAGRAM_DISPATCH, *PWSK_PROVIDER_DATAGRAM_DISPATCH;


//
// Connected socket downcalls
//

typedef struct _WSK_PROVIDER_CONNECTION_DISPATCH {
#ifdef __cplusplus
    WSK_PROVIDER_BASIC_DISPATCH Basic;
#else
    WSK_PROVIDER_BASIC_DISPATCH;
#endif
    PFN_WSK_BIND               WskBind;
    PFN_WSK_CONNECT            WskConnect;
    PFN_WSK_GET_LOCAL_ADDRESS  WskGetLocalAddress;
    PFN_WSK_GET_REMOTE_ADDRESS WskGetRemoteAddress;
    PFN_WSK_SEND               WskSend;
    PFN_WSK_RECEIVE            WskReceive;
    PFN_WSK_DISCONNECT         WskDisconnect;
    PFN_WSK_RELEASE_DATA_INDICATION_LIST WskRelease;
} WSK_PROVIDER_CONNECTION_DISPATCH, *PWSK_PROVIDER_CONNECTION_DISPATCH;


//
// Structures and routines used for WSK registration and deregistration
//

//
// WSK Client NPI
//
typedef struct _WSK_CLIENT_NPI {
    PVOID                        ClientContext;
    CONST WSK_CLIENT_DISPATCH   *Dispatch;    
} WSK_CLIENT_NPI, *PWSK_CLIENT_NPI;

//
// WSK Provider NPI
//
typedef struct _WSK_PROVIDER_NPI {
    PWSK_CLIENT                  Client;
    CONST WSK_PROVIDER_DISPATCH *Dispatch;    
} WSK_PROVIDER_NPI, *PWSK_PROVIDER_NPI;

//
// WSK Registration block that needs to be provided by the WSK client and
// initialized by the WSK subsystem via WskRegister. WSK client should not
// manipulate any of the fields of the registration block directly. 
//
typedef struct _WSK_REGISTRATION {
    ULONGLONG  ReservedRegistrationState;
    PVOID      ReservedRegistrationContext;
    KSPIN_LOCK ReservedRegistrationLock;
} WSK_REGISTRATION, *PWSK_REGISTRATION;

NTSTATUS
WskRegister(
    __in PWSK_CLIENT_NPI WskClientNpi,
    __out PWSK_REGISTRATION WskRegistration
    );
/*
 * Register as a WSK client. WSK clients may invoke this routine multiple times
 * with a seperate WskRegistation block for each call in order to have multiple
 * WSK registration instances. For each successful WskRegister call, there must
 * be exactly one corresponding WskDeregister call with the same WskRegistration
 * block that was passed to WskRegister.
 *
 * Required IRQL == PASSIVE_LEVEL
 *
 * Parameters:
 *  WskClientNpi - Pointer to the client NPI implemented by the WSK client.
 *  WskRegistration - Registration block used to identify this instance of
 *                    the WSK registration. This block of memory must be kept
 *                    allocated (not freed or gone out of scope) as long as
 *                    there are outstanding calls to the functions below.
 *
 * Returns:
 *
 *  STATUS_SUCCESS - request succeeded
 *  FAILURES - request failed
 */

#define WSK_NO_WAIT 0
#define WSK_INFINITE_WAIT 0xffffffff

NTSTATUS
WskCaptureProviderNPI(
    __in PWSK_REGISTRATION WskRegistration,
    __in ULONG WaitTimeout,
    __out PWSK_PROVIDER_NPI WskProviderNpi
    );
/*
 * Capture the provider NPI implemented by the WSK provider when the WSK
 * provider becomes available. This routine may be called multiple times.
 * For each call to WskCaptureProviderNPI that returns successfully, there must
 * be exactly one corresponding call to WskReleaseProviderNPI.
 * It's OK to call WskCaptureProviderNPI after WskDeregister is called as long
 * as the WskRegistration block is not freed or overwritten. After WskDeregister
 * is called, any further calls to WskCaptureProviderNPI will fail with 
 * STATUS_DEVICE_NOT_READY, and any exisiting WskCaptureProviderNPI calls that
 * are blocked in other threads waiting for WSK provider to become available
 * will also return immediately with the STATUS_DEVICE_NOT_READY status code.
 *
 * Required IRQL == PASSIVE_LEVEL  if WaitTimeout != WSK_NO_WAIT
 *          IRQL <= DISPATCH_LEVEL if WaitTimeout == WSK_NO_WAIT
 *
 * Parameters:
 *  WskRegistration - Registration block initialized by WskRegister.
 *  WaitTimeout - Time in milliseconds for how long to wait for the WSK provider
 *                to become available. 
 *                WSK_NO_WAIT : return immediately if provider not available
 *                WSK_INFINITE_WAIT : wait until provider becomes available
 * WskProviderNpi - Provider NPI returned by the WSK provider. WSK clients can
 *                  invoke functions in WSK_PROVIDER_DISPATCH until the provider
 *                  NPI is released via WskReleaseProviderNPI.
 * Returns:
 *
 *  STATUS_SUCCESS - request succeeded
 *  STATUS_DEVICE_NOT_READY - WSK provider was not available yet.
 *  STATUS_NOINTERFACE - Client's requested version is not supported.
 *  FAILURES - request failed
 */

VOID
WskReleaseProviderNPI(
    __in PWSK_REGISTRATION WskRegistration
    );
/*
 * Release the provider NPI instance that was captured via WskCaptureProviderNPI.
 * There must be exactly one call to WskReleaseProviderNPI for each call to
 * WskCaptureProviderNPI that returns successfully.
 *
 * Required IRQL <= DISPATCH_LEVEL
 *
 * Parameters:
 *  WskRegistration - Registration block initialized by WskRegister.
 *
 * Returns:
 *
 *  None.
 */

NTSTATUS
WskQueryProviderCharacteristics(
    __in PWSK_REGISTRATION WskRegistration,
    __out PWSK_PROVIDER_CHARACTERISTICS WskProviderCharacteristics
    );
/*
 * Query the characterisitics of the WSK provider. This routine should be called
 * after WskCaptureProviderNPI returns STATUS_NOINTERFACE or STATUS_SUCCESS.
 * WSK clients may use this routine to find out the versions supported by the 
 * WSK provider.
 *
 * Required IRQL <= DISPATCH_LEVEL
 *
 * Parameters:
 *  WskRegistration - Registration block initialized by WskRegister.
 * WskProviderCharacteristics - Provider characterisitics returned by the WSK 
 *                              provider
 * Returns:
 *
 *  STATUS_SUCCESS - request succeeded
 *  STATUS_DEVICE_NOT_READY - WSK provider was not available yet.
 *  FAILURES - request failed
 */

VOID
WskDeregister(
    __in PWSK_REGISTRATION WskRegistration
    );
/*
 * Deregister as a WSK client. For each successful WskRegister call, there must
 * be exactly one corresponding WskDeregister call with the same WskRegistration
 * block that was passed to WskRegister.
 * WskDeregister will wait until all captured instances of the provider NPI are 
 * released, any outstanding calls to functions in WSK_PROVIDER_DISPATCH have
 * returned, and all sockets are closed.
 *
 * Required IRQL == PASSIVE_LEVEL
 *
 * Parameters:
 *  WskRegistration - Registration block initialized by WskRegister.
 *
 * Returns:
 *
 *  None.
 */

#ifdef __cplusplus
}
#endif

#endif // _WSK_
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\win2k8\ddk\inc\wdf\kmdf\1.7\wdfassert.h ===
/*++

Copyright (c) Microsoft Corporation.  All rights reserved.

_WdfVersionBuild_

Module Name:

    WdfAssert.h

Abstract:

    Contains prototypes for dealing with run time asserts

Author:

Environment:

    kernel mode only

Revision History:

--*/

#ifndef _WDFASSERT_H_
#define _WDFASSERT_H_



#if (NTDDI_VERSION >= NTDDI_WIN2K)

//
// Including here because RtlAssert is not declared in XP and Win2K headers for
// free builds
//
NTSYSAPI
VOID
NTAPI
RtlAssert(
    __in PVOID FailedAssertion,
    __in PVOID FileName,
    __in ULONG LineNumber,
    __in_opt PSTR Message
    );



//
// WDFVERIFY is active both on checked and free build only if
// the wdf verifier is tuned on
//
#define WDFVERIFY(exp) {                                            \
    if ((WdfDriverGlobals->DriverFlags & WdfVerifyOn) && !(exp)) {  \
        RtlAssert( #exp, __FILE__, __LINE__, NULL );                \
    }                                                               \
}

#define VERIFY_IS_IRQL_PASSIVE_LEVEL()  WDFVERIFY(KeGetCurrentIrql() == PASSIVE_LEVEL)

//
// Following macro is obsolete and it will be phased out in due course
//
#define IS_AT_PASSIVE()                 WDFVERIFY(KeGetCurrentIrql() == PASSIVE_LEVEL)

//
// Compile time active "assert".  File will not compile if this assert is FALSE.
//
//
#define WDFCASSERT(c)                   { switch(0) case (c): case 0: ; }



#endif // (NTDDI_VERSION >= NTDDI_WIN2K)


#endif // _WDFASSERT_H_
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\win2k8\ddk\inc\wdf\kmdf\1.7\wdf10.h ===
#ifndef _WDF_V1_0_TYPES_H_
#define _WDF_V1_0_TYPES_H_


typedef enum _WDFFUNCENUM_V1_0 {
    WdfFunctionTableNumEntries_V1_0 = 383,
} WDFFUNCENUM_V1_0;

typedef struct _WDF_POWER_ROUTINE_TIMED_OUT_DATA_V1_0 *PWDF_POWER_ROUTINE_TIMED_OUT_DATA_V1_0;
typedef const struct _WDF_POWER_ROUTINE_TIMED_OUT_DATA_V1_0 *PCWDF_POWER_ROUTINE_TIMED_OUT_DATA_V1_0;
typedef struct _WDF_REQUEST_FATAL_ERROR_INFORMATION_LENGTH_MISMATCH_DATA_V1_0 *PWDF_REQUEST_FATAL_ERROR_INFORMATION_LENGTH_MISMATCH_DATA_V1_0;
typedef const struct _WDF_REQUEST_FATAL_ERROR_INFORMATION_LENGTH_MISMATCH_DATA_V1_0 *PCWDF_REQUEST_FATAL_ERROR_INFORMATION_LENGTH_MISMATCH_DATA_V1_0;
typedef struct _WDF_QUEUE_FATAL_ERROR_DATA_V1_0 *PWDF_QUEUE_FATAL_ERROR_DATA_V1_0;
typedef const struct _WDF_QUEUE_FATAL_ERROR_DATA_V1_0 *PCWDF_QUEUE_FATAL_ERROR_DATA_V1_0;
typedef struct _WDF_CHILD_IDENTIFICATION_DESCRIPTION_HEADER_V1_0 *PWDF_CHILD_IDENTIFICATION_DESCRIPTION_HEADER_V1_0;
typedef const struct _WDF_CHILD_IDENTIFICATION_DESCRIPTION_HEADER_V1_0 *PCWDF_CHILD_IDENTIFICATION_DESCRIPTION_HEADER_V1_0;
typedef struct _WDF_CHILD_ADDRESS_DESCRIPTION_HEADER_V1_0 *PWDF_CHILD_ADDRESS_DESCRIPTION_HEADER_V1_0;
typedef const struct _WDF_CHILD_ADDRESS_DESCRIPTION_HEADER_V1_0 *PCWDF_CHILD_ADDRESS_DESCRIPTION_HEADER_V1_0;
typedef struct _WDF_CHILD_RETRIEVE_INFO_V1_0 *PWDF_CHILD_RETRIEVE_INFO_V1_0;
typedef const struct _WDF_CHILD_RETRIEVE_INFO_V1_0 *PCWDF_CHILD_RETRIEVE_INFO_V1_0;
typedef struct _WDF_CHILD_LIST_CONFIG_V1_0 *PWDF_CHILD_LIST_CONFIG_V1_0;
typedef const struct _WDF_CHILD_LIST_CONFIG_V1_0 *PCWDF_CHILD_LIST_CONFIG_V1_0;
typedef struct _WDF_CHILD_LIST_ITERATOR_V1_0 *PWDF_CHILD_LIST_ITERATOR_V1_0;
typedef const struct _WDF_CHILD_LIST_ITERATOR_V1_0 *PCWDF_CHILD_LIST_ITERATOR_V1_0;
typedef struct _WDF_CLASS_EXTENSION_DESCRIPTOR_V1_0 *PWDF_CLASS_EXTENSION_DESCRIPTOR_V1_0;
typedef const struct _WDF_CLASS_EXTENSION_DESCRIPTOR_V1_0 *PCWDF_CLASS_EXTENSION_DESCRIPTOR_V1_0;
typedef struct _WDF_FILEOBJECT_CONFIG_V1_0 *PWDF_FILEOBJECT_CONFIG_V1_0;
typedef const struct _WDF_FILEOBJECT_CONFIG_V1_0 *PCWDF_FILEOBJECT_CONFIG_V1_0;
typedef struct _WDF_DEVICE_PNP_NOTIFICATION_DATA_V1_0 *PWDF_DEVICE_PNP_NOTIFICATION_DATA_V1_0;
typedef const struct _WDF_DEVICE_PNP_NOTIFICATION_DATA_V1_0 *PCWDF_DEVICE_PNP_NOTIFICATION_DATA_V1_0;
typedef struct _WDF_DEVICE_POWER_NOTIFICATION_DATA_V1_0 *PWDF_DEVICE_POWER_NOTIFICATION_DATA_V1_0;
typedef const struct _WDF_DEVICE_POWER_NOTIFICATION_DATA_V1_0 *PCWDF_DEVICE_POWER_NOTIFICATION_DATA_V1_0;
typedef struct _WDF_DEVICE_POWER_POLICY_NOTIFICATION_DATA_V1_0 *PWDF_DEVICE_POWER_POLICY_NOTIFICATION_DATA_V1_0;
typedef const struct _WDF_DEVICE_POWER_POLICY_NOTIFICATION_DATA_V1_0 *PCWDF_DEVICE_POWER_POLICY_NOTIFICATION_DATA_V1_0;
typedef struct _WDF_PNPPOWER_EVENT_CALLBACKS_V1_0 *PWDF_PNPPOWER_EVENT_CALLBACKS_V1_0;
typedef const struct _WDF_PNPPOWER_EVENT_CALLBACKS_V1_0 *PCWDF_PNPPOWER_EVENT_CALLBACKS_V1_0;
typedef struct _WDF_POWER_POLICY_EVENT_CALLBACKS_V1_0 *PWDF_POWER_POLICY_EVENT_CALLBACKS_V1_0;
typedef const struct _WDF_POWER_POLICY_EVENT_CALLBACKS_V1_0 *PCWDF_POWER_POLICY_EVENT_CALLBACKS_V1_0;
typedef struct _WDF_DEVICE_POWER_POLICY_IDLE_SETTINGS_V1_0 *PWDF_DEVICE_POWER_POLICY_IDLE_SETTINGS_V1_0;
typedef const struct _WDF_DEVICE_POWER_POLICY_IDLE_SETTINGS_V1_0 *PCWDF_DEVICE_POWER_POLICY_IDLE_SETTINGS_V1_0;
typedef struct _WDF_DEVICE_POWER_POLICY_WAKE_SETTINGS_V1_0 *PWDF_DEVICE_POWER_POLICY_WAKE_SETTINGS_V1_0;
typedef const struct _WDF_DEVICE_POWER_POLICY_WAKE_SETTINGS_V1_0 *PCWDF_DEVICE_POWER_POLICY_WAKE_SETTINGS_V1_0;
typedef struct _WDF_DEVICE_STATE_V1_0 *PWDF_DEVICE_STATE_V1_0;
typedef const struct _WDF_DEVICE_STATE_V1_0 *PCWDF_DEVICE_STATE_V1_0;
typedef struct _WDF_DEVICE_PNP_CAPABILITIES_V1_0 *PWDF_DEVICE_PNP_CAPABILITIES_V1_0;
typedef const struct _WDF_DEVICE_PNP_CAPABILITIES_V1_0 *PCWDF_DEVICE_PNP_CAPABILITIES_V1_0;
typedef struct _WDF_DEVICE_POWER_CAPABILITIES_V1_0 *PWDF_DEVICE_POWER_CAPABILITIES_V1_0;
typedef const struct _WDF_DEVICE_POWER_CAPABILITIES_V1_0 *PCWDF_DEVICE_POWER_CAPABILITIES_V1_0;
typedef struct _WDF_DMA_ENABLER_CONFIG_V1_0 *PWDF_DMA_ENABLER_CONFIG_V1_0;
typedef const struct _WDF_DMA_ENABLER_CONFIG_V1_0 *PCWDF_DMA_ENABLER_CONFIG_V1_0;
typedef struct _WDF_DPC_CONFIG_V1_0 *PWDF_DPC_CONFIG_V1_0;
typedef const struct _WDF_DPC_CONFIG_V1_0 *PCWDF_DPC_CONFIG_V1_0;
typedef struct _WDF_DRIVER_CONFIG_V1_0 *PWDF_DRIVER_CONFIG_V1_0;
typedef const struct _WDF_DRIVER_CONFIG_V1_0 *PCWDF_DRIVER_CONFIG_V1_0;
typedef struct _WDF_DRIVER_VERSION_AVAILABLE_PARAMS_V1_0 *PWDF_DRIVER_VERSION_AVAILABLE_PARAMS_V1_0;
typedef const struct _WDF_DRIVER_VERSION_AVAILABLE_PARAMS_V1_0 *PCWDF_DRIVER_VERSION_AVAILABLE_PARAMS_V1_0;
typedef struct _WDF_FDO_EVENT_CALLBACKS_V1_0 *PWDF_FDO_EVENT_CALLBACKS_V1_0;
typedef const struct _WDF_FDO_EVENT_CALLBACKS_V1_0 *PCWDF_FDO_EVENT_CALLBACKS_V1_0;
typedef struct _WDF_DRIVER_GLOBALS_V1_0 *PWDF_DRIVER_GLOBALS_V1_0;
typedef const struct _WDF_DRIVER_GLOBALS_V1_0 *PCWDF_DRIVER_GLOBALS_V1_0;
typedef struct _WDF_INTERRUPT_CONFIG_V1_0 *PWDF_INTERRUPT_CONFIG_V1_0;
typedef const struct _WDF_INTERRUPT_CONFIG_V1_0 *PCWDF_INTERRUPT_CONFIG_V1_0;
typedef struct _WDF_INTERRUPT_INFO_V1_0 *PWDF_INTERRUPT_INFO_V1_0;
typedef const struct _WDF_INTERRUPT_INFO_V1_0 *PCWDF_INTERRUPT_INFO_V1_0;
typedef struct _WDF_IO_QUEUE_CONFIG_V1_0 *PWDF_IO_QUEUE_CONFIG_V1_0;
typedef const struct _WDF_IO_QUEUE_CONFIG_V1_0 *PCWDF_IO_QUEUE_CONFIG_V1_0;
typedef struct _WDF_IO_TARGET_OPEN_PARAMS_V1_0 *PWDF_IO_TARGET_OPEN_PARAMS_V1_0;
typedef const struct _WDF_IO_TARGET_OPEN_PARAMS_V1_0 *PCWDF_IO_TARGET_OPEN_PARAMS_V1_0;
typedef struct _WDFMEMORY_OFFSET_V1_0 *PWDFMEMORY_OFFSET_V1_0;
typedef const struct _WDFMEMORY_OFFSET_V1_0 *PCWDFMEMORY_OFFSET_V1_0;
typedef struct _WDF_MEMORY_DESCRIPTOR_V1_0 *PWDF_MEMORY_DESCRIPTOR_V1_0;
typedef const struct _WDF_MEMORY_DESCRIPTOR_V1_0 *PCWDF_MEMORY_DESCRIPTOR_V1_0;
typedef struct _WDF_OBJECT_ATTRIBUTES_V1_0 *PWDF_OBJECT_ATTRIBUTES_V1_0;
typedef const struct _WDF_OBJECT_ATTRIBUTES_V1_0 *PCWDF_OBJECT_ATTRIBUTES_V1_0;
typedef struct _WDF_OBJECT_CONTEXT_TYPE_INFO_V1_0 *PWDF_OBJECT_CONTEXT_TYPE_INFO_V1_0;
typedef const struct _WDF_OBJECT_CONTEXT_TYPE_INFO_V1_0 *PCWDF_OBJECT_CONTEXT_TYPE_INFO_V1_0;
typedef struct _WDF_PDO_EVENT_CALLBACKS_V1_0 *PWDF_PDO_EVENT_CALLBACKS_V1_0;
typedef const struct _WDF_PDO_EVENT_CALLBACKS_V1_0 *PCWDF_PDO_EVENT_CALLBACKS_V1_0;
typedef struct _WDF_QUERY_INTERFACE_CONFIG_V1_0 *PWDF_QUERY_INTERFACE_CONFIG_V1_0;
typedef const struct _WDF_QUERY_INTERFACE_CONFIG_V1_0 *PCWDF_QUERY_INTERFACE_CONFIG_V1_0;
typedef struct _WDF_REQUEST_PARAMETERS_V1_0 *PWDF_REQUEST_PARAMETERS_V1_0;
typedef const struct _WDF_REQUEST_PARAMETERS_V1_0 *PCWDF_REQUEST_PARAMETERS_V1_0;
typedef struct _WDF_REQUEST_COMPLETION_PARAMS_V1_0 *PWDF_REQUEST_COMPLETION_PARAMS_V1_0;
typedef const struct _WDF_REQUEST_COMPLETION_PARAMS_V1_0 *PCWDF_REQUEST_COMPLETION_PARAMS_V1_0;
typedef struct _WDF_REQUEST_REUSE_PARAMS_V1_0 *PWDF_REQUEST_REUSE_PARAMS_V1_0;
typedef const struct _WDF_REQUEST_REUSE_PARAMS_V1_0 *PCWDF_REQUEST_REUSE_PARAMS_V1_0;
typedef struct _WDF_REQUEST_SEND_OPTIONS_V1_0 *PWDF_REQUEST_SEND_OPTIONS_V1_0;
typedef const struct _WDF_REQUEST_SEND_OPTIONS_V1_0 *PCWDF_REQUEST_SEND_OPTIONS_V1_0;
typedef struct _WDF_TIMER_CONFIG_V1_0 *PWDF_TIMER_CONFIG_V1_0;
typedef const struct _WDF_TIMER_CONFIG_V1_0 *PCWDF_TIMER_CONFIG_V1_0;
typedef struct _WDF_USB_REQUEST_COMPLETION_PARAMS_V1_0 *PWDF_USB_REQUEST_COMPLETION_PARAMS_V1_0;
typedef const struct _WDF_USB_REQUEST_COMPLETION_PARAMS_V1_0 *PCWDF_USB_REQUEST_COMPLETION_PARAMS_V1_0;
typedef struct _WDF_USB_CONTINUOUS_READER_CONFIG_V1_0 *PWDF_USB_CONTINUOUS_READER_CONFIG_V1_0;
typedef const struct _WDF_USB_CONTINUOUS_READER_CONFIG_V1_0 *PCWDF_USB_CONTINUOUS_READER_CONFIG_V1_0;
typedef struct _WDF_USB_DEVICE_INFORMATION_V1_0 *PWDF_USB_DEVICE_INFORMATION_V1_0;
typedef const struct _WDF_USB_DEVICE_INFORMATION_V1_0 *PCWDF_USB_DEVICE_INFORMATION_V1_0;
typedef struct _WDF_USB_INTERFACE_SETTING_PAIR_V1_0 *PWDF_USB_INTERFACE_SETTING_PAIR_V1_0;
typedef const struct _WDF_USB_INTERFACE_SETTING_PAIR_V1_0 *PCWDF_USB_INTERFACE_SETTING_PAIR_V1_0;
typedef struct _WDF_USB_DEVICE_SELECT_CONFIG_PARAMS_V1_0 *PWDF_USB_DEVICE_SELECT_CONFIG_PARAMS_V1_0;
typedef const struct _WDF_USB_DEVICE_SELECT_CONFIG_PARAMS_V1_0 *PCWDF_USB_DEVICE_SELECT_CONFIG_PARAMS_V1_0;
typedef struct _WDF_USB_INTERFACE_SELECT_SETTING_PARAMS_V1_0 *PWDF_USB_INTERFACE_SELECT_SETTING_PARAMS_V1_0;
typedef const struct _WDF_USB_INTERFACE_SELECT_SETTING_PARAMS_V1_0 *PCWDF_USB_INTERFACE_SELECT_SETTING_PARAMS_V1_0;
typedef struct _WDF_USB_PIPE_INFORMATION_V1_0 *PWDF_USB_PIPE_INFORMATION_V1_0;
typedef const struct _WDF_USB_PIPE_INFORMATION_V1_0 *PCWDF_USB_PIPE_INFORMATION_V1_0;
typedef struct _WDF_WMI_PROVIDER_CONFIG_V1_0 *PWDF_WMI_PROVIDER_CONFIG_V1_0;
typedef const struct _WDF_WMI_PROVIDER_CONFIG_V1_0 *PCWDF_WMI_PROVIDER_CONFIG_V1_0;
typedef struct _WDF_WMI_INSTANCE_CONFIG_V1_0 *PWDF_WMI_INSTANCE_CONFIG_V1_0;
typedef const struct _WDF_WMI_INSTANCE_CONFIG_V1_0 *PCWDF_WMI_INSTANCE_CONFIG_V1_0;
typedef struct _WDF_WORKITEM_CONFIG_V1_0 *PWDF_WORKITEM_CONFIG_V1_0;
typedef const struct _WDF_WORKITEM_CONFIG_V1_0 *PCWDF_WORKITEM_CONFIG_V1_0;

//
// Versioning of structures for wdf.h
//
// End of versioning of structures for wdf.h

//
// Versioning of structures for wdfassert.h
//
// End of versioning of structures for wdfassert.h

//
// Versioning of structures for wdfbugcodes.h
//
typedef struct _WDF_POWER_ROUTINE_TIMED_OUT_DATA_V1_0 {
    //
    // Current power state associated with the timed out device
    //
    WDF_DEVICE_POWER_STATE PowerState;

    //
    // Current power policy state associated with the timed out device
    //
    WDF_DEVICE_POWER_POLICY_STATE PowerPolicyState;

    //
    // The device object for the timed out device
    //
    PDEVICE_OBJECT DeviceObject;

    //
    // The handle for the timed out device
    //
    WDFDEVICE Device;

    //
    // The thread which is stuck
    //
    PKTHREAD TimedOutThread;

} WDF_POWER_ROUTINE_TIMED_OUT_DATA_V1_0;

typedef struct _WDF_REQUEST_FATAL_ERROR_INFORMATION_LENGTH_MISMATCH_DATA_V1_0 {
    WDFREQUEST Request;

    PIRP Irp;

    ULONG OutputBufferLength;

    ULONG_PTR Information;

    UCHAR MajorFunction;

} WDF_REQUEST_FATAL_ERROR_INFORMATION_LENGTH_MISMATCH_DATA_V1_0, *PWDF_REQUEST_FATAL_ERROR_INFORMATION_LENGTH_MISMATCH_DATA_V1_0;

typedef struct _WDF_QUEUE_FATAL_ERROR_DATA_V1_0 {
    WDFQUEUE Queue;

    WDFREQUEST Request;

    NTSTATUS Status;

} WDF_QUEUE_FATAL_ERROR_DATA_V1_0, *PWDF_QUEUE_FATAL_ERROR_DATA_V1_0;

// End of versioning of structures for wdfbugcodes.h

//
// Versioning of structures for wdfchildlist.h
//
typedef struct _WDF_CHILD_IDENTIFICATION_DESCRIPTION_HEADER_V1_0 {
    //
    // Size in bytes of the entire description, including this header.
    //
    // Same value as WDF_CHILD_LIST_CONFIG::IdentificationDescriptionSize
    // Used as a sanity check.
    //
    ULONG IdentificationDescriptionSize;

} WDF_CHILD_IDENTIFICATION_DESCRIPTION_HEADER_V1_0, *PWDF_CHILD_IDENTIFICATION_DESCRIPTION_HEADER_V1_0;

typedef struct _WDF_CHILD_ADDRESS_DESCRIPTION_HEADER_V1_0 {
    //
    // Size in bytes of the entire description, including this header.
    //
    // Same value as WDF_CHILD_LIST_CONFIG::AddressDescriptionSize
    // Used as a sanity check.
    //
    ULONG AddressDescriptionSize;

} WDF_CHILD_ADDRESS_DESCRIPTION_HEADER_V1_0, *PWDF_CHILD_ADDRESS_DESCRIPTION_HEADER_V1_0;

typedef struct _WDF_CHILD_RETRIEVE_INFO_V1_0 {
    //
    // Size of the structure in bytes
    //
    ULONG Size;

    //
    // Must be a valid pointer when passed in, copied into upon success
    //
    PWDF_CHILD_IDENTIFICATION_DESCRIPTION_HEADER_V1_0 IdentificationDescription;

    //
    // Optional pointer when passed in, copied into upon success
    //
    PWDF_CHILD_ADDRESS_DESCRIPTION_HEADER_V1_0 AddressDescription;

    //
    // Status of the returned device
    //
    WDF_CHILD_LIST_RETRIEVE_DEVICE_STATUS Status;

    //
    // If provided, will be used for searching through the list of devices
    // instead of the default list ID compare function
    //
    PFN_WDF_CHILD_LIST_IDENTIFICATION_DESCRIPTION_COMPARE EvtChildListIdentificationDescriptionCompare;

} WDF_CHILD_RETRIEVE_INFO_V1_0, *PWDF_CHILD_RETRIEVE_INFO_V1_0;

typedef struct _WDF_CHILD_LIST_CONFIG_V1_0 {
    //
    // Size of this structure in bytes
    //
    ULONG Size;

    //
    // The size in bytes of an identificaiton description to be used with the
    // created WDFCHILDLIST handle
    //
    ULONG IdentificationDescriptionSize;

    //
    // Optional size in bytes of an address description to be used with the
    // created WDFCHILDLIST handle.
    //
    ULONG AddressDescriptionSize;

    //
    // Required callback to be invoked when a description on the device list
    // needs to be converted into a real WDFDEVICE handle.
    //
    PFN_WDF_CHILD_LIST_CREATE_DEVICE EvtChildListCreateDevice;

    //
    // Optional callback to be invoked when the device list needs to be
    // rescanned.  This function will be called after the device has entered D0
    // and been fully initialized but before I/O has started.
    //
    PFN_WDF_CHILD_LIST_SCAN_FOR_CHILDREN EvtChildListScanForChildren;

    //
    // Optional callback to be invoked when an identification description needs
    // to be copied from one location to another.
    //
    // If left NULL, RtlCopyMemory will be used to copy the description.
    //
    PFN_WDF_CHILD_LIST_IDENTIFICATION_DESCRIPTION_COPY EvtChildListIdentificationDescriptionCopy;

    //
    // Optional callback to be invoked when an identification description needs
    // to be duplicated.  As opposed to EvtChildListIdentificationDescriptionCopy,
    // EvtChildListIdentificationDescriptionDuplicate can fail.
    //
    PFN_WDF_CHILD_LIST_IDENTIFICATION_DESCRIPTION_DUPLICATE EvtChildListIdentificationDescriptionDuplicate;

    //
    // Optional callback to be invoked when an identification description needs
    // to be cleaned up.  This function should *NOT* free the description passed
    // to it, just free any associated resources.
    //
    PFN_WDF_CHILD_LIST_IDENTIFICATION_DESCRIPTION_CLEANUP EvtChildListIdentificationDescriptionCleanup;

    //
    // Optional callback to be invoked when an identification description needs
    // to be compared with another identificaiton description.
    //
    // If left NULL, RtlCompareMemory will be used to compare the two
    // descriptions.
    //
    PFN_WDF_CHILD_LIST_IDENTIFICATION_DESCRIPTION_COMPARE EvtChildListIdentificationDescriptionCompare;

    //
    // Optional callback to be invoked when an address description needs
    // to be copied from one location to another.
    //
    // If left NULL, RtlCopyMemory will be used to copy the description.
    //
    PFN_WDF_CHILD_LIST_ADDRESS_DESCRIPTION_COPY EvtChildListAddressDescriptionCopy;

    //
    // Optional callback to be invoked when an address description needs to be
    // duplicated.  As opposed to EvtChildListAddressDescriptionCopy,
    // EvtChildListAddressDescriptionDuplicate can fail.
    //
    PFN_WDF_CHILD_LIST_ADDRESS_DESCRIPTION_DUPLICATE EvtChildListAddressDescriptionDuplicate;

    //
    // Optional callback to be invoked when an address description needs to be
    // cleaned up.  This function should *NOT* free the description passed to
    // it, just free any associated resources.
    //
    PFN_WDF_CHILD_LIST_ADDRESS_DESCRIPTION_CLEANUP EvtChildListAddressDescriptionCleanup;

    //
    // If provided, will be called when the child's stack requests that the
    // child be reenumerated.  Returning TRUE allows for the reenumeration to
    // proceed.  FALSE will no reenumerate the stack.
    //
    PFN_WDF_CHILD_LIST_DEVICE_REENUMERATED EvtChildListDeviceReenumerated;

} WDF_CHILD_LIST_CONFIG_V1_0, *PWDF_CHILD_LIST_CONFIG_V1_0;

typedef struct _WDF_CHILD_LIST_ITERATOR_V1_0 {
    //
    // Size of this structure in bytes
    //
    ULONG Size;

    //
    // What type of devices to return, see WDF_RETRIEVE_CHILD_FLAGS for
    // flag values
    //
    //
    ULONG Flags;

    //
    // For internal use, treat this field as opaque
    //
    PVOID Reserved[4];

} WDF_CHILD_LIST_ITERATOR_V1_0, *PWDF_CHILD_LIST_ITERATOR_V1_0;

// End of versioning of structures for wdfchildlist.h

//
// Versioning of structures for wdfClassExtension.h
//
typedef struct _WDF_CLASS_EXTENSION_DESCRIPTOR_V1_0 {
    PCWDF_CLASS_EXTENSION_DESCRIPTOR_V1_0   Next;

    ULONG                             Size;

    PFN_WDF_CLASS_EXTENSIONIN_BIND    Bind;

    PFN_WDF_CLASS_EXTENSIONIN_UNBIND  Unbind;

} WDF_CLASS_EXTENSION_DESCRIPTOR_V1_0, *PWDF_CLASS_EXTENSION_DESCRIPTOR_V1_0;

// End of versioning of structures for wdfClassExtension.h

//
// Versioning of structures for wdfClassExtensionList.h
//
// End of versioning of structures for wdfClassExtensionList.h

//
// Versioning of structures for wdfcollection.h
//
// End of versioning of structures for wdfcollection.h

//
// Versioning of structures for wdfCommonBuffer.h
//
// End of versioning of structures for wdfCommonBuffer.h

//
// Versioning of structures for wdfcontrol.h
//
// End of versioning of structures for wdfcontrol.h

//
// Versioning of structures for wdfcore.h
//
// End of versioning of structures for wdfcore.h

//
// Versioning of structures for wdfDevice.h
//
typedef struct _WDF_FILEOBJECT_CONFIG_V1_0 {
    //
    // Size of this structure in bytes
    //
    ULONG Size;

    //
    // Event callback for create requests
    //
    PFN_WDF_DEVICE_FILE_CREATE  EvtDeviceFileCreate;

    //
    // Event callback for close requests
    //
    PFN_WDF_FILE_CLOSE   EvtFileClose;

    //
    // Event callback for cleanup requests
    //
    PFN_WDF_FILE_CLEANUP EvtFileCleanup;

    //
    // If WdfTrue, create/cleanup/close file object related requests will be
    // sent down the stack.
    //
    // If WdfFalse, create/cleanup/close will be completed at this location in
    // the device stack.
    //
    // If WdfDefault, behavior depends on device type
    // FDO, PDO, Control:  use the WdfFalse behavior
    // Filter:  use the WdfTrue behavior
    //
    WDF_TRI_STATE AutoForwardCleanupClose;

    //
    // Specify whether framework should create WDFFILEOBJECT and also
    // whether it can FsContexts fields in the WDM fileobject to store
    // WDFFILEOBJECT so that it can avoid table look up and improve perf.
    //
    WDF_FILEOBJECT_CLASS FileObjectClass;

} WDF_FILEOBJECT_CONFIG_V1_0, *PWDF_FILEOBJECT_CONFIG_V1_0;

typedef struct _WDF_DEVICE_PNP_NOTIFICATION_DATA_V1_0 {
    //
    // Type of data
    //
    WDF_STATE_NOTIFICATION_TYPE Type;

    union {
        struct {
            //
            // The current state that is about to be exited
            //
            WDF_DEVICE_PNP_STATE CurrentState;

            //
            // The new state that is about to be entered
            //
            WDF_DEVICE_PNP_STATE NewState;

        } EnterState;

        struct {
            //
            // The current state
            //
            WDF_DEVICE_PNP_STATE CurrentState;

        } PostProcessState;

        struct {
            //
            // The current state that is about to be exitted
            //
            WDF_DEVICE_PNP_STATE CurrentState;

            //
            // The state that is about to be entered
            //
            WDF_DEVICE_PNP_STATE NewState;

        } LeaveState;

    } Data;

} WDF_DEVICE_PNP_NOTIFICATION_DATA_V1_0;

typedef struct _WDF_DEVICE_POWER_NOTIFICATION_DATA_V1_0 {
    //
    // Type of data
    //
    WDF_STATE_NOTIFICATION_TYPE Type;

    union {
        struct {
            //
            // The current state that is about to be exitted
            //
            WDF_DEVICE_POWER_STATE CurrentState;

            //
            // The new state that is about to be entered
            //
            WDF_DEVICE_POWER_STATE NewState;

        } EnterState;

        struct {
            //
            // The current state
            //
            WDF_DEVICE_POWER_STATE CurrentState;

        } PostProcessState;

        struct {
            //
            // The current state that is about to be exitted
            //
            WDF_DEVICE_POWER_STATE CurrentState;

            //
            // The state that is about to be entered
            //
            WDF_DEVICE_POWER_STATE NewState;

        } LeaveState;

    } Data;

} WDF_DEVICE_POWER_NOTIFICATION_DATA_V1_0;

typedef struct _WDF_DEVICE_POWER_POLICY_NOTIFICATION_DATA_V1_0 {
    //
    // Type of data
    //
    WDF_STATE_NOTIFICATION_TYPE Type;

    union {
        struct {
            //
            // The current state that is about to be exitted
            //
            WDF_DEVICE_POWER_POLICY_STATE CurrentState;

            //
            // The new state that is about to be entered
            //
            WDF_DEVICE_POWER_POLICY_STATE NewState;

        } EnterState;

        struct {
            //
            // The current state
            //
            WDF_DEVICE_POWER_POLICY_STATE CurrentState;

        } PostProcessState;

        struct {
            //
            // The current state that is about to be exitted
            //
            WDF_DEVICE_POWER_POLICY_STATE CurrentState;

            //
            // The state that is about to be entered
            //
            WDF_DEVICE_POWER_POLICY_STATE NewState;

        } LeaveState;

    } Data;

} WDF_DEVICE_POWER_POLICY_NOTIFICATION_DATA_V1_0;

typedef struct _WDF_PNPPOWER_EVENT_CALLBACKS_V1_0 {
    //
    // Size of this structure in bytes
    //
    ULONG Size;

    PFN_WDF_DEVICE_D0_ENTRY                 EvtDeviceD0Entry;

    PFN_WDF_DEVICE_D0_ENTRY_POST_INTERRUPTS_ENABLED EvtDeviceD0EntryPostInterruptsEnabled;

    PFN_WDF_DEVICE_D0_EXIT                  EvtDeviceD0Exit;

    PFN_WDF_DEVICE_D0_EXIT_PRE_INTERRUPTS_DISABLED EvtDeviceD0ExitPreInterruptsDisabled;

    PFN_WDF_DEVICE_PREPARE_HARDWARE         EvtDevicePrepareHardware;

    PFN_WDF_DEVICE_RELEASE_HARDWARE         EvtDeviceReleaseHardware;

    PFN_WDF_DEVICE_SELF_MANAGED_IO_CLEANUP  EvtDeviceSelfManagedIoCleanup;

    PFN_WDF_DEVICE_SELF_MANAGED_IO_FLUSH    EvtDeviceSelfManagedIoFlush;

    PFN_WDF_DEVICE_SELF_MANAGED_IO_INIT     EvtDeviceSelfManagedIoInit;

    PFN_WDF_DEVICE_SELF_MANAGED_IO_SUSPEND  EvtDeviceSelfManagedIoSuspend;

    PFN_WDF_DEVICE_SELF_MANAGED_IO_RESTART  EvtDeviceSelfManagedIoRestart;

    PFN_WDF_DEVICE_SURPRISE_REMOVAL         EvtDeviceSurpriseRemoval;

    PFN_WDF_DEVICE_QUERY_REMOVE             EvtDeviceQueryRemove;

    PFN_WDF_DEVICE_QUERY_STOP               EvtDeviceQueryStop;

    PFN_WDF_DEVICE_USAGE_NOTIFICATION       EvtDeviceUsageNotification;

    PFN_WDF_DEVICE_RELATIONS_QUERY          EvtDeviceRelationsQuery;

} WDF_PNPPOWER_EVENT_CALLBACKS_V1_0, *PWDF_PNPPOWER_EVENT_CALLBACKS_V1_0;

typedef struct _WDF_POWER_POLICY_EVENT_CALLBACKS_V1_0 {
    //
    // Size of this structure in bytes
    //
    ULONG Size;

    PFN_WDF_DEVICE_ARM_WAKE_FROM_S0         EvtDeviceArmWakeFromS0;

    PFN_WDF_DEVICE_DISARM_WAKE_FROM_S0      EvtDeviceDisarmWakeFromS0;

    PFN_WDF_DEVICE_WAKE_FROM_S0_TRIGGERED   EvtDeviceWakeFromS0Triggered;

    PFN_WDF_DEVICE_ARM_WAKE_FROM_SX         EvtDeviceArmWakeFromSx;

    PFN_WDF_DEVICE_DISARM_WAKE_FROM_SX      EvtDeviceDisarmWakeFromSx;

    PFN_WDF_DEVICE_WAKE_FROM_SX_TRIGGERED   EvtDeviceWakeFromSxTriggered;

} WDF_POWER_POLICY_EVENT_CALLBACKS_V1_0, *PWDF_POWER_POLICY_EVENT_CALLBACKS_V1_0;

typedef struct _WDF_DEVICE_POWER_POLICY_IDLE_SETTINGS_V1_0 {
    //
    // Size of this structure in bytes
    //
    ULONG Size;

    //
    // Indicates whether the device can wake itself up while the machine is in
    // S0.
    //
    WDF_POWER_POLICY_S0_IDLE_CAPABILITIES IdleCaps;

    //
    // The low power state in which the device will be placed when it is idled
    // out while the machine is in S0.
    //
    DEVICE_POWER_STATE DxState;

    //
    // Amount of time the device must be idle before idling out.  Timeout is in
    // milliseconds.
    //
    ULONG IdleTimeout;

    //
    // Inidcates whether a user can control the idle policy of the device.
    // By default, a user is allowed to change the policy.
    //
    WDF_POWER_POLICY_S0_IDLE_USER_CONTROL UserControlOfIdleSettings;

    //
    // If WdfTrue, idling out while the machine is in S0 will be enabled.
    //
    // If WdfFalse, idling out will be disabled.
    //
    // If WdfUseDefault, the idling out will be enabled.  If
    // UserControlOfIdleSettings is set to IdleAllowUserControl, the user's
    // settings will override the default.
    //
    WDF_TRI_STATE Enabled;

} WDF_DEVICE_POWER_POLICY_IDLE_SETTINGS_V1_0, *PWDF_DEVICE_POWER_POLICY_IDLE_SETTINGS_V1_0;

typedef struct _WDF_DEVICE_POWER_POLICY_WAKE_SETTINGS_V1_0 {
    //
    // Size of this structure in bytes
    //
    ULONG Size;

    //
    // The low power state in which the device will be placed when it is armed
    // for wake from Sx.
    //
    DEVICE_POWER_STATE DxState;

    //
    // Inidcates whether a user can control the idle policy of the device.
    // By default, a user is allowed to change the policy.
    //
    WDF_POWER_POLICY_SX_WAKE_USER_CONTROL UserControlOfWakeSettings;

    //
    // If WdfTrue, arming the device for wake while the machine is in Sx is
    // enabled.
    //
    // If WdfFalse, arming the device for wake while the machine is in Sx is
    // disabled.
    //
    // If WdfUseDefault, arming will be enabled.  If UserControlOfWakeSettings
    // is set to WakeAllowUserControl, the user's settings will override the
    // default.
    //
    WDF_TRI_STATE Enabled;

} WDF_DEVICE_POWER_POLICY_WAKE_SETTINGS_V1_0, *PWDF_DEVICE_POWER_POLICY_WAKE_SETTINGS_V1_0;

typedef struct _WDF_DEVICE_STATE_V1_0 {
    //
    // Size of this structure in bytes
    //
    ULONG Size;

    //
    // If set to WdfTrue, the device will be disabled
    //
    WDF_TRI_STATE Disabled;

    //
    // If set to WdfTrue, the device will not be displayed in device manager.
    // Once hidden, the device cannot be unhidden.
    //
    WDF_TRI_STATE DontDisplayInUI;

    //
    // If set to WdfTrue, the device is reporting itself as failed.  If set
    // in conjuction with ResourcesChanged to WdfTrue, the device will receive
    // a PnP stop and then a new PnP start device.
    //
    WDF_TRI_STATE Failed;

    //
    // If set to WdfTrue, the device cannot be subsequently disabled.
    //
    WDF_TRI_STATE NotDisableable;

    //
    //
    // If set to WdfTrue, the device stack will be torn down.
    //
    WDF_TRI_STATE Removed;

    //
    // If set to WdfTrue, the device will be sent another PnP start.  If the
    // Failed field is set to WdfTrue as well, a PnP stop will be sent before
    // the start.
    //
    WDF_TRI_STATE ResourcesChanged;

} WDF_DEVICE_STATE_V1_0, *PWDF_DEVICE_STATE_V1_0;

typedef struct _WDF_DEVICE_PNP_CAPABILITIES_V1_0 {
    //
    // Size of the structure in bytes
    //
    ULONG Size;

    //
    // NOTE: To mark a PDO as raw, call WdfPdoInitAssignRawDevice
    //
    //
    WDF_TRI_STATE LockSupported;

    WDF_TRI_STATE EjectSupported;

    WDF_TRI_STATE Removable;

    WDF_TRI_STATE DockDevice;

    WDF_TRI_STATE UniqueID;

    WDF_TRI_STATE SilentInstall;

    WDF_TRI_STATE SurpriseRemovalOK;

    WDF_TRI_STATE HardwareDisabled;

    WDF_TRI_STATE NoDisplayInUI;

    //
    // Default values of -1 indicate not to set this value
    //
    ULONG Address;

    ULONG UINumber;

} WDF_DEVICE_PNP_CAPABILITIES_V1_0, *PWDF_DEVICE_PNP_CAPABILITIES_V1_0;

typedef struct _WDF_DEVICE_POWER_CAPABILITIES_V1_0 {
    //
    // Size of the structure in bytes
    //
    ULONG Size;

    WDF_TRI_STATE DeviceD1;

    WDF_TRI_STATE DeviceD2;

    WDF_TRI_STATE WakeFromD0;

    WDF_TRI_STATE WakeFromD1;

    WDF_TRI_STATE WakeFromD2;

    WDF_TRI_STATE WakeFromD3;

    //
    // Default value PowerDeviceMaximum indicates not to set this value
    //
    DEVICE_POWER_STATE DeviceState[PowerSystemMaximum];

    //
    // Default value PowerDeviceMaximum, PowerSystemMaximum indicates not to
    // set this value.
    //
    DEVICE_POWER_STATE DeviceWake;

    SYSTEM_POWER_STATE SystemWake;

    //
    // Default values of -1 indicate not to set this value
    //
    ULONG D1Latency;

    ULONG D2Latency;

    ULONG D3Latency;

    //
    // Ideal Dx state for the device to be put into when the machine moves into
    // Sx and the device is not armed for wake.  By default, the default will be
    // placed into D3.  If IdealDxStateForSx is lighter then
    // DeviceState[Sx], then DeviceState[Sx] will be used as the Dx state.
    //
    DEVICE_POWER_STATE IdealDxStateForSx;

} WDF_DEVICE_POWER_CAPABILITIES_V1_0, *PWDF_DEVICE_POWER_CAPABILITIES_V1_0;

// End of versioning of structures for wdfDevice.h

//
// Versioning of structures for wdfDmaEnabler.h
//
typedef struct _WDF_DMA_ENABLER_CONFIG_V1_0 {
    //
    // Size of this structure in bytes
    //
    ULONG                Size;

    //
    // One of the above WDF_DMA_PROFILES
    //
    WDF_DMA_PROFILE      Profile;

    //
    // Maximum DMA Transfer handled in bytes.
    //
    size_t               MaximumLength;

    //
    // The various DMA PnP/Power event callbacks
    //
    PFN_WDF_DMA_ENABLER_FILL                  EvtDmaEnablerFill;

    PFN_WDF_DMA_ENABLER_FLUSH                 EvtDmaEnablerFlush;

    PFN_WDF_DMA_ENABLER_DISABLE               EvtDmaEnablerDisable;

    PFN_WDF_DMA_ENABLER_ENABLE                EvtDmaEnablerEnable;

    PFN_WDF_DMA_ENABLER_SELFMANAGED_IO_START  EvtDmaEnablerSelfManagedIoStart;

    PFN_WDF_DMA_ENABLER_SELFMANAGED_IO_STOP   EvtDmaEnablerSelfManagedIoStop;

} WDF_DMA_ENABLER_CONFIG_V1_0, *PWDF_DMA_ENABLER_CONFIG_V1_0;

// End of versioning of structures for wdfDmaEnabler.h

//
// Versioning of structures for wdfDmaTransaction.h
//
// End of versioning of structures for wdfDmaTransaction.h

//
// Versioning of structures for wdfdpc.h
//
typedef struct _WDF_DPC_CONFIG_V1_0 {
    ULONG       Size;

    PFN_WDF_DPC EvtDpcFunc;

    //
    // If this is TRUE, the DPC will automatically serialize
    // with the event callback handlers of its Parent Object.
    //
    // Parent Object's callback constraints should be compatible
    // with the DPC (DISPATCH_LEVEL), or the request will fail.
    //
    BOOLEAN     AutomaticSerialization;

} WDF_DPC_CONFIG_V1_0, *PWDF_DPC_CONFIG_V1_0;

// End of versioning of structures for wdfdpc.h

//
// Versioning of structures for wdfdriver.h
//
typedef struct _WDF_DRIVER_CONFIG_V1_0 {
    //
    // Size of this structure in bytes
    //
    ULONG Size;

    //
    // Event callbacks
    //
    PFN_WDF_DRIVER_DEVICE_ADD EvtDriverDeviceAdd;

    PFN_WDF_DRIVER_UNLOAD    EvtDriverUnload;

    //
    // Combination of WDF_DRIVER_INIT_FLAGS values
    //
    ULONG DriverInitFlags;

} WDF_DRIVER_CONFIG_V1_0, *PWDF_DRIVER_CONFIG_V1_0;

typedef struct _WDF_DRIVER_VERSION_AVAILABLE_PARAMS_V1_0 {
    //
    // Size of the structure in bytes
    //
    ULONG Size;

    //
    // Major Version requested
    //
    ULONG MajorVersion;

    //
    // Minor Version requested
    //
    ULONG MinorVersion;

} WDF_DRIVER_VERSION_AVAILABLE_PARAMS_V1_0, *PWDF_DRIVER_VERSION_AVAILABLE_PARAMS_V1_0;

// End of versioning of structures for wdfdriver.h

//
// Versioning of structures for wdffdo.h
//
typedef struct _WDF_FDO_EVENT_CALLBACKS_V1_0 {
    //
    // Size of this structure in bytes
    //
    ULONG Size;

    PFN_WDF_DEVICE_FILTER_RESOURCE_REQUIREMENTS EvtDeviceFilterAddResourceRequirements;

    PFN_WDF_DEVICE_FILTER_RESOURCE_REQUIREMENTS EvtDeviceFilterRemoveResourceRequirements;

    PFN_WDF_DEVICE_REMOVE_ADDED_RESOURCES EvtDeviceRemoveAddedResources;

} WDF_FDO_EVENT_CALLBACKS_V1_0, *PWDF_FDO_EVENT_CALLBACKS_V1_0;

// End of versioning of structures for wdffdo.h

//
// Versioning of structures for wdffileobject.h
//
// End of versioning of structures for wdffileobject.h

//
// Versioning of structures for wdfGlobals.h
//
typedef struct _WDF_DRIVER_GLOBALS_V1_0 {
    // backpointer to the handle for this driver
    WDFDRIVER Driver;

    // Flags indicated by the driver during create
    ULONG DriverFlags;

    // Tag generated by WDF for the driver.  Tag used by allocations made on
    // behalf of the driver by WDF.
    ULONG DriverTag;

    CHAR DriverName[WDF_DRIVER_GLOBALS_NAME_LEN];

    // If TRUE, the stub code will capture DriverObject->DriverUnload and insert
    // itself first in the unload chain.  If FALSE, DriverUnload is left alone
    // (but WDF will not be notified of unload and there will be no auto cleanup).
    BOOLEAN DisplaceDriverUnload;

} WDF_DRIVER_GLOBALS_V1_0, *PWDF_DRIVER_GLOBALS_V1_0;

// End of versioning of structures for wdfGlobals.h

//
// Versioning of structures for wdfinstaller.h
//
// End of versioning of structures for wdfinstaller.h

//
// Versioning of structures for wdfinterrupt.h
//
//
// Interrupt Configuration Structure
//
typedef struct _WDF_INTERRUPT_CONFIG_V1_0 {
    ULONG              Size;

    //
    // If this interrupt is to be synchronized with other interrupt(s) assigned
    // to the same WDFDEVICE, create a WDFSPINLOCK and assign it to each of the
    // WDFINTERRUPTs config.
    //
    WDFSPINLOCK        SpinLock;

    WDF_TRI_STATE      ShareVector;

    BOOLEAN            FloatingSave;

    //
    // Automatic Serialization of the DpcForIsr
    //
    BOOLEAN            AutomaticSerialization;

    // Event Callbacks
    PFN_WDF_INTERRUPT_ISR         EvtInterruptIsr;

    PFN_WDF_INTERRUPT_DPC         EvtInterruptDpc;

    PFN_WDF_INTERRUPT_ENABLE      EvtInterruptEnable;

    PFN_WDF_INTERRUPT_DISABLE     EvtInterruptDisable;

} WDF_INTERRUPT_CONFIG_V1_0, *PWDF_INTERRUPT_CONFIG_V1_0;

typedef struct _WDF_INTERRUPT_INFO_V1_0 {
    //
    // Size of this structure in bytes
    //
    ULONG                  Size;

    PHYSICAL_ADDRESS       MessageAddress;

    KAFFINITY              TargetProcessorSet;

    ULONG                  MessageData;

    ULONG                  MessageNumber;

    ULONG                  Vector;

    KIRQL                  Irql;

    KINTERRUPT_MODE        Mode;

    WDF_INTERRUPT_POLARITY Polarity;

    BOOLEAN                MessageSignaled;

    // CM_SHARE_DISPOSITION
    UCHAR                  ShareDisposition;

} WDF_INTERRUPT_INFO_V1_0, *PWDF_INTERRUPT_INFO_V1_0;

// End of versioning of structures for wdfinterrupt.h

//
// Versioning of structures for wdfio.h
//
//
// This is the structure used to configure an IoQueue and
// register callback events to it.
//
//
typedef struct _WDF_IO_QUEUE_CONFIG_V1_0 {
    ULONG                                       Size;

    WDF_IO_QUEUE_DISPATCH_TYPE                  DispatchType;

    WDF_TRI_STATE                               PowerManaged;

    BOOLEAN                                     AllowZeroLengthRequests;

    BOOLEAN                                     DefaultQueue;

    PFN_WDF_IO_QUEUE_IO_DEFAULT                 EvtIoDefault;

    PFN_WDF_IO_QUEUE_IO_READ                    EvtIoRead;

    PFN_WDF_IO_QUEUE_IO_WRITE                   EvtIoWrite;

    PFN_WDF_IO_QUEUE_IO_DEVICE_CONTROL          EvtIoDeviceControl;

    PFN_WDF_IO_QUEUE_IO_INTERNAL_DEVICE_CONTROL EvtIoInternalDeviceControl;

    PFN_WDF_IO_QUEUE_IO_STOP                    EvtIoStop;

    PFN_WDF_IO_QUEUE_IO_RESUME                  EvtIoResume;

    PFN_WDF_IO_QUEUE_IO_CANCELED_ON_QUEUE       EvtIoCanceledOnQueue;

} WDF_IO_QUEUE_CONFIG_V1_0, *PWDF_IO_QUEUE_CONFIG_V1_0;

// End of versioning of structures for wdfio.h

//
// Versioning of structures for wdfIoTarget.h
//
typedef struct _WDF_IO_TARGET_OPEN_PARAMS_V1_0 {
    //
    // Size of this structure in bytes
    //
    ULONG Size;

    //
    // Indicates which fields of this structure are going to be used in
    // creating the WDFIOTARGET.
    //
    WDF_IO_TARGET_OPEN_TYPE Type;

    //
    // Notification when the target is being queried for removal.
    // If !NT_SUCCESS is returned, the query will fail and the target will
    // remain opened.
    //
    PFN_WDF_IO_TARGET_QUERY_REMOVE EvtIoTargetQueryRemove;

    //
    // The previous query remove has been canceled and the target can now be
    // reopened.
    //
    PFN_WDF_IO_TARGET_REMOVE_CANCELED EvtIoTargetRemoveCanceled;

    //
    // The query remove has succeeded and the target is now removed from the
    // system.
    //
    PFN_WDF_IO_TARGET_REMOVE_COMPLETE EvtIoTargetRemoveComplete;

    // ========== WdfIoTargetOpenUseExistingDevice begin ==========
    //
    // The device object to send requests to
    //
    PDEVICE_OBJECT TargetDeviceObject;

    //
    // File object representing the TargetDeviceObject.  The PFILE_OBJECT will
    // be passed as a parameter in all requests sent to the resulting
    // WDFIOTARGET.
    //
    PFILE_OBJECT TargetFileObject;

    // ========== WdfIoTargetOpenUseExistingDevice end ==========
    //
    // ========== WdfIoTargetOpenByName begin ==========
    //
    // Name of the device to open.
    //
    UNICODE_STRING TargetDeviceName;

    //
    // The access desired on the device being opened up, ie WDM FILE_XXX_ACCESS
    // such as FILE_ANY_ACCESS, FILE_SPECIAL_ACCESS, FILE_READ_ACCESS, or
    // FILE_WRITE_ACCESS or you can use values such as GENERIC_READ,
    // GENERIC_WRITE, or GENERIC_ALL.
    //
    ACCESS_MASK DesiredAccess;

    //
    // Share access desired on the target being opened, ie WDM FILE_SHARE_XXX
    // values such as FILE_SHARE_READ, FILE_SHARE_WRITE, FILE_SHARE_DELETE.
    //
    // A zero value means exclusive access to the target.
    //
    ULONG ShareAccess;

    //
    // File  attributes, see ZwCreateFile in the DDK for a list of valid
    // values and their meaning.
    //
    ULONG FileAttributes;

    //
    // Create disposition, see ZwCreateFile in the DDK for a list of valid
    // values and their meaning.
    //
    ULONG CreateDisposition;

    //
    // Options for opening the device, see CreateOptions for ZwCreateFile in the
    // DDK for a list of valid values and their meaning.
    //
    ULONG CreateOptions;

    PVOID EaBuffer;

    ULONG EaBufferLength;

    PLONGLONG AllocationSize;

    // ========== WdfIoTargetOpenByName end ==========
    //
    //
    // On return for a create by name, this will contain one of the following
    // values:  FILE_CREATED, FILE_OPENED, FILE_OVERWRITTEN, FILE_SUPERSEDED,
    // FILE_EXISTS, FILE_DOES_NOT_EXIST
    //
    ULONG FileInformation;

} WDF_IO_TARGET_OPEN_PARAMS_V1_0, *PWDF_IO_TARGET_OPEN_PARAMS_V1_0;

// End of versioning of structures for wdfIoTarget.h

//
// Versioning of structures for wdfMemory.h
//
typedef struct _WDFMEMORY_OFFSET_V1_0 {
    //
    // Offset into the WDFMEMORY that the operation should start at.
    //
    size_t BufferOffset;

    //
    // Number of bytes that the operation should access.  If 0, the entire
    // length of the WDFMEMORY buffer will be used in the operation or ignored
    // depending on the API.
    //
    size_t BufferLength;

} WDFMEMORY_OFFSET_V1_0, *PWDFMEMORY_OFFSET_V1_0;

typedef struct _WDF_MEMORY_DESCRIPTOR_V1_0 {
    WDF_MEMORY_DESCRIPTOR_TYPE Type;

    union {
        struct {
            PVOID Buffer;

            ULONG Length;

        } BufferType;

        struct {
            PMDL Mdl;

            ULONG BufferLength;

        } MdlType;

        struct {
            WDFMEMORY Memory;

            PWDFMEMORY_OFFSET_V1_0 Offsets;

        } HandleType;

    } u;

} WDF_MEMORY_DESCRIPTOR_V1_0, *PWDF_MEMORY_DESCRIPTOR_V1_0;

// End of versioning of structures for wdfMemory.h

//
// Versioning of structures for wdfMiniport.h
//
// End of versioning of structures for wdfMiniport.h

//
// Versioning of structures for wdfObject.h
//
typedef struct _WDF_OBJECT_ATTRIBUTES_V1_0 {
    //
    // Size in bytes of this structure
    //
    ULONG Size;

    //
    // Function to call when the object is deleted
    //
    PFN_WDF_OBJECT_CONTEXT_CLEANUP EvtCleanupCallback;

    //
    // Function to call when the objects memory is destroyed when the
    // the last reference count goes to zero
    //
    PFN_WDF_OBJECT_CONTEXT_DESTROY EvtDestroyCallback;

    //
    // Execution level constraints for Object
    //
    WDF_EXECUTION_LEVEL            ExecutionLevel;

    //
    // Synchronization level constraint for Object
    //
    WDF_SYNCHRONIZATION_SCOPE        SynchronizationScope;

    //
    // Optional Parent Object
    //
    WDFOBJECT ParentObject;

    //
    // Overrides the size of the context allocated as specified by
    // ContextTypeInfo->ContextSize
    //
    size_t ContextSizeOverride;

    //
    // Pointer to the type information to be associated with the object
    //
    PCWDF_OBJECT_CONTEXT_TYPE_INFO_V1_0 ContextTypeInfo;

} WDF_OBJECT_ATTRIBUTES_V1_0, *PWDF_OBJECT_ATTRIBUTES_V1_0;

//
// Since C does not have strong type checking we must invent our own
//
typedef struct _WDF_OBJECT_CONTEXT_TYPE_INFO_V1_0 {
    //
    // The size of this structure in bytes
    //
    ULONG Size;

    //
    // String representation of the context's type name, i.e. "DEVICE_CONTEXT"
    //
    PCHAR ContextName;

    //
    // The size of the context in bytes.  This will be the size of the context
    // associated with the handle unless
    // WDF_OBJECT_ATTRIBUTES::ContextSizeOverride is specified.
    //
    size_t ContextSize;

} WDF_OBJECT_CONTEXT_TYPE_INFO_V1_0, *PWDF_OBJECT_CONTEXT_TYPE_INFO_V1_0;

// End of versioning of structures for wdfObject.h

//
// Versioning of structures for wdfpdo.h
//
typedef struct _WDF_PDO_EVENT_CALLBACKS_V1_0 {
    //
    // The size of this structure in bytes
    //
    ULONG Size;

    //
    // Called in response to IRP_MN_QUERY_RESOURCES
    //
    PFN_WDF_DEVICE_RESOURCES_QUERY EvtDeviceResourcesQuery;

    //
    // Called in response to IRP_MN_QUERY_RESOURCE_REQUIREMENTS
    //
    PFN_WDF_DEVICE_RESOURCE_REQUIREMENTS_QUERY EvtDeviceResourceRequirementsQuery;

    //
    // Called in response to IRP_MN_EJECT
    //
    PFN_WDF_DEVICE_EJECT EvtDeviceEject;

    //
    // Called in response to IRP_MN_SET_LOCK
    //
    PFN_WDF_DEVICE_SET_LOCK EvtDeviceSetLock;

    //
    // Called in response to the power policy owner sending a wait wake to the
    // PDO.  Bus generic arming shoulding occur here.
    //
    PFN_WDF_DEVICE_ENABLE_WAKE_AT_BUS       EvtDeviceEnableWakeAtBus;

    //
    // Called in response to the power policy owner sending a wait wake to the
    // PDO.  Bus generic disarming shoulding occur here.
    //
    PFN_WDF_DEVICE_DISABLE_WAKE_AT_BUS      EvtDeviceDisableWakeAtBus;

} WDF_PDO_EVENT_CALLBACKS_V1_0, *PWDF_PDO_EVENT_CALLBACKS_V1_0;

// End of versioning of structures for wdfpdo.h

//
// Versioning of structures for wdfpool.h
//
// End of versioning of structures for wdfpool.h

//
// Versioning of structures for wdfqueryinterface.h
//
typedef struct _WDF_QUERY_INTERFACE_CONFIG_V1_0 {
    //
    // Size of this structure in bytes.
    //
    ULONG Size;

    //
    // Interface to be returned to the caller.  Optional if BehaviorType is set
    // to WdfQueryInterfaceTypePassThrough or ImportInterface is set to TRUE.
    //
    PINTERFACE Interface;

    //
    // The GUID identifying the interface
    //
    CONST GUID * InterfaceType;

    //
    // Valid only for PDOs.  The framework will allocate a new request and
    // forward it down the parent's device stack.
    //
    BOOLEAN SendQueryToParentStack;

    //
    //
    // Driver supplied callback which is called after some basic interface
    // validation has been performed (size, version, and guid checking).  This
    // is an optional parameter and may be NULL unless ImportInterface is
    // specified.
    //
    // If the callback returns !NT_SUCCESS, this error will be returned to the
    // caller and the query interface will fail.
    //
    // In this callback, the caller is free to modify the ExposedInterface in
    // any manner of its choosing.  For instance, the callback may change any
    // field in the interface.  The callback may also alloate a dynamic context
    // to be associated with the interface; the InterfaceReference and
    // InterfaceDereference functions may also be overridden.
    //
    // If ImportInterface is set to TRUE, then this is a required field and the
    // callback must initialize the interface (the framework will leave the
    // ExposedInterface buffer exactly as it received it) since the framework
    // has no way of knowing which fields to fill in and which to leave alone.
    //
    PFN_WDF_DEVICE_PROCESS_QUERY_INTERFACE_REQUEST EvtDeviceProcessQueryInterfaceRequest;

    //
    // If TRUE, the interface provided by the caller contains data that the
    // driver is interested in.  By setting to this field to TRUE, the
    // EvtDeviceProcessQueryInterfaceRequest callback must initialize the
    // ExposedInterface.
    //
    // If FALSE, the entire ExposedInterface is initialized through a memory
    // copy before the EvtDeviceProcessQueryInterfaceRequest is called.
    //
    BOOLEAN ImportInterface;

} WDF_QUERY_INTERFACE_CONFIG_V1_0, *PWDF_QUERY_INTERFACE_CONFIG_V1_0;

// End of versioning of structures for wdfqueryinterface.h

//
// Versioning of structures for wdfregistry.h
//
// End of versioning of structures for wdfregistry.h

//
// Versioning of structures for wdfrequest.h
//
//
// This parameters structure allows general access to a requests parameters
//
typedef struct _WDF_REQUEST_PARAMETERS_V1_0 {
    USHORT Size;

    UCHAR MinorFunction;

    WDF_REQUEST_TYPE Type;

    //
    // The following user parameters are based on the service that is being
    // invoked.  Drivers and file systems can determine which set to use based
    // on the above major and minor function codes.
    //
    union {
        //
        // System service parameters for:  Create
        //
        //
        struct {
            PIO_SECURITY_CONTEXT SecurityContext;

            ULONG Options;

            USHORT POINTER_ALIGNMENT FileAttributes;

            USHORT ShareAccess;

            ULONG POINTER_ALIGNMENT EaLength;

        } Create;

        //
        // System service parameters for:  Read
        //
        //
        struct {
            size_t Length;

            ULONG POINTER_ALIGNMENT Key;

            LONGLONG DeviceOffset;

        } Read;

        //
        // System service parameters for:  Write
        //
        //
        struct {
            size_t Length;

            ULONG POINTER_ALIGNMENT Key;

            LONGLONG DeviceOffset;

        } Write;

        //
        // System service parameters for:  Device Control
        //
        // Note that the user's output buffer is stored in the UserBuffer field
        // and the user's input buffer is stored in the SystemBuffer field.
        //
        //
        struct {
            size_t OutputBufferLength;

            size_t POINTER_ALIGNMENT InputBufferLength;

            ULONG POINTER_ALIGNMENT IoControlCode;

            PVOID Type3InputBuffer;

        } DeviceIoControl;

        struct {
            PVOID Arg1;

            PVOID  Arg2;

            ULONG POINTER_ALIGNMENT IoControlCode;

            PVOID Arg4;

        } Others;

    } Parameters;

} WDF_REQUEST_PARAMETERS_V1_0, *PWDF_REQUEST_PARAMETERS_V1_0;

typedef struct _WDF_REQUEST_COMPLETION_PARAMS_V1_0 {
    //
    // Size of the structure in bytes
    //
    ULONG Size;

    WDF_REQUEST_TYPE Type;

    IO_STATUS_BLOCK IoStatus;

    union {
        struct {
            WDFMEMORY Buffer;

            size_t Length;

            size_t Offset;

        } Write;

        struct {
            WDFMEMORY Buffer;

            size_t Length;

            size_t Offset;

        } Read;

        struct {
            ULONG IoControlCode;

            struct {
                WDFMEMORY Buffer;

                size_t Offset;

            } Input;

            struct {
                WDFMEMORY Buffer;

                size_t Offset;

                size_t Length;

            } Output;

        } Ioctl;

        struct {
            union {
                PVOID Ptr;

                ULONG_PTR Value;

            } Argument1;

            union {
                PVOID Ptr;

                ULONG_PTR Value;

            } Argument2;

            union {
                PVOID Ptr;

                ULONG_PTR Value;

            } Argument3;

            union {
                PVOID Ptr;

                ULONG_PTR Value;

            } Argument4;

        } Others;

        struct {
            PWDF_USB_REQUEST_COMPLETION_PARAMS_V1_0 Completion;

        } Usb;

    } Parameters;

} WDF_REQUEST_COMPLETION_PARAMS_V1_0, *PWDF_REQUEST_COMPLETION_PARAMS_V1_0;

typedef struct _WDF_REQUEST_REUSE_PARAMS_V1_0 {
    //
    // Size of this structure in bytes
    //
    ULONG Size;

    //
    // Bit field combination of WDF_REQUEST_REUSE_Xxx values
    //
    ULONG Flags;

    //
    // The new status of the request.
    //
    NTSTATUS Status;

    //
    // New PIRP  to be contained in the WDFREQUEST.   Setting a new PIRP value
    // is only valid for WDFREQUESTs created by WdfRequestCreateFromIrp where
    // RequestFreesIrp == FALSE.  No other WDFREQUESTs (presented by the
    // I/O queue for instance) may have their IRPs changed.
    //
    PIRP NewIrp;

} WDF_REQUEST_REUSE_PARAMS_V1_0, *PWDF_REQUEST_REUSE_PARAMS_V1_0;

typedef struct _WDF_REQUEST_SEND_OPTIONS_V1_0 {
    //
    // Size of the structure in bytes
    //
    ULONG Size;

    //
    // Bit field combination of values from the WDF_REQUEST_SEND_OPTIONS_FLAGS
    // enumeration
    //
    ULONG Flags;

    //
    // Valid when WDF_REQUEST_SEND_OPTION_TIMEOUT is set
    //
    LONGLONG Timeout;

} WDF_REQUEST_SEND_OPTIONS_V1_0, *PWDF_REQUEST_SEND_OPTIONS_V1_0;

// End of versioning of structures for wdfrequest.h

//
// Versioning of structures for wdfresource.h
//
// End of versioning of structures for wdfresource.h

//
// Versioning of structures for wdfstring.h
//
// End of versioning of structures for wdfstring.h

//
// Versioning of structures for wdfsync.h
//
// End of versioning of structures for wdfsync.h

//
// Versioning of structures for wdftimer.h
//
typedef struct _WDF_TIMER_CONFIG_V1_0 {
    ULONG         Size;

    PFN_WDF_TIMER EvtTimerFunc;

    LONG          Period;

    //
    // If this is TRUE, the Timer will automatically serialize
    // with the event callback handlers of its Parent Object.
    //
    // Parent Object's callback constraints should be compatible
    // with the Timer DPC (DISPATCH_LEVEL), or the request will fail.
    //
    BOOLEAN       AutomaticSerialization;

} WDF_TIMER_CONFIG_V1_0, *PWDF_TIMER_CONFIG_V1_0;

// End of versioning of structures for wdftimer.h

//
// Versioning of structures for wdftypes.h
//
// End of versioning of structures for wdftypes.h

//
// Versioning of structures for wdfUsb.h
//
typedef struct _WDF_USB_REQUEST_COMPLETION_PARAMS_V1_0 {
    USBD_STATUS UsbdStatus;

    WDF_USB_REQUEST_TYPE Type;

    union {
        struct {
            WDFMEMORY Buffer;

            USHORT LangID;

            UCHAR StringIndex;

            //
            // If STATUS_BUFFER_OVERFLOW is returned, this field will contain the
            // number of bytes required to retrieve the entire string.
            //
            UCHAR RequiredSize;

        } DeviceString;

        struct {
            WDFMEMORY Buffer;

            WDF_USB_CONTROL_SETUP_PACKET SetupPacket;

            ULONG Length;

        } DeviceControlTransfer;

        struct {
            WDFMEMORY Buffer;

        } DeviceUrb;

        struct {
            WDFMEMORY Buffer;

            size_t Length;

            size_t Offset;

        } PipeWrite;

        struct {
            WDFMEMORY Buffer;

            size_t Length;

            size_t Offset;

        } PipeRead;

        struct {
            WDFMEMORY Buffer;

        } PipeUrb;

    } Parameters;

} WDF_USB_REQUEST_COMPLETION_PARAMS_V1_0, *PWDF_USB_REQUEST_COMPLETION_PARAMS_V1_0;

typedef struct _WDF_USB_CONTINUOUS_READER_CONFIG_V1_0 {
    //
    // Size of the string in bytes
    //
    ULONG Size;

    //
    // Number of bytes to send ask for from the usb device.
    //
    size_t TransferLength;

    //
    // Number of bytes to allocate before the requested transfer length
    //
    size_t HeaderLength;

    //
    // Number of bytes to allocate after the requested transfer length
    //
    size_t TrailerLength;

    //
    // Number of reads to send to the device at once.  If zero is specified, the
    // default will be used.
    //
    UCHAR NumPendingReads;

    //
    // Optional attributes to apply to each WDFMEMORY allocated for each read
    //
    PWDF_OBJECT_ATTRIBUTES_V1_0 BufferAttributes;

    //
    // Event callback invoked when a read is completed
    //
    PFN_WDF_USB_READER_COMPLETION_ROUTINE EvtUsbTargetPipeReadComplete;

    //
    // Context to be passed to EvtUsbTargetPipeReadComplete
    //
    WDFCONTEXT EvtUsbTargetPipeReadCompleteContext;

    //
    // Event callback invoked when a reader fails.  If TRUE is returned, the
    // readers are restarted.
    //
    PFN_WDF_USB_READERS_FAILED EvtUsbTargetPipeReadersFailed;

} WDF_USB_CONTINUOUS_READER_CONFIG_V1_0, *PWDF_USB_CONTINUOUS_READER_CONFIG_V1_0;

typedef struct _WDF_USB_DEVICE_INFORMATION_V1_0 {
    //
    // Size of this structure in bytes
    //
    ULONG Size;

    //
    // USBD version information
    //
    USBD_VERSION_INFORMATION UsbdVersionInformation;

    //
    // Usb controller port capabilities
    //
    ULONG HcdPortCapabilities;

    //
    // Bitfield of WDF_USB_DEVICE_TRAITS values
    //
    ULONG Traits;

} WDF_USB_DEVICE_INFORMATION_V1_0, *PWDF_USB_DEVICE_INFORMATION_V1_0;

typedef struct _WDF_USB_INTERFACE_SETTING_PAIR_V1_0 {
    //
    // Interface to select
    //
    WDFUSBINTERFACE UsbInterface;

    //
    // Setting to select on UsbInterface
    //
    UCHAR SettingIndex;

} WDF_USB_INTERFACE_SETTING_PAIR_V1_0, *PWDF_USB_INTERFACE_SETTING_PAIR_V1_0;

typedef struct _WDF_USB_DEVICE_SELECT_CONFIG_PARAMS_V1_0 {
    //
    // Size of the structure in bytes
    //
    ULONG Size;

    //
    // Type of select config, one of WdfUsbTargetDeviceSelectConfigType values
    //
    WdfUsbTargetDeviceSelectConfigType Type;

    union {
        struct {
            //
            // Configuration descriptor to use
            //
            PUSB_CONFIGURATION_DESCRIPTOR ConfigurationDescriptor;

            //
            // Array of interface descriptors pointers.
            //
            PUSB_INTERFACE_DESCRIPTOR * InterfaceDescriptors;

            //
            // Number of elements in the InterfaceDescrtiptors pointer array.
            //
            ULONG NumInterfaceDescriptors;

        } Descriptor;

        struct {
            //
            // Preallocated select config URB formatted by the caller.
            // Will be used, as supplied without modification, as the select
            // config request.
            //
            PURB Urb;

        } Urb;

        struct {
            //
            // Number of pipes configured on the single after.  This value is
            // returned to the caller after a succssful call.
            //
            UCHAR   NumberConfiguredPipes;

            //
            // The interface which was configred.  This value is returned to the
            // caller after a successful call.
            //
            WDFUSBINTERFACE ConfiguredUsbInterface;

        } SingleInterface;

        struct {
            //
            // Number of interface pairs in the Pairs array
            //
            UCHAR NumberInterfaces;

            //
            // Array of interface + settings
            //
            PWDF_USB_INTERFACE_SETTING_PAIR_V1_0 Pairs;

            //
            // Number of interfaces which were configured after a successful call
            //
            UCHAR NumberOfConfiguredInterfaces;

        } MultiInterface;

    } Types;

} WDF_USB_DEVICE_SELECT_CONFIG_PARAMS_V1_0, *PWDF_USB_DEVICE_SELECT_CONFIG_PARAMS_V1_0;

typedef struct _WDF_USB_INTERFACE_SELECT_SETTING_PARAMS_V1_0 {
    //
    // Size of this data structure in bytes
    //
    ULONG Size;

    //
    // Type of select interface as indicated by one of the
    // WdfUsbTargetDeviceSelectSettingType values.
    //
    WdfUsbTargetDeviceSelectSettingType Type;

    union {
        struct {
            //
            // Interface descriptor that will be used in the interface selection
            //
            PUSB_INTERFACE_DESCRIPTOR InterfaceDescriptor;

        } Descriptor;

        struct {
            //
            // The setting index of the WDFUSBINTERFACE to use
            //
            UCHAR SettingIndex;

        } Interface;

        struct {
            //
            // Preformatted select interface URB which will be used in the
            // select interface request.
            //
            PURB Urb;

        } Urb;

    } Types;

} WDF_USB_INTERFACE_SELECT_SETTING_PARAMS_V1_0, *PWDF_USB_INTERFACE_SELECT_SETTING_PARAMS_V1_0;

typedef struct _WDF_USB_PIPE_INFORMATION_V1_0 {
    //
    // Size of the structure in bytes
    //
    ULONG Size;

    //
    // Maximum packet size this device is capable of
    //
    ULONG MaximumPacketSize;

    //
    // Raw endpoint address of the device as described by its descriptor
    //
    UCHAR EndpointAddress;

    //
    // Polling interval
    //
    UCHAR Interval;

    //
    // Which alternate setting this structure is relevant for
    //
    UCHAR SettingIndex;

    //
    // The type of the pipe
    WDF_USB_PIPE_TYPE PipeType;

    //
    // Maximum size of one transfer which should be sent to the host controller
    //
    ULONG  MaximumTransferSize;

} WDF_USB_PIPE_INFORMATION_V1_0, *PWDF_USB_PIPE_INFORMATION_V1_0;

// End of versioning of structures for wdfUsb.h

//
// Versioning of structures for wdfverifier.h
//
// End of versioning of structures for wdfverifier.h

//
// Versioning of structures for wdfWMI.h
//
typedef struct _WDF_WMI_PROVIDER_CONFIG_V1_0 {
    //
    // Size of this structure in bytes
    //
    ULONG Size;

    //
    // The GUID being registered
    //
    GUID Guid;

    //
    // Combination of values from the enum WDF_WMI_PROVIDER_FLAGS
    //
    ULONG Flags;

    //
    // Minimum expected buffer size for query and set instance requests.
    // Ignored if WdfWmiProviderEventOnly is set in Flags.
    //
    ULONG MinInstanceBufferSize;

    //
    // Callback when caller is opening a provider which ha been marked as
    // expensive or when a caller is interested in events.
    //
    PFN_WDF_WMI_PROVIDER_FUNCTION_CONTROL EvtWmiProviderFunctionControl;

} WDF_WMI_PROVIDER_CONFIG_V1_0, *PWDF_WMI_PROVIDER_CONFIG_V1_0;

typedef struct _WDF_WMI_INSTANCE_CONFIG_V1_0 {
    //
    // Size of the structure in bytes
    //
    ULONG Size;

    //
    // Optional parameter.  If NULL, ProviderConfig must be set to a valid pointer
    // value.   If specified, indicates the provider to create an instance for.
    //
    WDFWMIPROVIDER Provider;

    //
    // Optional parameter.  If NULL, Provider must be set to a valid handle
    // value.  If specifeid, indicates the configuration for a provider to be
    // created and for this instance to be associated with.
    //
    PWDF_WMI_PROVIDER_CONFIG_V1_0 ProviderConfig;

    //
    // If the Provider is configured as read only and this field is set to TRUE,
    // the EvtWmiInstanceQueryInstance is ignored and WDF will blindly copy the
    // context associated with this instance (using RtlCopyMemory, with no locks
    // held) into the query buffer.
    //
    BOOLEAN UseContextForQuery;

    //
    // If TRUE, the instance will be registered as well as created.
    //
    BOOLEAN Register;

    //
    // Callback when caller wants to query the entire data item's buffer.
    //
    PFN_WDF_WMI_INSTANCE_QUERY_INSTANCE EvtWmiInstanceQueryInstance;

    //
    // Callback when caller wants to set the entire data item's buffer.
    //
    PFN_WDF_WMI_INSTANCE_SET_INSTANCE EvtWmiInstanceSetInstance;

    //
    // Callback when caller wants to set a single field in the data item's buffer
    //
    PFN_WDF_WMI_INSTANCE_SET_ITEM EvtWmiInstanceSetItem;

    //
    // Callback when caller wants to execute a method on the data item.
    //
    PFN_WDF_WMI_INSTANCE_EXECUTE_METHOD EvtWmiInstanceExecuteMethod;

} WDF_WMI_INSTANCE_CONFIG_V1_0, *PWDF_WMI_INSTANCE_CONFIG_V1_0;

// End of versioning of structures for wdfWMI.h

//
// Versioning of structures for wdfworkitem.h
//
typedef struct _WDF_WORKITEM_CONFIG_V1_0 {
    ULONG            Size;

    PFN_WDF_WORKITEM EvtWorkItemFunc;

    //
    // If this is TRUE, the workitem will automatically serialize
    // with the event callback handlers of its Parent Object.
    //
    // Parent Object's callback constraints should be compatible
    // with the work item (PASSIVE_LEVEL), or the request will fail.
    //
    BOOLEAN       AutomaticSerialization;

} WDF_WORKITEM_CONFIG_V1_0, *PWDF_WORKITEM_CONFIG_V1_0;

// End of versioning of structures for wdfworkitem.h


#endif // _WDF_V1_0_TYPES_H_
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\win2k8\ddk\inc\wdf\kmdf\1.7\wdf15.h ===
#ifndef _WDF_V1_5_TYPES_H_
#define _WDF_V1_5_TYPES_H_


typedef enum _WDFFUNCENUM_V1_5 {
    WdfFunctionTableNumEntries_V1_5 = 387,
} WDFFUNCENUM_V1_5;

typedef struct _WDF_POWER_ROUTINE_TIMED_OUT_DATA_V1_5 *PWDF_POWER_ROUTINE_TIMED_OUT_DATA_V1_5;
typedef const struct _WDF_POWER_ROUTINE_TIMED_OUT_DATA_V1_5 *PCWDF_POWER_ROUTINE_TIMED_OUT_DATA_V1_5;
typedef struct _WDF_REQUEST_FATAL_ERROR_INFORMATION_LENGTH_MISMATCH_DATA_V1_5 *PWDF_REQUEST_FATAL_ERROR_INFORMATION_LENGTH_MISMATCH_DATA_V1_5;
typedef const struct _WDF_REQUEST_FATAL_ERROR_INFORMATION_LENGTH_MISMATCH_DATA_V1_5 *PCWDF_REQUEST_FATAL_ERROR_INFORMATION_LENGTH_MISMATCH_DATA_V1_5;
typedef struct _WDF_QUEUE_FATAL_ERROR_DATA_V1_5 *PWDF_QUEUE_FATAL_ERROR_DATA_V1_5;
typedef const struct _WDF_QUEUE_FATAL_ERROR_DATA_V1_5 *PCWDF_QUEUE_FATAL_ERROR_DATA_V1_5;
typedef struct _WDF_CHILD_IDENTIFICATION_DESCRIPTION_HEADER_V1_5 *PWDF_CHILD_IDENTIFICATION_DESCRIPTION_HEADER_V1_5;
typedef const struct _WDF_CHILD_IDENTIFICATION_DESCRIPTION_HEADER_V1_5 *PCWDF_CHILD_IDENTIFICATION_DESCRIPTION_HEADER_V1_5;
typedef struct _WDF_CHILD_ADDRESS_DESCRIPTION_HEADER_V1_5 *PWDF_CHILD_ADDRESS_DESCRIPTION_HEADER_V1_5;
typedef const struct _WDF_CHILD_ADDRESS_DESCRIPTION_HEADER_V1_5 *PCWDF_CHILD_ADDRESS_DESCRIPTION_HEADER_V1_5;
typedef struct _WDF_CHILD_RETRIEVE_INFO_V1_5 *PWDF_CHILD_RETRIEVE_INFO_V1_5;
typedef const struct _WDF_CHILD_RETRIEVE_INFO_V1_5 *PCWDF_CHILD_RETRIEVE_INFO_V1_5;
typedef struct _WDF_CHILD_LIST_CONFIG_V1_5 *PWDF_CHILD_LIST_CONFIG_V1_5;
typedef const struct _WDF_CHILD_LIST_CONFIG_V1_5 *PCWDF_CHILD_LIST_CONFIG_V1_5;
typedef struct _WDF_CHILD_LIST_ITERATOR_V1_5 *PWDF_CHILD_LIST_ITERATOR_V1_5;
typedef const struct _WDF_CHILD_LIST_ITERATOR_V1_5 *PCWDF_CHILD_LIST_ITERATOR_V1_5;
typedef struct _WDF_CLASS_EXTENSION_DESCRIPTOR_V1_5 *PWDF_CLASS_EXTENSION_DESCRIPTOR_V1_5;
typedef const struct _WDF_CLASS_EXTENSION_DESCRIPTOR_V1_5 *PCWDF_CLASS_EXTENSION_DESCRIPTOR_V1_5;
typedef struct _WDF_COMMON_BUFFER_CONFIG_V1_5 *PWDF_COMMON_BUFFER_CONFIG_V1_5;
typedef const struct _WDF_COMMON_BUFFER_CONFIG_V1_5 *PCWDF_COMMON_BUFFER_CONFIG_V1_5;
typedef struct _WDF_FILEOBJECT_CONFIG_V1_5 *PWDF_FILEOBJECT_CONFIG_V1_5;
typedef const struct _WDF_FILEOBJECT_CONFIG_V1_5 *PCWDF_FILEOBJECT_CONFIG_V1_5;
typedef struct _WDF_DEVICE_PNP_NOTIFICATION_DATA_V1_5 *PWDF_DEVICE_PNP_NOTIFICATION_DATA_V1_5;
typedef const struct _WDF_DEVICE_PNP_NOTIFICATION_DATA_V1_5 *PCWDF_DEVICE_PNP_NOTIFICATION_DATA_V1_5;
typedef struct _WDF_DEVICE_POWER_NOTIFICATION_DATA_V1_5 *PWDF_DEVICE_POWER_NOTIFICATION_DATA_V1_5;
typedef const struct _WDF_DEVICE_POWER_NOTIFICATION_DATA_V1_5 *PCWDF_DEVICE_POWER_NOTIFICATION_DATA_V1_5;
typedef struct _WDF_DEVICE_POWER_POLICY_NOTIFICATION_DATA_V1_5 *PWDF_DEVICE_POWER_POLICY_NOTIFICATION_DATA_V1_5;
typedef const struct _WDF_DEVICE_POWER_POLICY_NOTIFICATION_DATA_V1_5 *PCWDF_DEVICE_POWER_POLICY_NOTIFICATION_DATA_V1_5;
typedef struct _WDF_PNPPOWER_EVENT_CALLBACKS_V1_5 *PWDF_PNPPOWER_EVENT_CALLBACKS_V1_5;
typedef const struct _WDF_PNPPOWER_EVENT_CALLBACKS_V1_5 *PCWDF_PNPPOWER_EVENT_CALLBACKS_V1_5;
typedef struct _WDF_POWER_POLICY_EVENT_CALLBACKS_V1_5 *PWDF_POWER_POLICY_EVENT_CALLBACKS_V1_5;
typedef const struct _WDF_POWER_POLICY_EVENT_CALLBACKS_V1_5 *PCWDF_POWER_POLICY_EVENT_CALLBACKS_V1_5;
typedef struct _WDF_DEVICE_POWER_POLICY_IDLE_SETTINGS_V1_5 *PWDF_DEVICE_POWER_POLICY_IDLE_SETTINGS_V1_5;
typedef const struct _WDF_DEVICE_POWER_POLICY_IDLE_SETTINGS_V1_5 *PCWDF_DEVICE_POWER_POLICY_IDLE_SETTINGS_V1_5;
typedef struct _WDF_DEVICE_POWER_POLICY_WAKE_SETTINGS_V1_5 *PWDF_DEVICE_POWER_POLICY_WAKE_SETTINGS_V1_5;
typedef const struct _WDF_DEVICE_POWER_POLICY_WAKE_SETTINGS_V1_5 *PCWDF_DEVICE_POWER_POLICY_WAKE_SETTINGS_V1_5;
typedef struct _WDF_DEVICE_STATE_V1_5 *PWDF_DEVICE_STATE_V1_5;
typedef const struct _WDF_DEVICE_STATE_V1_5 *PCWDF_DEVICE_STATE_V1_5;
typedef struct _WDF_DEVICE_PNP_CAPABILITIES_V1_5 *PWDF_DEVICE_PNP_CAPABILITIES_V1_5;
typedef const struct _WDF_DEVICE_PNP_CAPABILITIES_V1_5 *PCWDF_DEVICE_PNP_CAPABILITIES_V1_5;
typedef struct _WDF_DEVICE_POWER_CAPABILITIES_V1_5 *PWDF_DEVICE_POWER_CAPABILITIES_V1_5;
typedef const struct _WDF_DEVICE_POWER_CAPABILITIES_V1_5 *PCWDF_DEVICE_POWER_CAPABILITIES_V1_5;
typedef struct _WDF_DMA_ENABLER_CONFIG_V1_5 *PWDF_DMA_ENABLER_CONFIG_V1_5;
typedef const struct _WDF_DMA_ENABLER_CONFIG_V1_5 *PCWDF_DMA_ENABLER_CONFIG_V1_5;
typedef struct _WDF_DPC_CONFIG_V1_5 *PWDF_DPC_CONFIG_V1_5;
typedef const struct _WDF_DPC_CONFIG_V1_5 *PCWDF_DPC_CONFIG_V1_5;
typedef struct _WDF_DRIVER_CONFIG_V1_5 *PWDF_DRIVER_CONFIG_V1_5;
typedef const struct _WDF_DRIVER_CONFIG_V1_5 *PCWDF_DRIVER_CONFIG_V1_5;
typedef struct _WDF_DRIVER_VERSION_AVAILABLE_PARAMS_V1_5 *PWDF_DRIVER_VERSION_AVAILABLE_PARAMS_V1_5;
typedef const struct _WDF_DRIVER_VERSION_AVAILABLE_PARAMS_V1_5 *PCWDF_DRIVER_VERSION_AVAILABLE_PARAMS_V1_5;
typedef struct _WDF_FDO_EVENT_CALLBACKS_V1_5 *PWDF_FDO_EVENT_CALLBACKS_V1_5;
typedef const struct _WDF_FDO_EVENT_CALLBACKS_V1_5 *PCWDF_FDO_EVENT_CALLBACKS_V1_5;
typedef struct _WDF_DRIVER_GLOBALS_V1_5 *PWDF_DRIVER_GLOBALS_V1_5;
typedef const struct _WDF_DRIVER_GLOBALS_V1_5 *PCWDF_DRIVER_GLOBALS_V1_5;
typedef struct _WDF_INTERRUPT_CONFIG_V1_5 *PWDF_INTERRUPT_CONFIG_V1_5;
typedef const struct _WDF_INTERRUPT_CONFIG_V1_5 *PCWDF_INTERRUPT_CONFIG_V1_5;
typedef struct _WDF_INTERRUPT_INFO_V1_5 *PWDF_INTERRUPT_INFO_V1_5;
typedef const struct _WDF_INTERRUPT_INFO_V1_5 *PCWDF_INTERRUPT_INFO_V1_5;
typedef struct _WDF_IO_QUEUE_CONFIG_V1_5 *PWDF_IO_QUEUE_CONFIG_V1_5;
typedef const struct _WDF_IO_QUEUE_CONFIG_V1_5 *PCWDF_IO_QUEUE_CONFIG_V1_5;
typedef struct _WDF_IO_TARGET_OPEN_PARAMS_V1_5 *PWDF_IO_TARGET_OPEN_PARAMS_V1_5;
typedef const struct _WDF_IO_TARGET_OPEN_PARAMS_V1_5 *PCWDF_IO_TARGET_OPEN_PARAMS_V1_5;
typedef struct _WDFMEMORY_OFFSET_V1_5 *PWDFMEMORY_OFFSET_V1_5;
typedef const struct _WDFMEMORY_OFFSET_V1_5 *PCWDFMEMORY_OFFSET_V1_5;
typedef struct _WDF_MEMORY_DESCRIPTOR_V1_5 *PWDF_MEMORY_DESCRIPTOR_V1_5;
typedef const struct _WDF_MEMORY_DESCRIPTOR_V1_5 *PCWDF_MEMORY_DESCRIPTOR_V1_5;
typedef struct _WDF_OBJECT_ATTRIBUTES_V1_5 *PWDF_OBJECT_ATTRIBUTES_V1_5;
typedef const struct _WDF_OBJECT_ATTRIBUTES_V1_5 *PCWDF_OBJECT_ATTRIBUTES_V1_5;
typedef struct _WDF_OBJECT_CONTEXT_TYPE_INFO_V1_5 *PWDF_OBJECT_CONTEXT_TYPE_INFO_V1_5;
typedef const struct _WDF_OBJECT_CONTEXT_TYPE_INFO_V1_5 *PCWDF_OBJECT_CONTEXT_TYPE_INFO_V1_5;
typedef struct _WDF_PDO_EVENT_CALLBACKS_V1_5 *PWDF_PDO_EVENT_CALLBACKS_V1_5;
typedef const struct _WDF_PDO_EVENT_CALLBACKS_V1_5 *PCWDF_PDO_EVENT_CALLBACKS_V1_5;
typedef struct _WDF_QUERY_INTERFACE_CONFIG_V1_5 *PWDF_QUERY_INTERFACE_CONFIG_V1_5;
typedef const struct _WDF_QUERY_INTERFACE_CONFIG_V1_5 *PCWDF_QUERY_INTERFACE_CONFIG_V1_5;
typedef struct _WDF_REQUEST_PARAMETERS_V1_5 *PWDF_REQUEST_PARAMETERS_V1_5;
typedef const struct _WDF_REQUEST_PARAMETERS_V1_5 *PCWDF_REQUEST_PARAMETERS_V1_5;
typedef struct _WDF_REQUEST_COMPLETION_PARAMS_V1_5 *PWDF_REQUEST_COMPLETION_PARAMS_V1_5;
typedef const struct _WDF_REQUEST_COMPLETION_PARAMS_V1_5 *PCWDF_REQUEST_COMPLETION_PARAMS_V1_5;
typedef struct _WDF_REQUEST_REUSE_PARAMS_V1_5 *PWDF_REQUEST_REUSE_PARAMS_V1_5;
typedef const struct _WDF_REQUEST_REUSE_PARAMS_V1_5 *PCWDF_REQUEST_REUSE_PARAMS_V1_5;
typedef struct _WDF_REQUEST_SEND_OPTIONS_V1_5 *PWDF_REQUEST_SEND_OPTIONS_V1_5;
typedef const struct _WDF_REQUEST_SEND_OPTIONS_V1_5 *PCWDF_REQUEST_SEND_OPTIONS_V1_5;
typedef struct _WDF_TIMER_CONFIG_V1_5 *PWDF_TIMER_CONFIG_V1_5;
typedef const struct _WDF_TIMER_CONFIG_V1_5 *PCWDF_TIMER_CONFIG_V1_5;
typedef struct _WDF_USB_REQUEST_COMPLETION_PARAMS_V1_5 *PWDF_USB_REQUEST_COMPLETION_PARAMS_V1_5;
typedef const struct _WDF_USB_REQUEST_COMPLETION_PARAMS_V1_5 *PCWDF_USB_REQUEST_COMPLETION_PARAMS_V1_5;
typedef struct _WDF_USB_CONTINUOUS_READER_CONFIG_V1_5 *PWDF_USB_CONTINUOUS_READER_CONFIG_V1_5;
typedef const struct _WDF_USB_CONTINUOUS_READER_CONFIG_V1_5 *PCWDF_USB_CONTINUOUS_READER_CONFIG_V1_5;
typedef struct _WDF_USB_DEVICE_INFORMATION_V1_5 *PWDF_USB_DEVICE_INFORMATION_V1_5;
typedef const struct _WDF_USB_DEVICE_INFORMATION_V1_5 *PCWDF_USB_DEVICE_INFORMATION_V1_5;
typedef struct _WDF_USB_INTERFACE_SETTING_PAIR_V1_5 *PWDF_USB_INTERFACE_SETTING_PAIR_V1_5;
typedef const struct _WDF_USB_INTERFACE_SETTING_PAIR_V1_5 *PCWDF_USB_INTERFACE_SETTING_PAIR_V1_5;
typedef struct _WDF_USB_DEVICE_SELECT_CONFIG_PARAMS_V1_5 *PWDF_USB_DEVICE_SELECT_CONFIG_PARAMS_V1_5;
typedef const struct _WDF_USB_DEVICE_SELECT_CONFIG_PARAMS_V1_5 *PCWDF_USB_DEVICE_SELECT_CONFIG_PARAMS_V1_5;
typedef struct _WDF_USB_INTERFACE_SELECT_SETTING_PARAMS_V1_5 *PWDF_USB_INTERFACE_SELECT_SETTING_PARAMS_V1_5;
typedef const struct _WDF_USB_INTERFACE_SELECT_SETTING_PARAMS_V1_5 *PCWDF_USB_INTERFACE_SELECT_SETTING_PARAMS_V1_5;
typedef struct _WDF_USB_PIPE_INFORMATION_V1_5 *PWDF_USB_PIPE_INFORMATION_V1_5;
typedef const struct _WDF_USB_PIPE_INFORMATION_V1_5 *PCWDF_USB_PIPE_INFORMATION_V1_5;
typedef struct _WDF_WMI_PROVIDER_CONFIG_V1_5 *PWDF_WMI_PROVIDER_CONFIG_V1_5;
typedef const struct _WDF_WMI_PROVIDER_CONFIG_V1_5 *PCWDF_WMI_PROVIDER_CONFIG_V1_5;
typedef struct _WDF_WMI_INSTANCE_CONFIG_V1_5 *PWDF_WMI_INSTANCE_CONFIG_V1_5;
typedef const struct _WDF_WMI_INSTANCE_CONFIG_V1_5 *PCWDF_WMI_INSTANCE_CONFIG_V1_5;
typedef struct _WDF_WORKITEM_CONFIG_V1_5 *PWDF_WORKITEM_CONFIG_V1_5;
typedef const struct _WDF_WORKITEM_CONFIG_V1_5 *PCWDF_WORKITEM_CONFIG_V1_5;

//
// Versioning of structures for wdf.h
//
// End of versioning of structures for wdf.h

//
// Versioning of structures for wdfassert.h
//
// End of versioning of structures for wdfassert.h

//
// Versioning of structures for wdfbugcodes.h
//
typedef struct _WDF_POWER_ROUTINE_TIMED_OUT_DATA_V1_5 {
    // 
    // Current power state associated with the timed out device
    // 
    WDF_DEVICE_POWER_STATE PowerState;

    // 
    // Current power policy state associated with the timed out device
    // 
    WDF_DEVICE_POWER_POLICY_STATE PowerPolicyState;

    // 
    // The device object for the timed out device
    // 
    PDEVICE_OBJECT DeviceObject;

    // 
    // The handle for the timed out device
    // 
    WDFDEVICE Device;

    // 
    // The thread which is stuck
    // 
    PKTHREAD TimedOutThread;

} WDF_POWER_ROUTINE_TIMED_OUT_DATA_V1_5;

typedef struct _WDF_REQUEST_FATAL_ERROR_INFORMATION_LENGTH_MISMATCH_DATA_V1_5 {
    WDFREQUEST Request;

    PIRP Irp;

    ULONG OutputBufferLength;

    ULONG_PTR Information;

    UCHAR MajorFunction;

} WDF_REQUEST_FATAL_ERROR_INFORMATION_LENGTH_MISMATCH_DATA_V1_5, *PWDF_REQUEST_FATAL_ERROR_INFORMATION_LENGTH_MISMATCH_DATA_V1_5;

typedef struct _WDF_QUEUE_FATAL_ERROR_DATA_V1_5 {
    WDFQUEUE Queue;

    WDFREQUEST Request;

    NTSTATUS Status;

} WDF_QUEUE_FATAL_ERROR_DATA_V1_5, *PWDF_QUEUE_FATAL_ERROR_DATA_V1_5;

// End of versioning of structures for wdfbugcodes.h

//
// Versioning of structures for wdfchildlist.h
//
typedef struct _WDF_CHILD_IDENTIFICATION_DESCRIPTION_HEADER_V1_5 {
    // 
    // Size in bytes of the entire description, including this header.
    // 
    // Same value as WDF_CHILD_LIST_CONFIG::IdentificationDescriptionSize
    // Used as a sanity check.
    // 
    ULONG IdentificationDescriptionSize;

} WDF_CHILD_IDENTIFICATION_DESCRIPTION_HEADER_V1_5, *PWDF_CHILD_IDENTIFICATION_DESCRIPTION_HEADER_V1_5;

typedef struct _WDF_CHILD_ADDRESS_DESCRIPTION_HEADER_V1_5 {
    // 
    // Size in bytes of the entire description, including this header.
    // 
    // Same value as WDF_CHILD_LIST_CONFIG::AddressDescriptionSize
    // Used as a sanity check.
    // 
    ULONG AddressDescriptionSize;

} WDF_CHILD_ADDRESS_DESCRIPTION_HEADER_V1_5, *PWDF_CHILD_ADDRESS_DESCRIPTION_HEADER_V1_5;

typedef struct _WDF_CHILD_RETRIEVE_INFO_V1_5 {
    // 
    // Size of the structure in bytes
    // 
    ULONG Size;

    // 
    // Must be a valid pointer when passed in, copied into upon success
    // 
    PWDF_CHILD_IDENTIFICATION_DESCRIPTION_HEADER_V1_5 IdentificationDescription;

    // 
    // Optional pointer when passed in, copied into upon success
    // 
    PWDF_CHILD_ADDRESS_DESCRIPTION_HEADER_V1_5 AddressDescription;

    // 
    // Status of the returned device
    // 
    WDF_CHILD_LIST_RETRIEVE_DEVICE_STATUS Status;

    // 
    // If provided, will be used for searching through the list of devices
    // instead of the default list ID compare function
    // 
    PFN_WDF_CHILD_LIST_IDENTIFICATION_DESCRIPTION_COMPARE EvtChildListIdentificationDescriptionCompare;

} WDF_CHILD_RETRIEVE_INFO_V1_5, *PWDF_CHILD_RETRIEVE_INFO_V1_5;

typedef struct _WDF_CHILD_LIST_CONFIG_V1_5 {
    // 
    // Size of this structure in bytes
    // 
    ULONG Size;

    // 
    // The size in bytes of an identificaiton description to be used with the
    // created WDFCHILDLIST handle
    // 
    ULONG IdentificationDescriptionSize;

    // 
    // Optional size in bytes of an address description to be used with the
    // created WDFCHILDLIST handle.
    // 
    ULONG AddressDescriptionSize;

    // 
    // Required callback to be invoked when a description on the device list
    // needs to be converted into a real WDFDEVICE handle.
    // 
    PFN_WDF_CHILD_LIST_CREATE_DEVICE EvtChildListCreateDevice;

    // 
    // Optional callback to be invoked when the device list needs to be
    // rescanned.  This function will be called after the device has entered D0
    // and been fully initialized but before I/O has started.
    // 
    PFN_WDF_CHILD_LIST_SCAN_FOR_CHILDREN EvtChildListScanForChildren;

    // 
    // Optional callback to be invoked when an identification description needs
    // to be copied from one location to another.
    // 
    // If left NULL, RtlCopyMemory will be used to copy the description.
    // 
    PFN_WDF_CHILD_LIST_IDENTIFICATION_DESCRIPTION_COPY EvtChildListIdentificationDescriptionCopy;

    // 
    // Optional callback to be invoked when an identification description needs
    // to be duplicated.  As opposed to EvtChildListIdentificationDescriptionCopy,
    // EvtChildListIdentificationDescriptionDuplicate can fail.
    // 
    PFN_WDF_CHILD_LIST_IDENTIFICATION_DESCRIPTION_DUPLICATE EvtChildListIdentificationDescriptionDuplicate;

    // 
    // Optional callback to be invoked when an identification description needs
    // to be cleaned up.  This function should *NOT* free the description passed
    // to it, just free any associated resources.
    // 
    PFN_WDF_CHILD_LIST_IDENTIFICATION_DESCRIPTION_CLEANUP EvtChildListIdentificationDescriptionCleanup;

    // 
    // Optional callback to be invoked when an identification description needs
    // to be compared with another identificaiton description.
    // 
    // If left NULL, RtlCompareMemory will be used to compare the two
    // descriptions.
    // 
    PFN_WDF_CHILD_LIST_IDENTIFICATION_DESCRIPTION_COMPARE EvtChildListIdentificationDescriptionCompare;

    // 
    // Optional callback to be invoked when an address description needs
    // to be copied from one location to another.
    // 
    // If left NULL, RtlCopyMemory will be used to copy the description.
    // 
    PFN_WDF_CHILD_LIST_ADDRESS_DESCRIPTION_COPY EvtChildListAddressDescriptionCopy;

    // 
    // Optional callback to be invoked when an address description needs to be
    // duplicated.  As opposed to EvtChildListAddressDescriptionCopy,
    // EvtChildListAddressDescriptionDuplicate can fail.
    // 
    PFN_WDF_CHILD_LIST_ADDRESS_DESCRIPTION_DUPLICATE EvtChildListAddressDescriptionDuplicate;

    // 
    // Optional callback to be invoked when an address description needs to be
    // cleaned up.  This function should *NOT* free the description passed to
    // it, just free any associated resources.
    // 
    PFN_WDF_CHILD_LIST_ADDRESS_DESCRIPTION_CLEANUP EvtChildListAddressDescriptionCleanup;

    // 
    // If provided, will be called when the child's stack requests that the
    // child be reenumerated.  Returning TRUE allows for the reenumeration to
    // proceed.  FALSE will no reenumerate the stack.
    // 
    PFN_WDF_CHILD_LIST_DEVICE_REENUMERATED EvtChildListDeviceReenumerated;

} WDF_CHILD_LIST_CONFIG_V1_5, *PWDF_CHILD_LIST_CONFIG_V1_5;

typedef struct _WDF_CHILD_LIST_ITERATOR_V1_5 {
    // 
    // Size of this structure in bytes
    // 
    ULONG Size;

    // 
    // What type of devices to return, see WDF_RETRIEVE_CHILD_FLAGS for
    // flag values
    // 
    // 
    ULONG Flags;

    // 
    // For internal use, treat this field as opaque
    // 
    PVOID Reserved[4];

} WDF_CHILD_LIST_ITERATOR_V1_5, *PWDF_CHILD_LIST_ITERATOR_V1_5;

// End of versioning of structures for wdfchildlist.h

//
// Versioning of structures for wdfClassExtension.h
//
typedef struct _WDF_CLASS_EXTENSION_DESCRIPTOR_V1_5 {
    PCWDF_CLASS_EXTENSION_DESCRIPTOR_V1_5   Next;

    ULONG                             Size;

    PFN_WDF_CLASS_EXTENSIONIN_BIND    Bind;

    PFN_WDF_CLASS_EXTENSIONIN_UNBIND  Unbind;

} WDF_CLASS_EXTENSION_DESCRIPTOR_V1_5, *PWDF_CLASS_EXTENSION_DESCRIPTOR_V1_5;

// End of versioning of structures for wdfClassExtension.h

//
// Versioning of structures for wdfClassExtensionList.h
//
// End of versioning of structures for wdfClassExtensionList.h

//
// Versioning of structures for wdfcollection.h
//
// End of versioning of structures for wdfcollection.h

//
// Versioning of structures for wdfCommonBuffer.h
//
typedef struct _WDF_COMMON_BUFFER_CONFIG_V1_5 {
    // 
    // Size of this structure in bytes
    // 
    ULONG   Size;

    // 
    // Alignment requirement of the buffer address
    // 
    ULONG   AlignmentRequirement;

} WDF_COMMON_BUFFER_CONFIG_V1_5, *PWDF_COMMON_BUFFER_CONFIG_V1_5;

// End of versioning of structures for wdfCommonBuffer.h

//
// Versioning of structures for wdfcontrol.h
//
// End of versioning of structures for wdfcontrol.h

//
// Versioning of structures for wdfcore.h
//
// End of versioning of structures for wdfcore.h

//
// Versioning of structures for wdfDevice.h
//
typedef struct _WDF_FILEOBJECT_CONFIG_V1_5 {
    // 
    // Size of this structure in bytes
    // 
    ULONG Size;

    // 
    // Event callback for create requests
    // 
    PFN_WDF_DEVICE_FILE_CREATE  EvtDeviceFileCreate;

    // 
    // Event callback for close requests
    // 
    PFN_WDF_FILE_CLOSE   EvtFileClose;

    // 
    // Event callback for cleanup requests
    // 
    PFN_WDF_FILE_CLEANUP EvtFileCleanup;

    // 
    // If WdfTrue, create/cleanup/close file object related requests will be
    // sent down the stack.
    // 
    // If WdfFalse, create/cleanup/close will be completed at this location in
    // the device stack.
    // 
    // If WdfDefault, behavior depends on device type
    // FDO, PDO, Control:  use the WdfFalse behavior
    // Filter:  use the WdfTrue behavior
    // 
    WDF_TRI_STATE AutoForwardCleanupClose;

    // 
    // Specify whether framework should create WDFFILEOBJECT and also
    // whether it can FsContexts fields in the WDM fileobject to store
    // WDFFILEOBJECT so that it can avoid table look up and improve perf.
    // 
    WDF_FILEOBJECT_CLASS FileObjectClass;

} WDF_FILEOBJECT_CONFIG_V1_5, *PWDF_FILEOBJECT_CONFIG_V1_5;

typedef struct _WDF_DEVICE_PNP_NOTIFICATION_DATA_V1_5 {
    // 
    // Type of data
    // 
    WDF_STATE_NOTIFICATION_TYPE Type;

    union {
        struct {
            // 
            // The current state that is about to be exited
            // 
            WDF_DEVICE_PNP_STATE CurrentState;

            // 
            // The new state that is about to be entered
            // 
            WDF_DEVICE_PNP_STATE NewState;

        } EnterState;

        struct {
            // 
            // The current state
            // 
            WDF_DEVICE_PNP_STATE CurrentState;

        } PostProcessState;

        struct {
            // 
            // The current state that is about to be exitted
            // 
            WDF_DEVICE_PNP_STATE CurrentState;

            // 
            // The state that is about to be entered
            // 
            WDF_DEVICE_PNP_STATE NewState;

        } LeaveState;

    } Data;

} WDF_DEVICE_PNP_NOTIFICATION_DATA_V1_5;

typedef struct _WDF_DEVICE_POWER_NOTIFICATION_DATA_V1_5 {
    // 
    // Type of data
    // 
    WDF_STATE_NOTIFICATION_TYPE Type;

    union {
        struct {
            // 
            // The current state that is about to be exitted
            // 
            WDF_DEVICE_POWER_STATE CurrentState;

            // 
            // The new state that is about to be entered
            // 
            WDF_DEVICE_POWER_STATE NewState;

        } EnterState;

        struct {
            // 
            // The current state
            // 
            WDF_DEVICE_POWER_STATE CurrentState;

        } PostProcessState;

        struct {
            // 
            // The current state that is about to be exitted
            // 
            WDF_DEVICE_POWER_STATE CurrentState;

            // 
            // The state that is about to be entered
            // 
            WDF_DEVICE_POWER_STATE NewState;

        } LeaveState;

    } Data;

} WDF_DEVICE_POWER_NOTIFICATION_DATA_V1_5;

typedef struct _WDF_DEVICE_POWER_POLICY_NOTIFICATION_DATA_V1_5 {
    // 
    // Type of data
    // 
    WDF_STATE_NOTIFICATION_TYPE Type;

    union {
        struct {
            // 
            // The current state that is about to be exitted
            // 
            WDF_DEVICE_POWER_POLICY_STATE CurrentState;

            // 
            // The new state that is about to be entered
            // 
            WDF_DEVICE_POWER_POLICY_STATE NewState;

        } EnterState;

        struct {
            // 
            // The current state
            // 
            WDF_DEVICE_POWER_POLICY_STATE CurrentState;

        } PostProcessState;

        struct {
            // 
            // The current state that is about to be exitted
            // 
            WDF_DEVICE_POWER_POLICY_STATE CurrentState;

            // 
            // The state that is about to be entered
            // 
            WDF_DEVICE_POWER_POLICY_STATE NewState;

        } LeaveState;

    } Data;

} WDF_DEVICE_POWER_POLICY_NOTIFICATION_DATA_V1_5;

typedef struct _WDF_PNPPOWER_EVENT_CALLBACKS_V1_5 {
    // 
    // Size of this structure in bytes
    // 
    ULONG Size;

    PFN_WDF_DEVICE_D0_ENTRY                 EvtDeviceD0Entry;

    PFN_WDF_DEVICE_D0_ENTRY_POST_INTERRUPTS_ENABLED EvtDeviceD0EntryPostInterruptsEnabled;

    PFN_WDF_DEVICE_D0_EXIT                  EvtDeviceD0Exit;

    PFN_WDF_DEVICE_D0_EXIT_PRE_INTERRUPTS_DISABLED EvtDeviceD0ExitPreInterruptsDisabled;

    PFN_WDF_DEVICE_PREPARE_HARDWARE         EvtDevicePrepareHardware;

    PFN_WDF_DEVICE_RELEASE_HARDWARE         EvtDeviceReleaseHardware;

    PFN_WDF_DEVICE_SELF_MANAGED_IO_CLEANUP  EvtDeviceSelfManagedIoCleanup;

    PFN_WDF_DEVICE_SELF_MANAGED_IO_FLUSH    EvtDeviceSelfManagedIoFlush;

    PFN_WDF_DEVICE_SELF_MANAGED_IO_INIT     EvtDeviceSelfManagedIoInit;

    PFN_WDF_DEVICE_SELF_MANAGED_IO_SUSPEND  EvtDeviceSelfManagedIoSuspend;

    PFN_WDF_DEVICE_SELF_MANAGED_IO_RESTART  EvtDeviceSelfManagedIoRestart;

    PFN_WDF_DEVICE_SURPRISE_REMOVAL         EvtDeviceSurpriseRemoval;

    PFN_WDF_DEVICE_QUERY_REMOVE             EvtDeviceQueryRemove;

    PFN_WDF_DEVICE_QUERY_STOP               EvtDeviceQueryStop;

    PFN_WDF_DEVICE_USAGE_NOTIFICATION       EvtDeviceUsageNotification;

    PFN_WDF_DEVICE_RELATIONS_QUERY          EvtDeviceRelationsQuery;

} WDF_PNPPOWER_EVENT_CALLBACKS_V1_5, *PWDF_PNPPOWER_EVENT_CALLBACKS_V1_5;

typedef struct _WDF_POWER_POLICY_EVENT_CALLBACKS_V1_5 {
    // 
    // Size of this structure in bytes
    // 
    ULONG Size;

    PFN_WDF_DEVICE_ARM_WAKE_FROM_S0         EvtDeviceArmWakeFromS0;

    PFN_WDF_DEVICE_DISARM_WAKE_FROM_S0      EvtDeviceDisarmWakeFromS0;

    PFN_WDF_DEVICE_WAKE_FROM_S0_TRIGGERED   EvtDeviceWakeFromS0Triggered;

    PFN_WDF_DEVICE_ARM_WAKE_FROM_SX         EvtDeviceArmWakeFromSx;

    PFN_WDF_DEVICE_DISARM_WAKE_FROM_SX      EvtDeviceDisarmWakeFromSx;

    PFN_WDF_DEVICE_WAKE_FROM_SX_TRIGGERED   EvtDeviceWakeFromSxTriggered;

} WDF_POWER_POLICY_EVENT_CALLBACKS_V1_5, *PWDF_POWER_POLICY_EVENT_CALLBACKS_V1_5;

typedef struct _WDF_DEVICE_POWER_POLICY_IDLE_SETTINGS_V1_5 {
    // 
    // Size of this structure in bytes
    // 
    ULONG Size;

    // 
    // Indicates whether the device can wake itself up while the machine is in
    // S0.
    // 
    WDF_POWER_POLICY_S0_IDLE_CAPABILITIES IdleCaps;

    // 
    // The low power state in which the device will be placed when it is idled
    // out while the machine is in S0.
    // 
    DEVICE_POWER_STATE DxState;

    // 
    // Amount of time the device must be idle before idling out.  Timeout is in
    // milliseconds.
    // 
    ULONG IdleTimeout;

    // 
    // Inidcates whether a user can control the idle policy of the device.
    // By default, a user is allowed to change the policy.
    // 
    WDF_POWER_POLICY_S0_IDLE_USER_CONTROL UserControlOfIdleSettings;

    // 
    // If WdfTrue, idling out while the machine is in S0 will be enabled.
    // 
    // If WdfFalse, idling out will be disabled.
    // 
    // If WdfUseDefault, the idling out will be enabled.  If
    // UserControlOfIdleSettings is set to IdleAllowUserControl, the user's
    // settings will override the default.
    // 
    WDF_TRI_STATE Enabled;

} WDF_DEVICE_POWER_POLICY_IDLE_SETTINGS_V1_5, *PWDF_DEVICE_POWER_POLICY_IDLE_SETTINGS_V1_5;

typedef struct _WDF_DEVICE_POWER_POLICY_WAKE_SETTINGS_V1_5 {
    // 
    // Size of this structure in bytes
    // 
    ULONG Size;

    // 
    // The low power state in which the device will be placed when it is armed
    // for wake from Sx.
    // 
    DEVICE_POWER_STATE DxState;

    // 
    // Inidcates whether a user can control the idle policy of the device.
    // By default, a user is allowed to change the policy.
    // 
    WDF_POWER_POLICY_SX_WAKE_USER_CONTROL UserControlOfWakeSettings;

    // 
    // If WdfTrue, arming the device for wake while the machine is in Sx is
    // enabled.
    // 
    // If WdfFalse, arming the device for wake while the machine is in Sx is
    // disabled.
    // 
    // If WdfUseDefault, arming will be enabled.  If UserControlOfWakeSettings
    // is set to WakeAllowUserControl, the user's settings will override the
    // default.
    // 
    WDF_TRI_STATE Enabled;

} WDF_DEVICE_POWER_POLICY_WAKE_SETTINGS_V1_5, *PWDF_DEVICE_POWER_POLICY_WAKE_SETTINGS_V1_5;

typedef struct _WDF_DEVICE_STATE_V1_5 {
    // 
    // Size of this structure in bytes
    // 
    ULONG Size;

    // 
    // If set to WdfTrue, the device will be disabled
    // 
    WDF_TRI_STATE Disabled;

    // 
    // If set to WdfTrue, the device will not be displayed in device manager.
    // Once hidden, the device cannot be unhidden.
    // 
    WDF_TRI_STATE DontDisplayInUI;

    // 
    // If set to WdfTrue, the device is reporting itself as failed.  If set
    // in conjuction with ResourcesChanged to WdfTrue, the device will receive
    // a PnP stop and then a new PnP start device.
    // 
    WDF_TRI_STATE Failed;

    // 
    // If set to WdfTrue, the device cannot be subsequently disabled.
    // 
    WDF_TRI_STATE NotDisableable;

    //
    // 
    // If set to WdfTrue, the device stack will be torn down.
    // 
    WDF_TRI_STATE Removed;

    // 
    // If set to WdfTrue, the device will be sent another PnP start.  If the
    // Failed field is set to WdfTrue as well, a PnP stop will be sent before
    // the start.
    // 
    WDF_TRI_STATE ResourcesChanged;

} WDF_DEVICE_STATE_V1_5, *PWDF_DEVICE_STATE_V1_5;

typedef struct _WDF_DEVICE_PNP_CAPABILITIES_V1_5 {
    // 
    // Size of the structure in bytes
    // 
    ULONG Size;

    // 
    // NOTE: To mark a PDO as raw, call WdfPdoInitAssignRawDevice
    // 
    //
    WDF_TRI_STATE LockSupported;

    WDF_TRI_STATE EjectSupported;

    WDF_TRI_STATE Removable;

    WDF_TRI_STATE DockDevice;

    WDF_TRI_STATE UniqueID;

    WDF_TRI_STATE SilentInstall;

    WDF_TRI_STATE SurpriseRemovalOK;

    WDF_TRI_STATE HardwareDisabled;

    WDF_TRI_STATE NoDisplayInUI;

    // 
    // Default values of -1 indicate not to set this value
    // 
    ULONG Address;

    ULONG UINumber;

} WDF_DEVICE_PNP_CAPABILITIES_V1_5, *PWDF_DEVICE_PNP_CAPABILITIES_V1_5;

typedef struct _WDF_DEVICE_POWER_CAPABILITIES_V1_5 {
    // 
    // Size of the structure in bytes
    // 
    ULONG Size;

    WDF_TRI_STATE DeviceD1;

    WDF_TRI_STATE DeviceD2;

    WDF_TRI_STATE WakeFromD0;

    WDF_TRI_STATE WakeFromD1;

    WDF_TRI_STATE WakeFromD2;

    WDF_TRI_STATE WakeFromD3;

    // 
    // Default value PowerDeviceMaximum indicates not to set this value
    // 
    DEVICE_POWER_STATE DeviceState[PowerSystemMaximum];

    // 
    // Default value PowerDeviceMaximum, PowerSystemMaximum indicates not to
    // set this value.
    // 
    DEVICE_POWER_STATE DeviceWake;

    SYSTEM_POWER_STATE SystemWake;

    // 
    // Default values of -1 indicate not to set this value
    // 
    ULONG D1Latency;

    ULONG D2Latency;

    ULONG D3Latency;

    // 
    // Ideal Dx state for the device to be put into when the machine moves into
    // Sx and the device is not armed for wake.  By default, the default will be
    // placed into D3.  If IdealDxStateForSx is lighter then
    // DeviceState[Sx], then DeviceState[Sx] will be used as the Dx state.
    // 
    DEVICE_POWER_STATE IdealDxStateForSx;

} WDF_DEVICE_POWER_CAPABILITIES_V1_5, *PWDF_DEVICE_POWER_CAPABILITIES_V1_5;

// End of versioning of structures for wdfDevice.h

//
// Versioning of structures for wdfDmaEnabler.h
//
typedef struct _WDF_DMA_ENABLER_CONFIG_V1_5 {
    // 
    // Size of this structure in bytes
    // 
    ULONG                Size;

    // 
    // One of the above WDF_DMA_PROFILES
    // 
    WDF_DMA_PROFILE      Profile;

    // 
    // Maximum DMA Transfer handled in bytes.
    // 
    size_t               MaximumLength;

    // 
    // The various DMA PnP/Power event callbacks
    // 
    PFN_WDF_DMA_ENABLER_FILL                  EvtDmaEnablerFill;

    PFN_WDF_DMA_ENABLER_FLUSH                 EvtDmaEnablerFlush;

    PFN_WDF_DMA_ENABLER_DISABLE               EvtDmaEnablerDisable;

    PFN_WDF_DMA_ENABLER_ENABLE                EvtDmaEnablerEnable;

    PFN_WDF_DMA_ENABLER_SELFMANAGED_IO_START  EvtDmaEnablerSelfManagedIoStart;

    PFN_WDF_DMA_ENABLER_SELFMANAGED_IO_STOP   EvtDmaEnablerSelfManagedIoStop;

} WDF_DMA_ENABLER_CONFIG_V1_5, *PWDF_DMA_ENABLER_CONFIG_V1_5;

// End of versioning of structures for wdfDmaEnabler.h

//
// Versioning of structures for wdfDmaTransaction.h
//
// End of versioning of structures for wdfDmaTransaction.h

//
// Versioning of structures for wdfdpc.h
//
typedef struct _WDF_DPC_CONFIG_V1_5 {
    ULONG       Size;

    PFN_WDF_DPC EvtDpcFunc;

    // 
    // If this is TRUE, the DPC will automatically serialize
    // with the event callback handlers of its Parent Object.
    // 
    // Parent Object's callback constraints should be compatible
    // with the DPC (DISPATCH_LEVEL), or the request will fail.
    // 
    BOOLEAN     AutomaticSerialization;

} WDF_DPC_CONFIG_V1_5, *PWDF_DPC_CONFIG_V1_5;

// End of versioning of structures for wdfdpc.h

//
// Versioning of structures for wdfdriver.h
//
typedef struct _WDF_DRIVER_CONFIG_V1_5 {
    // 
    // Size of this structure in bytes
    // 
    ULONG Size;

    // 
    // Event callbacks
    // 
    PFN_WDF_DRIVER_DEVICE_ADD EvtDriverDeviceAdd;

    PFN_WDF_DRIVER_UNLOAD    EvtDriverUnload;

    // 
    // Combination of WDF_DRIVER_INIT_FLAGS values
    // 
    ULONG DriverInitFlags;

    // 
    // Pool tag to use for all allocations made by the framework on behalf of
    // the client driver.
    // 
    ULONG DriverPoolTag;

} WDF_DRIVER_CONFIG_V1_5, *PWDF_DRIVER_CONFIG_V1_5;

typedef struct _WDF_DRIVER_VERSION_AVAILABLE_PARAMS_V1_5 {
    // 
    // Size of the structure in bytes
    // 
    ULONG Size;

    // 
    // Major Version requested
    // 
    ULONG MajorVersion;

    // 
    // Minor Version requested
    // 
    ULONG MinorVersion;

} WDF_DRIVER_VERSION_AVAILABLE_PARAMS_V1_5, *PWDF_DRIVER_VERSION_AVAILABLE_PARAMS_V1_5;

// End of versioning of structures for wdfdriver.h

//
// Versioning of structures for wdffdo.h
//
typedef struct _WDF_FDO_EVENT_CALLBACKS_V1_5 {
    // 
    // Size of this structure in bytes
    // 
    ULONG Size;

    PFN_WDF_DEVICE_FILTER_RESOURCE_REQUIREMENTS EvtDeviceFilterAddResourceRequirements;

    PFN_WDF_DEVICE_FILTER_RESOURCE_REQUIREMENTS EvtDeviceFilterRemoveResourceRequirements;

    PFN_WDF_DEVICE_REMOVE_ADDED_RESOURCES EvtDeviceRemoveAddedResources;

} WDF_FDO_EVENT_CALLBACKS_V1_5, *PWDF_FDO_EVENT_CALLBACKS_V1_5;

// End of versioning of structures for wdffdo.h

//
// Versioning of structures for wdffileobject.h
//
// End of versioning of structures for wdffileobject.h

//
// Versioning of structures for wdfGlobals.h
//
typedef struct _WDF_DRIVER_GLOBALS_V1_5 {
    // backpointer to the handle for this driver
    WDFDRIVER Driver;

    // Flags indicated by the driver during create
    ULONG DriverFlags;

    // Tag generated by WDF for the driver.  Tag used by allocations made on
    // behalf of the driver by WDF.
    ULONG DriverTag;

    CHAR DriverName[WDF_DRIVER_GLOBALS_NAME_LEN];

    // If TRUE, the stub code will capture DriverObject->DriverUnload and insert
    // itself first in the unload chain.  If FALSE, DriverUnload is left alone
    // (but WDF will not be notified of unload and there will be no auto cleanup).
    BOOLEAN DisplaceDriverUnload;

} WDF_DRIVER_GLOBALS_V1_5, *PWDF_DRIVER_GLOBALS_V1_5;

// End of versioning of structures for wdfGlobals.h

//
// Versioning of structures for wdfinstaller.h
//
// End of versioning of structures for wdfinstaller.h

//
// Versioning of structures for wdfinterrupt.h
//
// 
// Interrupt Configuration Structure
// 
typedef struct _WDF_INTERRUPT_CONFIG_V1_5 {
    ULONG              Size;

    // 
    // If this interrupt is to be synchronized with other interrupt(s) assigned
    // to the same WDFDEVICE, create a WDFSPINLOCK and assign it to each of the
    // WDFINTERRUPTs config.
    // 
    WDFSPINLOCK        SpinLock;

    WDF_TRI_STATE      ShareVector;

    BOOLEAN            FloatingSave;

    // 
    // Automatic Serialization of the DpcForIsr
    // 
    BOOLEAN            AutomaticSerialization;

    // Event Callbacks
    PFN_WDF_INTERRUPT_ISR         EvtInterruptIsr;

    PFN_WDF_INTERRUPT_DPC         EvtInterruptDpc;

    PFN_WDF_INTERRUPT_ENABLE      EvtInterruptEnable;

    PFN_WDF_INTERRUPT_DISABLE     EvtInterruptDisable;

} WDF_INTERRUPT_CONFIG_V1_5, *PWDF_INTERRUPT_CONFIG_V1_5;

typedef struct _WDF_INTERRUPT_INFO_V1_5 {
    // 
    // Size of this structure in bytes
    // 
    ULONG                  Size;

    ULONG64                Reserved1;

    KAFFINITY              TargetProcessorSet;

    ULONG                  Reserved2;

    ULONG                  MessageNumber;

    ULONG                  Vector;

    KIRQL                  Irql;

    KINTERRUPT_MODE        Mode;

    WDF_INTERRUPT_POLARITY Polarity;

    BOOLEAN                MessageSignaled;

    // CM_SHARE_DISPOSITION
    UCHAR                  ShareDisposition;

} WDF_INTERRUPT_INFO_V1_5, *PWDF_INTERRUPT_INFO_V1_5;

// End of versioning of structures for wdfinterrupt.h

//
// Versioning of structures for wdfio.h
//
// 
// This is the structure used to configure an IoQueue and
// register callback events to it.
// 
//
typedef struct _WDF_IO_QUEUE_CONFIG_V1_5 {
    ULONG                                       Size;

    WDF_IO_QUEUE_DISPATCH_TYPE                  DispatchType;

    WDF_TRI_STATE                               PowerManaged;

    BOOLEAN                                     AllowZeroLengthRequests;

    BOOLEAN                                     DefaultQueue;

    PFN_WDF_IO_QUEUE_IO_DEFAULT                 EvtIoDefault;

    PFN_WDF_IO_QUEUE_IO_READ                    EvtIoRead;

    PFN_WDF_IO_QUEUE_IO_WRITE                   EvtIoWrite;

    PFN_WDF_IO_QUEUE_IO_DEVICE_CONTROL          EvtIoDeviceControl;

    PFN_WDF_IO_QUEUE_IO_INTERNAL_DEVICE_CONTROL EvtIoInternalDeviceControl;

    PFN_WDF_IO_QUEUE_IO_STOP                    EvtIoStop;

    PFN_WDF_IO_QUEUE_IO_RESUME                  EvtIoResume;

    PFN_WDF_IO_QUEUE_IO_CANCELED_ON_QUEUE       EvtIoCanceledOnQueue;

} WDF_IO_QUEUE_CONFIG_V1_5, *PWDF_IO_QUEUE_CONFIG_V1_5;

// End of versioning of structures for wdfio.h

//
// Versioning of structures for wdfIoTarget.h
//
typedef struct _WDF_IO_TARGET_OPEN_PARAMS_V1_5 {
    // 
    // Size of this structure in bytes
    // 
    ULONG Size;

    // 
    // Indicates which fields of this structure are going to be used in
    // creating the WDFIOTARGET.
    // 
    WDF_IO_TARGET_OPEN_TYPE Type;

    // 
    // Notification when the target is being queried for removal.
    // If !NT_SUCCESS is returned, the query will fail and the target will
    // remain opened.
    // 
    PFN_WDF_IO_TARGET_QUERY_REMOVE EvtIoTargetQueryRemove;

    // 
    // The previous query remove has been canceled and the target can now be
    // reopened.
    // 
    PFN_WDF_IO_TARGET_REMOVE_CANCELED EvtIoTargetRemoveCanceled;

    // 
    // The query remove has succeeded and the target is now removed from the
    // system.
    // 
    PFN_WDF_IO_TARGET_REMOVE_COMPLETE EvtIoTargetRemoveComplete;

    // ========== WdfIoTargetOpenUseExistingDevice begin ==========
    // 
    // The device object to send requests to
    // 
    PDEVICE_OBJECT TargetDeviceObject;

    // 
    // File object representing the TargetDeviceObject.  The PFILE_OBJECT will
    // be passed as a parameter in all requests sent to the resulting
    // WDFIOTARGET.
    // 
    PFILE_OBJECT TargetFileObject;

    // ========== WdfIoTargetOpenUseExistingDevice end ==========
    //
    // ========== WdfIoTargetOpenByName begin ==========
    // 
    // Name of the device to open.
    // 
    UNICODE_STRING TargetDeviceName;

    // 
    // The access desired on the device being opened up, ie WDM FILE_XXX_ACCESS
    // such as FILE_ANY_ACCESS, FILE_SPECIAL_ACCESS, FILE_READ_ACCESS, or
    // FILE_WRITE_ACCESS or you can use values such as GENERIC_READ,
    // GENERIC_WRITE, or GENERIC_ALL.
    // 
    ACCESS_MASK DesiredAccess;

    // 
    // Share access desired on the target being opened, ie WDM FILE_SHARE_XXX
    // values such as FILE_SHARE_READ, FILE_SHARE_WRITE, FILE_SHARE_DELETE.
    // 
    // A zero value means exclusive access to the target.
    // 
    ULONG ShareAccess;

    // 
    // File  attributes, see ZwCreateFile in the DDK for a list of valid
    // values and their meaning.
    // 
    ULONG FileAttributes;

    // 
    // Create disposition, see ZwCreateFile in the DDK for a list of valid
    // values and their meaning.
    // 
    ULONG CreateDisposition;

    // 
    // Options for opening the device, see CreateOptions for ZwCreateFile in the
    // DDK for a list of valid values and their meaning.
    // 
    ULONG CreateOptions;

    PVOID EaBuffer;

    ULONG EaBufferLength;

    PLONGLONG AllocationSize;

    // ========== WdfIoTargetOpenByName end ==========
    //
    // 
    // On return for a create by name, this will contain one of the following
    // values:  FILE_CREATED, FILE_OPENED, FILE_OVERWRITTEN, FILE_SUPERSEDED,
    // FILE_EXISTS, FILE_DOES_NOT_EXIST
    // 
    ULONG FileInformation;

} WDF_IO_TARGET_OPEN_PARAMS_V1_5, *PWDF_IO_TARGET_OPEN_PARAMS_V1_5;

// End of versioning of structures for wdfIoTarget.h

//
// Versioning of structures for wdfMemory.h
//
typedef struct _WDFMEMORY_OFFSET_V1_5 {
    // 
    // Offset into the WDFMEMORY that the operation should start at.
    // 
    size_t BufferOffset;

    // 
    // Number of bytes that the operation should access.  If 0, the entire
    // length of the WDFMEMORY buffer will be used in the operation or ignored
    // depending on the API.
    // 
    size_t BufferLength;

} WDFMEMORY_OFFSET_V1_5, *PWDFMEMORY_OFFSET_V1_5;

typedef struct _WDF_MEMORY_DESCRIPTOR_V1_5 {
    WDF_MEMORY_DESCRIPTOR_TYPE Type;

    union {
        struct {
            PVOID Buffer;

            ULONG Length;

        } BufferType;

        struct {
            PMDL Mdl;

            ULONG BufferLength;

        } MdlType;

        struct {
            WDFMEMORY Memory;

            PWDFMEMORY_OFFSET_V1_5 Offsets;

        } HandleType;

    } u;

} WDF_MEMORY_DESCRIPTOR_V1_5, *PWDF_MEMORY_DESCRIPTOR_V1_5;

// End of versioning of structures for wdfMemory.h

//
// Versioning of structures for wdfMiniport.h
//
// End of versioning of structures for wdfMiniport.h

//
// Versioning of structures for wdfObject.h
//
typedef struct _WDF_OBJECT_ATTRIBUTES_V1_5 {
    // 
    // Size in bytes of this structure
    // 
    ULONG Size;

    // 
    // Function to call when the object is deleted
    // 
    PFN_WDF_OBJECT_CONTEXT_CLEANUP EvtCleanupCallback;

    // 
    // Function to call when the objects memory is destroyed when the
    // the last reference count goes to zero
    // 
    PFN_WDF_OBJECT_CONTEXT_DESTROY EvtDestroyCallback;

    // 
    // Execution level constraints for Object
    // 
    WDF_EXECUTION_LEVEL            ExecutionLevel;

    // 
    // Synchronization level constraint for Object
    // 
    WDF_SYNCHRONIZATION_SCOPE        SynchronizationScope;

    // 
    // Optional Parent Object
    // 
    WDFOBJECT ParentObject;

    // 
    // Overrides the size of the context allocated as specified by
    // ContextTypeInfo->ContextSize
    // 
    size_t ContextSizeOverride;

    // 
    // Pointer to the type information to be associated with the object
    // 
    PCWDF_OBJECT_CONTEXT_TYPE_INFO_V1_5 ContextTypeInfo;

} WDF_OBJECT_ATTRIBUTES_V1_5, *PWDF_OBJECT_ATTRIBUTES_V1_5;

// 
// Since C does not have strong type checking we must invent our own
// 
typedef struct _WDF_OBJECT_CONTEXT_TYPE_INFO_V1_5 {
    // 
    // The size of this structure in bytes
    // 
    ULONG Size;

    // 
    // String representation of the context's type name, i.e. "DEVICE_CONTEXT"
    // 
    PCHAR ContextName;

    // 
    // The size of the context in bytes.  This will be the size of the context
    // associated with the handle unless
    // WDF_OBJECT_ATTRIBUTES::ContextSizeOverride is specified.
    // 
    size_t ContextSize;

    // 
    // If NULL, this structure is the unique type identifier for the context
    // type.  If != NULL, the UniqueType pointer value is the unique type id
    // for the context type.
    // 
    PCWDF_OBJECT_CONTEXT_TYPE_INFO_V1_5 UniqueType;

    // 
    // Function pointer to retrieve the context type information structure
    // pointer from the provider of the context type.  This function is invoked
    // by the client driver's entry point by the KMDF stub after all class
    // drivers are loaded and before DriverEntry is invoked.
    // 
    PFN_GET_UNIQUE_CONTEXT_TYPE EvtDriverGetUniqueContextType;

} WDF_OBJECT_CONTEXT_TYPE_INFO_V1_5, *PWDF_OBJECT_CONTEXT_TYPE_INFO_V1_5;

// End of versioning of structures for wdfObject.h

//
// Versioning of structures for wdfpdo.h
//
typedef struct _WDF_PDO_EVENT_CALLBACKS_V1_5 {
    // 
    // The size of this structure in bytes
    // 
    ULONG Size;

    // 
    // Called in response to IRP_MN_QUERY_RESOURCES
    // 
    PFN_WDF_DEVICE_RESOURCES_QUERY EvtDeviceResourcesQuery;

    // 
    // Called in response to IRP_MN_QUERY_RESOURCE_REQUIREMENTS
    // 
    PFN_WDF_DEVICE_RESOURCE_REQUIREMENTS_QUERY EvtDeviceResourceRequirementsQuery;

    // 
    // Called in response to IRP_MN_EJECT
    // 
    PFN_WDF_DEVICE_EJECT EvtDeviceEject;

    // 
    // Called in response to IRP_MN_SET_LOCK
    // 
    PFN_WDF_DEVICE_SET_LOCK EvtDeviceSetLock;

    // 
    // Called in response to the power policy owner sending a wait wake to the
    // PDO.  Bus generic arming shoulding occur here.
    // 
    PFN_WDF_DEVICE_ENABLE_WAKE_AT_BUS       EvtDeviceEnableWakeAtBus;

    // 
    // Called in response to the power policy owner sending a wait wake to the
    // PDO.  Bus generic disarming shoulding occur here.
    // 
    PFN_WDF_DEVICE_DISABLE_WAKE_AT_BUS      EvtDeviceDisableWakeAtBus;

} WDF_PDO_EVENT_CALLBACKS_V1_5, *PWDF_PDO_EVENT_CALLBACKS_V1_5;

// End of versioning of structures for wdfpdo.h

//
// Versioning of structures for wdfpool.h
//
// End of versioning of structures for wdfpool.h

//
// Versioning of structures for wdfqueryinterface.h
//
typedef struct _WDF_QUERY_INTERFACE_CONFIG_V1_5 {
    // 
    // Size of this structure in bytes.
    // 
    ULONG Size;

    // 
    // Interface to be returned to the caller.  Optional if BehaviorType is set
    // to WdfQueryInterfaceTypePassThrough or ImportInterface is set to TRUE.
    // 
    PINTERFACE Interface;

    // 
    // The GUID identifying the interface
    // 
    CONST GUID * InterfaceType;

    // 
    // Valid only for PDOs.  The framework will allocate a new request and
    // forward it down the parent's device stack.
    // 
    BOOLEAN SendQueryToParentStack;

    //
    // 
    // Driver supplied callback which is called after some basic interface
    // validation has been performed (size, version, and guid checking).  This
    // is an optional parameter and may be NULL unless ImportInterface is
    // specified.
    // 
    // If the callback returns !NT_SUCCESS, this error will be returned to the
    // caller and the query interface will fail.
    // 
    // In this callback, the caller is free to modify the ExposedInterface in
    // any manner of its choosing.  For instance, the callback may change any
    // field in the interface.  The callback may also alloate a dynamic context
    // to be associated with the interface; the InterfaceReference and
    // InterfaceDereference functions may also be overridden.
    // 
    // If ImportInterface is set to TRUE, then this is a required field and the
    // callback must initialize the interface (the framework will leave the
    // ExposedInterface buffer exactly as it received it) since the framework
    // has no way of knowing which fields to fill in and which to leave alone.
    // 
    PFN_WDF_DEVICE_PROCESS_QUERY_INTERFACE_REQUEST EvtDeviceProcessQueryInterfaceRequest;

    // 
    // If TRUE, the interface provided by the caller contains data that the
    // driver is interested in.  By setting to this field to TRUE, the
    // EvtDeviceProcessQueryInterfaceRequest callback must initialize the
    // ExposedInterface.
    // 
    // If FALSE, the entire ExposedInterface is initialized through a memory
    // copy before the EvtDeviceProcessQueryInterfaceRequest is called.
    // 
    BOOLEAN ImportInterface;

} WDF_QUERY_INTERFACE_CONFIG_V1_5, *PWDF_QUERY_INTERFACE_CONFIG_V1_5;

// End of versioning of structures for wdfqueryinterface.h

//
// Versioning of structures for wdfregistry.h
//
// End of versioning of structures for wdfregistry.h

//
// Versioning of structures for wdfrequest.h
//
// 
// This parameters structure allows general access to a requests parameters
// 
typedef struct _WDF_REQUEST_PARAMETERS_V1_5 {
    USHORT Size;

    UCHAR MinorFunction;

    WDF_REQUEST_TYPE Type;

    // 
    // The following user parameters are based on the service that is being
    // invoked.  Drivers and file systems can determine which set to use based
    // on the above major and minor function codes.
    // 
    union {
        // 
        // System service parameters for:  Create
        // 
        //
        struct {
            PIO_SECURITY_CONTEXT SecurityContext;

            ULONG Options;

            USHORT POINTER_ALIGNMENT FileAttributes;

            USHORT ShareAccess;

            ULONG POINTER_ALIGNMENT EaLength;

        } Create;

        // 
        // System service parameters for:  Read
        // 
        //
        struct {
            size_t Length;

            ULONG POINTER_ALIGNMENT Key;

            LONGLONG DeviceOffset;

        } Read;

        // 
        // System service parameters for:  Write
        // 
        //
        struct {
            size_t Length;

            ULONG POINTER_ALIGNMENT Key;

            LONGLONG DeviceOffset;

        } Write;

        // 
        // System service parameters for:  Device Control
        // 
        // Note that the user's output buffer is stored in the UserBuffer field
        // and the user's input buffer is stored in the SystemBuffer field.
        // 
        //
        struct {
            size_t OutputBufferLength;

            size_t POINTER_ALIGNMENT InputBufferLength;

            ULONG POINTER_ALIGNMENT IoControlCode;

            PVOID Type3InputBuffer;

        } DeviceIoControl;

        struct {
            PVOID Arg1;

            PVOID  Arg2;

            ULONG POINTER_ALIGNMENT IoControlCode;

            PVOID Arg4;

        } Others;

    } Parameters;

} WDF_REQUEST_PARAMETERS_V1_5, *PWDF_REQUEST_PARAMETERS_V1_5;

typedef struct _WDF_REQUEST_COMPLETION_PARAMS_V1_5 {
    // 
    // Size of the structure in bytes
    // 
    ULONG Size;

    WDF_REQUEST_TYPE Type;

    IO_STATUS_BLOCK IoStatus;

    union {
        struct {
            WDFMEMORY Buffer;

            size_t Length;

            size_t Offset;

        } Write;

        struct {
            WDFMEMORY Buffer;

            size_t Length;

            size_t Offset;

        } Read;

        struct {
            ULONG IoControlCode;

            struct {
                WDFMEMORY Buffer;

                size_t Offset;

            } Input;

            struct {
                WDFMEMORY Buffer;

                size_t Offset;

                size_t Length;

            } Output;

        } Ioctl;

        struct {
            union {
                PVOID Ptr;

                ULONG_PTR Value;

            } Argument1;

            union {
                PVOID Ptr;

                ULONG_PTR Value;

            } Argument2;

            union {
                PVOID Ptr;

                ULONG_PTR Value;

            } Argument3;

            union {
                PVOID Ptr;

                ULONG_PTR Value;

            } Argument4;

        } Others;

        struct {
            PWDF_USB_REQUEST_COMPLETION_PARAMS_V1_5 Completion;

        } Usb;

    } Parameters;

} WDF_REQUEST_COMPLETION_PARAMS_V1_5, *PWDF_REQUEST_COMPLETION_PARAMS_V1_5;

typedef struct _WDF_REQUEST_REUSE_PARAMS_V1_5 {
    // 
    // Size of this structure in bytes
    // 
    ULONG Size;

    // 
    // Bit field combination of WDF_REQUEST_REUSE_Xxx values
    // 
    ULONG Flags;

    // 
    // The new status of the request.
    // 
    NTSTATUS Status;

    // 
    // New PIRP  to be contained in the WDFREQUEST.   Setting a new PIRP value
    // is only valid for WDFREQUESTs created by WdfRequestCreateFromIrp where
    // RequestFreesIrp == FALSE.  No other WDFREQUESTs (presented by the
    // I/O queue for instance) may have their IRPs changed.
    // 
    PIRP NewIrp;

} WDF_REQUEST_REUSE_PARAMS_V1_5, *PWDF_REQUEST_REUSE_PARAMS_V1_5;

typedef struct _WDF_REQUEST_SEND_OPTIONS_V1_5 {
    // 
    // Size of the structure in bytes
    // 
    ULONG Size;

    // 
    // Bit field combination of values from the WDF_REQUEST_SEND_OPTIONS_FLAGS
    // enumeration
    // 
    ULONG Flags;

    // 
    // Valid when WDF_REQUEST_SEND_OPTION_TIMEOUT is set
    // 
    LONGLONG Timeout;

} WDF_REQUEST_SEND_OPTIONS_V1_5, *PWDF_REQUEST_SEND_OPTIONS_V1_5;

// End of versioning of structures for wdfrequest.h

//
// Versioning of structures for wdfresource.h
//
// End of versioning of structures for wdfresource.h

//
// Versioning of structures for wdfstring.h
//
// End of versioning of structures for wdfstring.h

//
// Versioning of structures for wdfsync.h
//
// End of versioning of structures for wdfsync.h

//
// Versioning of structures for wdftimer.h
//
typedef struct _WDF_TIMER_CONFIG_V1_5 {
    ULONG         Size;

    PFN_WDF_TIMER EvtTimerFunc;

    LONG          Period;

    // 
    // If this is TRUE, the Timer will automatically serialize
    // with the event callback handlers of its Parent Object.
    // 
    // Parent Object's callback constraints should be compatible
    // with the Timer DPC (DISPATCH_LEVEL), or the request will fail.
    // 
    BOOLEAN       AutomaticSerialization;

} WDF_TIMER_CONFIG_V1_5, *PWDF_TIMER_CONFIG_V1_5;

// End of versioning of structures for wdftimer.h

//
// Versioning of structures for wdftypes.h
//
// End of versioning of structures for wdftypes.h

//
// Versioning of structures for wdfUsb.h
//
typedef struct _WDF_USB_REQUEST_COMPLETION_PARAMS_V1_5 {
    USBD_STATUS UsbdStatus;

    WDF_USB_REQUEST_TYPE Type;

    union {
        struct {
            WDFMEMORY Buffer;

            USHORT LangID;

            UCHAR StringIndex;

            // 
            // If STATUS_BUFFER_OVERFLOW is returned, this field will contain the
            // number of bytes required to retrieve the entire string.
            // 
            UCHAR RequiredSize;

        } DeviceString;

        struct {
            WDFMEMORY Buffer;

            WDF_USB_CONTROL_SETUP_PACKET SetupPacket;

            ULONG Length;

        } DeviceControlTransfer;

        struct {
            WDFMEMORY Buffer;

        } DeviceUrb;

        struct {
            WDFMEMORY Buffer;

            size_t Length;

            size_t Offset;

        } PipeWrite;

        struct {
            WDFMEMORY Buffer;

            size_t Length;

            size_t Offset;

        } PipeRead;

        struct {
            WDFMEMORY Buffer;

        } PipeUrb;

    } Parameters;

} WDF_USB_REQUEST_COMPLETION_PARAMS_V1_5, *PWDF_USB_REQUEST_COMPLETION_PARAMS_V1_5;

typedef struct _WDF_USB_CONTINUOUS_READER_CONFIG_V1_5 {
    // 
    // Size of the string in bytes
    // 
    ULONG Size;

    // 
    // Number of bytes to send ask for from the usb device.
    // 
    size_t TransferLength;

    // 
    // Number of bytes to allocate before the requested transfer length
    // 
    size_t HeaderLength;

    // 
    // Number of bytes to allocate after the requested transfer length
    // 
    size_t TrailerLength;

    // 
    // Number of reads to send to the device at once.  If zero is specified, the
    // default will be used.
    // 
    UCHAR NumPendingReads;

    // 
    // Optional attributes to apply to each WDFMEMORY allocated for each read
    // 
    PWDF_OBJECT_ATTRIBUTES_V1_5 BufferAttributes;

    // 
    // Event callback invoked when a read is completed
    // 
    PFN_WDF_USB_READER_COMPLETION_ROUTINE EvtUsbTargetPipeReadComplete;

    // 
    // Context to be passed to EvtUsbTargetPipeReadComplete
    // 
    WDFCONTEXT EvtUsbTargetPipeReadCompleteContext;

    // 
    // Event callback invoked when a reader fails.  If TRUE is returned, the
    // readers are restarted.
    // 
    PFN_WDF_USB_READERS_FAILED EvtUsbTargetPipeReadersFailed;

} WDF_USB_CONTINUOUS_READER_CONFIG_V1_5, *PWDF_USB_CONTINUOUS_READER_CONFIG_V1_5;

typedef struct _WDF_USB_DEVICE_INFORMATION_V1_5 {
    // 
    // Size of this structure in bytes
    // 
    ULONG Size;

    // 
    // USBD version information
    // 
    USBD_VERSION_INFORMATION UsbdVersionInformation;

    // 
    // Usb controller port capabilities
    // 
    ULONG HcdPortCapabilities;

    // 
    // Bitfield of WDF_USB_DEVICE_TRAITS values
    // 
    ULONG Traits;

} WDF_USB_DEVICE_INFORMATION_V1_5, *PWDF_USB_DEVICE_INFORMATION_V1_5;

typedef struct _WDF_USB_INTERFACE_SETTING_PAIR_V1_5 {
    // 
    // Interface to select
    // 
    WDFUSBINTERFACE UsbInterface;

    // 
    // Setting to select on UsbInterface
    // 
    UCHAR SettingIndex;

} WDF_USB_INTERFACE_SETTING_PAIR_V1_5, *PWDF_USB_INTERFACE_SETTING_PAIR_V1_5;

typedef struct _WDF_USB_DEVICE_SELECT_CONFIG_PARAMS_V1_5 {
    // 
    // Size of the structure in bytes
    // 
    ULONG Size;

    // 
    // Type of select config, one of WdfUsbTargetDeviceSelectConfigType values
    // 
    WdfUsbTargetDeviceSelectConfigType Type;

    union {
        struct {
            // 
            // Configuration descriptor to use
            // 
            PUSB_CONFIGURATION_DESCRIPTOR ConfigurationDescriptor;

            // 
            // Array of interface descriptors pointers.
            // 
            PUSB_INTERFACE_DESCRIPTOR * InterfaceDescriptors;

            // 
            // Number of elements in the InterfaceDescrtiptors pointer array.
            // 
            ULONG NumInterfaceDescriptors;

        } Descriptor;

        struct {
            // 
            // Preallocated select config URB formatted by the caller.
            // Will be used, as supplied without modification, as the select
            // config request.
            // 
            PURB Urb;

        } Urb;

        struct {
            // 
            // Number of pipes configured on the single after.  This value is
            // returned to the caller after a succssful call.
            // 
            UCHAR   NumberConfiguredPipes;

            // 
            // The interface which was configred.  This value is returned to the
            // caller after a successful call.
            // 
            WDFUSBINTERFACE ConfiguredUsbInterface;

        } SingleInterface;

        struct {
            // 
            // Number of interface pairs in the Pairs array
            // 
            UCHAR NumberInterfaces;

            // 
            // Array of interface + settings
            // 
            PWDF_USB_INTERFACE_SETTING_PAIR_V1_5 Pairs;

            // 
            // Number of interfaces which were configured after a successful call
            // 
            UCHAR NumberOfConfiguredInterfaces;

        } MultiInterface;

    } Types;

} WDF_USB_DEVICE_SELECT_CONFIG_PARAMS_V1_5, *PWDF_USB_DEVICE_SELECT_CONFIG_PARAMS_V1_5;

typedef struct _WDF_USB_INTERFACE_SELECT_SETTING_PARAMS_V1_5 {
    // 
    // Size of this data structure in bytes
    // 
    ULONG Size;

    // 
    // Type of select interface as indicated by one of the
    // WdfUsbTargetDeviceSelectSettingType values.
    // 
    WdfUsbTargetDeviceSelectSettingType Type;

    union {
        struct {
            // 
            // Interface descriptor that will be used in the interface selection
            // 
            PUSB_INTERFACE_DESCRIPTOR InterfaceDescriptor;

        } Descriptor;

        struct {
            // 
            // The setting index of the WDFUSBINTERFACE to use
            // 
            UCHAR SettingIndex;

        } Interface;

        struct {
            // 
            // Preformatted select interface URB which will be used in the
            // select interface request.
            // 
            PURB Urb;

        } Urb;

    } Types;

} WDF_USB_INTERFACE_SELECT_SETTING_PARAMS_V1_5, *PWDF_USB_INTERFACE_SELECT_SETTING_PARAMS_V1_5;

typedef struct _WDF_USB_PIPE_INFORMATION_V1_5 {
    // 
    // Size of the structure in bytes
    // 
    ULONG Size;

    // 
    // Maximum packet size this device is capable of
    // 
    ULONG MaximumPacketSize;

    // 
    // Raw endpoint address of the device as described by its descriptor
    // 
    UCHAR EndpointAddress;

    // 
    // Polling interval
    // 
    UCHAR Interval;

    // 
    // Which alternate setting this structure is relevant for
    // 
    UCHAR SettingIndex;

    // 
    // The type of the pipe
    WDF_USB_PIPE_TYPE PipeType;

    // 
    // Maximum size of one transfer which should be sent to the host controller
    // 
    ULONG  MaximumTransferSize;

} WDF_USB_PIPE_INFORMATION_V1_5, *PWDF_USB_PIPE_INFORMATION_V1_5;

// End of versioning of structures for wdfUsb.h

//
// Versioning of structures for wdfverifier.h
//
// End of versioning of structures for wdfverifier.h

//
// Versioning of structures for wdfWMI.h
//
typedef struct _WDF_WMI_PROVIDER_CONFIG_V1_5 {
    // 
    // Size of this structure in bytes
    // 
    ULONG Size;

    // 
    // The GUID being registered
    // 
    GUID Guid;

    // 
    // Combination of values from the enum WDF_WMI_PROVIDER_FLAGS
    // 
    ULONG Flags;

    // 
    // Minimum expected buffer size for query and set instance requests.
    // Ignored if WdfWmiProviderEventOnly is set in Flags.
    // 
    ULONG MinInstanceBufferSize;

    // 
    // Callback when caller is opening a provider which ha been marked as
    // expensive or when a caller is interested in events.
    // 
    PFN_WDF_WMI_PROVIDER_FUNCTION_CONTROL EvtWmiProviderFunctionControl;

} WDF_WMI_PROVIDER_CONFIG_V1_5, *PWDF_WMI_PROVIDER_CONFIG_V1_5;

typedef struct _WDF_WMI_INSTANCE_CONFIG_V1_5 {
    // 
    // Size of the structure in bytes
    // 
    ULONG Size;

    // 
    // Optional parameter.  If NULL, ProviderConfig must be set to a valid pointer
    // value.   If specified, indicates the provider to create an instance for.
    // 
    WDFWMIPROVIDER Provider;

    // 
    // Optional parameter.  If NULL, Provider must be set to a valid handle
    // value.  If specifeid, indicates the configuration for a provider to be
    // created and for this instance to be associated with.
    // 
    PWDF_WMI_PROVIDER_CONFIG_V1_5 ProviderConfig;

    // 
    // If the Provider is configured as read only and this field is set to TRUE,
    // the EvtWmiInstanceQueryInstance is ignored and WDF will blindly copy the
    // context associated with this instance (using RtlCopyMemory, with no locks
    // held) into the query buffer.
    // 
    BOOLEAN UseContextForQuery;

    // 
    // If TRUE, the instance will be registered as well as created.
    // 
    BOOLEAN Register;

    // 
    // Callback when caller wants to query the entire data item's buffer.
    // 
    PFN_WDF_WMI_INSTANCE_QUERY_INSTANCE EvtWmiInstanceQueryInstance;

    // 
    // Callback when caller wants to set the entire data item's buffer.
    // 
    PFN_WDF_WMI_INSTANCE_SET_INSTANCE EvtWmiInstanceSetInstance;

    // 
    // Callback when caller wants to set a single field in the data item's buffer
    // 
    PFN_WDF_WMI_INSTANCE_SET_ITEM EvtWmiInstanceSetItem;

    // 
    // Callback when caller wants to execute a method on the data item.
    // 
    PFN_WDF_WMI_INSTANCE_EXECUTE_METHOD EvtWmiInstanceExecuteMethod;

} WDF_WMI_INSTANCE_CONFIG_V1_5, *PWDF_WMI_INSTANCE_CONFIG_V1_5;

// End of versioning of structures for wdfWMI.h

//
// Versioning of structures for wdfworkitem.h
//
typedef struct _WDF_WORKITEM_CONFIG_V1_5 {
    ULONG            Size;

    PFN_WDF_WORKITEM EvtWorkItemFunc;

    // 
    // If this is TRUE, the workitem will automatically serialize
    // with the event callback handlers of its Parent Object.
    // 
    // Parent Object's callback constraints should be compatible
    // with the work item (PASSIVE_LEVEL), or the request will fail.
    // 
    BOOLEAN       AutomaticSerialization;

} WDF_WORKITEM_CONFIG_V1_5, *PWDF_WORKITEM_CONFIG_V1_5;

// End of versioning of structures for wdfworkitem.h


#endif // _WDF_V1_5_TYPES_H_
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\win2k8\ddk\inc\wdf\kmdf\1.7\wdfbugcodes.h ===
/*++

Copyright (c) Microsoft Corporation.  All rights reserved.

_WdfVersionBuild_

Module Name:

    wdfbugcodes.h

Abstract:

    Lists bugcheck subcode values for the WDF_VIOLATION bugcheck code

Environment:

    kernel mode only

Revision History:

--*/

#ifndef _WDFBUGCODES_H_
#define _WDFBUGCODES_H_



#if (NTDDI_VERSION >= NTDDI_WIN2K)

// 
// These values are used in Parameter 1 in the bugcheck data
// 
// NOTE: Do not change these codes, only add to the end.
// The OCA analysis and debugger tools will look at
// these codes to perform fault analysis.
// 
typedef enum _WDF_BUGCHECK_CODES {
    WDF_POWER_ROUTINE_TIMED_OUT = 0x1,
    WDF_RECURSIVE_LOCK = 0x2,
    WDF_VERIFIER_FATAL_ERROR = 0x3,
    WDF_REQUIRED_PARAMETER_IS_NULL = 0x4,
    WDF_INVALID_HANDLE = 0x5,
    WDF_REQUEST_FATAL_ERROR = 0x6,
    WDF_OBJECT_ERROR = 0x7,
    WDF_DMA_FATAL_ERROR = 0x8,
    WDF_INVALID_INTERRUPT = 0x9,
    WDF_QUEUE_FATAL_ERROR = 0xA,
    WDF_INVALID_LOCK_OPERATION = 0xB,
} WDF_BUGCHECK_CODES;

typedef enum _WDF_REQUEST_FATAL_ERROR_CODES {
    WDF_REQUEST_FATAL_ERROR_NO_MORE_STACK_LOCATIONS = 0x1,
    WDF_REQUEST_FATAL_ERROR_NULL_IRP = 0x2,
    WDF_REQUEST_FATAL_ERROR_REQUEST_ALREADY_SENT = 0x3,
    WDF_REQUEST_FATAL_ERROR_INFORMATION_LENGTH_MISMATCH = 0x4,
} WDF_REQUEST_FATAL_ERROR_CODES;



typedef struct _WDF_POWER_ROUTINE_TIMED_OUT_DATA {
    //
    // Current power state associated with the timed out device
    //
    WDF_DEVICE_POWER_STATE PowerState;

    //
    // Current power policy state associated with the timed out device
    //
    WDF_DEVICE_POWER_POLICY_STATE PowerPolicyState;

    //
    // The device object for the timed out device
    //
    PDEVICE_OBJECT DeviceObject;

    //
    // The handle for the timed out device
    //
    WDFDEVICE Device;

    //
    // The thread which is stuck
    //
    PKTHREAD TimedOutThread;

} WDF_POWER_ROUTINE_TIMED_OUT_DATA;

typedef struct _WDF_REQUEST_FATAL_ERROR_INFORMATION_LENGTH_MISMATCH_DATA {
    WDFREQUEST Request;

    PIRP Irp;

    ULONG OutputBufferLength;

    ULONG_PTR Information;

    UCHAR MajorFunction;

}   WDF_REQUEST_FATAL_ERROR_INFORMATION_LENGTH_MISMATCH_DATA,
  *PWDF_REQUEST_FATAL_ERROR_INFORMATION_LENGTH_MISMATCH_DATA;

typedef struct _WDF_QUEUE_FATAL_ERROR_DATA {
    WDFQUEUE Queue;

    WDFREQUEST Request;

    NTSTATUS Status;

} WDF_QUEUE_FATAL_ERROR_DATA, *PWDF_QUEUE_FATAL_ERROR_DATA;



#endif // (NTDDI_VERSION >= NTDDI_WIN2K)


#endif // _WDFBUGCODES_H_
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\win2k8\ddk\inc\wdf\kmdf\1.7\wdfcollection.h ===
/*++

Copyright (c) Microsoft Corporation.  All rights reserved.

_WdfVersionBuild_

Module Name:

    WdfCollection.h

Abstract:

    This is the interface to the collection object

Environment:

    kernel mode only

Revision History:

--*/

#ifndef _WDFCOLLECTION_H_
#define _WDFCOLLECTION_H_



#if (NTDDI_VERSION >= NTDDI_WIN2K)



//
// WDF Function: WdfCollectionCreate
//
typedef
__checkReturn
__drv_maxIRQL(DISPATCH_LEVEL)
WDFAPI
NTSTATUS
(*PFN_WDFCOLLECTIONCREATE)(
    __in
    PWDF_DRIVER_GLOBALS DriverGlobals,
    __in_opt
    PWDF_OBJECT_ATTRIBUTES CollectionAttributes,
    __out
    WDFCOLLECTION* Collection
    );

__checkReturn
__drv_maxIRQL(DISPATCH_LEVEL)
NTSTATUS
FORCEINLINE
WdfCollectionCreate(
    __in_opt
    PWDF_OBJECT_ATTRIBUTES CollectionAttributes,
    __out
    WDFCOLLECTION* Collection
    )
{
    return ((PFN_WDFCOLLECTIONCREATE) WdfFunctions[WdfCollectionCreateTableIndex])(WdfDriverGlobals, CollectionAttributes, Collection);
}

//
// WDF Function: WdfCollectionGetCount
//
typedef
__drv_maxIRQL(DISPATCH_LEVEL)
WDFAPI
ULONG
(*PFN_WDFCOLLECTIONGETCOUNT)(
    __in
    PWDF_DRIVER_GLOBALS DriverGlobals,
    __in
    WDFCOLLECTION Collection
    );

__drv_maxIRQL(DISPATCH_LEVEL)
ULONG
FORCEINLINE
WdfCollectionGetCount(
    __in
    WDFCOLLECTION Collection
    )
{
    return ((PFN_WDFCOLLECTIONGETCOUNT) WdfFunctions[WdfCollectionGetCountTableIndex])(WdfDriverGlobals, Collection);
}

//
// WDF Function: WdfCollectionAdd
//
typedef
__checkReturn
__drv_maxIRQL(DISPATCH_LEVEL)
WDFAPI
NTSTATUS
(*PFN_WDFCOLLECTIONADD)(
    __in
    PWDF_DRIVER_GLOBALS DriverGlobals,
    __in
    WDFCOLLECTION Collection,
    __in
    WDFOBJECT Object
    );

__checkReturn
__drv_maxIRQL(DISPATCH_LEVEL)
NTSTATUS
FORCEINLINE
WdfCollectionAdd(
    __in
    WDFCOLLECTION Collection,
    __in
    WDFOBJECT Object
    )
{
    return ((PFN_WDFCOLLECTIONADD) WdfFunctions[WdfCollectionAddTableIndex])(WdfDriverGlobals, Collection, Object);
}

//
// WDF Function: WdfCollectionRemove
//
typedef
__drv_maxIRQL(DISPATCH_LEVEL)
WDFAPI
VOID
(*PFN_WDFCOLLECTIONREMOVE)(
    __in
    PWDF_DRIVER_GLOBALS DriverGlobals,
    __in
    WDFCOLLECTION Collection,
    __in
    WDFOBJECT Item
    );

__drv_maxIRQL(DISPATCH_LEVEL)
VOID
FORCEINLINE
WdfCollectionRemove(
    __in
    WDFCOLLECTION Collection,
    __in
    WDFOBJECT Item
    )
{
    ((PFN_WDFCOLLECTIONREMOVE) WdfFunctions[WdfCollectionRemoveTableIndex])(WdfDriverGlobals, Collection, Item);
}

//
// WDF Function: WdfCollectionRemoveItem
//
typedef
__drv_maxIRQL(DISPATCH_LEVEL)
WDFAPI
VOID
(*PFN_WDFCOLLECTIONREMOVEITEM)(
    __in
    PWDF_DRIVER_GLOBALS DriverGlobals,
    __in
    WDFCOLLECTION Collection,
    ULONG Index
    );

__drv_maxIRQL(DISPATCH_LEVEL)
VOID
FORCEINLINE
WdfCollectionRemoveItem(
    __in
    WDFCOLLECTION Collection,
    ULONG Index
    )
{
    ((PFN_WDFCOLLECTIONREMOVEITEM) WdfFunctions[WdfCollectionRemoveItemTableIndex])(WdfDriverGlobals, Collection, Index);
}

//
// WDF Function: WdfCollectionGetItem
//
typedef
__drv_maxIRQL(DISPATCH_LEVEL)
WDFAPI
WDFOBJECT
(*PFN_WDFCOLLECTIONGETITEM)(
    __in
    PWDF_DRIVER_GLOBALS DriverGlobals,
    __in
    WDFCOLLECTION Collection,
    ULONG Index
    );

__drv_maxIRQL(DISPATCH_LEVEL)
WDFOBJECT
FORCEINLINE
WdfCollectionGetItem(
    __in
    WDFCOLLECTION Collection,
    ULONG Index
    )
{
    return ((PFN_WDFCOLLECTIONGETITEM) WdfFunctions[WdfCollectionGetItemTableIndex])(WdfDriverGlobals, Collection, Index);
}

//
// WDF Function: WdfCollectionGetFirstItem
//
typedef
__drv_maxIRQL(DISPATCH_LEVEL)
WDFAPI
WDFOBJECT
(*PFN_WDFCOLLECTIONGETFIRSTITEM)(
    __in
    PWDF_DRIVER_GLOBALS DriverGlobals,
    __in
    WDFCOLLECTION Collection
    );

__drv_maxIRQL(DISPATCH_LEVEL)
WDFOBJECT
FORCEINLINE
WdfCollectionGetFirstItem(
    __in
    WDFCOLLECTION Collection
    )
{
    return ((PFN_WDFCOLLECTIONGETFIRSTITEM) WdfFunctions[WdfCollectionGetFirstItemTableIndex])(WdfDriverGlobals, Collection);
}

//
// WDF Function: WdfCollectionGetLastItem
//
typedef
__drv_maxIRQL(DISPATCH_LEVEL)
WDFAPI
WDFOBJECT
(*PFN_WDFCOLLECTIONGETLASTITEM)(
    __in
    PWDF_DRIVER_GLOBALS DriverGlobals,
    __in
    WDFCOLLECTION Collection
    );

__drv_maxIRQL(DISPATCH_LEVEL)
WDFOBJECT
FORCEINLINE
WdfCollectionGetLastItem(
    __in
    WDFCOLLECTION Collection
    )
{
    return ((PFN_WDFCOLLECTIONGETLASTITEM) WdfFunctions[WdfCollectionGetLastItemTableIndex])(WdfDriverGlobals, Collection);
}



#endif // (NTDDI_VERSION >= NTDDI_WIN2K)


#endif // _WDFCOLLECTION_H_
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\win2k8\ddk\inc\wdf\kmdf\1.7\wdf11.h ===
#ifndef _WDF_V1_1_TYPES_H_
#define _WDF_V1_1_TYPES_H_


typedef enum _WDFFUNCENUM_V1_1 {
    WdfFunctionTableNumEntries_V1_1 = 386,
} WDFFUNCENUM_V1_1;

typedef struct _WDF_POWER_ROUTINE_TIMED_OUT_DATA_V1_1 *PWDF_POWER_ROUTINE_TIMED_OUT_DATA_V1_1;
typedef const struct _WDF_POWER_ROUTINE_TIMED_OUT_DATA_V1_1 *PCWDF_POWER_ROUTINE_TIMED_OUT_DATA_V1_1;
typedef struct _WDF_REQUEST_FATAL_ERROR_INFORMATION_LENGTH_MISMATCH_DATA_V1_1 *PWDF_REQUEST_FATAL_ERROR_INFORMATION_LENGTH_MISMATCH_DATA_V1_1;
typedef const struct _WDF_REQUEST_FATAL_ERROR_INFORMATION_LENGTH_MISMATCH_DATA_V1_1 *PCWDF_REQUEST_FATAL_ERROR_INFORMATION_LENGTH_MISMATCH_DATA_V1_1;
typedef struct _WDF_QUEUE_FATAL_ERROR_DATA_V1_1 *PWDF_QUEUE_FATAL_ERROR_DATA_V1_1;
typedef const struct _WDF_QUEUE_FATAL_ERROR_DATA_V1_1 *PCWDF_QUEUE_FATAL_ERROR_DATA_V1_1;
typedef struct _WDF_CHILD_IDENTIFICATION_DESCRIPTION_HEADER_V1_1 *PWDF_CHILD_IDENTIFICATION_DESCRIPTION_HEADER_V1_1;
typedef const struct _WDF_CHILD_IDENTIFICATION_DESCRIPTION_HEADER_V1_1 *PCWDF_CHILD_IDENTIFICATION_DESCRIPTION_HEADER_V1_1;
typedef struct _WDF_CHILD_ADDRESS_DESCRIPTION_HEADER_V1_1 *PWDF_CHILD_ADDRESS_DESCRIPTION_HEADER_V1_1;
typedef const struct _WDF_CHILD_ADDRESS_DESCRIPTION_HEADER_V1_1 *PCWDF_CHILD_ADDRESS_DESCRIPTION_HEADER_V1_1;
typedef struct _WDF_CHILD_RETRIEVE_INFO_V1_1 *PWDF_CHILD_RETRIEVE_INFO_V1_1;
typedef const struct _WDF_CHILD_RETRIEVE_INFO_V1_1 *PCWDF_CHILD_RETRIEVE_INFO_V1_1;
typedef struct _WDF_CHILD_LIST_CONFIG_V1_1 *PWDF_CHILD_LIST_CONFIG_V1_1;
typedef const struct _WDF_CHILD_LIST_CONFIG_V1_1 *PCWDF_CHILD_LIST_CONFIG_V1_1;
typedef struct _WDF_CHILD_LIST_ITERATOR_V1_1 *PWDF_CHILD_LIST_ITERATOR_V1_1;
typedef const struct _WDF_CHILD_LIST_ITERATOR_V1_1 *PCWDF_CHILD_LIST_ITERATOR_V1_1;
typedef struct _WDF_CLASS_EXTENSION_DESCRIPTOR_V1_1 *PWDF_CLASS_EXTENSION_DESCRIPTOR_V1_1;
typedef const struct _WDF_CLASS_EXTENSION_DESCRIPTOR_V1_1 *PCWDF_CLASS_EXTENSION_DESCRIPTOR_V1_1;
typedef struct _WDF_COMMON_BUFFER_CONFIG_V1_1 *PWDF_COMMON_BUFFER_CONFIG_V1_1;
typedef const struct _WDF_COMMON_BUFFER_CONFIG_V1_1 *PCWDF_COMMON_BUFFER_CONFIG_V1_1;
typedef struct _WDF_FILEOBJECT_CONFIG_V1_1 *PWDF_FILEOBJECT_CONFIG_V1_1;
typedef const struct _WDF_FILEOBJECT_CONFIG_V1_1 *PCWDF_FILEOBJECT_CONFIG_V1_1;
typedef struct _WDF_DEVICE_PNP_NOTIFICATION_DATA_V1_1 *PWDF_DEVICE_PNP_NOTIFICATION_DATA_V1_1;
typedef const struct _WDF_DEVICE_PNP_NOTIFICATION_DATA_V1_1 *PCWDF_DEVICE_PNP_NOTIFICATION_DATA_V1_1;
typedef struct _WDF_DEVICE_POWER_NOTIFICATION_DATA_V1_1 *PWDF_DEVICE_POWER_NOTIFICATION_DATA_V1_1;
typedef const struct _WDF_DEVICE_POWER_NOTIFICATION_DATA_V1_1 *PCWDF_DEVICE_POWER_NOTIFICATION_DATA_V1_1;
typedef struct _WDF_DEVICE_POWER_POLICY_NOTIFICATION_DATA_V1_1 *PWDF_DEVICE_POWER_POLICY_NOTIFICATION_DATA_V1_1;
typedef const struct _WDF_DEVICE_POWER_POLICY_NOTIFICATION_DATA_V1_1 *PCWDF_DEVICE_POWER_POLICY_NOTIFICATION_DATA_V1_1;
typedef struct _WDF_PNPPOWER_EVENT_CALLBACKS_V1_1 *PWDF_PNPPOWER_EVENT_CALLBACKS_V1_1;
typedef const struct _WDF_PNPPOWER_EVENT_CALLBACKS_V1_1 *PCWDF_PNPPOWER_EVENT_CALLBACKS_V1_1;
typedef struct _WDF_POWER_POLICY_EVENT_CALLBACKS_V1_1 *PWDF_POWER_POLICY_EVENT_CALLBACKS_V1_1;
typedef const struct _WDF_POWER_POLICY_EVENT_CALLBACKS_V1_1 *PCWDF_POWER_POLICY_EVENT_CALLBACKS_V1_1;
typedef struct _WDF_DEVICE_POWER_POLICY_IDLE_SETTINGS_V1_1 *PWDF_DEVICE_POWER_POLICY_IDLE_SETTINGS_V1_1;
typedef const struct _WDF_DEVICE_POWER_POLICY_IDLE_SETTINGS_V1_1 *PCWDF_DEVICE_POWER_POLICY_IDLE_SETTINGS_V1_1;
typedef struct _WDF_DEVICE_POWER_POLICY_WAKE_SETTINGS_V1_1 *PWDF_DEVICE_POWER_POLICY_WAKE_SETTINGS_V1_1;
typedef const struct _WDF_DEVICE_POWER_POLICY_WAKE_SETTINGS_V1_1 *PCWDF_DEVICE_POWER_POLICY_WAKE_SETTINGS_V1_1;
typedef struct _WDF_DEVICE_STATE_V1_1 *PWDF_DEVICE_STATE_V1_1;
typedef const struct _WDF_DEVICE_STATE_V1_1 *PCWDF_DEVICE_STATE_V1_1;
typedef struct _WDF_DEVICE_PNP_CAPABILITIES_V1_1 *PWDF_DEVICE_PNP_CAPABILITIES_V1_1;
typedef const struct _WDF_DEVICE_PNP_CAPABILITIES_V1_1 *PCWDF_DEVICE_PNP_CAPABILITIES_V1_1;
typedef struct _WDF_DEVICE_POWER_CAPABILITIES_V1_1 *PWDF_DEVICE_POWER_CAPABILITIES_V1_1;
typedef const struct _WDF_DEVICE_POWER_CAPABILITIES_V1_1 *PCWDF_DEVICE_POWER_CAPABILITIES_V1_1;
typedef struct _WDF_DMA_ENABLER_CONFIG_V1_1 *PWDF_DMA_ENABLER_CONFIG_V1_1;
typedef const struct _WDF_DMA_ENABLER_CONFIG_V1_1 *PCWDF_DMA_ENABLER_CONFIG_V1_1;
typedef struct _WDF_DPC_CONFIG_V1_1 *PWDF_DPC_CONFIG_V1_1;
typedef const struct _WDF_DPC_CONFIG_V1_1 *PCWDF_DPC_CONFIG_V1_1;
typedef struct _WDF_DRIVER_CONFIG_V1_1 *PWDF_DRIVER_CONFIG_V1_1;
typedef const struct _WDF_DRIVER_CONFIG_V1_1 *PCWDF_DRIVER_CONFIG_V1_1;
typedef struct _WDF_DRIVER_VERSION_AVAILABLE_PARAMS_V1_1 *PWDF_DRIVER_VERSION_AVAILABLE_PARAMS_V1_1;
typedef const struct _WDF_DRIVER_VERSION_AVAILABLE_PARAMS_V1_1 *PCWDF_DRIVER_VERSION_AVAILABLE_PARAMS_V1_1;
typedef struct _WDF_FDO_EVENT_CALLBACKS_V1_1 *PWDF_FDO_EVENT_CALLBACKS_V1_1;
typedef const struct _WDF_FDO_EVENT_CALLBACKS_V1_1 *PCWDF_FDO_EVENT_CALLBACKS_V1_1;
typedef struct _WDF_DRIVER_GLOBALS_V1_1 *PWDF_DRIVER_GLOBALS_V1_1;
typedef const struct _WDF_DRIVER_GLOBALS_V1_1 *PCWDF_DRIVER_GLOBALS_V1_1;
typedef struct _WDF_INTERRUPT_CONFIG_V1_1 *PWDF_INTERRUPT_CONFIG_V1_1;
typedef const struct _WDF_INTERRUPT_CONFIG_V1_1 *PCWDF_INTERRUPT_CONFIG_V1_1;
typedef struct _WDF_INTERRUPT_INFO_V1_1 *PWDF_INTERRUPT_INFO_V1_1;
typedef const struct _WDF_INTERRUPT_INFO_V1_1 *PCWDF_INTERRUPT_INFO_V1_1;
typedef struct _WDF_IO_QUEUE_CONFIG_V1_1 *PWDF_IO_QUEUE_CONFIG_V1_1;
typedef const struct _WDF_IO_QUEUE_CONFIG_V1_1 *PCWDF_IO_QUEUE_CONFIG_V1_1;
typedef struct _WDF_IO_TARGET_OPEN_PARAMS_V1_1 *PWDF_IO_TARGET_OPEN_PARAMS_V1_1;
typedef const struct _WDF_IO_TARGET_OPEN_PARAMS_V1_1 *PCWDF_IO_TARGET_OPEN_PARAMS_V1_1;
typedef struct _WDFMEMORY_OFFSET_V1_1 *PWDFMEMORY_OFFSET_V1_1;
typedef const struct _WDFMEMORY_OFFSET_V1_1 *PCWDFMEMORY_OFFSET_V1_1;
typedef struct _WDF_MEMORY_DESCRIPTOR_V1_1 *PWDF_MEMORY_DESCRIPTOR_V1_1;
typedef const struct _WDF_MEMORY_DESCRIPTOR_V1_1 *PCWDF_MEMORY_DESCRIPTOR_V1_1;
typedef struct _WDF_OBJECT_ATTRIBUTES_V1_1 *PWDF_OBJECT_ATTRIBUTES_V1_1;
typedef const struct _WDF_OBJECT_ATTRIBUTES_V1_1 *PCWDF_OBJECT_ATTRIBUTES_V1_1;
typedef struct _WDF_OBJECT_CONTEXT_TYPE_INFO_V1_1 *PWDF_OBJECT_CONTEXT_TYPE_INFO_V1_1;
typedef const struct _WDF_OBJECT_CONTEXT_TYPE_INFO_V1_1 *PCWDF_OBJECT_CONTEXT_TYPE_INFO_V1_1;
typedef struct _WDF_PDO_EVENT_CALLBACKS_V1_1 *PWDF_PDO_EVENT_CALLBACKS_V1_1;
typedef const struct _WDF_PDO_EVENT_CALLBACKS_V1_1 *PCWDF_PDO_EVENT_CALLBACKS_V1_1;
typedef struct _WDF_QUERY_INTERFACE_CONFIG_V1_1 *PWDF_QUERY_INTERFACE_CONFIG_V1_1;
typedef const struct _WDF_QUERY_INTERFACE_CONFIG_V1_1 *PCWDF_QUERY_INTERFACE_CONFIG_V1_1;
typedef struct _WDF_REQUEST_PARAMETERS_V1_1 *PWDF_REQUEST_PARAMETERS_V1_1;
typedef const struct _WDF_REQUEST_PARAMETERS_V1_1 *PCWDF_REQUEST_PARAMETERS_V1_1;
typedef struct _WDF_REQUEST_COMPLETION_PARAMS_V1_1 *PWDF_REQUEST_COMPLETION_PARAMS_V1_1;
typedef const struct _WDF_REQUEST_COMPLETION_PARAMS_V1_1 *PCWDF_REQUEST_COMPLETION_PARAMS_V1_1;
typedef struct _WDF_REQUEST_REUSE_PARAMS_V1_1 *PWDF_REQUEST_REUSE_PARAMS_V1_1;
typedef const struct _WDF_REQUEST_REUSE_PARAMS_V1_1 *PCWDF_REQUEST_REUSE_PARAMS_V1_1;
typedef struct _WDF_REQUEST_SEND_OPTIONS_V1_1 *PWDF_REQUEST_SEND_OPTIONS_V1_1;
typedef const struct _WDF_REQUEST_SEND_OPTIONS_V1_1 *PCWDF_REQUEST_SEND_OPTIONS_V1_1;
typedef struct _WDF_TIMER_CONFIG_V1_1 *PWDF_TIMER_CONFIG_V1_1;
typedef const struct _WDF_TIMER_CONFIG_V1_1 *PCWDF_TIMER_CONFIG_V1_1;
typedef struct _WDF_USB_REQUEST_COMPLETION_PARAMS_V1_1 *PWDF_USB_REQUEST_COMPLETION_PARAMS_V1_1;
typedef const struct _WDF_USB_REQUEST_COMPLETION_PARAMS_V1_1 *PCWDF_USB_REQUEST_COMPLETION_PARAMS_V1_1;
typedef struct _WDF_USB_CONTINUOUS_READER_CONFIG_V1_1 *PWDF_USB_CONTINUOUS_READER_CONFIG_V1_1;
typedef const struct _WDF_USB_CONTINUOUS_READER_CONFIG_V1_1 *PCWDF_USB_CONTINUOUS_READER_CONFIG_V1_1;
typedef struct _WDF_USB_DEVICE_INFORMATION_V1_1 *PWDF_USB_DEVICE_INFORMATION_V1_1;
typedef const struct _WDF_USB_DEVICE_INFORMATION_V1_1 *PCWDF_USB_DEVICE_INFORMATION_V1_1;
typedef struct _WDF_USB_INTERFACE_SETTING_PAIR_V1_1 *PWDF_USB_INTERFACE_SETTING_PAIR_V1_1;
typedef const struct _WDF_USB_INTERFACE_SETTING_PAIR_V1_1 *PCWDF_USB_INTERFACE_SETTING_PAIR_V1_1;
typedef struct _WDF_USB_DEVICE_SELECT_CONFIG_PARAMS_V1_1 *PWDF_USB_DEVICE_SELECT_CONFIG_PARAMS_V1_1;
typedef const struct _WDF_USB_DEVICE_SELECT_CONFIG_PARAMS_V1_1 *PCWDF_USB_DEVICE_SELECT_CONFIG_PARAMS_V1_1;
typedef struct _WDF_USB_INTERFACE_SELECT_SETTING_PARAMS_V1_1 *PWDF_USB_INTERFACE_SELECT_SETTING_PARAMS_V1_1;
typedef const struct _WDF_USB_INTERFACE_SELECT_SETTING_PARAMS_V1_1 *PCWDF_USB_INTERFACE_SELECT_SETTING_PARAMS_V1_1;
typedef struct _WDF_USB_PIPE_INFORMATION_V1_1 *PWDF_USB_PIPE_INFORMATION_V1_1;
typedef const struct _WDF_USB_PIPE_INFORMATION_V1_1 *PCWDF_USB_PIPE_INFORMATION_V1_1;
typedef struct _WDF_WMI_PROVIDER_CONFIG_V1_1 *PWDF_WMI_PROVIDER_CONFIG_V1_1;
typedef const struct _WDF_WMI_PROVIDER_CONFIG_V1_1 *PCWDF_WMI_PROVIDER_CONFIG_V1_1;
typedef struct _WDF_WMI_INSTANCE_CONFIG_V1_1 *PWDF_WMI_INSTANCE_CONFIG_V1_1;
typedef const struct _WDF_WMI_INSTANCE_CONFIG_V1_1 *PCWDF_WMI_INSTANCE_CONFIG_V1_1;
typedef struct _WDF_WORKITEM_CONFIG_V1_1 *PWDF_WORKITEM_CONFIG_V1_1;
typedef const struct _WDF_WORKITEM_CONFIG_V1_1 *PCWDF_WORKITEM_CONFIG_V1_1;

//
// Versioning of structures for wdf.h
//
// End of v