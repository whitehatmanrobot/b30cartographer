LCID lcid,
            /* [out] */ __RPC__deref_out_opt ITypeInfo **ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetIDsOfNames )( 
            IPolicyQualifiers * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [size_is][in] */ __RPC__in_ecount_full(cNames) LPOLESTR *rgszNames,
            /* [range][in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ __RPC__out_ecount_full(cNames) DISPID *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE *Invoke )( 
            IPolicyQualifiers * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS *pDispParams,
            /* [out] */ VARIANT *pVarResult,
            /* [out] */ EXCEPINFO *pExcepInfo,
            /* [out] */ UINT *puArgErr);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_ItemByIndex )( 
            IPolicyQualifiers * This,
            /* [in] */ LONG Index,
            /* [retval][out] */ __RPC__deref_out_opt IPolicyQualifier **pVal);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_Count )( 
            IPolicyQualifiers * This,
            /* [retval][out] */ __RPC__out long *pVal);
        
        /* [restricted][helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get__NewEnum )( 
            IPolicyQualifiers * This,
            /* [retval][out] */ __RPC__deref_out_opt LPUNKNOWN *pVal);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *Add )( 
            IPolicyQualifiers * This,
            /* [in] */ __RPC__in_opt IPolicyQualifier *pVal);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *Remove )( 
            IPolicyQualifiers * This,
            /* [in] */ LONG Index);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *Clear )( 
            IPolicyQualifiers * This);
        
        END_INTERFACE
    } IPolicyQualifiersVtbl;

    interface IPolicyQualifiers
    {
        CONST_VTBL struct IPolicyQualifiersVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IPolicyQualifiers_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IPolicyQualifiers_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IPolicyQualifiers_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IPolicyQualifiers_GetTypeInfoCount(This,pctinfo)	\
    ( (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo) ) 

#define IPolicyQualifiers_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    ( (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo) ) 

#define IPolicyQualifiers_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    ( (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId) ) 

#define IPolicyQualifiers_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    ( (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr) ) 


#define IPolicyQualifiers_get_ItemByIndex(This,Index,pVal)	\
    ( (This)->lpVtbl -> get_ItemByIndex(This,Index,pVal) ) 

#define IPolicyQualifiers_get_Count(This,pVal)	\
    ( (This)->lpVtbl -> get_Count(This,pVal) ) 

#define IPolicyQualifiers_get__NewEnum(This,pVal)	\
    ( (This)->lpVtbl -> get__NewEnum(This,pVal) ) 

#define IPolicyQualifiers_Add(This,pVal)	\
    ( (This)->lpVtbl -> Add(This,pVal) ) 

#define IPolicyQualifiers_Remove(This,Index)	\
    ( (This)->lpVtbl -> Remove(This,Index) ) 

#define IPolicyQualifiers_Clear(This)	\
    ( (This)->lpVtbl -> Clear(This) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IPolicyQualifiers_INTERFACE_DEFINED__ */


#ifndef __ICertificatePolicy_INTERFACE_DEFINED__
#define __ICertificatePolicy_INTERFACE_DEFINED__

/* interface ICertificatePolicy */
/* [helpstring][dual][uuid][object] */ 


EXTERN_C const IID IID_ICertificatePolicy;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("728ab31e-217d-11da-b2a4-000e7bbb2b09")
    ICertificatePolicy : public IDispatch
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE Initialize( 
            /* [in] */ __RPC__in_opt IObjectId *pValue) = 0;
        
        virtual /* [propget] */ HRESULT STDMETHODCALLTYPE get_ObjectId( 
            /* [retval][out] */ __RPC__deref_out_opt IObjectId **ppValue) = 0;
        
        virtual /* [propget] */ HRESULT STDMETHODCALLTYPE get_PolicyQualifiers( 
            /* [retval][out] */ __RPC__deref_out_opt IPolicyQualifiers **ppValue) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct ICertificatePolicyVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            ICertificatePolicy * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            ICertificatePolicy * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            ICertificatePolicy * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfoCount )( 
            ICertificatePolicy * This,
            /* [out] */ __RPC__out UINT *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfo )( 
            ICertificatePolicy * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ __RPC__deref_out_opt ITypeInfo **ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetIDsOfNames )( 
            ICertificatePolicy * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [size_is][in] */ __RPC__in_ecount_full(cNames) LPOLESTR *rgszNames,
            /* [range][in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ __RPC__out_ecount_full(cNames) DISPID *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE *Invoke )( 
            ICertificatePolicy * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS *pDispParams,
            /* [out] */ VARIANT *pVarResult,
            /* [out] */ EXCEPINFO *pExcepInfo,
            /* [out] */ UINT *puArgErr);
        
        HRESULT ( STDMETHODCALLTYPE *Initialize )( 
            ICertificatePolicy * This,
            /* [in] */ __RPC__in_opt IObjectId *pValue);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_ObjectId )( 
            ICertificatePolicy * This,
            /* [retval][out] */ __RPC__deref_out_opt IObjectId **ppValue);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_PolicyQualifiers )( 
            ICertificatePolicy * This,
            /* [retval][out] */ __RPC__deref_out_opt IPolicyQualifiers **ppValue);
        
        END_INTERFACE
    } ICertificatePolicyVtbl;

    interface ICertificatePolicy
    {
        CONST_VTBL struct ICertificatePolicyVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define ICertificatePolicy_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define ICertificatePolicy_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define ICertificatePolicy_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define ICertificatePolicy_GetTypeInfoCount(This,pctinfo)	\
    ( (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo) ) 

#define ICertificatePolicy_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    ( (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo) ) 

#define ICertificatePolicy_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    ( (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId) ) 

#define ICertificatePolicy_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    ( (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr) ) 


#define ICertificatePolicy_Initialize(This,pValue)	\
    ( (This)->lpVtbl -> Initialize(This,pValue) ) 

#define ICertificatePolicy_get_ObjectId(This,ppValue)	\
    ( (This)->lpVtbl -> get_ObjectId(This,ppValue) ) 

#define ICertificatePolicy_get_PolicyQualifiers(This,ppValue)	\
    ( (This)->lpVtbl -> get_PolicyQualifiers(This,ppValue) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __ICertificatePolicy_INTERFACE_DEFINED__ */


#ifndef __ICertificatePolicies_INTERFACE_DEFINED__
#define __ICertificatePolicies_INTERFACE_DEFINED__

/* interface ICertificatePolicies */
/* [helpstring][dual][uuid][object] */ 


EXTERN_C const IID IID_ICertificatePolicies;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("728ab31f-217d-11da-b2a4-000e7bbb2b09")
    ICertificatePolicies : public IDispatch
    {
    public:
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_ItemByIndex( 
            /* [in] */ LONG Index,
            /* [retval][out] */ __RPC__deref_out_opt ICertificatePolicy **pVal) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_Count( 
            /* [retval][out] */ __RPC__out long *pVal) = 0;
        
        virtual /* [restricted][helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get__NewEnum( 
            /* [retval][out] */ __RPC__deref_out_opt LPUNKNOWN *pVal) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE Add( 
            /* [in] */ __RPC__in_opt ICertificatePolicy *pVal) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE Remove( 
            /* [in] */ LONG Index) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE Clear( void) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct ICertificatePoliciesVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            ICertificatePolicies * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            ICertificatePolicies * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            ICertificatePolicies * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfoCount )( 
            ICertificatePolicies * This,
            /* [out] */ __RPC__out UINT *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfo )( 
            ICertificatePolicies * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ __RPC__deref_out_opt ITypeInfo **ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetIDsOfNames )( 
            ICertificatePolicies * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [size_is][in] */ __RPC__in_ecount_full(cNames) LPOLESTR *rgszNames,
            /* [range][in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ __RPC__out_ecount_full(cNames) DISPID *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE *Invoke )( 
            ICertificatePolicies * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS *pDispParams,
            /* [out] */ VARIANT *pVarResult,
            /* [out] */ EXCEPINFO *pExcepInfo,
            /* [out] */ UINT *puArgErr);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_ItemByIndex )( 
            ICertificatePolicies * This,
            /* [in] */ LONG Index,
            /* [retval][out] */ __RPC__deref_out_opt ICertificatePolicy **pVal);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_Count )( 
            ICertificatePolicies * This,
            /* [retval][out] */ __RPC__out long *pVal);
        
        /* [restricted][helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get__NewEnum )( 
            ICertificatePolicies * This,
            /* [retval][out] */ __RPC__deref_out_opt LPUNKNOWN *pVal);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *Add )( 
            ICertificatePolicies * This,
            /* [in] */ __RPC__in_opt ICertificatePolicy *pVal);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *Remove )( 
            ICertificatePolicies * This,
            /* [in] */ LONG Index);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *Clear )( 
            ICertificatePolicies * This);
        
        END_INTERFACE
    } ICertificatePoliciesVtbl;

    interface ICertificatePolicies
    {
        CONST_VTBL struct ICertificatePoliciesVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define ICertificatePolicies_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define ICertificatePolicies_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define ICertificatePolicies_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define ICertificatePolicies_GetTypeInfoCount(This,pctinfo)	\
    ( (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo) ) 

#define ICertificatePolicies_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    ( (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo) ) 

#define ICertificatePolicies_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    ( (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId) ) 

#define ICertificatePolicies_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    ( (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr) ) 


#define ICertificatePolicies_get_ItemByIndex(This,Index,pVal)	\
    ( (This)->lpVtbl -> get_ItemByIndex(This,Index,pVal) ) 

#define ICertificatePolicies_get_Count(This,pVal)	\
    ( (This)->lpVtbl -> get_Count(This,pVal) ) 

#define ICertificatePolicies_get__NewEnum(This,pVal)	\
    ( (This)->lpVtbl -> get__NewEnum(This,pVal) ) 

#define ICertificatePolicies_Add(This,pVal)	\
    ( (This)->lpVtbl -> Add(This,pVal) ) 

#define ICertificatePolicies_Remove(This,Index)	\
    ( (This)->lpVtbl -> Remove(This,Index) ) 

#define ICertificatePolicies_Clear(This)	\
    ( (This)->lpVtbl -> Clear(This) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __ICertificatePolicies_INTERFACE_DEFINED__ */


#ifndef __IX509ExtensionCertificatePolicies_INTERFACE_DEFINED__
#define __IX509ExtensionCertificatePolicies_INTERFACE_DEFINED__

/* interface IX509ExtensionCertificatePolicies */
/* [helpstring][dual][uuid][object] */ 


EXTERN_C const IID IID_IX509ExtensionCertificatePolicies;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("728ab320-217d-11da-b2a4-000e7bbb2b09")
    IX509ExtensionCertificatePolicies : public IX509Extension
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE InitializeEncode( 
            /* [in] */ __RPC__in_opt ICertificatePolicies *pValue) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE InitializeDecode( 
            /* [in] */ EncodingType Encoding,
            /* [in] */ __RPC__in BSTR strEncodedData) = 0;
        
        virtual /* [propget] */ HRESULT STDMETHODCALLTYPE get_Policies( 
            /* [retval][out] */ __RPC__deref_out_opt ICertificatePolicies **ppValue) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IX509ExtensionCertificatePoliciesVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IX509ExtensionCertificatePolicies * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IX509ExtensionCertificatePolicies * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IX509ExtensionCertificatePolicies * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfoCount )( 
            IX509ExtensionCertificatePolicies * This,
            /* [out] */ __RPC__out UINT *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfo )( 
            IX509ExtensionCertificatePolicies * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ __RPC__deref_out_opt ITypeInfo **ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetIDsOfNames )( 
            IX509ExtensionCertificatePolicies * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [size_is][in] */ __RPC__in_ecount_full(cNames) LPOLESTR *rgszNames,
            /* [range][in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ __RPC__out_ecount_full(cNames) DISPID *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE *Invoke )( 
            IX509ExtensionCertificatePolicies * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS *pDispParams,
            /* [out] */ VARIANT *pVarResult,
            /* [out] */ EXCEPINFO *pExcepInfo,
            /* [out] */ UINT *puArgErr);
        
        /* [custom] */ HRESULT ( STDMETHODCALLTYPE *Initialize )( 
            IX509ExtensionCertificatePolicies * This,
            /* [in] */ __RPC__in_opt IObjectId *pObjectId,
            /* [in] */ EncodingType Encoding,
            /* [in] */ __RPC__in BSTR strEncodedData);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_ObjectId )( 
            IX509ExtensionCertificatePolicies * This,
            /* [retval][out] */ __RPC__deref_out_opt IObjectId **ppValue);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_RawData )( 
            IX509ExtensionCertificatePolicies * This,
            /* [in] */ EncodingType Encoding,
            /* [retval][out] */ __RPC__deref_out_opt BSTR *pValue);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_Critical )( 
            IX509ExtensionCertificatePolicies * This,
            /* [retval][out] */ __RPC__out VARIANT_BOOL *pValue);
        
        /* [custom][propput] */ HRESULT ( STDMETHODCALLTYPE *put_Critical )( 
            IX509ExtensionCertificatePolicies * This,
            /* [in] */ VARIANT_BOOL Value);
        
        HRESULT ( STDMETHODCALLTYPE *InitializeEncode )( 
            IX509ExtensionCertificatePolicies * This,
            /* [in] */ __RPC__in_opt ICertificatePolicies *pValue);
        
        HRESULT ( STDMETHODCALLTYPE *InitializeDecode )( 
            IX509ExtensionCertificatePolicies * This,
            /* [in] */ EncodingType Encoding,
            /* [in] */ __RPC__in BSTR strEncodedData);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_Policies )( 
            IX509ExtensionCertificatePolicies * This,
            /* [retval][out] */ __RPC__deref_out_opt ICertificatePolicies **ppValue);
        
        END_INTERFACE
    } IX509ExtensionCertificatePoliciesVtbl;

    interface IX509ExtensionCertificatePolicies
    {
        CONST_VTBL struct IX509ExtensionCertificatePoliciesVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IX509ExtensionCertificatePolicies_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IX509ExtensionCertificatePolicies_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IX509ExtensionCertificatePolicies_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IX509ExtensionCertificatePolicies_GetTypeInfoCount(This,pctinfo)	\
    ( (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo) ) 

#define IX509ExtensionCertificatePolicies_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    ( (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo) ) 

#define IX509ExtensionCertificatePolicies_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    ( (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId) ) 

#define IX509ExtensionCertificatePolicies_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    ( (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr) ) 


#define IX509ExtensionCertificatePolicies_Initialize(This,pObjectId,Encoding,strEncodedData)	\
    ( (This)->lpVtbl -> Initialize(This,pObjectId,Encoding,strEncodedData) ) 

#define IX509ExtensionCertificatePolicies_get_ObjectId(This,ppValue)	\
    ( (This)->lpVtbl -> get_ObjectId(This,ppValue) ) 

#define IX509ExtensionCertificatePolicies_get_RawData(This,Encoding,pValue)	\
    ( (This)->lpVtbl -> get_RawData(This,Encoding,pValue) ) 

#define IX509ExtensionCertificatePolicies_get_Critical(This,pValue)	\
    ( (This)->lpVtbl -> get_Critical(This,pValue) ) 

#define IX509ExtensionCertificatePolicies_put_Critical(This,Value)	\
    ( (This)->lpVtbl -> put_Critical(This,Value) ) 


#define IX509ExtensionCertificatePolicies_InitializeEncode(This,pValue)	\
    ( (This)->lpVtbl -> InitializeEncode(This,pValue) ) 

#define IX509ExtensionCertificatePolicies_InitializeDecode(This,Encoding,strEncodedData)	\
    ( (This)->lpVtbl -> InitializeDecode(This,Encoding,strEncodedData) ) 

#define IX509ExtensionCertificatePolicies_get_Policies(This,ppValue)	\
    ( (This)->lpVtbl -> get_Policies(This,ppValue) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IX509ExtensionCertificatePolicies_INTERFACE_DEFINED__ */


#ifndef __IX509ExtensionMSApplicationPolicies_INTERFACE_DEFINED__
#define __IX509ExtensionMSApplicationPolicies_INTERFACE_DEFINED__

/* interface IX509ExtensionMSApplicationPolicies */
/* [helpstring][dual][uuid][object] */ 


EXTERN_C const IID IID_IX509ExtensionMSApplicationPolicies;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("728ab321-217d-11da-b2a4-000e7bbb2b09")
    IX509ExtensionMSApplicationPolicies : public IX509Extension
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE InitializeEncode( 
            /* [in] */ __RPC__in_opt ICertificatePolicies *pValue) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE InitializeDecode( 
            /* [in] */ EncodingType Encoding,
            /* [in] */ __RPC__in BSTR strEncodedData) = 0;
        
        virtual /* [propget] */ HRESULT STDMETHODCALLTYPE get_Policies( 
            /* [retval][out] */ __RPC__deref_out_opt ICertificatePolicies **ppValue) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IX509ExtensionMSApplicationPoliciesVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IX509ExtensionMSApplicationPolicies * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IX509ExtensionMSApplicationPolicies * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IX509ExtensionMSApplicationPolicies * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfoCount )( 
            IX509ExtensionMSApplicationPolicies * This,
            /* [out] */ __RPC__out UINT *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfo )( 
            IX509ExtensionMSApplicationPolicies * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ __RPC__deref_out_opt ITypeInfo **ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetIDsOfNames )( 
            IX509ExtensionMSApplicationPolicies * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [size_is][in] */ __RPC__in_ecount_full(cNames) LPOLESTR *rgszNames,
            /* [range][in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ __RPC__out_ecount_full(cNames) DISPID *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE *Invoke )( 
            IX509ExtensionMSApplicationPolicies * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS *pDispParams,
            /* [out] */ VARIANT *pVarResult,
            /* [out] */ EXCEPINFO *pExcepInfo,
            /* [out] */ UINT *puArgErr);
        
        /* [custom] */ HRESULT ( STDMETHODCALLTYPE *Initialize )( 
            IX509ExtensionMSApplicationPolicies * This,
            /* [in] */ __RPC__in_opt IObjectId *pObjectId,
            /* [in] */ EncodingType Encoding,
            /* [in] */ __RPC__in BSTR strEncodedData);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_ObjectId )( 
            IX509ExtensionMSApplicationPolicies * This,
            /* [retval][out] */ __RPC__deref_out_opt IObjectId **ppValue);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_RawData )( 
            IX509ExtensionMSApplicationPolicies * This,
            /* [in] */ EncodingType Encoding,
            /* [retval][out] */ __RPC__deref_out_opt BSTR *pValue);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_Critical )( 
            IX509ExtensionMSApplicationPolicies * This,
            /* [retval][out] */ __RPC__out VARIANT_BOOL *pValue);
        
        /* [custom][propput] */ HRESULT ( STDMETHODCALLTYPE *put_Critical )( 
            IX509ExtensionMSApplicationPolicies * This,
            /* [in] */ VARIANT_BOOL Value);
        
        HRESULT ( STDMETHODCALLTYPE *InitializeEncode )( 
            IX509ExtensionMSApplicationPolicies * This,
            /* [in] */ __RPC__in_opt ICertificatePolicies *pValue);
        
        HRESULT ( STDMETHODCALLTYPE *InitializeDecode )( 
            IX509ExtensionMSApplicationPolicies * This,
            /* [in] */ EncodingType Encoding,
            /* [in] */ __RPC__in BSTR strEncodedData);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_Policies )( 
            IX509ExtensionMSApplicationPolicies * This,
            /* [retval][out] */ __RPC__deref_out_opt ICertificatePolicies **ppValue);
        
        END_INTERFACE
    } IX509ExtensionMSApplicationPoliciesVtbl;

    interface IX509ExtensionMSApplicationPolicies
    {
        CONST_VTBL struct IX509ExtensionMSApplicationPoliciesVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IX509ExtensionMSApplicationPolicies_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IX509ExtensionMSApplicationPolicies_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IX509ExtensionMSApplicationPolicies_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IX509ExtensionMSApplicationPolicies_GetTypeInfoCount(This,pctinfo)	\
    ( (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo) ) 

#define IX509ExtensionMSApplicationPolicies_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    ( (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo) ) 

#define IX509ExtensionMSApplicationPolicies_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    ( (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId) ) 

#define IX509ExtensionMSApplicationPolicies_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    ( (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr) ) 


#define IX509ExtensionMSApplicationPolicies_Initialize(This,pObjectId,Encoding,strEncodedData)	\
    ( (This)->lpVtbl -> Initialize(This,pObjectId,Encoding,strEncodedData) ) 

#define IX509ExtensionMSApplicationPolicies_get_ObjectId(This,ppValue)	\
    ( (This)->lpVtbl -> get_ObjectId(This,ppValue) ) 

#define IX509ExtensionMSApplicationPolicies_get_RawData(This,Encoding,pValue)	\
    ( (This)->lpVtbl -> get_RawData(This,Encoding,pValue) ) 

#define IX509ExtensionMSApplicationPolicies_get_Critical(This,pValue)	\
    ( (This)->lpVtbl -> get_Critical(This,pValue) ) 

#define IX509ExtensionMSApplicationPolicies_put_Critical(This,Value)	\
    ( (This)->lpVtbl -> put_Critical(This,Value) ) 


#define IX509ExtensionMSApplicationPolicies_InitializeEncode(This,pValue)	\
    ( (This)->lpVtbl -> InitializeEncode(This,pValue) ) 

#define IX509ExtensionMSApplicationPolicies_InitializeDecode(This,Encoding,strEncodedData)	\
    ( (This)->lpVtbl -> InitializeDecode(This,Encoding,strEncodedData) ) 

#define IX509ExtensionMSApplicationPolicies_get_Policies(This,ppValue)	\
    ( (This)->lpVtbl -> get_Policies(This,ppValue) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IX509ExtensionMSApplicationPolicies_INTERFACE_DEFINED__ */


#ifndef __IX509Attribute_INTERFACE_DEFINED__
#define __IX509Attribute_INTERFACE_DEFINED__

/* interface IX509Attribute */
/* [helpstring][dual][uuid][object] */ 


EXTERN_C const IID IID_IX509Attribute;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("728ab322-217d-11da-b2a4-000e7bbb2b09")
    IX509Attribute : public IDispatch
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE Initialize( 
            /* [in] */ __RPC__in_opt IObjectId *pObjectId,
            /* [in] */ EncodingType Encoding,
            /* [in] */ __RPC__in BSTR strEncodedData) = 0;
        
        virtual /* [propget] */ HRESULT STDMETHODCALLTYPE get_ObjectId( 
            /* [retval][out] */ __RPC__deref_out_opt IObjectId **ppValue) = 0;
        
        virtual /* [propget] */ HRESULT STDMETHODCALLTYPE get_RawData( 
            /* [in] */ EncodingType Encoding,
            /* [retval][out] */ __RPC__deref_out_opt BSTR *pValue) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IX509AttributeVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IX509Attribute * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IX509Attribute * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IX509Attribute * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfoCount )( 
            IX509Attribute * This,
            /* [out] */ __RPC__out UINT *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfo )( 
            IX509Attribute * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ __RPC__deref_out_opt ITypeInfo **ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetIDsOfNames )( 
            IX509Attribute * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [size_is][in] */ __RPC__in_ecount_full(cNames) LPOLESTR *rgszNames,
            /* [range][in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ __RPC__out_ecount_full(cNames) DISPID *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE *Invoke )( 
            IX509Attribute * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS *pDispParams,
            /* [out] */ VARIANT *pVarResult,
            /* [out] */ EXCEPINFO *pExcepInfo,
            /* [out] */ UINT *puArgErr);
        
        HRESULT ( STDMETHODCALLTYPE *Initialize )( 
            IX509Attribute * This,
            /* [in] */ __RPC__in_opt IObjectId *pObjectId,
            /* [in] */ EncodingType Encoding,
            /* [in] */ __RPC__in BSTR strEncodedData);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_ObjectId )( 
            IX509Attribute * This,
            /* [retval][out] */ __RPC__deref_out_opt IObjectId **ppValue);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_RawData )( 
            IX509Attribute * This,
            /* [in] */ EncodingType Encoding,
            /* [retval][out] */ __RPC__deref_out_opt BSTR *pValue);
        
        END_INTERFACE
    } IX509AttributeVtbl;

    interface IX509Attribute
    {
        CONST_VTBL struct IX509AttributeVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IX509Attribute_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IX509Attribute_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IX509Attribute_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IX509Attribute_GetTypeInfoCount(This,pctinfo)	\
    ( (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo) ) 

#define IX509Attribute_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    ( (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo) ) 

#define IX509Attribute_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    ( (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId) ) 

#define IX509Attribute_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    ( (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr) ) 


#define IX509Attribute_Initialize(This,pObjectId,Encoding,strEncodedData)	\
    ( (This)->lpVtbl -> Initialize(This,pObjectId,Encoding,strEncodedData) ) 

#define IX509Attribute_get_ObjectId(This,ppValue)	\
    ( (This)->lpVtbl -> get_ObjectId(This,ppValue) ) 

#define IX509Attribute_get_RawData(This,Encoding,pValue)	\
    ( (This)->lpVtbl -> get_RawData(This,Encoding,pValue) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IX509Attribute_INTERFACE_DEFINED__ */


#ifndef __IX509Attributes_INTERFACE_DEFINED__
#define __IX509Attributes_INTERFACE_DEFINED__

/* interface IX509Attributes */
/* [helpstring][dual][uuid][object] */ 


EXTERN_C const IID IID_IX509Attributes;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("728ab323-217d-11da-b2a4-000e7bbb2b09")
    IX509Attributes : public IDispatch
    {
    public:
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_ItemByIndex( 
            /* [in] */ LONG Index,
            /* [retval][out] */ __RPC__deref_out_opt IX509Attribute **pVal) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_Count( 
            /* [retval][out] */ __RPC__out long *pVal) = 0;
        
        virtual /* [restricted][helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get__NewEnum( 
            /* [retval][out] */ __RPC__deref_out_opt LPUNKNOWN *pVal) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE Add( 
            /* [in] */ __RPC__in_opt IX509Attribute *pVal) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE Remove( 
            /* [in] */ LONG Index) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE Clear( void) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IX509AttributesVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IX509Attributes * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IX509Attributes * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IX509Attributes * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfoCount )( 
            IX509Attributes * This,
            /* [out] */ __RPC__out UINT *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfo )( 
            IX509Attributes * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ __RPC__deref_out_opt ITypeInfo **ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetIDsOfNames )( 
            IX509Attributes * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [size_is][in] */ __RPC__in_ecount_full(cNames) LPOLESTR *rgszNames,
            /* [range][in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ __RPC__out_ecount_full(cNames) DISPID *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE *Invoke )( 
            IX509Attributes * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS *pDispParams,
            /* [out] */ VARIANT *pVarResult,
            /* [out] */ EXCEPINFO *pExcepInfo,
            /* [out] */ UINT *puArgErr);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_ItemByIndex )( 
            IX509Attributes * This,
            /* [in] */ LONG Index,
            /* [retval][out] */ __RPC__deref_out_opt IX509Attribute **pVal);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_Count )( 
            IX509Attributes * This,
            /* [retval][out] */ __RPC__out long *pVal);
        
        /* [restricted][helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get__NewEnum )( 
            IX509Attributes * This,
            /* [retval][out] */ __RPC__deref_out_opt LPUNKNOWN *pVal);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *Add )( 
            IX509Attributes * This,
            /* [in] */ __RPC__in_opt IX509Attribute *pVal);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *Remove )( 
            IX509Attributes * This,
            /* [in] */ LONG Index);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *Clear )( 
            IX509Attributes * This);
        
        END_INTERFACE
    } IX509AttributesVtbl;

    interface IX509Attributes
    {
        CONST_VTBL struct IX509AttributesVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IX509Attributes_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IX509Attributes_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IX509Attributes_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IX509Attributes_GetTypeInfoCount(This,pctinfo)	\
    ( (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo) ) 

#define IX509Attributes_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    ( (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo) ) 

#define IX509Attributes_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    ( (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId) ) 

#define IX509Attributes_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    ( (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr) ) 


#define IX509Attributes_get_ItemByIndex(This,Index,pVal)	\
    ( (This)->lpVtbl -> get_ItemByIndex(This,Index,pVal) ) 

#define IX509Attributes_get_Count(This,pVal)	\
    ( (This)->lpVtbl -> get_Count(This,pVal) ) 

#define IX509Attributes_get__NewEnum(This,pVal)	\
    ( (This)->lpVtbl -> get__NewEnum(This,pVal) ) 

#define IX509Attributes_Add(This,pVal)	\
    ( (This)->lpVtbl -> Add(This,pVal) ) 

#define IX509Attributes_Remove(This,Index)	\
    ( (This)->lpVtbl -> Remove(This,Index) ) 

#define IX509Attributes_Clear(This)	\
    ( (This)->lpVtbl -> Clear(This) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IX509Attributes_INTERFACE_DEFINED__ */


#ifndef __IX509AttributeExtensions_INTERFACE_DEFINED__
#define __IX509AttributeExtensions_INTERFACE_DEFINED__

/* interface IX509AttributeExtensions */
/* [helpstring][dual][uuid][object] */ 


EXTERN_C const IID IID_IX509AttributeExtensions;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("728ab324-217d-11da-b2a4-000e7bbb2b09")
    IX509AttributeExtensions : public IX509Attribute
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE InitializeEncode( 
            /* [in] */ __RPC__in_opt IX509Extensions *pExtensions) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE InitializeDecode( 
            /* [in] */ EncodingType Encoding,
            /* [in] */ __RPC__in BSTR strEncodedData) = 0;
        
        virtual /* [propget] */ HRESULT STDMETHODCALLTYPE get_X509Extensions( 
            /* [retval][out] */ __RPC__deref_out_opt IX509Extensions **ppValue) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IX509AttributeExtensionsVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IX509AttributeExtensions * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IX509AttributeExtensions * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IX509AttributeExtensions * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfoCount )( 
            IX509AttributeExtensions * This,
            /* [out] */ __RPC__out UINT *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfo )( 
            IX509AttributeExtensions * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ __RPC__deref_out_opt ITypeInfo **ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetIDsOfNames )( 
            IX509AttributeExtensions * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [size_is][in] */ __RPC__in_ecount_full(cNames) LPOLESTR *rgszNames,
            /* [range][in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ __RPC__out_ecount_full(cNames) DISPID *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE *Invoke )( 
            IX509AttributeExtensions * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS *pDispParams,
            /* [out] */ VARIANT *pVarResult,
            /* [out] */ EXCEPINFO *pExcepInfo,
            /* [out] */ UINT *puArgErr);
        
        HRESULT ( STDMETHODCALLTYPE *Initialize )( 
            IX509AttributeExtensions * This,
            /* [in] */ __RPC__in_opt IObjectId *pObjectId,
            /* [in] */ EncodingType Encoding,
            /* [in] */ __RPC__in BSTR strEncodedData);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_ObjectId )( 
            IX509AttributeExtensions * This,
            /* [retval][out] */ __RPC__deref_out_opt IObjectId **ppValue);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_RawData )( 
            IX509AttributeExtensions * This,
            /* [in] */ EncodingType Encoding,
            /* [retval][out] */ __RPC__deref_out_opt BSTR *pValue);
        
        HRESULT ( STDMETHODCALLTYPE *InitializeEncode )( 
            IX509AttributeExtensions * This,
            /* [in] */ __RPC__in_opt IX509Extensions *pExtensions);
        
        HRESULT ( STDMETHODCALLTYPE *InitializeDecode )( 
            IX509AttributeExtensions * This,
            /* [in] */ EncodingType Encoding,
            /* [in] */ __RPC__in BSTR strEncodedData);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_X509Extensions )( 
            IX509AttributeExtensions * This,
            /* [retval][out] */ __RPC__deref_out_opt IX509Extensions **ppValue);
        
        END_INTERFACE
    } IX509AttributeExtensionsVtbl;

    interface IX509AttributeExtensions
    {
        CONST_VTBL struct IX509AttributeExtensionsVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IX509AttributeExtensions_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IX509AttributeExtensions_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IX509AttributeExtensions_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IX509AttributeExtensions_GetTypeInfoCount(This,pctinfo)	\
    ( (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo) ) 

#define IX509AttributeExtensions_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    ( (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo) ) 

#define IX509AttributeExtensions_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    ( (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId) ) 

#define IX509AttributeExtensions_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    ( (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr) ) 


#define IX509AttributeExtensions_Initialize(This,pObjectId,Encoding,strEncodedData)	\
    ( (This)->lpVtbl -> Initialize(This,pObjectId,Encoding,strEncodedData) ) 

#define IX509AttributeExtensions_get_ObjectId(This,ppValue)	\
    ( (This)->lpVtbl -> get_ObjectId(This,ppValue) ) 

#define IX509AttributeExtensions_get_RawData(This,Encoding,pValue)	\
    ( (This)->lpVtbl -> get_RawData(This,Encoding,pValue) ) 


#define IX509AttributeExtensions_InitializeEncode(This,pExtensions)	\
    ( (This)->lpVtbl -> InitializeEncode(This,pExtensions) ) 

#define IX509AttributeExtensions_InitializeDecode(This,Encoding,strEncodedData)	\
    ( (This)->lpVtbl -> InitializeDecode(This,Encoding,strEncodedData) ) 

#define IX509AttributeExtensions_get_X509Extensions(This,ppValue)	\
    ( (This)->lpVtbl -> get_X509Extensions(This,ppValue) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IX509AttributeExtensions_INTERFACE_DEFINED__ */


/* interface __MIDL_itf_certenroll_0000_0037 */
/* [local] */ 

typedef 
enum RequestClientInfoClientId
    {	ClientIdNone	= 0,
	ClientIdXEnroll2003	= 1,
	ClientIdAutoEnroll2003	= 2,
	ClientIdWizard2003	= 3,
	ClientIdCertReq2003	= 4,
	ClientIdDefaultRequest	= 5,
	ClientIdAutoEnroll	= 6,
	ClientIdRequestWizard	= 7,
	ClientIdEOBO	= 8,
	ClientIdCertReq	= 9,
	ClientIdTest	= 10,
	ClientIdUserStart	= 1000
    } 	RequestClientInfoClientId;



extern RPC_IF_HANDLE __MIDL_itf_certenroll_0000_0037_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_certenroll_0000_0037_v0_0_s_ifspec;

#ifndef __IX509AttributeClientId_INTERFACE_DEFINED__
#define __IX509AttributeClientId_INTERFACE_DEFINED__

/* interface IX509AttributeClientId */
/* [helpstring][dual][uuid][object] */ 


EXTERN_C const IID IID_IX509AttributeClientId;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("728ab325-217d-11da-b2a4-000e7bbb2b09")
    IX509AttributeClientId : public IX509Attribute
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE InitializeEncode( 
            /* [in] */ RequestClientInfoClientId ClientId,
            /* [in] */ __RPC__in BSTR strMachineDnsName,
            /* [in] */ __RPC__in BSTR strUserSamName,
            /* [in] */ __RPC__in BSTR strProcessName) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE InitializeDecode( 
            /* [in] */ EncodingType Encoding,
            /* [in] */ __RPC__in BSTR strEncodedData) = 0;
        
        virtual /* [propget] */ HRESULT STDMETHODCALLTYPE get_ClientId( 
            /* [retval][out] */ __RPC__out RequestClientInfoClientId *pValue) = 0;
        
        virtual /* [propget] */ HRESULT STDMETHODCALLTYPE get_MachineDnsName( 
            /* [retval][out] */ __RPC__deref_out_opt BSTR *pValue) = 0;
        
        virtual /* [propget] */ HRESULT STDMETHODCALLTYPE get_UserSamName( 
            /* [retval][out] */ __RPC__deref_out_opt BSTR *pValue) = 0;
        
        virtual /* [propget] */ HRESULT STDMETHODCALLTYPE get_ProcessName( 
            /* [retval][out] */ __RPC__deref_out_opt BSTR *pValue) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IX509AttributeClientIdVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IX509AttributeClientId * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IX509AttributeClientId * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IX509AttributeClientId * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfoCount )( 
            IX509AttributeClientId * This,
            /* [out] */ __RPC__out UINT *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfo )( 
            IX509AttributeClientId * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ __RPC__deref_out_opt ITypeInfo **ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetIDsOfNames )( 
            IX509AttributeClientId * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [size_is][in] */ __RPC__in_ecount_full(cNames) LPOLESTR *rgszNames,
            /* [range][in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ __RPC__out_ecount_full(cNames) DISPID *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE *Invoke )( 
            IX509AttributeClientId * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS *pDispParams,
            /* [out] */ VARIANT *pVarResult,
            /* [out] */ EXCEPINFO *pExcepInfo,
            /* [out] */ UINT *puArgErr);
        
        HRESULT ( STDMETHODCALLTYPE *Initialize )( 
            IX509AttributeClientId * This,
            /* [in] */ __RPC__in_opt IObjectId *pObjectId,
            /* [in] */ EncodingType Encoding,
            /* [in] */ __RPC__in BSTR strEncodedData);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_ObjectId )( 
            IX509AttributeClientId * This,
            /* [retval][out] */ __RPC__deref_out_opt IObjectId **ppValue);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_RawData )( 
            IX509AttributeClientId * This,
            /* [in] */ EncodingType Encoding,
            /* [retval][out] */ __RPC__deref_out_opt BSTR *pValue);
        
        HRESULT ( STDMETHODCALLTYPE *InitializeEncode )( 
            IX509AttributeClientId * This,
            /* [in] */ RequestClientInfoClientId ClientId,
            /* [in] */ __RPC__in BSTR strMachineDnsName,
            /* [in] */ __RPC__in BSTR strUserSamName,
            /* [in] */ __RPC__in BSTR strProcessName);
        
        HRESULT ( STDMETHODCALLTYPE *InitializeDecode )( 
            IX509AttributeClientId * This,
            /* [in] */ EncodingType Encoding,
            /* [in] */ __RPC__in BSTR strEncodedData);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_ClientId )( 
            IX509AttributeClientId * This,
            /* [retval][out] */ __RPC__out RequestClientInfoClientId *pValue);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_MachineDnsName )( 
            IX509AttributeClientId * This,
            /* [retval][out] */ __RPC__deref_out_opt BSTR *pValue);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_UserSamName )( 
            IX509AttributeClientId * This,
            /* [retval][out] */ __RPC__deref_out_opt BSTR *pValue);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_ProcessName )( 
            IX509AttributeClientId * This,
            /* [retval][out] */ __RPC__deref_out_opt BSTR *pValue);
        
        END_INTERFACE
    } IX509AttributeClientIdVtbl;

    interface IX509AttributeClientId
    {
        CONST_VTBL struct IX509AttributeClientIdVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IX509AttributeClientId_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IX509AttributeClientId_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IX509AttributeClientId_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IX509AttributeClientId_GetTypeInfoCount(This,pctinfo)	\
    ( (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo) ) 

#define IX509AttributeClientId_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    ( (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo) ) 

#define IX509AttributeClientId_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    ( (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId) ) 

#define IX509AttributeClientId_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    ( (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr) ) 


#define IX509AttributeClientId_Initialize(This,pObjectId,Encoding,strEncodedData)	\
    ( (This)->lpVtbl -> Initialize(This,pObjectId,Encoding,strEncodedData) ) 

#define IX509AttributeClientId_get_ObjectId(This,ppValue)	\
    ( (This)->lpVtbl -> get_ObjectId(This,ppValue) ) 

#define IX509AttributeClientId_get_RawData(This,Encoding,pValue)	\
    ( (This)->lpVtbl -> get_RawData(This,Encoding,pValue) ) 


#define IX509AttributeClientId_InitializeEncode(This,ClientId,strMachineDnsName,strUserSamName,strProcessName)	\
    ( (This)->lpVtbl -> InitializeEncode(This,ClientId,strMachineDnsName,strUserSamName,strProcessName) ) 

#define IX509AttributeClientId_InitializeDecode(This,Encoding,strEncodedData)	\
    ( (This)->lpVtbl -> InitializeDecode(This,Encoding,strEncodedData) ) 

#define IX509AttributeClientId_get_ClientId(This,pValue)	\
    ( (This)->lpVtbl -> get_ClientId(This,pValue) ) 

#define IX509AttributeClientId_get_MachineDnsName(This,pValue)	\
    ( (This)->lpVtbl -> get_MachineDnsName(This,pValue) ) 

#define IX509AttributeClientId_get_UserSamName(This,pValue)	\
    ( (This)->lpVtbl -> get_UserSamName(This,pValue) ) 

#define IX509AttributeClientId_get_ProcessName(This,pValue)	\
    ( (This)->lpVtbl -> get_ProcessName(This,pValue) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IX509AttributeClientId_INTERFACE_DEFINED__ */


#ifndef __IX509AttributeRenewalCertificate_INTERFACE_DEFINED__
#define __IX509AttributeRenewalCertificate_INTERFACE_DEFINED__

/* interface IX509AttributeRenewalCertificate */
/* [helpstring][dual][uuid][object] */ 


EXTERN_C const IID IID_IX509AttributeRenewalCertificate;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("728ab326-217d-11da-b2a4-000e7bbb2b09")
    IX509AttributeRenewalCertificate : public IX509Attribute
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE InitializeEncode( 
            /* [in] */ EncodingType Encoding,
            /* [in] */ __RPC__in BSTR strCert) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE InitializeDecode( 
            /* [in] */ EncodingType Encoding,
            /* [in] */ __RPC__in BSTR strEncodedData) = 0;
        
        virtual /* [propget] */ HRESULT STDMETHODCALLTYPE get_RenewalCertificate( 
            /* [in] */ EncodingType Encoding,
            /* [retval][out] */ __RPC__deref_out_opt BSTR *pValue) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IX509AttributeRenewalCertificateVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IX509AttributeRenewalCertificate * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IX509AttributeRenewalCertificate * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IX509AttributeRenewalCertificate * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfoCount )( 
            IX509AttributeRenewalCertificate * This,
            /* [out] */ __RPC__out UINT *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfo )( 
            IX509AttributeRenewalCertificate * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ __RPC__deref_out_opt ITypeInfo **ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetIDsOfNames )( 
            IX509AttributeRenewalCertificate * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [size_is][in] */ __RPC__in_ecount_full(cNames) LPOLESTR *rgszNames,
            /* [range][in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ __RPC__out_ecount_full(cNames) DISPID *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE *Invoke )( 
            IX509AttributeRenewalCertificate * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS *pDispParams,
            /* [out] */ VARIANT *pVarResult,
            /* [out] */ EXCEPINFO *pExcepInfo,
            /* [out] */ UINT *puArgErr);
        
        HRESULT ( STDMETHODCALLTYPE *Initialize )( 
            IX509AttributeRenewalCertificate * This,
            /* [in] */ __RPC__in_opt IObjectId *pObjectId,
            /* [in] */ EncodingType Encoding,
            /* [in] */ __RPC__in BSTR strEncodedData);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_ObjectId )( 
            IX509AttributeRenewalCertificate * This,
            /* [retval][out] */ __RPC__deref_out_opt IObjectId **ppValue);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_RawData )( 
            IX509AttributeRenewalCertificate * This,
            /* [in] */ EncodingType Encoding,
            /* [retval][out] */ __RPC__deref_out_opt BSTR *pValue);
        
        HRESULT ( STDMETHODCALLTYPE *InitializeEncode )( 
            IX509AttributeRenewalCertificate * This,
            /* [in] */ EncodingType Encoding,
            /* [in] */ __RPC__in BSTR strCert);
        
        HRESULT ( STDMETHODCALLTYPE *InitializeDecode )( 
            IX509AttributeRenewalCertificate * This,
            /* [in] */ EncodingType Encoding,
            /* [in] */ __RPC__in BSTR strEncodedData);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_RenewalCertificate )( 
            IX509AttributeRenewalCertificate * This,
            /* [in] */ EncodingType Encoding,
            /* [retval][out] */ __RPC__deref_out_opt BSTR *pValue);
        
        END_INTERFACE
    } IX509AttributeRenewalCertificateVtbl;

    interface IX509AttributeRenewalCertificate
    {
        CONST_VTBL struct IX509AttributeRenewalCertificateVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IX509AttributeRenewalCertificate_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IX509AttributeRenewalCertificate_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IX509AttributeRenewalCertificate_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IX509AttributeRenewalCertificate_GetTypeInfoCount(This,pctinfo)	\
    ( (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo) ) 

#define IX509AttributeRenewalCertificate_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    ( (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo) ) 

#define IX509AttributeRenewalCertificate_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    ( (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId) ) 

#define IX509AttributeRenewalCertificate_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    ( (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr) ) 


#define IX509AttributeRenewalCertificate_Initialize(This,pObjectId,Encoding,strEncodedData)	\
    ( (This)->lpVtbl -> Initialize(This,pObjectId,Encoding,strEncodedData) ) 

#define IX509AttributeRenewalCertificate_get_ObjectId(This,ppValue)	\
    ( (This)->lpVtbl -> get_ObjectId(This,ppValue) ) 

#define IX509AttributeRenewalCertificate_get_RawData(This,Encoding,pValue)	\
    ( (This)->lpVtbl -> get_RawData(This,Encoding,pValue) ) 


#define IX509AttributeRenewalCertificate_InitializeEncode(This,Encoding,strCert)	\
    ( (This)->lpVtbl -> InitializeEncode(This,Encoding,strCert) ) 

#define IX509AttributeRenewalCertificate_InitializeDecode(This,Encoding,strEncodedData)	\
    ( (This)->lpVtbl -> InitializeDecode(This,Encoding,strEncodedData) ) 

#define IX509AttributeRenewalCertificate_get_RenewalCertificate(This,Encoding,pValue)	\
    ( (This)->lpVtbl -> get_RenewalCertificate(This,Encoding,pValue) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IX509AttributeRenewalCertificate_INTERFACE_DEFINED__ */


#ifndef __IX509AttributeArchiveKey_INTERFACE_DEFINED__
#define __IX509AttributeArchiveKey_INTERFACE_DEFINED__

/* interface IX509AttributeArchiveKey */
/* [helpstring][dual][uuid][object] */ 


EXTERN_C const IID IID_IX509AttributeArchiveKey;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("728ab327-217d-11da-b2a4-000e7bbb2b09")
    IX509AttributeArchiveKey : public IX509Attribute
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE InitializeEncode( 
            /* [in] */ __RPC__in_opt IX509PrivateKey *pKey,
            /* [in] */ EncodingType Encoding,
            /* [in] */ __RPC__in BSTR strCAXCert,
            /* [in] */ __RPC__in_opt IObjectId *pAlgorithm,
            /* [in] */ LONG EncryptionStrength) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE InitializeDecode( 
            /* [in] */ EncodingType Encoding,
            /* [in] */ __RPC__in BSTR strEncodedData) = 0;
        
        virtual /* [propget] */ HRESULT STDMETHODCALLTYPE get_EncryptedKeyBlob( 
            /* [in] */ EncodingType Encoding,
            /* [retval][out] */ __RPC__deref_out_opt BSTR *pValue) = 0;
        
        virtual /* [propget] */ HRESULT STDMETHODCALLTYPE get_EncryptionAlgorithm( 
            /* [retval][out] */ __RPC__deref_out_opt IObjectId **ppValue) = 0;
        
        virtual /* [propget] */ HRESULT STDMETHODCALLTYPE get_EncryptionStrength( 
            /* [retval][out] */ __RPC__out LONG *pValue) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IX509AttributeArchiveKeyVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IX509AttributeArchiveKey * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IX509AttributeArchiveKey * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IX509AttributeArchiveKey * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfoCount )( 
            IX509AttributeArchiveKey * This,
            /* [out] */ __RPC__out UINT *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfo )( 
            IX509AttributeArchiveKey * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ __RPC__deref_out_opt ITypeInfo **ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetIDsOfNames )( 
            IX509AttributeArchiveKey * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [size_is][in] */ __RPC__in_ecount_full(cNames) LPOLESTR *rgszNames,
            /* [range][in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ __RPC__out_ecount_full(cNames) DISPID *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE *Invoke )( 
            IX509AttributeArchiveKey * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS *pDispParams,
            /* [out] */ VARIANT *pVarResult,
            /* [out] */ EXCEPINFO *pExcepInfo,
            /* [out] */ UINT *puArgErr);
        
        HRESULT ( STDMETHODCALLTYPE *Initialize )( 
            IX509AttributeArchiveKey * This,
            /* [in] */ __RPC__in_opt IObjectId *pObjectId,
            /* [in] */ EncodingType Encoding,
            /* [in] */ __RPC__in BSTR strEncodedData);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_ObjectId )( 
            IX509AttributeArchiveKey * This,
            /* [retval][out] */ __RPC__deref_out_opt IObjectId **ppValue);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_RawData )( 
            IX509AttributeArchiveKey * This,
            /* [in] */ EncodingType Encoding,
            /* [retval][out] */ __RPC__deref_out_opt BSTR *pValue);
        
        HRESULT ( STDMETHODCALLTYPE *InitializeEncode )( 
            IX509AttributeArchiveKey * This,
            /* [in] */ __RPC__in_opt IX509PrivateKey *pKey,
            /* [in] */ EncodingType Encoding,
            /* [in] */ __RPC__in BSTR strCAXCert,
            /* [in] */ __RPC__in_opt IObjectId *pAlgorithm,
            /* [in] */ LONG EncryptionStrength);
        
        HRESULT ( STDMETHODCALLTYPE *InitializeDecode )( 
            IX509AttributeArchiveKey * This,
            /* [in] */ EncodingType Encoding,
            /* [in] */ __RPC__in BSTR strEncodedData);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_EncryptedKeyBlob )( 
            IX509AttributeArchiveKey * This,
            /* [in] */ EncodingType Encoding,
            /* [retval][out] */ __RPC__deref_out_opt BSTR *pValue);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_EncryptionAlgorithm )( 
            IX509AttributeArchiveKey * This,
            /* [retval][out] */ __RPC__deref_out_opt IObjectId **ppValue);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_EncryptionStrength )( 
            IX509AttributeArchiveKey * This,
            /* [retval][out] */ __RPC__out LONG *pValue);
        
        END_INTERFACE
    } IX509AttributeArchiveKeyVtbl;

    interface IX509AttributeArchiveKey
    {
        CONST_VTBL struct IX509AttributeArchiveKeyVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IX509AttributeArchiveKey_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IX509AttributeArchiveKey_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IX509AttributeArchiveKey_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IX509AttributeArchiveKey_GetTypeInfoCount(This,pctinfo)	\
    ( (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo) ) 

#define IX509AttributeArchiveKey_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    ( (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo) ) 

#define IX509AttributeArchiveKey_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    ( (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId) ) 

#define IX509AttributeArchiveKey_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    ( (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr) ) 


#define IX509AttributeArchiveKey_Initialize(This,pObjectId,Encoding,strEncodedData)	\
    ( (This)->lpVtbl -> Initialize(This,pObjectId,Encoding,strEncodedData) ) 

#define IX509AttributeArchiveKey_get_ObjectId(This,ppValue)	\
    ( (This)->lpVtbl -> get_ObjectId(This,ppValue) ) 

#define IX509AttributeArchiveKey_get_RawData(This,Encoding,pValue)	\
    ( (This)->lpVtbl -> get_RawData(This,Encoding,pValue) ) 


#define IX509AttributeArchiveKey_InitializeEncode(This,pKey,Encoding,strCAXCert,pAlgorithm,EncryptionStrength)	\
    ( (This)->lpVtbl -> InitializeEncode(This,pKey,Encoding,strCAXCert,pAlgorithm,EncryptionStrength) ) 

#define IX509AttributeArchiveKey_InitializeDecode(This,Encoding,strEncodedData)	\
    ( (This)->lpVtbl -> InitializeDecode(This,Encoding,strEncodedData) ) 

#define IX509AttributeArchiveKey_get_EncryptedKeyBlob(This,Encoding,pValue)	\
    ( (This)->lpVtbl -> get_EncryptedKeyBlob(This,Encoding,pValue) ) 

#define IX509AttributeArchiveKey_get_EncryptionAlgorithm(This,ppValue)	\
    ( (This)->lpVtbl -> get_EncryptionAlgorithm(This,ppValue) ) 

#define IX509AttributeArchiveKey_get_EncryptionStrength(This,pValue)	\
    ( (This)->lpVtbl -> get_EncryptionStrength(This,pValue) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IX509AttributeArchiveKey_INTERFACE_DEFINED__ */


#ifndef __IX509AttributeArchiveKeyHash_INTERFACE_DEFINED__
#define __IX509AttributeArchiveKeyHash_INTERFACE_DEFINED__

/* interface IX509AttributeArchiveKeyHash */
/* [helpstring][dual][uuid][object] */ 


EXTERN_C const IID IID_IX509AttributeArchiveKeyHash;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("728ab328-217d-11da-b2a4-000e7bbb2b09")
    IX509AttributeArchiveKeyHash : public IX509Attribute
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE InitializeEncodeFromEncryptedKeyBlob( 
            /* [in] */ EncodingType Encoding,
            /* [in] */ __RPC__in BSTR strEncryptedKeyBlob) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE InitializeDecode( 
            /* [in] */ EncodingType Encoding,
            /* [in] */ __RPC__in BSTR strEncodedData) = 0;
        
        virtual /* [propget] */ HRESULT STDMETHODCALLTYPE get_EncryptedKeyHashBlob( 
            /* [in] */ EncodingType Encoding,
            /* [retval][out] */ __RPC__deref_out_opt BSTR *pValue) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IX509AttributeArchiveKeyHashVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IX509AttributeArchiveKeyHash * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IX509AttributeArchiveKeyHash * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IX509AttributeArchiveKeyHash * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfoCount )( 
            IX509AttributeArchiveKeyHash * This,
            /* [out] */ __RPC__out UINT *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfo )( 
            IX509AttributeArchiveKeyHash * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ __RPC__deref_out_opt ITypeInfo **ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetIDsOfNames )( 
            IX509AttributeArchiveKeyHash * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [size_is][in] */ __RPC__in_ecount_full(cNames) LPOLESTR *rgszNames,
            /* [range][in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ __RPC__out_ecount_full(cNames) DISPID *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE *Invoke )( 
            IX509AttributeArchiveKeyHash * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS *pDispParams,
            /* [out] */ VARIANT *pVarResult,
            /* [out] */ EXCEPINFO *pExcepInfo,
            /* [out] */ UINT *puArgErr);
        
        HRESULT ( STDMETHODCALLTYPE *Initialize )( 
            IX509AttributeArchiveKeyHash * This,
            /* [in] */ __RPC__in_opt IObjectId *pObjectId,
            /* [in] */ EncodingType Encoding,
            /* [in] */ __RPC__in BSTR strEncodedData);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_ObjectId )( 
            IX509AttributeArchiveKeyHash * This,
            /* [retval][out] */ __RPC__deref_out_opt IObjectId **ppValue);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_RawData )( 
            IX509AttributeArchiveKeyHash * This,
            /* [in] */ EncodingType Encoding,
            /* [retval][out] */ __RPC__deref_out_opt BSTR *pValue);
        
        HRESULT ( STDMETHODCALLTYPE *InitializeEncodeFromEncryptedKeyBlob )( 
            IX509AttributeArchiveKeyHash * This,
            /* [in] */ EncodingType Encoding,
            /* [in] */ __RPC__in BSTR strEncryptedKeyBlob);
        
        HRESULT ( STDMETHODCALLTYPE *InitializeDecode )( 
            IX509AttributeArchiveKeyHash * This,
            /* [in] */ EncodingType Encoding,
            /* [in] */ __RPC__in BSTR strEncodedData);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_EncryptedKeyHashBlob )( 
            IX509AttributeArchiveKeyHash * This,
            /* [in] */ EncodingType Encoding,
            /* [retval][out] */ __RPC__deref_out_opt BSTR *pValue);
        
        END_INTERFACE
    } IX509AttributeArchiveKeyHashVtbl;

    interface IX509AttributeArchiveKeyHash
    {
        CONST_VTBL struct IX509AttributeArchiveKeyHashVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IX509AttributeArchiveKeyHash_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IX509AttributeArchiveKeyHash_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IX509AttributeArchiveKeyHash_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IX509AttributeArchiveKeyHash_GetTypeInfoCount(This,pctinfo)	\
    ( (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo) ) 

#define IX509AttributeArchiveKeyHash_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    ( (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo) ) 

#define IX509AttributeArchiveKeyHash_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    ( (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId) ) 

#define IX509AttributeArchiveKeyHash_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    ( (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr) ) 


#define IX509AttributeArchiveKeyHash_Initialize(This,pObjectId,Encoding,strEncodedData)	\
    ( (This)->lpVtbl -> Initialize(This,pObjectId,Encoding,strEncodedData) ) 

#define IX509AttributeArchiveKeyHash_get_ObjectId(This,ppValue)	\
    ( (This)->lpVtbl -> get_ObjectId(This,ppValue) ) 

#define IX509AttributeArchiveKeyHash_get_RawData(This,Encoding,pValue)	\
    ( (This)->lpVtbl -> get_RawData(This,Encoding,pValue) ) 


#define IX509AttributeArchiveKeyHash_InitializeEncodeFromEncryptedKeyBlob(This,Encoding,strEncryptedKeyBlob)	\
    ( (This)->lpVtbl -> InitializeEncodeFromEncryptedKeyBlob(This,Encoding,strEncryptedKeyBlob) ) 

#define IX509AttributeArchiveKeyHash_InitializeDecode(This,Encoding,strEncodedData)	\
    ( (This)->lpVtbl -> InitializeDecode(This,Encoding,strEncodedData) ) 

#define IX509AttributeArchiveKeyHash_get_EncryptedKeyHashBlob(This,Encoding,pValue)	\
    ( (This)->lpVtbl -> get_EncryptedKeyHashBlob(This,Encoding,pValue) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IX509AttributeArchiveKeyHash_INTERFACE_DEFINED__ */


#ifndef __IX509AttributeOSVersion_INTERFACE_DEFINED__
#define __IX509AttributeOSVersion_INTERFACE_DEFINED__

/* interface IX509AttributeOSVersion */
/* [helpstring][dual][uuid][object] */ 


EXTERN_C const IID IID_IX509AttributeOSVersion;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("728ab32a-217d-11da-b2a4-000e7bbb2b09")
    IX509AttributeOSVersion : public IX509Attribute
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE InitializeEncode( 
            /* [in] */ __RPC__in BSTR strOSVersion) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE InitializeDecode( 
            /* [in] */ EncodingType Encoding,
            /* [in] */ __RPC__in BSTR strEncodedData) = 0;
        
        virtual /* [propget] */ HRESULT STDMETHODCALLTYPE get_OSVersion( 
            /* [retval][out] */ __RPC__deref_out_opt BSTR *pValue) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IX509AttributeOSVersionVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IX509AttributeOSVersion * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IX509AttributeOSVersion * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IX509AttributeOSVersion * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfoCount )( 
            IX509AttributeOSVersion * This,
            /* [out] */ __RPC__out UINT *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfo )( 
            IX509AttributeOSVersion * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ __RPC__deref_out_opt ITypeInfo **ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetIDsOfNames )( 
            IX509AttributeOSVersion * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [size_is][in] */ __RPC__in_ecount_full(cNames) LPOLESTR *rgszNames,
            /* [range][in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ __RPC__out_ecount_full(cNames) DISPID *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE *Invoke )( 
            IX509AttributeOSVersion * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS *pDispParams,
            /* [out] */ VARIANT *pVarResult,
            /* [out] */ EXCEPINFO *pExcepInfo,
            /* [out] */ UINT *puArgErr);
        
        HRESULT ( STDMETHODCALLTYPE *Initialize )( 
            IX509AttributeOSVersion * This,
            /* [in] */ __RPC__in_opt IObjectId *pObjectId,
            /* [in] */ EncodingType Encoding,
            /* [in] */ __RPC__in BSTR strEncodedData);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_ObjectId )( 
            IX509AttributeOSVersion * This,
            /* [retval][out] */ __RPC__deref_out_opt IObjectId **ppValue);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_RawData )( 
            IX509AttributeOSVersion * This,
            /* [in] */ EncodingType Encoding,
            /* [retval][out] */ __RPC__deref_out_opt BSTR *pValue);
        
        HRESULT ( STDMETHODCALLTYPE *InitializeEncode )( 
            IX509AttributeOSVersion * This,
            /* [in] */ __RPC__in BSTR strOSVersion);
        
        HRESULT ( STDMETHODCALLTYPE *InitializeDecode )( 
            IX509AttributeOSVersion * This,
            /* [in] */ EncodingType Encoding,
            /* [in] */ __RPC__in BSTR strEncodedData);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_OSVersion )( 
            IX509AttributeOSVersion * This,
            /* [retval][out] */ __RPC__deref_out_opt BSTR *pValue);
        
        END_INTERFACE
    } IX509AttributeOSVersionVtbl;

    interface IX509AttributeOSVersion
    {
        CONST_VTBL struct IX509AttributeOSVersionVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IX509AttributeOSVersion_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IX509AttributeOSVersion_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IX509AttributeOSVersion_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IX509AttributeOSVersion_GetTypeInfoCount(This,pctinfo)	\
    ( (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo) ) 

#define IX509AttributeOSVersion_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    ( (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo) ) 

#define IX509AttributeOSVersion_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    ( (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId) ) 

#define IX509AttributeOSVersion_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    ( (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr) ) 


#define IX509AttributeOSVersion_Initialize(This,pObjectId,Encoding,strEncodedData)	\
    ( (This)->lpVtbl -> Initialize(This,pObjectId,Encoding,strEncodedData) ) 

#define IX509AttributeOSVersion_get_ObjectId(This,ppValue)	\
    ( (This)->lpVtbl -> get_ObjectId(This,ppValue) ) 

#define IX509AttributeOSVersion_get_RawData(This,Encoding,pValue)	\
    ( (This)->lpVtbl -> get_RawData(This,Encoding,pValue) ) 


#define IX509AttributeOSVersion_InitializeEncode(This,strOSVersion)	\
    ( (This)->lpVtbl -> InitializeEncode(This,strOSVersion) ) 

#define IX509AttributeOSVersion_InitializeDecode(This,Encoding,strEncodedData)	\
    ( (This)->lpVtbl -> InitializeDecode(This,Encoding,strEncodedData) ) 

#define IX509AttributeOSVersion_get_OSVersion(This,pValue)	\
    ( (This)->lpVtbl -> get_OSVersion(This,pValue) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IX509AttributeOSVersion_INTERFACE_DEFINED__ */


#ifndef __IX509AttributeCspProvider_INTERFACE_DEFINED__
#define __IX509AttributeCspProvider_INTERFACE_DEFINED__

/* interface IX509AttributeCspProvider */
/* [helpstring][dual][uuid][object] */ 


EXTERN_C const IID IID_IX509AttributeCspProvider;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("728ab32b-217d-11da-b2a4-000e7bbb2b09")
    IX509AttributeCspProvider : public IX509Attribute
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE InitializeEncode( 
            /* [in] */ X509KeySpec KeySpec,
            /* [in] */ __RPC__in BSTR strProviderName,
            /* [in] */ EncodingType Encoding,
            /* [in] */ __RPC__in BSTR strSignature) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE InitializeDecode( 
            /* [in] */ EncodingType Encoding,
            /* [in] */ __RPC__in BSTR strEncodedData) = 0;
        
        virtual /* [propget] */ HRESULT STDMETHODCALLTYPE get_KeySpec( 
            /* [retval][out] */ __RPC__out X509KeySpec *pValue) = 0;
        
        virtual /* [propget] */ HRESULT STDMETHODCALLTYPE get_ProviderName( 
            /* [retval][out] */ __RPC__deref_out_opt BSTR *pValue) = 0;
        
        virtual /* [propget] */ HRESULT STDMETHODCALLTYPE get_Signature( 
            /* [in] */ EncodingType Encoding,
            /* [retval][out] */ __RPC__deref_out_opt BSTR *pValue) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IX509AttributeCspProviderVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IX509AttributeCspProvider * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IX509AttributeCspProvider * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IX509AttributeCspProvider * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfoCount )( 
            IX509AttributeCspProvider * This,
            /* [out] */ __RPC__out UINT *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfo )( 
            IX509AttributeCspProvider * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ __RPC__deref_out_opt ITypeInfo **ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetIDsOfNames )( 
            IX509AttributeCspProvider * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [size_is][in] */ __RPC__in_ecount_full(cNames) LPOLESTR *rgszNames,
            /* [range][in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ __RPC__out_ecount_full(cNames) DISPID *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE *Invoke )( 
            IX509AttributeCspProvider * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS *pDispParams,
            /* [out] */ VARIANT *pVarResult,
            /* [out] */ EXCEPINFO *pExcepInfo,
            /* [out] */ UINT *puArgErr);
        
        HRESULT ( STDMETHODCALLTYPE *Initialize )( 
            IX509AttributeCspProvider * This,
            /* [in] */ __RPC__in_opt IObjectId *pObjectId,
            /* [in] */ EncodingType Encoding,
            /* [in] */ __RPC__in BSTR strEncodedData);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_ObjectId )( 
            IX509AttributeCspProvider * This,
            /* [retval][out] */ __RPC__deref_out_opt IObjectId **ppValue);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_RawData )( 
            IX509AttributeCspProvider * This,
            /* [in] */ EncodingType Encoding,
            /* [retval][out] */ __RPC__deref_out_opt BSTR *pValue);
        
        HRESULT ( STDMETHODCALLTYPE *InitializeEncode )( 
            IX509AttributeCspProvider * This,
            /* [in] */ X509KeySpec KeySpec,
            /* [in] */ __RPC__in BSTR strProviderName,
            /* [in] */ EncodingType Encoding,
            /* [in] */ __RPC__in BSTR strSignature);
        
        HRESULT ( STDMETHODCALLTYPE *InitializeDecode )( 
            IX509AttributeCspProvider * This,
            /* [in] */ EncodingType Encoding,
            /* [in] */ __RPC__in BSTR strEncodedData);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_KeySpec )( 
            IX509AttributeCspProvider * This,
            /* [retval][out] */ __RPC__out X509KeySpec *pValue);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_ProviderName )( 
            IX509AttributeCspProvider * This,
            /* [retval][out] */ __RPC__deref_out_opt BSTR *pValue);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_Signature )( 
            IX509AttributeCspProvider * This,
            /* [in] */ EncodingType Encoding,
            /* [retval][out] */ __RPC__deref_out_opt BSTR *pValue);
        
        END_INTERFACE
    } IX509AttributeCspProviderVtbl;

    interface IX509AttributeCspProvider
    {
        CONST_VTBL struct IX509AttributeCspProviderVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IX509AttributeCspProvider_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IX509AttributeCspProvider_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IX509AttributeCspProvider_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IX509AttributeCspProvider_GetTypeInfoCount(This,pctinfo)	\
    ( (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo) ) 

#define IX509AttributeCspProvider_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    ( (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo) ) 

#define IX509AttributeCspProvider_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    ( (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId) ) 

#define IX509AttributeCspProvider_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    ( (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr) ) 


#define IX509AttributeCspProvider_Initialize(This,pObjectId,Encoding,strEncodedData)	\
    ( (This)->lpVtbl -> Initialize(This,pObjectId,Encoding,strEncodedData) ) 

#define IX509AttributeCspProvider_get_ObjectId(This,ppValue)	\
    ( (This)->lpVtbl -> get_ObjectId(This,ppValue) ) 

#define IX509AttributeCspProvider_get_RawData(This,Encoding,pValue)	\
    ( (This)->lpVtbl -> get_RawData(This,Encoding,pValue) ) 


#define IX509AttributeCspProvider_InitializeEncode(This,KeySpec,strProviderName,Encoding,strSignature)	\
    ( (This)->lpVtbl -> InitializeEncode(This,KeySpec,strProviderName,Encoding,strSignature) ) 

#define IX509AttributeCspProvider_InitializeDecode(This,Encoding,strEncodedData)	\
    ( (This)->lpVtbl -> InitializeDecode(This,Encoding,strEncodedData) ) 

#define IX509AttributeCspProvider_get_KeySpec(This,pValue)	\
    ( (This)->lpVtbl -> get_KeySpec(This,pValue) ) 

#define IX509AttributeCspProvider_get_ProviderName(This,pValue)	\
    ( (This)->lpVtbl -> get_ProviderName(This,pValue) ) 

#define IX509AttributeCspProvider_get_Signature(This,Encoding,pValue)	\
    ( (This)->lpVtbl -> get_Signature(This,Encoding,pValue) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IX509AttributeCspProvider_INTERFACE_DEFINED__ */


#ifndef __ICryptAttribute_INTERFACE_DEFINED__
#define __ICryptAttribute_INTERFACE_DEFINED__

/* interface ICryptAttribute */
/* [helpstring][dual][uuid][object] */ 


EXTERN_C const IID IID_ICryptAttribute;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("728ab32c-217d-11da-b2a4-000e7bbb2b09")
    ICryptAttribute : public IDispatch
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE InitializeFromObjectId( 
            /* [in] */ __RPC__in_opt IObjectId *pObjectId) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE InitializeFromValues( 
            /* [in] */ __RPC__in_opt IX509Attributes *pAttributes) = 0;
        
        virtual /* [propget] */ HRESULT STDMETHODCALLTYPE get_ObjectId( 
            /* [retval][out] */ __RPC__deref_out_opt IObjectId **ppValue) = 0;
        
        virtual /* [propget] */ HRESULT STDMETHODCALLTYPE get_Values( 
            /* [retval][out] */ __RPC__deref_out_opt IX509Attributes **ppValue) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct ICryptAttributeVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            ICryptAttribute * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            ICryptAttribute * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            ICryptAttribute * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfoCount )( 
            ICryptAttribute * This,
            /* [out] */ __RPC__out UINT *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfo )( 
            ICryptAttribute * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ __RPC__deref_out_opt ITypeInfo **ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetIDsOfNames )( 
            ICryptAttribute * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [size_is][in] */ __RPC__in_ecount_full(cNames) LPOLESTR *rgszNames,
            /* [range][in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ __RPC__out_ecount_full(cNames) DISPID *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE *Invoke )( 
            ICryptAttribute * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS *pDispParams,
            /* [out] */ VARIANT *pVarResult,
            /* [out] */ EXCEPINFO *pExcepInfo,
            /* [out] */ UINT *puArgErr);
        
        HRESULT ( STDMETHODCALLTYPE *InitializeFromObjectId )( 
            ICryptAttribute * This,
            /* [in] */ __RPC__in_opt IObjectId *pObjectId);
        
        HRESULT ( STDMETHODCALLTYPE *InitializeFromValues )( 
            ICryptAttribute * This,
            /* [in] */ __RPC__in_opt IX509Attributes *pAttributes);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_ObjectId )( 
            ICryptAttribute * This,
            /* [retval][out] */ __RPC__deref_out_opt IObjectId **ppValue);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_Values )( 
            ICryptAttribute * This,
            /* [retval][out] */ __RPC__deref_out_opt IX509Attributes **ppValue);
        
        END_INTERFACE
    } ICryptAttributeVtbl;

    interface ICryptAttribute
    {
        CONST_VTBL struct ICryptAttributeVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define ICryptAttribute_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define ICryptAttribute_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define ICryptAttribute_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define ICryptAttribute_GetTypeInfoCount(This,pctinfo)	\
    ( (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo) ) 

#define ICryptAttribute_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    ( (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo) ) 

#define ICryptAttribute_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    ( (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId) ) 

#define ICryptAttribute_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    ( (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr) ) 


#define ICryptAttribute_InitializeFromObjectId(This,pObjectId)	\
    ( (This)->lpVtbl -> InitializeFromObjectId(This,pObjectId) ) 

#define ICryptAttribute_InitializeFromValues(This,pAttributes)	\
    ( (This)->lpVtbl -> InitializeFromValues(This,pAttributes) ) 

#define ICryptAttribute_get_ObjectId(This,ppValue)	\
    ( (This)->lpVtbl -> get_ObjectId(This,ppValue) ) 

#define ICryptAttribute_get_Values(This,ppValue)	\
    ( (This)->lpVtbl -> get_Values(This,ppValue) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __ICryptAttribute_INTERFACE_DEFINED__ */


#ifndef __ICryptAttributes_INTERFACE_DEFINED__
#define __ICryptAttributes_INTERFACE_DEFINED__

/* interface ICryptAttributes */
/* [helpstring][dual][uuid][object] */ 


EXTERN_C const IID IID_ICryptAttributes;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("728ab32d-217d-11da-b2a4-000e7bbb2b09")
    ICryptAttributes : public IDispatch
    {
    public:
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_ItemByIndex( 
            /* [in] */ LONG Index,
            /* [retval][out] */ __RPC__deref_out_opt ICryptAttribute **pVal) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_Count( 
            /* [retval][out] */ __RPC__out long *pVal) = 0;
        
        virtual /* [restricted][helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get__NewEnum( 
            /* [retval][out] */ __RPC__deref_out_opt LPUNKNOWN *pVal) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE Add( 
            /* [in] */ __RPC__in_opt ICryptAttribute *pVal) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE Remove( 
            /* [in] */ LONG Index) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE Clear( void) = 0;
        
        virtual /* [propget] */ HRESULT STDMETHODCALLTYPE get_IndexByObjectId( 
            /* [in] */ __RPC__in_opt IObjectId *pObjectId,
            /* [retval][out] */ __RPC__out LONG *pIndex) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE AddRange( 
            /* [in] */ __RPC__in_opt ICryptAttributes *pValue) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct ICryptAttributesVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            ICryptAttributes * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            ICryptAttributes * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            ICryptAttributes * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfoCount )( 
            ICryptAttributes * This,
            /* [out] */ __RPC__out UINT *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfo )( 
            ICryptAttributes * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ __RPC__deref_out_opt ITypeInfo **ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetIDsOfNames )( 
            ICryptAttributes * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [size_is][in] */ __RPC__in_ecount_full(cNames) LPOLESTR *rgszNames,
            /* [range][in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ __RPC__out_ecount_full(cNames) DISPID *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE *Invoke )( 
            ICryptAttributes * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS *pDispParams,
            /* [out] */ VARIANT *pVarResult,
            /* [out] */ EXCEPINFO *pExcepInfo,
            /* [out] */ UINT *puArgErr);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_ItemByIndex )( 
            ICryptAttributes * This,
            /* [in] */ LONG Index,
            /* [retval][out] */ __RPC__deref_out_opt ICryptAttribute **pVal);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_Count )( 
            ICryptAttributes * This,
            /* [retval][out] */ __RPC__out long *pVal);
        
        /* [restricted][helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get__NewEnum )( 
            ICryptAttributes * This,
            /* [retval][out] */ __RPC__deref_out_opt LPUNKNOWN *pVal);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *Add )( 
            ICryptAttributes * This,
            /* [in] */ __RPC__in_opt ICryptAttribute *pVal);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *Remove )( 
            ICryptAttributes * This,
            /* [in] */ LONG Index);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *Clear )( 
            ICryptAttributes * This);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_IndexByObjectId )( 
            ICryptAttributes * This,
            /* [in] */ __RPC__in_opt IObjectId *pObjectId,
            /* [retval][out] */ __RPC__out LONG *pIndex);
        
        HRESULT ( STDMETHODCALLTYPE *AddRange )( 
            ICryptAttributes * This,
            /* [in] */ __RPC__in_opt ICryptAttributes *pValue);
        
        END_INTERFACE
    } ICryptAttributesVtbl;

    interface ICryptAttributes
    {
        CONST_VTBL struct ICryptAttributesVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define ICryptAttributes_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define ICryptAttributes_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define ICryptAttributes_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define ICryptAttributes_GetTypeInfoCount(This,pctinfo)	\
    ( (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo) ) 

#define ICryptAttributes_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    ( (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo) ) 

#define ICryptAttributes_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    ( (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId) ) 

#define ICryptAttributes_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    ( (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr) ) 


#define ICryptAttributes_get_ItemByIndex(This,Index,pVal)	\
    ( (This)->lpVtbl -> get_ItemByIndex(This,Index,pVal) ) 

#define ICryptAttributes_get_Count(This,pVal)	\
    ( (This)->lpVtbl -> get_Count(This,pVal) ) 

#define ICryptAttributes_get__NewEnum(This,pVal)	\
    ( (This)->lpVtbl -> get__NewEnum(This,pVal) ) 

#define ICryptAttributes_Add(This,pVal)	\
    ( (This)->lpVtbl -> Add(This,pVal) ) 

#define ICryptAttributes_Remove(This,Index)	\
    ( (This)->lpVtbl -> Remove(This,Index) ) 

#define ICryptAttributes_Clear(This)	\
    ( (This)->lpVtbl -> Clear(This) ) 

#define ICryptAttributes_get_IndexByObjectId(This,pObjectId,pIndex)	\
    ( (This)->lpVtbl -> get_IndexByObjectId(This,pObjectId,pIndex) ) 

#define ICryptAttributes_AddRange(This,pValue)	\
    ( (This)->lpVtbl -> AddRange(This,pValue) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __ICryptAttributes_INTERFACE_DEFINED__ */


/* interface __MIDL_itf_certenroll_0000_0045 */
/* [local] */ 

typedef 
enum CERTENROLL_PROPERTYID
    {	XCN_PROPERTYID_NONE	= 0,
	XCN_CERT_KEY_PROV_HANDLE_PROP_ID	= 1,
	XCN_CERT_KEY_PROV_INFO_PROP_ID	= 2,
	XCN_CERT_SHA1_HASH_PROP_ID	= 3,
	XCN_CERT_MD5_HASH_PROP_ID	= 4,
	XCN_CERT_HASH_PROP_ID	= 3,
	XCN_CERT_KEY_CONTEXT_PROP_ID	= 5,
	XCN_CERT_KEY_SPEC_PROP_ID	= 6,
	XCN_CERT_IE30_RESERVED_PROP_ID	= 7,
	XCN_CERT_PUBKEY_HASH_RESERVED_PROP_ID	= 8,
	XCN_CERT_ENHKEY_USAGE_PROP_ID	= 9,
	XCN_CERT_CTL_USAGE_PROP_ID	= 9,
	XCN_CERT_NEXT_UPDATE_LOCATION_PROP_ID	= 10,
	XCN_CERT_FRIENDLY_NAME_PROP_ID	= 11,
	XCN_CERT_PVK_FILE_PROP_ID	= 12,
	XCN_CERT_DESCRIPTION_PROP_ID	= 13,
	XCN_CERT_ACCESS_STATE_PROP_ID	= 14,
	XCN_CERT_SIGNATURE_HASH_PROP_ID	= 15,
	XCN_CERT_SMART_CARD_DATA_PROP_ID	= 16,
	XCN_CERT_EFS_PROP_ID	= 17,
	XCN_CERT_FORTEZZA_DATA_PROP_ID	= 18,
	XCN_CERT_ARCHIVED_PROP_ID	= 19,
	XCN_CERT_KEY_IDENTIFIER_PROP_ID	= 20,
	XCN_CERT_AUTO_ENROLL_PROP_ID	= 21,
	XCN_CERT_PUBKEY_ALG_PARA_PROP_ID	= 22,
	XCN_CERT_CROSS_CERT_DIST_POINTS_PROP_ID	= 23,
	XCN_CERT_ISSUER_PUBLIC_KEY_MD5_HASH_PROP_ID	= 24,
	XCN_CERT_SUBJECT_PUBLIC_KEY_MD5_HASH_PROP_ID	= 25,
	XCN_CERT_ENROLLMENT_PROP_ID	= 26,
	XCN_CERT_DATE_STAMP_PROP_ID	= 27,
	XCN_CERT_ISSUER_SERIAL_NUMBER_MD5_HASH_PROP_ID	= 28,
	XCN_CERT_SUBJECT_NAME_MD5_HASH_PROP_ID	= 29,
	XCN_CERT_EXTENDED_ERROR_INFO_PROP_ID	= 30,
	XCN_CERT_RENEWAL_PROP_ID	= 64,
	XCN_CERT_ARCHIVED_KEY_HASH_PROP_ID	= 65,
	XCN_CERT_AUTO_ENROLL_RETRY_PROP_ID	= 66,
	XCN_CERT_AIA_URL_RETRIEVED_PROP_ID	= 67,
	XCN_CERT_AUTHORITY_INFO_ACCESS_PROP_ID	= 68,
	XCN_CERT_BACKED_UP_PROP_ID	= 69,
	XCN_CERT_OCSP_RESPONSE_PROP_ID	= 70,
	XCN_CERT_REQUEST_ORIGINATOR_PROP_ID	= 71,
	XCN_CERT_SOURCE_LOCATION_PROP_ID	= 72,
	XCN_CERT_SOURCE_URL_PROP_ID	= 73,
	XCN_CERT_NEW_KEY_PROP_ID	= 74,
	XCN_CERT_FIRST_RESERVED_PROP_ID	= 85,
	XCN_CERT_LAST_RESERVED_PROP_ID	= 0x7fff,
	XCN_CERT_FIRST_USER_PROP_ID	= 0x8000,
	XCN_CERT_LAST_USER_PROP_ID	= 0xffff,
	XCN_CERT_STORE_LOCALIZED_NAME_PROP_ID	= 0x1000
    } 	CERTENROLL_PROPERTYID;



extern RPC_IF_HANDLE __MIDL_itf_certenroll_0000_0045_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_certenroll_0000_0045_v0_0_s_ifspec;

#ifndef __ICertProperty_INTERFACE_DEFINED__
#define __ICertProperty_INTERFACE_DEFINED__

/* interface ICertProperty */
/* [helpstring][dual][uuid][object] */ 


EXTERN_C const IID IID_ICertProperty;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("728ab32e-217d-11da-b2a4-000e7bbb2b09")
    ICertProperty : public IDispatch
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE InitializeFromCertificate( 
            /* [in] */ VARIANT_BOOL MachineContext,
            /* [in] */ EncodingType Encoding,
            /* [in] */ __RPC__in BSTR strCertificate) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE InitializeDecode( 
            /* [in] */ EncodingType Encoding,
            /* [in] */ __RPC__in BSTR strEncodedData) = 0;
        
        virtual /* [propget] */ HRESULT STDMETHODCALLTYPE get_PropertyId( 
            /* [retval][out] */ __RPC__out CERTENROLL_PROPERTYID *pValue) = 0;
        
        virtual /* [propput] */ HRESULT STDMETHODCALLTYPE put_PropertyId( 
            /* [in] */ CERTENROLL_PROPERTYID Value) = 0;
        
        virtual /* [propget] */ HRESULT STDMETHODCALLTYPE get_RawData( 
            /* [in] */ EncodingType Encoding,
            /* [retval][out] */ __RPC__deref_out_opt BSTR *pValue) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE RemoveFromCertificate( 
            /* [in] */ VARIANT_BOOL MachineContext,
            /* [in] */ EncodingType Encoding,
            /* [in] */ __RPC__in BSTR strCertificate) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetValueOnCertificate( 
            /* [in] */ VARIANT_BOOL MachineContext,
            /* [in] */ EncodingType Encoding,
            /* [in] */ __RPC__in BSTR strCertificate) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct ICertPropertyVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            ICertProperty * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            ICertProperty * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            ICertProperty * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfoCount )( 
            ICertProperty * This,
            /* [out] */ __RPC__out UINT *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfo )( 
            ICertProperty * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ __RPC__deref_out_opt ITypeInfo **ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetIDsOfNames )( 
            ICertProperty * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [size_is][in] */ __RPC__in_ecount_full(cNames) LPOLESTR *rgszNames,
            /* [range][in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ __RPC__out_ecount_full(cNames) DISPID *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE *Invoke )( 
            ICertProperty * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS *pDispParams,
            /* [out] */ VARIANT *pVarResult,
            /* [out] */ EXCEPINFO *pExcepInfo,
            /* [out] */ UINT *puArgErr);
        
        HRESULT ( STDMETHODCALLTYPE *InitializeFromCertificate )( 
            ICertProperty * This,
            /* [in] */ VARIANT_BOOL MachineContext,
            /* [in] */ EncodingType Encoding,
            /* [in] */ __RPC__in BSTR strCertificate);
        
        HRESULT ( STDMETHODCALLTYPE *InitializeDecode )( 
            ICertProperty * This,
            /* [in] */ EncodingType Encoding,
            /* [in] */ __RPC__in BSTR strEncodedData);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_PropertyId )( 
            ICertProperty * This,
            /* [retval][out] */ __RPC__out CERTENROLL_PROPERTYID *pValue);
        
        /* [propput] */ HRESULT ( STDMETHODCALLTYPE *put_PropertyId )( 
            ICertProperty * This,
            /* [in] */ CERTENROLL_PROPERTYID Value);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_RawData )( 
            ICertProperty * This,
            /* [in] */ EncodingType Encoding,
            /* [retval][out] */ __RPC__deref_out_opt BSTR *pValue);
        
        HRESULT ( STDMETHODCALLTYPE *RemoveFromCertificate )( 
            ICertProperty * This,
            /* [in] */ VARIANT_BOOL MachineContext,
            /* [in] */ EncodingType Encoding,
            /* [in] */ __RPC__in BSTR strCertificate);
        
        HRESULT ( STDMETHODCALLTYPE *SetValueOnCertificate )( 
            ICertProperty * This,
            /* [in] */ VARIANT_BOOL MachineContext,
            /* [in] */ EncodingType Encoding,
            /* [in] */ __RPC__in BSTR strCertificate);
        
        END_INTERFACE
    } ICertPropertyVtbl;

    interface ICertProperty
    {
        CONST_VTBL struct ICertPropertyVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define ICertProperty_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define ICertProperty_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define ICertProperty_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define ICertProperty_GetTypeInfoCount(This,pctinfo)	\
    ( (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo) ) 

#define ICertProperty_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    ( (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo) ) 

#define ICertProperty_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    ( (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId) ) 

#define ICertProperty_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    ( (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr) ) 


#define ICertProperty_InitializeFromCertificate(This,MachineContext,Encoding,strCertificate)	\
    ( (This)->lpVtbl -> InitializeFromCertificate(This,MachineContext,Encoding,strCertificate) ) 

#define ICertProperty_InitializeDecode(This,Encoding,strEncodedData)	\
    ( (This)->lpVtbl -> InitializeDecode(This,Encoding,strEncodedData) ) 

#define ICertProperty_get_PropertyId(This,pValue)	\
    ( (This)->lpVtbl -> get_PropertyId(This,pValue) ) 

#define ICertProperty_put_PropertyId(This,Value)	\
    ( (This)->lpVtbl -> put_PropertyId(This,Value) ) 

#define ICertProperty_get_RawData(This,Encoding,pValue)	\
    ( (This)->lpVtbl -> get_RawData(This,Encoding,pValue) ) 

#define ICertProperty_RemoveFromCertificate(This,MachineContext,Encoding,strCertificate)	\
    ( (This)->lpVtbl -> RemoveFromCertificate(This,MachineContext,Encoding,strCertificate) ) 

#define ICertProperty_SetValueOnCertificate(This,MachineContext,Encoding,strCertificate)	\
    ( (This)->lpVtbl -> SetValueOnCertificate(This,MachineContext,Encoding,strCertificate) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __ICertProperty_INTERFACE_DEFINED__ */


#ifndef __ICertProperties_INTERFACE_DEFINED__
#define __ICertProperties_INTERFACE_DEFINED__

/* interface ICertProperties */
/* [helpstring][dual][uuid][object] */ 


EXTERN_C const IID IID_ICertProperties;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("728ab32f-217d-11da-b2a4-000e7bbb2b09")
    ICertProperties : public IDispatch
    {
    public:
        virtual /* [helpstring][id][propget][custom] */ HRESULT STDMETHODCALLTYPE get_ItemByIndex( 
            /* [in] */ LONG Index,
            /* [retval][out] */ __RPC__deref_out_opt ICertProperty **pVal) = 0;
        
        virtual /* [helpstring][id][propget][custom] */ HRESULT STDMETHODCALLTYPE get_Count( 
            /* [retval][out] */ __RPC__out long *pVal) = 0;
        
        virtual /* [restricted][helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get__NewEnum( 
            /* [retval][out] */ __RPC__deref_out_opt LPUNKNOWN *pVal) = 0;
        
        virtual /* [helpstring][id][custom] */ HRESULT STDMETHODCALLTYPE Add( 
            /* [in] */ __RPC__in_opt ICertProperty *pVal) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE Remove( 
            /* [in] */ LONG Index) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE Clear( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE InitializeFromCertificate( 
            /* [in] */ VARIANT_BOOL MachineContext,
            /* [in] */ EncodingType Encoding,
            /* [in] */ __RPC__in BSTR strCertificate) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct ICertPropertiesVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            ICertProperties * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            ICertProperties * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            ICertProperties * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfoCount )( 
            ICertProperties * This,
            /* [out] */ __RPC__out UINT *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfo )( 
            ICertProperties * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ __RPC__deref_out_opt ITypeInfo **ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetIDsOfNames )( 
            ICertProperties * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [size_is][in] */ __RPC__in_ecount_full(cNames) LPOLESTR *rgszNames,
            /* [range][in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ __RPC__out_ecount_full(cNames) DISPID *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE *Invoke )( 
            ICertProperties * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS *pDispParams,
            /* [out] */ VARIANT *pVarResult,
            /* [out] */ EXCEPINFO *pExcepInfo,
            /* [out] */ UINT *puArgErr);
        
        /* [helpstring][id][propget][custom] */ HRESULT ( STDMETHODCALLTYPE *get_ItemByIndex )( 
            ICertProperties * This,
            /* [in] */ LONG Index,
            /* [retval][out] */ __RPC__deref_out_opt ICertProperty **pVal);
        
        /* [helpstring][id][propget][custom] */ HRESULT ( STDMETHODCALLTYPE *get_Count )( 
            ICertProperties * This,
            /* [retval][out] */ __RPC__out long *pVal);
        
        /* [restricted][helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get__NewEnum )( 
            ICertProperties * This,
            /* [retval][out] */ __RPC__deref_out_opt LPUNKNOWN *pVal);
        
        /* [helpstring][id][custom] */ HRESULT ( STDMETHODCALLTYPE *Add )( 
            ICertProperties * This,
            /* [in] */ __RPC__in_opt ICertProperty *pVal);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *Remove )( 
            ICertProperties * This,
            /* [in] */ LONG Index);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *Clear )( 
            ICertProperties * This);
        
        HRESULT ( STDMETHODCALLTYPE *InitializeFromCertificate )( 
            ICertProperties * This,
            /* [in] */ VARIANT_BOOL MachineContext,
            /* [in] */ EncodingType Encoding,
            /* [in] */ __RPC__in BSTR strCertificate);
        
        END_INTERFACE
    } ICertPropertiesVtbl;

    interface ICertProperties
    {
        CONST_VTBL struct ICertPropertiesVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define ICertProperties_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define ICertProperties_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define ICertProperties_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define ICertProperties_GetTypeInfoCount(This,pctinfo)	\
    ( (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo) ) 

#define ICertProperties_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    ( (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo) ) 

#define ICertProperties_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    ( (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId) ) 

#define ICertProperties_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    ( (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr) ) 


#define ICertProperties_get_ItemByIndex(This,Index,pVal)	\
    ( (This)->lpVtbl -> get_ItemByIndex(This,Index,pVal) ) 

#define ICertProperties_get_Count(This,pVal)	\
    ( (This)->lpVtbl -> get_Count(This,pVal) ) 

#define ICertProperties_get__NewEnum(This,pVal)	\
    ( (This)->lpVtbl -> get__NewEnum(This,pVal) ) 

#define ICertProperties_Add(This,pVal)	\
    ( (This)->lpVtbl -> Add(This,pVal) ) 

#define ICertProperties_Remove(This,Index)	\
    ( (This)->lpVtbl -> Remove(This,Index) ) 

#define ICertProperties_Clear(This)	\
    ( (This)->lpVtbl -> Clear(This) ) 

#define ICertProperties_InitializeFromCertificate(This,MachineContext,Encoding,strCertificate)	\
    ( (This)->lpVtbl -> InitializeFromCertificate(This,MachineContext,Encoding,strCertificate) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __ICertProperties_INTERFACE_DEFINED__ */


#ifndef __ICertPropertyFriendlyName_INTERFACE_DEFINED__
#define __ICertPropertyFriendlyName_INTERFACE_DEFINED__

/* interface ICertPropertyFriendlyName */
/* [helpstring][dual][uuid][object] */ 


EXTERN_C const IID IID_ICertPropertyFriendlyName;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("728ab330-217d-11da-b2a4-000e7bbb2b09")
    ICertPropertyFriendlyName : public ICertProperty
    {
    public:
        virtual /* [custom] */ HRESULT STDMETHODCALLTYPE Initialize( 
            /* [in] */ __RPC__in BSTR strFriendlyName) = 0;
        
        virtual /* [propget] */ HRESULT STDMETHODCALLTYPE get_FriendlyName( 
            /* [retval][out] */ __RPC__deref_out_opt BSTR *pValue) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct ICertPropertyFriendlyNameVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            ICertPropertyFriendlyName * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            ICertPropertyFriendlyName * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            ICertPropertyFriendlyName * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfoCount )( 
            ICertPropertyFriendlyName * This,
            /* [out] */ __RPC__out UINT *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfo )( 
            ICertPropertyFriendlyName * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ __RPC__deref_out_opt ITypeInfo **ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetIDsOfNames )( 
            ICertPropertyFriendlyName * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [size_is][in] */ __RPC__in_ecount_full(cNames) LPOLESTR *rgszNames,
            /* [range][in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ __RPC__out_ecount_full(cNames) DISPID *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE *Invoke )( 
            ICertPropertyFriendlyName * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS *pDispParams,
            /* [out] */ VARIANT *pVarResult,
            /* [out] */ EXCEPINFO *pExcepInfo,
            /* [out] */ UINT *puArgErr);
        
        HRESULT ( STDMETHODCALLTYPE *InitializeFromCertificate )( 
            ICertPropertyFriendlyName * This,
            /* [in] */ VARIANT_BOOL MachineContext,
            /* [in] */ EncodingType Encoding,
            /* [in] */ __RPC__in BSTR strCertificate);
        
        HRESULT ( STDMETHODCALLTYPE *InitializeDecode )( 
            ICertPropertyFriendlyName * This,
            /* [in] */ EncodingType Encoding,
            /* [in] */ __RPC__in BSTR strEncodedData);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_PropertyId )( 
            ICertPropertyFriendlyName * This,
            /* [retval][out] */ __RPC__out CERTENROLL_PROPERTYID *pValue);
        
        /* [propput] */ HRESULT ( STDMETHODCALLTYPE *put_PropertyId )( 
            ICertPropertyFriendlyName * This,
            /* [in] */ CERTENROLL_PROPERTYID Value);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_RawData )( 
            ICertPropertyFriendlyName * This,
            /* [in] */ EncodingType Encoding,
            /* [retval][out] */ __RPC__deref_out_opt BSTR *pValue);
        
        HRESULT ( STDMETHODCALLTYPE *RemoveFromCertificate )( 
            ICertPropertyFriendlyName * This,
            /* [in] */ VARIANT_BOOL MachineContext,
            /* [in] */ EncodingType Encoding,
            /* [in] */ __RPC__in BSTR strCertificate);
        
        HRESULT ( STDMETHODCALLTYPE *SetValueOnCertificate )( 
            ICertPropertyFriendlyName * This,
            /* [in] */ VARIANT_BOOL MachineContext,
            /* [in] */ EncodingType Encoding,
            /* [in] */ __RPC__in BSTR strCertificate);
        
        /* [custom] */ HRESULT ( STDMETHODCALLTYPE *Initialize )( 
            ICertPropertyFriendlyName * This,
            /* [in] */ __RPC__in BSTR strFriendlyName);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_FriendlyName )( 
            ICertPropertyFriendlyName * This,
            /* [retval][out] */ __RPC__deref_out_opt BSTR *pValue);
        
        END_INTERFACE
    } ICertPropertyFriendlyNameVtbl;

    interface ICertPropertyFriendlyName
    {
        CONST_VTBL struct ICertPropertyFriendlyNameVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define ICertPropertyFriendlyName_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define ICertPropertyFriendlyName_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define ICertPropertyFriendlyName_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define ICertPropertyFriendlyName_GetTypeInfoCount(This,pctinfo)	\
    ( (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo) ) 

#define ICertPropertyFriendlyName_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    ( (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo) ) 

#define ICertPropertyFriendlyName_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    ( (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId) ) 

#define ICertPropertyFriendlyName_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    ( (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr) ) 


#define ICertPropertyFriendlyName_InitializeFromCertificate(This,MachineContext,Encoding,strCertificate)	\
    ( (This)->lpVtbl -> InitializeFromCertificate(This,MachineContext,Encoding,strCertificate) ) 

#define ICertPropertyFriendlyName_InitializeDecode(This,Encoding,strEncodedData)	\
    ( (This)->lpVtbl -> InitializeDecode(This,Encoding,strEncodedData) ) 

#define ICertPropertyFriendlyName_get_PropertyId(This,pValue)	\
    ( (This)->lpVtbl -> get_PropertyId(This,pValue) ) 

#define ICertPropertyFriendlyName_put_PropertyId(This,Value)	\
    ( (This)->lpVtbl -> put_PropertyId(This,Value) ) 

#define ICertPropertyFriendlyName_get_RawData(This,Encoding,pValue)	\
    ( (This)->lpVtbl -> get_RawData(This,Encoding,pValue) ) 

#define ICertPropertyFriendlyName_RemoveFromCertificate(This,MachineContext,Encoding,strCertificate)	\
    ( (This)->lpVtbl -> RemoveFromCertificate(This,MachineContext,Encoding,strCertificate) ) 

#define ICertPropertyFriendlyName_SetValueOnCertificate(This,MachineContext,Encoding,strCertificate)	\
    ( (This)->lpVtbl -> SetValueOnCertificate(This,MachineContext,Encoding,strCertificate) ) 


#define ICertPropertyFriendlyName_Initialize(This,strFriendlyName)	\
    ( (This)->lpVtbl -> Initialize(This,strFriendlyName) ) 

#define ICertPropertyFriendlyName_get_FriendlyName(This,pValue)	\
    ( (This)->lpVtbl -> get_FriendlyName(This,pValue) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __ICertPropertyFriendlyName_INTERFACE_DEFINED__ */


#ifndef __ICertPropertyDescription_INTERFACE_DEFINED__
#define __ICertPropertyDescription_INTERFACE_DEFINED__

/* interface ICertPropertyDescription */
/* [helpstring][dual][uuid][object] */ 


EXTERN_C const IID IID_ICertPropertyDescription;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("728ab331-217d-11da-b2a4-000e7bbb2b09")
    ICertPropertyDescription : public ICertProperty
    {
    public:
        virtual /* [custom] */ HRESULT STDMETHODCALLTYPE Initialize( 
            /* [in] */ __RPC__in BSTR strDescription) = 0;
        
        virtual /* [propget] */ HRESULT STDMETHODCALLTYPE get_Description( 
            /* [retval][out] */ __RPC__deref_out_opt BSTR *pValue) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct ICertPropertyDescriptionVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            ICertPropertyDescription * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            ICertPropertyDescription * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            ICertPropertyDescription * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfoCount )( 
            ICertPropertyDescription * This,
            /* [out] */ __RPC__out UINT *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfo )( 
            ICertPropertyDescription * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ __RPC__deref_out_opt ITypeInfo **ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetIDsOfNames )( 
            ICertPropertyDescription * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [size_is][in] */ __RPC__in_ecount_full(cNames) LPOLESTR *rgszNames,
            /* [range][in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ __RPC__out_ecount_full(cNames) DISPID *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE *Invoke )( 
            ICertPropertyDescription * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS *pDispParams,
            /* [out] */ VARIANT *pVarResult,
            /* [out] */ EXCEPINFO *pExcepInfo,
            /* [out] */ UINT *puArgErr);
        
        HRESULT ( STDMETHODCALLTYPE *InitializeFromCertificate )( 
            ICertPropertyDescription * This,
            /* [in] */ VARIANT_BOOL MachineContext,
            /* [in] */ EncodingType Encoding,
            /* [in] */ __RPC__in BSTR strCertificate);
        
        HRESULT ( STDMETHODCALLTYPE *InitializeDecode )( 
            ICertPropertyDescription * This,
            /* [in] */ EncodingType Encoding,
            /* [in] */ __RPC__in BSTR strEncodedData);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_PropertyId )( 
            ICertPropertyDescription * This,
            /* [retval][out] */ __RPC__out CERTENROLL_PROPERTYID *pValue);
        
        /* [propput] */ HRESULT ( STDMETHODCALLTYPE *put_PropertyId )( 
            ICertPropertyDescription * This,
            /* [in] */ CERTENROLL_PROPERTYID Value);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_RawData )( 
            ICertPropertyDescription * This,
            /* [in] */ EncodingType Encoding,
            /* [retval][out] */ __RPC__deref_out_opt BSTR *pValue);
        
        HRESULT ( STDMETHODCALLTYPE *RemoveFromCertificate )( 
            ICertPropertyDescription * This,
            /* [in] */ VARIANT_BOOL MachineContext,
            /* [in] */ EncodingType Encoding,
            /* [in] */ __RPC__in BSTR strCertificate);
        
        HRESULT ( STDMETHODCALLTYPE *SetValueOnCertificate )( 
            ICertPropertyDescription * This,
            /* [in] */ VARIANT_BOOL MachineContext,
            /* [in] */ EncodingType Encoding,
            /* [in] */ __RPC__in BSTR strCertificate);
        
        /* [custom] */ HRESULT ( STDMETHODCALLTYPE *Initialize )( 
            ICertPropertyDescription * This,
            /* [in] */ __RPC__in BSTR strDescription);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_Description )( 
            ICertPropertyDescription * This,
            /* [retval][out] */ __RPC__deref_out_opt BSTR *pValue);
        
        END_INTERFACE
    } ICertPropertyDescriptionVtbl;

    interface ICertPropertyDescription
    {
        CONST_VTBL struct ICertPropertyDescriptionVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define ICertPropertyDescription_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define ICertPropertyDescription_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define ICertPropertyDescription_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define ICertPropertyDescription_GetTypeInfoCount(This,pctinfo)	\
    ( (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo) ) 

#define ICertPropertyDescription_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    ( (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo) ) 

#define ICertPropertyDescription_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    ( (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId) ) 

#define ICertPropertyDescription_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    ( (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr) ) 


#define ICertPropertyDescription_InitializeFromCertificate(This,MachineContext,Encoding,strCertificate)	\
    ( (This)->lpVtbl -> InitializeFromCertificate(This,MachineContext,Encoding,strCertificate) ) 

#define ICertPropertyDescription_InitializeDecode(This,Encoding,strEncodedData)	\
    ( (This)->lpVtbl -> InitializeDecode(This,Encoding,strEncodedData) ) 

#define ICertPropertyDescription_get_PropertyId(This,pValue)	\
    ( (This)->lpVtbl -> get_PropertyId(This,pValue) ) 

#define ICertPropertyDescription_put_PropertyId(This,Value)	\
    ( (This)->lpVtbl -> put_PropertyId(This,Value) ) 

#define ICertPropertyDescription_get_RawData(This,Encoding,pValue)	\
    ( (This)->lpVtbl -> get_RawData(This,Encoding,pValue) ) 

#define ICertPropertyDescription_RemoveFromCertificate(This,MachineContext,Encoding,strCertificate)	\
    ( (This)->lpVtbl -> RemoveFromCertificate(This,MachineContext,Encoding,strCertificate) ) 

#define ICertPropertyDescription_SetValueOnCertificate(This,MachineContext,Encoding,strCertificate)	\
    ( (This)->lpVtbl -> SetValueOnCertificate(This,MachineContext,Encoding,strCertificate) ) 


#define ICertPropertyDescription_Initialize(This,strDescription)	\
    ( (This)->lpVtbl -> Initialize(This,strDescription) ) 

#define ICertPropertyDescription_get_Description(This,pValue)	\
    ( (This)->lpVtbl -> get_Description(This,pValue) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __ICertPropertyDescription_INTERFACE_DEFINED__ */


#ifndef __ICertPropertyAutoEnroll_INTERFACE_DEFINED__
#define __ICertPropertyAutoEnroll_INTERFACE_DEFINED__

/* interface ICertPropertyAutoEnroll */
/* [helpstring][dual][uuid][object] */ 


EXTERN_C const IID IID_ICertPropertyAutoEnroll;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("728ab332-217d-11da-b2a4-000e7bbb2b09")
    ICertPropertyAutoEnroll : public ICertProperty
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE Initialize( 
            /* [in] */ __RPC__in BSTR strTemplateName) = 0;
        
        virtual /* [propget] */ HRESULT STDMETHODCALLTYPE get_TemplateName( 
            /* [retval][out] */ __RPC__deref_out_opt BSTR *pValue) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct ICertPropertyAutoEnrollVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            ICertPropertyAutoEnroll * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            ICertPropertyAutoEnroll * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            ICertPropertyAutoEnroll * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfoCount )( 
            ICertPropertyAutoEnroll * This,
            /* [out] */ __RPC__out UINT *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfo )( 
            ICertPropertyAutoEnroll * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ __RPC__deref_out_opt ITypeInfo **ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetIDsOfNames )( 
            ICertPropertyAutoEnroll * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [size_is][in] */ __RPC__in_ecount_full(cNames) LPOLESTR *rgszNames,
            /* [range][in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ __RPC__out_ecount_full(cNames) DISPID *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE *Invoke )( 
            ICertPropertyAutoEnroll * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS *pDispParams,
            /* [out] */ VARIANT *pVarResult,
            /* [out] */ EXCEPINFO *pExcepInfo,
            /* [out] */ UINT *puArgErr);
        
        HRESULT ( STDMETHODCALLTYPE *InitializeFromCertificate )( 
            ICertPropertyAutoEnroll * This,
            /* [in] */ VARIANT_BOOL MachineContext,
            /* [in] */ EncodingType Encoding,
            /* [in] */ __RPC__in BSTR strCertificate);
        
        HRESULT ( STDMETHODCALLTYPE *InitializeDecode )( 
            ICertPropertyAutoEnroll * This,
            /* [in] */ EncodingType Encoding,
            /* [in] */ __RPC__in BSTR strEncodedData);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_PropertyId )( 
            ICertPropertyAutoEnroll * This,
            /* [retval][out] */ __RPC__out CERTENROLL_PROPERTYID *pValue);
        
        /* [propput] */ HRESULT ( STDMETHODCALLTYPE *put_PropertyId )( 
            ICertPropertyAutoEnroll * This,
            /* [in] */ CERTENROLL_PROPERTYID Value);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_RawData )( 
            ICertPropertyAutoEnroll * This,
            /* [in] */ EncodingType Encoding,
            /* [retval][out] */ __RPC__deref_out_opt BSTR *pValue);
        
        HRESULT ( STDMETHODCALLTYPE *RemoveFromCertificate )( 
            ICertPropertyAutoEnroll * This,
            /* [in] */ VARIANT_BOOL MachineContext,
            /* [in] */ EncodingType Encoding,
            /* [in] */ __RPC__in BSTR strCertificate);
        
        HRESULT ( STDMETHODCALLTYPE *SetValueOnCertificate )( 
            ICertPropertyAutoEnroll * This,
            /* [in] */ VARIANT_BOOL MachineContext,
            /* [in] */ EncodingType Encoding,
            /* [in] */ __RPC__in BSTR strCertificate);
        
        HRESULT ( STDMETHODCALLTYPE *Initialize )( 
            ICertPropertyAutoEnroll * This,
            /* [in] */ __RPC__in BSTR strTemplateName);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_TemplateName )( 
            ICertPropertyAutoEnroll * This,
            /* [retval][out] */ __RPC__deref_out_opt BSTR *pValue);
        
        END_INTERFACE
    } ICertPropertyAutoEnrollVtbl;

    interface ICertPropertyAutoEnroll
    {
        CONST_VTBL struct ICertPropertyAutoEnrollVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define ICertPropertyAutoEnroll_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define ICertPropertyAutoEnroll_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define ICertPropertyAutoEnroll_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define ICertPropertyAutoEnroll_GetTypeInfoCount(This,pctinfo)	\
    ( (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo) ) 

#define ICertPropertyAutoEnroll_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    ( (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo) ) 

#define ICertPropertyAutoEnroll_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    ( (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId) ) 

#define ICertPropertyAutoEnroll_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    ( (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr) ) 


#define ICertPropertyAutoEnroll_InitializeFromCertificate(This,MachineContext,Encoding,strCertificate)	\
    ( (This)->lpVtbl -> InitializeFromCertificate(This,MachineContext,Encoding,strCertificate) ) 

#define ICertPropertyAutoEnroll_InitializeDecode(This,Encoding,strEncodedData)	\
    ( (This)->lpVtbl -> InitializeDecode(This,Encoding,strEncodedData) ) 

#define ICertPropertyAutoEnroll_get_PropertyId(This,pValue)	\
    ( (This)->lpVtbl -> get_PropertyId(This,pValue) ) 

#define ICertPropertyAutoEnroll_put_PropertyId(This,Value)	\
    ( (This)->lpVtbl -> put_PropertyId(This,Value) ) 

#define ICertPropertyAutoEnroll_get_RawData(This,Encoding,pValue)	\
    ( (This)->lpVtbl -> get_RawData(This,Encoding,pValue) ) 

#define ICertPropertyAutoEnroll_RemoveFromCertificate(This,MachineContext,Encoding,strCertificate)	\
    ( (This)->lpVtbl -> RemoveFromCertificate(This,MachineContext,Encoding,strCertificate) ) 

#define ICertPropertyAutoEnroll_SetValueOnCertificate(This,MachineContext,Encoding,strCertificate)	\
    ( (This)->lpVtbl -> SetValueOnCertificate(This,MachineContext,Encoding,strCertificate) ) 


#define ICertPropertyAutoEnroll_Initialize(This,strTemplateName)	\
    ( (This)->lpVtbl -> Initialize(This,strTemplateName) ) 

#define ICertPropertyAutoEnroll_get_TemplateName(This,pValue)	\
    ( (This)->lpVtbl -> get_TemplateName(This,pValue) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __ICertPropertyAutoEnroll_INTERFACE_DEFINED__ */


#ifndef __ICertPropertyRequestOriginator_INTERFACE_DEFINED__
#define __ICertPropertyRequestOriginator_INTERFACE_DEFINED__

/* interface ICertPropertyRequestOriginator */
/* [helpstring][dual][uuid][object] */ 


EXTERN_C const IID IID_ICertPropertyRequestOriginator;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("728ab333-217d-11da-b2a4-000e7bbb2b09")
    ICertPropertyRequestOriginator : public ICertProperty
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE Initialize( 
            /* [in] */ __RPC__in BSTR strRequestOriginator) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE InitializeFromLocalRequestOriginator( void) = 0;
        
        virtual /* [propget] */ HRESULT STDMETHODCALLTYPE get_RequestOriginator( 
            /* [retval][out] */ __RPC__deref_out_opt BSTR *pValue) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct ICertPropertyRequestOriginatorVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            ICertPropertyRequestOriginator * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            ICertPropertyRequestOriginator * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            ICertPropertyRequestOriginator * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfoCount )( 
            ICertPropertyRequestOriginator * This,
            /* [out] */ __RPC__out UINT *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfo )( 
            ICertPropertyRequestOriginator * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ __RPC__deref_out_opt ITypeInfo **ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetIDsOfNames )( 
            ICertPropertyRequestOriginator * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [size_is][in] */ __RPC__in_ecount_full(cNames) LPOLESTR *rgszNames,
            /* [range][in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ __RPC__out_ecount_full(cNames) DISPID *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE *Invoke )( 
            ICertPropertyRequestOriginator * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS *pDispParams,
            /* [out] */ VARIANT *pVarResult,
            /* [out] */ EXCEPINFO *pExcepInfo,
            /* [out] */ UINT *puArgErr);
        
        HRESULT ( STDMETHODCALLTYPE *InitializeFromCertificate )( 
            ICertPropertyRequestOriginator * This,
            /* [in] */ VARIANT_BOOL MachineContext,
            /* [in] */ EncodingType Encoding,
            /* [in] */ __RPC__in BSTR strCertificate);
        
        HRESULT ( STDMETHODCALLTYPE *InitializeDecode )( 
            ICertPropertyRequestOriginator * This,
            /* [in] */ EncodingType Encoding,
            /* [in] */ __RPC__in BSTR strEncodedData);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_PropertyId )( 
            ICertPropertyRequestOriginator * This,
            /* [retval][out] */ __RPC__out CERTENROLL_PROPERTYID *pValue);
        
        /* [propput] */ HRESULT ( STDMETHODCALLTYPE *put_PropertyId )( 
            ICertPropertyRequestOriginator * This,
            /* [in] */ CERTENROLL_PROPERTYID Value);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_RawData )( 
            ICertPropertyRequestOriginator * This,
            /* [in] */ EncodingType Encoding,
            /* [retval][out] */ __RPC__deref_out_opt BSTR *pValue);
        
        HRESULT ( STDMETHODCALLTYPE *RemoveFromCertificate )( 
            ICertPropertyRequestOriginator * This,
            /* [in] */ VARIANT_BOOL MachineContext,
            /* [in] */ EncodingType Encoding,
            /* [in] */ __RPC__in BSTR strCertificate);
        
        HRESULT ( STDMETHODCALLTYPE *SetValueOnCertificate )( 
            ICertPropertyRequestOriginator * This,
            /* [in] */ VARIANT_BOOL MachineContext,
            /* [in] */ EncodingType Encoding,
            /* [in] */ __RPC__in BSTR strCertificate);
        
        HRESULT ( STDMETHODCALLTYPE *Initialize )( 
            ICertPropertyRequestOriginator * This,
            /* [in] */ __RPC__in BSTR strRequestOriginator);
        
        HRESULT ( STDMETHODCALLTYPE *InitializeFromLocalRequestOriginator )( 
            ICertPropertyRequestOriginator * This);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_RequestOriginator )( 
            ICertPropertyRequestOriginator * This,
            /* [retval][out] */ __RPC__deref_out_opt BSTR *pValue);
        
        END_INTERFACE
    } ICertPropertyRequestOriginatorVtbl;

    interface ICertPropertyRequestOriginator
    {
        CONST_VTBL struct ICertPropertyRequestOriginatorVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define ICertPropertyRequestOriginator_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define ICertPropertyRequestOriginator_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define ICertPropertyRequestOriginator_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define ICertPropertyRequestOriginator_GetTypeInfoCount(This,pctinfo)	\
    ( (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo) ) 

#define ICertPropertyRequestOriginator_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    ( (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo) ) 

#define ICertPropertyRequestOriginator_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    ( (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId) ) 

#define ICertPropertyRequestOriginator_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    ( (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr) ) 


#define ICertPropertyRequestOriginator_InitializeFromCertificate(This,MachineContext,Encoding,strCertificate)	\
    ( (This)->lpVtbl -> InitializeFromCertificate(This,MachineContext,Encoding,strCertificate) ) 

#define ICertPropertyRequestOriginator_InitializeDecode(This,Encoding,strEncodedData)	\
    ( (This)->lpVtbl -> InitializeDecode(This,Encoding,strEncodedData) ) 

#define ICertPropertyRequestOriginator_get_PropertyId(This,pValue)	\
    ( (This)->lpVtbl -> get_PropertyId(This,pValue) ) 

#define ICertPropertyRequestOriginator_put_PropertyId(This,Value)	\
    ( (This)->lpVtbl -> put_PropertyId(This,Value) ) 

#define ICertPropertyRequestOriginator_get_RawData(This,Encoding,pValue)	\
    ( (This)->lpVtbl -> get_RawData(This,Encoding,pValue) ) 

#define ICertPropertyRequestOriginator_RemoveFromCertificate(This,MachineContext,Encoding,strCertificate)	\
    ( (This)->lpVtbl -> RemoveFromCertificate(This,MachineContext,Encoding,strCertificate) ) 

#define ICertPropertyRequestOriginator_SetValueOnCertificate(This,MachineContext,Encoding,strCertificate)	\
    ( (This)->lpVtbl -> SetValueOnCertificate(This,MachineContext,Encoding,strCertificate) ) 


#define ICertPropertyRequestOriginator_Initialize(This,strRequestOriginator)	\
    ( (This)->lpVtbl -> Initialize(This,strRequestOriginator) ) 

#define ICertPropertyRequestOriginator_InitializeFromLocalRequestOriginator(This)	\
    ( (This)->lpVtbl -> InitializeFromLocalRequestOriginator(This) ) 

#define ICertPropertyRequestOriginator_get_RequestOriginator(This,pValue)	\
    ( (This)->lpVtbl -> get_RequestOriginator(This,pValue) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __ICertPropertyRequestOriginator_INTERFACE_DEFINED__ */


#ifndef __ICertPropertySHA1Hash_INTERFACE_DEFINED__
#define __ICertPropertySHA1Hash_INTERFACE_DEFINED__

/* interface ICertPropertySHA1Hash */
/* [helpstring][dual][uuid][object] */ 


EXTERN_C const IID IID_ICertPropertySHA1Hash;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("728ab334-217d-11da-b2a4-000e7bbb2b09")
    ICertPropertySHA1Hash : public ICertProperty
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE Initialize( 
            /* [in] */ EncodingType Encoding,
            /* [in] */ __RPC__in BSTR strRenewalValue) = 0;
        
        virtual /* [propget] */ HRESULT STDMETHODCALLTYPE get_SHA1Hash( 
            /* [in] */ EncodingType Encoding,
            /* [retval][out] */ __RPC__deref_out_opt BSTR *pValue) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct ICertPropertySHA1HashVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            ICertPropertySHA1Hash * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            ICertPropertySHA1Hash * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            ICertPropertySHA1Hash * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfoCount )( 
            ICertPropertySHA1Hash * This,
            /* [out] */ __RPC__out UINT *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfo )( 
            ICertPropertySHA1Hash * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ __RPC__deref_out_opt ITypeInfo **ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetIDsOfNames )( 
            ICertPropertySHA1Hash * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [size_is][in] */ __RPC__in_ecount_full(cNames) LPOLESTR *rgszNames,
            /* [range][in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ __RPC__out_ecount_full(cNames) DISPID *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE *Invoke )( 
            ICertPropertySHA1Hash * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS *pDispParams,
            /* [out] */ VARIANT *pVarResult,
            /* [out] */ EXCEPINFO *pExcepInfo,
            /* [out] */ UINT *puArgErr);
        
        HRESULT ( STDMETHODCALLTYPE *InitializeFromCertificate )( 
            ICertPropertySHA1Hash * This,
            /* [in] */ VARIANT_BOOL MachineContext,
            /* [in] */ EncodingType Encoding,
            /* [in] */ __RPC__in BSTR strCertificate);
        
        HRESULT ( STDMETHODCALLTYPE *InitializeDecode )( 
            ICertPropertySHA1Hash * This,
            /* [in] */ EncodingType Encoding,
            /* [in] */ __RPC__in BSTR strEncodedData);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_PropertyId )( 
            ICertPropertySHA1Hash * This,
            /* [retval][out] */ __RPC__out CERTENROLL_PROPERTYID *pValue);
        
        /* [propput] */ HRESULT ( STDMETHODCALLTYPE *put_PropertyId )( 
            ICertPropertySHA1Hash * This,
            /* [in] */ CERTENROLL_PROPERTYID Value);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_RawData )( 
            ICertPropertySHA1Hash * This,
            /* [in] */ EncodingType Encoding,
            /* [retval][out] */ __RPC__deref_out_opt BSTR *pValue);
        
        HRESULT ( STDMETHODCALLTYPE *RemoveFromCertificate )( 
            ICertPropertySHA1Hash * This,
            /* [in] */ VARIANT_BOOL MachineContext,
            /* [in] */ EncodingType Encoding,
            /* [in] */ __RPC__in BSTR strCertificate);
        
        HRESULT ( STDMETHODCALLTYPE *SetValueOnCertificate )( 
            ICertPropertySHA1Hash * This,
            /* [in] */ VARIANT_BOOL MachineContext,
            /* [in] */ EncodingType Encoding,
            /* [in] */ __RPC__in BSTR strCertificate);
        
        HRESULT ( STDMETHODCALLTYPE *Initialize )( 
            ICertPropertySHA1Hash * This,
            /* [in] */ EncodingType Encoding,
            /* [in] */ __RPC__in BSTR strRenewalValue);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_SHA1Hash )( 
            ICertPropertySHA1Hash * This,
            /* [in] */ EncodingType Encoding,
            /* [retval][out] */ __RPC__deref_out_opt BSTR *pValue);
        
        END_INTERFACE
    } ICertPropertySHA1HashVtbl;

    interface ICertPropertySHA1Hash
    {
        CONST_VTBL struct ICertPropertySHA1HashVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define ICertPropertySHA1Hash_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define ICertPropertySHA1Hash_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define ICertPropertySHA1Hash_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define ICertPropertySHA1Hash_GetTypeInfoCount(This,pctinfo)	\
    ( (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo) ) 

#define ICertPropertySHA1Hash_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    ( (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo) ) 

#define ICertPropertySHA1Hash_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    ( (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId) ) 

#define ICertPropertySHA1Hash_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    ( (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr) ) 


#define ICertPropertySHA1Hash_InitializeFromCertificate(This,MachineContext,Encoding,strCertificate)	\
    ( (This)->lpVtbl -> InitializeFromCertificate(This,MachineContext,Encoding,strCertificate) ) 

#define ICertPropertySHA1Hash_InitializeDecode(This,Encoding,strEncodedData)	\
    ( (This)->lpVtbl -> InitializeDecode(This,Encoding,strEncodedData) ) 

#define ICertPropertySHA1Hash_get_PropertyId(This,pValue)	\
    ( (This)->lpVtbl -> get_PropertyId(This,pValue) ) 

#define ICertPropertySHA1Hash_put_PropertyId(This,Value)	\
    ( (This)->lpVtbl -> put_PropertyId(This,Value) ) 

#define ICertPropertySHA1Hash_get_RawData(This,Encoding,pValue)	\
    ( (This)->lpVtbl -> get_RawData(This,Encoding,pValue) ) 

#define ICertPropertySHA1Hash_RemoveFromCertificate(This,MachineContext,Encoding,strCertificate)	\
    ( (This)->lpVtbl -> RemoveFromCertificate(This,MachineContext,Encoding,strCertificate) ) 

#define ICertPropertySHA1Hash_SetValueOnCertificate(This,MachineContext,Encoding,strCertificate)	\
    ( (This)->lpVtbl -> SetValueOnCertificate(This,MachineContext,Encoding,strCertificate) ) 


#define ICertPropertySHA1Hash_Initialize(This,Encoding,strRenewalValue)	\
    ( (This)->lpVtbl -> Initialize(This,Encoding,strRenewalValue) ) 

#define ICertPropertySHA1Hash_get_SHA1Hash(This,Encoding,pValue)	\
    ( (This)->lpVtbl -> get_SHA1Hash(This,Encoding,pValue) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __ICertPropertySHA1Hash_INTERFACE_DEFINED__ */


#ifndef __ICertPropertyKeyProvInfo_INTERFACE_DEFINED__
#define __ICertPropertyKeyProvInfo_INTERFACE_DEFINED__

/* interface ICertPropertyKeyProvInfo */
/* [helpstring][dual][uuid][object] */ 


EXTERN_C const IID IID_ICertPropertyKeyProvInfo;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("728ab336-217d-11da-b2a4-000e7bbb2b09")
    ICertPropertyKeyProvInfo : public ICertProperty
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE Initialize( 
            /* [in] */ __RPC__in_opt IX509PrivateKey *pValue) = 0;
        
        virtual /* [propget] */ HRESULT STDMETHODCALLTYPE get_PrivateKey( 
            /* [retval][out] */ __RPC__deref_out_opt IX509PrivateKey **ppValue) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct ICertPropertyKeyProvInfoVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            ICertPropertyKeyProvInfo * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            ICertPropertyKeyProvInfo * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            ICertPropertyKeyProvInfo * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfoCount )( 
            ICertPropertyKeyProvInfo * This,
            /* [out] */ __RPC__out UINT *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfo )( 
            ICertPropertyKeyProvInfo * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ __RPC__deref_out_opt ITypeInfo **ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetIDsOfNames )( 
            ICertPropertyKeyProvInfo * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [size_is][in] */ __RPC__in_ecount_full(cNames) LPOLESTR *rgszNames,
            /* [range][in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ __RPC__out_ecount_full(cNames) DISPID *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE *Invoke )( 
            ICertPropertyKeyProvInfo * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS *pDispParams,
            /* [out] */ VARIANT *pVarResult,
            /* [out] */ EXCEPINFO *pExcepInfo,
            /* [out] */ UINT *puArgErr);
        
        HRESULT ( STDMETHODCALLTYPE *InitializeFromCertificate )( 
            ICertPropertyKeyProvInfo * This,
            /* [in] */ VARIANT_BOOL MachineContext,
            /* [in] */ EncodingType Encoding,
            /* [in] */ __RPC__in BSTR strCertificate);
        
        HRESULT ( STDMETHODCALLTYPE *InitializeDecode )( 
            ICertPropertyKeyProvInfo * This,
            /* [in] */ EncodingType Encoding,
            /* [in] */ __RPC__in BSTR strEncodedData);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_PropertyId )( 
            ICertPropertyKeyProvInfo * This,
            /* [retval][out] */ __RPC__out CERTENROLL_PROPERTYID *pValue);
        
        /* [propput] */ HRESULT ( STDMETHODCALLTYPE *put_PropertyId )( 
            ICertPropertyKeyProvInfo * This,
            /* [in] */ CERTENROLL_PROPERTYID Value);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_RawData )( 
            ICertPropertyKeyProvInfo * This,
            /* [in] */ EncodingType Encoding,
            /* [retval][out] */ __RPC__deref_out_opt BSTR *pValue);
        
        HRESULT ( STDMETHODCALLTYPE *RemoveFromCertificate )( 
            ICertPropertyKeyProvInfo * This,
            /* [in] */ VARIANT_BOOL MachineContext,
            /* [in] */ EncodingType Encoding,
            /* [in] */ __RPC__in BSTR strCertificate);
        
        HRESULT ( STDMETHODCALLTYPE *SetValueOnCertificate )( 
            ICertPropertyKeyProvInfo * This,
            /* [in] */ VARIANT_BOOL MachineContext,
            /* [in] */ EncodingType Encoding,
            /* [in] */ __RPC__in BSTR strCertificate);
        
        HRESULT ( STDMETHODCALLTYPE *Initialize )( 
            ICertPropertyKeyProvInfo * This,
            /* [in] */ __RPC__in_opt IX509PrivateKey *pValue);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_PrivateKey )( 
            ICertPropertyKeyProvInfo * This,
            /* [retval][out] */ __RPC__deref_out_opt IX509PrivateKey **ppValue);
        
        END_INTERFACE
    } ICertPropertyKeyProvInfoVtbl;

    interface ICertPropertyKeyProvInfo
    {
        CONST_VTBL struct ICertPropertyKeyProvInfoVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define ICertPropertyKeyProvInfo_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define ICertPropertyKeyProvInfo_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define ICertPropertyKeyProvInfo_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define ICertPropertyKeyProvInfo_GetTypeInfoCount(This,pctinfo)	\
    ( (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo) ) 

#define ICertPropertyKeyProvInfo_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    ( (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo) ) 

#define ICertPropertyKeyProvInfo_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    ( (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId) ) 

#define ICertPropertyKeyProvInfo_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    ( (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr) ) 


#define ICertPropertyKeyProvInfo_InitializeFromCertificate(This,MachineContext,Encoding,strCertificate)	\
    ( (This)->lpVtbl -> InitializeFromCertificate(This,MachineContext,Encoding,strCertificate) ) 

#define ICertPropertyKeyProvInfo_InitializeDecode(This,Encoding,strEncodedData)	\
    ( (This)->lpVtbl -> InitializeDecode(This,Encoding,strEncodedData) ) 

#define ICertPropertyKeyProvInfo_get_PropertyId(This,pValue)	\
    ( (This)->lpVtbl -> get_PropertyId(This,pValue) ) 

#define ICertPropertyKeyProvInfo_put_PropertyId(This,Value)	\
    ( (This)->lpVtbl -> put_PropertyId(This,Value) ) 

#define ICertPropertyKeyProvInfo_get_RawData(This,Encoding,pValue)	\
    ( (This)->lpVtbl -> get_RawData(This,Encoding,pValue) ) 

#define ICertPropertyKeyProvInfo_RemoveFromCertificate(This,MachineContext,Encoding,strCertificate)	\
    ( (This)->lpVtbl -> RemoveFromCertificate(This,MachineContext,Encoding,strCertificate) ) 

#define ICertPropertyKeyProvInfo_SetValueOnCertificate(This,MachineContext,Encoding,strCertificate)	\
    ( (This)->lpVtbl -> SetValueOnCertificate(This,MachineContext,Encoding,strCertificate) ) 


#define ICertPropertyKeyProvInfo_Initialize(This,pValue)	\
    ( (This)->lpVtbl -> Initialize(This,pValue) ) 

#define ICertPropertyKeyProvInfo_get_PrivateKey(This,ppValue)	\
    ( (This)->lpVtbl -> get_PrivateKey(This,ppValue) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __ICertPropertyKeyProvInfo_INTERFACE_DEFINED__ */


#ifndef __ICertPropertyArchived_INTERFACE_DEFINED__
#define __ICertPropertyArchived_INTERFACE_DEFINED__

/* interface ICertPropertyArchived */
/* [helpstring][dual][uuid][object] */ 


EXTERN_C const IID IID_ICertPropertyArchived;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("728ab337-217d-11da-b2a4-000e7bbb2b09")
    ICertPropertyArchived : public ICertProperty
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE Initialize( 
            /* [in] */ VARIANT_BOOL ArchivedValue) = 0;
        
        virtual /* [propget] */ HRESULT STDMETHODCALLTYPE get_Archived( 
            /* [retval][out] */ __RPC__out VARIANT_BOOL *pValue) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct ICertPropertyArchivedVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            ICertPropertyArchived * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            ICertPropertyArchived * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            ICertPropertyArchived * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfoCount )( 
            ICertPropertyArchived * This,
            /* [out] */ __RPC__out UINT *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfo )( 
            ICertPropertyArchived * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ __RPC__deref_out_opt ITypeInfo **ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetIDsOfNames )( 
            ICertPropertyArchived * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [size_is][in] */ __RPC__in_ecount_full(cNames) LPOLESTR *rgszNames,
            /* [range][in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ __RPC__out_ecount_full(cNames) DISPID *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE *Invoke )( 
            ICertPropertyArchived * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS *pDispParams,
            /* [out] */ VARIANT *pVarResult,
            /* [out] */ EXCEPINFO *pExcepInfo,
            /* [out] */ UINT *puArgErr);
        
        HRESULT ( STDMETHODCALLTYPE *InitializeFromCertificate )( 
            ICertPropertyArchived * This,
            /* [in] */ VARIANT_BOOL MachineContext,
            /* [in] */ EncodingType Encoding,
            /* [in] */ __RPC__in BSTR strCertificate);
        
        HRESULT ( STDMETHODCALLTYPE *InitializeDecode )( 
            ICertPropertyArchived * This,
            /* [in] */ EncodingType Encoding,
            /* [in] */ __RPC__in BSTR strEncodedData);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_PropertyId )( 
            ICertPropertyArchived * This,
            /* [retval][out] */ __RPC__out CERTENROLL_PROPERTYID *pValue);
        
        /* [propput] */ HRESULT ( STDMETHODCALLTYPE *put_PropertyId )( 
            ICertPropertyArchived * This,
            /* [in] */ CERTENROLL_PROPERTYID Value);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_RawData )( 
            ICertPropertyArchived * This,
            /* [in] */ EncodingType Encoding,
            /* [retval][out] */ __RPC__deref_out_opt BSTR *pValue);
        
        HRESULT ( STDMETHODCALLTYPE *RemoveFromCertificate )( 
            ICertPropertyArchived * This,
            /* [in] */ VARIANT_BOOL MachineContext,
            /* [in] */ EncodingType Encoding,
            /* [in] */ __RPC__in BSTR strCertificate);
        
        HRESULT ( STDMETHODCALLTYPE *SetValueOnCertificate )( 
            ICertPropertyArchived * This,
            /* [in] */ VARIANT_BOOL MachineContext,
            /* [in] */ EncodingType Encoding,
            /* [in] */ __RPC__in BSTR strCertificate);
        
        HRESULT ( STDMETHODCALLTYPE *Initialize )( 
            ICertPropertyArchived * This,
            /* [in] */ VARIANT_BOOL ArchivedValue);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_Archived )( 
            ICertPropertyArchived * This,
            /* [retval][out] */ __RPC__out VARIANT_BOOL *pValue);
        
        END_INTERFACE
    } ICertPropertyArchivedVtbl;

    interface ICertPropertyArchived
    {
        CONST_VTBL struct ICertPropertyArchivedVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define ICertPropertyArchived_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define ICertPropertyArchived_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define ICertPropertyArchived_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define ICertPropertyArchived_GetTypeInfoCount(This,pctinfo)	\
    ( (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo) ) 

#define ICertPropertyArchived_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    ( (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo) ) 

#define ICertPropertyArchived_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    ( (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId) ) 

#define ICertPropertyArchived_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    ( (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr) ) 


#define ICertPropertyArchived_InitializeFromCertificate(This,MachineContext,Encoding,strCertificate)	\
    ( (This)->lpVtbl -> InitializeFromCertificate(This,MachineContext,Encoding,strCertificate) ) 

#define ICertPropertyArchived_InitializeDecode(This,Encoding,strEncodedData)	\
    ( (This)->lpVtbl -> InitializeDecode(This,Encoding,strEncodedData) ) 

#define ICertPropertyArchived_get_PropertyId(This,pValue)	\
    ( (This)->lpVtbl -> get_PropertyId(This,pValue) ) 

#define ICertPropertyArchived_put_PropertyId(This,Value)	\
    ( (This)->lpVtbl -> put_PropertyId(This,Value) ) 

#define ICertPropertyArchived_get_RawData(This,Encoding,pValue)	\
    ( (This)->lpVtbl -> get_RawData(This,Encoding,pValue) ) 

#define ICertPropertyArchived_RemoveFromCertificate(This,MachineContext,Encoding,strCertificate)	\
    ( (This)->lpVtbl -> RemoveFromCertificate(This,MachineContext,Encoding,strCertificate) ) 

#define ICertPropertyArchived_SetValueOnCertificate(This,MachineContext,Encoding,strCertificate)	\
    ( (This)->lpVtbl -> SetValueOnCertificate(This,MachineContext,Encoding,strCertificate) ) 


#define ICertPropertyArchived_Initialize(This,ArchivedValue)	\
    ( (This)->lpVtbl -> Initialize(This,ArchivedValue) ) 

#define ICertPropertyArchived_get_Archived(This,pValue)	\
    ( (This)->lpVtbl -> get_Archived(This,pValue) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __ICertPropertyArchived_INTERFACE_DEFINED__ */


#ifndef __ICertPropertyBackedUp_INTERFACE_DEFINED__
#define __ICertPropertyBackedUp_INTERFACE_DEFINED__

/* interface ICertPropertyBackedUp */
/* [helpstring][dual][uuid][object] */ 


EXTERN_C const IID IID_ICertPropertyBackedUp;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("728ab338-217d-11da-b2a4-000e7bbb2b09")
    ICertPropertyBackedUp : public ICertProperty
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE InitializeFromCurrentTime( 
            /* [in] */ VARIANT_BOOL BackedUpValue) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Initialize( 
            /* [in] */ VARIANT_BOOL BackedUpValue,
            /* [in] */ DATE Date) = 0;
        
        virtual /* [propget] */ HRESULT STDMETHODCALLTYPE get_BackedUpValue( 
            /* [retval][out] */ __RPC__out VARIANT_BOOL *pValue) = 0;
        
        virtual /* [propget] */ HRESULT STDMETHODCALLTYPE get_BackedUpTime( 
            /* [retval][out] */ __RPC__out DATE *pDate) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct ICertPropertyBackedUpVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            ICertPropertyBackedUp * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            ICertPropertyBackedUp * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            ICertPropertyBackedUp * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfoCount )( 
            ICertPropertyBackedUp * This,
            /* [out] */ __RPC__out UINT *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfo )( 
            ICertPropertyBackedUp * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ __RPC__deref_out_opt ITypeInfo **ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetIDsOfNames )( 
            ICertPropertyBackedUp * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [size_is][in] */ __RPC__in_ecount_full(cNames) LPOLESTR *rgszNames,
            /* [range][in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ __RPC__out_ecount_full(cNames) DISPID *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE *Invoke )( 
            ICertPropertyBackedUp * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS *pDispParams,
            /* [out] */ VARIANT *pVarResult,
            /* [out] */ EXCEPINFO *pExcepInfo,
            /* [out] */ UINT *puArgErr);
        
        HRESULT ( STDMETHODCALLTYPE *InitializeFromCertificate )( 
            ICertPropertyBackedUp * This,
            /* [in] */ VARIANT_BOOL MachineContext,
            /* [in] */ EncodingType Encoding,
            /* [in] */ __RPC__in BSTR strCertificate);
        
        HRESULT ( STDMETHODCALLTYPE *InitializeDecode )( 
            ICertPropertyBackedUp * This,
            /* [in] */ EncodingType Encoding,
            /* [in] */ __RPC__in BSTR strEncodedData);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_PropertyId )( 
            ICertPropertyBackedUp * This,
            /* [retval][out] */ __RPC__out CERTENROLL_PROPERTYID *pValue);
        
        /* [propput] */ HRESULT ( STDMETHODCALLTYPE *put_PropertyId )( 
            ICertPropertyBackedUp * This,
            /* [in] */ CERTENROLL_PROPERTYID Value);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_RawData )( 
            ICertPropertyBackedUp * This,
            /* [in] */ EncodingType Encoding,
            /* [retval][out] */ __RPC__deref_out_opt BSTR *pValue);
        
        HRESULT ( STDMETHODCALLTYPE *RemoveFromCertificate )( 
            ICertPropertyBackedUp * This,
            /* [in] */ VARIANT_BOOL MachineContext,
            /* [in] */ EncodingType Encoding,
            /* [in] */ __RPC__in BSTR strCertificate);
        
        HRESULT ( STDMETHODCALLTYPE *SetValueOnCertificate )( 
            ICertPropertyBackedUp * This,
            /* [in] */ VARIANT_BOOL MachineContext,
            /* [in] */ EncodingType Encoding,
            /* [in] */ __RPC__in BSTR strCertificate);
        
        HRESULT ( STDMETHODCALLTYPE *InitializeFromCurrentTime )( 
            ICertPropertyBackedUp * This,
            /* [in] */ VARIANT_BOOL BackedUpValue);
        
        HRESULT ( STDMETHODCALLTYPE *Initialize )( 
            ICertPropertyBackedUp * This,
            /* [in] */ VARIANT_BOOL BackedUpValue,
            /* [in] */ DATE Date);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_BackedUpValue )( 
            ICertPropertyBackedUp * This,
            /* [retval][out] */ __RPC__out VARIANT_BOOL *pValue);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_BackedUpTime )( 
            ICertPropertyBackedUp * This,
            /* [retval][out] */ __RPC__out DATE *pDate);
        
        END_INTERFACE
    } ICertPropertyBackedUpVtbl;

    interface ICertPropertyBackedUp
    {
        CONST_VTBL struct ICertPropertyBackedUpVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define ICertPropertyBackedUp_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define ICertPropertyBackedUp_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define ICertPropertyBackedUp_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define ICertPropertyBackedUp_GetTypeInfoCount(This,pctinfo)	\
    ( (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo) ) 

#define ICertPropertyBackedUp_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    ( (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo) ) 

#define ICertPropertyBackedUp_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    ( (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId) ) 

#define ICertPropertyBackedUp_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    ( (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr) ) 


#define ICertPropertyBackedUp_InitializeFromCertificate(This,MachineContext,Encoding,strCertificate)	\
    ( (This)->lpVtbl -> InitializeFromCertificate(This,MachineContext,Encoding,strCertificate) ) 

#define ICertPropertyBackedUp_InitializeDecode(This,Encoding,strEncodedData)	\
    ( (This)->lpVtbl -> InitializeDecode(This,Encoding,strEncodedData) ) 

#define ICertPropertyBackedUp_get_PropertyId(This,pValue)	\
    ( (This)->lpVtbl -> get_PropertyId(This,pValue) ) 

#define ICertPropertyBackedUp_put_PropertyId(This,Value)	\
    ( (This)->lpVtbl -> put_PropertyId(This,Value) ) 

#define ICertPropertyBackedUp_get_RawData(This,Encoding,pValue)	\
    ( (This)->lpVtbl -> get_RawData(This,Encoding,pValue) ) 

#define ICertPropertyBackedUp_RemoveFromCertificate(This,MachineContext,Encoding,strCertificate)	\
    ( (This)->lpVtbl -> RemoveFromCertificate(This,MachineContext,Encoding,strCertificate) ) 

#define ICertPropertyBackedUp_SetValueOnCertificate(This,MachineContext,Encoding,strCertificate)	\
    ( (This)->lpVtbl -> SetValueOnCertificate(This,MachineContext,Encoding,strCertificate) ) 


#define ICertPropertyBackedUp_InitializeFromCurrentTime(This,BackedUpValue)	\
    ( (This)->lpVtbl -> InitializeFromCurrentTime(This,BackedUpValue) ) 

#define ICertPropertyBackedUp_Initialize(This,BackedUpValue,Date)	\
    ( (This)->lpVtbl -> Initialize(This,BackedUpValue,Date) ) 

#define ICertPropertyBackedUp_get_BackedUpValue(This,pValue)	\
    ( (This)->lpVtbl -> get_BackedUpValue(This,pValue) ) 

#define ICertPropertyBackedUp_get_BackedUpTime(This,pDate)	\
    ( (This)->lpVtbl -> get_BackedUpTime(This,pDate) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __ICertPropertyBackedUp_INTERFACE_DEFINED__ */


#ifndef __ICertPropertyEnrollment_INTERFACE_DEFINED__
#define __ICertPropertyEnrollment_INTERFACE_DEFINED__

/* interface ICertPropertyEnrollment */
/* [helpstring][dual][uuid][object] */ 


EXTERN_C const IID IID_ICertPropertyEnrollment;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("728ab339-217d-11da-b2a4-000e7bbb2b09")
    ICertPropertyEnrollment : public ICertProperty
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE Initialize( 
            /* [in] */ LONG RequestId,
            /* [in] */ __RPC__in BSTR strCADnsName,
            /* [in] */ __RPC__in BSTR strCAName,
            /* [defaultvalue][in] */ __RPC__in BSTR strFriendlyName = 0) = 0;
        
        virtual /* [propget] */ HRESULT STDMETHODCALLTYPE get_RequestId( 
            /* [retval][out] */ __RPC__out LONG *pValue) = 0;
        
        virtual /* [propget] */ HRESULT STDMETHODCALLTYPE get_CADnsName( 
            /* [retval][out] */ __RPC__deref_out_opt BSTR *pValue) = 0;
        
        virtual /* [propget] */ HRESULT STDMETHODCALLTYPE get_CAName( 
            /* [retval][out] */ __RPC__deref_out_opt BSTR *pValue) = 0;
        
        virtual /* [propget] */ HRESULT STDMETHODCALLTYPE get_FriendlyName( 
            /* [retval][out] */ __RPC__deref_out_opt BSTR *pValue) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct ICertPropertyEnrollmentVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            ICertPropertyEnrollment * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            ICertPropertyEnrollment * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            ICertPropertyEnrollment * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfoCount )( 
            ICertPropertyEnrollment * This,
            /* [out] */ __RPC__out UINT *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfo )( 
            ICertPropertyEnrollment * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ __RPC__deref_out_opt ITypeInfo **ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetIDsOfNames )( 
            ICertPropertyEnrollment * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [size_is][in] */ __RPC__in_ecount_full(cNames) LPOLESTR *rgszNames,
            /* [range][in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ __RPC__out_ecount_full(cNames) DISPID *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE *Invoke )( 
            ICertPropertyEnrollment * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS *pDispParams,
            /* [out] */ VARIANT *pVarResult,
            /* [out] */ EXCEPINFO *pExcepInfo,
            /* [out] */ UINT *puArgErr);
        
        HRESULT ( STDMETHODCALLTYPE *InitializeFromCertificate )( 
            ICertPropertyEnrollment * This,
            /* [in] */ VARIANT_BOOL MachineContext,
            /* [in] */ EncodingType Encoding,
            /* [in] */ __RPC__in BSTR strCertificate);
        
        HRESULT ( STDMETHODCALLTYPE *InitializeDecode )( 
            ICertPropertyEnrollment * This,
            /* [in] */ EncodingType Encoding,
            /* [in] */ __RPC__in BSTR strEncodedData);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_PropertyId )( 
            ICertPropertyEnrollment * This,
            /* [retval][out] */ __RPC__out CERTENROLL_PROPERTYID *pValue);
        
        /* [propput] */ HRESULT ( STDMETHODCALLTYPE *put_PropertyId )( 
            ICertPropertyEnrollment * This,
            /* [in] */ CERTENROLL_PROPERTYID Value);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_RawData )( 
            ICertPropertyEnrollment * This,
            /* [in] */ EncodingType Encoding,
            /* [retval][out] */ __RPC__deref_out_opt BSTR *pValue);
        
        HRESULT ( STDMETHODCALLTYPE *RemoveFromCertificate )( 
            ICertPropertyEnrollment * This,
            /* [in] */ VARIANT_BOOL MachineContext,
            /* [in] */ EncodingType Encoding,
            /* [in] */ __RPC__in BSTR strCertificate);
        
        HRESULT ( STDMETHODCALLTYPE *SetValueOnCertificate )( 
            ICertPropertyEnrollment * This,
            /* [in] */ VARIANT_BOOL MachineContext,
            /* [in] */ EncodingType Encoding,
            /* [in] */ __RPC__in BSTR strCertificate);
        
        HRESULT ( STDMETHODCALLTYPE *Initialize )( 
            ICertPropertyEnrollment * This,
            /* [in] */ LONG RequestId,
            /* [in] */ __RPC__in BSTR strCADnsName,
            /* [in] */ __RPC__in BSTR strCAName,
            /* [defaultvalue][in] */ __RPC__in BSTR strFriendlyName);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_RequestId )( 
            ICertPropertyEnrollment * This,
            /* [retval][out] */ __RPC__out LONG *pValue);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_CADnsName )( 
            ICertPropertyEnrollment * This,
            /* [retval][out] */ __RPC__deref_out_opt BSTR *pValue);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_CAName )( 
            ICertPropertyEnrollment * This,
            /* [retval][out] */ __RPC__deref_out_opt BSTR *pValue);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_FriendlyName )( 
            ICertPropertyEnrollment * This,
            /* [retval][out] */ __RPC__deref_out_opt BSTR *pValue);
        
        END_INTERFACE
    } ICertPropertyEnrollmentVtbl;

    interface ICertPropertyEnrollment
    {
        CONST_VTBL struct ICertPropertyEnrollmentVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define ICertPropertyEnrollment_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define ICertPropertyEnrollment_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define ICertPropertyEnrollment_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define ICertPropertyEnrollment_GetTypeInfoCount(This,pctinfo)	\
    ( (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo) ) 

#define ICertPropertyEnrollment_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    ( (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo) ) 

#define ICertPropertyEnrollment_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    ( (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId) ) 

#define ICertPropertyEnrollment_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    ( (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr) ) 


#define ICertPropertyEnrollment_InitializeFromCertificate(This,MachineContext,Encoding,strCertificate)	\
    ( (This)->lpVtbl -> InitializeFromCertificate(This,MachineContext,Encoding,strCertificate) ) 

#define ICertPropertyEnrollment_InitializeDecode(This,Encoding,strEncodedData)	\
    ( (This)->lpVtbl -> InitializeDecode(This,Encoding,strEncodedData) ) 

#define ICertPropertyEnrollment_get_PropertyId(This,pValue)	\
    ( (This)->lpVtbl -> get_PropertyId(This,pValue) ) 

#define ICertPropertyEnrollment_put_PropertyId(This,Value)	\
    ( (This)->lpVtbl -> put_PropertyId(This,Value) ) 

#define ICertPropertyEnrollment_get_RawData(This,Encoding,pValue)	\
    ( (This)->lpVtbl -> get_RawData(This,Encoding,pValue) ) 

#define ICertPropertyEnrollment_RemoveFromCertificate(This,MachineContext,Encoding,strCertificate)	\
    ( (This)->lpVtbl -> RemoveFromCertificate(This,MachineContext,Encoding,strCertificate) ) 

#define ICertPropertyEnrollment_SetValueOnCertificate(This,MachineContext,Encoding,strCertificate)	\
    ( (This)->lpVtbl -> SetValueOnCertificate(This,MachineContext,Encoding,strCertificate) ) 


#define ICertPropertyEnrollment_Initialize(This,RequestId,strCADnsName,strCAName,strFriendlyName)	\
    ( (This)->lpVtbl -> Initialize(This,RequestId,strCADnsName,strCAName,strFriendlyName) ) 

#define ICertPropertyEnrollment_get_RequestId(This,pValue)	\
    ( (This)->lpVtbl -> get_RequestId(This,pValue) ) 

#define ICertPropertyEnrollment_get_CADnsName(This,pValue)	\
    ( (This)->lpVtbl -> get_CADnsName(This,pValue) ) 

#define ICertPropertyEnrollment_get_CAName(This,pValue)	\
    ( (This)->lpVtbl -> get_CAName(This,pValue) ) 

#define ICertPropertyEnrollment_get_FriendlyName(This,pValue)	\
    ( (This)->lpVtbl -> get_FriendlyName(This,pValue) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __ICertPropertyEnrollment_INTERFACE_DEFINED__ */


#ifndef __ICertPropertyRenewal_INTERFACE_DEFINED__
#define __ICertPropertyRenewal_INTERFACE_DEFINED__

/* interface ICertPropertyRenewal */
/* [helpstring][dual][uuid][object] */ 


EXTERN_C const IID IID_ICertPropertyRenewal;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("728ab33a-217d-11da-b2a4-000e7bbb2b09")
    ICertPropertyRenewal : public ICertProperty
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE Initialize( 
            /* [in] */ EncodingType Encoding,
            /* [in] */ __RPC__in BSTR strRenewalValue) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE InitializeFromCertificateHash( 
            /* [in] */ VARIANT_BOOL MachineContext,
            /* [in] */ EncodingType Encoding,
            /* [in] */ __RPC__in BSTR strCertificate) = 0;
        
        virtual /* [propget] */ HRESULT STDMETHODCALLTYPE get_Renewal( 
            /* [in] */ EncodingType Encoding,
            /* [retval][out] */ __RPC__deref_out_opt BSTR *pValue) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct ICertPropertyRenewalVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            ICertPropertyRenewal * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            ICertPropertyRenewal * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            ICertPropertyRenewal * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfoCount )( 
            ICertPropertyRenewal * This,
            /* [out] */ __RPC__out UINT *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfo )( 
            ICertPropertyRenewal * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ __RPC__deref_out_opt ITypeInfo **ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetIDsOfNames )( 
            ICertPropertyRenewal * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [size_is][in] */ __RPC__in_ecount_full(cNames) LPOLESTR *rgszNames,
            /* [range][in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ __RPC__out_ecount_full(cNames) DISPID *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE *Invoke )( 
            ICertPropertyRenewal * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS *pDispParams,
            /* [out] */ VARIANT *pVarResult,
            /* [out] */ EXCEPINFO *pExcepInfo,
            /* [out] */ UINT *puArgErr);
        
        HRESULT ( STDMETHODCALLTYPE *InitializeFromCertificate )( 
            ICertPropertyRenewal * This,
            /* [in] */ VARIANT_BOOL MachineContext,
            /* [in] */ EncodingType Encoding,
            /* [in] */ __RPC__in BSTR strCertificate);
        
        HRESULT ( STDMETHODCALLTYPE *InitializeDecode )( 
            ICertPropertyRenewal * This,
            /* [in] */ EncodingType Encoding,
            /* [in] */ __RPC__in BSTR strEncodedData);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_PropertyId )( 
            ICertPropertyRenewal * This,
            /* [retval][out] */ __RPC__out CERTENROLL_PROPERTYID *pValue);
        
        /* [propput] */ HRESULT ( STDMETHODCALLTYPE *put_PropertyId )( 
            ICertPropertyRenewal * This,
            /* [in] */ CERTENROLL_PROPERTYID Value);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_RawData )( 
            ICertPropertyRenewal * This,
            /* [in] */ EncodingType Encoding,
            /* [retval][out] */ __RPC__deref_out_opt BSTR *pValue);
        
        HRESULT ( STDMETHODCALLTYPE *RemoveFromCertificate )( 
            ICertPropertyRenewal * This,
            /* [in] */ VARIANT_BOOL MachineContext,
            /* [in] */ EncodingType Encoding,
            /* [in] */ __RPC__in BSTR strCertificate);
        
        HRESULT ( STDMETHODCALLTYPE *SetValueOnCertificate )( 
            ICertPropertyRenewal * This,
            /* [in] */ VARIANT_BOOL MachineContext,
            /* [in] */ EncodingType Encoding,
            /* [in] */ __RPC__in BSTR strCertificate);
        
        HRESULT ( STDMETHODCALLTYPE *Initialize )( 
            ICertPropertyRenewal * This,
            /* [in] */ EncodingType Encoding,
            /* [in] */ __RPC__in BSTR strRenewalValue);
        
        HRESULT ( STDMETHODCALLTYPE *InitializeFromCertificateHash )( 
            ICertPropertyRenewal * This,
            /* [in] */ VARIANT_BOOL MachineContext,
            /* [in] */ EncodingType Encoding,
            /* [in] */ __RPC__in BSTR strCertificate);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_Renewal )( 
            ICertPropertyRenewal * This,
            /* [in] */ EncodingType Encoding,
            /* [retval][out] */ __RPC__deref_out_opt BSTR *pValue);
        
        END_INTERFACE
    } ICertPropertyRenewalVtbl;

    interface ICertPropertyRenewal
    {
        CONST_VTBL struct ICertPropertyRenewalVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define ICertPropertyRenewal_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define ICertPropertyRenewal_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define ICertPropertyRenewal_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define ICertPropertyRenewal_GetTypeInfoCount(This,pctinfo)	\
    ( (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo) ) 

#define ICertPropertyRenewal_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    ( (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo) ) 

#define ICertPropertyRenewal_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    ( (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId) ) 

#define ICertPropertyRenewal_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    ( (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr) ) 


#define ICertPropertyRenewal_InitializeFromCertificate(This,MachineContext,Encoding,strCertificate)	\
    ( (This)->lpVtbl -> InitializeFromCertificate(This,MachineContext,Encoding,strCertificate) ) 

#define ICertPropertyRenewal_InitializeDecode(This,Encoding,strEncodedData)	\
    ( (This)->lpVtbl -> InitializeDecode(This,Encoding,strEncodedData) ) 

#define ICertPropertyRenewal_get_PropertyId(This,pValue)	\
    ( (This)->lpVtbl -> get_PropertyId(This,pValue) ) 

#define ICertPropertyRenewal_put_PropertyId(This,Value)	\
    ( (This)->lpVtbl -> put_PropertyId(This,Value) ) 

#define ICertPropertyRenewal_get_RawData(This,Encoding,pValue)	\
    ( (This)->lpVtbl -> get_RawData(This,Encoding,pValue) ) 

#define ICertPropertyRenewal_RemoveFromCertificate(This,MachineContext,Encoding,strCertificate)	\
    ( (This)->lpVtbl -> RemoveFromCertificate(This,MachineContext,Encoding,strCertificate) ) 

#define ICertPropertyRenewal_SetValueOnCertificate(This,MachineContext,Encoding,strCertificate)	\
    ( (This)->lpVtbl -> SetValueOnCertificate(This,MachineContext,Encoding,strCertificate) ) 


#define ICertPropertyRenewal_Initialize(This,Encoding,strRenewalValue)	\
    ( (This)->lpVtbl -> Initialize(This,Encoding,strRenewalValue) ) 

#define ICertPropertyRenewal_InitializeFromCertificateHash(This,MachineContext,Encoding,strCertificate)	\
    ( (This)->lpVtbl -> InitializeFromCertificateHash(This,MachineContext,Encoding,strCertificate) ) 

#define ICertPropertyRenewal_get_Renewal(This,Encoding,pValue)	\
    ( (This)->lpVtbl -> get_Renewal(This,Encoding,pValue) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __ICertPropertyRenewal_INTERFACE_DEFINED__ */


#ifndef __ICertPropertyArchivedKeyHash_INTERFACE_DEFINED__
#define __ICertPropertyArchivedKeyHash_INTERFACE_DEFINED__

/* interface ICertPropertyArchivedKeyHash */
/* [helpstring][dual][uuid][object] */ 


EXTERN_C const IID IID_ICertPropertyArchivedKeyHash;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("728ab33b-217d-11da-b2a4-000e7bbb2b09")
    ICertPropertyArchivedKeyHash : public ICertProperty
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE Initialize( 
            /* [in] */ EncodingType Encoding,
            /* [in] */ __RPC__in BSTR strArchivedKeyHashValue) = 0;
        
        virtual /* [propget] */ HRESULT STDMETHODCALLTYPE get_ArchivedKeyHash( 
            /* [in] */ EncodingType Encoding,
            /* [retval][out] */ __RPC__deref_out_opt BSTR *pValue) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct ICertPropertyArchivedKeyHashVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            ICertPropertyArchivedKeyHash * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            ICertPropertyArchivedKeyHash * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            ICertPropertyArchivedKeyHash * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfoCount )( 
            ICertPropertyArchivedKeyHash * This,
            /* [out] */ __RPC__out UINT *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfo )( 
            ICertPropertyArchivedKeyHash * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ __RPC__deref_out_opt ITypeInfo **ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetIDsOfNames )( 
            ICertPropertyArchivedKeyHash * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [size_is][in] */ __RPC__in_ecount_full(cNames) LPOLESTR *rgszNames,
            /* [range][in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ __RPC__out_ecount_full(cNames) DISPID *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE *Invoke )( 
            ICertPropertyArchivedKeyHash * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS *pDispParams,
            /* [out] */ VARIANT *pVarResult,
            /* [out] */ EXCEPINFO *pExcepInfo,
            /* [out] */ UINT *puArgErr);
        
        HRESULT ( STDMETHODCALLTYPE *InitializeFromCertificate )( 
            ICertPropertyArchivedKeyHash * This,
            /* [in] */ VARIANT_BOOL MachineContext,
            /* [in] */ EncodingType Encoding,
            /* [in] */ __RPC__in BSTR strCertificate);
        
        HRESULT ( STDMETHODCALLTYPE *InitializeDecode )( 
            ICertPropertyArchivedKeyHash * This,
            /* [in] */ EncodingType Encoding,
            /* [in] */ __RPC__in BSTR strEncodedData);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_PropertyId )( 
            ICertPropertyArchivedKeyHash * This,
            /* [retval][out] */ __RPC__out CERTENROLL_PROPERTYID *pValue);
        
        /* [propput] */ HRESULT ( STDMETHODCALLTYPE *put_PropertyId )( 
            ICertPropertyArchivedKeyHash * This,
            /* [in] */ CERTENROLL_PROPERTYID Value);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_RawData )( 
            ICertPropertyArchivedKeyHash * This,
            /* [in] */ EncodingType Encoding,
            /* [retval][out] */ __RPC__deref_out_opt BSTR *pValue);
        
        HRESULT ( STDMETHODCALLTYPE *RemoveFromCertificate )( 
            ICertPropertyArchivedKeyHash * This,
            /* [in] */ VARIANT_BOOL MachineContext,
            /* [in] */ EncodingType Encoding,
            /* [in] */ __RPC__in BSTR strCertificate);
        
        HRESULT ( STDMETHODCALLTYPE *SetValueOnCertificate )( 
            ICertPropertyArchivedKeyHash * This,
            /* [in] */ VARIANT_BOOL MachineContext,
            /* [in] */ EncodingType Encoding,
            /* [in] */ __RPC__in BSTR strCertificate);
        
        HRESULT ( STDMETHODCALLTYPE *Initialize )( 
            ICertPropertyArchivedKeyHash * This,
            /* [in] */ EncodingType Encoding,
            /* [in] */ __RPC__in BSTR strArchivedKeyHashValue);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_ArchivedKeyHash )( 
            ICertPropertyArchivedKeyHash * This,
            /* [in] */ EncodingType Encoding,
            /* [retval][out] */ __RPC__deref_out_opt BSTR *pValue);
        
        END_INTERFACE
    } ICertPropertyArchivedKeyHashVtbl;

    interface ICertPropertyArchivedKeyHash
    {
        CONST_VTBL struct ICertPropertyArchivedKeyHashVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define ICertPropertyArchivedKeyHash_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define ICertPropertyArchivedKeyHash_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define ICertPropertyArchivedKeyHash_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define ICertPropertyArchivedKeyHash_GetTypeInfoCount(This,pctinfo)	\
    ( (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo) ) 

#define ICertPropertyArchivedKeyHash_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    ( (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo) ) 

#define ICertPropertyArchivedKeyHash_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    ( (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId) ) 

#define ICertPropertyArchivedKeyHash_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    ( (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr) ) 


#define ICertPropertyArchivedKeyHash_InitializeFromCertificate(This,MachineContext,Encoding,strCertificate)	\
    ( (This)->lpVtbl -> InitializeFromCertificate(This,MachineContext,Encoding,strCertificate) ) 

#define ICertPropertyArchivedKeyHash_InitializeDecode(This,Encoding,strEncodedData)	\
    ( (This)->lpVtbl -> InitializeDecode(This,Encoding,strEncodedData) ) 

#define ICertPropertyArchivedKeyHash_get_PropertyId(This,pValue)	\
    ( (This)->lpVtbl -> get_PropertyId(This,pValue) ) 

#define ICertPropertyArchivedKeyHash_put_PropertyId(This,Value)	\
    ( (This)->lpVtbl -> put_PropertyId(This,Value) ) 

#define ICertPropertyArchivedKeyHash_get_RawData(This,Encoding,pValue)	\
    ( (This)->lpVtbl -> get_RawData(This,Encoding,pValue) ) 

#define ICertPropertyArchivedKeyHash_RemoveFromCertificate(This,MachineContext,Encoding,strCertificate)	\
    ( (This)->lpVtbl -> RemoveFromCertificate(This,MachineContext,Encoding,strCertificate) ) 

#define ICertPropertyArchivedKeyHash_SetValueOnCertificate(This,MachineContext,Encoding,strCertificate)	\
    ( (This)->lpVtbl -> SetValueOnCertificate(This,MachineContext,Encoding,strCertificate) ) 


#define ICertPropertyArchivedKeyHash_Initialize(This,Encoding,strArchivedKeyHashValue)	\
    ( (This)->lpVtbl -> Initialize(This,Encoding,strArchivedKeyHashValue) ) 

#define ICertPropertyArchivedKeyHash_get_ArchivedKeyHash(This,Encoding,pValue)	\
    ( (This)->lpVtbl -> get_ArchivedKeyHash(This,Encoding,pValue) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __ICertPropertyArchivedKeyHash_INTERFACE_DEFINED__ */


#ifndef __IX509SignatureInformation_INTERFACE_DEFINED__
#define __IX509SignatureInformation_INTERFACE_DEFINED__

/* interface IX509SignatureInformation */
/* [helpstring][dual][uuid][object] */ 


EXTERN_C const IID IID_IX509SignatureInformation;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("728ab33c-217d-11da-b2a4-000e7bbb2b09")
    IX509SignatureInformation : public IDispatch
    {
    public:
        virtual /* [propget] */ HRESULT STDMETHODCALLTYPE get_HashAlgorithm( 
            /* [retval][out] */ __RPC__deref_out_opt IObjectId **ppValue) = 0;
        
        virtual /* [propput] */ HRESULT STDMETHODCALLTYPE put_HashAlgorithm( 
            /* [in] */ __RPC__in_opt IObjectId *pValue) = 0;
        
        virtual /* [propget] */ HRESULT STDMETHODCALLTYPE get_PublicKeyAlgorithm( 
            /* [retval][out] */ __RPC__deref_out_opt IObjectId **ppValue) = 0;
        
        virtual /* [propput] */ HRESULT STDMETHODCALLTYPE put_PublicKeyAlgorithm( 
            /* [in] */ __RPC__in_opt IObjectId *pValue) = 0;
        
        virtual /* [propget] */ HRESULT STDMETHODCALLTYPE get_Parameters( 
            /* [defaultvalue][in] */ EncodingType Encoding,
            /* [retval][out] */ __RPC__deref_out_opt BSTR *pValue) = 0;
        
        virtual /* [propput] */ HRESULT STDMETHODCALLTYPE put_Parameters( 
            /* [defaultvalue][in] */ EncodingType Encoding,
            /* [in] */ __RPC__in BSTR Value) = 0;
        
        virtual /* [propget] */ HRESULT STDMETHODCALLTYPE get_AlternateSignatureAlgorithm( 
            /* [retval][out] */ __RPC__out VARIANT_BOOL *pValue) = 0;
        
        virtual /* [propput] */ HRESULT STDMETHODCALLTYPE put_AlternateSignatureAlgorithm( 
            /* [in] */ VARIANT_BOOL Value) = 0;
        
        virtual /* [propget] */ HRESULT STDMETHODCALLTYPE get_AlternateSignatureAlgorithmSet( 
            /* [retval][out] */ __RPC__out VARIANT_BOOL *pValue) = 0;
        
        virtual /* [propget] */ HRESULT STDMETHODCALLTYPE get_NullSigned( 
            /* [retval][out] */ __RPC__out VARIANT_BOOL *pValue) = 0;
        
        virtual /* [propput] */ HRESULT STDMETHODCALLTYPE put_NullSigned( 
            /* [in] */ VARIANT_BOOL Value) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetSignatureAlgorithm( 
            /* [in] */ VARIANT_BOOL Pkcs7Signature,
            /* [in] */ VARIANT_BOOL SignatureKey,
            /* [retval][out] */ __RPC__deref_out_opt IObjectId **ppValue) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetDefaultValues( void) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IX509SignatureInformationVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IX509SignatureInformation * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IX509SignatureInformation * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IX509SignatureInformation * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfoCount )( 
            IX509SignatureInformation * This,
            /* [out] */ __RPC__out UINT *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfo )( 
            IX509SignatureInformation * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ __RPC__deref_out_opt ITypeInfo **ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetIDsOfNames )( 
            IX509SignatureInformation * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [size_is][in] */ __RPC__in_ecount_full(cNames) LPOLESTR *rgszNames,
            /* [range][in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ __RPC__out_ecount_full(cNames) DISPID *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE *Invoke )( 
            IX509SignatureInformation * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS *pDispParams,
            /* [out] */ VARIANT *pVarResult,
            /* [out] */ EXCEPINFO *pExcepInfo,
            /* [out] */ UINT *puArgErr);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_HashAlgorithm )( 
            IX509SignatureInformation * This,
            /* [retval][out] */ __RPC__deref_out_opt IObjectId **ppValue);
        
        /* [propput] */ HRESULT ( STDMETHODCALLTYPE *put_HashAlgorithm )( 
            IX509SignatureInformation * This,
            /* [in] */ __RPC__in_opt IObjectId *pValue);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_PublicKeyAlgorithm )( 
            IX509SignatureInformation * This,
            /* [retval][out] */ __RPC__deref_out_opt IObjectId **ppValue);
        
        /* [propput] */ HRESULT ( STDMETHODCALLTYPE *put_PublicKeyAlgorithm )( 
            IX509SignatureInformation * This,
            /* [in] */ __RPC__in_opt IObjectId *pValue);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_Parameters )( 
            IX509SignatureInformation * This,
            /* [defaultvalue][in] */ EncodingType Encoding,
            /* [retval][out] */ __RPC__deref_out_opt BSTR *pValue);
        
        /* [propput] */ HRESULT ( STDMETHODCALLTYPE *put_Parameters )( 
            IX509SignatureInformation * This,
            /* [defaultvalue][in] */ EncodingType Encoding,
            /* [in] */ __RPC__in BSTR Value);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_AlternateSignatureAlgorithm )( 
            IX509SignatureInformation * This,
            /* [retval][out] */ __RPC__out VARIANT_BOOL *pValue);
        
        /* [propput] */ HRESULT ( STDMETHODCALLTYPE *put_AlternateSignatureAlgorithm )( 
            IX509SignatureInformation * This,
            /* [in] */ VARIANT_BOOL Value);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_AlternateSignatureAlgorithmSet )( 
            IX509SignatureInformation * This,
            /* [retval][out] */ __RPC__out VARIANT_BOOL *pValue);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_NullSigned )( 
            IX509SignatureInformation * This,
            /* [retval][out] */ __RPC__out VARIANT_BOOL *pValue);
        
        /* [propput] */ HRESULT ( STDMETHODCALLTYPE *put_NullSigned )( 
            IX509SignatureInformation * This,
            /* [in] */ VARIANT_BOOL Value);
        
        HRESULT ( STDMETHODCALLTYPE *GetSignatureAlgorithm )( 
            IX509SignatureInformation * This,
            /* [in] */ VARIANT_BOOL Pkcs7Signature,
            /* [in] */ VARIANT_BOOL SignatureKey,
            /* [retval][out] */ __RPC__deref_out_opt IObjectId **ppValue);
        
        HRESULT ( STDMETHODCALLTYPE *SetDefaultValues )( 
            IX509SignatureInformation * This);
        
        END_INTERFACE
    } IX509SignatureInformationVtbl;

    interface IX509SignatureInformation
    {
        CONST_VTBL struct IX509SignatureInformationVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IX509SignatureInformation_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IX509SignatureInformation_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IX509SignatureInformation_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IX509SignatureInformation_GetTypeInfoCount(This,pctinfo)	\
    ( (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo) ) 

#define IX509SignatureInformation_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    ( (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo) ) 

#define IX509SignatureInformation_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    ( (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId) ) 

#define IX509SignatureInformation_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    ( (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr) ) 


#define IX509SignatureInformation_get_HashAlgorithm(This,ppValue)	\
    ( (This)->lpVtbl -> get_HashAlgorithm(This,ppValue) ) 

#define IX509SignatureInformation_put_HashAlgorithm(This,pValue)	\
    ( (This)->lpVtbl -> put_HashAlgorithm(This,pValue) ) 

#define IX509SignatureInformation_get_PublicKeyAlgorithm(This,ppValue)	\
    ( (This)->lpVtbl -> get_PublicKeyAlgorithm(This,ppValue) ) 

#define IX509SignatureInformation_put_PublicKeyAlgorithm(This,pValue)	\
    ( (This)->lpVtbl -> put_PublicKeyAlgorithm(This,pValue) ) 

#define IX509SignatureInformation_get_Parameters(This,Encoding,pValue)	\
    ( (This)->lpVtbl -> get_Parameters(This,Encoding,pValue) ) 

#define IX509SignatureInformation_put_Parameters(This,Encoding,Value)	\
    ( (This)->lpVtbl -> put_Parameters(This,Encoding,Value) ) 

#define IX509SignatureInformation_get_AlternateSignatureAlgorithm(This,pValue)	\
    ( (This)->lpVtbl -> get_AlternateSignatureAlgorithm(This,pValue) ) 

#define IX509SignatureInformation_put_AlternateSignatureAlgorithm(This,Value)	\
    ( (This)->lpVtbl -> put_AlternateSignatureAlgorithm(This,Value) ) 

#define IX509SignatureInformation_get_AlternateSignatureAlgorithmSet(This,pValue)	\
    ( (This)->lpVtbl -> get_AlternateSignatureAlgorithmSet(This,pValue) ) 

#define IX509SignatureInformation_get_NullSigned(This,pValue)	\
    ( (This)->lpVtbl -> get_NullSigned(This,pValue) ) 

#define IX509SignatureInformation_put_NullSigned(This,Value)	\
    ( (This)->lpVtbl -> put_NullSigned(This,Value) ) 

#define IX509SignatureInformation_GetSignatureAlgorithm(This,Pkcs7Signature,SignatureKey,ppValue)	\
    ( (This)->lpVtbl -> GetSignatureAlgorithm(This,Pkcs7Signature,SignatureKey,ppValue) ) 

#define IX509SignatureInformation_SetDefaultValues(This)	\
    ( (This)->lpVtbl -> SetDefaultValues(This) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IX509SignatureInformation_INTERFACE_DEFINED__ */


#ifndef __ISignerCertificate_INTERFACE_DEFINED__
#define __ISignerCertificate_INTERFACE_DEFINED__

/* interface ISignerCertificate */
/* [helpstring][dual][uuid][object] */ 


EXTERN_C const IID IID_ISignerCertificate;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("728ab33d-217d-11da-b2a4-000e7bbb2b09")
    ISignerCertificate : public IDispatch
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE Initialize( 
            /* [in] */ VARIANT_BOOL MachineContext,
            /* [in] */ X509PrivateKeyVerify VerifyType,
            /* [in] */ EncodingType Encoding,
            /* [in] */ __RPC__in BSTR strCertifcate) = 0;
        
        virtual /* [propget] */ HRESULT STDMETHODCALLTYPE get_Certificate( 
            /* [in] */ EncodingType Encoding,
            /* [retval][out] */ __RPC__deref_out_opt BSTR *pValue) = 0;
        
        virtual /* [propget] */ HRESULT STDMETHODCALLTYPE get_PrivateKey( 
            /* [retval][out] */ __RPC__deref_out_opt IX509PrivateKey **ppValue) = 0;
        
        virtual /* [propget] */ HRESULT STDMETHODCALLTYPE get_Silent( 
            /* [retval][out] */ __RPC__out VARIANT_BOOL *pValue) = 0;
        
        virtual /* [propput] */ HRESULT STDMETHODCALLTYPE put_Silent( 
            /* [in] */ VARIANT_BOOL Value) = 0;
        
        virtual /* [propget] */ HRESULT STDMETHODCALLTYPE get_ParentWindow( 
            /* [retval][out] */ __RPC__out LONG *pValue) = 0;
        
        virtual /* [propput] */ HRESULT STDMETHODCALLTYPE put_ParentWindow( 
            /* [in] */ LONG Value) = 0;
        
        virtual /* [propget] */ HRESULT STDMETHODCALLTYPE get_UIContextMessage( 
            /* [retval][out] */ __RPC__deref_out_opt BSTR *pValue) = 0;
        
        virtual /* [propput] */ HRESULT STDMETHODCALLTYPE put_UIContextMessage( 
            /* [in] */ __RPC__in BSTR Value) = 0;
        
        virtual /* [propput] */ HRESULT STDMETHODCALLTYPE put_Pin( 
            /* [in] */ __RPC__in BSTR Value) = 0;
        
        virtual /* [propget] */ HRESULT STDMETHODCALLTYPE get_SignatureInformation( 
            /* [retval][out] */ __RPC__deref_out_opt IX509SignatureInformation **ppValue) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct ISignerCertificateVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            ISignerCertificate * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            ISignerCertificate * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            ISignerCertificate * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfoCount )( 
            ISignerCertificate * This,
            /* [out] */ __RPC__out UINT *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfo )( 
            ISignerCertificate * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ __RPC__deref_out_opt ITypeInfo **ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetIDsOfNames )( 
            ISignerCertificate * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [size_is][in] */ __RPC__in_ecount_full(cNames) LPOLESTR *rgszNames,
            /* [range][in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ __RPC__out_ecount_full(cNames) DISPID *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE *Invoke )( 
            ISignerCertificate * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS *pDispParams,
            /* [out] */ VARIANT *pVarResult,
            /* [out] */ EXCEPINFO *pExcepInfo,
            /* [out] */ UINT *puArgErr);
        
        HRESULT ( STDMETHODCALLTYPE *Initialize )( 
            ISignerCertificate * This,
            /* [in] */ VARIANT_BOOL MachineContext,
            /* [in] */ X509PrivateKeyVerify VerifyType,
            /* [in] */ EncodingType Encoding,
            /* [in] */ __RPC__in BSTR strCertifcate);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_Certificate )( 
            ISignerCertificate * This,
            /* [in] */ EncodingType Encoding,
            /* [retval][out] */ __RPC__deref_out_opt BSTR *pValue);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_PrivateKey )( 
            ISignerCertificate * This,
            /* [retval][out] */ __RPC__deref_out_opt IX509PrivateKey **ppValue);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_Silent )( 
            ISignerCertificate * This,
            /* [retval][out] */ __RPC__out VARIANT_BOOL *pValue);
        
        /* [propput] */ HRESULT ( STDMETHODCALLTYPE *put_Silent )( 
            ISignerCertificate * This,
            /* [in] */ VARIANT_BOOL Value);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_ParentWindow )( 
            ISignerCertificate * This,
            /* [retval][out] */ __RPC__out LONG *pValue);
        
        /* [propput] */ HRESULT ( STDMETHODCALLTYPE *put_ParentWindow )( 
            ISignerCertificate * This,
            /* [in] */ LONG Value);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_UIContextMessage )( 
            ISignerCertificate * This,
            /* [retval][out] */ __RPC__deref_out_opt BSTR *pValue);
        
        /* [propput] */ HRESULT ( STDMETHODCALLTYPE *put_UIContextMessage )( 
            ISignerCertificate * This,
            /* [in] */ __RPC__in BSTR Value);
        
        /* [propput] */ HRESULT ( STDMETHODCALLTYPE *put_Pin )( 
            ISignerCertificate * This,
            /* [in] */ __RPC__in BSTR Value);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_SignatureInformation )( 
            ISignerCertificate * This,
            /* [retval][out] */ __RPC__deref_out_opt IX509SignatureInformation **ppValue);
        
        END_INTERFACE
    } ISignerCertificateVtbl;

    interface ISignerCertificate
    {
        CONST_VTBL struct ISignerCertificateVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define ISignerCertificate_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define ISignerCertificate_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define ISignerCertificate_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define ISignerCertificate_GetTypeInfoCount(This,pctinfo)	\
    ( (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo) ) 

#define ISignerCertificate_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    ( (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo) ) 

#define ISignerCertificate_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    ( (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId) ) 

#define ISignerCertificate_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    ( (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr) ) 


#define ISignerCertificate_Initialize(This,MachineContext,VerifyType,Encoding,strCertifcate)	\
    ( (This)->lpVtbl -> Initialize(This,MachineContext,VerifyType,Encoding,strCertifcate) ) 

#define ISignerCertificate_get_Certificate(This,Encoding,pValue)	\
    ( (This)->lpVtbl -> get_Certificate(This,Encoding,pValue) ) 

#define ISignerCertificate_get_PrivateKey(This,ppValue)	\
    ( (This)->lpVtbl -> get_PrivateKey(This,ppValue) ) 

#define ISignerCertificate_get_Silent(This,pValue)	\
    ( (This)->lpVtbl -> get_Silent(This,pValue) ) 

#define ISignerCertificate_put_Silent(This,Value)	\
    ( (This)->lpVtbl -> put_Silent(This,Value) ) 

#define ISignerCertificate_get_ParentWindow(This,pValue)	\
    ( (This)->lpVtbl -> get_ParentWindow(This,pValue) ) 

#define ISignerCertificate_put_ParentWindow(This,Value)	\
    ( (This)->lpVtbl -> put_ParentWindow(This,Value) ) 

#define ISignerCertificate_get_UIContextMessage(This,pValue)	\
    ( (This)->lpVtbl -> get_UIContextMessage(This,pValue) ) 

#define ISignerCertificate_put_UIContextMessage(This,Value)	\
    ( (This)->lpVtbl -> put_UIContextMessage(This,Value) ) 

#define ISignerCertificate_put_Pin(This,Value)	\
    ( (This)->lpVtbl -> put_Pin(This,Value) ) 

#define ISignerCertificate_get_SignatureInformation(This,ppValue)	\
    ( (This)->lpVtbl -> get_SignatureInformation(This,ppValue) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __ISignerCertificate_INTERFACE_DEFINED__ */


#ifndef __ISignerCertificates_INTERFACE_DEFINED__
#define __ISignerCertificates_INTERFACE_DEFINED__

/* interface ISignerCertificates */
/* [helpstring][dual][uuid][object] */ 


EXTERN_C const IID IID_ISignerCertificates;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("728ab33e-217d-11da-b2a4-000e7bbb2b09")
    ISignerCertificates : public IDispatch
    {
    public:
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_ItemByIndex( 
            /* [in] */ LONG Index,
            /* [retval][out] */ __RPC__deref_out_opt ISignerCertificate **pVal) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_Count( 
            /* [retval][out] */ __RPC__out long *pVal) = 0;
        
        virtual /* [restricted][helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get__NewEnum( 
            /* [retval][out] */ __RPC__deref_out_opt LPUNKNOWN *pVal) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE Add( 
            /* [in] */ __RPC__in_opt ISignerCertificate *pVal) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE Remove( 
            /* [in] */ LONG Index) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE Clear( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Find( 
            /* [in] */ __RPC__in_opt ISignerCertificate *pSignerCert,
            /* [retval][out] */ __RPC__out LONG *piSignerCert) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct ISignerCertificatesVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            ISignerCertificates * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            ISignerCertificates * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            ISignerCertificates * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfoCount )( 
            ISignerCertificates * This,
            /* [out] */ __RPC__out UINT *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfo )( 
            ISignerCertificates * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ __RPC__deref_out_opt ITypeInfo **ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetIDsOfNames )( 
            ISignerCertificates * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [size_is][in] */ __RPC__in_ecount_full(cNames) LPOLESTR *rgszNames,
            /* [range][in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ __RPC__out_ecount_full(cNames) DISPID *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE *Invoke )( 
            ISignerCertificates * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS *pDispParams,
            /* [out] */ VARIANT *pVarResult,
            /* [out] */ EXCEPINFO *pExcepInfo,
            /* [out] */ UINT *puArgErr);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_ItemByIndex )( 
            ISignerCertificates * This,
            /* [in] */ LONG Index,
            /* [retval][out] */ __RPC__deref_out_opt ISignerCertificate **pVal);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_Count )( 
            ISignerCertificates * This,
            /* [retval][out] */ __RPC__out long *pVal);
        
        /* [restricted][helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get__NewEnum )( 
            ISignerCertificates * This,
            /* [retval][out] */ __RPC__deref_out_opt LPUNKNOWN *pVal);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *Add )( 
            ISignerCertificates * This,
            /* [in] */ __RPC__in_opt ISignerCertificate *pVal);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *Remove )( 
            ISignerCertificates * This,
            /* [in] */ LONG Index);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *Clear )( 
            ISignerCertificates * This);
        
        HRESULT ( STDMETHODCALLTYPE *Find )( 
            ISignerCertificates * This,
            /* [in] */ __RPC__in_opt ISignerCertificate *pSignerCert,
            /* [retval][out] */ __RPC__out LONG *piSignerCert);
        
        END_INTERFACE
    } ISignerCertificatesVtbl;

    interface ISignerCertificates
    {
        CONST_VTBL struct ISignerCertificatesVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define ISignerCertificates_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define ISignerCertificates_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define ISignerCertificates_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define ISignerCertificates_GetTypeInfoCount(This,pctinfo)	\
    ( (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo) ) 

#define ISignerCertificates_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    ( (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo) ) 

#define ISignerCertificates_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    ( (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId) ) 

#define ISignerCertificates_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    ( (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr) ) 


#define ISignerCertificates_get_ItemByIndex(This,Index,pVal)	\
    ( (This)->lpVtbl -> get_ItemByIndex(This,Index,pVal) ) 

#define ISignerCertificates_get_Count(This,pVal)	\
    ( (This)->lpVtbl -> get_Count(This,pVal) ) 

#define ISignerCertificates_get__NewEnum(This,pVal)	\
    ( (This)->lpVtbl -> get__NewEnum(This,pVal) ) 

#define ISignerCertificates_Add(This,pVal)	\
    ( (This)->lpVtbl -> Add(This,pVal) ) 

#define ISignerCertificates_Remove(This,Index)	\
    ( (This)->lpVtbl -> Remove(This,Index) ) 

#define ISignerCertificates_Clear(This)	\
    ( (This)->lpVtbl -> Clear(This) ) 

#define ISignerCertificates_Find(This,pSignerCert,piSignerCert)	\
    ( (This)->lpVtbl -> Find(This,pSignerCert,piSignerCert) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __ISignerCertificates_INTERFACE_DEFINED__ */


#ifndef __IX509NameValuePair_INTERFACE_DEFINED__
#define __IX509NameValuePair_INTERFACE_DEFINED__

/* interface IX509NameValuePair */
/* [helpstring][dual][uuid][object] */ 


EXTERN_C const IID IID_IX509NameValuePair;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("728ab33f-217d-11da-b2a4-000e7bbb2b09")
    IX509NameValuePair : public IDispatch
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE Initialize( 
            /* [in] */ __RPC__in BSTR strName,
            /* [in] */ __RPC__in BSTR strValue) = 0;
        
        virtual /* [propget] */ HRESULT STDMETHODCALLTYPE get_Value( 
            /* [retval][out] */ __RPC__deref_out_opt BSTR *pValue) = 0;
        
        virtual /* [propget] */ HRESULT STDMETHODCALLTYPE get_Name( 
            /* [retval][out] */ __RPC__deref_out_opt BSTR *pValue) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IX509NameValuePairVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IX509NameValuePair * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IX509NameValuePair * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IX509NameValuePair * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfoCount )( 
            IX509NameValuePair * This,
            /* [out] */ __RPC__out UINT *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfo )( 
            IX509NameValuePair * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ __RPC__deref_out_opt ITypeInfo **ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetIDsOfNames )( 
            IX509NameValuePair * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [size_is][in] */ __RPC__in_ecount_full(cNames) LPOLESTR *rgszNames,
            /* [range][in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ __RPC__out_ecount_full(cNames) DISPID *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE *Invoke )( 
            IX509NameValuePair * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS *pDispParams,
            /* [out] */ VARIANT *pVarResult,
            /* [out] */ EXCEPINFO *pExcepInfo,
            /* [out] */ UINT *puArgErr);
        
        HRESULT ( STDMETHODCALLTYPE *Initialize )( 
            IX509NameValuePair * This,
            /* [in] */ __RPC__in BSTR strName,
            /* [in] */ __RPC__in BSTR strValue);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_Value )( 
            IX509NameValuePair * This,
            /* [retval][out] */ __RPC__deref_out_opt BSTR *pValue);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_Name )( 
            IX509NameValuePair * This,
            /* [retval][out] */ __RPC__deref_out_opt BSTR *pValue);
        
        END_INTERFACE
    } IX509NameValuePairVtbl;

    interface IX509NameValuePair
    {
        CONST_VTBL struct IX509NameValuePairVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IX509NameValuePair_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IX509NameValuePair_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IX509NameValuePair_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IX509NameValuePair_GetTypeInfoCount(This,pctinfo)	\
    ( (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo) ) 

#define IX509NameValuePair_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    ( (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo) ) 

#define IX509NameValuePair_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    ( (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId) ) 

#define IX509NameValuePair_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    ( (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr) ) 


#define IX509NameValuePair_Initialize(This,strName,strValue)	\
    ( (This)->lpVtbl -> Initialize(This,strName,strValue) ) 

#define IX509NameValuePair_get_Value(This,pValue)	\
    ( (This)->lpVtbl -> get_Value(This,pValue) ) 

#define IX509NameValuePair_get_Name(This,pValue)	\
    ( (This)->lpVtbl -> get_Name(This,pValue) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IX509NameValuePair_INTERFACE_DEFINED__ */


#ifndef __IX509NameValuePairs_INTERFACE_DEFINED__
#define __IX509NameValuePairs_INTERFACE_DEFINED__

/* interface IX509NameValuePairs */
/* [helpstring][dual][uuid][object] */ 


EXTERN_C const IID IID_IX509NameValuePairs;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("728ab340-217d-11da-b2a4-000e7bbb2b09")
    IX509NameValuePairs : public IDispatch
    {
    public:
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_ItemByIndex( 
            /* [in] */ LONG Index,
            /* [retval][out] */ __RPC__deref_out_opt IX509NameValuePair **pVal) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_Count( 
            /* [retval][out] */ __RPC__out long *pVal) = 0;
        
        virtual /* [restricted][helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get__NewEnum( 
            /* [retval][out] */ __RPC__deref_out_opt LPUNKNOWN *pVal) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE Add( 
            /* [in] */ __RPC__in_opt IX509NameValuePair *pVal) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE Remove( 
            /* [in] */ LONG Index) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE Clear( void) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IX509NameValuePairsVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IX509NameValuePairs * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IX509NameValuePairs * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IX509NameValuePairs * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfoCount )( 
            IX509NameValuePairs * This,
            /* [out] */ __RPC__out UINT *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfo )( 
            IX509NameValuePairs * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ __RPC__deref_out_opt ITypeInfo **ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetIDsOfNames )( 
            IX509NameValuePairs * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [size_is][in] */ __RPC__in_ecount_full(cNames) LPOLESTR *rgszNames,
            /* [range][in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ __RPC__out_ecount_full(cNames) DISPID *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE *Invoke )( 
            IX509NameValuePairs * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS *pDispParams,
            /* [out] */ VARIANT *pVarResult,
            /* [out] */ EXCEPINFO *pExcepInfo,
            /* [out] */ UINT *puArgErr);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_ItemByIndex )( 
            IX509NameValuePairs * This,
            /* [in] */ LONG Index,
            /* [retval][out] */ __RPC__deref_out_opt IX509NameValuePair **pVal);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_Count )( 
            IX509NameValuePairs * This,
            /* [retval][out] */ __RPC__out long *pVal);
        
        /* [restricted][helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get__NewEnum )( 
            IX509NameValuePairs * This,
            /* [retval][out] */ __RPC__deref_out_opt LPUNKNOWN *pVal);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *Add )( 
            IX509NameValuePairs * This,
            /* [in] */ __RPC__in_opt IX509NameValuePair *pVal);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *Remove )( 
            IX509NameValuePairs * This,
            /* [in] */ LONG Index);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *Clear )( 
            IX509NameValuePairs * This);
        
        END_INTERFACE
    } IX509NameValuePairsVtbl;

    interface IX509NameValuePairs
    {
        CONST_VTBL struct IX509NameValuePairsVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IX509NameValuePairs_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IX509NameValuePairs_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IX509NameValuePairs_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IX509NameValuePairs_GetTypeInfoCount(This,pctinfo)	\
    ( (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo) ) 

#define IX509NameValuePairs_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    ( (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo) ) 

#define IX509NameValuePairs_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    ( (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId) ) 

#define IX509NameValuePairs_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    ( (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr) ) 


#define IX509NameValuePairs_get_ItemByIndex(This,Index,pVal)	\
    ( (This)->lpVtbl -> get_ItemByIndex(This,Index,pVal) ) 

#define IX509NameValuePairs_get_Count(This,pVal)	\
    ( (This)->lpVtbl -> get_Count(This,pVal) ) 

#define IX509NameValuePairs_get__NewEnum(This,pVal)	\
    ( (This)->lpVtbl -> get__NewEnum(This,pVal) ) 

#define IX509NameValuePairs_Add(This,pVal)	\
    ( (This)->lpVtbl -> Add(This,pVal) ) 

#define IX509NameValuePairs_Remove(This,Index)	\
    ( (This)->lpVtbl -> Remove(This,Index) ) 

#define IX509NameValuePairs_Clear(This)	\
    ( (This)->lpVtbl -> Clear(This) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IX509NameValuePairs_INTERFACE_DEFINED__ */


/* interface __MIDL_itf_certenroll_0000_0063 */
/* [local] */ 

typedef 
enum X509RequestType
    {	TypeAny	= 0,
	TypePkcs10	= 1,
	TypePkcs7	= 2,
	TypeCmc	= 3,
	TypeCertificate	= 4
    } 	X509RequestType;

typedef 
enum X509RequestInheritOptions
    {	InheritDefault	= 0,
	InheritNewDefaultKey	= 0x1,
	InheritNewSimilarKey	= 0x2,
	InheritPrivateKey	= 0x3,
	InheritPublicKey	= 0x4,
	InheritKeyMask	= 0xf,
	InheritNone	= 0x10,
	InheritRenewalCertificateFlag	= 0x20,
	InheritTemplateFlag	= 0x40,
	InheritSubjectFlag	= 0x80,
	InheritExtensionsFlag	= 0x100,
	InheritSubjectAltNameFlag	= 0x200,
	InheritValidityPeriodFlag	= 0x400
    } 	X509RequestInheritOptions;

typedef 
enum InnerRequestLevel
    {	LevelInnermost	= 0,
	LevelNext	= 1
    } 	InnerRequestLevel;



extern RPC_IF_HANDLE __MIDL_itf_certenroll_0000_0063_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_certenroll_0000_0063_v0_0_s_ifspec;

#ifndef __IX509CertificateRequest_INTERFACE_DEFINED__
#define __IX509CertificateRequest_INTERFACE_DEFINED__

/* interface IX509CertificateRequest */
/* [helpstring][dual][uuid][object] */ 


EXTERN_C const IID IID_IX509CertificateRequest;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("728ab341-217d-11da-b2a4-000e7bbb2b09")
    IX509CertificateRequest : public IDispatch
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE Initialize( 
            /* [in] */ X509CertificateEnrollmentContext Context) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Encode( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE ResetForEncode( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetInnerRequest( 
            /* [in] */ InnerRequestLevel Level,
            /* [retval][out] */ __RPC__deref_out_opt IX509CertificateRequest **ppValue) = 0;
        
        virtual /* [propget] */ HRESULT STDMETHODCALLTYPE get_Type( 
            /* [retval][out] */ __RPC__out X509RequestType *pValue) = 0;
        
        virtual /* [propget] */ HRESULT STDMETHODCALLTYPE get_EnrollmentContext( 
            /* [retval][out] */ __RPC__out X509CertificateEnrollmentContext *pValue) = 0;
        
        virtual /* [propget] */ HRESULT STDMETHODCALLTYPE get_Silent( 
            /* [retval][out] */ __RPC__out VARIANT_BOOL *pValue) = 0;
        
        virtual /* [propput] */ HRESULT STDMETHODCALLTYPE put_Silent( 
            /* [in] */ VARIANT_BOOL Value) = 0;
        
        virtual /* [propget] */ HRESULT STDMETHODCALLTYPE get_ParentWindow( 
            /* [retval][out] */ __RPC__out LONG *pValue) = 0;
        
        virtual /* [propput] */ HRESULT STDMETHODCALLTYPE put_ParentWindow( 
            /* [in] */ LONG Value) = 0;
        
        virtual /* [propget] */ HRESULT STDMETHODCALLTYPE get_UIContextMessage( 
            /* [retval][out] */ __RPC__deref_out_opt BSTR *pValue) = 0;
        
        virtual /* [propput] */ HRESULT STDMETHODCALLTYPE put_UIContextMessage( 
            /* [in] */ __RPC__in BSTR Value) = 0;
        
        virtual /* [propget] */ HRESULT STDMETHODCALLTYPE get_SuppressDefaults( 
            /* [retval][out] */ __RPC__out VARIANT_BOOL *pValue) = 0;
        
        virtual /* [propput] */ HRESULT STDMETHODCALLTYPE put_SuppressDefaults( 
            /* [in] */ VARIANT_BOOL Value) = 0;
        
        virtual /* [propget] */ HRESULT STDMETHODCALLTYPE get_RenewalCertificate( 
            /* [defaultvalue][in] */ EncodingType Encoding,
            /* [retval][out] */ __RPC__deref_out_opt BSTR *pValue) = 0;
        
        virtual /* [propput] */ HRESULT STDMETHODCALLTYPE put_RenewalCertificate( 
            /* [defaultvalue][in] */ EncodingType Encoding,
            /* [in] */ __RPC__in BSTR Value) = 0;
        
        virtual /* [custom][propget] */ HRESULT STDMETHODCALLTYPE get_ClientId( 
            /* [retval][out] */ __RPC__out RequestClientInfoClientId *pValue) = 0;
        
        virtual /* [custom][propput] */ HRESULT STDMETHODCALLTYPE put_ClientId( 
            /* [in] */ RequestClientInfoClientId Value) = 0;
        
        virtual /* [propget] */ HRESULT STDMETHODCALLTYPE get_CspInformations( 
            /* [retval][out] */ __RPC__deref_out_opt ICspInformations **ppValue) = 0;
        
        virtual /* [propput] */ HRESULT STDMETHODCALLTYPE put_CspInformations( 
            /* [in] */ __RPC__in_opt ICspInformations *pValue) = 0;
        
        virtual /* [custom][propget] */ HRESULT STDMETHODCALLTYPE get_HashAlgorithm( 
            /* [retval][out] */ __RPC__deref_out_opt IObjectId **ppValue) = 0;
        
        virtual /* [custom][propput] */ HRESULT STDMETHODCALLTYPE put_HashAlgorithm( 
            /* [in] */ __RPC__in_opt IObjectId *pValue) = 0;
        
        virtual /* [propget] */ HRESULT STDMETHODCALLTYPE get_AlternateSignatureAlgorithm( 
            /* [retval][out] */ __RPC__out VARIANT_BOOL *pValue) = 0;
        
        virtual /* [propput] */ HRESULT STDMETHODCALLTYPE put_AlternateSignatureAlgorithm( 
            /* [in] */ VARIANT_BOOL Value) = 0;
        
        virtual /* [propget] */ HRESULT STDMETHODCALLTYPE get_RawData( 
            /* [defaultvalue][in] */ EncodingType Encoding,
            /* [retval][out] */ __RPC__deref_out_opt BSTR *pValue) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IX509CertificateRequestVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IX509CertificateRequest * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IX509CertificateRequest * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IX509CertificateRequest * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfoCount )( 
            IX509CertificateRequest * This,
            /* [out] */ __RPC__out UINT *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfo )( 
            IX509CertificateRequest * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ __RPC__deref_out_opt ITypeInfo **ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetIDsOfNames )( 
            IX509CertificateRequest * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [size_is][in] */ __RPC__in_ecount_full(cNames) LPOLESTR *rgszNames,
            /* [range][in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ __RPC__out_ecount_full(cNames) DISPID *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE *Invoke )( 
            IX509CertificateRequest * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS *pDispParams,
            /* [out] */ VARIANT *pVarResult,
            /* [out] */ EXCEPINFO *pExcepInfo,
            /* [out] */ UINT *puArgErr);
        
        HRESULT ( STDMETHODCALLTYPE *Initialize )( 
            IX509CertificateRequest * This,
            /* [in] */ X509CertificateEnrollmentContext Context);
        
        HRESULT ( STDMETHODCALLTYPE *Encode )( 
            IX509CertificateRequest * This);
        
        HRESULT ( STDMETHODCALLTYPE *ResetForEncode )( 
            IX509CertificateRequest * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetInnerRequest )( 
            IX509CertificateRequest * This,
            /* [in] */ InnerRequestLevel Level,
            /* [retval][out] */ __RPC__deref_out_opt IX509CertificateRequest **ppValue);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_Type )( 
            IX509CertificateRequest * This,
            /* [retval][out] */ __RPC__out X509RequestType *pValue);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_EnrollmentContext )( 
            IX509CertificateRequest * This,
            /* [retval][out] */ __RPC__out X509CertificateEnrollmentContext *pValue);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_Silent )( 
            IX509CertificateRequest * This,
            /* [retval][out] */ __RPC__out VARIANT_BOOL *pValue);
        
        /* [propput] */ HRESULT ( STDMETHODCALLTYPE *put_Silent )( 
            IX509CertificateRequest * This,
            /* [in] */ VARIANT_BOOL Value);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_ParentWindow )( 
            IX509CertificateRequest * This,
            /* [retval][out] */ __RPC__out LONG *pValue);
        
        /* [propput] */ HRESULT ( STDMETHODCALLTYPE *put_ParentWindow )( 
            IX509CertificateRequest * This,
            /* [in] */ LONG Value);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_UIContextMessage )( 
            IX509CertificateRequest * This,
            /* [retval][out] */ __RPC__deref_out_opt BSTR *pValue);
        
        /* [propput] */ HRESULT ( STDMETHODCALLTYPE *put_UIContextMessage )( 
            IX509CertificateRequest * This,
            /* [in] */ __RPC__in BSTR Value);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_SuppressDefaults )( 
            IX509CertificateRequest * This,
            /* [retval][out] */ __RPC__out VARIANT_BOOL *pValue);
        
        /* [propput] */ HRESULT ( STDMETHODCALLTYPE *put_SuppressDefaults )( 
            IX509CertificateRequest * This,
            /* [in] */ VARIANT_BOOL Value);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_RenewalCertificate )( 
            IX509CertificateRequest * This,
            /* [defaultvalue][in] */ EncodingType Encoding,
            /* [retval][out] */ __RPC__deref_out_opt BSTR *pValue);
        
        /* [propput] */ HRESULT ( STDMETHODCALLTYPE *put_RenewalCertificate )( 
            IX509CertificateRequest * This,
            /* [defaultvalue][in] */ EncodingType Encoding,
            /* [in] */ __RPC__in BSTR Value);
        
        /* [custom][propget] */ HRESULT ( STDMETHODCALLTYPE *get_ClientId )( 
            IX509CertificateRequest * This,
            /* [retval][out] */ __RPC__out RequestClientInfoClientId *pValue);
        
        /* [custom][propput] */ HRESULT ( STDMETHODCALLTYPE *put_ClientId )( 
            IX509CertificateRequest * This,
            /* [in] */ RequestClientInfoClientId Value);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_CspInformations )( 
            IX509CertificateRequest * This,
            /* [retval][out] */ __RPC__deref_out_opt ICspInformations **ppValue);
        
        /* [propput] */ HRESULT ( STDMETHODCALLTYPE *put_CspInformations )( 
            IX509CertificateRequest * This,
            /* [in] */ __RPC__in_opt ICspInformations *pValue);
        
        /* [custom][propget] */ HRESULT ( STDMETHODCALLTYPE *get_HashAlgorithm )( 
            IX509CertificateRequest * This,
            /* [retval][out] */ __RPC__deref_out_opt IObjectId **ppValue);
        
        /* [custom][propput] */ HRESULT ( STDMETHODCALLTYPE *put_HashAlgorithm )( 
            IX509CertificateRequest * This,
            /* [in] */ __RPC__in_opt IObjectId *pValue);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_AlternateSignatureAlgorithm )( 
            IX509CertificateRequest * This,
            /* [retval][out] */ __RPC__out VARIANT_BOOL *pValue);
        
        /* [propput] */ HRESULT ( STDMETHODCALLTYPE *put_AlternateSignatureAlgorithm )( 
            IX509CertificateRequest * This,
            /* [in] */ VARIANT_BOOL Value);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_RawData )( 
            IX509CertificateRequest * This,
            /* [defaultvalue][in] */ EncodingType Encoding,
            /* [retval][out] */ __RPC__deref_out_opt BSTR *pValue);
        
        END_INTERFACE
    } IX509CertificateRequestVtbl;

    interface IX509CertificateRequest
    {
        CONST_VTBL struct IX509CertificateRequestVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IX509CertificateRequest_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IX509CertificateRequest_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IX509CertificateRequest_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IX509CertificateRequest_GetTypeInfoCount(This,pctinfo)	\
    ( (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo) ) 

#define IX509CertificateRequest_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    ( (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo) ) 

#define IX509CertificateRequest_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    ( (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId) ) 

#define IX509CertificateRequest_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    ( (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr) ) 


#define IX509CertificateRequest_Initialize(This,Context)	\
    ( (This)->lpVtbl -> Initialize(This,Context) ) 

#define IX509CertificateRequest_Encode(This)	\
    ( (This)->lpVtbl -> Encode(This) ) 

#define IX509CertificateRequest_ResetForEncode(This)	\
    ( (This)->lpVtbl -> ResetForEncode(This) ) 

#define IX509CertificateRequest_GetInnerRequest(This,Level,ppValue)	\
    ( (This)->lpVtbl -> GetInnerRequest(This,Level,ppValue) ) 

#define IX509CertificateRequest_get_Type(This,pValue)	\
    ( (This)->lpVtbl -> get_Type(This,pValue) ) 

#define IX509CertificateRequest_get_EnrollmentContext(This,pValue)	\
    ( (This)->lpVtbl -> get_EnrollmentContext(This,pValue) ) 

#define IX509CertificateRequest_get_Silent(This,pValue)	\
    ( (This)->lpVtbl -> get_Silent(This,pValue) ) 

#define IX509CertificateRequest_put_Silent(This,Value)	\
    ( (This)->lpVtbl -> put_Silent(This,Value) ) 

#define IX509CertificateRequest_get_ParentWindow(This,pValue)	\
    ( (This)->lpVtbl -> get_ParentWindow(This,pValue) ) 

#define IX509CertificateRequest_put_ParentWindow(This,Value)	\
    ( (This)->lpVtbl -> put_ParentWindow(This,Value) ) 

#define IX509CertificateRequest_get_UIContextMessage(This,pValue)	\
    ( (This)->lpVtbl -> get_UIContextMessage(This,pValue) ) 

#define IX509CertificateRequest_put_UIContextMessage(This,Value)	\
    ( (This)->lpVtbl -> put_UIContextMessage(This,Value) ) 

#define IX509CertificateRequest_get_SuppressDefaults(This,pValue)	\
    ( (This)->lpVtbl -> get_SuppressDefaults(This,pValue) ) 

#define IX509CertificateRequest_put_SuppressDefaults(This,Value)	\
    ( (This)->lpVtbl -> put_SuppressDefaults(This,Value) ) 

#define IX509CertificateRequest_get_RenewalCertificate(This,Encoding,pValue)	\
    ( (This)->lpVtbl -> get_RenewalCertificate(This,Encoding,pValue) ) 

#define IX509CertificateRequest_put_RenewalCertificate(This,Encoding,Value)	\
    ( (This)->lpVtbl -> put_RenewalCertificate(This,Encoding,Value) ) 

#define IX509CertificateRequest_get_ClientId(This,pValue)	\
    ( (This)->lpVtbl -> get_ClientId(This,pValue) ) 

#define IX509CertificateRequest_put_ClientId(This,Value)	\
    ( (This)->lpVtbl -> put_ClientId(This,Value) ) 

#define IX509CertificateRequest_get_CspInformations(This,ppValue)	\
    ( (This)->lpVtbl -> get_CspInformations(This,ppValue) ) 

#define IX509CertificateRequest_put_CspInformations(This,pValue)	\
    ( (This)->lpVtbl -> put_CspInformations(This,pValue) ) 

#define IX509CertificateRequest_get_HashAlgorithm(This,ppValue)	\
    ( (This)->lpVtbl -> get_HashAlgorithm(This,ppValue) ) 

#define IX509CertificateRequest_put_HashAlgorithm(This,pValue)	\
    ( (This)->lpVtbl -> put_HashAlgorithm(This,pValue) ) 

#define IX509CertificateRequest_get_AlternateSignatureAlgorithm(This,pValue)	\
    ( (This)->lpVtbl -> get_AlternateSignatureAlgorithm(This,pValue) ) 

#define IX509CertificateRequest_put_AlternateSignatureAlgorithm(This,Value)	\
    ( (This)->lpVtbl -> put_AlternateSignatureAlgorithm(This,Value) ) 

#define IX509CertificateRequest_get_RawData(This,Encoding,pValue)	\
    ( (This)->lpVtbl -> get_RawData(This,Encoding,pValue) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IX509CertificateRequest_INTERFACE_DEFINED__ */


/* interface __MIDL_itf_certenroll_0000_0064 */
/* [local] */ 

typedef 
enum Pkcs10AllowedSignatureTypes
    {	AllowedKeySignature	= 0x1,
	AllowedNullSignature	= 0x2
    } 	Pkcs10AllowedSignatureTypes;



extern RPC_IF_HANDLE __MIDL_itf_certenroll_0000_0064_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_certenroll_0000_0064_v0_0_s_ifspec;

#ifndef __IX509CertificateRequestPkcs10_INTERFACE_DEFINED__
#define __IX509CertificateRequestPkcs10_INTERFACE_DEFINED__

/* interface IX509CertificateRequestPkcs10 */
/* [helpstring][dual][uuid][object] */ 


EXTERN_C const IID IID_IX509CertificateRequestPkcs10;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("728ab342-217d-11da-b2a4-000e7bbb2b09")
    IX509CertificateRequestPkcs10 : public IX509CertificateRequest
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE InitializeFromTemplateName( 
            /* [in] */ X509CertificateEnrollmentContext Context,
            /* [in] */ __RPC__in BSTR strTemplateName) = 0;
        
        virtual /* [custom] */ HRESULT STDMETHODCALLTYPE InitializeFromPrivateKey( 
            /* [in] */ X509CertificateEnrollmentContext Context,
            /* [in] */ __RPC__in_opt IX509PrivateKey *pPrivateKey,
            /* [in] */ __RPC__in BSTR strTemplateName) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE InitializeFromPublicKey( 
            /* [in] */ X509CertificateEnrollmentContext Context,
            /* [in] */ __RPC__in_opt IX509PublicKey *pPublicKey,
            /* [in] */ __RPC__in BSTR strTemplateName) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE InitializeFromCertificate( 
            /* [in] */ X509CertificateEnrollmentContext Context,
            /* [in] */ __RPC__in BSTR strCertificate,
            /* [defaultvalue][in] */ EncodingType Encoding = XCN_CRYPT_STRING_BASE64,
            /* [defaultvalue][in] */ X509RequestInheritOptions InheritOptions = InheritDefault) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE InitializeDecode( 
            /* [in] */ __RPC__in BSTR strEncodedData,
            /* [defaultvalue][in] */ EncodingType Encoding = XCN_CRYPT_STRING_BASE64) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE CheckSignature( 
            /* [defaultvalue][in] */ Pkcs10AllowedSignatureTypes AllowedSignatureTypes = AllowedKeySignature) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE IsSmartCard( 
            /* [retval][out] */ __RPC__out VARIANT_BOOL *pValue) = 0;
        
        virtual /* [propget] */ HRESULT STDMETHODCALLTYPE get_TemplateObjectId( 
            /* [retval][out] */ __RPC__deref_out_opt IObjectId **ppValue) = 0;
        
        virtual /* [propget] */ HRESULT STDMETHODCALLTYPE get_PublicKey( 
            /* [retval][out] */ __RPC__deref_out_opt IX509PublicKey **ppValue) = 0;
        
        virtual /* [custom][propget] */ HRESULT STDMETHODCALLTYPE get_PrivateKey( 
            /* [retval][out] */ __RPC__deref_out_opt IX509PrivateKey **ppValue) = 0;
        
        virtual /* [propget] */ HRESULT STDMETHODCALLTYPE get_NullSigned( 
            /* [retval][out] */ __RPC__out VARIANT_BOOL *pValue) = 0;
        
        virtual /* [propget] */ HRESULT STDMETHODCALLTYPE get_ReuseKey( 
            /* [retval][out] */ __RPC__out VARIANT_BOOL *pValue) = 0;
        
        virtual /* [propget] */ HRESULT STDMETHODCALLTYPE get_OldCertificate( 
            /* [defaultvalue][in] */ EncodingType Encoding,
            /* [retval][out] */ __RPC__deref_out_opt BSTR *pValue) = 0;
        
        virtual /* [custom][propget] */ HRESULT STDMETHODCALLTYPE get_Subject( 
            /* [retval][out] */ __RPC__deref_out_opt IX500DistinguishedName **ppValue) = 0;
        
        virtual /* [custom][propput] */ HRESULT STDMETHODCALLTYPE put_Subject( 
            /* [in] */ __RPC__in_opt IX500DistinguishedName *pValue) = 0;
        
        virtual /* [propget] */ HRESULT STDMETHODCALLTYPE get_CspStatuses( 
            /* [retval][out] */ __RPC__deref_out_opt ICspStatuses **ppValue) = 0;
        
        virtual /* [custom][propget] */ HRESULT STDMETHODCALLTYPE get_SmimeCapabilities( 
            /* [retval][out] */ __RPC__out VARIANT_BOOL *pValue) = 0;
        
        virtual /* [custom][propput] */ HRESULT STDMETHODCALLTYPE put_SmimeCapabilities( 
            /* [in] */ VARIANT_BOOL Value) = 0;
        
        virtual /* [custom][propget] */ HRESULT STDMETHODCALLTYPE get_SignatureInformation( 
            /* [retval][out] */ __RPC__deref_out_opt IX509SignatureInformation **ppValue) = 0;
        
        virtual /* [propget] */ HRESULT STDMETHODCALLTYPE get_KeyContainerNamePrefix( 
            /* [retval][out] */ __RPC__deref_out_opt BSTR *pValue) = 0;
        
        virtual /* [propput] */ HRESULT STDMETHODCALLTYPE put_KeyContainerNamePrefix( 
            /* [in] */ __RPC__in BSTR Value) = 0;
        
        virtual /* [propget] */ HRESULT STDMETHODCALLTYPE get_CryptAttributes( 
            /* [retval][out] */ __RPC__deref_out_opt ICryptAttributes **ppValue) = 0;
        
        virtual /* [custom][propget] */ HRESULT STDMETHODCALLTYPE get_X509Extensions( 
            /* [retval][out] */ __RPC__deref_out_opt IX509Extensions **ppValue) = 0;
        
        virtual /* [propget] */ HRESULT STDMETHODCALLTYPE get_CriticalExtensions( 
            /* [retval][out] */ __RPC__deref_out_opt IObjectIds **ppValue) = 0;
        
        virtual /* [propget] */ HRESULT STDMETHODCALLTYPE get_SuppressOids( 
            /* [retval][out] */ __RPC__deref_out_opt IObjectIds **ppValue) = 0;
        
        virtual /* [propget] */ HRESULT STDMETHODCALLTYPE get_RawDataToBeSigned( 
            /* [defaultvalue][in] */ EncodingType Encoding,
            /* [retval][out] */ __RPC__deref_out_opt BSTR *pValue) = 0;
        
        virtual /* [propget] */ HRESULT STDMETHODCALLTYPE get_Signature( 
            /* [defaultvalue][in] */ EncodingType Encoding,
            /* [retval][out] */ __RPC__deref_out_opt BSTR *pValue) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetCspStatuses( 
            /* [in] */ X509KeySpec KeySpec,
            /* [retval][out] */ __RPC__deref_out_opt ICspStatuses **ppCspStatuses) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IX509CertificateRequestPkcs10Vtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IX509CertificateRequestPkcs10 * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IX509CertificateRequestPkcs10 * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IX509CertificateRequestPkcs10 * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfoCount )( 
            IX509CertificateRequestPkcs10 * This,
            /* [out] */ __RPC__out UINT *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfo )( 
            IX509CertificateRequestPkcs10 * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ __RPC__deref_out_opt ITypeInfo **ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetIDsOfNames )( 
            IX509CertificateRequestPkcs10 * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [size_is][in] */ __RPC__in_ecount_full(cNames) LPOLESTR *rgszNames,
            /* [range][in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ __RPC__out_ecount_full(cNames) DISPID *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE *Invoke )( 
            IX509CertificateRequestPkcs10 * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS *pDispParams,
            /* [out] */ VARIANT *pVarResult,
            /* [out] */ EXCEPINFO *pExcepInfo,
            /* [out] */ UINT *puArgErr);
        
        HRESULT ( STDMETHODCALLTYPE *Initialize )( 
            IX509CertificateRequestPkcs10 * This,
            /* [in] */ X509CertificateEnrollmentContext Context);
        
        HRESULT ( STDMETHODCALLTYPE *Encode )( 
            IX509CertificateRequestPkcs10 * This);
        
        HRESULT ( STDMETHODCALLTYPE *ResetForEncode )( 
            IX509CertificateRequestPkcs10 * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetInnerRequest )( 
            IX509CertificateRequestPkcs10 * This,
            /* [in] */ InnerRequestLevel Level,
            /* [retval][out] */ __RPC__deref_out_opt IX509CertificateRequest **ppValue);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_Type )( 
            IX509CertificateRequestPkcs10 * This,
            /* [retval][out] */ __RPC__out X509RequestType *pValue);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_EnrollmentContext )( 
            IX509CertificateRequestPkcs10 * This,
            /* [retval][out] */ __RPC__out X509CertificateEnrollmentContext *pValue);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_Silent )( 
            IX509CertificateRequestPkcs10 * This,
            /* [retval][out] */ __RPC__out VARIANT_BOOL *pValue);
        
        /* [propput] */ HRESULT ( STDMETHODCALLTYPE *put_Silent )( 
            IX509CertificateRequestPkcs10 * This,
            /* [in] */ VARIANT_BOOL Value);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_ParentWindow )( 
            IX509CertificateRequestPkcs10 * This,
            /* [retval][out] */ __RPC__out LONG *pValue);
        
        /* [propput] */ HRESULT ( STDMETHODCALLTYPE *put_ParentWindow )( 
            IX509CertificateRequestPkcs10 * This,
            /* [in] */ LONG Value);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_UIContextMessage )( 
            IX509CertificateRequestPkcs10 * This,
            /* [retval][out] */ __RPC__deref_out_opt BSTR *pValue);
        
        /* [propput] */ HRESULT ( STDMETHODCALLTYPE *put_UIContextMessage )( 
            IX509CertificateRequestPkcs10 * This,
            /* [in] */ __RPC__in BSTR Value);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_SuppressDefaults )( 
            IX509CertificateRequestPkcs10 * This,
            /* [retval][out] */ __RPC__out VARIANT_BOOL *pValue);
        
        /* [propput] */ HRESULT ( STDMETHODCALLTYPE *put_SuppressDefaults )( 
            IX509CertificateRequestPkcs10 * This,
            /* [in] */ VARIANT_BOOL Value);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_RenewalCertificate )( 
            IX509CertificateRequestPkcs10 * This,
            /* [defaultvalue][in] */ EncodingType Encoding,
            /* [retval][out] */ __RPC__deref_out_opt BSTR *pValue);
        
        /* [propput] */ HRESULT ( STDMETHODCALLTYPE *put_RenewalCertificate )( 
            IX509CertificateRequestPkcs10 * This,
            /* [defaultvalue][in] */ EncodingType Encoding,
            /* [in] */ __RPC__in BSTR Value);
        
        /* [custom][propget] */ HRESULT ( STDMETHODCALLTYPE *get_ClientId )( 
            IX509CertificateRequestPkcs10 * This,
            /* [retval][out] */ __RPC__out RequestClientInfoClientId *pValue);
        
        /* [custom][propput] */ HRESULT ( STDMETHODCALLTYPE *put_ClientId )( 
            IX509CertificateRequestPkcs10 * This,
            /* [in] */ RequestClientInfoClientId Value);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_CspInformations )( 
            IX509CertificateRequestPkcs10 * This,
            /* [retval][out] */ __RPC__deref_out_opt ICspInformations **ppValue);
        
        /* [propput] */ HRESULT ( STDMETHODCALLTYPE *put_CspInformations )( 
            IX509CertificateRequestPkcs10 * This,
            /* [in] */ __RPC__in_opt ICspInformations *pValue);
        
        /* [custom][propget] */ HRESULT ( STDMETHODCALLTYPE *get_HashAlgorithm )( 
            IX509CertificateRequestPkcs10 * This,
            /* [retval][out] */ __RPC__deref_out_opt IObjectId **ppValue);
        
        /* [custom][propput] */ HRESULT ( STDMETHODCALLTYPE *put_HashAlgorithm )( 
            IX509CertificateRequestPkcs10 * This,
            /* [in] */ __RPC__in_opt IObjectId *pValue);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_AlternateSignatureAlgorithm )( 
            IX509CertificateRequestPkcs10 * This,
            /* [retval][out] */ __RPC__out VARIANT_BOOL *pValue);
        
        /* [propput] */ HRESULT ( STDMETHODCALLTYPE *put_AlternateSignatureAlgorithm )( 
            IX509CertificateRequestPkcs10 * This,
            /* [in] */ VARIANT_BOOL Value);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_RawData )( 
            IX509CertificateRequestPkcs10 * This,
            /* [defaultvalue][in] */ EncodingType Encoding,
            /* [retval][out] */ __RPC__deref_out_opt BSTR *pValue);
        
        HRESULT ( STDMETHODCALLTYPE *InitializeFromTemplateName )( 
            IX509CertificateRequestPkcs10 * This,
            /* [in] */ X509CertificateEnrollmentContext Context,
            /* [in] */ __RPC__in BSTR strTemplateName);
        
        /* [custom] */ HRESULT ( STDMETHODCALLTYPE *InitializeFromPrivateKey )( 
            IX509CertificateRequestPkcs10 * This,
            /* [in] */ X509CertificateEnrollmentContext Context,
            /* [in] */ __RPC__in_opt IX509PrivateKey *pPrivateKey,
            /* [in] */ __RPC__in BSTR strTemplateName);
        
        HRESULT ( STDMETHODCALLTYPE *InitializeFromPublicKey )( 
            IX509CertificateRequestPkcs10 * This,
            /* [in] */ X509CertificateEnrollmentContext Context,
            /* [in] */ __RPC__in_opt IX509PublicKey *pPublicKey,
            /* [in] */ __RPC__in BSTR strTemplateName);
        
        HRESULT ( STDMETHODCALLTYPE *InitializeFromCertificate )( 
            IX509CertificateRequestPkcs10 * This,
            /* [in] */ X509CertificateEnrollmentContext Context,
            /* [in] */ __RPC__in BSTR strCertificate,
            /* [defaultvalue][in] */ EncodingType Encoding,
            /* [defaultvalue][in] */ X509RequestInheritOptions InheritOptions);
        
        HRESULT ( STDMETHODCALLTYPE *InitializeDecode )( 
            IX509CertificateRequestPkcs10 * This,
            /* [in] */ __RPC__in BSTR strEncodedData,
            /* [defaultvalue][in] */ EncodingType Encoding);
        
        HRESULT ( STDMETHODCALLTYPE *CheckSignature )( 
            IX509CertificateRequestPkcs10 * This,
            /* [defaultvalue][in] */ Pkcs10AllowedSignatureTypes AllowedSignatureTypes);
        
        HRESULT ( STDMETHODCALLTYPE *IsSmartCard )( 
            IX509CertificateRequestPkcs10 * This,
            /* [retval][out] */ __RPC__out VARIANT_BOOL *pValue);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_TemplateObjectId )( 
            IX509CertificateRequestPkcs10 * This,
            /* [retval][out] */ __RPC__deref_out_opt IObjectId **ppValue);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_PublicKey )( 
            IX509CertificateRequestPkcs10 * This,
            /* [retval][out] */ __RPC__deref_out_opt IX509PublicKey **ppValue);
        
        /* [custom][propget] */ HRESULT ( STDMETHODCALLTYPE *get_PrivateKey )( 
            IX509CertificateRequestPkcs10 * This,
            /* [retval][out] */ __RPC__deref_out_opt IX509PrivateKey **ppValue);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_NullSigned )( 
            IX509CertificateRequestPkcs10 * This,
            /* [retval][out] */ __RPC__out VARIANT_BOOL *pValue);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_ReuseKey )( 
            IX509CertificateRequestPkcs10 * This,
            /* [retval][out] */ __RPC__out VARIANT_BOOL *pValue);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_OldCertificate )( 
            IX509CertificateRequestPkcs10 * This,
            /* [defaultvalue][in] */ EncodingType Encoding,
            /* [retval][out] */ __RPC__deref_out_opt BSTR *pValue);
        
        /* [custom][propget] */ HRESULT ( STDMETHODCALLTYPE *get_Subject )( 
            IX509CertificateRequestPkcs10 * This,
            /* [retval][out] */ __RPC__deref_out_opt IX500DistinguishedName **ppValue);
        
        /* [custom][propput] */ HRESULT ( STDMETHODCALLTYPE *put_Subject )( 
            IX509CertificateRequestPkcs10 * This,
            /* [in] */ __RPC__in_opt IX500DistinguishedName *pValue);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_CspStatuses )( 
            IX509CertificateRequestPkcs10 * This,
            /* [retval][out] */ __RPC__deref_out_opt ICspStatuses **ppValue);
        
        /* [custom][propget] */ HRESULT ( STDMETHODCALLTYPE *get_SmimeCapabilities )( 
            IX509CertificateRequestPkcs10 * This,
            /* [retval][out] */ __RPC__out VARIANT_BOOL *pValue);
        
        /* [custom][propput] */ HRESULT ( STDMETHODCALLTYPE *put_SmimeCapabilities )( 
            IX509CertificateRequestPkcs10 * This,
            /* [in] */ VARIANT_BOOL Value);
        
        /* [custom][propget] */ HRESULT ( STDMETHODCALLTYPE *get_SignatureInformation )( 
            IX509CertificateRequestPkcs10 * This,
            /* [retval][out] */ __RPC__deref_out_opt IX509SignatureInformation **ppValue);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_KeyContainerNamePrefix )( 
            IX509CertificateRequestPkcs10 * This,
            /* [retval][out] */ __RPC__deref_out_opt BSTR *pValue);
        
        /* [propput] */ HRESULT ( STDMETHODCALLTYPE *put_KeyContainerNamePrefix )( 
            IX509CertificateRequestPkcs10 * This,
            /* [in] */ __RPC__in BSTR Value);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_CryptAttributes )( 
            IX509CertificateRequestPkcs10 * This,
            /* [retval][out] */ __RPC__deref_out_opt ICryptAttributes **ppValue);
        
        /* [custom][propget] */ HRESULT ( STDMETHODCALLTYPE *get_X509Extensions )( 
            IX509CertificateRequestPkcs10 * This,
            /* [retval][out] */ __RPC__deref_out_opt IX509Extensions **ppValue);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_CriticalExtensions )( 
            IX509CertificateRequestPkcs10 * This,
            /* [retval][out] */ __RPC__deref_out_opt IObjectIds **ppValue);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_SuppressOids )( 
            IX509CertificateRequestPkcs10 * This,
            /* [retval][out] */ __RPC__deref_out_opt IObjectIds **ppValue);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_RawDataToBeSigned )( 
            IX509CertificateRequestPkcs10 * This,
            /* [defaultvalue][in] */ EncodingType Encoding,
            /* [retval][out] */ __RPC__deref_out_opt BSTR *pValue);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_Signature )( 
            IX509CertificateRequestPkcs10 * This,
            /* [defaultvalue][in] */ EncodingType Encoding,
            /* [retval][out] */ __RPC__deref_out_opt BSTR *pValue);
        
        HRESULT ( STDMETHODCALLTYPE *GetCspStatuses )( 
            IX509CertificateRequestPkcs10 * This,
            /* [in] */ X509KeySpec KeySpec,
            /* [retval][out] */ __RPC__deref_out_opt ICspStatuses **ppCspStatuses);
        
        END_INTERFACE
    } IX509CertificateRequestPkcs10Vtbl;

    interface IX509CertificateRequestPkcs10
    {
        CONST_VTBL struct IX509CertificateRequestPkcs10Vtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IX509CertificateRequestPkcs10_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IX509CertificateRequestPkcs10_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IX509CertificateRequestPkcs10_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IX509CertificateRequestPkcs10_GetTypeInfoCount(This,pctinfo)	\
    ( (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo) ) 

#define IX509CertificateRequestPkcs10_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    ( (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo) ) 

#define IX509CertificateRequestPkcs10_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    ( (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId) ) 

#define IX509CertificateRequestPkcs10_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    ( (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr) ) 


#define IX509CertificateRequestPkcs10_Initialize(This,Context)	\
    ( (This)->lpVtbl -> Initialize(This,Context) ) 

#define IX509CertificateRequestPkcs10_Encode(This)	\
    ( (This)->lpVtbl -> Encode(This) ) 

#define IX509CertificateRequestPkcs10_ResetForEncode(This)	\
    ( (This)->lpVtbl -> ResetForEncode(This) ) 

#define IX509CertificateRequestPkcs10_GetInnerRequest(This,Level,ppValue)	\
    ( (This)->lpVtbl -> GetInnerRequest(This,Level,ppValue) ) 

#define IX509CertificateRequestPkcs10_get_Type(This,pValue)	\
    ( (This)->lpVtbl -> get_Type(This,pValue) ) 

#define IX509CertificateRequestPkcs10_get_EnrollmentContext(This,pValue)	\
    ( (This)->lpVtbl -> get_EnrollmentContext(This,pValue) ) 

#define IX509CertificateRequestPkcs10_get_Silent(This,pValue)	\
    ( (This)->lpVtbl -> get_Silent(This,pValue) ) 

#define IX509CertificateRequestPkcs10_put_Silent(This,Value)	\
    ( (This)->lpVtbl -> put_Silent(This,Value) ) 

#define IX509CertificateRequestPkcs10_get_ParentWindow(This,pValue)	\
    ( (This)->lpVtbl -> get_ParentWindow(This,pValue) ) 

#define IX509CertificateRequestPkcs10_put_ParentWindow(This,Value)	\
    ( (This)->lpVtbl -> put_ParentWindow(This,Value) ) 

#define IX509CertificateRequestPkcs10_get_UIContextMessage(This,pValue)	\
    ( (This)->lpVtbl -> get_UIContextMessage(This,pValue) ) 

#define IX509CertificateRequestPkcs10_put_UIContextMessage(This,Value)	\
    ( (This)->lpVtbl -> put_UIContextMessage(This,Value) ) 

#define IX509CertificateRequestPkcs10_get_SuppressDefaults(This,pValue)	\
    ( (This)->lpVtbl -> get_SuppressDefaults(This,pValue) ) 

#define IX509CertificateRequestPkcs10_put_SuppressDefaults(This,Value)	\
    ( (This)->lpVtbl -> put_SuppressDefaults(This,Value) ) 

#define IX509CertificateRequestPkcs10_get_RenewalCertificate(This,Encoding,pValue)	\
    ( (This)->lpVtbl -> get_RenewalCertificate(This,Encoding,pValue) ) 

#define IX509CertificateRequestPkcs10_put_RenewalCertificate(This,Encoding,Value)	\
    ( (This)->lpVtbl -> put_RenewalCertificate(This,Encoding,Value) ) 

#define IX509CertificateRequestPkcs10_get_ClientId(This,pValue)	\
    ( (This)->lpVtbl -> get_ClientId(This,pValue) ) 

#define IX509CertificateRequestPkcs10_put_ClientId(This,Value)	\
    ( (This)->lpVtbl -> put_ClientId(This,Value) ) 

#define IX509CertificateRequestPkcs10_get_CspInformations(This,ppValue)	\
    ( (This)->lpVtbl -> get_CspInformations(This,ppValue) ) 

#define IX509CertificateRequestPkcs10_put_CspInformations(This,pValue)	\
    ( (This)->lpVtbl -> put_CspInformations(This,pValue) ) 

#define IX509CertificateRequestPkcs10_get_HashAlgorithm(This,ppValue)	\
    ( (This)->lpVtbl -> get_HashAlgorithm(This,ppValue) ) 

#define IX509CertificateRequestPkcs10_put_HashAlgorithm(This,pValue)	\
    ( (This)->lpVtbl -> put_HashAlgorithm(This,pValue) ) 

#define IX509CertificateRequestPkcs10_get_AlternateSignatureAlgorithm(This,pValue)	\
    ( (This)->lpVtbl -> get_AlternateSignatureAlgorithm(This,pValue) ) 

#define IX509CertificateRequestPkcs10_put_AlternateSignatureAlgorithm(This,Value)	\
    ( (This)->lpVtbl -> put_AlternateSignatureAlgorithm(This,Value) ) 

#define IX509CertificateRequestPkcs10_get_RawData(This,Encoding,pValue)	\
    ( (This)->lpVtbl -> get_RawData(This,Encoding,pValue) ) 


#define IX509CertificateRequestPkcs10_InitializeFromTemplateName(This,Context,strTemplateName)	\
    ( (This)->lpVtbl -> InitializeFromTemplateName(This,Context,strTemplateName) ) 

#define IX509CertificateRequestPkcs10_InitializeFromPrivateKey(This,Context,pPrivateKey,strTemplateName)	\
    ( (This)->lpVtbl -> InitializeFromPrivateKey(This,Context,pPrivateKey,strTemplateName) ) 

#define IX509CertificateRequestPkcs10_InitializeFromPublicKey(This,Context,pPublicKey,strTemplateName)	\
    ( (This)->lpVtbl -> InitializeFromPublicKey(This,Context,pPublicKey,strTemplateName) ) 

#define IX509CertificateRequestPkcs10_InitializeFromCertificate(This,Context,strCertificate,Encoding,InheritOptions)	\
    ( (This)->lpVtbl -> InitializeFromCertificate(This,Context,strCertificate,Encoding,InheritOptions) ) 

#define IX509CertificateRequestPkcs10_InitializeDecode(This,strEncodedData,Encoding)	\
    ( (This)->lpVtbl -> InitializeDecode(This,strEncodedData,Encoding) ) 

#define IX509CertificateRequestPkcs10_CheckSignature(This,AllowedSignatureTypes)	\
    ( (This)->lpVtbl -> CheckSignature(This,AllowedSignatureTypes) ) 

#define IX509CertificateRequestPkcs10_IsSmartCard(This,pValue)	\
    ( (This)->lpVtbl -> IsSmartCard(This,pValue) ) 

#define IX509CertificateRequestPkcs10_get_TemplateObjectId(This,ppValue)	\
    ( (This)->lpVtbl -> get_TemplateObjectId(This,ppValue) ) 

#define IX509CertificateRequestPkcs10_get_PublicKey(This,ppValue)	\
    ( (This)->lpVtbl -> get_PublicKey(This,ppValue) ) 

#define IX509CertificateRequestPkcs10_get_PrivateKey(This,ppValue)	\
    ( (This)->lpVtbl -> get_PrivateKey(This,ppValue) ) 

#define IX509CertificateRequestPkcs10_get_NullSigned(This,pValue)	\
    ( (This)->lpVtbl -> get_NullSigned(This,pValue) ) 

#define IX509CertificateRequestPkcs10_get_ReuseKey(This,pValue)	\
    ( (This)->lpVtbl -> get_ReuseKey(This,pValue) ) 

#define IX509CertificateRequestPkcs10_get_OldCertificate(This,Encoding,pValue)	\
    ( (This)->lpVtbl -> get_OldCertificate(This,Encoding,pValue) ) 

#define IX509CertificateRequestPkcs10_get_Subject(This,ppValue)	\
    ( (This)->lpVtbl -> get_Subject(This,ppValue) ) 

#define IX509CertificateRequestPkcs10_put_Subject(This,pValue)	\
    ( (This)->lpVtbl -> put_Subject(This,pValue) ) 

#define IX509CertificateRequestPkcs10_get_CspStatuses(This,ppValue)	\
    ( (This)->lpVtbl -> get_CspStatuses(This,ppValue) ) 

#define IX509CertificateRequestPkcs10_get_SmimeCapabilities(This,pValue)	\
    ( (This)->lpVtbl -> get_SmimeCapabilities(This,pValue) ) 

#define IX509CertificateRequestPkcs10_put_SmimeCapabilities(This,Value)	\
    ( (This)->lpVtbl -> put_SmimeCapabilities(This,Value) ) 

#define IX509CertificateRequestPkcs10_get_SignatureInformation(This,ppValue)	\
    ( (This)->lpVtbl -> get_SignatureInformation(This,ppValue) ) 

#define IX509CertificateRequestPkcs10_get_KeyContainerNamePrefix(This,pValue)	\
    ( (This)->lpVtbl -> get_KeyContainerNamePrefix(This,pValue) ) 

#define IX509CertificateRequestPkcs10_put_KeyContainerNamePrefix(This,Value)	\
    ( (This)->lpVtbl -> put_KeyContainerNamePrefix(This,Value) ) 

#define IX509CertificateRequestPkcs10_get_CryptAttributes(This,ppValue)	\
    ( (This)->lpVtbl -> get_CryptAttributes(This,ppValue) ) 

#define IX509CertificateRequestPkcs10_get_X509Extensions(This,ppValue)	\
    ( (This)->lpVtbl -> get_X509Extensions(This,ppValue) ) 

#define IX509CertificateRequestPkcs10_get_CriticalExtensions(This,ppValue)	\
    ( (This)->lpVtbl -> get_CriticalExtensions(This,ppValue) ) 

#define IX509CertificateRequestPkcs10_get_SuppressOids(This,ppValue)	\
    ( (This)->lpVtbl -> get_SuppressOids(This,ppValue) ) 

#define IX509CertificateRequestPkcs10_get_RawDataToBeSigned(This,Encoding,pValue)	\
    ( (This)->lpVtbl -> get_RawDataToBeSigned(This,Encoding,pValue) ) 

#define IX509CertificateRequestPkcs10_get_Signature(This,Encoding,pValue)	\
    ( (This)->lpVtbl -> get_Signature(This,Encoding,pValue) ) 

#define IX509CertificateRequestPkcs10_GetCspStatuses(This,KeySpec,ppCspStatuses)	\
    ( (This)->lpVtbl -> GetCspStatuses(This,KeySpec,ppCspStatuses) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IX509CertificateRequestPkcs10_INTERFACE_DEFINED__ */


#ifndef __IX509CertificateRequestCertificate_INTERFACE_DEFINED__
#define __IX509CertificateRequestCertificate_INTERFACE_DEFINED__

/* interface IX509CertificateRequestCertificate */
/* [helpstring][dual][uuid][object] */ 


EXTERN_C const IID IID_IX509CertificateRequestCertificate;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("728ab343-217d-11da-b2a4-000e7bbb2b09")
    IX509CertificateRequestCertificate : public IX509CertificateRequestPkcs10
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE CheckPublicKeySignature( 
            /* [in] */ __RPC__in_opt IX509PublicKey *pPublicKey) = 0;
        
        virtual /* [propget] */ HRESULT STDMETHODCALLTYPE get_Issuer( 
            /* [retval][out] */ __RPC__deref_out_opt IX500DistinguishedName **ppValue) = 0;
        
        virtual /* [propput] */ HRESULT STDMETHODCALLTYPE put_Issuer( 
            /* [in] */ __RPC__in_opt IX500DistinguishedName *pValue) = 0;
        
        virtual /* [propget] */ HRESULT STDMETHODCALLTYPE get_NotBefore( 
            /* [retval][out] */ __RPC__out DATE *pValue) = 0;
        
        virtual /* [propput] */ HRESULT STDMETHODCALLTYPE put_NotBefore( 
            /* [in] */ DATE Value) = 0;
        
        virtual /* [propget] */ HRESULT STDMETHODCALLTYPE get_NotAfter( 
            /* [retval][out] */ __RPC__out DATE *pValue) = 0;
        
        virtual /* [propput] */ HRESULT STDMETHODCALLTYPE put_NotAfter( 
            /* [in] */ DATE Value) = 0;
        
        virtual /* [propget] */ HRESULT STDMETHODCALLTYPE get_SerialNumber( 
            /* [defaultvalue][in] */ EncodingType Encoding,
            /* [retval][out] */ __RPC__deref_out_opt BSTR *pValue) = 0;
        
        virtual /* [propput] */ HRESULT STDMETHODCALLTYPE put_SerialNumber( 
            /* [defaultvalue][in] */ EncodingType Encoding,
            /* [in] */ __RPC__in BSTR Value) = 0;
        
        virtual /* [propget] */ HRESULT STDMETHODCALLTYPE get_SignerCertificate( 
            /* [retval][out] */ __RPC__deref_out_opt ISignerCertificate **ppValue) = 0;
        
        virtual /* [propput] */ HRESULT STDMETHODCALLTYPE put_SignerCertificate( 
            /* [in] */ __RPC__in_opt ISignerCertificate *pValue) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IX509CertificateRequestCertificateVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IX509CertificateRequestCertificate * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IX509CertificateRequestCertificate * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IX509CertificateRequestCertificate * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfoCount )( 
            IX509CertificateRequestCertificate * This,
            /* [out] */ __RPC__out UINT *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfo )( 
            IX509CertificateRequestCertificate * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ __RPC__deref_out_opt ITypeInfo **ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetIDsOfNames )( 
            IX509CertificateRequestCertificate * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [size_is][in] */ __RPC__in_ecount_full(cNames) LPOLESTR *rgszNames,
            /* [range][in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ __RPC__out_ecount_full(cNames) DISPID *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE *Invoke )( 
            IX509CertificateRequestCertificate * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS *pDispParams,
            /* [out] */ VARIANT *pVarResult,
            /* [out] */ EXCEPINFO *pExcepInfo,
            /* [out] */ UINT *puArgErr);
        
        HRESULT ( STDMETHODCALLTYPE *Initialize )( 
            IX509CertificateRequestCertificate * This,
            /* [in] */ X509CertificateEnrollmentContext Context);
        
        HRESULT ( STDMETHODCALLTYPE *Encode )( 
            IX509CertificateRequestCertificate * This);
        
        HRESULT ( STDMETHODCALLTYPE *ResetForEncode )( 
            IX509CertificateRequestCertificate * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetInnerRequest )( 
            IX509CertificateRequestCertificate * This,
            /* [in] */ InnerRequestLevel Level,
            /* [retval][out] */ __RPC__deref_out_opt IX509CertificateRequest **ppValue);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_Type )( 
            IX509CertificateRequestCertificate * This,
            /* [retval][out] */ __RPC__out X509RequestType *pValue);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_EnrollmentContext )( 
            IX509CertificateRequestCertificate * This,
            /* [retval][out] */ __RPC__out X509CertificateEnrollmentContext *pValue);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_Silent )( 
            IX509CertificateRequestCertificate * This,
            /* [retval][out] */ __RPC__out VARIANT_BOOL *pValue);
        
        /* [propput] */ HRESULT ( STDMETHODCALLTYPE *put_Silent )( 
            IX509CertificateRequestCertificate * This,
            /* [in] */ VARIANT_BOOL Value);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_ParentWindow )( 
            IX509CertificateRequestCertificate * This,
            /* [retval][out] */ __RPC__out LONG *pValue);
        
        /* [propput] */ HRESULT ( STDMETHODCALLTYPE *put_ParentWindow )( 
            IX509CertificateRequestCertificate * This,
            /* [in] */ LONG Value);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_UIContextMessage )( 
            IX509CertificateRequestCertificate * This,
            /* [retval][out] */ __RPC__deref_out_opt BSTR *pValue);
        
        /* [propput] */ HRESULT ( STDMETHODCALLTYPE *put_UIContextMessage )( 
            IX509CertificateRequestCertificate * This,
            /* [in] */ __RPC__in BSTR Value);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_SuppressDefaults )( 
            IX509CertificateRequestCertificate * This,
            /* [retval][out] */ __RPC__out VARIANT_BOOL *pValue);
        
        /* [propput] */ HRESULT ( STDMETHODCALLTYPE *put_SuppressDefaults )( 
            IX509CertificateRequestCertificate * This,
            /* [in] */ VARIANT_BOOL Value);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_RenewalCertificate )( 
            IX509CertificateRequestCertificate * This,
            /* [defaultvalue][in] */ EncodingType Encoding,
            /* [retval][out] */ __RPC__deref_out_opt BSTR *pValue);
        
        /* [propput] */ HRESULT ( STDMETHODCALLTYPE *put_RenewalCertificate )( 
            IX509CertificateRequestCertificate * This,
            /* [defaultvalue][in] */ EncodingType Encoding,
            /* [in] */ __RPC__in BSTR Value);
        
        /* [custom][propget] */ HRESULT ( STDMETHODCALLTYPE *get_ClientId )( 
            IX509CertificateRequestCertificate * This,
            /* [retval][out] */ __RPC__out RequestClientInfoClientId *pValue);
        
        /* [custom][propput] */ HRESULT ( STDMETHODCALLTYPE *put_ClientId )( 
            IX509CertificateRequestCertificate * This,
            /* [in] */ RequestClientInfoClientId Value);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_CspInformations )( 
            IX509CertificateRequestCertificate * This,
            /* [retval][out] */ __RPC__deref_out_opt ICspInformations **ppValue);
        
        /* [propput] */ HRESULT ( STDMETHODCALLTYPE *put_CspInformations )( 
            IX509CertificateRequestCertificate * This,
            /* [in] */ __RPC__in_opt ICspInformations *pValue);
        
        /* [custom][propget] */ HRESULT ( STDMETHODCALLTYPE *get_HashAlgorithm )( 
            IX509CertificateRequestCertificate * This,
            /* [retval][out] */ __RPC__deref_out_opt IObjectId **ppValue);
        
        /* [custom][propput] */ HRESULT ( STDMETHODCALLTYPE *put_HashAlgorithm )( 
            IX509CertificateRequestCertificate * This,
            /* [in] */ __RPC__in_opt IObjectId *pValue);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_AlternateSignatureAlgorithm )( 
            IX509CertificateRequestCertificate * This,
            /* [retval][out] */ __RPC__out VARIANT_BOOL *pValue);
        
        /* [propput] */ HRESULT ( STDMETHODCALLTYPE *put_AlternateSignatureAlgorithm )( 
            IX509CertificateRequestCertificate * This,
            /* [in] */ VARIANT_BOOL Value);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_RawData )( 
            IX509CertificateRequestCertificate * This,
            /* [defaultvalue][in] */ EncodingType Encoding,
            /* [retval][out] */ __RPC__deref_out_opt BSTR *pValue);
        
        HRESULT ( STDMETHODCALLTYPE *InitializeFromTemplateName )( 
            IX509CertificateRequestCertificate * This,
            /* [in] */ X509CertificateEnrollmentContext Context,
            /* [in] */ __RPC__in BSTR strTemplateName);
        
        /* [custom] */ HRESULT ( STDMETHODCALLTYPE *InitializeFromPrivateKey )( 
            IX509CertificateRequestCertificate * This,
            /* [in] */ X509CertificateEnrollmentContext Context,
            /* [in] */ __RPC__in_opt IX509PrivateKey *pPrivateKey,
            /* [in] */ __RPC__in BSTR strTemplateName);
        
        HRESULT ( STDMETHODCALLTYPE *InitializeFromPublicKey )( 
            IX509CertificateRequestCertificate * This,
            /* [in] */ X509CertificateEnrollmentContext Context,
            /* [in] */ __RPC__in_opt IX509PublicKey *pPublicKey,
            /* [in] */ __RPC__in BSTR strTemplateName);
        
        HRESULT ( STDMETHODCALLTYPE *InitializeFromCertificate )( 
            IX509CertificateRequestCertificate * This,
            /* [in] */ X509CertificateEnrollmentContext Context,
            /* [in] */ __RPC__in BSTR strCertificate,
            /* [defaultvalue][in] */ EncodingType Encoding,
            /* [defaultvalue][in] */ X509RequestInheritOptions InheritOptions);
        
        HRESULT ( STDMETHODCALLTYPE *InitializeDecode )( 
            IX509CertificateRequestCertificate * This,
            /* [in] */ __RPC__in BSTR strEncodedData,
            /* [defaultvalue][in] */ EncodingType Encoding);
        
        HRESULT ( STDMETHODCALLTYPE *CheckSignature )( 
            IX509CertificateRequestCertificate * This,
            /* [defaultvalue][in] */ Pkcs10AllowedSignatureTypes AllowedSignatureTypes);
        
        HRESULT ( STDMETHODCALLTYPE *IsSmartCard )( 
            IX509CertificateRequestCertificate * This,
            /* [retval][out] */ __RPC__out VARIANT_BOOL *pValue);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_TemplateObjectId )( 
            IX509CertificateRequestCertificate * This,
            /* [retval][out] */ __RPC__deref_out_opt IObjectId **ppValue);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_PublicKey )( 
            IX509CertificateRequestCertificate * This,
            /* [retval][out] */ __RPC__deref_out_opt IX509PublicKey **ppValue);
        
        /* [custom][propget] */ HRESULT ( STDMETHODCALLTYPE *get_PrivateKey )( 
            IX509CertificateRequestCertificate * This,
            /* [retval][out] */ __RPC__deref_out_opt IX509PrivateKey **ppValue);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_NullSigned )( 
            IX509CertificateRequestCertificate * This,
            /* [retval][out] */ __RPC__out VARIANT_BOOL *pValue);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_ReuseKey )( 
            IX509CertificateRequestCertificate * This,
            /* [retval][out] */ __RPC__out VARIANT_BOOL *pValue);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_OldCertificate )( 
            IX509CertificateRequestCertificate * This,
            /* [defaultvalue][in] */ EncodingType Encoding,
            /* [retval][out] */ __RPC__deref_out_opt BSTR *pValue);
        
        /* [custom][propget] */ HRESULT ( STDMETHODCALLTYPE *get_Subject )( 
            IX509CertificateRequestCertificate * This,
            /* [retval][out] */ __RPC__deref_out_opt IX500DistinguishedName **ppValue);
        
        /* [custom][propput] */ HRESULT ( STDMETHODCALLTYPE *put_Subject )( 
            IX509CertificateRequestCertificate * This,
            /* [in] */ __RPC__in_opt IX500DistinguishedName *pValue);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_CspStatuses )( 
            IX509CertificateRequestCertificate * This,
            /* [retval][out] */ __RPC__deref_out_opt ICspStatuses **ppValue);
        
        /* [custom][propget] */ HRESULT ( STDMETHODCALLTYPE *get_SmimeCapabilities )( 
            IX509CertificateRequestCertificate * This,
            /* [retval][out] */ __RPC__out VARIANT_BOOL *pValue);
        
        /* [custom][propput] */ HRESULT ( STDMETHODCALLTYPE *put_SmimeCapabilities )( 
            IX509CertificateRequestCertificate * This,
            /* [in] */ VARIANT_BOOL Value);
        
        /* [custom][propget] */ HRESULT ( STDMETHODCALLTYPE *get_SignatureInformation )( 
            IX509CertificateRequestCertificate * This,
            /* [retval][out] */ __RPC__deref_out_opt IX509SignatureInformation **ppValue);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_KeyContainerNamePrefix )( 
            IX509CertificateRequestCertificate * This,
            /* [retval][out] */ __RPC__deref_out_opt BSTR *pValue);
        
        /* [propput] */ HRESULT ( STDMETHODCALLTYPE *put_KeyContainerNamePrefix )( 
            IX509CertificateRequestCertificate * This,
            /* [in] */ __RPC__in BSTR Value);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_CryptAttributes )( 
            IX509CertificateRequestCertificate * This,
            /* [retval][out] */ __RPC__deref_out_opt ICryptAttributes **ppValue);
        
        /* [custom][propget] */ HRESULT ( STDMETHODCALLTYPE *get_X509Extensions )( 
            IX509CertificateRequestCertificate * This,
            /* [retval][out] */ __RPC__deref_out_opt IX509Extensions **ppValue);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_CriticalExtensions )( 
            IX509CertificateRequestCertificate * This,
            /* [retval][out] */ __RPC__deref_out_opt IObjectIds **ppValue);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_SuppressOids )( 
            IX509CertificateRequestCertificate * This,
            /* [retval][out] */ __RPC__deref_out_opt IObjectIds **ppValue);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_RawDataToBeSigned )( 
            IX509CertificateRequestCertificate * This,
            /* [defaultvalue][in] */ EncodingType Encoding,
            /* [retval][out] */ __RPC__deref_out_opt BSTR *pValue);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_Signature )( 
            IX509CertificateRequestCertificate * This,
            /* [defaultvalue][in] */ EncodingType Encoding,
            /* [retval][out] */ __RPC__deref_out_opt BSTR *pValue);
        
        HRESULT ( STDMETHODCALLTYPE *GetCspStatuses )( 
            IX509CertificateRequestCertificate * This,
            /* [in] */ X509KeySpec KeySpec,
            /* [retval][out] */ __RPC__deref_out_opt ICspStatuses **ppCspStatuses);
        
        HRESULT ( STDMETHODCALLTYPE *CheckPublicKeySignature )( 
            IX509CertificateRequestCertificate * This,
            /* [in] */ __RPC__in_opt IX509PublicKey *pPublicKey);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_Issuer )( 
            IX509CertificateRequestCertificate * This,
            /* [retval][out] */ __RPC__deref_out_opt IX500DistinguishedName **ppValue);
        
        /* [propput] */ HRESULT ( STDMETHODCALLTYPE *put_Issuer )( 
            IX509CertificateRequestCertificate * This,
            /* [in] */ __RPC__in_opt IX500DistinguishedName *pValue);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_NotBefore )( 
            IX509CertificateRequestCertificate * This,
            /* [retval][out] */ __RPC__out DATE *pValue);
        
        /* [propput] */ HRESULT ( STDMETHODCALLTYPE *put_NotBefore )( 
            IX509CertificateRequestCertificate * This,
            /* [in] */ DATE Value);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_NotAfter )( 
            IX509CertificateRequestCertificate * This,
            /* [retval][out] */ __RPC__out DATE *pValue);
        
        /* [propput] */ HRESULT ( STDMETHODCALLTYPE *put_NotAfter )( 
            IX509CertificateRequestCertificate * This,
            /* [in] */ DATE Value);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_SerialNumber )( 
            IX509CertificateRequestCertificate * This,
            /* [defaultvalue][in] */ EncodingType Encoding,
            /* [retval][out] */ __RPC__deref_out_opt BSTR *pValue);
        
        /* [propput] */ HRESULT ( STDMETHODCALLTYPE *put_SerialNumber )( 
            IX509CertificateRequestCertificate * This,
            /* [defaultvalue][in] */ EncodingType Encoding,
            /* [in] */ __RPC__in BSTR Value);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_SignerCertificate )( 
            IX509CertificateRequestCertificate * This,
            /* [retval][out] */ __RPC__deref_out_opt ISignerCertificate **ppValue);
        
        /* [propput] */ HRESULT ( STDMETHODCALLTYPE *put_SignerCertificate )( 
            IX509CertificateRequestCertificate * This,
            /* [in] */ __RPC__in_opt ISignerCertificate *pValue);
        
        END_INTERFACE
    } IX509CertificateRequestCertificateVtbl;

    interface IX509CertificateRequestCertificate
    {
        CONST_VTBL struct IX509CertificateRequestCertificateVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IX509CertificateRequestCertificate_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IX509CertificateRequestCertificate_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IX509CertificateRequestCertificate_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IX509CertificateRequestCertificate_GetTypeInfoCount(This,pctinfo)	\
    ( (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo) ) 

#define IX509CertificateRequestCertificate_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    ( (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo) ) 

#define IX509CertificateRequestCertificate_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    ( (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId) ) 

#define IX509CertificateRequestCertificate_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    ( (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr) ) 


#define IX509CertificateRequestCertificate_Initialize(This,Context)	\
    ( (This)->lpVtbl -> Initialize(This,Context) ) 

#define IX509CertificateRequestCertificate_Encode(This)	\
    ( (This)->lpVtbl -> Encode(This) ) 

#define IX509CertificateRequestCertificate_ResetForEncode(This)	\
    ( (This)->lpVtbl -> ResetForEncode(This) ) 

#define IX509CertificateRequestCertificate_GetInnerRequest(This,Level,ppValue)	\
    ( (This)->lpVtbl -> GetInnerRequest(This,Level,ppValue) ) 

#define IX509CertificateRequestCertificate_get_Type(This,pValue)	\
    ( (This)->lpVtbl -> get_Type(This,pValue) ) 

#define IX509CertificateRequestCertificate_get_EnrollmentContext(This,pValue)	\
    ( (This)->lpVtbl -> get_EnrollmentContext(This,pValue) ) 

#define IX509CertificateRequestCertificate_get_Silent(This,pValue)	\
    ( (This)->lpVtbl -> get_Silent(This,pValue) ) 

#define IX509CertificateRequestCertificate_put_Silent(This,Value)	\
    ( (This)->lpVtbl -> put_Silent(This,Value) ) 

#define IX509CertificateRequestCertificate_get_ParentWindow(This,pValue)	\
    ( (This)->lpVtbl -> get_ParentWindow(This,pValue) ) 

#define IX509CertificateRequestCertificate_put_ParentWindow(This,Value)	\
    ( (This)->lpVtbl -> put_ParentWindow(This,Value) ) 

#define IX509CertificateRequestCertificate_get_UIContextMessage(This,pValue)	\
    ( (This)->lpVtbl -> get_UIContextMessage(This,pValue) ) 

#define IX509CertificateRequestCertificate_put_UIContextMessage(This,Value)	\
    ( (This)->lpVtbl -> put_UIContextMessage(This,Value) ) 

#define IX509CertificateRequestCertificate_get_SuppressDefaults(This,pValue)	\
    ( (This)->lpVtbl -> get_SuppressDefaults(This,pValue) ) 

#define IX509CertificateRequestCertificate_put_SuppressDefaults(This,Value)	\
    ( (This)->lpVtbl -> put_SuppressDefaults(This,Value) ) 

#define IX509CertificateRequestCertificate_get_RenewalCertificate(This,Encoding,pValue)	\
    ( (This)->lpVtbl -> get_RenewalCertificate(This,Encoding,pValue) ) 

#define IX509CertificateRequestCertificate_put_RenewalCertificate(This,Encoding,Value)	\
    ( (This)->lpVtbl -> put_RenewalCertificate(This,Encoding,Value) ) 

#define IX509CertificateRequestCertificate_get_ClientId(This,pValue)	\
    ( (This)->lpVtbl -> get_ClientId(This,pValue) ) 

#define IX509CertificateRequestCertificate_put_ClientId(This,Value)	\
    ( (This)->lpVtbl -> put_ClientId(This,Value) ) 

#define IX509CertificateRequestCertificate_get_CspInformations(This,ppValue)	\
    ( (This)->lpVtbl -> get_CspInformations(This,ppValue) ) 

#define IX509CertificateRequestCertificate_put_CspInformations(This,pValue)	\
    ( (This)->lpVtbl -> put_CspInformations(This,pValue) ) 

#define IX509CertificateRequestCertificate_get_HashAlgorithm(This,ppValue)	\
    ( (This)->lpVtbl -> get_HashAlgorithm(This,ppValue) ) 

#define IX509CertificateRequestCertificate_put_HashAlgorithm(This,pValue)	\
    ( (This)->lpVtbl -> put_HashAlgorithm(This,pValue) ) 

#define IX509CertificateRequestCertificate_get_AlternateSignatureAlgorithm(This,pValue)	\
    ( (This)->lpVtbl -> get_AlternateSignatureAlgorithm(This,pValue) ) 

#define IX509CertificateRequestCertificate_put_AlternateSignatureAlgorithm(This,Value)	\
    ( (This)->lpVtbl -> put_AlternateSignatureAlgorithm(This,Value) ) 

#define IX509CertificateRequestCertificate_get_RawData(This,Encoding,pValue)	\
    ( (This)->lpVtbl -> get_RawData(This,Encoding,pValue) ) 


#define IX509CertificateRequestCertificate_InitializeFromTemplateName(This,Context,strTemplateName)	\
    ( (This)->lpVtbl -> InitializeFromTemplateName(This,Context,strTemplateName) ) 

#define IX509CertificateRequestCertificate_InitializeFromPrivateKey(This,Context,pPrivateKey,strTemplateName)	\
    ( (This)->lpVtbl -> InitializeFromPrivateKey(This,Context,pPrivateKey,strTemplateName) ) 

#define IX509CertificateRequestCertificate_InitializeFromPublicKey(This,Context,pPublicKey,strTemplateName)	\
    ( (This)->lpVtbl -> InitializeFromPublicKey(This,Context,pPublicKey,strTemplateName) ) 

#define IX509CertificateRequestCertificate_InitializeFromCertificate(This,Context,strCertificate,Encoding,InheritOptions)	\
    ( (This)->lpVtbl -> InitializeFromCertificate(This,Context,strCertificate,Encoding,InheritOptions) ) 

#define IX509CertificateRequestCertificate_InitializeDecode(This,strEncodedData,Encoding)	\
    ( (This)->lpVtbl -> InitializeDecode(This,strEncodedData,Encoding) ) 

#define IX509CertificateRequestCertificate_CheckSignature(This,AllowedSignatureTypes)	\
    ( (This)->lpVtbl -> CheckSignature(This,AllowedSignatureTypes) ) 

#define IX509CertificateRequestCertificate_IsSmartCard(This,pValue)	\
    ( (This)->lpVtbl -> IsSmartCard(This,pValue) ) 

#define IX509CertificateRequestCertificate_get_TemplateObjectId(This,ppValue)	\
    ( (This)->lpVtbl -> get_TemplateObjectId(This,ppValue) ) 

#define IX509CertificateRequestCertificate_get_PublicKey(This,ppValue)	\
    ( (This)->lpVtbl -> get_PublicKey(This,ppValue) ) 

#define IX509CertificateRequestCertificate_get_PrivateKey(This,ppValue)	\
    ( (This)->lpVtbl -> get_PrivateKey(This,ppValue) ) 

#define IX509CertificateRequestCertificate_get_NullSigned(This,pValue)	\
    ( (This)->lpVtbl -> get_NullSigned(This,pValue) ) 

#define IX509CertificateRequestCertificate_get_ReuseKey(This,pValue)	\
    ( (This)->lpVtbl -> get_ReuseKey(This,pValue) ) 

#define IX509CertificateRequestCertificate_get_OldCertificate(This,Encoding,pValue)	\
    ( (This)->lpVtbl -> get_OldCertificate(This,Encoding,pValue) ) 

#define IX509CertificateRequestCertificate_get_Subject(This,ppValue)	\
    ( (This)->lpVtbl -> get_Subject(This,ppValue) ) 

#define IX509CertificateRequestCertificate_put_Subject(This,pValue)	\
    ( (This)->lpVtbl -> put_Subject(This,pValue) ) 

#define IX509CertificateRequestCertificate_get_CspStatuses(This,ppValue)	\
    ( (This)->lpVtbl -> get_CspStatuses(This,ppValue) ) 

#define IX509CertificateRequestCertificate_get_SmimeCapabilities(This,pValue)	\
    ( (This)->lpVtbl -> get_SmimeCapabilities(This,pValue) ) 

#define IX509CertificateRequestCertificate_put_SmimeCapabilities(This,Value)	\
    ( (This)->lpVtbl -> put_SmimeCapabilities(This,Value) ) 

#define IX509CertificateRequestCertificate_get_SignatureInformation(This,ppValue)	\
    ( (This)->lpVtbl -> get_SignatureInformation(This,ppValue) ) 

#define IX509CertificateRequestCertificate_get_KeyContainerNamePrefix(This,pValue)	\
    ( (This)->lpVtbl -> get_KeyContainerNamePrefix(This,pValue) ) 

#define IX509CertificateRequestCertificate_put_KeyContainerNamePrefix(This,Value)	\
    ( (This)->lpVtbl -> put_KeyContainerNamePrefix(This,Value) ) 

#define IX509CertificateRequestCertificate_get_CryptAttributes(This,ppValue)	\
    ( (This)->lpVtbl -> get_CryptAttributes(This,ppValue) ) 

#define IX509CertificateRequestCertificate_get_X509Extensions(This,ppValue)	\
    ( (This)->lpVtbl -> get_X509Extensions(This,ppValue) ) 

#define IX509CertificateRequestCertificate_get_CriticalExtensions(This,ppValue)	\
    ( (This)->lpVtbl -> get_CriticalExtensions(This,ppValue) ) 

#define IX509CertificateRequestCertificate_get_SuppressOids(This,ppValue)	\
    ( (This)->lpVtbl -> get_SuppressOids(This,ppValue) ) 

#define IX509CertificateRequestCertificate_get_RawDataToBeSigned(This,Encoding,pValue)	\
    ( (This)->lpVtbl -> get_RawDataToBeSigned(This,Encoding,pValue) ) 

#define IX509CertificateRequestCertificate_get_Signature(This,Encoding,pValue)	\
    ( (This)->lpVtbl -> get_Signature(This,Encoding,pValue) ) 

#define IX509CertificateRequestCertificate_GetCspStatuses(This,KeySpec,ppCspStatuses)	\
    ( (This)->lpVtbl -> GetCspStatuses(This,KeySpec,ppCspStatuses) ) 


#define IX509CertificateRequestCertificate_CheckPublicKeySignature(This,pPublicKey)	\
    ( (This)->lpVtbl -> CheckPublicKeySignature(This,pPublicKey) ) 

#define IX509CertificateRequestCertificate_get_Issuer(This,ppValue)	\
    ( (This)->lpVtbl -> get_Issuer(This,ppValue) ) 

#define IX509CertificateRequestCertificate_put_Issuer(This,pValue)	\
    ( (This)->lpVtbl -> put_Issuer(This,pValue) ) 

#define IX509CertificateRequestCertificate_get_NotBefore(This,pValue)	\
    ( (This)->lpVtbl -> get_NotBefore(This,pValue) ) 

#define IX509CertificateRequestCertificate_put_NotBefore(This,Value)	\
    ( (This)->lpVtbl -> put_NotBefore(This,Value) ) 

#define IX509CertificateRequestCertificate_get_NotAfter(This,pValue)	\
    ( (This)->lpVtbl -> get_NotAfter(This,pValue) ) 

#define IX509CertificateRequestCertificate_put_NotAfter(This,Value)	\
    ( (This)->lpVtbl -> put_NotAfter(This,Value) ) 

#define IX509CertificateRequestCertificate_get_SerialNumber(This,Encoding,pValue)	\
    ( (This)->lpVtbl -> get_SerialNumber(This,Encoding,pValue) ) 

#define IX509CertificateRequestCertificate_put_SerialNumber(This,Encoding,Value)	\
    ( (This)->lpVtbl -> put_SerialNumber(This,Encoding,Value) ) 

#define IX509CertificateRequestCertificate_get_SignerCertificate(This,ppValue)	\
    ( (This)->lpVtbl -> get_SignerCertificate(This,ppValue) ) 

#define IX509CertificateRequestCertificate_put_SignerCertificate(This,pValue)	\
    ( (This)->lpVtbl -> put_SignerCertificate(This,pValue) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IX509CertificateRequestCertificate_INTERFACE_DEFINED__ */


#ifndef __IX509CertificateRequestPkcs7_INTERFACE_DEFINED__
#define __IX509CertificateRequestPkcs7_INTERFACE_DEFINED__

/* interface IX509CertificateRequestPkcs7 */
/* [helpstring][dual][uuid][object] */ 


EXTERN_C const IID IID_IX509CertificateRequestPkcs7;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("728ab344-217d-11da-b2a4-000e7bbb2b09")
    IX509CertificateRequestPkcs7 : public IX509CertificateRequest
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE InitializeFromTemplateName( 
            /* [in] */ X509CertificateEnrollmentContext Context,
            /* [in] */ __RPC__in BSTR strTemplateName) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE InitializeFromCertificate( 
            /* [in] */ X509CertificateEnrollmentContext Context,
            /* [in] */ VARIANT_BOOL RenewalRequest,
            /* [in] */ __RPC__in BSTR strCertificate,
            /* [defaultvalue][in] */ EncodingType Encoding = XCN_CRYPT_STRING_BASE64,
            /* [defaultvalue][in] */ X509RequestInheritOptions InheritOptions = InheritDefault) = 0;
        
        virtual /* [custom] */ HRESULT STDMETHODCALLTYPE InitializeFromInnerRequest( 
            /* [in] */ __RPC__in_opt IX509CertificateRequest *pInnerRequest) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE InitializeDecode( 
            /* [in] */ __RPC__in BSTR strEncodedData,
            /* [defaultvalue][in] */ EncodingType Encoding = XCN_CRYPT_STRING_BASE64) = 0;
        
        virtual /* [custom][propget] */ HRESULT STDMETHODCALLTYPE get_RequesterName( 
            /* [retval][out] */ __RPC__deref_out_opt BSTR *pValue) = 0;
        
        virtual /* [custom][propput] */ HRESULT STDMETHODCALLTYPE put_RequesterName( 
            /* [in] */ __RPC__in BSTR Value) = 0;
        
        virtual /* [propget] */ HRESULT STDMETHODCALLTYPE get_SignerCertificate( 
            /* [retval][out] */ __RPC__deref_out_opt ISignerCertificate **ppValue) = 0;
        
        virtual /* [propput] */ HRESULT STDMETHODCALLTYPE put_SignerCertificate( 
            /* [in] */ __RPC__in_opt ISignerCertificate *pValue) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IX509CertificateRequestPkcs7Vtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IX509CertificateRequestPkcs7 * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IX509CertificateRequestPkcs7 * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IX509CertificateRequestPkcs7 * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfoCount )( 
            IX509CertificateRequestPkcs7 * This,
            /* [out] */ __RPC__out UINT *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfo )( 
            IX509CertificateRequestPkcs7 * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ __RPC__deref_out_opt ITypeInfo **ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetIDsOfNames )( 
            IX509CertificateRequestPkcs7 * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [size_is][in] */ __RPC__in_ecount_full(cNames) LPOLESTR *rgszNames,
            /* [range][in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ __RPC__out_ecount_full(cNames) DISPID *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE *Invoke )( 
            IX509CertificateRequestPkcs7 * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS *pDispParams,
            /* [out] */ VARIANT *pVarResult,
            /* [out] */ EXCEPINFO *pExcepInfo,
            /* [out] */ UINT *puArgErr);
        
        HRESULT ( STDMETHODCALLTYPE *Initialize )( 
            IX509CertificateRequestPkcs7 * This,
            /* [in] */ X509CertificateEnrollmentContext Context);
        
        HRESULT ( STDMETHODCALLTYPE *Encode )( 
            IX509CertificateRequestPkcs7 * This);
        
        HRESULT ( STDMETHODCALLTYPE *ResetForEncode )( 
            IX509CertificateRequestPkcs7 * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetInnerRequest )( 
            IX509CertificateRequestPkcs7 * This,
            /* [in] */ InnerRequestLevel Level,
            /* [retval][out] */ __RPC__deref_out_opt IX509CertificateRequest **ppValue);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_Type )( 
            IX509CertificateRequestPkcs7 * This,
            /* [retval][out] */ __RPC__out X509RequestType *pValue);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_EnrollmentContext )( 
            IX509CertificateRequestPkcs7 * This,
            /* [retval][out] */ __RPC__out X509CertificateEnrollmentContext *pValue);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_Silent )( 
            IX509CertificateRequestPkcs7 * This,
            /* [retval][out] */ __RPC__out VARIANT_BOOL *pValue);
        
        /* [propput] */ HRESULT ( STDMETHODCALLTYPE *put_Silent )( 
            IX509CertificateRequestPkcs7 * This,
            /* [in] */ VARIANT_BOOL Value);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_ParentWindow )( 
            IX509CertificateRequestPkcs7 * This,
            /* [retval][out] */ __RPC__out LONG *pValue);
        
        /* [propput] */ HRESULT ( STDMETHODCALLTYPE *put_ParentWindow )( 
            IX509CertificateRequestPkcs7 * This,
            /* [in] */ LONG Value);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_UIContextMessage )( 
            IX509CertificateRequestPkcs7 * This,
            /* [retval][out] */ __RPC__deref_out_opt BSTR *pValue);
        
        /* [propput] */ HRESULT ( STDMETHODCALLTYPE *put_UIContextMessage )( 
            IX509CertificateRequestPkcs7 * This,
            /* [in] */ __RPC__in BSTR Value);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_SuppressDefaults )( 
            IX509CertificateRequestPkcs7 * This,
            /* [retval][out] */ __RPC__out VARIANT_BOOL *pValue);
        
        /* [propput] */ HRESULT ( STDMETHODCALLTYPE *put_SuppressDefaults )( 
            IX509CertificateRequestPkcs7 * This,
            /* [in] */ VARIANT_BOOL Value);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_RenewalCertificate )( 
            IX509CertificateRequestPkcs7 * This,
            /* [defaultvalue][in] */ EncodingType Encoding,
            /* [retval][out] */ __RPC__deref_out_opt BSTR *pValue);
        
        /* [propput] */ HRESULT ( STDMETHODCALLTYPE *put_RenewalCertificate )( 
            IX509CertificateRequestPkcs7 * This,
            /* [defaultvalue][in] */ EncodingType Encoding,
            /* [in] */ __RPC__in BSTR Value);
        
        /* [custom][propget] */ HRESULT ( STDMETHODCALLTYPE *get_ClientId )( 
            IX509CertificateRequestPkcs7 * This,
            /* [retval][out] */ __RPC__out RequestClientInfoClientId *pValue);
        
        /* [custom][propput] */ HRESULT ( STDMETHODCALLTYPE *put_ClientId )( 
            IX509CertificateRequestPkcs7 * This,
            /* [in] */ RequestClientInfoClientId Value);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_CspInformations )( 
            IX509CertificateRequestPkcs7 * This,
            /* [retval][out] */ __RPC__deref_out_opt ICspInformations **ppValue);
        
        /* [propput] */ HRESULT ( STDMETHODCALLTYPE *put_CspInformations )( 
            IX509CertificateRequestPkcs7 * This,
            /* [in] */ __RPC__in_opt ICspInformations *pValue);
        
        /* [custom][propget] */ HRESULT ( STDMETHODCALLTYPE *get_HashAlgorithm )( 
            IX509CertificateRequestPkcs7 * This,
            /* [retval][out] */ __RPC__deref_out_opt IObjectId **ppValue);
        
        /* [custom][propput] */ HRESULT ( STDMETHODCALLTYPE *put_HashAlgorithm )( 
            IX509CertificateRequestPkcs7 * This,
            /* [in] */ __RPC__in_opt IObjectId *pValue);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_AlternateSignatureAlgorithm )( 
            IX509CertificateRequestPkcs7 * This,
            /* [retval][out] */ __RPC__out VARIANT_BOOL *pValue);
        
        /* [propput] */ HRESULT ( STDMETHODCALLTYPE *put_AlternateSignatureAlgorithm )( 
            IX509CertificateRequestPkcs7 * This,
            /* [in] */ VARIANT_BOOL Value);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_RawData )( 
            IX509CertificateRequestPkcs7 * This,
            /* [defaultvalue][in] */ EncodingType Encoding,
            /* [retval][out] */ __RPC__deref_out_opt BSTR *pValue);
        
        HRESULT ( STDMETHODCALLTYPE *InitializeFromTemplateName )( 
            IX509CertificateRequestPkcs7 * This,
            /* [in] */ X509CertificateEnrollmentContext Context,
            /* [in] */ __RPC__in BSTR strTemplateName);
        
        HRESULT ( STDMETHODCALLTYPE *InitializeFromCertificate )( 
            IX509CertificateRequestPkcs7 * This,
            /* [in] */ X509CertificateEnrollmentContext Context,
            /* [in] */ VARIANT_BOOL RenewalRequest,
            /* [in] */ __RPC__in BSTR strCertificate,
            /* [defaultvalue][in] */ EncodingType Encoding,
            /* [defaultvalue][in] */ X509RequestInheritOptions InheritOptions);
        
        /* [custom] */ HRESULT ( STDMETHODCALLTYPE *InitializeFromInnerRequest )( 
            IX509CertificateRequestPkcs7 * This,
            /* [in] */ __RPC__in_opt IX509CertificateRequest *pInnerRequest);
        
        HRESULT ( STDMETHODCALLTYPE *InitializeDecode )( 
            IX509CertificateRequestPkcs7 * This,
            /* [in] */ __RPC__in BSTR strEncodedData,
            /* [defaultvalue][in] */ EncodingType Encoding);
        
        /* [custom][propget] */ HRESULT ( STDMETHODCALLTYPE *get_RequesterName )( 
            IX509CertificateRequestPkcs7 * This,
            /* [retval][out] */ __RPC__deref_out_opt BSTR *pValue);
        
        /* [custom][propput] */ HRESULT ( STDMETHODCALLTYPE *put_RequesterName )( 
            IX509CertificateRequestPkcs7 * This,
            /* [in] */ __RPC__in BSTR Value);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_SignerCertificate )( 
            IX509CertificateRequestPkcs7 * This,
            /* [retval][out] */ __RPC__deref_out_opt ISignerCertificate **ppValue);
        
        /* [propput] */ HRESULT ( STDMETHODCALLTYPE *put_SignerCertificate )( 
            IX509CertificateRequestPkcs7 * This,
            /* [in] */ __RPC__in_opt ISignerCertificate *pValue);
        
        END_INTERFACE
    } IX509CertificateRequestPkcs7Vtbl;

    interface IX509CertificateRequestPkcs7
    {
        CONST_VTBL struct IX509CertificateRequestPkcs7Vtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IX509CertificateRequestPkcs7_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IX509CertificateRequestPkcs7_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IX509CertificateRequestPkcs7_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IX509CertificateRequestPkcs7_GetTypeInfoCount(This,pctinfo)	\
    ( (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo) ) 

#define IX509CertificateRequestPkcs7_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    ( (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo) ) 

#define IX509CertificateRequestPkcs7_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    ( (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId) ) 

#define IX509CertificateRequestPkcs7_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    ( (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr) ) 


#define IX509CertificateRequestPkcs7_Initialize(This,Context)	\
    ( (This)->lpVtbl -> Initialize(This,Context) ) 

#define IX509CertificateRequestPkcs7_Encode(This)	\
    ( (This)->lpVtbl -> Encode(This) ) 

#define IX509CertificateRequestPkcs7_ResetForEncode(This)	\
    ( (This)->lpVtbl -> ResetForEncode(This) ) 

#define IX509CertificateRequestPkcs7_GetInnerRequest(This,Level,ppValue)	\
    ( (This)->lpVtbl -> GetInnerRequest(This,Level,ppValue) ) 

#define IX509CertificateRequestPkcs7_get_Type(This,pValue)	\
    ( (This)->lpVtbl -> get_Type(This,pValue) ) 

#define IX509CertificateRequestPkcs7_get_EnrollmentContext(This,pValue)	\
    ( (This)->lpVtbl -> get_EnrollmentContext(This,pValue) ) 

#define IX509CertificateRequestPkcs7_get_Silent(This,pValue)	\
    ( (This)->lpVtbl -> get_Silent(This,pValue) ) 

#define IX509CertificateRequestPkcs7_put_Silent(This,Value)	\
    ( (This)->lpVtbl -> put_Silent(This,Value) ) 

#define IX509CertificateRequestPkcs7_get_ParentWindow(This,pValue)	\
    ( (This)->lpVtbl -> get_ParentWindow(This,pValue) ) 

#define IX509CertificateRequestPkcs7_put_ParentWindow(This,Value)	\
    ( (This)->lpVtbl -> put_ParentWindow(This,Value) ) 

#define IX509CertificateRequestPkcs7_get_UIContextMessage(This,pValue)	\
    ( (This)->lpVtbl -> get_UIContextMessage(This,pValue) ) 

#define IX509CertificateRequestPkcs7_put_UIContextMessage(This,Value)	\
    ( (This)->lpVtbl -> put_UIContextMessage(This,Value) ) 

#define IX509CertificateRequestPkcs7_get_SuppressDefaults(This,pValue)	\
    ( (This)->lpVtbl -> get_SuppressDefaults(This,pValue) ) 

#define IX509CertificateRequestPkcs7_put_SuppressDefaults(This,Value)	\
    ( (This)->lpVtbl -> put_SuppressDefaults(This,Value) ) 

#define IX509CertificateRequestPkcs7_get_RenewalCertificate(This,Encoding,pValue)	\
    ( (This)->lpVtbl -> get_RenewalCertificate(This,Encoding,pValue) ) 

#define IX509CertificateRequestPkcs7_put_RenewalCertificate(This,Encoding,Value)	\
    ( (This)->lpVtbl -> put_RenewalCertificate(This,Encoding,Value) ) 

#define IX509CertificateRequestPkcs7_get_ClientId(This,pValue)	\
    ( (This)->lpVtbl -> get_ClientId(This,pValue) ) 

#define IX509CertificateRequestPkcs7_put_ClientId(This,Value)	\
    ( (This)->lpVtbl -> put_ClientId(This,Value) ) 

#define IX509CertificateRequestPkcs7_get_CspInformations(This,ppValue)	\
    ( (This)->lpVtbl -> get_CspInformations(This,ppValue) ) 

#define IX509CertificateRequestPkcs7_put_CspInformations(This,pValue)	\
    ( (This)->lpVtbl -> put_CspInformations(This,pValue) ) 

#define IX509CertificateRequestPkcs7_get_HashAlgorithm(This,ppValue)	\
    ( (This)->lpVtbl -> get_HashAlgorithm(This,ppValue) ) 

#define IX509CertificateRequestPkcs7_put_HashAlgorithm(This,pValue)	\
    ( (This)->lpVtbl -> put_HashAlgorithm(This,pValue) ) 

#define IX509CertificateRequestPkcs7_get_AlternateSignatureAlgorithm(This,pValue)	\
    ( (This)->lpVtbl -> get_AlternateSignatureAlgorithm(This,pValue) ) 

#define IX509CertificateRequestPkcs7_put_AlternateSignatureAlgorithm(This,Value)	\
    ( (This)->lpVtbl -> put_AlternateSignatureAlgorithm(This,Value) ) 

#define IX509CertificateRequestPkcs7_get_RawData(This,Encoding,pValue)	\
    ( (This)->lpVtbl -> get_RawData(This,Encoding,pValue) ) 


#define IX509CertificateRequestPkcs7_InitializeFromTemplateName(This,Context,strTemplateName)	\
    ( (This)->lpVtbl -> InitializeFromTemplateName(This,Context,strTemplateName) ) 

#define IX509CertificateRequestPkcs7_InitializeFromCertificate(This,Context,RenewalRequest,strCertificate,Encoding,InheritOptions)	\
    ( (This)->lpVtbl -> InitializeFromCertificate(This,Context,RenewalRequest,strCertificate,Encoding,InheritOptions) ) 

#define IX509CertificateRequestPkcs7_InitializeFromInnerRequest(This,pInnerRequest)	\
    ( (This)->lpVtbl -> InitializeFromInnerRequest(This,pInnerRequest) ) 

#define IX509CertificateRequestPkcs7_InitializeDecode(This,strEncodedData,Encoding)	\
    ( (This)->lpVtbl -> InitializeDecode(This,strEncodedData,Encoding) ) 

#define IX509CertificateRequestPkcs7_get_RequesterName(This,pValue)	\
    ( (This)->lpVtbl -> get_RequesterName(This,pValue) ) 

#define IX509CertificateRequestPkcs7_put_RequesterName(This,Value)	\
    ( (This)->lpVtbl -> put_RequesterName(This,Value) ) 

#define IX509CertificateRequestPkcs7_get_SignerCertificate(This,ppValue)	\
    ( (This)->lpVtbl -> get_SignerCertificate(This,ppValue) ) 

#define IX509CertificateRequestPkcs7_put_SignerCertificate(This,pValue)	\
    ( (This)->lpVtbl -> put_SignerCertificate(This,pValue) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IX509CertificateRequestPkcs7_INTERFACE_DEFINED__ */


#ifndef __IX509CertificateRequestCmc_INTERFACE_DEFINED__
#define __IX509CertificateRequestCmc_INTERFACE_DEFINED__

/* interface IX509CertificateRequestCmc */
/* [helpstring][dual][uuid][object] */ 


EXTERN_C const IID IID_IX509CertificateRequestCmc;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("728ab345-217d-11da-b2a4-000e7bbb2b09")
    IX509CertificateRequestCmc : public IX509CertificateRequestPkcs7
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE InitializeFromInnerRequestTemplateName( 
            /* [in] */ __RPC__in_opt IX509CertificateRequest *pInnerRequest,
            /* [in] */ __RPC__in BSTR strTemplateName) = 0;
        
        virtual /* [propget] */ HRESULT STDMETHODCALLTYPE get_TemplateObjectId( 
            /* [retval][out] */ __RPC__deref_out_opt IObjectId **ppValue) = 0;
        
        virtual /* [propget] */ HRESULT STDMETHODCALLTYPE get_NullSigned( 
            /* [retval][out] */ __RPC__out VARIANT_BOOL *pValue) = 0;
        
        virtual /* [propget] */ HRESULT STDMETHODCALLTYPE get_CryptAttributes( 
            /* [retval][out] */ __RPC__deref_out_opt ICryptAttributes **ppValue) = 0;
        
        virtual /* [propget] */ HRESULT STDMETHODCALLTYPE get_NameValuePairs( 
            /* [retval][out] */ __RPC__deref_out_opt IX509NameValuePairs **ppValue) = 0;
        
        virtual /* [propget] */ HRESULT STDMETHODCALLTYPE get_X509Extensions( 
            /* [retval][out] */ __RPC__deref_out_opt IX509Extensions **ppValue) = 0;
        
        virtual /* [propget] */ HRESULT STDMETHODCALLTYPE get_CriticalExtensions( 
            /* [retval][out] */ __RPC__deref_out_opt IObjectIds **ppValue) = 0;
        
        virtual /* [propget] */ HRESULT STDMETHODCALLTYPE get_SuppressOids( 
            /* [retval][out] */ __RPC__deref_out_opt IObjectIds **ppValue) = 0;
        
        virtual /* [propget] */ HRESULT STDMETHODCALLTYPE get_TransactionId( 
            /* [retval][out] */ __RPC__out LONG *pValue) = 0;
        
        virtual /* [propput] */ HRESULT STDMETHODCALLTYPE put_TransactionId( 
            /* [in] */ LONG Value) = 0;
        
        virtual /* [propget] */ HRESULT STDMETHODCALLTYPE get_SenderNonce( 
            /* [defaultvalue][in] */ EncodingType Encoding,
            /* [retval][out] */ __RPC__deref_out_opt BSTR *pValue) = 0;
        
        virtual /* [propput] */ HRESULT STDMETHODCALLTYPE put_SenderNonce( 
            /* [defaultvalue][in] */ EncodingType Encoding,
            /* [in] */ __RPC__in BSTR Value) = 0;
        
        virtual /* [custom][propget] */ HRESULT STDMETHODCALLTYPE get_SignatureInformation( 
            /* [retval][out] */ __RPC__deref_out_opt IX509SignatureInformation **ppValue) = 0;
        
        virtual /* [propget] */ HRESULT STDMETHODCALLTYPE get_ArchivePrivateKey( 
            /* [retval][out] */ __RPC__out VARIANT_BOOL *pValue) = 0;
        
        virtual /* [propput] */ HRESULT STDMETHODCALLTYPE put_ArchivePrivateKey( 
            /* [in] */ VARIANT_BOOL Value) = 0;
        
        virtual /* [custom][propget] */ HRESULT STDMETHODCALLTYPE get_KeyArchivalCertificate( 
            /* [defaultvalue][in] */ EncodingType Encoding,
            /* [retval][out] */ __RPC__deref_out_opt BSTR *pValue) = 0;
        
        virtual /* [custom][propput] */ HRESULT STDMETHODCALLTYPE put_KeyArchivalCertificate( 
            /* [defaultvalue][in] */ EncodingType Encoding,
            /* [in] */ __RPC__in BSTR Value) = 0;
        
        virtual /* [custom][propget] */ HRESULT STDMETHODCALLTYPE get_EncryptionAlgorithm( 
            /* [retval][out] */ __RPC__deref_out_opt IObjectId **ppValue) = 0;
        
        virtual /* [custom][propput] */ HRESULT STDMETHODCALLTYPE put_EncryptionAlgorithm( 
            /* [in] */ __RPC__in_opt IObjectId *pValue) = 0;
        
        virtual /* [propget] */ HRESULT STDMETHODCALLTYPE get_EncryptionStrength( 
            /* [retval][out] */ __RPC__out LONG *pValue) = 0;
        
        virtual /* [propput] */ HRESULT STDMETHODCALLTYPE put_EncryptionStrength( 
            /* [in] */ LONG Value) = 0;
        
        virtual /* [propget] */ HRESULT STDMETHODCALLTYPE get_EncryptedKeyHash( 
            /* [in] */ EncodingType Encoding,
            /* [retval][out] */ __RPC__deref_out_opt BSTR *pValue) = 0;
        
        virtual /* [propget] */ HRESULT STDMETHODCALLTYPE get_SignerCertificates( 
            /* [retval][out] */ __RPC__deref_out_opt ISignerCertificates **ppValue) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IX509CertificateRequestCmcVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IX509CertificateRequestCmc * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IX509CertificateRequestCmc * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IX509CertificateRequestCmc * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfoCount )( 
            IX509CertificateRequestCmc * This,
            /* [out] */ __RPC__out UINT *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfo )( 
            IX509CertificateRequestCmc * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ __RPC__deref_out_opt ITypeInfo **ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetIDsOfNames )( 
            IX509CertificateRequestCmc * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [size_is][in] */ __RPC__in_ecount_full(cNames) LPOLESTR *rgszNames,
            /* [range][in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ __RPC__out_ecount_full(cNames) DISPID *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE *Invoke )( 
            IX509CertificateRequestCmc * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS *pDispParams,
            /* [out] */ VARIANT *pVarResult,
            /* [out] */ EXCEPINFO *pExcepInfo,
            /* [out] */ UINT *puArgErr);
        
        HRESULT ( STDMETHODCALLTYPE *Initialize )( 
            IX509CertificateRequestCmc * This,
            /* [in] */ X509CertificateEnrollmentContext Context);
        
        HRESULT ( STDMETHODCALLTYPE *Encode )( 
            IX509CertificateRequestCmc * This);
        
        HRESULT ( STDMETHODCALLTYPE *ResetForEncode )( 
            IX509CertificateRequestCmc * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetInnerRequest )( 
            IX509CertificateRequestCmc * This,
            /* [in] */ InnerRequestLevel Level,
            /* [retval][out] */ __RPC__deref_out_opt IX509CertificateRequest **ppValue);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_Type )( 
            IX509CertificateRequestCmc * This,
            /* [retval][out] */ __RPC__out X509RequestType *pValue);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_EnrollmentContext )( 
            IX509CertificateRequestCmc * This,
            /* [retval][out] */ __RPC__out X509CertificateEnrollmentContext *pValue);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_Silent )( 
            IX509CertificateRequestCmc * This,
            /* [retval][out] */ __RPC__out VARIANT_BOOL *pValue);
        
        /* [propput] */ HRESULT ( STDMETHODCALLTYPE *put_Silent )( 
            IX509CertificateRequestCmc * This,
            /* [in] */ VARIANT_BOOL Value);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_ParentWindow )( 
            IX509CertificateRequestCmc * This,
            /* [retval][out] */ __RPC__out LONG *pValue);
        
        /* [propput] */ HRESULT ( STDMETHODCALLTYPE *put_ParentWindow )( 
            IX509CertificateRequestCmc * This,
            /* [in] */ LONG Value);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_UIContextMessage )( 
            IX509CertificateRequestCmc * This,
            /* [retval][out] */ __RPC__deref_out_opt BSTR *pValue);
        
        /* [propput] */ HRESULT ( STDMETHODCALLTYPE *put_UIContextMessage )( 
            IX509CertificateRequestCmc * This,
            /* [in] */ __RPC__in BSTR Value);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_SuppressDefaults )( 
            IX509CertificateRequestCmc * This,
            /* [retval][out] */ __RPC__out VARIANT_BOOL *pValue);
        
        /* [propput] */ HRESULT ( STDMETHODCALLTYPE *put_SuppressDefaults )( 
            IX509CertificateRequestCmc * This,
            /* [in] */ VARIANT_BOOL Value);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_RenewalCertificate )( 
            IX509CertificateRequestCmc * This,
            /* [defaultvalue][in] */ EncodingType Encoding,
            /* [retval][out] */ __RPC__deref_out_opt BSTR *pValue);
        
        /* [propput] */ HRESULT ( STDMETHODCALLTYPE *put_RenewalCertificate )( 
            IX509CertificateRequestCmc * This,
            /* [defaultvalue][in] */ EncodingType Encoding,
            /* [in] */ __RPC__in BSTR Value);
        
        /* [custom][propget] */ HRESULT ( STDMETHODCALLTYPE *get_ClientId )( 
            IX509CertificateRequestCmc * This,
            /* [retval][out] */ __RPC__out RequestClientInfoClientId *pValue);
        
        /* [custom][propput] */ HRESULT ( STDMETHODCALLTYPE *put_ClientId )( 
            IX509CertificateRequestCmc * This,
            /* [in] */ RequestClientInfoClientId Value);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_CspInformations )( 
            IX509CertificateRequestCmc * This,
            /* [retval][out] */ __RPC__deref_out_opt ICspInformations **ppValue);
        
        /* [propput] */ HRESULT ( STDMETHODCALLTYPE *put_CspInformations )( 
            IX509CertificateRequestCmc * This,
            /* [in] */ __RPC__in_opt ICspInformations *pValue);
        
        /* [custom][propget] */ HRESULT ( STDMETHODCALLTYPE *get_HashAlgorithm )( 
            IX509CertificateRequestCmc * This,
            /* [retval][out] */ __RPC__deref_out_opt IObjectId **ppValue);
        
        /* [custom][propput] */ HRESULT ( STDMETHODCALLTYPE *put_HashAlgorithm )( 
            IX509CertificateRequestCmc * This,
            /* [in] */ __RPC__in_opt IObjectId *pValue);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_AlternateSignatureAlgorithm )( 
            IX509CertificateRequestCmc * This,
            /* [retval][out] */ __RPC__out VARIANT_BOOL *pValue);
        
        /* [propput] */ HRESULT ( STDMETHODCALLTYPE *put_AlternateSignatureAlgorithm )( 
            IX509CertificateRequestCmc * This,
            /* [in] */ VARIANT_BOOL Value);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_RawData )( 
            IX509CertificateRequestCmc * This,
            /* [defaultvalue][in] */ EncodingType Encoding,
            /* [retval][out] */ __RPC__deref_out_opt BSTR *pValue);
        
        HRESULT ( STDMETHODCALLTYPE *InitializeFromTemplateName )( 
            IX509CertificateRequestCmc * This,
            /* [in] */ X509CertificateEnrollmentContext Context,
            /* [in] */ __RPC__in BSTR strTemplateName);
        
        HRESULT ( STDMETHODCALLTYPE *InitializeFromCertificate )( 
            IX509CertificateRequestCmc * This,
            /* [in] */ X509CertificateEnrollmentContext Context,
            /* [in] */ VARIANT_BOOL RenewalRequest,
            /* [in] */ __RPC__in BSTR strCertificate,
            /* [defaultvalue][in] */ EncodingType Encoding,
            /* [defaultvalue][in] */ X509RequestInheritOptions InheritOptions);
        
        /* [custom] */ HRESULT ( STDMETHODCALLTYPE *InitializeFromInnerRequest )( 
            IX509CertificateRequestCmc * This,
            /* [in] */ __RPC__in_opt IX509CertificateRequest *pInnerRequest);
        
        HRESULT ( STDMETHODCALLTYPE *InitializeDecode )( 
            IX509CertificateRequestCmc * This,
            /* [in] */ __RPC__in BSTR strEncodedData,
            /* [defaultvalue][in] */ EncodingType Encoding);
        
        /* [custom][propget] */ HRESULT ( STDMETHODCALLTYPE *get_RequesterName )( 
            IX509CertificateRequestCmc * This,
            /* [retval][out] */ __RPC__deref_out_opt BSTR *pValue);
        
        /* [custom][propput] */ HRESULT ( STDMETHODCALLTYPE *put_RequesterName )( 
            IX509CertificateRequestCmc * This,
            /* [in] */ __RPC__in BSTR Value);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_SignerCertificate )( 
            IX509CertificateRequestCmc * This,
            /* [retval][out] */ __RPC__deref_out_opt ISignerCertificate **ppValue);
        
        /* [propput] */ HRESULT ( STDMETHODCALLTYPE *put_SignerCertificate )( 
            IX509CertificateRequestCmc * This,
            /* [in] */ __RPC__in_opt ISignerCertificate *pValue);
        
        HRESULT ( STDMETHODCALLTYPE *InitializeFromInnerRequestTemplateName )( 
            IX509CertificateRequestCmc * This,
            /* [in] */ __RPC__in_opt IX509CertificateRequest *pInnerRequest,
            /* [in] */ __RPC__in BSTR strTemplateName);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_TemplateObjectId )( 
            IX509CertificateRequestCmc * This,
            /* [retval][out] */ __RPC__deref_out_opt IObjectId **ppValue);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_NullSigned )( 
            IX509CertificateRequestCmc * This,
            /* [retval][out] */ __RPC__out VARIANT_BOOL *pValue);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_CryptAttributes )( 
            IX509CertificateRequestCmc * This,
            /* [retval][out] */ __RPC__deref_out_opt ICryptAttributes **ppValue);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_NameValuePairs )( 
            IX509CertificateRequestCmc * This,
            /* [retval][out] */ __RPC__deref_out_opt IX509NameValuePairs **ppValue);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_X509Extensions )( 
            IX509CertificateRequestCmc * This,
            /* [retval][out] */ __RPC__deref_out_opt IX509Extensions **ppValue);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_CriticalExtensions )( 
            IX509CertificateRequestCmc * This,
            /* [retval][out] */ __RPC__deref_out_opt IObjectIds **ppValue);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_SuppressOids )( 
            IX509CertificateRequestCmc * This,
            /* [retval][out] */ __RPC__deref_out_opt IObjectIds **ppValue);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_TransactionId )( 
            IX509CertificateRequestCmc * This,
            /* [retval][out] */ __RPC__out LONG *pValue);
        
        /* [propput] */ HRESULT ( STDMETHODCALLTYPE *put_TransactionId )( 
            IX509CertificateRequestCmc * This,
            /* [in] */ LONG Value);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_SenderNonce )( 
            IX509CertificateRequestCmc * This,
            /* [defaultvalue][in] */ EncodingType Encoding,
            /* [retval][out] */ __RPC__deref_out_opt BSTR *pValue);
        
        /* [propput] */ HRESULT ( STDMETHODCALLTYPE *put_SenderNonce )( 
            IX509CertificateRequestCmc * This,
            /* [defaultvalue][in] */ EncodingType Encoding,
            /* [in] */ __RPC__in BSTR Value);
        
        /* [custom][propget] */ HRESULT ( STDMETHODCALLTYPE *get_SignatureInformation )( 
            IX509CertificateRequestCmc * This,
            /* [retval][out] */ __RPC__deref_out_opt IX509SignatureInformation **ppValue);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_ArchivePrivateKey )( 
            IX509CertificateRequestCmc * This,
            /* [retval][out] */ __RPC__out VARIANT_BOOL *pValue);
        
        /* [propput] */ HRESULT ( STDMETHODCALLTYPE *put_ArchivePrivateKey )( 
            IX509CertificateRequestCmc * This,
            /* [in] */ VARIANT_BOOL Value);
        
        /* [custom][propget] */ HRESULT ( STDMETHODCALLTYPE *get_KeyArchivalCertificate )( 
            IX509CertificateRequestCmc * This,
            /* [defaultvalue][in] */ EncodingType Encoding,
            /* [retval][out] */ __RPC__deref_out_opt BSTR *pValue);
        
        /* [custom][propput] */ HRESULT ( STDMETHODCALLTYPE *put_KeyArchivalCertificate )( 
            IX509CertificateRequestCmc * This,
            /* [defaultvalue][in] */ EncodingType Encoding,
            /* [in] */ __RPC__in BSTR Value);
        
        /* [custom][propget] */ HRESULT ( STDMETHODCALLTYPE *get_EncryptionAlgorithm )( 
            IX509CertificateRequestCmc * This,
            /* [retval][out] */ __RPC__deref_out_opt IObjectId **ppValue);
        
        /* [custom][propput] */ HRESULT ( STDMETHODCALLTYPE *put_EncryptionAlgorithm )( 
            IX509CertificateRequestCmc * This,
            /* [in] */ __RPC__in_opt IObjectId *pValue);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_EncryptionStrength )( 
            IX509CertificateRequestCmc * This,
            /* [retval][out] */ __RPC__out LONG *pValue);
        
        /* [propput] */ HRESULT ( STDMETHODCALLTYPE *put_EncryptionStrength )( 
            IX509CertificateRequestCmc * This,
            /* [in] */ LONG Value);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_EncryptedKeyHash )( 
            IX509CertificateRequestCmc * This,
            /* [in] */ EncodingType Encoding,
            /* [retval][out] */ __RPC__deref_out_opt BSTR *pValue);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_SignerCertificates )( 
            IX509CertificateRequestCmc * This,
            /* [retval][out] */ __RPC__deref_out_opt ISignerCertificates **ppValue);
        
        END_INTERFACE
    } IX509CertificateRequestCmcVtbl;

    interface IX509CertificateRequestCmc
    {
        CONST_VTBL struct IX509CertificateRequestCmcVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IX509CertificateRequestCmc_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IX509CertificateRequestCmc_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IX509CertificateRequestCmc_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IX509CertificateRequestCmc_GetTypeInfoCount(This,pctinfo)	\
    ( (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo) ) 

#define IX509CertificateRequestCmc_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    ( (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo) ) 

#define IX509CertificateRequestCmc_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    ( (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId) ) 

#define IX509CertificateRequestCmc_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    ( (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr) ) 


#define IX509CertificateRequestCmc_Initialize(This,Context)	\
    ( (This)->lpVtbl -> Initialize(This,Context) ) 

#define IX509CertificateRequestCmc_Encode(This)	\
    ( (This)->lpVtbl -> Encode(This) ) 

#define IX509CertificateRequestCmc_ResetForEncode(This)	\
    ( (This)->lpVtbl -> ResetForEncode(This) ) 

#define IX509CertificateRequestCmc_GetInnerRequest(This,Level,ppValue)	\
    ( (This)->lpVtbl -> GetInnerRequest(This,Level,ppValue) ) 

#define IX509CertificateRequestCmc_get_Type(This,pValue)	\
    ( (This)->lpVtbl -> get_Type(This,pValue) ) 

#define IX509CertificateRequestCmc_get_EnrollmentContext(This,pValue)	\
    ( (This)->lpVtbl -> get_EnrollmentContext(This,pValue) ) 

#define IX509CertificateRequestCmc_get_Silent(This,pValue)	\
    ( (This)->lpVtbl -> get_Silent(This,pValue) ) 

#define IX509CertificateRequestCmc_put_Silent(This,Value)	\
    ( (This)->lpVtbl -> put_Silent(This,Value) ) 

#define IX509CertificateRequestCmc_get_ParentWindow(This,pValue)	\
    ( (This)->lpVtbl -> get_ParentWindow(This,pValue) ) 

#define IX509CertificateRequestCmc_put_ParentWindow(This,Value)	\
    ( (This)->lpVtbl -> put_ParentWindow(This,Value) ) 

#define IX509CertificateRequestCmc_get_UIContextMessage(This,pValue)	\
    ( (This)->lpVtbl -> get_UIContextMessage(This,pValue) ) 

#define IX509CertificateRequestCmc_put_UIContextMessage(This,Value)	\
    ( (This)->lpVtbl -> put_UIContextMessage(This,Value) ) 

#define IX509CertificateRequestCmc_get_SuppressDefaults(This,pValue)	\
    ( (This)->lpVtbl -> get_SuppressDefaults(This,pValue) ) 

#define IX509CertificateRequestCmc_put_SuppressDefaults(This,Value)	\
    ( (This)->lpVtbl -> put_SuppressDefaults(This,Value) ) 

#define IX509CertificateRequestCmc_get_RenewalCertificate(This,Encoding,pValue)	\
    ( (This)->lpVtbl -> get_RenewalCertificate(This,Encoding,pValue) ) 

#define IX509CertificateRequestCmc_put_RenewalCertificate(This,Encoding,Value)	\
    ( (This)->lpVtbl -> put_RenewalCertificate(This,Encoding,Value) ) 

#define IX509CertificateRequestCmc_get_ClientId(This,pValue)	\
    ( (This)->lpVtbl -> get_ClientId(This,pValue) ) 

#define IX509CertificateRequestCmc_put_ClientId(This,Value)	\
    ( (This)->lpVtbl -> put_ClientId(This,Value) ) 

#define IX509CertificateRequestCmc_get_CspInformations(This,ppValue)	\
    ( (This)->lpVtbl -> get_CspInformations(This,ppValue) ) 

#define IX509CertificateRequestCmc_put_CspInformations(This,pValue)	\
    ( (This)->lpVtbl -> put_CspInformations(This,pValue) ) 

#define IX509CertificateRequestCmc_get_HashAlgorithm(This,ppValue)	\
    ( (This)->lpVtbl -> get_HashAlgorithm(This,ppValue) ) 

#define IX509CertificateRequestCmc_put_HashAlgorithm(This,pValue)	\
    ( (This)->lpVtbl -> put_HashAlgorithm(This,pValue) ) 

#define IX509CertificateRequestCmc_get_AlternateSignatureAlgorithm(This,pValue)	\
    ( (This)->lpVtbl -> get_AlternateSignatureAlgorithm(This,pValue) ) 

#define IX509CertificateRequestCmc_put_AlternateSignatureAlgorithm(This,Value)	\
    ( (This)->lpVtbl -> put_AlternateSignatureAlgorithm(This,Value) ) 

#define IX509CertificateRequestCmc_get_RawData(This,Encoding,pValue)	\
    ( (This)->lpVtbl -> get_RawData(This,Encoding,pValue) ) 


#define IX509CertificateRequestCmc_InitializeFromTemplateName(This,Context,strTemplateName)	\
    ( (This)->lpVtbl -> InitializeFromTemplateName(This,Context,strTemplateName) ) 

#define IX509CertificateRequestCmc_InitializeFromCertificate(This,Context,RenewalRequest,strCertificate,Encoding,InheritOptions)	\
    ( (This)->lpVtbl -> InitializeFromCertificate(This,Context,RenewalRequest,strCertificate,Encoding,InheritOptions) ) 

#define IX509CertificateRequestCmc_InitializeFromInnerRequest(This,pInnerRequest)	\
    ( (This)->lpVtbl -> InitializeFromInnerRequest(This,pInnerRequest) ) 

#define IX509CertificateRequestCmc_InitializeDecode(This,strEncodedData,Encoding)	\
    ( (This)->lpVtbl -> InitializeDecode(This,strEncodedData,Encoding) ) 

#define IX509CertificateRequestCmc_get_RequesterName(This,pValue)	\
    ( (This)->lpVtbl -> get_RequesterName(This,pValue) ) 

#define IX509CertificateRequestCmc_put_RequesterName(This,Value)	\
    ( (This)->lpVtbl -> put_RequesterName(This,Value) ) 

#define IX509CertificateRequestCmc_get_SignerCertificate(This,ppValue)	\
    ( (This)->lpVtbl -> get_SignerCertificate(This,ppValue) ) 

#define IX509CertificateRequestCmc_put_SignerCertificate(This,pValue)	\
    ( (This)->lpVtbl -> put_SignerCertificate(This,pValue) ) 


#define IX509CertificateRequestCmc_InitializeFromInnerRequestTemplateName(This,pInnerRequest,strTemplateName)	\
    ( (This)->lpVtbl -> InitializeFromInnerRequestTemplateName(This,pInnerRequest,strTemplateName) ) 

#define IX509CertificateRequestCmc_get_TemplateObjectId(This,ppValue)	\
    ( (This)->lpVtbl -> get_TemplateObjectId(This,ppValue) ) 

#define IX509CertificateRequestCmc_get_NullSigned(This,pValue)	\
    ( (This)->lpVtbl -> get_NullSigned(This,pValue) ) 

#define IX509CertificateRequestCmc_get_CryptAttributes(This,ppValue)	\
    ( (This)->lpVtbl -> get_CryptAttributes(This,ppValue) ) 

#define IX509CertificateRequestCmc_get_NameValuePairs(This,ppValue)	\
    ( (This)->lpVtbl -> get_NameValuePairs(This,ppValue) ) 

#define IX509CertificateRequestCmc_get_X509Extensions(This,ppValue)	\
    ( (This)->lpVtbl -> get_X509Extensions(This,ppValue) ) 

#define IX509CertificateRequestCmc_get_CriticalExtensions(This,ppValue)	\
    ( (This)->lpVtbl -> get_CriticalExtensions(This,ppValue) ) 

#define IX509CertificateRequestCmc_get_SuppressOids(This,ppValue)	\
    ( (This)->lpVtbl -> get_SuppressOids(This,ppValue) ) 

#define IX509CertificateRequestCmc_get_TransactionId(This,pValue)	\
    ( (This)->lpVtbl -> get_TransactionId(This,pValue) ) 

#define IX509CertificateRequestCmc_put_TransactionId(This,Value)	\
    ( (This)->lpVtbl -> put_TransactionId(This,Value) ) 

#define IX509CertificateRequestCmc_get_SenderNonce(This,Encoding,pValue)	\
    ( (This)->lpVtbl -> get_SenderNonce(This,Encoding,pValue) ) 

#define IX509CertificateRequestCmc_put_SenderNonce(This,Encoding,Value)	\
    ( (This)->lpVtbl -> put_SenderNonce(This,Encoding,Value) ) 

#define IX509CertificateRequestCmc_get_SignatureInformation(This,ppValue)	\
    ( (This)->lpVtbl -> get_SignatureInformation(This,ppValue) ) 

#define IX509CertificateRequestCmc_get_ArchivePrivateKey(This,pValue)	\
    ( (This)->lpVtbl -> get_ArchivePrivateKey(This,pValue) ) 

#define IX509CertificateRequestCmc_put_ArchivePrivateKey(This,Value)	\
    ( (This)->lpVtbl -> put_ArchivePrivateKey(This,Value) ) 

#define IX509CertificateRequestCmc_get_KeyArchivalCertificate(This,Encoding,pValue)	\
    ( (This)->lpVtbl -> get_KeyArchivalCertificate(This,Encoding,pValue) ) 

#define IX509CertificateRequestCmc_put_KeyArchivalCertificate(This,Encoding,Value)	\
    ( (This)->lpVtbl -> put_KeyArchivalCertificate(This,Encoding,Value) ) 

#define IX509CertificateRequestCmc_get_EncryptionAlgorithm(This,ppValue)	\
    ( (This)->lpVtbl -> get_EncryptionAlgorithm(This,ppValue) ) 

#define IX509CertificateRequestCmc_put_EncryptionAlgorithm(This,pValue)	\
    ( (This)->lpVtbl -> put_EncryptionAlgorithm(This,pValue) ) 

#define IX509CertificateRequestCmc_get_EncryptionStrength(This,pValue)	\
    ( (This)->lpVtbl -> get_EncryptionStrength(This,pValue) ) 

#define IX509CertificateRequestCmc_put_EncryptionStrength(This,Value)	\
    ( (This)->lpVtbl -> put_EncryptionStrength(This,Value) ) 

#define IX509CertificateRequestCmc_get_EncryptedKeyHash(This,Encoding,pValue)	\
    ( (This)->lpVtbl -> get_EncryptedKeyHash(This,Encoding,pValue) ) 

#define IX509CertificateRequestCmc_get_SignerCertificates(This,ppValue)	\
    ( (This)->lpVtbl -> get_SignerCertificates(This,ppValue) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IX509CertificateRequestCmc_INTERFACE_DEFINED__ */


/* interface __MIDL_itf_certenroll_0000_0068 */
/* [local] */ 

typedef 
enum InstallResponseRestrictionFlags
    {	AllowNone	= 0,
	AllowNoOutstandingRequest	= 0x1,
	AllowUntrustedCertificate	= 0x2,
	AllowUntrustedRoot	= 0x4
    } 	InstallResponseRestrictionFlags;



extern RPC_IF_HANDLE __MIDL_itf_certenroll_0000_0068_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_certenroll_0000_0068_v0_0_s_ifspec;

#ifndef __IX509Enrollment_INTERFACE_DEFINED__
#define __IX509Enrollment_INTERFACE_DEFINED__

/* interface IX509Enrollment */
/* [helpstring][dual][uuid][object] */ 


EXTERN_C const IID IID_IX509Enrollment;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("728ab346-217d-11da-b2a4-000e7bbb2b09")
    IX509Enrollment : public IDispatch
    {
    public:
        virtual /* [custom] */ HRESULT STDMETHODCALLTYPE Initialize( 
            /* [in] */ X509CertificateEnrollmentContext Context) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE InitializeFromTemplateName( 
            /* [in] */ X509CertificateEnrollmentContext Context,
            /* [in] */ __RPC__in BSTR strTemplateName) = 0;
        
        virtual /* [custom] */ HRESULT STDMETHODCALLTYPE InitializeFromRequest( 
            /* [in] */ __RPC__in_opt IX509CertificateRequest *pRequest) = 0;
        
        virtual /* [custom][custom] */ HRESULT STDMETHODCALLTYPE CreateRequest( 
            /* [defaultvalue][in] */ EncodingType Encoding,
            /* [retval][out] */ __RPC__deref_out_opt BSTR *pValue) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Enroll( void) = 0;
        
        virtual /* [custom][custom] */ HRESULT STDMETHODCALLTYPE InstallResponse( 
            /* [in] */ InstallResponseRestrictionFlags Restrictions,
            /* [in] */ __RPC__in BSTR strResponse,
            /* [in] */ EncodingType Encoding,
            /* [in] */ __RPC__in BSTR strPassword) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE CreatePFX( 
            /* [in] */ __RPC__in BSTR strPassword,
            /* [in] */ PFXExportOptions ExportOptions,
            /* [defaultvalue][in] */ EncodingType Encoding,
            /* [retval][out] */ __RPC__deref_out_opt BSTR *pValue) = 0;
        
        virtual /* [propget] */ HRESULT STDMETHODCALLTYPE get_Request( 
            /* [retval][out] */ __RPC__deref_out_opt IX509CertificateRequest **pValue) = 0;
        
        virtual /* [propget] */ HRESULT STDMETHODCALLTYPE get_Silent( 
            /* [retval][out] */ __RPC__out VARIANT_BOOL *pValue) = 0;
        
        virtual /* [propput] */ HRESULT STDMETHODCALLTYPE put_Silent( 
            /* [in] */ VARIANT_BOOL Value) = 0;
        
        virtual /* [propget] */ HRESULT STDMETHODCALLTYPE get_ParentWindow( 
            /* [retval][out] */ __RPC__out LONG *pValue) = 0;
        
        virtual /* [propput] */ HRESULT STDMETHODCALLTYPE put_ParentWindow( 
            /* [in] */ LONG Value) = 0;
        
        virtual /* [propget] */ HRESULT STDMETHODCALLTYPE get_NameValuePairs( 
            /* [retval][out] */ __RPC__deref_out_opt IX509NameValuePairs **ppValue) = 0;
        
        virtual /* [propget] */ HRESULT STDMETHODCALLTYPE get_EnrollmentContext( 
            /* [retval][out] */ __RPC__out X509CertificateEnrollmentContext *pValue) = 0;
        
        virtual /* [propget] */ HRESULT STDMETHODCALLTYPE get_Status( 
            /* [retval][out] */ __RPC__deref_out_opt IX509EnrollmentStatus **ppValue) = 0;
        
        virtual /* [propget] */ HRESULT STDMETHODCALLTYPE get_Certificate( 
            /* [defaultvalue][in] */ EncodingType Encoding,
            /* [retval][out] */ __RPC__deref_out_opt BSTR *pValue) = 0;
        
        virtual /* [propget] */ HRESULT STDMETHODCALLTYPE get_Response( 
            /* [defaultvalue][in] */ EncodingType Encoding,
            /* [retval][out] */ __RPC__deref_out_opt BSTR *pValue) = 0;
        
        virtual /* [custom][propget] */ HRESULT STDMETHODCALLTYPE get_CertificateFriendlyName( 
            /* [retval][out] */ __RPC__deref_out_opt BSTR *pValue) = 0;
        
        virtual /* [custom][propput] */ HRESULT STDMETHODCALLTYPE put_CertificateFriendlyName( 
            /* [in] */ __RPC__in BSTR strValue) = 0;
        
        virtual /* [custom][propget] */ HRESULT STDMETHODCALLTYPE get_CertificateDescription( 
            /* [retval][out] */ __RPC__deref_out_opt BSTR *pValue) = 0;
        
        virtual /* [custom][propput] */ HRESULT STDMETHODCALLTYPE put_CertificateDescription( 
            /* [in] */ __RPC__in BSTR strValue) = 0;
        
        virtual /* [propget] */ HRESULT STDMETHODCALLTYPE get_RequestId( 
            /* [retval][out] */ __RPC__out LONG *pValue) = 0;
        
        virtual /* [propget] */ HRESULT STDMETHODCALLTYPE get_CAConfigString( 
            /* [retval][out] */ __RPC__deref_out_opt BSTR *pValue) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IX509EnrollmentVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IX509Enrollment * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IX509Enrollment * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IX509Enrollment * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfoCount )( 
            IX509Enrollment * This,
            /* [out] */ __RPC__out UINT *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfo )( 
            IX509Enrollment * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ __RPC__deref_out_opt ITypeInfo **ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetIDsOfNames )( 
            IX509Enrollment * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [size_is][in] */ __RPC__in_ecount_full(cNames) LPOLESTR *rgszNames,
            /* [range][in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ __RPC__out_ecount_full(cNames) DISPID *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE *Invoke )( 
            IX509Enrollment * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS *pDispParams,
            /* [out] */ VARIANT *pVarResult,
            /* [out] */ EXCEPINFO *pExcepInfo,
            /* [out] */ UINT *puArgErr);
        
        /* [custom] */ HRESULT ( STDMETHODCALLTYPE *Initialize )( 
            IX509Enrollment * This,
            /* [in] */ X509CertificateEnrollmentContext Context);
        
        HRESULT ( STDMETHODCALLTYPE *InitializeFromTemplateName )( 
            IX509Enrollment * This,
            /* [in] */ X509CertificateEnrollmentContext Context,
            /* [in] */ __RPC__in BSTR strTemplateName);
        
        /* [custom] */ HRESULT ( STDMETHODCALLTYPE *InitializeFromRequest )( 
            IX509Enrollment * This,
            /* [in] */ __RPC__in_opt IX509CertificateRequest *pRequest);
        
        /* [custom][custom] */ HRESULT ( STDMETHODCALLTYPE *CreateRequest )( 
            IX509Enrollment * This,
            /* [defaultvalue][in] */ EncodingType Encoding,
            /* [retval][out] */ __RPC__deref_out_opt BSTR *pValue);
        
        HRESULT ( STDMETHODCALLTYPE *Enroll )( 
            IX509Enrollment * This);
        
        /* [custom][custom] */ HRESULT ( STDMETHODCALLTYPE *InstallResponse )( 
            IX509Enrollment * This,
            /* [in] */ InstallResponseRestrictionFlags Restrictions,
            /* [in] */ __RPC__in BSTR strResponse,
            /* [in] */ EncodingType Encoding,
            /* [in] */ __RPC__in BSTR strPassword);
        
        HRESULT ( STDMETHODCALLTYPE *CreatePFX )( 
            IX509Enrollment * This,
            /* [in] */ __RPC__in BSTR strPassword,
            /* [in] */ PFXExportOptions ExportOptions,
            /* [defaultvalue][in] */ EncodingType Encoding,
            /* [retval][out] */ __RPC__deref_out_opt BSTR *pValue);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_Request )( 
            IX509Enrollment * This,
            /* [retval][out] */ __RPC__deref_out_opt IX509CertificateRequest **pValue);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_Silent )( 
            IX509Enrollment * This,
            /* [retval][out] */ __RPC__out VARIANT_BOOL *pValue);
        
        /* [propput] */ HRESULT ( STDMETHODCALLTYPE *put_Silent )( 
            IX509Enrollment * This,
            /* [in] */ VARIANT_BOOL Value);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_ParentWindow )( 
            IX509Enrollment * This,
            /* [retval][out] */ __RPC__out LONG *pValue);
        
        /* [propput] */ HRESULT ( STDMETHODCALLTYPE *put_ParentWindow )( 
            IX509Enrollment * This,
            /* [in] */ LONG Value);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_NameValuePairs )( 
            IX509Enrollment * This,
            /* [retval][out] */ __RPC__deref_out_opt IX509NameValuePairs **ppValue);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_EnrollmentContext )( 
            IX509Enrollment * This,
            /* [retval][out] */ __RPC__out X509CertificateEnrollmentContext *pValue);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_Status )( 
            IX509Enrollment * This,
            /* [retval][out] */ __RPC__deref_out_opt IX509EnrollmentStatus **ppValue);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_Certificate )( 
            IX509Enrollment * This,
            /* [defaultvalue][in] */ EncodingType Encoding,
            /* [retval][out] */ __RPC__deref_out_opt BSTR *pValue);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_Response )( 
            IX509Enrollment * This,
            /* [defaultvalue][in] */ EncodingType Encoding,
            /* [retval][out] */ __RPC__deref_out_opt BSTR *pValue);
        
        /* [custom][propget] */ HRESULT ( STDMETHODCALLTYPE *get_CertificateFriendlyName )( 
            IX509Enrollment * This,
            /* [retval][out] */ __RPC__deref_out_opt BSTR *pValue);
        
        /* [custom][propput] */ HRESULT ( STDMETHODCALLTYPE *put_CertificateFriendlyName )( 
            IX509Enrollment * This,
            /* [in] */ __RPC__in BSTR strValue);
        
        /* [custom][propget] */ HRESULT ( STDMETHODCALLTYPE *get_CertificateDescription )( 
            IX509Enrollment * This,
            /* [retval][out] */ __RPC__deref_out_opt BSTR *pValue);
        
        /* [custom][propput] */ HRESULT ( STDMETHODCALLTYPE *put_CertificateDescription )( 
            IX509Enrollment * This,
            /* [in] */ __RPC__in BSTR strValue);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_RequestId )( 
            IX509Enrollment * This,
            /* [retval][out] */ __RPC__out LONG *pValue);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_CAConfigString )( 
            IX509Enrollment * This,
            /* [retval][out] */ __RPC__deref_out_opt BSTR *pValue);
        
        END_INTERFACE
    } IX509EnrollmentVtbl;

    interface IX509Enrollment
    {
        CONST_VTBL struct IX509EnrollmentVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IX509Enrollment_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IX509Enrollment_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IX509Enrollment_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IX509Enrollment_GetTypeInfoCount(This,pctinfo)	\
    ( (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo) ) 

#define IX509Enrollment_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    ( (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo) ) 

#define IX509Enrollment_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    ( (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId) ) 

#define IX509Enrollment_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    ( (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr) ) 


#define IX509Enrollment_Initialize(This,Context)	\
    ( (This)->lpVtbl -> Initialize(This,Context) ) 

#define IX509Enrollment_InitializeFromTemplateName(This,Context,strTemplateName)	\
    ( (This)->lpVtbl -> InitializeFromTemplateName(This,Context,strTemplateName) ) 

#define IX509Enrollment_InitializeFromRequest(This,pRequest)	\
    ( (This)->lpVtbl -> InitializeFromRequest(This,pRequest) ) 

#define IX509Enrollment_CreateRequest(This,Encoding,pValue)	\
    ( (This)->lpVtbl -> CreateRequest(This,Encoding,pValue) ) 

#define IX509Enrollment_Enroll(This)	\
    ( (This)->lpVtbl -> Enroll(This) ) 

#define IX509Enrollment_InstallResponse(This,Restrictions,strResponse,Encoding,strPassword)	\
    ( (This)->lpVtbl -> InstallResponse(This,Restrictions,strResponse,Encoding,strPassword) ) 

#define IX509Enrollment_CreatePFX(This,strPassword,ExportOptions,Encoding,pValue)	\
    ( (This)->lpVtbl -> CreatePFX(This,strPassword,ExportOptions,Encoding,pValue) ) 

#define IX509Enrollment_get_Request(This,pValue)	\
    ( (This)->lpVtbl -> get_Request(This,pValue) ) 

#define IX509Enrollment_get_Silent(This,pValue)	\
    ( (This)->lpVtbl -> get_Silent(This,pValue) ) 

#define IX509Enrollment_put_Silent(This,Value)	\
    ( (This)->lpVtbl -> put_Silent(This,Value) ) 

#define IX509Enrollment_get_ParentWindow(This,pValue)	\
    ( (This)->lpVtbl -> get_ParentWindow(This,pValue) ) 

#define IX509Enrollment_put_ParentWindow(This,Value)	\
    ( (This)->lpVtbl -> put_ParentWindow(This,Value) ) 

#define IX509Enrollment_get_NameValuePairs(This,ppValue)	\
    ( (This)->lpVtbl -> get_NameValuePairs(This,ppValue) ) 

#define IX509Enrollment_get_EnrollmentContext(This,pValue)	\
    ( (This)->lpVtbl -> get_EnrollmentContext(This,pValue) ) 

#define IX509Enrollment_get_Status(This,ppValue)	\
    ( (This)->lpVtbl -> get_Status(This,ppValue) ) 

#define IX509Enrollment_get_Certificate(This,Encoding,pValue)	\
    ( (This)->lpVtbl -> get_Certificate(This,Encoding,pValue) ) 

#define IX509Enrollment_get_Response(This,Encoding,pValue)	\
    ( (This)->lpVtbl -> get_Response(This,Encoding,pValue) ) 

#define IX509Enrollment_get_CertificateFriendlyName(This,pValue)	\
    ( (This)->lpVtbl -> get_CertificateFriendlyName(This,pValue) ) 

#define IX509Enrollment_put_CertificateFriendlyName(This,strValue)	\
    ( (This)->lpVtbl -> put_CertificateFriendlyName(This,strValue) ) 

#define IX509Enrollment_get_CertificateDescription(This,pValue)	\
    ( (This)->lpVtbl -> get_CertificateDescription(This,pValue) ) 

#define IX509Enrollment_put_CertificateDescription(This,strValue)	\
    ( (This)->lpVtbl -> put_CertificateDescription(This,strValue) ) 

#define IX509Enrollment_get_RequestId(This,pValue)	\
    ( (This)->lpVtbl -> get_RequestId(This,pValue) ) 

#define IX509Enrollment_get_CAConfigString(This,pValue)	\
    ( (This)->lpVtbl -> get_CAConfigString(This,pValue) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IX509Enrollment_INTERFACE_DEFINED__ */


#ifndef __IX509EnrollmentWebClassFactory_INTERFACE_DEFINED__
#define __IX509EnrollmentWebClassFactory_INTERFACE_DEFINED__

/* interface IX509EnrollmentWebClassFactory */
/* [helpstring][dual][uuid][object] */ 


EXTERN_C const IID IID_IX509EnrollmentWebClassFactory;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("728ab349-217d-11da-b2a4-000e7bbb2b09")
    IX509EnrollmentWebClassFactory : public IDispatch
    {
    public:
        virtual /* [custom] */ HRESULT STDMETHODCALLTYPE CreateObject( 
            /* [in] */ __RPC__in BSTR strProgID,
            /* [retval][out] */ __RPC__deref_out_opt IUnknown **ppIUnknown) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IX509EnrollmentWebClassFactoryVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IX509EnrollmentWebClassFactory * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IX509EnrollmentWebClassFactory * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IX509EnrollmentWebClassFactory * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfoCount )( 
            IX509EnrollmentWebClassFactory * This,
            /* [out] */ __RPC__out UINT *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfo )( 
            IX509EnrollmentWebClassFactory * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ __RPC__deref_out_opt ITypeInfo **ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetIDsOfNames )( 
            IX509EnrollmentWebClassFactory * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [size_is][in] */ __RPC__in_ecount_full(cNames) LPOLESTR *rgszNames,
            /* [range][in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ __RPC__out_ecount_full(cNames) DISPID *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE *Invoke )( 
            IX509EnrollmentWebClassFactory * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS *pDispParams,
            /* [out] */ VARIANT *pVarResult,
            /* [out] */ EXCEPINFO *pExcepInfo,
            /* [out] */ UINT *puArgErr);
        
        /* [custom] */ HRESULT ( STDMETHODCALLTYPE *CreateObject )( 
            IX509EnrollmentWebClassFactory * This,
            /* [in] */ __RPC__in BSTR strProgID,
            /* [retval][out] */ __RPC__deref_out_opt IUnknown **ppIUnknown);
        
        END_INTERFACE
    } IX509EnrollmentWebClassFactoryVtbl;

    interface IX509EnrollmentWebClassFactory
    {
        CONST_VTBL struct IX509EnrollmentWebClassFactoryVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IX509EnrollmentWebClassFactory_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IX509EnrollmentWebClassFactory_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IX509EnrollmentWebClassFactory_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IX509EnrollmentWebClassFactory_GetTypeInfoCount(This,pctinfo)	\
    ( (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo) ) 

#define IX509EnrollmentWebClassFactory_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    ( (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo) ) 

#define IX509EnrollmentWebClassFactory_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    ( (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId) ) 

#define IX509EnrollmentWebClassFactory_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    ( (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr) ) 


#define IX509EnrollmentWebClassFactory_CreateObject(This,strProgID,ppIUnknown)	\
    ( (This)->lpVtbl -> CreateObject(This,strProgID,ppIUnknown) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IX509EnrollmentWebClassFactory_INTERFACE_DEFINED__ */



#ifndef __CERTENROLLLib_LIBRARY_DEFINED__
#define __CERTENROLLLib_LIBRARY_DEFINED__

/* library CERTENROLLLib */
/* [helpstring][version][uuid] */ 


EXTERN_C const IID LIBID_CERTENROLLLib;

EXTERN_C const CLSID CLSID_CObjectId;

#ifdef __cplusplus

class DECLSPEC_UUID("884e2000-217d-11da-b2a4-000e7bbb2b09")
CObjectId;
#endif

EXTERN_C const CLSID CLSID_CObjectIds;

#ifdef __cplusplus

class DECLSPEC_UUID("884e2001-217d-11da-b2a4-000e7bbb2b09")
CObjectIds;
#endif

EXTERN_C const CLSID CLSID_CBinaryConverter;

#ifdef __cplusplus

class DECLSPEC_UUID("884e2002-217d-11da-b2a4-000e7bbb2b09")
CBinaryConverter;
#endif

EXTERN_C const CLSID CLSID_CX500DistinguishedName;

#ifdef __cplusplus

class DECLSPEC_UUID("884e2003-217d-11da-b2a4-000e7bbb2b09")
CX500DistinguishedName;
#endif

EXTERN_C const CLSID CLSID_CCspInformation;

#ifdef __cplusplus

class DECLSPEC_UUID("884e2007-217d-11da-b2a4-000e7bbb2b09")
CCspInformation;
#endif

EXTERN_C const CLSID CLSID_CCspInformations;

#ifdef __cplusplus

class DECLSPEC_UUID("884e2008-217d-11da-b2a4-000e7bbb2b09")
CCspInformations;
#endif

EXTERN_C const CLSID CLSID_CCspStatus;

#ifdef __cplusplus

class DECLSPEC_UUID("884e2009-217d-11da-b2a4-000e7bbb2b09")
CCspStatus;
#endif

EXTERN_C const CLSID CLSID_CX509PublicKey;

#ifdef __cplusplus

class DECLSPEC_UUID("884e200b-217d-11da-b2a4-000e7bbb2b09")
CX509PublicKey;
#endif

EXTERN_C const CLSID CLSID_CX509PrivateKey;

#ifdef __cplusplus

class DECLSPEC_UUID("884e200c-217d-11da-b2a4-000e7bbb2b09")
CX509PrivateKey;
#endif

EXTERN_C const CLSID CLSID_CX509Extension;

#ifdef __cplusplus

class DECLSPEC_UUID("884e200d-217d-11da-b2a4-000e7bbb2b09")
CX509Extension;
#endif

EXTERN_C const CLSID CLSID_CX509Extensions;

#ifdef __cplusplus

class DECLSPEC_UUID("884e200e-217d-11da-b2a4-000e7bbb2b09")
CX509Extensions;
#endif

EXTERN_C const CLSID CLSID_CX509ExtensionKeyUsage;

#ifdef __cplusplus

class DECLSPEC_UUID("884e200f-217d-11da-b2a4-000e7bbb2b09")
CX509ExtensionKeyUsage;
#endif

EXTERN_C const CLSID CLSID_CX509ExtensionEnhancedKeyUsage;

#ifdef __cplusplus

class DECLSPEC_UUID("884e2010-217d-11da-b2a4-000e7bbb2b09")
CX509ExtensionEnhancedKeyUsage;
#endif

EXTERN_C const CLSID CLSID_CX509ExtensionTemplateName;

#ifdef __cplusplus

class DECLSPEC_UUID("884e2011-217d-11da-b2a4-000e7bbb2b09")
CX509ExtensionTemplateName;
#endif

EXTERN_C const CLSID CLSID_CX509ExtensionTemplate;

#ifdef __cplusplus

class DECLSPEC_UUID("884e2012-217d-11da-b2a4-000e7bbb2b09")
CX509ExtensionTemplate;
#endif

EXTERN_C const CLSID CLSID_CAlternativeName;

#ifdef __cplusplus

class DECLSPEC_UUID("884e2013-217d-11da-b2a4-000e7bbb2b09")
CAlternativeName;
#endif

EXTERN_C const CLSID CLSID_CAlternativeNames;

#ifdef __cplusplus

class DECLSPEC_UUID("884e2014-217d-11da-b2a4-000e7bbb2b09")
CAlternativeNames;
#endif

EXTERN_C const CLSID CLSID_CX509ExtensionAlternativeNames;

#ifdef __cplusplus

class DECLSPEC_UUID("884e2015-217d-11da-b2a4-000e7bbb2b09")
CX509ExtensionAlternativeNames;
#endif

EXTERN_C const CLSID CLSID_CX509ExtensionBasicConstraints;

#ifdef __cplusplus

class DECLSPEC_UUID("884e2016-217d-11da-b2a4-000e7bbb2b09")
CX509ExtensionBasicConstraints;
#endif

EXTERN_C const CLSID CLSID_CX509ExtensionSubjectKeyIdentifier;

#ifdef __cplusplus

class DECLSPEC_UUID("884e2017-217d-11da-b2a4-000e7bbb2b09")
CX509ExtensionSubjectKeyIdentifier;
#endif

EXTERN_C const CLSID CLSID_CX509ExtensionAuthorityKeyIdentifier;

#ifdef __cplusplus

class DECLSPEC_UUID("884e2018-217d-11da-b2a4-000e7bbb2b09")
CX509ExtensionAuthorityKeyIdentifier;
#endif

EXTERN_C const CLSID CLSID_CSmimeCapability;

#ifdef __cplusplus

class DECLSPEC_UUID("884e2019-217d-11da-b2a4-000e7bbb2b09")
CSmimeCapability;
#endif

EXTERN_C const CLSID CLSID_CSmimeCapabilities;

#ifdef __cplusplus

class DECLSPEC_UUID("884e201a-217d-11da-b2a4-000e7bbb2b09")
CSmimeCapabilities;
#endif

EXTERN_C const CLSID CLSID_CX509ExtensionSmimeCapabilities;

#ifdef __cplusplus

class DECLSPEC_UUID("884e201b-217d-11da-b2a4-000e7bbb2b09")
CX509ExtensionSmimeCapabilities;
#endif

EXTERN_C const CLSID CLSID_CPolicyQualifier;

#ifdef __cplusplus

class DECLSPEC_UUID("884e201c-217d-11da-b2a4-000e7bbb2b09")
CPolicyQualifier;
#endif

EXTERN_C const CLSID CLSID_CPolicyQualifiers;

#ifdef __cplusplus

class DECLSPEC_UUID("884e201d-217d-11da-b2a4-000e7bbb2b09")
CPolicyQualifiers;
#endif

EXTERN_C const CLSID CLSID_CCertificatePolicy;

#ifdef __cplusplus

class DECLSPEC_UUID("884e201e-217d-11da-b2a4-000e7bbb2b09")
CCertificatePolicy;
#endif

EXTERN_C const CLSID CLSID_CCertificatePolicies;

#ifdef __cplusplus

class DECLSPEC_UUID("884e201f-217d-11da-b2a4-000e7bbb2b09")
CCertificatePolicies;
#endif

EXTERN_C const CLSID CLSID_CX509ExtensionCertificatePolicies;

#ifdef __cplusplus

class DECLSPEC_UUID("884e2020-217d-11da-b2a4-000e7bbb2b09")
CX509ExtensionCertificatePolicies;
#endif

EXTERN_C const CLSID CLSID_CX509ExtensionMSApplicationPolicies;

#ifdef __cplusplus

class DECLSPEC_UUID("884e2021-217d-11da-b2a4-000e7bbb2b09")
CX509ExtensionMSApplicationPolicies;
#endif

EXTERN_C const CLSID CLSID_CX509Attribute;

#ifdef __cplusplus

class DECLSPEC_UUID("884e2022-217d-11da-b2a4-000e7bbb2b09")
CX509Attribute;
#endif

EXTERN_C const CLSID CLSID_CX509Attributes;

#ifdef __cplusplus

class DECLSPEC_UUID("884e2023-217d-11da-b2a4-000e7bbb2b09")
CX509Attributes;
#endif

EXTERN_C const CLSID CLSID_CX509AttributeExtensions;

#ifdef __cplusplus

class DECLSPEC_UUID("884e2024-217d-11da-b2a4-000e7bbb2b09")
CX509AttributeExtensions;
#endif

EXTERN_C const CLSID CLSID_CX509AttributeClientId;

#ifdef __cplusplus

class DECLSPEC_UUID("884e2025-217d-11da-b2a4-000e7bbb2b09")
CX509AttributeClientId;
#endif

EXTERN_C const CLSID CLSID_CX509AttributeRenewalCertificate;

#ifdef __cplusplus

class DECLSPEC_UUID("884e2026-217d-11da-b2a4-000e7bbb2b09")
CX509AttributeRenewalCertificate;
#endif

EXTERN_C const CLSID CLSID_CX509AttributeArchiveKey;

#ifdef __cplusplus

class DECLSPEC_UUID("884e2027-217d-11da-b2a4-000e7bbb2b09")
CX509AttributeArchiveKey;
#endif

EXTERN_C const CLSID CLSID_CX509AttributeArchiveKeyHash;

#ifdef __cplusplus

class DECLSPEC_UUID("884e2028-217d-11da-b2a4-000e7bbb2b09")
CX509AttributeArchiveKeyHash;
#endif

EXTERN_C const CLSID CLSID_CX509AttributeOSVersion;

#ifdef __cplusplus

class DECLSPEC_UUID("884e202a-217d-11da-b2a4-000e7bbb2b09")
CX509AttributeOSVersion;
#endif

EXTERN_C const CLSID CLSID_CX509AttributeCspProvider;

#ifdef __cplusplus

class DECLSPEC_UUID("884e202b-217d-11da-b2a4-000e7bbb2b09")
CX509AttributeCspProvider;
#endif

EXTERN_C const CLSID CLSID_CCryptAttribute;

#ifdef __cplusplus

class DECLSPEC_UUID("884e202c-217d-11da-b2a4-000e7bbb2b09")
CCryptAttribute;
#endif

EXTERN_C const CLSID CLSID_CCryptAttributes;

#ifdef __cplusplus

class DECLSPEC_UUID("884e202d-217d-11da-b2a4-000e7bbb2b09")
CCryptAttributes;
#endif

EXTERN_C const CLSID CLSID_CCertProperty;

#ifdef __cplusplus

class DECLSPEC_UUID("884e202e-217d-11da-b2a4-000e7bbb2b09")
CCertProperty;
#endif

EXTERN_C const CLSID CLSID_CCertProperties;

#ifdef __cplusplus

class DECLSPEC_UUID("884e202f-217d-11da-b2a4-000e7bbb2b09")
CCertProperties;
#endif

EXTERN_C const CLSID CLSID_CCertPropertyFriendlyName;

#ifdef __cplusplus

class DECLSPEC_UUID("884e2030-217d-11da-b2a4-000e7bbb2b09")
CCertPropertyFriendlyName;
#endif

EXTERN_C const CLSID CLSID_CCertPropertyDescription;

#ifdef __cplusplus

class DECLSPEC_UUID("884e2031-217d-11da-b2a4-000e7bbb2b09")
CCertPropertyDescription;
#endif

EXTERN_C const CLSID CLSID_CCertPropertyAutoEnroll;

#ifdef __cplusplus

class DECLSPEC_UUID("884e2032-217d-11da-b2a4-000e7bbb2b09")
CCertPropertyAutoEnroll;
#endif

EXTERN_C const CLSID CLSID_CCertPropertyRequestOriginator;

#ifdef __cplusplus

class DECLSPEC_UUID("884e2033-217d-11da-b2a4-000e7bbb2b09")
CCertPropertyRequestOriginator;
#endif

EXTERN_C const CLSID CLSID_CCertPropertySHA1Hash;

#ifdef __cplusplus

class DECLSPEC_UUID("884e2034-217d-11da-b2a4-000e7bbb2b09")
CCertPropertySHA1Hash;
#endif

EXTERN_C const CLSID CLSID_CCertPropertyKeyProvInfo;

#ifdef __cplusplus

class DECLSPEC_UUID("884e2036-217d-11da-b2a4-000e7bbb2b09")
CCertPropertyKeyProvInfo;
#endif

EXTERN_C const CLSID CLSID_CCertPropertyArchived;

#ifdef __cplusplus

class DECLSPEC_UUID("884e2037-217d-11da-b2a4-000e7bbb2b09")
CCertPropertyArchived;
#endif

EXTERN_C const CLSID CLSID_CCertPropertyBackedUp;

#ifdef __cplusplus

class DECLSPEC_UUID("884e2038-217d-11da-b2a4-000e7bbb2b09")
CCertPropertyBackedUp;
#endif

EXTERN_C const CLSID CLSID_CCertPropertyEnrollment;

#ifdef __cplusplus

class DECLSPEC_UUID("884e2039-217d-11da-b2a4-000e7bbb2b09")
CCertPropertyEnrollment;
#endif

EXTERN_C const CLSID CLSID_CCertPropertyRenewal;

#ifdef __cplusplus

class DECLSPEC_UUID("884e203a-217d-11da-b2a4-000e7bbb2b09")
CCertPropertyRenewal;
#endif

EXTERN_C const CLSID CLSID_CCertPropertyArchivedKeyHash;

#ifdef __cplusplus

class DECLSPEC_UUID("884e203b-217d-11da-b2a4-000e7bbb2b09")
CCertPropertyArchivedKeyHash;
#endif

EXTERN_C const CLSID CLSID_CSignerCertificate;

#ifdef __cplusplus

class DECLSPEC_UUID("884e203d-217d-11da-b2a4-000e7bbb2b09")
CSignerCertificate;
#endif

EXTERN_C const CLSID CLSID_CX509NameValuePair;

#ifdef __cplusplus

class DECLSPEC_UUID("884e203f-217d-11da-b2a4-000e7bbb2b09")
CX509NameValuePair;
#endif

EXTERN_C const CLSID CLSID_CX509CertificateRequestPkcs10;

#ifdef __cplusplus

class DECLSPEC_UUID("884e2042-217d-11da-b2a4-000e7bbb2b09")
CX509CertificateRequestPkcs10;
#endif

EXTERN_C const CLSID CLSID_CX509CertificateRequestCertificate;

#ifdef __cplusplus

class DECLSPEC_UUID("884e2043-217d-11da-b2a4-000e7bbb2b09")
CX509CertificateRequestCertificate;
#endif

EXTERN_C const CLSID CLSID_CX509CertificateRequestPkcs7;

#ifdef __cplusplus

class DECLSPEC_UUID("884e2044-217d-11da-b2a4-000e7bbb2b09")
CX509CertificateRequestPkcs7;
#endif

EXTERN_C const CLSID CLSID_CX509CertificateRequestCmc;

#ifdef __cplusplus

class DECLSPEC_UUID("884e2045-217d-11da-b2a4-000e7bbb2b09")
CX509CertificateRequestCmc;
#endif

EXTERN_C const CLSID CLSID_CX509Enrollment;

#ifdef __cplusplus

class DECLSPEC_UUID("884e2046-217d-11da-b2a4-000e7bbb2b09")
CX509Enrollment;
#endif

EXTERN_C const CLSID CLSID_CX509EnrollmentWebClassFactory;

#ifdef __cplusplus

class DECLSPEC_UUID("884e2049-217d-11da-b2a4-000e7bbb2b09")
CX509EnrollmentWebClassFactory;
#endif
#endif /* __CERTENROLLLib_LIBRARY_DEFINED__ */

/* Additional Prototypes for ALL interfaces */

unsigned long             __RPC_USER  BSTR_UserSize(     unsigned long *, unsigned long            , BSTR * ); 
unsigned char * __RPC_USER  BSTR_UserMarshal(  unsigned long *, unsigned char *, BSTR * ); 
unsigned char * __RPC_USER  BSTR_UserUnmarshal(unsigned long *, unsigned char *, BSTR * ); 
void                      __RPC_USER  BSTR_UserFree(     unsigned long *, BSTR * ); 

unsigned long             __RPC_USER  VARIANT_UserSize(     unsigned long *, unsigned long            , VARIANT * ); 
unsigned char * __RPC_USER  VARIANT_UserMarshal(  unsigned long *, unsigned char *, VARIANT * ); 
unsigned char * __RPC_USER  VARIANT_UserUnmarshal(unsigned long *, unsigned char *, VARIANT * ); 
void                      __RPC_USER  VARIANT_UserFree(     unsigned long *, VARIANT * ); 

unsigned long             __RPC_USER  BSTR_UserSize64(     unsigned long *, unsigned long            , BSTR * ); 
unsigned char * __RPC_USER  BSTR_UserMarshal64(  unsigned long *, unsigned char *, BSTR * ); 
unsigned char * __RPC_USER  BSTR_UserUnmarshal64(unsigned long *, unsigned char *, BSTR * ); 
void                      __RPC_USER  BSTR_UserFree64(     unsigned long *, BSTR * ); 

unsigned long             __RPC_USER  VARIANT_UserSize64(     unsigned long *, unsigned long            , VARIANT * ); 
unsigned char * __RPC_USER  VARIANT_UserMarshal64(  unsigned long *, unsigned char *, VARIANT * ); 
unsigned char * __RPC_USER  VARIANT_UserUnmarshal64(unsigned long *, unsigned char *, VARIANT * ); 
void                      __RPC_USER  VARIANT_UserFree64(     unsigned long *, VARIANT * ); 

/* end of Additional Prototypes */

#ifdef __cplusplus
}
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\vs9sp1\sdk\include\CertMod.h ===
/* this ALWAYS GENERATED file contains the definitions for the interfaces */


 /* File created by MIDL compiler version 7.00.0499 */
/* Compiler settings for certmod.idl:
    Oicf, W1, Zp8, env=Win32 (32b run)
    protocol : dce , ms_ext, c_ext, robust
    error checks: allocation ref bounds_check enum stub_data 
    VC __declspec() decoration level: 
         __declspec(uuid()), __declspec(selectany), __declspec(novtable)
         DECLSPEC_UUID(), MIDL_INTERFACE()
*/
//@@MIDL_FILE_HEADING(  )

#pragma warning( disable: 4049 )  /* more than 64k source lines */


/* verify that the <rpcndr.h> version is high enough to compile this file*/
#ifndef __REQUIRED_RPCNDR_H_VERSION__
#define __REQUIRED_RPCNDR_H_VERSION__ 500
#endif

/* verify that the <rpcsal.h> version is high enough to compile this file*/
#ifndef __REQUIRED_RPCSAL_H_VERSION__
#define __REQUIRED_RPCSAL_H_VERSION__ 100
#endif

#include "rpc.h"
#include "rpcndr.h"

#ifndef __RPCNDR_H_VERSION__
#error this stub requires an updated version of <rpcndr.h>
#endif // __RPCNDR_H_VERSION__

#ifndef COM_NO_WINDOWS_H
#include "windows.h"
#include "ole2.h"
#endif /*COM_NO_WINDOWS_H*/

#ifndef __certmod_h__
#define __certmod_h__

#if defined(_MSC_VER) && (_MSC_VER >= 1020)
#pragma once
#endif

/* Forward Declarations */ 

#ifndef __ICertManageModule_FWD_DEFINED__
#define __ICertManageModule_FWD_DEFINED__
typedef interface ICertManageModule ICertManageModule;
#endif 	/* __ICertManageModule_FWD_DEFINED__ */


/* header files for imported files */
#include "wtypes.h"
#include "oaidl.h"

#ifdef __cplusplus
extern "C"{
#endif 


/* interface __MIDL_itf_certmod_0000_0000 */
/* [local] */ 

#define	CMM_REFRESHONLY	( 0x1 )

#define	CMM_READONLY	( 0x2 )

const WCHAR wszCMM_PROP_NAME[  ]	=	L"Name";

const WCHAR wszCMM_PROP_DESCRIPTION[  ]	=	L"Description";

const WCHAR wszCMM_PROP_COPYRIGHT[  ]	=	L"Copyright";

const WCHAR wszCMM_PROP_FILEVER[  ]	=	L"File Version";

const WCHAR wszCMM_PROP_PRODUCTVER[  ]	=	L"Product Version";

const WCHAR wszCMM_PROP_DISPLAY_HWND[  ]	=	L"HWND";

const WCHAR wszCMM_PROP_ISMULTITHREADED[  ]	=	L"IsMultiThreaded";



extern RPC_IF_HANDLE __MIDL_itf_certmod_0000_0000_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_certmod_0000_0000_v0_0_s_ifspec;

#ifndef __ICertManageModule_INTERFACE_DEFINED__
#define __ICertManageModule_INTERFACE_DEFINED__

/* interface ICertManageModule */
/* [unique][helpstring][dual][uuid][object] */ 


EXTERN_C const IID IID_ICertManageModule;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("e7d7ad42-bd3d-11d1-9a4d-00c04fc297eb")
    ICertManageModule : public IDispatch
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE GetProperty( 
            /* [in] */ __RPC__in const BSTR strConfig,
            /* [in] */ __RPC__in BSTR strStorageLocation,
            /* [in] */ __RPC__in BSTR strPropertyName,
            /* [in] */ LONG Flags,
            /* [retval][out] */ __RPC__out VARIANT *pvarProperty) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetProperty( 
            /* [in] */ __RPC__in const BSTR strConfig,
            /* [in] */ __RPC__in BSTR strStorageLocation,
            /* [in] */ __RPC__in BSTR strPropertyName,
            /* [in] */ LONG Flags,
            /* [in] */ __RPC__in const VARIANT *pvarProperty) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Configure( 
            /* [in] */ __RPC__in const BSTR strConfig,
            /* [in] */ __RPC__in BSTR strStorageLocation,
            /* [in] */ LONG Flags) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct ICertManageModuleVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            ICertManageModule * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            ICertManageModule * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            ICertManageModule * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfoCount )( 
            ICertManageModule * This,
            /* [out] */ __RPC__out UINT *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfo )( 
            ICertManageModule * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ __RPC__deref_out_opt ITypeInfo **ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetIDsOfNames )( 
            ICertManageModule * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [size_is][in] */ __RPC__in_ecount_full(cNames) LPOLESTR *rgszNames,
            /* [range][in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ __RPC__out_ecount_full(cNames) DISPID *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE *Invoke )( 
            ICertManageModule * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS *pDispParams,
            /* [out] */ VARIANT *pVarResult,
            /* [out] */ EXCEPINFO *pExcepInfo,
            /* [out] */ UINT *puArgErr);
        
        HRESULT ( STDMETHODCALLTYPE *GetProperty )( 
            ICertManageModule * This,
            /* [in] */ __RPC__in const BSTR strConfig,
            /* [in] */ __RPC__in BSTR strStorageLocation,
            /* [in] */ __RPC__in BSTR strPropertyName,
            /* [in] */ LONG Flags,
            /* [retval][out] */ __RPC__out VARIANT *pvarProperty);
        
        HRESULT ( STDMETHODCALLTYPE *SetProperty )( 
            ICertManageModule * This,
            /* [in] */ __RPC__in const BSTR strConfig,
            /* [in] */ __RPC__in BSTR strStorageLocation,
            /* [in] */ __RPC__in BSTR strPropertyName,
            /* [in] */ LONG Flags,
            /* [in] */ __RPC__in const VARIANT *pvarProperty);
        
        HRESULT ( STDMETHODCALLTYPE *Configure )( 
            ICertManageModule * This,
            /* [in] */ __RPC__in const BSTR strConfig,
            /* [in] */ __RPC__in BSTR strStorageLocation,
            /* [in] */ LONG Flags);
        
        END_INTERFACE
    } ICertManageModuleVtbl;

    interface ICertManageModule
    {
        CONST_VTBL struct ICertManageModuleVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define ICertManageModule_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define ICertManageModule_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define ICertManageModule_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define ICertManageModule_GetTypeInfoCount(This,pctinfo)	\
    ( (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo) ) 

#define ICertManageModule_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    ( (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo) ) 

#define ICertManageModule_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    ( (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId) ) 

#define ICertManageModule_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    ( (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr) ) 


#define ICertManageModule_GetProperty(This,strConfig,strStorageLocation,strPropertyName,Flags,pvarProperty)	\
    ( (This)->lpVtbl -> GetProperty(This,strConfig,strStorageLocation,strPropertyName,Flags,pvarProperty) ) 

#define ICertManageModule_SetProperty(This,strConfig,strStorageLocation,strPropertyName,Flags,pvarProperty)	\
    ( (This)->lpVtbl -> SetProperty(This,strConfig,strStorageLocation,strPropertyName,Flags,pvarProperty) ) 

#define ICertManageModule_Configure(This,strConfig,strStorageLocation,Flags)	\
    ( (This)->lpVtbl -> Configure(This,strConfig,strStorageLocation,Flags) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __ICertManageModule_INTERFACE_DEFINED__ */


/* Additional Prototypes for ALL interfaces */

unsigned long             __RPC_USER  BSTR_UserSize(     unsigned long *, unsigned long            , BSTR * ); 
unsigned char * __RPC_USER  BSTR_UserMarshal(  unsigned long *, unsigned char *, BSTR * ); 
unsigned char * __RPC_USER  BSTR_UserUnmarshal(unsigned long *, unsigned char *, BSTR * ); 
void                      __RPC_USER  BSTR_UserFree(     unsigned long *, BSTR * ); 

unsigned long             __RPC_USER  VARIANT_UserSize(     unsigned long *, unsigned long            , VARIANT * ); 
unsigned char * __RPC_USER  VARIANT_UserMarshal(  unsigned long *, unsigned char *, VARIANT * ); 
unsigned char * __RPC_USER  VARIANT_UserUnmarshal(unsigned long *, unsigned char *, VARIANT * ); 
void                      __RPC_USER  VARIANT_UserFree(     unsigned long *, VARIANT * ); 

unsigned long             __RPC_USER  BSTR_UserSize64(     unsigned long *, unsigned long            , BSTR * ); 
unsigned char * __RPC_USER  BSTR_UserMarshal64(  unsigned long *, unsigned char *, BSTR * ); 
unsigned char * __RPC_USER  BSTR_UserUnmarshal64(unsigned long *, unsigned char *, BSTR * ); 
void                      __RPC_USER  BSTR_UserFree64(     unsigned long *, BSTR * ); 

unsigned long             __RPC_USER  VARIANT_UserSize64(     unsigned long *, unsigned long            , VARIANT * ); 
unsigned char * __RPC_USER  VARIANT_UserMarshal64(  unsigned long *, unsigned char *, VARIANT * ); 
unsigned char * __RPC_USER  VARIANT_UserUnmarshal64(unsigned long *, unsigned char *, VARIANT * ); 
void                      __RPC_USER  VARIANT_UserFree64(     unsigned long *, VARIANT * ); 

/* end of Additional Prototypes */

#ifdef __cplusplus
}
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\vs9sp1\sdk\include\Certif.h ===
/* this ALWAYS GENERATED file contains the definitions for the interfaces */


 /* File created by MIDL compiler version 7.00.0499 */
/* Compiler settings for certif.idl:
    Oicf, W1, Zp8, env=Win32 (32b run)
    protocol : dce , ms_ext, c_ext, robust
    error checks: allocation ref bounds_check enum stub_data 
    VC __declspec() decoration level: 
         __declspec(uuid()), __declspec(selectany), __declspec(novtable)
         DECLSPEC_UUID(), MIDL_INTERFACE()
*/
//@@MIDL_FILE_HEADING(  )

#pragma warning( disable: 4049 )  /* more than 64k source lines */


/* verify that the <rpcndr.h> version is high enough to compile this file*/
#ifndef __REQUIRED_RPCNDR_H_VERSION__
#define __REQUIRED_RPCNDR_H_VERSION__ 500
#endif

/* verify that the <rpcsal.h> version is high enough to compile this file*/
#ifndef __REQUIRED_RPCSAL_H_VERSION__
#define __REQUIRED_RPCSAL_H_VERSION__ 100
#endif

#include "rpc.h"
#include "rpcndr.h"

#ifndef __RPCNDR_H_VERSION__
#error this stub requires an updated version of <rpcndr.h>
#endif // __RPCNDR_H_VERSION__

#ifndef COM_NO_WINDOWS_H
#include "windows.h"
#include "ole2.h"
#endif /*COM_NO_WINDOWS_H*/

#ifndef __certif_h__
#define __certif_h__

#if defined(_MSC_VER) && (_MSC_VER >= 1020)
#pragma once
#endif

/* Forward Declarations */ 

#ifndef __ICertServerPolicy_FWD_DEFINED__
#define __ICertServerPolicy_FWD_DEFINED__
typedef interface ICertServerPolicy ICertServerPolicy;
#endif 	/* __ICertServerPolicy_FWD_DEFINED__ */


#ifndef __ICertServerExit_FWD_DEFINED__
#define __ICertServerExit_FWD_DEFINED__
typedef interface ICertServerExit ICertServerExit;
#endif 	/* __ICertServerExit_FWD_DEFINED__ */


/* header files for imported files */
#include "wtypes.h"
#include "oaidl.h"

#ifdef __cplusplus
extern "C"{
#endif 


/* interface __MIDL_itf_certif_0000_0000 */
/* [local] */ 

#define	ENUMEXT_OBJECTID	( 0x1 )



extern RPC_IF_HANDLE __MIDL_itf_certif_0000_0000_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_certif_0000_0000_v0_0_s_ifspec;

#ifndef __ICertServerPolicy_INTERFACE_DEFINED__
#define __ICertServerPolicy_INTERFACE_DEFINED__

/* interface ICertServerPolicy */
/* [unique][helpstring][dual][uuid][object] */ 


EXTERN_C const IID IID_ICertServerPolicy;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("aa000922-ffbe-11cf-8800-00a0c903b83c")
    ICertServerPolicy : public IDispatch
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE SetContext( 
            /* [in] */ LONG Context) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetRequestProperty( 
            /* [in] */ __RPC__in const BSTR strPropertyName,
            /* [in] */ LONG PropertyType,
            /* [retval][out] */ __RPC__out VARIANT *pvarPropertyValue) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetRequestAttribute( 
            /* [in] */ __RPC__in const BSTR strAttributeName,
            /* [retval][out] */ __RPC__deref_out_opt BSTR *pstrAttributeValue) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetCertificateProperty( 
            /* [in] */ __RPC__in const BSTR strPropertyName,
            /* [in] */ LONG PropertyType,
            /* [retval][out] */ __RPC__out VARIANT *pvarPropertyValue) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetCertificateProperty( 
            /* [in] */ __RPC__in const BSTR strPropertyName,
            /* [in] */ LONG PropertyType,
            /* [in] */ __RPC__in const VARIANT *pvarPropertyValue) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetCertificateExtension( 
            /* [in] */ __RPC__in const BSTR strExtensionName,
            /* [in] */ LONG Type,
            /* [retval][out] */ __RPC__out VARIANT *pvarValue) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetCertificateExtensionFlags( 
            /* [retval][out] */ __RPC__out LONG *pExtFlags) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetCertificateExtension( 
            /* [in] */ __RPC__in const BSTR strExtensionName,
            /* [in] */ LONG Type,
            /* [in] */ LONG ExtFlags,
            /* [in] */ __RPC__in const VARIANT *pvarValue) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE EnumerateExtensionsSetup( 
            /* [in] */ LONG Flags) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE EnumerateExtensions( 
            /* [retval][out] */ __RPC__deref_out_opt BSTR *pstrExtensionName) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE EnumerateExtensionsClose( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE EnumerateAttributesSetup( 
            /* [in] */ LONG Flags) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE EnumerateAttributes( 
            /* [retval][out] */ __RPC__deref_out_opt BSTR *pstrAttributeName) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE EnumerateAttributesClose( void) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct ICertServerPolicyVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            ICertServerPolicy * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            ICertServerPolicy * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            ICertServerPolicy * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfoCount )( 
            ICertServerPolicy * This,
            /* [out] */ __RPC__out UINT *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfo )( 
            ICertServerPolicy * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ __RPC__deref_out_opt ITypeInfo **ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetIDsOfNames )( 
            ICertServerPolicy * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [size_is][in] */ __RPC__in_ecount_full(cNames) LPOLESTR *rgszNames,
            /* [range][in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ __RPC__out_ecount_full(cNames) DISPID *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE *Invoke )( 
            ICertServerPolicy * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS *pDispParams,
            /* [out] */ VARIANT *pVarResult,
            /* [out] */ EXCEPINFO *pExcepInfo,
            /* [out] */ UINT *puArgErr);
        
        HRESULT ( STDMETHODCALLTYPE *SetContext )( 
            ICertServerPolicy * This,
            /* [in] */ LONG Context);
        
        HRESULT ( STDMETHODCALLTYPE *GetRequestProperty )( 
            ICertServerPolicy * This,
            /* [in] */ __RPC__in const BSTR strPropertyName,
            /* [in] */ LONG PropertyType,
            /* [retval][out] */ __RPC__out VARIANT *pvarPropertyValue);
        
        HRESULT ( STDMETHODCALLTYPE *GetRequestAttribute )( 
            ICertServerPolicy * This,
            /* [in] */ __RPC__in const BSTR strAttributeName,
            /* [retval][out] */ __RPC__deref_out_opt BSTR *pstrAttributeValue);
        
        HRESULT ( STDMETHODCALLTYPE *GetCertificateProperty )( 
            ICertServerPolicy * This,
            /* [in] */ __RPC__in const BSTR strPropertyName,
            /* [in] */ LONG PropertyType,
            /* [retval][out] */ __RPC__out VARIANT *pvarPropertyValue);
        
        HRESULT ( STDMETHODCALLTYPE *SetCertificateProperty )( 
            ICertServerPolicy * This,
            /* [in] */ __RPC__in const BSTR strPropertyName,
            /* [in] */ LONG PropertyType,
            /* [in] */ __RPC__in const VARIANT *pvarPropertyValue);
        
        HRESULT ( STDMETHODCALLTYPE *GetCertificateExtension )( 
            ICertServerPolicy * This,
            /* [in] */ __RPC__in const BSTR strExtensionName,
            /* [in] */ LONG Type,
            /* [retval][out] */ __RPC__out VARIANT *pvarValue);
        
        HRESULT ( STDMETHODCALLTYPE *GetCertificateExtensionFlags )( 
            ICertServerPolicy * This,
            /* [retval][out] */ __RPC__out LONG *pExtFlags);
        
        HRESULT ( STDMETHODCALLTYPE *SetCertificateExtension )( 
            ICertServerPolicy * This,
            /* [in] */ __RPC__in const BSTR strExtensionName,
            /* [in] */ LONG Type,
            /* [in] */ LONG ExtFlags,
            /* [in] */ __RPC__in const VARIANT *pvarValue);
        
        HRESULT ( STDMETHODCALLTYPE *EnumerateExtensionsSetup )( 
            ICertServerPolicy * This,
            /* [in] */ LONG Flags);
        
        HRESULT ( STDMETHODCALLTYPE *EnumerateExtensions )( 
            ICertServerPolicy * This,
            /* [retval][out] */ __RPC__deref_out_opt BSTR *pstrExtensionName);
        
        HRESULT ( STDMETHODCALLTYPE *EnumerateExtensionsClose )( 
            ICertServerPolicy * This);
        
        HRESULT ( STDMETHODCALLTYPE *EnumerateAttributesSetup )( 
            ICertServerPolicy * This,
            /* [in] */ LONG Flags);
        
        HRESULT ( STDMETHODCALLTYPE *EnumerateAttributes )( 
            ICertServerPolicy * This,
            /* [retval][out] */ __RPC__deref_out_opt BSTR *pstrAttributeName);
        
        HRESULT ( STDMETHODCALLTYPE *EnumerateAttributesClose )( 
            ICertServerPolicy * This);
        
        END_INTERFACE
    } ICertServerPolicyVtbl;

    interface ICertServerPolicy
    {
        CONST_VTBL struct ICertServerPolicyVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define ICertServerPolicy_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define ICertServerPolicy_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define ICertServerPolicy_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define ICertServerPolicy_GetTypeInfoCount(This,pctinfo)	\
    ( (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo) ) 

#define ICertServerPolicy_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    ( (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo) ) 

#define ICertServerPolicy_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    ( (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId) ) 

#define ICertServerPolicy_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    ( (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr) ) 


#define ICertServerPolicy_SetContext(This,Context)	\
    ( (This)->lpVtbl -> SetContext(This,Context) ) 

#define ICertServerPolicy_GetRequestProperty(This,strPropertyName,PropertyType,pvarPropertyValue)	\
    ( (This)->lpVtbl -> GetRequestProperty(This,strPropertyName,PropertyType,pvarPropertyValue) ) 

#define ICertServerPolicy_GetRequestAttribute(This,strAttributeName,pstrAttributeValue)	\
    ( (This)->lpVtbl -> GetRequestAttribute(This,strAttributeName,pstrAttributeValue) ) 

#define ICertServerPolicy_GetCertificateProperty(This,strPropertyName,PropertyType,pvarPropertyValue)	\
    ( (This)->lpVtbl -> GetCertificateProperty(This,strPropertyName,PropertyType,pvarPropertyValue) ) 

#define ICertServerPolicy_SetCertificateProperty(This,strPropertyName,PropertyType,pvarPropertyValue)	\
    ( (This)->lpVtbl -> SetCertificateProperty(This,strPropertyName,PropertyType,pvarPropertyValue) ) 

#define ICertServerPolicy_GetCertificateExtension(This,strExtensionName,Type,pvarValue)	\
    ( (This)->lpVtbl -> GetCertificateExtension(This,strExtensionName,Type,pvarValue) ) 

#define ICertServerPolicy_GetCertificateExtensionFlags(This,pExtFlags)	\
    ( (This)->lpVtbl -> GetCertificateExtensionFlags(This,pExtFlags) ) 

#define ICertServerPolicy_SetCertificateExtension(This,strExtensionName,Type,ExtFlags,pvarValue)	\
    ( (This)->lpVtbl -> SetCertificateExtension(This,strExtensionName,Type,ExtFlags,pvarValue) ) 

#define ICertServerPolicy_EnumerateExtensionsSetup(This,Flags)	\
    ( (This)->lpVtbl -> EnumerateExtensionsSetup(This,Flags) ) 

#define ICertServerPolicy_EnumerateExtensions(This,pstrExtensionName)	\
    ( (This)->lpVtbl -> EnumerateExtensions(This,pstrExtensionName) ) 

#define ICertServerPolicy_EnumerateExtensionsClose(This)	\
    ( (This)->lpVtbl -> EnumerateExtensionsClose(This) ) 

#define ICertServerPolicy_EnumerateAttributesSetup(This,Flags)	\
    ( (This)->lpVtbl -> EnumerateAttributesSetup(This,Flags) ) 

#define ICertServerPolicy_EnumerateAttributes(This,pstrAttributeName)	\
    ( (This)->lpVtbl -> EnumerateAttributes(This,pstrAttributeName) ) 

#define ICertServerPolicy_EnumerateAttributesClose(This)	\
    ( (This)->lpVtbl -> EnumerateAttributesClose(This) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __ICertServerPolicy_INTERFACE_DEFINED__ */


#ifndef __ICertServerExit_INTERFACE_DEFINED__
#define __ICertServerExit_INTERFACE_DEFINED__

/* interface ICertServerExit */
/* [unique][helpstring][dual][uuid][object] */ 


EXTERN_C const IID IID_ICertServerExit;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("4ba9eb90-732c-11d0-8816-00a0c903b83c")
    ICertServerExit : public IDispatch
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE SetContext( 
            /* [in] */ LONG Context) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetRequestProperty( 
            /* [in] */ __RPC__in const BSTR strPropertyName,
            /* [in] */ LONG PropertyType,
            /* [retval][out] */ __RPC__out VARIANT *pvarPropertyValue) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetRequestAttribute( 
            /* [in] */ __RPC__in const BSTR strAttributeName,
            /* [retval][out] */ __RPC__deref_out_opt BSTR *pstrAttributeValue) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetCertificateProperty( 
            /* [in] */ __RPC__in const BSTR strPropertyName,
            /* [in] */ LONG PropertyType,
            /* [retval][out] */ __RPC__out VARIANT *pvarPropertyValue) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetCertificateExtension( 
            /* [in] */ __RPC__in const BSTR strExtensionName,
            /* [in] */ LONG Type,
            /* [retval][out] */ __RPC__out VARIANT *pvarValue) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetCertificateExtensionFlags( 
            /* [retval][out] */ __RPC__out LONG *pExtFlags) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE EnumerateExtensionsSetup( 
            /* [in] */ LONG Flags) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE EnumerateExtensions( 
            /* [retval][out] */ __RPC__deref_out_opt BSTR *pstrExtensionName) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE EnumerateExtensionsClose( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE EnumerateAttributesSetup( 
            /* [in] */ LONG Flags) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE EnumerateAttributes( 
            /* [retval][out] */ __RPC__deref_out_opt BSTR *pstrAttributeName) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE EnumerateAttributesClose( void) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct ICertServerExitVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            ICertServerExit * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            ICertServerExit * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            ICertServerExit * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfoCount )( 
            ICertServerExit * This,
            /* [out] */ __RPC__out UINT *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfo )( 
            ICertServerExit * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ __RPC__deref_out_opt ITypeInfo **ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetIDsOfNames )( 
            ICertServerExit * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [size_is][in] */ __RPC__in_ecount_full(cNames) LPOLESTR *rgszNames,
            /* [range][in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ __RPC__out_ecount_full(cNames) DISPID *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE *Invoke )( 
            ICertServerExit * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS *pDispParams,
            /* [out] */ VARIANT *pVarResult,
            /* [out] */ EXCEPINFO *pExcepInfo,
            /* [out] */ UINT *puArgErr);
        
        HRESULT ( STDMETHODCALLTYPE *SetContext )( 
            ICertServerExit * This,
            /* [in] */ LONG Context);
        
        HRESULT ( STDMETHODCALLTYPE *GetRequestProperty )( 
            ICertServerExit * This,
            /* [in] */ __RPC__in const BSTR strPropertyName,
            /* [in] */ LONG PropertyType,
            /* [retval][out] */ __RPC__out VARIANT *pvarPropertyValue);
        
        HRESULT ( STDMETHODCALLTYPE *GetRequestAttribute )( 
            ICertServerExit * This,
            /* [in] */ __RPC__in const BSTR strAttributeName,
            /* [retval][out] */ __RPC__deref_out_opt BSTR *pstrAttributeValue);
        
        HRESULT ( STDMETHODCALLTYPE *GetCertificateProperty )( 
            ICertServerExit * This,
            /* [in] */ __RPC__in const BSTR strPropertyName,
            /* [in] */ LONG PropertyType,
            /* [retval][out] */ __RPC__out VARIANT *pvarPropertyValue);
        
        HRESULT ( STDMETHODCALLTYPE *GetCertificateExtension )( 
            ICertServerExit * This,
            /* [in] */ __RPC__in const BSTR strExtensionName,
            /* [in] */ LONG Type,
            /* [retval][out] */ __RPC__out VARIANT *pvarValue);
        
        HRESULT ( STDMETHODCALLTYPE *GetCertificateExtensionFlags )( 
            ICertServerExit * This,
            /* [retval][out] */ __RPC__out LONG *pExtFlags);
        
        HRESULT ( STDMETHODCALLTYPE *EnumerateExtensionsSetup )( 
            ICertServerExit * This,
            /* [in] */ LONG Flags);
        
        HRESULT ( STDMETHODCALLTYPE *EnumerateExtensions )( 
            ICertServerExit * This,
            /* [retval][out] */ __RPC__deref_out_opt BSTR *pstrExtensionName);
        
        HRESULT ( STDMETHODCALLTYPE *EnumerateExtensionsClose )( 
            ICertServerExit * This);
        
        HRESULT ( STDMETHODCALLTYPE *EnumerateAttributesSetup )( 
            ICertServerExit * This,
            /* [in] */ LONG Flags);
        
        HRESULT ( STDMETHODCALLTYPE *EnumerateAttributes )( 
            ICertServerExit * This,
            /* [retval][out] */ __RPC__deref_out_opt BSTR *pstrAttributeName);
        
        HRESULT ( STDMETHODCALLTYPE *EnumerateAttributesClose )( 
            ICertServerExit * This);
        
        END_INTERFACE
    } ICertServerExitVtbl;

    interface ICertServerExit
    {
        CONST_VTBL struct ICertServerExitVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define ICertServerExit_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define ICertServerExit_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define ICertServerExit_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define ICertServerExit_GetTypeInfoCount(This,pctinfo)	\
    ( (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo) ) 

#define ICertServerExit_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    ( (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo) ) 

#define ICertServerExit_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    ( (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId) ) 

#define ICertServerExit_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    ( (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr) ) 


#define ICertServerExit_SetContext(This,Context)	\
    ( (This)->lpVtbl -> SetContext(This,Context) ) 

#define ICertServerExit_GetRequestProperty(This,strPropertyName,PropertyType,pvarPropertyValue)	\
    ( (This)->lpVtbl -> GetRequestProperty(This,strPropertyName,PropertyType,pvarPropertyValue) ) 

#define ICertServerExit_GetRequestAttribute(This,strAttributeName,pstrAttributeValue)	\
    ( (This)->lpVtbl -> GetRequestAttribute(This,strAttributeName,pstrAttributeValue) ) 

#define ICertServerExit_GetCertificateProperty(This,strPropertyName,PropertyType,pvarPropertyValue)	\
    ( (This)->lpVtbl -> GetCertificateProperty(This,strPropertyName,PropertyType,pvarPropertyValue) ) 

#define ICertServerExit_GetCertificateExtension(This,strExtensionName,Type,pvarValue)	\
    ( (This)->lpVtbl -> GetCertificateExtension(This,strExtensionName,Type,pvarValue) ) 

#define ICertServerExit_GetCertificateExtensionFlags(This,pExtFlags)	\
    ( (This)->lpVtbl -> GetCertificateExtensionFlags(This,pExtFlags) ) 

#define ICertServerExit_EnumerateExtensionsSetup(This,Flags)	\
    ( (This)->lpVtbl -> EnumerateExtensionsSetup(This,Flags) ) 

#define ICertServerExit_EnumerateExtensions(This,pstrExtensionName)	\
    ( (This)->lpVtbl -> EnumerateExtensions(This,pstrExtensionName) ) 

#define ICertServerExit_EnumerateExtensionsClose(This)	\
    ( (This)->lpVtbl -> EnumerateExtensionsClose(This) ) 

#define ICertServerExit_EnumerateAttributesSetup(This,Flags)	\
    ( (This)->lpVtbl -> EnumerateAttributesSetup(This,Flags) ) 

#define ICertServerExit_EnumerateAttributes(This,pstrAttributeName)	\
    ( (This)->lpVtbl -> EnumerateAttributes(This,pstrAttributeName) ) 

#define ICertServerExit_EnumerateAttributesClose(This)	\
    ( (This)->lpVtbl -> EnumerateAttributesClose(This) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __ICertServerExit_INTERFACE_DEFINED__ */


/* Additional Prototypes for ALL interfaces */

unsigned long             __RPC_USER  BSTR_UserSize(     unsigned long *, unsigned long            , BSTR * ); 
unsigned char * __RPC_USER  BSTR_UserMarshal(  unsigned long *, unsigned char *, BSTR * ); 
unsigned char * __RPC_USER  BSTR_UserUnmarshal(unsigned long *, unsigned char *, BSTR * ); 
void                      __RPC_USER  BSTR_UserFree(     unsigned long *, BSTR * ); 

unsigned long             __RPC_USER  VARIANT_UserSize(     unsigned long *, unsigned long            , VARIANT * ); 
unsigned char * __RPC_USER  VARIANT_UserMarshal(  unsigned long *, unsigned char *, VARIANT * ); 
unsigned char * __RPC_USER  VARIANT_UserUnmarshal(unsigned long *, unsigned char *, VARIANT * ); 
void                      __RPC_USER  VARIANT_UserFree(     unsigned long *, VARIANT * ); 

unsigned long             __RPC_USER  BSTR_UserSize64(     unsigned long *, unsigned long            , BSTR * ); 
unsigned char * __RPC_USER  BSTR_UserMarshal64(  unsigned long *, unsigned char *, BSTR * ); 
unsigned char * __RPC_USER  BSTR_UserUnmarshal64(unsigned long *, unsigned char *, BSTR * ); 
void                      __RPC_USER  BSTR_UserFree64(     unsigned long *, BSTR * ); 

unsigned long             __RPC_USER  VARIANT_UserSize64(     unsigned long *, unsigned long            , VARIANT * ); 
unsigned char * __RPC_USER  VARIANT_UserMarshal64(  unsigned long *, unsigned char *, VARIANT * ); 
unsigned char * __RPC_USER  VARIANT_UserUnmarshal64(unsigned long *, unsigned char *, VARIANT * ); 
void                      __RPC_USER  VARIANT_UserFree64(     unsigned long *, VARIANT * ); 

/* end of Additional Prototypes */

#ifdef __cplusplus
}
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\vs9sp1\sdk\include\CertPol.h ===
/* this ALWAYS GENERATED file contains the definitions for the interfaces */


 /* File created by MIDL compiler version 7.00.0499 */
/* Compiler settings for certpol.idl:
    Oicf, W1, Zp8, env=Win32 (32b run)
    protocol : dce , ms_ext, c_ext, robust
    error checks: allocation ref bounds_check enum stub_data 
    VC __declspec() decoration level: 
         __declspec(uuid()), __declspec(selectany), __declspec(novtable)
         DECLSPEC_UUID(), MIDL_INTERFACE()
*/
//@@MIDL_FILE_HEADING(  )

#pragma warning( disable: 4049 )  /* more than 64k source lines */


/* verify that the <rpcndr.h> version is high enough to compile this file*/
#ifndef __REQUIRED_RPCNDR_H_VERSION__
#define __REQUIRED_RPCNDR_H_VERSION__ 500
#endif

/* verify that the <rpcsal.h> version is high enough to compile this file*/
#ifndef __REQUIRED_RPCSAL_H_VERSION__
#define __REQUIRED_RPCSAL_H_VERSION__ 100
#endif

#include "rpc.h"
#include "rpcndr.h"

#ifndef __RPCNDR_H_VERSION__
#error this stub requires an updated version of <rpcndr.h>
#endif // __RPCNDR_H_VERSION__

#ifndef COM_NO_WINDOWS_H
#include "windows.h"
#include "ole2.h"
#endif /*COM_NO_WINDOWS_H*/

#ifndef __certpol_h__
#define __certpol_h__

#if defined(_MSC_VER) && (_MSC_VER >= 1020)
#pragma once
#endif

/* Forward Declarations */ 

#ifndef __ICertPolicy_FWD_DEFINED__
#define __ICertPolicy_FWD_DEFINED__
typedef interface ICertPolicy ICertPolicy;
#endif 	/* __ICertPolicy_FWD_DEFINED__ */


#ifndef __ICertPolicy2_FWD_DEFINED__
#define __ICertPolicy2_FWD_DEFINED__
typedef interface ICertPolicy2 ICertPolicy2;
#endif 	/* __ICertPolicy2_FWD_DEFINED__ */


/* header files for imported files */
#include "wtypes.h"
#include "certmod.h"

#ifdef __cplusplus
extern "C"{
#endif 


#ifndef __ICertPolicy_INTERFACE_DEFINED__
#define __ICertPolicy_INTERFACE_DEFINED__

/* interface ICertPolicy */
/* [unique][helpstring][dual][uuid][object] */ 


EXTERN_C const IID IID_ICertPolicy;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("38bb5a00-7636-11d0-b413-00a0c91bbf8c")
    ICertPolicy : public IDispatch
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE Initialize( 
            /* [in] */ __RPC__in const BSTR strConfig) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE VerifyRequest( 
            /* [in] */ __RPC__in const BSTR strConfig,
            /* [in] */ LONG Context,
            /* [in] */ LONG bNewRequest,
            /* [in] */ LONG Flags,
            /* [retval][out] */ __RPC__out LONG *pDisposition) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetDescription( 
            /* [retval][out] */ __RPC__deref_out_opt BSTR *pstrDescription) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE ShutDown( void) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct ICertPolicyVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            ICertPolicy * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            ICertPolicy * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            ICertPolicy * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfoCount )( 
            ICertPolicy * This,
            /* [out] */ __RPC__out UINT *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfo )( 
            ICertPolicy * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ __RPC__deref_out_opt ITypeInfo **ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetIDsOfNames )( 
            ICertPolicy * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [size_is][in] */ __RPC__in_ecount_full(cNames) LPOLESTR *rgszNames,
            /* [range][in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ __RPC__out_ecount_full(cNames) DISPID *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE *Invoke )( 
            ICertPolicy * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS *pDispParams,
            /* [out] */ VARIANT *pVarResult,
            /* [out] */ EXCEPINFO *pExcepInfo,
            /* [out] */ UINT *puArgErr);
        
        HRESULT ( STDMETHODCALLTYPE *Initialize )( 
            ICertPolicy * This,
            /* [in] */ __RPC__in const BSTR strConfig);
        
        HRESULT ( STDMETHODCALLTYPE *VerifyRequest )( 
            ICertPolicy * This,
            /* [in] */ __RPC__in const BSTR strConfig,
            /* [in] */ LONG Context,
            /* [in] */ LONG bNewRequest,
            /* [in] */ LONG Flags,
            /* [retval][out] */ __RPC__out LONG *pDisposition);
        
        HRESULT ( STDMETHODCALLTYPE *GetDescription )( 
            ICertPolicy * This,
            /* [retval][out] */ __RPC__deref_out_opt BSTR *pstrDescription);
        
        HRESULT ( STDMETHODCALLTYPE *ShutDown )( 
            ICertPolicy * This);
        
        END_INTERFACE
    } ICertPolicyVtbl;

    interface ICertPolicy
    {
        CONST_VTBL struct ICertPolicyVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define ICertPolicy_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define ICertPolicy_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define ICertPolicy_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define ICertPolicy_GetTypeInfoCount(This,pctinfo)	\
    ( (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo) ) 

#define ICertPolicy_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    ( (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo) ) 

#define ICertPolicy_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    ( (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId) ) 

#define ICertPolicy_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    ( (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr) ) 


#define ICertPolicy_Initialize(This,strConfig)	\
    ( (This)->lpVtbl -> Initialize(This,strConfig) ) 

#define ICertPolicy_VerifyRequest(This,strConfig,Context,bNewRequest,Flags,pDisposition)	\
    ( (This)->lpVtbl -> VerifyRequest(This,strConfig,Context,bNewRequest,Flags,pDisposition) ) 

#define ICertPolicy_GetDescription(This,pstrDescription)	\
    ( (This)->lpVtbl -> GetDescription(This,pstrDescription) ) 

#define ICertPolicy_ShutDown(This)	\
    ( (This)->lpVtbl -> ShutDown(This) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __ICertPolicy_INTERFACE_DEFINED__ */


#ifndef __ICertPolicy2_INTERFACE_DEFINED__
#define __ICertPolicy2_INTERFACE_DEFINED__

/* interface ICertPolicy2 */
/* [unique][helpstring][dual][uuid][object] */ 


EXTERN_C const IID IID_ICertPolicy2;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("3db4910e-8001-4bf1-aa1b-f43a808317a0")
    ICertPolicy2 : public ICertPolicy
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE GetManageModule( 
            /* [retval][out] */ __RPC__deref_out_opt ICertManageModule **ppManageModule) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct ICertPolicy2Vtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            ICertPolicy2 * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            ICertPolicy2 * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            ICertPolicy2 * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfoCount )( 
            ICertPolicy2 * This,
            /* [out] */ __RPC__out UINT *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfo )( 
            ICertPolicy2 * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ __RPC__deref_out_opt ITypeInfo **ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetIDsOfNames )( 
            ICertPolicy2 * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [size_is][in] */ __RPC__in_ecount_full(cNames) LPOLESTR *rgszNames,
            /* [range][in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ __RPC__out_ecount_full(cNames) DISPID *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE *Invoke )( 
            ICertPolicy2 * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS *pDispParams,
            /* [out] */ VARIANT *pVarResult,
            /* [out] */ EXCEPINFO *pExcepInfo,
            /* [out] */ UINT *puArgErr);
        
        HRESULT ( STDMETHODCALLTYPE *Initialize )( 
            ICertPolicy2 * This,
            /* [in] */ __RPC__in const BSTR strConfig);
        
        HRESULT ( STDMETHODCALLTYPE *VerifyRequest )( 
            ICertPolicy2 * This,
            /* [in] */ __RPC__in const BSTR strConfig,
            /* [in] */ LONG Context,
            /* [in] */ LONG bNewRequest,
            /* [in] */ LONG Flags,
            /* [retval][out] */ __RPC__out LONG *pDisposition);
        
        HRESULT ( STDMETHODCALLTYPE *GetDescription )( 
            ICertPolicy2 * This,
            /* [retval][out] */ __RPC__deref_out_opt BSTR *pstrDescription);
        
        HRESULT ( STDMETHODCALLTYPE *ShutDown )( 
            ICertPolicy2 * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetManageModule )( 
            ICertPolicy2 * This,
            /* [retval][out] */ __RPC__deref_out_opt ICertManageModule **ppManageModule);
        
        END_INTERFACE
    } ICertPolicy2Vtbl;

    interface ICertPolicy2
    {
        CONST_VTBL struct ICertPolicy2Vtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define ICertPolicy2_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define ICertPolicy2_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define ICertPolicy2_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define ICertPolicy2_GetTypeInfoCount(This,pctinfo)	\
    ( (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo) ) 

#define ICertPolicy2_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    ( (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo) ) 

#define ICertPolicy2_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    ( (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId) ) 

#define ICertPolicy2_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    ( (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr) ) 


#define ICertPolicy2_Initialize(This,strConfig)	\
    ( (This)->lpVtbl -> Initialize(This,strConfig) ) 

#define ICertPolicy2_VerifyRequest(This,strConfig,Context,bNewRequest,Flags,pDisposition)	\
    ( (This)->lpVtbl -> VerifyRequest(This,strConfig,Context,bNewRequest,Flags,pDisposition) ) 

#define ICertPolicy2_GetDescription(This,pstrDescription)	\
    ( (This)->lpVtbl -> GetDescription(This,pstrDescription) ) 

#define ICertPolicy2_ShutDown(This)	\
    ( (This)->lpVtbl -> ShutDown(This) ) 


#define ICertPolicy2_GetManageModule(This,ppManageModule)	\
    ( (This)->lpVtbl -> GetManageModule(This,ppManageModule) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __ICertPolicy2_INTERFACE_DEFINED__ */


/* Additional Prototypes for ALL interfaces */

unsigned long             __RPC_USER  BSTR_UserSize(     unsigned long *, unsigned long            , BSTR * ); 
unsigned char * __RPC_USER  BSTR_UserMarshal(  unsigned long *, unsigned char *, BSTR * ); 
unsigned char * __RPC_USER  BSTR_UserUnmarshal(unsigned long *, unsigned char *, BSTR * ); 
void                      __RPC_USER  BSTR_UserFree(     unsigned long *, BSTR * ); 

unsigned long             __RPC_USER  BSTR_UserSize64(     unsigned long *, unsigned long            , BSTR * ); 
unsigned char * __RPC_USER  BSTR_UserMarshal64(  unsigned long *, unsigned char *, BSTR * ); 
unsigned char * __RPC_USER  BSTR_UserUnmarshal64(unsigned long *, unsigned char *, BSTR * ); 
void                      __RPC_USER  BSTR_UserFree64(     unsigned long *, BSTR * ); 

/* end of Additional Prototypes */

#ifdef __cplusplus
}
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\vs9sp1\sdk\include\certreqd.h ===
/* this ALWAYS GENERATED file contains the definitions for the interfaces */


 /* File created by MIDL compiler version 7.00.0499 */
/* Compiler settings for certreqd.idl:
    Oicf, W1, Zp8, env=Win32 (32b run)
    protocol : dce , ms_ext, c_ext, robust
    error checks: allocation ref bounds_check enum stub_data 
    VC __declspec() decoration level: 
         __declspec(uuid()), __declspec(selectany), __declspec(novtable)
         DECLSPEC_UUID(), MIDL_INTERFACE()
*/
//@@MIDL_FILE_HEADING(  )

#pragma warning( disable: 4049 )  /* more than 64k source lines */


/* verify that the <rpcndr.h> version is high enough to compile this file*/
#ifndef __REQUIRED_RPCNDR_H_VERSION__
#define __REQUIRED_RPCNDR_H_VERSION__ 500
#endif

/* verify that the <rpcsal.h> version is high enough to compile this file*/
#ifndef __REQUIRED_RPCSAL_H_VERSION__
#define __REQUIRED_RPCSAL_H_VERSION__ 100
#endif

#include "rpc.h"
#include "rpcndr.h"

#ifndef __RPCNDR_H_VERSION__
#error this stub requires an updated version of <rpcndr.h>
#endif // __RPCNDR_H_VERSION__

#ifndef COM_NO_WINDOWS_H
#include "windows.h"
#include "ole2.h"
#endif /*COM_NO_WINDOWS_H*/

#ifndef __certreqd_h__
#define __certreqd_h__

#if defined(_MSC_VER) && (_MSC_VER >= 1020)
#pragma once
#endif

/* Forward Declarations */ 

#ifndef __ICertRequestD_FWD_DEFINED__
#define __ICertRequestD_FWD_DEFINED__
typedef interface ICertRequestD ICertRequestD;
#endif 	/* __ICertRequestD_FWD_DEFINED__ */


#ifndef __ICertRequestD2_FWD_DEFINED__
#define __ICertRequestD2_FWD_DEFINED__
typedef interface ICertRequestD2 ICertRequestD2;
#endif 	/* __ICertRequestD2_FWD_DEFINED__ */


/* header files for imported files */
#include "certbase.h"
#include "oaidl.h"

#ifdef __cplusplus
extern "C"{
#endif 


#ifndef __ICertRequestD_INTERFACE_DEFINED__
#define __ICertRequestD_INTERFACE_DEFINED__

/* interface ICertRequestD */
/* [unique][helpstring][uuid][object] */ 


EXTERN_C const IID IID_ICertRequestD;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("d99e6e70-fc88-11d0-b498-00a0c90312f3")
    ICertRequestD : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE Request( 
            /* [in] */ DWORD dwFlags,
            /* [unique][string][in] */ __RPC__in_opt const wchar_t *pwszAuthority,
            /* [ref][out][in] */ __RPC__inout DWORD *pdwRequestId,
            /* [out] */ __RPC__out DWORD *pdwDisposition,
            /* [unique][string][in] */ __RPC__in_opt const wchar_t *pwszAttributes,
            /* [ref][in] */ __RPC__in const CERTTRANSBLOB *pctbRequest,
            /* [ref][out] */ __RPC__out CERTTRANSBLOB *pctbCertChain,
            /* [ref][out] */ __RPC__out CERTTRANSBLOB *pctbEncodedCert,
            /* [ref][out] */ __RPC__out CERTTRANSBLOB *pctbDispositionMessage) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetCACert( 
            /* [in] */ DWORD fchain,
            /* [unique][string][in] */ __RPC__in_opt const wchar_t *pwszAuthority,
            /* [ref][out] */ __RPC__out CERTTRANSBLOB *pctbOut) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Ping( 
            /* [unique][string][in] */ __RPC__in_opt const wchar_t *pwszAuthority) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct ICertRequestDVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            ICertRequestD * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            ICertRequestD * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            ICertRequestD * This);
        
        HRESULT ( STDMETHODCALLTYPE *Request )( 
            ICertRequestD * This,
            /* [in] */ DWORD dwFlags,
            /* [unique][string][in] */ __RPC__in_opt const wchar_t *pwszAuthority,
            /* [ref][out][in] */ __RPC__inout DWORD *pdwRequestId,
            /* [out] */ __RPC__out DWORD *pdwDisposition,
            /* [unique][string][in] */ __RPC__in_opt const wchar_t *pwszAttributes,
            /* [ref][in] */ __RPC__in const CERTTRANSBLOB *pctbRequest,
            /* [ref][out] */ __RPC__out CERTTRANSBLOB *pctbCertChain,
            /* [ref][out] */ __RPC__out CERTTRANSBLOB *pctbEncodedCert,
            /* [ref][out] */ __RPC__out CERTTRANSBLOB *pctbDispositionMessage);
        
        HRESULT ( STDMETHODCALLTYPE *GetCACert )( 
            ICertRequestD * This,
            /* [in] */ DWORD fchain,
            /* [unique][string][in] */ __RPC__in_opt const wchar_t *pwszAuthority,
            /* [ref][out] */ __RPC__out CERTTRANSBLOB *pctbOut);
        
        HRESULT ( STDMETHODCALLTYPE *Ping )( 
            ICertRequestD * This,
            /* [unique][string][in] */ __RPC__in_opt const wchar_t *pwszAuthority);
        
        END_INTERFACE
    } ICertRequestDVtbl;

    interface ICertRequestD
    {
        CONST_VTBL struct ICertRequestDVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define ICertRequestD_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define ICertRequestD_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define ICertRequestD_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define ICertRequestD_Request(This,dwFlags,pwszAuthority,pdwRequestId,pdwDisposition,pwszAttributes,pctbRequest,pctbCertChain,pctbEncodedCert,pctbDispositionMessage)	\
    ( (This)->lpVtbl -> Request(This,dwFlags,pwszAuthority,pdwRequestId,pdwDisposition,pwszAttributes,pctbRequest,pctbCertChain,pctbEncodedCert,pctbDispositionMessage) ) 

#define ICertRequestD_GetCACert(This,fchain,pwszAuthority,pctbOut)	\
    ( (This)->lpVtbl -> GetCACert(This,fchain,pwszAuthority,pctbOut) ) 

#define ICertRequestD_Ping(This,pwszAuthority)	\
    ( (This)->lpVtbl -> Ping(This,pwszAuthority) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __ICertRequestD_INTERFACE_DEFINED__ */


#ifndef __ICertRequestD2_INTERFACE_DEFINED__
#define __ICertRequestD2_INTERFACE_DEFINED__

/* interface ICertRequestD2 */
/* [unique][helpstring][uuid][object] */ 


EXTERN_C const IID IID_ICertRequestD2;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("5422fd3a-d4b8-4cef-a12e-e87d4ca22e90")
    ICertRequestD2 : public ICertRequestD
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE Request2( 
            /* [unique][string][in] */ __RPC__in_opt const wchar_t *pwszAuthority,
            /* [in] */ DWORD dwFlags,
            /* [unique][string][in] */ __RPC__in_opt const wchar_t *pwszSerialNumber,
            /* [ref][out][in] */ __RPC__inout DWORD *pdwRequestId,
            /* [out] */ __RPC__out DWORD *pdwDisposition,
            /* [unique][string][in] */ __RPC__in_opt const wchar_t *pwszAttributes,
            /* [ref][in] */ __RPC__in const CERTTRANSBLOB *pctbRequest,
            /* [ref][out] */ __RPC__out CERTTRANSBLOB *pctbFullResponse,
            /* [ref][out] */ __RPC__out CERTTRANSBLOB *pctbEncodedCert,
            /* [ref][out] */ __RPC__out CERTTRANSBLOB *pctbDispositionMessage) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetCAProperty( 
            /* [unique][string][in] */ __RPC__in_opt const wchar_t *pwszAuthority,
            /* [in] */ LONG PropId,
            /* [in] */ LONG PropIndex,
            /* [in] */ LONG PropType,
            /* [ref][out] */ __RPC__out CERTTRANSBLOB *pctbPropertyValue) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetCAPropertyInfo( 
            /* [unique][string][in] */ __RPC__in_opt const wchar_t *pwszAuthority,
            /* [out] */ __RPC__out LONG *pcProperty,
            /* [ref][out] */ __RPC__out CERTTRANSBLOB *pctbPropInfo) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Ping2( 
            /* [unique][string][in] */ __RPC__in_opt const wchar_t *pwszAuthority) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct ICertRequestD2Vtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            ICertRequestD2 * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            ICertRequestD2 * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            ICertRequestD2 * This);
        
        HRESULT ( STDMETHODCALLTYPE *Request )( 
            ICertRequestD2 * This,
            /* [in] */ DWORD dwFlags,
            /* [unique][string][in] */ __RPC__in_opt const wchar_t *pwszAuthority,
            /* [ref][out][in] */ __RPC__inout DWORD *pdwRequestId,
            /* [out] */ __RPC__out DWORD *pdwDisposition,
            /* [unique][string][in] */ __RPC__in_opt const wchar_t *pwszAttributes,
            /* [ref][in] */ __RPC__in const CERTTRANSBLOB *pctbRequest,
            /* [ref][out] */ __RPC__out CERTTRANSBLOB *pctbCertChain,
            /* [ref][out] */ __RPC__out CERTTRANSBLOB *pctbEncodedCert,
            /* [ref][out] */ __RPC__out CERTTRANSBLOB *pctbDispositionMessage);
        
        HRESULT ( STDMETHODCALLTYPE *GetCACert )( 
            ICertRequestD2 * This,
            /* [in] */ DWORD fchain,
            /* [unique][string][in] */ __RPC__in_opt const wchar_t *pwszAuthority,
            /* [ref][out] */ __RPC__out CERTTRANSBLOB *pctbOut);
        
        HRESULT ( STDMETHODCALLTYPE *Ping )( 
            ICertRequestD2 * This,
            /* [unique][string][in] */ __RPC__in_opt const wchar_t *pwszAuthority);
        
        HRESULT ( STDMETHODCALLTYPE *Request2 )( 
            ICertRequestD2 * This,
            /* [unique][string][in] */ __RPC__in_opt const wchar_t *pwszAuthority,
            /* [in] */ DWORD dwFlags,
            /* [unique][string][in] */ __RPC__in_opt const wchar_t *pwszSerialNumber,
            /* [ref][out][in] */ __RPC__inout DWORD *pdwRequestId,
            /* [out] */ __RPC__out DWORD *pdwDisposition,
            /* [unique][string][in] */ __RPC__in_opt const wchar_t *pwszAttributes,
            /* [ref][in] */ __RPC__in const CERTTRANSBLOB *pctbRequest,
            /* [ref][out] */ __RPC__out CERTTRANSBLOB *pctbFullResponse,
            /* [ref][out] */ __RPC__out CERTTRANSBLOB *pctbEncodedCert,
            /* [ref][out] */ __RPC__out CERTTRANSBLOB *pctbDispositionMessage);
        
        HRESULT ( STDMETHODCALLTYPE *GetCAProperty )( 
            ICertRequestD2 * This,
            /* [unique][string][in] */ __RPC__in_opt const wchar_t *pwszAuthority,
            /* [in] */ LONG PropId,
            /* [in] */ LONG PropIndex,
            /* [in] */ LONG PropType,
            /* [ref][out] */ __RPC__out CERTTRANSBLOB *pctbPropertyValue);
        
        HRESULT ( STDMETHODCALLTYPE *GetCAPropertyInfo )( 
            ICertRequestD2 * This,
            /* [unique][string][in] */ __RPC__in_opt const wchar_t *pwszAuthority,
            /* [out] */ __RPC__out LONG *pcProperty,
            /* [ref][out] */ __RPC__out CERTTRANSBLOB *pctbPropInfo);
        
        HRESULT ( STDMETHODCALLTYPE *Ping2 )( 
            ICertRequestD2 * This,
            /* [unique][string][in] */ __RPC__in_opt const wchar_t *pwszAuthority);
        
        END_INTERFACE
    } ICertRequestD2Vtbl;

    interface ICertRequestD2
    {
        CONST_VTBL struct ICertRequestD2Vtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define ICertRequestD2_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define ICertRequestD2_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define ICertRequestD2_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define ICertRequestD2_Request(This,dwFlags,pwszAuthority,pdwRequestId,pdwDisposition,pwszAttributes,pctbRequest,pctbCertChain,pctbEncodedCert,pctbDispositionMessage)	\
    ( (This)->lpVtbl -> Request(This,dwFlags,pwszAuthority,pdwRequestId,pdwDisposition,pwszAttributes,pctbRequest,pctbCertChain,pctbEncodedCert,pctbDispositionMessage) ) 

#define ICertRequestD2_GetCACert(This,fchain,pwszAuthority,pctbOut)	\
    ( (This)->lpVtbl -> GetCACert(This,fchain,pwszAuthority,pctbOut) ) 

#define ICertRequestD2_Ping(This,pwszAuthority)	\
    ( (This)->lpVtbl -> Ping(This,pwszAuthority) ) 


#define ICertRequestD2_Request2(This,pwszAuthority,dwFlags,pwszSerialNumber,pdwRequestId,pdwDisposition,pwszAttributes,pctbRequest,pctbFullResponse,pctbEncodedCert,pctbDispositionMessage)	\
    ( (This)->lpVtbl -> Request2(This,pwszAuthority,dwFlags,pwszSerialNumber,pdwRequestId,pdwDisposition,pwszAttributes,pctbRequest,pctbFullResponse,pctbEncodedCert,pctbDispositionMessage) ) 

#define ICertRequestD2_GetCAProperty(This,pwszAuthority,PropId,PropIndex,PropType,pctbPropertyValue)	\
    ( (This)->lpVtbl -> GetCAProperty(This,pwszAuthority,PropId,PropIndex,PropType,pctbPropertyValue) ) 

#define ICertRequestD2_GetCAPropertyInfo(This,pwszAuthority,pcProperty,pctbPropInfo)	\
    ( (This)->lpVtbl -> GetCAPropertyInfo(This,pwszAuthority,pcProperty,pctbPropInfo) ) 

#define ICertRequestD2_Ping2(This,pwszAuthority)	\
    ( (This)->lpVtbl -> Ping2(This,pwszAuthority) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __ICertRequestD2_INTERFACE_DEFINED__ */


/* Additional Prototypes for ALL interfaces */

/* end of Additional Prototypes */

#ifdef __cplusplus
}
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\vs9sp1\sdk\include\cfg.h ===
/*++

Copyright (c) Microsoft Corporation.  All rights reserved.

Module Name:

    cfg.h

Abstract:

    This module contains the common Configuration Manager definitions for
    both user mode and kernel mode code.

Revision History:

--*/

#ifndef _CFG_INCLUDED_
#define _CFG_INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif

//
// The following definitions are also used by kernel mode code to
// set up the registry.
//
//
// VetoType used in
//      CM_Disable_DevNode
//      CM_Uninstall_DevNode
//      CM_Query_And_Remove_SubTree
//
typedef enum    _PNP_VETO_TYPE {
    PNP_VetoTypeUnknown,            // Name is unspecified
    PNP_VetoLegacyDevice,           // Name is an Instance Path
    PNP_VetoPendingClose,           // Name is an Instance Path
    PNP_VetoWindowsApp,             // Name is a Module
    PNP_VetoWindowsService,         // Name is a Service
    PNP_VetoOutstandingOpen,        // Name is an Instance Path
    PNP_VetoDevice,                 // Name is an Instance Path
    PNP_VetoDriver,                 // Name is a Driver Service Name
    PNP_VetoIllegalDeviceRequest,   // Name is an Instance Path
    PNP_VetoInsufficientPower,      // Name is unspecified
    PNP_VetoNonDisableable,         // Name is an Instance Path
    PNP_VetoLegacyDriver,           // Name is a Service
    PNP_VetoInsufficientRights      // Name is unspecified
}   PNP_VETO_TYPE, *PPNP_VETO_TYPE;


//
// DevInst problem values, returned by call to CM_Get_DevInst_Status
//
#define CM_PROB_NOT_CONFIGURED             (0x00000001)   // no config for device
#define CM_PROB_DEVLOADER_FAILED           (0x00000002)   // service load failed
#define CM_PROB_OUT_OF_MEMORY              (0x00000003)   // out of memory
#define CM_PROB_ENTRY_IS_WRONG_TYPE        (0x00000004)   //
#define CM_PROB_LACKED_ARBITRATOR          (0x00000005)   //
#define CM_PROB_BOOT_CONFIG_CONFLICT       (0x00000006)   // boot config conflict
#define CM_PROB_FAILED_FILTER              (0x00000007)   //
#define CM_PROB_DEVLOADER_NOT_FOUND        (0x00000008)   // Devloader not found
#define CM_PROB_INVALID_DATA               (0x00000009)   // Invalid ID
#define CM_PROB_FAILED_START               (0x0000000A)   //
#define CM_PROB_LIAR                       (0x0000000B)   //
#define CM_PROB_NORMAL_CONFLICT            (0x0000000C)   // config conflict
#define CM_PROB_NOT_VERIFIED               (0x0000000D)   //
#define CM_PROB_NEED_RESTART               (0x0000000E)   // requires restart
#define CM_PROB_REENUMERATION              (0x0000000F)   //
#define CM_PROB_PARTIAL_LOG_CONF           (0x00000010)   //
#define CM_PROB_UNKNOWN_RESOURCE           (0x00000011)   // unknown res type
#define CM_PROB_REINSTALL                  (0x00000012)   //
#define CM_PROB_REGISTRY                   (0x00000013)   //
#define CM_PROB_VXDLDR                     (0x00000014)   // WINDOWS 95 ONLY
#define CM_PROB_WILL_BE_REMOVED            (0x00000015)   // devinst will remove
#define CM_PROB_DISABLED                   (0x00000016)   // devinst is disabled
#define CM_PROB_DEVLOADER_NOT_READY        (0x00000017)   // Devloader not ready
#define CM_PROB_DEVICE_NOT_THERE           (0x00000018)   // device doesn't exist
#define CM_PROB_MOVED                      (0x00000019)   //
#define CM_PROB_TOO_EARLY                  (0x0000001A)   //
#define CM_PROB_NO_VALID_LOG_CONF          (0x0000001B)   // no valid log config
#define CM_PROB_FAILED_INSTALL             (0x0000001C)   // install failed
#define CM_PROB_HARDWARE_DISABLED          (0x0000001D)   // device disabled
#define CM_PROB_CANT_SHARE_IRQ             (0x0000001E)   // can't share IRQ
#define CM_PROB_FAILED_ADD                 (0x0000001F)   // driver failed add
#define CM_PROB_DISABLED_SERVICE           (0x00000020)   // service's Start = 4
#define CM_PROB_TRANSLATION_FAILED         (0x00000021)   // resource translation failed
#define CM_PROB_NO_SOFTCONFIG              (0x00000022)   // no soft config
#define CM_PROB_BIOS_TABLE                 (0x00000023)   // device missing in BIOS table
#define CM_PROB_IRQ_TRANSLATION_FAILED     (0x00000024)   // IRQ translator failed

#if (NTDDI_VERSION >= NTDDI_WINXP)

#define CM_PROB_FAILED_DRIVER_ENTRY        (0x00000025)   // DriverEntry() failed.
#define CM_PROB_DRIVER_FAILED_PRIOR_UNLOAD (0x00000026)   // Driver should have unloaded.
#define CM_PROB_DRIVER_FAILED_LOAD         (0x00000027)   // Driver load unsuccessful.
#define CM_PROB_DRIVER_SERVICE_KEY_INVALID (0x00000028)   // Error accessing driver's service key
#define CM_PROB_LEGACY_SERVICE_NO_DEVICES  (0x00000029)   // Loaded legacy service created no devices
#define CM_PROB_DUPLICATE_DEVICE           (0x0000002A)   // Two devices were discovered with the same name
#define CM_PROB_FAILED_POST_START          (0x0000002B)   // The drivers set the device state to failed
#define CM_PROB_HALTED                     (0x0000002C)   // This device was failed post start via usermode
#define CM_PROB_PHANTOM                    (0x0000002D)   // The devinst currently exists only in the registry
#define CM_PROB_SYSTEM_SHUTDOWN            (0x0000002E)   // The system is shutting down
#define CM_PROB_HELD_FOR_EJECT             (0x0000002F)   // The device is offline awaiting removal
#define CM_PROB_DRIVER_BLOCKED             (0x00000030)   // One or more drivers is blocked from loading
#define CM_PROB_REGISTRY_TOO_LARGE         (0x00000031)   // System hive has grown too large
#define CM_PROB_SETPROPERTIES_FAILED       (0x00000032)   // Failed to apply one or more registry properties  
#define NUM_CM_PROB                        (0x00000033)

#elif (NTDDI_VERSION >= NTDDI_WIN2K)

#define NUM_CM_PROB                        (0x00000025)

#endif

//
// Configuration Manager Global State Flags (returned by CM_Get_Global_State)
//
#define CM_GLOBAL_STATE_CAN_DO_UI            (0x00000001) // Can  do UI?
#define CM_GLOBAL_STATE_ON_BIG_STACK         (0x00000002) // WINDOWS 95 ONLY
#define CM_GLOBAL_STATE_SERVICES_AVAILABLE   (0x00000004) // CM APIs available?
#define CM_GLOBAL_STATE_SHUTTING_DOWN        (0x00000008) // CM shutting down
#define CM_GLOBAL_STATE_DETECTION_PENDING    (0x00000010) // detection pending

//
// Device Instance status flags, returned by call to CM_Get_DevInst_Status
//
#define DN_ROOT_ENUMERATED (0x00000001) // Was enumerated by ROOT
#define DN_DRIVER_LOADED   (0x00000002) // Has Register_Device_Driver
#define DN_ENUM_LOADED     (0x00000004) // Has Register_Enumerator
#define DN_STARTED         (0x00000008) // Is currently configured
#define DN_MANUAL          (0x00000010) // Manually installed
#define DN_NEED_TO_ENUM    (0x00000020) // May need reenumeration
#define DN_NOT_FIRST_TIME  (0x00000040) // Has received a config
#define DN_HARDWARE_ENUM   (0x00000080) // Enum generates hardware ID
#define DN_LIAR            (0x00000100) // Lied about can reconfig once
#define DN_HAS_MARK        (0x00000200) // Not CM_Create_DevInst lately
#define DN_HAS_PROBLEM     (0x00000400) // Need device installer
#define DN_FILTERED        (0x00000800) // Is filtered
#define DN_MOVED           (0x00001000) // Has been moved
#define DN_DISABLEABLE     (0x00002000) // Can be disabled
#define DN_REMOVABLE       (0x00004000) // Can be removed
#define DN_PRIVATE_PROBLEM (0x00008000) // Has a private problem
#define DN_MF_PARENT       (0x00010000) // Multi function parent
#define DN_MF_CHILD        (0x00020000) // Multi function child
#define DN_WILL_BE_REMOVED (0x00040000) // DevInst is being removed

//
// Windows 4 OPK2 Flags
//
#define DN_NOT_FIRST_TIMEE  0x00080000  // S: Has received a config enumerate
#define DN_STOP_FREE_RES    0x00100000  // S: When child is stopped, free resources
#define DN_REBAL_CANDIDATE  0x00200000  // S: Don't skip during rebalance
#define DN_BAD_PARTIAL      0x00400000  // S: This devnode's log_confs do not have same resources
#define DN_NT_ENUMERATOR    0x00800000  // S: This devnode's is an NT enumerator
#define DN_NT_DRIVER        0x01000000  // S: This devnode's is an NT driver
//
// Windows 4.1 Flags
//
#define DN_NEEDS_LOCKING    0x02000000  // S: Devnode need lock resume processing
#define DN_ARM_WAKEUP       0x04000000  // S: Devnode can be the wakeup device
#define DN_APM_ENUMERATOR   0x08000000  // S: APM aware enumerator
#define DN_APM_DRIVER       0x10000000  // S: APM aware driver
#define DN_SILENT_INSTALL   0x20000000  // S: Silent install
#define DN_NO_SHOW_IN_DM    0x40000000  // S: No show in device manager
#define DN_BOOT_LOG_PROB    0x80000000  // S: Had a problem during preassignment of boot log conf

//
// Windows NT Flags
//
// These are overloaded on top of unused Win 9X flags
//
//#define DN_LIAR                       (0x00000100)            // Lied about can reconfig once

#if (NTDDI_VERSION >= NTDDI_WINXP)

#define DN_NEED_RESTART                 DN_LIAR                 // System needs to be restarted for this Devnode to work properly
// #define DN_NOT_FIRST_TIME            (0x00000040)            // Has Register_Enumerator
#define DN_DRIVER_BLOCKED               DN_NOT_FIRST_TIME       // One or more drivers are blocked from loading for this Devnode
//#define DN_MOVED                      (0x00001000)            // Has been moved
#define DN_LEGACY_DRIVER                DN_MOVED                // This device is using a legacy driver
//#define DN_HAS_MARK                   (0x00000200)            // Not CM_Create_DevInst lately
#define DN_CHILD_WITH_INVALID_ID        DN_HAS_MARK             // One or more children have invalid ID(s)

#elif (NTDDI_VERSION >= NTDDI_WIN2K)

#define DN_NEED_RESTART                 0x00000100              // System needs to be restarted for this Devnode to work properly

#endif

#define DN_CHANGEABLE_FLAGS (DN_NOT_FIRST_TIME+\
                DN_HARDWARE_ENUM+\
                DN_HAS_MARK+\
                DN_DISABLEABLE+\
                DN_REMOVABLE+\
                DN_MF_CHILD+\
                DN_MF_PARENT+\
                DN_NOT_FIRST_TIMEE+\
                DN_STOP_FREE_RES+\
                DN_REBAL_CANDIDATE+\
                DN_NT_ENUMERATOR+\
                DN_NT_DRIVER+\
                DN_SILENT_INSTALL+\
                DN_NO_SHOW_IN_DM)

//
// Logical configuration Priority values
//
// These priority values are used in user-mode calls to CM_Add_Empty_Log_Conf.
// Drivers may also specify priority values for a given IO_RESOURCE_LIST
// structure by including a ConfigData member union as the first
// IO_RESOURCE_DESCRIPTOR in the IO_RESOURCE_LIST. In this case, the descriptor
// type would be CmResourceTypeConfigData.
//
#define LCPRI_FORCECONFIG     (0x00000000) // Coming from a forced config
#define LCPRI_BOOTCONFIG      (0x00000001) // Coming from a boot config
#define LCPRI_DESIRED         (0x00002000) // Preferable (better performance)
#define LCPRI_NORMAL          (0x00003000) // Workable (acceptable performance)
#define LCPRI_LASTBESTCONFIG  (0x00003FFF) // CM only--do not use
#define LCPRI_SUBOPTIMAL      (0x00005000) // Not desired, but will work
#define LCPRI_LASTSOFTCONFIG  (0x00007FFF) // CM only--do not use
#define LCPRI_RESTART         (0x00008000) // Need to restart
#define LCPRI_REBOOT          (0x00009000) // Need to reboot
#define LCPRI_POWEROFF        (0x0000A000) // Need to shutdown/power-off
#define LCPRI_HARDRECONFIG    (0x0000C000) // Need to change a jumper
#define LCPRI_HARDWIRED       (0x0000E000) // Cannot be changed
#define LCPRI_IMPOSSIBLE      (0x0000F000) // Impossible configuration
#define LCPRI_DISABLED        (0x0000FFFF) // Disabled configuration
#define MAX_LCPRI             (0x0000FFFF) // Maximum known LC Priority

#endif // _CFG_INCLUDED_
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\vs9sp1\sdk\include\CertView.h ===
/* this ALWAYS GENERATED file contains the definitions for the interfaces */


 /* File created by MIDL compiler version 7.00.0499 */
/* Compiler settings for certview.idl:
    Oicf, W1, Zp8, env=Win32 (32b run)
    protocol : dce , ms_ext, c_ext, robust
    error checks: allocation ref bounds_check enum stub_data 
    VC __declspec() decoration level: 
         __declspec(uuid()), __declspec(selectany), __declspec(novtable)
         DECLSPEC_UUID(), MIDL_INTERFACE()
*/
//@@MIDL_FILE_HEADING(  )

#pragma warning( disable: 4049 )  /* more than 64k source lines */


/* verify that the <rpcndr.h> version is high enough to compile this file*/
#ifndef __REQUIRED_RPCNDR_H_VERSION__
#define __REQUIRED_RPCNDR_H_VERSION__ 500
#endif

/* verify that the <rpcsal.h> version is high enough to compile this file*/
#ifndef __REQUIRED_RPCSAL_H_VERSION__
#define __REQUIRED_RPCSAL_H_VERSION__ 100
#endif

#include "rpc.h"
#include "rpcndr.h"

#ifndef __RPCNDR_H_VERSION__
#error this stub requires an updated version of <rpcndr.h>
#endif // __RPCNDR_H_VERSION__

#ifndef COM_NO_WINDOWS_H
#include "windows.h"
#include "ole2.h"
#endif /*COM_NO_WINDOWS_H*/

#ifndef __certview_h__
#define __certview_h__

#if defined(_MSC_VER) && (_MSC_VER >= 1020)
#pragma once
#endif

/* Forward Declarations */ 

#ifndef __IEnumCERTVIEWCOLUMN_FWD_DEFINED__
#define __IEnumCERTVIEWCOLUMN_FWD_DEFINED__
typedef interface IEnumCERTVIEWCOLUMN IEnumCERTVIEWCOLUMN;
#endif 	/* __IEnumCERTVIEWCOLUMN_FWD_DEFINED__ */


#ifndef __IEnumCERTVIEWATTRIBUTE_FWD_DEFINED__
#define __IEnumCERTVIEWATTRIBUTE_FWD_DEFINED__
typedef interface IEnumCERTVIEWATTRIBUTE IEnumCERTVIEWATTRIBUTE;
#endif 	/* __IEnumCERTVIEWATTRIBUTE_FWD_DEFINED__ */


#ifndef __IEnumCERTVIEWEXTENSION_FWD_DEFINED__
#define __IEnumCERTVIEWEXTENSION_FWD_DEFINED__
typedef interface IEnumCERTVIEWEXTENSION IEnumCERTVIEWEXTENSION;
#endif 	/* __IEnumCERTVIEWEXTENSION_FWD_DEFINED__ */


#ifndef __IEnumCERTVIEWROW_FWD_DEFINED__
#define __IEnumCERTVIEWROW_FWD_DEFINED__
typedef interface IEnumCERTVIEWROW IEnumCERTVIEWROW;
#endif 	/* __IEnumCERTVIEWROW_FWD_DEFINED__ */


#ifndef __ICertView_FWD_DEFINED__
#define __ICertView_FWD_DEFINED__
typedef interface ICertView ICertView;
#endif 	/* __ICertView_FWD_DEFINED__ */


#ifndef __ICertView2_FWD_DEFINED__
#define __ICertView2_FWD_DEFINED__
typedef interface ICertView2 ICertView2;
#endif 	/* __ICertView2_FWD_DEFINED__ */


/* header files for imported files */
#include "wtypes.h"
#include "oaidl.h"

#ifdef __cplusplus
extern "C"{
#endif 


/* interface __MIDL_itf_certview_0000_0000 */
/* [local] */ 

#define	CV_OUT_BASE64HEADER	( 0 )

#define	CV_OUT_BASE64	( 0x1 )

#define	CV_OUT_BINARY	( 0x2 )

#define	CV_OUT_BASE64REQUESTHEADER	( 0x3 )

#define	CV_OUT_HEX	( 0x4 )

#define	CV_OUT_HEXASCII	( 0x5 )

#define	CV_OUT_BASE64X509CRLHEADER	( 0x9 )

#define	CV_OUT_HEXADDR	( 0xa )

#define	CV_OUT_HEXASCIIADDR	( 0xb )

#define	CV_OUT_HEXRAW	( 0xc )

#define	CV_OUT_ENCODEMASK	( 0xff )

#define	CV_OUT_NOCRLF	( 0x40000000 )

#define	CV_OUT_NOCR	( 0x80000000 )

#define	CVR_SEEK_NONE	( 0 )

#define	CVR_SEEK_EQ	( 0x1 )

#define	CVR_SEEK_LT	( 0x2 )

#define	CVR_SEEK_LE	( 0x4 )

#define	CVR_SEEK_GE	( 0x8 )

#define	CVR_SEEK_GT	( 0x10 )

#define	CVR_SEEK_MASK	( 0xff )

#define	CVR_SEEK_NODELTA	( 0x1000 )

#define	CVR_SORT_NONE	( 0 )

#define	CVR_SORT_ASCEND	( 0x1 )

#define	CVR_SORT_DESCEND	( 0x2 )

#define	CV_COLUMN_QUEUE_DEFAULT	( -1 )

#define	CV_COLUMN_LOG_DEFAULT	( -2 )

#define	CV_COLUMN_LOG_FAILED_DEFAULT	( -3 )

#define	CV_COLUMN_EXTENSION_DEFAULT	( -4 )

#define	CV_COLUMN_ATTRIBUTE_DEFAULT	( -5 )

#define	CV_COLUMN_CRL_DEFAULT	( -6 )

#define	CV_COLUMN_LOG_REVOKED_DEFAULT	( -7 )

#define	CVRC_COLUMN_SCHEMA	( 0 )

#define	CVRC_COLUMN_RESULT	( 0x1 )

#define	CVRC_COLUMN_VALUE	( 0x2 )

#define	CVRC_COLUMN_MASK	( 0xfff )

#define	CVRC_TABLE_REQCERT	( 0 )

#define	CVRC_TABLE_EXTENSIONS	( 0x3000 )

#define	CVRC_TABLE_ATTRIBUTES	( 0x4000 )

#define	CVRC_TABLE_CRL	( 0x5000 )

#define	CVRC_TABLE_MASK	( 0xf000 )

#define	CVRC_TABLE_SHIFT	( 12 )



extern RPC_IF_HANDLE __MIDL_itf_certview_0000_0000_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_certview_0000_0000_v0_0_s_ifspec;

#ifndef __IEnumCERTVIEWCOLUMN_INTERFACE_DEFINED__
#define __IEnumCERTVIEWCOLUMN_INTERFACE_DEFINED__

/* interface IEnumCERTVIEWCOLUMN */
/* [unique][helpstring][local][dual][uuid][object] */ 


EXTERN_C const IID IID_IEnumCERTVIEWCOLUMN;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("9c735be2-57a5-11d1-9bdb-00c04fb683fa")
    IEnumCERTVIEWCOLUMN : public IDispatch
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE Next( 
            /* [retval][out] */ LONG *pIndex) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetName( 
            /* [retval][out] */ BSTR *pstrOut) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetDisplayName( 
            /* [retval][out] */ BSTR *pstrOut) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetType( 
            /* [retval][out] */ LONG *pType) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE IsIndexed( 
            /* [retval][out] */ LONG *pIndexed) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetMaxLength( 
            /* [retval][out] */ LONG *pMaxLength) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetValue( 
            /* [in] */ LONG Flags,
            /* [retval][out] */ VARIANT *pvarValue) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Skip( 
            /* [in] */ LONG celt) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Reset( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Clone( 
            /* [retval][out] */ IEnumCERTVIEWCOLUMN **ppenum) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IEnumCERTVIEWCOLUMNVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IEnumCERTVIEWCOLUMN * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IEnumCERTVIEWCOLUMN * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IEnumCERTVIEWCOLUMN * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfoCount )( 
            IEnumCERTVIEWCOLUMN * This,
            /* [out] */ UINT *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfo )( 
            IEnumCERTVIEWCOLUMN * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo **ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetIDsOfNames )( 
            IEnumCERTVIEWCOLUMN * This,
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR *rgszNames,
            /* [range][in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE *Invoke )( 
            IEnumCERTVIEWCOLUMN * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS *pDispParams,
            /* [out] */ VARIANT *pVarResult,
            /* [out] */ EXCEPINFO *pExcepInfo,
            /* [out] */ UINT *puArgErr);
        
        HRESULT ( STDMETHODCALLTYPE *Next )( 
            IEnumCERTVIEWCOLUMN * This,
            /* [retval][out] */ LONG *pIndex);
        
        HRESULT ( STDMETHODCALLTYPE *GetName )( 
            IEnumCERTVIEWCOLUMN * This,
            /* [retval][out] */ BSTR *pstrOut);
        
        HRESULT ( STDMETHODCALLTYPE *GetDisplayName )( 
            IEnumCERTVIEWCOLUMN * This,
            /* [retval][out] */ BSTR *pstrOut);
        
        HRESULT ( STDMETHODCALLTYPE *GetType )( 
            IEnumCERTVIEWCOLUMN * This,
            /* [retval][out] */ LONG *pType);
        
        HRESULT ( STDMETHODCALLTYPE *IsIndexed )( 
            IEnumCERTVIEWCOLUMN * This,
            /* [retval][out] */ LONG *pIndexed);
        
        HRESULT ( STDMETHODCALLTYPE *GetMaxLength )( 
            IEnumCERTVIEWCOLUMN * This,
            /* [retval][out] */ LONG *pMaxLength);
        
        HRESULT ( STDMETHODCALLTYPE *GetValue )( 
            IEnumCERTVIEWCOLUMN * This,
            /* [in] */ LONG Flags,
            /* [retval][out] */ VARIANT *pvarValue);
        
        HRESULT ( STDMETHODCALLTYPE *Skip )( 
            IEnumCERTVIEWCOLUMN * This,
            /* [in] */ LONG celt);
        
        HRESULT ( STDMETHODCALLTYPE *Reset )( 
            IEnumCERTVIEWCOLUMN * This);
        
        HRESULT ( STDMETHODCALLTYPE *Clone )( 
            IEnumCERTVIEWCOLUMN * This,
            /* [retval][out] */ IEnumCERTVIEWCOLUMN **ppenum);
        
        END_INTERFACE
    } IEnumCERTVIEWCOLUMNVtbl;

    interface IEnumCERTVIEWCOLUMN
    {
        CONST_VTBL struct IEnumCERTVIEWCOLUMNVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IEnumCERTVIEWCOLUMN_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IEnumCERTVIEWCOLUMN_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IEnumCERTVIEWCOLUMN_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IEnumCERTVIEWCOLUMN_GetTypeInfoCount(This,pctinfo)	\
    ( (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo) ) 

#define IEnumCERTVIEWCOLUMN_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    ( (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo) ) 

#define IEnumCERTVIEWCOLUMN_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    ( (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId) ) 

#define IEnumCERTVIEWCOLUMN_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    ( (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr) ) 


#define IEnumCERTVIEWCOLUMN_Next(This,pIndex)	\
    ( (This)->lpVtbl -> Next(This,pIndex) ) 

#define IEnumCERTVIEWCOLUMN_GetName(This,pstrOut)	\
    ( (This)->lpVtbl -> GetName(This,pstrOut) ) 

#define IEnumCERTVIEWCOLUMN_GetDisplayName(This,pstrOut)	\
    ( (This)->lpVtbl -> GetDisplayName(This,pstrOut) ) 

#define IEnumCERTVIEWCOLUMN_GetType(This,pType)	\
    ( (This)->lpVtbl -> GetType(This,pType) ) 

#define IEnumCERTVIEWCOLUMN_IsIndexed(This,pIndexed)	\
    ( (This)->lpVtbl -> IsIndexed(This,pIndexed) ) 

#define IEnumCERTVIEWCOLUMN_GetMaxLength(This,pMaxLength)	\
    ( (This)->lpVtbl -> GetMaxLength(This,pMaxLength) ) 

#define IEnumCERTVIEWCOLUMN_GetValue(This,Flags,pvarValue)	\
    ( (This)->lpVtbl -> GetValue(This,Flags,pvarValue) ) 

#define IEnumCERTVIEWCOLUMN_Skip(This,celt)	\
    ( (This)->lpVtbl -> Skip(This,celt) ) 

#define IEnumCERTVIEWCOLUMN_Reset(This)	\
    ( (This)->lpVtbl -> Reset(This) ) 

#define IEnumCERTVIEWCOLUMN_Clone(This,ppenum)	\
    ( (This)->lpVtbl -> Clone(This,ppenum) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IEnumCERTVIEWCOLUMN_INTERFACE_DEFINED__ */


#ifndef __IEnumCERTVIEWATTRIBUTE_INTERFACE_DEFINED__
#define __IEnumCERTVIEWATTRIBUTE_INTERFACE_DEFINED__

/* interface IEnumCERTVIEWATTRIBUTE */
/* [unique][helpstring][local][dual][uuid][object] */ 


EXTERN_C const IID IID_IEnumCERTVIEWATTRIBUTE;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("e77db656-7653-11d1-9bde-00c04fb683fa")
    IEnumCERTVIEWATTRIBUTE : public IDispatch
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE Next( 
            /* [retval][out] */ LONG *pIndex) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetName( 
            /* [retval][out] */ BSTR *pstrOut) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetValue( 
            /* [retval][out] */ BSTR *pstrOut) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Skip( 
            /* [in] */ LONG celt) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Reset( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Clone( 
            /* [retval][out] */ IEnumCERTVIEWATTRIBUTE **ppenum) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IEnumCERTVIEWATTRIBUTEVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IEnumCERTVIEWATTRIBUTE * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IEnumCERTVIEWATTRIBUTE * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IEnumCERTVIEWATTRIBUTE * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfoCount )( 
            IEnumCERTVIEWATTRIBUTE * This,
            /* [out] */ UINT *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfo )( 
            IEnumCERTVIEWATTRIBUTE * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo **ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetIDsOfNames )( 
            IEnumCERTVIEWATTRIBUTE * This,
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR *rgszNames,
            /* [range][in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE *Invoke )( 
            IEnumCERTVIEWATTRIBUTE * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS *pDispParams,
            /* [out] */ VARIANT *pVarResult,
            /* [out] */ EXCEPINFO *pExcepInfo,
            /* [out] */ UINT *puArgErr);
        
        HRESULT ( STDMETHODCALLTYPE *Next )( 
            IEnumCERTVIEWATTRIBUTE * This,
            /* [retval][out] */ LONG *pIndex);
        
        HRESULT ( STDMETHODCALLTYPE *GetName )( 
            IEnumCERTVIEWATTRIBUTE * This,
            /* [retval][out] */ BSTR *pstrOut);
        
        HRESULT ( STDMETHODCALLTYPE *GetValue )( 
            IEnumCERTVIEWATTRIBUTE * This,
            /* [retval][out] */ BSTR *pstrOut);
        
        HRESULT ( STDMETHODCALLTYPE *Skip )( 
            IEnumCERTVIEWATTRIBUTE * This,
            /* [in] */ LONG celt);
        
        HRESULT ( STDMETHODCALLTYPE *Reset )( 
            IEnumCERTVIEWATTRIBUTE * This);
        
        HRESULT ( STDMETHODCALLTYPE *Clone )( 
            IEnumCERTVIEWATTRIBUTE * This,
            /* [retval][out] */ IEnumCERTVIEWATTRIBUTE **ppenum);
        
        END_INTERFACE
    } IEnumCERTVIEWATTRIBUTEVtbl;

    interface IEnumCERTVIEWATTRIBUTE
    {
        CONST_VTBL struct IEnumCERTVIEWATTRIBUTEVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IEnumCERTVIEWATTRIBUTE_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IEnumCERTVIEWATTRIBUTE_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IEnumCERTVIEWATTRIBUTE_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IEnumCERTVIEWATTRIBUTE_GetTypeInfoCount(This,pctinfo)	\
    ( (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo) ) 

#define IEnumCERTVIEWATTRIBUTE_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    ( (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo) ) 

#define IEnumCERTVIEWATTRIBUTE_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    ( (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId) ) 

#define IEnumCERTVIEWATTRIBUTE_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    ( (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr) ) 


#define IEnumCERTVIEWATTRIBUTE_Next(This,pIndex)	\
    ( (This)->lpVtbl -> Next(This,pIndex) ) 

#define IEnumCERTVIEWATTRIBUTE_GetName(This,pstrOut)	\
    ( (This)->lpVtbl -> GetName(This,pstrOut) ) 

#define IEnumCERTVIEWATTRIBUTE_GetValue(This,pstrOut)	\
    ( (This)->lpVtbl -> GetValue(This,pstrOut) ) 

#define IEnumCERTVIEWATTRIBUTE_Skip(This,celt)	\
    ( (This)->lpVtbl -> Skip(This,celt) ) 

#define IEnumCERTVIEWATTRIBUTE_Reset(This)	\
    ( (This)->lpVtbl -> Reset(This) ) 

#define IEnumCERTVIEWATTRIBUTE_Clone(This,ppenum)	\
    ( (This)->lpVtbl -> Clone(This,ppenum) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IEnumCERTVIEWATTRIBUTE_INTERFACE_DEFINED__ */


#ifndef __IEnumCERTVIEWEXTENSION_INTERFACE_DEFINED__
#define __IEnumCERTVIEWEXTENSION_INTERFACE_DEFINED__

/* interface IEnumCERTVIEWEXTENSION */
/* [unique][helpstring][local][dual][uuid][object] */ 


EXTERN_C const IID IID_IEnumCERTVIEWEXTENSION;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("e7dd1466-7653-11d1-9bde-00c04fb683fa")
    IEnumCERTVIEWEXTENSION : public IDispatch
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE Next( 
            /* [retval][out] */ LONG *pIndex) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetName( 
            /* [retval][out] */ BSTR *pstrOut) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetFlags( 
            /* [retval][out] */ LONG *pFlags) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetValue( 
            /* [in] */ LONG Type,
            /* [in] */ LONG Flags,
            /* [retval][out] */ VARIANT *pvarValue) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Skip( 
            /* [in] */ LONG celt) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Reset( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Clone( 
            /* [retval][out] */ IEnumCERTVIEWEXTENSION **ppenum) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IEnumCERTVIEWEXTENSIONVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IEnumCERTVIEWEXTENSION * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IEnumCERTVIEWEXTENSION * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IEnumCERTVIEWEXTENSION * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfoCount )( 
            IEnumCERTVIEWEXTENSION * This,
            /* [out] */ UINT *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfo )( 
            IEnumCERTVIEWEXTENSION * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo **ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetIDsOfNames )( 
            IEnumCERTVIEWEXTENSION * This,
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR *rgszNames,
            /* [range][in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE *Invoke )( 
            IEnumCERTVIEWEXTENSION * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS *pDispParams,
            /* [out] */ VARIANT *pVarResult,
            /* [out] */ EXCEPINFO *pExcepInfo,
            /* [out] */ UINT *puArgErr);
        
        HRESULT ( STDMETHODCALLTYPE *Next )( 
            IEnumCERTVIEWEXTENSION * This,
            /* [retval][out] */ LONG *pIndex);
        
        HRESULT ( STDMETHODCALLTYPE *GetName )( 
            IEnumCERTVIEWEXTENSION * This,
            /* [retval][out] */ BSTR *pstrOut);
        
        HRESULT ( STDMETHODCALLTYPE *GetFlags )( 
            IEnumCERTVIEWEXTENSION * This,
            /* [retval][out] */ LONG *pFlags);
        
        HRESULT ( STDMETHODCALLTYPE *GetValue )( 
            IEnumCERTVIEWEXTENSION * This,
            /* [in] */ LONG Type,
            /* [in] */ LONG Flags,
            /* [retval][out] */ VARIANT *pvarValue);
        
        HRESULT ( STDMETHODCALLTYPE *Skip )( 
            IEnumCERTVIEWEXTENSION * This,
            /* [in] */ LONG celt);
        
        HRESULT ( STDMETHODCALLTYPE *Reset )( 
            IEnumCERTVIEWEXTENSION * This);
        
        HRESULT ( STDMETHODCALLTYPE *Clone )( 
            IEnumCERTVIEWEXTENSION * This,
            /* [retval][out] */ IEnumCERTVIEWEXTENSION **ppenum);
        
        END_INTERFACE
    } IEnumCERTVIEWEXTENSIONVtbl;

    interface IEnumCERTVIEWEXTENSION
    {
        CONST_VTBL struct IEnumCERTVIEWEXTENSIONVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IEnumCERTVIEWEXTENSION_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IEnumCERTVIEWEXTENSION_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IEnumCERTVIEWEXTENSION_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IEnumCERTVIEWEXTENSION_GetTypeInfoCount(This,pctinfo)	\
    ( (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo) ) 

#define IEnumCERTVIEWEXTENSION_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    ( (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo) ) 

#define IEnumCERTVIEWEXTENSION_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    ( (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId) ) 

#define IEnumCERTVIEWEXTENSION_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    ( (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr) ) 


#define IEnumCERTVIEWEXTENSION_Next(This,pIndex)	\
    ( (This)->lpVtbl -> Next(This,pIndex) ) 

#define IEnumCERTVIEWEXTENSION_GetName(This,pstrOut)	\
    ( (This)->lpVtbl -> GetName(This,pstrOut) ) 

#define IEnumCERTVIEWEXTENSION_GetFlags(This,pFlags)	\
    ( (This)->lpVtbl -> GetFlags(This,pFlags) ) 

#define IEnumCERTVIEWEXTENSION_GetValue(This,Type,Flags,pvarValue)	\
    ( (This)->lpVtbl -> GetValue(This,Type,Flags,pvarValue) ) 

#define IEnumCERTVIEWEXTENSION_Skip(This,celt)	\
    ( (This)->lpVtbl -> Skip(This,celt) ) 

#define IEnumCERTVIEWEXTENSION_Reset(This)	\
    ( (This)->lpVtbl -> Reset(This) ) 

#define IEnumCERTVIEWEXTENSION_Clone(This,ppenum)	\
    ( (This)->lpVtbl -> Clone(This,ppenum) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IEnumCERTVIEWEXTENSION_INTERFACE_DEFINED__ */


#ifndef __IEnumCERTVIEWROW_INTERFACE_DEFINED__
#define __IEnumCERTVIEWROW_INTERFACE_DEFINED__

/* interface IEnumCERTVIEWROW */
/* [unique][helpstring][local][dual][uuid][object] */ 


EXTERN_C const IID IID_IEnumCERTVIEWROW;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("d1157f4c-5af2-11d1-9bdc-00c04fb683fa")
    IEnumCERTVIEWROW : public IDispatch
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE Next( 
            /* [retval][out] */ LONG *pIndex) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE EnumCertViewColumn( 
            /* [retval][out] */ IEnumCERTVIEWCOLUMN **ppenum) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE EnumCertViewAttribute( 
            /* [in] */ LONG Flags,
            /* [retval][out] */ IEnumCERTVIEWATTRIBUTE **ppenum) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE EnumCertViewExtension( 
            /* [in] */ LONG Flags,
            /* [retval][out] */ IEnumCERTVIEWEXTENSION **ppenum) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Skip( 
            /* [in] */ LONG celt) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Reset( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Clone( 
            /* [retval][out] */ IEnumCERTVIEWROW **ppenum) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetMaxIndex( 
            /* [retval][out] */ LONG *pIndex) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IEnumCERTVIEWROWVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IEnumCERTVIEWROW * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IEnumCERTVIEWROW * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IEnumCERTVIEWROW * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfoCount )( 
            IEnumCERTVIEWROW * This,
            /* [out] */ UINT *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfo )( 
            IEnumCERTVIEWROW * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo **ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetIDsOfNames )( 
            IEnumCERTVIEWROW * This,
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR *rgszNames,
            /* [range][in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE *Invoke )( 
            IEnumCERTVIEWROW * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS *pDispParams,
            /* [out] */ VARIANT *pVarResult,
            /* [out] */ EXCEPINFO *pExcepInfo,
            /* [out] */ UINT *puArgErr);
        
        HRESULT ( STDMETHODCALLTYPE *Next )( 
            IEnumCERTVIEWROW * This,
            /* [retval][out] */ LONG *pIndex);
        
        HRESULT ( STDMETHODCALLTYPE *EnumCertViewColumn )( 
            IEnumCERTVIEWROW * This,
            /* [retval][out] */ IEnumCERTVIEWCOLUMN **ppenum);
        
        HRESULT ( STDMETHODCALLTYPE *EnumCertViewAttribute )( 
            IEnumCERTVIEWROW * This,
            /* [in] */ LONG Flags,
            /* [retval][out] */ IEnumCERTVIEWATTRIBUTE **ppenum);
        
        HRESULT ( STDMETHODCALLTYPE *EnumCertViewExtension )( 
            IEnumCERTVIEWROW * This,
            /* [in] */ LONG Flags,
            /* [retval][out] */ IEnumCERTVIEWEXTENSION **ppenum);
        
        HRESULT ( STDMETHODCALLTYPE *Skip )( 
            IEnumCERTVIEWROW * This,
            /* [in] */ LONG celt);
        
        HRESULT ( STDMETHODCALLTYPE *Reset )( 
            IEnumCERTVIEWROW * This);
        
        HRESULT ( STDMETHODCALLTYPE *Clone )( 
            IEnumCERTVIEWROW * This,
            /* [retval][out] */ IEnumCERTVIEWROW **ppenum);
        
        HRESULT ( STDMETHODCALLTYPE *GetMaxIndex )( 
            IEnumCERTVIEWROW * This,
            /* [retval][out] */ LONG *pIndex);
        
        END_INTERFACE
    } IEnumCERTVIEWROWVtbl;

    interface IEnumCERTVIEWROW
    {
        CONST_VTBL struct IEnumCERTVIEWROWVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IEnumCERTVIEWROW_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IEnumCERTVIEWROW_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IEnumCERTVIEWROW_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IEnumCERTVIEWROW_GetTypeInfoCount(This,pctinfo)	\
    ( (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo) ) 

#define IEnumCERTVIEWROW_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    ( (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo) ) 

#define IEnumCERTVIEWROW_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    ( (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId) ) 

#define IEnumCERTVIEWROW_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    ( (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr) ) 


#define IEnumCERTVIEWROW_Next(This,pIndex)	\
    ( (This)->lpVtbl -> Next(This,pIndex) ) 

#define IEnumCERTVIEWROW_EnumCertViewColumn(This,ppenum)	\
    ( (This)->lpVtbl -> EnumCertViewColumn(This,ppenum) ) 

#define IEnumCERTVIEWROW_EnumCertViewAttribute(This,Flags,ppenum)	\
    ( (This)->lpVtbl -> EnumCertViewAttribute(This,Flags,ppenum) ) 

#define IEnumCERTVIEWROW_EnumCertViewExtension(This,Flags,ppenum)	\
    ( (This)->lpVtbl -> EnumCertViewExtension(This,Flags,ppenum) ) 

#define IEnumCERTVIEWROW_Skip(This,celt)	\
    ( (This)->lpVtbl -> Skip(This,celt) ) 

#define IEnumCERTVIEWROW_Reset(This)	\
    ( (This)->lpVtbl -> Reset(This) ) 

#define IEnumCERTVIEWROW_Clone(This,ppenum)	\
    ( (This)->lpVtbl -> Clone(This,ppenum) ) 

#define IEnumCERTVIEWROW_GetMaxIndex(This,pIndex)	\
    ( (This)->lpVtbl -> GetMaxIndex(This,pIndex) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IEnumCERTVIEWROW_INTERFACE_DEFINED__ */


#ifndef __ICertView_INTERFACE_DEFINED__
#define __ICertView_INTERFACE_DEFINED__

/* interface ICertView */
/* [unique][helpstring][local][dual][uuid][object] */ 


EXTERN_C const IID IID_ICertView;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("c3fac344-1e84-11d1-9bd6-00c04fb683fa")
    ICertView : public IDispatch
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE OpenConnection( 
            /* [in] */ const BSTR strConfig) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE EnumCertViewColumn( 
            /* [in] */ LONG fResultColumn,
            /* [retval][out] */ IEnumCERTVIEWCOLUMN **ppenum) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetColumnCount( 
            /* [in] */ LONG fResultColumn,
            /* [retval][out] */ LONG *pcColumn) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetColumnIndex( 
            /* [in] */ LONG fResultColumn,
            /* [in] */ const BSTR strColumnName,
            /* [retval][out] */ LONG *pColumnIndex) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetResultColumnCount( 
            /* [in] */ LONG cResultColumn) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetResultColumn( 
            /* [in] */ LONG ColumnIndex) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetRestriction( 
            /* [in] */ LONG ColumnIndex,
            /* [in] */ LONG SeekOperator,
            /* [in] */ LONG SortOrder,
            /* [in] */ const VARIANT *pvarValue) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE OpenView( 
            /* [retval][out] */ IEnumCERTVIEWROW **ppenum) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct ICertViewVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            ICertView * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            ICertView * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            ICertView * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfoCount )( 
            ICertView * This,
            /* [out] */ UINT *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfo )( 
            ICertView * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo **ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetIDsOfNames )( 
            ICertView * This,
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR *rgszNames,
            /* [range][in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE *Invoke )( 
            ICertView * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS *pDispParams,
            /* [out] */ VARIANT *pVarResult,
            /* [out] */ EXCEPINFO *pExcepInfo,
            /* [out] */ UINT *puArgErr);
        
        HRESULT ( STDMETHODCALLTYPE *OpenConnection )( 
            ICertView * This,
            /* [in] */ const BSTR strConfig);
        
        HRESULT ( STDMETHODCALLTYPE *EnumCertViewColumn )( 
            ICertView * This,
            /* [in] */ LONG fResultColumn,
            /* [retval][out] */ IEnumCERTVIEWCOLUMN **ppenum);
        
        HRESULT ( STDMETHODCALLTYPE *GetColumnCount )( 
            ICertView * This,
            /* [in] */ LONG fResultColumn,
            /* [retval][out] */ LONG *pcColumn);
        
        HRESULT ( STDMETHODCALLTYPE *GetColumnIndex )( 
            ICertView * This,
            /* [in] */ LONG fResultColumn,
            /* [in] */ const BSTR strColumnName,
            /* [retval][out] */ LONG *pColumnIndex);
        
        HRESULT ( STDMETHODCALLTYPE *SetResultColumnCount )( 
            ICertView * This,
            /* [in] */ LONG cResultColumn);
        
        HRESULT ( STDMETHODCALLTYPE *SetResultColumn )( 
            ICertView * This,
            /* [in] */ LONG ColumnIndex);
        
        HRESULT ( STDMETHODCALLTYPE *SetRestriction )( 
            ICertView * This,
            /* [in] */ LONG ColumnIndex,
            /* [in] */ LONG SeekOperator,
            /* [in] */ LONG SortOrder,
            /* [in] */ const VARIANT *pvarValue);
        
        HRESULT ( STDMETHODCALLTYPE *OpenView )( 
            ICertView * This,
            /* [retval][out] */ IEnumCERTVIEWROW **ppenum);
        
        END_INTERFACE
    } ICertViewVtbl;

    interface ICertView
    {
        CONST_VTBL struct ICertViewVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define ICertView_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define ICertView_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define ICertView_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define ICertView_GetTypeInfoCount(This,pctinfo)	\
    ( (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo) ) 

#define ICertView_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    ( (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo) ) 

#define ICertView_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    ( (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId) ) 

#define ICertView_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    ( (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr) ) 


#define ICertView_OpenConnection(This,strConfig)	\
    ( (This)->lpVtbl -> OpenConnection(This,strConfig) ) 

#define ICertView_EnumCertViewColumn(This,fResultColumn,ppenum)	\
    ( (This)->lpVtbl -> EnumCertViewColumn(This,fResultColumn,ppenum) ) 

#define ICertView_GetColumnCount(This,fResultColumn,pcColumn)	\
    ( (This)->lpVtbl -> GetColumnCount(This,fResultColumn,pcColumn) ) 

#define ICertView_GetColumnIndex(This,fResultColumn,strColumnName,pColumnIndex)	\
    ( (This)->lpVtbl -> GetColumnIndex(This,fResultColumn,strColumnName,pColumnIndex) ) 

#define ICertView_SetResultColumnCount(This,cResultColumn)	\
    ( (This)->lpVtbl -> SetResultColumnCount(This,cResultColumn) ) 

#define ICertView_SetResultColumn(This,ColumnIndex)	\
    ( (This)->lpVtbl -> SetResultColumn(This,ColumnIndex) ) 

#define ICertView_SetRestriction(This,ColumnIndex,SeekOperator,SortOrder,pvarValue)	\
    ( (This)->lpVtbl -> SetRestriction(This,ColumnIndex,SeekOperator,SortOrder,pvarValue) ) 

#define ICertView_OpenView(This,ppenum)	\
    ( (This)->lpVtbl -> OpenView(This,ppenum) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __ICertView_INTERFACE_DEFINED__ */


#ifndef __ICertView2_INTERFACE_DEFINED__
#define __ICertView2_INTERFACE_DEFINED__

/* interface ICertView2 */
/* [unique][helpstring][dual][uuid][object] */ 


EXTERN_C const IID IID_ICertView2;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("d594b282-8851-4b61-9c66-3edadf848863")
    ICertView2 : public ICertView
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE SetTable( 
            /* [in] */ LONG Table) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct ICertView2Vtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            ICertView2 * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            ICertView2 * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            ICertView2 * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfoCount )( 
            ICertView2 * This,
            /* [out] */ __RPC__out UINT *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfo )( 
            ICertView2 * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ __RPC__deref_out_opt ITypeInfo **ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetIDsOfNames )( 
            ICertView2 * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [size_is][in] */ __RPC__in_ecount_full(cNames) LPOLESTR *rgszNames,
            /* [range][in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ __RPC__out_ecount_full(cNames) DISPID *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE *Invoke )( 
            ICertView2 * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS *pDispParams,
            /* [out] */ VARIANT *pVarResult,
            /* [out] */ EXCEPINFO *pExcepInfo,
            /* [out] */ UINT *puArgErr);
        
        HRESULT ( STDMETHODCALLTYPE *OpenConnection )( 
            ICertView2 * This,
            /* [in] */ __RPC__in const BSTR strConfig);
        
        HRESULT ( STDMETHODCALLTYPE *EnumCertViewColumn )( 
            ICertView2 * This,
            /* [in] */ LONG fResultColumn,
            /* [retval][out] */ __RPC__deref_out_opt IEnumCERTVIEWCOLUMN **ppenum);
        
        HRESULT ( STDMETHODCALLTYPE *GetColumnCount )( 
            ICertView2 * This,
            /* [in] */ LONG fResultColumn,
            /* [retval][out] */ __RPC__out LONG *pcColumn);
        
        HRESULT ( STDMETHODCALLTYPE *GetColumnIndex )( 
            ICertView2 * This,
            /* [in] */ LONG fResultColumn,
            /* [in] */ __RPC__in const BSTR strColumnName,
            /* [retval][out] */ __RPC__out LONG *pColumnIndex);
        
        HRESULT ( STDMETHODCALLTYPE *SetResultColumnCount )( 
            ICertView2 * This,
            /* [in] */ LONG cResultColumn);
        
        HRESULT ( STDMETHODCALLTYPE *SetResultColumn )( 
            ICertView2 * This,
            /* [in] */ LONG ColumnIndex);
        
        HRESULT ( STDMETHODCALLTYPE *SetRestriction )( 
            ICertView2 * This,
            /* [in] */ LONG ColumnIndex,
            /* [in] */ LONG SeekOperator,
            /* [in] */ LONG SortOrder,
            /* [in] */ __RPC__in const VARIANT *pvarValue);
        
        HRESULT ( STDMETHODCALLTYPE *OpenView )( 
            ICertView2 * This,
            /* [retval][out] */ __RPC__deref_out_opt IEnumCERTVIEWROW **ppenum);
        
        HRESULT ( STDMETHODCALLTYPE *SetTable )( 
            ICertView2 * This,
            /* [in] */ LONG Table);
        
        END_INTERFACE
    } ICertView2Vtbl;

    interface ICertView2
    {
        CONST_VTBL struct ICertView2Vtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define ICertView2_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define ICertView2_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define ICertView2_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define ICertView2_GetTypeInfoCount(This,pctinfo)	\
    ( (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo) ) 

#define ICertView2_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    ( (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo) ) 

#define ICertView2_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    ( (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId) ) 

#define ICertView2_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    ( (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr) ) 


#define ICertView2_OpenConnection(This,strConfig)	\
    ( (This)->lpVtbl -> OpenConnection(This,strConfig) ) 

#define ICertView2_EnumCertViewColumn(This,fResultColumn,ppenum)	\
    ( (This)->lpVtbl -> EnumCertViewColumn(This,fResultColumn,ppenum) ) 

#define ICertView2_GetColumnCount(This,fResultColumn,pcColumn)	\
    ( (This)->lpVtbl -> GetColumnCount(This,fResultColumn,pcColumn) ) 

#define ICertView2_GetColumnIndex(This,fResultColumn,strColumnName,pColumnIndex)	\
    ( (This)->lpVtbl -> GetColumnIndex(This,fResultColumn,strColumnName,pColumnIndex) ) 

#define ICertView2_SetResultColumnCount(This,cResultColumn)	\
    ( (This)->lpVtbl -> SetResultColumnCount(This,cResultColumn) ) 

#define ICertView2_SetResultColumn(This,ColumnIndex)	\
    ( (This)->lpVtbl -> SetResultColumn(This,ColumnIndex) ) 

#define ICertView2_SetRestriction(This,ColumnIndex,SeekOperator,SortOrder,pvarValue)	\
    ( (This)->lpVtbl -> SetRestriction(This,ColumnIndex,SeekOperator,SortOrder,pvarValue) ) 

#define ICertView2_OpenView(This,ppenum)	\
    ( (This)->lpVtbl -> OpenView(This,ppenum) ) 


#define ICertView2_SetTable(This,Table)	\
    ( (This)->lpVtbl -> SetTable(This,Table) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __ICertView2_INTERFACE_DEFINED__ */


/* Additional Prototypes for ALL interfaces */

/* end of Additional Prototypes */

#ifdef __cplusplus
}
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\vs9sp1\sdk\include\ChStrArr.h ===
//***************************************************************************
//
//  Copyright (c) Microsoft Corporation.  All rights reserved.
//
//  CHSTRARR.H
//
//  Purpose: Utility library version of MFC CHStringArray
//
//***************************************************************************

#if _MSC_VER > 1000
#pragma once
#endif

#ifndef _CHStringArray_
#define _CHStringArray_

#include <polarity.h>
#include <ProvExce.h>

class POLARITY CHStringArray 
{
    public:

        CHStringArray();
        ~CHStringArray();

        // Attributes
        int GetSize() const             { return m_nSize; }
        int GetUpperBound() const       { return m_nSize-1; }
        void SetSize(int nNewSize, int nGrowBy = -1) throw ( CHeap_Exception ) ;

        // Operations
        // Clean up
        void FreeExtra() throw ( CHeap_Exception ) ;
        void RemoveAll()                { SetSize(0); }

        // Accessing elements
#if (!defined DEBUG && !defined _DEBUG)
        CHString GetAt(int nIndex) const{ return m_pData[nIndex]; }
        void SetAt(int nIndex, LPCWSTR newElement){ m_pData[nIndex] = newElement; }
        CHString& ElementAt(int nIndex) { return m_pData[nIndex]; }
#else
        CHString GetAt(int nIndex) const;
        void SetAt(int nIndex, LPCWSTR newElement);
        CHString& ElementAt(int nIndex);
#endif

        // Direct Access to the element data (may return NULL)
        const CHString* GetData() const { return (const CHString*)m_pData; }
        CHString* GetData()             { return (CHString*)m_pData; }

        // Potentially growing the array
        void SetAtGrow(int nIndex, LPCWSTR newElement) throw ( CHeap_Exception ) ;
        int Add(LPCWSTR newElement) throw ( CHeap_Exception ) 
        { 
            int nIndex = m_nSize;
            SetAtGrow(nIndex, newElement);
            return nIndex; 
        }

        int Append(const CHStringArray& src) throw ( CHeap_Exception ) ;
        void Copy(const CHStringArray& src) throw ( CHeap_Exception ) ;

        // overloaded operator helpers
        CHString operator[](int nIndex) const { return GetAt(nIndex); }
        CHString& operator[](int nIndex)      { return ElementAt(nIndex); }

        // Operations that move elements around
        void InsertAt(int nIndex, LPCWSTR newElement, int nCount = 1) throw ( CHeap_Exception ) ;
        void RemoveAt(int nIndex, int nCount = 1);
        void InsertAt(int nStartIndex, CHStringArray* pNewArray) throw ( CHeap_Exception ) ;

        // Implementation

    protected:
        CHString* m_pData;      // the actual array of data
        int m_nSize;            // # of elements (upperBound - 1)
        int m_nMaxSize;         // max allocated
        int m_nGrowBy;          // grow amount
                                // local typedefs for class templates
        typedef CHString BASE_TYPE;
        typedef LPCWSTR BASE_ARG_TYPE;
};
////////////////////////////////////////////////////////////////////////////
#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\vs9sp1\sdk\include\CertSrv.h ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1999
//
//  File:       CertSrv.h
//  Contents:   Main Certificate Server header
//              Also includes .h files for the COM interfaces
//
//----------------------------------------------------------------------------

#if !defined( _CERTSRV_H_ )
#define _CERTSRV_H_

#include <certadm.h>
#include <certbcli.h>
#include <certcli.h>
#include <certenc.h>
#include <certexit.h>
#include <certif.h>
#include <certpol.h>
#include <certmod.h>
#include <certview.h>

#ifndef DBG_CERTSRV
# if defined(_DEBUG)
#  define DBG_CERTSRV     1
# elif defined(DBG)
#  define DBG_CERTSRV     DBG
# else
#  define DBG_CERTSRV     0
# endif
#endif

#define wszSERVICE_NAME		TEXT("CertSvc")

#define wszREGKEYNOSYSTEMCERTSVCPATH \
				TEXT("CurrentControlSet\\Services\\") \
				wszSERVICE_NAME

#define wszREGKEYCERTSVCPATH	TEXT("SYSTEM\\") wszREGKEYNOSYSTEMCERTSVCPATH
#define wszREGKEYBASE		wszREGKEYCERTSVCPATH	// obsolete definition

//======================================================================
// Full path to "CertSvc\Configuration\":
#define wszREGKEYCONFIGPATH	wszREGKEYCERTSVCPATH TEXT("\\") wszREGKEYCONFIG
#define wszREGKEYCONFIGPATH_BS	wszREGKEYCONFIGPATH TEXT("\\")
#define wszREGKEYCONFIGCANAME	wszREGKEYCONFIGPATH_BS	// obsolete definition

//======================================================================
// Full path to "CertSvc\Configuration\RestoreInProgress":
#define wszREGKEYCONFIGRESTORE wszREGKEYCONFIGPATH_BS wszREGKEYRESTOREINPROGRESS

//======================================================================
// Key Under "CertSvc":
#define wszREGKEYCONFIG		TEXT("Configuration")

//======================================================================
// Values Under "CertSvc\Configuration":
#define wszREGACTIVE		      TEXT("Active")
#define wszREGDIRECTORY		      TEXT("ConfigurationDirectory")
#define wszREGDBDIRECTORY             TEXT("DBDirectory")
#define wszREGDBLOGDIRECTORY          TEXT("DBLogDirectory")
#define wszREGDBSYSDIRECTORY          TEXT("DBSystemDirectory")
#define wszREGDBTEMPDIRECTORY         TEXT("DBTempDirectory")
#define wszREGDBSESSIONCOUNT	      TEXT("DBSessionCount")
#define wszREGDBFLAGS		      TEXT("DBFlags")
#define wszREGDBLASTFULLBACKUP	      TEXT("DBLastFullBackup")
#define wszREGDBLASTINCREMENTALBACKUP TEXT("DBLastIncrementalBackup")
#define wszREGDBLASTRECOVERY	      TEXT("DBLastRecovery")
#define wszREGWEBCLIENTCAMACHINE      TEXT("WebClientCAMachine")
#define wszREGVERSION		      TEXT("Version")
#define wszREGWEBCLIENTCANAME         TEXT("WebClientCAName")
#define wszREGWEBCLIENTCATYPE         TEXT("WebClientCAType")
#define wszREGLDAPFLAGS               TEXT("LDAPFlags")
#define wszREGCERTSRVDEBUG	      TEXT("Debug")


// Default value for wszREGDBSESSIONCOUNT
#define DBSESSIONCOUNTDEFAULT	     20

//==================================
// Values for wszREGDBFLAGS

#define DBFLAGS_READONLY		0x00000001	// ignored in registry
#define DBFLAGS_CREATEIFNEEDED		0x00000002
#define DBFLAGS_CIRCULARLOGGING		0x00000004
#define DBFLAGS_LAZYFLUSH		0x00000008
#define DBFLAGS_MAXCACHESIZEX100	0x00000010
#define DBFLAGS_CHECKPOINTDEPTH60MB	0x00000020
#define DBFLAGS_LOGBUFFERSLARGE		0x00000040
#define DBFLAGS_LOGBUFFERSHUGE		0x00000080
#define DBFLAGS_LOGFILESIZE16MB		0x00000100
#define DBFLAGS_MULTITHREADTRANSACTIONS	0x00000200
#define DBFLAGS_DISABLESNAPSHOTBACKUP	0x00000400	// ignored in registry

#define DBFLAGS_DEFAULT		(DBFLAGS_LAZYFLUSH | \
				 DBFLAGS_MAXCACHESIZEX100 | \
				 DBFLAGS_CHECKPOINTDEPTH60MB | \
				 DBFLAGS_LOGBUFFERSHUGE)


//==================================
// Values for wszREGLDAPSSLFLAGS
// Default is zero (same as a missing registry value):
//    0: Don't use SSL, but sign all LDAP traffic.
//    3: Use SSL but don't sign LDAP traffic.
#define LDAPF_SSLENABLE		0x00000001	// use SSL for LDAP traffic
#define LDAPF_SIGNDISABLE	0x00000002	// disable signing LDAP traffic

// Default value for wszREGMAXINCOMINGMESSAGESIZE
#define MAXINCOMINGMESSAGESIZEDEFAULT		(64 * 1024)

// Default value for wszREGMAXINCOMINGALLOCSIZE
#define MAXINCOMINGALLOCSIZEDEFAULT		(64 * 1024)

// Value for wszREGVERSION:

// win2k version
#define CSVER_MAJOR_WIN2K            1 // actually this wasn't define in win2k
#define CSVER_MINOR_WIN2K            1

// whistler version
#define CSVER_MAJOR_WHISTLER         2
#define CSVER_MINOR_WHISTLER_BETA2   1
#define CSVER_MINOR_WHISTLER_BETA3   2

// whistler version
#define CSVER_MAJOR_LONGHORN         3
#define CSVER_MINOR_LONGHORN_BETA1   1

// current version
#define CSVER_MAJOR		     CSVER_MAJOR_LONGHORN	    // high 16 bits
#define CSVER_MINOR		     CSVER_MINOR_LONGHORN_BETA1	// low 16 bits

// version manipulation
#define CSVER_EXTRACT_MAJOR(version) ((version)>>16)
#define CSVER_EXTRACT_MINOR(version) ((version)&0xffff)
#define CSVER_BUILD_VERSION(major, minor) (((major)<<16)|(minor))

// Keys Under "CertSvc\Configuration":
#define wszREGKEYRESTOREINPROGRESS   TEXT("RestoreInProgress")
#define wszREGKEYDBPARAMETERS	     TEXT("DBParameters")

//======================================================================
// Values Under "CertSvc\Configuration\<CAName>":
#define wszREGCADESCRIPTION          TEXT("CADescription")
#define wszREGCACERTHASH	     TEXT("CACertHash")
#define wszREGCASERIALNUMBER	     TEXT("CACertSerialNumber")
#define wszREGCAXCHGCERTHASH	     TEXT("CAXchgCertHash")
#define wszREGKRACERTHASH	     TEXT("KRACertHash")
#define wszREGKRACERTCOUNT	     TEXT("KRACertCount")
#define wszREGKRAFLAGS		     TEXT("KRAFlags")
#define wszREGCATYPE		     TEXT("CAType")
#define wszREGCERTENROLLCOMPATIBLE   TEXT("CertEnrollCompatible")
#define wszREGENFORCEX500NAMELENGTHS TEXT("EnforceX500NameLengths")
#define wszREGCOMMONNAME	     TEXT("CommonName")
#define wszREGCLOCKSKEWMINUTES	     TEXT("ClockSkewMinutes")

#define wszREGCRLNEXTPUBLISH         TEXT("CRLNextPublish")
#define wszREGCRLPERIODSTRING	     TEXT("CRLPeriod")
#define wszREGCRLPERIODCOUNT	     TEXT("CRLPeriodUnits")
#define wszREGCRLOVERLAPPERIODSTRING TEXT("CRLOverlapPeriod")
#define wszREGCRLOVERLAPPERIODCOUNT  TEXT("CRLOverlapUnits")

#define wszREGCRLDELTANEXTPUBLISH    TEXT("CRLDeltaNextPublish")
#define wszREGCRLDELTAPERIODSTRING   TEXT("CRLDeltaPeriod")
#define wszREGCRLDELTAPERIODCOUNT    TEXT("CRLDeltaPeriodUnits")
#define wszREGCRLDELTAOVERLAPPERIODSTRING TEXT("CRLDeltaOverlapPeriod")
#define wszREGCRLDELTAOVERLAPPERIODCOUNT  TEXT("CRLDeltaOverlapUnits")

#define wszREGCRLPUBLICATIONURLS     TEXT("CRLPublicationURLs")
#define wszREGCACERTPUBLICATIONURLS  TEXT("CACertPublicationURLs")

#define wszREGCAXCHGVALIDITYPERIODSTRING  TEXT("CAXchgValidityPeriod")
#define wszREGCAXCHGVALIDITYPERIODCOUNT   TEXT("CAXchgValidityPeriodUnits")
#define wszREGCAXCHGOVERLAPPERIODSTRING   TEXT("CAXchgOverlapPeriod")
#define wszREGCAXCHGOVERLAPPERIODCOUNT    TEXT("CAXchgOverlapPeriodUnits")

#define wszREGCRLPATH_OLD            TEXT("CRLPath")
#define wszREGCRLEDITFLAGS	     TEXT("CRLEditFlags")
#define wszREGCRLFLAGS		     TEXT("CRLFlags")
#define wszREGCRLATTEMPTREPUBLISH    TEXT("CRLAttemptRepublish")
#define wszREGENABLED		     TEXT("Enabled")
#define wszREGFORCETELETEX           TEXT("ForceTeletex")
#define wszREGLOGLEVEL		     TEXT("LogLevel")
#define wszREGHIGHSERIAL	     TEXT("HighSerial")
#define wszREGPOLICYFLAGS	     TEXT("PolicyFlags")
#define wszREGNAMESEPARATOR          TEXT("SubjectNameSeparator")
#define wszREGSUBJECTTEMPLATE	     TEXT("SubjectTemplate")
#define wszREGCAUSEDS		     TEXT("UseDS")
#define wszREGVALIDITYPERIODSTRING   TEXT("ValidityPeriod")
#define wszREGVALIDITYPERIODCOUNT    TEXT("ValidityPeriodUnits")
#define wszREGPARENTCAMACHINE        TEXT("ParentCAMachine")
#define wszREGPARENTCANAME           TEXT("ParentCAName")
#define wszREGREQUESTFILENAME        TEXT("RequestFileName")
#define wszREGREQUESTID              TEXT("RequestId")
#define wszREGREQUESTKEYCONTAINER    TEXT("RequestKeyContainer")
#define wszREGREQUESTKEYINDEX        TEXT("RequestKeyIndex")
#define wszREGCASERVERNAME           TEXT("CAServerName")
#define wszREGCACERTFILENAME         TEXT("CACertFileName")
#define wszREGCASECURITY             TEXT("Security")
#define wszREGAUDITFILTER            TEXT("AuditFilter")
#define wszREGOFFICERRIGHTS          TEXT("OfficerRights")
#define wszENROLLMENTAGENTRIGHTS     TEXT("EnrollmentAgentRights")
#define wszREGMAXINCOMINGMESSAGESIZE TEXT("MaxIncomingMessageSize")
#define wszREGMAXINCOMINGALLOCSIZE   TEXT("MaxIncomingAllocSize")
#define wszREGROLESEPARATIONENABLED  TEXT("RoleSeparationEnabled")
#define wszREGALTERNATEPUBLISHDOMAINS TEXT("AlternatePublishDomains")

#define wszREGSETUPSTATUS            TEXT("SetupStatus")
#define wszREGINTERFACEFLAGS         TEXT("InterfaceFlags")    
#define wszREGDSCONFIGDN	     TEXT("DSConfigDN")    
#define wszREGDSDOMAINDN	     TEXT("DSDomainDN")    
#define wszREGVIEWAGEMINUTES	     TEXT("ViewAgeMinutes")
#define wszREGVIEWIDLEMINUTES	     TEXT("ViewIdleMinutes")


#define wszCRTFILENAMEEXT	     TEXT(".crt")
#define wszPFXFILENAMEEXT	     TEXT(".p12")
#define wszDATFILENAMEEXT	     TEXT(".dat")
#define wszLOGFILENAMEEXT	     TEXT(".log")
#define wszDBFILENAMEEXT	     TEXT(".edb")
#define szDBBASENAMEPARM	     "edb"
#define wszDBBASENAMEPARM	     TEXT(szDBBASENAMEPARM)
#define wszLOGPATH		     TEXT("CertLog")
#define wszDBBACKUPSUBDIR	     TEXT("DataBase")
#define wszDBBACKUPCERTBACKDAT	     TEXT("certbkxp.dat")

#ifndef __ENUM_CATYPES__
#define __ENUM_CATYPES__

//==================================
// Values for wszREGCATYPE:
typedef enum {
    ENUM_ENTERPRISE_ROOTCA = 0,
    ENUM_ENTERPRISE_SUBCA = 1,
    //ENUM_UNUSED2 = 2,
    ENUM_STANDALONE_ROOTCA = 3,
    ENUM_STANDALONE_SUBCA = 4,
    ENUM_UNKNOWN_CA = 5,
} ENUM_CATYPES;

typedef struct _CAINFO
{
    DWORD   cbSize;
    ENUM_CATYPES CAType;
    DWORD   cCASignatureCerts;
    DWORD   cCAExchangeCerts;
    DWORD   cExitModules;
    LONG    lPropIdMax;
    LONG    lRoleSeparationEnabled;
    DWORD   cKRACertUsedCount;
    DWORD   cKRACertCount;
    DWORD   fAdvancedServer;   
} CAINFO;

#endif __ENUM_CATYPES__

// Default value for wszREGCLOCKSKEWMINUTES
#define CCLOCKSKEWMINUTESDEFAULT	      10


// Default value for wszREGVIEWAGEMINUTES, wszREGVIEWIDLEMINUTES
#define CVIEWAGEMINUTESDEFAULT			16
#define CVIEWIDLEMINUTESDEFAULT			(CVIEWAGEMINUTESDEFAULT / 2)

// Default validity period for ROOT CA certs:
#define dwVALIDITYPERIODCOUNTDEFAULT_ROOT	5

// Default validity periods for certs issued by a CA:
#define dwVALIDITYPERIODCOUNTDEFAULT_ENTERPRISE	2
#define dwVALIDITYPERIODCOUNTDEFAULT_STANDALONE	1
#define dwVALIDITYPERIODENUMDEFAULT	      ENUM_PERIOD_YEARS
#define wszVALIDITYPERIODSTRINGDEFAULT	      wszPERIODYEARS

#define dwCAXCHGVALIDITYPERIODCOUNTDEFAULT    1
#define dwCAXCHGVALIDITYPERIODENUMDEFAULT     ENUM_PERIOD_WEEKS
#define wszCAXCHGVALIDITYPERIODSTRINGDEFAULT  wszPERIODWEEKS

#define dwCAXCHGOVERLAPPERIODCOUNTDEFAULT     1
#define dwCAXCHGOVERLAPPERIODENUMDEFAULT      ENUM_PERIOD_DAYS
#define wszCAXCHGOVERLAPPERIODSTRINGDEFAULT   wszPERIODDAYS

#define dwCRLPERIODCOUNTDEFAULT		      1
#define wszCRLPERIODSTRINGDEFAULT	      wszPERIODWEEKS

#define dwCRLOVERLAPPERIODCOUNTDEFAULT	      0		// 0 --> disabled
#define wszCRLOVERLAPPERIODSTRINGDEFAULT      wszPERIODHOURS

#define dwCRLDELTAPERIODCOUNTDEFAULT          1
#define wszCRLDELTAPERIODSTRINGDEFAULT        wszPERIODDAYS

#define dwCRLDELTAOVERLAPPERIODCOUNTDEFAULT   0		// 0 --> disabled
#define wszCRLDELTAOVERLAPPERIODSTRINGDEFAULT wszPERIODMINUTES


//==================================
// Values for wszREGLOGLEVEL:
#define CERTLOG_MINIMAL		(DWORD) 0
#define CERTLOG_TERSE		(DWORD) 1
#define CERTLOG_ERROR		(DWORD) 2
#define CERTLOG_WARNING		(DWORD) 3
#define CERTLOG_VERBOSE		(DWORD) 4
#define CERTLOG_EXHAUSTIVE	(DWORD) 5


//==================================
// Values for wszREGSETUPSTATUS:
#define SETUP_SERVER_FLAG		     0x00000001	// server installed
#define SETUP_CLIENT_FLAG		     0x00000002	// client installed
#define SETUP_SUSPEND_FLAG		     0x00000004	// incomplete install
#define SETUP_REQUEST_FLAG		     0x00000008	// new cert requested
#define SETUP_ONLINE_FLAG		     0x00000010	// requested online
#define SETUP_DENIED_FLAG		     0x00000020	// request denied
#define SETUP_CREATEDB_FLAG		     0x00000040	// create new DB
#define SETUP_ATTEMPT_VROOT_CREATE	     0x00000080	// try to create vroots
#define SETUP_FORCECRL_FLAG		     0x00000100	// force new CRL(s)

// add server type to CA DS object "flags" attr:
#define SETUP_UPDATE_CAOBJECT_SVRTYPE	     0x00000200

#define SETUP_SERVER_UPGRADED_FLAG	     0x00000400	// server was upgraded

// still need to upgrade security:
#define SETUP_W2K_SECURITY_NOT_UPGRADED_FLAG 0x00000800

// permissons changed while CA was down, certsrv will need to update DS &
// service when it restarts:
#define SETUP_SECURITY_CHANGED		     0x00001000

// win2k3 SP1 - global DCOM security has been fixed:
#define SETUP_DCOM_SECURITY_UPDATED_FLAG     0x00002000

// Indicates that the server is up to date:
#define SETUP_SERVER_IS_UP_TO_DATE_FLAG      0x00004000


//==================================
// Values for wszREGCRLFLAGS:
#define CRLF_DELTA_USE_OLDEST_UNEXPIRED_BASE	0x00000001 // use oldest base:
// else use newest base CRL that satisfies base CRL propagation delay

#define CRLF_DELETE_EXPIRED_CRLS		0x00000002
#define CRLF_CRLNUMBER_CRITICAL			0x00000004
#define CRLF_REVCHECK_IGNORE_OFFLINE		0x00000008
#define CRLF_IGNORE_INVALID_POLICIES		0x00000010
#define CRLF_REBUILD_MODIFIED_SUBJECT_ONLY	0x00000020
#define CRLF_SAVE_FAILED_CERTS			0x00000040
#define CRLF_IGNORE_UNKNOWN_CMC_ATTRIBUTES	0x00000080
#define CRLF_IGNORE_CROSS_CERT_TRUST_ERROR	0x00000100
#define CRLF_PUBLISH_EXPIRED_CERT_CRLS		0x00000200
#define CRLF_ENFORCE_ENROLLMENT_AGENT		0x00000400
#define CRLF_DISABLE_RDN_REORDER		0x00000800
#define CRLF_DISABLE_ROOT_CROSS_CERTS		0x00001000
#define CRLF_LOG_FULL_RESPONSE	     0x00002000 // hex dump response to console
#define CRLF_USE_XCHG_CERT_TEMPLATE  0x00004000 // enforce xchg template access
#define CRLF_USE_CROSS_CERT_TEMPLATE 0x00008000 // enforce cross template access
#define CRLF_ALLOW_REQUEST_ATTRIBUTE_SUBJECT	0x00010000
#define CRLF_REVCHECK_IGNORE_NOREVCHECK		0x00020000
#define CRLF_PRESERVE_EXPIRED_CA_CERTS		0x00040000
#define CRLF_PRESERVE_REVOKED_CA_CERTS		0x00080000

//==================================
// Values for wszREGKRAFLAGS:
#define KRAF_ENABLEFOREIGN	0x00000001 // allow foreign cert, key archival
#define KRAF_SAVEBADREQUESTKEY	0x00000002 // save failed request w/archived key
#define KRAF_ENABLEARCHIVEALL	0x00000004
#define KRAF_DISABLEUSEDEFAULTPROVIDER    0x00000008

//==================================
// Values for wszREGINTERFACEFLAGS:
#define IF_LOCKICERTREQUEST		0x00000001
#define IF_NOREMOTEICERTREQUEST		0x00000002
#define IF_NOLOCALICERTREQUEST		0x00000004
#define IF_NORPCICERTREQUEST		0x00000008
#define IF_NOREMOTEICERTADMIN		0x00000010
#define IF_NOLOCALICERTADMIN		0x00000020
#define IF_NOREMOTEICERTADMINBACKUP	0x00000040
#define IF_NOLOCALICERTADMINBACKUP	0x00000080
#define IF_NOSNAPSHOTBACKUP		0x00000100
#define IF_ENFORCEENCRYPTICERTREQUEST   0x00000200
#define IF_ENFORCEENCRYPTICERTADMIN     0x00000400
#define IF_ENABLEEXITKEYRETRIEVAL	0x00000800
#define IF_ENABLEADMINASAUDITOR		0x00001000

#define IF_DEFAULT			(IF_NOREMOTEICERTADMINBACKUP)

//==================================
// Values for numeric prefixes for
// wszREGCRLPUBLICATIONURLS and wszREGCACERTPUBLICATIONURLS:
//
// URL publication template Flags values, encoded as a decimal prefix for URL
// publication templates in the registry:
//   "1:c:\winnt\System32\CertSrv\CertEnroll\MyCA.crl"
//   "2:http:\//MyServer.MyDomain.com/CertEnroll\MyCA.crl"

#define CSURL_SERVERPUBLISH	 0x00000001
#define CSURL_ADDTOCERTCDP	 0x00000002
#define CSURL_ADDTOFRESHESTCRL	 0x00000004
#define CSURL_ADDTOCRLCDP	 0x00000008
#define CSURL_PUBLISHRETRY	 0x00000010
#define CSURL_ADDTOCERTOCSP	 0x00000020
#define CSURL_SERVERPUBLISHDELTA 0x00000040
#define CSURL_ADDTOIDP		 0x00000080  
//======================================================================
// Keys Under "CertSvc\Configuration\<CAName>":
#define wszREGKEYCSP			TEXT("CSP")
#define wszREGKEYENCRYPTIONCSP		TEXT("EncryptionCSP")
#define wszREGKEYEXITMODULES		TEXT("ExitModules")
#define wszREGKEYPOLICYMODULES	        TEXT("PolicyModules")
#define wszSECUREDATTRIBUTES		TEXT("SignedAttributes")

#define wszzDEFAULTSIGNEDATTRIBUTES     TEXT("RequesterName\0")

//======================================================================
// Values Under "CertSvc\Configuration\RestoreInProgress":
#define wszREGBACKUPLOGDIRECTORY	TEXT("BackupLogDirectory")
#define wszREGCHECKPOINTFILE		TEXT("CheckPointFile")
#define wszREGHIGHLOGNUMBER		TEXT("HighLogNumber")
#define wszREGLOWLOGNUMBER		TEXT("LowLogNumber")
#define wszREGLOGPATH			TEXT("LogPath")
#define wszREGRESTOREMAPCOUNT		TEXT("RestoreMapCount")
#define wszREGRESTOREMAP		TEXT("RestoreMap")
#define wszREGDATABASERECOVERED		TEXT("DatabaseRecovered")
#define wszREGRESTORESTATUS		TEXT("RestoreStatus")

// values under \Configuration\PolicyModules in nt5 beta 2
#define wszREGB2ICERTMANAGEMODULE   TEXT("ICertManageModule")
// values under \Configuration in nt4 sp4
#define wszREGSP4DEFAULTCONFIGURATION  TEXT("DefaultConfiguration")
// values under ca in nt4 sp4
#define wszREGSP4KEYSETNAME            TEXT("KeySetName")
#define wszREGSP4SUBJECTNAMESEPARATOR  TEXT("SubjectNameSeparator")
#define wszREGSP4NAMES                 TEXT("Names")
#define wszREGSP4QUERIES               TEXT("Queries")
// both nt4 sp4 and nt5 beta 2
#define wszREGNETSCAPECERTTYPE         TEXT("NetscapeCertType")
#define wszNETSCAPEREVOCATIONTYPE      TEXT("Netscape")


//======================================================================
// Values Under "CertSvc\Configuration\<CAName>\CSP":
// and "CertSvc\Configuration\<CAName>\EncryptionCSP":
#define wszREGPROVIDERTYPE     TEXT("ProviderType")
#define wszREGPROVIDER         TEXT("Provider")
#define wszHASHALGORITHM       TEXT("HashAlgorithm")
#define wszENCRYPTIONALGORITHM TEXT("EncryptionAlgorithm")
#define wszMACHINEKEYSET       TEXT("MachineKeyset")
#define wszREGKEYSIZE	       TEXT("KeySize")
#define wszREGSYMMETRICKEYSIZE TEXT("SymmetricKeySize")
#define wszCNGPUBLICKEYALGORITHM TEXT("CNGPublicKeyAlgorithm")
#define wszCNGHASHALGORITHM	TEXT("CNGHashAlgorithm")
#define wszCNGENCRYPTIONALGORITHM TEXT("CNGEncryptionAlgorithm")
#define wszREGALTERNATESIGNATUREALGORITHM TEXT("AlternateSignatureAlgorithm")


//======================================================================
// Value strings for "CertSvc\Configuration\<CAName>\SubjectNameSeparator":
#define szNAMESEPARATORDEFAULT   "\n"
#define wszNAMESEPARATORDEFAULT   TEXT(szNAMESEPARATORDEFAULT)


//======================================================================
// Value strings for "CertSvc\Configuration\<CAName>\ValidityPeriod", etc.:
#define wszPERIODYEARS		TEXT("Years")
#define wszPERIODMONTHS		TEXT("Months")
#define wszPERIODWEEKS		TEXT("Weeks")
#define wszPERIODDAYS		TEXT("Days")
#define wszPERIODHOURS		TEXT("Hours")
#define wszPERIODMINUTES	TEXT("Minutes")
#define wszPERIODSECONDS	TEXT("Seconds")

//======================================================================
// Values Under "CertSvc\Configuration\<CAName>\PolicyModules\<ProgId>":
#define wszREGISSUERCERTURLFLAGS    TEXT("IssuerCertURLFlags")
#define wszREGEDITFLAGS		    TEXT("EditFlags")
#define wszREGUPNMAP		    TEXT("UPNMap")
#define wszREGSUBJECTALTNAME	    TEXT("SubjectAltName")
#define wszREGSUBJECTALTNAME2	    TEXT("SubjectAltName2")
#define wszREGREQUESTDISPOSITION    TEXT("RequestDisposition")
#define wszREGCAPATHLENGTH	    TEXT("CAPathLength")
#define wszREGREVOCATIONTYPE	    TEXT("RevocationType")

#define wszREGLDAPREVOCATIONCRLURL_OLD	TEXT("LDAPRevocationCRLURL")
#define wszREGREVOCATIONCRLURL_OLD	TEXT("RevocationCRLURL")
#define wszREGFTPREVOCATIONCRLURL_OLD	TEXT("FTPRevocationCRLURL")
#define wszREGFILEREVOCATIONCRLURL_OLD	TEXT("FileRevocationCRLURL")

#define wszREGREVOCATIONURL		TEXT("RevocationURL")

#define wszREGLDAPISSUERCERTURL_OLD	TEXT("LDAPIssuerCertURL")
#define wszREGISSUERCERTURL_OLD		TEXT("IssuerCertURL")
#define wszREGFTPISSUERCERTURL_OLD	TEXT("FTPIssuerCertURL")
#define wszREGFILEISSUERCERTURL_OLD	TEXT("FileIssuerCertURL")

#define wszREGENABLEREQUESTEXTENSIONLIST  TEXT("EnableRequestExtensionList")
#define wszREGENABLEENROLLEEREQUESTEXTENSIONLIST  TEXT("EnableEnrolleeRequestExtensionList")
#define wszREGDISABLEEXTENSIONLIST  TEXT("DisableExtensionList")

#define wszREGDEFAULTSMIME		TEXT("DefaultSMIME")

// wszREGCAPATHLENGTH Values:
#define CAPATHLENGTH_INFINITE		0xffffffff

// wszREGREQUESTDISPOSITION Values:
#define REQDISP_PENDING			0x00000000
#define REQDISP_ISSUE			0x00000001
#define REQDISP_DENY			0x00000002
#define REQDISP_USEREQUESTATTRIBUTE	0x00000003
#define REQDISP_MASK			0x000000ff
#define REQDISP_PENDINGFIRST		0x00000100
#define REQDISP_DEFAULT_STANDALONE	(REQDISP_PENDINGFIRST | REQDISP_ISSUE)
#define REQDISP_DEFAULT_ENTERPRISE	(REQDISP_ISSUE)

// wszREGREVOCATIONTYPE Values:
#define REVEXT_CDPLDAPURL_OLD		0x00000001
#define REVEXT_CDPHTTPURL_OLD		0x00000002
#define REVEXT_CDPFTPURL_OLD		0x00000004
#define REVEXT_CDPFILEURL_OLD		0x00000008
#define REVEXT_CDPURLMASK_OLD		0x000000ff
#define REVEXT_CDPENABLE		0x00000100
#define REVEXT_ASPENABLE		0x00000200

#define REVEXT_DEFAULT_NODS		(REVEXT_CDPENABLE)
#define REVEXT_DEFAULT_DS		(REVEXT_CDPENABLE)

// wszREGISSUERCERTURLFLAGS Values:
#define ISSCERT_LDAPURL_OLD		0x00000001
#define ISSCERT_HTTPURL_OLD		0x00000002
#define ISSCERT_FTPURL_OLD		0x00000004
#define ISSCERT_FILEURL_OLD		0x00000008
#define ISSCERT_URLMASK_OLD		0x000000ff
#define ISSCERT_ENABLE			0x00000100

#define ISSCERT_DEFAULT_NODS		(ISSCERT_ENABLE)
#define ISSCERT_DEFAULT_DS		(ISSCERT_ENABLE)

// wszREGEDITFLAGS Values:				   Defaults:
// Under CA key: wszREGCRLEDITFLAGS Values (EDITF_ENABLEAKI* only):
#define EDITF_ENABLEREQUESTEXTENSIONS	0x00000001	// neither
#define EDITF_REQUESTEXTENSIONLIST	0x00000002	// both
#define EDITF_DISABLEEXTENSIONLIST	0x00000004	// both
#define EDITF_ADDOLDKEYUSAGE		0x00000008	// both
#define EDITF_ADDOLDCERTTYPE		0x00000010	// neither
#define EDITF_ATTRIBUTEENDDATE		0x00000020	// Standalone
#define EDITF_BASICCONSTRAINTSCRITICAL	0x00000040	// both
#define EDITF_BASICCONSTRAINTSCA	0x00000080	// Standalone
#define EDITF_ENABLEAKIKEYID		0x00000100	// both
#define EDITF_ATTRIBUTECA		0x00000200	// Standalone
#define EDITF_IGNOREREQUESTERGROUP      0x00000400	// neither
#define EDITF_ENABLEAKIISSUERNAME	0x00000800	// neither
#define EDITF_ENABLEAKIISSUERSERIAL	0x00001000	// neither
#define EDITF_ENABLEAKICRITICAL		0x00002000	// neither
#define EDITF_SERVERUPGRADED		0x00004000	// neither
#define EDITF_ATTRIBUTEEKU		0x00008000	// Standalone
#define EDITF_ENABLEDEFAULTSMIME	0x00010000	// Enterprise
#define EDITF_EMAILOPTIONAL		0x00020000	// neither
#define EDITF_ATTRIBUTESUBJECTALTNAME2	0x00040000	// neither
#define EDITF_ENABLELDAPREFERRALS	0x00080000	// neither
#define EDITF_ENABLECHASECLIENTDC	0x00100000	// Enterprise
#define EDITF_AUDITCERTTEMPLATELOAD	0x00200000	// neither
#define EDITF_DISABLEOLDOSCNUPN         0x00400000	// neither
#define EDITF_DISABLELDAPPACKAGELIST	0x00800000	// neither
#define EDITF_ENABLEUPNMAP		0x01000000	// neither
#define EDITF_ENABLEOCSPREVNOCHECK	0x02000000	// neither
#define EDITF_ALLOWSIGNINGWITHOLDCAKEY	0x04000000	// neither

#define EDITF_DEFAULT_STANDALONE	(EDITF_REQUESTEXTENSIONLIST | \
					 EDITF_DISABLEEXTENSIONLIST | \
					 EDITF_ADDOLDKEYUSAGE | \
					 EDITF_ATTRIBUTEENDDATE | \
					 EDITF_BASICCONSTRAINTSCRITICAL | \
					 EDITF_BASICCONSTRAINTSCA | \
					 EDITF_ENABLEAKIKEYID | \
					 EDITF_ATTRIBUTECA | \
					 EDITF_ATTRIBUTEEKU)

#define EDITF_DEFAULT_ENTERPRISE	(EDITF_REQUESTEXTENSIONLIST | \
					 EDITF_DISABLEEXTENSIONLIST | \
					 EDITF_ADDOLDKEYUSAGE | \
                                         EDITF_BASICCONSTRAINTSCRITICAL | \
                                         EDITF_ENABLEAKIKEYID | \
					 EDITF_ENABLEDEFAULTSMIME | \
					 EDITF_ENABLECHASECLIENTDC)


//======================================================================
// Values Under "CertSvc\Configuration\<CAName>\ExitModules\<ProgId>":

// LDAP based CRL and URL issuance
#define wszREGLDAPREVOCATIONDN_OLD	   TEXT("LDAPRevocationDN")
#define wszREGLDAPREVOCATIONDNTEMPLATE_OLD TEXT("LDAPRevocationDNTemplate")
#define wszCRLPUBLISHRETRYCOUNT    TEXT("CRLPublishRetryCount")
#define wszREGCERTPUBLISHFLAGS     TEXT("PublishCertFlags")

// wszREGCERTPUBLISHFLAGS Values:
#define EXITPUB_FILE			0x00000001
#define EXITPUB_ACTIVEDIRECTORY		0x00000002
#define EXITPUB_REMOVEOLDCERTS		0x00000010

#define EXITPUB_DEFAULT_ENTERPRISE	EXITPUB_ACTIVEDIRECTORY

#define EXITPUB_DEFAULT_STANDALONE	EXITPUB_FILE


#define wszCLASS_CERTADMIN	  TEXT("CertificateAuthority.Admin")
#define wszCLASS_CERTCONFIG	  TEXT("CertificateAuthority.Config")
#define wszCLASS_CERTGETCONFIG	  TEXT("CertificateAuthority.GetConfig")

#define wszCLASS_CERTENCODE	  TEXT("CertificateAuthority.Encode")
#define wszCLASS_CERTREQUEST	  TEXT("CertificateAuthority.Request")
#define wszCLASS_CERTSERVEREXIT   TEXT("CertificateAuthority.ServerExit")
#define wszCLASS_CERTSERVERPOLICY TEXT("CertificateAuthority.ServerPolicy")
#define wszCLASS_CERTVIEW	  TEXT("CertificateAuthority.View")

// class name templates
#define wszMICROSOFTCERTMODULE_PREFIX  TEXT("CertificateAuthority_MicrosoftDefault") 
#define wszCERTMANAGE_SUFFIX TEXT("Manage")
#define wszCERTEXITMODULE_POSTFIX	TEXT(".Exit")
#define wszCERTMANAGEEXIT_POSTFIX	wszCERTEXITMODULE_POSTFIX wszCERTMANAGE_SUFFIX
#define wszCERTPOLICYMODULE_POSTFIX	TEXT(".Policy")
#define wszCERTMANAGEPOLICY_POSTFIX	wszCERTPOLICYMODULE_POSTFIX wszCERTMANAGE_SUFFIX


// actual policy/exit manage class names
#define wszCLASS_CERTMANAGEEXITMODULE   wszMICROSOFTCERTMODULE_PREFIX wszCERTMANAGEEXIT_POSTFIX 

#define wszCLASS_CERTMANAGEPOLICYMODULE wszMICROSOFTCERTMODULE_PREFIX wszCERTMANAGEPOLICY_POSTFIX 

// actual policy/exit class names
#define wszCLASS_CERTEXIT	wszMICROSOFTCERTMODULE_PREFIX wszCERTEXITMODULE_POSTFIX

#define wszCLASS_CERTPOLICY	wszMICROSOFTCERTMODULE_PREFIX wszCERTPOLICYMODULE_POSTFIX


#define wszCAPOLICYFILE			L"CAPolicy.inf"

#define wszINFSECTION_CDP		L"CRLDistributionPoint"
#define wszINFSECTION_AIA		L"AuthorityInformationAccess"
#define wszINFSECTION_EKU		L"EnhancedKeyUsageExtension"
#define wszINFSECTION_CCDP		L"CrossCertificateDistributionPointsExtension"

#define wszINFSECTION_CERTSERVER	L"certsrv_server"
#define wszINFKEY_RENEWALKEYLENGTH	L"RenewalKeyLength"
#define wszINFKEY_RENEWALVALIDITYPERIODSTRING	L"RenewalValidityPeriod"
#define wszINFKEY_RENEWALVALIDITYPERIODCOUNT	L"RenewalValidityPeriodUnits"
#define wszINFKEY_UTF8			L"UTF8"
#define wszINFKEY_CRLPERIODSTRING	wszREGCRLPERIODSTRING
#define wszINFKEY_CRLPERIODCOUNT	wszREGCRLPERIODCOUNT
#define wszINFKEY_CRLDELTAPERIODSTRING	wszREGCRLDELTAPERIODSTRING
#define wszINFKEY_CRLDELTAPERIODCOUNT	wszREGCRLDELTAPERIODCOUNT
#define wszINFKEY_LOADDEFAULTTEMPLATES  L"LoadDefaultTemplates"
#define wszINFKEY_ENABLEKEYCOUNTING     L"EnableKeyCounting"
#define wszINFKEY_FORCEUTF8		L"ForceUTF8"
#define wszINFKEY_ALTERNATESIGNATUREALGORITHM wszREGALTERNATESIGNATUREALGORITHM

#define wszINFKEY_CRITICAL		L"Critical"
#define wszINFKEY_EMPTY			L"Empty"

#define wszINFKEY_CCDPSYNCDELTATIME	L"SyncDeltaTime"

#define wszINFSECTION_CAPOLICY		L"CAPolicy"
#define wszINFSECTION_POLICYSTATEMENT	L"PolicyStatementExtension"
#define wszINFSECTION_APPLICATIONPOLICYSTATEMENT	L"ApplicationPolicyStatementExtension"
#define wszINFKEY_POLICIES		L"Policies"
#define wszINFKEY_OID			L"OID"
#define wszINFKEY_NOTICE		L"Notice"

#define wszINFSECTION_REQUESTATTRIBUTES	L"RequestAttributes"

#define wszINFSECTION_NAMECONSTRAINTS	L"NameConstraintsExtension"
#define wszINFKEY_INCLUDE		L"Include"
#define wszINFKEY_EXCLUDE		L"Exclude"

#define wszINFKEY_UPN			L"UPN"
#define wszINFKEY_EMAIL			L"EMail"
#define wszINFKEY_DNS			L"DNS"
#define wszINFKEY_DIRECTORYNAME		L"DirectoryName"
#define wszINFKEY_URL			L"URL"
#define wszINFKEY_IPADDRESS		L"IPAddress"
#define wszINFKEY_REGISTEREDID		L"RegisteredId"
#define wszINFKEY_OTHERNAME		L"OtherName"

#define wszINFSECTION_POLICYMAPPINGS	L"PolicyMappingsExtension"
#define wszINFSECTION_APPLICATIONPOLICYMAPPINGS	L"ApplicationPolicyMappingsExtension"

#define wszINFSECTION_POLICYCONSTRAINTS	L"PolicyConstraintsExtension"
#define wszINFSECTION_APPLICATIONPOLICYCONSTRAINTS	L"ApplicationPolicyConstraintsExtension"
#define wszINFKEY_REQUIREEXPLICITPOLICY	L"RequireExplicitPolicy"
#define wszINFKEY_INHIBITPOLICYMAPPING	L"InhibitPolicyMapping"

#define wszINFSECTION_BASICCONSTRAINTS	L"BasicConstraintsExtension"
#define wszINFKEY_PATHLENGTH		L"PathLength"

#define wszINFSECTION_EXTENSIONS	L"Extensions"
#define wszINFSECTION_PROPERTIES	L"Properties"

#define wszINFKEY_CONTINUE		L"_continue_"


#define wszINFSECTION_NEWREQUEST	L"NewRequest"
#define wszINFKEY_SUBJECT		L"Subject"
#define wszINFKEY_SUBJECTNAMEFLAGS	L"SubjectNameFlags"
#define wszINFKEY_X500NAMEFLAGS		L"X500NameFlags"
#define wszINFKEY_EXPORTABLE		L"Exportable"
#define wszINFKEY_EXPORTABLEENCRYPTED	L"ExportableEncrypted"
#define wszINFKEY_HASHALGORITHM		L"HashAlgorithm"
#define wszINFKEY_KEYALGORITHM		L"KeyAlgorithm"
#define wszINFKEY_KEYCONTAINER		L"KeyContainer"
#define wszINFKEY_KEYLENGTH		L"KeyLength"
#define wszINFKEY_LEGACYKEYSPEC		L"KeySpec"
#define wszINFKEY_KEYUSAGEEXTENSION	L"KeyUsage"
#define wszINFKEY_KEYUSAGEPROPERTY	L"KeyUsageProperty"
#define wszINFKEY_MACHINEKEYSET		L"MachineKeySet"
#define wszINFKEY_PRIVATEKEYARCHIVE	L"PrivateKeyArchive"
#define wszINFKEY_ENCRYPTIONALGORITHM	L"EncryptionAlgorithm"
#define wszINFKEY_ENCRYPTIONLENGTH	L"EncryptionLength"
#define wszINFKEY_PROVIDERNAME		L"ProviderName"
#define wszINFKEY_PROVIDERTYPE		L"ProviderType"
#define wszINFKEY_RENEWALCERT		L"RenewalCert"
#define wszINFKEY_REQUESTERNAME         wszPROPREQUESTERNAME
#define wszINFKEY_REQUESTTYPE		L"RequestType"
#define wszINFKEY_SECURITYDESCRIPTOR	L"SecurityDescriptor"
// #define wszINFKEY_ALTERNATESIGNATUREALGORITHM wszREGALTERNATESIGNATUREALGORITHM
#define wszINFKEY_SILENT		L"Silent"
#define wszINFKEY_SMIME			L"SMIME"
#define wszINFKEY_SUPPRESSDEFAULTS	L"SuppressDefaults"
#define wszINFKEY_USEEXISTINGKEY	L"UseExistingKeySet"
#define wszINFKEY_USERPROTECTED		L"UserProtected"	// deprecated
#define wszINFKEY_KEYPROTECTION		L"KeyProtection"
#define wszINFKEY_UICONTEXTMESSAGE	L"UIContextMessage"
#define wszINFKEY_FRIENDLYNAME		L"FriendlyName"

#define wszINFVALUE_REQUESTTYPE_PKCS10	L"PKCS10"
#define wszINFVALUE_REQUESTTYPE_PKCS7	L"PKCS7"
#define wszINFVALUE_REQUESTTYPE_CMC	L"CMC"
#define wszINFVALUE_REQUESTTYPE_CERT	L"Cert"


//======================================================================
// Values Under "CertSvc\Configuration\<CAName>\ExitModules\CertificateAuthority_MicrosoftDefault.Exit\SMTP":
//
// exit module mail support
//
#define wszREGEXITSMTPKEY	    	L"SMTP"
#define wszREGEXITSMTPTEMPLATES		L"Templates"
#define wszREGEXITSMTPEVENTFILTER	L"EventFilter"
#define wszREGEXITSMTPSERVER		L"SMTPServer"
#define wszREGEXITSMTPAUTHENTICATE	L"SMTPAuthenticate"

// Subkeys:
#define wszREGEXITDENIEDKEY		L"Denied"
#define wszREGEXITISSUEDKEY		L"Issued"
#define wszREGEXITPENDINGKEY		L"Pending"
#define wszREGEXITREVOKEDKEY		L"Revoked"
#define wszREGEXITCRLISSUEDKEY		L"CRLIssued"
#define wszREGEXITSHUTDOWNKEY		L"Shutdown"
#define wszREGEXITSTARTUPKEY		L"Startup"

//======================================================================
// Values Under 
// "CertSvc\Configuration\<CAName>\ExitModules\CertificateAuthority_MicrosoftDefault.Exit\SMTP\Issued| 
// Pending|Denied|Revoked|CRLIssued|Shutdown":
#define wszREGEXITSMTPFROM		L"From"
#define wszREGEXITSMTPTO		L"To"
#define wszREGEXITSMTPCC		L"Cc"
#define wszREGEXITTITLEFORMAT		L"TitleFormat"
#define wszREGEXITTITLEARG		L"TitleArg"
#define wszREGEXITBODYFORMAT		L"BodyFormat"
#define wszREGEXITBODYARG		L"BodyArg"

#define wszREGEXITPROPNOTFOUND		L"???"


//+--------------------------------------------------------------------------
// Name properties:

#define wszPROPDISTINGUISHEDNAME   TEXT("DistinguishedName")
#define wszPROPRAWNAME             TEXT("RawName")

#define wszPROPCOUNTRY             TEXT("Country")
#define wszPROPORGANIZATION        TEXT("Organization")
#define wszPROPORGUNIT             TEXT("OrgUnit")
#define wszPROPCOMMONNAME          TEXT("CommonName")
#define wszPROPLOCALITY            TEXT("Locality")
#define wszPROPSTATE               TEXT("State")
#define wszPROPTITLE               TEXT("Title")
#define wszPROPGIVENNAME           TEXT("GivenName")
#define wszPROPINITIALS            TEXT("Initials")
#define wszPROPSURNAME             TEXT("SurName")
#define wszPROPDOMAINCOMPONENT     TEXT("DomainComponent")
#define wszPROPEMAIL               TEXT("EMail")
#define wszPROPSTREETADDRESS       TEXT("StreetAddress")
#define wszPROPUNSTRUCTUREDNAME    TEXT("UnstructuredName")
#define wszPROPUNSTRUCTUREDADDRESS TEXT("UnstructuredAddress")
#define wszPROPDEVICESERIALNUMBER  TEXT("DeviceSerialNumber")

//+--------------------------------------------------------------------------
// Subject Name properties:

#define wszPROPSUBJECTDOT	    TEXT("Subject.")
#define wszPROPSUBJECTDISTINGUISHEDNAME \
				    wszPROPSUBJECTDOT wszPROPDISTINGUISHEDNAME
#define wszPROPSUBJECTRAWNAME       wszPROPSUBJECTDOT wszPROPRAWNAME

#define wszPROPSUBJECTCOUNTRY       wszPROPSUBJECTDOT wszPROPCOUNTRY
#define wszPROPSUBJECTORGANIZATION  wszPROPSUBJECTDOT wszPROPORGANIZATION
#define wszPROPSUBJECTORGUNIT       wszPROPSUBJECTDOT wszPROPORGUNIT
#define wszPROPSUBJECTCOMMONNAME    wszPROPSUBJECTDOT wszPROPCOMMONNAME
#define wszPROPSUBJECTLOCALITY      wszPROPSUBJECTDOT wszPROPLOCALITY
#define wszPROPSUBJECTSTATE         wszPROPSUBJECTDOT wszPROPSTATE
#define wszPROPSUBJECTTITLE	    wszPROPSUBJECTDOT wszPROPTITLE
#define wszPROPSUBJECTGIVENNAME	    wszPROPSUBJECTDOT wszPROPGIVENNAME
#define wszPROPSUBJECTINITIALS	    wszPROPSUBJECTDOT wszPROPINITIALS
#define wszPROPSUBJECTSURNAME	    wszPROPSUBJECTDOT wszPROPSURNAME
#define wszPROPSUBJECTDOMAINCOMPONENT wszPROPSUBJECTDOT wszPROPDOMAINCOMPONENT
#define wszPROPSUBJECTEMAIL	    wszPROPSUBJECTDOT wszPROPEMAIL
#define wszPROPSUBJECTSTREETADDRESS wszPROPSUBJECTDOT wszPROPSTREETADDRESS
#define wszPROPSUBJECTUNSTRUCTUREDNAME wszPROPSUBJECTDOT wszPROPUNSTRUCTUREDNAME
#define wszPROPSUBJECTUNSTRUCTUREDADDRESS wszPROPSUBJECTDOT wszPROPUNSTRUCTUREDADDRESS
#define wszPROPSUBJECTDEVICESERIALNUMBER wszPROPSUBJECTDOT wszPROPDEVICESERIALNUMBER


//+--------------------------------------------------------------------------
// Request properties:
#define wszPROPREQUESTDOT	            TEXT("Request.")

#define wszPROPREQUESTREQUESTID		    TEXT("RequestID")
#define wszPROPREQUESTRAWREQUEST	    TEXT("RawRequest")
#define wszPROPREQUESTRAWARCHIVEDKEY	    TEXT("RawArchivedKey")
#define wszPROPREQUESTARCHIVEDKEY	    TEXT("ArchivedKey")	// constructed
#define wszPROPREQUESTKEYRECOVERYHASHES	    TEXT("KeyRecoveryHashes")
#define wszPROPREQUESTRAWOLDCERTIFICATE	    TEXT("RawOldCertificate")
#define wszPROPREQUESTATTRIBUTES	    TEXT("RequestAttributes")
#define wszPROPREQUESTTYPE		    TEXT("RequestType")
#define wszPROPREQUESTFLAGS		    TEXT("RequestFlags")
#define wszPROPREQUESTSTATUSCODE	    TEXT("StatusCode")
#define wszPROPREQUESTDISPOSITION	    TEXT("Disposition")
#define wszPROPREQUESTDISPOSITIONMESSAGE    TEXT("DispositionMessage")
#define wszPROPREQUESTSUBMITTEDWHEN	    TEXT("SubmittedWhen")
#define wszPROPREQUESTRESOLVEDWHEN	    TEXT("ResolvedWhen")
#define wszPROPREQUESTREVOKEDWHEN	    TEXT("RevokedWhen")
#define wszPROPREQUESTREVOKEDEFFECTIVEWHEN  TEXT("RevokedEffectiveWhen")
#define wszPROPREQUESTREVOKEDREASON	    TEXT("RevokedReason")
#define wszPROPREQUESTERNAME		    TEXT("RequesterName")
#define wszPROPCALLERNAME		    TEXT("CallerName")
#define wszPROPSIGNERPOLICIES		    TEXT("SignerPolicies")
#define wszPROPSIGNERAPPLICATIONPOLICIES    TEXT("SignerApplicationPolicies")
#define wszPROPOFFICER			    TEXT("Officer")

//+--------------------------------------------------------------------------
// Request attribute properties:

#define wszPROPCHALLENGE		TEXT("Challenge")
#define wszPROPEXPECTEDCHALLENGE	TEXT("ExpectedChallenge")

#define wszPROPDISPOSITION		TEXT("Disposition")
#define wszPROPDISPOSITIONDENY		TEXT("Deny")
#define wszPROPDISPOSITIONPENDING	TEXT("Pending")

#define wszPROPVALIDITYPERIODSTRING	TEXT("ValidityPeriod")
#define wszPROPVALIDITYPERIODCOUNT	TEXT("ValidityPeriodUnits")
#define wszPROPEXPIRATIONDATE           TEXT("ExpirationDate")

#define wszPROPCERTTYPE			TEXT("CertType")
#define wszPROPCERTTEMPLATE		TEXT("CertificateTemplate")
#define wszPROPCERTUSAGE		TEXT("CertificateUsage")

#define wszPROPREQUESTOSVERSION		TEXT("RequestOSVersion")
#define wszPROPREQUESTCSPPROVIDER       TEXT("RequestCSPProvider")

#define wszPROPEXITCERTFILE		TEXT("CertFile")
#define wszPROPCLIENTBROWSERMACHINE	TEXT("cbm")
#define wszPROPCERTCLIENTMACHINE	TEXT("ccm")
#define wszPROPCLIENTDCDNS		L"cdc"
#define wszPROPREQUESTMACHINEDNS	L"rmd"
#define wszPROPSUBJECTALTNAME2		TEXT("san")
#define wszPROPDNS			TEXT("dns")
#define wszPROPDN			TEXT("dn")
#define wszPROPURL			TEXT("url")
#define wszPROPIPADDRESS		TEXT("ipaddress")
#define wszPROPGUID			TEXT("guid")
#define wszPROPOID			TEXT("oid")
#define wszPROPUPN			TEXT("upn")
#define wszPROPUPN			TEXT("upn")

#define szPROPASNTAG			"{asn}"

#define wszPROPUTF8TAG			TEXT("{utf8}")
#define wszPROPOCTETTAG			TEXT("{octet}")
#define wszPROPHEXTAG			TEXT("{hex}")
#define wszPROPASNTAG			TEXT(szPROPASNTAG)
#define wszPROPTEXTTAG			TEXT("{text}")


//+--------------------------------------------------------------------------
// "System" properties
// ".#" means ".0", ".1", ".2" ... may be appended to the property name to
// collect context specific values.  For some properties, the suffix selects
// the CA certificate context.  For others, it selects the the CA CRL context.

#define wszPROPCATYPE                   TEXT("CAType")
#define wszPROPSANITIZEDCANAME          TEXT("SanitizedCAName")
#define wszPROPSANITIZEDSHORTNAME       TEXT("SanitizedShortName")
#define wszPROPMACHINEDNSNAME           TEXT("MachineDNSName")
#define wszPROPMODULEREGLOC             TEXT("ModuleRegistryLocation")
#define wszPROPUSEDS                    TEXT("fUseDS")
#define wszPROPDELTACRLSDISABLED        TEXT("fDeltaCRLsDisabled")
#define wszPROPSERVERUPGRADED           TEXT("fServerUpgraded")
#define wszPROPCONFIGDN			TEXT("ConfigDN")
#define wszPROPDOMAINDN			TEXT("DomainDN")
#define wszPROPLOGLEVEL			TEXT("LogLevel")
#define wszPROPSESSIONCOUNT		TEXT("SessionCount")
#define wszPROPTEMPLATECHANGESEQUENCENUMBER TEXT("TemplateChangeSequenceNumber")

// ".#" suffix for ENUM_PERIOD_SECONDS, ... ENUM_PERIOD_YEARS
#define wszLOCALIZEDTIMEPERIODUNITS	TEXT("LocalizedTimePeriodUnits")

// Request Context properties:

#define wszPROPREQUESTERCAACCESS	TEXT("RequesterCAAccess")
#define wszPROPUSERDN			TEXT("UserDN")
#define wszPROPKEYARCHIVED		TEXT("KeyArchived")


// CA Certificate properties: (all ".#" extensible except wszPROPCERTCOUNT)

#define wszPROPCERTCOUNT                TEXT("CertCount")
#define wszPROPRAWCACERTIFICATE         TEXT("RawCACertificate")
#define wszPROPCERTSTATE                TEXT("CertState")
#define wszPROPCERTSUFFIX               TEXT("CertSuffix")

// CA CRL properties: (all ".#" extensible)

#define wszPROPRAWCRL                   TEXT("RawCRL")
#define wszPROPRAWDELTACRL              TEXT("RawDeltaCRL")
#define wszPROPCRLINDEX                 TEXT("CRLIndex")
#define wszPROPCRLSTATE                 TEXT("CRLState")
#define wszPROPCRLSUFFIX                TEXT("CRLSuffix")

// Values for wszPROPCERTSTATE (see certadm.h):
//   CA_DISP_REVOKED    // This Cert has been revoked.
//   CA_DISP_VALID      // This Cert is still valid
//   CA_DISP_INVALID    // This Cert has expired.
//   CA_DISP_ERROR      // Cert unavailable (placehholder in registry?)

// Values for wszPROPCRLSTATE (see certadm.h):
//   CA_DISP_REVOKED	// All unexpired certs using this Cert's CRL have been
//			// revoked.
//   CA_DISP_VALID	// This Cert is still publishing CRLs as needed.
//   CA_DISP_INVALID    // All certs using this Cert's CRL are expired.
//   CA_DISP_ERROR      // This Cert's CRL is managed by another Cert.

// "Settable" system properties:
#define wszPROPEVENTLOGTERSE		TEXT("EventLogTerse")
#define wszPROPEVENTLOGERROR		TEXT("EventLogError")
#define wszPROPEVENTLOGWARNING		TEXT("EventLogWarning")
#define wszPROPEVENTLOGVERBOSE		TEXT("EventLogVerbose")
#define wszPROPEVENTLOGEXHAUSTIVE	TEXT("EventLogExhaustive")
#define wszPROPDCNAME			TEXT("DCName")

// "Settable" system properties (".#" extensible)
#define wszPROPSEAUDITID		TEXT("SEAuditId")

// "Fetchable" system properties
#define wszPROPSEAUDITFILTER		TEXT("SEAuditFilter")

//+--------------------------------------------------------------------------
// Certificate properties:

#define wszPROPCERTIFICATEREQUESTID	       TEXT("RequestID")
#define wszPROPRAWCERTIFICATE		       TEXT("RawCertificate")
#define wszPROPCERTIFICATEHASH		       TEXT("CertificateHash")
#define wszPROPCERTIFICATETEMPLATE	       TEXT("CertificateTemplate")
#define wszPROPCERTIFICATEENROLLMENTFLAGS      TEXT("EnrollmentFlags")
#define wszPROPCERTIFICATEGENERALFLAGS         TEXT("GeneralFlags")
#define wszPROPCERTIFICATESERIALNUMBER	       TEXT("SerialNumber")
#define wszPROPCERTIFICATENOTBEFOREDATE	       TEXT("NotBefore")
#define wszPROPCERTIFICATENOTAFTERDATE	       TEXT("NotAfter")
#define wszPROPCERTIFICATESUBJECTKEYIDENTIFIER TEXT("SubjectKeyIdentifier")
#define wszPROPCERTIFICATERAWPUBLICKEY	       TEXT("RawPublicKey")
#define wszPROPCERTIFICATEPUBLICKEYLENGTH      TEXT("PublicKeyLength")
#define wszPROPCERTIFICATEPUBLICKEYALGORITHM   TEXT("PublicKeyAlgorithm")
#define wszPROPCERTIFICATERAWPUBLICKEYALGORITHMPARAMETERS \
    TEXT("RawPublicKeyAlgorithmParameters")
#define wszPROPCERTIFICATEUPN		       TEXT("UPN")

// Obsolete:
#define wszPROPCERTIFICATETYPE		       TEXT("CertificateType")
#define wszPROPCERTIFICATERAWSMIMECAPABILITIES TEXT("RawSMIMECapabilities")
#define wszPROPNAMETYPE			       TEXT("NameType")

//+--------------------------------------------------------------------------
// Certificate extension properties:

#define EXTENSION_CRITICAL_FLAG	      0x00000001
#define EXTENSION_DISABLE_FLAG	      0x00000002
#define EXTENSION_POLICY_MASK	      0x0000ffff // Settable by admin+policy

#define EXTENSION_ORIGIN_REQUEST      0x00010000
#define EXTENSION_ORIGIN_POLICY	      0x00020000
#define EXTENSION_ORIGIN_ADMIN	      0x00030000
#define EXTENSION_ORIGIN_SERVER	      0x00040000
#define EXTENSION_ORIGIN_RENEWALCERT  0x00050000
#define EXTENSION_ORIGIN_IMPORTEDCERT 0x00060000
#define EXTENSION_ORIGIN_PKCS7	      0x00070000
#define EXTENSION_ORIGIN_CMC	      0x00080000
#define EXTENSION_ORIGIN_CACERT       0x00090000
#define EXTENSION_ORIGIN_MASK	      0x000f0000

//+--------------------------------------------------------------------------
// Extension properties:

#define wszPROPEXTREQUESTID		TEXT("ExtensionRequestId")
#define wszPROPEXTNAME			TEXT("ExtensionName")
#define wszPROPEXTFLAGS			TEXT("ExtensionFlags")
#define wszPROPEXTRAWVALUE		TEXT("ExtensionRawValue")

//+--------------------------------------------------------------------------
// Attribute properties:

#define wszPROPATTRIBREQUESTID		TEXT("AttributeRequestId")
#define wszPROPATTRIBNAME		TEXT("AttributeName")
#define wszPROPATTRIBVALUE		TEXT("AttributeValue")

//+--------------------------------------------------------------------------
// CRL properties:

#define wszPROPCRLROWID			TEXT("CRLRowId")
#define wszPROPCRLNUMBER		TEXT("CRLNumber")
#define wszPROPCRLMINBASE		TEXT("CRLMinBase") // Delta CRLs only
#define wszPROPCRLNAMEID		TEXT("CRLNameId")
#define wszPROPCRLCOUNT			TEXT("CRLCount")
#define wszPROPCRLTHISUPDATE		TEXT("CRLThisUpdate")
#define wszPROPCRLNEXTUPDATE		TEXT("CRLNextUpdate")
#define wszPROPCRLTHISPUBLISH		TEXT("CRLThisPublish")
#define wszPROPCRLNEXTPUBLISH		TEXT("CRLNextPublish")
#define wszPROPCRLEFFECTIVE		TEXT("CRLEffective")
#define wszPROPCRLPROPAGATIONCOMPLETE	TEXT("CRLPropagationComplete")
#define wszPROPCRLLASTPUBLISHED		TEXT("CRLLastPublished")
#define wszPROPCRLPUBLISHATTEMPTS	TEXT("CRLPublishAttempts")
#define wszPROPCRLPUBLISHFLAGS		TEXT("CRLPublishFlags")
#define wszPROPCRLPUBLISHSTATUSCODE	TEXT("CRLPublishStatusCode")
#define wszPROPCRLPUBLISHERROR		TEXT("CRLPublishError")
#define wszPROPCRLRAWCRL		TEXT("CRLRawCRL")

//+--------------------------------------------------------------------------
// CRL Published Flags:

#define CPF_BASE		0x00000001
#define CPF_DELTA		0x00000002
#define CPF_COMPLETE		0x00000004
#define CPF_SHADOW		0x00000008
#define CPF_CASTORE_ERROR	0x00000010
#define CPF_BADURL_ERROR	0x00000020
#define CPF_MANUAL		0x00000040
#define CPF_SIGNATURE_ERROR	0x00000080
#define CPF_LDAP_ERROR		0x00000100
#define CPF_FILE_ERROR		0x00000200
#define CPF_FTP_ERROR		0x00000400
#define CPF_HTTP_ERROR		0x00000800
#define CPF_POSTPONED_BASE_LDAP_ERROR	0x00001000
#define CPF_POSTPONED_BASE_FILE_ERROR	0x00002000

//+--------------------------------------------------------------------------
// GetProperty/SetProperty Flags:
//
// Choose one Type

#define PROPTYPE_LONG		 0x00000001	// Signed long
#define PROPTYPE_DATE		 0x00000002	// Date+Time
#define PROPTYPE_BINARY		 0x00000003	// Binary data
#define PROPTYPE_STRING		 0x00000004	// Unicode String
#define PROPTYPE_MASK		 0x000000ff

// Choose one Caller:

#define PROPCALLER_SERVER	 0x00000100
#define PROPCALLER_POLICY	 0x00000200
#define PROPCALLER_EXIT		 0x00000300
#define PROPCALLER_ADMIN	 0x00000400
#define PROPCALLER_REQUEST	 0x00000500
#define PROPCALLER_MASK		 0x00000f00
#define PROPFLAGS_INDEXED	 0x00010000	

// RequestFlags definitions:

#define CR_FLG_FORCETELETEX	 	0x00000001
#define CR_FLG_RENEWAL		 	0x00000002
#define CR_FLG_FORCEUTF8	 	0x00000004
#define CR_FLG_CAXCHGCERT	 	0x00000008
#define CR_FLG_ENROLLONBEHALFOF	 	0x00000010
#define CR_FLG_SUBJECTUNMODIFIED 	0x00000020
#define CR_FLG_VALIDENCRYPTEDKEYHASH	0x00000040
#define CR_FLG_CACROSSCERT		0x00000080
#define CR_FLG_ENFORCEUTF8              0x00000100
#define CR_FLG_PUBLISHERROR		0x80000000

// Disposition property values:

// Disposition values for requests in the queue:
#define DB_DISP_ACTIVE	        8	// being processed
#define DB_DISP_PENDING		9	// taken under submission
#define DB_DISP_QUEUE_MAX	9	// max disposition value for queue view

#define DB_DISP_FOREIGN		12	// archived foreign cert

#define DB_DISP_CA_CERT		15	// CA cert
#define DB_DISP_CA_CERT_CHAIN	16	// CA cert chain
#define DB_DISP_KRA_CERT	17	// KRA cert

// Disposition values for requests in the log:
#define DB_DISP_LOG_MIN		20	// min disposition value for log view
#define DB_DISP_ISSUED		20	// cert issued
#define DB_DISP_REVOKED	        21	// issued and revoked

// Disposition values for failed requests in the log:
#define DB_DISP_LOG_FAILED_MIN	30	// min disposition value for log view
#define DB_DISP_ERROR		30	// request failed
#define DB_DISP_DENIED		31	// request denied


// VerifyRequest() return values

#define VR_PENDING	0	 // request will be accepted or denied later
#define VR_INSTANT_OK	1	 // request was accepted
#define VR_INSTANT_BAD	2	 // request was rejected


//+--------------------------------------------------------------------------
// Known request Attribute names and Value strings

// RequestType attribute name:
#define wszCERT_TYPE		L"RequestType"	// attribute name

// RequestType attribute values:
// Not specified: 				// Non-specific certificate
#define wszCERT_TYPE_CLIENT	L"Client"	// Client authentication cert
#define wszCERT_TYPE_SERVER	L"Server"	// Server authentication cert
#define wszCERT_TYPE_CODESIGN	L"CodeSign"	// Code signing certificate
#define wszCERT_TYPE_CUSTOMER	L"SetCustomer"	// SET Customer certificate
#define wszCERT_TYPE_MERCHANT	L"SetMerchant"	// SET Merchant certificate
#define wszCERT_TYPE_PAYMENT	L"SetPayment"	// SET Payment certificate


// Version attribute name:
#define wszCERT_VERSION		L"Version"	// attribute name

// Version attribute values:
// Not specified: 				// Whetever is current
#define wszCERT_VERSION_1	L"1"		// Version one certificate
#define wszCERT_VERSION_2	L"2"		// Version two certificate
#define wszCERT_VERSION_3	L"3"		// Version three certificate

#endif // _CERTSRV_H_
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\vs9sp1\sdk\include\clfslsn.h ===
/*=============================================================================

    Copyright (c) 1998  Microsoft Corporation

    Module Name:

        clfslsn.h

    Abstract:

        Header file containing the private definition for the common log
        file system's log sequence number structure.

    Author:

        Dexter Bradshaw    [DexterB]   09-Dec-1998


    Revision History:

=============================================================================*/

#ifndef _CLFS_LSN_H_
#define _CLFS_LSN_H_


#if (NTDDI_VERSION >= NTDDI_WS03SP1) || (_WIN32_WINNT >= _WIN32_WINNT_WS03)
//
// CLFS_RECORD_INDEX
//
// Log record offset on container file.  The log record offset consists of a block
// offset in the container and a bucket identifier indexing the records in the block.
// Declared up here because including clfs_x.h will try to define the LSN, which needs
// this.
//

typedef UINT32                      CLFS_RECORD_INDEX;
#endif /* NTDDI_VERSION || _WIN32_WINNT */


#if (NTDDI_VERSION >= NTDDI_WS03SP1) || (_WIN32_WINNT >= _WIN32_WINNT_WS03)
//
// CLS_LSN
//
// The log sequence number (LSN) is a valid log file address.  The LSN consists of
// three (3) parts: (a) a log identifier to identify which physical log the log record
// belongs to, (b) a container index identifying the log container where the log record
// lies, and (c) a record offset identified by the offset of the block in the container
// and an ordinal number for the record within the container.
//
//
// The structure of the LSN poses some inherent limitations of the number of logs,
// the number of containers, the size of a container, and the number of log records in
// a log block.
//
//          Maximum number of physical log files is 64K.
//          Maximum number of container identifiers is 4G.
//          Maximum size of a container is 4G.
//          Maximum number of sector-aligned log blocks is 8M
//          Maximum number of record buckets in a log block is 512
//

typedef union _CLS_LSN
{
    //
    // Container identifier
    //

    struct
    {
       CLFS_RECORD_INDEX   idxRecord;      // Record offset on container.
       CLFS_CONTAINER_ID   cidContainer;   // Container identifier.
    } offset;
    
    __volatile ULONGLONG               ullOffset;      // Sequence number within physical log.

} CLS_LSN, *PCLS_LSN, **PPCLS_LSN;

//
// Alias CLS prefixed types with CLFS prefixes.
//

typedef CLS_LSN CLFS_LSN;
typedef CLFS_LSN *PCLFS_LSN, **PPCLFS_LSN;
#endif /* NTDDI_VERSION || _WIN32_WINNT */

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\vs9sp1\sdk\include\cfgmgr32.h ===
/*++

Copyright (c) Microsoft Corporation.  All rights reserved.

Module Name:

    cfgmgr32.h

Abstract:

    This module contains the user APIs for the Configuration Manager,
    along with any public data structures needed to call these APIs.

--*/

#ifndef _CFGMGR32_H_
#define _CFGMGR32_H_

#if _MSC_VER > 1000
#pragma once
#endif

#include <cfg.h>

#ifndef GUID_DEFINED
#include <guiddef.h>
#endif /* GUID_DEFINED */

#ifdef __cplusplus
extern "C" {
#endif

#if !defined (_CFGMGR32_)
#define CMAPI     DECLSPEC_IMPORT
#else
#define CMAPI
#endif

typedef  CONST VOID *PCVOID;

//--------------------------------------------------------------
// General size definitions
//--------------------------------------------------------------

#define MAX_DEVICE_ID_LEN     200
#define MAX_DEVNODE_ID_LEN    MAX_DEVICE_ID_LEN

#define MAX_GUID_STRING_LEN   39          // 38 chars + terminator null
#define MAX_CLASS_NAME_LEN    32
#define MAX_PROFILE_LEN       80

#define MAX_CONFIG_VALUE      9999
#define MAX_INSTANCE_VALUE    9999

#define MAX_MEM_REGISTERS     9     // Win95 compatibility--not applicable to 32-bit ConfigMgr
#define MAX_IO_PORTS          20    // Win95 compatibility--not applicable to 32-bit ConfigMgr
#define MAX_IRQS              7     // Win95 compatibility--not applicable to 32-bit ConfigMgr
#define MAX_DMA_CHANNELS      7     // Win95 compatibility--not applicable to 32-bit ConfigMgr

#define DWORD_MAX             0xffffffffUL
#define DWORDLONG_MAX         0xffffffffffffffffui64

#define CONFIGMG_VERSION      0x0400

//--------------------------------------------------------------
// Data types
//--------------------------------------------------------------

#ifdef NT_INCLUDED

typedef unsigned __int64 DWORDLONG;
typedef DWORDLONG *PDWORDLONG;

#endif /* NT_INCLUDED */

//
// Standardized Return Value data type
//
typedef DWORD        RETURN_TYPE;
typedef RETURN_TYPE  CONFIGRET;

//
// Device Instance Handle data type
//
typedef DWORD       DEVNODE, DEVINST;
typedef DEVNODE    *PDEVNODE, *PDEVINST;

//
// Device Instance Identifier data type
// The device instance ID specifies the registry path, relative to the
// Enum key , for a device instance.  For example:  \Root\*PNP0500\0000.
//
typedef __nullterminated CHAR  *DEVNODEID_A, *DEVINSTID_A; // Device ID ANSI name.
typedef __nullterminated WCHAR *DEVNODEID_W, *DEVINSTID_W; // Device ID Unicode name.
#ifdef UNICODE
typedef DEVNODEID_W DEVNODEID;
typedef DEVINSTID_W DEVINSTID;
#else
typedef DEVNODEID_A DEVNODEID;
typedef DEVINSTID_A DEVINSTID;
#endif

//
// Logical Configuration Handle data type
//
typedef DWORD_PTR      LOG_CONF;
typedef LOG_CONF      *PLOG_CONF;

//
// Resource Descriptor Handle data type
//
typedef DWORD_PTR      RES_DES;
typedef RES_DES       *PRES_DES;

//
// Resource ID data type (may take any of the ResType_* values)
//
typedef ULONG          RESOURCEID;
typedef RESOURCEID    *PRESOURCEID;

//
// Priority data type (may take any of the LCPRI_* values)
//
typedef ULONG          PRIORITY;
typedef PRIORITY      *PPRIORITY;

//
// Range List Handle data type
//
typedef DWORD_PTR      RANGE_LIST;
typedef RANGE_LIST    *PRANGE_LIST;

//
// Range Element Handle data type
//
typedef DWORD_PTR      RANGE_ELEMENT;
typedef RANGE_ELEMENT *PRANGE_ELEMENT;

//
// Machine Handle data type
//
typedef  HANDLE        HMACHINE;
typedef  HMACHINE     *PHMACHINE;

//
// Conflict List data types
//
typedef ULONG_PTR      CONFLICT_LIST;
typedef CONFLICT_LIST *PCONFLICT_LIST;

typedef struct _CONFLICT_DETAILS_A {
    ULONG       CD_ulSize;                   // size of structure, ie: sizeof(CONFLICT_DETAILS)
    ULONG       CD_ulMask;                   // indicates what information is required/valid
    DEVINST     CD_dnDevInst;                // filled with DevInst of conflicting device if CM_CDMASK_DEVINST set
    RES_DES     CD_rdResDes;                 // filled with a ResDes of conflict if CM_CDMASK_RESDES set
    ULONG       CD_ulFlags;                  // various flags regarding conflict
    CHAR        CD_szDescription[MAX_PATH];  // description of conflicting device
} CONFLICT_DETAILS_A , *PCONFLICT_DETAILS_A;

typedef struct _CONFLICT_DETAILS_W {
    ULONG       CD_ulSize;                   // size of structure, ie: sizeof(CONFLICT_DETAILS)
    ULONG       CD_ulMask;                   // indicates what information is required/valid
    DEVINST     CD_dnDevInst;                // filled with DevInst of conflicting device if CM_CDMASK_DEVINST set
    RES_DES     CD_rdResDes;                 // filled with a ResDes of conflict if CM_CDMASK_RESDES set
    ULONG       CD_ulFlags;                  // various flags regarding conflict
    WCHAR       CD_szDescription[MAX_PATH];  // description of conflicting device
} CONFLICT_DETAILS_W , *PCONFLICT_DETAILS_W;

#ifdef UNICODE
typedef CONFLICT_DETAILS_W CONFLICT_DETAILS;
typedef PCONFLICT_DETAILS_W PCONFLICT_DETAILS;
#else
typedef CONFLICT_DETAILS_A CONFLICT_DETAILS;
typedef PCONFLICT_DETAILS_A PCONFLICT_DETAILS;
#endif

#define CM_CDMASK_DEVINST      (0x00000001)   // mask to retrieve CD_dnDevInst attribute for conflict
#define CM_CDMASK_RESDES       (0x00000002)   // mask to retrieve CD_rdResDes attribute for conflict
#define CM_CDMASK_FLAGS        (0x00000004)   // mask to retrieve CD_ulFlags attribute for conflict
#define CM_CDMASK_DESCRIPTION  (0x00000008)   // mask to retrieve CD_szDescription attribute for conflict
#define CM_CDMASK_VALID        (0x0000000F)   // valid bits

#define CM_CDFLAGS_DRIVER      (0x00000001)     // CD_ulFlags: CD_szDescription reports back legacy driver name
#define CM_CDFLAGS_ROOT_OWNED  (0x00000002)     // CD_ulFlags: Root owned device
#define CM_CDFLAGS_RESERVED    (0x00000004)     // CD_ulFlags: Specified range is not available for use

typedef  ULONG             REGDISPOSITION;

//
// use 1 byte packing for the data structures
//
#include "pshpack1.h"

//--------------------------------------------------------------
// Memory resource
//--------------------------------------------------------------

//
// Define the attribute flags for memory ranges.  Each bit flag is
// identified by a constant bitmask.  Following the bitmask definition,
// are the two possible values.
//
#define mMD_MemoryType              (0x1) // Bitmask, whether memory is writable
#define fMD_MemoryType              mMD_MemoryType // compatibility
#define fMD_ROM                     (0x0) // Memory range is read-only
#define fMD_RAM                     (0x1) // Memory range may be written to

#define mMD_32_24                   (0x2) // Bitmask, memory is 24 or 32-bit
#define fMD_32_24                   mMD_32_24 // compatibility
#define fMD_24                      (0x0) // Memory range is 24-bit
#define fMD_32                      (0x2) // Memory range is 32-bit

#define mMD_Prefetchable            (0x4) // Bitmask,whether memory prefetchable
#define fMD_Prefetchable            mMD_Prefetchable // compatibility
#define fMD_Pref                    mMD_Prefetchable // compatibility
#define fMD_PrefetchDisallowed      (0x0) // Memory range is not prefetchable
#define fMD_PrefetchAllowed         (0x4) // Memory range is prefetchable

#define mMD_Readable                (0x8) // Bitmask,whether memory is readable
#define fMD_Readable                mMD_Readable // compatibility
#define fMD_ReadAllowed             (0x0) // Memory range is readable
#define fMD_ReadDisallowed          (0x8) // Memory range is write-only

#define mMD_CombinedWrite           (0x10) // Bitmask,supports write-behind
#define fMD_CombinedWrite           mMD_CombinedWrite // compatibility
#define fMD_CombinedWriteDisallowed (0x0)  // no combined-write caching
#define fMD_CombinedWriteAllowed    (0x10) // supports combined-write caching

#define mMD_Cacheable               (0x20) // Bitmask,whether memory is cacheable
#define fMD_NonCacheable            (0x0)  // Memory range is non-cacheable
#define fMD_Cacheable               (0x20) // Memory range is cacheable

#define fMD_WINDOW_DECODE           (0x40) // Memory range is bridge window decode.
#define fMD_MEMORY_BAR              (0x80) // Memory BAR resource.

//
// MEM_RANGE Structure
//
typedef struct Mem_Range_s {
   DWORDLONG MR_Align;     // specifies mask for base alignment
   ULONG     MR_nBytes;    // specifies number of bytes required
   DWORDLONG MR_Min;       // specifies minimum address of the range
   DWORDLONG MR_Max;       // specifies maximum address of the range
   DWORD     MR_Flags;     // specifies flags describing range (fMD flags)
   DWORD     MR_Reserved;
} MEM_RANGE, *PMEM_RANGE;

//
// MEM_DES structure
//
typedef struct Mem_Des_s {
   DWORD     MD_Count;        // number of MEM_RANGE structs in MEM_RESOURCE
   DWORD     MD_Type;         // size (in bytes) of MEM_RANGE (MType_Range)
   DWORDLONG MD_Alloc_Base;   // base memory address of range allocated
   DWORDLONG MD_Alloc_End;    // end of allocated range
   DWORD     MD_Flags;        // flags describing allocated range (fMD flags)
   DWORD     MD_Reserved;
} MEM_DES, *PMEM_DES;

//
// MEM_RESOURCE structure
//
typedef struct Mem_Resource_s {
   MEM_DES   MEM_Header;               // info about memory range list
   MEM_RANGE MEM_Data[ANYSIZE_ARRAY];  // list of memory ranges
} MEM_RESOURCE, *PMEM_RESOURCE;

//
// Define the size of each range structure
//
#define MType_Range     sizeof(struct Mem_Range_s)

//--------------------------------------------------------------
// I/O Port Resource
//--------------------------------------------------------------

//
// Define the attribute flags for port resources.  Each bit flag is
// identified by a constant bitmask.  Following the bitmask definition,
// are the two possible values.
//
#define fIOD_PortType   (0x1) // Bitmask,whether port is IO or memory
#define fIOD_Memory     (0x0) // Port resource really uses memory
#define fIOD_IO         (0x1) // Port resource uses IO ports
#define fIOD_DECODE     (0x00fc) // decode flags
#define fIOD_10_BIT_DECODE    (0x0004)
#define fIOD_12_BIT_DECODE    (0x0008)
#define fIOD_16_BIT_DECODE    (0x0010)
#define fIOD_POSITIVE_DECODE  (0x0020)
#define fIOD_PASSIVE_DECODE   (0x0040)
#define fIOD_WINDOW_DECODE    (0x0080)
#define fIOD_PORT_BAR         (0x0100)

//
// these are for compatiblity
//
#define IO_ALIAS_10_BIT_DECODE      (0x00000004)
#define IO_ALIAS_12_BIT_DECODE      (0x00000010)
#define IO_ALIAS_16_BIT_DECODE      (0x00000000)
#define IO_ALIAS_POSITIVE_DECODE    (0x000000FF)

//
// IO_RANGE structure
//
typedef struct IO_Range_s {
   DWORDLONG IOR_Align;      // mask for base alignment
   DWORD     IOR_nPorts;     // number of ports
   DWORDLONG IOR_Min;        // minimum port address
   DWORDLONG IOR_Max;        // maximum port address
   DWORD     IOR_RangeFlags; // flags for this port range
   DWORDLONG IOR_Alias;      // multiplier that generates aliases for port(s)
} IO_RANGE, *PIO_RANGE;

//
// IO_DES structure
//
typedef struct IO_Des_s {
   DWORD     IOD_Count;          // number of IO_RANGE structs in IO_RESOURCE
   DWORD     IOD_Type;           // size (in bytes) of IO_RANGE (IOType_Range)
   DWORDLONG IOD_Alloc_Base;     // base of allocated port range
   DWORDLONG IOD_Alloc_End;      // end of allocated port range
   DWORD     IOD_DesFlags;       // flags relating to allocated port range
} IO_DES, *PIO_DES;

//
// IO_RESOURCE
//
typedef struct IO_Resource_s {
   IO_DES   IO_Header;                 // info about I/O port range list
   IO_RANGE IO_Data[ANYSIZE_ARRAY];    // list of I/O port ranges
} IO_RESOURCE, *PIO_RESOURCE;

#define IOA_Local       0xff

//
// Define the size of each range structure
//
#define IOType_Range    sizeof(struct IO_Range_s)

//--------------------------------------------------------------
// DMA Resource
//--------------------------------------------------------------

//
// Define the attribute flags for a DMA resource range.  Each bit flag is
// identified with a constant bitmask.  Following the bitmask definition
// are the possible values.
//
#define mDD_Width         (0x3)    // Bitmask, width of the DMA channel:
#define fDD_BYTE          (0x0)    //   8-bit DMA channel
#define fDD_WORD          (0x1)    //   16-bit DMA channel
#define fDD_DWORD         (0x2)    //   32-bit DMA channel
#define fDD_BYTE_AND_WORD (0x3)    //   8-bit and 16-bit DMA channel

#define mDD_BusMaster     (0x4)    // Bitmask, whether bus mastering is supported
#define fDD_NoBusMaster   (0x0)    //   no bus mastering
#define fDD_BusMaster     (0x4)    //   bus mastering

#define mDD_Type         (0x18)    // Bitmask, specifies type of DMA
#define fDD_TypeStandard (0x00)    //   standard DMA
#define fDD_TypeA        (0x08)    //   Type-A DMA
#define fDD_TypeB        (0x10)    //   Type-B DMA
#define fDD_TypeF        (0x18)    //   Type-F DMA

//
// DMA_RANGE structure
//
typedef struct DMA_Range_s {
   ULONG DR_Min;     // minimum DMA port in the range
   ULONG DR_Max;     // maximum DMA port in the range
   ULONG DR_Flags;   // flags describing the range (fDD flags)
} DMA_RANGE, *PDMA_RANGE;

//
// DMA_DES structure
//
typedef struct DMA_Des_s {
   DWORD  DD_Count;       // number of DMA_RANGE structs in DMA_RESOURCE
   DWORD  DD_Type;        // size (in bytes) of DMA_RANGE struct (DType_Range)
   DWORD  DD_Flags;       // Flags describing DMA channel (fDD flags)
   ULONG  DD_Alloc_Chan;  // Specifies the DMA channel that was allocated
} DMA_DES, *PDMA_DES;

//
// DMA_RESOURCE
//
typedef struct DMA_Resource_s {
   DMA_DES   DMA_Header;               // info about DMA channel range list
   DMA_RANGE DMA_Data[ANYSIZE_ARRAY];  // list of DMA ranges
} DMA_RESOURCE, *PDMA_RESOURCE;

//
// Define the size of each range structure
//
#define DType_Range     sizeof(struct DMA_Range_s)

//--------------------------------------------------------------
// Interrupt Resource
//--------------------------------------------------------------

//
// Define the attribute flags for an interrupt resource range.  Each bit flag
// is identified with a constant bitmask.  Following the bitmask definition
// are the possible values.
//
#define mIRQD_Share        (0x1) // Bitmask,whether the IRQ may be shared:
#define fIRQD_Exclusive    (0x0) //   The IRQ may not be shared
#define fIRQD_Share        (0x1) //   The IRQ may be shared

#define fIRQD_Share_Bit    0     // compatibility
#define fIRQD_Level_Bit    1     // compatibility

//
// ** NOTE: 16-bit ConfigMgr uses fIRQD_Level_Bit being set to indicate that the
// ** interrupt is _level-sensitive_.  For 32-bit ConfigMgr, if this bit is set,
// ** then the interrupt is _edge-sensitive_.
//
#define mIRQD_Edge_Level   (0x2) // Bitmask,whether edge or level triggered:
#define fIRQD_Level        (0x0) //   The IRQ is level-sensitive
#define fIRQD_Edge         (0x2) //   The IRQ is edge-sensitive

//
// IRQ_RANGE
//
typedef struct IRQ_Range_s {
   ULONG IRQR_Min;      // minimum IRQ in the range
   ULONG IRQR_Max;      // maximum IRQ in the range
   ULONG IRQR_Flags;    // flags describing the range (fIRQD flags)
} IRQ_RANGE, *PIRQ_RANGE;

//
// IRQ_DES structure
//
typedef struct IRQ_Des_32_s {
   DWORD   IRQD_Count;       // number of IRQ_RANGE structs in IRQ_RESOURCE
   DWORD   IRQD_Type;        // size (in bytes) of IRQ_RANGE (IRQType_Range)
   DWORD   IRQD_Flags;       // flags describing the IRQ (fIRQD flags)
   ULONG   IRQD_Alloc_Num;   // specifies the IRQ that was allocated
   ULONG32 IRQD_Affinity;
} IRQ_DES_32, *PIRQ_DES_32;

typedef struct IRQ_Des_64_s {
   DWORD   IRQD_Count;       // number of IRQ_RANGE structs in IRQ_RESOURCE
   DWORD   IRQD_Type;        // size (in bytes) of IRQ_RANGE (IRQType_Range)
   DWORD   IRQD_Flags;       // flags describing the IRQ (fIRQD flags)
   ULONG   IRQD_Alloc_Num;   // specifies the IRQ that was allocated
   ULONG64 IRQD_Affinity;
} IRQ_DES_64, *PIRQ_DES_64;

#ifdef _WIN64
typedef IRQ_DES_64   IRQ_DES;
typedef PIRQ_DES_64  PIRQ_DES;
#else
typedef IRQ_DES_32   IRQ_DES;
typedef PIRQ_DES_32  PIRQ_DES;
#endif

//
// IRQ_RESOURCE structure
//
typedef struct IRQ_Resource_32_s {
   IRQ_DES_32   IRQ_Header;               // info about IRQ range list
   IRQ_RANGE    IRQ_Data[ANYSIZE_ARRAY];  // list of IRQ ranges
} IRQ_RESOURCE_32, *PIRQ_RESOURCE_32;

typedef struct IRQ_Resource_64_s {
   IRQ_DES_64   IRQ_Header;               // info about IRQ range list
   IRQ_RANGE    IRQ_Data[ANYSIZE_ARRAY];  // list of IRQ ranges
} IRQ_RESOURCE_64, *PIRQ_RESOURCE_64;

#ifdef _WIN64
typedef IRQ_RESOURCE_64  IRQ_RESOURCE;
typedef PIRQ_RESOURCE_64 PIRQ_RESOURCE;
#else
typedef IRQ_RESOURCE_32  IRQ_RESOURCE;
typedef PIRQ_RESOURCE_32 PIRQ_RESOURCE;
#endif

//
// Define the size of each range structure
//
#define IRQType_Range   sizeof(struct IRQ_Range_s)

#if (WINVER >= _WIN32_WINNT_WINXP)
//
// Flags for resource descriptor APIs indicating the width of certain
// variable-size resource descriptor structure fields, where applicable.
//
#define CM_RESDES_WIDTH_DEFAULT (0x00000000)  // 32 or 64-bit IRQ_RESOURCE / IRQ_DES, based on client
#define CM_RESDES_WIDTH_32      (0x00000001)  // 32-bit IRQ_RESOURCE / IRQ_DES
#define CM_RESDES_WIDTH_64      (0x00000002)  // 64-bit IRQ_RESOURCE / IRQ_DES
#define CM_RESDES_WIDTH_BITS    (0x00000003)
#endif // (WINVER >= _WIN32_WINNT_WINXP)

//--------------------------------------------------------------
// Device Private Resource
//--------------------------------------------------------------

//
// DEVICEPRIVATE_RANGE structure
//

typedef struct DevPrivate_Range_s {
   DWORD    PR_Data1;     // mask for base alignment
   DWORD    PR_Data2;     // number of bytes
   DWORD    PR_Data3;     // minimum address
} DEVPRIVATE_RANGE, *PDEVPRIVATE_RANGE;

//
// DEVPRIVATE_DES structure
//
typedef struct DevPrivate_Des_s {
   DWORD     PD_Count;
   DWORD     PD_Type;
   DWORD     PD_Data1;
   DWORD     PD_Data2;
   DWORD     PD_Data3;
   DWORD     PD_Flags;
} DEVPRIVATE_DES, *PDEVPRIVATE_DES;

//
// DEVPRIVATE_RESOURCE
//
typedef struct DevPrivate_Resource_s {
   DEVPRIVATE_DES   PRV_Header;
   DEVPRIVATE_RANGE PRV_Data[ANYSIZE_ARRAY];
} DEVPRIVATE_RESOURCE, *PDEVPRIVATE_RESOURCE;

//
// Define the size of each range structure
//
#define PType_Range    sizeof(struct DevPrivate_Range_s)

//--------------------------------------------------------------
// Class-Specific Resource
//--------------------------------------------------------------

typedef struct CS_Des_s {
   DWORD    CSD_SignatureLength;
   DWORD    CSD_LegacyDataOffset;
   DWORD    CSD_LegacyDataSize;
   DWORD    CSD_Flags;
   GUID     CSD_ClassGuid;
   BYTE     CSD_Signature[ANYSIZE_ARRAY];
} CS_DES, *PCS_DES;

typedef struct CS_Resource_s {
   CS_DES   CS_Header;
} CS_RESOURCE, *PCS_RESOURCE;

//--------------------------------------------------------------
// PC Card Configuration Resource
//--------------------------------------------------------------

//
// Define the attribute flags for a PC Card configuration resource descriptor.
// Each bit flag is identified with a constant bitmask.  Following the bitmask
// definition are the possible values.
//
#define mPCD_IO_8_16        (0x1)   // Bitmask, whether I/O is 8 or 16 bits
#define fPCD_IO_8           (0x0)   // I/O is 8-bit
#define fPCD_IO_16          (0x1)   // I/O is 16-bit
#define mPCD_MEM_8_16       (0x2)   // Bitmask, whether MEM is 8 or 16 bits
#define fPCD_MEM_8          (0x0)   // MEM is 8-bit
#define fPCD_MEM_16         (0x2)   // MEM is 16-bit
#define mPCD_MEM_A_C        (0xC)   // Bitmask, whether MEMx is Attribute or Common
#define fPCD_MEM1_A         (0x4)   // MEM1 is Attribute
#define fPCD_MEM2_A         (0x8)   // MEM2 is Attribute
#define fPCD_IO_ZW_8        (0x10)  // zero wait on 8 bit I/O
#define fPCD_IO_SRC_16      (0x20)  // iosrc 16
#define fPCD_IO_WS_16       (0x40)  // wait states on 16 bit io
#define mPCD_MEM_WS         (0x300) // Bitmask, for additional wait states on memory windows
#define fPCD_MEM_WS_ONE     (0x100) // 1 wait state
#define fPCD_MEM_WS_TWO     (0x200) // 2 wait states
#define fPCD_MEM_WS_THREE   (0x300) // 3 wait states

#if (WINVER >= _WIN32_WINNT_WINXP)
#define fPCD_MEM_A          (0x4)   // MEM is Attribute

#define fPCD_ATTRIBUTES_PER_WINDOW (0x8000)

#define fPCD_IO1_16         (0x00010000)  // I/O window 1 is 16-bit
#define fPCD_IO1_ZW_8       (0x00020000)  // I/O window 1 zero wait on 8 bit I/O
#define fPCD_IO1_SRC_16     (0x00040000)  // I/O window 1 iosrc 16
#define fPCD_IO1_WS_16      (0x00080000)  // I/O window 1 wait states on 16 bit io

#define fPCD_IO2_16         (0x00100000)  // I/O window 2 is 16-bit
#define fPCD_IO2_ZW_8       (0x00200000)  // I/O window 2 zero wait on 8 bit I/O
#define fPCD_IO2_SRC_16     (0x00400000)  // I/O window 2 iosrc 16
#define fPCD_IO2_WS_16      (0x00800000)  // I/O window 2 wait states on 16 bit io

#define mPCD_MEM1_WS        (0x03000000)  // MEM window 1 Bitmask, for additional wait states on memory windows
#define fPCD_MEM1_WS_ONE    (0x01000000)  // MEM window 1, 1 wait state
#define fPCD_MEM1_WS_TWO    (0x02000000)  // MEM window 1, 2 wait states
#define fPCD_MEM1_WS_THREE  (0x03000000)  // MEM window 1, 3 wait states
#define fPCD_MEM1_16        (0x04000000)  // MEM window 1 is 16-bit

#define mPCD_MEM2_WS        (0x30000000)  // MEM window 2 Bitmask, for additional wait states on memory windows
#define fPCD_MEM2_WS_ONE    (0x10000000)  // MEM window 2, 1 wait state
#define fPCD_MEM2_WS_TWO    (0x20000000)  // MEM window 2, 2 wait states
#define fPCD_MEM2_WS_THREE  (0x30000000)  // MEM window 2, 3 wait states
#define fPCD_MEM2_16        (0x40000000)  // MEM window 2 is 16-bit

#define PCD_MAX_MEMORY   2
#define PCD_MAX_IO       2
#endif // (WINVER >= _WIN32_WINNT_WINXP)

typedef struct PcCard_Des_s {
    DWORD    PCD_Count;
    DWORD    PCD_Type;
    DWORD    PCD_Flags;
    BYTE     PCD_ConfigIndex;
    BYTE     PCD_Reserved[3];
    DWORD    PCD_MemoryCardBase1;
    DWORD    PCD_MemoryCardBase2;

#if (WINVER >= _WIN32_WINNT_WINXP)
    DWORD    PCD_MemoryCardBase[PCD_MAX_MEMORY];            // will soon be removed
    WORD     PCD_MemoryFlags[PCD_MAX_MEMORY];               // will soon be removed
    BYTE     PCD_IoFlags[PCD_MAX_IO];                       // will soon be removed
#endif // (WINVER >= _WIN32_WINNT_WINXP)

} PCCARD_DES, *PPCCARD_DES;

typedef struct PcCard_Resource_s {
   PCCARD_DES   PcCard_Header;
} PCCARD_RESOURCE, *PPCCARD_RESOURCE;

//--------------------------------------------------------------
// MF (multifunction) PCCard Configuration Resource
//--------------------------------------------------------------

#define mPMF_AUDIO_ENABLE   (0x8)   // Bitmask, whether audio is enabled or not
#define fPMF_AUDIO_ENABLE   (0x8)   // Audio is enabled

typedef struct MfCard_Des_s {
    DWORD    PMF_Count;
    DWORD    PMF_Type;
    DWORD    PMF_Flags;
    BYTE     PMF_ConfigOptions;
    BYTE     PMF_IoResourceIndex;
    BYTE     PMF_Reserved[2];
    DWORD    PMF_ConfigRegisterBase;
} MFCARD_DES, *PMFCARD_DES;

typedef struct MfCard_Resource_s {
   MFCARD_DES   MfCard_Header;
} MFCARD_RESOURCE, *PMFCARD_RESOURCE;

//--------------------------------------------------------------
// Bus Number Resource
//--------------------------------------------------------------

//
// Define the attribute flags for a Bus Number resource descriptor.
// Each bit flag is identified with a constant bitmask.  Following the bitmask
// definition are the possible values.
//
// Currently unused.
//

//
// BUSNUMBER_RANGE
//
typedef struct BusNumber_Range_s {
   ULONG BUSR_Min;          // minimum Bus Number in the range
   ULONG BUSR_Max;          // maximum Bus Number in the range
   ULONG BUSR_nBusNumbers;  // specifies number of buses required
   ULONG BUSR_Flags;        // flags describing the range (currently unused)
} BUSNUMBER_RANGE, *PBUSNUMBER_RANGE;

//
// BUSNUMBER_DES structure
//
typedef struct BusNumber_Des_s {
   DWORD BUSD_Count;       // number of BUSNUMBER_RANGE structs in BUSNUMBER_RESOURCE
   DWORD BUSD_Type;        // size (in bytes) of BUSNUMBER_RANGE (BusNumberType_Range)
   DWORD BUSD_Flags;       // flags describing the range (currently unused)
   ULONG BUSD_Alloc_Base;  // specifies the first Bus that was allocated
   ULONG BUSD_Alloc_End;   // specifies the last Bus number that was allocated
} BUSNUMBER_DES, *PBUSNUMBER_DES;

//
// BUSNUMBER_RESOURCE structure
//
typedef struct BusNumber_Resource_s {
   BUSNUMBER_DES   BusNumber_Header;               // info about Bus Number range list
   BUSNUMBER_RANGE BusNumber_Data[ANYSIZE_ARRAY];  // list of Bus Number ranges
} BUSNUMBER_RESOURCE, *PBUSNUMBER_RESOURCE;

//
// Define the size of each range structure
//
#define BusNumberType_Range   sizeof(struct BusNumber_Range_s)

//--------------------------------------------------------------
// Hardware Profile Information
//--------------------------------------------------------------

//
// Define flags relating to hardware profiles
//
#define CM_HWPI_NOT_DOCKABLE  (0x00000000)   // machine is not dockable
#define CM_HWPI_UNDOCKED      (0x00000001)   // hw profile for docked config
#define CM_HWPI_DOCKED        (0x00000002)   // hw profile for undocked config

//
// HWPROFILEINFO structure
//
typedef struct HWProfileInfo_sA {
   ULONG  HWPI_ulHWProfile;                      // handle of hw profile
   CHAR   HWPI_szFriendlyName[MAX_PROFILE_LEN];  // friendly name of hw profile
   DWORD  HWPI_dwFlags;                          // profile flags (CM_HWPI_*)
} HWPROFILEINFO_A, *PHWPROFILEINFO_A;

typedef struct HWProfileInfo_sW {
   ULONG  HWPI_ulHWProfile;                      // handle of hw profile
   WCHAR  HWPI_szFriendlyName[MAX_PROFILE_LEN];  // friendly name of hw profile
   DWORD  HWPI_dwFlags;                          // profile flags (CM_HWPI_*)
} HWPROFILEINFO_W, *PHWPROFILEINFO_W;

#ifdef UNICODE
typedef HWPROFILEINFO_W   HWPROFILEINFO;
typedef PHWPROFILEINFO_W  PHWPROFILEINFO;
#else
typedef HWPROFILEINFO_A   HWPROFILEINFO;
typedef PHWPROFILEINFO_A  PHWPROFILEINFO;
#endif

//
// revert back to normal default packing
//
#include "poppack.h"

//--------------------------------------------------------------
// Miscellaneous
//--------------------------------------------------------------

//
// Resource types
//
#define ResType_All           (0x00000000)   // Return all resource types
#define ResType_None          (0x00000000)   // Arbitration always succeeded
#define ResType_Mem           (0x00000001)   // Physical address resource
#define ResType_IO            (0x00000002)   // Physical I/O address resource
#define ResType_DMA           (0x00000003)   // DMA channels resource
#define ResType_IRQ           (0x00000004)   // IRQ resource
#define ResType_DoNotUse      (0x00000005)   // Used as spacer to sync subsequent ResTypes w/NT
#define ResType_BusNumber     (0x00000006)   // bus number resource
#define ResType_MAX           (0x00000006)   // Maximum known (arbitrated) ResType

// 
// This resource type is currently only supported in Kernel Mode as 
// CmResourceTypeMemoryLarge.  It is shown here as ResType_MemLarge
// for completeness and will eventually be fully implemented in user mode 
//
#define ResType_MemLarge      (0x00000007)   // Memory resources >= 4GB

#define ResType_Ignored_Bit   (0x00008000)   // Ignore this resource
#define ResType_ClassSpecific (0x0000FFFF)   // class-specific resource
#define ResType_Reserved      (0x00008000)   // reserved for internal use
#define ResType_DevicePrivate (0x00008001)   // device private data
#define ResType_PcCardConfig  (0x00008002)   // PC Card configuration data
#define ResType_MfCardConfig  (0x00008003)   // MF Card configuration data

//
// Flags specifying options for ranges that conflict with ranges already in
// the range list (CM_Add_Range)
//
#define CM_ADD_RANGE_ADDIFCONFLICT        (0x00000000) // merg with conflicting range
#define CM_ADD_RANGE_DONOTADDIFCONFLICT   (0x00000001) // error if range conflicts
#define CM_ADD_RANGE_BITS                 (0x00000001)

//
// Logical Config Flags (specified in call to CM_Get_First_Log_Conf
//
#define BASIC_LOG_CONF    0x00000000  // Specifies the req list.
#define FILTERED_LOG_CONF 0x00000001  // Specifies the filtered req list.
#define ALLOC_LOG_CONF    0x00000002  // Specifies the Alloc Element.
#define BOOT_LOG_CONF     0x00000003  // Specifies the RM Alloc Element.
#define FORCED_LOG_CONF   0x00000004  // Specifies the Forced Log Conf
#define OVERRIDE_LOG_CONF 0x00000005  // Specifies the Override req list.
#define NUM_LOG_CONF      0x00000006  // Number of Log Conf type
#define LOG_CONF_BITS     0x00000007  // The bits of the log conf type.

#define PRIORITY_EQUAL_FIRST  (0x00000008) // Same priority, new one first
#define PRIORITY_EQUAL_LAST   (0x00000000) // Same priority, new one last
#define PRIORITY_BIT          (0x00000008)

//
// Registry disposition values
// (specified in call to CM_Open_DevNode_Key and CM_Open_Class_Key)
//
#define RegDisposition_OpenAlways   (0x00000000)   // open if exists else create
#define RegDisposition_OpenExisting (0x00000001)   // open key only if exists
#define RegDisposition_Bits         (0x00000001)

//
// ulFlags values for CM API routines
//

//
// Flags for CM_Add_ID
//
#define CM_ADD_ID_HARDWARE                (0x00000000)
#define CM_ADD_ID_COMPATIBLE              (0x00000001)
#define CM_ADD_ID_BITS                    (0x00000001)

//
// Device Node creation flags
//
#define CM_CREATE_DEVNODE_NORMAL          (0x00000000)   // install later
#define CM_CREATE_DEVNODE_NO_WAIT_INSTALL (0x00000001)   // NOT SUPPORTED ON NT
#define CM_CREATE_DEVNODE_PHANTOM         (0x00000002)
#define CM_CREATE_DEVNODE_GENERATE_ID     (0x00000004)
#define CM_CREATE_DEVNODE_DO_NOT_INSTALL  (0x00000008)
#define CM_CREATE_DEVNODE_BITS            (0x0000000F)

#define CM_CREATE_DEVINST_NORMAL          CM_CREATE_DEVNODE_NORMAL
#define CM_CREATE_DEVINST_NO_WAIT_INSTALL CM_CREATE_DEVNODE_NO_WAIT_INSTALL
#define CM_CREATE_DEVINST_PHANTOM         CM_CREATE_DEVNODE_PHANTOM
#define CM_CREATE_DEVINST_GENERATE_ID     CM_CREATE_DEVNODE_GENERATE_ID
#define CM_CREATE_DEVINST_DO_NOT_INSTALL  CM_CREATE_DEVNODE_DO_NOT_INSTALL
#define CM_CREATE_DEVINST_BITS            CM_CREATE_DEVNODE_BITS

//
// Flags for CM_Delete_Class_Key
//
#define CM_DELETE_CLASS_ONLY        (0x00000000)
#define CM_DELETE_CLASS_SUBKEYS     (0x00000001)

#if (WINVER >= _WIN32_WINNT_LONGHORN)
#define CM_DELETE_CLASS_INTERFACE   (0x00000002)
#endif // (WINVER >= _WIN32_WINNT_LONGHORN)

#define CM_DELETE_CLASS_BITS        (0x00000003)

//
// Detection reason flags (specified in call to CM_Run_Detection)
//
#define CM_DETECT_NEW_PROFILE       (0x00000001) // detection for new hw profile
#define CM_DETECT_CRASHED           (0x00000002) // Previous detection crashed
#define CM_DETECT_HWPROF_FIRST_BOOT (0x00000004)
#define CM_DETECT_RUN               (0x80000000)
#define CM_DETECT_BITS              (0x80000007)

#define CM_DISABLE_POLITE           (0x00000000)    // Ask the driver
#define CM_DISABLE_ABSOLUTE         (0x00000001)    // Don't ask the driver
#define CM_DISABLE_HARDWARE         (0x00000002)    // Don't ask the driver, and won't be restarteable
#define CM_DISABLE_UI_NOT_OK        (0x00000004)    // Don't popup any veto API
#define CM_DISABLE_BITS             (0x00000007)    // The bits for the disable function

//
// Flags for CM_Get_Device_ID_List, CM_Get_Device_ID_List_Size
//
#define CM_GETIDLIST_FILTER_NONE                (0x00000000)
#define CM_GETIDLIST_FILTER_ENUMERATOR          (0x00000001)
#define CM_GETIDLIST_FILTER_SERVICE             (0x00000002)
#define CM_GETIDLIST_FILTER_EJECTRELATIONS      (0x00000004)
#define CM_GETIDLIST_FILTER_REMOVALRELATIONS    (0x00000008)
#define CM_GETIDLIST_FILTER_POWERRELATIONS      (0x00000010)
#define CM_GETIDLIST_FILTER_BUSRELATIONS        (0x00000020)
#define CM_GETIDLIST_DONOTGENERATE              (0x10000040)
#define CM_GETIDLIST_FILTER_BITS                (0x1000007F)

//
// Flags for CM_Get_Device_Interface_List, CM_Get_Device_Interface_List_Size
//
#define CM_GET_DEVICE_INTERFACE_LIST_PRESENT     (0x00000000)  // only currently 'live' device interfaces
#define CM_GET_DEVICE_INTERFACE_LIST_ALL_DEVICES (0x00000001)  // all registered device interfaces, live or not
#define CM_GET_DEVICE_INTERFACE_LIST_BITS        (0x00000001)

//
// Registry properties (specified in call to CM_Get_DevInst_Registry_Property or CM_Get_Class_Registry_Property,
// some are allowed in calls to CM_Set_DevInst_Registry_Property and CM_Set_Class_Registry_Property)
// CM_DRP_xxxx values should be used for CM_Get_DevInst_Registry_Property / CM_Set_DevInst_Registry_Property
// CM_CRP_xxxx values should be used for CM_Get_Class_Registry_Property / CM_Set_Class_Registry_Property
// DRP/CRP values that overlap must have a 1:1 correspondence with each other
//
#define CM_DRP_DEVICEDESC                  (0x00000001) // DeviceDesc REG_SZ property (RW)
#define CM_DRP_HARDWAREID                  (0x00000002) // HardwareID REG_MULTI_SZ property (RW)
#define CM_DRP_COMPATIBLEIDS               (0x00000003) // CompatibleIDs REG_MULTI_SZ property (RW)
#define CM_DRP_UNUSED0                     (0x00000004) // unused
#define CM_DRP_SERVICE                     (0x00000005) // Service REG_SZ property (RW)
#define CM_DRP_UNUSED1                     (0x00000006) // unused
#define CM_DRP_UNUSED2                     (0x00000007) // unused
#define CM_DRP_CLASS                       (0x00000008) // Class REG_SZ property (RW)
#define CM_DRP_CLASSGUID                   (0x00000009) // ClassGUID REG_SZ property (RW)
#define CM_DRP_DRIVER                      (0x0000000A) // Driver REG_SZ property (RW)
#define CM_DRP_CONFIGFLAGS                 (0x0000000B) // ConfigFlags REG_DWORD property (RW)
#define CM_DRP_MFG                         (0x0000000C) // Mfg REG_SZ property (RW)
#define CM_DRP_FRIENDLYNAME                (0x0000000D) // FriendlyName REG_SZ property (RW)
#define CM_DRP_LOCATION_INFORMATION        (0x0000000E) // LocationInformation REG_SZ property (RW)
#define CM_DRP_PHYSICAL_DEVICE_OBJECT_NAME (0x0000000F) // PhysicalDeviceObjectName REG_SZ property (R)
#define CM_DRP_CAPABILITIES                (0x00000010) // Capabilities REG_DWORD property (R)
#define CM_DRP_UI_NUMBER                   (0x00000011) // UiNumber REG_DWORD property (R)
#define CM_DRP_UPPERFILTERS                (0x00000012) // UpperFilters REG_MULTI_SZ property (RW)

#if (WINVER >= _WIN32_WINNT_LONGHORN)
#define CM_CRP_UPPERFILTERS                CM_DRP_UPPERFILTERS // UpperFilters REG_MULTI_SZ property (RW)
#endif // (WINVER >= _WIN32_WINNT_LONGHORN)

#define CM_DRP_LOWERFILTERS                (0x00000013) // LowerFilters REG_MULTI_SZ property (RW)

#if (WINVER >= _WIN32_WINNT_LONGHORN)
#define CM_CRP_LOWERFILTERS                CM_DRP_LOWERFILTERS // LowerFilters REG_MULTI_SZ property (RW)
#endif // (WINVER >= _WIN32_WINNT_LONGHORN)

#define CM_DRP_BUSTYPEGUID                 (0x00000014) // Bus Type Guid, GUID, (R)
#define CM_DRP_LEGACYBUSTYPE               (0x00000015) // Legacy bus type, INTERFACE_TYPE, (R)
#define CM_DRP_BUSNUMBER                   (0x00000016) // Bus Number, DWORD, (R)
#define CM_DRP_ENUMERATOR_NAME             (0x00000017) // Enumerator Name REG_SZ property (R)
#define CM_DRP_SECURITY                    (0x00000018) // Security - Device override (RW)
#define CM_CRP_SECURITY                    CM_DRP_SECURITY   // Class default security (RW)
#define CM_DRP_SECURITY_SDS                (0x00000019) // Security - Device override (RW)
#define CM_CRP_SECURITY_SDS                CM_DRP_SECURITY_SDS // Class default security (RW)
#define CM_DRP_DEVTYPE                     (0x0000001A) // Device Type - Device override (RW)
#define CM_CRP_DEVTYPE                     CM_DRP_DEVTYPE    // Class default Device-type (RW)
#define CM_DRP_EXCLUSIVE                   (0x0000001B) // Exclusivity - Device override (RW)
#define CM_CRP_EXCLUSIVE                   CM_DRP_EXCLUSIVE  // Class default (RW)
#define CM_DRP_CHARACTERISTICS             (0x0000001C) // Characteristics - Device Override (RW)
#define CM_CRP_CHARACTERISTICS             CM_DRP_CHARACTERISTICS  // Class default (RW)
#define CM_DRP_ADDRESS                     (0x0000001D) // Device Address (R)
#define CM_DRP_UI_NUMBER_DESC_FORMAT       (0x0000001E) // UINumberDescFormat REG_SZ property (RW)

#if (WINVER >= _WIN32_WINNT_WINXP)
#define CM_DRP_DEVICE_POWER_DATA           (0x0000001F) // CM_POWER_DATA REG_BINARY property (R)
#define CM_DRP_REMOVAL_POLICY              (0x00000020) // CM_DEVICE_REMOVAL_POLICY REG_DWORD (R)
#define CM_DRP_REMOVAL_POLICY_HW_DEFAULT   (0x00000021) // CM_DRP_REMOVAL_POLICY_HW_DEFAULT REG_DWORD (R)
#define CM_DRP_REMOVAL_POLICY_OVERRIDE     (0x00000022) // CM_DRP_REMOVAL_POLICY_OVERRIDE REG_DWORD (RW)
#define CM_DRP_INSTALL_STATE               (0x00000023) // CM_DRP_INSTALL_STATE REG_DWORD (R)
#endif // (WINVER >= _WIN32_WINNT_WINXP)

#if (WINVER >= _WIN32_WINNT_WS03)
#define CM_DRP_LOCATION_PATHS              (0x00000024) // CM_DRP_LOCATION_PATHS REG_MULTI_SZ (R)
#endif // (WINVER >= _WIN32_WINNT_WS03)

#define CM_DRP_MIN                         (0x00000001) // First device register
#define CM_CRP_MIN                         CM_DRP_MIN   // First class register
#define CM_DRP_MAX                         (0x00000024) // Last device register
#define CM_CRP_MAX                         CM_DRP_MAX   // Last class register

//
// Capabilities bits (the capability value is returned from calling
// CM_Get_DevInst_Registry_Property with CM_DRP_CAPABILITIES property)
//
#define CM_DEVCAP_LOCKSUPPORTED     (0x00000001)
#define CM_DEVCAP_EJECTSUPPORTED    (0x00000002)
#define CM_DEVCAP_REMOVABLE         (0x00000004)
#define CM_DEVCAP_DOCKDEVICE        (0x00000008)
#define CM_DEVCAP_UNIQUEID          (0x00000010)
#define CM_DEVCAP_SILENTINSTALL     (0x00000020)
#define CM_DEVCAP_RAWDEVICEOK       (0x00000040)
#define CM_DEVCAP_SURPRISEREMOVALOK (0x00000080)
#define CM_DEVCAP_HARDWAREDISABLED  (0x00000100)
#define CM_DEVCAP_NONDYNAMIC        (0x00000200)

#if (WINVER >= _WIN32_WINNT_WINXP)
//
// Removal policies (retrievable via CM_Get_DevInst_Registry_Property with
// the CM_DRP_REMOVAL_POLICY, CM_DRP_REMOVAL_POLICY_OVERRIDE, or
// CM_DRP_REMOVAL_POLICY_HW_DEFAULT properties)
//
#define CM_REMOVAL_POLICY_EXPECT_NO_REMOVAL             1
#define CM_REMOVAL_POLICY_EXPECT_ORDERLY_REMOVAL        2
#define CM_REMOVAL_POLICY_EXPECT_SURPRISE_REMOVAL       3

//
// Device install states (retrievable via CM_Get_DevInst_Registry_Property with
// the CM_DRP_INSTALL_STATE properties)
//
#define CM_INSTALL_STATE_INSTALLED                      0
#define CM_INSTALL_STATE_NEEDS_REINSTALL                1
#define CM_INSTALL_STATE_FAILED_INSTALL                 2
#define CM_INSTALL_STATE_FINISH_INSTALL                 3
#endif // (WINVER >= _WIN32_WINNT_WINXP)

//
// Flags for CM_Locate_DevNode
//
#define CM_LOCATE_DEVNODE_NORMAL       0x00000000
#define CM_LOCATE_DEVNODE_PHANTOM      0x00000001
#define CM_LOCATE_DEVNODE_CANCELREMOVE 0x00000002
#define CM_LOCATE_DEVNODE_NOVALIDATION 0x00000004
#define CM_LOCATE_DEVNODE_BITS         0x00000007

#define CM_LOCATE_DEVINST_NORMAL       CM_LOCATE_DEVNODE_NORMAL
#define CM_LOCATE_DEVINST_PHANTOM      CM_LOCATE_DEVNODE_PHANTOM
#define CM_LOCATE_DEVINST_CANCELREMOVE CM_LOCATE_DEVNODE_CANCELREMOVE
#define CM_LOCATE_DEVINST_NOVALIDATION CM_LOCATE_DEVNODE_NOVALIDATION
#define CM_LOCATE_DEVINST_BITS         CM_LOCATE_DEVNODE_BITS

//
// Flags for CM_Open_Class_Key
//
#define CM_OPEN_CLASS_KEY_INSTALLER        (0x00000000)
#define CM_OPEN_CLASS_KEY_INTERFACE        (0x00000001)
#define CM_OPEN_CLASS_KEY_BITS             (0x00000001)

//
// Flags for CM_Query_And_Remove_SubTree
//
#define CM_REMOVE_UI_OK             0x00000000
#define CM_REMOVE_UI_NOT_OK         0x00000001
#define CM_REMOVE_NO_RESTART        0x00000002
#define CM_REMOVE_BITS              0x00000003

//
// Backward compatibility--do not use
// (use above CM_REMOVE_* flags instead)
//
#define CM_QUERY_REMOVE_UI_OK       (CM_REMOVE_UI_OK)
#define CM_QUERY_REMOVE_UI_NOT_OK   (CM_REMOVE_UI_NOT_OK)
#define CM_QUERY_REMOVE_BITS        (CM_QUERY_REMOVE_UI_OK|CM_QUERY_REMOVE_UI_NOT_OK)

//
// Flags for CM_Reenumerate_DevNode
//
#define CM_REENUMERATE_NORMAL                   0x00000000
#define CM_REENUMERATE_SYNCHRONOUS              0x00000001

#if (WINVER >= _WIN32_WINNT_WINXP)
#define CM_REENUMERATE_RETRY_INSTALLATION       0x00000002
#define CM_REENUMERATE_ASYNCHRONOUS             0x00000004
#endif // (WINVER >= _WIN32_WINNT_WINXP)

#define CM_REENUMERATE_BITS                     0x00000007

//
// Flags for CM_Register_Device_Driver
//
#define CM_REGISTER_DEVICE_DRIVER_STATIC        (0x00000000)
#define CM_REGISTER_DEVICE_DRIVER_DISABLEABLE   (0x00000001)
#define CM_REGISTER_DEVICE_DRIVER_REMOVABLE     (0x00000002)
#define CM_REGISTER_DEVICE_DRIVER_BITS          (0x00000003)

//
// Registry Branch Locations (for CM_Open_DevNode_Key)
//
#define CM_REGISTRY_HARDWARE        (0x00000000)
#define CM_REGISTRY_SOFTWARE        (0x00000001)
#define CM_REGISTRY_USER            (0x00000100)
#define CM_REGISTRY_CONFIG          (0x00000200)
#define CM_REGISTRY_BITS            (0x00000301)

//
// Flags for CM_Set_DevNode_Problem
//
#define CM_SET_DEVNODE_PROBLEM_NORMAL    (0x00000000)  // only set problem if currently no problem
#define CM_SET_DEVNODE_PROBLEM_OVERRIDE  (0x00000001)  // override current problem with new problem
#define CM_SET_DEVNODE_PROBLEM_BITS      (0x00000001)

#define CM_SET_DEVINST_PROBLEM_NORMAL    CM_SET_DEVNODE_PROBLEM_NORMAL
#define CM_SET_DEVINST_PROBLEM_OVERRIDE  CM_SET_DEVNODE_PROBLEM_OVERRIDE
#define CM_SET_DEVINST_PROBLEM_BITS      CM_SET_DEVNODE_PROBLEM_BITS

//
// Flags for CM_Set_HW_Prof_Flags
//
#define CM_SET_HW_PROF_FLAGS_UI_NOT_OK  (0x00000001)    // Don't popup any veto UI
#define CM_SET_HW_PROF_FLAGS_BITS       (0x00000001)

//
// Re-enable and configuration actions (specified in call to CM_Setup_DevInst)
//
#define CM_SETUP_DEVNODE_READY   (0x00000000) // Reenable problem devinst
#define CM_SETUP_DEVINST_READY   CM_SETUP_DEVNODE_READY
#define CM_SETUP_DOWNLOAD        (0x00000001) // Get info about devinst
#define CM_SETUP_WRITE_LOG_CONFS (0x00000002)
#define CM_SETUP_PROP_CHANGE     (0x00000003)

#if (WINVER >= _WIN32_WINNT_WINXP)
#define CM_SETUP_DEVNODE_RESET   (0x00000004) // Reset problem devinst without starting
#define CM_SETUP_DEVINST_RESET   CM_SETUP_DEVNODE_RESET
#endif // (WINVER >= _WIN32_WINNT_WINXP)

#define CM_SETUP_BITS            (0x00000007)

//
// Flags for CM_Query_Arbitrator_Free_Data and
// CM_Query_Arbitrator_Free_Data_Size.
//
#define CM_QUERY_ARBITRATOR_RAW         (0x00000000)
#define CM_QUERY_ARBITRATOR_TRANSLATED  (0x00000001)
#define CM_QUERY_ARBITRATOR_BITS        (0x00000001)

#if (WINVER >= _WIN32_WINNT_WINXP)
//
// Flags for CM_Get_DevNode_Custom_Property
//
#define CM_CUSTOMDEVPROP_MERGE_MULTISZ  (0x00000001)
#define CM_CUSTOMDEVPROP_BITS           (0x00000001)
#endif // (WINVER >= _WIN32_WINNT_WINXP)


//--------------------------------------------------------------
// Function prototypes
//--------------------------------------------------------------

CMAPI
CONFIGRET
WINAPI
CM_Add_Empty_Log_Conf(
    __out PLOG_CONF     plcLogConf,
    __in  DEVINST       dnDevInst,
    __in  PRIORITY      Priority,
    __in  ULONG         ulFlags
    );
CMAPI
CONFIGRET
WINAPI
CM_Add_Empty_Log_Conf_Ex(
    __out PLOG_CONF     plcLogConf,
    __in  DEVINST       dnDevInst,
    __in  PRIORITY      Priority,
    __in  ULONG         ulFlags,
    __in_opt HMACHINE   hMachine
    );

CMAPI
CONFIGRET
WINAPI
CM_Add_IDA(
    __in  DEVINST       dnDevInst,
    __in  PSTR          pszID,
    __in  ULONG         ulFlags
    );
CMAPI
CONFIGRET
WINAPI
CM_Add_IDW(
    __in  DEVINST       dnDevInst,
    __in  PWSTR         pszID,
    __in  ULONG         ulFlags
    );
CMAPI
CONFIGRET
WINAPI
CM_Add_ID_ExA(
    __in  DEVINST       dnDevInst,
    __in  PSTR          pszID,
    __in  ULONG         ulFlags,
    __in_opt HMACHINE   hMachine
    );
CMAPI
CONFIGRET
WINAPI
CM_Add_ID_ExW(
    __in  DEVINST       dnDevInst,
    __in  PWSTR         pszID,
    __in  ULONG         ulFlags,
    __in_opt HMACHINE   hMachine
    );
#ifdef UNICODE
#define CM_Add_ID             CM_Add_IDW
#define CM_Add_ID_Ex          CM_Add_ID_ExW
#else
#define CM_Add_ID             CM_Add_IDA
#define CM_Add_ID_Ex          CM_Add_ID_ExA
#endif // UNICODE

CMAPI
CONFIGRET
WINAPI
CM_Add_Range(
    __in  DWORDLONG     ullStartValue,
    __in  DWORDLONG     ullEndValue,
    __in  RANGE_LIST    rlh,
    __in  ULONG         ulFlags
    );

CMAPI
CONFIGRET
WINAPI
CM_Add_Res_Des(
    __out_opt PRES_DES  prdResDes,
    __in  LOG_CONF      lcLogConf,
    __in  RESOURCEID    ResourceID,
    __in_bcount(ResourceLen) PCVOID ResourceData,
    __in  ULONG         ResourceLen,
    __in  ULONG         ulFlags
    );
CMAPI
CONFIGRET
WINAPI
CM_Add_Res_Des_Ex(
    __out_opt PRES_DES  prdResDes,
    __in  LOG_CONF      lcLogConf,
    __in  RESOURCEID    ResourceID,
    __in_bcount(ResourceLen) PCVOID ResourceData,
    __in  ULONG         ResourceLen,
    __in  ULONG         ulFlags,
    __in_opt HMACHINE   hMachine
    );

CMAPI
CONFIGRET
WINAPI
CM_Connect_MachineA(
    __in_opt PCSTR      UNCServerName,
    __out PHMACHINE     phMachine
    );
CMAPI
CONFIGRET
WINAPI
CM_Connect_MachineW(
    __in_opt PCWSTR     UNCServerName,
    __out PHMACHINE     phMachine
    );
#ifdef UNICODE
#define CM_Connect_Machine       CM_Connect_MachineW
#else
#define CM_Connect_Machine       CM_Connect_MachineA
#endif // UNICODE

CMAPI
CONFIGRET
WINAPI
CM_Create_DevNodeA(
    __out PDEVINST      pdnDevInst,
    __in  DEVINSTID_A   pDeviceID,
    __in  DEVINST       dnParent,
    __in  ULONG         ulFlags
    );
CMAPI
CONFIGRET
WINAPI
CM_Create_DevNodeW(
    __out PDEVINST      pdnDevInst,
    __in  DEVINSTID_W   pDeviceID,
    __in  DEVINST       dnParent,
    __in  ULONG         ulFlags
    );
CMAPI
CONFIGRET
WINAPI
CM_Create_DevNode_ExA(
    __out PDEVINST      pdnDevInst,
    __in  DEVINSTID_A   pDeviceID,
    __in  DEVINST       dnParent,
    __in  ULONG         ulFlags,
    __in_opt HMACHINE   hMachine
    );
CMAPI
CONFIGRET
WINAPI
CM_Create_DevNode_ExW(
    __out PDEVINST      pdnDevInst,
    __in  DEVINSTID_W   pDeviceID,
    __in  DEVINST       dnParent,
    __in  ULONG         ulFlags,
    __in_opt HMACHINE   hMachine
    );
#define CM_Create_DevInstW       CM_Create_DevNodeW
#define CM_Create_DevInstA       CM_Create_DevNodeA
#define CM_Create_DevInst_ExW    CM_Create_DevNode_ExW
#define CM_Create_DevInst_ExA    CM_Create_DevNode_ExA
#ifdef UNICODE
#define CM_Create_DevNode        CM_Create_DevNodeW
#define CM_Create_DevInst        CM_Create_DevNodeW
#define CM_Create_DevNode_Ex     CM_Create_DevNode_ExW
#define CM_Create_DevInst_Ex     CM_Create_DevInst_ExW
#else
#define CM_Create_DevNode        CM_Create_DevNodeA
#define CM_Create_DevInst        CM_Create_DevNodeA
#define CM_Create_DevNode_Ex     CM_Create_DevNode_ExA
#define CM_Create_DevInst_Ex     CM_Create_DevNode_ExA
#endif // UNICODE

CMAPI
CONFIGRET
WINAPI
CM_Create_Range_List(
    __out PRANGE_LIST   prlh,
    __in  ULONG         ulFlags
    );

CMAPI
CONFIGRET
WINAPI
CM_Delete_Class_Key(
    __in  LPGUID        ClassGuid,
    __in  ULONG         ulFlags
    );
CMAPI
CONFIGRET
WINAPI
CM_Delete_Class_Key_Ex(
    __in  LPGUID        ClassGuid,
    __in  ULONG         ulFlags,
    __in_opt HMACHINE   hMachine
    );

CMAPI
CONFIGRET
WINAPI
CM_Delete_DevNode_Key(
    __in  DEVNODE       dnDevNode,
    __in  ULONG         ulHardwareProfile,
    __in  ULONG         ulFlags
    );
CMAPI
CONFIGRET
WINAPI
CM_Delete_DevNode_Key_Ex(
    __in  DEVNODE       dnDevNode,
    __in  ULONG         ulHardwareProfile,
    __in  ULONG         ulFlags,
    __in_opt HMACHINE   hMachine
    );
#define CM_Delete_DevInst_Key       CM_Delete_DevNode_Key
#define CM_Delete_DevInst_Key_Ex    CM_Delete_DevNode_Key_Ex

CMAPI
CONFIGRET
WINAPI
CM_Delete_Range(
    __in  DWORDLONG     ullStartValue,
    __in  DWORDLONG     ullEndValue,
    __in  RANGE_LIST    rlh,
    __in  ULONG         ulFlags
    );

CMAPI
CONFIGRET
WINAPI
CM_Detect_Resource_Conflict(
    __in  DEVINST       dnDevInst,
    __in  RESOURCEID    ResourceID,
    __in_bcount(ResourceLen) PCVOID ResourceData,
    __in  ULONG         ResourceLen,
    __out PBOOL         pbConflictDetected,
    __in  ULONG         ulFlags
    );
CMAPI
CONFIGRET
WINAPI
CM_Detect_Resource_Conflict_Ex(
    __in  DEVINST       dnDevInst,
    __in  RESOURCEID    ResourceID,
    __in_bcount(ResourceLen) PCVOID ResourceData,
    __in  ULONG         ResourceLen,
    __out PBOOL         pbConflictDetected,
    __in  ULONG         ulFlags,
    __in_opt HMACHINE   hMachine
    );

CMAPI
CONFIGRET
WINAPI
CM_Disable_DevNode(
    __in  DEVINST       dnDevInst,
    __in  ULONG         ulFlags
    );
CMAPI
CONFIGRET
WINAPI
CM_Disable_DevNode_Ex(
    __in  DEVINST       dnDevInst,
    __in  ULONG         ulFlags,
    __in_opt HMACHINE   hMachine
    );
#define CM_Disable_DevInst       CM_Disable_DevNode
#define CM_Disable_DevInst_Ex    CM_Disable_DevNode_Ex

CMAPI
CONFIGRET
WINAPI
CM_Disconnect_Machine(
    __in_opt HMACHINE   hMachine
    );

CMAPI
CONFIGRET
WINAPI
CM_Dup_Range_List(
    __in  RANGE_LIST    rlhOld,
    __in  RANGE_LIST    rlhNew,
    __in  ULONG         ulFlags
    );

CMAPI
CONFIGRET
WINAPI
CM_Enable_DevNode(
    __in  DEVINST       dnDevInst,
    __in  ULONG         ulFlags
    );
CMAPI
CONFIGRET
WINAPI
CM_Enable_DevNode_Ex(
    __in  DEVINST       dnDevInst,
    __in  ULONG         ulFlags,
    __in_opt HMACHINE   hMachine
    );
#define CM_Enable_DevInst        CM_Enable_DevNode
#define CM_Enable_DevInst_Ex     CM_Enable_DevNode_Ex

CMAPI
CONFIGRET
WINAPI
CM_Enumerate_Classes(
    __in  ULONG         ulClassIndex,
    __out LPGUID        ClassGuid,
    __in  ULONG         ulFlags
    );
CMAPI
CONFIGRET
WINAPI
CM_Enumerate_Classes_Ex(
    __in  ULONG         ulClassIndex,
    __out LPGUID        ClassGuid,
    __in  ULONG         ulFlags,
    __in_opt HMACHINE   hMachine
    );

CMAPI
CONFIGRET
WINAPI
CM_Enumerate_EnumeratorsA(
    __in  ULONG         ulEnumIndex,
    __out_ecount(*pulLength) PSTR Buffer,
    __inout PULONG      pulLength,
    __in  ULONG         ulFlags
    );
CMAPI
CONFIGRET
WINAPI
CM_Enumerate_EnumeratorsW(
    __in  ULONG         ulEnumIndex,
    __out_ecount(*pulLength) PWSTR Buffer,
    __inout PULONG      pulLength,
    __in  ULONG         ulFlags
    );
CMAPI
CONFIGRET
WINAPI
CM_Enumerate_Enumerators_ExA(
    __in  ULONG         ulEnumIndex,
    __out_ecount(*pulLength) PSTR Buffer,
    __inout PULONG      pulLength,
    __in  ULONG         ulFlags,
    __in_opt HMACHINE   hMachine
    );
CMAPI
CONFIGRET
WINAPI
CM_Enumerate_Enumerators_ExW(
    __in  ULONG         ulEnumIndex,
    __out_ecount(*pulLength) PWSTR Buffer,
    __inout PULONG      pulLength,
    __in  ULONG         ulFlags,
    __in_opt HMACHINE   hMachine
    );
#ifdef UNICODE
#define CM_Enumerate_Enumerators       CM_Enumerate_EnumeratorsW
#define CM_Enumerate_Enumerators_Ex    CM_Enumerate_Enumerators_ExW
#else
#define CM_Enumerate_Enumerators       CM_Enumerate_EnumeratorsA
#define CM_Enumerate_Enumerators_Ex    CM_Enumerate_Enumerators_ExA
#endif // UNICODE

CMAPI
CONFIGRET
WINAPI
CM_Find_Range(
    __out PDWORDLONG    pullStart,
    __in  DWORDLONG     ullStart,
    __in  ULONG         ulLength,
    __in  DWORDLONG     ullAlignment,
    __in  DWORDLONG     ullEnd,
    __in  RANGE_LIST    rlh,
    __in  ULONG         ulFlags
    );

CMAPI
CONFIGRET
WINAPI
CM_First_Range(
    __in  RANGE_LIST    rlh,
    __out PDWORDLONG    pullStart,
    __out PDWORDLONG    pullEnd,
    __out PRANGE_ELEMENT preElement,
    __in  ULONG         ulFlags
    );

CMAPI
CONFIGRET
WINAPI
CM_Free_Log_Conf(
    __in  LOG_CONF      lcLogConfToBeFreed,
    __in  ULONG         ulFlags
    );
CMAPI
CONFIGRET
WINAPI
CM_Free_Log_Conf_Ex(
    __in  LOG_CONF      lcLogConfToBeFreed,
    __in  ULONG         ulFlags,
    __in_opt HMACHINE   hMachine
    );

CMAPI
CONFIGRET
WINAPI
CM_Free_Log_Conf_Handle(
    __in  LOG_CONF      lcLogConf
    );

CMAPI
CONFIGRET
WINAPI
CM_Free_Range_List(
    __in  RANGE_LIST    rlh,
    __in  ULONG         ulFlags
    );

CMAPI
CONFIGRET
WINAPI
CM_Free_Res_Des(
    __out PRES_DES      prdResDes,
    __in  RES_DES       rdResDes,
    __in  ULONG         ulFlags
    );
CMAPI
CONFIGRET
WINAPI
CM_Free_Res_Des_Ex(
    __out PRES_DES      prdResDes,
    __in  RES_DES       rdResDes,
    __in  ULONG         ulFlags,
    __in_opt HMACHINE   hMachine
    );

CMAPI
CONFIGRET
WINAPI
CM_Free_Res_Des_Handle(
    __in  RES_DES       rdResDes
    );

CMAPI
CONFIGRET
WINAPI
CM_Get_Child(
    __out PDEVINST      pdnDevInst,
    __in  DEVINST       dnDevInst,
    __in  ULONG         ulFlags
    );
CMAPI
CONFIGRET
WINAPI
CM_Get_Child_Ex(
    __out PDEVINST      pdnDevInst,
    __in  DEVINST       dnDevInst,
    __in  ULONG         ulFlags,
    __in_opt HMACHINE   hMachine
    );

CMAPI
CONFIGRET
WINAPI
CM_Get_Class_NameA(
    __in  LPGUID        ClassGuid,
    __out_ecount_opt(*pulLength) PSTR Buffer,
    __inout PULONG      pulLength,
    __in  ULONG         ulFlags
    );
CMAPI
CONFIGRET
WINAPI
CM_Get_Class_NameW(
    __in  LPGUID        ClassGuid,
    __out_ecount_opt(*pulLength) PWSTR Buffer,
    __inout PULONG      pulLength,
    __in  ULONG         ulFlags
    );
CMAPI
CONFIGRET
WINAPI
CM_Get_Class_Name_ExA(
    __in  LPGUID        ClassGuid,
    __out_ecount_opt(*pulLength) PSTR Buffer,
    __inout PULONG      pulLength,
    __in  ULONG         ulFlags,
    __in_opt HMACHINE   hMachine
    );
CMAPI
CONFIGRET
WINAPI
CM_Get_Class_Name_ExW(
    __in  LPGUID        ClassGuid,
    __out_ecount_opt(*pulLength) PWSTR Buffer,
    __inout PULONG      pulLength,
    __in  ULONG         ulFlags,
    __in_opt HMACHINE   hMachine
    );
#ifdef UNICODE
#define CM_Get_Class_Name        CM_Get_Class_NameW
#define CM_Get_Class_Name_Ex     CM_Get_Class_Name_ExW
#else
#define CM_Get_Class_Name        CM_Get_Class_NameA
#define CM_Get_Class_Name_Ex     CM_Get_Class_Name_ExA
#endif // UNICODE

CMAPI
CONFIGRET
WINAPI
CM_Get_Class_Key_NameA(
    __in  LPGUID        ClassGuid,
    __out_ecount_opt(*pulLength) LPSTR pszKeyName,
    __inout PULONG      pulLength,
    __in  ULONG         ulFlags
    );
CMAPI
CONFIGRET
WINAPI
CM_Get_Class_Key_NameW(
    __in  LPGUID        ClassGuid,
    __out_ecount_opt(*pulLength) LPWSTR pszKeyName,
    __inout PULONG      pulLength,
    __in  ULONG         ulFlags
    );
CMAPI
CONFIGRET
WINAPI
CM_Get_Class_Key_Name_ExA(
    __in  LPGUID        ClassGuid,
    __out_ecount_opt(*pulLength) LPSTR pszKeyName,
    __inout PULONG      pulLength,
    __in  ULONG         ulFlags,
    __in_opt HMACHINE   hMachine
    );
CMAPI
CONFIGRET
WINAPI
CM_Get_Class_Key_Name_ExW(
    __in  LPGUID        ClassGuid,
    __out_ecount_opt(*pulLength) LPWSTR pszKeyName,
    __inout PULONG      pulLength,
    __in  ULONG         ulFlags,
    __in_opt HMACHINE   hMachine
    );
#ifdef UNICODE
#define CM_Get_Class_Key_Name        CM_Get_Class_Key_NameW
#define CM_Get_Class_Key_Name_Ex     CM_Get_Class_Key_Name_ExW
#else
#define CM_Get_Class_Key_Name        CM_Get_Class_Key_NameA
#define CM_Get_Class_Key_Name_Ex     CM_Get_Class_Key_Name_ExA
#endif // UNICODE

CMAPI
CONFIGRET
WINAPI
CM_Get_Depth(
    __out PULONG        pulDepth,
    __in  DEVINST       dnDevInst,
    __in  ULONG         ulFlags
    );
CMAPI
CONFIGRET
WINAPI
CM_Get_Depth_Ex(
    __out PULONG        pulDepth,
    __in  DEVINST       dnDevInst,
    __in  ULONG         ulFlags,
    __in_opt HMACHINE   hMachine
    );

CMAPI
CONFIGRET
WINAPI
CM_Get_Device_IDA(
    __in  DEVINST       dnDevInst,
    __out_ecount(BufferLen) PSTR Buffer,
    __in  ULONG         BufferLen,
    __in  ULONG         ulFlags
    );
CMAPI
CONFIGRET
WINAPI
CM_Get_Device_IDW(
    __in  DEVINST       dnDevInst,
    __out_ecount(BufferLen) PWSTR Buffer,
    __in  ULONG         BufferLen,
    __in  ULONG         ulFlags
    );
CMAPI
CONFIGRET
WINAPI
CM_Get_Device_ID_ExA(
    __in  DEVINST       dnDevInst,
    __out_ecount(BufferLen) PSTR Buffer,
    __in  ULONG         BufferLen,
    __in  ULONG         ulFlags,
    __in_opt HMACHINE   hMachine
    );
CMAPI
CONFIGRET
WINAPI
CM_Get_Device_ID_ExW(
    __in  DEVINST       dnDevInst,
    __out_ecount(BufferLen) PWSTR Buffer,
    __in  ULONG         BufferLen,
    __in  ULONG         ulFlags,
    __in_opt HMACHINE   hMachine
    );
#ifdef UNICODE
#define CM_Get_Device_ID         CM_Get_Device_IDW
#define CM_Get_Device_ID_Ex      CM_Get_Device_ID_ExW
#else
#define CM_Get_Device_ID         CM_Get_Device_IDA
#define CM_Get_Device_ID_Ex      CM_Get_Device_ID_ExA
#endif // UNICODE

CMAPI
CONFIGRET
WINAPI
CM_Get_Device_ID_ListA(
    __in_opt PCSTR      pszFilter,
    __out_ecount(BufferLen) PCHAR Buffer,
    __in  ULONG         BufferLen,
    __in  ULONG         ulFlags
    );

CMAPI
CONFIGRET
WINAPI
CM_Get_Device_ID_ListW(
    __in_opt PCWSTR     pszFilter,
    __out_ecount(BufferLen) PWCHAR Buffer,
    __in  ULONG         BufferLen,
    __in  ULONG         ulFlags
    );

CMAPI
CONFIGRET
WINAPI
CM_Get_Device_ID_List_ExA(
    __in_opt PCSTR      pszFilter,
    __out_ecount(BufferLen) PCHAR Buffer,
    __in  ULONG         BufferLen,
    __in  ULONG         ulFlags,
    __in_opt HMACHINE   hMachine
    );

CMAPI
CONFIGRET
WINAPI
CM_Get_Device_ID_List_ExW(
    __in_opt PCWSTR     pszFilter,
    __out_ecount(BufferLen) PWCHAR Buffer,
    __in  ULONG         BufferLen,
    __in  ULONG         ulFlags,
    __in_opt HMACHINE   hMachine
    );

#ifdef UNICODE
#define CM_Get_Device_ID_List       CM_Get_Device_ID_ListW
#define CM_Get_Device_ID_List_Ex    CM_Get_Device_ID_List_ExW
#else
#define CM_Get_Device_ID_List       CM_Get_Device_ID_ListA
#define CM_Get_Device_ID_List_Ex    CM_Get_Device_ID_List_ExA
#endif // UNICODE

CMAPI
CONFIGRET
WINAPI
CM_Get_Device_ID_List_SizeA(
    __out PULONG        pulLen,
    __in_opt PCSTR      pszFilter,
    __in  ULONG         ulFlags
    );
CMAPI
CONFIGRET
WINAPI
CM_Get_Device_ID_List_SizeW(
    __out PULONG        pulLen,
    __in_opt PCWSTR     pszFilter,
    __in  ULONG         ulFlags
    );
CMAPI
CONFIGRET
WINAPI
CM_Get_Device_ID_List_Size_ExA(
    __out PULONG        pulLen,
    __in_opt PCSTR      pszFilter,
    __in  ULONG         ulFlags,
    __in_opt HMACHINE   hMachine
    );
CMAPI
CONFIGRET
WINAPI
CM_Get_Device_ID_List_Size_ExW(
    __out PULONG        pulLen,
    __in_opt PCWSTR     pszFilter,
    __in  ULONG         ulFlags,
    __in_opt HMACHINE   hMachine
    );
#ifdef UNICODE
#define CM_Get_Device_ID_List_Size    CM_Get_Device_ID_List_SizeW
#define CM_Get_Device_ID_List_Size_Ex CM_Get_Device_ID_List_Size_ExW
#else
#define CM_Get_Device_ID_List_Size    CM_Get_Device_ID_List_SizeA
#define CM_Get_Device_ID_List_Size_Ex CM_Get_Device_ID_List_Size_ExA
#endif // UNICODE

CMAPI
CONFIGRET
WINAPI
CM_Get_Device_ID_Size(
    __out PULONG        pulLen,
    __in  DEVINST       dnDevInst,
    __in  ULONG         ulFlags
    );
CMAPI
CONFIGRET
WINAPI
CM_Get_Device_ID_Size_Ex(
    __out PULONG        pulLen,
    __in  DEVINST       dnDevInst,
    __in  ULONG         ulFlags,
    __in_opt HMACHINE   hMachine
    );

CMAPI
CONFIGRET
WINAPI
CM_Get_DevNode_Registry_PropertyA(
    __in  DEVINST       dnDevInst,
    __in  ULONG         ulProperty,
    __out_opt PULONG    pulRegDataType,
    __out_bcount_opt(*pulLength) PVOID Buffer,
    __inout PULONG      pulLength,
    __in  ULONG         ulFlags
    );
CMAPI
CONFIGRET
WINAPI
CM_Get_DevNode_Registry_PropertyW(
    __in  DEVINST       dnDevInst,
    __in  ULONG         ulProperty,
    __out_opt PULONG    pulRegDataType,
    __out_bcount_opt(*pulLength) PVOID Buffer,
    __inout PULONG      pulLength,
    __in  ULONG         ulFlags
    );
CMAPI
CONFIGRET
WINAPI
CM_Get_DevNode_Registry_Property_ExA(
    __in  DEVINST       dnDevInst,
    __in  ULONG         ulProperty,
    __out_opt PULONG    pulRegDataType,
    __out_bcount_opt(*pulLength) PVOID Buffer,
    __inout PULONG      pulLength,
    __in  ULONG         ulFlags,
    __in_opt HMACHINE   hMachine
    );
CMAPI
CONFIGRET
WINAPI
CM_Get_DevNode_Registry_Property_ExW(
    __in  DEVINST       dnDevInst,
    __in  ULONG         ulProperty,
    __out_opt PULONG    pulRegDataType,
    __out_bcount_opt(*pulLength) PVOID Buffer,
    __inout PULONG      pulLength,
    __in  ULONG         ulFlags,
    __in_opt HMACHINE   hMachine
    );
#define CM_Get_DevInst_Registry_PropertyW     CM_Get_DevNode_Registry_PropertyW
#define CM_Get_DevInst_Registry_PropertyA     CM_Get_DevNode_Registry_PropertyA
#define CM_Get_DevInst_Registry_Property_ExW  CM_Get_DevNode_Registry_Property_ExW
#define CM_Get_DevInst_Registry_Property_ExA  CM_Get_DevNode_Registry_Property_ExA
#ifdef UNICODE
#define CM_Get_DevInst_Registry_Property      CM_Get_DevNode_Registry_PropertyW
#define CM_Get_DevInst_Registry_Property_Ex   CM_Get_DevNode_Registry_Property_ExW
#define CM_Get_DevNode_Registry_Property      CM_Get_DevNode_Registry_PropertyW
#define CM_Get_DevNode_Registry_Property_Ex   CM_Get_DevNode_Registry_Property_ExW
#else
#define CM_Get_DevInst_Registry_Property      CM_Get_DevNode_Registry_PropertyA
#define CM_Get_DevInst_Registry_Property_Ex   CM_Get_DevNode_Registry_Property_ExA
#define CM_Get_DevNode_Registry_Property      CM_Get_DevNode_Registry_PropertyA
#define CM_Get_DevNode_Registry_Property_Ex   CM_Get_DevNode_Registry_Property_ExA
#endif // UNICODE

#if (WINVER >= _WIN32_WINNT_WINXP)
CMAPI
CONFIGRET
WINAPI
CM_Get_DevNode_Custom_PropertyA(
    __in  DEVINST       dnDevInst,
    __in  PCSTR         pszCustomPropertyName,
    __out_opt PULONG    pulRegDataType,
    __out_bcount_opt(*pulLength) PVOID Buffer,
    __inout PULONG      pulLength,
    __in  ULONG         ulFlags
    );
CMAPI
CONFIGRET
WINAPI
CM_Get_DevNode_Custom_PropertyW(
    __in  DEVINST       dnDevInst,
    __in  PCWSTR        pszCustomPropertyName,
    __out_opt PULONG    pulRegDataType,
    __out_bcount_opt(*pulLength) PVOID Buffer,
    __inout PULONG      pulLength,
    __in  ULONG         ulFlags
    );
CMAPI
CONFIGRET
WINAPI
CM_Get_DevNode_Custom_Property_ExA(
    __in  DEVINST       dnDevInst,
    __in  PCSTR         pszCustomPropertyName,
    __out_opt PULONG    pulRegDataType,
    __out_bcount_opt(*pulLength) PVOID Buffer,
    __inout PULONG      pulLength,
    __in  ULONG         ulFlags,
    __in_opt HMACHINE   hMachine
    );
CMAPI
CONFIGRET
WINAPI
CM_Get_DevNode_Custom_Property_ExW(
    __in  DEVINST       dnDevInst,
    __in  PCWSTR        pszCustomPropertyName,
    __out_opt PULONG    pulRegDataType,
    __out_bcount_opt(*pulLength) PVOID Buffer,
    __inout PULONG      pulLength,
    __in  ULONG         ulFlags,
    __in_opt HMACHINE   hMachine
    );
#define CM_Get_DevInst_Custom_PropertyW     CM_Get_DevNode_Custom_PropertyW
#define CM_Get_DevInst_Custom_PropertyA     CM_Get_DevNode_Custom_PropertyA
#define CM_Get_DevInst_Custom_Property_ExW  CM_Get_DevNode_Custom_Property_ExW
#define CM_Get_DevInst_Custom_Property_ExA  CM_Get_DevNode_Custom_Property_ExA
#ifdef UNICODE
#define CM_Get_DevInst_Custom_Property      CM_Get_DevNode_Custom_PropertyW
#define CM_Get_DevInst_Custom_Property_Ex   CM_Get_DevNode_Custom_Property_ExW
#define CM_Get_DevNode_Custom_Property      CM_Get_DevNode_Custom_PropertyW
#define CM_Get_DevNode_Custom_Property_Ex   CM_Get_DevNode_Custom_Property_ExW
#else
#define CM_Get_DevInst_Custom_Property      CM_Get_DevNode_Custom_PropertyA
#define CM_Get_DevInst_Custom_Property_Ex   CM_Get_DevNode_Custom_Property_ExA
#define CM_Get_DevNode_Custom_Property      CM_Get_DevNode_Custom_PropertyA
#define CM_Get_DevNode_Custom_Property_Ex   CM_Get_DevNode_Custom_Property_ExA
#endif // UNICODE
#endif // (WINVER >= _WIN32_WINNT_WINXP)

CMAPI
CONFIGRET
WINAPI
CM_Get_DevNode_Status(
    __out PULONG        pulStatus,
    __out PULONG        pulProblemNumber,
    __in  DEVINST       dnDevInst,
    __in  ULONG         ulFlags
    );
CMAPI
CONFIGRET
WINAPI
CM_Get_DevNode_Status_Ex(
    __out PULONG        pulStatus,
    __out PULONG        pulProblemNumber,
    __in  DEVINST       dnDevInst,
    __in  ULONG         ulFlags,
    __in_opt HMACHINE   hMachine
    );
#define CM_Get_DevInst_Status    CM_Get_DevNode_Status
#define CM_Get_DevInst_Status_Ex CM_Get_DevNode_Status_Ex

CMAPI
CONFIGRET
WINAPI
CM_Get_First_Log_Conf(
    __out_opt PLOG_CONF plcLogConf,
    __in  DEVINST       dnDevInst,
    __in  ULONG         ulFlags
    );
CMAPI
CONFIGRET
WINAPI
CM_Get_First_Log_Conf_Ex(
    __out_opt PLOG_CONF plcLogConf,
    __in  DEVINST       dnDevInst,
    __in  ULONG         ulFlags,
    __in_opt HMACHINE   hMachine
    );

CMAPI
CONFIGRET
WINAPI
CM_Get_Global_State(
    __out PULONG        pulState,
    __in  ULONG         ulFlags
    );
CMAPI
CONFIGRET
WINAPI
CM_Get_Global_State_Ex(
    __out PULONG        pulState,
    __in  ULONG         ulFlags,
    __in_opt HMACHINE   hMachine
    );

CMAPI
CONFIGRET
WINAPI
CM_Get_Hardware_Profile_InfoA(
    __in  ULONG         ulIndex,
    __out PHWPROFILEINFO_A pHWProfileInfo,
    __in  ULONG         ulFlags
    );
CMAPI
CONFIGRET
WINAPI
CM_Get_Hardware_Profile_Info_ExA(
    __in  ULONG         ulIndex,
    __out PHWPROFILEINFO_A pHWProfileInfo,
    __in  ULONG         ulFlags,
    __in_opt HMACHINE   hMachine
    );
CMAPI
CONFIGRET
WINAPI
CM_Get_Hardware_Profile_InfoW(
    __in  ULONG         ulIndex,
    __out PHWPROFILEINFO_W pHWProfileInfo,
    __in  ULONG         ulFlags
    );
CMAPI
CONFIGRET
WINAPI
CM_Get_Hardware_Profile_Info_ExW(
    __in  ULONG         ulIndex,
    __out PHWPROFILEINFO_W pHWProfileInfo,
    __in  ULONG         ulFlags,
    __in_opt HMACHINE   hMachine
    );
#ifdef UNICODE
#define CM_Get_Hardware_Profile_Info      CM_Get_Hardware_Profile_InfoW
#define CM_Get_Hardware_Profile_Info_Ex   CM_Get_Hardware_Profile_Info_ExW
#else
#define CM_Get_Hardware_Profile_Info      CM_Get_Hardware_Profile_InfoA
#define CM_Get_Hardware_Profile_Info_Ex   CM_Get_Hardware_Profile_Info_ExA
#endif // UNICODE

CMAPI
CONFIGRET
WINAPI
CM_Get_HW_Prof_FlagsA(
    __in  DEVINSTID_A   pDeviceID,
    __in  ULONG         ulHardwareProfile,
    __out PULONG        pulValue,
    __in  ULONG         ulFlags
    );
CMAPI
CONFIGRET
WINAPI
CM_Get_HW_Prof_FlagsW(
    __in  DEVINSTID_W   pDeviceID,
    __in  ULONG         ulHardwareProfile,
    __out PULONG        pulValue,
    __in  ULONG         ulFlags
    );
CMAPI
CONFIGRET
WINAPI
CM_Get_HW_Prof_Flags_ExA(
    __in  DEVINSTID_A   pDeviceID,
    __in  ULONG         ulHardwareProfile,
    __out PULONG        pulValue,
    __in  ULONG         ulFlags,
    __in_opt HMACHINE   hMachine
    );
CMAPI
CONFIGRET
WINAPI
CM_Get_HW_Prof_Flags_ExW(
    __in  DEVINSTID_W   pDeviceID,
    __in  ULONG         ulHardwareProfile,
    __out PULONG        pulValue,
    __in  ULONG         ulFlags,
    __in_opt HMACHINE   hMachine
    );
#ifdef UNICODE
#define CM_Get_HW_Prof_Flags     CM_Get_HW_Prof_FlagsW
#define CM_Get_HW_Prof_Flags_Ex  CM_Get_HW_Prof_Flags_ExW
#else
#define CM_Get_HW_Prof_Flags     CM_Get_HW_Prof_FlagsA
#define CM_Get_HW_Prof_Flags_Ex  CM_Get_HW_Prof_Flags_ExA
#endif // UNICODE

CMAPI
CONFIGRET
WINAPI
CM_Get_Device_Interface_AliasA(
    __in  LPCSTR        pszDeviceInterface,
    __in  LPGUID        AliasInterfaceGuid,
    __out_ecount(*pulLength) LPSTR pszAliasDeviceInterface,
    __inout PULONG      pulLength,
    __in  ULONG         ulFlags
    );
CMAPI
CONFIGRET
WINAPI
CM_Get_Device_Interface_AliasW(
    __in  LPCWSTR       pszDeviceInterface,
    __in  LPGUID        AliasInterfaceGuid,
    __out_ecount(*pulLength) LPWSTR pszAliasDeviceInterface,
    __inout PULONG      pulLength,
    __in  ULONG         ulFlags
    );
CMAPI
CONFIGRET
WINAPI
CM_Get_Device_Interface_Alias_ExA(
    __in  LPCSTR        pszDeviceInterface,
    __in  LPGUID        AliasInterfaceGuid,
    __out_ecount(*pulLength) LPSTR pszAliasDeviceInterface,
    __inout PULONG      pulLength,
    __in  ULONG         ulFlags,
    __in_opt HMACHINE   hMachine
    );
CMAPI
CONFIGRET
WINAPI
CM_Get_Device_Interface_Alias_ExW(
    __in  LPCWSTR       pszDeviceInterface,
    __in  LPGUID        AliasInterfaceGuid,
    __out_ecount(*pulLength) LPWSTR pszAliasDeviceInterface,
    __inout PULONG      pulLength,
    __in  ULONG         ulFlags,
    __in_opt HMACHINE   hMachine
    );
#ifdef UNICODE
#define CM_Get_Device_Interface_Alias     CM_Get_Device_Interface_AliasW
#define CM_Get_Device_Interface_Alias_Ex  CM_Get_Device_Interface_Alias_ExW
#else
#define CM_Get_Device_Interface_Alias     CM_Get_Device_Interface_AliasA
#define CM_Get_Device_Interface_Alias_Ex  CM_Get_Device_Interface_Alias_ExA
#endif // UNICODE

CMAPI
CONFIGRET
WINAPI
CM_Get_Device_Interface_ListA(
    __in  LPGUID        InterfaceClassGuid,
    __in_opt DEVINSTID_A pDeviceID,
    __out_ecount(BufferLen) PCHAR Buffer,
    __in  ULONG         BufferLen,
    __in  ULONG         ulFlags
    );
CMAPI
CONFIGRET
WINAPI
CM_Get_Device_Interface_ListW(
    __in  LPGUID        InterfaceClassGuid,
    __in_opt DEVINSTID_W pDeviceID,
    __out_ecount(BufferLen) PWCHAR Buffer,
    __in  ULONG         BufferLen,
    __in  ULONG         ulFlags
    );
CMAPI
CONFIGRET
WINAPI
CM_Get_Device_Interface_List_ExA(
    __in  LPGUID        InterfaceClassGuid,
    __in_opt DEVINSTID_A pDeviceID,
    __out_ecount(BufferLen) PCHAR Buffer,
    __in  ULONG         BufferLen,
    __in  ULONG         ulFlags,
    __in_opt HMACHINE   hMachine
    );
CMAPI
CONFIGRET
WINAPI
CM_Get_Device_Interface_List_ExW(
    __in  LPGUID        InterfaceClassGuid,
    __in_opt DEVINSTID_W pDeviceID,
    __out_ecount(BufferLen) PWCHAR Buffer,
    __in  ULONG         BufferLen,
    __in  ULONG         ulFlags,
    __in_opt HMACHINE   hMachine
    );
#ifdef UNICODE
#define CM_Get_Device_Interface_List     CM_Get_Device_Interface_ListW
#define CM_Get_Device_Interface_List_Ex  CM_Get_Device_Interface_List_ExW
#else
#define CM_Get_Device_Interface_List     CM_Get_Device_Interface_ListA
#define CM_Get_Device_Interface_List_Ex  CM_Get_Device_Interface_List_ExA
#endif // UNICODE

CMAPI
CONFIGRET
WINAPI
CM_Get_Device_Interface_List_SizeA(
    __out PULONG        pulLen,
    __in  LPGUID        InterfaceClassGuid,
    __in_opt DEVINSTID_A pDeviceID,
    __in  ULONG         ulFlags
    );
CMAPI
CONFIGRET
WINAPI
CM_Get_Device_Interface_List_SizeW(
    __out PULONG        pulLen,
    __in  LPGUID        InterfaceClassGuid,
    __in_opt DEVINSTID_W pDeviceID,
    __in  ULONG         ulFlags
    );
CMAPI
CONFIGRET
WINAPI
CM_Get_Device_Interface_List_Size_ExA(
    __out PULONG        pulLen,
    __in  LPGUID        InterfaceClassGuid,
    __in_opt DEVINSTID_A pDeviceID,
    __in  ULONG         ulFlags,
    __in_opt HMACHINE   hMachine
    );
CMAPI
CONFIGRET
WINAPI
CM_Get_Device_Interface_List_Size_ExW(
    __out PULONG        pulLen,
    __in  LPGUID        InterfaceClassGuid,
    __in_opt DEVINSTID_W pDeviceID,
    __in  ULONG         ulFlags,
    __in_opt HMACHINE   hMachine
    );
#ifdef UNICODE
#define CM_Get_Device_Interface_List_Size     CM_Get_Device_Interface_List_SizeW
#define CM_Get_Device_Interface_List_Size_Ex  CM_Get_Device_Interface_List_Size_ExW
#else
#define CM_Get_Device_Interface_List_Size     CM_Get_Device_Interface_List_SizeA
#define CM_Get_Device_Interface_List_Size_Ex  CM_Get_Device_Interface_List_Size_ExA
#endif // UNICODE

CMAPI
CONFIGRET
WINAPI
CM_Get_Log_Conf_Priority(
    __in  LOG_CONF      lcLogConf,
    __out PPRIORITY     pPriority,
    __in  ULONG         ulFlags
    );
CMAPI
CONFIGRET
WINAPI
CM_Get_Log_Conf_Priority_Ex(
    __in  LOG_CONF      lcLogConf,
    __out PPRIORITY     pPriority,
    __in  ULONG         ulFlags,
    __in_opt HMACHINE   hMachine
    );

CMAPI
CONFIGRET
WINAPI
CM_Get_Next_Log_Conf(
    __out_opt PLOG_CONF plcLogConf,
    __in  LOG_CONF      lcLogConf,
    __in  ULONG         ulFlags
    );
CMAPI
CONFIGRET
WINAPI
CM_Get_Next_Log_Conf_Ex(
    __out_opt PLOG_CONF plcLogConf,
    __in  LOG_CONF      lcLogConf,
    __in  ULONG         ulFlags,
    __in_opt HMACHINE   hMachine
    );

CMAPI
CONFIGRET
WINAPI
CM_Get_Parent(
    __out PDEVINST      pdnDevInst,
    __in  DEVINST       dnDevInst,
    __in  ULONG         ulFlags
    );
CMAPI
CONFIGRET
WINAPI
CM_Get_Parent_Ex(
    __out PDEVINST      pdnDevInst,
    __in  DEVINST       dnDevInst,
    __in  ULONG         ulFlags,
    __in_opt HMACHINE   hMachine
    );

CMAPI
CONFIGRET
WINAPI
CM_Get_Res_Des_Data(
    __in  RES_DES       rdResDes,
    __out_bcount(BufferLen) PVOID Buffer,
    __in  ULONG         BufferLen,
    __in  ULONG         ulFlags
    );
CMAPI
CONFIGRET
WINAPI
CM_Get_Res_Des_Data_Ex(
    __in  RES_DES       rdResDes,
    __out_bcount(BufferLen) PVOID Buffer,
    __in  ULONG         BufferLen,
    __in  ULONG         ulFlags,
    __in_opt HMACHINE   hMachine
    );

CMAPI
CONFIGRET
WINAPI
CM_Get_Res_Des_Data_Size(
    __out PULONG        pulSize,
    __in  RES_DES       rdResDes,
    __in  ULONG         ulFlags
    );
CMAPI
CONFIGRET
WINAPI
CM_Get_Res_Des_Data_Size_Ex(
    __out PULONG        pulSize,
    __in  RES_DES       rdResDes,
    __in  ULONG         ulFlags,
    __in_opt HMACHINE   hMachine
    );

CMAPI
CONFIGRET
WINAPI
CM_Get_Sibling(
    __out PDEVINST      pdnDevInst,
    __in  DEVINST       dnDevInst,
    __in  ULONG         ulFlags
    );
CMAPI
CONFIGRET
WINAPI
CM_Get_Sibling_Ex(
    __out PDEVINST      pdnDevInst,
    __in  DEVINST       dnDevInst,
    __in  ULONG         ulFlags,
    __in_opt HMACHINE   hMachine
    );

CMAPI
WORD
WINAPI
CM_Get_Version(
    VOID
    );
CMAPI
WORD
WINAPI
CM_Get_Version_Ex(
    __in_opt HMACHINE   hMachine
    );

#if (WINVER >= _WIN32_WINNT_WINXP)
CMAPI
BOOL
WINAPI
CM_Is_Version_Available(
    __in  WORD          wVersion
    );
CMAPI
BOOL
WINAPI
CM_Is_Version_Available_Ex(
    __in  WORD          wVersion,
    __in_opt HMACHINE   hMachine
    );
#endif // (WINVER >= _WIN32_WINNT_WINXP)

CMAPI
CONFIGRET
WINAPI
CM_Intersect_Range_List(
    __in  RANGE_LIST    rlhOld1,
    __in  RANGE_LIST    rlhOld2,
    __in  RANGE_LIST    rlhNew,
    __in  ULONG         ulFlags
    );

CMAPI
CONFIGRET
WINAPI
CM_Invert_Range_List(
    __in  RANGE_LIST    rlhOld,
    __in  RANGE_LIST    rlhNew,
    __in  DWORDLONG     ullMaxValue,
    __in  ULONG         ulFlags
    );

CMAPI
CONFIGRET
WINAPI
CM_Locate_DevNodeA(
    __out PDEVINST      pdnDevInst,
    __in_opt DEVINSTID_A pDeviceID,
    __in  ULONG         ulFlags
    );
CMAPI
CONFIGRET
WINAPI
CM_Locate_DevNodeW(
    __out PDEVINST      pdnDevInst,
    __in_opt DEVINSTID_W pDeviceID,
    __in  ULONG         ulFlags
    );
CMAPI
CONFIGRET
WINAPI
CM_Locate_DevNode_ExA(
    __out PDEVINST      pdnDevInst,
    __in_opt DEVINSTID_A pDeviceID,
    __in  ULONG         ulFlags,
    __in_opt HMACHINE   hMachine
    );
CMAPI
CONFIGRET
WINAPI
CM_Locate_DevNode_ExW(
    __out PDEVINST      pdnDevInst,
    __in_opt DEVINSTID_W pDeviceID,
    __in  ULONG         ulFlags,
    __in_opt HMACHINE   hMachine
    );
#define CM_Locate_DevInstA       CM_Locate_DevNodeA
#define CM_Locate_DevInstW       CM_Locate_DevNodeW
#define CM_Locate_DevInst_ExA    CM_Locate_DevNode_ExA
#define CM_Locate_DevInst_ExW    CM_Locate_DevNode_ExW
#ifdef UNICODE
#define CM_Locate_DevNode        CM_Locate_DevNodeW
#define CM_Locate_DevInst        CM_Locate_DevNodeW
#define CM_Locate_DevNode_Ex     CM_Locate_DevNode_ExW
#define CM_Locate_DevInst_Ex     CM_Locate_DevNode_ExW
#else
#define CM_Locate_DevNode        CM_Locate_DevNodeA
#define CM_Locate_DevInst        CM_Locate_DevNodeA
#define CM_Locate_DevNode_Ex     CM_Locate_DevNode_ExA
#define CM_Locate_DevInst_Ex     CM_Locate_DevNode_ExA
#endif // UNICODE

CMAPI
CONFIGRET
WINAPI
CM_Merge_Range_List(
    __in  RANGE_LIST    rlhOld1,
    __in  RANGE_LIST    rlhOld2,
    __in  RANGE_LIST    rlhNew,
    __in  ULONG         ulFlags
    );

CMAPI
CONFIGRET
WINAPI
CM_Modify_Res_Des(
    __out PRES_DES      prdResDes,
    __in  RES_DES       rdResDes,
    __in  RESOURCEID    ResourceID,
    __in_bcount(ResourceLen) PCVOID ResourceData,
    __in  ULONG         ResourceLen,
    __in  ULONG         ulFlags
    );
CMAPI
CONFIGRET
WINAPI
CM_Modify_Res_Des_Ex(
    __out PRES_DES      prdResDes,
    __in  RES_DES       rdResDes,
    __in  RESOURCEID    ResourceID,
    __in_bcount(ResourceLen) PCVOID ResourceData,
    __in  ULONG         ResourceLen,
    __in  ULONG         ulFlags,
    __in_opt HMACHINE   hMachine
    );

CMAPI
CONFIGRET
WINAPI
CM_Move_DevNode(
    __in  DEVINST       dnFromDevInst,
    __in  DEVINST       dnToDevInst,
    __in  ULONG         ulFlags
    );
CMAPI
CONFIGRET
WINAPI
CM_Move_DevNode_Ex(
    __in  DEVINST       dnFromDevInst,
    __in  DEVINST       dnToDevInst,
    __in  ULONG         ulFlags,
    __in_opt HMACHINE   hMachine
    );
#define CM_Move_DevInst          CM_Move_DevNode
#define CM_Move_DevInst_Ex       CM_Move_DevNode_Ex

CMAPI
CONFIGRET
WINAPI
CM_Next_Range(
    __inout PRANGE_ELEMENT preElement,
    __out PDWORDLONG    pullStart,
    __out PDWORDLONG    pullEnd,
    __in  ULONG         ulFlags
    );

CMAPI
CONFIGRET
WINAPI
CM_Get_Next_Res_Des(
    __out PRES_DES      prdResDes,
    __in  RES_DES       rdResDes,
    __in  RESOURCEID    ForResource,
    __out_opt PRESOURCEID pResourceID,
    __in  ULONG         ulFlags
    );
CMAPI
CONFIGRET
WINAPI
CM_Get_Next_Res_Des_Ex(
    __out PRES_DES      prdResDes,
    __in  RES_DES       rdResDes,
    __in  RESOURCEID    ForResource,
    __out_opt PRESOURCEID pResourceID,
    __in  ULONG         ulFlags,
    __in_opt HMACHINE   hMachine
    );

CMAPI
CONFIGRET
WINAPI
CM_Open_Class_KeyA(
    __in_opt LPGUID     ClassGuid,
    __in_opt LPCSTR     pszClassName,
    __in  REGSAM        samDesired,
    __in  REGDISPOSITION Disposition,
    __out PHKEY         phkClass,
    __in  ULONG         ulFlags
    );
CMAPI
CONFIGRET
WINAPI
CM_Open_Class_KeyW(
    __in_opt LPGUID     ClassGuid,
    __in_opt LPCWSTR    pszClassName,
    __in  REGSAM        samDesired,
    __in  REGDISPOSITION Disposition,
    __out PHKEY         phkClass,
    __in  ULONG         ulFlags
    );
CMAPI
CONFIGRET
WINAPI
CM_Open_Class_Key_ExA(
    __in_opt LPGUID     ClassGuid,
    __in_opt LPCSTR     pszClassName,
    __in  REGSAM        samDesired,
    __in  REGDISPOSITION Disposition,
    __out PHKEY         phkClass,
    __in  ULONG         ulFlags,
    __in_opt HMACHINE   hMachine
    );
CMAPI
CONFIGRET
WINAPI
CM_Open_Class_Key_ExW(
    __in_opt LPGUID     ClassGuid,
    __in_opt LPCWSTR    pszClassName,
    __in  REGSAM        samDesired,
    __in  REGDISPOSITION Disposition,
    __out PHKEY         phkClass,
    __in  ULONG         ulFlags,
    __in_opt HMACHINE   hMachine
    );
#ifdef UNICODE
#define CM_Open_Class_Key        CM_Open_Class_KeyW
#define CM_Open_Class_Key_Ex     CM_Open_Class_Key_ExW
#else
#define CM_Open_Class_Key        CM_Open_Class_KeyA
#define CM_Open_Class_Key_Ex     CM_Open_Class_Key_ExA
#endif // UNICODE

CMAPI
CONFIGRET
WINAPI
CM_Open_DevNode_Key(
    __in  DEVINST       dnDevNode,
    __in  REGSAM        samDesired,
    __in  ULONG         ulHardwareProfile,
    __in  REGDISPOSITION Disposition,
    __out PHKEY         phkDevice,
    __in  ULONG         ulFlags
    );
CMAPI
CONFIGRET
WINAPI
CM_Open_DevNode_Key_Ex(
    __in  DEVINST       dnDevNode,
    __in  REGSAM        samDesired,
    __in  ULONG         ulHardwareProfile,
    __in  REGDISPOSITION Disposition,
    __out PHKEY         phkDevice,
    __in  ULONG         ulFlags,
    __in_opt HMACHINE   hMachine
    );
#define CM_Open_DevInst_Key      CM_Open_DevNode_Key
#define CM_Open_DevInst_Key_Ex   CM_Open_DevNode_Key_Ex

#if (WINVER >= _WIN32_WINNT_LONGHORN)
CMAPI
CONFIGRET
WINAPI
CM_Open_Device_Interface_KeyA(
    __in  LPCSTR        pszDeviceInterface,
    __in  REGSAM        samDesired,
    __in  REGDISPOSITION Disposition,
    __out PHKEY         phkDeviceInterface,
    __in  ULONG         ulFlags
    );
CMAPI
CONFIGRET
WINAPI
CM_Open_Device_Interface_KeyW(
    __in  LPCWSTR       pszDeviceInterface,
    __in  REGSAM        samDesired,
    __in  REGDISPOSITION Disposition,
    __out PHKEY         phkDeviceInterface,
    __in  ULONG         ulFlags
    );
CMAPI
CONFIGRET
WINAPI
CM_Open_Device_Interface_Key_ExA(
    __in  LPCSTR        pszDeviceInterface,
    __in  REGSAM        samDesired,
    __in  REGDISPOSITION Disposition,
    __out PHKEY         phkDeviceInterface,
    __in  ULONG         ulFlags,
    __in_opt HMACHINE   hMachine
    );
CMAPI
CONFIGRET
WINAPI
CM_Open_Device_Interface_Key_ExW(
    __in  LPCWSTR       pszDeviceInterface,
    __in  REGSAM        samDesired,
    __in  REGDISPOSITION Disposition,
    __out PHKEY         phkDeviceInterface,
    __in  ULONG         ulFlags,
    __in_opt HMACHINE   hMachine
    );
#ifdef UNICODE
#define CM_Open_Device_Interface_Key    CM_Open_Device_Interface_KeyW
#define CM_Open_Device_Interface_Key_Ex CM_Open_Device_Interface_Key_ExW
#else
#define CM_Open_Device_Interface_Key    CM_Open_Device_Interface_KeyA
#define CM_Open_Device_Interface_Key_Ex CM_Open_Device_Interface_Key_ExA
#endif // UNICODE

CMAPI
CONFIGRET
WINAPI
CM_Delete_Device_Interface_KeyA(
    __in  LPCSTR        pszDeviceInterface,
    __in  ULONG         ulFlags
    );
CMAPI
CONFIGRET
WINAPI
CM_Delete_Device_Interface_KeyW(
    __in  LPCWSTR       pszDeviceInterface,
    __in  ULONG         ulFlags
    );
CMAPI
CONFIGRET
WINAPI
CM_Delete_Device_Interface_Key_ExA(
    __in  LPCSTR        pszDeviceInterface,
    __in  ULONG         ulFlags,
    __in_opt HMACHINE   hMachine
    );
CMAPI
CONFIGRET
WINAPI
CM_Delete_Device_Interface_Key_ExW(
    __in  LPCWSTR       pszDeviceInterface,
    __in  ULONG         ulFlags,
    __in_opt HMACHINE   hMachine
    );
#ifdef UNICODE
#define CM_Delete_Device_Interface_Key    CM_Delete_Device_Interface_KeyW
#define CM_Delete_Device_Interface_Key_Ex CM_Delete_Device_Interface_Key_ExW
#else
#define CM_Delete_Device_Interface_Key    CM_Delete_Device_Interface_KeyA
#define CM_Delete_Device_Interface_Key_Ex CM_Delete_Device_Interface_Key_ExA
#endif // UNICODE
#endif // (WINVER >= _WIN32_WINNT_LONGHORN)

CMAPI
CONFIGRET
WINAPI
CM_Query_Arbitrator_Free_Data(
    __out_bcount(DataLen) PVOID pData,
    __in  ULONG         DataLen,
    __in  DEVINST       dnDevInst,
    __in  RESOURCEID    ResourceID,
    __in  ULONG         ulFlags
    );
CMAPI
CONFIGRET
WINAPI
CM_Query_Arbitrator_Free_Data_Ex(
    __out_bcount(DataLen) PVOID pData,
    __in  ULONG         DataLen,
    __in  DEVINST       dnDevInst,
    __in  RESOURCEID    ResourceID,
    __in  ULONG         ulFlags,
    __in_opt HMACHINE   hMachine
    );

CMAPI
CONFIGRET
WINAPI
CM_Query_Arbitrator_Free_Size(
    __out PULONG        pulSize,
    __in  DEVINST       dnDevInst,
    __in  RESOURCEID    ResourceID,
    __in  ULONG         ulFlags
    );
CMAPI
CONFIGRET
WINAPI
CM_Query_Arbitrator_Free_Size_Ex(
    __out PULONG        pulSize,
    __in  DEVINST       dnDevInst,
    __in  RESOURCEID    ResourceID,
    __in  ULONG         ulFlags,
    __in_opt HMACHINE   hMachine
    );

CMAPI
CONFIGRET
WINAPI
CM_Query_Remove_SubTree(
    __in  DEVINST       dnAncestor,
    __in  ULONG         ulFlags
    );
CMAPI
CONFIGRET
WINAPI
CM_Query_Remove_SubTree_Ex(
    __in  DEVINST       dnAncestor,
    __in  ULONG         ulFlags,
    __in_opt HMACHINE   hMachine
    );

CMAPI
CONFIGRET
WINAPI
CM_Query_And_Remove_SubTreeA(
    __in  DEVINST       dnAncestor,
    __out_opt PPNP_VETO_TYPE pVetoType,
    __out_ecount_opt(ulNameLength) LPSTR pszVetoName,
    __in  ULONG         ulNameLength,
    __in  ULONG         ulFlags
    );
CMAPI
CONFIGRET
WINAPI
CM_Query_And_Remove_SubTree_ExA(
    __in  DEVINST       dnAncestor,
    __out_opt PPNP_VETO_TYPE pVetoType,
    __out_ecount_opt(ulNameLength) LPSTR pszVetoName,
    __in  ULONG         ulNameLength,
    __in  ULONG         ulFlags,
    __in_opt HMACHINE   hMachine
    );
CMAPI
CONFIGRET
WINAPI
CM_Query_And_Remove_SubTreeW(
    __in  DEVINST       dnAncestor,
    __out_opt PPNP_VETO_TYPE pVetoType,
    __out_ecount_opt(ulNameLength) LPWSTR pszVetoName,
    __in  ULONG         ulNameLength,
    __in  ULONG         ulFlags
    );
CMAPI
CONFIGRET
WINAPI
CM_Query_And_Remove_SubTree_ExW(
    __in  DEVINST       dnAncestor,
    __out_opt PPNP_VETO_TYPE pVetoType,
    __out_ecount_opt(ulNameLength) LPWSTR pszVetoName,
    __in  ULONG         ulNameLength,
    __in  ULONG         ulFlags,
    __in_opt HMACHINE   hMachine
    );
#ifdef UNICODE
#define CM_Query_And_Remove_SubTree     CM_Query_And_Remove_SubTreeW
#define CM_Query_And_Remove_SubTree_Ex  CM_Query_And_Remove_SubTree_ExW
#else
#define CM_Query_And_Remove_SubTree     CM_Query_And_Remove_SubTreeA
#define CM_Query_And_Remove_SubTree_Ex  CM_Query_And_Remove_SubTree_ExA
#endif // UNICODE

CMAPI
CONFIGRET
WINAPI
CM_Request_Device_EjectA(
    __in  DEVINST       dnDevInst,
    __out_opt PPNP_VETO_TYPE pVetoType,
    __out_ecount_opt(ulNameLength) LPSTR pszVetoName,
    __in  ULONG         ulNameLength,
    __in  ULONG         ulFlags
    );
CMAPI
CONFIGRET
WINAPI
CM_Request_Device_Eject_ExA(
    __in  DEVINST       dnDevInst,
    __out_opt PPNP_VETO_TYPE pVetoType,
    __out_ecount_opt(ulNameLength) LPSTR pszVetoName,
    __in  ULONG         ulNameLength,
    __in  ULONG         ulFlags,
    __in_opt HMACHINE   hMachine
    );
CMAPI
CONFIGRET
WINAPI
CM_Request_Device_EjectW(
    __in  DEVINST       dnDevInst,
    __out_opt PPNP_VETO_TYPE pVetoType,
    __out_ecount_opt(ulNameLength) LPWSTR pszVetoName,
    __in  ULONG         ulNameLength,
    __in  ULONG         ulFlags
    );
CMAPI
CONFIGRET
WINAPI
CM_Request_Device_Eject_ExW(
    __in  DEVINST       dnDevInst,
    __out_opt PPNP_VETO_TYPE pVetoType,
    __out_ecount_opt(ulNameLength) LPWSTR pszVetoName,
    __in  ULONG         ulNameLength,
    __in  ULONG         ulFlags,
    __in_opt HMACHINE   hMachine
    );
#ifdef UNICODE
#define CM_Request_Device_Eject         CM_Request_Device_EjectW
#define CM_Request_Device_Eject_Ex      CM_Request_Device_Eject_ExW
#else
#define CM_Request_Device_Eject         CM_Request_Device_EjectA
#define CM_Request_Device_Eject_Ex      CM_Request_Device_Eject_ExA
#endif // UNICODE

CMAPI
CONFIGRET
WINAPI
CM_Reenumerate_DevNode(
    __in  DEVINST       dnDevInst,
    __in  ULONG         ulFlags
    );
CMAPI
CONFIGRET
WINAPI
CM_Reenumerate_DevNode_Ex(
    __in  DEVINST       dnDevInst,
    __in  ULONG         ulFlags,
    __in_opt HMACHINE   hMachine
    );
#define CM_Reenumerate_DevInst      CM_Reenumerate_DevNode
#define CM_Reenumerate_DevInst_Ex   CM_Reenumerate_DevNode_Ex

CMAPI
CONFIGRET
WINAPI
CM_Register_Device_InterfaceA(
    __in  DEVINST       dnDevInst,
    __in  LPGUID        InterfaceClassGuid,
    __in_opt LPCSTR     pszReference,
    __out_ecount(*pulLength) LPSTR pszDeviceInterface,
    __inout PULONG      pulLength,
    __in  ULONG         ulFlags
    );
CMAPI
CONFIGRET
WINAPI
CM_Register_Device_InterfaceW(
    __in  DEVINST       dnDevInst,
    __in  LPGUID        InterfaceClassGuid,
    __in_opt LPCWSTR    pszReference,
    __out_ecount(*pulLength) LPWSTR pszDeviceInterface,
    __inout PULONG      pulLength,
    __in  ULONG         ulFlags
    );
CMAPI
CONFIGRET
WINAPI
CM_Register_Device_Interface_ExA(
    __in  DEVINST       dnDevInst,
    __in  LPGUID        InterfaceClassGuid,
    __in_opt LPCSTR     pszReference,
    __out_ecount(*pulLength) LPSTR pszDeviceInterface,
    __inout PULONG      pulLength,
    __in  ULONG         ulFlags,
    __in_opt HMACHINE   hMachine
    );
CMAPI
CONFIGRET
WINAPI
CM_Register_Device_Interface_ExW(
    __in  DEVINST       dnDevInst,
    __in  LPGUID        InterfaceClassGuid,
    __in_opt LPCWSTR    pszReference,
    __out_ecount(*pulLength) LPWSTR pszDeviceInterface,
    __inout PULONG      pulLength,
    __in  ULONG         ulFlags,
    __in_opt HMACHINE   hMachine
    );
#ifdef UNICODE
#define CM_Register_Device_Interface    CM_Register_Device_InterfaceW
#define CM_Register_Device_Interface_Ex CM_Register_Device_Interface_ExW
#else
#define CM_Register_Device_Interface    CM_Register_Device_InterfaceA
#define CM_Register_Device_Interface_Ex CM_Register_Device_Interface_ExA
#endif // UNICODE

CMAPI
CONFIGRET
WINAPI
CM_Set_DevNode_Problem_Ex(
    __in  DEVINST       dnDevInst,
    __in  ULONG         ulProblem,
    __in  ULONG         ulFlags,
    __in_opt HMACHINE   hMachine
    );
CMAPI
CONFIGRET
WINAPI
CM_Set_DevNode_Problem(
    __in  DEVINST       dnDevInst,
    __in  ULONG         ulProblem,
    __in  ULONG         ulFlags
    );
#define CM_Set_DevInst_Problem      CM_Set_DevNode_Problem
#define CM_Set_DevInst_Problem_Ex   CM_Set_DevNode_Problem_Ex

CMAPI
CONFIGRET
WINAPI
CM_Unregister_Device_InterfaceA(
    __in  LPCSTR        pszDeviceInterface,
    __in  ULONG         ulFlags
    );
CMAPI
CONFIGRET
WINAPI
CM_Unregister_Device_InterfaceW(
    __in  LPCWSTR       pszDeviceInterface,
    __in  ULONG         ulFlags
    );
CMAPI
CONFIGRET
WINAPI
CM_Unregister_Device_Interface_ExA(
    __in  LPCSTR        pszDeviceInterface,
    __in  ULONG         ulFlags,
    __in_opt HMACHINE   hMachine
    );
CMAPI
CONFIGRET
WINAPI
CM_Unregister_Device_Interface_ExW(
    __in  LPCWSTR       pszDeviceInterface,
    __in  ULONG         ulFlags,
    __in_opt HMACHINE   hMachine
    );
#ifdef UNICODE
#define CM_Unregister_Device_Interface    CM_Unregister_Device_InterfaceW
#define CM_Unregister_Device_Interface_Ex CM_Unregister_Device_Interface_ExW
#else
#define CM_Unregister_Device_Interface    CM_Unregister_Device_InterfaceA
#define CM_Unregister_Device_Interface_Ex CM_Unregister_Device_Interface_ExA
#endif // UNICODE

CMAPI
CONFIGRET
WINAPI
CM_Register_Device_Driver(
    __in  DEVINST       dnDevInst,
    __in  ULONG         ulFlags
    );
CMAPI
CONFIGRET
WINAPI
CM_Register_Device_Driver_Ex(
    __in  DEVINST       dnDevInst,
    __in  ULONG         ulFlags,
    __in_opt HMACHINE   hMachine
    );

CMAPI
CONFIGRET
WINAPI
CM_Remove_SubTree(
    __in  DEVINST       dnAncestor,
    __in  ULONG         ulFlags
    );
CMAPI
CONFIGRET
WINAPI
CM_Remove_SubTree_Ex(
    __in  DEVINST       dnAncestor,
    __in  ULONG         ulFlags,
    __in_opt HMACHINE   hMachine
    );

CMAPI
CONFIGRET
WINAPI
CM_Set_DevNode_Registry_PropertyA(
    __in  DEVINST       dnDevInst,
    __in  ULONG         ulProperty,
    __in_bcount_opt(ulLength) PCVOID Buffer,
    __in  ULONG         ulLength,
    __in  ULONG         ulFlags
    );
CMAPI
CONFIGRET
WINAPI
CM_Set_DevNode_Registry_PropertyW(
    __in  DEVINST       dnDevInst,
    __in  ULONG         ulProperty,
    __in_bcount_opt(ulLength) PCVOID Buffer,
    __in  ULONG         ulLength,
    __in  ULONG         ulFlags
    );
CMAPI
CONFIGRET
WINAPI
CM_Set_DevNode_Registry_Property_ExA(
    __in  DEVINST       dnDevInst,
    __in  ULONG         ulProperty,
    __in_bcount_opt(ulLength) PCVOID Buffer,
    __in  ULONG         ulLength,
    __in  ULONG         ulFlags,
    __in_opt HMACHINE   hMachine
    );
CMAPI
CONFIGRET
WINAPI
CM_Set_DevNode_Registry_Property_ExW(
    __in  DEVINST       dnDevInst,
    __in  ULONG         ulProperty,
    __in_bcount_opt(ulLength) PCVOID Buffer,
    __in  ULONG         ulLength,
    __in  ULONG         ulFlags,
    __in_opt HMACHINE   hMachine
    );
#define CM_Set_DevInst_Registry_PropertyW     CM_Set_DevNode_Registry_PropertyW
#define CM_Set_DevInst_Registry_PropertyA     CM_Set_DevNode_Registry_PropertyA
#define CM_Set_DevInst_Registry_Property_ExW  CM_Set_DevNode_Registry_Property_ExW
#define CM_Set_DevInst_Registry_Property_ExA  CM_Set_DevNode_Registry_Property_ExA
#ifdef UNICODE
#define CM_Set_DevInst_Registry_Property      CM_Set_DevNode_Registry_PropertyW
#define CM_Set_DevInst_Registry_Property_Ex   CM_Set_DevNode_Registry_Property_ExW
#define CM_Set_DevNode_Registry_Property      CM_Set_DevNode_Registry_PropertyW
#define CM_Set_DevNode_Registry_Property_Ex   CM_Set_DevNode_Registry_Property_ExW
#else
#define CM_Set_DevInst_Registry_Property      CM_Set_DevNode_Registry_PropertyA
#define CM_Set_DevInst_Registry_Property_Ex   CM_Set_DevNode_Registry_Property_ExA
#define CM_Set_DevNode_Registry_Property      CM_Set_DevNode_Registry_PropertyA
#define CM_Set_DevNode_Registry_Property_Ex   CM_Set_DevNode_Registry_Property_ExA
#endif // UNICODE

CMAPI
CONFIGRET
WINAPI
CM_Is_Dock_Station_Present(
    __out PBOOL         pbPresent
    );
CMAPI
CONFIGRET
WINAPI
CM_Is_Dock_Station_Present_Ex(
    __out PBOOL         pbPresent,
    __in_opt HMACHINE   hMachine
    );

CMAPI
CONFIGRET
WINAPI
CM_Request_Eject_PC(
    VOID
    );
CMAPI
CONFIGRET
WINAPI
CM_Request_Eject_PC_Ex(
    __in_opt HMACHINE   hMachine
    );

CMAPI
CONFIGRET
WINAPI
CM_Set_HW_Prof_FlagsA(
    __in  DEVINSTID_A   pDeviceID,
    __in  ULONG         ulConfig,
    __in  ULONG         ulValue,
    __in  ULONG         ulFlags
    );
CMAPI
CONFIGRET
WINAPI
CM_Set_HW_Prof_FlagsW(
    __in  DEVINSTID_W   pDeviceID,
    __in  ULONG         ulConfig,
    __in  ULONG         ulValue,
    __in  ULONG         ulFlags
    );
CMAPI
CONFIGRET
WINAPI
CM_Set_HW_Prof_Flags_ExA(
    __in  DEVINSTID_A   pDeviceID,
    __in  ULONG         ulConfig,
    __in  ULONG         ulValue,
    __in  ULONG         ulFlags,
    __in_opt HMACHINE   hMachine
    );
CMAPI
CONFIGRET
WINAPI
CM_Set_HW_Prof_Flags_ExW(
    __in  DEVINSTID_W   pDeviceID,
    __in  ULONG         ulConfig,
    __in  ULONG         ulValue,
    __in  ULONG         ulFlags,
    __in_opt HMACHINE   hMachine
    );
#ifdef UNICODE
#define CM_Set_HW_Prof_Flags     CM_Set_HW_Prof_FlagsW
#define CM_Set_HW_Prof_Flags_Ex  CM_Set_HW_Prof_Flags_ExW
#else
#define CM_Set_HW_Prof_Flags     CM_Set_HW_Prof_FlagsA
#define CM_Set_HW_Prof_Flags_Ex  CM_Set_HW_Prof_Flags_ExA
#endif // UNICODE

CMAPI
CONFIGRET
WINAPI
CM_Setup_DevNode(
    __in  DEVINST       dnDevInst,
    __in  ULONG         ulFlags
    );
CMAPI
CONFIGRET
WINAPI
CM_Setup_DevNode_Ex(
    __in  DEVINST       dnDevInst,
    __in  ULONG         ulFlags,
    __in_opt HMACHINE   hMachine
    );
#define CM_Setup_DevInst         CM_Setup_DevNode
#define CM_Setup_DevInst_Ex      CM_Setup_DevNode_Ex

CMAPI
CONFIGRET
WINAPI
CM_Test_Range_Available(
    __in  DWORDLONG     ullStartValue,
    __in  DWORDLONG     ullEndValue,
    __in  RANGE_LIST    rlh,
    __in  ULONG         ulFlags
    );

CMAPI
CONFIGRET
WINAPI
CM_Uninstall_DevNode(
    __in  DEVNODE       dnDevInst,
    __in  ULONG         ulFlags
    );
CMAPI
CONFIGRET
WINAPI
CM_Uninstall_DevNode_Ex(
    __in  DEVNODE       dnDevInst,
    __in  ULONG         ulFlags,
    __in_opt HMACHINE   hMachine
    );
#define CM_Uninstall_DevInst     CM_Uninstall_DevNode
#define CM_Uninstall_DevInst_Ex  CM_Uninstall_DevNode_Ex

CMAPI
CONFIGRET
WINAPI
CM_Run_Detection(
    __in  ULONG         ulFlags
    );
CMAPI
CONFIGRET
WINAPI
CM_Run_Detection_Ex(
    __in  ULONG         ulFlags,
    __in_opt HMACHINE   hMachine
    );

#if (WINVER >= _WIN32_WINNT_LONGHORN)
CONFIGRET
CM_Apply_PowerScheme(
    VOID
    );
    
CONFIGRET
CM_Write_UserPowerKey(
    __in_opt CONST GUID *SchemeGuid,
    __in_opt CONST GUID *SubGroupOfPowerSettingsGuid,
    __in_opt CONST GUID *PowerSettingGuid,
    __in ULONG AccessFlags,
    __in ULONG Type,
    __in_bcount(BufferSize) UCHAR *Buffer,
    __in DWORD BufferSize,
    __out PDWORD Error
    );
    

CONFIGRET
CM_Set_ActiveScheme(
    __in CONST GUID *SchemeGuid,
    __out PDWORD Error
    );
    
CONFIGRET
CM_Restore_DefaultPowerScheme(
    __in CONST GUID *SchemeGuid,
    __out PDWORD Error
    );
    
CONFIGRET
CM_RestoreAll_DefaultPowerSchemes(
    __out PDWORD Error
    );
    
CONFIGRET
CM_Duplicate_PowerScheme (
    __in CONST GUID *SourceSchemeGuid,
    __in GUID **DestinationSchemeGuid,
    __out PDWORD Error
    );
    
CONFIGRET
CM_Delete_PowerScheme (
    __in CONST GUID *SchemeGuid,
    __out PDWORD Error
    );
    
CONFIGRET
CM_Import_PowerScheme (
    __in LPCWSTR ImportFileNamePath,
    __deref_inout GUID **DestinationSchemeGuid,
    __out PDWORD Error
    );

#endif // (WINVER >= _WIN32_WINNT_LONGHORN)

CMAPI
CONFIGRET
WINAPI
CM_Set_HW_Prof(
    __in  ULONG         ulHardwareProfile,
    __in  ULONG         ulFlags
    );
CMAPI
CONFIGRET
WINAPI
CM_Set_HW_Prof_Ex(
    __in  ULONG         ulHardwareProfile,
    __in  ULONG         ulFlags,
    __in_opt HMACHINE   hMachine
    );

CMAPI
CONFIGRET
WINAPI
CM_Query_Resource_Conflict_List(
    __out PCONFLICT_LIST pclConflictList,
    __in  DEVINST       dnDevInst,
    __in  RESOURCEID    ResourceID,
    __in_bcount(ResourceLen) PCVOID ResourceData,
    __in  ULONG         ResourceLen,
    __in  ULONG         ulFlags,
    __in_opt HMACHINE   hMachine
    );

CMAPI
CONFIGRET
WINAPI
CM_Free_Resource_Conflict_Handle(
    __in  CONFLICT_LIST clConflictList
    );

CMAPI
CONFIGRET
WINAPI
CM_Get_Resource_Conflict_Count(
    __in  CONFLICT_LIST clConflictList,
    __out PULONG        pulCount
    );

CMAPI
CONFIGRET
WINAPI
CM_Get_Resource_Conflict_DetailsA(
    __in  CONFLICT_LIST clConflictList,
    __in  ULONG         ulIndex,
    __inout PCONFLICT_DETAILS_A pConflictDetails
    );
CMAPI
CONFIGRET
WINAPI
CM_Get_Resource_Conflict_DetailsW(
    __in  CONFLICT_LIST clConflictList,
    __in  ULONG         ulIndex,
    __inout PCONFLICT_DETAILS_W pConflictDetails
    );
#ifdef UNICODE
#define CM_Get_Resource_Conflict_Details CM_Get_Resource_Conflict_DetailsW
#else
#define CM_Get_Resource_Conflict_Details CM_Get_Resource_Conflict_DetailsA
#endif // UNICODE

CMAPI
CONFIGRET
WINAPI
CM_Get_Class_Registry_PropertyW(
    __in  LPGUID        ClassGuid,
    __in  ULONG         ulProperty,
    __out_opt PULONG    pulRegDataType,
    __out_bcount_opt(*pulLength) PVOID Buffer,
    __inout PULONG      pulLength,
    __in  ULONG         ulFlags,
    __in_opt HMACHINE   hMachine
    );
CMAPI
CONFIGRET
WINAPI
CM_Set_Class_Registry_PropertyW(
    __in  LPGUID        ClassGuid,
    __in  ULONG         ulProperty,
    __in_bcount_opt(ulLength) PCVOID Buffer,
    __in  ULONG         ulLength,
    __in  ULONG         ulFlags,
    __in_opt HMACHINE   hMachine
    );
CMAPI
CONFIGRET
WINAPI
CM_Get_Class_Registry_PropertyA(
    __in  LPGUID        ClassGuid,
    __in  ULONG         ulProperty,
    __out_opt PULONG    pulRegDataType,
    __out_bcount_opt(*pulLength) PVOID Buffer,
    __inout PULONG      pulLength,
    __in  ULONG         ulFlags,
    __in_opt HMACHINE   hMachine
    );
CMAPI
CONFIGRET
WINAPI
CM_Set_Class_Registry_PropertyA(
    __in  LPGUID        ClassGuid,
    __in  ULONG         ulProperty,
    __in_bcount_opt(ulLength) PCVOID Buffer,
    __in  ULONG         ulLength,
    __in  ULONG         ulFlags,
    __in_opt HMACHINE   hMachine
    );
#ifdef UNICODE
#define CM_Get_Class_Registry_Property CM_Get_Class_Registry_PropertyW
#define CM_Set_Class_Registry_Property CM_Set_Class_Registry_PropertyW
#else
#define CM_Get_Class_Registry_Property CM_Get_Class_Registry_PropertyA
#define CM_Set_Class_Registry_Property CM_Set_Class_Registry_PropertyA
#endif // UNICODE

#if (WINVER >= _WIN32_WINNT_WINXP)
#define CM_WaitNoPendingInstallEvents CMP_WaitNoPendingInstallEvents

DWORD
WINAPI
CM_WaitNoPendingInstallEvents(
    __in  DWORD dwTimeout
    );
#endif // (WINVER >= _WIN32_WINNT_WINXP)


//--------------------------------------------------------------
// Configuration Manager return status codes
//--------------------------------------------------------------

#define CR_SUCCESS                  (0x00000000)
#define CR_DEFAULT                  (0x00000001)
#define CR_OUT_OF_MEMORY            (0x00000002)
#define CR_INVALID_POINTER          (0x00000003)
#define CR_INVALID_FLAG             (0x00000004)
#define CR_INVALID_DEVNODE          (0x00000005)
#define CR_INVALID_DEVINST          CR_INVALID_DEVNODE
#define CR_INVALID_RES_DES          (0x00000006)
#define CR_INVALID_LOG_CONF         (0x00000007)
#define CR_INVALID_ARBITRATOR       (0x00000008)
#define CR_INVALID_NODELIST         (0x00000009)
#define CR_DEVNODE_HAS_REQS         (0x0000000A)
#define CR_DEVINST_HAS_REQS         CR_DEVNODE_HAS_REQS
#define CR_INVALID_RESOURCEID       (0x0000000B)
#define CR_DLVXD_NOT_FOUND          (0x0000000C)   // WIN 95 ONLY
#define CR_NO_SUCH_DEVNODE          (0x0000000D)
#define CR_NO_SUCH_DEVINST          CR_NO_SUCH_DEVNODE
#define CR_NO_MORE_LOG_CONF         (0x0000000E)
#define CR_NO_MORE_RES_DES          (0x0000000F)
#define CR_ALREADY_SUCH_DEVNODE     (0x00000010)
#define CR_ALREADY_SUCH_DEVINST     CR_ALREADY_SUCH_DEVNODE
#define CR_INVALID_RANGE_LIST       (0x00000011)
#define CR_INVALID_RANGE            (0x00000012)
#define CR_FAILURE                  (0x00000013)
#define CR_NO_SUCH_LOGICAL_DEV      (0x00000014)
#define CR_CREATE_BLOCKED           (0x00000015)
#define CR_NOT_SYSTEM_VM            (0x00000016)   // WIN 95 ONLY
#define CR_REMOVE_VETOED            (0x00000017)
#define CR_APM_VETOED               (0x00000018)
#define CR_INVALID_LOAD_TYPE        (0x00000019)
#define CR_BUFFER_SMALL             (0x0000001A)
#define CR_NO_ARBITRATOR            (0x0000001B)
#define CR_NO_REGISTRY_HANDLE       (0x0000001C)
#define CR_REGISTRY_ERROR           (0x0000001D)
#define CR_INVALID_DEVICE_ID        (0x0000001E)
#define CR_INVALID_DATA             (0x0000001F)
#define CR_INVALID_API              (0x00000020)
#define CR_DEVLOADER_NOT_READY      (0x00000021)
#define CR_NEED_RESTART             (0x00000022)
#define CR_NO_MORE_HW_PROFILES      (0x00000023)
#define CR_DEVICE_NOT_THERE         (0x00000024)
#define CR_NO_SUCH_VALUE            (0x00000025)
#define CR_WRONG_TYPE               (0x00000026)
#define CR_INVALID_PRIORITY         (0x00000027)
#define CR_NOT_DISABLEABLE          (0x00000028)
#define CR_FREE_RESOURCES           (0x00000029)
#define CR_QUERY_VETOED             (0x0000002A)
#define CR_CANT_SHARE_IRQ           (0x0000002B)
#define CR_NO_DEPENDENT             (0x0000002C)
#define CR_SAME_RESOURCES           (0x0000002D)
#define CR_NO_SUCH_REGISTRY_KEY     (0x0000002E)
#define CR_INVALID_MACHINENAME      (0x0000002F)   // NT ONLY
#define CR_REMOTE_COMM_FAILURE      (0x00000030)   // NT ONLY
#define CR_MACHINE_UNAVAILABLE      (0x00000031)   // NT ONLY
#define CR_NO_CM_SERVICES           (0x00000032)   // NT ONLY
#define CR_ACCESS_DENIED            (0x00000033)   // NT ONLY
#define CR_CALL_NOT_IMPLEMENTED     (0x00000034)
#define CR_INVALID_PROPERTY         (0x00000035)
#define CR_DEVICE_INTERFACE_ACTIVE  (0x00000036)
#define CR_NO_SUCH_DEVICE_INTERFACE (0x00000037)
#define CR_INVALID_REFERENCE_STRING (0x00000038)
#define CR_INVALID_CONFLICT_LIST    (0x00000039)
#define CR_INVALID_INDEX            (0x0000003A)
#define CR_INVALID_STRUCTURE_SIZE   (0x0000003B)
#define NUM_CR_RESULTS              (0x0000003C)

#ifdef __cplusplus
}
#endif

#endif // _CFGMGR32_H_
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\vs9sp1\sdk\include\ChanMgr.h ===
/* this ALWAYS GENERATED file contains the definitions for the interfaces */


 /* File created by MIDL compiler version 7.00.0447 */
/* Compiler settings for chanmgr.idl:
    Oicf, W1, Zp8, env=Win32 (32b run)
    protocol : dce , ms_ext, c_ext, robust
    error checks: allocation ref bounds_check enum stub_data 
    VC __declspec() decoration level: 
         __declspec(uuid()), __declspec(selectany), __declspec(novtable)
         DECLSPEC_UUID(), MIDL_INTERFACE()
*/
//@@MIDL_FILE_HEADING(  )

#pragma warning( disable: 4049 )  /* more than 64k source lines */


/* verify that the <rpcndr.h> version is high enough to compile this file*/
#ifndef __REQUIRED_RPCNDR_H_VERSION__
#define __REQUIRED_RPCNDR_H_VERSION__ 475
#endif

/* verify that the <rpcsal.h> version is high enough to compile this file*/
#ifndef __REQUIRED_RPCSAL_H_VERSION__
#define __REQUIRED_RPCSAL_H_VERSION__ 100
#endif

#include "rpc.h"
#include "rpcndr.h"

#ifndef __RPCNDR_H_VERSION__
#error this stub requires an updated version of <rpcndr.h>
#endif // __RPCNDR_H_VERSION__


#ifndef __chanmgr_h__
#define __chanmgr_h__

#if defined(_MSC_VER) && (_MSC_VER >= 1020)
#pragma once
#endif

/* Forward Declarations */ 

#ifndef __IChannelMgr_FWD_DEFINED__
#define __IChannelMgr_FWD_DEFINED__
typedef interface IChannelMgr IChannelMgr;
#endif 	/* __IChannelMgr_FWD_DEFINED__ */


#ifndef __IEnumChannels_FWD_DEFINED__
#define __IEnumChannels_FWD_DEFINED__
typedef interface IEnumChannels IEnumChannels;
#endif 	/* __IEnumChannels_FWD_DEFINED__ */


#ifndef __ChannelMgr_FWD_DEFINED__
#define __ChannelMgr_FWD_DEFINED__

#ifdef __cplusplus
typedef class ChannelMgr ChannelMgr;
#else
typedef struct ChannelMgr ChannelMgr;
#endif /* __cplusplus */

#endif 	/* __ChannelMgr_FWD_DEFINED__ */


/* header files for imported files */
#include "unknwn.h"

#ifdef __cplusplus
extern "C"{
#endif 


/* interface __MIDL_itf_chanmgr_0000_0000 */
/* [local] */ 

//=--------------------------------------------------------------------------=
// chanmgr.h
//=--------------------------------------------------------------------------=
// Copyright (c) Microsoft Corporation. All rights reserved.
//
// THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF
// ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO
// THE IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A
// PARTICULAR PURPOSE.
//=--------------------------------------------------------------------------=

#pragma comment(lib,"uuid.lib")

//---------------------------------------------------------------------------=
// Channel Manager Interfaces.





extern RPC_IF_HANDLE __MIDL_itf_chanmgr_0000_0000_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_chanmgr_0000_0000_v0_0_s_ifspec;


#ifndef __CHANNELMGR_LIBRARY_DEFINED__
#define __CHANNELMGR_LIBRARY_DEFINED__

/* library CHANNELMGR */
/* [version][lcid][helpstring][uuid] */ 


EXTERN_C const IID LIBID_CHANNELMGR;

#ifndef __IChannelMgr_INTERFACE_DEFINED__
#define __IChannelMgr_INTERFACE_DEFINED__

/* interface IChannelMgr */
/* [object][helpstring][uuid] */ 

typedef struct _tagChannelShortcutInfo
    {
    DWORD cbSize;
    LPWSTR pszTitle;
    LPWSTR pszURL;
    LPWSTR pszLogo;
    LPWSTR pszIcon;
    LPWSTR pszWideLogo;
    BOOL bIsSoftware;
    } 	CHANNELSHORTCUTINFO;

typedef struct _tagChannelCategoryInfo
    {
    DWORD cbSize;
    LPWSTR pszTitle;
    LPWSTR pszURL;
    LPWSTR pszLogo;
    LPWSTR pszIcon;
    LPWSTR pszWideLogo;
    } 	CHANNELCATEGORYINFO;

typedef 
enum _tagChannelEnumFlags
    {	CHANENUM_CHANNELFOLDER	= 0x1,
	CHANENUM_SOFTUPDATEFOLDER	= 0x2,
	CHANENUM_DESKTOPFOLDER	= 0x4,
	CHANENUM_TITLE	= 0x10000,
	CHANENUM_PATH	= 0x20000,
	CHANENUM_URL	= 0x40000,
	CHANENUM_SUBSCRIBESTATE	= 0x80000
    } 	CHANNELENUMFLAGS;

#define CHANENUM_ALLFOLDERS (CHANENUM_CHANNELFOLDER    |    \
                             CHANENUM_SOFTUPDATEFOLDER |    \
                             CHANENUM_DESKTOPFOLDER          )

#define CHANENUM_ALLDATA    (CHANENUM_TITLE            |    \
                             CHANENUM_PATH             |    \
                             CHANENUM_URL              |    \
                             CHANENUM_SUBSCRIBESTATE         )

#define CHANENUM_ALL        (CHANENUM_CHANNELFOLDER    |    \
                             CHANENUM_SOFTUPDATEFOLDER |    \
                             CHANENUM_DESKTOPFOLDER    |    \
                             CHANENUM_TITLE            |    \
                             CHANENUM_PATH             |    \
                             CHANENUM_URL              |    \
                             CHANENUM_SUBSCRIBESTATE         )


EXTERN_C const IID IID_IChannelMgr;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("85BD8E82-0FBA-11d1-90C3-00C04FC2F568")
    IChannelMgr : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE AddChannelShortcut( 
            /* [in] */ __RPC__in CHANNELSHORTCUTINFO *pChannelInfo) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE DeleteChannelShortcut( 
            /* [in] */ __RPC__in LPWSTR pszTitle) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE AddCategory( 
            /* [in] */ __RPC__in CHANNELCATEGORYINFO *pCategoryInfo) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE DeleteCategory( 
            /* [in] */ __RPC__in LPWSTR pszTitle) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE EnumChannels( 
            /* [in] */ DWORD dwEnumFlags,
            /* [in] */ __RPC__in LPCWSTR pszURL,
            /* [out] */ __RPC__deref_out_opt IEnumChannels **pIEnumChannels) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IChannelMgrVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IChannelMgr * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [iid_is][out] */ __RPC__deref_out_opt void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IChannelMgr * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IChannelMgr * This);
        
        HRESULT ( STDMETHODCALLTYPE *AddChannelShortcut )( 
            IChannelMgr * This,
            /* [in] */ __RPC__in CHANNELSHORTCUTINFO *pChannelInfo);
        
        HRESULT ( STDMETHODCALLTYPE *DeleteChannelShortcut )( 
            IChannelMgr * This,
            /* [in] */ __RPC__in LPWSTR pszTitle);
        
        HRESULT ( STDMETHODCALLTYPE *AddCategory )( 
            IChannelMgr * This,
            /* [in] */ __RPC__in CHANNELCATEGORYINFO *pCategoryInfo);
        
        HRESULT ( STDMETHODCALLTYPE *DeleteCategory )( 
            IChannelMgr * This,
            /* [in] */ __RPC__in LPWSTR pszTitle);
        
        HRESULT ( STDMETHODCALLTYPE *EnumChannels )( 
            IChannelMgr * This,
            /* [in] */ DWORD dwEnumFlags,
            /* [in] */ __RPC__in LPCWSTR pszURL,
            /* [out] */ __RPC__deref_out_opt IEnumChannels **pIEnumChannels);
        
        END_INTERFACE
    } IChannelMgrVtbl;

    interface IChannelMgr
    {
        CONST_VTBL struct IChannelMgrVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IChannelMgr_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IChannelMgr_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IChannelMgr_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IChannelMgr_AddChannelShortcut(This,pChannelInfo)	\
    ( (This)->lpVtbl -> AddChannelShortcut(This,pChannelInfo) ) 

#define IChannelMgr_DeleteChannelShortcut(This,pszTitle)	\
    ( (This)->lpVtbl -> DeleteChannelShortcut(This,pszTitle) ) 

#define IChannelMgr_AddCategory(This,pCategoryInfo)	\
    ( (This)->lpVtbl -> AddCategory(This,pCategoryInfo) ) 

#define IChannelMgr_DeleteCategory(This,pszTitle)	\
    ( (This)->lpVtbl -> DeleteCategory(This,pszTitle) ) 

#define IChannelMgr_EnumChannels(This,dwEnumFlags,pszURL,pIEnumChannels)	\
    ( (This)->lpVtbl -> EnumChannels(This,dwEnumFlags,pszURL,pIEnumChannels) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IChannelMgr_AddChannelShortcut_Proxy( 
    IChannelMgr * This,
    /* [in] */ __RPC__in CHANNELSHORTCUTINFO *pChannelInfo);


void __RPC_STUB IChannelMgr_AddChannelShortcut_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IChannelMgr_DeleteChannelShortcut_Proxy( 
    IChannelMgr * This,
    /* [in] */ __RPC__in LPWSTR pszTitle);


void __RPC_STUB IChannelMgr_DeleteChannelShortcut_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IChannelMgr_AddCategory_Proxy( 
    IChannelMgr * This,
    /* [in] */ __RPC__in CHANNELCATEGORYINFO *pCategoryInfo);


void __RPC_STUB IChannelMgr_AddCategory_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IChannelMgr_DeleteCategory_Proxy( 
    IChannelMgr * This,
    /* [in] */ __RPC__in LPWSTR pszTitle);


void __RPC_STUB IChannelMgr_DeleteCategory_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IChannelMgr_EnumChannels_Proxy( 
    IChannelMgr * This,
    /* [in] */ DWORD dwEnumFlags,
    /* [in] */ __RPC__in LPCWSTR pszURL,
    /* [out] */ __RPC__deref_out_opt IEnumChannels **pIEnumChannels);


void __RPC_STUB IChannelMgr_EnumChannels_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IChannelMgr_INTERFACE_DEFINED__ */


#ifndef __IEnumChannels_INTERFACE_DEFINED__
#define __IEnumChannels_INTERFACE_DEFINED__

/* interface IEnumChannels */
/* [object][helpstring][uuid] */ 

typedef 
enum _tagSubcriptionState
    {	SUBSTATE_NOTSUBSCRIBED	= 0,
	SUBSTATE_PARTIALSUBSCRIPTION	= ( SUBSTATE_NOTSUBSCRIBED + 1 ) ,
	SUBSTATE_FULLSUBSCRIPTION	= ( SUBSTATE_PARTIALSUBSCRIPTION + 1 ) 
    } 	SUBSCRIPTIONSTATE;

typedef struct _tagChannelInfo
    {
    LPOLESTR pszTitle;
    LPOLESTR pszPath;
    LPOLESTR pszURL;
    SUBSCRIPTIONSTATE stSubscriptionState;
    } 	CHANNELENUMINFO;


EXTERN_C const IID IID_IEnumChannels;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("A4C65425-0F82-11d1-90C3-00C04FC2F568")
    IEnumChannels : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE Next( 
            ULONG celt,
            __RPC__in CHANNELENUMINFO *rgChanInf,
            __RPC__in ULONG *pceltFetched) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Skip( 
            ULONG celt) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Reset( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Clone( 
            __RPC__deref_in_opt IEnumChannels **ppenum) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IEnumChannelsVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IEnumChannels * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [iid_is][out] */ __RPC__deref_out_opt void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IEnumChannels * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IEnumChannels * This);
        
        HRESULT ( STDMETHODCALLTYPE *Next )( 
            IEnumChannels * This,
            ULONG celt,
            __RPC__in CHANNELENUMINFO *rgChanInf,
            __RPC__in ULONG *pceltFetched);
        
        HRESULT ( STDMETHODCALLTYPE *Skip )( 
            IEnumChannels * This,
            ULONG celt);
        
        HRESULT ( STDMETHODCALLTYPE *Reset )( 
            IEnumChannels * This);
        
        HRESULT ( STDMETHODCALLTYPE *Clone )( 
            IEnumChannels * This,
            __RPC__deref_in_opt IEnumChannels **ppenum);
        
        END_INTERFACE
    } IEnumChannelsVtbl;

    interface IEnumChannels
    {
        CONST_VTBL struct IEnumChannelsVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IEnumChannels_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IEnumChannels_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IEnumChannels_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IEnumChannels_Next(This,celt,rgChanInf,pceltFetched)	\
    ( (This)->lpVtbl -> Next(This,celt,rgChanInf,pceltFetched) ) 

#define IEnumChannels_Skip(This,celt)	\
    ( (This)->lpVtbl -> Skip(This,celt) ) 

#define IEnumChannels_Reset(This)	\
    ( (This)->lpVtbl -> Reset(This) ) 

#define IEnumChannels_Clone(This,ppenum)	\
    ( (This)->lpVtbl -> Clone(This,ppenum) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IEnumChannels_Next_Proxy( 
    IEnumChannels * This,
    ULONG celt,
    __RPC__in CHANNELENUMINFO *rgChanInf,
    __RPC__in ULONG *pceltFetched);


void __RPC_STUB IEnumChannels_Next_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IEnumChannels_Skip_Proxy( 
    IEnumChannels * This,
    ULONG celt);


void __RPC_STUB IEnumChannels_Skip_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IEnumChannels_Reset_Proxy( 
    IEnumChannels * This);


void __RPC_STUB IEnumChannels_Reset_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IEnumChannels_Clone_Proxy( 
    IEnumChannels * This,
    __RPC__deref_in_opt IEnumChannels **ppenum);


void __RPC_STUB IEnumChannels_Clone_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IEnumChannels_INTERFACE_DEFINED__ */


EXTERN_C const CLSID CLSID_ChannelMgr;

#ifdef __cplusplus

class DECLSPEC_UUID("b3cdae90-d170-11d0-802b-00c04fd75d13")
ChannelMgr;
#endif
#endif /* __CHANNELMGR_LIBRARY_DEFINED__ */

/* Additional Prototypes for ALL interfaces */

/* end of Additional Prototypes */

#ifdef __cplusplus
}
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\vs9sp1\sdk\include\CGuid.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (c) Microsoft Corporation. All rights reserved.
//
//  File:       cguid.h
//
//--------------------------------------------------------------------------

#ifndef __CGUID_H__
#define __CGUID_H__

#if _MSC_VER > 1000
#pragma once
#endif

#ifdef __cplusplus
extern "C" {
#endif

extern const IID GUID_NULL;

#if(NTDDI_VERSION >= NTDDI_WINXP)
extern const IID CATID_MARSHALER;
#endif

extern const IID IID_IRpcChannel;
extern const IID IID_IRpcStub;
extern const IID IID_IStubManager;
extern const IID IID_IRpcProxy;
extern const IID IID_IProxyManager;
extern const IID IID_IPSFactory;
extern const IID IID_IInternalMoniker;
extern const IID IID_IDfReserved1;
extern const IID IID_IDfReserved2;
extern const IID IID_IDfReserved3;
extern const CLSID CLSID_StdMarshal;
extern const CLSID CLSID_AggStdMarshal;
extern const CLSID CLSID_StdAsyncActManager;
extern const IID IID_IStub;
extern const IID IID_IProxy;
extern const IID IID_IEnumGeneric;
extern const IID IID_IEnumHolder;
extern const IID IID_IEnumCallback;
extern const IID IID_IOleManager;
extern const IID IID_IOlePresObj;
extern const IID IID_IDebug;
extern const IID IID_IDebugStream;
extern const CLSID CLSID_PSGenObject;
extern const CLSID CLSID_PSClientSite;
extern const CLSID CLSID_PSClassObject;
extern const CLSID CLSID_PSInPlaceActive;
extern const CLSID CLSID_PSInPlaceFrame;
extern const CLSID CLSID_PSDragDrop;
extern const CLSID CLSID_PSBindCtx;
extern const CLSID CLSID_PSEnumerators;
extern const CLSID CLSID_StaticMetafile;
extern const CLSID CLSID_StaticDib;
extern const CLSID CID_CDfsVolume;
extern const CLSID CLSID_DCOMAccessControl;
extern const CLSID CLSID_GlobalOptions;
extern const CLSID CLSID_StdGlobalInterfaceTable;
extern const CLSID CLSID_ComBinding;
extern const CLSID CLSID_StdEvent;
extern const CLSID CLSID_ManualResetEvent;
extern const CLSID CLSID_SynchronizeContainer;

#if(NTDDI_VERSION >= NTDDI_WINXP)
extern const CLSID CLSID_AddrControl;
#endif

#if(NTDDI_VERSION >= NTDDI_LONGHORN)
extern const CLSID CLSID_ContextSwitcher;
#endif

//********************************************
//
// CD Forms CLSIDs
//
//********************************************

//
// Form Kernel objects
//
extern const CLSID CLSID_CCDFormKrnl;
extern const CLSID CLSID_CCDPropertyPage;
extern const CLSID CLSID_CCDFormDialog;

//
// Control objects
//
extern const CLSID CLSID_CCDCommandButton;
extern const CLSID CLSID_CCDComboBox;
extern const CLSID CLSID_CCDTextBox;
extern const CLSID CLSID_CCDCheckBox;
extern const CLSID CLSID_CCDLabel;
extern const CLSID CLSID_CCDOptionButton;
extern const CLSID CLSID_CCDListBox;
extern const CLSID CLSID_CCDScrollBar;
extern const CLSID CLSID_CCDGroupBox;

//
// Property Pages
//
extern const CLSID CLSID_CCDGeneralPropertyPage;
extern const CLSID CLSID_CCDGenericPropertyPage;
extern const CLSID CLSID_CCDFontPropertyPage;
extern const CLSID CLSID_CCDColorPropertyPage;
extern const CLSID CLSID_CCDLabelPropertyPage;
extern const CLSID CLSID_CCDCheckBoxPropertyPage;
extern const CLSID CLSID_CCDTextBoxPropertyPage;
extern const CLSID CLSID_CCDOptionButtonPropertyPage;
extern const CLSID CLSID_CCDListBoxPropertyPage;
extern const CLSID CLSID_CCDCommandButtonPropertyPage;
extern const CLSID CLSID_CCDComboBoxPropertyPage;
extern const CLSID CLSID_CCDScrollBarPropertyPage;
extern const CLSID CLSID_CCDGroupBoxPropertyPage;
extern const CLSID CLSID_CCDXObjectPropertyPage;

extern const CLSID CLSID_CStdPropertyFrame;

extern const CLSID CLSID_CFormPropertyPage;
extern const CLSID CLSID_CGridPropertyPage;

extern const CLSID CLSID_CWSJArticlePage;
extern const CLSID CLSID_CSystemPage;

extern const CLSID CLSID_IdentityUnmarshal;
extern const CLSID CLSID_InProcFreeMarshaler;

extern const CLSID CLSID_Picture_Metafile;
extern const CLSID CLSID_Picture_EnhMetafile;
extern const CLSID CLSID_Picture_Dib;

//
// Enumerations
//
extern const GUID GUID_TRISTATE;

#ifdef __cplusplus
}
#endif


#endif // __CGUID_H__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\vs9sp1\sdk\include\ChPtrArr.h ===
//***************************************************************************
//
//  Copyright (c) Microsoft Corporation.  All rights reserved.
//
//  chptrarr.h
//
//  Purpose: Non-MFC CPtrArray class definition
//
//***************************************************************************

#if _MSC_VER > 1000
#pragma once
#endif

#ifndef __CHPTRARRAY__
#define __CHPTRARRAY__

#include <windows.h>
#include <limits.h>
#include <assert.h>
#include <tchar.h>
#include <polarity.h>
#include <ProvExce.h>

class POLARITY CHPtrArray
{
    public :

        // Construction/destruction
        //=========================

    CHPtrArray() ;

// Attributes
    int GetSize() const ;
    int GetUpperBound() const ;
    void SetSize(int nNewSize, int nGrowBy = -1) throw ( CHeap_Exception ) ;

// Operations
    // Clean up
    void FreeExtra() throw ( CHeap_Exception ) ;
    void RemoveAll() ;

    // Accessing elements
    void* GetAt(int nIndex) const ;
    void SetAt(int nIndex, void* newElement) ;
    void*& ElementAt(int nIndex) ;

    // Direct Access to the element data (may return NULL)
    const void** GetData() const ;
    void** GetData() ;

    // Potentially growing the array
    void SetAtGrow(int nIndex, void* newElement) throw ( CHeap_Exception ) ;
    int Add(void* newElement) throw ( CHeap_Exception ) ;
    int Append(const CHPtrArray& src) throw ( CHeap_Exception ) ;
    void Copy(const CHPtrArray& src) throw ( CHeap_Exception ) ;

    // overloaded operator helpers
    void* operator[](int nIndex) const ;
    void*& operator[](int nIndex) ;

    // Operations that move elements around
    void InsertAt(int nIndex, void* newElement, int nCount = 1) throw ( CHeap_Exception ) ;
    void RemoveAt(int nIndex, int nCount = 1) ;
    void InsertAt(int nStartIndex, CHPtrArray* pNewArray) throw ( CHeap_Exception ) ;

// Implementation
protected:
    void** m_pData ;   // the actual array of data
    int m_nSize ;     // # of elements (upperBound - 1)
    int m_nMaxSize ;  // max allocated
    int m_nGrowBy ;   // grow amount

public:
    ~CHPtrArray() ;
#ifdef _DEBUG
//    void Dump(CDumpContext&) const ;
    void AssertValid() const ;
#endif

protected:
    // local typedefs for class templates
    typedef void* BASE_TYPE ;
    typedef void* BASE_ARG_TYPE ;
} ;


#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\vs9sp1\sdk\include\CiError.h ===
#ifndef _CIERROR_H_
#define _CIERROR_H_
#ifndef FACILITY_WINDOWS
//
//  Values are 32 bit values layed out as follows:
//
//   3 3 2 2 2 2 2 2 2 2 2 2 1 1 1 1 1 1 1 1 1 1
//   1 0 9 8 7 6 5 4 3 2 1 0 9 8 7 6 5 4 3 2 1 0 9 8 7 6 5 4 3 2 1 0
//  +---+-+-+-----------------------+-------------------------------+
//  |Sev|C|R|     Facility          |               Code            |
//  +---+-+-+-----------------------+-------------------------------+
//
//  where
//
//      Sev - is the severity code
//
//          00 - Success
//          01 - Informational
//          10 - Warning
//          11 - Error
//
//      C - is the Customer code flag
//
//      R - is a reserved bit
//
//      Facility - is the facility code
//
//      Code - is the facility's status code
//
//
// Define the facility codes
//
#define FACILITY_WINDOWS                 0x8
#define FACILITY_NULL                    0x0
#define FACILITY_ITF                     0x4


//
// Define the severity codes
//
#define STATUS_SEVERITY_SUCCESS          0x0
#define STATUS_SEVERITY_COFAIL           0x3
#define STATUS_SEVERITY_COERROR          0x2


//
// MessageId: NOT_AN_ERROR1
//
// MessageText:
//
//  NOTE:  This dummy error message is necessary to force MC to output
//         the above defines inside the FACILITY_WINDOWS guard instead
//         of leaving it empty.
//
#define NOT_AN_ERROR1                    ((HRESULT)0x00081600L)

#endif // FACILITY_WINDOWS
//
// Range 0x1600-0x1850 is reserved by Content Index.
//
//
// Codes 0x1600-0x164f are reserved for QUERY
//
//
// MessageId: QUERY_E_FAILED
//
// MessageText:
//
//  Call failed for unknown reason.
//
#define QUERY_E_FAILED                   ((HRESULT)0x80041600L)

//
// MessageId: QUERY_E_INVALIDQUERY
//
// MessageText:
//
//  Invalid parameter.
//
#define QUERY_E_INVALIDQUERY             ((HRESULT)0x80041601L)

//
// MessageId: QUERY_E_INVALIDRESTRICTION
//
// MessageText:
//
//  The query restriction could not be parsed.
//
#define QUERY_E_INVALIDRESTRICTION       ((HRESULT)0x80041602L)

//
// MessageId: QUERY_E_INVALIDSORT
//
// MessageText:
//
//  An invalid sort order was requested.
//
#define QUERY_E_INVALIDSORT              ((HRESULT)0x80041603L)

//
// MessageId: QUERY_E_INVALIDCATEGORIZE
//
// MessageText:
//
//  An invalid categorization order was requested.
//
#define QUERY_E_INVALIDCATEGORIZE        ((HRESULT)0x80041604L)

//
// MessageId: QUERY_E_ALLNOISE
//
// MessageText:
//
//  The query contained only ignored words.
//
#define QUERY_E_ALLNOISE                 ((HRESULT)0x80041605L)

//
// MessageId: QUERY_E_TOOCOMPLEX
//
// MessageText:
//
//  The query was too complex to be executed.
//
#define QUERY_E_TOOCOMPLEX               ((HRESULT)0x80041606L)

//
// MessageId: QUERY_E_TIMEDOUT
//
// MessageText:
//
//  The query exceeded its execution time limit.
//
#define QUERY_E_TIMEDOUT                 ((HRESULT)0x80041607L)

//
// MessageId: QUERY_E_DUPLICATE_OUTPUT_COLUMN
//
// MessageText:
//
//  One or more columns in the output column list is a duplicate.
//
#define QUERY_E_DUPLICATE_OUTPUT_COLUMN  ((HRESULT)0x80041608L)

//
// MessageId: QUERY_E_INVALID_OUTPUT_COLUMN
//
// MessageText:
//
//  One or more columns in the output column list is not valid.
//
#define QUERY_E_INVALID_OUTPUT_COLUMN    ((HRESULT)0x80041609L)

//
// MessageId: QUERY_E_INVALID_DIRECTORY
//
// MessageText:
//
//  Invalid directory name.
//
#define QUERY_E_INVALID_DIRECTORY        ((HRESULT)0x8004160AL)

//
// MessageId: QUERY_E_DIR_ON_REMOVABLE_DRIVE
//
// MessageText:
//
//  Specified directory is on a removable medium.
//
#define QUERY_E_DIR_ON_REMOVABLE_DRIVE   ((HRESULT)0x8004160BL)

//
// MessageId: QUERY_S_NO_QUERY
//
// MessageText:
//
//  The catalog is in a state where indexing continues, but queries are not allowed.
//
#define QUERY_S_NO_QUERY                 ((HRESULT)0x8004160CL)

//
// Codes 0x1650-0x167f are reserved for qutil error codes
//
//
// MessageId: QPLIST_E_CANT_OPEN_FILE
//
// MessageText:
//
//  Can not open file.
//
#define QPLIST_E_CANT_OPEN_FILE          ((HRESULT)0x80041651L)

//
// MessageId: QPLIST_E_READ_ERROR
//
// MessageText:
//
//  Read error in file.
//
#define QPLIST_E_READ_ERROR              ((HRESULT)0x80041652L)

//
// MessageId: QPLIST_E_EXPECTING_NAME
//
// MessageText:
//
//  Expecting property name.
//
#define QPLIST_E_EXPECTING_NAME          ((HRESULT)0x80041653L)

//
// MessageId: QPLIST_E_EXPECTING_TYPE
//
// MessageText:
//
//  Expecting type specifier.
//
#define QPLIST_E_EXPECTING_TYPE          ((HRESULT)0x80041654L)

//
// MessageId: QPLIST_E_UNRECOGNIZED_TYPE
//
// MessageText:
//
//  Unrecognized type.
//
#define QPLIST_E_UNRECOGNIZED_TYPE       ((HRESULT)0x80041655L)

//
// MessageId: QPLIST_E_EXPECTING_INTEGER
//
// MessageText:
//
//  Expecting integer.
//
#define QPLIST_E_EXPECTING_INTEGER       ((HRESULT)0x80041656L)

//
// MessageId: QPLIST_E_EXPECTING_CLOSE_PAREN
//
// MessageText:
//
//  Expecting closing parenthesis.
//
#define QPLIST_E_EXPECTING_CLOSE_PAREN   ((HRESULT)0x80041657L)

//
// MessageId: QPLIST_E_EXPECTING_GUID
//
// MessageText:
//
//  Expecting GUID.
//
#define QPLIST_E_EXPECTING_GUID          ((HRESULT)0x80041658L)

//
// MessageId: QPLIST_E_BAD_GUID
//
// MessageText:
//
//  Invalid guid.
//
#define QPLIST_E_BAD_GUID                ((HRESULT)0x80041659L)

//
// MessageId: QPLIST_E_EXPECTING_PROP_SPEC
//
// MessageText:
//
//  Expecting property specifier.
//
#define QPLIST_E_EXPECTING_PROP_SPEC     ((HRESULT)0x8004165AL)

//
// MessageId: QPLIST_E_CANT_SET_PROPERTY
//
// MessageText:
//
//  Failed to set property name.
//
#define QPLIST_E_CANT_SET_PROPERTY       ((HRESULT)0x8004165BL)

//
// MessageId: QPLIST_E_DUPLICATE
//
// MessageText:
//
//  Duplicate property name.
//
#define QPLIST_E_DUPLICATE               ((HRESULT)0x8004165CL)

//
// MessageId: QPLIST_E_VECTORBYREF_USED_ALONE
//
// MessageText:
//
//  DBTYPE_VECTOR or DBTYPE_BYREF used alone.
//
#define QPLIST_E_VECTORBYREF_USED_ALONE  ((HRESULT)0x8004165DL)

//
// MessageId: QPLIST_E_BYREF_USED_WITHOUT_PTRTYPE
//
// MessageText:
//
//  DBTYPE_BYREF must be used with DBTYPE_STR, DBTYPE_WSTR, DBTYPE_GUID
//   or DBTYPE_UI1 types.
//
#define QPLIST_E_BYREF_USED_WITHOUT_PTRTYPE ((HRESULT)0x8004165EL)

//
// MessageId: QPARSE_E_UNEXPECTED_NOT
//
// MessageText:
//
//  Unexpected NOT operator.
//
#define QPARSE_E_UNEXPECTED_NOT          ((HRESULT)0x80041660L)

//
// MessageId: QPARSE_E_EXPECTING_INTEGER
//
// MessageText:
//
//  Expecting integer.
//
#define QPARSE_E_EXPECTING_INTEGER       ((HRESULT)0x80041661L)

//
// MessageId: QPARSE_E_EXPECTING_REAL
//
// MessageText:
//
//  Expecting real number.
//
#define QPARSE_E_EXPECTING_REAL          ((HRESULT)0x80041662L)

//
// MessageId: QPARSE_E_EXPECTING_DATE
//
// MessageText:
//
//  Expecting date.
//
#define QPARSE_E_EXPECTING_DATE          ((HRESULT)0x80041663L)

//
// MessageId: QPARSE_E_EXPECTING_CURRENCY
//
// MessageText:
//
//  Expecting currency.
//
#define QPARSE_E_EXPECTING_CURRENCY      ((HRESULT)0x80041664L)

//
// MessageId: QPARSE_E_EXPECTING_GUID
//
// MessageText:
//
//  Expecting GUID.
//
#define QPARSE_E_EXPECTING_GUID          ((HRESULT)0x80041665L)

//
// MessageId: QPARSE_E_EXPECTING_BRACE
//
// MessageText:
//
//  Expecting closing square bracket ']'.
//
#define QPARSE_E_EXPECTING_BRACE         ((HRESULT)0x80041666L)

//
// MessageId: QPARSE_E_EXPECTING_PAREN
//
// MessageText:
//
//  Expecting closing parenthesis ')'.
//
#define QPARSE_E_EXPECTING_PAREN         ((HRESULT)0x80041667L)

//
// MessageId: QPARSE_E_EXPECTING_PROPERTY
//
// MessageText:
//
//  Expecting property name.
//
#define QPARSE_E_EXPECTING_PROPERTY      ((HRESULT)0x80041668L)

//
// MessageId: QPARSE_E_NOT_YET_IMPLEMENTED
//
// MessageText:
//
//  Not yet implemented.
//
#define QPARSE_E_NOT_YET_IMPLEMENTED     ((HRESULT)0x80041669L)

//
// MessageId: QPARSE_E_EXPECTING_PHRASE
//
// MessageText:
//
//  Expecting phrase.
//
#define QPARSE_E_EXPECTING_PHRASE        ((HRESULT)0x8004166AL)

//
// MessageId: QPARSE_E_UNSUPPORTED_PROPERTY_TYPE
//
// MessageText:
//
//  Unsupported property type.
//
#define QPARSE_E_UNSUPPORTED_PROPERTY_TYPE ((HRESULT)0x8004166BL)

//
// MessageId: QPARSE_E_EXPECTING_REGEX
//
// MessageText:
//
//  Expecting regular expression.
//
#define QPARSE_E_EXPECTING_REGEX         ((HRESULT)0x8004166CL)

//
// MessageId: QPARSE_E_EXPECTING_REGEX_PROPERTY
//
// MessageText:
//
//  Regular expressions require a property of type string.
//
#define QPARSE_E_EXPECTING_REGEX_PROPERTY ((HRESULT)0x8004166DL)

//
// MessageId: QPARSE_E_INVALID_LITERAL
//
// MessageText:
//
//  Invalid literal.
//
#define QPARSE_E_INVALID_LITERAL         ((HRESULT)0x8004166EL)

//
// MessageId: QPARSE_E_NO_SUCH_PROPERTY
//
// MessageText:
//
//  No such property.
//
#define QPARSE_E_NO_SUCH_PROPERTY        ((HRESULT)0x8004166FL)

//
// MessageId: QPARSE_E_EXPECTING_EOS
//
// MessageText:
//
//  Expecting end of string.
//
#define QPARSE_E_EXPECTING_EOS           ((HRESULT)0x80041670L)

//
// MessageId: QPARSE_E_EXPECTING_COMMA
//
// MessageText:
//
//  Expecting comma.
//
#define QPARSE_E_EXPECTING_COMMA         ((HRESULT)0x80041671L)

//
// MessageId: QPARSE_E_UNEXPECTED_EOS
//
// MessageText:
//
//  Unexpected end of string.
//
#define QPARSE_E_UNEXPECTED_EOS          ((HRESULT)0x80041672L)

//
// MessageId: QPARSE_E_WEIGHT_OUT_OF_RANGE
//
// MessageText:
//
//  Weight must be between 0 and 1000 in short form queries and between 0.0 and 1.0 in long form queries.
//
#define QPARSE_E_WEIGHT_OUT_OF_RANGE     ((HRESULT)0x80041673L)

//
// MessageId: QPARSE_E_NO_SUCH_SORT_PROPERTY
//
// MessageText:
//
//  An invalid property was found in the sort specification.
//
#define QPARSE_E_NO_SUCH_SORT_PROPERTY   ((HRESULT)0x80041674L)

//
// MessageId: QPARSE_E_INVALID_SORT_ORDER
//
// MessageText:
//
//  An invalid sort order was specified.  Only [a] and [d] are supported.
//
#define QPARSE_E_INVALID_SORT_ORDER      ((HRESULT)0x80041675L)

//
// MessageId: QUTIL_E_CANT_CONVERT_VROOT
//
// MessageText:
//
//  Couldn't convert a virtual path to a physical path.
//
#define QUTIL_E_CANT_CONVERT_VROOT       ((HRESULT)0x80041676L)

//
// MessageId: QPARSE_E_INVALID_GROUPING
//
// MessageText:
//
//  An unsupported grouping type was specified.
//
#define QPARSE_E_INVALID_GROUPING        ((HRESULT)0x80041677L)

//
// MessageId: QUTIL_E_INVALID_CODEPAGE
//
// MessageText:
//
//  Invalid CiCodepage was specified.
//
#define QUTIL_E_INVALID_CODEPAGE         ((HRESULT)0xC0041678L)

//
// MessageId: QPLIST_S_DUPLICATE
//
// MessageText:
//
//  Exact duplicate property defined.
//
#define QPLIST_S_DUPLICATE               ((HRESULT)0x00041679L)

//
// MessageId: QPARSE_E_INVALID_QUERY
//
// MessageText:
//
//  Invalid query.
//
#define QPARSE_E_INVALID_QUERY           ((HRESULT)0x8004167AL)

//
// MessageId: QPARSE_E_INVALID_RANKMETHOD
//
// MessageText:
//
//  Invalid rank method.
//
#define QPARSE_E_INVALID_RANKMETHOD      ((HRESULT)0x8004167BL)

//
// 0x1680 - 0x169F are Filter daemon error codes
//
//
// MessageId: FDAEMON_W_WORDLISTFULL
//
// MessageText:
//
//  Wordlist has reached maximum size.  Additional documents should not be filtered.
//
#define FDAEMON_W_WORDLISTFULL           ((HRESULT)0x00041680L)

//
// MessageId: FDAEMON_E_LOWRESOURCE
//
// MessageText:
//
//  The system is running out of one of more resources needed for filtering, usually memory.
//
#define FDAEMON_E_LOWRESOURCE            ((HRESULT)0x80041681L)

//
// MessageId: FDAEMON_E_FATALERROR
//
// MessageText:
//
//  A critical error occurred during document filtering.  Consult system administrator.
//
#define FDAEMON_E_FATALERROR             ((HRESULT)0x80041682L)

//
// MessageId: FDAEMON_E_PARTITIONDELETED
//
// MessageText:
//
//  Documents not stored in content index because partition has been deleted.
//
#define FDAEMON_E_PARTITIONDELETED       ((HRESULT)0x80041683L)

//
// MessageId: FDAEMON_E_CHANGEUPDATEFAILED
//
// MessageText:
//
//  Documents not stored in content index because update of changelist failed.
//
#define FDAEMON_E_CHANGEUPDATEFAILED     ((HRESULT)0x80041684L)

//
// MessageId: FDAEMON_W_EMPTYWORDLIST
//
// MessageText:
//
//  Final wordlist was empty.
//
#define FDAEMON_W_EMPTYWORDLIST          ((HRESULT)0x00041685L)

//
// MessageId: FDAEMON_E_WORDLISTCOMMITFAILED
//
// MessageText:
//
//  Commit of wordlist failed.  Data not available for query.
//
#define FDAEMON_E_WORDLISTCOMMITFAILED   ((HRESULT)0x80041686L)

//
// MessageId: FDAEMON_E_NOWORDLIST
//
// MessageText:
//
//  No wordlist is being constructed.  May happen after fatal filter error.
//
#define FDAEMON_E_NOWORDLIST             ((HRESULT)0x80041687L)

//
// MessageId: FDAEMON_E_TOOMANYFILTEREDBLOCKS
//
// MessageText:
//
//  During document filtering the limit on buffers has been exceeded.
//
#define FDAEMON_E_TOOMANYFILTEREDBLOCKS  ((HRESULT)0x80041688L)

//
// ISearch error codes
//
//
// MessageId: SEARCH_S_NOMOREHITS
//
// MessageText:
//
//  End of hits has been reached.
//
#define SEARCH_S_NOMOREHITS              ((HRESULT)0x000416A0L)

//
// MessageId: SEARCH_E_NOMONIKER
//
// MessageText:
//
//  Retrival of hits as monikers is not supported (by filter passed into Init).
//
#define SEARCH_E_NOMONIKER               ((HRESULT)0x800416A1L)

//
// MessageId: SEARCH_E_NOREGION
//
// MessageText:
//
//  Retrival of hits as filter regions is not supported (by filter passed into Init).
//
#define SEARCH_E_NOREGION                ((HRESULT)0x800416A2L)

//
// Filter error codes
//
//
// MessageId: FILTER_E_TOO_BIG
//
// MessageText:
//
//  File is too large to filter.
//
#define FILTER_E_TOO_BIG                 ((HRESULT)0x80041730L)

//
// MessageId: FILTER_S_PARTIAL_CONTENTSCAN_IMMEDIATE
//
// MessageText:
//
//  A partial content scan of the disk needs to be scheduled for immediate execution.
//
#define FILTER_S_PARTIAL_CONTENTSCAN_IMMEDIATE ((HRESULT)0x00041731L)

//
// MessageId: FILTER_S_FULL_CONTENTSCAN_IMMEDIATE
//
// MessageText:
//
//  A full content scan of the disk needs to be scheduled for immediate execution.
//
#define FILTER_S_FULL_CONTENTSCAN_IMMEDIATE ((HRESULT)0x00041732L)

//
// MessageId: FILTER_S_CONTENTSCAN_DELAYED
//
// MessageText:
//
//  A content scan of the disk needs to be scheduled for execution later.
//
#define FILTER_S_CONTENTSCAN_DELAYED     ((HRESULT)0x00041733L)

//
// MessageId: FILTER_E_CONTENTINDEXCORRUPT
//
// MessageText:
//
//  The content index is corrupt. A content scan will to be scheduled after chkdsk or autochk is run.
//
#define FILTER_E_CONTENTINDEXCORRUPT     ((HRESULT)0xC0041734L)

//
// MessageId: FILTER_S_DISK_FULL
//
// MessageText:
//
//  The disk is getting full.
//
#define FILTER_S_DISK_FULL               ((HRESULT)0x00041735L)

//
// MessageId: FILTER_E_ALREADY_OPEN
//
// MessageText:
//
//  A file is already open. Cannot open another one while a file is open.
//
#define FILTER_E_ALREADY_OPEN            ((HRESULT)0x80041736L)

//
// MessageId: FILTER_E_UNREACHABLE
//
// MessageText:
//
//  The file is not reachable.
//
#define FILTER_E_UNREACHABLE             ((HRESULT)0x80041737L)

//
// MessageId: FILTER_E_IN_USE
//
// MessageText:
//
//  The document is in use by another process.
//
#define FILTER_E_IN_USE                  ((HRESULT)0x80041738L)

//
// MessageId: FILTER_E_NOT_OPEN
//
// MessageText:
//
//  The document is not opened.
//
#define FILTER_E_NOT_OPEN                ((HRESULT)0x80041739L)

//
// MessageId: FILTER_S_NO_PROPSETS
//
// MessageText:
//
//  The document has no property sets.
//
#define FILTER_S_NO_PROPSETS             ((HRESULT)0x0004173AL)

//
// MessageId: FILTER_E_NO_SUCH_PROPERTY
//
// MessageText:
//
//  There is no property with the given GUID.
//
#define FILTER_E_NO_SUCH_PROPERTY        ((HRESULT)0x8004173BL)

//
// MessageId: FILTER_S_NO_SECURITY_DESCRIPTOR
//
// MessageText:
//
//  The document has no security descriptor.
//
#define FILTER_S_NO_SECURITY_DESCRIPTOR  ((HRESULT)0x0004173CL)

//
// MessageId: FILTER_E_OFFLINE
//
// MessageText:
//
//  The document is offline.
//
#define FILTER_E_OFFLINE                 ((HRESULT)0x8004173DL)

//
// MessageId: FILTER_E_PARTIALLY_FILTERED
//
// MessageText:
//
//  The document was too large to filter in its entirety.  Portions of the document were not emitted.
//
#define FILTER_E_PARTIALLY_FILTERED      ((HRESULT)0x8004173EL)

//
// Word breaker error codes
//
//
// MessageId: WBREAK_E_END_OF_TEXT
//
// MessageText:
//
//  End of text reached in text source.
//
#define WBREAK_E_END_OF_TEXT             ((HRESULT)0x80041780L)

//
// MessageId: LANGUAGE_S_LARGE_WORD
//
// MessageText:
//
//  Word larger than maximum length.  May be truncated by word sink.
//
#define LANGUAGE_S_LARGE_WORD            ((HRESULT)0x00041781L)

//
// MessageId: WBREAK_E_QUERY_ONLY
//
// MessageText:
//
//  Feature only available in query mode.
//
#define WBREAK_E_QUERY_ONLY              ((HRESULT)0x80041782L)

//
// MessageId: WBREAK_E_BUFFER_TOO_SMALL
//
// MessageText:
//
//  Buffer too small to hold composed phrase.
//
#define WBREAK_E_BUFFER_TOO_SMALL        ((HRESULT)0x80041783L)

//
// MessageId: LANGUAGE_E_DATABASE_NOT_FOUND
//
// MessageText:
//
//  Langauge database/cache file could not be found.
//
#define LANGUAGE_E_DATABASE_NOT_FOUND    ((HRESULT)0x80041784L)

//
// MessageId: WBREAK_E_INIT_FAILED
//
// MessageText:
//
//  Initialization of word breaker failed.
//
#define WBREAK_E_INIT_FAILED             ((HRESULT)0x80041785L)

//
// MessageId: PSINK_E_QUERY_ONLY
//
// MessageText:
//
//  Feature only available in query mode.
//
#define PSINK_E_QUERY_ONLY               ((HRESULT)0x80041790L)

//
// MessageId: PSINK_E_INDEX_ONLY
//
// MessageText:
//
//  Feature only available in index mode.
//
#define PSINK_E_INDEX_ONLY               ((HRESULT)0x80041791L)

//
// MessageId: PSINK_E_LARGE_ATTACHMENT
//
// MessageText:
//
//  Attachment type beyond valid range.
//
#define PSINK_E_LARGE_ATTACHMENT         ((HRESULT)0x80041792L)

//
// MessageId: PSINK_S_LARGE_WORD
//
// MessageText:
//
//  Word larger than maximum length.  May be truncated by phrase sink.
//
#define PSINK_S_LARGE_WORD               ((HRESULT)0x00041793L)

//
// Content Index Framework Error Codes
//
//
// MessageId: CI_CORRUPT_DATABASE
//
// MessageText:
//
//  The content index is corrupt.
//
#define CI_CORRUPT_DATABASE              ((HRESULT)0xC0041800L)

//
// MessageId: CI_CORRUPT_CATALOG
//
// MessageText:
//
//  The content index meta data is corrupt.
//
#define CI_CORRUPT_CATALOG               ((HRESULT)0xC0041801L)

//
// MessageId: CI_INVALID_PARTITION
//
// MessageText:
//
//  The content index partition is invalid.
//
#define CI_INVALID_PARTITION             ((HRESULT)0xC0041802L)

//
// MessageId: CI_INVALID_PRIORITY
//
// MessageText:
//
//  The priority is invalid.
//
#define CI_INVALID_PRIORITY              ((HRESULT)0xC0041803L)

//
// MessageId: CI_NO_STARTING_KEY
//
// MessageText:
//
//  There is no starting key.
//
#define CI_NO_STARTING_KEY               ((HRESULT)0xC0041804L)

//
// MessageId: CI_OUT_OF_INDEX_IDS
//
// MessageText:
//
//  The content index is out of index ids.
//
#define CI_OUT_OF_INDEX_IDS              ((HRESULT)0xC0041805L)

//
// MessageId: CI_NO_CATALOG
//
// MessageText:
//
//  There is no catalog.
//
#define CI_NO_CATALOG                    ((HRESULT)0xC0041806L)

//
// MessageId: CI_CORRUPT_FILTER_BUFFER
//
// MessageText:
//
//  The filter buffer is corrupt.
//
#define CI_CORRUPT_FILTER_BUFFER         ((HRESULT)0xC0041807L)

//
// MessageId: CI_INVALID_INDEX
//
// MessageText:
//
//  The index is invalid.
//
#define CI_INVALID_INDEX                 ((HRESULT)0xC0041808L)

//
// MessageId: CI_PROPSTORE_INCONSISTENCY
//
// MessageText:
//
//  Inconsistency in property store detected.
//
#define CI_PROPSTORE_INCONSISTENCY       ((HRESULT)0xC0041809L)

//
// MessageId: CI_E_ALREADY_INITIALIZED
//
// MessageText:
//
//  The object is already initialzed.
//
#define CI_E_ALREADY_INITIALIZED         ((HRESULT)0x8004180AL)

//
// MessageId: CI_E_NOT_INITIALIZED
//
// MessageText:
//
//  The object is not initialzed.
//
#define CI_E_NOT_INITIALIZED             ((HRESULT)0x8004180BL)

//
// MessageId: CI_E_BUFFERTOOSMALL
//
// MessageText:
//
//  The buffer is too small.
//
#define CI_E_BUFFERTOOSMALL              ((HRESULT)0x8004180CL)

//
// MessageId: CI_E_PROPERTY_NOT_CACHED
//
// MessageText:
//
//  The given property is not cached.
//
#define CI_E_PROPERTY_NOT_CACHED         ((HRESULT)0x8004180DL)

//
// MessageId: CI_S_WORKID_DELETED
//
// MessageText:
//
//  The workid is deleted.
//
#define CI_S_WORKID_DELETED              ((HRESULT)0x0004180EL)

//
// MessageId: CI_E_INVALID_STATE
//
// MessageText:
//
//  The object is not in a valid state.
//
#define CI_E_INVALID_STATE               ((HRESULT)0x8004180FL)

//
// MessageId: CI_E_FILTERING_DISABLED
//
// MessageText:
//
//  Filtering is disabled in this content index.
//
#define CI_E_FILTERING_DISABLED          ((HRESULT)0x80041810L)

//
// MessageId: CI_E_DISK_FULL
//
// MessageText:
//
//  The disk is full and the specified operation cannot be done.
//
#define CI_E_DISK_FULL                   ((HRESULT)0x80041811L)

//
// MessageId: CI_E_SHUTDOWN
//
// MessageText:
//
//  Content Index has been shutdown.
//
#define CI_E_SHUTDOWN                    ((HRESULT)0x80041812L)

//
// MessageId: CI_E_WORKID_NOTVALID
//
// MessageText:
//
//  The workid is not valid.
//
#define CI_E_WORKID_NOTVALID             ((HRESULT)0x80041813L)

//
// MessageId: CI_S_END_OF_ENUMERATION
//
// MessageText:
//
//  There are no more documents to enumerate.
//
#define CI_S_END_OF_ENUMERATION          ((HRESULT)0x00041814L)    

//
// MessageId: CI_E_NOT_FOUND
//
// MessageText:
//
//  The object was not found.
//
#define CI_E_NOT_FOUND                   ((HRESULT)0x80041815L)

//
// MessageId: CI_E_USE_DEFAULT_PID
//
// MessageText:
//
//  The passed-in property id is not supported.
//
#define CI_E_USE_DEFAULT_PID             ((HRESULT)0x80041816L)

//
// MessageId: CI_E_DUPLICATE_NOTIFICATION
//
// MessageText:
//
//  There were two notifications for the same workid.
//
#define CI_E_DUPLICATE_NOTIFICATION      ((HRESULT)0x80041817L)

//
// MessageId: CI_E_UPDATES_DISABLED
//
// MessageText:
//
//  A document update was rejected because updates were disabled.
//
#define CI_E_UPDATES_DISABLED            ((HRESULT)0x80041818L)

//
// MessageId: CI_E_INVALID_FLAGS_COMBINATION
//
// MessageText:
//
//  The combination of flags specified is invalid.
//
#define CI_E_INVALID_FLAGS_COMBINATION   ((HRESULT)0x80041819L)

//
// MessageId: CI_E_OUTOFSEQ_INCREMENT_DATA
//
// MessageText:
//
//  The incremental data given to Load is not valid. It may be out of sequence.
//
#define CI_E_OUTOFSEQ_INCREMENT_DATA     ((HRESULT)0x8004181AL)

//
// MessageId: CI_E_SHARING_VIOLATION
//
// MessageText:
//
//  A sharing or locking violation caused a failure.
//
#define CI_E_SHARING_VIOLATION           ((HRESULT)0x8004181BL)

//
// MessageId: CI_E_LOGON_FAILURE
//
// MessageText:
//
//  A logon permission violation caused a failure.
//
#define CI_E_LOGON_FAILURE               ((HRESULT)0x8004181CL)

//
// MessageId: CI_E_NO_CATALOG
//
// MessageText:
//
//  There is no catalog.
//
#define CI_E_NO_CATALOG                  ((HRESULT)0x8004181DL)

//
// MessageId: CI_E_STRANGE_PAGEORSECTOR_SIZE
//
// MessageText:
//
//  Page size is not an integral multiple of the sector size of the volume where index is located.
//
#define CI_E_STRANGE_PAGEORSECTOR_SIZE   ((HRESULT)0x8004181EL)

//
// MessageId: CI_E_TIMEOUT
//
// MessageText:
//
//  Service is too busy.
//
#define CI_E_TIMEOUT                     ((HRESULT)0x8004181FL)

//
// MessageId: CI_E_NOT_RUNNING
//
// MessageText:
//
//  Service is not running.
//
#define CI_E_NOT_RUNNING                 ((HRESULT)0x80041820L)

//
// MessageId: CI_INCORRECT_VERSION
//
// MessageText:
//
//  The content index data on disk is for the wrong version.
//
#define CI_INCORRECT_VERSION             ((HRESULT)0xC0041821L)

//
// MessageId: CI_E_ENUMERATION_STARTED
//
// MessageText:
//
//  Enumeration has already been started for this query.
//
#define CI_E_ENUMERATION_STARTED         ((HRESULT)0xC0041822L)

//
// MessageId: CI_E_PROPERTY_TOOLARGE
//
// MessageText:
//
//  The specified variable length property is too large for the property cache.
//
#define CI_E_PROPERTY_TOOLARGE           ((HRESULT)0xC0041823L)

//
// MessageId: CI_E_CLIENT_FILTER_ABORT
//
// MessageText:
//
//  Filtering of object was aborted by client.
//
#define CI_E_CLIENT_FILTER_ABORT         ((HRESULT)0xC0041824L)

//
// MessageId: CI_S_NO_DOCSTORE
//
// MessageText:
//
//  For administrative connections from client without association to a docstore.
//
#define CI_S_NO_DOCSTORE                 ((HRESULT)0x00041825L)

//
// MessageId: CI_S_CAT_STOPPED
//
// MessageText:
//
//  The catalog has been stopped.
//
#define CI_S_CAT_STOPPED                 ((HRESULT)0x00041826L)

//
// MessageId: CI_E_CARDINALITY_MISMATCH
//
// MessageText:
//
//  Mismatch in cardinality of machine(s)/catalog(s)/scope(s).
//
#define CI_E_CARDINALITY_MISMATCH        ((HRESULT)0x80041827L)

//
// MessageId: CI_E_CONFIG_DISK_FULL
//
// MessageText:
//
//  The disk has reached its configured space limit.
//
#define CI_E_CONFIG_DISK_FULL            ((HRESULT)0x80041828L)

#endif // _CIERROR_H_
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\vs9sp1\sdk\include\clfs.h ===
/*=============================================================================

    Copyright (c) 1998  Microsoft Corporation

    Module Name:

        clfs.h

    Abstract:

        Header file containing all publicly defined data structures for the
        common log file system.

    Author:

        Dexter Bradshaw    [DexterB]   09-Dec-1998


    Revision History:

=============================================================================*/

// begin_wdm
#ifndef _CLFS_PUBLIC_H_
#define _CLFS_PUBLIC_H_
// end_wdm

#ifdef CLFS_KERNEL_MODE

// begin_wdm
#define CLFSUSER_API
// end_wdm

#else

#include <stdio.h>

#if (NTDDI_VERSION >= NTDDI_WS03SP1) || (_WIN32_WINNT >= _WIN32_WINNT_WS03)
//
// PFILE
//
// Define PFILE to be a pointer to _iobuf *
//

typedef FILE *PFILE, **PPFILE;
typedef DWORD CLFSSTATUS;

#   ifdef __CLFSUSER_EXPORTS__
#       define CLFSUSER_API 
#   else
#       define CLFSUSER_API __declspec(dllimport)
#   endif /* __CLFSUSER_EXPORTS__ */

#   define ClfsLsnEqual             LsnEqual
#   define ClfsLsnLess              LsnLess
#   define ClfsLsnGreater           LsnGreater
#   define ClfsLsnNull              LsnNull
#   define ClfsLsnCreate            LsnCreate
#   define ClfsLsnContainer         LsnContainer
#   define ClfsLsnBlockOffset       LsnBlockOffset
#   define ClfsLsnRecordSequence    LsnRecordSequence
#   define ClfsLsnInvalid           LsnInvalid
#   define ClfsLsnIncrement         LsnIncrement

#endif /* NTDDI_VERSION || _WIN32_WINNT */

#endif /* CLFS_KERNEL_MODE */

// begin_wdm

#if (NTDDI_VERSION >= NTDDI_WS03SP1) || (_WIN32_WINNT >= _WIN32_WINNT_WS03)

//
// FILE_ATTRIBUTE_DEDICATED is defined as FILE_ATTRIBUTE_TEMPORARY.
//

#define FILE_ATTRIBUTE_DEDICATED    FILE_ATTRIBUTE_TEMPORARY

//
// Container name and container size extended attribute entry names.
//

#define EA_CONTAINER_NAME           "ContainerName"
#define EA_CONTAINER_SIZE           "ContainerSize"

//
// Base log file name 3-letter extension.
//

#define CLFS_BASELOG_EXTENSION      L".blf"

//
// Common log file system public flags and constants.
//

#define CLFS_FLAG_NO_FLAGS              0x00000000      // No flags.
#define CLFS_FLAG_FORCE_APPEND          0x00000001      // Flag to force an append to log queue
#define CLFS_FLAG_FORCE_FLUSH           0x00000002      // Flag to force a log flush
#define CLFS_FLAG_USE_RESERVATION       0x00000004      // Flag to charge a data append to reservation
#define CLFS_FLAG_REENTRANT_FILE_SYSTEM 0x00000008      // Kernel mode create flag indicating a re-entrant file system.
#define CLFS_FLAG_NON_REENTRANT_FILTER  0x00000010      // Kernel mode create flag indicating non-reentrant filter.
#define CLFS_FLAG_REENTRANT_FILTER      0x00000020      // Kernel mode create flag indicating reentrant filter.
#define CLFS_FLAG_IGNORE_SHARE_ACCESS   0x00000040      // Kernel mode create flag indicating IO_IGNORE_SHARE_ACCESS_CHECK semantics.
#define CLFS_FLAG_READ_IN_PROGRESS      0x00000080      // Flag indicating read in progress and not completed.
#define CLFS_FLAG_MINIFILTER_LEVEL      0x00000100      // Kernel mode create flag indicating mini-filter target.
#define CLFS_FLAG_HIDDEN_SYSTEM_LOG     0x00000200      // Kernel mode create flag indicating the log and containers should be marked hidden & system.


//
// Flag indicating all CLFS I/O will be targeted to an intermediate level of the I/O stack
//

#define CLFS_FLAG_FILTER_INTERMEDIATE_LEVEL CLFS_FLAG_NON_REENTRANT_FILTER
    
//
// Flag indicating all CLFS I/O will be targeted to the top level of the I/O stack
//

#define CLFS_FLAG_FILTER_TOP_LEVEL          CLFS_FLAG_REENTRANT_FILTER

//
// CLFS_CONTAINER_INDEX
//
// Index into the container table.
//

typedef ULONG                       CLFS_CONTAINER_ID;
typedef CLFS_CONTAINER_ID           *PCLFS_CONTAINER_ID;
typedef CLFS_CONTAINER_ID           **PPCLFS_CONTAINER_ID;

#endif /* NTDDI_VERSION || _WIN32_WINNT */

#ifdef __CLFS_PRIVATE_LSN__

#include <clfslsn.h>

#else

#if (NTDDI_VERSION >= NTDDI_WS03SP1) || (_WIN32_WINNT >= _WIN32_WINNT_WS03)

//
// CLS_LSN
//

typedef struct _CLS_LSN
{

    ULONGLONG               Internal;

} CLS_LSN, *PCLS_LSN, **PPCLS_LSN;

#endif /* NTDDI_VERSION || _WIN32_WINNT */

#endif /* __CLFS_PRIVATE_LSN__ */

#if (NTDDI_VERSION >= NTDDI_WS03SP1) || (_WIN32_WINNT >= _WIN32_WINNT_WS03)

//
// Alias CLS prefixed types with CLFS prefixes.
//

typedef CLS_LSN CLFS_LSN;
typedef CLFS_LSN *PCLFS_LSN, **PPCLFS_LSN;

#endif /* NTDDI_VERSION || _WIN32_WINNT */

#ifdef __cplusplus
extern "C"
{
#endif /* __cplusplus */

// end_wdm

//
// Definition of special LSN's: CLFS_LSN_INVALID and CLFS_LSN_NULL. Note that
// [CLFS_LSN_NULL, CLFS_LSN_INVALID) define the only valid LSN range.  LSN values
// are strictly monotonic increasing.
//
#ifdef CLFS_KERNEL_MODE

#if defined __CLFS_SUPPORT_LIBRARY__

#if (NTDDI_VERSION >= NTDDI_WS03SP1) || (_WIN32_WINNT >= _WIN32_WINNT_WS03)
extern const CLFS_LSN CLFS_LSN_INVALID;
extern const CLFS_LSN CLFS_LSN_NULL;
#endif /* NTDDI_VERSION || _WIN32_WINNT */

#elif defined __CLFSUSER_EXPORTS__

#if (NTDDI_VERSION >= NTDDI_WS03SP1) || (_WIN32_WINNT >= _WIN32_WINNT_WS03)
extern __declspec(dllexport) const CLFS_LSN CLFS_LSN_INVALID;
extern __declspec(dllexport) const CLFS_LSN CLFS_LSN_NULL;
#endif /* NTDDI_VERSION || _WIN32_WINNT */

#   else

// begin_wdm
#if (NTDDI_VERSION >= NTDDI_WS03SP1) || (_WIN32_WINNT >= _WIN32_WINNT_WS03)
extern __declspec(dllimport) const CLFS_LSN CLFS_LSN_INVALID;
extern __declspec(dllimport) const CLFS_LSN CLFS_LSN_NULL;
#endif /* NTDDI_VERSION || _WIN32_WINNT */
// end_wdm 

#   endif /* __CLFSUSER_EXPORTS__ */

#else

#if (NTDDI_VERSION >= NTDDI_WS03SP1) || (_WIN32_WINNT >= _WIN32_WINNT_WS03)
extern CLFSUSER_API const CLFS_LSN CLFS_LSN_INVALID;
extern CLFSUSER_API const CLFS_LSN CLFS_LSN_NULL;
#endif /* NTDDI_VERSION || _WIN32_WINNT */

#endif /* CLFS_KERNEL_MODE */

// begin_wdm

#ifdef __cplusplus
}
#endif /* __cplusplus */

#if (NTDDI_VERSION >= NTDDI_WS03SP1) || (_WIN32_WINNT >= _WIN32_WINNT_WS03)

//
// CLS_RECORD_TYPE
//
// Definition of record types.
//

#ifdef __cplusplus

const UCHAR  ClfsNullRecord          =   0x00;           // Null record type.        
const UCHAR  ClfsDataRecord          =   0x01;           // Client data record.
const UCHAR  ClfsRestartRecord       =   0x02;           // Restart record.


// Valid client records are restart and data records.

const UCHAR  ClfsClientRecord        =   0x03; 

#else

#define ClfsNullRecord                  0x00            // Null record type.        
#define ClfsDataRecord                  0x01            // Client data record.
#define ClfsRestartRecord               0x02            // Restart record.


// Valid client records are restart and data records.

#define ClfsClientRecord (ClfsDataRecord|ClfsRestartRecord) 

#endif /* _cplusplus */

#endif /* NTDDI_VERSION || _WIN32_WINNT */

#if (NTDDI_VERSION >= NTDDI_WS03SP1) || (_WIN32_WINNT >= _WIN32_WINNT_WS03)
//
// Log container path prefix indicating the log container's location is
// actually a stream inside of the BLF.
//

#ifdef _cplusplus

const LPCWSTR CLFS_CONTAINER_STREAM_PREFIX     = L"%BLF%:"

#else

#define CLFS_CONTAINER_STREAM_PREFIX             L"%BLF%:"

#endif /* _cplusplus */

#endif /* NTDDI_VERSION || _WIN32_WINNT */

#if (NTDDI_VERSION >= NTDDI_WS03SP1) || (_WIN32_WINNT >= _WIN32_WINNT_WS03)
//
// Log container path prefix indicating the log container's location is
// relative to the base log file (BLF) and not an absolute path.
// Paths which do not being with said prefix are absolute paths.
//

#ifdef _cplusplus

const LPCWSTR CLFS_CONTAINER_RELATIVE_PREFIX    = L"%BLF%\\"

#else

#define CLFS_CONTAINER_RELATIVE_PREFIX            L"%BLF%\\"

#endif /* _cplusplus */

#endif /* NTDDI_VERSION || _WIN32_WINNT */

#if (NTDDI_VERSION >= NTDDI_WS03SP1) || (_WIN32_WINNT >= _WIN32_WINNT_WS03)
//
// Alias CLS prefix with CLFS prefixes.
//

typedef UCHAR CLS_RECORD_TYPE, *PCLS_RECORD_TYPE, **PPCLS_RECORD_TYPE;
typedef CLS_RECORD_TYPE CLFS_RECORD_TYPE, *PCLFS_RECORD_TYPE, **PPCLFS_RECORD_TYPE;
#endif /* NTDDI_VERSION || _WIN32_WINNT */

#if (NTDDI_VERSION >= NTDDI_WS03SP1) || (_WIN32_WINNT >= _WIN32_WINNT_WS03)
//
// CLS_CONTEXT_MODE
//
// The context mode specifies the dirction and access methods used to scan the
// log file. 
//

typedef enum _CLS_CONTEXT_MODE
{
    ClsContextNone = 0x00,
    ClsContextUndoNext,
    ClsContextPrevious,
    ClsContextForward

} CLS_CONTEXT_MODE, *PCLS_CONTEXT_MODE, **PPCLS_CONTEXT_MODE;
#endif /* NTDDI_VERSION || _WIN32_WINNT */

#if (NTDDI_VERSION >= NTDDI_WS03SP1) || (_WIN32_WINNT >= _WIN32_WINNT_WS03)
//
// Alias all CLS prefixes with CLFS prefixes.
//

typedef enum _CLFS_CONTEXT_MODE
{
    ClfsContextNone = 0x00,
    ClfsContextUndoNext,
    ClfsContextPrevious,
    ClfsContextForward

} CLFS_CONTEXT_MODE, *PCLFS_CONTEXT_MODE, **PPCLFS_CONTEXT_MODE;
#endif /* NTDDI_VERSION || _WIN32_WINNT */


#if (NTDDI_VERSION >= NTDDI_WS03SP1) || (_WIN32_WINNT >= _WIN32_WINNT_WS03)
//
// CLFSD_NODE_ID
//
// Common log file system node identifier.  Every CLFS file system
// structure has a node identity and type.  The node type is a signature
// field while the size is used in for consistency checking.
//

typedef struct _CLFS_NODE_ID
{
    ULONG   cType;                                      // CLFS node type.
    ULONG   cbNode;                                     // CLFS node size.

} CLFS_NODE_ID, *PCLFS_NODE_ID;
#endif /* NTDDI_VERSION || _WIN32_WINNT */


#if (NTDDI_VERSION >= NTDDI_WS03SP1) || (_WIN32_WINNT >= _WIN32_WINNT_WS03)
//
//  CLS_WRITE_ENTRY
//
// Write entry specifying the contents of a user buffer and length that are
// marshalled in the space reservation and append interface of the CLS API.
//

typedef struct _CLS_WRITE_ENTRY
{
    PVOID Buffer;
    ULONG ByteLength;
} CLS_WRITE_ENTRY, *PCLS_WRITE_ENTRY, **PPCLS_WRITE_ENTRY;
#endif /* NTDDI_VERSION || _WIN32_WINNT */

#if (NTDDI_VERSION >= NTDDI_WS03SP1) || (_WIN32_WINNT >= _WIN32_WINNT_WS03)
//
// Alias all CLS prefixes with CLFS prefixes.
//

typedef CLS_WRITE_ENTRY CLFS_WRITE_ENTRY;
typedef CLFS_WRITE_ENTRY *PCLFS_WRITE_ENTRY, **PPCLFS_WRITE_ENTRY;
#endif /* NTDDI_VERSION || _WIN32_WINNT */

#if (NTDDI_VERSION >= NTDDI_WS03SP1) || (_WIN32_WINNT >= _WIN32_WINNT_WS03)
//
// CLFS_LOG_ID
// 
// A log identifier is a GUID that describes uniquely a physical log file.
//

typedef GUID CLFS_LOG_ID;
#endif /* NTDDI_VERSION || _WIN32_WINNT */

#if (NTDDI_VERSION >= NTDDI_WS03SP1) || (_WIN32_WINNT >= _WIN32_WINNT_WS03)
//
// CLFS_INFORMATION
//
// Logical log file information structure describing either virtual or physical log
// file data, depending on the type of information queried.
//

typedef struct _CLS_INFORMATION
{
    LONGLONG TotalAvailable;                            // Total log data space available.
    LONGLONG CurrentAvailable;                          // Useable space in the log file.
    LONGLONG TotalReservation;                       // Space reserved for UNDO's (aggregate for physical log)
    ULONGLONG BaseFileSize;                             // Size of the base log file.
    ULONGLONG ContainerSize;                            // Uniform size of log containers.
    ULONG TotalContainers;                              // Total number of containers.
    ULONG FreeContainers;                               // Number of containers not in active log.
    ULONG TotalClients;                                 // Total number of clients.
    ULONG Attributes;                                   // Log file attributes.
    ULONG FlushThreshold;                               // Log file flush threshold.
    ULONG SectorSize;                                   // Underlying container sector size.
    CLS_LSN MinArchiveTailLsn;                          // Marks the global archive tail.
    CLS_LSN BaseLsn;                                    // Start of the active log region.
    CLS_LSN LastFlushedLsn;                             // Last flushed LSN in active log.
    CLS_LSN LastLsn;                                    // End of active log region.
    CLS_LSN RestartLsn;                                 // Location of restart record.
    GUID Identity;                                      // Unique identifier for the log.
} CLS_INFORMATION, *PCLS_INFORMATION, *PPCLS_INFORMATION;
#endif /* NTDDI_VERSION || _WIN32_WINNT */

#if (NTDDI_VERSION >= NTDDI_WS03SP1) || (_WIN32_WINNT >= _WIN32_WINNT_WS03)
//
// Alias CLS prefixes with CLS prefixes.
//

typedef CLS_INFORMATION CLFS_INFORMATION;
typedef CLFS_INFORMATION *PCLFS_INFORMATION, *PPCLFS_INFORMATION;
#endif /* NTDDI_VERSION || _WIN32_WINNT */
/*
//
// CLFS_CLIENT_INFORMATION
// 
// The client information structure maintains client-based log metadata.
//

typedef struct _CLS_CLIENT_INFORMATION
{
    CLS_INFORMATION ClfsInfo;                           // Contains base log file information.
    ULONG ClientAttributes;                             // Virtual log file attributes.
    LONGLONG ClientUndoCommitment;                      // Max. undo commitment for client.
    CLS_LSN ClientArchiveTailLsn;                       // Marks the client archive tail.
    CLS_LSN ClientBaseLsn;                              // Min. client LSN in active log region.
    CLS_LSN ClientLastLsn;                              // Max. client LSN in active log region.
    CLS_LSN ClientRestartLsn;                           // Location of restart record.

} CLS_CLIENT_INFORMATION, *PCLS_CLIENT_INFORMATION, **PPCLS_CLIENT_INFORMATION;

//
// Alias CLS prefixes with CLS prefixes.
//

typedef CLS_CLIENT_INFORMATION CLFS_CLIENT_INFORMATION;
typedef CLFS_CLIENT_INFORMATION *PCLFS_CLIENT_INFORMATION, *PPCLFS_CLIENT_INFORMATION;
*/

#if (NTDDI_VERSION >= NTDDI_WS03SP1) || (_WIN32_WINNT >= _WIN32_WINNT_WS03)
//
// CLFS_LOG_NAME_INFORMATION
// 
// The client information structure stores the name of a log.  It is used
// to communicate ClfsLogNameInformation and ClfsLogPhysicalNameInformation.
//

typedef struct _CLFS_LOG_NAME_INFORMATION
{

    USHORT NameLengthInBytes;
    WCHAR  Name[1];

} CLFS_LOG_NAME_INFORMATION, *PCLFS_LOG_NAME_INFORMATION, **PPCLFS_LOG_NAME_INFORMATION;
#endif /* NTDDI_VERSION || _WIN32_WINNT */

#if (NTDDI_VERSION >= NTDDI_WS03SP1) || (_WIN32_WINNT >= _WIN32_WINNT_WS03)
//
// CLFS_STREAM_ID_INFORMATION
// 
// The client information structure provides a permanent identifier unique
// to the log for the stream in question.
//

typedef struct _CLFS_STREAM_ID_INFORMATION
{

    UCHAR StreamIdentifier;

} CLFS_STREAM_ID_INFORMATION, *PCLFS_STREAM_ID_INFORMATION, **PPCLFS_STREAM_ID_INFORMATION;
#endif /* NTDDI_VERSION || _WIN32_WINNT */

#if (NTDDI_VERSION >= NTDDI_LONGHORN) || (_WIN32_WINNT >= _WIN32_WINNT_LONGHORN)
//
// CLFS_PHYSICAL_LSN_INFORMATION
// 
// An information structure that describes a virtual:physical LSN pairing 
// for the stream identified in the structure.
//
#pragma pack (8)
typedef struct _CLFS_PHYSICAL_LSN_INFORMATION
{
    UCHAR          StreamIdentifier;
    CLFS_LSN       VirtualLsn;
    CLFS_LSN       PhysicalLsn;

} CLFS_PHYSICAL_LSN_INFORMATION, *PCLFS_PHYSICAL_LSN_INFORMATION;
#endif /* NTDDI_VERSION || _WIN32_WINNT */

#if (NTDDI_VERSION >= NTDDI_WS03SP1) || (_WIN32_WINNT >= _WIN32_WINNT_WS03)
//
// CLS_CONTAINER_STATE
//
// At any point in time a container could be inactive or unitialized, active,
// pending deletion from the list of free containers, pending archival, or 
// pending deletion while waiting to be archived.
//

typedef UINT32 CLS_CONTAINER_STATE, *PCLS_CONTAINER_STATE, *PPCLS_CONTAINER_STATE;
typedef CLS_CONTAINER_STATE  CLFS_CONTAINER_STATE, *PCLFS_CONTAINER_STATE, *PPCLFS_CONTAINER_STATE;
#endif /* NTDDI_VERSION || _WIN32_WINNT */

#ifdef __cplusplus

#if (NTDDI_VERSION >= NTDDI_WS03SP1) || (_WIN32_WINNT >= _WIN32_WINNT_WS03)
const CLFS_CONTAINER_STATE  ClsContainerInitializing            = 0x01;
const CLFS_CONTAINER_STATE  ClsContainerInactive                = 0x02;
const CLFS_CONTAINER_STATE  ClsContainerActive                  = 0x04;
const CLFS_CONTAINER_STATE  ClsContainerActivePendingDelete     = 0x08;
const CLFS_CONTAINER_STATE  ClsContainerPendingArchive          = 0x10;
const CLFS_CONTAINER_STATE  ClsContainerPendingArchiveAndDelete = 0x20;

const CLFS_CONTAINER_STATE  ClfsContainerInitializing           = 0x01;
const CLFS_CONTAINER_STATE  ClfsContainerInactive               = 0x02;
const CLFS_CONTAINER_STATE  ClfsContainerActive                 = 0x04;
const CLFS_CONTAINER_STATE  ClfsContainerActivePendingDelete    = 0x08;
const CLFS_CONTAINER_STATE  ClfsContainerPendingArchive         = 0x10;
const CLFS_CONTAINER_STATE  ClfsContainerPendingArchiveAndDelete= 0x20;
#endif /* NTDDI_VERSION || _WIN32_WINNT */

#else

#if (NTDDI_VERSION >= NTDDI_WS03SP1) || (_WIN32_WINNT >= _WIN32_WINNT_WS03)
#define ClsContainerInitializing                                  0x01
#define ClsContainerInactive                                      0x02
#define ClsContainerActive                                        0x04
#define ClsContainerActivePendingDelete                           0x08
#define ClsContainerPendingArchive                                0x10
#define ClsContainerPendingArchiveAndDelete                       0x20

#define ClfsContainerInitializing                                 0x01
#define ClfsContainerInactive                                     0x02
#define ClfsContainerActive                                       0x04
#define ClfsContainerActivePendingDelete                          0x08
#define ClfsContainerPendingArchive                               0x10
#define ClfsContainerPendingArchiveAndDelete                      0x20
#endif /* NTDDI_VERSION || _WIN32_WINNT */

#endif /* __cplusplus */

#if (NTDDI_VERSION >= NTDDI_WS03SP1) || (_WIN32_WINNT >= _WIN32_WINNT_WS03)
//
// CLFS_MAX_CONTAINER_INFO
//
// The maximum length, in bytes, of the FileName field in the CLFS
// container information structure.
//

#ifdef __cplusplus

const ULONG CLFS_MAX_CONTAINER_INFO = (256);

#else

#define CLFS_MAX_CONTAINER_INFO       (256)

#endif /* __cplusplus */

#endif /* NTDDI_VERSION || _WIN32_WINNT */


#if (NTDDI_VERSION >= NTDDI_WS03SP1) || (_WIN32_WINNT >= _WIN32_WINNT_WS03)
//
// CLS_CONTAINER_INFORMATION
//
// This structure defines a container descriptor.  The descriptor specifies the
// container's creation and access times, size, file system name, file system
// attributes, state, minimum, and maximum LSNs.
//

typedef struct _CLS_CONTAINER_INFORMATION
{
    ULONG FileAttributes;                    // File system attribute flag.
    ULONGLONG CreationTime;                  // File creation time.
    ULONGLONG LastAccessTime;                // Last time container was read/written.
    ULONGLONG LastWriteTime;                 // Last time container was written.
    LONGLONG ContainerSize;                  // Size of container in bytes.
    ULONG FileNameActualLength;              // Length of the actual file name.
    ULONG FileNameLength;                    // Length of file name in buffer
    WCHAR FileName [CLFS_MAX_CONTAINER_INFO];// File system name for container.
    CLFS_CONTAINER_STATE State;              // Current state of the container.
    CLFS_CONTAINER_ID PhysicalContainerId;   // Physical container identifier.
    CLFS_CONTAINER_ID LogicalContainerId;    // Logical container identifier.

} CLS_CONTAINER_INFORMATION, *PCLS_CONTAINER_INFORMATION, **PPCLS_CONTAINER_INFORMATION;

//
// Alias all CLS prefixes with CLFS prefixes.
//

typedef CLS_CONTAINER_INFORMATION CLFS_CONTAINER_INFORMATION;
typedef CLFS_CONTAINER_INFORMATION *PCLFS_CONTAINER_INFORMATION, **PPCLFS_CONTAINER_INFORMATION;
#endif /* NTDDI_VERSION || _WIN32_WINNT */


#if (NTDDI_VERSION >= NTDDI_WS03SP1) || (_WIN32_WINNT >= _WIN32_WINNT_WS03)
//
// CLFS_LOG_INFORMATION_CLASS
//
// The information class specifies the kind of information a caller
// wishes to query or set on a log file.
//

typedef enum _CLS_LOG_INFORMATION_CLASS
{

    ClfsLogBasicInformation = 0x00,         // For virtual or physical logs, indicates the respective basic information.
    ClfsLogBasicInformationPhysical,        // Always indicates physical log basic information.
    ClfsLogPhysicalNameInformation,         // Always indicates physical name information.
    ClfsLogStreamIdentifierInformation,     // Virtual/physical log agnostic.
#if (NTDDI_VERSION >= NTDDI_LONGHORN) || (_WIN32_WINNT >= _WIN32_WINNT_LONGHORN)
    ClfsLogSystemMarkingInformation,        // Count of system marking references.
    ClfsLogPhysicalLsnInformation           // Maps virtual LSNs to physical LSNs; only valid for physical logs.
#endif /* NTDDI_VERSION || _WIN32_WINNT */

} CLS_LOG_INFORMATION_CLASS, *PCLS_LOG_INFORMATION_CLASS, **PPCLS_LOG_INFORMATION_CLASS;

//
// Alias all CLS prefixes with CLFS prefixes.
//

typedef CLS_LOG_INFORMATION_CLASS CLFS_LOG_INFORMATION_CLASS;
typedef CLFS_LOG_INFORMATION_CLASS *PCLFS_LOG_INFORMATION_CLASS, **PPCLFS_LOG_INFORMATION_CLASS;
#endif /* NTDDI_VERSION || _WIN32_WINNT */

#if (NTDDI_VERSION >= NTDDI_WS03SP1) || (_WIN32_WINNT >= _WIN32_WINNT_WS03)
//
// CLS_IOSTATS_CLASS
//
// Enumerated type defining the class of I/O statistics.
//

typedef enum _CLS_IOSTATS_CLASS
{
    ClsIoStatsDefault = 0x0000,
    ClsIoStatsMax     = 0xFFFF

} CLS_IOSTATS_CLASS, *PCLS_IOSTATS_CLASS, **PPCLS_IOSTATS_CLASS;
#endif /* NTDDI_VERSION || _WIN32_WINNT */


#if (NTDDI_VERSION >= NTDDI_WS03SP1) || (_WIN32_WINNT >= _WIN32_WINNT_WS03)
//
// CLFS_IOSTATS_CLASS
//
// Alias all CLS prefixes with CLFS prefixes.
//

typedef enum _CLFS_IOSTATS_CLASS
{
    ClfsIoStatsDefault = 0x0000,
    ClfsIoStatsMax     = 0xFFFF

} CLFS_IOSTATS_CLASS, *PCLFS_IOSTATS_CLASS, **PPCLFS_IOSTATS_CLASS;
#endif /* NTDDI_VERSION || _WIN32_WINNT */


#if (NTDDI_VERSION >= NTDDI_WS03SP1) || (_WIN32_WINNT >= _WIN32_WINNT_WS03)
//
// CLS_IO_STATISTICS
//
// This structure defines I/O performance counters particular to a log file.  It consists
// of a header followed by the I/O statistics counters.  The header is being ignored for
// now.
//

typedef struct _CLS_IO_STATISTICS_HEADER
{
    UCHAR                ubMajorVersion;     // Major version of the statistics buffer.
    UCHAR                ubMinorVersion;     // Minor version of the statistics buffer.
    CLFS_IOSTATS_CLASS  eStatsClass;        // I/O statistics class.
    USHORT              cbLength;           // Length of the statistics buffer.                     
    ULONG               coffData;           // Offset of statistics counters.

} CLS_IO_STATISTICS_HEADER, *PCLS_IO_STATISTICS_HEADER, **PPCLS_IO_STATISTICS_HEADER;

//
// Alias all CLS prefixes with CLFS prefixes.
//

typedef CLS_IO_STATISTICS_HEADER CLFS_IO_STATISTICS_HEADER;
typedef CLFS_IO_STATISTICS_HEADER *PCLFS_IO_STATISTICS_HEADER, **PPCLFS_IO_STATISTICS_HEADER;
#endif /* NTDDI_VERSION || _WIN32_WINNT */


#if (NTDDI_VERSION >= NTDDI_WS03SP1) || (_WIN32_WINNT >= _WIN32_WINNT_WS03)
typedef struct _CLS_IO_STATISTICS
{
    CLS_IO_STATISTICS_HEADER hdrIoStats;    // Statistics buffer header.
    ULONGLONG cFlush;                       // Flush count.
    ULONGLONG cbFlush;                      // Cumulative number of bytes flushed.
    ULONGLONG cMetaFlush;                   // Metadata flush count.
    ULONGLONG cbMetaFlush;                  // Cumulative number of metadata bytes flushed.

} CLS_IO_STATISTICS, *PCLS_IO_STATISTICS, **PPCLS_IO_STATISTICS;

//
// Alias all CLS prefixes with CLFS prefixes.
//

typedef CLS_IO_STATISTICS CLFS_IO_STATISTICS;
typedef CLFS_IO_STATISTICS *PCLFS_IO_STATISTICS, **PPCLFS_IO_STATISTICS;
#endif /* NTDDI_VERSION || _WIN32_WINNT */

#if (NTDDI_VERSION >= NTDDI_WS03SP1) || (_WIN32_WINNT >= _WIN32_WINNT_WS03)
//
// CLFS_SCAN_MODE
//
// Container scan mode flags.
//

#ifdef __cplusplus

const   UCHAR CLFS_SCAN_INIT         =   0x01;
const   UCHAR CLFS_SCAN_FORWARD      =   0x02;
const   UCHAR CLFS_SCAN_BACKWARD     =   0x04;
const   UCHAR CLFS_SCAN_CLOSE        =   0x08;
const   UCHAR CLFS_SCAN_INITIALIZED  =   0x10;
const   UCHAR CLFS_SCAN_BUFFERED     =   0x20;

#else

#define CLFS_SCAN_INIT                  0x01
#define CLFS_SCAN_FORWARD               0x02
#define CLFS_SCAN_BACKWARD              0x04
#define CLFS_SCAN_CLOSE                 0x08
#define CLFS_SCAN_INITIALIZED           0x10
#define CLFS_SCAN_BUFFERED              0x20

#endif

typedef UCHAR CLFS_SCAN_MODE, *PCLFS_SCAN_MODE;
#endif /* NTDDI_VERSION || _WIN32_WINNT */


// end_wdm

#ifdef CLFS_KERNEL_MODE

// begin_wdm
#if (NTDDI_VERSION >= NTDDI_WS03SP1) || (_WIN32_WINNT >= _WIN32_WINNT_WS03)

//
// CLFS_SCAN_CONTEXT
//
// Container scan context for scanning all containers in a given physical log
// file.
//

//
// The log file object wraps an NT file object and the size of the structure. 
// The log file object may be modified in the near future and there should be no
// dependencies on the size of the structure itself.
//

typedef FILE_OBJECT LOG_FILE_OBJECT, *PLOG_FILE_OBJECT, **PPLOG_FILE_OBJECT;

typedef struct _CLS_SCAN_CONTEXT
{
    CLFS_NODE_ID cidNode;
    PLOG_FILE_OBJECT plfoLog;
    __declspec(align(8)) ULONG cIndex;
    __declspec(align(8)) ULONG cContainers;
    __declspec(align(8)) ULONG cContainersReturned;
    __declspec(align(8)) CLFS_SCAN_MODE eScanMode;
    __declspec(align(8)) PCLS_CONTAINER_INFORMATION pinfoContainer;
    
} CLS_SCAN_CONTEXT, *PCLS_SCAN_CONTEXT, **PPCLS_SCAN_CONTEXT;

#endif /* NTDDI_VERSION || _WIN32_WINNT */

// end_wdm

#else

#if (NTDDI_VERSION >= NTDDI_WS03SP1) || (_WIN32_WINNT >= _WIN32_WINNT_WS03)
typedef struct _CLS_SCAN_CONTEXT
{
    CLFS_NODE_ID cidNode;
    HANDLE hLog;
    __declspec(align(8)) ULONG cIndex;
    __declspec(align(8)) ULONG cContainers;
    __declspec(align(8)) ULONG cContainersReturned;
    __declspec(align(8)) CLFS_SCAN_MODE eScanMode;
    __declspec(align(8)) PCLS_CONTAINER_INFORMATION pinfoContainer;
    
} CLS_SCAN_CONTEXT, *PCLS_SCAN_CONTEXT, **PPCLS_SCAN_CONTEXT;
#endif /* NTDDI_VERSION || _WIN32_WINNT */

#endif /* CLFS_KERNEL_MODE */

// begin_wdm

#if (NTDDI_VERSION >= NTDDI_WS03SP1) || (_WIN32_WINNT >= _WIN32_WINNT_WS03)
//
// Alias all CLS prefixes with CLFS prefixes.
//

typedef CLS_SCAN_CONTEXT CLFS_SCAN_CONTEXT;
typedef CLFS_SCAN_CONTEXT *PCLFS_SCAN_CONTEXT, **PPCLFS_SCAN_CONTEXT;
#endif /* NTDDI_VERSION || _WIN32_WINNT */

#if (NTDDI_VERSION >= NTDDI_WS03SP1) || (_WIN32_WINNT >= _WIN32_WINNT_WS03)
//
// CLFS_ARCHIVE_DESCRIPTOR
//
// Log archive descriptors describe the set of discrete but logically
// contiguous disk extents comprising a snapshot of the active log when
// preparing for archival.  Log archive descriptors specify enough information
// for log archive clients directly access the relevant contents of containers
// for archiving and restoring a snapshot of the log.
//

typedef struct _CLS_ARCHIVE_DESCRIPTOR
{
    ULONGLONG coffLow;
    ULONGLONG coffHigh;
    CLS_CONTAINER_INFORMATION infoContainer;

} CLS_ARCHIVE_DESCRIPTOR, *PCLS_ARCHIVE_DESCRIPTOR, **PPCLS_ARCHIVE_DESCRIPTOR;

//
// Alias CLS prefixes with CLFS prefixes.
//

typedef CLS_ARCHIVE_DESCRIPTOR CLFS_ARCHIVE_DESCRIPTOR;
typedef CLFS_ARCHIVE_DESCRIPTOR *PCLFS_ARCHIVE_DESCRIPTOR, **PPCLFS_ARCHIVE_DESCRIPTOR;
#endif /* NTDDI_VERSION || _WIN32_WINNT */

#if (NTDDI_VERSION >= NTDDI_WS03SP1) || (_WIN32_WINNT >= _WIN32_WINNT_WS03)
//
// CLFS_ALLOCATION_ROUTINE
//
// Allocate a blocks for marshalled reads or writes
//

typedef PVOID (* CLFS_BLOCK_ALLOCATION) (ULONG cbBufferLength, PVOID pvUserContext);

//
// CLFS_DEALLOCATION_ROUTINE
//
// Deallocate buffers allocated by the CLFS_ALLOCATION_ROUTINE.
//

typedef void (* CLFS_BLOCK_DEALLOCATION) (PVOID pvBuffer, PVOID pvUserContext);
#endif /* NTDDI_VERSION || _WIN32_WINNT */

#if (NTDDI_VERSION >= NTDDI_WS03SP1) || (_WIN32_WINNT >= _WIN32_WINNT_WS03)
//
// CLFS_LOG_ARCHIVE_MODE
//
// Describes the archive support behavior for the log.
//

typedef enum _CLFS_LOG_ARCHIVE_MODE
{

    ClfsLogArchiveEnabled = 0x01,
    ClfsLogArchiveDisabled = 0x02

} CLFS_LOG_ARCHIVE_MODE, *PCLFS_LOG_ARCHIVE_MODE;
#endif /* NTDDI_VERSION || _WIN32_WINNT */


//-----------------------------------------------------------------------------
// LSN OPERATORS
//-----------------------------------------------------------------------------

#ifdef __cplusplus
extern "C"
{
#endif


#if (NTDDI_VERSION >= NTDDI_WS03SP1) || (_WIN32_WINNT >= _WIN32_WINNT_WS03)
//-----------------------------------------------------------------------------
// ClfsLsnEqual
//
//      Method Description:
//
//          Check for the equivalence of LSNs.
//
//      Arguments:
//
//          plsn1   -- first LSN comparator
//          plsn2   -- second LSN comparator
//          
//
//      Return Value:
//
//          TRUE if LSN values are equivalent and FALSE otherwise.
//
//-----------------------------------------------------------------------------

CLFSUSER_API BOOLEAN NTAPI
ClfsLsnEqual
(
    IN const CLFS_LSN* plsn1,
    IN const CLFS_LSN* plsn2
);
#endif /* NTDDI_VERSION || _WIN32_WINNT */


#if (NTDDI_VERSION >= NTDDI_WS03SP1) || (_WIN32_WINNT >= _WIN32_WINNT_WS03)
//-----------------------------------------------------------------------------
// ClfsLsnLess
//
//      Method Description:
//
//          Check if LSN1 is less than LSN2.
//
//      Arguments:
//
//          plsn1   -- first LSN comparator
//          plsn2   -- second LSN comparator
//          
//
//      Return Value:
//
//          TRUE if LSN1 is less than LSN2 and FALSE otherwise.
//
//-----------------------------------------------------------------------------

CLFSUSER_API BOOLEAN NTAPI
ClfsLsnLess
(
    IN const CLFS_LSN* plsn1,
    IN const CLFS_LSN* plsn2
);
#endif /* NTDDI_VERSION || _WIN32_WINNT */


#if (NTDDI_VERSION >= NTDDI_WS03SP1) || (_WIN32_WINNT >= _WIN32_WINNT_WS03)
//-----------------------------------------------------------------------------
// ClfsLsnGreater
//
//      Method Description:
//
//          Check if LSN1 is  greater than LSN2.
//
//      Arguments:
//
//          plsn1   -- first LSN comparator
//          plsn2   -- second LSN comparator
//          
//
//      Return Value:
//
//          TRUE if LSN1 is greater than LSN2 and FALSE otherwise.
//
//-----------------------------------------------------------------------------

CLFSUSER_API BOOLEAN NTAPI
ClfsLsnGreater
(
    IN const CLFS_LSN* plsn1,
    IN const CLFS_LSN* plsn2
);
#endif /* NTDDI_VERSION || _WIN32_WINNT */


#if (NTDDI_VERSION >= NTDDI_WS03SP1) || (_WIN32_WINNT >= _WIN32_WINNT_WS03)
//-----------------------------------------------------------------------------
// ClfsLsnNull (Inline)
//
//      Method Description:
//
//          Check whether or not an LSN is CLFS_LSN_NULL.
//
//      Arguments:
//
//          plsn    -- reference to LSN tested against the NULL value.
//          
//
//      Return Value:
//
//          TRUE if and only if an LSN is equivalent to CLFS_LSN_NULL.  
//          LSNs with the value CLFS_LSN_INVALID will return FALSE.
//
//-----------------------------------------------------------------------------

CLFSUSER_API BOOLEAN NTAPI
ClfsLsnNull
(
    IN const CLFS_LSN* plsn
);
#endif /* NTDDI_VERSION || _WIN32_WINNT */


#if (NTDDI_VERSION >= NTDDI_WS03SP1) || (_WIN32_WINNT >= _WIN32_WINNT_WS03)
//-----------------------------------------------------------------------------
// ClfsLsnContainer (Inline)
//
//      Routine Description:
//
//      Extract the container identifier from the LSN.
//
//      Arguments:
//
//          plsn -- get block offset from this LSN
//
//      Return Value:
//
//          Returns the container identifier for the LSN.
//
//-----------------------------------------------------------------------------

CLFSUSER_API CLFS_CONTAINER_ID NTAPI
ClfsLsnContainer
(
  IN const CLFS_LSN* plsn
);
#endif /* NTDDI_VERSION || _WIN32_WINNT */


#if (NTDDI_VERSION >= NTDDI_WS03SP1) || (_WIN32_WINNT >= _WIN32_WINNT_WS03)
//-----------------------------------------------------------------------------
// ClfsLsnCreate (Inline)
//
//      Routine Description:
//
//      Create an LSN given a log identifier, a container identifier, a block
//      offset and a bucket identifier.  Caller must test for invalid LSN after
//      making this call.
//
//      Arguments:
//
//          cidContainer    -- container identifier
//          offBlock        -- block offset
//          cRecord         -- ordinal number of the record in block
//
//      Return Value:
//
//          Returns a valid LSN if successful, otherwise it returns
//          CLFS_LSN_INVALID
//
//-----------------------------------------------------------------------------

CLFSUSER_API CLFS_LSN NTAPI
ClfsLsnCreate
(
    IN CLFS_CONTAINER_ID    cidContainer,
    IN ULONG                offBlock,
    IN ULONG                cRecord
);
#endif /* NTDDI_VERSION || _WIN32_WINNT */


#if (NTDDI_VERSION >= NTDDI_WS03SP1) || (_WIN32_WINNT >= _WIN32_WINNT_WS03)
//-----------------------------------------------------------------------------
// ClfsLsnBlockOffset (Inline)
//
//      Routine Description:
//
//      Extract the block offset from the LSN.
//
//      Arguments:
//
//          plsn -- get block offset from this LSN
//
//      Return Value:
//
//          Returns the block offset for the LSN.
//
//-----------------------------------------------------------------------------

CLFSUSER_API ULONG NTAPI
ClfsLsnBlockOffset
(
  IN const CLFS_LSN* plsn
);
#endif /* NTDDI_VERSION || _WIN32_WINNT */


#if (NTDDI_VERSION >= NTDDI_WS03SP1) || (_WIN32_WINNT >= _WIN32_WINNT_WS03)
//-----------------------------------------------------------------------------
// ClfsLsnRecordSequence (Inline)
//
//      Routine Description:
//
//          Extract the bucket identifier from the LSN.
//
//      Arguments:
//
//          plsn    -- get block offset from this LSN
//
//      Return Value:
//
//          Returns the bucket identifier for the LSN.
//
//-----------------------------------------------------------------------------

CLFSUSER_API ULONG NTAPI
ClfsLsnRecordSequence
(
    IN const CLFS_LSN* plsn
);
#endif /* NTDDI_VERSION || _WIN32_WINNT */


#if (NTDDI_VERSION >= NTDDI_WS03SP1) || (_WIN32_WINNT >= _WIN32_WINNT_WS03)
//-----------------------------------------------------------------------------
// ClfsLsnInvalid
//
//      Method Description:
//
//          Check whether or not an LSN is CLFS_LSN_INVALID.
//
//      Arguments:
//
//          plsn    -- reference to LSN tested against CLFS_LSN_INVALID.
//          
//
//      Return Value:
//
//          TRUE if and only if an LSN is equivalent to CLFS_LSN_INVALID.  
//          LSNs with the value CLFS_LSN_NULL will return FALSE.
//
//-----------------------------------------------------------------------------

CLFSUSER_API BOOLEAN NTAPI
ClfsLsnInvalid
(
    IN const CLFS_LSN* plsn
);
#endif /* NTDDI_VERSION || _WIN32_WINNT */


#if (NTDDI_VERSION >= NTDDI_WS03SP1) || (_WIN32_WINNT >= _WIN32_WINNT_WS03)
//-----------------------------------------------------------------------------
// ClfsLsnIncrement
//
//      Method Description:
//
//          Increment and LSN by 1
//
//      Arguments:
//
//          plsn -- LSN to be incremented.
//          
//
//      Return Value:
//
//          A valid LSN next in sequence to the input LSN, if successful.
//          Otherwise, this function returns CLFS_LSN_INVALID.
//
//-----------------------------------------------------------------------------

CLFSUSER_API CLFS_LSN NTAPI
ClfsLsnIncrement (IN PCLFS_LSN  plsn);
#endif /* NTDDI_VERSION || _WIN32_WINNT */


#ifdef __cplusplus
}
#endif

#ifdef __cplusplus

#ifdef CLFS_OPERATORS

#if (NTDDI_VERSION >= NTDDI_WS03SP1) || (_WIN32_WINNT >= _WIN32_WINNT_WS03)
//
// LSN arithmetic increment operator.
//

inline CLFS_LSN
operator++
(
    CLFS_LSN& refLsn
)
{
    //
    // Prefix increment operator.
    //

    refLsn = ClfsLsnIncrement (&refLsn);
    return refLsn;
}
#endif /* NTDDI_VERSION || _WIN32_WINNT */

#if (NTDDI_VERSION >= NTDDI_WS03SP1) || (_WIN32_WINNT >= _WIN32_WINNT_WS03)
//
// BOOLEAN LSN operators.
//

inline BOOLEAN      
operator<
(
    const CLFS_LSN& refLsn1, 
    const CLFS_LSN& refLsn2
)
{
    return (ClfsLsnLess ((PCLFS_LSN) &refLsn1, (PCLFS_LSN) &refLsn2));
}
#endif /* NTDDI_VERSION || _WIN32_WINNT */

#if (NTDDI_VERSION >= NTDDI_WS03SP1) || (_WIN32_WINNT >= _WIN32_WINNT_WS03)
inline BOOLEAN  
operator>
(
    const CLFS_LSN& refLsn1, 
    const CLFS_LSN& refLsn2
)
{
    return (ClfsLsnGreater ((PCLFS_LSN) &refLsn1, (PCLFS_LSN) &refLsn2));
}
#endif /* NTDDI_VERSION || _WIN32_WINNT */

#if (NTDDI_VERSION >= NTDDI_WS03SP1) || (_WIN32_WINNT >= _WIN32_WINNT_WS03)
inline BOOLEAN  
operator==
(
    const CLFS_LSN& refLsn1, 
    const CLFS_LSN& refLsn2
)
{
    return (ClfsLsnEqual ((PCLFS_LSN) &refLsn1, (PCLFS_LSN) &refLsn2));
}
#endif /* NTDDI_VERSION || _WIN32_WINNT */

#if (NTDDI_VERSION >= NTDDI_WS03SP1) || (_WIN32_WINNT >= _WIN32_WINNT_WS03)
inline BOOLEAN
operator!=
(
    const CLFS_LSN& refLsn1,
    const CLFS_LSN& refLsn2
)
{
    return (!ClfsLsnEqual ((PCLFS_LSN) &refLsn1, (PCLFS_LSN) &refLsn2));
}
#endif /* NTDDI_VERSION || _WIN32_WINNT */

#if (NTDDI_VERSION >= NTDDI_WS03SP1) || (_WIN32_WINNT >= _WIN32_WINNT_WS03)
inline BOOLEAN      
operator<=
(
    const CLFS_LSN& refLsn1, 
    const CLFS_LSN& refLsn2
)
{
    return (!ClfsLsnGreater ((PCLFS_LSN) &refLsn1, (PCLFS_LSN) &refLsn2));
}
#endif /* NTDDI_VERSION || _WIN32_WINNT */

#if (NTDDI_VERSION >= NTDDI_WS03SP1) || (_WIN32_WINNT >= _WIN32_WINNT_WS03)
inline BOOLEAN  
operator>=
(
    const CLFS_LSN& refLsn1, 
    const CLFS_LSN& refLsn2
)
{
    return (!ClfsLsnLess ((PCLFS_LSN) &refLsn1, (PCLFS_LSN) &refLsn2));
}
#endif /* NTDDI_VERSION || _WIN32_WINNT */

#endif /* CLFS_OPERATORS */

#endif /* __cplusplus */

#endif /* _CLFS_PUBLIC_H_ */
// end_wdm

//-----------------------------------------------------------------------------
//                                      END OF FILE
//-----------------------------------------------------------------------------
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\vs9sp1\sdk\include\clfsmgmt.h ===
/*++

Copyright (c) Microsoft Corporation. All rights reserved.

Module Name:

    clfsmgmt.h

Abstract:

    This module exposes the API for managing CLFS logs for kernel
    mode clients.  "Managing" in this sense means manipulating
    log file policies and performing operations (such as log growth)
    which honor the policies.

Author:

    J.R. Tipton (jrtipton) 15-Aug-2003

Revision History:

--*/

#ifndef _CLFSMGMT_H_
#define _CLFSMGMT_H_
#pragma once

// begin_wdm

#ifdef __cplusplus
extern "C" {
#endif

#if (NTDDI_VERSION >= NTDDI_WS03SP1) || (_WIN32_WINNT >= _WIN32_WINNT_WS03)
//
// We start with the information that is shared
// between user and kernel mode.
//

typedef enum _CLFS_MGMT_POLICY_TYPE {

    ClfsMgmtPolicyMaximumSize = 0x0,
    ClfsMgmtPolicyMinimumSize,
    ClfsMgmtPolicyNewContainerSize,
    ClfsMgmtPolicyGrowthRate,
    ClfsMgmtPolicyLogTail,
    ClfsMgmtPolicyAutoShrink,
    ClfsMgmtPolicyAutoGrow,
    ClfsMgmtPolicyNewContainerPrefix,
    ClfsMgmtPolicyNewContainerSuffix,
    ClfsMgmtPolicyNewContainerExtension,

    ClfsMgmtPolicyInvalid

} CLFS_MGMT_POLICY_TYPE, *PCLFS_MGMT_POLICY_TYPE;
#endif /* NTDDI_VERSION || _WIN32_WINNT */

#if (NTDDI_VERSION >= NTDDI_WS03SP1) || (_WIN32_WINNT >= _WIN32_WINNT_WS03)
#define CLFS_MGMT_NUM_POLICIES ((ULONG)ClfsMgmtPolicyInvalid)
#endif /* NTDDI_VERSION || _WIN32_WINNT */


#if (NTDDI_VERSION >= NTDDI_WS03SP1) || (_WIN32_WINNT >= _WIN32_WINNT_WS03)
//
// Relative sizes used when explicitly setting log size.
//
#define CLFS_LOG_SIZE_MINIMUM ((ULONGLONG)(0))
#define CLFS_LOG_SIZE_MAXIMUM ((ULONGLONG)(-1))
#endif /* NTDDI_VERSION || _WIN32_WINNT */


#if (NTDDI_VERSION >= NTDDI_WS03SP1) || (_WIN32_WINNT >= _WIN32_WINNT_WS03)
//
// The version of a given policy structure.  See CLFS_MGMT_POLICY.
//
#define CLFS_MGMT_POLICY_VERSION (0x01)
#endif /* NTDDI_VERSION || _WIN32_WINNT */


#if (NTDDI_VERSION >= NTDDI_WS03SP1) || (_WIN32_WINNT >= _WIN32_WINNT_WS03)
//
// Log policy flags.
//
// LOG_POLICY_OVERWRITE: If set when adding a log policy, the previous
//                       policy of given type will be replaced.
//
// LOG_POLICY_PERSIST:   If set when adding a log policy, the policy
//                       will be persisted with the log metadata.
//
#define LOG_POLICY_OVERWRITE   (0x01)
#define LOG_POLICY_PERSIST     (0x02)
#endif /* NTDDI_VERSION || _WIN32_WINNT */


#if (NTDDI_VERSION >= NTDDI_WS03SP1) || (_WIN32_WINNT >= _WIN32_WINNT_WS03)
//
// CLFS_MGMT_POLICY
//
// This structure describes one particular policy that
// may be present on a log file.  These are installed
// via InstallLogPolicy (Win32) or ClfsMgmtInstallPolicy (kernel).
//
typedef struct _CLFS_MGMT_POLICY {

    //
    // Version of the structure.  Should be CLFS_MGMT_POLICY_VERSION.
    //
    ULONG                   Version;

    //
    // The entire length of the structure.
    //
    ULONG                   LengthInBytes;

    //
    // Flags which apply to all policies, such as LOG_POLICY_OVERWRITE
    // and LOG_POLICY_PERSIST.
    //
    ULONG                   PolicyFlags;

    //
    // Determines how PolicyParameters union is interpreted.
    //
    CLFS_MGMT_POLICY_TYPE   PolicyType;

    //
    // The way to interpret the PolicyParameters union is
    // determined by the value of PolicyType -- if it is
    // ClfsMgmtPolicyMaximumSize, for instance, then the
    // MaximumSize structure is the relevant one.
    //

    union {

        struct {
            ULONG       Containers;
        } MaximumSize;

        struct {
            ULONG       Containers;
        } MinimumSize;

        struct {
            ULONG       SizeInBytes;
        } NewContainerSize;

        struct {
            ULONG       AbsoluteGrowthInContainers;
            ULONG       RelativeGrowthPercentage;
        } GrowthRate;

        struct {
            ULONG       MinimumAvailablePercentage;
            ULONG       MinimumAvailableContainers;
        } LogTail;

        struct {
            ULONG       Percentage;
        } AutoShrink;

        struct {
            ULONG       Enabled;
        } AutoGrow;

        struct {
            USHORT      PrefixLengthInBytes;
            WCHAR       PrefixString[1]; // dynamic in length depending on PrefixLength
        } NewContainerPrefix;

        struct {
            ULONGLONG   NextContainerSuffix;
        } NewContainerSuffix;

        struct {
            USHORT      ExtensionLengthInBytes;
            WCHAR       ExtensionString[1]; // dynamic in length depending on ExtensionLengthInBytes
        } NewContainerExtension;

    } PolicyParameters;

    //
    // Nothing will be added down here since the structure above
    // can be of dynamic length.
    //

} CLFS_MGMT_POLICY, *PCLFS_MGMT_POLICY;
#endif /* NTDDI_VERSION || _WIN32_WINNT */


#if (NTDDI_VERSION >= NTDDI_WS03SP1) || (_WIN32_WINNT >= _WIN32_WINNT_WS03)
//
// CLFS_MGMT_NOTIFICATION_TYPE
// 
// The types of notifications given to either the callback proxy
// or to readers of notifications.
//

typedef enum _CLFS_MGMT_NOTIFICATION_TYPE
{

    //
    // Notification to advance base LSN.
    //

    ClfsMgmtAdvanceTailNotification = 0,

    //
    // Notification that a request to handle log full condition
    // has completed.
    //

    ClfsMgmtLogFullHandlerNotification,

    //
    // Notification that a previously pinned log is now considered
    // unpinned.
    //

    ClfsMgmtLogUnpinnedNotification

} CLFS_MGMT_NOTIFICATION_TYPE, *PCLFS_MGMT_NOTIFICATION_TYPE;
#endif /* NTDDI_VERSION || _WIN32_WINNT */


#if (NTDDI_VERSION >= NTDDI_WS03SP1) || (_WIN32_WINNT >= _WIN32_WINNT_WS03)
//
// CLFS_MGMT_NOTIFICATION
//
// A notification and associated parameters.
//

typedef struct _CLFS_MGMT_NOTIFICATION
{

    //
    // Nature of the notification.
    //

    CLFS_MGMT_NOTIFICATION_TYPE     Notification;
    
    //
    // Target LSN for base LSN advancement if the
    // notification type is ClfsMgmtAdvanceTailNotification.
    //

    CLFS_LSN                        Lsn;

    //
    // TRUE if the log is pinned, FALSE otherwise.
    // Especially meaningful when receiving an error
    // status for ClfsMgmtLogFullHandlerNotification.
    //

    USHORT                          LogIsPinned;

} CLFS_MGMT_NOTIFICATION, *PCLFS_MGMT_NOTIFICATION;
#endif /* NTDDI_VERSION || _WIN32_WINNT */


//
// Kernel interface described below.
//

// end_wdm

#ifdef CLFS_KERNEL_MODE

// begin_wdm

#if (NTDDI_VERSION >= NTDDI_WS03SP1) || (_WIN32_WINNT >= _WIN32_WINNT_WS03)
//
// The advance tail callback is required when log clients 
// register for management.  It is invoked whenever the 
// management library decides that this client needs to 
// advance the tail of its log. Only minimal processing is 
// allowed.
//
typedef
NTSTATUS
(*PCLFS_CLIENT_ADVANCE_TAIL_CALLBACK) (
    IN PLOG_FILE_OBJECT LogFile,
    IN PCLFS_LSN        TargetLsn,
    IN PVOID            ClientData
    );
#endif /* NTDDI_VERSION || _WIN32_WINNT */

#if (NTDDI_VERSION >= NTDDI_WS03SP1) || (_WIN32_WINNT >= _WIN32_WINNT_WS03)
//
// The log file full handler complete callback is invoked upon
// completion of a log growth request (that is, via a call 
// to ClfsMgmtHandleLogFileFull).
//
typedef
VOID
(*PCLFS_CLIENT_LFF_HANDLER_COMPLETE_CALLBACK) (
    IN PLOG_FILE_OBJECT LogFile,
    IN NTSTATUS         OperationStatus,
    IN BOOLEAN          LogIsPinned,
    IN PVOID            ClientData
    );
#endif /* NTDDI_VERSION || _WIN32_WINNT */

#if (NTDDI_VERSION >= NTDDI_WS03SP1) || (_WIN32_WINNT >= _WIN32_WINNT_WS03)
//
// The log pinned callback is invoked when log space is freed up
// after a log file full handler completion callback indicates an 
// NT_ERROR status code and LogIsPinned = TRUE.
//

typedef
VOID
(*PCLFS_CLIENT_LOG_UNPINNED_CALLBACK) (
    IN PLOG_FILE_OBJECT LogFile,
    IN PVOID            ClientData
    );
#endif /* NTDDI_VERSION || _WIN32_WINNT */


#if (NTDDI_VERSION >= NTDDI_WS03SP1) || (_WIN32_WINNT >= _WIN32_WINNT_WS03)
//
// The log size complete callback is invoked whenever
// ClfsMgmtSetLogFileSize operation which returned
// STATUS_PENDING is completed.
//

typedef
VOID
(*PCLFS_SET_LOG_SIZE_COMPLETE_CALLBACK) (
    IN PLOG_FILE_OBJECT LogFile,
    IN NTSTATUS         OperationStatus,
    IN PVOID            ClientData
    );
#endif /* NTDDI_VERSION || _WIN32_WINNT */


#if (NTDDI_VERSION >= NTDDI_WS03SP1) || (_WIN32_WINNT >= _WIN32_WINNT_WS03)
//
// CLFS_MGMT_CLIENT_REGISTRATION
//
// This structure is given to the CLFS management infrastructure
// by clients who wish to be managed (via ClfsMgmtRegisterManagedClient).
// The CLFS_MGMT_CLIENT_REGISTRATION_VERSION value must be stored
// in the 'Version' field of the structure.
//

#define CLFS_MGMT_CLIENT_REGISTRATION_VERSION (0x1)

typedef struct _CLFS_MGMT_CLIENT_REGISTRATION {

    //
    // Initialize Version to CLFS_MGMT_CLIENT_REGISTRATION_VERSION.
    //

    ULONG   Version;  

    PCLFS_CLIENT_ADVANCE_TAIL_CALLBACK AdvanceTailCallback;
    PVOID                              AdvanceTailCallbackData;

    PCLFS_CLIENT_LFF_HANDLER_COMPLETE_CALLBACK LogGrowthCompleteCallback;
    PVOID                                      LogGrowthCompleteCallbackData;

    PCLFS_CLIENT_LOG_UNPINNED_CALLBACK LogUnpinnedCallback;
    PVOID                              LogUnpinnedCallbackData;

} CLFS_MGMT_CLIENT_REGISTRATION, *PCLFS_MGMT_CLIENT_REGISTRATION;
#endif /* NTDDI_VERSION || _WIN32_WINNT */


#if (NTDDI_VERSION >= NTDDI_WS03SP1) || (_WIN32_WINNT >= _WIN32_WINNT_WS03)
//
// CLFS_MGMT_CLIENT
//
// This is the cookie that clients are given when registering and
// must give back to the management infrastructure whenever 
// performing an operation.
//
typedef PVOID CLFS_MGMT_CLIENT, *PCLFS_MGMT_CLIENT;
#endif /* NTDDI_VERSION || _WIN32_WINNT */


#if (NTDDI_VERSION >= NTDDI_WS03SP1) || (_WIN32_WINNT >= _WIN32_WINNT_WS03)
NTSTATUS
ClfsMgmtRegisterManagedClient(
    IN  PLOG_FILE_OBJECT LogFile,
    IN  PCLFS_MGMT_CLIENT_REGISTRATION RegistrationData,
    OUT PCLFS_MGMT_CLIENT ClientCookie
    );
#endif /* NTDDI_VERSION || _WIN32_WINNT */

#if (NTDDI_VERSION >= NTDDI_WS03SP1) || (_WIN32_WINNT >= _WIN32_WINNT_WS03)
NTSTATUS
ClfsMgmtDeregisterManagedClient(
    IN CLFS_MGMT_CLIENT ClientCookie
    );
#endif /* NTDDI_VERSION || _WIN32_WINNT */

#if (NTDDI_VERSION >= NTDDI_WS03SP1) || (_WIN32_WINNT >= _WIN32_WINNT_WS03)
NTSTATUS
ClfsMgmtTailAdvanceFailure(
    IN CLFS_MGMT_CLIENT  Client,
    IN NTSTATUS          Reason
    );
#endif /* NTDDI_VERSION || _WIN32_WINNT */

#if (NTDDI_VERSION >= NTDDI_WS03SP1) || (_WIN32_WINNT >= _WIN32_WINNT_WS03)
NTSTATUS
ClfsMgmtHandleLogFileFull(
    IN CLFS_MGMT_CLIENT Client
    );
#endif /* NTDDI_VERSION || _WIN32_WINNT */

#if (NTDDI_VERSION >= NTDDI_WS03SP1) || (_WIN32_WINNT >= _WIN32_WINNT_WS03)
NTSTATUS
ClfsMgmtInstallPolicy(
    IN PLOG_FILE_OBJECT  LogFile,
    IN PCLFS_MGMT_POLICY Policy,
    IN ULONG             PolicyLength
    );
#endif /* NTDDI_VERSION || _WIN32_WINNT */

#if (NTDDI_VERSION >= NTDDI_WS03SP1) || (_WIN32_WINNT >= _WIN32_WINNT_WS03)
NTSTATUS
ClfsMgmtQueryPolicy(
    IN  PLOG_FILE_OBJECT      LogFile,
    IN  CLFS_MGMT_POLICY_TYPE PolicyType,
    OUT PCLFS_MGMT_POLICY     Policy,
    OUT PULONG                PolicyLength
    );
#endif /* NTDDI_VERSION || _WIN32_WINNT */

#if (NTDDI_VERSION >= NTDDI_WS03SP1) || (_WIN32_WINNT >= _WIN32_WINNT_WS03)
NTSTATUS
ClfsMgmtRemovePolicy(
    IN PLOG_FILE_OBJECT      LogFile,
    IN CLFS_MGMT_POLICY_TYPE PolicyType
    );
#endif /* NTDDI_VERSION || _WIN32_WINNT */

#if (NTDDI_VERSION >= NTDDI_WS03SP1) || (_WIN32_WINNT >= _WIN32_WINNT_WS03)
NTSTATUS
ClfsMgmtSetLogFileSize(
    IN  PLOG_FILE_OBJECT  LogFile,
    IN  PULONGLONG        NewSizeInContainers,
    OUT PULONGLONG        ResultingSizeInContainers,
    IN  PCLFS_SET_LOG_SIZE_COMPLETE_CALLBACK CompletionRoutine,
    IN  PVOID                                CompletionRoutineData
    );
#endif /* NTDDI_VERSION || _WIN32_WINNT */


#if (NTDDI_VERSION >= NTDDI_LONGHORN) || (_WIN32_WINNT >= _WIN32_WINNT_LONGHORN)
NTSTATUS
ClfsMgmtSetLogFileSizeAsClient(
    IN  PLOG_FILE_OBJECT  LogFile,
    IN  PCLFS_MGMT_CLIENT ClientCookie OPTIONAL,
    IN  PULONGLONG        NewSizeInContainers,
    OUT PULONGLONG        ResultingSizeInContainers,
    IN  PCLFS_SET_LOG_SIZE_COMPLETE_CALLBACK CompletionRoutine,
    IN  PVOID                                CompletionRoutineData
    );
#endif /* NTDDI_VERSION || _WIN32_WINNT */

// end_wdm

#endif // CLFS_KERNEL_MODE

// begin_wdm

#ifdef __cplusplus
} // extern "C"
#endif

// end_wdm

#endif // _CLFSMGMT_H_
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\vs9sp1\sdk\include\ChString.h ===
//***************************************************************************
//
//  Copyright (c) Microsoft Corporation.  All rights reserved.
//
//  CHSTRING.h
//
//  Purpose: Utility library version of MFC CString
//
//***************************************************************************

#if _MSC_VER > 1000
#pragma once
#endif

#ifndef _CHSTRING_H
#define _CHSTRING_H

/////////////////////////////////////////////////////////////////////////////
#include <windows.h>
#include <limits.h>
#include <tchar.h>
#include <polarity.h>
#pragma warning( disable : 4290 ) // Ignore 'C++ Exception Specification ignored'
#include <ProvExce.h>

/////////////////////////////////////////////////////////////////////////////

struct _DOUBLE  { BYTE doubleBits[sizeof(double)]; };

#ifdef FRAMEWORK_ALLOW_DEPRECATED
void POLARITY WINAPI SetCHStringResourceHandle(HINSTANCE handle);
#endif

/////////////////////////////////////////////////////////////////////////////
// CHString formatting
/////////////////////////////////////////////////////////////////////////////
#define TCHAR_ARG   WCHAR
#define WCHAR_ARG   WCHAR
#define CHAR_ARG    char

#if defined(_68K_) || defined(_X86_)
    #define DOUBLE_ARG  _DOUBLE
#else
    #define DOUBLE_ARG  double
#endif

struct CHStringData
{
    long nRefs;
    int nDataLength;
    int nAllocLength;

    WCHAR* data()
    {
        return (WCHAR*)(this+1); 
    }
};

/////////////////////////////////////////////////////////////////////////////
class POLARITY CHString
{
    protected:

        LPWSTR m_pchData;               // pointer to ref counted string data

    protected:

                                        // implementation helpers

        CHStringData* GetData() const;  // returns data pointer
        void Init();
        void AllocCopy(CHString& dest, int nCopyLen, int nCopyIndex, int nExtraLen) const throw ( CHeap_Exception ) ;
        void AllocBuffer(int nLen) throw ( CHeap_Exception ) ;
        void AssignCopy(int nSrcLen, LPCWSTR lpszSrcData) throw ( CHeap_Exception ) ;
        void ConcatCopy(int nSrc1Len, LPCWSTR lpszSrc1Data, int nSrc2Len, LPCWSTR lpszSrc2Data) throw ( CHeap_Exception ) ;
        void ConcatInPlace(int nSrcLen, LPCWSTR lpszSrcData);
        void CopyBeforeWrite() throw ( CHeap_Exception ) ;
        void AllocBeforeWrite(int nLen) throw ( CHeap_Exception ) ;
        static inline int WINAPI SafeStrlen(LPCWSTR lpsz)   { return (lpsz == NULL) ? 0 : (int)wcslen(lpsz); }

        // Helper function used to load resource into lpszBuf buffer.
#ifdef FRAMEWORK_ALLOW_DEPRECATED
        int LoadStringW(UINT nID, __in_ecount(nMaxBuf)  LPWSTR lpszBuf, UINT nMaxBuf) throw ( CHeap_Exception ) ;
#endif

    public:

// Constructors/Destruction

        CHString();
        CHString(const CHString& stringSrc);
        CHString(WCHAR ch, int nRepeat = 1) throw ( CHeap_Exception ) ;
        CHString(LPCSTR lpsz) throw ( CHeap_Exception ) ;
        CHString(LPCWSTR lpsz) throw ( CHeap_Exception ) ;
        CHString(LPCWSTR lpch, int nLength) throw ( CHeap_Exception ) ;
        inline CHString(const unsigned char* lpsz)  { Init(); *this = (LPCSTR)lpsz; }

        ~CHString();

// Functions

        void SetAt(int nIndex, WCHAR ch) throw ( CHeap_Exception ) ;
        void Empty();    

        // inlines

        inline int GetLength() const { return GetData()->nDataLength; }
        inline BOOL IsEmpty() const  { return GetData()->nDataLength == 0; }

#if (!defined DEBUG && !defined _DEBUG)
        inline WCHAR GetAt(int nIndex) const{ return m_pchData[nIndex]; }
        inline WCHAR operator[](int nIndex) const{  return m_pchData[nIndex]; }
#else
        WCHAR GetAt(int nIndex) const;
        WCHAR operator[](int nIndex) const;
#endif
        inline operator LPCWSTR() const     { return m_pchData; }
        inline int GetAllocLength() const       { return GetData()->nAllocLength; }

// overloaded assignment

        const CHString& operator=(const CHString& stringSrc) throw ( CHeap_Exception ) ;
        const CHString& operator=(WCHAR ch) throw ( CHeap_Exception ) ;
        const CHString& operator=(LPCSTR lpsz) throw ( CHeap_Exception ) ;
        const CHString& operator=(LPCWSTR lpsz) throw ( CHeap_Exception ) ;
        inline const CHString& operator=(const unsigned char* lpsz) throw ( CHeap_Exception ) { *this = (LPCSTR)lpsz; return *this; }
        inline const CHString& operator=(CHString *p) throw ( CHeap_Exception ) { *this = *p; return *this; }
        inline const CHString& operator=(char ch) throw ( CHeap_Exception ) { *this = (WCHAR)ch; return *this; }        
        
        inline const CHString& CHString::operator+=(char ch) throw ( CHeap_Exception ) { *this += (WCHAR)ch; return *this; }
        friend inline CHString  operator+(const CHString& string, char ch) throw ( CHeap_Exception ) { return string + (WCHAR)ch; }
        friend inline CHString  operator+(char ch, const CHString& string) throw ( CHeap_Exception ) { return (WCHAR)ch + string; }

        const CHString& operator+=(const CHString& string) throw ( CHeap_Exception ) ;
        const CHString& operator+=(WCHAR ch) throw ( CHeap_Exception ) ;
        const CHString& operator+=(LPCWSTR lpsz) throw ( CHeap_Exception ) ;

        friend CHString POLARITY WINAPI operator+(const CHString& string1,  const CHString& string2) throw ( CHeap_Exception ) ;
        friend CHString POLARITY WINAPI operator+(const CHString& string, WCHAR ch) throw ( CHeap_Exception ) ;
        friend CHString POLARITY WINAPI operator+(WCHAR ch, const CHString& string) throw ( CHeap_Exception ) ;
        friend CHString POLARITY WINAPI operator+(const CHString& string, LPCWSTR lpsz) throw ( CHeap_Exception ) ;
        friend CHString POLARITY WINAPI operator+(LPCWSTR lpsz, const CHString& string) throw ( CHeap_Exception ) ;

// string comparison

        int Compare(LPCWSTR lpsz) const;

        inline int CompareNoCase(LPCWSTR lpsz) const
        {
            // ignore case

            return _wcsicmp(m_pchData, lpsz); 

        }   // MBCS/Unicode aware

        inline int Collate(LPCWSTR lpsz) const
        {  
            // NLS aware
            // CHString::Collate is often slower than Compare but is MBSC/Unicode
            // aware as well as locale-sensitive with respect to sort order.

            return wcscoll(m_pchData, lpsz); 

        }   // locale sensitive

// Load string from resource file.

#ifdef FRAMEWORK_ALLOW_DEPRECATED
        BOOL LoadStringW(UINT nID) throw ( CHeap_Exception ) ;
#endif

// Access to string implementation buffer as "C" character array

        LPWSTR GetBuffer(int nMinBufLength) throw ( CHeap_Exception ) ;
        void ReleaseBuffer(int nNewLength = -1) throw ( CHeap_Exception ) ;
        LPWSTR GetBufferSetLength(int nNewLength) throw ( CHeap_Exception ) ;
        void FreeExtra() throw ( CHeap_Exception ) ;

// Use LockBuffer/UnlockBuffer to turn refcounting off

        LPWSTR LockBuffer() ;
        void UnlockBuffer();

// searching (return starting index, or -1 if not found)
// look for a single character match

        int Find(WCHAR ch) const;               // like "C" strchr
        int FindOneOf(LPCWSTR lpszCharSet) const;
        int ReverseFind(WCHAR ch) const;

// look for a specific sub-string

        int Find(LPCWSTR lpszSub) const;        // like "C" strstr

// upper/lower/reverse conversion

        void MakeUpper() throw ( CHeap_Exception ) ;
        void MakeLower() throw ( CHeap_Exception ) ;
        void MakeReverse() throw ( CHeap_Exception ) ;

// simple sub-string extraction

        CHString Mid(int nFirst, int nCount) const throw ( CHeap_Exception ) ;
        CHString Mid(int nFirst) const throw ( CHeap_Exception ) ;
        CHString Left(int nCount) const throw ( CHeap_Exception ) ;
        CHString Right(int nCount) const throw ( CHeap_Exception ) ;

        CHString SpanIncluding(LPCWSTR lpszCharSet) const throw ( CHeap_Exception ) ;
        CHString SpanExcluding(LPCWSTR lpszCharSet) const throw ( CHeap_Exception ) ;

// trimming whitespace (either side)

        void TrimRight() throw ( CHeap_Exception ) ;
        void TrimLeft() throw ( CHeap_Exception ) ;
    
// printf-like formatting using passed string
        void __cdecl Format(LPCWSTR lpszFormat, ...) throw ( CHeap_Exception ) ;
        void FormatV(LPCWSTR lpszFormat, va_list argList);

// printf-like formatting using referenced string resource
#ifdef FRAMEWORK_ALLOW_DEPRECATED
        void __cdecl Format(UINT nFormatID, ...) throw ( CHeap_Exception ) ;
#endif

// format using FormatMessage API on passed string
        // Warning: if you pass string inserts to this function, they must
        // be LPCSTRs on Win9x and LPCWSTRs on NT.
        void __cdecl FormatMessageW(LPCWSTR lpszFormat, ...) throw ( CHeap_Exception ) ;

// format using FormatMessage API on referenced string resource
        // Warning: if you pass string inserts to this function, they must
        // be LPCSTRs on Win9x and LPCWSTRs on NT.
#ifdef FRAMEWORK_ALLOW_DEPRECATED
        void __cdecl FormatMessageW(UINT nFormatID, ...) throw ( CHeap_Exception ) ;
#endif

#ifndef _NO_BSTR_SUPPORT

        // OLE BSTR support (use for OLE automation)

        BSTR AllocSysString() const throw ( CHeap_Exception ) ;
        static void WINAPI Release(CHStringData* pData);
        void Release();
		
#endif

};

inline BOOL operator==(const CHString& s1, const CHString& s2)  { return s1.Compare(s2) == 0; }
inline BOOL operator==(const CHString& s1, LPCWSTR s2)          { return s1.Compare(s2) == 0; }

inline BOOL operator!=(const CHString& s1, const CHString& s2)  { return s1.Compare(s2) != 0; }
inline BOOL operator!=(const CHString& s1, LPCWSTR s2)          { return s1.Compare(s2) != 0; }

inline BOOL operator<(const CHString& s1, const CHString& s2)   { return s1.Compare(s2) < 0; }
inline BOOL operator<(const CHString& s1, LPCWSTR s2)           { return s1.Compare(s2) < 0; }

inline BOOL operator>(const CHString& s1, const CHString& s2)   { return s1.Compare(s2) > 0; }
inline BOOL operator>(const CHString& s1, LPCWSTR s2)           { return s1.Compare(s2) > 0; }

inline BOOL operator<=(const CHString& s1, const CHString& s2)  { return s1.Compare(s2) <= 0; }
inline BOOL operator<=(const CHString& s1, LPCWSTR s2)          { return s1.Compare(s2) <= 0; }

inline BOOL operator>=(const CHString& s1, const CHString& s2)  { return s1.Compare(s2) >= 0; }
inline BOOL operator>=(const CHString& s1, LPCWSTR s2)          { return s1.Compare(s2) >= 0; }

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\vs9sp1\sdk\include\clfsmgmtw32.h ===
/*=============================================================================

    Copyright (c) 2003  Microsoft Corporation

    Module Name:

        clfsmgmtw32.h

    Abstract:

        Declares the exported API set for the Common Log Win32
        Management API.

    Author:

        JR Tipton [jrtipton] 24-Aug-2003

    Environment:

        User Mode

    Revision History:


=============================================================================*/
#ifndef __CLFSMGMTW32_H__
#define __CLFSMGMTW32_H__


#ifdef CLFS_KERNEL_MODE
#    undef CLFS_KERNEL_MODE
#endif /* CLFS_KERNEL_MODE */

#include <clfsmgmt.h>

#ifdef __cplusplus
extern "C"
{
#endif /* __cplusplus */

#if (_WIN32_WINNT >= _WIN32_WINNT_WS03)
typedef
VOID
(*PLOG_TAIL_ADVANCE_CALLBACK) (
    IN HANDLE           hLogFile,
    IN CLFS_LSN         lsnTarget,
    IN PVOID            pvClientContext
    );
#endif /* _WIN32_WINNT */

#if (_WIN32_WINNT >= _WIN32_WINNT_WS03)
typedef
VOID
(*PLOG_FULL_HANDLER_CALLBACK) (
    IN HANDLE           hLogFile,
    IN DWORD            dwError,
    IN BOOL             fLogIsPinned,
    IN PVOID            pvClientContext
    );
#endif /* _WIN32_WINNT */

#if (_WIN32_WINNT >= _WIN32_WINNT_WS03)
typedef
VOID
(*PLOG_UNPINNED_CALLBACK) (
    IN HANDLE           hLogFile,
    IN PVOID            pvClientContext
    );
#endif /* _WIN32_WINNT */

#if (_WIN32_WINNT >= _WIN32_WINNT_WS03)
typedef struct _LOG_MANAGEMENT_CALLBACKS
{
    PVOID   CallbackContext;

    PLOG_TAIL_ADVANCE_CALLBACK AdvanceTailCallback;
    PLOG_FULL_HANDLER_CALLBACK LogFullHandlerCallback;
    PLOG_UNPINNED_CALLBACK     LogUnpinnedCallback;

} LOG_MANAGEMENT_CALLBACKS, *PLOG_MANAGEMENT_CALLBACKS;
#endif /* _WIN32_WINNT */

#if (_WIN32_WINNT >= _WIN32_WINNT_WS03)
//------------------------------------------------------------------------------
// RegisterManageableLogClient
// 
// Registers a client as one that wishes to participate in the CLFS management
// scheme.  The client can receive notifications such as "advance base lsn" if
// pCallbacks is non-null.
//------------------------------------------------------------------------------
CLFSUSER_API BOOL WINAPI RegisterManageableLogClient (
    IN HANDLE                         hLog,
    IN PLOG_MANAGEMENT_CALLBACKS      pCallbacks
    );
#endif /* _WIN32_WINNT */

#if (_WIN32_WINNT >= _WIN32_WINNT_WS03)
//------------------------------------------------------------------------------
// DeregisterManageableLogClient
// 
// When a log client no longer wishes to be registered, either the log handle
// can be closed (deregistering the client implicitly) or this routine can
// be invoked which will deregister the client explicitly.  The client will
// no longer receive notifications related to management.
//------------------------------------------------------------------------------
CLFSUSER_API BOOL WINAPI DeregisterManageableLogClient (
    IN HANDLE hLog
    );
#endif /* _WIN32_WINNT */

#if (_WIN32_WINNT >= _WIN32_WINNT_WS03)
//------------------------------------------------------------------------------
// ReadLogNotification
// 
// Allows a registered log management client to read a management notification.
// Only possible if the client is not receiving callbacks.  Can function in
// synchronous or asynchronous mode.
//------------------------------------------------------------------------------
CLFSUSER_API BOOL WINAPI ReadLogNotification (
    IN  HANDLE                   hLog,
    OUT PCLFS_MGMT_NOTIFICATION  pNotification,
    IN  LPOVERLAPPED             lpOverlapped
    );
#endif /* _WIN32_WINNT */

#if (_WIN32_WINNT >= _WIN32_WINNT_WS03)
//------------------------------------------------------------------------------
// InstallLogPolicy
// 
// Installs a policy on a log.  The possible policies are described by the 
// enumerated type CLFS_MGMT_POLICY_TYPE.
//------------------------------------------------------------------------------
CLFSUSER_API BOOL WINAPI InstallLogPolicy (
    IN HANDLE            hLog,
    IN PCLFS_MGMT_POLICY pPolicy
    );
#endif /* _WIN32_WINNT */

#if (_WIN32_WINNT >= _WIN32_WINNT_WS03)
//------------------------------------------------------------------------------
// InstallLogPolicy
// 
// Removes a policy from a log, reverting back to the default behavior for the
// policy indicated.  The possible policies are described by the enumerated type 
// CLFS_MGMT_POLICY_TYPE.
//------------------------------------------------------------------------------
CLFSUSER_API BOOL WINAPI RemoveLogPolicy (
    IN HANDLE                hLog,
    IN CLFS_MGMT_POLICY_TYPE ePolicyType
    );
#endif /* _WIN32_WINNT */

#if (_WIN32_WINNT >= _WIN32_WINNT_WS03)
//------------------------------------------------------------------------------
// QueryLogPolicy
// 
// Given a policy type, returns the associated policy data.
//------------------------------------------------------------------------------
CLFSUSER_API BOOL WINAPI QueryLogPolicy (
    IN     HANDLE                hLog,
    IN     CLFS_MGMT_POLICY_TYPE ePolicyType,
    OUT    PCLFS_MGMT_POLICY     pPolicyBuffer,
    IN OUT PULONG                pcbPolicyBuffer
    );
#endif /* _WIN32_WINNT */

#if (_WIN32_WINNT >= _WIN32_WINNT_WS03)
//------------------------------------------------------------------------------
// SetLogFileSizeWithPolicy
// 
// Sets the size of a log file, obeying any policies present on the log file
// at the time.
//------------------------------------------------------------------------------
CLFSUSER_API BOOL WINAPI SetLogFileSizeWithPolicy(
    IN  HANDLE     hLog,
    IN  PULONGLONG pDesiredSize,
    OUT PULONGLONG pResultingSize
    );
#endif /* _WIN32_WINNT */

#if (_WIN32_WINNT >= _WIN32_WINNT_WS03)
//------------------------------------------------------------------------------
// HandleLogFull
// 
// Handles a log full condition according to policy (either by growing the log
// or demanding that other streams advance their log bases).
//
// This routine may do the work asynchronously (returning FALSE with last error
// of ERROR_IO_PENDING).
//------------------------------------------------------------------------------
CLFSUSER_API BOOL WINAPI HandleLogFull(
    IN HANDLE hLog
    );
#endif /* _WIN32_WINNT */

#if (_WIN32_WINNT >= _WIN32_WINNT_WS03)
//------------------------------------------------------------------------------
// LogTailAdvanceFailure
// 
// Allows a log client to indicate that it cannot comply with a request from
// log management to advance its tail.
//------------------------------------------------------------------------------
CLFSUSER_API BOOL WINAPI LogTailAdvanceFailure(
    IN HANDLE hLog,
    IN DWORD  dwReason
    );
#endif /* _WIN32_WINNT */

#endif /* __CLFSMGMTW32_H__ */

#ifdef __cplusplus
} // extern "C"
#endif /* __cplusplus */

//-----------------------------------------------------------------------------
//                                        END OF FILE
//-----------------------------------------------------------------------------
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\vs9sp1\sdk\include\ClusApi.h ===
/*++

Copyright (c) Microsoft Corporation.  All rights reserved.

Module Name:

    clusapi.h

Abstract:

    This module defines the common management and application interface to
    the Microsoft Cluster Server services.

Revision History:

--*/

#ifndef _CLUSTER_API_
#define _CLUSTER_API_

#define CLUSAPI_VERSION 0x0600

#if _MSC_VER > 1000
#pragma once
#endif

#ifdef __cplusplus
extern "C" {
#endif

#if ( !MIDL_PASS && !__midl )
#if _MSC_VER >= 1200
#pragma warning(push)
#endif
#pragma warning( disable : 4200 ) // nonstandard extension used : zero-sized array in struct/union
#pragma warning( disable : 4201 ) // nonstandard extension used : nameless struct/union
#endif // MIDL_PASS

//
// General cluster definitions
//

#ifndef _CLUSTER_API_TYPES_
//
// Defined cluster handle types.
//
typedef struct _HCLUSTER *HCLUSTER;
typedef struct _HNODE *HNODE;
typedef struct _HRESOURCE *HRESOURCE;
typedef struct _HGROUP *HGROUP;
typedef struct _HNETWORK *HNETWORK;
typedef struct _HNETINTERFACE *HNETINTERFACE;
typedef struct _HCHANGE *HCHANGE;
typedef struct _HCLUSENUM *HCLUSENUM;
typedef struct _HGROUPENUM *HGROUPENUM;
typedef struct _HRESENUM *HRESENUM;
typedef struct _HNETWORKENUM *HNETWORKENUM;
typedef struct _HNODEENUM *HNODEENUM;
typedef struct _HRESTYPEENUM *HRESTYPEENUM;
typedef struct _HREGBATCH *HREGBATCH;

#endif // _CLUSTER_API_TYPES_

//
// Definitions used in cluster management routines.
//

#define MAX_CLUSTERNAME_LENGTH      DNS_MAX_LABEL_LENGTH

#ifndef _CLUSTER_API_TYPES_
//
// Cluster-related structures and types
//
typedef enum CLUSTER_QUORUM_TYPE {
    OperationalQuorum,
    ModifyQuorum
} CLUSTER_QUORUM_TYPE;

#if ( !MIDL_PASS && !__midl )

typedef struct CLUSTERVERSIONINFO_NT4 {
    DWORD dwVersionInfoSize;
    WORD  MajorVersion;
    WORD  MinorVersion;
    WORD  BuildNumber;
    WCHAR szVendorId[64];
    WCHAR szCSDVersion[64];
}CLUSTERVERSIONINFO_NT4, *PCLUSTERVERSIONINFO_NT4;

typedef struct CLUSTERVERSIONINFO {
    DWORD dwVersionInfoSize;
    WORD  MajorVersion;
    WORD  MinorVersion;
    WORD  BuildNumber;
    WCHAR szVendorId[64];
    WCHAR szCSDVersion[64];
    DWORD dwClusterHighestVersion;
    DWORD dwClusterLowestVersion;
    DWORD dwFlags;
    DWORD dwReserved;
} CLUSTERVERSIONINFO, *LPCLUSTERVERSIONINFO, *PCLUSTERVERSIONINFO;


typedef struct CLUS_STARTING_PARAMS {
    DWORD   dwSize;
    BOOL    bForm;
    BOOL    bFirst;
} CLUS_STARTING_PARAMS, * PCLUS_STARTING_PARAMS;




#define     CLUSTER_VERSION_FLAG_MIXED_MODE     0x00000001

#define NT4_MAJOR_VERSION           1
#define NT4SP4_MAJOR_VERSION        2
#define NT5_MAJOR_VERSION           3
#define NT51_MAJOR_VERSION          4
#define LONGHORN_MAJOR_VERSION      5

#define CLUSTER_VERSION_UNKNOWN         0xFFFFFFFF


//
// Version number macros
//

#define CLUSTER_MAKE_VERSION( _maj, _min ) ((( _maj ) << 16 ) | ( _min ))
#define CLUSTER_GET_MAJOR_VERSION( _ver ) (( _ver ) >> 16 )
#define CLUSTER_GET_MINOR_VERSION( _ver ) (( _ver ) & 0xFFFF )

#endif // MIDL_PASS

//
// Interfaces for the cluster state on a node
//
#define CLUSTER_INSTALLED   0x00000001
#define CLUSTER_CONFIGURED  0x00000002
#define CLUSTER_RUNNING     0x00000010

typedef enum NODE_CLUSTER_STATE {
    ClusterStateNotInstalled                = 0x00000000,
    ClusterStateNotConfigured               = CLUSTER_INSTALLED,
    ClusterStateNotRunning                  = CLUSTER_INSTALLED | CLUSTER_CONFIGURED,
    ClusterStateRunning                     = CLUSTER_INSTALLED | CLUSTER_CONFIGURED | CLUSTER_RUNNING
} NODE_CLUSTER_STATE;

// Quorum mode flags for SetClusterQuorumResource API

#define CLUS_HYBRID_QUORUM          1024                // 0xFFFFFFFF
#define CLUS_NODE_MAJORITY_QUORUM   0                   // 0xFFFFFFFE
#define CLUS_LEGACY_QUORUM          (4 * 1024 * 1024)   // 0xFFFFFFFD

//
//  Resource state change reason related types and defines
//
#define CLUSCTL_RESOURCE_STATE_CHANGE_REASON_VERSION_1  1

typedef enum CLUSTER_RESOURCE_STATE_CHANGE_REASON {
    eResourceStateChangeReasonUnknown,
    eResourceStateChangeReasonMove,
    eResourceStateChangeReasonFailover,
    eResourceStateChangeReasonFailedMove,
    eResourceStateChangeReasonShutdown,
    eResourceStateChangeReasonRundown
} CLUSTER_RESOURCE_STATE_CHANGE_REASON;

typedef enum _CLUSTER_REG_COMMAND
{
    CLUSREG_COMMAND_NONE = 0,

    CLUSREG_SET_VALUE = 1,
    CLUSREG_CREATE_KEY,
    CLUSREG_DELETE_KEY,
    CLUSREG_DELETE_VALUE,
    CLUSREG_SET_KEY_SECURITY,

    CLUSREG_LAST_COMMAND

} CLUSTER_REG_COMMAND;


#if ( !MIDL_PASS && !__midl )

typedef struct _CLUSCTL_RESOURCE_STATE_CHANGE_REASON_STRUCT {
    DWORD                                   dwSize;
    DWORD                                   dwVersion;
    CLUSTER_RESOURCE_STATE_CHANGE_REASON    eReason;
} CLUSCTL_RESOURCE_STATE_CHANGE_REASON_STRUCT, *PCLUSCTL_RESOURCE_STATE_CHANGE_REASON_STRUCT;


#endif // MIDL_PASS

#endif // _CLUSTER_API_TYPES_


//
// Interfaces for managing clusters
//

//
// Cluster API Specific Access Rights
//
#define CLUSAPI_READ_ACCESS     0x00000001L
#define CLUSAPI_CHANGE_ACCESS   0x00000002L
#define CLUSAPI_NO_ACCESS       0x00000004L
#define CLUSAPI_ALL_ACCESS (CLUSAPI_READ_ACCESS | CLUSAPI_CHANGE_ACCESS)

//
// Return values for CLUSCTL_CLUSTER_CHECK_VOTER_DOWN and CLUSCTL_CLUSTER_CHECK_VOTER_EVICT
//
typedef enum CLUSTER_QUORUM_VALUE {
    CLUSTER_QUORUM_MAINTAINED = 0,
    CLUSTER_QUORUM_LOST = 1,
} CLUSTER_QUORUM_VALUE;

#if ( !MIDL_PASS && !__midl )

//
// Structure used to return the status of a request to set the
// password on the account used by the Cluster Service on each
// cluster node.
//
typedef struct CLUSTER_SET_PASSWORD_STATUS {
    DWORD    NodeId;
    BOOLEAN  SetAttempted;
    DWORD    ReturnStatus;
} CLUSTER_SET_PASSWORD_STATUS, *PCLUSTER_SET_PASSWORD_STATUS;

#ifndef _CLUSTER_API_TYPES_
typedef struct _CLUSTER_IP_ENTRY
{
    PCWSTR          lpszIpAddress;
    DWORD           dwPrefixLength;
} CLUSTER_IP_ENTRY, *PCLUSTER_IP_ENTRY;

typedef struct _CREATE_CLUSTER_CONFIG
{
    DWORD             dwVersion;          
    PCWSTR            lpszClusterName;    
    DWORD             cNodes;           
    PCWSTR *          ppszNodeNames;   
    DWORD             cIpEntries;       
    PCLUSTER_IP_ENTRY pIpEntries;
    PCWSTR            lpszQuorumVolume;
} CREATE_CLUSTER_CONFIG, *PCREATE_CLUSTER_CONFIG;
#endif // _CLUSTER_API_TYPES_

DWORD
WINAPI
GetNodeClusterState(
    __in_opt    LPCWSTR lpszNodeName,
    __out       LPDWORD pdwClusterState
    );

typedef DWORD
(WINAPI * PCLUSAPI_GET_NODE_CLUSTER_STATE)(
    __in_opt    LPCWSTR lpszNodeName,
    __out       LPDWORD pdwClusterState
    );

HCLUSTER
WINAPI
OpenCluster(
    __in_opt LPCWSTR lpszClusterName
    );

typedef HCLUSTER
(WINAPI * PCLUSAPI_OPEN_CLUSTER)(
    __in_opt LPCWSTR lpszClusterName
    );

BOOL
WINAPI
CloseCluster(
    __in HCLUSTER hCluster
    );

typedef BOOL
(WINAPI * PCLUSAPI_CLOSE_CLUSTER)(
    __in HCLUSTER hCluster
    );

DWORD
WINAPI
SetClusterName(
    __in HCLUSTER hCluster,
    __in LPCWSTR lpszNewClusterName
    );

typedef DWORD
(WINAPI * PCLUSAPI_SetClusterName)(
    __in HCLUSTER hCluster,
    __in LPCWSTR lpszNewClusterName
    );

__success(return == ERROR_SUCCESS)
DWORD
WINAPI
GetClusterInformation(
    __in HCLUSTER hCluster,
    __out_ecount_part(*lpcchClusterName, *lpcchClusterName + 1) LPWSTR lpszClusterName,
    __inout LPDWORD lpcchClusterName,
    __out_opt LPCLUSTERVERSIONINFO lpClusterInfo
    );

typedef DWORD
(WINAPI * PCLUSAPI_GET_CLUSTER_INFORMATION)(
    __in HCLUSTER hCluster,
    __out_ecount_part(*lpcchClusterName, *lpcchClusterName + 1) LPWSTR lpszClusterName,
    __inout LPDWORD lpcchClusterName,
    __out_opt LPCLUSTERVERSIONINFO lpClusterInfo
    );

__success(return == ERROR_SUCCESS)
DWORD
WINAPI
GetClusterQuorumResource(
    __in HCLUSTER hCluster,
    __out_ecount_part(*lpcchResourceName, *lpcchResourceName + 1) LPWSTR lpszResourceName,
    __inout LPDWORD lpcchResourceName,
    __out_ecount_part(*lpcchDeviceName, *lpcchDeviceName + 1) LPWSTR lpszDeviceName,
    __inout LPDWORD lpcchDeviceName,
    __out LPDWORD lpdwMaxQuorumLogSize
    );

typedef DWORD
(WINAPI * PCLUSAPI_GET_CLUSTER_QUORUM_RESOURCE)(
    __in HCLUSTER hCluster,
    __out_ecount_part(*lpcchResourceName, *lpcchResourceName + 1) LPWSTR lpszResourceName,
    __inout LPDWORD lpcchResourceName,
    __out_ecount_part(*lpcchDeviceName, *lpcchDeviceName + 1) LPWSTR lpszDeviceName,
    __inout LPDWORD lpcchDeviceName,
    __out LPDWORD lpdwMaxQuorumLogSize
    );

DWORD
WINAPI
SetClusterQuorumResource(
    __in     HRESOURCE hResource,
    __in_opt LPCWSTR   lpszDeviceName,
    __in     DWORD     dwMaxQuoLogSize
    );

typedef DWORD
(WINAPI * PCLUSAPI_SET_CLUSTER_QUORUM_RESOURCE)(
    __in     HRESOURCE hResource,
    __in_opt LPCWSTR   lpszDeviceName,
    __in     DWORD     dwMaxQuoLogSize
    );

DWORD
WINAPI
BackupClusterDatabase(
    __in HCLUSTER hCluster,
    __in LPCWSTR  lpszPathName
    );

typedef DWORD
(WINAPI * PCLUSAPI_BACKUP_CLUSTER_DATABASE)(
    __in HCLUSTER hCluster,
    __in LPCWSTR  lpszPathName
    );

DWORD
WINAPI
RestoreClusterDatabase(
    __in LPCWSTR  lpszPathName,
    __in BOOL     bForce,
    __in_opt LPCWSTR  lpszQuorumDriveLetter
    );

typedef DWORD
(WINAPI * PCLUSAPI_RESTORE_CLUSTER_DATABASE)(
    __in LPCWSTR  lpszPathName,
    __in BOOL     bForce,
    __in_opt LPCWSTR  lpszQuorumDriveLetter
    );

DWORD
WINAPI
SetClusterNetworkPriorityOrder(
    __in HCLUSTER hCluster,
    __in DWORD NetworkCount,
    __in_ecount( NetworkCount ) HNETWORK NetworkList[]
    );

typedef DWORD
(WINAPI * PCLUSAPI_SET_CLUSTER_NETWORK_PRIORITY_ORDER)(
    __in HCLUSTER hCluster,
    __in DWORD NetworkCount,
    __in_ecount( NetworkCount ) HNETWORK NetworkList[]
    );

DWORD
WINAPI
SetClusterServiceAccountPassword(
    __in LPCWSTR lpszClusterName,
    __in LPCWSTR lpszNewPassword,
    __in DWORD dwFlags,
    __out_bcount_part_opt(*lpcbReturnStatusBufferSize, *lpcbReturnStatusBufferSize) PCLUSTER_SET_PASSWORD_STATUS lpReturnStatusBuffer,
    __inout LPDWORD lpcbReturnStatusBufferSize
    );

typedef DWORD
(WINAPI * PCLUSAPI_SET_CLUSTER_SERVICE_ACCOUNT_PASSWORD)(
    __in LPCWSTR lpszClusterName,
    __in LPCWSTR lpszNewPassword,
    __in DWORD dwFlags,
    __out_bcount_part_opt(*lpcbReturnStatusBufferSize, *lpcbReturnStatusBufferSize) PCLUSTER_SET_PASSWORD_STATUS lpReturnStatusBuffer,
    __inout LPDWORD lpcbReturnStatusBufferSize
    );

DWORD
WINAPI
ClusterControl(
    __in HCLUSTER hCluster,
    __in_opt HNODE hHostNode,
    __in DWORD dwControlCode,
    __in_bcount_opt(nInBufferSize) LPVOID lpInBuffer,
    __in DWORD nInBufferSize,
    __out_bcount_part_opt(nOutBufferSize, *lpBytesReturned) LPVOID lpOutBuffer,
    __in DWORD nOutBufferSize,
    __out_opt LPDWORD lpBytesReturned
    );

typedef DWORD
(WINAPI * PCLUSAPI_CLUSTER_CONTROL)(
    __in HCLUSTER hCluster,
    __in_opt HNODE hHostNode,
    __in DWORD dwControlCode,
    __in_bcount_opt(nInBufferSize) LPVOID lpInBuffer,
    __in DWORD nInBufferSize,
    __out_bcount_part_opt(nOutBufferSize, *lpBytesReturned) LPVOID lpOutBuffer,
    __in DWORD nOutBufferSize,
    __out_opt LPDWORD lpBytesReturned
    );

#endif // MIDL_PASS

//
// Cluster Event Notification API
//

#ifndef _CLUSTER_API_TYPES_
//
// Cluster event filter flags.
//
typedef enum CLUSTER_CHANGE {
    CLUSTER_CHANGE_NODE_STATE               = 0x00000001,
    CLUSTER_CHANGE_NODE_DELETED             = 0x00000002,
    CLUSTER_CHANGE_NODE_ADDED               = 0x00000004,
    CLUSTER_CHANGE_NODE_PROPERTY            = 0x00000008,

    CLUSTER_CHANGE_REGISTRY_NAME            = 0x00000010,
    CLUSTER_CHANGE_REGISTRY_ATTRIBUTES      = 0x00000020,
    CLUSTER_CHANGE_REGISTRY_VALUE           = 0x00000040,
    CLUSTER_CHANGE_REGISTRY_SUBTREE         = 0x00000080,

    CLUSTER_CHANGE_RESOURCE_STATE           = 0x00000100,
    CLUSTER_CHANGE_RESOURCE_DELETED         = 0x00000200,
    CLUSTER_CHANGE_RESOURCE_ADDED           = 0x00000400,
    CLUSTER_CHANGE_RESOURCE_PROPERTY        = 0x00000800,

    CLUSTER_CHANGE_GROUP_STATE              = 0x00001000,
    CLUSTER_CHANGE_GROUP_DELETED            = 0x00002000,
    CLUSTER_CHANGE_GROUP_ADDED              = 0x00004000,
    CLUSTER_CHANGE_GROUP_PROPERTY           = 0x00008000,

    CLUSTER_CHANGE_RESOURCE_TYPE_DELETED    = 0x00010000,
    CLUSTER_CHANGE_RESOURCE_TYPE_ADDED      = 0x00020000,
    CLUSTER_CHANGE_RESOURCE_TYPE_PROPERTY   = 0x00040000,

    CLUSTER_CHANGE_CLUSTER_RECONNECT        = 0x00080000,

    CLUSTER_CHANGE_NETWORK_STATE            = 0x00100000,
    CLUSTER_CHANGE_NETWORK_DELETED          = 0x00200000,
    CLUSTER_CHANGE_NETWORK_ADDED            = 0x00400000,
    CLUSTER_CHANGE_NETWORK_PROPERTY         = 0x00800000,

    CLUSTER_CHANGE_NETINTERFACE_STATE       = 0x01000000,
    CLUSTER_CHANGE_NETINTERFACE_DELETED     = 0x02000000,
    CLUSTER_CHANGE_NETINTERFACE_ADDED       = 0x04000000,
    CLUSTER_CHANGE_NETINTERFACE_PROPERTY    = 0x08000000,

    CLUSTER_CHANGE_QUORUM_STATE             = 0x10000000,
    CLUSTER_CHANGE_CLUSTER_STATE            = 0x20000000,
    CLUSTER_CHANGE_CLUSTER_PROPERTY         = 0x40000000,


    CLUSTER_CHANGE_HANDLE_CLOSE             = 0x80000000,

    CLUSTER_CHANGE_ALL                      = (CLUSTER_CHANGE_NODE_STATE                |
                                               CLUSTER_CHANGE_NODE_DELETED              |
                                               CLUSTER_CHANGE_NODE_ADDED                |
                                               CLUSTER_CHANGE_NODE_PROPERTY             |
                                               CLUSTER_CHANGE_REGISTRY_NAME             |
                                               CLUSTER_CHANGE_REGISTRY_ATTRIBUTES       |
                                               CLUSTER_CHANGE_REGISTRY_VALUE            |
                                               CLUSTER_CHANGE_REGISTRY_SUBTREE          |
                                               CLUSTER_CHANGE_RESOURCE_STATE            |
                                               CLUSTER_CHANGE_RESOURCE_DELETED          |
                                               CLUSTER_CHANGE_RESOURCE_ADDED            |
                                               CLUSTER_CHANGE_RESOURCE_PROPERTY         |
                                               CLUSTER_CHANGE_GROUP_STATE               |
                                               CLUSTER_CHANGE_GROUP_DELETED             |
                                               CLUSTER_CHANGE_GROUP_ADDED               |
                                               CLUSTER_CHANGE_GROUP_PROPERTY            |
                                               CLUSTER_CHANGE_RESOURCE_TYPE_DELETED     |
                                               CLUSTER_CHANGE_RESOURCE_TYPE_ADDED       |
                                               CLUSTER_CHANGE_RESOURCE_TYPE_PROPERTY    |
                                               CLUSTER_CHANGE_NETWORK_STATE             |
                                               CLUSTER_CHANGE_NETWORK_DELETED           |
                                               CLUSTER_CHANGE_NETWORK_ADDED             |
                                               CLUSTER_CHANGE_NETWORK_PROPERTY          |
                                               CLUSTER_CHANGE_NETINTERFACE_STATE        |
                                               CLUSTER_CHANGE_NETINTERFACE_DELETED      |
                                               CLUSTER_CHANGE_NETINTERFACE_ADDED        |
                                               CLUSTER_CHANGE_NETINTERFACE_PROPERTY     |
                                               CLUSTER_CHANGE_QUORUM_STATE              |
                                               CLUSTER_CHANGE_CLUSTER_STATE             |
                                               CLUSTER_CHANGE_CLUSTER_PROPERTY          |
                                               CLUSTER_CHANGE_CLUSTER_RECONNECT         |
                                               CLUSTER_CHANGE_HANDLE_CLOSE)

} CLUSTER_CHANGE;

#endif // _CLUSTER_API_TYPES_

#if ( !MIDL_PASS && !__midl )
HCHANGE
WINAPI
CreateClusterNotifyPort(
    __in HCHANGE hChange,
    __in HCLUSTER hCluster,
    __in DWORD dwFilter,
    __in DWORD_PTR dwNotifyKey
    );

typedef HCHANGE
(WINAPI * PCLUSAPI_CREATE_CLUSTER_NOTIFY_PORT)(
    __in HCHANGE hChange,
    __in HCLUSTER hCluster,
    __in DWORD dwFilter,
    __in DWORD_PTR dwNotifyKey
    );

DWORD
WINAPI
RegisterClusterNotify(
    __in HCHANGE hChange,
    __in DWORD dwFilterType,
    __in HANDLE hObject,
    __in DWORD_PTR dwNotifyKey
    );

typedef DWORD
(WINAPI * PCLUSAPI_REGISTER_CLUSTER_NOTIFY)(
    __in HCHANGE hChange,
    __in DWORD dwFilterType,
    __in HANDLE hObject,
    __in DWORD_PTR dwNotifyKey
    );

__success(return == ERROR_SUCCESS)
DWORD
WINAPI
GetClusterNotify(
    __in HCHANGE hChange,
    __out DWORD_PTR *lpdwNotifyKey,
    __out LPDWORD lpdwFilterType,
    __out_ecount(*lpcchName) LPWSTR lpszName,
    __inout LPDWORD lpcchName,
    __in DWORD dwMilliseconds
    );

typedef DWORD
(WINAPI * PCLUSAPI_GET_CLUSTER_NOTIFY)(
    __in HCHANGE hChange,
    __out DWORD_PTR *lpdwNotifyKey,
    __out LPDWORD lpdwFilterType,
    __out_ecount_part_opt(*lpcchName, *lpcchName + 1) LPWSTR lpszName,
    __inout LPDWORD lpcchName,
    __in DWORD dwMilliseconds
    );

BOOL
WINAPI
CloseClusterNotifyPort(
    __in HCHANGE hChange
    );

typedef BOOL
(WINAPI * PCLUSAPI_CLOSE_CLUSTER_NOTIFY_PORT)(
    __in HCHANGE hChange
    );

#endif // MIDL_PASS

//
// Enumeration routines
//

#ifndef _CLUSTER_API_TYPES_
//
// Define enumerable types
//
typedef enum CLUSTER_ENUM {
    CLUSTER_ENUM_NODE               = 0x00000001,
    CLUSTER_ENUM_RESTYPE            = 0x00000002,
    CLUSTER_ENUM_RESOURCE           = 0x00000004,
    CLUSTER_ENUM_GROUP              = 0x00000008,
    CLUSTER_ENUM_NETWORK            = 0x00000010,
    CLUSTER_ENUM_NETINTERFACE       = 0x00000020,
    CLUSTER_ENUM_INTERNAL_NETWORK   = 0x80000000,

    CLUSTER_ENUM_ALL                = (CLUSTER_ENUM_NODE      |
                                       CLUSTER_ENUM_RESTYPE   |
                                       CLUSTER_ENUM_RESOURCE  |
                                       CLUSTER_ENUM_GROUP     |
                                       CLUSTER_ENUM_NETWORK   |
                                       CLUSTER_ENUM_NETINTERFACE)

} CLUSTER_ENUM;

#endif // _CLUSTER_API_TYPES_

#if ( !MIDL_PASS && !__midl )
HCLUSENUM
WINAPI
ClusterOpenEnum(
    __in HCLUSTER hCluster,
    __in DWORD dwType
    );

typedef HCLUSENUM
(WINAPI * PCLUSAPI_CLUSTER_OPEN_ENUM)(
    __in HCLUSTER hCluster,
    __in DWORD dwType
    );

DWORD
WINAPI
ClusterGetEnumCount(
    __in HCLUSENUM hEnum
    );

typedef DWORD
(WINAPI * PCLUSAPI_CLUSTER_GET_ENUM_COUNT)(
    __in HCLUSENUM hEnum
    );

__success(return == ERROR_SUCCESS)
DWORD
WINAPI
ClusterEnum(
    __in HCLUSENUM hEnum,
    __in DWORD dwIndex,
    __out LPDWORD lpdwType,
    __out_ecount_part(*lpcchName, *lpcchName + 1) LPWSTR lpszName,
    __inout LPDWORD lpcchName
    );

typedef DWORD
(WINAPI * PCLUSAPI_CLUSTER_ENUM)(
    __in HCLUSENUM hEnum,
    __in DWORD dwIndex,
    __out LPDWORD lpdwType,
    __out_ecount_part(*lpcchName, *lpcchName + 1) LPWSTR lpszName,
    __inout LPDWORD lpcchName
    );

DWORD
WINAPI
ClusterCloseEnum(
    __in HCLUSENUM hEnum
    );

typedef DWORD
(WINAPI * PCLUSAPI_CLUSTER_CLOSE_ENUM)(
    __in HCLUSENUM hEnum
    );

#endif // MIDL_PASS


#ifndef _CLUSTER_API_TYPES_
//
// Define enumerable node types
//
typedef enum CLUSTER_NODE_ENUM {
    CLUSTER_NODE_ENUM_NETINTERFACES = 0x00000001,

    CLUSTER_NODE_ENUM_ALL           = (CLUSTER_NODE_ENUM_NETINTERFACES)

} CLUSTER_NODE_ENUM;

//
// Node-related structures and types.
//
typedef enum CLUSTER_NODE_STATE {
    ClusterNodeStateUnknown = -1,
    ClusterNodeUp,
    ClusterNodeDown,
    ClusterNodePaused,
    ClusterNodeJoining
} CLUSTER_NODE_STATE;

#endif // _CLUSTER_API_TYPES_

//
// Interfaces for managing the nodes of a cluster.
//

#if ( !MIDL_PASS && !__midl )
HNODE
WINAPI
OpenClusterNode(
    __in HCLUSTER hCluster,
    __in LPCWSTR lpszNodeName
    );

typedef HNODE
(WINAPI * PCLUSAPI_OPEN_CLUSTER_NODE)(
    __in HCLUSTER hCluster,
    __in LPCWSTR lpszNodeName
    );

BOOL
WINAPI
CloseClusterNode(
    __in HNODE hNode
    );

typedef BOOL
(WINAPI * PCLUSAPI_CLOSE_CLUSTER_NODE)(
    __in HNODE hNode
    );

CLUSTER_NODE_STATE
WINAPI
GetClusterNodeState(
    __in HNODE hNode
    );

typedef CLUSTER_NODE_STATE
(WINAPI * PCLUSAPI_GET_CLUSTER_NODE_STATE)(
    __in HNODE hNode
    );

__success(return == ERROR_SUCCESS)
DWORD
WINAPI
GetClusterNodeId(
    __in HNODE hNode,
    __out_ecount_part(*lpcchName, *lpcchName + 1) LPWSTR lpszNodeId,
    __inout LPDWORD lpcchName
    );

typedef DWORD
(WINAPI * PCLUSAPI_GET_CLUSTER_NODE_ID)(
    __in HNODE hNode,
    __out_ecount_part(*lpcchName, *lpcchName + 1) LPWSTR lpszNodeId,
    __inout LPDWORD lpcchName
    );

#define GetCurrentClusterNodeId(_lpszNodeId_, _lpcchName_) \
    GetClusterNodeId(NULL, (_lpszNodeId_), (_lpcchName_))

HCLUSTER
WINAPI
GetClusterFromNode(
    __in HNODE hNode
    );

typedef HCLUSTER
(WINAPI * PCLUSAPI_GET_CLUSTER_FROM_NODE)(
    __in HNODE hNode
    );

DWORD
WINAPI
PauseClusterNode(
    __in HNODE hNode
    );

typedef DWORD
(WINAPI * PCLUSAPI_PAUSE_CLUSTER_NODE)(
    __in HNODE hNode
    );

DWORD
WINAPI
ResumeClusterNode(
    __in HNODE hNode
    );

typedef DWORD
(WINAPI * PCLUSAPI_RESUME_CLUSTER_NODE)(
    __in HNODE hNode
    );

DWORD
WINAPI
EvictClusterNode(
    __in HNODE hNode
    );

typedef DWORD
(WINAPI * PCLUSAPI_EVICT_CLUSTER_NODE)(
    __in HNODE hNode
    );

HNODEENUM
WINAPI
ClusterNodeOpenEnum(
    __in HNODE hNode,
    __in DWORD dwType
    );

typedef HNODEENUM
(WINAPI * PCLUSAPI_CLUSTER_NODE_OPEN_ENUM)(
    __in HNODE hNode,
    __in DWORD dwType
    );

DWORD
WINAPI
ClusterNodeGetEnumCount(
    __in HNODEENUM hNodeEnum
    );

typedef DWORD
(WINAPI * PCLUSAPI_CLUSTER_NODE_GET_ENUM_COUNT)(
    __in HNODEENUM hNodeEnum
    );

DWORD
WINAPI
ClusterNodeCloseEnum(
    __in HNODEENUM hNodeEnum
    );

typedef DWORD
(WINAPI * PCLUSAPI_CLUSTER_NODE_CLOSE_ENUM)(
    __in HNODEENUM hNodeEnum
    );

__success(return == ERROR_SUCCESS)
DWORD
WINAPI
ClusterNodeEnum(
    __in HNODEENUM hNodeEnum,
    __in DWORD dwIndex,
    __out LPDWORD lpdwType,
    __out_ecount_part(*lpcchName, *lpcchName + 1) LPWSTR lpszName,
    __inout LPDWORD lpcchName
    );

typedef DWORD
(WINAPI * PCLUSAPI_CLUSTER_NODE_ENUM)(
    __in HNODEENUM hNodeEnum,
    __in DWORD dwIndex,
    __out LPDWORD lpdwType,
    __out_ecount_part(*lpcchName, *lpcchName + 1) LPWSTR lpszName,
    __inout LPDWORD lpcchName
    );

DWORD
WINAPI
EvictClusterNodeEx(
    __in HNODE hNode,
    __in DWORD dwTimeOut,
    __out HRESULT * phrCleanupStatus
    );

typedef DWORD
(WINAPI * PCLUSAPI_EVICT_CLUSTER_NODE_EX)(
    __in HNODE hNode,
    __in DWORD dwTimeOut,
    __out HRESULT * phrCleanupStatus
    );

#endif // MIDL_PASS


//
// Interfaces for managing the resource types in a cluster
//

#if ( !MIDL_PASS && !__midl )
HKEY
WINAPI
GetClusterResourceTypeKey(
    __in HCLUSTER hCluster,
    __in LPCWSTR lpszTypeName,
    __in REGSAM samDesired
    );

typedef HKEY
(WINAPI * PCLUSAPI_GET_CLUSTER_RESOURCE_TYPE_KEY)(
    __in HCLUSTER hCluster,
    __in LPCWSTR lpszTypeName,
    __in REGSAM samDesired
    );

#endif // MIDL_PASS

#ifndef _CLUSTER_API_TYPES_
//
// Define enumerable group types
//
typedef enum CLUSTER_GROUP_ENUM {
    CLUSTER_GROUP_ENUM_CONTAINS     = 0x00000001,
    CLUSTER_GROUP_ENUM_NODES        = 0x00000002,

    CLUSTER_GROUP_ENUM_ALL          = (CLUSTER_GROUP_ENUM_CONTAINS |
                                       CLUSTER_GROUP_ENUM_NODES)
} CLUSTER_GROUP_ENUM;

//
// Interfaces for managing the failover groups in a cluster.
//
typedef enum CLUSTER_GROUP_STATE {
    ClusterGroupStateUnknown = -1,
    ClusterGroupOnline,
    ClusterGroupOffline,
    ClusterGroupFailed,
    ClusterGroupPartialOnline,
    ClusterGroupPending
} CLUSTER_GROUP_STATE;

typedef enum CLUSTER_GROUP_AUTOFAILBACK_TYPE
{
    ClusterGroupPreventFailback = 0,
    ClusterGroupAllowFailback,
    ClusterGroupFailbackTypeCount
} CLUSTER_GROUP_AUTOFAILBACK_TYPE, CGAFT;

#endif // _CLUSTER_API_TYPES_

#if ( !MIDL_PASS && !__midl )
HGROUP
WINAPI
CreateClusterGroup(
    __in HCLUSTER hCluster,
    __in LPCWSTR lpszGroupName
    );

typedef HGROUP
(WINAPI * PCLUSAPI_CREATE_CLUSTER_GROUP)(
    __in HCLUSTER hCluster,
    __in LPCWSTR lpszGroupName
    );

HGROUP
WINAPI
OpenClusterGroup(
    __in HCLUSTER hCluster,
    __in LPCWSTR lpszGroupName
    );

typedef HGROUP
(WINAPI * PCLUSAPI_OPEN_CLUSTER_GROUP)(
    __in HCLUSTER hCluster,
    __in LPCWSTR lpszGroupName
    );

BOOL
WINAPI
CloseClusterGroup(
    __in HGROUP hGroup
    );

typedef BOOL
(WINAPI * PCLUSAPI_CLOSE_CLUSTER_GROUP)(
    __in HGROUP hGroup
    );

HCLUSTER
WINAPI
GetClusterFromGroup(
    __in HGROUP hGroup
    );

typedef HCLUSTER
(WINAPI * PCLUSAPI_GET_CLUSTER_FROM_GROUP)(
    __in HGROUP hGroup
    );

__success(return >= 0) //!= ClusterGroupStateUnknown
CLUSTER_GROUP_STATE
WINAPI
GetClusterGroupState(
    __in HGROUP hGroup,
    __out_ecount_part_opt(*lpcchNodeName, *lpcchNodeName + 1) LPWSTR lpszNodeName,
    __inout_opt LPDWORD lpcchNodeName
    );

typedef CLUSTER_GROUP_STATE
(WINAPI * PCLUSAPI_GET_CLUSTER_GROUP_STATE)(
    __in HGROUP hGroup,
    __out_ecount_part_opt(*lpcchNodeName, *lpcchNodeName + 1) LPWSTR lpszNodeName,
    __inout_opt LPDWORD lpcchNodeName
    );

DWORD
WINAPI
SetClusterGroupName(
    __in HGROUP hGroup,
    __in LPCWSTR lpszGroupName
    );

typedef DWORD
(WINAPI * PCLUSAPI_SET_CLUSTER_GROUP_NAME)(
    HGROUP hGroup,
    LPCWSTR lpszGroupName
    );

DWORD
WINAPI
SetClusterGroupNodeList(
    __in HGROUP hGroup,
    __in DWORD NodeCount,
    __in_ecount( NodeCount ) HNODE NodeList[]
    );

typedef DWORD
(WINAPI * PCLUSAPI_SET_CLUSTER_GROUP_NODE_LIST)(
    __in HGROUP hGroup,
    __in DWORD NodeCount,
    __in_ecount( NodeCount ) HNODE NodeList[]
    );

DWORD
WINAPI
OnlineClusterGroup(
    __in HGROUP hGroup,
    __in_opt HNODE hDestinationNode
    );

typedef DWORD
(WINAPI * PCLUSAPI_ONLINE_CLUSTER_GROUP)(
    __in HGROUP hGroup,
    __in_opt HNODE hDestinationNode
    );

DWORD
WINAPI
MoveClusterGroup(
    __in HGROUP hGroup,
    __in_opt HNODE hDestinationNode
    );

typedef DWORD
(WINAPI * PCLUSAPI_MOVE_CLUSTER_GROUP)(
    __in HGROUP hGroup,
    __in_opt HNODE hDestinationNode
    );

DWORD
WINAPI
OfflineClusterGroup(
    __in HGROUP hGroup
    );

typedef DWORD
(WINAPI * PCLUSAPI_OFFLINE_CLUSTER_GROUP)(
    HGROUP hGroup
    );

DWORD
WINAPI
DeleteClusterGroup(
    __in HGROUP hGroup
    );

typedef DWORD
(WINAPI * PCLUSAPI_DELETE_CLUSTER_GROUP)(
    HGROUP hGroup
    );

HGROUPENUM
WINAPI
ClusterGroupOpenEnum(
    __in HGROUP hGroup,
    __in DWORD dwType
    );

typedef HGROUPENUM
(WINAPI * PCLUSAPI_CLUSTER_GROUP_OPEN_ENUM)(
    HGROUP hGroup,
    DWORD dwType
    );

DWORD
WINAPI
ClusterGroupGetEnumCount(
    __in HGROUPENUM hGroupEnum
    );

typedef DWORD
(WINAPI * PCLUSAPI_CLUSTER_GROUP_GET_ENUM_COUNT)(
    __in HGROUPENUM hGroupEnum
    );

__success(return == ERROR_SUCCESS)
DWORD
WINAPI
ClusterGroupEnum(
    __in HGROUPENUM hGroupEnum,
    __in DWORD dwIndex,
    __out LPDWORD lpdwType,
    __out_ecount_part(*lpcchName, *lpcchName + 1) LPWSTR lpszResourceName,
    __inout LPDWORD lpcchName
    );

typedef DWORD
(WINAPI * PCLUSAPI_CLUSTER_GROUP_ENUM)(
    __in HGROUPENUM hGroupEnum,
    __in DWORD dwIndex,
    __out LPDWORD lpdwType,
    __out_ecount_part(*lpcchName, *lpcchName + 1) LPWSTR lpszResourceName,
    __inout LPDWORD lpcchName
    );

DWORD
WINAPI
ClusterGroupCloseEnum(
    __in HGROUPENUM hGroupEnum
    );

typedef DWORD
(WINAPI * PCLUSAPI_CLUSTER_GROUP_CLOSE_ENUM)(
    HGROUPENUM hGroupEnum
    );

#endif // MIDL_PASS


//
// Definitions used in resource management routines.
//

#ifndef _CLUSTER_API_TYPES_
//
// Resource-related structures and types
//
typedef enum CLUSTER_RESOURCE_STATE {
    ClusterResourceStateUnknown = -1,
    ClusterResourceInherited,
    ClusterResourceInitializing,
    ClusterResourceOnline,
    ClusterResourceOffline,
    ClusterResourceFailed,
    ClusterResourcePending = 128,
    ClusterResourceOnlinePending,
    ClusterResourceOfflinePending
} CLUSTER_RESOURCE_STATE;

typedef enum CLUSTER_RESOURCE_RESTART_ACTION {
    ClusterResourceDontRestart = 0,
    ClusterResourceRestartNoNotify,
    ClusterResourceRestartNotify,
    ClusterResourceRestartNotifyIfNotInORexpression,
    ClusterResourceRestartActionCount
} CLUSTER_RESOURCE_RESTART_ACTION, CRRA;

//
// Flags for resource creation
//
typedef enum CLUSTER_RESOURCE_CREATE_FLAGS {
    CLUSTER_RESOURCE_DEFAULT_MONITOR   = 0,
    CLUSTER_RESOURCE_SEPARATE_MONITOR  = 1,
    CLUSTER_RESOURCE_VALID_FLAGS       = CLUSTER_RESOURCE_SEPARATE_MONITOR
} CLUSTER_RESOURCE_CREATE_FLAGS;

#endif // _CLUSTER_API_TYPES_

//
// Interfaces for managing the resources in a cluster
//

#if ( !MIDL_PASS && !__midl )
HRESOURCE
WINAPI
CreateClusterResource(
    __in HGROUP hGroup,
    __in LPCWSTR lpszResourceName,
    __in LPCWSTR lpszResourceType,
    __in DWORD dwFlags
    );

typedef HRESOURCE
(WINAPI * PCLUSAPI_CREATE_CLUSTER_RESOURCE)(
    HGROUP hGroup,
    LPCWSTR lpszResourceName,
    LPCWSTR lpszResourceType,
    DWORD dwFlags
    );

HRESOURCE
WINAPI
OpenClusterResource(
    __in HCLUSTER hCluster,
    __in LPCWSTR lpszResourceName
    );

typedef HRESOURCE
(WINAPI * PCLUSAPI_OPEN_CLUSTER_RESOURCE)(
    HCLUSTER hCluster,
    LPCWSTR lpszResourceName
    );

BOOL
WINAPI
CloseClusterResource(
    __in HRESOURCE hResource
    );

typedef BOOL
(WINAPI * PCLUSAPI_CLOSE_CLUSTER_RESOURCE)(
    HRESOURCE hResource
    );

HCLUSTER
WINAPI
GetClusterFromResource(
    __in HRESOURCE hResource
    );

typedef HCLUSTER
(WINAPI * PCLUSAPI_GET_CLUSTER_FROM_RESOURCE)(
    __in HRESOURCE hResource
    );

DWORD
WINAPI
DeleteClusterResource(
    __in HRESOURCE hResource
    );

typedef DWORD
(WINAPI * PCLUSAPI_DELETE_CLUSTER_RESOURCE)(
    HRESOURCE hResource
    );

__success(return >= 0) // != ClusterResourceStateUnknown
CLUSTER_RESOURCE_STATE
WINAPI
GetClusterResourceState(
    __in HRESOURCE hResource,
    __out_ecount_part_opt(*lpcchNodeName, *lpcchNodeName + 1) LPWSTR lpszNodeName,
    __inout_opt LPDWORD lpcchNodeName,
    __out_ecount_part_opt(*lpcchGroupName, *lpcchGroupName + 1) LPWSTR lpszGroupName,
    __inout_opt LPDWORD lpcchGroupName
    );

typedef CLUSTER_RESOURCE_STATE
(WINAPI * PCLUSAPI_GET_CLUSTER_RESOURCE_STATE)(
    __in HRESOURCE hResource,
    __out_ecount_part_opt(*lpcchNodeName, *lpcchNodeName + 1) LPWSTR lpszNodeName,
    __inout_opt LPDWORD lpcchNodeName,
    __out_ecount_part_opt(*lpcchGroupName, *lpcchGroupName + 1) LPWSTR lpszGroupName,
    __inout_opt LPDWORD lpcchGroupName
    );

DWORD
WINAPI
SetClusterResourceName(
    __in HRESOURCE hResource,
    __in LPCWSTR lpszResourceName
    );

typedef DWORD
(WINAPI * PCLUSAPI_SET_CLUSTER_RESOURCE_NAME)(
    HRESOURCE hResource,
    LPCWSTR lpszResourceName
    );

DWORD
WINAPI
FailClusterResource(
    __in HRESOURCE hResource
    );

typedef DWORD
(WINAPI * PCLUSAPI_FAIL_CLUSTER_RESOURCE)(
    HRESOURCE hResource
    );

DWORD
WINAPI
OnlineClusterResource(
    __in HRESOURCE hResource
    );

typedef DWORD
(WINAPI * PCLUSAPI_ONLINE_CLUSTER_RESOURCE)(
    HRESOURCE hResource
    );

DWORD
WINAPI
OfflineClusterResource(
    __in HRESOURCE hResource
    );

typedef DWORD
(WINAPI * PCLUSAPI_OFFLINE_CLUSTER_RESOURCE)(
    HRESOURCE hResource
    );

DWORD
WINAPI
ChangeClusterResourceGroup(
    __in HRESOURCE hResource,
    __in HGROUP hGroup
    );

typedef DWORD
(WINAPI * PCLUSAPI_CHANGE_CLUSTER_RESOURCE_GROUP)(
    HRESOURCE hResource,
    HGROUP hGroup
    );

DWORD
WINAPI
AddClusterResourceNode(
    __in HRESOURCE hResource,
    __in HNODE hNode
    );

typedef DWORD
(WINAPI * PCLUSAPI_ADD_CLUSTER_RESOURCE_NODE)(
    HRESOURCE hResource,
    HNODE hNode
    );

DWORD
WINAPI
RemoveClusterResourceNode(
    __in HRESOURCE hResource,
    __in HNODE hNode
    );

typedef DWORD
(WINAPI * PCLUSAPI_REMOVE_CLUSTER_RESOURCE_NODE)(
    HRESOURCE hResource,
    HNODE hNode
    );

DWORD
WINAPI
AddClusterResourceDependency(
    __in HRESOURCE hResource,
    __in HRESOURCE hDependsOn
    );

typedef DWORD
(WINAPI * PCLUSAPI_ADD_CLUSTER_RESOURCE_DEPENDENCY)(
    HRESOURCE hResource,
    HRESOURCE hDependsOn
    );

DWORD
WINAPI
RemoveClusterResourceDependency(
    __in HRESOURCE hResource,
    __in HRESOURCE hDependsOn
    );

typedef DWORD
(WINAPI * PCLUSAPI_REMOVE_CLUSTER_RESOURCE_DEPENDENCY)(
    HRESOURCE hResource,
    HRESOURCE hDependsOn
    );

DWORD
WINAPI
SetClusterResourceDependencyExpression(
    __in HRESOURCE hResource,
    __in LPCWSTR lpszDependencyExpression
    );

typedef DWORD
(WINAPI * PCLUSAPI_SET_CLUSTER_RESOURCE_DEPENDENCY_EXPRESSION)(
    __in HRESOURCE hResource,
    __in LPCWSTR lpszDependencyExpression
    );

__success(return == ERROR_SUCCESS)
DWORD
WINAPI
GetClusterResourceDependencyExpression(
    __in HRESOURCE hResource,
    __out_ecount_part_opt(*lpcchDependencyExpression, *lpcchDependencyExpression + 1)
        LPWSTR lpszDependencyExpression,
    __inout LPDWORD lpcchDependencyExpression
    );

typedef DWORD
(WINAPI  * PCLUSAPI_GET_CLUSTER_RESOURCE_DEPENDENCY_EXPRESSION)(
    __in HRESOURCE hResource,
    __out_ecount_part_opt(*lpcchDependencyExpression, *lpcchDependencyExpression + 1)
        LPWSTR lpszDependencyExpression,
    __inout LPDWORD lpcchDependencyExpression
    );

BOOL
WINAPI
CanResourceBeDependent(
    __in HRESOURCE hResource,
    __in HRESOURCE hResourceDependent
    );

typedef BOOL
(WINAPI * PCLUSAPI_CAN_RESOURCE_BE_DEPENDENT)(
    HRESOURCE hResource,
    HRESOURCE hResourceDependent
    );

__success(return == ERROR_SUCCESS)
DWORD
WINAPI
ClusterResourceControl(
    __in HRESOURCE hResource,
    __in_opt HNODE hHostNode,
    __in DWORD dwControlCode,
    __in_bcount_opt(cbInBufferSize) LPVOID lpInBuffer,
    __in DWORD cbInBufferSize,
    __out_bcount_part_opt(cbOutBufferSize, *lpBytesReturned) LPVOID lpOutBuffer,
    __in DWORD cbOutBufferSize,
    __out_opt LPDWORD lpBytesReturned
    );

typedef DWORD
(WINAPI * PCLUSAPI_CLUSTER_RESOURCE_CONTROL)(
    __in HRESOURCE hResource,
    __in_opt HNODE hHostNode,
    __in DWORD dwControlCode,
    __in_bcount_opt(cbInBufferSize) LPVOID lpInBuffer,
    __in DWORD cbInBufferSize,
    __out_bcount_part_opt(cbOutBufferSize, *lpBytesReturned) LPVOID lpOutBuffer,
    __in DWORD cbOutBufferSize,
    __out_opt LPDWORD lpBytesReturned
    );

__success(return == ERROR_SUCCESS)
DWORD
WINAPI
ClusterResourceTypeControl(
    __in HCLUSTER hCluster,
    __in LPCWSTR lpszResourceTypeName,
    __in_opt HNODE hHostNode,
    __in DWORD dwControlCode,
    __in_bcount_opt(nInBufferSize) LPVOID lpInBuffer,
    __in DWORD nInBufferSize,
    __out_bcount_part_opt(nOutBufferSize, *lpBytesReturned) LPVOID lpOutBuffer,
    __in DWORD nOutBufferSize,
    __out_opt LPDWORD lpBytesReturned
    );

typedef DWORD
(WINAPI * PCLUSAPI_CLUSTER_RESOURCE_TYPE_CONTROL)(
    __in HCLUSTER hCluster,
    __in LPCWSTR lpszResourceTypeName,
    __in_opt HNODE hHostNode,
    __in DWORD dwControlCode,
    __in_bcount_opt(nInBufferSize) LPVOID lpInBuffer,
    __in DWORD nInBufferSize,
    __out_bcount_part_opt(nOutBufferSize, *lpBytesReturned) LPVOID lpOutBuffer,
    __in DWORD nOutBufferSize,
    __out_opt LPDWORD lpBytesReturned
    );

__success(return == ERROR_SUCCESS)
DWORD
WINAPI
ClusterGroupControl(
    __in HGROUP hGroup,
    __in_opt HNODE hHostNode,
    __in DWORD dwControlCode,
    __in_bcount_opt(nInBufferSize) LPVOID lpInBuffer,
    __in DWORD nInBufferSize,
    __out_bcount_part_opt(nOutBufferSize, *lpBytesReturned) LPVOID lpOutBuffer,
    __in DWORD nOutBufferSize,
    __out_opt LPDWORD lpBytesReturned
    );

typedef DWORD
(WINAPI * PCLUSAPI_CLUSTER_GROUP_CONTROL)(
    __in HGROUP hGroup,
    __in_opt HNODE hHostNode,
    __in DWORD dwControlCode,
    __in_bcount_opt(nInBufferSize) LPVOID lpInBuffer,
    __in DWORD nInBufferSize,
    __out_bcount_part_opt(nOutBufferSize, *lpBytesReturned) LPVOID lpOutBuffer,
    __in DWORD nOutBufferSize,
    __out_opt LPDWORD lpBytesReturned
    );

__success(return == ERROR_SUCCESS)
DWORD
WINAPI
ClusterNodeControl(
    __in HNODE hNode,
    __in_opt HNODE hHostNode,
    __in DWORD dwControlCode,
    __in_bcount_opt(nInBufferSize) LPVOID lpInBuffer,
    __in DWORD nInBufferSize,
    __out_bcount_part_opt(nOutBufferSize, *lpBytesReturned) LPVOID lpOutBuffer,
    __in DWORD nOutBufferSize,
    __out_opt LPDWORD lpBytesReturned
    );

typedef DWORD
(WINAPI * PCLUSAPI_CLUSTER_NODE_CONTROL)(
    __in HNODE hNode,
    __in_opt HNODE hHostNode,
    __in DWORD dwControlCode,
    __in_bcount_opt(nInBufferSize) LPVOID lpInBuffer,
    __in DWORD nInBufferSize,
    __out_bcount_part_opt(nOutBufferSize, *lpBytesReturned) LPVOID lpOutBuffer,
    __in DWORD nOutBufferSize,
    __out_opt LPDWORD lpBytesReturned
    );

BOOL
WINAPI
GetClusterResourceNetworkName(
    __in HRESOURCE hResource,
    __out_ecount_part(*nSize, *nSize + 1) LPWSTR lpBuffer,
    __inout LPDWORD nSize
    );

typedef BOOL
(WINAPI * PCLUSAPI_GET_CLUSTER_RESOURCE_NETWORK_NAME)(
    __in HRESOURCE hResource,
    __out_ecount_part(*nSize, *nSize + 1) LPWSTR lpBuffer,
    __inout LPDWORD nSize
    );

#endif // MIDL_PASS


//
// Cluster control properties
//

#ifndef _CLUSTER_API_TYPES_
//
// Cluster Control Property Data - Types (a WORD)
//
typedef enum CLUSTER_PROPERTY_TYPE {
    CLUSPROP_TYPE_UNKNOWN = -1,
    CLUSPROP_TYPE_ENDMARK = 0,
    CLUSPROP_TYPE_LIST_VALUE,
    CLUSPROP_TYPE_RESCLASS,
    CLUSPROP_TYPE_RESERVED1,
    CLUSPROP_TYPE_NAME,
    CLUSPROP_TYPE_SIGNATURE,
    CLUSPROP_TYPE_SCSI_ADDRESS,
    CLUSPROP_TYPE_DISK_NUMBER,
    CLUSPROP_TYPE_PARTITION_INFO,
    CLUSPROP_TYPE_FTSET_INFO,
    CLUSPROP_TYPE_DISK_SERIALNUMBER,
    CLUSPROP_TYPE_DISK_GUID,
    CLUSPROP_TYPE_DISK_SIZE,
    CLUSPROP_TYPE_PARTITION_INFO_EX,
    CLUSPROP_TYPE_USER=32768
} CLUSTER_PROPERTY_TYPE;

//
// Cluster Control Property Data - Formats (a WORD)
//
typedef enum CLUSTER_PROPERTY_FORMAT {
    CLUSPROP_FORMAT_UNKNOWN = 0,
    CLUSPROP_FORMAT_BINARY,
    CLUSPROP_FORMAT_DWORD,
    CLUSPROP_FORMAT_SZ,
    CLUSPROP_FORMAT_EXPAND_SZ,
    CLUSPROP_FORMAT_MULTI_SZ,
    CLUSPROP_FORMAT_ULARGE_INTEGER,
    CLUSPROP_FORMAT_LONG,
    CLUSPROP_FORMAT_EXPANDED_SZ,
    CLUSPROP_FORMAT_SECURITY_DESCRIPTOR,
    CLUSPROP_FORMAT_LARGE_INTEGER,
    CLUSPROP_FORMAT_WORD,
    CLUSPROP_FORMAT_FILETIME,
    CLUSPROP_FORMAT_USER=32768
} CLUSTER_PROPERTY_FORMAT;

#endif // _CLUSTER_API_TYPES_

//
// Cluster Control Property Data - Syntax
//
#define CLUSPROP_SYNTAX_VALUE( type, format ) ((DWORD) ((type << 16) | format))

#ifndef _CLUSTER_API_TYPES_

typedef enum CLUSTER_PROPERTY_SYNTAX {

    CLUSPROP_SYNTAX_ENDMARK         = CLUSPROP_SYNTAX_VALUE( CLUSPROP_TYPE_ENDMARK, CLUSPROP_FORMAT_UNKNOWN ),
    CLUSPROP_SYNTAX_NAME            = CLUSPROP_SYNTAX_VALUE( CLUSPROP_TYPE_NAME, CLUSPROP_FORMAT_SZ ),
    CLUSPROP_SYNTAX_RESCLASS        = CLUSPROP_SYNTAX_VALUE( CLUSPROP_TYPE_RESCLASS, CLUSPROP_FORMAT_DWORD ),

    CLUSPROP_SYNTAX_LIST_VALUE_SZ                   = CLUSPROP_SYNTAX_VALUE( CLUSPROP_TYPE_LIST_VALUE, CLUSPROP_FORMAT_SZ ),
    CLUSPROP_SYNTAX_LIST_VALUE_EXPAND_SZ            = CLUSPROP_SYNTAX_VALUE( CLUSPROP_TYPE_LIST_VALUE, CLUSPROP_FORMAT_EXPAND_SZ ),
    CLUSPROP_SYNTAX_LIST_VALUE_DWORD                = CLUSPROP_SYNTAX_VALUE( CLUSPROP_TYPE_LIST_VALUE, CLUSPROP_FORMAT_DWORD ),
    CLUSPROP_SYNTAX_LIST_VALUE_BINARY               = CLUSPROP_SYNTAX_VALUE( CLUSPROP_TYPE_LIST_VALUE, CLUSPROP_FORMAT_BINARY ),
    CLUSPROP_SYNTAX_LIST_VALUE_MULTI_SZ             = CLUSPROP_SYNTAX_VALUE( CLUSPROP_TYPE_LIST_VALUE, CLUSPROP_FORMAT_MULTI_SZ ),
    CLUSPROP_SYNTAX_LIST_VALUE_LONG                 = CLUSPROP_SYNTAX_VALUE( CLUSPROP_TYPE_LIST_VALUE, CLUSPROP_FORMAT_LONG ),
    CLUSPROP_SYNTAX_LIST_VALUE_EXPANDED_SZ          = CLUSPROP_SYNTAX_VALUE( CLUSPROP_TYPE_LIST_VALUE, CLUSPROP_FORMAT_EXPANDED_SZ ),
    CLUSPROP_SYNTAX_LIST_VALUE_SECURITY_DESCRIPTOR  = CLUSPROP_SYNTAX_VALUE( CLUSPROP_TYPE_LIST_VALUE, CLUSPROP_FORMAT_SECURITY_DESCRIPTOR ),
    CLUSPROP_SYNTAX_LIST_VALUE_LARGE_INTEGER        = CLUSPROP_SYNTAX_VALUE( CLUSPROP_TYPE_LIST_VALUE, CLUSPROP_FORMAT_LARGE_INTEGER ),
    CLUSPROP_SYNTAX_LIST_VALUE_ULARGE_INTEGER       = CLUSPROP_SYNTAX_VALUE( CLUSPROP_TYPE_LIST_VALUE, CLUSPROP_FORMAT_ULARGE_INTEGER ),
    CLUSPROP_SYNTAX_LIST_VALUE_WORD                 = CLUSPROP_SYNTAX_VALUE( CLUSPROP_TYPE_LIST_VALUE, CLUSPROP_FORMAT_WORD ),

    // Storage syntax values

    CLUSPROP_SYNTAX_DISK_SIGNATURE      = CLUSPROP_SYNTAX_VALUE( CLUSPROP_TYPE_SIGNATURE, CLUSPROP_FORMAT_DWORD ),
    CLUSPROP_SYNTAX_SCSI_ADDRESS        = CLUSPROP_SYNTAX_VALUE( CLUSPROP_TYPE_SCSI_ADDRESS, CLUSPROP_FORMAT_DWORD ),
    CLUSPROP_SYNTAX_DISK_NUMBER         = CLUSPROP_SYNTAX_VALUE( CLUSPROP_TYPE_DISK_NUMBER, CLUSPROP_FORMAT_DWORD ),
    CLUSPROP_SYNTAX_PARTITION_INFO      = CLUSPROP_SYNTAX_VALUE( CLUSPROP_TYPE_PARTITION_INFO, CLUSPROP_FORMAT_BINARY ),
    CLUSPROP_SYNTAX_FTSET_INFO          = CLUSPROP_SYNTAX_VALUE( CLUSPROP_TYPE_FTSET_INFO, CLUSPROP_FORMAT_BINARY ),
    CLUSPROP_SYNTAX_DISK_SERIALNUMBER   = CLUSPROP_SYNTAX_VALUE( CLUSPROP_TYPE_DISK_SERIALNUMBER, CLUSPROP_FORMAT_SZ ),
    CLUSPROP_SYNTAX_DISK_GUID           = CLUSPROP_SYNTAX_VALUE( CLUSPROP_TYPE_DISK_GUID, CLUSPROP_FORMAT_SZ ),
    CLUSPROP_SYNTAX_DISK_SIZE           = CLUSPROP_SYNTAX_VALUE( CLUSPROP_TYPE_DISK_SIZE, CLUSPROP_FORMAT_ULARGE_INTEGER ),
    CLUSPROP_SYNTAX_PARTITION_INFO_EX   = CLUSPROP_SYNTAX_VALUE( CLUSPROP_TYPE_PARTITION_INFO_EX, CLUSPROP_FORMAT_BINARY ),
    CLUSPROP_SYNTAX_LIST_VALUE_FILETIME = CLUSPROP_SYNTAX_VALUE( CLUSPROP_TYPE_LIST_VALUE, CLUSPROP_FORMAT_FILETIME ),

} CLUSTER_PROPERTY_SYNTAX;

#endif // _CLUSTER_API_TYPES_

//
// Define Cluster Control Code access methods
//
#define CLUS_ACCESS_ANY        0
#define CLUS_ACCESS_READ    0x01
#define CLUS_ACCESS_WRITE   0x02

//
// Define Cluster Control Code modification actions
//
#define CLUS_NO_MODIFY      0
#define CLUS_MODIFY         0x01

//
// Define Cluster Control Code Global actions
//
#define CLUS_NOT_GLOBAL     0
#define CLUS_GLOBAL         0x01

#ifndef _CLUSTER_API_TYPES_
//
// Define Cluster Control Code target objects
//
typedef enum CLUSTER_CONTROL_OBJECT {
    CLUS_OBJECT_INVALID=0,
    CLUS_OBJECT_RESOURCE,
    CLUS_OBJECT_RESOURCE_TYPE,
    CLUS_OBJECT_GROUP,
    CLUS_OBJECT_NODE,
    CLUS_OBJECT_NETWORK,
    CLUS_OBJECT_NETINTERFACE,
    CLUS_OBJECT_CLUSTER,
    CLUS_OBJECT_USER=128
} CLUSTER_CONTROL_OBJECT;

#endif // _CLUSTER_API_TYPES_

//
// Macro to generate full cluster control codes
//
//  31      24 23 22 21 20 19       16 15                    2 1    0
// +----------+--+--+--+--+-----------+-----------------------+------+
// |  OBJECT  |G |M |U |I       CLUSTER CONTROL CODES         |ACCESS|
// +----------+--+--+--+--+-----------+-----------------------+------+
//
// OBJECT - Object identifier (8 bits)
// G - Global bit (operation must be performed on all nodes of cluster)
// M - Modify bit (code causes a modification, may cause event notification)
// U - User code bit (splits the control codes into 2 spaces each 2^^19 in size)
// I - Internal code bit (only for non-user control codes)
// CLUSTER CONTROL CODES - 2^^18 (256 thousand possible control codes)
// ACCESS - Access mode (2 bits)
//

//
// Define control code shifts
//
#define CLUSCTL_ACCESS_SHIFT         0
#define CLUSCTL_FUNCTION_SHIFT       2
#define CLCTL_INTERNAL_SHIFT        20
#define CLCTL_USER_SHIFT            21
#define CLCTL_MODIFY_SHIFT          22
#define CLCTL_GLOBAL_SHIFT          23
#define CLUSCTL_OBJECT_SHIFT        24

//
// Define control code masks
//
#define CLCTL_INTERNAL_MASK             (1<<CLCTL_INTERNAL_SHIFT)
#define CLCTL_USER_MASK                 (1<<CLCTL_USER_SHIFT)
#define CLCTL_MODIFY_MASK               (1<<CLCTL_MODIFY_SHIFT)
#define CLCTL_GLOBAL_MASK               (1<<CLCTL_GLOBAL_SHIFT)
#define CLUSCTL_CONTROL_CODE_MASK       0x3FFFFF // Includes access mask
#define CLUSCTL_OBJECT_MASK             0xFF
#define CLUSCTL_ACCESS_MODE_MASK        0x03

//
// Cluster Control function codes (a DWORD)
//
#define CLCTL_CLUSTER_BASE  0           // Start of cluster defined functions
#define CLCTL_USER_BASE     (1<<CLCTL_USER_SHIFT) // Start of user functions

#define CLCTL_EXTERNAL_CODE( Function, Access, Modify ) ( \
    ((Access) << CLUSCTL_ACCESS_SHIFT) | \
    ((CLCTL_CLUSTER_BASE + Function) << CLUSCTL_FUNCTION_SHIFT) | \
    ((Modify) << CLCTL_MODIFY_SHIFT) )

#define CLCTL_INTERNAL_CODE( Function, Access, Modify ) ( \
    ((Access) << CLUSCTL_ACCESS_SHIFT) | \
    CLCTL_INTERNAL_MASK | \
    ((CLCTL_CLUSTER_BASE + Function) << CLUSCTL_FUNCTION_SHIFT) | \
    ((Modify) << CLCTL_MODIFY_SHIFT) )

#ifndef _CLUSTER_API_TYPES_
typedef enum CLCTL_CODES {
    //
    // External control codes
    //
    CLCTL_UNKNOWN                           = CLCTL_EXTERNAL_CODE( 0, CLUS_ACCESS_ANY, CLUS_NO_MODIFY ),
    CLCTL_GET_CHARACTERISTICS               = CLCTL_EXTERNAL_CODE( 1, CLUS_ACCESS_READ, CLUS_NO_MODIFY ),
    CLCTL_GET_FLAGS                         = CLCTL_EXTERNAL_CODE( 2, CLUS_ACCESS_READ, CLUS_NO_MODIFY ),
    CLCTL_GET_CLASS_INFO                    = CLCTL_EXTERNAL_CODE( 3, CLUS_ACCESS_READ, CLUS_NO_MODIFY ),
    CLCTL_GET_REQUIRED_DEPENDENCIES         = CLCTL_EXTERNAL_CODE( 4, CLUS_ACCESS_READ, CLUS_NO_MODIFY ),
    CLCTL_GET_ARB_TIMEOUT                   = CLCTL_EXTERNAL_CODE( 5, CLUS_ACCESS_READ, CLUS_NO_MODIFY ),

    CLCTL_GET_NAME                          = CLCTL_EXTERNAL_CODE( 10, CLUS_ACCESS_READ, CLUS_NO_MODIFY ),
    CLCTL_GET_RESOURCE_TYPE                 = CLCTL_EXTERNAL_CODE( 11, CLUS_ACCESS_READ, CLUS_NO_MODIFY ),
    CLCTL_GET_NODE                          = CLCTL_EXTERNAL_CODE( 12, CLUS_ACCESS_READ, CLUS_NO_MODIFY ),
    CLCTL_GET_NETWORK                       = CLCTL_EXTERNAL_CODE( 13, CLUS_ACCESS_READ, CLUS_NO_MODIFY ),
    CLCTL_GET_ID                            = CLCTL_EXTERNAL_CODE( 14, CLUS_ACCESS_READ, CLUS_NO_MODIFY ),
    CLCTL_GET_FQDN                          = CLCTL_EXTERNAL_CODE( 15, CLUS_ACCESS_READ, CLUS_NO_MODIFY ),
    CLCTL_GET_CLUSTER_SERVICE_ACCOUNT_NAME  = CLCTL_EXTERNAL_CODE( 16, CLUS_ACCESS_READ, CLUS_NO_MODIFY ),
    CLCTL_CHECK_VOTER_EVICT                 = CLCTL_EXTERNAL_CODE( 17, CLUS_ACCESS_READ, CLUS_NO_MODIFY ),
    CLCTL_CHECK_VOTER_DOWN                  = CLCTL_EXTERNAL_CODE( 18, CLUS_ACCESS_READ, CLUS_NO_MODIFY ),
    CLCTL_SHUTDOWN                          = CLCTL_EXTERNAL_CODE( 19, CLUS_ACCESS_READ, CLUS_NO_MODIFY ),

    CLCTL_ENUM_COMMON_PROPERTIES            = CLCTL_EXTERNAL_CODE( 20, CLUS_ACCESS_READ, CLUS_NO_MODIFY ),
    CLCTL_GET_RO_COMMON_PROPERTIES          = CLCTL_EXTERNAL_CODE( 21, CLUS_ACCESS_READ, CLUS_NO_MODIFY ),
    CLCTL_GET_COMMON_PROPERTIES             = CLCTL_EXTERNAL_CODE( 22, CLUS_ACCESS_READ, CLUS_NO_MODIFY ),
    CLCTL_SET_COMMON_PROPERTIES             = CLCTL_EXTERNAL_CODE( 23, CLUS_ACCESS_WRITE, CLUS_MODIFY ),
    CLCTL_VALIDATE_COMMON_PROPERTIES        = CLCTL_EXTERNAL_CODE( 24, CLUS_ACCESS_READ, CLUS_NO_MODIFY ),
    CLCTL_GET_COMMON_PROPERTY_FMTS          = CLCTL_EXTERNAL_CODE( 25, CLUS_ACCESS_READ, CLUS_NO_MODIFY ),
    CLCTL_GET_COMMON_RESOURCE_PROPERTY_FMTS = CLCTL_EXTERNAL_CODE( 26, CLUS_ACCESS_READ, CLUS_NO_MODIFY ),

    CLCTL_ENUM_PRIVATE_PROPERTIES           = CLCTL_EXTERNAL_CODE( 30, CLUS_ACCESS_READ, CLUS_NO_MODIFY ),
    CLCTL_GET_RO_PRIVATE_PROPERTIES         = CLCTL_EXTERNAL_CODE( 31, CLUS_ACCESS_READ, CLUS_NO_MODIFY ),
    CLCTL_GET_PRIVATE_PROPERTIES            = CLCTL_EXTERNAL_CODE( 32, CLUS_ACCESS_READ, CLUS_NO_MODIFY ),
    CLCTL_SET_PRIVATE_PROPERTIES            = CLCTL_EXTERNAL_CODE( 33, CLUS_ACCESS_WRITE, CLUS_MODIFY ),
    CLCTL_VALIDATE_PRIVATE_PROPERTIES       = CLCTL_EXTERNAL_CODE( 34, CLUS_ACCESS_READ, CLUS_NO_MODIFY ),
    CLCTL_GET_PRIVATE_PROPERTY_FMTS         = CLCTL_EXTERNAL_CODE( 35, CLUS_ACCESS_READ, CLUS_NO_MODIFY ),
    CLCTL_GET_PRIVATE_RESOURCE_PROPERTY_FMTS= CLCTL_EXTERNAL_CODE( 36, CLUS_ACCESS_READ, CLUS_NO_MODIFY ),

    CLCTL_ADD_REGISTRY_CHECKPOINT           = CLCTL_EXTERNAL_CODE( 40, CLUS_ACCESS_WRITE, CLUS_MODIFY ),
    CLCTL_DELETE_REGISTRY_CHECKPOINT        = CLCTL_EXTERNAL_CODE( 41, CLUS_ACCESS_WRITE, CLUS_MODIFY ),
    CLCTL_GET_REGISTRY_CHECKPOINTS          = CLCTL_EXTERNAL_CODE( 42, CLUS_ACCESS_READ, CLUS_NO_MODIFY ),

    CLCTL_ADD_CRYPTO_CHECKPOINT             = CLCTL_EXTERNAL_CODE( 43, CLUS_ACCESS_WRITE, CLUS_MODIFY ),
    CLCTL_DELETE_CRYPTO_CHECKPOINT          = CLCTL_EXTERNAL_CODE( 44, CLUS_ACCESS_WRITE, CLUS_MODIFY ),
    CLCTL_GET_CRYPTO_CHECKPOINTS            = CLCTL_EXTERNAL_CODE( 45, CLUS_ACCESS_READ, CLUS_NO_MODIFY ),

    CLCTL_RESOURCE_UPGRADE_DLL              = CLCTL_EXTERNAL_CODE( 46, CLUS_ACCESS_WRITE, CLUS_MODIFY ),

    CLCTL_ADD_REGISTRY_CHECKPOINT_64BIT     = CLCTL_EXTERNAL_CODE( 47, CLUS_ACCESS_WRITE, CLUS_MODIFY ),
    CLCTL_ADD_REGISTRY_CHECKPOINT_32BIT     = CLCTL_EXTERNAL_CODE( 48, CLUS_ACCESS_WRITE, CLUS_MODIFY ),

    CLCTL_GET_LOADBAL_PROCESS_LIST          = CLCTL_EXTERNAL_CODE( 50, CLUS_ACCESS_READ, CLUS_NO_MODIFY ),

    CLCTL_GET_NETWORK_NAME                  = CLCTL_EXTERNAL_CODE( 90, CLUS_ACCESS_READ,  CLUS_NO_MODIFY ),
    CLCTL_NETNAME_GET_VIRTUAL_SERVER_TOKEN  = CLCTL_EXTERNAL_CODE( 91, CLUS_ACCESS_READ,  CLUS_NO_MODIFY ),
    CLCTL_NETNAME_REGISTER_DNS_RECORDS      = CLCTL_EXTERNAL_CODE( 92, CLUS_ACCESS_WRITE, CLUS_NO_MODIFY ),
    CLCTL_GET_DNS_NAME                      = CLCTL_EXTERNAL_CODE( 93, CLUS_ACCESS_READ,  CLUS_NO_MODIFY ),
    CLCTL_NETNAME_SET_PWD_INFO              = CLCTL_EXTERNAL_CODE( 94, CLUS_ACCESS_WRITE, CLUS_NO_MODIFY ),
    CLCTL_NETNAME_DELETE_CO                 = CLCTL_EXTERNAL_CODE( 95, CLUS_ACCESS_WRITE, CLUS_NO_MODIFY ),
    CLCTL_NETNAME_VALIDATE_VCO              = CLCTL_EXTERNAL_CODE( 96, CLUS_ACCESS_READ,  CLUS_NO_MODIFY ),
    
    CLCTL_STORAGE_GET_DISK_INFO             = CLCTL_EXTERNAL_CODE( 100, CLUS_ACCESS_READ, CLUS_NO_MODIFY ),
    CLCTL_STORAGE_GET_AVAILABLE_DISKS       = CLCTL_EXTERNAL_CODE( 101, CLUS_ACCESS_READ, CLUS_NO_MODIFY ),
    CLCTL_STORAGE_IS_PATH_VALID             = CLCTL_EXTERNAL_CODE( 102, CLUS_ACCESS_READ, CLUS_NO_MODIFY ),
    CLCTL_STORAGE_GET_ALL_AVAILABLE_DISKS   = CLCTL_EXTERNAL_CODE( 103, CLUS_ACCESS_READ, CLUS_NO_MODIFY ),
    CLCTL_STORAGE_SYNC_CLUSDISK_DB          = (CLCTL_EXTERNAL_CODE( 103, CLUS_ACCESS_WRITE, CLUS_MODIFY ) | CLCTL_GLOBAL_MASK),

    CLCTL_QUERY_DELETE                      = CLCTL_EXTERNAL_CODE( 110, CLUS_ACCESS_READ, CLUS_NO_MODIFY ),

    CLCTL_IPADDRESS_RENEW_LEASE             = CLCTL_EXTERNAL_CODE( 111, CLUS_ACCESS_WRITE, CLUS_MODIFY ),
    CLCTL_IPADDRESS_RELEASE_LEASE           = CLCTL_EXTERNAL_CODE( 112, CLUS_ACCESS_WRITE, CLUS_MODIFY ),

    CLCTL_QUERY_MAINTENANCE_MODE            = CLCTL_EXTERNAL_CODE( 120, CLUS_ACCESS_READ, CLUS_NO_MODIFY ),
    CLCTL_SET_MAINTENANCE_MODE              = CLCTL_EXTERNAL_CODE( 121, CLUS_ACCESS_WRITE, CLUS_MODIFY ),
    CLCTL_STORAGE_SET_DRIVELETTER           = CLCTL_EXTERNAL_CODE( 122, CLUS_ACCESS_WRITE, CLUS_MODIFY ),
    CLCTL_STORAGE_GET_DRIVELETTERS          = CLCTL_EXTERNAL_CODE( 123, CLUS_ACCESS_READ, CLUS_NO_MODIFY ),
    CLCTL_STORAGE_GET_DISK_INFO_EX          = CLCTL_EXTERNAL_CODE( 124, CLUS_ACCESS_READ, CLUS_NO_MODIFY ),
    CLCTL_STORAGE_GET_AVAILABLE_DISKS_EX    = CLCTL_EXTERNAL_CODE( 125, CLUS_ACCESS_READ, CLUS_NO_MODIFY ),
    CLCTL_STORAGE_REMAP_DRIVELETTER         = CLCTL_EXTERNAL_CODE( 128, CLUS_ACCESS_READ, CLUS_NO_MODIFY ),

    //
    // Internal control codes
    //
    CLCTL_DELETE                            = CLCTL_INTERNAL_CODE( 1, CLUS_ACCESS_WRITE, CLUS_MODIFY ),
    CLCTL_INSTALL_NODE                      = CLCTL_INTERNAL_CODE( 2, CLUS_ACCESS_WRITE, CLUS_MODIFY ),
    CLCTL_EVICT_NODE                        = CLCTL_INTERNAL_CODE( 3, CLUS_ACCESS_WRITE, CLUS_MODIFY ),
    CLCTL_ADD_DEPENDENCY                    = CLCTL_INTERNAL_CODE( 4, CLUS_ACCESS_WRITE, CLUS_MODIFY ),
    CLCTL_REMOVE_DEPENDENCY                 = CLCTL_INTERNAL_CODE( 5, CLUS_ACCESS_WRITE, CLUS_MODIFY ),
    CLCTL_ADD_OWNER                         = CLCTL_INTERNAL_CODE( 6, CLUS_ACCESS_WRITE, CLUS_MODIFY ),
    CLCTL_REMOVE_OWNER                      = CLCTL_INTERNAL_CODE( 7, CLUS_ACCESS_WRITE, CLUS_MODIFY ),
    //************ Hole here at 8
    CLCTL_SET_NAME                          = CLCTL_INTERNAL_CODE( 9, CLUS_ACCESS_WRITE, CLUS_MODIFY ),
    CLCTL_CLUSTER_NAME_CHANGED              = CLCTL_INTERNAL_CODE( 10, CLUS_ACCESS_WRITE, CLUS_MODIFY ),
    CLCTL_CLUSTER_VERSION_CHANGED           = CLCTL_INTERNAL_CODE( 11, CLUS_ACCESS_WRITE, CLUS_MODIFY ),
    CLCTL_FIXUP_ON_UPGRADE                  = CLCTL_INTERNAL_CODE( 12, CLUS_ACCESS_WRITE, CLUS_MODIFY ),
    CLCTL_STARTING_PHASE1                   = CLCTL_INTERNAL_CODE( 13, CLUS_ACCESS_WRITE, CLUS_MODIFY ),
    CLCTL_STARTING_PHASE2                   = CLCTL_INTERNAL_CODE( 14, CLUS_ACCESS_WRITE, CLUS_MODIFY ),
    CLCTL_HOLD_IO                           = CLCTL_INTERNAL_CODE( 15, CLUS_ACCESS_WRITE, CLUS_MODIFY ),
    CLCTL_RESUME_IO                         = CLCTL_INTERNAL_CODE( 16, CLUS_ACCESS_WRITE, CLUS_MODIFY ),
    CLCTL_FORCE_QUORUM                      = CLCTL_INTERNAL_CODE( 17, CLUS_ACCESS_WRITE, CLUS_MODIFY ),
    CLCTL_INITIALIZE                        = CLCTL_INTERNAL_CODE( 18, CLUS_ACCESS_WRITE, CLUS_MODIFY ),
    CLCTL_STATE_CHANGE_REASON               = CLCTL_INTERNAL_CODE( 19, CLUS_ACCESS_WRITE, CLUS_MODIFY ),
    CLCTL_PROVIDER_STATE_CHANGE             = CLCTL_INTERNAL_CODE( 20, CLUS_ACCESS_WRITE, CLUS_MODIFY ),

} CLCTL_CODES;

#endif // _CLUSTER_API_TYPES_

//
// Define macros to generate object specific control codes
//
#define CLUSCTL_RESOURCE_CODE( Function ) ( \
    ((CLUS_OBJECT_RESOURCE << CLUSCTL_OBJECT_SHIFT) | Function) )

#define CLUSCTL_RESOURCE_TYPE_CODE( Function ) ( \
    ((CLUS_OBJECT_RESOURCE_TYPE << CLUSCTL_OBJECT_SHIFT) | Function) )

#define CLUSCTL_GROUP_CODE( Function ) ( \
    ((CLUS_OBJECT_GROUP << CLUSCTL_OBJECT_SHIFT) | Function) )

#define CLUSCTL_NODE_CODE( Function ) ( \
    ((CLUS_OBJECT_NODE << CLUSCTL_OBJECT_SHIFT) | Function) )

#define CLUSCTL_NETWORK_CODE( Function ) ( \
    ((CLUS_OBJECT_NETWORK << CLUSCTL_OBJECT_SHIFT) | Function) )

#define CLUSCTL_NETINTERFACE_CODE( Function ) ( \
    ((CLUS_OBJECT_NETINTERFACE << CLUSCTL_OBJECT_SHIFT) | Function) )

#define CLUSCTL_CLUSTER_CODE( Function ) ( \
    ((CLUS_OBJECT_CLUSTER << CLUSCTL_OBJECT_SHIFT) | Function) )

#define CLUSCTL_USER_CODE( Function, Object ) ( \
     ((Object) << CLUSCTL_OBJECT_SHIFT) | ((CLCTL_USER_BASE + Function) << CLUSCTL_FUNCTION_SHIFT) )

//
// Define macros to get the function or access mode out of a control code
//
#define CLUSCTL_GET_CONTROL_FUNCTION( ControlCode ) \
    ((ControlCode >> CLUSCTL_ACCESS_SHIFT) & CLUSCTL_CONTROL_CODE_MASK)

#define CLUSCTL_GET_ACCESS_MODE( ControlCode ) \
    ((ControlCode >> CLUSCTL_ACCESS_SHIFT) & CLUSCTL_ACCESS_MODE_MASK)

#define CLUSCTL_GET_CONTROL_OBJECT( ControlCode ) \
    ((ControlCode >> CLUSCTL_OBJECT_SHIFT) & CLUSCTL_OBJECT_MASK)

#ifndef _CLUSTER_API_TYPES_
//
// Cluster Control Codes for Resources
//
typedef enum CLUSCTL_RESOURCE_CODES {

    // External
    CLUSCTL_RESOURCE_UNKNOWN =
        CLUSCTL_RESOURCE_CODE( CLCTL_UNKNOWN ),

    CLUSCTL_RESOURCE_GET_CHARACTERISTICS =
        CLUSCTL_RESOURCE_CODE( CLCTL_GET_CHARACTERISTICS ),

    CLUSCTL_RESOURCE_GET_FLAGS =
        CLUSCTL_RESOURCE_CODE( CLCTL_GET_FLAGS ),

    CLUSCTL_RESOURCE_GET_CLASS_INFO =
        CLUSCTL_RESOURCE_CODE( CLCTL_GET_CLASS_INFO ),

    CLUSCTL_RESOURCE_GET_REQUIRED_DEPENDENCIES =
        CLUSCTL_RESOURCE_CODE( CLCTL_GET_REQUIRED_DEPENDENCIES ),

    CLUSCTL_RESOURCE_GET_NAME =
        CLUSCTL_RESOURCE_CODE( CLCTL_GET_NAME ),

    CLUSCTL_RESOURCE_GET_ID =
        CLUSCTL_RESOURCE_CODE( CLCTL_GET_ID ),

    CLUSCTL_RESOURCE_GET_RESOURCE_TYPE =
        CLUSCTL_RESOURCE_CODE( CLCTL_GET_RESOURCE_TYPE ),

    CLUSCTL_RESOURCE_ENUM_COMMON_PROPERTIES =
        CLUSCTL_RESOURCE_CODE( CLCTL_ENUM_COMMON_PROPERTIES ),

    CLUSCTL_RESOURCE_GET_RO_COMMON_PROPERTIES =
        CLUSCTL_RESOURCE_CODE( CLCTL_GET_RO_COMMON_PROPERTIES ),

    CLUSCTL_RESOURCE_GET_COMMON_PROPERTIES =
        CLUSCTL_RESOURCE_CODE( CLCTL_GET_COMMON_PROPERTIES ),

    CLUSCTL_RESOURCE_SET_COMMON_PROPERTIES =
        CLUSCTL_RESOURCE_CODE( CLCTL_SET_COMMON_PROPERTIES ),

    CLUSCTL_RESOURCE_VALIDATE_COMMON_PROPERTIES =
        CLUSCTL_RESOURCE_CODE( CLCTL_VALIDATE_COMMON_PROPERTIES ),

    CLUSCTL_RESOURCE_GET_COMMON_PROPERTY_FMTS =
        CLUSCTL_RESOURCE_CODE( CLCTL_GET_COMMON_PROPERTY_FMTS ),

    CLUSCTL_RESOURCE_ENUM_PRIVATE_PROPERTIES =
        CLUSCTL_RESOURCE_CODE( CLCTL_ENUM_PRIVATE_PROPERTIES ),

    CLUSCTL_RESOURCE_GET_RO_PRIVATE_PROPERTIES =
        CLUSCTL_RESOURCE_CODE( CLCTL_GET_RO_PRIVATE_PROPERTIES ),

    CLUSCTL_RESOURCE_GET_PRIVATE_PROPERTIES =
        CLUSCTL_RESOURCE_CODE( CLCTL_GET_PRIVATE_PROPERTIES ),

    CLUSCTL_RESOURCE_SET_PRIVATE_PROPERTIES =
        CLUSCTL_RESOURCE_CODE( CLCTL_SET_PRIVATE_PROPERTIES ),

    CLUSCTL_RESOURCE_VALIDATE_PRIVATE_PROPERTIES =
        CLUSCTL_RESOURCE_CODE( CLCTL_VALIDATE_PRIVATE_PROPERTIES ),

    CLUSCTL_RESOURCE_GET_PRIVATE_PROPERTY_FMTS =
        CLUSCTL_RESOURCE_CODE( CLCTL_GET_PRIVATE_PROPERTY_FMTS ),

    CLUSCTL_RESOURCE_ADD_REGISTRY_CHECKPOINT =
        CLUSCTL_RESOURCE_CODE( CLCTL_ADD_REGISTRY_CHECKPOINT ),

    CLUSCTL_RESOURCE_DELETE_REGISTRY_CHECKPOINT =
        CLUSCTL_RESOURCE_CODE( CLCTL_DELETE_REGISTRY_CHECKPOINT ),

    CLUSCTL_RESOURCE_GET_REGISTRY_CHECKPOINTS =
        CLUSCTL_RESOURCE_CODE( CLCTL_GET_REGISTRY_CHECKPOINTS ),

    CLUSCTL_RESOURCE_ADD_CRYPTO_CHECKPOINT =
        CLUSCTL_RESOURCE_CODE( CLCTL_ADD_CRYPTO_CHECKPOINT ),

    CLUSCTL_RESOURCE_DELETE_CRYPTO_CHECKPOINT =
        CLUSCTL_RESOURCE_CODE( CLCTL_DELETE_CRYPTO_CHECKPOINT ),

    CLUSCTL_RESOURCE_GET_CRYPTO_CHECKPOINTS =
        CLUSCTL_RESOURCE_CODE( CLCTL_GET_CRYPTO_CHECKPOINTS ),

    CLUSCTL_RESOURCE_GET_LOADBAL_PROCESS_LIST =
        CLUSCTL_RESOURCE_CODE( CLCTL_GET_LOADBAL_PROCESS_LIST ),

    CLUSCTL_RESOURCE_GET_NETWORK_NAME =
        CLUSCTL_RESOURCE_CODE( CLCTL_GET_NETWORK_NAME ),

    CLUSCTL_RESOURCE_NETNAME_GET_VIRTUAL_SERVER_TOKEN =
        CLUSCTL_RESOURCE_CODE( CLCTL_NETNAME_GET_VIRTUAL_SERVER_TOKEN ),
        
    CLUSCTL_RESOURCE_NETNAME_SET_PWD_INFO =
        CLUSCTL_RESOURCE_CODE( CLCTL_NETNAME_SET_PWD_INFO ),
        
    CLUSCTL_RESOURCE_NETNAME_DELETE_CO =
        CLUSCTL_RESOURCE_CODE( CLCTL_NETNAME_DELETE_CO ),

    CLUSCTL_RESOURCE_NETNAME_VALIDATE_VCO =
        CLUSCTL_RESOURCE_CODE( CLCTL_NETNAME_VALIDATE_VCO ),

    CLUSCTL_RESOURCE_NETNAME_REGISTER_DNS_RECORDS =
        CLUSCTL_RESOURCE_CODE( CLCTL_NETNAME_REGISTER_DNS_RECORDS ),

    CLUSCTL_RESOURCE_GET_DNS_NAME =
        CLUSCTL_RESOURCE_CODE( CLCTL_GET_DNS_NAME ),

    CLUSCTL_RESOURCE_STORAGE_GET_DISK_INFO =
        CLUSCTL_RESOURCE_CODE( CLCTL_STORAGE_GET_DISK_INFO ),

    CLUSCTL_RESOURCE_STORAGE_IS_PATH_VALID =
        CLUSCTL_RESOURCE_CODE( CLCTL_STORAGE_IS_PATH_VALID ),

    CLUSCTL_RESOURCE_QUERY_DELETE =
        CLUSCTL_RESOURCE_CODE( CLCTL_QUERY_DELETE ),

    CLUSCTL_RESOURCE_UPGRADE_DLL =
        CLUSCTL_RESOURCE_CODE( CLCTL_RESOURCE_UPGRADE_DLL ),

    CLUSCTL_RESOURCE_IPADDRESS_RENEW_LEASE =
        CLUSCTL_RESOURCE_CODE( CLCTL_IPADDRESS_RENEW_LEASE ),

    CLUSCTL_RESOURCE_IPADDRESS_RELEASE_LEASE =
        CLUSCTL_RESOURCE_CODE( CLCTL_IPADDRESS_RELEASE_LEASE ),

    CLUSCTL_RESOURCE_ADD_REGISTRY_CHECKPOINT_64BIT =
        CLUSCTL_RESOURCE_CODE( CLCTL_ADD_REGISTRY_CHECKPOINT_64BIT ),

    CLUSCTL_RESOURCE_ADD_REGISTRY_CHECKPOINT_32BIT =
        CLUSCTL_RESOURCE_CODE( CLCTL_ADD_REGISTRY_CHECKPOINT_32BIT ),

    CLUSCTL_RESOURCE_QUERY_MAINTENANCE_MODE =
        CLUSCTL_RESOURCE_CODE( CLCTL_QUERY_MAINTENANCE_MODE ),

    CLUSCTL_RESOURCE_SET_MAINTENANCE_MODE =
        CLUSCTL_RESOURCE_CODE( CLCTL_SET_MAINTENANCE_MODE ),

    CLUSCTL_RESOURCE_STORAGE_SET_DRIVELETTER =
        CLUSCTL_RESOURCE_CODE( CLCTL_STORAGE_SET_DRIVELETTER ),

    CLUSCTL_RESOURCE_STORAGE_GET_DISK_INFO_EX =
        CLUSCTL_RESOURCE_CODE( CLCTL_STORAGE_GET_DISK_INFO_EX ),

    // Internal
    CLUSCTL_RESOURCE_DELETE =
        CLUSCTL_RESOURCE_CODE( CLCTL_DELETE ),

    CLUSCTL_RESOURCE_INSTALL_NODE =
        CLUSCTL_RESOURCE_CODE( CLCTL_INSTALL_NODE ),

    CLUSCTL_RESOURCE_EVICT_NODE =
        CLUSCTL_RESOURCE_CODE( CLCTL_EVICT_NODE ),

    CLUSCTL_RESOURCE_ADD_DEPENDENCY =
        CLUSCTL_RESOURCE_CODE( CLCTL_ADD_DEPENDENCY ),

    CLUSCTL_RESOURCE_REMOVE_DEPENDENCY =
        CLUSCTL_RESOURCE_CODE( CLCTL_REMOVE_DEPENDENCY ),

    CLUSCTL_RESOURCE_ADD_OWNER =
        CLUSCTL_RESOURCE_CODE( CLCTL_ADD_OWNER ),

    CLUSCTL_RESOURCE_REMOVE_OWNER =
        CLUSCTL_RESOURCE_CODE( CLCTL_REMOVE_OWNER ),

    CLUSCTL_RESOURCE_SET_NAME =
        CLUSCTL_RESOURCE_CODE( CLCTL_SET_NAME ),

    CLUSCTL_RESOURCE_CLUSTER_NAME_CHANGED =
        CLUSCTL_RESOURCE_CODE( CLCTL_CLUSTER_NAME_CHANGED ),

    CLUSCTL_RESOURCE_CLUSTER_VERSION_CHANGED =
        CLUSCTL_RESOURCE_CODE( CLCTL_CLUSTER_VERSION_CHANGED ),

    CLUSCTL_RESOURCE_FORCE_QUORUM =
        CLUSCTL_RESOURCE_CODE( CLCTL_FORCE_QUORUM ),

    CLUSCTL_RESOURCE_INITIALIZE =
        CLUSCTL_RESOURCE_CODE( CLCTL_INITIALIZE ),

    CLUSCTL_RESOURCE_STATE_CHANGE_REASON =
        CLUSCTL_RESOURCE_CODE( CLCTL_STATE_CHANGE_REASON ),

    CLUSCTL_RESOURCE_PROVIDER_STATE_CHANGE =
        CLUSCTL_RESOURCE_CODE( CLCTL_PROVIDER_STATE_CHANGE ),
        
} CLUSCTL_RESOURCE_CODES;

//
// Cluster Control Codes for Resource Types
//
typedef enum CLUSCTL_RESOURCE_TYPE_CODES {

    // External
    CLUSCTL_RESOURCE_TYPE_UNKNOWN =
        CLUSCTL_RESOURCE_TYPE_CODE( CLCTL_UNKNOWN ),

    CLUSCTL_RESOURCE_TYPE_GET_CHARACTERISTICS  =
        CLUSCTL_RESOURCE_TYPE_CODE( CLCTL_GET_CHARACTERISTICS ),

    CLUSCTL_RESOURCE_TYPE_GET_FLAGS =
        CLUSCTL_RESOURCE_TYPE_CODE( CLCTL_GET_FLAGS ),

    CLUSCTL_RESOURCE_TYPE_GET_CLASS_INFO =
        CLUSCTL_RESOURCE_TYPE_CODE( CLCTL_GET_CLASS_INFO ),

    CLUSCTL_RESOURCE_TYPE_GET_REQUIRED_DEPENDENCIES =
        CLUSCTL_RESOURCE_TYPE_CODE( CLCTL_GET_REQUIRED_DEPENDENCIES ),

    CLUSCTL_RESOURCE_TYPE_GET_ARB_TIMEOUT =
        CLUSCTL_RESOURCE_TYPE_CODE( CLCTL_GET_ARB_TIMEOUT ),

    CLUSCTL_RESOURCE_TYPE_ENUM_COMMON_PROPERTIES =
        CLUSCTL_RESOURCE_TYPE_CODE( CLCTL_ENUM_COMMON_PROPERTIES ),

    CLUSCTL_RESOURCE_TYPE_GET_RO_COMMON_PROPERTIES =
        CLUSCTL_RESOURCE_TYPE_CODE( CLCTL_GET_RO_COMMON_PROPERTIES ),

    CLUSCTL_RESOURCE_TYPE_GET_COMMON_PROPERTIES =
        CLUSCTL_RESOURCE_TYPE_CODE( CLCTL_GET_COMMON_PROPERTIES ),

    CLUSCTL_RESOURCE_TYPE_VALIDATE_COMMON_PROPERTIES =
        CLUSCTL_RESOURCE_TYPE_CODE( CLCTL_VALIDATE_COMMON_PROPERTIES ),

    CLUSCTL_RESOURCE_TYPE_SET_COMMON_PROPERTIES =
        CLUSCTL_RESOURCE_TYPE_CODE( CLCTL_SET_COMMON_PROPERTIES ),

    CLUSCTL_RESOURCE_TYPE_GET_COMMON_PROPERTY_FMTS =
        CLUSCTL_RESOURCE_TYPE_CODE( CLCTL_GET_COMMON_PROPERTY_FMTS ),

    CLUSCTL_RESOURCE_TYPE_GET_COMMON_RESOURCE_PROPERTY_FMTS =
        CLUSCTL_RESOURCE_TYPE_CODE( CLCTL_GET_COMMON_RESOURCE_PROPERTY_FMTS ),

    CLUSCTL_RESOURCE_TYPE_ENUM_PRIVATE_PROPERTIES =
        CLUSCTL_RESOURCE_TYPE_CODE( CLCTL_ENUM_PRIVATE_PROPERTIES ),

    CLUSCTL_RESOURCE_TYPE_GET_RO_PRIVATE_PROPERTIES =
        CLUSCTL_RESOURCE_TYPE_CODE( CLCTL_GET_RO_PRIVATE_PROPERTIES ),

    CLUSCTL_RESOURCE_TYPE_GET_PRIVATE_PROPERTIES =
        CLUSCTL_RESOURCE_TYPE_CODE( CLCTL_GET_PRIVATE_PROPERTIES ),

    CLUSCTL_RESOURCE_TYPE_SET_PRIVATE_PROPERTIES =
        CLUSCTL_RESOURCE_TYPE_CODE( CLCTL_SET_PRIVATE_PROPERTIES ),

    CLUSCTL_RESOURCE_TYPE_VALIDATE_PRIVATE_PROPERTIES =
        CLUSCTL_RESOURCE_TYPE_CODE( CLCTL_VALIDATE_PRIVATE_PROPERTIES ),

    CLUSCTL_RESOURCE_TYPE_GET_PRIVATE_PROPERTY_FMTS =
        CLUSCTL_RESOURCE_TYPE_CODE( CLCTL_GET_PRIVATE_PROPERTY_FMTS ),

    CLUSCTL_RESOURCE_TYPE_GET_PRIVATE_RESOURCE_PROPERTY_FMTS =
        CLUSCTL_RESOURCE_TYPE_CODE( CLCTL_GET_PRIVATE_RESOURCE_PROPERTY_FMTS ),

    CLUSCTL_RESOURCE_TYPE_GET_REGISTRY_CHECKPOINTS =
        CLUSCTL_RESOURCE_TYPE_CODE( CLCTL_GET_REGISTRY_CHECKPOINTS ),

    CLUSCTL_RESOURCE_TYPE_GET_CRYPTO_CHECKPOINTS =
        CLUSCTL_RESOURCE_TYPE_CODE( CLCTL_GET_CRYPTO_CHECKPOINTS ),

    CLUSCTL_RESOURCE_TYPE_STORAGE_GET_AVAILABLE_DISKS =
        CLUSCTL_RESOURCE_TYPE_CODE( CLCTL_STORAGE_GET_AVAILABLE_DISKS ),

    CLUSCTL_RESOURCE_TYPE_STORAGE_SYNC_CLUSDISK_DB =
        CLUSCTL_RESOURCE_TYPE_CODE( CLCTL_STORAGE_SYNC_CLUSDISK_DB ),

    CLUSCTL_RESOURCE_TYPE_QUERY_DELETE =
        CLUSCTL_RESOURCE_TYPE_CODE( CLCTL_QUERY_DELETE ),

    CLUSCTL_RESOURCE_TYPE_STORAGE_GET_DRIVELETTERS =
        CLUSCTL_RESOURCE_TYPE_CODE( CLCTL_STORAGE_GET_DRIVELETTERS ),

    CLUSCTL_RESOURCE_TYPE_STORAGE_GET_AVAILABLE_DISKS_EX =
        CLUSCTL_RESOURCE_TYPE_CODE( CLCTL_STORAGE_GET_AVAILABLE_DISKS_EX ),

    CLUSCTL_RESOURCE_TYPE_STORAGE_REMAP_DRIVELETTER =
        CLUSCTL_RESOURCE_TYPE_CODE( CLCTL_STORAGE_REMAP_DRIVELETTER ),

    // Internal
    CLUSCTL_RESOURCE_TYPE_INSTALL_NODE =
        CLUSCTL_RESOURCE_TYPE_CODE( CLCTL_INSTALL_NODE ),

    CLUSCTL_RESOURCE_TYPE_EVICT_NODE =
        CLUSCTL_RESOURCE_TYPE_CODE( CLCTL_EVICT_NODE ),

    CLUSCTL_RESOURCE_TYPE_CLUSTER_VERSION_CHANGED =
        CLUSCTL_RESOURCE_TYPE_CODE( CLCTL_CLUSTER_VERSION_CHANGED ),

    CLUSCTL_RESOURCE_TYPE_FIXUP_ON_UPGRADE =
        CLUSCTL_RESOURCE_TYPE_CODE( CLCTL_FIXUP_ON_UPGRADE ),

    CLUSCTL_RESOURCE_TYPE_STARTING_PHASE1 =
        CLUSCTL_RESOURCE_TYPE_CODE( CLCTL_STARTING_PHASE1 ),

    CLUSCTL_RESOURCE_TYPE_STARTING_PHASE2 =
        CLUSCTL_RESOURCE_TYPE_CODE( CLCTL_STARTING_PHASE2 ),

    CLUSCTL_RESOURCE_TYPE_HOLD_IO =
        CLUSCTL_RESOURCE_TYPE_CODE( CLCTL_HOLD_IO ),

    CLUSCTL_RESOURCE_TYPE_RESUME_IO =
        CLUSCTL_RESOURCE_TYPE_CODE( CLCTL_RESUME_IO )


} CLUSCTL_RESOURCE_TYPE_CODES;

//
// Cluster Control Codes for Groups
//
typedef enum CLUSCTL_GROUP_CODES {

    // External
    CLUSCTL_GROUP_UNKNOWN =
        CLUSCTL_GROUP_CODE( CLCTL_UNKNOWN ),

    CLUSCTL_GROUP_GET_CHARACTERISTICS =
        CLUSCTL_GROUP_CODE( CLCTL_GET_CHARACTERISTICS ),

    CLUSCTL_GROUP_GET_FLAGS =
        CLUSCTL_GROUP_CODE( CLCTL_GET_FLAGS ),

    CLUSCTL_GROUP_GET_NAME =
        CLUSCTL_GROUP_CODE( CLCTL_GET_NAME ),

    CLUSCTL_GROUP_GET_ID =
        CLUSCTL_GROUP_CODE( CLCTL_GET_ID ),

    CLUSCTL_GROUP_ENUM_COMMON_PROPERTIES =
        CLUSCTL_GROUP_CODE( CLCTL_ENUM_COMMON_PROPERTIES ),

    CLUSCTL_GROUP_GET_RO_COMMON_PROPERTIES =
        CLUSCTL_GROUP_CODE( CLCTL_GET_RO_COMMON_PROPERTIES ),

    CLUSCTL_GROUP_GET_COMMON_PROPERTIES =
        CLUSCTL_GROUP_CODE( CLCTL_GET_COMMON_PROPERTIES ),

    CLUSCTL_GROUP_SET_COMMON_PROPERTIES =
        CLUSCTL_GROUP_CODE( CLCTL_SET_COMMON_PROPERTIES ),

    CLUSCTL_GROUP_VALIDATE_COMMON_PROPERTIES =
        CLUSCTL_GROUP_CODE( CLCTL_VALIDATE_COMMON_PROPERTIES ),

    CLUSCTL_GROUP_ENUM_PRIVATE_PROPERTIES =
        CLUSCTL_GROUP_CODE( CLCTL_ENUM_PRIVATE_PROPERTIES ),

    CLUSCTL_GROUP_GET_RO_PRIVATE_PROPERTIES =
        CLUSCTL_GROUP_CODE( CLCTL_GET_RO_PRIVATE_PROPERTIES ),

    CLUSCTL_GROUP_GET_PRIVATE_PROPERTIES =
        CLUSCTL_GROUP_CODE( CLCTL_GET_PRIVATE_PROPERTIES ),

    CLUSCTL_GROUP_SET_PRIVATE_PROPERTIES =
        CLUSCTL_GROUP_CODE( CLCTL_SET_PRIVATE_PROPERTIES ),

    CLUSCTL_GROUP_VALIDATE_PRIVATE_PROPERTIES =
        CLUSCTL_GROUP_CODE( CLCTL_VALIDATE_PRIVATE_PROPERTIES ),

    CLUSCTL_GROUP_QUERY_DELETE =
        CLUSCTL_GROUP_CODE( CLCTL_QUERY_DELETE ),

    CLUSCTL_GROUP_GET_COMMON_PROPERTY_FMTS=
        CLUSCTL_GROUP_CODE( CLCTL_GET_COMMON_PROPERTY_FMTS ),

    CLUSCTL_GROUP_GET_PRIVATE_PROPERTY_FMTS=
        CLUSCTL_GROUP_CODE( CLCTL_GET_PRIVATE_PROPERTY_FMTS )

    // Internal

} CLUSCTL_GROUP_CODES;

//
// Cluster Control Codes for Nodes
//
typedef enum CLUSCTL_NODE_CODES {

    // External
    CLUSCTL_NODE_UNKNOWN =
        CLUSCTL_NODE_CODE( CLCTL_UNKNOWN ),

    CLUSCTL_NODE_GET_CHARACTERISTICS =
        CLUSCTL_NODE_CODE( CLCTL_GET_CHARACTERISTICS ),

    CLUSCTL_NODE_GET_FLAGS =
        CLUSCTL_NODE_CODE( CLCTL_GET_FLAGS ),

    CLUSCTL_NODE_GET_NAME =
        CLUSCTL_NODE_CODE( CLCTL_GET_NAME ),

    CLUSCTL_NODE_GET_ID =
        CLUSCTL_NODE_CODE( CLCTL_GET_ID ),

    CLUSCTL_NODE_ENUM_COMMON_PROPERTIES =
        CLUSCTL_NODE_CODE( CLCTL_ENUM_COMMON_PROPERTIES ),

    CLUSCTL_NODE_GET_RO_COMMON_PROPERTIES =
        CLUSCTL_NODE_CODE( CLCTL_GET_RO_COMMON_PROPERTIES ),

    CLUSCTL_NODE_GET_COMMON_PROPERTIES =
        CLUSCTL_NODE_CODE( CLCTL_GET_COMMON_PROPERTIES ),

    CLUSCTL_NODE_SET_COMMON_PROPERTIES =
        CLUSCTL_NODE_CODE( CLCTL_SET_COMMON_PROPERTIES ),

    CLUSCTL_NODE_VALIDATE_COMMON_PROPERTIES =
        CLUSCTL_NODE_CODE( CLCTL_VALIDATE_COMMON_PROPERTIES ),

    CLUSCTL_NODE_ENUM_PRIVATE_PROPERTIES =
        CLUSCTL_NODE_CODE( CLCTL_ENUM_PRIVATE_PROPERTIES ),

    CLUSCTL_NODE_GET_RO_PRIVATE_PROPERTIES =
        CLUSCTL_NODE_CODE( CLCTL_GET_RO_PRIVATE_PROPERTIES ),

    CLUSCTL_NODE_GET_PRIVATE_PROPERTIES =
        CLUSCTL_NODE_CODE( CLCTL_GET_PRIVATE_PROPERTIES ),

    CLUSCTL_NODE_SET_PRIVATE_PROPERTIES =
        CLUSCTL_NODE_CODE( CLCTL_SET_PRIVATE_PROPERTIES ),

    CLUSCTL_NODE_VALIDATE_PRIVATE_PROPERTIES =
        CLUSCTL_NODE_CODE( CLCTL_VALIDATE_PRIVATE_PROPERTIES ),

    CLUSCTL_NODE_GET_COMMON_PROPERTY_FMTS=
        CLUSCTL_NODE_CODE( CLCTL_GET_COMMON_PROPERTY_FMTS ),

    CLUSCTL_NODE_GET_PRIVATE_PROPERTY_FMTS=
        CLUSCTL_NODE_CODE( CLCTL_GET_PRIVATE_PROPERTY_FMTS ),

    CLUSCTL_NODE_GET_CLUSTER_SERVICE_ACCOUNT_NAME =
        CLUSCTL_NODE_CODE( CLCTL_GET_CLUSTER_SERVICE_ACCOUNT_NAME )


} CLUSCTL_NODE_CODES;

//
// Cluster Control Codes for Networks
//
typedef enum CLUSCTL_NETWORK_CODES {

    // External
    CLUSCTL_NETWORK_UNKNOWN =
        CLUSCTL_NETWORK_CODE( CLCTL_UNKNOWN ),

    CLUSCTL_NETWORK_GET_CHARACTERISTICS =
        CLUSCTL_NETWORK_CODE( CLCTL_GET_CHARACTERISTICS ),

    CLUSCTL_NETWORK_GET_FLAGS =
        CLUSCTL_NETWORK_CODE( CLCTL_GET_FLAGS ),

    CLUSCTL_NETWORK_GET_NAME =
        CLUSCTL_NETWORK_CODE( CLCTL_GET_NAME ),

    CLUSCTL_NETWORK_GET_ID =
        CLUSCTL_NETWORK_CODE( CLCTL_GET_ID ),

    CLUSCTL_NETWORK_ENUM_COMMON_PROPERTIES =
        CLUSCTL_NETWORK_CODE( CLCTL_ENUM_COMMON_PROPERTIES ),

    CLUSCTL_NETWORK_GET_RO_COMMON_PROPERTIES =
        CLUSCTL_NETWORK_CODE( CLCTL_GET_RO_COMMON_PROPERTIES ),

    CLUSCTL_NETWORK_GET_COMMON_PROPERTIES =
        CLUSCTL_NETWORK_CODE( CLCTL_GET_COMMON_PROPERTIES ),

    CLUSCTL_NETWORK_SET_COMMON_PROPERTIES =
        CLUSCTL_NETWORK_CODE( CLCTL_SET_COMMON_PROPERTIES ),

    CLUSCTL_NETWORK_VALIDATE_COMMON_PROPERTIES =
        CLUSCTL_NETWORK_CODE( CLCTL_VALIDATE_COMMON_PROPERTIES ),

    CLUSCTL_NETWORK_ENUM_PRIVATE_PROPERTIES =
        CLUSCTL_NETWORK_CODE( CLCTL_ENUM_PRIVATE_PROPERTIES ),

    CLUSCTL_NETWORK_GET_RO_PRIVATE_PROPERTIES =
        CLUSCTL_NETWORK_CODE( CLCTL_GET_RO_PRIVATE_PROPERTIES ),

    CLUSCTL_NETWORK_GET_PRIVATE_PROPERTIES =
        CLUSCTL_NETWORK_CODE( CLCTL_GET_PRIVATE_PROPERTIES ),

    CLUSCTL_NETWORK_SET_PRIVATE_PROPERTIES =
        CLUSCTL_NETWORK_CODE( CLCTL_SET_PRIVATE_PROPERTIES ),

    CLUSCTL_NETWORK_VALIDATE_PRIVATE_PROPERTIES =
        CLUSCTL_NETWORK_CODE( CLCTL_VALIDATE_PRIVATE_PROPERTIES ),

    CLUSCTL_NETWORK_GET_COMMON_PROPERTY_FMTS=
        CLUSCTL_NETWORK_CODE( CLCTL_GET_COMMON_PROPERTY_FMTS ),

    CLUSCTL_NETWORK_GET_PRIVATE_PROPERTY_FMTS=
        CLUSCTL_NETWORK_CODE( CLCTL_GET_PRIVATE_PROPERTY_FMTS )

} CLUSCTL_NETWORK_CODES;

//
// Cluster Control Codes for Network Interfaces
//
typedef enum CLUSCTL_NETINTERFACE_CODES {

    // External
    CLUSCTL_NETINTERFACE_UNKNOWN =
        CLUSCTL_NETINTERFACE_CODE( CLCTL_UNKNOWN ),

    CLUSCTL_NETINTERFACE_GET_CHARACTERISTICS =
        CLUSCTL_NETINTERFACE_CODE( CLCTL_GET_CHARACTERISTICS ),

    CLUSCTL_NETINTERFACE_GET_FLAGS =
        CLUSCTL_NETINTERFACE_CODE( CLCTL_GET_FLAGS ),

    CLUSCTL_NETINTERFACE_GET_NAME =
        CLUSCTL_NETINTERFACE_CODE( CLCTL_GET_NAME ),

    CLUSCTL_NETINTERFACE_GET_ID =
        CLUSCTL_NETINTERFACE_CODE( CLCTL_GET_ID ),

    CLUSCTL_NETINTERFACE_GET_NODE =
        CLUSCTL_NETINTERFACE_CODE( CLCTL_GET_NODE ),

    CLUSCTL_NETINTERFACE_GET_NETWORK =
        CLUSCTL_NETINTERFACE_CODE( CLCTL_GET_NETWORK ),

    CLUSCTL_NETINTERFACE_ENUM_COMMON_PROPERTIES =
        CLUSCTL_NETINTERFACE_CODE( CLCTL_ENUM_COMMON_PROPERTIES ),

    CLUSCTL_NETINTERFACE_GET_RO_COMMON_PROPERTIES =
        CLUSCTL_NETINTERFACE_CODE( CLCTL_GET_RO_COMMON_PROPERTIES ),

    CLUSCTL_NETINTERFACE_GET_COMMON_PROPERTIES =
        CLUSCTL_NETINTERFACE_CODE( CLCTL_GET_COMMON_PROPERTIES ),

    CLUSCTL_NETINTERFACE_SET_COMMON_PROPERTIES =
        CLUSCTL_NETINTERFACE_CODE( CLCTL_SET_COMMON_PROPERTIES ),

    CLUSCTL_NETINTERFACE_VALIDATE_COMMON_PROPERTIES =
        CLUSCTL_NETINTERFACE_CODE( CLCTL_VALIDATE_COMMON_PROPERTIES ),

    CLUSCTL_NETINTERFACE_ENUM_PRIVATE_PROPERTIES =
        CLUSCTL_NETINTERFACE_CODE( CLCTL_ENUM_PRIVATE_PROPERTIES ),

    CLUSCTL_NETINTERFACE_GET_RO_PRIVATE_PROPERTIES =
        CLUSCTL_NETINTERFACE_CODE( CLCTL_GET_RO_PRIVATE_PROPERTIES ),

    CLUSCTL_NETINTERFACE_GET_PRIVATE_PROPERTIES =
        CLUSCTL_NETINTERFACE_CODE( CLCTL_GET_PRIVATE_PROPERTIES ),

    CLUSCTL_NETINTERFACE_SET_PRIVATE_PROPERTIES =
        CLUSCTL_NETINTERFACE_CODE( CLCTL_SET_PRIVATE_PROPERTIES ),

    CLUSCTL_NETINTERFACE_VALIDATE_PRIVATE_PROPERTIES =
        CLUSCTL_NETINTERFACE_CODE( CLCTL_VALIDATE_PRIVATE_PROPERTIES ),

    CLUSCTL_NETINTERFACE_GET_COMMON_PROPERTY_FMTS=
        CLUSCTL_NETINTERFACE_CODE( CLCTL_GET_COMMON_PROPERTY_FMTS ),

    CLUSCTL_NETINTERFACE_GET_PRIVATE_PROPERTY_FMTS=
        CLUSCTL_NETINTERFACE_CODE( CLCTL_GET_PRIVATE_PROPERTY_FMTS )

} CLUSCTL_NETINTERFACE_CODES;

//
// Cluster Control Codes for Nodes
//
typedef enum CLUSCTL_CLUSTER_CODES {

    // External
    CLUSCTL_CLUSTER_UNKNOWN =
        CLUSCTL_CLUSTER_CODE( CLCTL_UNKNOWN ),

    CLUSCTL_CLUSTER_GET_FQDN =
        CLUSCTL_CLUSTER_CODE( CLCTL_GET_FQDN ),

    CLUSCTL_CLUSTER_ENUM_COMMON_PROPERTIES =
        CLUSCTL_CLUSTER_CODE( CLCTL_ENUM_COMMON_PROPERTIES ),

    CLUSCTL_CLUSTER_GET_RO_COMMON_PROPERTIES =
        CLUSCTL_CLUSTER_CODE( CLCTL_GET_RO_COMMON_PROPERTIES ),

    CLUSCTL_CLUSTER_GET_COMMON_PROPERTIES =
        CLUSCTL_CLUSTER_CODE( CLCTL_GET_COMMON_PROPERTIES ),

    CLUSCTL_CLUSTER_SET_COMMON_PROPERTIES =
        CLUSCTL_CLUSTER_CODE( CLCTL_SET_COMMON_PROPERTIES ),

    CLUSCTL_CLUSTER_VALIDATE_COMMON_PROPERTIES =
        CLUSCTL_CLUSTER_CODE( CLCTL_VALIDATE_COMMON_PROPERTIES ),

    CLUSCTL_CLUSTER_ENUM_PRIVATE_PROPERTIES =
        CLUSCTL_CLUSTER_CODE( CLCTL_ENUM_PRIVATE_PROPERTIES ),

    CLUSCTL_CLUSTER_GET_RO_PRIVATE_PROPERTIES =
        CLUSCTL_CLUSTER_CODE( CLCTL_GET_RO_PRIVATE_PROPERTIES ),

    CLUSCTL_CLUSTER_GET_PRIVATE_PROPERTIES =
        CLUSCTL_CLUSTER_CODE( CLCTL_GET_PRIVATE_PROPERTIES ),

    CLUSCTL_CLUSTER_SET_PRIVATE_PROPERTIES =
        CLUSCTL_CLUSTER_CODE( CLCTL_SET_PRIVATE_PROPERTIES ),

    CLUSCTL_CLUSTER_VALIDATE_PRIVATE_PROPERTIES =
        CLUSCTL_CLUSTER_CODE( CLCTL_VALIDATE_PRIVATE_PROPERTIES ),

    CLUSCTL_CLUSTER_GET_COMMON_PROPERTY_FMTS=
        CLUSCTL_CLUSTER_CODE( CLCTL_GET_COMMON_PROPERTY_FMTS ),

    CLUSCTL_CLUSTER_GET_PRIVATE_PROPERTY_FMTS=
        CLUSCTL_CLUSTER_CODE( CLCTL_GET_PRIVATE_PROPERTY_FMTS ),

    CLUSCTL_CLUSTER_CHECK_VOTER_EVICT=
        CLUSCTL_CLUSTER_CODE( CLCTL_CHECK_VOTER_EVICT ),

    CLUSCTL_CLUSTER_CHECK_VOTER_DOWN=
        CLUSCTL_CLUSTER_CODE( CLCTL_CHECK_VOTER_DOWN ),

    CLUSCTL_CLUSTER_SHUTDOWN=
        CLUSCTL_CLUSTER_CODE( CLCTL_SHUTDOWN ),

} CLUSCTL_CLUSTER_CODES;

//
// Cluster Resource Class types
//
typedef enum CLUSTER_RESOURCE_CLASS {
    CLUS_RESCLASS_UNKNOWN = 0,
    CLUS_RESCLASS_STORAGE,
    CLUS_RESCLASS_NETWORK,
    CLUS_RESCLASS_USER = 32768
} CLUSTER_RESOURCE_CLASS;

//
// Define Resource SubClass bits
//
// legacy subclass struct
//
typedef enum CLUS_RESSUBCLASS {
    CLUS_RESSUBCLASS_SHARED =                       0x80000000
} CLUS_RESSUBCLASS;

typedef enum CLUS_RESSUBCLASS_STORAGE {
    CLUS_RESSUBCLASS_STORAGE_SHARED_BUS =           0x80000000
} CLUS_RESSUBCLASS_STORAGE;

typedef enum CLUS_RESSUBCLASS_NETWORK {
    CLUS_RESSUBCLASS_NETWORK_INTERNET_PROTOCOL =    0x80000000    // Identifies IP address providers
} CLUS_RESSUBCLASS_NETWORK;

//
// Cluster Characteristics
//
typedef enum CLUS_CHARACTERISTICS {
    CLUS_CHAR_UNKNOWN                       = 0x00000000,
    CLUS_CHAR_QUORUM                        = 0x00000001,
    CLUS_CHAR_DELETE_REQUIRES_ALL_NODES     = 0x00000002,
    CLUS_CHAR_LOCAL_QUORUM                  = 0x00000004,
    CLUS_CHAR_LOCAL_QUORUM_DEBUG            = 0x00000008,
    CLUS_CHAR_REQUIRES_STATE_CHANGE_REASON  = 0x00000010
} CLUS_CHARACTERISTICS;

//
// Cluster Flags
//
typedef enum CLUS_FLAGS {
    CLUS_FLAG_CORE          = 0x00000001
}  CLUS_FLAGS;


//
// Cluster Resource Property Helper Structures
//

#if ( !MIDL_PASS && !__midl )

// Property syntax.  Used for property names and values.
typedef union CLUSPROP_SYNTAX {
    DWORD dw;
    struct {
        WORD wFormat;
        WORD wType;
    };
} CLUSPROP_SYNTAX, *PCLUSPROP_SYNTAX;

// Property value.
typedef struct CLUSPROP_VALUE {
    CLUSPROP_SYNTAX Syntax;
    DWORD           cbLength;
} CLUSPROP_VALUE, *PCLUSPROP_VALUE;

// Binary property value.
#ifdef __cplusplus
typedef struct CLUSPROP_BINARY : public CLUSPROP_VALUE {
#else
typedef struct CLUSPROP_BINARY {
    CLUSPROP_VALUE;
#endif
    BYTE            rgb[];
} CLUSPROP_BINARY, *PCLUSPROP_BINARY;

// WORD property value.
#ifdef __cplusplus
typedef struct CLUSPROP_WORD : public CLUSPROP_VALUE {
#else
typedef struct CLUSPROP_WORD {
    CLUSPROP_VALUE;
#endif
    WORD            w;
} CLUSPROP_WORD, *PCLUSPROP_WORD;

// DWORD property value.
#ifdef __cplusplus
typedef struct CLUSPROP_DWORD : public CLUSPROP_VALUE {
#else
typedef struct CLUSPROP_DWORD {
    CLUSPROP_VALUE;
#endif
    DWORD           dw;
} CLUSPROP_DWORD, *PCLUSPROP_DWORD;

// LONG property value.
#ifdef __cplusplus
typedef struct CLUSPROP_LONG : public CLUSPROP_VALUE {
#else
typedef struct CLUSPROP_LONG {
    CLUSPROP_VALUE;
#endif
    LONG           l;
} CLUSPROP_LONG, *PCLUSPROP_LONG;

// String property value.
#ifdef __cplusplus
typedef struct CLUSPROP_SZ : public CLUSPROP_VALUE {
#else
typedef struct CLUSPROP_SZ {
    CLUSPROP_VALUE;
#endif
    WCHAR           sz[];
} CLUSPROP_SZ, *PCLUSPROP_SZ;

// Multiple string property value.
typedef CLUSPROP_SZ CLUSPROP_MULTI_SZ, *PCLUSPROP_MULTI_SZ;

// Property name.
typedef CLUSPROP_SZ CLUSPROP_PROPERTY_NAME, *PCLUSPROP_PROPERTY_NAME;

// Unsigned large Integer property value.
#ifdef __cplusplus
typedef struct CLUSPROP_ULARGE_INTEGER
    : public CLUSPROP_VALUE {
#else
typedef struct CLUSPROP_ULARGE_INTEGER {
    CLUSPROP_VALUE;
#endif
    ULARGE_INTEGER li;
} CLUSPROP_ULARGE_INTEGER;

typedef CLUSPROP_ULARGE_INTEGER UNALIGNED *PCLUSPROP_ULARGE_INTEGER;

// Signed large Integer property value.
#ifdef __cplusplus
typedef struct CLUSPROP_LARGE_INTEGER
    : public CLUSPROP_VALUE {
#else
typedef struct CLUSPROP_LARGE_INTEGER {
    CLUSPROP_VALUE;
#endif
    LARGE_INTEGER li;
} CLUSPROP_LARGE_INTEGER;

typedef CLUSPROP_LARGE_INTEGER UNALIGNED *PCLUSPROP_LARGE_INTEGER;

// Security Descriptor property value.
#ifdef __cplusplus
typedef struct CLUSPROP_SECURITY_DESCRIPTOR : public CLUSPROP_VALUE {
#else
typedef struct CLUSPROP_SECURITY_DESCRIPTOR {
    CLUSPROP_VALUE;
#endif
    union {
        SECURITY_DESCRIPTOR_RELATIVE    sd;
        BYTE                            rgbSecurityDescriptor[];
    };
} CLUSPROP_SECURITY_DESCRIPTOR, *PCLUSPROP_SECURITY_DESCRIPTOR;

// FILETIME Time property value.
#ifdef __cplusplus
typedef struct CLUSPROP_FILETIME 
    : public CLUSPROP_VALUE {
#else
typedef struct CLUSPROP_FILETIME {
    CLUSPROP_VALUE;
#endif
    FILETIME ft;
} CLUSPROP_FILETIME, *PCLUSPROP_FILETIME;

// Resource class info returned by CLCTL_GET_CLASS_INFO control functions.
typedef struct CLUS_RESOURCE_CLASS_INFO {
    union {
        struct {
            union {
                DWORD                   dw;
                CLUSTER_RESOURCE_CLASS  rc;
                };
            DWORD           SubClass;
        };
        ULARGE_INTEGER      li;
    };
} CLUS_RESOURCE_CLASS_INFO, *PCLUS_RESOURCE_CLASS_INFO;

// Resource class property value.
#ifdef __cplusplus
typedef struct CLUSPROP_RESOURCE_CLASS
    : public CLUSPROP_VALUE {
#else
typedef struct CLUSPROP_RESOURCE_CLASS {
    CLUSPROP_VALUE;
#endif
    CLUSTER_RESOURCE_CLASS rc;
} CLUSPROP_RESOURCE_CLASS, *PCLUSPROP_RESOURCE_CLASS;

// Resource class info property value.
#ifdef __cplusplus
typedef struct CLUSPROP_RESOURCE_CLASS_INFO
    : public CLUSPROP_VALUE
    , public CLUS_RESOURCE_CLASS_INFO {
#else
typedef struct CLUSPROP_RESOURCE_CLASS_INFO {
    CLUSPROP_VALUE;
    CLUS_RESOURCE_CLASS_INFO;
#endif
} CLUSPROP_RESOURCE_CLASS_INFO, *PCLUSPROP_RESOURCE_CLASS_INFO;

// One entry from list returned by CLCTL_GET_REQUIRED_DEPENDENCIES control functions.
typedef union CLUSPROP_REQUIRED_DEPENDENCY {
    CLUSPROP_VALUE          Value;
    CLUSPROP_RESOURCE_CLASS ResClass;
    CLUSPROP_SZ             ResTypeName;
} CLUSPROP_REQUIRED_DEPENDENCY, *PCLUSPROP_REQUIRED_DEPENDENCY;

typedef CLUSPROP_DWORD CLUSPROP_DISK_NUMBER, *PCLUSPROP_DISK_NUMBER;

#endif // MIDL_PASS
#endif // _CLUSTER_API_TYPES_

#ifndef _CLUSTER_API_TYPES_

// Disk partition information flags.
typedef enum CLUSPROP_PIFLAGS {
    CLUSPROP_PIFLAG_STICKY          = 0x00000001,
    CLUSPROP_PIFLAG_REMOVABLE       = 0x00000002,
    CLUSPROP_PIFLAG_USABLE          = 0x00000004,
    CLUSPROP_PIFLAG_DEFAULT_QUORUM  = 0x00000008
} CLUSPROP_PIFLAGS;

#if ( !MIDL_PASS && !__midl )
//force quorum information, useful for QON type resources
//to be able to continue operation without the quorum
typedef struct CLUS_FORCE_QUORUM_INFO {
    DWORD           dwSize;             // size of this struct including the nodes list.
    DWORD           dwNodeBitMask;      // a bit mask representing the max assumed node set
    DWORD           dwMaxNumberofNodes; // the number of bits set in the mask
    WCHAR           multiszNodeList[1]; // Multi sz list of nodes
} CLUS_FORCE_QUORUM_INFO, *PCLUS_FORCE_QUORUM_INFO;

// Disk partition information.
typedef struct CLUS_PARTITION_INFO {
    DWORD           dwFlags;
    WCHAR           szDeviceName[MAX_PATH];
    WCHAR           szVolumeLabel[MAX_PATH];
    DWORD           dwSerialNumber;
    DWORD           rgdwMaximumComponentLength;
    DWORD           dwFileSystemFlags;
    WCHAR           szFileSystem[32];
} CLUS_PARTITION_INFO, *PCLUS_PARTITION_INFO;

// Disk partition information ex
typedef struct CLUS_PARTITION_INFO_EX {
    DWORD           dwFlags;
    WCHAR           szDeviceName[MAX_PATH];
    WCHAR           szVolumeLabel[MAX_PATH];
    DWORD           dwSerialNumber;
    DWORD           rgdwMaximumComponentLength;
    DWORD           dwFileSystemFlags;
    WCHAR           szFileSystem[32];
    ULARGE_INTEGER  TotalSizeInBytes;
    ULARGE_INTEGER  FreeSizeInBytes;
    DWORD           DeviceNumber;
    DWORD           PartitionNumber;
    GUID            VolumeGuid;
} CLUS_PARTITION_INFO_EX, *PCLUS_PARTITION_INFO_EX;

// Disk partition information property value.
#ifdef __cplusplus
typedef struct CLUSPROP_PARTITION_INFO
    : public CLUSPROP_VALUE
    , public CLUS_PARTITION_INFO {
#else
typedef struct CLUSPROP_PARTITION_INFO {
    CLUSPROP_VALUE;
    CLUS_PARTITION_INFO;
#endif
} CLUSPROP_PARTITION_INFO, *PCLUSPROP_PARTITION_INFO;

// Disk partition information ex property value.
#ifdef __cplusplus
typedef struct CLUSPROP_PARTITION_INFO_EX
    : public CLUSPROP_VALUE
    , public CLUS_PARTITION_INFO_EX {
#else
typedef struct CLUSPROP_PARTITION_INFO_EX {
    CLUSPROP_VALUE;
    CLUS_PARTITION_INFO_EX;
#endif
} CLUSPROP_PARTITION_INFO_EX;

typedef CLUSPROP_PARTITION_INFO_EX UNALIGNED *PCLUSPROP_PARTITION_INFO_EX;
//
// FT set information.
//
typedef struct CLUS_FTSET_INFO {
    DWORD           dwRootSignature;
    DWORD           dwFtType;
} CLUS_FTSET_INFO, *PCLUS_FTSET_INFO;

// Disk partition information property value.
#ifdef __cplusplus
typedef struct CLUSPROP_FTSET_INFO
    : public CLUSPROP_VALUE
    , public CLUS_FTSET_INFO {
#else
typedef struct CLUSPROP_FTSET_INFO {
    CLUSPROP_VALUE;
    CLUS_FTSET_INFO;
#endif
} CLUSPROP_FTSET_INFO, *PCLUSPROP_FTSET_INFO;

// Disk Signature property value.
typedef CLUSPROP_DWORD CLUSPROP_DISK_SIGNATURE, *PCLUSPROP_DISK_SIGNATURE;

// SCSI Address.
typedef struct CLUS_SCSI_ADDRESS {
    union {
        struct {
            UCHAR PortNumber;
            UCHAR PathId;
            UCHAR TargetId;
            UCHAR Lun;
        };
        DWORD   dw;
    };
} CLUS_SCSI_ADDRESS, *PCLUS_SCSI_ADDRESS;

// SCSI Address property value.
#ifdef __cplusplus
typedef struct CLUSPROP_SCSI_ADDRESS
    : public CLUSPROP_VALUE
    , public CLUS_SCSI_ADDRESS {
#else
typedef struct CLUSPROP_SCSI_ADDRESS {
    CLUSPROP_VALUE;
    CLUS_SCSI_ADDRESS;
#endif
} CLUSPROP_SCSI_ADDRESS, *PCLUSPROP_SCSI_ADDRESS;

//
// input structure for CLUSCTL_RESOURCE_NETNAME_GET_VIRTUAL_SERVER_TOKEN
//
typedef struct CLUS_NETNAME_VS_TOKEN_INFO {
    DWORD ProcessID;
    DWORD DesiredAccess;
    BOOL  InheritHandle;
} CLUS_NETNAME_VS_TOKEN_INFO, *PCLUS_NETNAME_VS_TOKEN_INFO;


//
// input structure for CLUSCTL_RESOURCE_NETNAME_SET_PWD
//
#define MAX_OBJECTID 64
#define MAX_CO_PASSWORD_LENGTH 16
#define GUID_PRESENT 0x1
#define CREATEDC_PRESENT 0x2

#define MAX_CREATINGDC_LENGTH 256

typedef struct CLUS_NETNAME_PWD_INFO {
    DWORD Flags;
    WCHAR Password[MAX_CO_PASSWORD_LENGTH];
    WCHAR CreatingDC[MAX_CREATINGDC_LENGTH+2];  // including the '\\' prefix
    WCHAR ObjectGuid[MAX_OBJECTID];                          //
} CLUS_NETNAME_PWD_INFO, *PCLUS_NETNAME_PWD_INFO;



//
// input/output structure associated with Maintenance Mode
//
typedef struct CLUS_MAINTENANCE_MODE_INFO {
    BOOL  InMaintenance;
} CLUS_MAINTENANCE_MODE_INFO, *PCLUS_MAINTENANCE_MODE_INFO;

#define MAINTENANCE_MODE_V2_SIG 0xabbaf00f

typedef enum _MAINTENANCE_MODE_TYPE_ENUM {
    MaintenanceModeTypeDisableIsAliveCheck=1,
    MaintenanceModeTypeOfflineResource=2,
    MaintenanceModeTypeUnclusterResource=3,
} MAINTENANCE_MODE_TYPE_ENUM, *PMAINTENANCE_MODE_TYPE_ENUM;

typedef struct _CLUS_MAINTENANCE_MODE_INFOEX {
    BOOL                        InMaintenance;
    MAINTENANCE_MODE_TYPE_ENUM  MaintainenceModeType;
    CLUSTER_RESOURCE_STATE      InternalState;
    DWORD                       Signature;
} CLUS_MAINTENANCE_MODE_INFOEX, *PCLUS_MAINTENANCE_MODE_INFOEX;

typedef struct _CLUS_STORAGE_SET_DRIVELETTER {
    DWORD    PartitionNumber;
    DWORD    DriveLetterMask;
} CLUS_STORAGE_SET_DRIVELETTER, *PCLUS_STORAGE_SET_DRIVELETTER;

typedef struct _CLUS_STORAGE_GET_AVAILABLE_DRIVELETTERS {
    DWORD    AvailDrivelettersMask;
} CLUS_STORAGE_GET_AVAILABLE_DRIVELETTERS, *PCLUS_STORAGE_GET_AVAILABLE_DRIVELETTERS;

typedef struct _CLUS_STORAGE_REMAP_DRIVELETTER {
    DWORD    CurrentDriveLetterMask;
    DWORD    TargetDriveLetterMask;
} CLUS_STORAGE_REMAP_DRIVELETTER, *PCLUS_STORAGE_REMAP_DRIVELETTER;

typedef struct _CLUS_PROVIDER_STATE_CHANGE_INFO {
    DWORD                   dwSize;             // size of this struct including the provider name.
    CLUSTER_RESOURCE_STATE  resourceState;
    WCHAR                   szProviderId[1];
} CLUS_PROVIDER_STATE_CHANGE_INFO, *PCLUS_PROVIDER_STATE_CHANGE_INFO;

// Beginning of a property list.
typedef struct CLUSPROP_LIST {
    DWORD                   nPropertyCount;
    CLUSPROP_PROPERTY_NAME  PropertyName;
} CLUSPROP_LIST, *PCLUSPROP_LIST;

//
// values for IP Address' EnableNetbios property
//
typedef enum CLUSPROP_IPADDR_ENABLENETBIOS {
    CLUSPROP_IPADDR_ENABLENETBIOS_DISABLED = 0,
    CLUSPROP_IPADDR_ENABLENETBIOS_ENABLED,
    CLUSPROP_IPADDR_ENABLENETBIOS_TRACK_NIC
} CLUSPROP_IPADDR_ENABLENETBIOS;

// Helper for building or parsing a property list buffer.
typedef union CLUSPROP_BUFFER_HELPER {
    BYTE *                          pb;
    WORD *                          pw;
    DWORD *                         pdw;
    LONG *                          pl;
    LPWSTR                          psz;
    PCLUSPROP_LIST                  pList;
    PCLUSPROP_SYNTAX                pSyntax;
    PCLUSPROP_PROPERTY_NAME         pName;
    PCLUSPROP_VALUE                 pValue;
    PCLUSPROP_BINARY                pBinaryValue;
    PCLUSPROP_WORD                  pWordValue;
    PCLUSPROP_DWORD                 pDwordValue;
    PCLUSPROP_LONG                  pLongValue;
    PCLUSPROP_ULARGE_INTEGER        pULargeIntegerValue;
    PCLUSPROP_LARGE_INTEGER         pLargeIntegerValue;
    PCLUSPROP_SZ                    pStringValue;
    PCLUSPROP_MULTI_SZ              pMultiSzValue;
    PCLUSPROP_SECURITY_DESCRIPTOR   pSecurityDescriptor;
    PCLUSPROP_RESOURCE_CLASS        pResourceClassValue;
    PCLUSPROP_RESOURCE_CLASS_INFO   pResourceClassInfoValue;
    PCLUSPROP_DISK_SIGNATURE        pDiskSignatureValue;
    PCLUSPROP_SCSI_ADDRESS          pScsiAddressValue;
    PCLUSPROP_DISK_NUMBER           pDiskNumberValue;
    PCLUSPROP_PARTITION_INFO        pPartitionInfoValue;
    PCLUSPROP_REQUIRED_DEPENDENCY   pRequiredDependencyValue;
    PCLUSPROP_PARTITION_INFO_EX     pPartitionInfoValueEx;
    PCLUSPROP_FILETIME              pFileTimeValue;
} CLUSPROP_BUFFER_HELPER, *PCLUSPROP_BUFFER_HELPER;

#endif // MIDL_PASS

#endif // _CLUSTER_API_TYPES_

// Macro for aligning CLUSPROP buffers on a DWORD boundary.
#define ALIGN_CLUSPROP( count ) ((count + 3) & ~3)

// Macros for declaring array format values
#define CLUSPROP_BINARY_DECLARE( name, cb ) \
    struct {                                \
        CLUSPROP_SYNTAX Syntax;             \
        DWORD           cbLength;           \
        BYTE            rgb[(cb + 3) & ~3]; \
    } name

#define CLUSPROP_SZ_DECLARE( name, cch )    \
    struct {                                \
        CLUSPROP_SYNTAX Syntax;             \
        DWORD           cbLength;           \
        WCHAR           sz[(cch + 1) & ~1]; \
    } name

#define CLUSPROP_PROPERTY_NAME_DECLARE( name, cch ) CLUSPROP_SZ_DECLARE( name, cch )



//
// Cluster resource property enumeration.
//

#ifndef _CLUSTER_API_TYPES_
//
// Define enumerable types
//
typedef enum CLUSTER_RESOURCE_ENUM {
    CLUSTER_RESOURCE_ENUM_DEPENDS   = 0x00000001,
    CLUSTER_RESOURCE_ENUM_PROVIDES  = 0x00000002,
    CLUSTER_RESOURCE_ENUM_NODES     = 0x00000004,

    CLUSTER_RESOURCE_ENUM_ALL       = (CLUSTER_RESOURCE_ENUM_DEPENDS  |
                                         CLUSTER_RESOURCE_ENUM_PROVIDES |
                                         CLUSTER_RESOURCE_ENUM_NODES)
} CLUSTER_RESOURCE_ENUM;

typedef enum CLUSTER_RESOURCE_TYPE_ENUM {
    CLUSTER_RESOURCE_TYPE_ENUM_NODES = 0x00000001,

    CLUSTER_RESOURCE_TYPE_ENUM_ALL   = (CLUSTER_RESOURCE_TYPE_ENUM_NODES)
} CLUSTER_RESOURCE_TYPE_ENUM;

#endif // _CLUSTER_API_TYPES_

#if ( !MIDL_PASS && !__midl )
HRESENUM
WINAPI
ClusterResourceOpenEnum(
    __in HRESOURCE hResource,
    __in DWORD dwType
    );

typedef HRESENUM
(WINAPI * PCLUSAPI_CLUSTER_RESOURCE_OPEN_ENUM)(
    HRESOURCE hResource,
    DWORD dwType
    );

DWORD
WINAPI
ClusterResourceGetEnumCount(
    __in HRESENUM hResEnum
    );

typedef DWORD
(WINAPI * PCLUSAPI_CLUSTER_RESOURCE_GET_ENUM_COUNT)(
    __in HRESENUM hResEnum
    );

__success(return == ERROR_SUCCESS)
DWORD
WINAPI
ClusterResourceEnum(
    __in HRESENUM hResEnum,
    __in DWORD dwIndex,
    __out LPDWORD lpdwType,
    __out_ecount_part(*lpcchName, *lpcchName + 1) LPWSTR lpszName,
    __inout LPDWORD lpcchName
    );

typedef DWORD
(WINAPI * PCLUSAPI_CLUSTER_RESOURCE_ENUM)(
    __in HRESENUM hResEnum,
    __in DWORD dwIndex,
    __out LPDWORD lpdwType,
    __out_ecount_part(*lpcchName, *lpcchName + 1) LPWSTR lpszName,
    __inout LPDWORD lpcchName
    );

DWORD
WINAPI
ClusterResourceCloseEnum(
    __in HRESENUM hResEnum
    );

typedef DWORD
(WINAPI * PCLUSAPI_CLUSTER_RESOURCE_CLOSE_ENUM)(
    HRESENUM hResEnum
    );

DWORD
WINAPI
CreateClusterResourceType(
    __in HCLUSTER hCluster,
    __in LPCWSTR lpszResourceTypeName,
    __in LPCWSTR lpszDisplayName,
    __in LPCWSTR lpszResourceTypeDll,
    __in DWORD dwLooksAlivePollInterval,
    __in DWORD dwIsAlivePollInterval
    );

typedef DWORD
(WINAPI * PCLUSAPI_CREATE_CLUSTER_RESOURCE_TYPE)(
    __in HCLUSTER hCluster,
    __in LPCWSTR lpszResourceTypeName,
    __in LPCWSTR lpszDisplayName,
    __in LPCWSTR lpszResourceTypeDll,
    __in DWORD dwLooksAlivePollInterval,
    __in DWORD dwIsAlivePollInterval
    );

DWORD
WINAPI
DeleteClusterResourceType(
    __in HCLUSTER hCluster,
    __in LPCWSTR lpszResourceTypeName
    );

typedef DWORD
(WINAPI * PCLUSAPI_DELETE_CLUSTER_RESOURCE_TYPE)(
    HCLUSTER hCluster,
    LPCWSTR lpszResourceTypeName
    );

HRESTYPEENUM
WINAPI
ClusterResourceTypeOpenEnum(
    __in HCLUSTER hCluster,
    __in LPCWSTR lpszResourceTypeName,
    __in DWORD dwType
    );

typedef HRESTYPEENUM
(WINAPI * PCLUSAPI_CLUSTER_RESOURCE_TYPE_OPEN_ENUM)(
    __in HCLUSTER hCluster,
    __in LPCWSTR lpszResourceTypeName,
    __in DWORD dwType
    );

DWORD
WINAPI
ClusterResourceTypeGetEnumCount(
    __in HRESTYPEENUM hResTypeEnum
    );

typedef DWORD
(WINAPI * PCLUSAPI_CLUSTER_RESOURCE_TYPE_GET_ENUM_COUNT)(
    __in HRESTYPEENUM hResTypeEnum
    );

__success(return == ERROR_SUCCESS)
DWORD
WINAPI
ClusterResourceTypeEnum(
    __in HRESTYPEENUM hResTypeEnum,
    __in DWORD dwIndex,
    __out LPDWORD lpdwType,
    __out_ecount_part(*lpcchName, *lpcchName + 1) LPWSTR lpszName,
    __inout LPDWORD lpcchName
    );

typedef DWORD
(WINAPI * PCLUSAPI_CLUSTER_RESOURCE_TYPE_ENUM)(
    __in HRESTYPEENUM hResTypeEnum,
    __in DWORD dwIndex,
    __out LPDWORD lpdwType,
    __out_ecount_part(*lpcchName, *lpcchName + 1) LPWSTR lpszName,
    __inout LPDWORD lpcchName
    );

DWORD
WINAPI
ClusterResourceTypeCloseEnum(
    __in HRESTYPEENUM hResTypeEnum
    );

typedef DWORD
(WINAPI * PCLUSAPI_CLUSTER_RESOURCE_TYPE_CLOSE_ENUM)(
    __in HRESTYPEENUM hResTypeEnum
    );

#endif // MIDL_PASS



//
// Network-related structures and types.
//

#ifndef _CLUSTER_API_TYPES_
//
// Define enumerable group types
//
typedef enum CLUSTER_NETWORK_ENUM {
    CLUSTER_NETWORK_ENUM_NETINTERFACES  = 0x00000001,

    CLUSTER_NETWORK_ENUM_ALL            = CLUSTER_NETWORK_ENUM_NETINTERFACES
} CLUSTER_NETWORK_ENUM;

typedef enum CLUSTER_NETWORK_STATE {
    ClusterNetworkStateUnknown = -1,
    ClusterNetworkUnavailable,
    ClusterNetworkDown,
    ClusterNetworkPartitioned,
    ClusterNetworkUp
} CLUSTER_NETWORK_STATE;

// Role the network plays in the cluster.  This is a bitmask.
typedef enum CLUSTER_NETWORK_ROLE {
    ClusterNetworkRoleNone              = 0,
    ClusterNetworkRoleInternalUse       = 0x00000001,
    ClusterNetworkRoleClientAccess      = 0x00000002,
    ClusterNetworkRoleInternalAndClient = 0x00000003
} CLUSTER_NETWORK_ROLE;

#endif // _CLUSTER_API_TYPES_

//
// Interfaces for managing the networks of a cluster.
//

#if ( !MIDL_PASS && !__midl )
HNETWORK
WINAPI
OpenClusterNetwork(
    __in HCLUSTER hCluster,
    __in LPCWSTR lpszNetworkName
    );

typedef HNETWORK
(WINAPI * PCLUSAPI_OPEN_CLUSTER_NETWORK)(
    __in HCLUSTER hCluster,
    __in LPCWSTR lpszNetworkName
    );

BOOL
WINAPI
CloseClusterNetwork(
    __in HNETWORK hNetwork
    );

typedef BOOL
(WINAPI * PCLUSAPI_CLOSE_CLUSTER_NETWORK)(
    __in HNETWORK hNetwork
    );

HCLUSTER
WINAPI
GetClusterFromNetwork(
    __in HNETWORK hNetwork
    );

typedef HCLUSTER
(WINAPI * PCLUSAPI_GET_CLUSTER_FROM_NETWORK)(
    __in HNETWORK hNetwork
    );

HNETWORKENUM
WINAPI
ClusterNetworkOpenEnum(
    __in HNETWORK hNetwork,
    __in DWORD dwType
    );

typedef HNETWORKENUM
(WINAPI * PCLUSAPI_CLUSTER_NETWORK_OPEN_ENUM)(
    __in HNETWORK hNetwork,
    __in DWORD dwType
    );

DWORD
WINAPI
ClusterNetworkGetEnumCount(
    __in HNETWORKENUM hNetworkEnum
    );

typedef DWORD
(WINAPI * PCLUSAPI_CLUSTER_NETWORK_GET_ENUM_COUNT)(
    __in HNETWORKENUM hNetworkEnum
    );

__success (return == ERROR_SUCCESS)
DWORD
WINAPI
ClusterNetworkEnum(
    __in HNETWORKENUM hNetworkEnum,
    __in DWORD dwIndex,
    __out LPDWORD lpdwType,
    __out_ecount_part(*lpcchName, *lpcchName + 1) LPWSTR lpszName,
    __inout LPDWORD lpcchName
    );

typedef DWORD
(WINAPI * PCLUSAPI_CLUSTER_NETWORK_ENUM)(
    __in HNETWORKENUM hNetworkEnum,
    __in DWORD dwIndex,
    __out LPDWORD lpdwType,
    __out_ecount_part(*lpcchName, *lpcchName + 1) LPWSTR lpszName,
    __inout LPDWORD lpcchName
    );

DWORD
WINAPI
ClusterNetworkCloseEnum(
    __in HNETWORKENUM hNetworkEnum
    );

typedef DWORD
(WINAPI * PCLUSAPI_CLUSTER_NETWORK_CLOSE_ENUM)(
    __in HNETWORKENUM hNetworkEnum
    );

CLUSTER_NETWORK_STATE
WINAPI
GetClusterNetworkState(
    __in HNETWORK hNetwork
    );

typedef CLUSTER_NETWORK_STATE
(WINAPI * PCLUSAPI_GET_CLUSTER_NETWORK_STATE)(
    __in HNETWORK hNetwork
    );

DWORD
WINAPI
SetClusterNetworkName(
    __in HNETWORK hNetwork,
    __in LPCWSTR lpszName
    );

typedef DWORD
(WINAPI * PCLUSAPI_SET_CLUSTER_NETWORK_NAME)(
    __in HNETWORK hNetwork,
    __in LPCWSTR lpszName
    );

__success(return == ERROR_SUCCESS)
DWORD
WINAPI
GetClusterNetworkId(
    __in HNETWORK hNetwork,
    __out_ecount_part(*lpcchName, *lpcchName + 1) LPWSTR lpszNetworkId,
    __inout LPDWORD lpcchName
    );

typedef DWORD
(WINAPI * PCLUSAPI_GET_CLUSTER_NETWORK_ID)(
    __in HNETWORK hNetwork,
    __out_ecount_part(*lpcchName, *lpcchName + 1) LPWSTR lpszNetworkId,
    __inout LPDWORD lpcchName
    );

DWORD
WINAPI
ClusterNetworkControl(
    __in HNETWORK hNetwork,
    __in_opt HNODE hHostNode,
    __in DWORD dwControlCode,
    __in_bcount_opt(nInBufferSize) LPVOID lpInBuffer,
    __in DWORD nInBufferSize,
    __out_bcount_part_opt(nOutBufferSize, *lpBytesReturned) LPVOID lpOutBuffer,
    __in DWORD nOutBufferSize,
    __out_opt LPDWORD lpBytesReturned
    );

typedef DWORD
(WINAPI * PCLUSAPI_CLUSTER_NETWORK_CONTROL)(
    __in HNETWORK hNetwork,
    __in_opt HNODE hHostNode,
    __in DWORD dwControlCode,
    __in_bcount_opt(nInBufferSize) LPVOID lpInBuffer,
    __in DWORD nInBufferSize,
    __out_bcount_part_opt(nOutBufferSize, *lpBytesReturned) LPVOID lpOutBuffer,
    __in DWORD nOutBufferSize,
    __out_opt LPDWORD lpBytesReturned
    );

#endif // MIDL_PASS


#ifndef _CLUSTER_API_TYPES_
//
// Network interface-related structures and types.
//
typedef enum CLUSTER_NETINTERFACE_STATE {
    ClusterNetInterfaceStateUnknown = -1,
    ClusterNetInterfaceUnavailable,
    ClusterNetInterfaceFailed,
    ClusterNetInterfaceUnreachable,
    ClusterNetInterfaceUp
} CLUSTER_NETINTERFACE_STATE;

#endif // _CLUSTER_API_TYPES_

//
// Interfaces for managing the network interfaces of a cluster.
//

#if ( !MIDL_PASS && !__midl )
HNETINTERFACE
WINAPI
OpenClusterNetInterface(
    __in HCLUSTER hCluster,
    __in LPCWSTR lpszInterfaceName
    );

typedef HNETINTERFACE
(WINAPI * PCLUSAPI_OPEN_CLUSTER_NET_INTERFACE)(
    __in HCLUSTER hCluster,
    __in LPCWSTR lpszInterfaceName
    );

__success(return == ERROR_SUCCESS)
DWORD
WINAPI
GetClusterNetInterface(
    __in HCLUSTER hCluster,
    __in LPCWSTR lpszNodeName,
    __in LPCWSTR lpszNetworkName,
    __out_ecount_part(*lpcchInterfaceName, *lpcchInterfaceName + 1) LPWSTR lpszInterfaceName,
    __inout LPDWORD lpcchInterfaceName
    );

typedef DWORD
(WINAPI * PCLUSAPI_GET_CLUSTER_NET_INTERFACE)(
    __in HCLUSTER hCluster,
    __in LPCWSTR lpszNodeName,
    __in LPCWSTR lpszNetworkName,
    __out_ecount_part_opt(*lpcchInterfaceName, *lpcchInterfaceName + 1) LPWSTR lpszInterfaceName,
    __inout LPDWORD lpcchInterfaceName
    );

BOOL
WINAPI
CloseClusterNetInterface(
    __in HNETINTERFACE hNetInterface
    );

typedef BOOL
(WINAPI * PCLUSAPI_CLOSE_CLUSTER_NET_INTERFACE)(
    __in HNETINTERFACE hNetInterface
    );

HCLUSTER
WINAPI
GetClusterFromNetInterface(
    __in HNETINTERFACE hNetInterface
    );

typedef HCLUSTER
(WINAPI * PCLUSAPI_GET_CLUSTER_FROM_NET_INTERFACE)(
    __in HNETINTERFACE hNetInterface
    );

CLUSTER_NETINTERFACE_STATE
WINAPI
GetClusterNetInterfaceState(
    __in HNETINTERFACE hNetInterface
    );

typedef CLUSTER_NETINTERFACE_STATE
(WINAPI * PCLUSAPI_GET_CLUSTER_NET_INTERFACE_STATE)(
    __in HNETINTERFACE hNetInterface
    );

DWORD
WINAPI
ClusterNetInterfaceControl(
    __in HNETINTERFACE hNetInterface,
    __in_opt HNODE hHostNode,
    __in DWORD dwControlCode,
    __in_bcount_opt(nInBufferSize) LPVOID lpInBuffer,
    __in DWORD nInBufferSize,
    __out_bcount_part_opt(nOutBufferSize, *lpBytesReturned) LPVOID lpOutBuffer,
    __in DWORD nOutBufferSize,
    __out_opt LPDWORD lpBytesReturned
    );

typedef DWORD
(WINAPI * PCLUSAPI_CLUSTER_NET_INTERFACE_CONTROL)(
    __in HNETINTERFACE hNetInterface,
    __in_opt HNODE hHostNode,
    __in DWORD dwControlCode,
    __in_bcount_opt(nInBufferSize) LPVOID lpInBuffer,
    __in DWORD nInBufferSize,
    __out_bcount_part_opt(nOutBufferSize, *lpBytesReturned) LPVOID lpOutBuffer,
    __in DWORD nOutBufferSize,
    __out_opt LPDWORD lpBytesReturned
    );
#endif // MIDL_PASS


//
// Cluster registry update and access routines
//

#if ( !MIDL_PASS && !__midl )
HKEY
WINAPI
GetClusterKey(
    __in HCLUSTER hCluster,
    __in REGSAM samDesired
    );

typedef HKEY
(WINAPI * PCLUSAPI_GET_CLUSTER_KEY)(
     HCLUSTER hCluster,
     REGSAM samDesired
     );

HKEY
WINAPI
GetClusterGroupKey(
    __in HGROUP hGroup,
    __in REGSAM samDesired
    );

typedef HKEY
(WINAPI * PCLUSAPI_GET_CLUSTER_GROUP_KEY)(
    HGROUP hGroup,
    REGSAM samDesired
    );

HKEY
WINAPI
GetClusterResourceKey(
    __in HRESOURCE hResource,
    __in REGSAM samDesired
    );

typedef HKEY
(WINAPI * PCLUSAPI_GET_CLUSTER_RESOURCE_KEY)(
    HRESOURCE hResource,
    REGSAM samDesired
    );

HKEY
WINAPI
GetClusterNodeKey(
    __in HNODE hNode,
    __in REGSAM samDesired
    );

typedef HKEY
(WINAPI * PCLUSAPI_GET_CLUSTER_NODE_KEY)(
    HNODE hNode,
    REGSAM samDesired
    );

HKEY
WINAPI
GetClusterNetworkKey(
    __in HNETWORK hNetwork,
    __in REGSAM samDesired
    );

typedef HKEY
(WINAPI * PCLUSAPI_GET_CLUSTER_NETWORK_KEY)(
    __in HNETWORK hNetwork,
    __in REGSAM samDesired
    );

HKEY
WINAPI
GetClusterNetInterfaceKey(
    __in HNETINTERFACE hNetInterface,
    __in REGSAM samDesired
    );

typedef HKEY
(WINAPI * PCLUSAPI_GET_CLUSTER_NET_INTERFACE_KEY)(
    __in HNETINTERFACE hNetInterface,
    __in REGSAM samDesired
    );

LONG
WINAPI
ClusterRegCreateKey(
    __in HKEY hKey,
    __in LPCWSTR lpszSubKey,
    __in DWORD dwOptions,
    __in REGSAM samDesired,
    __in_opt LPSECURITY_ATTRIBUTES lpSecurityAttributes,
    __out PHKEY phkResult,
    __out_opt LPDWORD lpdwDisposition
    );

typedef LONG
(WINAPI * PCLUSAPI_CLUSTER_REG_CREATE_KEY)(
    __in HKEY hKey,
    __in LPCWSTR lpszSubKey,
    __in DWORD dwOptions,
    __in REGSAM samDesired,
    __in_opt LPSECURITY_ATTRIBUTES lpSecurityAttributes,
    __out PHKEY phkResult,
    __out_opt LPDWORD lpdwDisposition
    );

LONG
WINAPI
ClusterRegOpenKey(
    __in HKEY hKey,
    __in LPCWSTR lpszSubKey,
    __in REGSAM samDesired,
    __out PHKEY phkResult
    );

typedef LONG
(WINAPI * PCLUSAPI_CLUSTER_REG_OPEN_KEY)(
    HKEY hKey,
    LPCWSTR lpszSubKey,
    REGSAM samDesired,
    PHKEY phkResult
    );

LONG
WINAPI
ClusterRegDeleteKey(
    __in HKEY hKey,
    __in LPCWSTR lpszSubKey
    );

typedef LONG
(WINAPI * PCLUSAPI_CLUSTER_REG_DELETE_KEY)(
    HKEY hKey,
    LPCWSTR lpszSubKey
    );

LONG
WINAPI
ClusterRegCloseKey(
    __in HKEY hKey
    );

typedef LONG
(WINAPI * PCLUSAPI_CLUSTER_REG_CLOSE_KEY)(
    HKEY hKey
    );

__success(return == ERROR_SUCCESS)
LONG
WINAPI
ClusterRegEnumKey(
    __in HKEY hKey,
    __in DWORD dwIndex,
    __out_ecount_part(*lpcchName, *lpcchName + 1) LPWSTR lpszName,
    __inout LPDWORD lpcchName,
    __out_opt PFILETIME lpftLastWriteTime
    );

typedef LONG
(WINAPI * PCLUSAPI_CLUSTER_REG_ENUM_KEY)(
    __in HKEY hKey,
    __in DWORD dwIndex,
    __out_ecount_part(*lpcchName, *lpcchName + 1) LPWSTR lpszName,
    __inout LPDWORD lpcchName,
    __out PFILETIME lpftLastWriteTime
    );

DWORD
WINAPI
ClusterRegSetValue(
    __in HKEY hKey,
    __in LPCWSTR lpszValueName,
    __in DWORD dwType,
    __in CONST BYTE* lpData,
    __in DWORD cbData
    );

typedef DWORD
(WINAPI * PCLUSAPI_CLUSTER_REG_SET_VALUE)(
    HKEY hKey,
    LPCWSTR lpszValueName,
    DWORD dwType,
    CONST BYTE* lpData,
    DWORD cbData
    );

DWORD
WINAPI
ClusterRegDeleteValue(
    __in HKEY hKey,
    __in LPCWSTR lpszValueName
    );

typedef DWORD
(WINAPI * PCLUSAPI_CLUSTER_REG_DELETE_VALUE)(
    HKEY hKey,
    LPCWSTR lpszValueName
    );

LONG
WINAPI
ClusterRegQueryValue(
    __in HKEY hKey,
    __in LPCWSTR lpszValueName,
    __out_opt LPDWORD lpdwValueType,
    __out_bcount_part_opt(*lpcbData, *lpcbData) LPBYTE lpData,
    __inout_opt LPDWORD lpcbData
    );

typedef LONG
(WINAPI * PCLUSAPI_CLUSTER_REG_QUERY_VALUE)(
    __in HKEY hKey,
    __in LPCWSTR lpszValueName,
    __out_opt LPDWORD lpdwValueType,
    __out_bcount_part_opt(*lpcbData, *lpcbData) LPBYTE lpData,
    __inout_opt LPDWORD lpcbData
    );

__success(return == ERROR_SUCCESS)
DWORD
WINAPI
ClusterRegEnumValue(
    __in HKEY hKey,
    __in DWORD dwIndex,
    __out_ecount_part(*lpcchValueName, *lpcchValueName + 1) LPWSTR lpszValueName,
    __inout LPDWORD lpcchValueName,
    __out_opt LPDWORD lpdwType,
    __out_bcount_part_opt(*lpcbData, *lpcbData) LPBYTE lpData,
    __inout_opt LPDWORD lpcbData
    );

typedef DWORD
(WINAPI * PCLUSAPI_CLUSTER_REG_ENUM_VALUE)(
    __in HKEY hKey,
    __in DWORD dwIndex,
    __out_ecount_part(*lpcchValueName, *lpcchValueName + 1) LPWSTR lpszValueName,
    __inout LPDWORD lpcchValueName,
    __out LPDWORD lpdwType,
    __out_bcount_part_opt(*lpcbData, *lpcbData) LPBYTE lpData,
    __inout_opt LPDWORD lpcbData
    );

LONG
WINAPI
ClusterRegQueryInfoKey(
    __in HKEY hKey,
    __in LPDWORD lpcSubKeys,
    __in LPDWORD lpcchMaxSubKeyLen,
    __in LPDWORD lpcValues,
    __in LPDWORD lpcchMaxValueNameLen,
    __in LPDWORD lpcbMaxValueLen,
    __in LPDWORD lpcbSecurityDescriptor,
    __in PFILETIME lpftLastWriteTime
    );

typedef LONG
(WINAPI * PCLUSAPI_CLUSTER_REG_QUERY_INFO_KEY)(
    HKEY hKey,
    LPDWORD lpcSubKeys,
    LPDWORD lpcbMaxSubKeyLen,
    LPDWORD lpcValues,
    LPDWORD lpcbMaxValueNameLen,
    LPDWORD lpcbMaxValueLen,
    LPDWORD lpcbSecurityDescriptor,
    PFILETIME lpftLastWriteTime
    );

LONG
WINAPI
ClusterRegGetKeySecurity (
    __in HKEY hKey,
    __in SECURITY_INFORMATION RequestedInformation,
    __out_bcount_part(*lpcbSecurityDescriptor, *lpcbSecurityDescriptor) PSECURITY_DESCRIPTOR pSecurityDescriptor,
    __inout LPDWORD lpcbSecurityDescriptor
    );

typedef LONG
(WINAPI * PCLUSAPI_CLUSTER_REG_GET_KEY_SECURITY)(
    __in HKEY hKey,
    __in SECURITY_INFORMATION RequestedInformation,
    __out_bcount_part(*lpcbSecurityDescriptor, *lpcbSecurityDescriptor) PSECURITY_DESCRIPTOR pSecurityDescriptor,
    __inout LPDWORD lpcbSecurityDescriptor
    );

LONG
WINAPI
ClusterRegSetKeySecurity(
    __in HKEY hKey,
    __in SECURITY_INFORMATION SecurityInformation,
    __in PSECURITY_DESCRIPTOR pSecurityDescriptor
    );

typedef LONG
(WINAPI * PCLUSAPI_CLUSTER_REG_SET_KEY_SECURITY)(
    HKEY hKey,
    SECURITY_INFORMATION SecurityInformation,
    PSECURITY_DESCRIPTOR pSecurityDescriptor
    );

LONG WINAPI ClusterRegCreateBatch(
    __in_opt HKEY hKey,
    __out HREGBATCH* pHREGBATCH
    );

typedef LONG 
(WINAPI *PCLUSAPI_CLUSTER_REG_CREATE_BATCH)(
    __in_opt HKEY hKey,
    __out HREGBATCH* pHREGBATCH
    );

LONG WINAPI ClusterRegAddCommand(
    __in HREGBATCH HREGBATCH,
    __in CLUSTER_REG_COMMAND dwCommand,
    __in_opt LPCWSTR wzName,
    __in DWORD dwOptions,
    __in VOID CONST * lpData,
    __in DWORD cbData
    );

typedef LONG 
(WINAPI *PCLUSTER_REG_ADD_COMMAND)(
    __in HREGBATCH HREGBATCH,
    __in CLUSTER_REG_COMMAND dwCommand,
    __in DWORD dwOptions,
    __in_opt LPWSTR wzName,
    __in VOID CONST * lpData,
    __in DWORD cbData
    );

LONG WINAPI ClusterRegCloseBatch(
    __in HREGBATCH HREGBATCH,
    __in BOOL bCommit,
    __out_opt INT * failedCommandNumber
    );

typedef LONG 
(WINAPI *PCLUSTER_REG_CLOSE_BATCH)(
    __in HREGBATCH HREGBATCH,
    __in BOOL bCommit,
    __out_opt INT * failedCommandNumber
    );


//
// Cluster Create, Add Node and Destroy Cluster
//

//
// Phases that changes in cluster persistent membership will go through.
// Phase numbers may arrive in any order via the callback function.
//

typedef enum _CLUSTER_MEMBERSHIP_CHANGE_PHASE {

    MembershipChangePhaseValidateNodeState              = 1,
    MembershipChangePhaseNodeInitialize                 = 3,
    MembershipChangePhaseValidateNetft                  = 4,
    MembershipChangePhaseValidateClusDisk               = 5,
    MembershipChangePhaseConfigureClusSvc               = 6,
    MembershipChangePhaseStartingClusSvc                = 7,
    MembershipChangePhaseInitialize                     = 8,
    MembershipChangePhaseWaitForServiceStart            = 9,
    MembershipChangePhaseNodeUp                         = 10,
    MembershipChangePhaseAddClusterProperties           = 11,
    MembershipChangePhaseCreateResourceTypes            = 12,
    MembershipChangePhaseCreateClusterGroup             = 13,
    MembershipChangePhaseCreateQuorumResource           = 14,
    MembershipChangePhaseCreateIPAddressResources       = 15,
    MembershipChangePhaseCreateNetworkName              = 16,
    MembershipChangePhaseClusterGroupOnline             = 17,
    MembershipChangePhaseGettingCurrentMembership       = 18,
    MembershipChangePhaseAddNodeToCluster               = 19,
    MembershipChangePhaseOfflineGroup                   = 20,
    MembershipChangePhaseEvictNode                      = 21,
    MembershipChangePhaseFailureCleanup                 = 22

} CLUSTER_MEMBERSHIP_CHANGE_PHASE;

typedef BOOL
(WINAPI *PCLUSTER_MEMBERSHIP_CHANGE_PROGRESS)(
    PVOID                           pvCallbackArg,
    CLUSTER_MEMBERSHIP_CHANGE_PHASE eMembershipPhase,
    DWORD                           dwPercentComplete,
    __in PCWSTR                     lpszObjectName,
    DWORD                           dwStatus );

HCLUSTER
WINAPI
CreateCluster(
    __in PCREATE_CLUSTER_CONFIG pConfig,
    __in BOOL                   fAcceptPartialFailure,
    __in_opt PCLUSTER_MEMBERSHIP_CHANGE_PROGRESS    pfnProgressCallback,
    __in_opt PVOID              pvCallbackArg
    );

typedef HCLUSTER
(WINAPI * PCLUSAPI_CREATE_CLUSTER)(
    __in PCREATE_CLUSTER_CONFIG pConfig,
    __in BOOL                   fAcceptPartialFailure,
    __in_opt PCLUSTER_MEMBERSHIP_CHANGE_PROGRESS    pfnProgressCallback,
    __in_opt PVOID              pvCallbackArg
    );

HNODE
WINAPI
AddClusterNode(
    __in HCLUSTER    hCluster,
    __in PCWSTR      lpszNodeName,
    __in_opt PCLUSTER_MEMBERSHIP_CHANGE_PROGRESS    pfnProgressCallback,
    __in_opt PVOID   pvCallbackArg
    );

typedef HNODE
(WINAPI * PCLUSAPI_ADD_CLUSTER_NODE)(
    __in HCLUSTER    hCluster,
    __in PCWSTR      lpszNodeName,
    __in_opt PCLUSTER_MEMBERSHIP_CHANGE_PROGRESS    pfnProgressCallback,
    __in_opt PVOID   pvCallbackArg
    );

DWORD
WINAPI
DestroyCluster(
    __in HCLUSTER    hCluster,
    __in_opt PCLUSTER_MEMBERSHIP_CHANGE_PROGRESS    pfnProgressCallback,
    __in_opt PVOID   pvCallbackArg
    );

typedef DWORD
(WINAPI * PCLUSAPI_DESTROY_CLUSTER)(
    __in HCLUSTER    hCluster,
    __in_opt PCLUSTER_MEMBERSHIP_CHANGE_PROGRESS    pfnProgressCallback,
    __in_opt PVOID   pvCallbackArg
    );

//
// Standard Resource Type Names
//

#define CLUS_RESTYPE_NAME_GENAPP            L"Generic Application"
#define CLUS_RESTYPE_NAME_GENSVC            L"Generic Service"
#define CLUS_RESTYPE_NAME_GENSCRIPT         L"Generic Script"
#define CLUS_RESTYPE_NAME_IPADDR            L"IP Address"
#define CLUS_RESTYPE_NAME_NETNAME           L"Network Name"
#define CLUS_RESTYPE_NAME_FILESHR           L"File Share"
#define CLUS_RESTYPE_NAME_PRTSPLR           L"Print Spooler"
#define CLUS_RESTYPE_NAME_LKQUORUM          L"Local Quorum"
#define CLUS_RESTYPE_NAME_IPV6_NATIVE       L"IPv6 Address"
#define CLUS_RESTYPE_NAME_IPV6_TUNNEL       L"IPv6 Tunnel Address"

#define CLUS_RESTYPE_NAME_VSSTASK           L"Volume Shadow Copy Service Task"

#define CLUS_RESTYPE_NAME_WINS              L"WINS Service"
#define CLUS_RESTYPE_NAME_DHCP              L"DHCP Service"

#define CLUS_RESTYPE_NAME_MSMQ              L"Microsoft Message Queue Server"
#define CLUS_RESTYPE_NAME_NEW_MSMQ          L"MSMQ"
#define CLUS_RESTYPE_NAME_MSMQ_TRIGGER      L"MSMQTriggers"

#define CLUS_RESTYPE_NAME_MSDTC             L"Distributed Transaction Coordinator"

#define CLUS_RESTYPE_NAME_NFS               L"NFS Share"

#define CLUS_RESTYPE_NAME_ISNS              L"Microsoft iSNS"

#define CLUS_RESTYPE_NAME_HARDDISK          L"Physical Disk"
#define CLUS_RESTYPE_NAME_PHYS_DISK         CLUS_RESTYPE_NAME_HARDDISK


//
// Cluster common property names
//
#define CLUSREG_NAME_ADMIN_EXT  L"AdminExtensions"
#define CLUSREG_NAME_CLUS_DESC  L"Description"
#define CLUSREG_NAME_CLUS_SD    L"Security Descriptor"

#define CLUSREG_NAME_CLUS_DEFAULT_NETWORK_ROLE    L"DefaultNetworkRole"
#define CLUSREG_NAME_QUORUM_ARBITRATION_TIMEOUT   L"QuorumArbitrationTimeMax"
#define CLUSREG_NAME_QUORUM_ARBITRATION_EQUALIZER L"QuorumArbitrationTimeMin"
#define CLUSTER_HEARTBEAT_TIMEOUT_KEYNAME         L"ClusSvcHeartbeatTimeout"
#define CLUSTER_HANG_RECOVERY_ACTION_KEYNAME      L"HangRecoveryAction"
#define CLUSTER_CSA_VSS_STATE                     L"BackupInProgress"

#define CLUSREG_NAME_DISABLE_GROUP_PREFERRED_OWNER_RANDOMIZATION    L"DisableGroupPreferredOwnerRandomization"

//
// Properties and defaults for single and multi subnet delays and thresholds.
//
#define CLUSREG_NAME_SAME_SUBNET_DELAY      L"SameSubnetDelay"
#define CLUSREG_NAME_CROSS_SUBNET_DELAY     L"CrossSubnetDelay"
#define CLUSREG_NAME_SAME_SUBNET_THRESHOLD  L"SameSubnetThreshold"
#define CLUSREG_NAME_CROSS_SUBNET_THRESHOLD L"CrossSubnetThreshold"


//
// Node common property names
//

#define CLUSREG_NAME_NODE_NAME              L"NodeName"
#define CLUSREG_NAME_NODE_HIGHEST_VERSION   L"NodeHighestVersion"
#define CLUSREG_NAME_NODE_LOWEST_VERSION    L"NodeLowestVersion"
#define CLUSREG_NAME_NODE_DESC              L"Description"
#define CLUSREG_NAME_NODE_MAJOR_VERSION     L"MajorVersion"
#define CLUSREG_NAME_NODE_MINOR_VERSION     L"MinorVersion"
#define CLUSREG_NAME_NODE_BUILD_NUMBER      L"BuildNumber"
#define CLUSREG_NAME_NODE_CSDVERSION        L"CSDVersion"


//
// Group common property names
//

#define CLUSREG_NAME_GRP_NAME               L"Name"
#define CLUSREG_NAME_GRP_DESC               L"Description"
#define CLUSREG_NAME_GRP_PERSISTENT_STATE   L"PersistentState"
#define CLUSREG_NAME_GRP_FAILBACK_TYPE      L"AutoFailbackType"
#define CLUSREG_NAME_GRP_FAILBACK_WIN_START L"FailbackWindowStart"
#define CLUSREG_NAME_GRP_FAILBACK_WIN_END   L"FailbackWindowEnd"
#define CLUSREG_NAME_GRP_FAILOVER_THRESHOLD L"FailoverThreshold"
#define CLUSREG_NAME_GRP_FAILOVER_PERIOD    L"FailoverPeriod"

#define CLUSREG_NAME_GRP_ANTI_AFFINITY_CLASS_NAME L"AntiAffinityClassNames"


//
// Resource common property names
//

#define CLUSREG_NAME_RES_NAME                       L"Name"
#define CLUSREG_NAME_RES_TYPE                       L"Type"
#define CLUSREG_NAME_RES_DESC                       L"Description"
#define CLUSREG_NAME_RES_SEPARATE_MONITOR           L"SeparateMonitor"
#define CLUSREG_NAME_RES_PERSISTENT_STATE           L"PersistentState"
#define CLUSREG_NAME_RES_LOOKS_ALIVE                L"LooksAlivePollInterval"
#define CLUSREG_NAME_RES_IS_ALIVE                   L"IsAlivePollInterval"
#define CLUSREG_NAME_RES_RESTART_ACTION             L"RestartAction"
#define CLUSREG_NAME_RES_RESTART_THRESHOLD          L"RestartThreshold"
#define CLUSREG_NAME_RES_RESTART_PERIOD             L"RestartPeriod"
#define CLUSREG_NAME_RES_RETRY_PERIOD_ON_FAILURE    L"RetryPeriodOnFailure"
#define CLUSREG_NAME_RES_PENDING_TIMEOUT            L"PendingTimeout"
#define CLUSREG_NAME_RES_DEADLOCK_TIMEOUT           L"DeadlockTimeout"
#define CLUSREG_NAME_RES_MONITOR_PID                L"MonitorProcessId"
#define CLUSREG_NAME_RES_INTERNAL_STATE             L"InternalState"


//
// Resource Type common property names
//

#define CLUSREG_NAME_RESTYPE_NAME               L"Name"
#define CLUSREG_NAME_RESTYPE_DESC               L"Description"
#define CLUSREG_NAME_RESTYPE_DLL_NAME           L"DllName"
#define CLUSREG_NAME_RESTYPE_ADMIN_EXTENSIONS   L"AdminExtensions"
#define CLUSREG_NAME_RESTYPE_LOOKS_ALIVE        CLUSREG_NAME_RES_LOOKS_ALIVE
#define CLUSREG_NAME_RESTYPE_IS_ALIVE           CLUSREG_NAME_RES_IS_ALIVE
#define CLUSREG_NAME_RESTYPE_PENDING_TIMEOUT    CLUSREG_NAME_RES_PENDING_TIMEOUT
#define CLUSREG_NAME_RESTYPE_DEADLOCK_TIMEOUT   CLUSREG_NAME_RES_DEADLOCK_TIMEOUT

//
// Network common property names
//

#define CLUSREG_NAME_NET_NAME               L"Name"
#define CLUSREG_NAME_NET_IPV6_ADDRESSES     L"IPv6Addresses"
#define CLUSREG_NAME_NET_IPV6_PREFIXLENGTHS L"IPv6PrefixLengths"
#define CLUSREG_NAME_NET_IPV4_ADDRESSES     L"IPv4Addresses"
#define CLUSREG_NAME_NET_IPV4_PREFIXLENGTHS L"IPv4PrefixLengths"
#define CLUSREG_NAME_NET_ADDRESS            L"Address"
#define CLUSREG_NAME_NET_ADDRESS_MASK       L"AddressMask"
#define CLUSREG_NAME_NET_DESC               L"Description"
#define CLUSREG_NAME_NET_ROLE               L"Role"


//
// Network Interface common property names
//

#define CLUSREG_NAME_NETIFACE_NAME              L"Name"
#define CLUSREG_NAME_NETIFACE_NODE              L"Node"
#define CLUSREG_NAME_NETIFACE_NETWORK           L"Network"
#define CLUSREG_NAME_NETIFACE_ADAPTER_NAME      L"Adapter"
#define CLUSREG_NAME_NETIFACE_ADAPTER_ID        L"AdapterId"
#define CLUSREG_NAME_NETIFACE_DHCP_ENABLED      L"DhcpEnabled"
#define CLUSREG_NAME_NETIFACE_IPV6_ADDRESSES    L"IPv6Addresses"
#define CLUSREG_NAME_NETIFACE_IPV4_ADDRESSES    L"IPv4Addresses"
#define CLUSREG_NAME_NETIFACE_ADDRESS           L"Address"
#define CLUSREG_NAME_NETIFACE_DESC              L"Description"

//
// Resource private property names
//

//
// Physical Disk
//

#define CLUSREG_NAME_PHYSDISK_DISKIDTYPE       L"DiskIdType"
#define CLUSREG_NAME_PHYSDISK_DISKSIGNATURE    L"DiskSignature"
#define CLUSREG_NAME_PHYSDISK_DISKIDGUID       L"DiskIdGuid"
#define CLUSREG_NAME_PHYSDISK_DISKRUNCHKDSK    L"DiskRunChkDsk"
#define CLUSREG_NAME_PHYSDISK_DISKUNIQUEIDS    L"DiskUniqueIds"
#define CLUSREG_NAME_PHYSDISK_DISKVOLUMEINFO   L"DiskVolumeInfo"
#define CLUSREG_NAME_PHYSDISK_DISKARBTYPE      L"DiskArbType"
#define CLUSREG_NAME_PHYSDISK_DISKARBINTERVAL  L"DiskArbInterval"
#define CLUSREG_NAME_PHYSDISK_DISKPATH         L"DiskPath"
#define CLUSREG_NAME_PHYSDISK_DISKRELOAD       L"DiskReload"
#define CLUSREG_NAME_PHYSDISK_MAINTMODE        L"MainteanceMode"
#define CLUSREG_NAME_PHYSDISK_DISKIODELAY      L"MaxIoLatency"
#define CLUSREG_NAME_PHYSDISK_MIGRATEFIXUP     L"MigrateDriveLetters"


//
// Generic Application
//

#define CLUSREG_NAME_GENAPP_COMMAND_LINE            L"CommandLine"
#define CLUSREG_NAME_GENAPP_CURRENT_DIRECTORY       L"CurrentDirectory"
#define CLUSREG_NAME_GENAPP_INTERACT_WITH_DESKTOP   L"InteractWithDesktop"
#define CLUSREG_NAME_GENAPP_USE_NETWORK_NAME        L"UseNetworkName"

//
// Generic Script
//

#define CLUSREG_NAME_GENSCRIPT_SCRIPT_FILEPATH      L"ScriptFilepath"


//
// Generic Service
//

#define CLUSREG_NAME_GENSVC_SERVICE_NAME            L"ServiceName"
#define CLUSREG_NAME_GENSVC_STARTUP_PARAMS          L"StartupParameters"
#define CLUSREG_NAME_GENSVC_USE_NETWORK_NAME        L"UseNetworkName"


//
// IPv4 Address
//

#define CLUSREG_NAME_IPADDR_NETWORK                 L"Network"
#define CLUSREG_NAME_IPADDR_ADDRESS                 L"Address"
#define CLUSREG_NAME_IPADDR_SUBNET_MASK             L"SubnetMask"
#define CLUSREG_NAME_IPADDR_ENABLE_NETBIOS          L"EnableNetBIOS"
#define CLUSREG_NAME_IPADDR_OVERRIDE_ADDRMATCH      L"OverrideAddressMatch"
#define CLUSREG_NAME_IPADDR_ENABLE_DHCP             L"EnableDhcp"
#define CLUSREG_NAME_IPADDR_LEASE_OBTAINED_TIME     L"LeaseObtainedTime"
#define CLUSREG_NAME_IPADDR_LEASE_TERMINATES_TIME   L"LeaseExpiresTime"
#define CLUSREG_NAME_IPADDR_T1                      L"T1"
#define CLUSREG_NAME_IPADDR_T2                      L"T2"
#define CLUSREG_NAME_IPADDR_DHCP_SERVER             L"DhcpServer"
#define CLUSREG_NAME_IPADDR_DHCP_ADDRESS            L"DhcpAddress"
#define CLUSREG_NAME_IPADDR_DHCP_SUBNET_MASK        L"DhcpSubnetMask"


//
// IPv6 Address
//

#define CLUSREG_NAME_IPV6_NATIVE_NETWORK            L"Network"
#define CLUSREG_NAME_IPV6_NATIVE_ADDRESS            L"Address"
#define CLUSREG_NAME_IPV6_NATIVE_PREFIX_LENGTH      L"PrefixLength"

#define CLUSREG_NAME_IPV6_TUNNEL_ADDRESS            L"Address"
#define CLUSREG_NAME_IPV6_TUNNEL_TUNNELTYPE         L"TunnelType"


//
// Network Name
//

#define CLUSREG_NAME_NETNAME_NAME                   L"Name"
#define CLUSREG_NAME_NETNAME_CREATING_DC            L"CreatingDC"
#define CLUSREG_NAME_NETNAME_OBJECT_ID              L"ObjectGUID"
#define CLUSREG_NAME_NETNAME_DNS_NAME               L"DnsName"
#define CLUSREG_NAME_NETNAME_REMAP_PIPE_NAMES       L"RemapPipeNames"
#define CLUSREG_NAME_NETNAME_RESOURCE_DATA          L"ResourceData"
#define CLUSREG_NAME_NETNAME_REQUIRE_DNS            L"RequireDNS"
#define CLUSREG_NAME_NETNAME_REQUIRE_KERBEROS       L"RequireKerberos"
#define CLUSREG_NAME_NETNAME_SCOPED_NAME            L"ScopedName"
#define CLUSREG_NAME_NETNAME_STATUS_NETBIOS         L"StatusNetBIOS"
#define CLUSREG_NAME_NETNAME_STATUS_DNS             L"StatusDNS"
#define CLUSREG_NAME_NETNAME_STATUS_KERBEROS        L"StatusKerberos"
#define CLUSREG_NAME_NETNAME_VCO_CONTAINER          L"VcoContainer"
#define CLUSREG_NAME_NETNAME_LAST_DNS_UPDATE        L"LastDNSUpdateTime"
#define CLUSREG_NAME_NETNAME_CONTAINERGUID          L"CryptoContainerGUID"
#define CLUSREG_NAME_NETNAME_HOST_TTL               L"HostRecordTTL"
#define CLUSREG_NAME_NETNAME_PUBLISH_PTR            L"PublishPTRRecords"


//
// Print Spooler
//

#define CLUSREG_NAME_PRTSPOOL_DEFAULT_SPOOL_DIR     L"DefaultSpoolDirectory"
#define CLUSREG_NAME_PRTSPOOL_TIMEOUT               L"JobCompletionTimeout"

//
// File Share
//

#define CLUSREG_NAME_FILESHR_SHARE_NAME             L"ShareName"
#define CLUSREG_NAME_FILESHR_PATH                   L"Path"
#define CLUSREG_NAME_FILESHR_REMARK                 L"Remark"
#define CLUSREG_NAME_FILESHR_MAX_USERS              L"MaxUsers"
#define CLUSREG_NAME_FILESHR_SD                     L"Security Descriptor"
#define CLUSREG_NAME_FILESHR_SHARE_SUBDIRS          L"ShareSubDirs"
#define CLUSREG_NAME_FILESHR_HIDE_SUBDIR_SHARES     L"HideSubDirShares"
#define CLUSREG_NAME_FILESHR_IS_DFS_ROOT            L"IsDfsRoot"
#define CLUSREG_NAME_FILESHR_SHARE_FLAGS            L"ShareFlags"

//
// DHCP Service
//

#define CLUSREG_NAME_DHCP_DATABASE_PATH             L"DatabasePath"
#define CLUSREG_NAME_DHCP_BACKUP_PATH               L"BackupPath"
#define CLUSREG_NAME_LOG_FILE_PATH                  L"LogFilePath"


//
// WINS Service
//

#define CLUSREG_NAME_WINS_DATABASE_PATH             L"DatabasePath"
#define CLUSREG_NAME_WINS_BACKUP_PATH               L"BackupPath"

//
// Local Quorum
//

#define CLUSREG_NAME_LKQUORUM_PATH                  L"Path"
#define CLUSREG_NAME_LKQUORUM_DEBUG                 L"Debug"


//
// Volume Shadow Copy Service Task
//

#define CLUSREG_NAME_VSSTASK_CURRENTDIRECTORY       L"CurrentDirectory"
#define CLUSREG_NAME_VSSTASK_APPNAME                L"ApplicationName"
#define CLUSREG_NAME_VSSTASK_APPPARAMS              L"ApplicationParams"
#define CLUSREG_NAME_VSSTASK_TRIGGERARRAY           L"TriggerArray"




#if _MSC_VER >= 1200
#pragma warning(pop)              // restore 4200/4201
#else
#pragma warning( default : 4200 ) // nonstandard extension used : zero-sized array in struct/union
#pragma warning( default : 4201 ) // nonstandard extension used : nameless struct/union
#endif
#endif // MIDL_PASS

#ifdef __cplusplus
} // extern "C"
#endif

#ifndef _CLUSTER_API_TYPES_
#define _CLUSTER_API_TYPES_
#endif // _CLUSTER_API_TYPES_

#endif // _CLUSTER_API_
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\vs9sp1\sdk\include\cmdtree.h ===
/* this ALWAYS GENERATED file contains the definitions for the interfaces */


 /* File created by MIDL compiler version 7.00.0499 */
/* Compiler settings for cmdtree.idl:
    Oicf, W1, ..., env=Win32 (32b run)
    protocol : dce , ms_ext, c_ext, robust
    error checks: allocation ref bounds_check enum stub_data 
    VC __declspec() decoration level: 
         __declspec(uuid()), __declspec(selectany), __declspec(novtable)
         DECLSPEC_UUID(), MIDL_INTERFACE()
*/
//@@MIDL_FILE_HEADING(  )

#pragma warning( disable: 4049 )  /* more than 64k source lines */


/* verify that the <rpcndr.h> version is high enough to compile this file*/
#ifndef __REQUIRED_RPCNDR_H_VERSION__
#define __REQUIRED_RPCNDR_H_VERSION__ 500
#endif

/* verify that the <rpcsal.h> version is high enough to compile this file*/
#ifndef __REQUIRED_RPCSAL_H_VERSION__
#define __REQUIRED_RPCSAL_H_VERSION__ 100
#endif

#include "rpc.h"
#include "rpcndr.h"

#ifndef __RPCNDR_H_VERSION__
#error this stub requires an updated version of <rpcndr.h>
#endif // __RPCNDR_H_VERSION__

#ifndef COM_NO_WINDOWS_H
#include "windows.h"
#include "ole2.h"
#endif /*COM_NO_WINDOWS_H*/

#ifndef __cmdtree_h__
#define __cmdtree_h__

#if defined(_MSC_VER) && (_MSC_VER >= 1020)
#pragma once
#endif

/* Forward Declarations */ 

#ifndef __ICommandTree_FWD_DEFINED__
#define __ICommandTree_FWD_DEFINED__
typedef interface ICommandTree ICommandTree;
#endif 	/* __ICommandTree_FWD_DEFINED__ */


#ifndef __IQuery_FWD_DEFINED__
#define __IQuery_FWD_DEFINED__
typedef interface IQuery IQuery;
#endif 	/* __IQuery_FWD_DEFINED__ */


/* header files for imported files */
#include "oledb.h"

#ifdef __cplusplus
extern "C"{
#endif 


/* interface __MIDL_itf_cmdtree_0000_0000 */
/* [local] */ 

//+---------------------------------------------------------------------------
//
//  Microsoft OLE DB
//  Copyright (C) Microsoft Corporation, 1994 - 1999.
//
//----------------------------------------------------------------------------

#ifdef _WIN64
#include <pshpack8.h>	// 8-byte structure packing
#else
#include <pshpack2.h>	// 2-byte structure packing
#endif



extern RPC_IF_HANDLE __MIDL_itf_cmdtree_0000_0000_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_cmdtree_0000_0000_v0_0_s_ifspec;

#ifndef __CommandTreeStructureDefinitions_INTERFACE_DEFINED__
#define __CommandTreeStructureDefinitions_INTERFACE_DEFINED__

/* interface CommandTreeStructureDefinitions */
/* [unique][uuid] */ 

typedef WORD DBCOMMANDOP;


enum DBCOMMANDOPENUM
    {	DBOP_scalar_constant	= 0,
	DBOP_DEFAULT	= ( DBOP_scalar_constant + 1 ) ,
	DBOP_NULL	= ( DBOP_DEFAULT + 1 ) ,
	DBOP_bookmark_name	= ( DBOP_NULL + 1 ) ,
	DBOP_catalog_name	= ( DBOP_bookmark_name + 1 ) ,
	DBOP_column_name	= ( DBOP_catalog_name + 1 ) ,
	DBOP_schema_name	= ( DBOP_column_name + 1 ) ,
	DBOP_outall_name	= ( DBOP_schema_name + 1 ) ,
	DBOP_qualifier_name	= ( DBOP_outall_name + 1 ) ,
	DBOP_qualified_column_name	= ( DBOP_qualifier_name + 1 ) ,
	DBOP_table_name	= ( DBOP_qualified_column_name + 1 ) ,
	DBOP_nested_table_name	= ( DBOP_table_name + 1 ) ,
	DBOP_nested_column_name	= ( DBOP_nested_table_name + 1 ) ,
	DBOP_row	= ( DBOP_nested_column_name + 1 ) ,
	DBOP_table	= ( DBOP_row + 1 ) ,
	DBOP_sort	= ( DBOP_table + 1 ) ,
	DBOP_distinct	= ( DBOP_sort + 1 ) ,
	DBOP_distinct_order_preserving	= ( DBOP_distinct + 1 ) ,
	DBOP_alias	= ( DBOP_distinct_order_preserving + 1 ) ,
	DBOP_cross_join	= ( DBOP_alias + 1 ) ,
	DBOP_union_join	= ( DBOP_cross_join + 1 ) ,
	DBOP_inner_join	= ( DBOP_union_join + 1 ) ,
	DBOP_left_semi_join	= ( DBOP_inner_join + 1 ) ,
	DBOP_right_semi_join	= ( DBOP_left_semi_join + 1 ) ,
	DBOP_left_anti_semi_join	= ( DBOP_right_semi_join + 1 ) ,
	DBOP_right_anti_semi_join	= ( DBOP_left_anti_semi_join + 1 ) ,
	DBOP_left_outer_join	= ( DBOP_right_anti_semi_join + 1 ) ,
	DBOP_right_outer_join	= ( DBOP_left_outer_join + 1 ) ,
	DBOP_full_outer_join	= ( DBOP_right_outer_join + 1 ) ,
	DBOP_natural_join	= ( DBOP_full_outer_join + 1 ) ,
	DBOP_natural_left_outer_join	= ( DBOP_natural_join + 1 ) ,
	DBOP_natural_right_outer_join	= ( DBOP_natural_left_outer_join + 1 ) ,
	DBOP_natural_full_outer_join	= ( DBOP_natural_right_outer_join + 1 ) ,
	DBOP_set_intersection	= ( DBOP_natural_full_outer_join + 1 ) ,
	DBOP_set_union	= ( DBOP_set_intersection + 1 ) ,
	DBOP_set_left_difference	= ( DBOP_set_union + 1 ) ,
	DBOP_set_right_difference	= ( DBOP_set_left_difference + 1 ) ,
	DBOP_set_anti_difference	= ( DBOP_set_right_difference + 1 ) ,
	DBOP_bag_intersection	= ( DBOP_set_anti_difference + 1 ) ,
	DBOP_bag_union	= ( DBOP_bag_intersection + 1 ) ,
	DBOP_bag_left_difference	= ( DBOP_bag_union + 1 ) ,
	DBOP_bag_right_difference	= ( DBOP_bag_left_difference + 1 ) ,
	DBOP_bag_anti_difference	= ( DBOP_bag_right_difference + 1 ) ,
	DBOP_division	= ( DBOP_bag_anti_difference + 1 ) ,
	DBOP_relative_sampling	= ( DBOP_division + 1 ) ,
	DBOP_absolute_sampling	= ( DBOP_relative_sampling + 1 ) ,
	DBOP_transitive_closure	= ( DBOP_absolute_sampling + 1 ) ,
	DBOP_recursive_union	= ( DBOP_transitive_closure + 1 ) ,
	DBOP_aggregate	= ( DBOP_recursive_union + 1 ) ,
	DBOP_remote_table	= ( DBOP_aggregate + 1 ) ,
	DBOP_select	= ( DBOP_remote_table + 1 ) ,
	DBOP_order_preserving_select	= ( DBOP_select + 1 ) ,
	DBOP_project	= ( DBOP_order_preserving_select + 1 ) ,
	DBOP_project_order_preserving	= ( DBOP_project + 1 ) ,
	DBOP_top	= ( DBOP_project_order_preserving + 1 ) ,
	DBOP_top_percent	= ( DBOP_top + 1 ) ,
	DBOP_top_plus_ties	= ( DBOP_top_percent + 1 ) ,
	DBOP_top_percent_plus_ties	= ( DBOP_top_plus_ties + 1 ) ,
	DBOP_rank	= ( DBOP_top_percent_plus_ties + 1 ) ,
	DBOP_rank_ties_equally	= ( DBOP_rank + 1 ) ,
	DBOP_rank_ties_equally_and_skip	= ( DBOP_rank_ties_equally + 1 ) ,
	DBOP_navigate	= ( DBOP_rank_ties_equally_and_skip + 1 ) ,
	DBOP_nesting	= ( DBOP_navigate + 1 ) ,
	DBOP_unnesting	= ( DBOP_nesting + 1 ) ,
	DBOP_nested_apply	= ( DBOP_unnesting + 1 ) ,
	DBOP_cross_tab	= ( DBOP_nested_apply + 1 ) ,
	DBOP_is_NULL	= ( DBOP_cross_tab + 1 ) ,
	DBOP_is_NOT_NULL	= ( DBOP_is_NULL + 1 ) ,
	DBOP_equal	= ( DBOP_is_NOT_NULL + 1 ) ,
	DBOP_not_equal	= ( DBOP_equal + 1 ) ,
	DBOP_less	= ( DBOP_not_equal + 1 ) ,
	DBOP_less_equal	= ( DBOP_less + 1 ) ,
	DBOP_greater	= ( DBOP_less_equal + 1 ) ,
	DBOP_greater_equal	= ( DBOP_greater + 1 ) ,
	DBOP_equal_all	= ( DBOP_greater_equal + 1 ) ,
	DBOP_not_equal_all	= ( DBOP_equal_all + 1 ) ,
	DBOP_less_all	= ( DBOP_not_equal_all + 1 ) ,
	DBOP_less_equal_all	= ( DBOP_less_all + 1 ) ,
	DBOP_greater_all	= ( DBOP_less_equal_all + 1 ) ,
	DBOP_greater_equal_all	= ( DBOP_greater_all + 1 ) ,
	DBOP_equal_any	= ( DBOP_greater_equal_all + 1 ) ,
	DBOP_not_equal_any	= ( DBOP_equal_any + 1 ) ,
	DBOP_less_any	= ( DBOP_not_equal_any + 1 ) ,
	DBOP_less_equal_any	= ( DBOP_less_any + 1 ) ,
	DBOP_greater_any	= ( DBOP_less_equal_any + 1 ) ,
	DBOP_greater_equal_any	= ( DBOP_greater_any + 1 ) ,
	DBOP_anybits	= ( DBOP_greater_equal_any + 1 ) ,
	DBOP_allbits	= ( DBOP_anybits + 1 ) ,
	DBOP_anybits_any	= ( DBOP_allbits + 1 ) ,
	DBOP_allbits_any	= ( DBOP_anybits_any + 1 ) ,
	DBOP_anybits_all	= ( DBOP_allbits_any + 1 ) ,
	DBOP_allbits_all	= ( DBOP_anybits_all + 1 ) ,
	DBOP_between	= ( DBOP_allbits_all + 1 ) ,
	DBOP_between_unordered	= ( DBOP_between + 1 ) ,
	DBOP_match	= ( DBOP_between_unordered + 1 ) ,
	DBOP_match_unique	= ( DBOP_match + 1 ) ,
	DBOP_match_partial	= ( DBOP_match_unique + 1 ) ,
	DBOP_match_partial_unique	= ( DBOP_match_partial + 1 ) ,
	DBOP_match_full	= ( DBOP_match_partial_unique + 1 ) ,
	DBOP_match_full_unique	= ( DBOP_match_full + 1 ) ,
	DBOP_scalar_parameter	= ( DBOP_match_full_unique + 1 ) ,
	DBOP_scalar_function	= ( DBOP_scalar_parameter + 1 ) ,
	DBOP_plus	= ( DBOP_scalar_function + 1 ) ,
	DBOP_minus	= ( DBOP_plus + 1 ) ,
	DBOP_times	= ( DBOP_minus + 1 ) ,
	DBOP_over	= ( DBOP_times + 1 ) ,
	DBOP_div	= ( DBOP_over + 1 ) ,
	DBOP_modulo	= ( DBOP_div + 1 ) ,
	DBOP_power	= ( DBOP_modulo + 1 ) ,
	DBOP_like	= ( DBOP_power + 1 ) ,
	DBOP_sounds_like	= ( DBOP_like + 1 ) ,
	DBOP_like_any	= ( DBOP_sounds_like + 1 ) ,
	DBOP_like_all	= ( DBOP_like_any + 1 ) ,
	DBOP_is_INVALID	= ( DBOP_like_all + 1 ) ,
	DBOP_is_TRUE	= ( DBOP_is_INVALID + 1 ) ,
	DBOP_is_FALSE	= ( DBOP_is_TRUE + 1 ) ,
	DBOP_and	= ( DBOP_is_FALSE + 1 ) ,
	DBOP_or	= ( DBOP_and + 1 ) ,
	DBOP_xor	= ( DBOP_or + 1 ) ,
	DBOP_equivalent	= ( DBOP_xor + 1 ) ,
	DBOP_not	= ( DBOP_equivalent + 1 ) ,
	DBOP_implies	= ( DBOP_not + 1 ) ,
	DBOP_overlaps	= ( DBOP_implies + 1 ) ,
	DBOP_case_condition	= ( DBOP_overlaps + 1 ) ,
	DBOP_case_value	= ( DBOP_case_condition + 1 ) ,
	DBOP_nullif	= ( DBOP_case_value + 1 ) ,
	DBOP_cast	= ( DBOP_nullif + 1 ) ,
	DBOP_coalesce	= ( DBOP_cast + 1 ) ,
	DBOP_position	= ( DBOP_coalesce + 1 ) ,
	DBOP_extract	= ( DBOP_position + 1 ) ,
	DBOP_char_length	= ( DBOP_extract + 1 ) ,
	DBOP_octet_length	= ( DBOP_char_length + 1 ) ,
	DBOP_bit_length	= ( DBOP_octet_length + 1 ) ,
	DBOP_substring	= ( DBOP_bit_length + 1 ) ,
	DBOP_upper	= ( DBOP_substring + 1 ) ,
	DBOP_lower	= ( DBOP_upper + 1 ) ,
	DBOP_trim	= ( DBOP_lower + 1 ) ,
	DBOP_translate	= ( DBOP_trim + 1 ) ,
	DBOP_convert	= ( DBOP_translate + 1 ) ,
	DBOP_string_concat	= ( DBOP_convert + 1 ) ,
	DBOP_current_date	= ( DBOP_string_concat + 1 ) ,
	DBOP_current_time	= ( DBOP_current_date + 1 ) ,
	DBOP_current_timestamp	= ( DBOP_current_time + 1 ) ,
	DBOP_content_select	= ( DBOP_current_timestamp + 1 ) ,
	DBOP_content	= ( DBOP_content_select + 1 ) ,
	DBOP_content_freetext	= ( DBOP_content + 1 ) ,
	DBOP_content_proximity	= ( DBOP_content_freetext + 1 ) ,
	DBOP_content_vector_or	= ( DBOP_content_proximity + 1 ) ,
	DBOP_delete	= ( DBOP_content_vector_or + 1 ) ,
	DBOP_update	= ( DBOP_delete + 1 ) ,
	DBOP_insert	= ( DBOP_update + 1 ) ,
	DBOP_min	= ( DBOP_insert + 1 ) ,
	DBOP_max	= ( DBOP_min + 1 ) ,
	DBOP_count	= ( DBOP_max + 1 ) ,
	DBOP_sum	= ( DBOP_count + 1 ) ,
	DBOP_avg	= ( DBOP_sum + 1 ) ,
	DBOP_any_sample	= ( DBOP_avg + 1 ) ,
	DBOP_stddev	= ( DBOP_any_sample + 1 ) ,
	DBOP_stddev_pop	= ( DBOP_stddev + 1 ) ,
	DBOP_var	= ( DBOP_stddev_pop + 1 ) ,
	DBOP_var_pop	= ( DBOP_var + 1 ) ,
	DBOP_first	= ( DBOP_var_pop + 1 ) ,
	DBOP_last	= ( DBOP_first + 1 ) ,
	DBOP_in	= ( DBOP_last + 1 ) ,
	DBOP_exists	= ( DBOP_in + 1 ) ,
	DBOP_unique	= ( DBOP_exists + 1 ) ,
	DBOP_subset	= ( DBOP_unique + 1 ) ,
	DBOP_proper_subset	= ( DBOP_subset + 1 ) ,
	DBOP_superset	= ( DBOP_proper_subset + 1 ) ,
	DBOP_proper_superset	= ( DBOP_superset + 1 ) ,
	DBOP_disjoint	= ( DBOP_proper_superset + 1 ) ,
	DBOP_pass_through	= ( DBOP_disjoint + 1 ) ,
	DBOP_defined_by_GUID	= ( DBOP_pass_through + 1 ) ,
	DBOP_text_command	= ( DBOP_defined_by_GUID + 1 ) ,
	DBOP_SQL_select	= ( DBOP_text_command + 1 ) ,
	DBOP_prior_command_tree	= ( DBOP_SQL_select + 1 ) ,
	DBOP_add_columns	= ( DBOP_prior_command_tree + 1 ) ,
	DBOP_column_list_anchor	= ( DBOP_add_columns + 1 ) ,
	DBOP_column_list_element	= ( DBOP_column_list_anchor + 1 ) ,
	DBOP_command_list_anchor	= ( DBOP_column_list_element + 1 ) ,
	DBOP_command_list_element	= ( DBOP_command_list_anchor + 1 ) ,
	DBOP_from_list_anchor	= ( DBOP_command_list_element + 1 ) ,
	DBOP_from_list_element	= ( DBOP_from_list_anchor + 1 ) ,
	DBOP_project_list_anchor	= ( DBOP_from_list_element + 1 ) ,
	DBOP_project_list_element	= ( DBOP_project_list_anchor + 1 ) ,
	DBOP_row_list_anchor	= ( DBOP_project_list_element + 1 ) ,
	DBOP_row_list_element	= ( DBOP_row_list_anchor + 1 ) ,
	DBOP_scalar_list_anchor	= ( DBOP_row_list_element + 1 ) ,
	DBOP_scalar_list_element	= ( DBOP_scalar_list_anchor + 1 ) ,
	DBOP_set_list_anchor	= ( DBOP_scalar_list_element + 1 ) ,
	DBOP_set_list_element	= ( DBOP_set_list_anchor + 1 ) ,
	DBOP_sort_list_anchor	= ( DBOP_set_list_element + 1 ) ,
	DBOP_sort_list_element	= ( DBOP_sort_list_anchor + 1 ) ,
	DBOP_alter_character_set	= ( DBOP_sort_list_element + 1 ) ,
	DBOP_alter_collation	= ( DBOP_alter_character_set + 1 ) ,
	DBOP_alter_domain	= ( DBOP_alter_collation + 1 ) ,
	DBOP_alter_index	= ( DBOP_alter_domain + 1 ) ,
	DBOP_alter_procedure	= ( DBOP_alter_index + 1 ) ,
	DBOP_alter_schema	= ( DBOP_alter_procedure + 1 ) ,
	DBOP_alter_table	= ( DBOP_alter_schema + 1 ) ,
	DBOP_alter_trigger	= ( DBOP_alter_table + 1 ) ,
	DBOP_alter_view	= ( DBOP_alter_trigger + 1 ) ,
	DBOP_coldef_list_anchor	= ( DBOP_alter_view + 1 ) ,
	DBOP_coldef_list_element	= ( DBOP_coldef_list_anchor + 1 ) ,
	DBOP_create_assertion	= ( DBOP_coldef_list_element + 1 ) ,
	DBOP_create_character_set	= ( DBOP_create_assertion + 1 ) ,
	DBOP_create_collation	= ( DBOP_create_character_set + 1 ) ,
	DBOP_create_domain	= ( DBOP_create_collation + 1 ) ,
	DBOP_create_index	= ( DBOP_create_domain + 1 ) ,
	DBOP_create_procedure	= ( DBOP_create_index + 1 ) ,
	DBOP_create_schema	= ( DBOP_create_procedure + 1 ) ,
	DBOP_create_synonym	= ( DBOP_create_schema + 1 ) ,
	DBOP_create_table	= ( DBOP_create_synonym + 1 ) ,
	DBOP_create_temporary_table	= ( DBOP_create_table + 1 ) ,
	DBOP_create_translation	= ( DBOP_create_temporary_table + 1 ) ,
	DBOP_create_trigger	= ( DBOP_create_translation + 1 ) ,
	DBOP_create_view	= ( DBOP_create_trigger + 1 ) ,
	DBOP_drop_assertion	= ( DBOP_create_view + 1 ) ,
	DBOP_drop_character_set	= ( DBOP_drop_assertion + 1 ) ,
	DBOP_drop_collation	= ( DBOP_drop_character_set + 1 ) ,
	DBOP_drop_domain	= ( DBOP_drop_collation + 1 ) ,
	DBOP_drop_index	= ( DBOP_drop_domain + 1 ) ,
	DBOP_drop_procedure	= ( DBOP_drop_index + 1 ) ,
	DBOP_drop_schema	= ( DBOP_drop_procedure + 1 ) ,
	DBOP_drop_synonym	= ( DBOP_drop_schema + 1 ) ,
	DBOP_drop_table	= ( DBOP_drop_synonym + 1 ) ,
	DBOP_drop_translation	= ( DBOP_drop_table + 1 ) ,
	DBOP_drop_trigger	= ( DBOP_drop_translation + 1 ) ,
	DBOP_drop_view	= ( DBOP_drop_trigger + 1 ) ,
	DBOP_foreign_key	= ( DBOP_drop_view + 1 ) ,
	DBOP_grant_privileges	= ( DBOP_foreign_key + 1 ) ,
	DBOP_index_list_anchor	= ( DBOP_grant_privileges + 1 ) ,
	DBOP_index_list_element	= ( DBOP_index_list_anchor + 1 ) ,
	DBOP_primary_key	= ( DBOP_index_list_element + 1 ) ,
	DBOP_property_list_anchor	= ( DBOP_primary_key + 1 ) ,
	DBOP_property_list_element	= ( DBOP_property_list_anchor + 1 ) ,
	DBOP_referenced_table	= ( DBOP_property_list_element + 1 ) ,
	DBOP_rename_object	= ( DBOP_referenced_table + 1 ) ,
	DBOP_revoke_privileges	= ( DBOP_rename_object + 1 ) ,
	DBOP_schema_authorization	= ( DBOP_revoke_privileges + 1 ) ,
	DBOP_unique_key	= ( DBOP_schema_authorization + 1 ) ,
	DBOP_scope_list_anchor	= ( DBOP_unique_key + 1 ) ,
	DBOP_scope_list_element	= ( DBOP_scope_list_anchor + 1 ) ,
	DBOP_content_table	= ( DBOP_scope_list_element + 1 ) 
    } ;
#ifdef DBINITCONSTANTS
extern const OLEDBDECLSPEC GUID DBGUID_LIKE_SQL                        = {0xc8b521f6,0x5cf3,0x11ce,{0xad,0xe5,0x00,0xaa,0x00,0x44,0x77,0x3d}};
extern const OLEDBDECLSPEC GUID DBGUID_LIKE_DOS                        = {0xc8b521f7,0x5cf3,0x11ce,{0xad,0xe5,0x00,0xaa,0x00,0x44,0x77,0x3d}};
extern const OLEDBDECLSPEC GUID DBGUID_LIKE_OFS                        = {0xc8b521f8,0x5cf3,0x11ce,{0xad,0xe5,0x00,0xaa,0x00,0x44,0x77,0x3d}};
extern const OLEDBDECLSPEC GUID DBGUID_LIKE_MAPI                       = {0xc8b521f9,0x5cf3,0x11ce,{0xad,0xe5,0x00,0xaa,0x00,0x44,0x77,0x3d}};
#else // !DBINITCONSTANTS
extern const GUID DBGUID_LIKE_SQL;
extern const GUID DBGUID_LIKE_DOS;
extern const GUID DBGUID_LIKE_OFS;
extern const GUID DBGUID_LIKE_MAPI;
#endif // DBINITCONSTANTS


extern RPC_IF_HANDLE CommandTreeStructureDefinitions_v0_0_c_ifspec;
extern RPC_IF_HANDLE CommandTreeStructureDefinitions_v0_0_s_ifspec;
#endif /* __CommandTreeStructureDefinitions_INTERFACE_DEFINED__ */

#ifndef __ICommandTree_INTERFACE_DEFINED__
#define __ICommandTree_INTERFACE_DEFINED__

/* interface ICommandTree */
/* [unique][uuid][object][local] */ 

typedef DWORD DBCOMMANDREUSE;


enum DBCOMMANDREUSEENUM
    {	DBCOMMANDREUSE_NONE	= 0,
	DBCOMMANDREUSE_PROPERTIES	= 0x1,
	DBCOMMANDREUSE_PARAMETERS	= 0x2
    } ;
typedef DWORD DBVALUEKIND;


enum DBVALUEKINDENUM
    {	DBVALUEKIND_BYGUID	= 256,
	DBVALUEKIND_COLDESC	= ( DBVALUEKIND_BYGUID + 1 ) ,
	DBVALUEKIND_ID	= ( DBVALUEKIND_COLDESC + 1 ) ,
	DBVALUEKIND_CONTENT	= ( DBVALUEKIND_ID + 1 ) ,
	DBVALUEKIND_CONTENTVECTOR	= ( DBVALUEKIND_CONTENT + 1 ) ,
	DBVALUEKIND_GROUPINFO	= ( DBVALUEKIND_CONTENTVECTOR + 1 ) ,
	DBVALUEKIND_PARAMETER	= ( DBVALUEKIND_GROUPINFO + 1 ) ,
	DBVALUEKIND_PROPERTY	= ( DBVALUEKIND_PARAMETER + 1 ) ,
	DBVALUEKIND_SETFUNC	= ( DBVALUEKIND_PROPERTY + 1 ) ,
	DBVALUEKIND_SORTINFO	= ( DBVALUEKIND_SETFUNC + 1 ) ,
	DBVALUEKIND_TEXT	= ( DBVALUEKIND_SORTINFO + 1 ) ,
	DBVALUEKIND_COMMAND	= ( DBVALUEKIND_TEXT + 1 ) ,
	DBVALUEKIND_MONIKER	= ( DBVALUEKIND_COMMAND + 1 ) ,
	DBVALUEKIND_ROWSET	= ( DBVALUEKIND_MONIKER + 1 ) ,
	DBVALUEKIND_LIKE	= ( DBVALUEKIND_ROWSET + 1 ) ,
	DBVALUEKIND_CONTENTPROXIMITY	= ( DBVALUEKIND_LIKE + 1 ) ,
	DBVALUEKIND_CONTENTSCOPE	= ( DBVALUEKIND_CONTENTPROXIMITY + 1 ) ,
	DBVALUEKIND_CONTENTTABLE	= ( DBVALUEKIND_CONTENTSCOPE + 1 ) ,
	DBVALUEKIND_IDISPATCH	= 9,
	DBVALUEKIND_IUNKNOWN	= 13,
	DBVALUEKIND_EMPTY	= 0,
	DBVALUEKIND_NULL	= 1,
	DBVALUEKIND_I2	= 2,
	DBVALUEKIND_I4	= 3,
	DBVALUEKIND_R4	= 4,
	DBVALUEKIND_R8	= 5,
	DBVALUEKIND_CY	= 6,
	DBVALUEKIND_DATE	= 7,
	DBVALUEKIND_BSTR	= 8,
	DBVALUEKIND_ERROR	= 10,
	DBVALUEKIND_BOOL	= 11,
	DBVALUEKIND_VARIANT	= 12,
	DBVALUEKIND_VECTOR	= 0x1000,
	DBVALUEKIND_ARRAY	= 0x2000,
	DBVALUEKIND_BYREF	= 0x4000,
	DBVALUEKIND_I1	= 16,
	DBVALUEKIND_UI1	= 17,
	DBVALUEKIND_UI2	= 18,
	DBVALUEKIND_UI4	= ( DBVALUEKIND_UI2 + 1 ) ,
	DBVALUEKIND_I8	= ( DBVALUEKIND_UI4 + 1 ) ,
	DBVALUEKIND_UI8	= ( DBVALUEKIND_I8 + 1 ) ,
	DBVALUEKIND_GUID	= 72,
	DBVALUEKIND_BYTES	= 128,
	DBVALUEKIND_STR	= 129,
	DBVALUEKIND_WSTR	= 130,
	DBVALUEKIND_NUMERIC	= 131,
	DBVALUEKIND_DBDATE	= 133,
	DBVALUEKIND_DBTIME	= 134,
	DBVALUEKIND_DBTIMESTAMP	= 135,
	DBVALUEKIND_PROBABILISTIC	= 136,
	DBVALUEKIND_RELEVANTDOCUMENT	= 137
    } ;
typedef struct tagDBBYGUID
    {
    BYTE *pbInfo;
    DBLENGTH cbInfo;
    GUID guid;
    } 	DBBYGUID;

#define GENERATE_METHOD_EXACT    ( 0 )
#define GENERATE_METHOD_PREFIX   ( 1 )
#define GENERATE_METHOD_INFLECT  ( 2 )
typedef struct tagDBCONTENT
    {
    LPOLESTR pwszPhrase;
    DWORD dwGenerateMethod;
    LONG lWeight;
    LCID lcid;
    } 	DBCONTENT;

#define SCOPE_FLAG_MASK      ( 0x000000ff )
#define SCOPE_FLAG_INCLUDE   ( 0x00000001 )
#define SCOPE_FLAG_DEEP      ( 0x00000002 )
#define SCOPE_TYPE_MASK      ( 0xffffff00 )
#define SCOPE_TYPE_WINPATH   ( 0x00000100 )
#define SCOPE_TYPE_VPATH     ( 0x00000200 )
typedef struct tagDBCONTENTSCOPE
    {
    DWORD dwFlags;
    LPOLESTR *rgpwszTagName;
    LPOLESTR pwszElementValue;
    } 	DBCONTENTSCOPE;

typedef struct tagDBCONTENTTABLE
    {
    LPOLESTR pwszMachine;
    LPOLESTR pwszCatalog;
    } 	DBCONTENTTABLE;

#define PROPID_QUERY_RANKVECTOR  ( 0x2 )
#define PROPID_QUERY_RANK        ( 0x3 )
#define PROPID_QUERY_HITCOUNT    ( 0x4 )
#define PROPID_QUERY_ALL         ( 0x6 )
#define PROPID_STG_CONTENTS      ( 0x13 )
#define VECTOR_RANK_MIN          ( 0 )
#define VECTOR_RANK_MAX          ( 1 )
#define VECTOR_RANK_INNER        ( 2 )
#define VECTOR_RANK_DICE         ( 3 )
#define VECTOR_RANK_JACCARD      ( 4 )
typedef struct tagDBCONTENTVECTOR
    {
    LONG lWeight;
    DWORD dwRankingMethod;
    } 	DBCONTENTVECTOR;

typedef struct tagDBGROUPINFO
    {
    LCID lcid;
    } 	DBGROUPINFO;

typedef struct tagDBPARAMETER
    {
    LPOLESTR pwszName;
    ITypeInfo *pTypeInfo;
    DB_NUMERIC *pNum;
    DBLENGTH cbMaxLength;
    DBPARAMFLAGS dwFlags;
    DBTYPE wType;
    } 	DBPARAMETER;

#define DBSETFUNC_NONE       0x0
#define DBSETFUNC_ALL        0x1
#define DBSETFUNC_DISTINCT   0x2
typedef struct tagDBSETFUNC
    {
    DWORD dwSetQuantifier;
    } 	DBSETFUNC;

typedef struct tagDBSORTINFO
    {
    BOOL fDesc;
    LCID lcid;
    } 	DBSORTINFO;

typedef struct tagDBTEXT
    {
    LPOLESTR pwszText;
    ULONG ulErrorLocator;
    ULONG ulTokenLength;
    GUID guidDialect;
    } 	DBTEXT;

typedef struct tagDBLIKE
    {
    LONG lWeight;
    GUID guidDialect;
    } 	DBLIKE;

#define PROXIMITY_UNIT_WORD           ( 0 )
#define PROXIMITY_UNIT_SENTENCE       ( 1 )
#define PROXIMITY_UNIT_PARAGRAPH      ( 2 )
#define PROXIMITY_UNIT_CHAPTER        ( 3 )
typedef struct tagDBCONTENTPROXIMITY
    {
    DWORD dwProximityUnit;
    ULONG ulProximityDistance;
    LONG lWeight;
    } 	DBCONTENTPROXIMITY;

typedef struct tagDBPROBABILISTIC
    {
    LONG lWeight;
    float flK1;
    float flK2;
    float flK3;
    float flB;
    } 	DBPROBABILISTIC;

typedef struct tagDBRELEVANTDOCUMENT
    {
    LONG lWeight;
    VARIANT vDocument;
    } 	DBRELEVANTDOCUMENT;

typedef struct tagDBCOMMANDTREE
    {
    DBCOMMANDOP op;
    WORD wKind;
    struct tagDBCOMMANDTREE *pctFirstChild;
    struct tagDBCOMMANDTREE *pctNextSibling;
    union 
        {
        __int64 llValue;
        unsigned __int64 ullValue;
        BOOL fValue;
        unsigned char uchValue;
        signed char schValue;
        unsigned short usValue;
        short sValue;
        LPOLESTR pwszValue;
        LONG lValue;
        ULONG ulValue;
        float flValue;
        double dblValue;
        CY cyValue;
        DATE dateValue;
        DBDATE dbdateValue;
        DBTIME dbtimeValue;
        SCODE scodeValue;
        BSTR *pbstrValue;
        ICommand *pCommand;
        IDispatch *pDispatch;
        IMoniker *pMoniker;
        IRowset *pRowset;
        IUnknown *pUnknown;
        DBBYGUID *pdbbygdValue;
        DBCOLUMNDESC *pcoldescValue;
        DBID *pdbidValue;
        DBLIKE *pdblikeValue;
        DBCONTENT *pdbcntntValue;
        DBCONTENTSCOPE *pdbcntntscpValue;
        DBCONTENTTABLE *pdbcntnttblValue;
        DBCONTENTVECTOR *pdbcntntvcValue;
        DBCONTENTPROXIMITY *pdbcntntproxValue;
        DBGROUPINFO *pdbgrpinfValue;
        DBPARAMETER *pdbparamValue;
        DBPROPSET *pdbpropValue;
        DBSETFUNC *pdbstfncValue;
        DBSORTINFO *pdbsrtinfValue;
        DBTEXT *pdbtxtValue;
        DBVECTOR *pdbvectorValue;
        SAFEARRAY *parrayValue;
        VARIANT *pvarValue;
        GUID *pGuid;
        BYTE *pbValue;
        char *pzValue;
        DB_NUMERIC *pdbnValue;
        DBTIMESTAMP *pdbtsValue;
        void *pvValue;
        DBPROBABILISTIC *pdbprobValue;
        DBRELEVANTDOCUMENT *pdbreldocValue;
        } 	value;
    HRESULT hrError;
    } 	DBCOMMANDTREE;


EXTERN_C const IID IID_ICommandTree;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("0c733a87-2a1c-11ce-ade5-00aa0044773d")
    ICommandTree : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE FindErrorNodes( 
            /* [in] */ const DBCOMMANDTREE *pRoot,
            /* [out] */ ULONG *pcErrorNodes,
            /* [out] */ DBCOMMANDTREE ***prgErrorNodes) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE FreeCommandTree( 
            /* [in] */ DBCOMMANDTREE **ppRoot) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetCommandTree( 
            /* [out] */ DBCOMMANDTREE **ppRoot) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetCommandTree( 
            /* [in] */ DBCOMMANDTREE **ppRoot,
            /* [in] */ DBCOMMANDREUSE dwCommandReuse,
            /* [in] */ BOOL fCopy) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct ICommandTreeVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            ICommandTree * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            ICommandTree * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            ICommandTree * This);
        
        HRESULT ( STDMETHODCALLTYPE *FindErrorNodes )( 
            ICommandTree * This,
            /* [in] */ const DBCOMMANDTREE *pRoot,
            /* [out] */ ULONG *pcErrorNodes,
            /* [out] */ DBCOMMANDTREE ***prgErrorNodes);
        
        HRESULT ( STDMETHODCALLTYPE *FreeCommandTree )( 
            ICommandTree * This,
            /* [in] */ DBCOMMANDTREE **ppRoot);
        
        HRESULT ( STDMETHODCALLTYPE *GetCommandTree )( 
            ICommandTree * This,
            /* [out] */ DBCOMMANDTREE **ppRoot);
        
        HRESULT ( STDMETHODCALLTYPE *SetCommandTree )( 
            ICommandTree * This,
            /* [in] */ DBCOMMANDTREE **ppRoot,
            /* [in] */ DBCOMMANDREUSE dwCommandReuse,
            /* [in] */ BOOL fCopy);
        
        END_INTERFACE
    } ICommandTreeVtbl;

    interface ICommandTree
    {
        CONST_VTBL struct ICommandTreeVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define ICommandTree_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define ICommandTree_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define ICommandTree_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define ICommandTree_FindErrorNodes(This,pRoot,pcErrorNodes,prgErrorNodes)	\
    ( (This)->lpVtbl -> FindErrorNodes(This,pRoot,pcErrorNodes,prgErrorNodes) ) 

#define ICommandTree_FreeCommandTree(This,ppRoot)	\
    ( (This)->lpVtbl -> FreeCommandTree(This,ppRoot) ) 

#define ICommandTree_GetCommandTree(This,ppRoot)	\
    ( (This)->lpVtbl -> GetCommandTree(This,ppRoot) ) 

#define ICommandTree_SetCommandTree(This,ppRoot,dwCommandReuse,fCopy)	\
    ( (This)->lpVtbl -> SetCommandTree(This,ppRoot,dwCommandReuse,fCopy) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __ICommandTree_INTERFACE_DEFINED__ */


#ifndef __IQuery_INTERFACE_DEFINED__
#define __IQuery_INTERFACE_DEFINED__

/* interface IQuery */
/* [unique][uuid][object][local] */ 


EXTERN_C const IID IID_IQuery;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("0c733a51-2a1c-11ce-ade5-00aa0044773d")
    IQuery : public ICommandTree
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE AddPostProcessing( 
            /* [in] */ DBCOMMANDTREE **ppRoot,
            /* [in] */ BOOL fCopy) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetCardinalityEstimate( 
            /* [out] */ DBORDINAL *pulCardinality) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IQueryVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IQuery * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IQuery * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IQuery * This);
        
        HRESULT ( STDMETHODCALLTYPE *FindErrorNodes )( 
            IQuery * This,
            /* [in] */ const DBCOMMANDTREE *pRoot,
            /* [out] */ ULONG *pcErrorNodes,
            /* [out] */ DBCOMMANDTREE ***prgErrorNodes);
        
        HRESULT ( STDMETHODCALLTYPE *FreeCommandTree )( 
            IQuery * This,
            /* [in] */ DBCOMMANDTREE **ppRoot);
        
        HRESULT ( STDMETHODCALLTYPE *GetCommandTree )( 
            IQuery * This,
            /* [out] */ DBCOMMANDTREE **ppRoot);
        
        HRESULT ( STDMETHODCALLTYPE *SetCommandTree )( 
            IQuery * This,
            /* [in] */ DBCOMMANDTREE **ppRoot,
            /* [in] */ DBCOMMANDREUSE dwCommandReuse,
            /* [in] */ BOOL fCopy);
        
        HRESULT ( STDMETHODCALLTYPE *AddPostProcessing )( 
            IQuery * This,
            /* [in] */ DBCOMMANDTREE **ppRoot,
            /* [in] */ BOOL fCopy);
        
        HRESULT ( STDMETHODCALLTYPE *GetCardinalityEstimate )( 
            IQuery * This,
            /* [out] */ DBORDINAL *pulCardinality);
        
        END_INTERFACE
    } IQueryVtbl;

    interface IQuery
    {
        CONST_VTBL struct IQueryVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IQuery_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IQuery_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IQuery_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IQuery_FindErrorNodes(This,pRoot,pcErrorNodes,prgErrorNodes)	\
    ( (This)->lpVtbl -> FindErrorNodes(This,pRoot,pcErrorNodes,prgErrorNodes) ) 

#define IQuery_FreeCommandTree(This,ppRoot)	\
    ( (This)->lpVtbl -> FreeCommandTree(This,ppRoot) ) 

#define IQuery_GetCommandTree(This,ppRoot)	\
    ( (This)->lpVtbl -> GetCommandTree(This,ppRoot) ) 

#define IQuery_SetCommandTree(This,ppRoot,dwCommandReuse,fCopy)	\
    ( (This)->lpVtbl -> SetCommandTree(This,ppRoot,dwCommandReuse,fCopy) ) 


#define IQuery_AddPostProcessing(This,ppRoot,fCopy)	\
    ( (This)->lpVtbl -> AddPostProcessing(This,ppRoot,fCopy) ) 

#define IQuery_GetCardinalityEstimate(This,pulCardinality)	\
    ( (This)->lpVtbl -> GetCardinalityEstimate(This,pulCardinality) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IQuery_INTERFACE_DEFINED__ */


/* interface __MIDL_itf_cmdtree_0000_0003 */
/* [local] */ 

#include <poppack.h>     // restore original structure packing


extern RPC_IF_HANDLE __MIDL_itf_cmdtree_0000_0003_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_cmdtree_0000_0003_v0_0_s_ifspec;

/* Additional Prototypes for ALL interfaces */

/* end of Additional Prototypes */

#ifdef __cplusplus
}
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\vs9sp1\sdk\include\clrdata.h ===
/* this ALWAYS GENERATED file contains the definitions for the interfaces */


 /* File created by MIDL compiler version 6.00.0366 */
/* Compiler settings for clrdata.idl:
    Oicf, W1, Zp8, env=Win32 (32b run)
    protocol : dce , ms_ext, c_ext, robust
    error checks: allocation ref bounds_check enum stub_data 
    VC __declspec() decoration level: 
         __declspec(uuid()), __declspec(selectany), __declspec(novtable)
         DECLSPEC_UUID(), MIDL_INTERFACE()
*/
//@@MIDL_FILE_HEADING(  )

#pragma warning( disable: 4049 )  /* more than 64k source lines */


/* verify that the <rpcndr.h> version is high enough to compile this file*/
#ifndef __REQUIRED_RPCNDR_H_VERSION__
#define __REQUIRED_RPCNDR_H_VERSION__ 475
#endif

#include "rpc.h"
#include "rpcndr.h"

#ifndef __RPCNDR_H_VERSION__
#error this stub requires an updated version of <rpcndr.h>
#endif // __RPCNDR_H_VERSION__

#ifndef COM_NO_WINDOWS_H
#include "windows.h"
#include "ole2.h"
#endif /*COM_NO_WINDOWS_H*/

#ifndef __clrdata_h__
#define __clrdata_h__

#if defined(_MSC_VER) && (_MSC_VER >= 1020)
#pragma once
#endif

/* Forward Declarations */ 

#ifndef __ICLRDataTarget_FWD_DEFINED__
#define __ICLRDataTarget_FWD_DEFINED__
typedef interface ICLRDataTarget ICLRDataTarget;
#endif 	/* __ICLRDataTarget_FWD_DEFINED__ */


#ifndef __ICLRDataTarget2_FWD_DEFINED__
#define __ICLRDataTarget2_FWD_DEFINED__
typedef interface ICLRDataTarget2 ICLRDataTarget2;
#endif 	/* __ICLRDataTarget2_FWD_DEFINED__ */


#ifndef __ICLRMetadataLocator_FWD_DEFINED__
#define __ICLRMetadataLocator_FWD_DEFINED__
typedef interface ICLRMetadataLocator ICLRMetadataLocator;
#endif 	/* __ICLRMetadataLocator_FWD_DEFINED__ */


#ifndef __ICLRDataEnumMemoryRegionsCallback_FWD_DEFINED__
#define __ICLRDataEnumMemoryRegionsCallback_FWD_DEFINED__
typedef interface ICLRDataEnumMemoryRegionsCallback ICLRDataEnumMemoryRegionsCallback;
#endif 	/* __ICLRDataEnumMemoryRegionsCallback_FWD_DEFINED__ */


#ifndef __ICLRDataEnumMemoryRegions_FWD_DEFINED__
#define __ICLRDataEnumMemoryRegions_FWD_DEFINED__
typedef interface ICLRDataEnumMemoryRegions ICLRDataEnumMemoryRegions;
#endif 	/* __ICLRDataEnumMemoryRegions_FWD_DEFINED__ */


/* header files for imported files */
#include "unknwn.h"

#ifdef __cplusplus
extern "C"{
#endif 

void * __RPC_USER MIDL_user_allocate(size_t);
void __RPC_USER MIDL_user_free( void * ); 

/* interface __MIDL_itf_clrdata_0000 */
/* [local] */ 






typedef ULONG64 CLRDATA_ADDRESS;

STDAPI CLRDataCreateInstance(REFIID iid, ICLRDataTarget* target, void** iface);
typedef HRESULT (STDAPICALLTYPE* PFN_CLRDataCreateInstance)(REFIID iid, ICLRDataTarget* target, void** iface);


extern RPC_IF_HANDLE __MIDL_itf_clrdata_0000_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_clrdata_0000_v0_0_s_ifspec;

#ifndef __ICLRDataTarget_INTERFACE_DEFINED__
#define __ICLRDataTarget_INTERFACE_DEFINED__

/* interface ICLRDataTarget */
/* [unique][uuid][object] */ 


EXTERN_C const IID IID_ICLRDataTarget;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("3E11CCEE-D08B-43e5-AF01-32717A64DA03")
    ICLRDataTarget : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE GetMachineType( 
            /* [out] */ ULONG32 *machineType) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetPointerSize( 
            /* [out] */ ULONG32 *pointerSize) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetImageBase( 
            /* [string][in] */ LPCWSTR imagePath,
            /* [out] */ CLRDATA_ADDRESS *baseAddress) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE ReadVirtual( 
            /* [in] */ CLRDATA_ADDRESS address,
            /* [length_is][size_is][out] */ BYTE *buffer,
            /* [in] */ ULONG32 bytesRequested,
            /* [out] */ ULONG32 *bytesRead) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE WriteVirtual( 
            /* [in] */ CLRDATA_ADDRESS address,
            /* [size_is][in] */ BYTE *buffer,
            /* [in] */ ULONG32 bytesRequested,
            /* [out] */ ULONG32 *bytesWritten) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetTLSValue( 
            /* [in] */ ULONG32 threadID,
            /* [in] */ ULONG32 index,
            /* [out] */ CLRDATA_ADDRESS *value) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetTLSValue( 
            /* [in] */ ULONG32 threadID,
            /* [in] */ ULONG32 index,
            /* [in] */ CLRDATA_ADDRESS value) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetCurrentThreadID( 
            /* [out] */ ULONG32 *threadID) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetThreadContext( 
            /* [in] */ ULONG32 threadID,
            /* [in] */ ULONG32 contextFlags,
            /* [in] */ ULONG32 contextSize,
            /* [size_is][out] */ BYTE *context) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetThreadContext( 
            /* [in] */ ULONG32 threadID,
            /* [in] */ ULONG32 contextSize,
            /* [size_is][in] */ BYTE *context) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Request( 
            /* [in] */ ULONG32 reqCode,
            /* [in] */ ULONG32 inBufferSize,
            /* [size_is][in] */ BYTE *inBuffer,
            /* [in] */ ULONG32 outBufferSize,
            /* [size_is][out] */ BYTE *outBuffer) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct ICLRDataTargetVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            ICLRDataTarget * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            ICLRDataTarget * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            ICLRDataTarget * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetMachineType )( 
            ICLRDataTarget * This,
            /* [out] */ ULONG32 *machineType);
        
        HRESULT ( STDMETHODCALLTYPE *GetPointerSize )( 
            ICLRDataTarget * This,
            /* [out] */ ULONG32 *pointerSize);
        
        HRESULT ( STDMETHODCALLTYPE *GetImageBase )( 
            ICLRDataTarget * This,
            /* [string][in] */ LPCWSTR imagePath,
            /* [out] */ CLRDATA_ADDRESS *baseAddress);
        
        HRESULT ( STDMETHODCALLTYPE *ReadVirtual )( 
            ICLRDataTarget * This,
            /* [in] */ CLRDATA_ADDRESS address,
            /* [length_is][size_is][out] */ BYTE *buffer,
            /* [in] */ ULONG32 bytesRequested,
            /* [out] */ ULONG32 *bytesRead);
        
        HRESULT ( STDMETHODCALLTYPE *WriteVirtual )( 
            ICLRDataTarget * This,
            /* [in] */ CLRDATA_ADDRESS address,
            /* [size_is][in] */ BYTE *buffer,
            /* [in] */ ULONG32 bytesRequested,
            /* [out] */ ULONG32 *bytesWritten);
        
        HRESULT ( STDMETHODCALLTYPE *GetTLSValue )( 
            ICLRDataTarget * This,
            /* [in] */ ULONG32 threadID,
            /* [in] */ ULONG32 index,
            /* [out] */ CLRDATA_ADDRESS *value);
        
        HRESULT ( STDMETHODCALLTYPE *SetTLSValue )( 
            ICLRDataTarget * This,
            /* [in] */ ULONG32 threadID,
            /* [in] */ ULONG32 index,
            /* [in] */ CLRDATA_ADDRESS value);
        
        HRESULT ( STDMETHODCALLTYPE *GetCurrentThreadID )( 
            ICLRDataTarget * This,
            /* [out] */ ULONG32 *threadID);
        
        HRESULT ( STDMETHODCALLTYPE *GetThreadContext )( 
            ICLRDataTarget * This,
            /* [in] */ ULONG32 threadID,
            /* [in] */ ULONG32 contextFlags,
            /* [in] */ ULONG32 contextSize,
            /* [size_is][out] */ BYTE *context);
        
        HRESULT ( STDMETHODCALLTYPE *SetThreadContext )( 
            ICLRDataTarget * This,
            /* [in] */ ULONG32 threadID,
            /* [in] */ ULONG32 contextSize,
            /* [size_is][in] */ BYTE *context);
        
        HRESULT ( STDMETHODCALLTYPE *Request )( 
            ICLRDataTarget * This,
            /* [in] */ ULONG32 reqCode,
            /* [in] */ ULONG32 inBufferSize,
            /* [size_is][in] */ BYTE *inBuffer,
            /* [in] */ ULONG32 outBufferSize,
            /* [size_is][out] */ BYTE *outBuffer);
        
        END_INTERFACE
    } ICLRDataTargetVtbl;

    interface ICLRDataTarget
    {
        CONST_VTBL struct ICLRDataTargetVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define ICLRDataTarget_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define ICLRDataTarget_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define ICLRDataTarget_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define ICLRDataTarget_GetMachineType(This,machineType)	\
    (This)->lpVtbl -> GetMachineType(This,machineType)

#define ICLRDataTarget_GetPointerSize(This,pointerSize)	\
    (This)->lpVtbl -> GetPointerSize(This,pointerSize)

#define ICLRDataTarget_GetImageBase(This,imagePath,baseAddress)	\
    (This)->lpVtbl -> GetImageBase(This,imagePath,baseAddress)

#define ICLRDataTarget_ReadVirtual(This,address,buffer,bytesRequested,bytesRead)	\
    (This)->lpVtbl -> ReadVirtual(This,address,buffer,bytesRequested,bytesRead)

#define ICLRDataTarget_WriteVirtual(This,address,buffer,bytesRequested,bytesWritten)	\
    (This)->lpVtbl -> WriteVirtual(This,address,buffer,bytesRequested,bytesWritten)

#define ICLRDataTarget_GetTLSValue(This,threadID,index,value)	\
    (This)->lpVtbl -> GetTLSValue(This,threadID,index,value)

#define ICLRDataTarget_SetTLSValue(This,threadID,index,value)	\
    (This)->lpVtbl -> SetTLSValue(This,threadID,index,value)

#define ICLRDataTarget_GetCurrentThreadID(This,threadID)	\
    (This)->lpVtbl -> GetCurrentThreadID(This,threadID)

#define ICLRDataTarget_GetThreadContext(This,threadID,contextFlags,contextSize,context)	\
    (This)->lpVtbl -> GetThreadContext(This,threadID,contextFlags,contextSize,context)

#define ICLRDataTarget_SetThreadContext(This,threadID,contextSize,context)	\
    (This)->lpVtbl -> SetThreadContext(This,threadID,contextSize,context)

#define ICLRDataTarget_Request(This,reqCode,inBufferSize,inBuffer,outBufferSize,outBuffer)	\
    (This)->lpVtbl -> Request(This,reqCode,inBufferSize,inBuffer,outBufferSize,outBuffer)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE ICLRDataTarget_GetMachineType_Proxy( 
    ICLRDataTarget * This,
    /* [out] */ ULONG32 *machineType);


void __RPC_STUB ICLRDataTarget_GetMachineType_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ICLRDataTarget_GetPointerSize_Proxy( 
    ICLRDataTarget * This,
    /* [out] */ ULONG32 *pointerSize);


void __RPC_STUB ICLRDataTarget_GetPointerSize_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ICLRDataTarget_GetImageBase_Proxy( 
    ICLRDataTarget * This,
    /* [string][in] */ LPCWSTR imagePath,
    /* [out] */ CLRDATA_ADDRESS *baseAddress);


void __RPC_STUB ICLRDataTarget_GetImageBase_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ICLRDataTarget_ReadVirtual_Proxy( 
    ICLRDataTarget * This,
    /* [in] */ CLRDATA_ADDRESS address,
    /* [length_is][size_is][out] */ BYTE *buffer,
    /* [in] */ ULONG32 bytesRequested,
    /* [out] */ ULONG32 *bytesRead);


void __RPC_STUB ICLRDataTarget_ReadVirtual_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ICLRDataTarget_WriteVirtual_Proxy( 
    ICLRDataTarget * This,
    /* [in] */ CLRDATA_ADDRESS address,
    /* [size_is][in] */ BYTE *buffer,
    /* [in] */ ULONG32 bytesRequested,
    /* [out] */ ULONG32 *bytesWritten);


void __RPC_STUB ICLRDataTarget_WriteVirtual_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ICLRDataTarget_GetTLSValue_Proxy( 
    ICLRDataTarget * This,
    /* [in] */ ULONG32 threadID,
    /* [in] */ ULONG32 index,
    /* [out] */ CLRDATA_ADDRESS *value);


void __RPC_STUB ICLRDataTarget_GetTLSValue_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ICLRDataTarget_SetTLSValue_Proxy( 
    ICLRDataTarget * This,
    /* [in] */ ULONG32 threadID,
    /* [in] */ ULONG32 index,
    /* [in] */ CLRDATA_ADDRESS value);


void __RPC_STUB ICLRDataTarget_SetTLSValue_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ICLRDataTarget_GetCurrentThreadID_Proxy( 
    ICLRDataTarget * This,
    /* [out] */ ULONG32 *threadID);


void __RPC_STUB ICLRDataTarget_GetCurrentThreadID_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ICLRDataTarget_GetThreadContext_Proxy( 
    ICLRDataTarget * This,
    /* [in] */ ULONG32 threadID,
    /* [in] */ ULONG32 contextFlags,
    /* [in] */ ULONG32 contextSize,
    /* [size_is][out] */ BYTE *context);


void __RPC_STUB ICLRDataTarget_GetThreadContext_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ICLRDataTarget_SetThreadContext_Proxy( 
    ICLRDataTarget * This,
    /* [in] */ ULONG32 threadID,
    /* [in] */ ULONG32 contextSize,
    /* [size_is][in] */ BYTE *context);


void __RPC_STUB ICLRDataTarget_SetThreadContext_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ICLRDataTarget_Request_Proxy( 
    ICLRDataTarget * This,
    /* [in] */ ULONG32 reqCode,
    /* [in] */ ULONG32 inBufferSize,
    /* [size_is][in] */ BYTE *inBuffer,
    /* [in] */ ULONG32 outBufferSize,
    /* [size_is][out] */ BYTE *outBuffer);


void __RPC_STUB ICLRDataTarget_Request_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __ICLRDataTarget_INTERFACE_DEFINED__ */


#ifndef __ICLRDataTarget2_INTERFACE_DEFINED__
#define __ICLRDataTarget2_INTERFACE_DEFINED__

/* interface ICLRDataTarget2 */
/* [unique][uuid][object] */ 


EXTERN_C const IID IID_ICLRDataTarget2;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("6d05fae3-189c-4630-a6dc-1c251e1c01ab")
    ICLRDataTarget2 : public ICLRDataTarget
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE AllocVirtual( 
            /* [in] */ CLRDATA_ADDRESS addr,
            /* [in] */ ULONG32 size,
            /* [in] */ ULONG32 typeFlags,
            /* [in] */ ULONG32 protectFlags,
            /* [out] */ CLRDATA_ADDRESS *virt) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE FreeVirtual( 
            /* [in] */ CLRDATA_ADDRESS addr,
            /* [in] */ ULONG32 size,
            /* [in] */ ULONG32 typeFlags) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct ICLRDataTarget2Vtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            ICLRDataTarget2 * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            ICLRDataTarget2 * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            ICLRDataTarget2 * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetMachineType )( 
            ICLRDataTarget2 * This,
            /* [out] */ ULONG32 *machineType);
        
        HRESULT ( STDMETHODCALLTYPE *GetPointerSize )( 
            ICLRDataTarget2 * This,
            /* [out] */ ULONG32 *pointerSize);
        
        HRESULT ( STDMETHODCALLTYPE *GetImageBase )( 
            ICLRDataTarget2 * This,
            /* [string][in] */ LPCWSTR imagePath,
            /* [out] */ CLRDATA_ADDRESS *baseAddress);
        
        HRESULT ( STDMETHODCALLTYPE *ReadVirtual )( 
            ICLRDataTarget2 * This,
            /* [in] */ CLRDATA_ADDRESS address,
            /* [length_is][size_is][out] */ BYTE *buffer,
            /* [in] */ ULONG32 bytesRequested,
            /* [out] */ ULONG32 *bytesRead);
        
        HRESULT ( STDMETHODCALLTYPE *WriteVirtual )( 
            ICLRDataTarget2 * This,
            /* [in] */ CLRDATA_ADDRESS address,
            /* [size_is][in] */ BYTE *buffer,
            /* [in] */ ULONG32 bytesRequested,
            /* [out] */ ULONG32 *bytesWritten);
        
        HRESULT ( STDMETHODCALLTYPE *GetTLSValue )( 
            ICLRDataTarget2 * This,
            /* [in] */ ULONG32 threadID,
            /* [in] */ ULONG32 index,
            /* [out] */ CLRDATA_ADDRESS *value);
        
        HRESULT ( STDMETHODCALLTYPE *SetTLSValue )( 
            ICLRDataTarget2 * This,
            /* [in] */ ULONG32 threadID,
            /* [in] */ ULONG32 index,
            /* [in] */ CLRDATA_ADDRESS value);
        
        HRESULT ( STDMETHODCALLTYPE *GetCurrentThreadID )( 
            ICLRDataTarget2 * This,
            /* [out] */ ULONG32 *threadID);
        
        HRESULT ( STDMETHODCALLTYPE *GetThreadContext )( 
            ICLRDataTarget2 * This,
            /* [in] */ ULONG32 threadID,
            /* [in] */ ULONG32 contextFlags,
            /* [in] */ ULONG32 contextSize,
            /* [size_is][out] */ BYTE *context);
        
        HRESULT ( STDMETHODCALLTYPE *SetThreadContext )( 
            ICLRDataTarget2 * This,
            /* [in] */ ULONG32 threadID,
            /* [in] */ ULONG32 contextSize,
            /* [size_is][in] */ BYTE *context);
        
        HRESULT ( STDMETHODCALLTYPE *Request )( 
            ICLRDataTarget2 * This,
            /* [in] */ ULONG32 reqCode,
            /* [in] */ ULONG32 inBufferSize,
            /* [size_is][in] */ BYTE *inBuffer,
            /* [in] */ ULONG32 outBufferSize,
            /* [size_is][out] */ BYTE *outBuffer);
        
        HRESULT ( STDMETHODCALLTYPE *AllocVirtual )( 
            ICLRDataTarget2 * This,
            /* [in] */ CLRDATA_ADDRESS addr,
            /* [in] */ ULONG32 size,
            /* [in] */ ULONG32 typeFlags,
            /* [in] */ ULONG32 protectFlags,
            /* [out] */ CLRDATA_ADDRESS *virt);
        
        HRESULT ( STDMETHODCALLTYPE *FreeVirtual )( 
            ICLRDataTarget2 * This,
            /* [in] */ CLRDATA_ADDRESS addr,
            /* [in] */ ULONG32 size,
            /* [in] */ ULONG32 typeFlags);
        
        END_INTERFACE
    } ICLRDataTarget2Vtbl;

    interface ICLRDataTarget2
    {
        CONST_VTBL struct ICLRDataTarget2Vtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define ICLRDataTarget2_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define ICLRDataTarget2_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define ICLRDataTarget2_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define ICLRDataTarget2_GetMachineType(This,machineType)	\
    (This)->lpVtbl -> GetMachineType(This,machineType)

#define ICLRDataTarget2_GetPointerSize(This,pointerSize)	\
    (This)->lpVtbl -> GetPointerSize(This,pointerSize)

#define ICLRDataTarget2_GetImageBase(This,imagePath,baseAddress)	\
    (This)->lpVtbl -> GetImageBase(This,imagePath,baseAddress)

#define ICLRDataTarget2_ReadVirtual(This,address,buffer,bytesRequested,bytesRead)	\
    (This)->lpVtbl -> ReadVirtual(This,address,buffer,bytesRequested,bytesRead)

#define ICLRDataTarget2_WriteVirtual(This,address,buffer,bytesRequested,bytesWritten)	\
    (This)->lpVtbl -> WriteVirtual(This,address,buffer,bytesRequested,bytesWritten)

#define ICLRDataTarget2_GetTLSValue(This,threadID,index,value)	\
    (This)->lpVtbl -> GetTLSValue(This,threadID,index,value)

#define ICLRDataTarget2_SetTLSValue(This,threadID,index,value)	\
    (This)->lpVtbl -> SetTLSValue(This,threadID,index,value)

#define ICLRDataTarget2_GetCurrentThreadID(This,threadID)	\
    (This)->lpVtbl -> GetCurrentThreadID(This,threadID)

#define ICLRDataTarget2_GetThreadContext(This,threadID,contextFlags,contextSize,context)	\
    (This)->lpVtbl -> GetThreadContext(This,threadID,contextFlags,contextSize,context)

#define ICLRDataTarget2_SetThreadContext(This,threadID,contextSize,context)	\
    (This)->lpVtbl -> SetThreadContext(This,threadID,contextSize,context)

#define ICLRDataTarget2_Request(This,reqCode,inBufferSize,inBuffer,outBufferSize,outBuffer)	\
    (This)->lpVtbl -> Request(This,reqCode,inBufferSize,inBuffer,outBufferSize,outBuffer)


#define ICLRDataTarget2_AllocVirtual(This,addr,size,typeFlags,protectFlags,virt)	\
    (This)->lpVtbl -> AllocVirtual(This,addr,size,typeFlags,protectFlags,virt)

#define ICLRDataTarget2_FreeVirtual(This,addr,size,typeFlags)	\
    (This)->lpVtbl -> FreeVirtual(This,addr,size,typeFlags)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE ICLRDataTarget2_AllocVirtual_Proxy( 
    ICLRDataTarget2 * This,
    /* [in] */ CLRDATA_ADDRESS addr,
    /* [in] */ ULONG32 size,
    /* [in] */ ULONG32 typeFlags,
    /* [in] */ ULONG32 protectFlags,
    /* [out] */ CLRDATA_ADDRESS *virt);


void __RPC_STUB ICLRDataTarget2_AllocVirtual_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ICLRDataTarget2_FreeVirtual_Proxy( 
    ICLRDataTarget2 * This,
    /* [in] */ CLRDATA_ADDRESS addr,
    /* [in] */ ULONG32 size,
    /* [in] */ ULONG32 typeFlags);


void __RPC_STUB ICLRDataTarget2_FreeVirtual_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __ICLRDataTarget2_INTERFACE_DEFINED__ */


#ifndef __ICLRMetadataLocator_INTERFACE_DEFINED__
#define __ICLRMetadataLocator_INTERFACE_DEFINED__

/* interface ICLRMetadataLocator */
/* [unique][uuid][object] */ 


EXTERN_C const IID IID_ICLRMetadataLocator;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("aa8fa804-bc05-4642-b2c5-c353ed22fc63")
    ICLRMetadataLocator : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE GetMetadata( 
            /* [in] */ LPCWSTR imagePath,
            /* [in] */ ULONG32 imageTimestamp,
            /* [in] */ ULONG32 imageSize,
            /* [in] */ GUID *mvid,
            /* [in] */ ULONG32 mdRva,
            /* [in] */ ULONG32 flags,
            /* [in] */ ULONG32 bufferSize,
            /* [length_is][size_is][out] */ BYTE *buffer,
            /* [out] */ ULONG32 *dataSize) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct ICLRMetadataLocatorVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            ICLRMetadataLocator * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            ICLRMetadataLocator * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            ICLRMetadataLocator * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetMetadata )( 
            ICLRMetadataLocator * This,
            /* [in] */ LPCWSTR imagePath,
            /* [in] */ ULONG32 imageTimestamp,
            /* [in] */ ULONG32 imageSize,
            /* [in] */ GUID *mvid,
            /* [in] */ ULONG32 mdRva,
            /* [in] */ ULONG32 flags,
            /* [in] */ ULONG32 bufferSize,
            /* [length_is][size_is][out] */ BYTE *buffer,
            /* [out] */ ULONG32 *dataSize);
        
        END_INTERFACE
    } ICLRMetadataLocatorVtbl;

    interface ICLRMetadataLocator
    {
        CONST_VTBL struct ICLRMetadataLocatorVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define ICLRMetadataLocator_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define ICLRMetadataLocator_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define ICLRMetadataLocator_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define ICLRMetadataLocator_GetMetadata(This,imagePath,imageTimestamp,imageSize,mvid,mdRva,flags,bufferSize,buffer,dataSize)	\
    (This)->lpVtbl -> GetMetadata(This,imagePath,imageTimestamp,imageSize,mvid,mdRva,flags,bufferSize,buffer,dataSize)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE ICLRMetadataLocator_GetMetadata_Proxy( 
    ICLRMetadataLocator * This,
    /* [in] */ LPCWSTR imagePath,
    /* [in] */ ULONG32 imageTimestamp,
    /* [in] */ ULONG32 imageSize,
    /* [in] */ GUID *mvid,
    /* [in] */ ULONG32 mdRva,
    /* [in] */ ULONG32 flags,
    /* [in] */ ULONG32 bufferSize,
    /* [length_is][size_is][out] */ BYTE *buffer,
    /* [out] */ ULONG32 *dataSize);


void __RPC_STUB ICLRMetadataLocator_GetMetadata_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __ICLRMetadataLocator_INTERFACE_DEFINED__ */


#ifndef __ICLRDataEnumMemoryRegionsCallback_INTERFACE_DEFINED__
#define __ICLRDataEnumMemoryRegionsCallback_INTERFACE_DEFINED__

/* interface ICLRDataEnumMemoryRegionsCallback */
/* [uuid][object] */ 


EXTERN_C const IID IID_ICLRDataEnumMemoryRegionsCallback;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("BCDD6908-BA2D-4ec5-96CF-DF4D5CDCB4A4")
    ICLRDataEnumMemoryRegionsCallback : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE EnumMemoryRegion( 
            /* [in] */ CLRDATA_ADDRESS address,
            /* [in] */ ULONG32 size) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct ICLRDataEnumMemoryRegionsCallbackVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            ICLRDataEnumMemoryRegionsCallback * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            ICLRDataEnumMemoryRegionsCallback * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            ICLRDataEnumMemoryRegionsCallback * This);
        
        HRESULT ( STDMETHODCALLTYPE *EnumMemoryRegion )( 
            ICLRDataEnumMemoryRegionsCallback * This,
            /* [in] */ CLRDATA_ADDRESS address,
            /* [in] */ ULONG32 size);
        
        END_INTERFACE
    } ICLRDataEnumMemoryRegionsCallbackVtbl;

    interface ICLRDataEnumMemoryRegionsCallback
    {
        CONST_VTBL struct ICLRDataEnumMemoryRegionsCallbackVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define ICLRDataEnumMemoryRegionsCallback_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define ICLRDataEnumMemoryRegionsCallback_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define ICLRDataEnumMemoryRegionsCallback_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define ICLRDataEnumMemoryRegionsCallback_EnumMemoryRegion(This,address,size)	\
    (This)->lpVtbl -> EnumMemoryRegion(This,address,size)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE ICLRDataEnumMemoryRegionsCallback_EnumMemoryRegion_Proxy( 
    ICLRDataEnumMemoryRegionsCallback * This,
    /* [in] */ CLRDATA_ADDRESS address,
    /* [in] */ ULONG32 size);


void __RPC_STUB ICLRDataEnumMemoryRegionsCallback_EnumMemoryRegion_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __ICLRDataEnumMemoryRegionsCallback_INTERFACE_DEFINED__ */


/* interface __MIDL_itf_clrdata_0012 */
/* [local] */ 

typedef 
enum CLRDataEnumMemoryFlags
    {	CLRDATA_ENUM_MEM_DEFAULT	= 0,
	CLRDATA_ENUM_MEM_MINI	= CLRDATA_ENUM_MEM_DEFAULT,
	CLRDATA_ENUM_MEM_HEAP	= 0x1
    } 	CLRDataEnumMemoryFlags;



extern RPC_IF_HANDLE __MIDL_itf_clrdata_0012_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_clrdata_0012_v0_0_s_ifspec;

#ifndef __ICLRDataEnumMemoryRegions_INTERFACE_DEFINED__
#define __ICLRDataEnumMemoryRegions_INTERFACE_DEFINED__

/* interface ICLRDataEnumMemoryRegions */
/* [uuid][object] */ 


EXTERN_C const IID IID_ICLRDataEnumMemoryRegions;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("471c35b4-7c2f-4ef0-a945-00f8c38056f1")
    ICLRDataEnumMemoryRegions : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE EnumMemoryRegions( 
            /* [in] */ ICLRDataEnumMemoryRegionsCallback *callback,
            /* [in] */ ULONG32 miniDumpFlags,
            /* [in] */ CLRDataEnumMemoryFlags clrFlags) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct ICLRDataEnumMemoryRegionsVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            ICLRDataEnumMemoryRegions * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            ICLRDataEnumMemoryRegions * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            ICLRDataEnumMemoryRegions * This);
        
        HRESULT ( STDMETHODCALLTYPE *EnumMemoryRegions )( 
            ICLRDataEnumMemoryRegions * This,
            /* [in] */ ICLRDataEnumMemoryRegionsCallback *callback,
            /* [in] */ ULONG32 miniDumpFlags,
            /* [in] */ CLRDataEnumMemoryFlags clrFlags);
        
        END_INTERFACE
    } ICLRDataEnumMemoryRegionsVtbl;

    interface ICLRDataEnumMemoryRegions
    {
        CONST_VTBL struct ICLRDataEnumMemoryRegionsVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define ICLRDataEnumMemoryRegions_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define ICLRDataEnumMemoryRegions_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define ICLRDataEnumMemoryRegions_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define ICLRDataEnumMemoryRegions_EnumMemoryRegions(This,callback,miniDumpFlags,clrFlags)	\
    (This)->lpVtbl -> EnumMemoryRegions(This,callback,miniDumpFlags,clrFlags)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE ICLRDataEnumMemoryRegions_EnumMemoryRegions_Proxy( 
    ICLRDataEnumMemoryRegions * This,
    /* [in] */ ICLRDataEnumMemoryRegionsCallback *callback,
    /* [in] */ ULONG32 miniDumpFlags,
    /* [in] */ CLRDataEnumMemoryFlags clrFlags);


void __RPC_STUB ICLRDataEnumMemoryRegions_EnumMemoryRegions_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __ICLRDataEnumMemoryRegions_INTERFACE_DEFINED__ */


/* Additional Prototypes for ALL interfaces */

/* end of Additional Prototypes */

#ifdef __cplusplus
}
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\vs9sp1\sdk\include\clfsw32.h ===
/*=============================================================================

    Copyright (c) 1998-2001  Microsoft Corporation

    Module Name:

        clfsw32.h

    Abstract:

        Declares the exported API set for the Common Log Win32
        API dynamic link library and static library.

    Author:

        Dexter Bradshaw [DexterB] 24-Apr-2001

    Environment:

        User Mode

    Revision History:


=============================================================================*/
#ifndef __CLFSW32_H__
#define __CLFSW32_H__

//-----------------------------------------------------------------------------
// CLFS INCLUDES
//-----------------------------------------------------------------------------


#ifdef CLFS_KERNEL_MODE
#   undef CLFS_KERNEL_MODE
#endif CLFS_KERNEL_MODE

#include <clfs.h>


//------------------------------------------------------------------------------
// TYPE DEFINITIONS
//------------------------------------------------------------------------------


#ifdef __cplusplus
extern "C"
{
#endif /* __cplusplus */


#if (_WIN32_WINNT >= _WIN32_WINNT_WS03)
//
// PCLFS_COMPLETION_ROUTINE
//

typedef void (__stdcall * PCLFS_COMPLETION_ROUTINE) (
                    IN PVOID pvOverlapped,
                    IN ULONG ulReserved
                    );
#endif /* _WIN32_WINNT */

#if (_WIN32_WINNT >= _WIN32_WINNT_WS03)
//
// PCLFS_PRINT_RECORD_ROUTINE
//
// User defined callback deciphering the format of a log record
// buffer and dumping its content to the log stream.
//

typedef ULONG (__stdcall * CLFS_PRINT_RECORD_ROUTINE) (
                    IN PFILE pstrmOut,
                    IN CLFS_RECORD_TYPE fRecordType,
                    IN PVOID pvBuffer,
                    IN ULONG cbBuffer
                    );
#endif /* _WIN32_WINNT */

#if (_WIN32_WINNT >= _WIN32_WINNT_WS03)
//
// CLFS_LOG_ARCHIVE_CONTEXT
//
// The log archive context is an opaque user data structure allocated by the CLFS
// user-mode runtime after successfully preparing for archival.  Log archive
// clients should make no assumptions about the contents of this data structure
// nor in any way attempt to change it.  The log archive context maintains a copy
// (not a reference) to the log file handle and maintains the cursor state during
// iteration throught the archive descriptor set returned from preparing for
// archival.
//

typedef PVOID CLFS_LOG_ARCHIVE_CONTEXT, *PCLFS_LOG_ARCHIVE_CONTEXT;
#endif /* _WIN32_WINNT */


//------------------------------------------------------------------------------
// EXPORTED ENTRY POINT DECLARATION
//------------------------------------------------------------------------------

#if (_WIN32_WINNT >= _WIN32_WINNT_WS03)
//------------------------------------------------------------------------------
// LsnCreate
// 
// Create an LSN given a log identifier, a container identifier, a block
// offset and a bucket identifier.  Caller must test for invalid LSN after
// making this call.
//------------------------------------------------------------------------------

CLFSUSER_API CLFS_LSN WINAPI LsnCreate (
                    IN CLFS_CONTAINER_ID    cidContainer,
                    IN ULONG                offBlock,
                    IN ULONG                cRecord
                    );
#endif /* _WIN32_WINNT */

#if (_WIN32_WINNT >= _WIN32_WINNT_WS03)
//-----------------------------------------------------------------------------
// LsnContainer
//
// Entry point to extract the container identifier from the LSN.
//-----------------------------------------------------------------------------

CLFSUSER_API CLFS_CONTAINER_ID WINAPI LsnContainer (
                    IN const CLFS_LSN* plsn
                    );
#endif /* _WIN32_WINNT */

#if (_WIN32_WINNT >= _WIN32_WINNT_WS03)
//-----------------------------------------------------------------------------
// LsnBlockOffset
//
// Entry point to extract the block offset from the LSN.
//-----------------------------------------------------------------------------

CLFSUSER_API ULONG WINAPI LsnBlockOffset (
                    IN const CLFS_LSN* plsn
                    );
#endif /* _WIN32_WINNT */

#if (_WIN32_WINNT >= _WIN32_WINNT_WS03)
//-----------------------------------------------------------------------------
// LsnRecordSequence 
//
// Entry point to extract the bucket identifier from the LSN.
//-----------------------------------------------------------------------------

CLFSUSER_API ULONG WINAPI LsnRecordSequence (
                    IN const CLFS_LSN* plsn
                    );
#endif /* _WIN32_WINNT */

#if (_WIN32_WINNT >= _WIN32_WINNT_WS03)
//------------------------------------------------------------------------------
// CreateLogFile
//
// Entry point to create a physical log file consisting of uniformly sized
// containers lying in a given directory path.
//------------------------------------------------------------------------------

CLFSUSER_API HANDLE WINAPI CreateLogFile (
                    IN LPCWSTR pszLogFileName,
                    IN ACCESS_MASK fDesiredAccess,
                    IN DWORD dwShareMode,
                    IN LPSECURITY_ATTRIBUTES psaLogFile OPTIONAL,
                    IN ULONG fCreateDisposition,
                    IN ULONG fFlagsAndAttributes
                    );
#endif /* _WIN32_WINNT */

#if (_WIN32_WINNT >= _WIN32_WINNT_WS03)
//------------------------------------------------------------------------------
// DeleteLogByHandle
//
// Entry point to delete a physical log file and its underlying container
// storage by handle.
//------------------------------------------------------------------------------

CLFSUSER_API BOOL WINAPI DeleteLogByHandle (IN HANDLE hLog);
#endif /* _WIN32_WINNT */

#if (_WIN32_WINNT >= _WIN32_WINNT_WS03)
//------------------------------------------------------------------------------
// DeleteLogFile
//
// Entry point to delete a physical log file and its underlying container
// storage by name.
//------------------------------------------------------------------------------

CLFSUSER_API BOOL WINAPI DeleteLogFile (
                    IN LPCWSTR pszLogFileName,
                    IN PVOID pvReserved OPTIONAL
                    );
#endif /* _WIN32_WINNT */

#if (_WIN32_WINNT >= _WIN32_WINNT_WS03)
//------------------------------------------------------------------------------
// AddLogContainer
//
// Adds a log container to a given physical file identified by the log
// handle.
//------------------------------------------------------------------------------

CLFSUSER_API BOOL WINAPI AddLogContainer (
                    __in HANDLE hLog,
                    __in_opt PULONGLONG pcbContainer,
                    __in LPWSTR pwszContainerPath,
                    __inout_opt LPVOID pReserved
                    );
#endif /* _WIN32_WINNT */

#if (_WIN32_WINNT >= _WIN32_WINNT_WS03)
//------------------------------------------------------------------------------
// AddLogContainerSet
//
// Adds a set of log containers to a given physical file identified by the log
// handle.
//------------------------------------------------------------------------------

CLFSUSER_API BOOL WINAPI AddLogContainerSet (
                    __in HANDLE hLog,
                    __in USHORT cContainer,
                    __in_opt PULONGLONG pcbContainer,
                    __in_ecount(cContainer) LPWSTR *rgwszContainerPath,
                    __inout_opt LPVOID pReserved
                    );
#endif /* _WIN32_WINNT */

#if (_WIN32_WINNT >= _WIN32_WINNT_WS03)
//------------------------------------------------------------------------------
// RemoveLogContainer
//
// Removes a log container from a physical log file identified by
// the log handle.
//------------------------------------------------------------------------------

CLFSUSER_API BOOL WINAPI RemoveLogContainer (
                    __in HANDLE hLog,
                    __in LPWSTR pwszContainerPath,
                    __in BOOL fForce,
                    __inout_opt LPVOID pReserved
                    );
#endif /* _WIN32_WINNT */

#if (_WIN32_WINNT >= _WIN32_WINNT_WS03)
//------------------------------------------------------------------------------
// RemoveLogContainerSet
//
// Removes a set of log containers from a physical log file identified by
// the log handle.
//------------------------------------------------------------------------------


CLFSUSER_API BOOL WINAPI RemoveLogContainerSet (
                    __in HANDLE hLog,
                    __in USHORT cContainer,
                    __in_ecount(cContainer) LPWSTR *rgwszContainerPath,
                    __in BOOL fForce,
                    __inout_opt LPVOID pReserved
                    );
#endif /* _WIN32_WINNT */

#if (_WIN32_WINNT >= _WIN32_WINNT_WS03)
//------------------------------------------------------------------------------
// SetLogArchiveTail
//
// Sets the archive tail for either a client or physical log file
// depending on the type of the log handle.
//------------------------------------------------------------------------------

CLFSUSER_API BOOL WINAPI SetLogArchiveTail (
                    IN HANDLE hLog,
                    IN PCLFS_LSN plsnArchiveTail,
                    IN OUT LPVOID pReserved OPTIONAL
                    );
#endif /* _WIN32_WINNT */

#if (_WIN32_WINNT >= _WIN32_WINNT_WS03)
//------------------------------------------------------------------------------
// SetEndOfLog
//
// This function sets the end of log to the value specified by the plsnEnd 
// parameter.  The operation only works on non-ephemeral logs and is usually
// called by archival or log-shipping engines during dynamic roll forward
// recovery.
//
// Deprecated.  See TruncateLog.
//
//------------------------------------------------------------------------------

CLFSUSER_API BOOL WINAPI SetEndOfLog (
                    IN HANDLE hLog,
                    IN PCLFS_LSN plsnEnd,
                    IN OUT LPOVERLAPPED lpOverlapped
                    );
#endif /* _WIN32_WINNT */

#if (_WIN32_WINNT >= _WIN32_WINNT_LONGHORN)
//------------------------------------------------------------------------------
// TruncateLog
//
// This function sets the end of log to the value specified by the plsnEnd 
// parameter.  
//
//------------------------------------------------------------------------------

CLFSUSER_API BOOL WINAPI TruncateLog (
                    __in PVOID pvMarshal,
                    __in PCLFS_LSN plsnEnd,
                    __inout_opt LPOVERLAPPED lpOverlapped
                    );
#endif /* _WIN32_WINNT */


#if (_WIN32_WINNT >= _WIN32_WINNT_WS03)
//------------------------------------------------------------------------------
// CreateLogContainerScanContext
//
// Create a scan context to enumerate scan descriptors for storage containers 
// that back the physical log file stream.
//------------------------------------------------------------------------------

CLFSUSER_API BOOL WINAPI CreateLogContainerScanContext (
                    IN HANDLE hLog,
                    IN ULONG cFromContainer,
                    IN ULONG cContainers,
                    IN CLFS_SCAN_MODE eScanMode,
                    IN OUT PCLFS_SCAN_CONTEXT pcxScan,
                    IN OUT LPOVERLAPPED pOverlapped OPTIONAL
                    );
#endif /* _WIN32_WINNT */

#if (_WIN32_WINNT >= _WIN32_WINNT_WS03)
//------------------------------------------------------------------------------
// ScanLogContainers
//
// Scan descriptors for storage containers backing the physical
// log file stream.
//------------------------------------------------------------------------------

CLFSUSER_API BOOL WINAPI ScanLogContainers (
                    IN OUT PCLFS_SCAN_CONTEXT pcxScan,
                    IN CLFS_SCAN_MODE eScanMode,
                    IN OUT LPVOID pReserved OPTIONAL
                    );
#endif /* _WIN32_WINNT */

#if (_WIN32_WINNT >= _WIN32_WINNT_WS03)
//------------------------------------------------------------------------------
// AlignReservedLog
//
// Given a valid marshalling context calculate the sector algined aggregate
// number of reserved records and bytes.
//------------------------------------------------------------------------------

CLFSUSER_API BOOL WINAPI AlignReservedLog (
                    IN OUT PVOID pvMarshal,
                    IN ULONG cReservedRecords,
                    IN LONGLONG rgcbReservation [],
                    OUT PLONGLONG pcbAlignReservation
                    );
#endif /* _WIN32_WINNT */

#if (_WIN32_WINNT >= _WIN32_WINNT_WS03)
//------------------------------------------------------------------------------
// AllocReservedLog
//
// Given a valid marshalling context, allocate an aggregate number of reserved
// records and bytes.
//------------------------------------------------------------------------------

CLFSUSER_API BOOL WINAPI AllocReservedLog (
                    IN OUT PVOID pvMarshal,
                    IN ULONG cReservedRecords,
                    IN OUT PLONGLONG pcbAdjustment
                    );
#endif /* _WIN32_WINNT */

#if (_WIN32_WINNT >= _WIN32_WINNT_WS03)
//------------------------------------------------------------------------------
// FreeReservedLog
//
// Set the reserved log space to a new size or specify a delta
// for the reserved space.
//------------------------------------------------------------------------------

CLFSUSER_API BOOL WINAPI FreeReservedLog (
                    IN OUT PVOID pvMarshal,
                    IN ULONG cReservedRecords,
                    IN OUT PLONGLONG pcbAdjustment
                    );
#endif /* _WIN32_WINNT */

#if (_WIN32_WINNT >= _WIN32_WINNT_WS03)
//------------------------------------------------------------------------------
// GetLogFileInformation
//
// Get log file information for a physical log and client stream
// specific to the handle.
//------------------------------------------------------------------------------

CLFSUSER_API BOOL WINAPI GetLogFileInformation (
                    IN HANDLE hLog,
                    IN OUT PCLFS_INFORMATION pinfoBuffer,
                    IN OUT PULONG cbBuffer
                    );
#endif /* _WIN32_WINNT */

#if (_WIN32_WINNT >= _WIN32_WINNT_WS03)
//------------------------------------------------------------------------------
// SetLogArchiveMode
//
// Enable or disable the log's archive support mechanisms.
//------------------------------------------------------------------------------

CLFSUSER_API BOOL WINAPI SetLogArchiveMode (
                    IN HANDLE hLog,
                    IN CLFS_LOG_ARCHIVE_MODE eMode
                    );
#endif /* _WIN32_WINNT */

#if (_WIN32_WINNT >= _WIN32_WINNT_WS03)
//------------------------------------------------------------------------------
// ReadLogRestartArea
//
// Read the last restart area successfully written to a physical or 
// client log stream.
//------------------------------------------------------------------------------

CLFSUSER_API BOOL WINAPI ReadLogRestartArea (
                    IN PVOID pvMarshal,
                    OUT PVOID* ppvRestartBuffer,
                    OUT PULONG pcbRestartBuffer,
                    OUT PCLFS_LSN plsn,
                    OUT PVOID *ppvContext,
                    IN OUT LPOVERLAPPED pOverlapped OPTIONAL
                    );
#endif /* _WIN32_WINNT */

#if (_WIN32_WINNT >= _WIN32_WINNT_WS03)
//------------------------------------------------------------------------------
// ReadPreviousLogRestartArea
//
// Read the previous restart area successfully written to a physical or 
// client log stream given the read context created by the a call to
// ReadRestartArea.
//------------------------------------------------------------------------------

CLFSUSER_API BOOL WINAPI ReadPreviousLogRestartArea (
                    IN PVOID pvReadContext,
                    OUT PVOID *ppvRestartBuffer,
                    OUT PULONG pcbRestartBuffer,
                    OUT PCLFS_LSN plsnRestart,
                    IN OUT LPOVERLAPPED pOverlapped OPTIONAL
                    );
#endif /* _WIN32_WINNT */

#if (_WIN32_WINNT >= _WIN32_WINNT_WS03)
//------------------------------------------------------------------------------
// WriteLogRestartArea
//
// Write a new restart area to a physical or client log stream.
//------------------------------------------------------------------------------

CLFSUSER_API BOOL WINAPI WriteLogRestartArea (
                    IN OUT PVOID pvMarshal,
                    IN PVOID pvRestartBuffer,
                    IN ULONG cbRestartBuffer,
                    IN PCLFS_LSN plsnBase OPTIONAL,
                    IN ULONG fFlags,
                    OUT PULONG pcbWritten OPTIONAL,
                    OUT PCLFS_LSN plsnNext OPTIONAL,
                    IN OUT LPOVERLAPPED pOverlapped OPTIONAL
                    );
#endif /* _WIN32_WINNT */

#if (_WIN32_WINNT >= _WIN32_WINNT_WS03)
//------------------------------------------------------------------------------
// AdvanceLogBase
//
// Set a new base LSN for a log stream without writing a restart record.
//------------------------------------------------------------------------------

CLFSUSER_API BOOL WINAPI AdvanceLogBase (
                    IN OUT PVOID pvMarshal,
                    IN PCLFS_LSN plsnBase,
                    IN ULONG fFlags,
                    IN OUT LPOVERLAPPED pOverlapped OPTIONAL
                    );
#endif /* _WIN32_WINNT */

#if (_WIN32_WINNT >= _WIN32_WINNT_WS03)
//------------------------------------------------------------------------------
// CloseAndResetLogFile
//
// Orderly shutdown of a client log stream.  This call only works on client
// stream handles and will return ERROR_INVALID_HANDLE on a physical stream.
//
//------------------------------------------------------------------------------

CLFSUSER_API BOOL WINAPI CloseAndResetLogFile (IN HANDLE hLog);
#endif /* _WIN32_WINNT */

#if (_WIN32_WINNT >= _WIN32_WINNT_WS03)
//------------------------------------------------------------------------------
// CreateLogMarshallingArea
//
// Initalize a marshalling area for a physical or client log
// file stream.
//------------------------------------------------------------------------------

CLFSUSER_API BOOL WINAPI CreateLogMarshallingArea (
                    IN HANDLE hLog,
                    IN CLFS_BLOCK_ALLOCATION pfnAllocBuffer OPTIONAL,
                    IN CLFS_BLOCK_DEALLOCATION pfnFreeBuffer OPTIONAL,
                    IN PVOID pvBlockAllocContext OPTIONAL,
                    IN ULONG cbMarshallingBuffer,
                    IN ULONG cMaxWriteBuffers,
                    IN ULONG cMaxReadBuffers,
                    OUT PVOID *ppvMarshal
                    );
#endif /* _WIN32_WINNT */

#if (_WIN32_WINNT >= _WIN32_WINNT_WS03)
//------------------------------------------------------------------------------
// DeleteLogMarshallingArea
//
// Delete a marshalling area for a physical or client log
// file stream.
//------------------------------------------------------------------------------

CLFSUSER_API BOOL WINAPI DeleteLogMarshallingArea (IN PVOID pvMarshal);
#endif /* _WIN32_WINNT */

#if (_WIN32_WINNT >= _WIN32_WINNT_WS03)
//------------------------------------------------------------------------------
// ReserveAndAppendLog
//
// Reserve space and append log buffers to a physical or client
// log stream.
//------------------------------------------------------------------------------

CLFSUSER_API BOOL WINAPI ReserveAndAppendLog (
                    IN PVOID pvMarshal,
                    IN PCLFS_WRITE_ENTRY rgWriteEntries OPTIONAL,
                    IN ULONG cWriteEntries,
                    IN PCLFS_LSN plsnUndoNext OPTIONAL,
                    IN PCLFS_LSN plsnPrevious OPTIONAL,
                    IN ULONG cReserveRecords,
                    IN OUT LONGLONG rgcbReservation [] OPTIONAL,
                    IN ULONG fFlags,
                    OUT PCLFS_LSN plsn OPTIONAL,
                    IN OUT LPOVERLAPPED pOverlapped OPTIONAL
                    );
#endif /* _WIN32_WINNT */

#if (_WIN32_WINNT >= _WIN32_WINNT_WS03)
//------------------------------------------------------------------------------
// ReserveAndAppendLogAligned
//
// Reserve space and append log buffers to a physical or client
// log stream, honoring an alignment between write entries.
//------------------------------------------------------------------------------

CLFSUSER_API BOOL WINAPI ReserveAndAppendLogAligned (
                    IN PVOID pvMarshal,
                    IN PCLFS_WRITE_ENTRY rgWriteEntries OPTIONAL,
                    IN ULONG cWriteEntries,
                    IN ULONG cbEntryAlignment,
                    IN PCLFS_LSN plsnUndoNext OPTIONAL,
                    IN PCLFS_LSN plsnPrevious OPTIONAL,
                    IN ULONG cReserveRecords,
                    IN OUT LONGLONG rgcbReservation [] OPTIONAL,
                    IN ULONG fFlags,
                    OUT PCLFS_LSN plsn OPTIONAL,
                    IN OUT LPOVERLAPPED pOverlapped OPTIONAL
                    );
#endif /* _WIN32_WINNT */

#if (_WIN32_WINNT >= _WIN32_WINNT_WS03)
//------------------------------------------------------------------------------
// FlushLogBuffers
// 
// Flush move all current buffers in the marshalling area to the flush queue and 
// flush all buffers to the disk.
//------------------------------------------------------------------------------

CLFSUSER_API BOOL WINAPI FlushLogBuffers (
                    IN PVOID pvMarshal,
                    IN OUT LPOVERLAPPED pOverlapped OPTIONAL
                    );
#endif /* _WIN32_WINNT */

#if (_WIN32_WINNT >= _WIN32_WINNT_WS03)
//------------------------------------------------------------------------------
// FlushLogToLsn
// 
// Flush all buffers in the marshalling area up to a target LSN to the flush
// queue and flush all buffers up to the target LSN to the disk.
//------------------------------------------------------------------------------

CLFSUSER_API BOOL WINAPI FlushLogToLsn (
                    IN PVOID pvMarshalContext,
                    IN PCLFS_LSN plsnFlush,
                    OUT PCLFS_LSN plsnLastFlushed OPTIONAL,
                    IN OUT LPOVERLAPPED pOverlapped OPTIONAL
                    );
#endif /* _WIN32_WINNT */

#if (_WIN32_WINNT >= _WIN32_WINNT_WS03)
//------------------------------------------------------------------------------
// ReadLogRecord
//
// Read a log record from a physical or client log stream given
// a starting LSN.
//------------------------------------------------------------------------------


CLFSUSER_API BOOL WINAPI ReadLogRecord (
                    IN PVOID pvMarshal,
                    IN PCLFS_LSN plsnFirst,
                    IN CLFS_CONTEXT_MODE eContextMode,
                    OUT PVOID* ppvReadBuffer,
                    OUT PULONG pcbReadBuffer,
                    OUT PCLFS_RECORD_TYPE peRecordType,
                    OUT PCLFS_LSN plsnUndoNext,
                    OUT PCLFS_LSN plsnPrevious,
                    OUT PVOID* ppvReadContext,
                    IN OUT LPOVERLAPPED pOverlapped OPTIONAL
                    );
#endif /* _WIN32_WINNT */

#if (_WIN32_WINNT >= _WIN32_WINNT_WS03)
//------------------------------------------------------------------------------
// ReadNextLogRecord
//
// Read the next log record from a given marshalling context.
//------------------------------------------------------------------------------


CLFSUSER_API BOOL WINAPI ReadNextLogRecord (
                    IN OUT PVOID pvReadContext,
                    OUT PVOID* ppvBuffer,
                    OUT PULONG pcbBuffer,
                    IN OUT PCLFS_RECORD_TYPE peRecordType,
                    IN PCLFS_LSN plsnUser OPTIONAL,
                    OUT PCLFS_LSN plsnUndoNext,
                    OUT PCLFS_LSN plsnPrevious,
                    OUT PCLFS_LSN plsnRecord,
                    IN OUT LPOVERLAPPED pOverlapped OPTIONAL
                    );
#endif /* _WIN32_WINNT */

#if (_WIN32_WINNT >= _WIN32_WINNT_WS03)
//------------------------------------------------------------------------------
// TerminateReadLog
//
// Terminate the read context.
//------------------------------------------------------------------------------

CLFSUSER_API BOOL WINAPI TerminateReadLog (IN PVOID pvCursorContext);
#endif /* _WIN32_WINNT */

#if (_WIN32_WINNT >= _WIN32_WINNT_WS03)
//------------------------------------------------------------------------------
// DumpLogRecords
//
// Given log file name, scan a log file and dump log records to a file stream.
//
//------------------------------------------------------------------------------

CLFSUSER_API BOOL WINAPI DumpLogRecords (
                    __in PWSTR pwszLogFileName,
                    __in CLFS_RECORD_TYPE fRecordType,
                    __in_opt PCLFS_LSN plsnStart,
                    __in_opt PCLFS_LSN plsnEnd,
                    __in_opt PFILE pstrmOut,
                    __in_opt CLFS_PRINT_RECORD_ROUTINE pfnPrintRecord,
                    __in_opt CLFS_BLOCK_ALLOCATION pfnAllocBlock,
                    __in_opt CLFS_BLOCK_DEALLOCATION pfnFreeBlock,
                    __in_opt PVOID pvBlockAllocContext,
                    __in ULONG cbBlock,
                    __in ULONG cMaxBlocks
                    );
#endif /* _WIN32_WINNT */

#if (_WIN32_WINNT >= _WIN32_WINNT_WS03)
//------------------------------------------------------------------------------
// PrepareLogArchive
//
// Snapshots the current active log and builds an ordered set of log archive
// descriptors describing the logically contiguous active log extents. This
// function also allocates and initializes a log archvie context for use in
// GetNextLogArchiveExtent and ReadLogArchiveMetadata.
//
//------------------------------------------------------------------------------

CLFSUSER_API BOOL WINAPI PrepareLogArchive (
                __in HANDLE hLog,
                __inout_ecount(cLen) PWSTR pszBaseLogFileName,
                __in ULONG cLen,
                __in_opt const PCLFS_LSN plsnLow,
                __in_opt const PCLFS_LSN plsnHigh,
                __out_opt PULONG pcActualLength,
                __out PULONGLONG poffBaseLogFileData,
                __out PULONGLONG pcbBaseLogFileLength,
                __out PCLFS_LSN plsnBase,
                __out PCLFS_LSN plsnLast,
                __out PCLFS_LSN plsnCurrentArchiveTail,
                __out PCLFS_LOG_ARCHIVE_CONTEXT ppvArchiveContext
                );
#endif /* _WIN32_WINNT */

#if (_WIN32_WINNT >= _WIN32_WINNT_WS03)
//------------------------------------------------------------------------------
// ReadLogArchiveMetadata
//
// Copies a portion of the metadata snapshot taken at the time of an invocation
// of PrepareLogArchvie to a user buffer.
//
//------------------------------------------------------------------------------

CLFSUSER_API BOOL WINAPI ReadLogArchiveMetadata(
                IN CLFS_LOG_ARCHIVE_CONTEXT pvArchiveContext,
                IN ULONG     cbOffset,
                IN ULONG     cbBytesToRead,
                IN OUT PBYTE pbReadBuffer,
                OUT PULONG   pcbBytesRead
                );
#endif /* _WIN32_WINNT */

#if (_WIN32_WINNT >= _WIN32_WINNT_WS03)
//------------------------------------------------------------------------------
// GetNextLogArchiveExtent
//
// Iterates through the ordered set of log archive descriptors maintaining
// cursor state through the log archive context returned in PrepareLogArchive.
//
//------------------------------------------------------------------------------

CLFSUSER_API BOOL WINAPI GetNextLogArchiveExtent (
                IN CLFS_LOG_ARCHIVE_CONTEXT pvArchiveContext,
                IN OUT CLFS_ARCHIVE_DESCRIPTOR rgadExtent [],
                IN ULONG cDescriptors,
                OUT PULONG pcDescriptorsReturned
                );
#endif /* _WIN32_WINNT */

#if (_WIN32_WINNT >= _WIN32_WINNT_WS03)
//------------------------------------------------------------------------------
// TerminateLogArchive
//
// De-allocates all system resources allocated to a valid log archive context
// on completion of enumeration of all log descriptors.
//
//------------------------------------------------------------------------------

CLFSUSER_API BOOL WINAPI TerminateLogArchive (
                IN CLFS_LOG_ARCHIVE_CONTEXT pvArchiveContext
                );
#endif /* _WIN32_WINNT */

#if (_WIN32_WINNT >= _WIN32_WINNT_WS03)
//------------------------------------------------------------------------------
// ValidateLog
//
// Validates the consistency of both log metadata and data before archival and
// after log restore.
//
//------------------------------------------------------------------------------

CLFSUSER_API BOOL WINAPI ValidateLog (
                IN LPCWSTR pszLogFileName,
                IN LPSECURITY_ATTRIBUTES psaLogFile OPTIONAL,
                OUT PCLFS_INFORMATION pinfoBuffer OPTIONAL,
                IN OUT PULONG pcbBuffer
                );
#endif /* _WIN32_WINNT */

#if (_WIN32_WINNT >= _WIN32_WINNT_WS03)
//------------------------------------------------------------------------------
// GetLogContainerName
//
// Gets the name of a container given the container identifier.
//
//------------------------------------------------------------------------------

CLFSUSER_API BOOL WINAPI GetLogContainerName (
                IN HANDLE hLog,
                IN CLFS_CONTAINER_ID cidLogicalContainer,
                IN OUT LPCWSTR pwstrContainerName,
                IN ULONG cLenContainerName,
                IN OUT PULONG pcActualLenContainerName OPTIONAL
                );
#endif /* _WIN32_WINNT */

#if (_WIN32_WINNT >= _WIN32_WINNT_WS03)
//------------------------------------------------------------------------------
// GetLogIoStatistics
//
// Gets the log I/O statistics for the log associated with a given log handle.
//
//------------------------------------------------------------------------------

CLFSUSER_API BOOL WINAPI GetLogIoStatistics (
                IN HANDLE hLog,
                IN OUT PVOID pvStatsBuffer,
                IN ULONG cbStatsBuffer,
                IN CLFS_IOSTATS_CLASS eStatsClass,
                OUT PULONG pcbStatsWritten OPTIONAL
                );
#endif /* _WIN32_WINNT */



#ifdef __cplusplus
}
#endif /* __cplusplus */

#endif  __CLFSW32_H__

//-----------------------------------------------------------------------------
//                                      END OF FILE
//-----------------------------------------------------------------------------
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\vs9sp1\sdk\include\CluAdmEx.h ===
/* this ALWAYS GENERATED file contains the definitions for the interfaces */


 /* File created by MIDL compiler version 7.00.0499 */
/* Compiler settings for cluadmex.idl:
    Oicf, W1, Zp8, env=Win32 (32b run)
    protocol : dce , ms_ext, c_ext, robust
    error checks: allocation ref bounds_check enum stub_data 
    VC __declspec() decoration level: 
         __declspec(uuid()), __declspec(selectany), __declspec(novtable)
         DECLSPEC_UUID(), MIDL_INTERFACE()
*/
//@@MIDL_FILE_HEADING(  )

#pragma warning( disable: 4049 )  /* more than 64k source lines */


/* verify that the <rpcndr.h> version is high enough to compile this file*/
#ifndef __REQUIRED_RPCNDR_H_VERSION__
#define __REQUIRED_RPCNDR_H_VERSION__ 500
#endif

/* verify that the <rpcsal.h> version is high enough to compile this file*/
#ifndef __REQUIRED_RPCSAL_H_VERSION__
#define __REQUIRED_RPCSAL_H_VERSION__ 100
#endif

#include "rpc.h"
#include "rpcndr.h"

#ifndef __RPCNDR_H_VERSION__
#error this stub requires an updated version of <rpcndr.h>
#endif // __RPCNDR_H_VERSION__

#ifndef COM_NO_WINDOWS_H
#include "windows.h"
#include "ole2.h"
#endif /*COM_NO_WINDOWS_H*/

#ifndef __cluadmex_h__
#define __cluadmex_h__

#if defined(_MSC_VER) && (_MSC_VER >= 1020)
#pragma once
#endif

/* Forward Declarations */ 

#ifndef __IGetClusterUIInfo_FWD_DEFINED__
#define __IGetClusterUIInfo_FWD_DEFINED__
typedef interface IGetClusterUIInfo IGetClusterUIInfo;
#endif 	/* __IGetClusterUIInfo_FWD_DEFINED__ */


#ifndef __IGetClusterDataInfo_FWD_DEFINED__
#define __IGetClusterDataInfo_FWD_DEFINED__
typedef interface IGetClusterDataInfo IGetClusterDataInfo;
#endif 	/* __IGetClusterDataInfo_FWD_DEFINED__ */


#ifndef __IGetClusterObjectInfo_FWD_DEFINED__
#define __IGetClusterObjectInfo_FWD_DEFINED__
typedef interface IGetClusterObjectInfo IGetClusterObjectInfo;
#endif 	/* __IGetClusterObjectInfo_FWD_DEFINED__ */


#ifndef __IGetClusterNodeInfo_FWD_DEFINED__
#define __IGetClusterNodeInfo_FWD_DEFINED__
typedef interface IGetClusterNodeInfo IGetClusterNodeInfo;
#endif 	/* __IGetClusterNodeInfo_FWD_DEFINED__ */


#ifndef __IGetClusterGroupInfo_FWD_DEFINED__
#define __IGetClusterGroupInfo_FWD_DEFINED__
typedef interface IGetClusterGroupInfo IGetClusterGroupInfo;
#endif 	/* __IGetClusterGroupInfo_FWD_DEFINED__ */


#ifndef __IGetClusterResourceInfo_FWD_DEFINED__
#define __IGetClusterResourceInfo_FWD_DEFINED__
typedef interface IGetClusterResourceInfo IGetClusterResourceInfo;
#endif 	/* __IGetClusterResourceInfo_FWD_DEFINED__ */


#ifndef __IGetClusterNetworkInfo_FWD_DEFINED__
#define __IGetClusterNetworkInfo_FWD_DEFINED__
typedef interface IGetClusterNetworkInfo IGetClusterNetworkInfo;
#endif 	/* __IGetClusterNetworkInfo_FWD_DEFINED__ */


#ifndef __IGetClusterNetInterfaceInfo_FWD_DEFINED__
#define __IGetClusterNetInterfaceInfo_FWD_DEFINED__
typedef interface IGetClusterNetInterfaceInfo IGetClusterNetInterfaceInfo;
#endif 	/* __IGetClusterNetInterfaceInfo_FWD_DEFINED__ */


#ifndef __IWCPropertySheetCallback_FWD_DEFINED__
#define __IWCPropertySheetCallback_FWD_DEFINED__
typedef interface IWCPropertySheetCallback IWCPropertySheetCallback;
#endif 	/* __IWCPropertySheetCallback_FWD_DEFINED__ */


#ifndef __IWEExtendPropertySheet_FWD_DEFINED__
#define __IWEExtendPropertySheet_FWD_DEFINED__
typedef interface IWEExtendPropertySheet IWEExtendPropertySheet;
#endif 	/* __IWEExtendPropertySheet_FWD_DEFINED__ */


#ifndef __IWCWizardCallback_FWD_DEFINED__
#define __IWCWizardCallback_FWD_DEFINED__
typedef interface IWCWizardCallback IWCWizardCallback;
#endif 	/* __IWCWizardCallback_FWD_DEFINED__ */


#ifndef __IWEExtendWizard_FWD_DEFINED__
#define __IWEExtendWizard_FWD_DEFINED__
typedef interface IWEExtendWizard IWEExtendWizard;
#endif 	/* __IWEExtendWizard_FWD_DEFINED__ */


#ifndef __IWCContextMenuCallback_FWD_DEFINED__
#define __IWCContextMenuCallback_FWD_DEFINED__
typedef interface IWCContextMenuCallback IWCContextMenuCallback;
#endif 	/* __IWCContextMenuCallback_FWD_DEFINED__ */


#ifndef __IWEExtendContextMenu_FWD_DEFINED__
#define __IWEExtendContextMenu_FWD_DEFINED__
typedef interface IWEExtendContextMenu IWEExtendContextMenu;
#endif 	/* __IWEExtendContextMenu_FWD_DEFINED__ */


#ifndef __IWEInvokeCommand_FWD_DEFINED__
#define __IWEInvokeCommand_FWD_DEFINED__
typedef interface IWEInvokeCommand IWEInvokeCommand;
#endif 	/* __IWEInvokeCommand_FWD_DEFINED__ */


#ifndef __IWCWizard97Callback_FWD_DEFINED__
#define __IWCWizard97Callback_FWD_DEFINED__
typedef interface IWCWizard97Callback IWCWizard97Callback;
#endif 	/* __IWCWizard97Callback_FWD_DEFINED__ */


#ifndef __IWEExtendWizard97_FWD_DEFINED__
#define __IWEExtendWizard97_FWD_DEFINED__
typedef interface IWEExtendWizard97 IWEExtendWizard97;
#endif 	/* __IWEExtendWizard97_FWD_DEFINED__ */


/* header files for imported files */
#include "oaidl.h"
#include "clusapi.h"

#ifdef __cplusplus
extern "C"{
#endif 


/* interface __MIDL_itf_cluadmex_0000_0000 */
/* [local] */ 

typedef 
enum _CLUADMEX_OBJECT_TYPE
    {	CLUADMEX_OT_NONE	= 0,
	CLUADMEX_OT_CLUSTER	= ( CLUADMEX_OT_NONE + 1 ) ,
	CLUADMEX_OT_NODE	= ( CLUADMEX_OT_CLUSTER + 1 ) ,
	CLUADMEX_OT_GROUP	= ( CLUADMEX_OT_NODE + 1 ) ,
	CLUADMEX_OT_RESOURCE	= ( CLUADMEX_OT_GROUP + 1 ) ,
	CLUADMEX_OT_RESOURCETYPE	= ( CLUADMEX_OT_RESOURCE + 1 ) ,
	CLUADMEX_OT_NETWORK	= ( CLUADMEX_OT_RESOURCETYPE + 1 ) ,
	CLUADMEX_OT_NETINTERFACE	= ( CLUADMEX_OT_NETWORK + 1 ) 
    } 	CLUADMEX_OBJECT_TYPE;



extern RPC_IF_HANDLE __MIDL_itf_cluadmex_0000_0000_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_cluadmex_0000_0000_v0_0_s_ifspec;

#ifndef __IGetClusterUIInfo_INTERFACE_DEFINED__
#define __IGetClusterUIInfo_INTERFACE_DEFINED__

/* interface IGetClusterUIInfo */
/* [unique][helpstring][uuid][object] */ 


EXTERN_C const IID IID_IGetClusterUIInfo;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("97DEDE50-FC6B-11CF-B5F5-00A0C90AB505")
    IGetClusterUIInfo : public IUnknown
    {
    public:
        virtual /* [local] */ HRESULT STDMETHODCALLTYPE GetClusterName( 
            /* [out] */ BSTR lpszName,
            /* [out][in] */ LONG *pcchName) = 0;
        
        virtual /* [local] */ LCID STDMETHODCALLTYPE GetLocale( void) = 0;
        
        virtual /* [local] */ HFONT STDMETHODCALLTYPE GetFont( void) = 0;
        
        virtual /* [local] */ HICON STDMETHODCALLTYPE GetIcon( void) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IGetClusterUIInfoVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IGetClusterUIInfo * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IGetClusterUIInfo * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IGetClusterUIInfo * This);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE *GetClusterName )( 
            IGetClusterUIInfo * This,
            /* [out] */ BSTR lpszName,
            /* [out][in] */ LONG *pcchName);
        
        /* [local] */ LCID ( STDMETHODCALLTYPE *GetLocale )( 
            IGetClusterUIInfo * This);
        
        /* [local] */ HFONT ( STDMETHODCALLTYPE *GetFont )( 
            IGetClusterUIInfo * This);
        
        /* [local] */ HICON ( STDMETHODCALLTYPE *GetIcon )( 
            IGetClusterUIInfo * This);
        
        END_INTERFACE
    } IGetClusterUIInfoVtbl;

    interface IGetClusterUIInfo
    {
        CONST_VTBL struct IGetClusterUIInfoVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IGetClusterUIInfo_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IGetClusterUIInfo_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IGetClusterUIInfo_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IGetClusterUIInfo_GetClusterName(This,lpszName,pcchName)	\
    ( (This)->lpVtbl -> GetClusterName(This,lpszName,pcchName) ) 

#define IGetClusterUIInfo_GetLocale(This)	\
    ( (This)->lpVtbl -> GetLocale(This) ) 

#define IGetClusterUIInfo_GetFont(This)	\
    ( (This)->lpVtbl -> GetFont(This) ) 

#define IGetClusterUIInfo_GetIcon(This)	\
    ( (This)->lpVtbl -> GetIcon(This) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IGetClusterUIInfo_INTERFACE_DEFINED__ */


#ifndef __IGetClusterDataInfo_INTERFACE_DEFINED__
#define __IGetClusterDataInfo_INTERFACE_DEFINED__

/* interface IGetClusterDataInfo */
/* [unique][helpstring][uuid][object] */ 


EXTERN_C const IID IID_IGetClusterDataInfo;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("97DEDE51-FC6B-11CF-B5F5-00A0C90AB505")
    IGetClusterDataInfo : public IUnknown
    {
    public:
        virtual /* [local] */ HRESULT STDMETHODCALLTYPE GetClusterName( 
            /* [out] */ BSTR lpszName,
            /* [out][in] */ LONG *pcchName) = 0;
        
        virtual /* [local] */ HCLUSTER STDMETHODCALLTYPE GetClusterHandle( void) = 0;
        
        virtual /* [local] */ LONG STDMETHODCALLTYPE GetObjectCount( void) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IGetClusterDataInfoVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IGetClusterDataInfo * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IGetClusterDataInfo * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IGetClusterDataInfo * This);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE *GetClusterName )( 
            IGetClusterDataInfo * This,
            /* [out] */ BSTR lpszName,
            /* [out][in] */ LONG *pcchName);
        
        /* [local] */ HCLUSTER ( STDMETHODCALLTYPE *GetClusterHandle )( 
            IGetClusterDataInfo * This);
        
        /* [local] */ LONG ( STDMETHODCALLTYPE *GetObjectCount )( 
            IGetClusterDataInfo * This);
        
        END_INTERFACE
    } IGetClusterDataInfoVtbl;

    interface IGetClusterDataInfo
    {
        CONST_VTBL struct IGetClusterDataInfoVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IGetClusterDataInfo_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IGetClusterDataInfo_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IGetClusterDataInfo_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IGetClusterDataInfo_GetClusterName(This,lpszName,pcchName)	\
    ( (This)->lpVtbl -> GetClusterName(This,lpszName,pcchName) ) 

#define IGetClusterDataInfo_GetClusterHandle(This)	\
    ( (This)->lpVtbl -> GetClusterHandle(This) ) 

#define IGetClusterDataInfo_GetObjectCount(This)	\
    ( (This)->lpVtbl -> GetObjectCount(This) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IGetClusterDataInfo_INTERFACE_DEFINED__ */


#ifndef __IGetClusterObjectInfo_INTERFACE_DEFINED__
#define __IGetClusterObjectInfo_INTERFACE_DEFINED__

/* interface IGetClusterObjectInfo */
/* [unique][helpstring][uuid][object] */ 


EXTERN_C const IID IID_IGetClusterObjectInfo;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("97DEDE52-FC6B-11CF-B5F5-00A0C90AB505")
    IGetClusterObjectInfo : public IUnknown
    {
    public:
        virtual /* [local] */ HRESULT STDMETHODCALLTYPE GetObjectName( 
            /* [in] */ LONG lObjIndex,
            /* [out] */ BSTR lpszName,
            /* [out][in] */ LONG *pcchName) = 0;
        
        virtual /* [local] */ CLUADMEX_OBJECT_TYPE STDMETHODCALLTYPE GetObjectType( 
            /* [in] */ LONG lObjIndex) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IGetClusterObjectInfoVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IGetClusterObjectInfo * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IGetClusterObjectInfo * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IGetClusterObjectInfo * This);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE *GetObjectName )( 
            IGetClusterObjectInfo * This,
            /* [in] */ LONG lObjIndex,
            /* [out] */ BSTR lpszName,
            /* [out][in] */ LONG *pcchName);
        
        /* [local] */ CLUADMEX_OBJECT_TYPE ( STDMETHODCALLTYPE *GetObjectType )( 
            IGetClusterObjectInfo * This,
            /* [in] */ LONG lObjIndex);
        
        END_INTERFACE
    } IGetClusterObjectInfoVtbl;

    interface IGetClusterObjectInfo
    {
        CONST_VTBL struct IGetClusterObjectInfoVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IGetClusterObjectInfo_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IGetClusterObjectInfo_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IGetClusterObjectInfo_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IGetClusterObjectInfo_GetObjectName(This,lObjIndex,lpszName,pcchName)	\
    ( (This)->lpVtbl -> GetObjectName(This,lObjIndex,lpszName,pcchName) ) 

#define IGetClusterObjectInfo_GetObjectType(This,lObjIndex)	\
    ( (This)->lpVtbl -> GetObjectType(This,lObjIndex) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IGetClusterObjectInfo_INTERFACE_DEFINED__ */


#ifndef __IGetClusterNodeInfo_INTERFACE_DEFINED__
#define __IGetClusterNodeInfo_INTERFACE_DEFINED__

/* interface IGetClusterNodeInfo */
/* [unique][helpstring][uuid][object] */ 


EXTERN_C const IID IID_IGetClusterNodeInfo;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("97DEDE53-FC6B-11CF-B5F5-00A0C90AB505")
    IGetClusterNodeInfo : public IUnknown
    {
    public:
        virtual /* [local] */ HNODE STDMETHODCALLTYPE GetNodeHandle( 
            /* [in] */ LONG lObjIndex) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IGetClusterNodeInfoVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IGetClusterNodeInfo * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IGetClusterNodeInfo * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IGetClusterNodeInfo * This);
        
        /* [local] */ HNODE ( STDMETHODCALLTYPE *GetNodeHandle )( 
            IGetClusterNodeInfo * This,
            /* [in] */ LONG lObjIndex);
        
        END_INTERFACE
    } IGetClusterNodeInfoVtbl;

    interface IGetClusterNodeInfo
    {
        CONST_VTBL struct IGetClusterNodeInfoVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IGetClusterNodeInfo_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IGetClusterNodeInfo_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IGetClusterNodeInfo_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IGetClusterNodeInfo_GetNodeHandle(This,lObjIndex)	\
    ( (This)->lpVtbl -> GetNodeHandle(This,lObjIndex) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IGetClusterNodeInfo_INTERFACE_DEFINED__ */


#ifndef __IGetClusterGroupInfo_INTERFACE_DEFINED__
#define __IGetClusterGroupInfo_INTERFACE_DEFINED__

/* interface IGetClusterGroupInfo */
/* [unique][helpstring][uuid][object] */ 


EXTERN_C const IID IID_IGetClusterGroupInfo;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("97DEDE54-FC6B-11CF-B5F5-00A0C90AB505")
    IGetClusterGroupInfo : public IUnknown
    {
    public:
        virtual /* [local] */ HGROUP STDMETHODCALLTYPE GetGroupHandle( 
            /* [in] */ LONG lObjIndex) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IGetClusterGroupInfoVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IGetClusterGroupInfo * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IGetClusterGroupInfo * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IGetClusterGroupInfo * This);
        
        /* [local] */ HGROUP ( STDMETHODCALLTYPE *GetGroupHandle )( 
            IGetClusterGroupInfo * This,
            /* [in] */ LONG lObjIndex);
        
        END_INTERFACE
    } IGetClusterGroupInfoVtbl;

    interface IGetClusterGroupInfo
    {
        CONST_VTBL struct IGetClusterGroupInfoVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IGetClusterGroupInfo_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IGetClusterGroupInfo_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IGetClusterGroupInfo_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IGetClusterGroupInfo_GetGroupHandle(This,lObjIndex)	\
    ( (This)->lpVtbl -> GetGroupHandle(This,lObjIndex) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IGetClusterGroupInfo_INTERFACE_DEFINED__ */


#ifndef __IGetClusterResourceInfo_INTERFACE_DEFINED__
#define __IGetClusterResourceInfo_INTERFACE_DEFINED__

/* interface IGetClusterResourceInfo */
/* [unique][helpstring][uuid][object] */ 


EXTERN_C const IID IID_IGetClusterResourceInfo;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("97DEDE55-FC6B-11CF-B5F5-00A0C90AB505")
    IGetClusterResourceInfo : public IUnknown
    {
    public:
        virtual /* [local] */ HRESOURCE STDMETHODCALLTYPE GetResourceHandle( 
            /* [in] */ LONG lObjIndex) = 0;
        
        virtual /* [local] */ HRESULT STDMETHODCALLTYPE GetResourceTypeName( 
            /* [in] */ LONG lObjIndex,
            /* [out] */ BSTR lpszResTypeName,
            /* [out][in] */ LONG *pcchResTypeName) = 0;
        
        virtual /* [local] */ BOOL STDMETHODCALLTYPE GetResourceNetworkName( 
            /* [in] */ LONG lObjIndex,
            /* [out] */ BSTR lpszNetName,
            /* [out][in] */ ULONG *pcchNetName) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IGetClusterResourceInfoVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IGetClusterResourceInfo * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IGetClusterResourceInfo * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IGetClusterResourceInfo * This);
        
        /* [local] */ HRESOURCE ( STDMETHODCALLTYPE *GetResourceHandle )( 
            IGetClusterResourceInfo * This,
            /* [in] */ LONG lObjIndex);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE *GetResourceTypeName )( 
            IGetClusterResourceInfo * This,
            /* [in] */ LONG lObjIndex,
            /* [out] */ BSTR lpszResTypeName,
            /* [out][in] */ LONG *pcchResTypeName);
        
        /* [local] */ BOOL ( STDMETHODCALLTYPE *GetResourceNetworkName )( 
            IGetClusterResourceInfo * This,
            /* [in] */ LONG lObjIndex,
            /* [out] */ BSTR lpszNetName,
            /* [out][in] */ ULONG *pcchNetName);
        
        END_INTERFACE
    } IGetClusterResourceInfoVtbl;

    interface IGetClusterResourceInfo
    {
        CONST_VTBL struct IGetClusterResourceInfoVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IGetClusterResourceInfo_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IGetClusterResourceInfo_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IGetClusterResourceInfo_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IGetClusterResourceInfo_GetResourceHandle(This,lObjIndex)	\
    ( (This)->lpVtbl -> GetResourceHandle(This,lObjIndex) ) 

#define IGetClusterResourceInfo_GetResourceTypeName(This,lObjIndex,lpszResTypeName,pcchResTypeName)	\
    ( (This)->lpVtbl -> GetResourceTypeName(This,lObjIndex,lpszResTypeName,pcchResTypeName) ) 

#define IGetClusterResourceInfo_GetResourceNetworkName(This,lObjIndex,lpszNetName,pcchNetName)	\
    ( (This)->lpVtbl -> GetResourceNetworkName(This,lObjIndex,lpszNetName,pcchNetName) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IGetClusterResourceInfo_INTERFACE_DEFINED__ */


#ifndef __IGetClusterNetworkInfo_INTERFACE_DEFINED__
#define __IGetClusterNetworkInfo_INTERFACE_DEFINED__

/* interface IGetClusterNetworkInfo */
/* [unique][helpstring][uuid][object] */ 


EXTERN_C const IID IID_IGetClusterNetworkInfo;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("97DEDE56-FC6B-11CF-B5F5-00A0C90AB505")
    IGetClusterNetworkInfo : public IUnknown
    {
    public:
        virtual /* [local] */ HNETWORK STDMETHODCALLTYPE GetNetworkHandle( 
            /* [in] */ LONG lObjIndex) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IGetClusterNetworkInfoVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IGetClusterNetworkInfo * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IGetClusterNetworkInfo * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IGetClusterNetworkInfo * This);
        
        /* [local] */ HNETWORK ( STDMETHODCALLTYPE *GetNetworkHandle )( 
            IGetClusterNetworkInfo * This,
            /* [in] */ LONG lObjIndex);
        
        END_INTERFACE
    } IGetClusterNetworkInfoVtbl;

    interface IGetClusterNetworkInfo
    {
        CONST_VTBL struct IGetClusterNetworkInfoVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IGetClusterNetworkInfo_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IGetClusterNetworkInfo_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IGetClusterNetworkInfo_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IGetClusterNetworkInfo_GetNetworkHandle(This,lObjIndex)	\
    ( (This)->lpVtbl -> GetNetworkHandle(This,lObjIndex) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IGetClusterNetworkInfo_INTERFACE_DEFINED__ */


#ifndef __IGetClusterNetInterfaceInfo_INTERFACE_DEFINED__
#define __IGetClusterNetInterfaceInfo_INTERFACE_DEFINED__

/* interface IGetClusterNetInterfaceInfo */
/* [unique][helpstring][uuid][object] */ 


EXTERN_C const IID IID_IGetClusterNetInterfaceInfo;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("97DEDE57-FC6B-11CF-B5F5-00A0C90AB505")
    IGetClusterNetInterfaceInfo : public IUnknown
    {
    public:
        virtual /* [local] */ HNETINTERFACE STDMETHODCALLTYPE GetNetInterfaceHandle( 
            /* [in] */ LONG lObjIndex) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IGetClusterNetInterfaceInfoVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IGetClusterNetInterfaceInfo * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IGetClusterNetInterfaceInfo * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IGetClusterNetInterfaceInfo * This);
        
        /* [local] */ HNETINTERFACE ( STDMETHODCALLTYPE *GetNetInterfaceHandle )( 
            IGetClusterNetInterfaceInfo * This,
            /* [in] */ LONG lObjIndex);
        
        END_INTERFACE
    } IGetClusterNetInterfaceInfoVtbl;

    interface IGetClusterNetInterfaceInfo
    {
        CONST_VTBL struct IGetClusterNetInterfaceInfoVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IGetClusterNetInterfaceInfo_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IGetClusterNetInterfaceInfo_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IGetClusterNetInterfaceInfo_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IGetClusterNetInterfaceInfo_GetNetInterfaceHandle(This,lObjIndex)	\
    ( (This)->lpVtbl -> GetNetInterfaceHandle(This,lObjIndex) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IGetClusterNetInterfaceInfo_INTERFACE_DEFINED__ */


#ifndef __IWCPropertySheetCallback_INTERFACE_DEFINED__
#define __IWCPropertySheetCallback_INTERFACE_DEFINED__

/* interface IWCPropertySheetCallback */
/* [unique][helpstring][uuid][object] */ 


EXTERN_C const IID IID_IWCPropertySheetCallback;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("97DEDE60-FC6B-11CF-B5F5-00A0C90AB505")
    IWCPropertySheetCallback : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE AddPropertySheetPage( 
            /* [in] */ __RPC__in LONG *hpage) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IWCPropertySheetCallbackVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IWCPropertySheetCallback * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IWCPropertySheetCallback * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IWCPropertySheetCallback * This);
        
        HRESULT ( STDMETHODCALLTYPE *AddPropertySheetPage )( 
            IWCPropertySheetCallback * This,
            /* [in] */ __RPC__in LONG *hpage);
        
        END_INTERFACE
    } IWCPropertySheetCallbackVtbl;

    interface IWCPropertySheetCallback
    {
        CONST_VTBL struct IWCPropertySheetCallbackVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IWCPropertySheetCallback_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IWCPropertySheetCallback_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IWCPropertySheetCallback_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IWCPropertySheetCallback_AddPropertySheetPage(This,hpage)	\
    ( (This)->lpVtbl -> AddPropertySheetPage(This,hpage) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IWCPropertySheetCallback_INTERFACE_DEFINED__ */


#ifndef __IWEExtendPropertySheet_INTERFACE_DEFINED__
#define __IWEExtendPropertySheet_INTERFACE_DEFINED__

/* interface IWEExtendPropertySheet */
/* [unique][helpstring][uuid][object] */ 


EXTERN_C const IID IID_IWEExtendPropertySheet;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("97DEDE61-FC6B-11CF-B5F5-00A0C90AB505")
    IWEExtendPropertySheet : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE CreatePropertySheetPages( 
            /* [in] */ __RPC__in_opt IUnknown *piData,
            /* [in] */ __RPC__in_opt IWCPropertySheetCallback *piCallback) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IWEExtendPropertySheetVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IWEExtendPropertySheet * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IWEExtendPropertySheet * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IWEExtendPropertySheet * This);
        
        HRESULT ( STDMETHODCALLTYPE *CreatePropertySheetPages )( 
            IWEExtendPropertySheet * This,
            /* [in] */ __RPC__in_opt IUnknown *piData,
            /* [in] */ __RPC__in_opt IWCPropertySheetCallback *piCallback);
        
        END_INTERFACE
    } IWEExtendPropertySheetVtbl;

    interface IWEExtendPropertySheet
    {
        CONST_VTBL struct IWEExtendPropertySheetVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IWEExtendPropertySheet_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IWEExtendPropertySheet_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IWEExtendPropertySheet_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IWEExtendPropertySheet_CreatePropertySheetPages(This,piData,piCallback)	\
    ( (This)->lpVtbl -> CreatePropertySheetPages(This,piData,piCallback) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IWEExtendPropertySheet_INTERFACE_DEFINED__ */


#ifndef __IWCWizardCallback_INTERFACE_DEFINED__
#define __IWCWizardCallback_INTERFACE_DEFINED__

/* interface IWCWizardCallback */
/* [unique][helpstring][uuid][object] */ 


EXTERN_C const IID IID_IWCWizardCallback;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("97DEDE62-FC6B-11CF-B5F5-00A0C90AB505")
    IWCWizardCallback : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE AddWizardPage( 
            /* [in] */ __RPC__in LONG *hpage) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE EnableNext( 
            /* [in] */ __RPC__in LONG *hpage,
            /* [in] */ BOOL bEnable) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IWCWizardCallbackVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IWCWizardCallback * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IWCWizardCallback * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IWCWizardCallback * This);
        
        HRESULT ( STDMETHODCALLTYPE *AddWizardPage )( 
            IWCWizardCallback * This,
            /* [in] */ __RPC__in LONG *hpage);
        
        HRESULT ( STDMETHODCALLTYPE *EnableNext )( 
            IWCWizardCallback * This,
            /* [in] */ __RPC__in LONG *hpage,
            /* [in] */ BOOL bEnable);
        
        END_INTERFACE
    } IWCWizardCallbackVtbl;

    interface IWCWizardCallback
    {
        CONST_VTBL struct IWCWizardCallbackVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IWCWizardCallback_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IWCWizardCallback_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IWCWizardCallback_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IWCWizardCallback_AddWizardPage(This,hpage)	\
    ( (This)->lpVtbl -> AddWizardPage(This,hpage) ) 

#define IWCWizardCallback_EnableNext(This,hpage,bEnable)	\
    ( (This)->lpVtbl -> EnableNext(This,hpage,bEnable) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IWCWizardCallback_INTERFACE_DEFINED__ */


#ifndef __IWEExtendWizard_INTERFACE_DEFINED__
#define __IWEExtendWizard_INTERFACE_DEFINED__

/* interface IWEExtendWizard */
/* [unique][helpstring][uuid][object] */ 


EXTERN_C const IID IID_IWEExtendWizard;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("97DEDE63-FC6B-11CF-B5F5-00A0C90AB505")
    IWEExtendWizard : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE CreateWizardPages( 
            /* [in] */ __RPC__in_opt IUnknown *piData,
            /* [in] */ __RPC__in_opt IWCWizardCallback *piCallback) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IWEExtendWizardVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IWEExtendWizard * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IWEExtendWizard * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IWEExtendWizard * This);
        
        HRESULT ( STDMETHODCALLTYPE *CreateWizardPages )( 
            IWEExtendWizard * This,
            /* [in] */ __RPC__in_opt IUnknown *piData,
            /* [in] */ __RPC__in_opt IWCWizardCallback *piCallback);
        
        END_INTERFACE
    } IWEExtendWizardVtbl;

    interface IWEExtendWizard
    {
        CONST_VTBL struct IWEExtendWizardVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IWEExtendWizard_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IWEExtendWizard_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IWEExtendWizard_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IWEExtendWizard_CreateWizardPages(This,piData,piCallback)	\
    ( (This)->lpVtbl -> CreateWizardPages(This,piData,piCallback) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IWEExtendWizard_INTERFACE_DEFINED__ */


#ifndef __IWCContextMenuCallback_INTERFACE_DEFINED__
#define __IWCContextMenuCallback_INTERFACE_DEFINED__

/* interface IWCContextMenuCallback */
/* [unique][helpstring][uuid][object] */ 


EXTERN_C const IID IID_IWCContextMenuCallback;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("97DEDE64-FC6B-11CF-B5F5-00A0C90AB505")
    IWCContextMenuCallback : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE AddExtensionMenuItem( 
            /* [in] */ __RPC__in BSTR lpszName,
            /* [in] */ __RPC__in BSTR lpszStatusBarText,
            /* [in] */ ULONG nCommandID,
            /* [in] */ ULONG nSubmenuCommandID,
            /* [in] */ ULONG uFlags) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IWCContextMenuCallbackVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IWCContextMenuCallback * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IWCContextMenuCallback * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IWCContextMenuCallback * This);
        
        HRESULT ( STDMETHODCALLTYPE *AddExtensionMenuItem )( 
            IWCContextMenuCallback * This,
            /* [in] */ __RPC__in BSTR lpszName,
            /* [in] */ __RPC__in BSTR lpszStatusBarText,
            /* [in] */ ULONG nCommandID,
            /* [in] */ ULONG nSubmenuCommandID,
            /* [in] */ ULONG uFlags);
        
        END_INTERFACE
    } IWCContextMenuCallbackVtbl;

    interface IWCContextMenuCallback
    {
        CONST_VTBL struct IWCContextMenuCallbackVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IWCContextMenuCallback_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IWCContextMenuCallback_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IWCContextMenuCallback_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IWCContextMenuCallback_AddExtensionMenuItem(This,lpszName,lpszStatusBarText,nCommandID,nSubmenuCommandID,uFlags)	\
    ( (This)->lpVtbl -> AddExtensionMenuItem(This,lpszName,lpszStatusBarText,nCommandID,nSubmenuCommandID,uFlags) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IWCContextMenuCallback_INTERFACE_DEFINED__ */


#ifndef __IWEExtendContextMenu_INTERFACE_DEFINED__
#define __IWEExtendContextMenu_INTERFACE_DEFINED__

/* interface IWEExtendContextMenu */
/* [unique][helpstring][uuid][object] */ 


EXTERN_C const IID IID_IWEExtendContextMenu;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("97DEDE65-FC6B-11CF-B5F5-00A0C90AB505")
    IWEExtendContextMenu : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE AddContextMenuItems( 
            /* [in] */ __RPC__in_opt IUnknown *piData,
            /* [in] */ __RPC__in_opt IWCContextMenuCallback *piCallback) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IWEExtendContextMenuVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IWEExtendContextMenu * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IWEExtendContextMenu * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IWEExtendContextMenu * This);
        
        HRESULT ( STDMETHODCALLTYPE *AddContextMenuItems )( 
            IWEExtendContextMenu * This,
            /* [in] */ __RPC__in_opt IUnknown *piData,
            /* [in] */ __RPC__in_opt IWCContextMenuCallback *piCallback);
        
        END_INTERFACE
    } IWEExtendContextMenuVtbl;

    interface IWEExtendContextMenu
    {
        CONST_VTBL struct IWEExtendContextMenuVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IWEExtendContextMenu_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IWEExtendContextMenu_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IWEExtendContextMenu_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IWEExtendContextMenu_AddContextMenuItems(This,piData,piCallback)	\
    ( (This)->lpVtbl -> AddContextMenuItems(This,piData,piCallback) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IWEExtendContextMenu_INTERFACE_DEFINED__ */


#ifndef __IWEInvokeCommand_INTERFACE_DEFINED__
#define __IWEInvokeCommand_INTERFACE_DEFINED__

/* interface IWEInvokeCommand */
/* [unique][helpstring][uuid][object] */ 


EXTERN_C const IID IID_IWEInvokeCommand;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("97DEDE66-FC6B-11CF-B5F5-00A0C90AB505")
    IWEInvokeCommand : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE InvokeCommand( 
            /* [in] */ ULONG nCommandID,
            /* [in] */ __RPC__in_opt IUnknown *piData) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IWEInvokeCommandVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IWEInvokeCommand * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IWEInvokeCommand * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IWEInvokeCommand * This);
        
        HRESULT ( STDMETHODCALLTYPE *InvokeCommand )( 
            IWEInvokeCommand * This,
            /* [in] */ ULONG nCommandID,
            /* [in] */ __RPC__in_opt IUnknown *piData);
        
        END_INTERFACE
    } IWEInvokeCommandVtbl;

    interface IWEInvokeCommand
    {
        CONST_VTBL struct IWEInvokeCommandVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IWEInvokeCommand_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IWEInvokeCommand_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IWEInvokeCommand_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IWEInvokeCommand_InvokeCommand(This,nCommandID,piData)	\
    ( (This)->lpVtbl -> InvokeCommand(This,nCommandID,piData) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IWEInvokeCommand_INTERFACE_DEFINED__ */


#ifndef __IWCWizard97Callback_INTERFACE_DEFINED__
#define __IWCWizard97Callback_INTERFACE_DEFINED__

/* interface IWCWizard97Callback */
/* [unique][helpstring][uuid][object] */ 


EXTERN_C const IID IID_IWCWizard97Callback;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("97DEDE67-FC6B-11CF-B5F5-00A0C90AB505")
    IWCWizard97Callback : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE AddWizard97Page( 
            /* [in] */ __RPC__in LONG *hpage) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE EnableNext( 
            /* [in] */ __RPC__in LONG *hpage,
            /* [in] */ BOOL bEnable) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IWCWizard97CallbackVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IWCWizard97Callback * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IWCWizard97Callback * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IWCWizard97Callback * This);
        
        HRESULT ( STDMETHODCALLTYPE *AddWizard97Page )( 
            IWCWizard97Callback * This,
            /* [in] */ __RPC__in LONG *hpage);
        
        HRESULT ( STDMETHODCALLTYPE *EnableNext )( 
            IWCWizard97Callback * This,
            /* [in] */ __RPC__in LONG *hpage,
            /* [in] */ BOOL bEnable);
        
        END_INTERFACE
    } IWCWizard97CallbackVtbl;

    interface IWCWizard97Callback
    {
        CONST_VTBL struct IWCWizard97CallbackVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IWCWizard97Callback_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IWCWizard97Callback_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IWCWizard97Callback_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IWCWizard97Callback_AddWizard97Page(This,hpage)	\
    ( (This)->lpVtbl -> AddWizard97Page(This,hpage) ) 

#define IWCWizard97Callback_EnableNext(This,hpage,bEnable)	\
    ( (This)->lpVtbl -> EnableNext(This,hpage,bEnable) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IWCWizard97Callback_INTERFACE_DEFINED__ */


#ifndef __IWEExtendWizard97_INTERFACE_DEFINED__
#define __IWEExtendWizard97_INTERFACE_DEFINED__

/* interface IWEExtendWizard97 */
/* [unique][helpstring][uuid][object] */ 


EXTERN_C const IID IID_IWEExtendWizard97;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("97DEDE68-FC6B-11CF-B5F5-00A0C90AB505")
    IWEExtendWizard97 : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE CreateWizard97Pages( 
            /* [in] */ __RPC__in_opt IUnknown *piData,
            /* [in] */ __RPC__in_opt IWCWizard97Callback *piCallback) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IWEExtendWizard97Vtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IWEExtendWizard97 * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IWEExtendWizard97 * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IWEExtendWizard97 * This);
        
        HRESULT ( STDMETHODCALLTYPE *CreateWizard97Pages )( 
            IWEExtendWizard97 * This,
            /* [in] */ __RPC__in_opt IUnknown *piData,
            /* [in] */ __RPC__in_opt IWCWizard97Callback *piCallback);
        
        END_INTERFACE
    } IWEExtendWizard97Vtbl;

    interface IWEExtendWizard97
    {
        CONST_VTBL struct IWEExtendWizard97Vtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IWEExtendWizard97_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IWEExtendWizard97_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IWEExtendWizard97_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IWEExtendWizard97_CreateWizard97Pages(This,piData,piCallback)	\
    ( (This)->lpVtbl -> CreateWizard97Pages(This,piData,piCallback) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IWEExtendWizard97_INTERFACE_DEFINED__ */


/* Additional Prototypes for ALL interfaces */

unsigned long             __RPC_USER  BSTR_UserSize(     unsigned long *, unsigned long            , BSTR * ); 
unsigned char * __RPC_USER  BSTR_UserMarshal(  unsigned long *, unsigned char *, BSTR * ); 
unsigned char * __RPC_USER  BSTR_UserUnmarshal(unsigned long *, unsigned char *, BSTR * ); 
void                      __RPC_USER  BSTR_UserFree(     unsigned long *, BSTR * ); 

unsigned long             __RPC_USER  BSTR_UserSize64(     unsigned long *, unsigned long            , BSTR * ); 
unsigned char * __RPC_USER  BSTR_UserMarshal64(  unsigned long *, unsigned char *, BSTR * ); 
unsigned char * __RPC_USER  BSTR_UserUnmarshal64(unsigned long *, unsigned char *, BSTR * ); 
void                      __RPC_USER  BSTR_UserFree64(     unsigned long *, BSTR * ); 

/* end of Additional Prototypes */

#ifdef __cplusplus
}
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\vs9sp1\sdk\include\CmnQuery.h ===
#ifndef __cmnquery_h
#define __cmnquery_h

DEFINE_GUID(IID_IQueryForm, 0x8cfcee30, 0x39bd, 0x11d0, 0xb8, 0xd1, 0x0, 0xa0, 0x24, 0xab, 0x2d, 0xbb);
DEFINE_GUID(IID_IPersistQuery, 0x1a3114b8, 0xa62e, 0x11d0, 0xa6, 0xc5, 0x0, 0xa0, 0xc9, 0x06, 0xaf, 0x45);

DEFINE_GUID(CLSID_CommonQuery,  0x83bc5ec0, 0x6f2a, 0x11d0, 0xa1, 0xc4, 0x0, 0xaa, 0x00, 0xc1, 0x6e, 0x65);
DEFINE_GUID(IID_ICommonQuery, 0xab50dec0, 0x6f1d, 0x11d0, 0xa1, 0xc4, 0x0, 0xaa, 0x00, 0xc1, 0x6e, 0x65);


#ifndef GUID_DEFS_ONLY

//-----------------------------------------------------------------------------
// IQueryForm
//-----------------------------------------------------------------------------

//
// A query form object is registered under the query handlers CLSID,
// a list is stored in the registry:
//
//  HKCR\CLSID\{CLSID query handler}\Forms
//
// For each form object there are server values which can be defined:
//
//  Flags           = flags for the form object:
//                      QUERYFORM_CHANGESFORMLIST
//                      QUERYFORM_CHANGESOPTFORMLIST
//
//  CLSID           = string containing the CLSID of the InProc server to invoke
//                    to get the IQueryFormObject.
//
//  Forms           = a sub key containing the CLSIDs for the forms registered
//                    by IQueryForm::AddForms (or modified by ::AddPages), if
//                    the flags are 0, then we scan this list looking for a match
//                    for the default form specified.
//

#define QUERYFORM_CHANGESFORMLIST       0x000000001
#define QUERYFORM_CHANGESOPTFORMLIST    0x000000002


//
// Query Forms
// ===========
//  Query forms are registered and have query pages added to them, a form without
//  pages is not displayed.  Each form has a unique CLSID to allow it to be
//  selected by invoking the query dialog.
//

#define CQFF_NOGLOBALPAGES  0x0000001       // = 1 => doesn't have global pages added
#define CQFF_ISOPTIONAL     0x0000002       // = 1 => form is hidden, unless optional forms requested

typedef struct
{
    DWORD   cbStruct;
    DWORD   dwFlags;
    CLSID   clsid;
    HICON   hIcon;
    LPCWSTR pszTitle;
} CQFORM, * LPCQFORM;

typedef HRESULT (CALLBACK *LPCQADDFORMSPROC)(LPARAM lParam, LPCQFORM pForm);


//
// Query Form Pages
// ================
//  When a query form has been registered the caller can then add pages to it,
//  any form can have pages appended.
//


struct _cqpage;
typedef struct _cqpage CQPAGE, * LPCQPAGE;
typedef HRESULT (CALLBACK *LPCQADDPAGESPROC)(LPARAM lParam, REFCLSID clsidForm, LPCQPAGE pPage);
typedef HRESULT (CALLBACK *LPCQPAGEPROC)(LPCQPAGE pPage, HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam);

struct _cqpage
{
    DWORD        cbStruct;
    DWORD        dwFlags;
    LPCQPAGEPROC pPageProc;
    HINSTANCE    hInstance;
    INT          idPageName;
    INT          idPageTemplate;
    DLGPROC      pDlgProc;
    LPARAM       lParam;
};


//
// IQueryForm interfaces
//

#undef  INTERFACE
#define INTERFACE IQueryForm

DECLARE_INTERFACE_IID_(IQueryForm, IUnknown, "8cfcee30-39bd-11d0-b8d1-00a024ab2dbb")
{
    // *** IUnknown methods ***
    STDMETHOD(QueryInterface)(THIS_ REFIID riid, LPVOID * ppvObj) PURE;
    STDMETHOD_(ULONG,AddRef)(THIS) PURE;
    STDMETHOD_(ULONG,Release)(THIS) PURE;

    // IQueryForm methods
    STDMETHOD(Initialize)(THIS_ HKEY hkForm) PURE;
    STDMETHOD(AddForms)(THIS_ LPCQADDFORMSPROC pAddFormsProc, LPARAM lParam) PURE;
    STDMETHOD(AddPages)(THIS_ LPCQADDPAGESPROC pAddPagesProc, LPARAM lParam) PURE;
};


//
// Messages for pages
//

#define CQPM_INITIALIZE             0x00000001
#define CQPM_RELEASE                0x00000002
#define CQPM_ENABLE                 0x00000003 // wParam = TRUE/FALSE (enable, disable), lParam = 0
#define CQPM_GETPARAMETERS          0x00000005 // wParam = 0, lParam = -> receives the LocalAlloc
#define CQPM_CLEARFORM              0x00000006 // wParam, lParam = 0
#define CQPM_PERSIST                0x00000007 // wParam = fRead, lParam -> IPersistQuery
#define CQPM_HELP                   0x00000008 // wParam = 0, lParam -> LPHELPINFO
#define CQPM_SETDEFAULTPARAMETERS   0x00000009 // wParam = 0, lParam -> OPENQUERYWINDOW

#define CQPM_HANDLERSPECIFIC        0x10000000

//-----------------------------------------------------------------------------
// IPersistQuery
//-----------------------------------------------------------------------------

// IPersistQuery interface

#undef  INTERFACE
#define INTERFACE IPersistQuery

DECLARE_INTERFACE_IID_(IPersistQuery, IPersist, "1a3114b8-a62e-11d0-a6c5-00a0c906af45")
{
    // *** IUnknown methods ***
    STDMETHOD(QueryInterface)(THIS_ REFIID riid, LPVOID * ppvObj) PURE;
    STDMETHOD_(ULONG,AddRef)(THIS)  PURE;
    STDMETHOD_(ULONG,Release)(THIS) PURE;

    // IPersist
    STDMETHOD(GetClassID)(THIS_ CLSID* pClassID) PURE;

    // IPersistQuery
    STDMETHOD(WriteString)(THIS_ LPCWSTR pSection, LPCWSTR pValueName, LPCWSTR pValue) PURE;
    STDMETHOD(ReadString)(THIS_ LPCWSTR pSection, LPCWSTR pValueName, LPWSTR pBuffer, INT cchBuffer) PURE;
    STDMETHOD(WriteInt)(THIS_ LPCWSTR pSection, LPCWSTR pValueName, INT value) PURE;
    STDMETHOD(ReadInt)(THIS_ LPCWSTR pSection, LPCWSTR pValueName, LPINT pValue) PURE;
    STDMETHOD(WriteStruct)(THIS_ LPCWSTR pSection, LPCWSTR pValueName, LPVOID pStruct, DWORD cbStruct) PURE;
    STDMETHOD(ReadStruct)(THIS_ LPCWSTR pSection, LPCWSTR pValueName, LPVOID pStruct, DWORD cbStruct) PURE;
    STDMETHOD(Clear)(THIS) PURE;
};


//-----------------------------------------------------------------------------
// ICommonQuery
//-----------------------------------------------------------------------------

#define OQWF_OKCANCEL               0x00000001 // = 1 => Provide OK/Cancel buttons
#define OQWF_DEFAULTFORM            0x00000002 // = 1 => clsidDefaultQueryForm is valid
#define OQWF_SINGLESELECT           0x00000004 // = 1 => view to have single selection (depends on viewer)
#define OQWF_LOADQUERY              0x00000008 // = 1 => use the IPersistQuery to load the given query
#define OQWF_REMOVESCOPES           0x00000010 // = 1 => remove scope picker from dialog
#define OQWF_REMOVEFORMS            0x00000020 // = 1 => remove form picker from dialog
#define OQWF_ISSUEONOPEN            0x00000040 // = 1 => issue query on opening the dialog
#define OQWF_SHOWOPTIONAL           0x00000080 // = 1 => list optional forms by default
#define OQWF_SAVEQUERYONOK          0x00000200 // = 1 => use the IPersistQuery to write the query on close
#define OQWF_HIDEMENUS              0x00000400 // = 1 => no menu bar displayed
#define OQWF_HIDESEARCHUI           0x00000800 // = 1 => dialog is filter, therefore start, stop, new search etc

#define OQWF_PARAMISPROPERTYBAG     0x80000000 // = 1 => the form parameters ptr is an IPropertyBag (ppbFormParameters)

typedef struct
{
    DWORD           cbStruct;                   // structure size
    DWORD           dwFlags;                    // flags (OQFW_*)
    CLSID           clsidHandler;               // clsid of handler we are using
    LPVOID          pHandlerParameters;         // handler specific structure for initialization
    CLSID           clsidDefaultForm;           // default form to be selected (if OQF_DEFAULTFORM == 1 )
    IPersistQuery*  pPersistQuery;              // IPersistQuery used for loading queries
    union
    {
        void*         pFormParameters;
        IPropertyBag* ppbFormParameters;
    };
} OPENQUERYWINDOW, * LPOPENQUERYWINDOW;


// ICommonQuery

#undef  INTERFACE
#define INTERFACE ICommonQuery

DECLARE_INTERFACE_IID_(ICommonQuery, IUnknown, "ab50dec0-6f1d-11d0-a1c4-00aa00c16e65")
{
    // *** IUnknown methods ***
    STDMETHOD(QueryInterface)(THIS_ REFIID riid, LPVOID * ppvObj) PURE;
    STDMETHOD_(ULONG,AddRef)(THIS)  PURE;
    STDMETHOD_(ULONG,Release)(THIS) PURE;

    // ICommonQuery methods
    STDMETHOD(OpenQueryWindow)(THIS_ HWND hwndParent, LPOPENQUERYWINDOW pQueryWnd, IDataObject** ppDataObject) PURE;
};



#endif  // GUID_DEFS_ONLY
#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\vs9sp1\sdk\include\codecapi.h ===
/*++

Copyright (c) Microsoft Corporation. All rights reserved.

Module Name:

    codecapi.h

Abstract:

    CodecAPI Definitions.

--*/

#ifndef __CODECAPI_H
#define __CODECAPI_H

#ifdef UUID_GEN
    #define DEFINE_CODECAPI_GUID( name, guidstr, g1, g2, g3, g4, g5, g6, g7, g8, g9, g10, g11 ) \
        OUR_GUID_ENTRY( CODECAPI_##name, g1, g2, g3, g4, g5, g6, g7, g8, g9, g10, g11 )
#else
    #if !defined(_KS_)
        #error KS.H must be included before codecapi.H
    #endif // !defined(_KS_)

/* Ideally we would like:
        #define DEFINE_CODECAPI_GUID( name, guidstr, g1, g2, g3, g4, g5, g6, g7, g8, g9, g10, g11 ) \
            #define STATIC_CODECAPI_##name 0x##g1, 0x##g2, 0x##g3, 0x##g4, 0x##g5, 0x##g6, 0x##g7, 0x##g8, 0x##g9, 0x##g10, 0x##g11 
            DEFINE_GUIDSTRUCT( guidstr, CODECAPI_##name ) 
            #define CODECAPI_##name DEFINE_GUIDNAMED( CODECAPI_##name )
    Unfortunately you can't invoke multiple defines from a single statement
*/
    #define DEFINE_CODECAPI_GUID( name, guidstr, g1, g2, g3, g4, g5, g6, g7, g8, g9, g10, g11 ) DEFINE_GUIDSTRUCT( guidstr, CODECAPI_##name );
    #define DEFINE_CODECAPI_GUIDNAMED( name )       DEFINE_GUIDNAMED( CODECAPI_##name )
#endif

// Windows CodecAPI Properties

// Legend for the 
//  Reference   VariantType VariantField
//  UINT8       VT_UI1      bVal
//  UINT16      VT_UI2      uiVal
//  UINT32      VT_UI4      ulVal
//  UINT64      VT_UI8      ullVal
//  INT8        VT_I1       eVal
//  INT16       VT_I2       iVal
//  INT32       VT_I4       lVal
//  INT64       VT_I8       llVal
//  BOOL        VT_BOOL     boolVal
//  GUID        VT_BSTR     bstrVal (guid string)
//  UINT32/UNINT32 VT_UI8   ullVal  (ratio)

// { Static definitions
    #define STATIC_CODECAPI_AVEncCommonFormatConstraint 0x57cbb9b8, 0x116f, 0x4951, 0xb4, 0x0c, 0xc2, 0xa0, 0x35, 0xed, 0x8f, 0x17 
    #define STATIC_CODECAPI_GUID_AVEncCommonFormatUnSpecified   0xaf46a35a, 0x6024, 0x4525, 0xa4, 0x8a, 0x09, 0x4b, 0x97, 0xf5, 0xb3, 0xc2
    #define STATIC_CODECAPI_GUID_AVEncCommonFormatDVD_V     0xcc9598c4, 0xe7fe, 0x451d, 0xb1, 0xca, 0x76, 0x1b, 0xc8, 0x40, 0xb7, 0xf3
    #define STATIC_CODECAPI_GUID_AVEncCommonFormatDVD_DashVR 0xe55199d6, 0x044c, 0x4dae, 0xa4, 0x88, 0x53, 0x1e, 0xd3, 0x06, 0x23, 0x5b
    #define STATIC_CODECAPI_GUID_AVEncCommonFormatDVD_PlusVR 0xe74c6f2e, 0xec37, 0x478d, 0x9a, 0xf4, 0xa5, 0xe1, 0x35, 0xb6, 0x27, 0x1c
    #define STATIC_CODECAPI_GUID_AVEncCommonFormatVCD        0x95035bf7, 0x9d90, 0x40ff, 0xad, 0x5c, 0x5c, 0xf8, 0xcf, 0x71, 0xca, 0x1d
    #define STATIC_CODECAPI_GUID_AVEncCommonFormatSVCD       0x51d85818, 0x8220, 0x448c, 0x80, 0x66, 0xd6, 0x9b, 0xed, 0x16, 0xc9, 0xad
    #define STATIC_CODECAPI_GUID_AVEncCommonFormatATSC       0x8d7b897c, 0xa019, 0x4670, 0xaa, 0x76, 0x2e, 0xdc, 0xac, 0x7a, 0xc2, 0x96
    #define STATIC_CODECAPI_GUID_AVEncCommonFormatDVB        0x71830d8f, 0x6c33, 0x430d, 0x84, 0x4b, 0xc2, 0x70, 0x5b, 0xaa, 0xe6, 0xdb
    #define STATIC_CODECAPI_GUID_AVEncCommonFormatMP3        0x349733cd, 0xeb08, 0x4dc2, 0x81, 0x97, 0xe4, 0x98, 0x35, 0xef, 0x82, 0x8b
    #define STATIC_CODECAPI_GUID_AVEncCommonFormatHighMAT    0x1eabe760, 0xfb2b, 0x4928, 0x90, 0xd1, 0x78, 0xdb, 0x88, 0xee, 0xe8, 0x89
    #define STATIC_CODECAPI_GUID_AVEncCommonFormatHighMPV    0xa2d25db8, 0xb8f9, 0x42c2, 0x8b, 0xc7, 0x0b, 0x93, 0xcf, 0x60, 0x47, 0x88
    #define STATIC_CODECAPI_AVEncCodecType                   0x08af4ac1, 0xf3f2, 0x4c74, 0x9d, 0xcf, 0x37, 0xf2, 0xec, 0x79, 0xf8, 0x26
    #define STATIC_CODECAPI_GUID_AVEncMPEG1Video                0xc8dafefe, 0xda1e, 0x4774, 0xb2, 0x7d, 0x11, 0x83, 0x0c, 0x16, 0xb1, 0xfe
    #define STATIC_CODECAPI_GUID_AVEncMPEG2Video                0x046dc19a, 0x6677, 0x4aaa, 0xa3, 0x1d, 0xc1, 0xab, 0x71, 0x6f, 0x45, 0x60
    #define STATIC_CODECAPI_GUID_AVEncMPEG1Audio                0xd4dd1362, 0xcd4a, 0x4cd6, 0x81, 0x38, 0xb9, 0x4d, 0xb4, 0x54, 0x2b, 0x04
    #define STATIC_CODECAPI_GUID_AVEncMPEG2Audio                0xee4cbb1f, 0x9c3f, 0x4770, 0x92, 0xb5, 0xfc, 0xb7, 0xc2, 0xa8, 0xd3, 0x81
    #define STATIC_CODECAPI_GUID_AVEncWMV                    0x4e0fef9b, 0x1d43, 0x41bd, 0xb8, 0xbd, 0x4d, 0x7b, 0xf7, 0x45, 0x7a, 0x2a
    #define STATIC_CODECAPI_GUID_AVEndMPEG4Video                0xdd37b12a, 0x9503, 0x4f8b, 0xb8, 0xd0, 0x32, 0x4a, 0x00, 0xc0, 0xa1, 0xcf
    #define STATIC_CODECAPI_GUID_AVEncH264Video             0x95044eab, 0x31b3, 0x47de, 0x8e, 0x75, 0x38, 0xa4, 0x2b, 0xb0, 0x3e, 0x28
    #define STATIC_CODECAPI_GUID_AVEncDV                        0x09b769c7, 0x3329, 0x44fb, 0x89, 0x54, 0xfa, 0x30, 0x93, 0x7d, 0x3d, 0x5a
    #define STATIC_CODECAPI_GUID_AVEncWMAPro                 0x1955f90c, 0x33f7, 0x4a68, 0xab, 0x81, 0x53, 0xf5, 0x65, 0x71, 0x25, 0xc4
    #define STATIC_CODECAPI_GUID_AVEncWMALossless            0x55ca7265, 0x23d8, 0x4761, 0x90, 0x31, 0xb7, 0x4f, 0xbe, 0x12, 0xf4, 0xc1
    #define STATIC_CODECAPI_GUID_AVEncWMAVoice              0x13ed18cb, 0x50e8, 0x4276, 0xa2, 0x88, 0xa6, 0xaa, 0x22, 0x83, 0x82, 0xd9
    #define STATIC_CODECAPI_GUID_AVEncDolbyDigitalPro       0xf5be76cc, 0x0ff8, 0x40eb, 0x9c, 0xb1, 0xbb, 0xa9, 0x40, 0x04, 0xd4, 0x4f
    #define STATIC_CODECAPI_GUID_AVEncDolbyDigitalConsumer  0xc1a7bf6c, 0x0059, 0x4bfa, 0x94, 0xef, 0xef, 0x74, 0x7a, 0x76, 0x8d, 0x52
    #define STATIC_CODECAPI_GUID_AVEncDolbyDigitalPlus      0x698d1b80, 0xf7dd, 0x415c, 0x97, 0x1c, 0x42, 0x49, 0x2a, 0x20, 0x56, 0xc6
    #define STATIC_CODECAPI_GUID_AVEncDTSHD                 0x2052e630, 0x469d, 0x4bfb, 0x80, 0xca, 0x1d, 0x65, 0x6e, 0x7e, 0x91, 0x8f
    #define STATIC_CODECAPI_GUID_AVEncDTS                   0x45fbcaa2, 0x5e6e, 0x4ab0, 0x88, 0x93, 0x59, 0x03, 0xbe, 0xe9, 0x3a, 0xcf
    #define STATIC_CODECAPI_GUID_AVEncMLP                   0x05f73e29, 0xf0d1, 0x431e, 0xa4, 0x1c, 0xa4, 0x74, 0x32, 0xec, 0x5a, 0x66
    #define STATIC_CODECAPI_GUID_AVEncPCM                   0x844be7f4, 0x26cf, 0x4779, 0xb3, 0x86, 0xcc, 0x05, 0xd1, 0x87, 0x99, 0x0c
    #define STATIC_CODECAPI_GUID_AVEncSDDS                  0x1dc1b82f, 0x11c8, 0x4c71, 0xb7, 0xb6, 0xee, 0x3e, 0xb9, 0xbc, 0x2b, 0x94
    #define STATIC_CODECAPI_AVEncCommonRateControlMode      0x1c0608e9, 0x370c, 0x4710, 0x8a, 0x58, 0xcb, 0x61, 0x81, 0xc4, 0x24, 0x23
    #define STATIC_CODECAPI_AVEncCommonLowLatency    0x9d3ecd55, 0x89e8, 0x490a, 0x97, 0x0a, 0x0c, 0x95, 0x48, 0xd5, 0xa5, 0x6e
    #define STATIC_CODECAPI_AVEncCommonMultipassMode  0x22533d4c, 0x47e1, 0x41b5, 0x93, 0x52, 0xa2, 0xb7, 0x78, 0x0e, 0x7a, 0xc4
    #define STATIC_CODECAPI_AVEncCommonPassStart     0x6a67739f, 0x4eb5, 0x4385, 0x99, 0x28, 0xf2, 0x76, 0xa9, 0x39, 0xef, 0x95
    #define STATIC_CODECAPI_AVEncCommonPassEnd       0x0e3d01bc, 0xc85c, 0x467d, 0x8b, 0x60, 0xc4, 0x10, 0x12, 0xee, 0x3b, 0xf6
    #define STATIC_CODECAPI_AVEncCommonRealTime      0x143a0ff6, 0xa131, 0x43da, 0xb8, 0x1e, 0x98, 0xfb, 0xb8, 0xec, 0x37, 0x8e
    #define STATIC_CODECAPI_AVEncCommonQuality       0xfcbf57a3, 0x7ea5, 0x4b0c, 0x96, 0x44, 0x69, 0xb4, 0x0c, 0x39, 0xc3, 0x91
    #define STATIC_CODECAPI_AVEncCommonQualityVsSpeed 0x98332df8, 0x03cd, 0x476b, 0x89, 0xfa, 0x3f, 0x9e, 0x44, 0x2d, 0xec, 0x9f
    #define STATIC_CODECAPI_AVEncCommonMeanBitRate   0xf7222374, 0x2144, 0x4815, 0xb5, 0x50, 0xa3, 0x7f, 0x8e, 0x12, 0xee, 0x52
    #define STATIC_CODECAPI_AVEncCommonMeanBitRateInterval 0xbfaa2f0c, 0xcb82, 0x4bc0, 0x84, 0x74, 0xf0, 0x6a, 0x8a, 0x0d, 0x02, 0x58
    #define STATIC_CODECAPI_AVEncCommonMaxBitRate    0x9651eae4, 0x39b9, 0x4ebf, 0x85, 0xef, 0xd7, 0xf4, 0x44, 0xec, 0x74, 0x65
    #define STATIC_CODECAPI_AVEncCommonMinBitRate    0x101405b2, 0x2083, 0x4034, 0xa8, 0x06, 0xef, 0xbe, 0xdd, 0xd7, 0xc9, 0xff
    #define STATIC_CODECAPI_AVEncCommonBufferSize    0x0db96574, 0xb6a4, 0x4c8b, 0x81, 0x06, 0x37, 0x73, 0xde, 0x03, 0x10, 0xcd
    #define STATIC_CODECAPI_AVEncCommonBufferInLevel 0xd9c5c8db, 0xfc74, 0x4064, 0x94, 0xe9, 0xcd, 0x19, 0xf9, 0x47, 0xed, 0x45
    #define STATIC_CODECAPI_AVEncCommonBufferOutLevel 0xccae7f49, 0xd0bc, 0x4e3d, 0xa5, 0x7e, 0xfb, 0x57, 0x40, 0x14, 0x00, 0x69
    #define STATIC_CODECAPI_AVEncCommonStreamEndHandling 0x6aad30af, 0x6ba8, 0x4ccc, 0x8f, 0xca, 0x18, 0xd1, 0x9b, 0xea, 0xeb, 0x1c
    #define STATIC_CODECAPI_AVEncStatCommonCompletedPasses 0x3e5de533, 0x9df7, 0x438c, 0x85, 0x4f, 0x9f, 0x7d, 0xd3, 0x68, 0x3d, 0x34
    #define STATIC_CODECAPI_AVEncVideoOutputFrameRate 0xea85e7c3, 0x9567, 0x4d99, 0x87, 0xc4, 0x02, 0xc1, 0xc2, 0x78, 0xca, 0x7c
    #define STATIC_CODECAPI_AVEncVideoOutputFrameRateConversion 0x8c068bf4, 0x369a, 0x4ba3, 0x82, 0xfd, 0xb2, 0x51, 0x8f, 0xb3, 0x39, 0x6e
    #define STATIC_CODECAPI_AVEncVideoPixelAspectRatio 0x3cdc718f, 0xb3e9, 0x4eb6, 0xa5, 0x7f, 0xcf, 0x1f, 0x1b, 0x32, 0x1b, 0x87
    #define STATIC_CODECAPI_AVEncVideoForceSourceScanType 0x1ef2065f, 0x058a, 0x4765, 0xa4, 0xfc, 0x8a, 0x86, 0x4c, 0x10, 0x30, 0x12
    #define STATIC_CODECAPI_AVEncVideoNoOfFieldsToEncode 0x61e4bbe2, 0x4ee0, 0x40e7, 0x80, 0xab, 0x51, 0xdd, 0xee, 0xbe, 0x62, 0x91
    #define STATIC_CODECAPI_AVEncVideoNoOfFieldsToSkip 0xa97e1240, 0x1427, 0x4c16, 0xa7, 0xf7, 0x3d, 0xcf, 0xd8, 0xba, 0x4c, 0xc5
    #define STATIC_CODECAPI_AVEncVideoEncodeDimension 0x1074df28, 0x7e0f, 0x47a4, 0xa4, 0x53, 0xcd, 0xd7, 0x38, 0x70, 0xf5, 0xce
    #define STATIC_CODECAPI_AVEncVideoEncodeOffsetOrigin 0x6bc098fe, 0xa71a, 0x4454, 0x85, 0x2e, 0x4d, 0x2d, 0xde, 0xb2, 0xcd, 0x24
    #define STATIC_CODECAPI_AVEncVideoDisplayDimension 0xde053668, 0xf4ec, 0x47a9, 0x86, 0xd0, 0x83, 0x67, 0x70, 0xf0, 0xc1, 0xd5
    #define STATIC_CODECAPI_AVEncVideoOutputScanType 0x460b5576, 0x842e, 0x49ab, 0xa6, 0x2d, 0xb3, 0x6f, 0x73, 0x12, 0xc9, 0xdb
    #define STATIC_CODECAPI_AVEncVideoInverseTelecineEnable 0x2ea9098b, 0xe76d, 0x4ccd, 0xa0, 0x30, 0xd3, 0xb8, 0x89, 0xc1, 0xb6, 0x4c
    #define STATIC_CODECAPI_AVEncVideoInverseTelecineThreshold 0x40247d84, 0xe895, 0x497f, 0xb4, 0x4c, 0xb7, 0x45, 0x60, 0xac, 0xfe, 0x27
    #define STATIC_CODECAPI_AVEncVideoSourceFilmContent 0x1791c64b, 0xccfc, 0x4827, 0xa0, 0xed, 0x25, 0x57, 0x79, 0x3b, 0x2b, 0x1c
    #define STATIC_CODECAPI_AVEncVideoSourceIsBW 0x42ffc49b, 0x1812, 0x4fdc, 0x8d, 0x24, 0x70, 0x54, 0xc5, 0x21, 0xe6, 0xeb
    #define STATIC_CODECAPI_AVEncVideoFieldSwap  0xfefd7569, 0x4e0a, 0x49f2, 0x9f, 0x2b, 0x36, 0x0e, 0xa4, 0x8c, 0x19, 0xa2
    #define STATIC_CODECAPI_AVEncVideoInputChromaResolution  0xbb0cec33, 0x16f1, 0x47b0, 0x8a, 0x88, 0x37, 0x81, 0x5b, 0xee, 0x17, 0x39
    #define STATIC_CODECAPI_AVEncVideoOutputChromaResolution 0x6097b4c9, 0x7c1d, 0x4e64, 0xbf, 0xcc, 0x9e, 0x97, 0x65, 0x31, 0x8a, 0xe7
    #define STATIC_CODECAPI_AVEncVideoInputChromaSubsampling     0xa8e73a39, 0x4435, 0x4ec3, 0xa6, 0xea, 0x98, 0x30, 0x0f, 0x4b, 0x36, 0xf7
    #define STATIC_CODECAPI_AVEncVideoOutputChromaSubsampling    0xfa561c6c, 0x7d17, 0x44f0, 0x83, 0xc9, 0x32, 0xed, 0x12, 0xe9, 0x63, 0x43
    #define STATIC_CODECAPI_AVEncVideoInputColorPrimaries    0xc24d783f, 0x7ce6, 0x4278, 0x90, 0xab, 0x28, 0xa4, 0xf1, 0xe5, 0xf8, 0x6c
    #define STATIC_CODECAPI_AVEncVideoOutputColorPrimaries   0xbe95907c, 0x9d04, 0x4921, 0x89, 0x85, 0xa6, 0xd6, 0xd8, 0x7d, 0x1a, 0x6c
    #define STATIC_CODECAPI_AVEncVideoInputColorTransferFunction 0x8c056111, 0xa9c3, 0x4b08, 0xa0, 0xa0, 0xce, 0x13, 0xf8, 0xa2, 0x7c, 0x75
    #define STATIC_CODECAPI_AVEncVideoOutputColorTransferFunction    0x4a7f884a, 0xea11, 0x460d, 0xbf, 0x57, 0xb8, 0x8b, 0xc7, 0x59, 0x00, 0xde
    #define STATIC_CODECAPI_AVEncVideoInputColorTransferMatrix   0x52ed68b9, 0x72d5, 0x4089, 0x95, 0x8d, 0xf5, 0x40, 0x5d, 0x55, 0x08, 0x1c
    #define STATIC_CODECAPI_AVEncVideoOutputColorTransferMatrix  0xa9b90444, 0xaf40, 0x4310, 0x8f, 0xbe, 0xed, 0x6d, 0x93, 0x3f, 0x89, 0x2b
    #define STATIC_CODECAPI_AVEncVideoInputColorLighting 0x46a99549, 0x0015, 0x4a45, 0x9c, 0x30, 0x1d, 0x5c, 0xfa, 0x25, 0x83, 0x16
    #define STATIC_CODECAPI_AVEncVideoOutputColorLighting    0x0e5aaac6, 0xace6, 0x4c5c, 0x99, 0x8e, 0x1a, 0x8c, 0x9c, 0x6c, 0x0f, 0x89
    #define STATIC_CODECAPI_AVEncVideoInputColorNominalRange 0x16cf25c6, 0xa2a6, 0x48e9, 0xae, 0x80, 0x21, 0xae, 0xc4, 0x1d, 0x42, 0x7e
    #define STATIC_CODECAPI_AVEncVideoOutputColorNominalRange    0x972835ed, 0x87b5, 0x4e95, 0x95, 0x00, 0xc7, 0x39, 0x58, 0x56, 0x6e, 0x54
    #define STATIC_CODECAPI_AVEncInputVideoSystem    0xbede146d, 0xb616, 0x4dc7, 0x92, 0xb2, 0xf5, 0xd9, 0xfa, 0x92, 0x98, 0xf7
    #define STATIC_CODECAPI_AVEncVideoHeaderDropFrame 0x6ed9e124, 0x7925, 0x43fe, 0x97, 0x1b, 0xe0, 0x19, 0xf6, 0x22, 0x22, 0xb4
    #define STATIC_CODECAPI_AVEncVideoHeaderHours    0x2acc7702, 0xe2da, 0x4158, 0xbf, 0x9b, 0x88, 0x88, 0x01, 0x29, 0xd7, 0x40
    #define STATIC_CODECAPI_AVEncVideoHeaderMinutes  0xdc1a99ce, 0x0307, 0x408b, 0x88, 0x0b, 0xb8, 0x34, 0x8e, 0xe8, 0xca, 0x7f
    #define STATIC_CODECAPI_AVEncVideoHeaderSeconds  0x4a2e1a05, 0xa780, 0x4f58, 0x81, 0x20, 0x9a, 0x44, 0x9d, 0x69, 0x65, 0x6b
    #define STATIC_CODECAPI_AVEncVideoHeaderFrames   0xafd5f567, 0x5c1b, 0x4adc, 0xbd, 0xaf, 0x73, 0x56, 0x10, 0x38, 0x14, 0x36
    #define STATIC_CODECAPI_AVEncVideoDefaultUpperFieldDominant 0x810167c4, 0x0bc1, 0x47ca, 0x8f, 0xc2, 0x57, 0x05, 0x5a, 0x14, 0x74, 0xa5
    #define STATIC_CODECAPI_AVEncVideoCBRMotionTradeoff 0x0d49451e, 0x18d5, 0x4367, 0xa4, 0xef, 0x32, 0x40, 0xdf, 0x16, 0x93, 0xc4
    #define STATIC_CODECAPI_AVEncVideoCodedVideoAccessUnitSize 0xb4b10c15, 0x14a7, 0x4ce8, 0xb1, 0x73, 0xdc, 0x90, 0xa0, 0xb4, 0xfc, 0xdb
    #define STATIC_CODECAPI_AVEncVideoMaxKeyframeDistance   0x2987123a, 0xba93, 0x4704, 0xb4, 0x89, 0xec, 0x1e, 0x5f, 0x25, 0x29, 0x2c
    #define STATIC_CODECAPI_AVEncStatVideoOutputFrameRate 0xbe747849, 0x9ab4, 0x4a63, 0x98, 0xfe, 0xf1, 0x43, 0xf0, 0x4f, 0x8e, 0xe9
    #define STATIC_CODECAPI_AVEncStatVideoCodedFrames    0xd47f8d61, 0x6f5a, 0x4a26, 0xbb, 0x9f, 0xcd, 0x95, 0x18, 0x46, 0x2b, 0xcd
    #define STATIC_CODECAPI_AVEncStatVideoTotalFrames    0xfdaa9916, 0x119a, 0x4222, 0x9a, 0xd6, 0x3f, 0x7c, 0xab, 0x99, 0xcc, 0x8b
    #define STATIC_CODECAPI_AVEncAudioIntervalToEncode   0x866e4b4d, 0x725a, 0x467c, 0xbb, 0x01, 0xb4, 0x96, 0xb2, 0x3b, 0x25, 0xf9
    #define STATIC_CODECAPI_AVEncAudioIntervalToSkip     0x88c15f94, 0xc38c, 0x4796, 0xa9, 0xe8, 0x96, 0xe9, 0x67, 0x98, 0x3f, 0x26
    #define STATIC_CODECAPI_AVEncAudioDualMono           0x3648126b, 0xa3e8, 0x4329, 0x9b, 0x3a, 0x5c, 0xe5, 0x66, 0xa4, 0x3b, 0xd3

    #define STATIC_CODECAPI_AVEncAudioMapDestChannel0    0xbc5d0b60, 0xdf6a, 0x4e16, 0x98, 0x03, 0xb8, 0x20, 0x07, 0xa3, 0x0c, 0x8d
    #define STATIC_CODECAPI_AVEncAudioMapDestChannel1    0xbc5d0b61, 0xdf6a, 0x4e16, 0x98, 0x03, 0xb8, 0x20, 0x07, 0xa3, 0x0c, 0x8d
    #define STATIC_CODECAPI_AVEncAudioMapDestChannel2    0xbc5d0b62, 0xdf6a, 0x4e16, 0x98, 0x03, 0xb8, 0x20, 0x07, 0xa3, 0x0c, 0x8d
    #define STATIC_CODECAPI_AVEncAudioMapDestChannel3    0xbc5d0b63, 0xdf6a, 0x4e16, 0x98, 0x03, 0xb8, 0x20, 0x07, 0xa3, 0x0c, 0x8d
    #define STATIC_CODECAPI_AVEncAudioMapDestChannel4    0xbc5d0b64, 0xdf6a, 0x4e16, 0x98, 0x03, 0xb8, 0x20, 0x07, 0xa3, 0x0c, 0x8d
    #define STATIC_CODECAPI_AVEncAudioMapDestChannel5    0xbc5d0b65, 0xdf6a, 0x4e16, 0x98, 0x03, 0xb8, 0x20, 0x07, 0xa3, 0x0c, 0x8d
    #define STATIC_CODECAPI_AVEncAudioMapDestChannel6    0xbc5d0b66, 0xdf6a, 0x4e16, 0x98, 0x03, 0xb8, 0x20, 0x07, 0xa3, 0x0c, 0x8d
    #define STATIC_CODECAPI_AVEncAudioMapDestChannel7    0xbc5d0b67, 0xdf6a, 0x4e16, 0x98, 0x03, 0xb8, 0x20, 0x07, 0xa3, 0x0c, 0x8d
    #define STATIC_CODECAPI_AVEncAudioMapDestChannel8    0xbc5d0b68, 0xdf6a, 0x4e16, 0x98, 0x03, 0xb8, 0x20, 0x07, 0xa3, 0x0c, 0x8d
    #define STATIC_CODECAPI_AVEncAudioMapDestChannel9    0xbc5d0b69, 0xdf6a, 0x4e16, 0x98, 0x03, 0xb8, 0x20, 0x07, 0xa3, 0x0c, 0x8d
    #define STATIC_CODECAPI_AVEncAudioMapDestChannel10   0xbc5d0b6a, 0xdf6a, 0x4e16, 0x98, 0x03, 0xb8, 0x20, 0x07, 0xa3, 0x0c, 0x8d
    #define STATIC_CODECAPI_AVEncAudioMapDestChannel11   0xbc5d0b6b, 0xdf6a, 0x4e16, 0x98, 0x03, 0xb8, 0x20, 0x07, 0xa3, 0x0c, 0x8d
    #define STATIC_CODECAPI_AVEncAudioMapDestChannel12   0xbc5d0b6c, 0xdf6a, 0x4e16, 0x98, 0x03, 0xb8, 0x20, 0x07, 0xa3, 0x0c, 0x8d
    #define STATIC_CODECAPI_AVEncAudioMapDestChannel13   0xbc5d0b6d, 0xdf6a, 0x4e16, 0x98, 0x03, 0xb8, 0x20, 0x07, 0xa3, 0x0c, 0x8d
    #define STATIC_CODECAPI_AVEncAudioMapDestChannel14   0xbc5d0b6e, 0xdf6a, 0x4e16, 0x98, 0x03, 0xb8, 0x20, 0x07, 0xa3, 0x0c, 0x8d
    #define STATIC_CODECAPI_AVEncAudioMapDestChannel15   0xbc5d0b6f, 0xdf6a, 0x4e16, 0x98, 0x03, 0xb8, 0x20, 0x07, 0xa3, 0x0c, 0x8d

    #define STATIC_CODECAPI_AVEncAudioInputContent       0x3e226c2b, 0x60b9, 0x4a39, 0xb0, 0x0b, 0xa7, 0xb4, 0x0f, 0x70, 0xd5, 0x66
    #define STATIC_CODECAPI_AVEncStatAudioPeakPCMValue   0xdce7fd34, 0xdc00, 0x4c16, 0x82, 0x1b, 0x35, 0xd9, 0xeb, 0x00, 0xfb, 0x1a
    #define STATIC_CODECAPI_AVEncStatAudioAveragePCMValue 0x979272f8, 0xd17f, 0x4e32, 0xbb, 0x73, 0x4e, 0x73, 0x1c, 0x68, 0xba, 0x2d
    #define STATIC_CODECAPI_AVEncStatAudioAverageBPS 0xca6724db, 0x7059, 0x4351, 0x8b, 0x43, 0xf8, 0x21, 0x98, 0x82, 0x6a, 0x14
    #define STATIC_CODECAPI_AVEncMPVGOPSize          0x95f31b26, 0x95a4, 0x41aa, 0x93, 0x03, 0x24, 0x6a, 0x7f, 0xc6, 0xee, 0xf1
    #define STATIC_CODECAPI_AVEncMPVGOPOpen          0xb1d5d4a6, 0x3300, 0x49b1, 0xae, 0x61, 0xa0, 0x99, 0x37, 0xab, 0x0e, 0x49
    #define STATIC_CODECAPI_AVEncMPVDefaultBPictureCount 0x8d390aac, 0xdc5c, 0x4200, 0xb5, 0x7f, 0x81, 0x4d, 0x04, 0xba, 0xba, 0xb2
    #define STATIC_CODECAPI_AVEncMPVProfile          0xdabb534a, 0x1d99, 0x4284, 0x97, 0x5a, 0xd9, 0x0e, 0x22, 0x39, 0xba, 0xa1
    #define STATIC_CODECAPI_AVEncMPVLevel            0x6ee40c40, 0xa60c, 0x41ef, 0x8f, 0x50, 0x37, 0xc2, 0x24, 0x9e, 0x2c, 0xb3
    #define STATIC_CODECAPI_AVEncMPVFrameFieldMode   0xacb5de96, 0x7b93, 0x4c2f, 0x88, 0x25, 0xb0, 0x29, 0x5f, 0xa9, 0x3b, 0xf4
    #define STATIC_CODECAPI_AVEncMPVAddSeqEndCode    0xa823178f, 0x57df, 0x4c7a, 0xb8, 0xfd, 0xe5, 0xec, 0x88, 0x87, 0x70, 0x8d
    #define STATIC_CODECAPI_AVEncMPVGOPSInSeq        0x993410d4, 0x2691, 0x4192, 0x99, 0x78, 0x98, 0xdc, 0x26, 0x03, 0x66, 0x9f
    #define STATIC_CODECAPI_AVEncMPVUseConcealmentMotionVectors  0xec770cf3, 0x6908, 0x4b4b, 0xaa, 0x30, 0x7f, 0xb9, 0x86, 0x21, 0x4f, 0xea
    #define STATIC_CODECAPI_AVEncMPVSceneDetection   0x552799f1, 0xdb4c, 0x405b, 0x8a, 0x3a, 0xc9, 0x3f, 0x2d, 0x06, 0x74, 0xdc
    #define STATIC_CODECAPI_AVEncMPVGenerateHeaderSeqExt 0xd5e78611, 0x082d, 0x4e6b, 0x98, 0xaf, 0x0f, 0x51, 0xab, 0x13, 0x92, 0x22
    #define STATIC_CODECAPI_AVEncMPVGenerateHeaderSeqDispExt 0x6437aa6f, 0x5a3c, 0x4de9, 0x8a, 0x16, 0x53, 0xd9, 0xc4, 0xad, 0x32, 0x6f
    #define STATIC_CODECAPI_AVEncMPVGenerateHeaderPicExt 0x1b8464ab, 0x944f, 0x45f0, 0xb7, 0x4e, 0x3a, 0x58, 0xda, 0xd1, 0x1f, 0x37
    #define STATIC_CODECAPI_AVEncMPVGenerateHeaderPicDispExt 0xc6412f84, 0xc03f, 0x4f40, 0xa0, 0x0c, 0x42, 0x93, 0xdf, 0x83, 0x95, 0xbb
    #define STATIC_CODECAPI_AVEncMPVGenerateHeaderSeqScaleExt 0x0722d62f, 0xdd59, 0x4a86, 0x9c, 0xd5, 0x64, 0x4f, 0x8e, 0x26, 0x53, 0xd8
    #define STATIC_CODECAPI_AVEncMPVScanPattern      0x7f8a478e, 0x7bbb, 0x4ae2, 0xb2, 0xfc, 0x96, 0xd1, 0x7f, 0xc4, 0xa2, 0xd6
    #define STATIC_CODECAPI_AVEncMPVIntraDCPrecision 0xa0116151, 0xcbc8, 0x4af3, 0x97, 0xdc, 0xd0, 0x0c, 0xce, 0xb8, 0x2d, 0x79
    #define STATIC_CODECAPI_AVEncMPVQScaleType       0x2b79ebb7, 0xf484, 0x4af7, 0xbb, 0x58, 0xa2, 0xa1, 0x88, 0xc5, 0xcb, 0xbe
    #define STATIC_CODECAPI_AVEncMPVIntraVLCTable    0xa2b83ff5, 0x1a99, 0x405a, 0xaf, 0x95, 0xc5, 0x99, 0x7d, 0x55, 0x8d, 0x3a
    #define STATIC_CODECAPI_AVEncMPVQuantMatrixIntra 0x9bea04f3, 0x6621, 0x442c, 0x8b, 0xa1, 0x3a, 0xc3, 0x78, 0x97, 0x96, 0x98
    #define STATIC_CODECAPI_AVEncMPVQuantMatrixNonIntra 0x87f441d8, 0x0997, 0x4beb, 0xa0, 0x8e, 0x85, 0x73, 0xd4, 0x09, 0xcf, 0x75
    #define STATIC_CODECAPI_AVEncMPVQuantMatrixChromaIntra 0x9eb9ecd4, 0x018d, 0x4ffd, 0x8f, 0x2d, 0x39, 0xe4, 0x9f, 0x07, 0xb1, 0x7a
    #define STATIC_CODECAPI_AVEncMPVQuantMatrixChromaNonIntra 0x1415b6b1, 0x362a, 0x4338, 0xba, 0x9a, 0x1e, 0xf5, 0x87, 0x03, 0xc0, 0x5b
    #define STATIC_CODECAPI_AVEncMPALayer    0x9d377230, 0xf91b, 0x453d, 0x9c, 0xe0, 0x78, 0x44, 0x54, 0x14, 0xc2, 0x2d
    #define STATIC_CODECAPI_AVEncMPACodingMode       0xb16ade03, 0x4b93, 0x43d7, 0xa5, 0x50, 0x90, 0xb4, 0xfe, 0x22, 0x45, 0x37
    #define STATIC_CODECAPI_AVEncDDService           0xd2e1bec7, 0x5172, 0x4d2a, 0xa5, 0x0e, 0x2f, 0x3b, 0x82, 0xb1, 0xdd, 0xf8
    #define STATIC_CODECAPI_AVEncDDDialogNormalization 0xd7055acf, 0xf125, 0x437d, 0xa7, 0x04, 0x79, 0xc7, 0x9f, 0x04, 0x04, 0xa8
    #define STATIC_CODECAPI_AVEncDDCentreDownMixLevel 0xe285072c, 0xc958, 0x4a81, 0xaf, 0xd2, 0xe5, 0xe0, 0xda, 0xf1, 0xb1, 0x48
    #define STATIC_CODECAPI_AVEncDDSurroundDownMixLevel 0x7b20d6e5, 0x0bcf, 0x4273, 0xa4, 0x87, 0x50, 0x6b, 0x04, 0x79, 0x97, 0xe9
    #define STATIC_CODECAPI_AVEncDDProductionInfoExists 0xb0b7fe5f, 0xb6ab, 0x4f40, 0x96, 0x4d, 0x8d, 0x91, 0xf1, 0x7c, 0x19, 0xe8
    #define STATIC_CODECAPI_AVEncDDProductionRoomType 0xdad7ad60, 0x23d8, 0x4ab7, 0xa2, 0x84, 0x55, 0x69, 0x86, 0xd8, 0xa6, 0xfe
    #define STATIC_CODECAPI_AVEncDDProductionMixLevel 0x301d103a, 0xcbf9, 0x4776, 0x88, 0x99, 0x7c, 0x15, 0xb4, 0x61, 0xab, 0x26
    #define STATIC_CODECAPI_AVEncDDCopyright         0x8694f076, 0xcd75, 0x481d, 0xa5, 0xc6, 0xa9, 0x04, 0xdc, 0xc8, 0x28, 0xf0
    #define STATIC_CODECAPI_AVEncDDOriginalBitstream 0x966ae800, 0x5bd3, 0x4ff9, 0x95, 0xb9, 0xd3, 0x05, 0x66, 0x27, 0x38, 0x56
    #define STATIC_CODECAPI_AVEncDDDigitalDeemphasis 0xe024a2c2, 0x947c, 0x45ac, 0x87, 0xd8, 0xf1, 0x03, 0x0c, 0x5c, 0x00, 0x82
    #define STATIC_CODECAPI_AVEncDDDCHighPassFilter  0x9565239f, 0x861c, 0x4ac8, 0xbf, 0xda, 0xe0, 0x0c, 0xb4, 0xdb, 0x85, 0x48
    #define STATIC_CODECAPI_AVEncDDChannelBWLowPassFilter 0xe197821d, 0xd2e7, 0x43e2, 0xad, 0x2c, 0x00, 0x58, 0x2f, 0x51, 0x85, 0x45
    #define STATIC_CODECAPI_AVEncDDLFELowPassFilter  0xd3b80f6f, 0x9d15, 0x45e5, 0x91, 0xbe, 0x01, 0x9c, 0x3f, 0xab, 0x1f, 0x01
    #define STATIC_CODECAPI_AVEncDDSurround90DegreeePhaseShift 0x25ecec9d, 0x3553, 0x42c0, 0xbb, 0x56, 0xd2, 0x57, 0x92, 0x10, 0x4f, 0x80
    #define STATIC_CODECAPI_AVEncDDSurround3dBAttenuation 0x4d43b99d, 0x31e2, 0x48b9, 0xbf, 0x2e, 0x5c, 0xbf, 0x1a, 0x57, 0x27, 0x84
    #define STATIC_CODECAPI_AVEncDDDynamicRangeCompressionControl 0xcfc2ff6d, 0x79b8, 0x4b8d, 0xa8, 0xaa, 0xa0, 0xc9, 0xbd, 0x1c, 0x29, 0x40
    #define STATIC_CODECAPI_AVEncDDRFPreEmphasisFilter 0x21af44c0, 0x244e, 0x4f3d, 0xa2, 0xcc, 0x3d, 0x30, 0x68, 0xb2, 0xe7, 0x3f
    #define STATIC_CODECAPI_AVEncDDSurroundExMode    0x91607cee, 0xdbdd, 0x4eb6, 0xbc, 0xa2, 0xaa, 0xdf, 0xaf, 0xa3, 0xdd, 0x68
    #define STATIC_CODECAPI_AVEncDDPreferredStereoDownMixMode    0x7f4e6b31, 0x9185, 0x403d, 0xb0, 0xa2, 0x76, 0x37, 0x43, 0xe6, 0xf0, 0x63
    #define STATIC_CODECAPI_AVEncDDLtRtCenterMixLvl_x10 0xdca128a2, 0x491f, 0x4600, 0xb2, 0xda, 0x76, 0xe3, 0x34, 0x4b, 0x41, 0x97
    #define STATIC_CODECAPI_AVEncDDLtRtSurroundMixLvl_x10 0x212246c7, 0x3d2c, 0x4dfa, 0xbc, 0x21, 0x65, 0x2a, 0x90, 0x98, 0x69, 0x0d
    #define STATIC_CODECAPI_AVEncDDLoRoCenterMixLvl_x10 0x1cfba222, 0x25b3, 0x4bf4, 0x9b, 0xfd, 0xe7, 0x11, 0x12, 0x67, 0x85, 0x8c
    #define STATIC_CODECAPI_AVEncDDLoRoSurroundMixLvl_x10 0xe725cff6, 0xeb56, 0x40c7, 0x84, 0x50, 0x2b, 0x93, 0x67, 0xe9, 0x15, 0x55
    #define STATIC_CODECAPI_AVEncDDAtoDConverterType 0x719f9612, 0x81a1, 0x47e0, 0x9a, 0x05, 0xd9, 0x4a, 0xd5, 0xfc, 0xa9, 0x48
    #define STATIC_CODECAPI_AVEncDDHeadphoneMode 0x4052dbec, 0x52f5, 0x42f5, 0x9b, 0x00, 0xd1, 0x34, 0xb1, 0x34, 0x1b, 0x9d
    #define STATIC_CODECAPI_AVEncWMVKeyFrameDistance 0x5569055e, 0xe268, 0x4771, 0xb8, 0x3e, 0x95, 0x55, 0xea, 0x28, 0xae, 0xd3
    #define STATIC_CODECAPI_AVEncWMVInterlacedEncoding 0xe3d00f8a, 0xc6f5, 0x4e14, 0xa5, 0x88, 0x0e, 0xc8, 0x7a, 0x72, 0x6f, 0x9b
    #define STATIC_CODECAPI_AVEncWMVDecoderComplexity 0xf32c0dab, 0xf3cb, 0x4217, 0xb7, 0x9f, 0x87, 0x62, 0x76, 0x8b, 0x5f, 0x67
    #define STATIC_CODECAPI_AVEncWMVKeyFrameBufferLevelMarker 0x51ff1115, 0x33ac, 0x426c, 0xa1, 0xb1, 0x09, 0x32, 0x1b, 0xdf, 0x96, 0xb4
    #define STATIC_CODECAPI_AVEncWMVProduceDummyFrames 0xd669d001, 0x183c, 0x42e3, 0xa3, 0xca, 0x2f, 0x45, 0x86, 0xd2, 0x39, 0x6c
    #define STATIC_CODECAPI_AVEncStatWMVCBAvg        0x6aa6229f, 0xd602, 0x4b9d, 0xb6, 0x8c, 0xc1, 0xad, 0x78, 0x88, 0x4b, 0xef
    #define STATIC_CODECAPI_AVEncStatWMVCBMax        0xe976bef8, 0x00fe, 0x44b4, 0xb6, 0x25, 0x8f, 0x23, 0x8b, 0xc0, 0x34, 0x99
    #define STATIC_CODECAPI_AVEncStatWMVDecoderComplexityProfile 0x89e69fc3, 0x0f9b, 0x436c, 0x97, 0x4a, 0xdf, 0x82, 0x12, 0x27, 0xc9, 0x0d
    #define STATIC_CODECAPI_AVEncStatMPVSkippedEmptyFrames 0x32195fd3, 0x590d, 0x4812, 0xa7, 0xed, 0x6d, 0x63, 0x9a, 0x1f, 0x97, 0x11
    #define STATIC_CODECAPI_AVEncMP12PktzSTDBuffer   0x0b751bd0, 0x819e, 0x478c, 0x94, 0x35, 0x75, 0x20, 0x89, 0x26, 0xb3, 0x77
    #define STATIC_CODECAPI_AVEncMP12PktzStreamID    0xc834d038, 0xf5e8, 0x4408, 0x9b, 0x60, 0x88, 0xf3, 0x64, 0x93, 0xfe, 0xdf
    #define STATIC_CODECAPI_AVEncMP12PktzInitialPTS  0x2a4f2065, 0x9a63, 0x4d20, 0xae, 0x22, 0x0a, 0x1b, 0xc8, 0x96, 0xa3, 0x15
    #define STATIC_CODECAPI_AVEncMP12PktzPacketSize  0xab71347a, 0x1332, 0x4dde, 0xa0, 0xe5, 0xcc, 0xf7, 0xda, 0x8a, 0x0f, 0x22
    #define STATIC_CODECAPI_AVEncMP12PktzCopyright   0xc8f4b0c1, 0x094c, 0x43c7, 0x8e, 0x68, 0xa5, 0x95, 0x40, 0x5a, 0x6e, 0xf8
    #define STATIC_CODECAPI_AVEncMP12PktzOriginal    0x6b178416, 0x31b9, 0x4964, 0x94, 0xcb, 0x6b, 0xff, 0x86, 0x6c, 0xdf, 0x83
    #define STATIC_CODECAPI_AVEncMP12MuxPacketOverhead 0xe40bd720, 0x3955, 0x4453, 0xac, 0xf9, 0xb7, 0x91, 0x32, 0xa3, 0x8f, 0xa0
    #define STATIC_CODECAPI_AVEncMP12MuxNumStreams   0xf7164a41, 0xdced, 0x4659, 0xa8, 0xf2, 0xfb, 0x69, 0x3f, 0x2a, 0x4c, 0xd0
    #define STATIC_CODECAPI_AVEncMP12MuxEarliestPTS  0x157232b6, 0xf809, 0x474e, 0x94, 0x64, 0xa7, 0xf9, 0x30, 0x14, 0xa8, 0x17
    #define STATIC_CODECAPI_AVEncMP12MuxLargestPacketSize 0x35ceb711, 0xf461, 0x4b92, 0xa4, 0xef, 0x17, 0xb6, 0x84, 0x1e, 0xd2, 0x54
    #define STATIC_CODECAPI_AVEncMP12MuxInitialSCR   0x3433ad21, 0x1b91, 0x4a0b, 0xb1, 0x90, 0x2b, 0x77, 0x06, 0x3b, 0x63, 0xa4
    #define STATIC_CODECAPI_AVEncMP12MuxMuxRate      0xee047c72, 0x4bdb, 0x4a9d, 0x8e, 0x21, 0x41, 0x92, 0x6c, 0x82, 0x3d, 0xa7
    #define STATIC_CODECAPI_AVEncMP12MuxPackSize     0xf916053a, 0x1ce8, 0x4faf, 0xaa, 0x0b, 0xba, 0x31, 0xc8, 0x00, 0x34, 0xb8
    #define STATIC_CODECAPI_AVEncMP12MuxSysSTDBufferBound 0x35746903, 0xb545, 0x43e7, 0xbb, 0x35, 0xc5, 0xe0, 0xa7, 0xd5, 0x09, 0x3c
    #define STATIC_CODECAPI_AVEncMP12MuxSysRateBound 0x05f0428a, 0xee30, 0x489d, 0xae, 0x28, 0x20, 0x5c, 0x72, 0x44, 0x67, 0x10
    #define STATIC_CODECAPI_AVEncMP12MuxTargetPacketizer 0xd862212a, 0x2015, 0x45dd, 0x9a, 0x32, 0x1b, 0x3a, 0xa8, 0x82, 0x05, 0xa0
    #define STATIC_CODECAPI_AVEncMP12MuxSysFixed     0xcefb987e, 0x894f, 0x452e, 0x8f, 0x89, 0xa4, 0xef, 0x8c, 0xec, 0x06, 0x3a
    #define STATIC_CODECAPI_AVEncMP12MuxSysCSPS      0x7952ff45, 0x9c0d, 0x4822, 0xbc, 0x82, 0x8a, 0xd7, 0x72, 0xe0, 0x29, 0x93
    #define STATIC_CODECAPI_AVEncMP12MuxSysVideoLock 0xb8296408, 0x2430, 0x4d37, 0xa2, 0xa1, 0x95, 0xb3, 0xe4, 0x35, 0xa9, 0x1d
    #define STATIC_CODECAPI_AVEncMP12MuxSysAudioLock 0x0fbb5752, 0x1d43, 0x47bf, 0xbd, 0x79, 0xf2, 0x29, 0x3d, 0x8c, 0xe3, 0x37
    #define STATIC_CODECAPI_AVEncMP12MuxDVDNavPacks  0xc7607ced, 0x8cf1, 0x4a99, 0x83, 0xa1, 0xee, 0x54, 0x61, 0xbe, 0x35, 0x74

    #define STATIC_CODECAPI_AVEncMPACopyright           0xa6ae762a, 0xd0a9, 0x4454, 0xb8, 0xef, 0xf2, 0xdb, 0xee, 0xfd, 0xd3, 0xbd
    #define STATIC_CODECAPI_AVEncMPAOriginalBitstream   0x3cfb7855, 0x9cc9, 0x47ff, 0xb8, 0x29, 0xb3, 0x67, 0x86, 0xc9, 0x23, 0x46
    #define STATIC_CODECAPI_AVEncMPAEnableRedundancyProtection 0x5e54b09e, 0xb2e7, 0x4973, 0xa8, 0x9b, 0x0b, 0x36, 0x50, 0xa3, 0xbe, 0xda
    #define STATIC_CODECAPI_AVEncMPAPrivateUserBit     0xafa505ce, 0xc1e3, 0x4e3d, 0x85, 0x1b, 0x61, 0xb7, 0x00, 0xe5, 0xe6, 0xcc
    #define STATIC_CODECAPI_AVEncMPAEmphasisType        0x2d59fcda, 0xbf4e, 0x4ed6, 0xb5, 0xdf, 0x5b, 0x03, 0xb3, 0x6b, 0x0a, 0x1f

    #define STATIC_CODECAPI_AVDecCommonMeanBitRate          0x59488217, 0x007a, 0x4f7a, 0x8e, 0x41, 0x5c, 0x48, 0xb1, 0xea, 0xc5, 0xc6
    #define STATIC_CODECAPI_AVDecCommonMeanBitRateInterval  0x0ee437c6, 0x38a7, 0x4c5c, 0x94, 0x4c, 0x68, 0xab, 0x42, 0x11, 0x6b, 0x85
    #define STATIC_CODECAPI_AVDecCommonInputFormat  0xe5005239, 0xbd89, 0x4be3, 0x9c, 0x0f, 0x5d, 0xde, 0x31, 0x79, 0x88, 0xcc 
    #define STATIC_CODECAPI_AVDecCommonOutputFormat                     0x3c790028, 0xc0ce, 0x4256, 0xb1, 0xa2, 0x1b, 0x0f, 0xc8, 0xb1, 0xdc, 0xdc

    #define STATIC_CODECAPI_GUID_AVDecAudioOutputFormat_PCM_Stereo_MatrixEncoded    0x696e1d30, 0x548f, 0x4036, 0x82, 0x5f, 0x70, 0x26, 0xc6, 0x00, 0x11, 0xbd
    #define STATIC_CODECAPI_GUID_AVDecAudioOutputFormat_PCM             0x696e1d31, 0x548f, 0x4036, 0x82, 0x5f, 0x70, 0x26, 0xc6, 0x00, 0x11, 0xbd
    #define STATIC_CODECAPI_GUID_AVDecAudioOutputFormat_SPDIF_PCM       0x696e1d32, 0x548f, 0x4036, 0x82, 0x5f, 0x70, 0x26, 0xc6, 0x00, 0x11, 0xbd
    #define STATIC_CODECAPI_GUID_AVDecAudioOutputFormat_SPDIF_Bitstream 0x696e1d33, 0x548f, 0x4036, 0x82, 0x5f, 0x70, 0x26, 0xc6, 0x00, 0x11, 0xbd
    #define STATIC_CODECAPI_GUID_AVDecAudioOutputFormat_PCM_Headphones  0x696e1d34, 0x548f, 0x4036, 0x82, 0x5f, 0x70, 0x26, 0xc6, 0x00, 0x11, 0xbd
    #define STATIC_CODECAPI_GUID_AVDecAudioOutputFormat_PCM_Stereo_Auto 0x696e1d35, 0x548f, 0x4036, 0x82, 0x5f, 0x70, 0x26, 0xc6, 0x00, 0x11, 0xbd

    #define STATIC_CODECAPI_AVDecVideoImageSize        0x5ee5747c, 0x6801, 0x4cab, 0xaa, 0xf1, 0x62, 0x48, 0xfa, 0x84, 0x1b, 0xa4
    #define STATIC_CODECAPI_AVDecVideoInputScanType    0x38477e1f, 0x0ea7, 0x42cd, 0x8c, 0xd1, 0x13, 0x0c, 0xed, 0x57, 0xc5, 0x80 
    #define STATIC_CODECAPI_AVDecVideoPixelAspectRatio 0xb0cf8245, 0xf32d, 0x41df, 0xb0, 0x2c, 0x87, 0xbd, 0x30, 0x4d, 0x12, 0xab 

    #define STATIC_CODECAPI_GUID_AVDecAudioInputWMA     0xc95e8dcf, 0x4058, 0x4204, 0x8c, 0x42, 0xcb, 0x24, 0xd9, 0x1e, 0x4b, 0x9b 
    #define STATIC_CODECAPI_GUID_AVDecAudioInputWMAPro  0x0128b7c7, 0xda72, 0x4fe3, 0xbe, 0xf8, 0x5c, 0x52, 0xe3, 0x55, 0x77, 0x04
    #define STATIC_CODECAPI_GUID_AVDecAudioInputDolby   0x8e4228a0, 0xf000, 0x4e0b, 0x8f, 0x54, 0xab, 0x8d, 0x24, 0xad, 0x61, 0xa2
    #define STATIC_CODECAPI_GUID_AVDecAudioInputDTS     0x600bc0ca, 0x6a1f, 0x4e91, 0xb2, 0x41, 0x1b, 0xbe, 0xb1, 0xcb, 0x19, 0xe0 
    #define STATIC_CODECAPI_GUID_AVDecAudioInputPCM     0xf2421da5, 0xbbb4, 0x4cd5, 0xa9, 0x96, 0x93, 0x3c, 0x6b, 0x5d, 0x13, 0x47
    #define STATIC_CODECAPI_GUID_AVDecAudioInputMPEG    0x91106f36, 0x02c5, 0x4f75, 0x97, 0x19, 0x3b, 0x7a, 0xbf, 0x75, 0xe1, 0xf6

    #define STATIC_CODECAPI_AVDecAudioDualMono              0x4a52cda8, 0x30f8, 0x4216, 0xbe, 0x0f, 0xba, 0x0b, 0x20, 0x25, 0x92, 0x1d
    #define STATIC_CODECAPI_AVDecAudioDualMonoReproMode     0xa5106186, 0xcc94, 0x4bc9, 0x8c, 0xd9, 0xaa, 0x2f, 0x61, 0xf6, 0x80, 0x7e 

    #define STATIC_CODECAPI_AVAudioChannelCount             0x1d3583c4, 0x1583, 0x474e, 0xb7, 0x1a, 0x5e, 0xe4, 0x63, 0xc1, 0x98, 0xe4
    #define STATIC_CODECAPI_AVAudioChannelConfig            0x17f89cb3, 0xc38d, 0x4368, 0x9e, 0xde, 0x63, 0xb9, 0x4d, 0x17, 0x7f, 0x9f
    #define STATIC_CODECAPI_AVAudioSampleRate               0x971d2723, 0x1acb, 0x42e7, 0x85, 0x5c, 0x52, 0x0a, 0x4b, 0x70, 0xa5, 0xf2

    #define STATIC_CODECAPI_AVDDSurroundMode                0x99f2f386, 0x98d1, 0x4452, 0xa1, 0x63, 0xab, 0xc7, 0x8a, 0x6e, 0xb7, 0x70
    #define STATIC_CODECAPI_AVDecDDOperationalMode          0xd6d6c6d1, 0x064e, 0x4fdd, 0xa4, 0x0e, 0x3e, 0xcb, 0xfc, 0xb7, 0xeb, 0xd0
    #define STATIC_CODECAPI_AVDecDDMatrixDecodingMode       0xddc811a5, 0x04ed, 0x4bf3, 0xa0, 0xca, 0xd0, 0x04, 0x49, 0xf9, 0x35, 0x5f
    #define STATIC_CODECAPI_AVDecDDDynamicRangeScaleHigh    0x50196c21, 0x1f33, 0x4af5, 0xb2, 0x96, 0x11, 0x42, 0x6d, 0x6c, 0x87, 0x89 
    #define STATIC_CODECAPI_AVDecDDDynamicRangeScaleLow     0x044e62e4, 0x11a5, 0x42d5, 0xa3, 0xb2, 0x3b, 0xb2, 0xc7, 0xc2, 0xd7, 0xcf


// end of static definitions }

//
// Common Parameters
//

// AVEncCommonFormatConstraint (GUID)

DEFINE_CODECAPI_GUID( AVEncCommonFormatConstraint,      "57cbb9b8-116f-4951-b40c-c2a035ed8f17", 0x57cbb9b8, 0x116f, 0x4951, 0xb4, 0x0c, 0xc2, 0xa0, 0x35, 0xed, 0x8f, 0x17 )

DEFINE_CODECAPI_GUID( GUID_AVEncCommonFormatUnSpecified, "af46a35a-6024-4525-a48a-094b97f5b3c2", 0xaf46a35a, 0x6024, 0x4525, 0xa4, 0x8a, 0x09, 0x4b, 0x97, 0xf5, 0xb3, 0xc2 )
DEFINE_CODECAPI_GUID( GUID_AVEncCommonFormatDVD_V,      "cc9598c4-e7fe-451d-b1ca-761bc840b7f3", 0xcc9598c4, 0xe7fe, 0x451d, 0xb1, 0xca, 0x76, 0x1b, 0xc8, 0x40, 0xb7, 0xf3 )
DEFINE_CODECAPI_GUID( GUID_AVEncCommonFormatDVD_DashVR, "e55199d6-044c-4dae-a488-531ed306235b", 0xe55199d6, 0x044c, 0x4dae, 0xa4, 0x88, 0x53, 0x1e, 0xd3, 0x06, 0x23, 0x5b )
DEFINE_CODECAPI_GUID( GUID_AVEncCommonFormatDVD_PlusVR, "e74c6f2e-ec37-478d-9af4-a5e135b6271c", 0xe74c6f2e, 0xec37, 0x478d, 0x9a, 0xf4, 0xa5, 0xe1, 0x35, 0xb6, 0x27, 0x1c )
DEFINE_CODECAPI_GUID( GUID_AVEncCommonFormatVCD,        "95035bf7-9d90-40ff-ad5c-5cf8cf71ca1d", 0x95035bf7, 0x9d90, 0x40ff, 0xad, 0x5c, 0x5c, 0xf8, 0xcf, 0x71, 0xca, 0x1d )
DEFINE_CODECAPI_GUID( GUID_AVEncCommonFormatSVCD,       "51d85818-8220-448c-8066-d69bed16c9ad", 0x51d85818, 0x8220, 0x448c, 0x80, 0x66, 0xd6, 0x9b, 0xed, 0x16, 0xc9, 0xad )
DEFINE_CODECAPI_GUID( GUID_AVEncCommonFormatATSC,       "8d7b897c-a019-4670-aa76-2edcac7ac296", 0x8d7b897c, 0xa019, 0x4670, 0xaa, 0x76, 0x2e, 0xdc, 0xac, 0x7a, 0xc2, 0x96 )
DEFINE_CODECAPI_GUID( GUID_AVEncCommonFormatDVB,        "71830d8f-6c33-430d-844b-c2705baae6db", 0x71830d8f, 0x6c33, 0x430d, 0x84, 0x4b, 0xc2, 0x70, 0x5b, 0xaa, 0xe6, 0xdb )
DEFINE_CODECAPI_GUID( GUID_AVEncCommonFormatMP3,        "349733cd-eb08-4dc2-8197-e49835ef828b", 0x349733cd, 0xeb08, 0x4dc2, 0x81, 0x97, 0xe4, 0x98, 0x35, 0xef, 0x82, 0x8b )
DEFINE_CODECAPI_GUID( GUID_AVEncCommonFormatHighMAT,    "1eabe760-fb2b-4928-90d1-78db88eee889", 0x1eabe760, 0xfb2b, 0x4928, 0x90, 0xd1, 0x78, 0xdb, 0x88, 0xee, 0xe8, 0x89 )
DEFINE_CODECAPI_GUID( GUID_AVEncCommonFormatHighMPV,    "a2d25db8-b8f9-42c2-8bc7-0b93cf604788", 0xa2d25db8, 0xb8f9, 0x42c2, 0x8b, 0xc7, 0x0b, 0x93, 0xcf, 0x60, 0x47, 0x88 )

// AVEncCodecType (GUID)
DEFINE_CODECAPI_GUID( AVEncCodecType,                   "08af4ac1-f3f2-4c74-9dcf-37f2ec79f826", 0x08af4ac1, 0xf3f2, 0x4c74, 0x9d, 0xcf, 0x37, 0xf2, 0xec, 0x79, 0xf8, 0x26 )

DEFINE_CODECAPI_GUID( GUID_AVEncMPEG1Video,             "c8dafefe-da1e-4774-b27d-11830c16b1fe", 0xc8dafefe, 0xda1e, 0x4774, 0xb2, 0x7d, 0x11, 0x83, 0x0c, 0x16, 0xb1, 0xfe )
DEFINE_CODECAPI_GUID( GUID_AVEncMPEG2Video,             "046dc19a-6677-4aaa-a31d-c1ab716f4560", 0x046dc19a, 0x6677, 0x4aaa, 0xa3, 0x1d, 0xc1, 0xab, 0x71, 0x6f, 0x45, 0x60 )
DEFINE_CODECAPI_GUID( GUID_AVEncMPEG1Audio,             "d4dd1362-cd4a-4cd6-8138-b94db4542b04", 0xd4dd1362, 0xcd4a, 0x4cd6, 0x81, 0x38, 0xb9, 0x4d, 0xb4, 0x54, 0x2b, 0x04 )
DEFINE_CODECAPI_GUID( GUID_AVEncMPEG2Audio,             "ee4cbb1f-9c3f-4770-92b5-fcb7c2a8d381", 0xee4cbb1f, 0x9c3f, 0x4770, 0x92, 0xb5, 0xfc, 0xb7, 0xc2, 0xa8, 0xd3, 0x81 )
DEFINE_CODECAPI_GUID( GUID_AVEncWMV,                    "4e0fef9b-1d43-41bd-b8bd-4d7bf7457a2a", 0x4e0fef9b, 0x1d43, 0x41bd, 0xb8, 0xbd, 0x4d, 0x7b, 0xf7, 0x45, 0x7a, 0x2a )
DEFINE_CODECAPI_GUID( GUID_AVEndMPEG4Video,             "dd37b12a-9503-4f8b-b8d0-324a00c0a1cf", 0xdd37b12a, 0x9503, 0x4f8b, 0xb8, 0xd0, 0x32, 0x4a, 0x00, 0xc0, 0xa1, 0xcf )
DEFINE_CODECAPI_GUID( GUID_AVEncH264Video,              "95044eab-31b3-47de-8e75-38a42bb03e28", 0x95044eab, 0x31b3, 0x47de, 0x8e, 0x75, 0x38, 0xa4, 0x2b, 0xb0, 0x3e, 0x28 )
DEFINE_CODECAPI_GUID( GUID_AVEncDV,                     "09b769c7-3329-44fb-8954-fa30937d3d5a", 0x09b769c7, 0x3329, 0x44fb, 0x89, 0x54, 0xfa, 0x30, 0x93, 0x7d, 0x3d, 0x5a )
DEFINE_CODECAPI_GUID( GUID_AVEncWMAPro,                 "1955f90c-33f7-4a68-ab81-53f5657125c4", 0x1955f90c, 0x33f7, 0x4a68, 0xab, 0x81, 0x53, 0xf5, 0x65, 0x71, 0x25, 0xc4 )
DEFINE_CODECAPI_GUID( GUID_AVEncWMALossless,            "55ca7265-23d8-4761-9031-b74fbe12f4c1", 0x55ca7265, 0x23d8, 0x4761, 0x90, 0x31, 0xb7, 0x4f, 0xbe, 0x12, 0xf4, 0xc1 )
DEFINE_CODECAPI_GUID( GUID_AVEncWMAVoice,               "13ed18cb-50e8-4276-a288-a6aa228382d9", 0x13ed18cb, 0x50e8, 0x4276, 0xa2, 0x88, 0xa6, 0xaa, 0x22, 0x83, 0x82, 0xd9 )
DEFINE_CODECAPI_GUID( GUID_AVEncDolbyDigitalPro,        "f5be76cc-0ff8-40eb-9cb1-bba94004d44f", 0xf5be76cc, 0x0ff8, 0x40eb, 0x9c, 0xb1, 0xbb, 0xa9, 0x40, 0x04, 0xd4, 0x4f )
DEFINE_CODECAPI_GUID( GUID_AVEncDolbyDigitalConsumer,   "c1a7bf6c-0059-4bfa-94ef-ef747a768d52", 0xc1a7bf6c, 0x0059, 0x4bfa, 0x94, 0xef, 0xef, 0x74, 0x7a, 0x76, 0x8d, 0x52 )
DEFINE_CODECAPI_GUID( GUID_AVEncDolbyDigitalPlus,       "698d1b80-f7dd-415c-971c-42492a2056c6", 0x698d1b80, 0xf7dd, 0x415c, 0x97, 0x1c, 0x42, 0x49, 0x2a, 0x20, 0x56, 0xc6 )
DEFINE_CODECAPI_GUID( GUID_AVEncDTSHD,                  "2052e630-469d-4bfb-80ca-1d656e7e918f", 0x2052e630, 0x469d, 0x4bfb, 0x80, 0xca, 0x1d, 0x65, 0x6e, 0x7e, 0x91, 0x8f )
DEFINE_CODECAPI_GUID( GUID_AVEncDTS,                    "45fbcaa2-5e6e-4ab0-8893-5903bee93acf", 0x45fbcaa2, 0x5e6e, 0x4ab0, 0x88, 0x93, 0x59, 0x03, 0xbe, 0xe9, 0x3a, 0xcf )
DEFINE_CODECAPI_GUID( GUID_AVEncMLP,                    "05f73e29-f0d1-431e-a41c-a47432ec5a66", 0x05f73e29, 0xf0d1, 0x431e, 0xa4, 0x1c, 0xa4, 0x74, 0x32, 0xec, 0x5a, 0x66 )
DEFINE_CODECAPI_GUID( GUID_AVEncPCM,                    "844be7f4-26cf-4779-b386-cc05d187990c", 0x844be7f4, 0x26cf, 0x4779, 0xb3, 0x86, 0xcc, 0x05, 0xd1, 0x87, 0x99, 0x0c )
DEFINE_CODECAPI_GUID( GUID_AVEncSDDS,                   "1dc1b82f-11c8-4c71-b7b6-ee3eb9bc2b94", 0x1dc1b82f, 0x11c8, 0x4c71, 0xb7, 0xb6, 0xee, 0x3e, 0xb9, 0xbc, 0x2b, 0x94 )

    
    

// AVEncCommonRateControlMode (UINT32)
DEFINE_CODECAPI_GUID( AVEncCommonRateControlMode,       "1c0608e9-370c-4710-8a58-cb6181c42423", 0x1c0608e9, 0x370c, 0x4710, 0x8a, 0x58, 0xcb, 0x61, 0x81, 0xc4, 0x24, 0x23 )

enum eAVEncCommonRateControlMode
{
    eAVEncCommonRateControlMode_CBR                = 0,
    eAVEncCommonRateControlMode_PeakConstrainedVBR = 1,
    eAVEncCommonRateControlMode_UnconstrainedVBR   = 2,
    eAVEncCommonRateControlMode_Quality            = 3
};

// AVEncCommonLowLatency (BOOL)
DEFINE_CODECAPI_GUID( AVEncCommonLowLatency,    "9d3ecd55-89e8-490a-970a-0c9548d5a56e", 0x9d3ecd55, 0x89e8, 0x490a, 0x97, 0x0a, 0x0c, 0x95, 0x48, 0xd5, 0xa5, 0x6e )

// AVEncCommonMultipassMode (UINT32)
DEFINE_CODECAPI_GUID( AVEncCommonMultipassMode,  "22533d4c-47e1-41b5-9352-a2b7780e7ac4", 0x22533d4c, 0x47e1, 0x41b5, 0x93, 0x52, 0xa2, 0xb7, 0x78, 0x0e, 0x7a, 0xc4 )

// AVEncCommonPassStart (UINT32)
DEFINE_CODECAPI_GUID( AVEncCommonPassStart,     "6a67739f-4eb5-4385-9928-f276a939ef95", 0x6a67739f, 0x4eb5, 0x4385, 0x99, 0x28, 0xf2, 0x76, 0xa9, 0x39, 0xef, 0x95 )

// AVEncCommonPassEnd (UINT32)
DEFINE_CODECAPI_GUID( AVEncCommonPassEnd,       "0e3d01bc-c85c-467d-8b60-c41012ee3bf6", 0x0e3d01bc, 0xc85c, 0x467d, 0x8b, 0x60, 0xc4, 0x10, 0x12, 0xee, 0x3b, 0xf6 )

// AVEncCommonRealTime (BOOL)
DEFINE_CODECAPI_GUID( AVEncCommonRealTime,      "143a0ff6-a131-43da-b81e-98fbb8ec378e", 0x143a0ff6, 0xa131, 0x43da, 0xb8, 0x1e, 0x98, 0xfb, 0xb8, 0xec, 0x37, 0x8e )

// AVEncCommonQuality (UINT32)
DEFINE_CODECAPI_GUID( AVEncCommonQuality,       "fcbf57a3-7ea5-4b0c-9644-69b40c39c391", 0xfcbf57a3, 0x7ea5, 0x4b0c, 0x96, 0x44, 0x69, 0xb4, 0x0c, 0x39, 0xc3, 0x91 )

// AVEncCommonQualityVsSpeed (UINT32)
DEFINE_CODECAPI_GUID( AVEncCommonQualityVsSpeed, "98332df8-03cd-476b-89fa-3f9e442dec9f", 0x98332df8, 0x03cd, 0x476b, 0x89, 0xfa, 0x3f, 0x9e, 0x44, 0x2d, 0xec, 0x9f )

// AVEncCommonMeanBitRate (UINT32)
DEFINE_CODECAPI_GUID( AVEncCommonMeanBitRate,   "f7222374-2144-4815-b550-a37f8e12ee52", 0xf7222374, 0x2144, 0x4815, 0xb5, 0x50, 0xa3, 0x7f, 0x8e, 0x12, 0xee, 0x52 )

// AVEncCommonMeanBitRateInterval (UINT64)
DEFINE_CODECAPI_GUID( AVEncCommonMeanBitRateInterval, "bfaa2f0c-cb82-4bc0-8474-f06a8a0d0258", 0xbfaa2f0c, 0xcb82, 0x4bc0, 0x84, 0x74, 0xf0, 0x6a, 0x8a, 0x0d, 0x02, 0x58 )

// AVEncCommonMaxBitRate (UINT32)
DEFINE_CODECAPI_GUID( AVEncCommonMaxBitRate,    "9651eae4-39b9-4ebf-85ef-d7f444ec7465", 0x9651eae4, 0x39b9, 0x4ebf, 0x85, 0xef, 0xd7, 0xf4, 0x44, 0xec, 0x74, 0x65 )

// AVEncCommonMinBitRate (UINT32)
DEFINE_CODECAPI_GUID( AVEncCommonMinBitRate,    "101405b2-2083-4034-a806-efbeddd7c9ff", 0x101405b2, 0x2083, 0x4034, 0xa8, 0x06, 0xef, 0xbe, 0xdd, 0xd7, 0xc9, 0xff )

// AVEncCommonBufferSize (UINT32)
DEFINE_CODECAPI_GUID( AVEncCommonBufferSize,    "0db96574-b6a4-4c8b-8106-3773de0310cd", 0x0db96574, 0xb6a4, 0x4c8b, 0x81, 0x06, 0x37, 0x73, 0xde, 0x03, 0x10, 0xcd )

// AVEncCommonBufferInLevel (UINT32)
DEFINE_CODECAPI_GUID( AVEncCommonBufferInLevel, "d9c5c8db-fc74-4064-94e9-cd19f947ed45", 0xd9c5c8db, 0xfc74, 0x4064, 0x94, 0xe9, 0xcd, 0x19, 0xf9, 0x47, 0xed, 0x45 )

// AVEncCommonBufferOutLevel (UINT32)
DEFINE_CODECAPI_GUID( AVEncCommonBufferOutLevel, "ccae7f49-d0bc-4e3d-a57e-fb5740140069", 0xccae7f49, 0xd0bc, 0x4e3d, 0xa5, 0x7e, 0xfb, 0x57, 0x40, 0x14, 0x00, 0x69 )

// AVEncCommonStreamEndHandling (UINT32)
DEFINE_CODECAPI_GUID( AVEncCommonStreamEndHandling, "6aad30af-6ba8-4ccc-8fca-18d19beaeb1c", 0x6aad30af, 0x6ba8, 0x4ccc, 0x8f, 0xca, 0x18, 0xd1, 0x9b, 0xea, 0xeb, 0x1c )

enum eAVEncCommonStreamEndHandling
{
    eAVEncCommonStreamEndHandling_DiscardPartial = 0,
    eAVEncCommonStreamEndHandling_EnsureComplete = 1
};

//
// Common Post Encode Statistical Parameters
//

// AVEncStatCommonCompletedPasses (UINT32)
DEFINE_CODECAPI_GUID( AVEncStatCommonCompletedPasses, "3e5de533-9df7-438c-854f-9f7dd3683d34", 0x3e5de533, 0x9df7, 0x438c, 0x85, 0x4f, 0x9f, 0x7d, 0xd3, 0x68, 0x3d, 0x34 )

//
// Common Video Parameters
//

// AVEncVideoOutputFrameRate (UINT32)
DEFINE_CODECAPI_GUID( AVEncVideoOutputFrameRate, "ea85e7c3-9567-4d99-87c4-02c1c278ca7c", 0xea85e7c3, 0x9567, 0x4d99, 0x87, 0xc4, 0x02, 0xc1, 0xc2, 0x78, 0xca, 0x7c )

// AVEncVideoOutputFrameRateConversion (UINT32)
DEFINE_CODECAPI_GUID( AVEncVideoOutputFrameRateConversion, "8c068bf4-369a-4ba3-82fd-b2518fb3396e", 0x8c068bf4, 0x369a, 0x4ba3, 0x82, 0xfd, 0xb2, 0x51, 0x8f, 0xb3, 0x39, 0x6e )

enum eAVEncVideoOutputFrameRateConversion
{
    eAVEncVideoOutputFrameRateConversion_Disable = 0,
    eAVEncVideoOutputFrameRateConversion_Enable  = 1,
    eAVEncVideoOutputFrameRateConversion_Alias   = 2
};

// AVEncVideoPixelAspectRatio (UINT32 as UINT16/UNIT16) <---- You have WORD in the doc
DEFINE_CODECAPI_GUID( AVEncVideoPixelAspectRatio, "3cdc718f-b3e9-4eb6-a57f-cf1f1b321b87", 0x3cdc718f, 0xb3e9, 0x4eb6, 0xa5, 0x7f, 0xcf, 0x1f, 0x1b, 0x32, 0x1b, 0x87 )

// AVEncVideoForceSourceScanType (UINT32)
DEFINE_CODECAPI_GUID( AVEncVideoForceSourceScanType, "1ef2065f-058a-4765-a4fc-8a864c103012", 0x1ef2065f, 0x058a, 0x4765, 0xa4, 0xfc, 0x8a, 0x86, 0x4c, 0x10, 0x30, 0x12 )
enum eAVEncVideoSourceScanType
{
    eAVEncVideoSourceScan_Automatic         = 0,
    eAVEncVideoSourceScan_Interlaced        = 1,
    eAVEncVideoSourceScan_Progressive       = 2
};

// AVEncVideoNoOfFieldsToEncode (UINT64)
DEFINE_CODECAPI_GUID( AVEncVideoNoOfFieldsToEncode, "61e4bbe2-4ee0-40e7-80ab-51ddeebe6291", 0x61e4bbe2, 0x4ee0, 0x40e7, 0x80, 0xab, 0x51, 0xdd, 0xee, 0xbe, 0x62, 0x91 )

// AVEncVideoNoOfFieldsToSkip (UINT64)
DEFINE_CODECAPI_GUID( AVEncVideoNoOfFieldsToSkip, "a97e1240-1427-4c16-a7f7-3dcfd8ba4cc5", 0xa97e1240, 0x1427, 0x4c16, 0xa7, 0xf7, 0x3d, 0xcf, 0xd8, 0xba, 0x4c, 0xc5 )

// AVEncVideoEncodeDimension (UINT32)
DEFINE_CODECAPI_GUID( AVEncVideoEncodeDimension, "1074df28-7e0f-47a4-a453-cdd73870f5ce", 0x1074df28, 0x7e0f, 0x47a4, 0xa4, 0x53, 0xcd, 0xd7, 0x38, 0x70, 0xf5, 0xce )

// AVEncVideoEncodeOffsetOrigin (UINT32)
DEFINE_CODECAPI_GUID( AVEncVideoEncodeOffsetOrigin, "6bc098fe-a71a-4454-852e-4d2ddeb2cd24", 0x6bc098fe, 0xa71a, 0x4454, 0x85, 0x2e, 0x4d, 0x2d, 0xde, 0xb2, 0xcd, 0x24 )

// AVEncVideoDisplayDimension (UINT32)
DEFINE_CODECAPI_GUID( AVEncVideoDisplayDimension, "de053668-f4ec-47a9-86d0-836770f0c1d5", 0xde053668, 0xf4ec, 0x47a9, 0x86, 0xd0, 0x83, 0x67, 0x70, 0xf0, 0xc1, 0xd5 )

// AVEncVideoOutputScanType (UINT32)
DEFINE_CODECAPI_GUID( AVEncVideoOutputScanType, "460b5576-842e-49ab-a62d-b36f7312c9db", 0x460b5576, 0x842e, 0x49ab, 0xa6, 0x2d, 0xb3, 0x6f, 0x73, 0x12, 0xc9, 0xdb )
enum eAVEncVideoOutputScanType
{
    eAVEncVideoOutputScan_Progressive       = 0, 
    eAVEncVideoOutputScan_Interlaced        = 1,
    eAVEncVideoOutputScan_SameAsInput       = 2,
    eAVEncVideoOutputScan_Automatic         = 3
};

// AVEncVideoInverseTelecineEnable (BOOL)
DEFINE_CODECAPI_GUID( AVEncVideoInverseTelecineEnable, "2ea9098b-e76d-4ccd-a030-d3b889c1b64c", 0x2ea9098b, 0xe76d, 0x4ccd, 0xa0, 0x30, 0xd3, 0xb8, 0x89, 0xc1, 0xb6, 0x4c )

// AVEncVideoInverseTelecineThreshold (UINT32)
DEFINE_CODECAPI_GUID( AVEncVideoInverseTelecineThreshold, "40247d84-e895-497f-b44c-b74560acfe27", 0x40247d84, 0xe895, 0x497f, 0xb4, 0x4c, 0xb7, 0x45, 0x60, 0xac, 0xfe, 0x27 )

// AVEncVideoSourceFilmContent (UINT32)
DEFINE_CODECAPI_GUID( AVEncVideoSourceFilmContent, "1791c64b-ccfc-4827-a0ed-2557793b2b1c", 0x1791c64b, 0xccfc, 0x4827, 0xa0, 0xed, 0x25, 0x57, 0x79, 0x3b, 0x2b, 0x1c )

enum eAVEncVideoFilmContent
{
    eAVEncVideoFilmContent_VideoOnly = 0,
    eAVEncVideoFilmContent_FilmOnly  = 1,
    eAVEncVideoFilmContent_Mixed     = 2
};

// AVEncVideoSourceIsBW (BOOL)
DEFINE_CODECAPI_GUID( AVEncVideoSourceIsBW, "42ffc49b-1812-4fdc-8d24-7054c521e6eb", 0x42ffc49b, 0x1812, 0x4fdc, 0x8d, 0x24, 0x70, 0x54, 0xc5, 0x21, 0xe6, 0xeb )

// AVEncVideoFieldSwap (BOOL)
DEFINE_CODECAPI_GUID( AVEncVideoFieldSwap,  "fefd7569-4e0a-49f2-9f2b-360ea48c19a2", 0xfefd7569, 0x4e0a, 0x49f2, 0x9f, 0x2b, 0x36, 0x0e, 0xa4, 0x8c, 0x19, 0xa2 )

// AVEncVideoInputChromaResolution (UINT32)
// AVEncVideoOutputChromaSubsamplingFormat (UINT32)
DEFINE_CODECAPI_GUID( AVEncVideoInputChromaResolution,  "bb0cec33-16f1-47b0-8a88-37815bee1739", 0xbb0cec33, 0x16f1, 0x47b0, 0x8a, 0x88, 0x37, 0x81, 0x5b, 0xee, 0x17, 0x39 )
DEFINE_CODECAPI_GUID( AVEncVideoOutputChromaResolution, "6097b4c9-7c1d-4e64-bfcc-9e9765318ae7", 0x6097b4c9, 0x7c1d, 0x4e64, 0xbf, 0xcc, 0x9e, 0x97, 0x65, 0x31, 0x8a, 0xe7 )

enum eAVEncVideoChromaResolution
{
    eAVEncVideoChromaResolution_SameAsSource =0 ,
    eAVEncVideoChromaResolution_444 = 1,
    eAVEncVideoChromaResolution_422 = 2,
    eAVEncVideoChromaResolution_420 = 3,
    eAVEncVideoChromaResolution_411 = 4
};

// AVEncVideoInputChromaSubsampling (UINT32)
// AVEncVideoOutputChromaSubsampling (UINT32)
DEFINE_CODECAPI_GUID( AVEncVideoInputChromaSubsampling,     "a8e73a39-4435-4ec3-a6ea-98300f4b36f7", 0xa8e73a39, 0x4435, 0x4ec3, 0xa6, 0xea, 0x98, 0x30, 0x0f, 0x4b, 0x36, 0xf7 )
DEFINE_CODECAPI_GUID( AVEncVideoOutputChromaSubsampling,    "fa561c6c-7d17-44f0-83c9-32ed12e96343", 0xfa561c6c, 0x7d17, 0x44f0, 0x83, 0xc9, 0x32, 0xed, 0x12, 0xe9, 0x63, 0x43 )

enum eAVEncVideoChromaSubsampling
{
    eAVEncVideoChromaSubsamplingFormat_SameAsSource                   = 0,
    eAVEncVideoChromaSubsamplingFormat_ProgressiveChroma              = 0x8,
    eAVEncVideoChromaSubsamplingFormat_Horizontally_Cosited           = 0x4,
    eAVEncVideoChromaSubsamplingFormat_Vertically_Cosited             = 0x2,
    eAVEncVideoChromaSubsamplingFormat_Vertically_AlignedChromaPlanes = 0x1,
};

// AVEncVideoInputColorPrimaries (UINT32)
// AVEncVideoOutputColorPrimaries (UINT32)
DEFINE_CODECAPI_GUID( AVEncVideoInputColorPrimaries,    "c24d783f-7ce6-4278-90ab-28a4f1e5f86c", 0xc24d783f, 0x7ce6, 0x4278, 0x90, 0xab, 0x28, 0xa4, 0xf1, 0xe5, 0xf8, 0x6c )
DEFINE_CODECAPI_GUID( AVEncVideoOutputColorPrimaries,   "be95907c-9d04-4921-8985-a6d6d87d1a6c", 0xbe95907c, 0x9d04, 0x4921, 0x89, 0x85, 0xa6, 0xd6, 0xd8, 0x7d, 0x1a, 0x6c )

enum eAVEncVideoColorPrimaries
{
    eAVEncVideoColorPrimaries_SameAsSource  = 0, 
    eAVEncVideoColorPrimaries_Reserved      = 1,
    eAVEncVideoColorPrimaries_BT709         = 2,
    eAVEncVideoColorPrimaries_BT470_2_SysM  = 3,
    eAVEncVideoColorPrimaries_BT470_2_SysBG = 4,
    eAVEncVideoColorPrimaries_SMPTE170M     = 5,
    eAVEncVideoColorPrimaries_SMPTE240M     = 6,
    eAVEncVideoColorPrimaries_EBU3231       = 7,
    eAVEncVideoColorPrimaries_SMPTE_C       = 8
};

// AVEncVideoInputColorTransferFunction (UINT32)
// AVEncVideoOutputColorTransferFunction (UINT32)
DEFINE_CODECAPI_GUID( AVEncVideoInputColorTransferFunction, "8c056111-a9c3-4b08-a0a0-ce13f8a27c75", 0x8c056111, 0xa9c3, 0x4b08, 0xa0, 0xa0, 0xce, 0x13, 0xf8, 0xa2, 0x7c, 0x75 )
DEFINE_CODECAPI_GUID( AVEncVideoOutputColorTransferFunction,    "4a7f884a-ea11-460d-bf57-b88bc75900de", 0x4a7f884a, 0xea11, 0x460d, 0xbf, 0x57, 0xb8, 0x8b, 0xc7, 0x59, 0x00, 0xde )

enum eAVEncVideoColorTransferFunction
{
    eAVEncVideoColorTransferFunction_SameAsSource = 0,
    eAVEncVideoColorTransferFunction_10           = 1,  // (Linear, scRGB)
    eAVEncVideoColorTransferFunction_18           = 2,
    eAVEncVideoColorTransferFunction_20           = 3,
    eAVEncVideoColorTransferFunction_22           = 4,  // (BT470-2 SysM) 
    eAVEncVideoColorTransferFunction_22_709       = 5,  // (BT709,  SMPTE296M, SMPTE170M, BT470, SMPTE274M, BT.1361) 
    eAVEncVideoColorTransferFunction_22_240M      = 6,  // (SMPTE240M, interim 274M)
    eAVEncVideoColorTransferFunction_22_8bit_sRGB = 7,  // (sRGB)
    eAVEncVideoColorTransferFunction_28           = 8
};

// AVEncVideoInputColorTransferMatrix (UINT32)
// AVEncVideoOutputColorTransferMatrix (UINT32)
DEFINE_CODECAPI_GUID( AVEncVideoInputColorTransferMatrix,   "52ed68b9-72d5-4089-958d-f5405d55081c", 0x52ed68b9, 0x72d5, 0x4089, 0x95, 0x8d, 0xf5, 0x40, 0x5d, 0x55, 0x08, 0x1c )
DEFINE_CODECAPI_GUID( AVEncVideoOutputColorTransferMatrix , "a9b90444-af40-4310-8fbe-ed6d933f892b", 0xa9b90444, 0xaf40, 0x4310, 0x8f, 0xbe, 0xed, 0x6d, 0x93, 0x3f, 0x89, 0x2b )


enum eAVEncVideoColorTransferMatrix
{
    eAVEncVideoColorTransferMatrix_SameAsSource = 0,
    eAVEncVideoColorTransferMatrix_BT709        = 1,
    eAVEncVideoColorTransferMatrix_BT601        = 2,  // (601, BT470-2 B,B, 170M)
    eAVEncVideoColorTransferMatrix_SMPTE240M    = 3
};

// AVEncVideoInputColorLighting (UINT32)
// AVEncVideoOutputColorLighting (UINT32)
DEFINE_CODECAPI_GUID( AVEncVideoInputColorLighting, "46a99549-0015-4a45-9c30-1d5cfa258316", 0x46a99549, 0x0015, 0x4a45, 0x9c, 0x30, 0x1d, 0x5c, 0xfa, 0x25, 0x83, 0x16 )
DEFINE_CODECAPI_GUID( AVEncVideoOutputColorLighting ,   "0e5aaac6-ace6-4c5c-998e-1a8c9c6c0f89", 0x0e5aaac6, 0xace6, 0x4c5c, 0x99, 0x8e, 0x1a, 0x8c, 0x9c, 0x6c, 0x0f, 0x89 )

enum eAVEncVideoColorLighting
{
    eAVEncVideoColorLighting_SameAsSource = 0,
    eAVEncVideoColorLighting_Unknown      = 1,
    eAVEncVideoColorLighting_Bright       = 2,
    eAVEncVideoColorLighting_Office       = 3,
    eAVEncVideoColorLighting_Dim          = 4,
    eAVEncVideoColorLighting_Dark         = 5
};

// AVEncVideoInputColorNominalRange (UINT32)
// AVEncVideoOutputColorNominalRange (UINT32)
DEFINE_CODECAPI_GUID( AVEncVideoInputColorNominalRange, "16cf25c6-a2a6-48e9-ae80-21aec41d427e", 0x16cf25c6, 0xa2a6, 0x48e9, 0xae, 0x80, 0x21, 0xae, 0xc4, 0x1d, 0x42, 0x7e )
DEFINE_CODECAPI_GUID( AVEncVideoOutputColorNominalRange ,   "972835ed-87b5-4e95-9500-c73958566e54", 0x972835ed, 0x87b5, 0x4e95, 0x95, 0x00, 0xc7, 0x39, 0x58, 0x56, 0x6e, 0x54 )

enum eAVEncVideoColorNominalRange
{
    eAVEncVideoColorNominalRange_SameAsSource = 0,
    eAVEncVideoColorNominalRange_0_255        = 1,  // (8 bit: 0..255, 10 bit: 0..1023)
    eAVEncVideoColorNominalRange_16_235       = 2,  // (16..235, 64..940 (16*4...235*4) 
    eAVEncVideoColorNominalRange_48_208       = 3   // (48..208) 
};

// AVEncInputVideoSystem (UINT32)
DEFINE_CODECAPI_GUID( AVEncInputVideoSystem,    "bede146d-b616-4dc7-92b2-f5d9fa9298f7", 0xbede146d, 0xb616, 0x4dc7, 0x92, 0xb2, 0xf5, 0xd9, 0xfa, 0x92, 0x98, 0xf7 )

enum eAVEncInputVideoSystem
{
    eAVEncInputVideoSystem_Unspecified = 0,
    eAVEncInputVideoSystem_PAL       = 1,
    eAVEncInputVideoSystem_NTSC      = 2,
    eAVEncInputVideoSystem_SECAM     = 3,
    eAVEncInputVideoSystem_MAC       = 4,
    eAVEncInputVideoSystem_HDV       = 5,
    eAVEncInputVideoSystem_Component = 6
};

// AVEncVideoHeaderDropFrame (UINT32)
DEFINE_CODECAPI_GUID( AVEncVideoHeaderDropFrame, "6ed9e124-7925-43fe-971b-e019f62222b4", 0x6ed9e124, 0x7925, 0x43fe, 0x97, 0x1b, 0xe0, 0x19, 0xf6, 0x22, 0x22, 0xb4 )

// AVEncVideoHeaderHours (UINT32)
DEFINE_CODECAPI_GUID( AVEncVideoHeaderHours,    "2acc7702-e2da-4158-bf9b-88880129d740", 0x2acc7702, 0xe2da, 0x4158, 0xbf, 0x9b, 0x88, 0x88, 0x01, 0x29, 0xd7, 0x40 )

// AVEncVideoHeaderMinutes (UINT32)
DEFINE_CODECAPI_GUID( AVEncVideoHeaderMinutes,  "dc1a99ce-0307-408b-880b-b8348ee8ca7f", 0xdc1a99ce, 0x0307, 0x408b, 0x88, 0x0b, 0xb8, 0x34, 0x8e, 0xe8, 0xca, 0x7f )

// AVEncVideoHeaderSeconds (UINT32)
DEFINE_CODECAPI_GUID( AVEncVideoHeaderSeconds,  "4a2e1a05-a780-4f58-8120-9a449d69656b", 0x4a2e1a05, 0xa780, 0x4f58, 0x81, 0x20, 0x9a, 0x44, 0x9d, 0x69, 0x65, 0x6b )

// AVEncVideoHeaderFrames (UINT32)
DEFINE_CODECAPI_GUID( AVEncVideoHeaderFrames,   "afd5f567-5c1b-4adc-bdaf-735610381436", 0xafd5f567, 0x5c1b, 0x4adc, 0xbd, 0xaf, 0x73, 0x56, 0x10, 0x38, 0x14, 0x36 )

// AVEncVideoDefaultUpperFieldDominant (BOOL)
DEFINE_CODECAPI_GUID( AVEncVideoDefaultUpperFieldDominant, "810167c4-0bc1-47ca-8fc2-57055a1474a5", 0x810167c4, 0x0bc1, 0x47ca, 0x8f, 0xc2, 0x57, 0x05, 0x5a, 0x14, 0x74, 0xa5 )

// AVEncVideoCBRMotionTradeoff (UINT32)
DEFINE_CODECAPI_GUID( AVEncVideoCBRMotionTradeoff, "0d49451e-18d5-4367-a4ef-3240df1693c4", 0x0d49451e, 0x18d5, 0x4367, 0xa4, 0xef, 0x32, 0x40, 0xdf, 0x16, 0x93, 0xc4 )

// AVEncVideoCodedVideoAccessUnitSize (UINT32)
DEFINE_CODECAPI_GUID( AVEncVideoCodedVideoAccessUnitSize, "b4b10c15-14a7-4ce8-b173-dc90a0b4fcdb", 0xb4b10c15, 0x14a7, 0x4ce8, 0xb1, 0x73, 0xdc, 0x90, 0xa0, 0xb4, 0xfc, 0xdb )

// AVEncVideoMaxKeyframeDistance (UINT32)
DEFINE_CODECAPI_GUID( AVEncVideoMaxKeyframeDistance, "2987123a-ba93-4704-b489-ec1e5f25292c", 0x2987123a, 0xba93, 0x4704, 0xb4, 0x89, 0xec, 0x1e, 0x5f, 0x25, 0x29, 0x2c )

//
// Common Post-Encode Video Statistical Parameters
//

// AVEncStatVideoOutputFrameRate (UINT32/UINT32)
DEFINE_CODECAPI_GUID( AVEncStatVideoOutputFrameRate, "be747849-9ab4-4a63-98fe-f143f04f8ee9", 0xbe747849, 0x9ab4, 0x4a63, 0x98, 0xfe, 0xf1, 0x43, 0xf0, 0x4f, 0x8e, 0xe9 )

// AVEncStatVideoCodedFrames (UINT32)
DEFINE_CODECAPI_GUID( AVEncStatVideoCodedFrames,    "d47f8d61-6f5a-4a26-bb9f-cd9518462bcd", 0xd47f8d61, 0x6f5a, 0x4a26, 0xbb, 0x9f, 0xcd, 0x95, 0x18, 0x46, 0x2b, 0xcd )

// AVEncStatVideoTotalFrames (UINT32)
DEFINE_CODECAPI_GUID( AVEncStatVideoTotalFrames,    "fdaa9916-119a-4222-9ad6-3f7cab99cc8b", 0xfdaa9916, 0x119a, 0x4222, 0x9a, 0xd6, 0x3f, 0x7c, 0xab, 0x99, 0xcc, 0x8b )

//
// Common Audio Parameters
//

// AVEncAudioIntervalToEncode (UINT64)
DEFINE_CODECAPI_GUID( AVEncAudioIntervalToEncode,   "866e4b4d-725a-467c-bb01-b496b23b25f9", 0x866e4b4d, 0x725a, 0x467c, 0xbb, 0x01, 0xb4, 0x96, 0xb2, 0x3b, 0x25, 0xf9 )

// AVEncAudioIntervalToSkip (UINT64)
DEFINE_CODECAPI_GUID( AVEncAudioIntervalToSkip,     "88c15f94-c38c-4796-a9e8-96e967983f26", 0x88c15f94, 0xc38c, 0x4796, 0xa9, 0xe8, 0x96, 0xe9, 0x67, 0x98, 0x3f, 0x26 )

// AVEncAudioDualMono (UINT32) - Read/Write
// Some audio encoders can encode 2 channel input as "dual mono". Use this
// property to set the appropriate field in the bitstream header to indicate that the 
// 2 channel bitstream is or isn't dual mono. 
// For encoding MPEG audio, use the DualChannel option in AVEncMPACodingMode instead
DEFINE_CODECAPI_GUID( AVEncAudioDualMono, "3648126b-a3e8-4329-9b3a-5ce566a43bd3", 0x3648126b, 0xa3e8, 0x4329, 0x9b, 0x3a, 0x5c, 0xe5, 0x66, 0xa4, 0x3b, 0xd3 )

enum eAVEncAudioDualMono
{
    eAVEncAudioDualMono_SameAsInput = 0, // As indicated by input media type 
    eAVEncAudioDualMono_Off         = 1,  // 2-ch output bitstream should not be dual mono
    eAVEncAudioDualMono_On          = 2   // 2-ch output bitstream should be dual mono
}; 

// AVEncAudioMapDestChannel0..15 (UINT32)
DEFINE_CODECAPI_GUID( AVEncAudioMapDestChannel0,    "bc5d0b60-df6a-4e16-9803-b82007a30c8d", 0xbc5d0b60, 0xdf6a, 0x4e16, 0x98, 0x03, 0xb8, 0x20, 0x07, 0xa3, 0x0c, 0x8d )
DEFINE_CODECAPI_GUID( AVEncAudioMapDestChannel1,    "bc5d0b61-df6a-4e16-9803-b82007a30c8d", 0xbc5d0b61, 0xdf6a, 0x4e16, 0x98, 0x03, 0xb8, 0x20, 0x07, 0xa3, 0x0c, 0x8d )
DEFINE_CODECAPI_GUID( AVEncAudioMapDestChannel2,    "bc5d0b62-df6a-4e16-9803-b82007a30c8d", 0xbc5d0b62, 0xdf6a, 0x4e16, 0x98, 0x03, 0xb8, 0x20, 0x07, 0xa3, 0x0c, 0x8d )
DEFINE_CODECAPI_GUID( AVEncAudioMapDestChannel3,    "bc5d0b63-df6a-4e16-9803-b82007a30c8d", 0xbc5d0b63, 0xdf6a, 0x4e16, 0x98, 0x03, 0xb8, 0x20, 0x07, 0xa3, 0x0c, 0x8d )
DEFINE_CODECAPI_GUID( AVEncAudioMapDestChannel4,    "bc5d0b64-df6a-4e16-9803-b82007a30c8d", 0xbc5d0b64, 0xdf6a, 0x4e16, 0x98, 0x03, 0xb8, 0x20, 0x07, 0xa3, 0x0c, 0x8d )
DEFINE_CODECAPI_GUID( AVEncAudioMapDestChannel5,    "bc5d0b65-df6a-4e16-9803-b82007a30c8d", 0xbc5d0b65, 0xdf6a, 0x4e16, 0x98, 0x03, 0xb8, 0x20, 0x07, 0xa3, 0x0c, 0x8d )
DEFINE_CODECAPI_GUID( AVEncAudioMapDestChannel6,    "bc5d0b66-df6a-4e16-9803-b82007a30c8d", 0xbc5d0b66, 0xdf6a, 0x4e16, 0x98, 0x03, 0xb8, 0x20, 0x07, 0xa3, 0x0c, 0x8d )
DEFINE_CODECAPI_GUID( AVEncAudioMapDestChannel7,    "bc5d0b67-df6a-4e16-9803-b82007a30c8d", 0xbc5d0b67, 0xdf6a, 0x4e16, 0x98, 0x03, 0xb8, 0x20, 0x07, 0xa3, 0x0c, 0x8d )
DEFINE_CODECAPI_GUID( AVEncAudioMapDestChannel8,    "bc5d0b68-df6a-4e16-9803-b82007a30c8d", 0xbc5d0b68, 0xdf6a, 0x4e16, 0x98, 0x03, 0xb8, 0x20, 0x07, 0xa3, 0x0c, 0x8d )
DEFINE_CODECAPI_GUID( AVEncAudioMapDestChannel9,    "bc5d0b69-df6a-4e16-9803-b82007a30c8d", 0xbc5d0b69, 0xdf6a, 0x4e16, 0x98, 0x03, 0xb8, 0x20, 0x07, 0xa3, 0x0c, 0x8d )
DEFINE_CODECAPI_GUID( AVEncAudioMapDestChannel10,   "bc5d0b6a-df6a-4e16-9803-b82007a30c8d", 0xbc5d0b6a, 0xdf6a, 0x4e16, 0x98, 0x03, 0xb8, 0x20, 0x07, 0xa3, 0x0c, 0x8d )
DEFINE_CODECAPI_GUID( AVEncAudioMapDestChannel11,   "bc5d0b6b-df6a-4e16-9803-b82007a30c8d", 0xbc5d0b6b, 0xdf6a, 0x4e16, 0x98, 0x03, 0xb8, 0x20, 0x07, 0xa3, 0x0c, 0x8d )
DEFINE_CODECAPI_GUID( AVEncAudioMapDestChannel12,   "bc5d0b6c-df6a-4e16-9803-b82007a30c8d", 0xbc5d0b6c, 0xdf6a, 0x4e16, 0x98, 0x03, 0xb8, 0x20, 0x07, 0xa3, 0x0c, 0x8d )
DEFINE_CODECAPI_GUID( AVEncAudioMapDestChannel13,   "bc5d0b6d-df6a-4e16-9803-b82007a30c8d", 0xbc5d0b6d, 0xdf6a, 0x4e16, 0x98, 0x03, 0xb8, 0x20, 0x07, 0xa3, 0x0c, 0x8d )
DEFINE_CODECAPI_GUID( AVEncAudioMapDestChannel14,   "bc5d0b6e-df6a-4e16-9803-b82007a30c8d", 0xbc5d0b6e, 0xdf6a, 0x4e16, 0x98, 0x03, 0xb8, 0x20, 0x07, 0xa3, 0x0c, 0x8d )
DEFINE_CODECAPI_GUID( AVEncAudioMapDestChannel15,   "bc5d0b6f-df6a-4e16-9803-b82007a30c8d", 0xbc5d0b6f, 0xdf6a, 0x4e16, 0x98, 0x03, 0xb8, 0x20, 0x07, 0xa3, 0x0c, 0x8d )

// AVEncAudioInputContent (UINT32) <---- You have ENUM in the doc
DEFINE_CODECAPI_GUID( AVEncAudioInputContent,       "3e226c2b-60b9-4a39-b00b-a7b40f70d566", 0x3e226c2b, 0x60b9, 0x4a39, 0xb0, 0x0b, 0xa7, 0xb4, 0x0f, 0x70, 0xd5, 0x66 )

enum eAVEncAudioInputContent
{
    AVEncAudioInputContent_Unknown =0,
    AVEncAudioInputContent_Voice = 1,
    AVEncAudioInputContent_Music = 2
};

//
// Common Post-Encode Audio Statistical Parameters
//

// AVEncStatAudioPeakPCMValue (UINT32)
DEFINE_CODECAPI_GUID( AVEncStatAudioPeakPCMValue,   "dce7fd34-dc00-4c16-821b-35d9eb00fb1a", 0xdce7fd34, 0xdc00, 0x4c16, 0x82, 0x1b, 0x35, 0xd9, 0xeb, 0x00, 0xfb, 0x1a )

// AVEncStatAudioAveragePCMValue (UINT32)
DEFINE_CODECAPI_GUID( AVEncStatAudioAveragePCMValue, "979272f8-d17f-4e32-bb73-4e731c68ba2d", 0x979272f8, 0xd17f, 0x4e32, 0xbb, 0x73, 0x4e, 0x73, 0x1c, 0x68, 0xba, 0x2d )

// AVEncStatAudioAverageBPS (UINT32)
DEFINE_CODECAPI_GUID( AVEncStatAudioAverageBPS, "ca6724db-7059-4351-8b43-f82198826a14", 0xca6724db, 0x7059, 0x4351, 0x8b, 0x43, 0xf8, 0x21, 0x98, 0x82, 0x6a, 0x14 )

//
// MPEG Video Encoding Interface
//

//
// MPV Encoder Specific Parameters
//

// AVEncMPVGOPSize (UINT32)
DEFINE_CODECAPI_GUID( AVEncMPVGOPSize,          "95f31b26-95a4-41aa-9303-246a7fc6eef1", 0x95f31b26, 0x95a4, 0x41aa, 0x93, 0x03, 0x24, 0x6a, 0x7f, 0xc6, 0xee, 0xf1 )

// AVEncMPVGOPOpen (BOOL)
DEFINE_CODECAPI_GUID( AVEncMPVGOPOpen,          "b1d5d4a6-3300-49b1-ae61-a09937ab0e49", 0xb1d5d4a6, 0x3300, 0x49b1, 0xae, 0x61, 0xa0, 0x99, 0x37, 0xab, 0x0e, 0x49 )

// AVEncMPVDefaultBPictureCount (UINT32)
DEFINE_CODECAPI_GUID( AVEncMPVDefaultBPictureCount, "8d390aac-dc5c-4200-b57f-814d04babab2", 0x8d390aac, 0xdc5c, 0x4200, 0xb5, 0x7f, 0x81, 0x4d, 0x04, 0xba, 0xba, 0xb2 )

// AVEncMPVProfile (UINT32) <---- You have GUID in the doc
DEFINE_CODECAPI_GUID( AVEncMPVProfile,          "dabb534a-1d99-4284-975a-d90e2239baa1", 0xdabb534a, 0x1d99, 0x4284, 0x97, 0x5a, 0xd9, 0x0e, 0x22, 0x39, 0xba, 0xa1 )

enum eAVEncMPVProfile
{
    eAVEncMPVProfile_unknown = 0,
    eAVEncMPVProfile_Simple = 1,
    eAVEncMPVProfile_Main   = 2,
    eAVEncMPVProfile_High   = 3,
    eAVEncMPVProfile_422    = 4
};

// AVEncMPVLevel (UINT32) <---- You have GUID in the doc
DEFINE_CODECAPI_GUID( AVEncMPVLevel,            "6ee40c40-a60c-41ef-8f50-37c2249e2cb3", 0x6ee40c40, 0xa60c, 0x41ef, 0x8f, 0x50, 0x37, 0xc2, 0x24, 0x9e, 0x2c, 0xb3 )

enum eAVEncMPVLevel
{
    eAVEncMPVLevel_Low      = 1,
    eAVEncMPVLevel_Main     = 2,
    eAVEncMPVLevel_High1440 = 3,
    eAVEncMPVLevel_High     = 4
};

// AVEncMPVFrameFieldMode (UINT32)
DEFINE_CODECAPI_GUID( AVEncMPVFrameFieldMode,   "acb5de96-7b93-4c2f-8825-b0295fa93bf4", 0xacb5de96, 0x7b93, 0x4c2f, 0x88, 0x25, 0xb0, 0x29, 0x5f, 0xa9, 0x3b, 0xf4 )

enum eAVEncMPVFrameFieldMode
{
    eAVEncMPVFrameFieldMode_FieldMode = 0,
    eAVEncMPVFrameFieldMode_FrameMode = 1
};

//
// Advanced MPV Encoder Specific Parameters
//

// AVEncMPVAddSeqEndCode (BOOL)
DEFINE_CODECAPI_GUID( AVEncMPVAddSeqEndCode,    "a823178f-57df-4c7a-b8fd-e5ec8887708d", 0xa823178f, 0x57df, 0x4c7a, 0xb8, 0xfd, 0xe5, 0xec, 0x88, 0x87, 0x70, 0x8d )

// AVEncMPVGOPSInSeq (UINT32)
DEFINE_CODECAPI_GUID( AVEncMPVGOPSInSeq,        "993410d4-2691-4192-9978-98dc2603669f", 0x993410d4, 0x2691, 0x4192, 0x99, 0x78, 0x98, 0xdc, 0x26, 0x03, 0x66, 0x9f )

// AVEncMPVUseConcealmentMotionVectors (BOOL)
DEFINE_CODECAPI_GUID( AVEncMPVUseConcealmentMotionVectors,  "ec770cf3-6908-4b4b-aa30-7fb986214fea", 0xec770cf3, 0x6908, 0x4b4b, 0xaa, 0x30, 0x7f, 0xb9, 0x86, 0x21, 0x4f, 0xea )

// AVEncMPVSceneDetection (UINT32)
DEFINE_CODECAPI_GUID( AVEncMPVSceneDetection,   "552799f1-db4c-405b-8a3a-c93f2d0674dc", 0x552799f1, 0xdb4c, 0x405b, 0x8a, 0x3a, 0xc9, 0x3f, 0x2d, 0x06, 0x74, 0xdc )

enum eAVEncMPVSceneDetection
{
    eAVEncMPVSceneDetection_None                 = 0,
    eAVEncMPVSceneDetection_InsertIPicture       = 1,
    eAVEncMPVSceneDetection_StartNewGOP          = 2,
    eAVEncMPVSceneDetection_StartNewLocatableGOP = 3
};

// AVEncMPVGenerateHeaderSeqExt (BOOL)
DEFINE_CODECAPI_GUID( AVEncMPVGenerateHeaderSeqExt, "d5e78611-082d-4e6b-98af-0f51ab139222", 0xd5e78611, 0x082d, 0x4e6b, 0x98, 0xaf, 0x0f, 0x51, 0xab, 0x13, 0x92, 0x22 )

// AVEncMPVGenerateHeaderSeqDispExt (BOOL)
DEFINE_CODECAPI_GUID( AVEncMPVGenerateHeaderSeqDispExt, "6437aa6f-5a3c-4de9-8a16-53d9c4ad326f", 0x6437aa6f, 0x5a3c, 0x4de9, 0x8a, 0x16, 0x53, 0xd9, 0xc4, 0xad, 0x32, 0x6f )

// AVEncMPVGenerateHeaderPicExt (BOOL)
DEFINE_CODECAPI_GUID( AVEncMPVGenerateHeaderPicExt, "1b8464ab-944f-45f0-b74e-3a58dad11f37", 0x1b8464ab, 0x944f, 0x45f0, 0xb7, 0x4e, 0x3a, 0x58, 0xda, 0xd1, 0x1f, 0x37 )

// AVEncMPVGenerateHeaderPicDispExt (BOOL)
DEFINE_CODECAPI_GUID( AVEncMPVGenerateHeaderPicDispExt, "c6412f84-c03f-4f40-a00c-4293df8395bb", 0xc6412f84, 0xc03f, 0x4f40, 0xa0, 0x0c, 0x42, 0x93, 0xdf, 0x83, 0x95, 0xbb )

// AVEncMPVGenerateHeaderSeqScaleExt (BOOL)
DEFINE_CODECAPI_GUID( AVEncMPVGenerateHeaderSeqScaleExt, "0722d62f-dd59-4a86-9cd5-644f8e2653d8", 0x0722d62f, 0xdd59, 0x4a86, 0x9c, 0xd5, 0x64, 0x4f, 0x8e, 0x26, 0x53, 0xd8 )

// AVEncMPVScanPattern (UINT32)
DEFINE_CODECAPI_GUID( AVEncMPVScanPattern,      "7f8a478e-7bbb-4ae2-b2fc-96d17fc4a2d6", 0x7f8a478e, 0x7bbb, 0x4ae2, 0xb2, 0xfc, 0x96, 0xd1, 0x7f, 0xc4, 0xa2, 0xd6 )

enum eAVEncMPVScanPattern
{
    eAVEncMPVScanPattern_Auto          = 0,
    eAVEncMPVScanPattern_ZigZagScan    = 1,
    eAVEncMPVScanPattern_AlternateScan = 2
};

// AVEncMPVIntraDCPrecision (UINT32)
DEFINE_CODECAPI_GUID( AVEncMPVIntraDCPrecision, "a0116151-cbc8-4af3-97dc-d00cceb82d79", 0xa0116151, 0xcbc8, 0x4af3, 0x97, 0xdc, 0xd0, 0x0c, 0xce, 0xb8, 0x2d, 0x79 )

// AVEncMPVQScaleType (UINT32)
DEFINE_CODECAPI_GUID( AVEncMPVQScaleType,       "2b79ebb7-f484-4af7-bb58-a2a188c5cbbe", 0x2b79ebb7, 0xf484, 0x4af7, 0xbb, 0x58, 0xa2, 0xa1, 0x88, 0xc5, 0xcb, 0xbe )

enum eAVEncMPVQScaleType
{
    eAVEncMPVQScaleType_Auto      = 0,
    eAVEncMPVQScaleType_Linear    = 1,
    eAVEncMPVQScaleType_NonLinear = 2
};

// AVEncMPVIntraVLCTable (UINT32)
DEFINE_CODECAPI_GUID( AVEncMPVIntraVLCTable,    "a2b83ff5-1a99-405a-af95-c5997d558d3a", 0xa2b83ff5, 0x1a99, 0x405a, 0xaf, 0x95, 0xc5, 0x99, 0x7d, 0x55, 0x8d, 0x3a )

enum eAVEncMPVIntraVLCTable
{
    eAVEncMPVIntraVLCTable_Auto      = 0,
    eAVEncMPVIntraVLCTable_MPEG1     = 1,
    eAVEncMPVIntraVLCTable_Alternate = 2
};

// AVEncMPVQuantMatrixIntra (BYTE[64] encoded as a string of 128 hex digits)
DEFINE_CODECAPI_GUID( AVEncMPVQuantMatrixIntra, "9bea04f3-6621-442c-8ba1-3ac378979698", 0x9bea04f3, 0x6621, 0x442c, 0x8b, 0xa1, 0x3a, 0xc3, 0x78, 0x97, 0x96, 0x98 )

// AVEncMPVQuantMatrixNonIntra (BYTE[64] encoded as a string of 128 hex digits)
DEFINE_CODECAPI_GUID( AVEncMPVQuantMatrixNonIntra, "87f441d8-0997-4beb-a08e-8573d409cf75", 0x87f441d8, 0x0997, 0x4beb, 0xa0, 0x8e, 0x85, 0x73, 0xd4, 0x09, 0xcf, 0x75 )

// AVEncMPVQuantMatrixChromaIntra (BYTE[64] encoded as a string of 128 hex digits)
DEFINE_CODECAPI_GUID( AVEncMPVQuantMatrixChromaIntra, "9eb9ecd4-018d-4ffd-8f2d-39e49f07b17a", 0x9eb9ecd4, 0x018d, 0x4ffd, 0x8f, 0x2d, 0x39, 0xe4, 0x9f, 0x07, 0xb1, 0x7a )

// AVEncMPVQuantMatrixChromaNonIntra (BYTE[64] encoded as a string of 128 hex digits)
DEFINE_CODECAPI_GUID( AVEncMPVQuantMatrixChromaNonIntra, "1415b6b1-362a-4338-ba9a-1ef58703c05b", 0x1415b6b1, 0x362a, 0x4338, 0xba, 0x9a, 0x1e, 0xf5, 0x87, 0x03, 0xc0, 0x5b )

//
// MPEG1 Audio Encoding Interface
//

//
// MPEG1 Audio Specific Parameters
//

// AVEncMPALayer (UINT)
DEFINE_CODECAPI_GUID( AVEncMPALayer,    "9d377230-f91b-453d-9ce0-78445414c22d", 0x9d377230, 0xf91b, 0x453d, 0x9c, 0xe0, 0x78, 0x44, 0x54, 0x14, 0xc2, 0x2d )

enum eAVEncMPALayer
{
    eAVEncMPALayer_1 = 1,
    eAVEncMPALayer_2 = 2,
    eAVEncMPALayer_3 = 3
};

// AVEncMPACodingMode (UINT)
DEFINE_CODECAPI_GUID( AVEncMPACodingMode,       "b16ade03-4b93-43d7-a550-90b4fe224537", 0xb16ade03, 0x4b93, 0x43d7, 0xa5, 0x50, 0x90, 0xb4, 0xfe, 0x22, 0x45, 0x37 )

enum eAVEncMPACodingMode
{
    eAVEncMPACodingMode_Mono        = 0,
    eAVEncMPACodingMode_Stereo      = 1,
    eAVEncMPACodingMode_DualChannel = 2,
    eAVEncMPACodingMode_JointStereo = 3,
    eAVEncMPACodingMode_Surround    = 4
};

// AVEncMPACopyright (BOOL) - default state to encode into the stream (may be overridden by input)
// 1 (true)  - copyright protected
// 0 (false) - not copyright protected 
DEFINE_CODECAPI_GUID( AVEncMPACopyright,         "a6ae762a-d0a9-4454-b8ef-f2dbeefdd3bd", 0xa6ae762a, 0xd0a9, 0x4454, 0xb8, 0xef, 0xf2, 0xdb, 0xee, 0xfd, 0xd3, 0xbd )

// AVEncMPAOriginalBitstream (BOOL) - default value to encode into the stream (may be overridden by input)
// 1 (true)  - for original bitstream
// 0 (false) - for copy bitstream 
DEFINE_CODECAPI_GUID( AVEncMPAOriginalBitstream, "3cfb7855-9cc9-47ff-b829-b36786c92346", 0x3cfb7855, 0x9cc9, 0x47ff, 0xb8, 0x29, 0xb3, 0x67, 0x86, 0xc9, 0x23, 0x46 )

// AVEncMPAEnableRedundancyProtection (BOOL) 
// 1 (true)  -  Redundancy should be added to facilitate error detection and concealment (CRC)
// 0 (false) -  No redundancy should be added
DEFINE_CODECAPI_GUID( AVEncMPAEnableRedundancyProtection,     "5e54b09e-b2e7-4973-a89b-0b3650a3beda", 0x5e54b09e, 0xb2e7, 0x4973, 0xa8, 0x9b, 0x0b, 0x36, 0x50, 0xa3, 0xbe, 0xda )

// AVEncMPAPrivateUserBit (UINT) - User data bit value to encode in the stream
DEFINE_CODECAPI_GUID( AVEncMPAPrivateUserBit,      "afa505ce-c1e3-4e3d-851b-61b700e5e6cc", 0xafa505ce, 0xc1e3, 0x4e3d, 0x85, 0x1b, 0x61, 0xb7, 0x00, 0xe5, 0xe6, 0xcc )

// AVEncMPAEmphasisType (UINT)
// Indicates type of de-emphasis filter to be used
DEFINE_CODECAPI_GUID( AVEncMPAEmphasisType,         "2d59fcda-bf4e-4ed6-b5df-5b03b36b0a1f", 0x2d59fcda, 0xbf4e, 0x4ed6, 0xb5, 0xdf, 0x5b, 0x03, 0xb3, 0x6b, 0x0a, 0x1f )

enum eAVEncMPAEmphasisType
{
    eAVEncMPAEmphasisType_None        = 0,
    eAVEncMPAEmphasisType_50_15       = 1,
    eAVEncMPAEmphasisType_Reserved    = 2,
    eAVEncMPAEmphasisType_CCITT_J17   = 3,
};

//
// Dolby Digital(TM) Audio Encoding Interface
//

//
// Dolby Digital(TM) Audio Specific Parameters
//

// AVEncDDService (UINT)
DEFINE_CODECAPI_GUID( AVEncDDService,           "d2e1bec7-5172-4d2a-a50e-2f3b82b1ddf8", 0xd2e1bec7, 0x5172, 0x4d2a, 0xa5, 0x0e, 0x2f, 0x3b, 0x82, 0xb1, 0xdd, 0xf8 )

enum eAVEncDDService
{
    eAVEncDDService_CM = 0,  // (Main Service: Complete Main)
    eAVEncDDService_ME = 1,  // (Main Service: Music and Effects (ME))
    eAVEncDDService_VI = 2,  // (Associated Service: Visually-Impaired (VI)
    eAVEncDDService_HI = 3,  // (Associated Service: Hearing-Impaired (HI))
    eAVEncDDService_D  = 4,  // (Associated Service: Dialog (D))
    eAVEncDDService_C  = 5,  // (Associated Service: Commentary (C))
    eAVEncDDService_E  = 6,  // (Associated Service: Emergency (E))
    eAVEncDDService_VO = 7   // (Associated Service: Voice Over (VO) / Karaoke)
};

// AVEncDDDialogNormalization (UINT32)
DEFINE_CODECAPI_GUID( AVEncDDDialogNormalization, "d7055acf-f125-437d-a704-79c79f0404a8", 0xd7055acf, 0xf125, 0x437d, 0xa7, 0x04, 0x79, 0xc7, 0x9f, 0x04, 0x04, 0xa8 )

// AVEncDDCentreDownMixLevel (UINT32)
DEFINE_CODECAPI_GUID( AVEncDDCentreDownMixLevel, "e285072c-c958-4a81-afd2-e5e0daf1b148", 0xe285072c, 0xc958, 0x4a81, 0xaf, 0xd2, 0xe5, 0xe0, 0xda, 0xf1, 0xb1, 0x48 )

// AVEncDDSurroundDownMixLevel (UINT32)
DEFINE_CODECAPI_GUID( AVEncDDSurroundDownMixLevel, "7b20d6e5-0bcf-4273-a487-506b047997e9", 0x7b20d6e5, 0x0bcf, 0x4273, 0xa4, 0x87, 0x50, 0x6b, 0x04, 0x79, 0x97, 0xe9 )

// AVEncDDProductionInfoExists (BOOL)
DEFINE_CODECAPI_GUID( AVEncDDProductionInfoExists, "b0b7fe5f-b6ab-4f40-964d-8d91f17c19e8", 0xb0b7fe5f, 0xb6ab, 0x4f40, 0x96, 0x4d, 0x8d, 0x91, 0xf1, 0x7c, 0x19, 0xe8 )

// AVEncDDProductionRoomType (UINT32)
DEFINE_CODECAPI_GUID( AVEncDDProductionRoomType, "dad7ad60-23d8-4ab7-a284-556986d8a6fe", 0xdad7ad60, 0x23d8, 0x4ab7, 0xa2, 0x84, 0x55, 0x69, 0x86, 0xd8, 0xa6, 0xfe )

enum eAVEncDDProductionRoomType
{
    eAVEncDDProductionRoomType_NotIndicated = 0,
    eAVEncDDProductionRoomType_Large        = 1,
    eAVEncDDProductionRoomType_Small        = 2
};

// AVEncDDProductionMixLevel (UINT32)
DEFINE_CODECAPI_GUID( AVEncDDProductionMixLevel, "301d103a-cbf9-4776-8899-7c15b461ab26", 0x301d103a, 0xcbf9, 0x4776, 0x88, 0x99, 0x7c, 0x15, 0xb4, 0x61, 0xab, 0x26 )

// AVEncDDCopyright (BOOL)
DEFINE_CODECAPI_GUID( AVEncDDCopyright,         "8694f076-cd75-481d-a5c6-a904dcc828f0", 0x8694f076, 0xcd75, 0x481d, 0xa5, 0xc6, 0xa9, 0x04, 0xdc, 0xc8, 0x28, 0xf0 )

// AVEncDDOriginalBitstream (BOOL)
DEFINE_CODECAPI_GUID( AVEncDDOriginalBitstream, "966ae800-5bd3-4ff9-95b9-d30566273856", 0x966ae800, 0x5bd3, 0x4ff9, 0x95, 0xb9, 0xd3, 0x05, 0x66, 0x27, 0x38, 0x56 )

// AVEncDDDigitalDeemphasis (BOOL)
DEFINE_CODECAPI_GUID( AVEncDDDigitalDeemphasis, "e024a2c2-947c-45ac-87d8-f1030c5c0082", 0xe024a2c2, 0x947c, 0x45ac, 0x87, 0xd8, 0xf1, 0x03, 0x0c, 0x5c, 0x00, 0x82 )

// AVEncDDDCHighPassFilter (BOOL)
DEFINE_CODECAPI_GUID( AVEncDDDCHighPassFilter,  "9565239f-861c-4ac8-bfda-e00cb4db8548", 0x9565239f, 0x861c, 0x4ac8, 0xbf, 0xda, 0xe0, 0x0c, 0xb4, 0xdb, 0x85, 0x48 )

// AVEncDDChannelBWLowPassFilter (BOOL)
DEFINE_CODECAPI_GUID( AVEncDDChannelBWLowPassFilter, "e197821d-d2e7-43e2-ad2c-00582f518545", 0xe197821d, 0xd2e7, 0x43e2, 0xad, 0x2c, 0x00, 0x58, 0x2f, 0x51, 0x85, 0x45 )

// AVEncDDLFELowPassFilter (BOOL)
DEFINE_CODECAPI_GUID( AVEncDDLFELowPassFilter,  "d3b80f6f-9d15-45e5-91be-019c3fab1f01", 0xd3b80f6f, 0x9d15, 0x45e5, 0x91, 0xbe, 0x01, 0x9c, 0x3f, 0xab, 0x1f, 0x01 )

// AVEncDDSurround90DegreeePhaseShift (BOOL)
DEFINE_CODECAPI_GUID( AVEncDDSurround90DegreeePhaseShift, "25ecec9d-3553-42c0-bb56-d25792104f80", 0x25ecec9d, 0x3553, 0x42c0, 0xbb, 0x56, 0xd2, 0x57, 0x92, 0x10, 0x4f, 0x80 )

// AVEncDDSurround3dBAttenuation (BOOL)
DEFINE_CODECAPI_GUID( AVEncDDSurround3dBAttenuation, "4d43b99d-31e2-48b9-bf2e-5cbf1a572784", 0x4d43b99d, 0x31e2, 0x48b9, 0xbf, 0x2e, 0x5c, 0xbf, 0x1a, 0x57, 0x27, 0x84 )

// AVEncDDDynamicRangeCompressionControl (UINT32)
DEFINE_CODECAPI_GUID( AVEncDDDynamicRangeCompressionControl, "cfc2ff6d-79b8-4b8d-a8aa-a0c9bd1c2940", 0xcfc2ff6d, 0x79b8, 0x4b8d, 0xa8, 0xaa, 0xa0, 0xc9, 0xbd, 0x1c, 0x29, 0x40 )

enum eAVEncDDDynamicRangeCompressionControl
{
    eAVEncDDDynamicRangeCompressionControl_None          = 0,
    eAVEncDDDynamicRangeCompressionControl_FilmStandard  = 1,
    eAVEncDDDynamicRangeCompressionControl_FilmLight     = 2,
    eAVEncDDDynamicRangeCompressionControl_MusicStandard = 3,
    eAVEncDDDynamicRangeCompressionControl_MusicLight    = 4,
    eAVEncDDDynamicRangeCompressionControl_Speech        = 5
};

// AVEncDDRFPreEmphasisFilter (BOOL)
DEFINE_CODECAPI_GUID( AVEncDDRFPreEmphasisFilter, "21af44c0-244e-4f3d-a2cc-3d3068b2e73f", 0x21af44c0, 0x244e, 0x4f3d, 0xa2, 0xcc, 0x3d, 0x30, 0x68, 0xb2, 0xe7, 0x3f )

// AVEncDDSurroundExMode (UINT32)
DEFINE_CODECAPI_GUID( AVEncDDSurroundExMode,    "91607cee-dbdd-4eb6-bca2-aadfafa3dd68", 0x91607cee, 0xdbdd, 0x4eb6, 0xbc, 0xa2, 0xaa, 0xdf, 0xaf, 0xa3, 0xdd, 0x68 )

enum eAVEncDDSurroundExMode
{
    eAVEncDDSurroundExMode_NotIndicated = 0,
    eAVEncDDSurroundExMode_No           = 1,
    eAVEncDDSurroundExMode_Yes          = 2
};

// AVEncDDPreferredStereoDownMixMode (UINT32)
DEFINE_CODECAPI_GUID( AVEncDDPreferredStereoDownMixMode,    "7f4e6b31-9185-403d-b0a2-763743e6f063", 0x7f4e6b31, 0x9185, 0x403d, 0xb0, 0xa2, 0x76, 0x37, 0x43, 0xe6, 0xf0, 0x63 )

enum eAVEncDDPreferredStereoDownMixMode
{
    eAVEncDDPreferredStereoDownMixMode_LtRt = 0,
    eAVEncDDPreferredStereoDownMixMode_LoRo = 1
};

// AVEncDDLtRtCenterMixLvl_x10 (INT32)
DEFINE_CODECAPI_GUID( AVEncDDLtRtCenterMixLvl_x10, "dca128a2-491f-4600-b2da-76e3344b4197", 0xdca128a2, 0x491f, 0x4600, 0xb2, 0xda, 0x76, 0xe3, 0x34, 0x4b, 0x41, 0x97 )

// AVEncDDLtRtSurroundMixLvl_x10 (INT32)
DEFINE_CODECAPI_GUID( AVEncDDLtRtSurroundMixLvl_x10, "212246c7-3d2c-4dfa-bc21-652a9098690d", 0x212246c7, 0x3d2c, 0x4dfa, 0xbc, 0x21, 0x65, 0x2a, 0x90, 0x98, 0x69, 0x0d )

// AVEncDDLoRoCenterMixLvl (INT32)
DEFINE_CODECAPI_GUID( AVEncDDLoRoCenterMixLvl_x10, "1cfba222-25b3-4bf4-9bfd-e7111267858c", 0x1cfba222, 0x25b3, 0x4bf4, 0x9b, 0xfd, 0xe7, 0x11, 0x12, 0x67, 0x85, 0x8c )

// AVEncDDLoRoSurroundMixLvl_x10 (INT32)
DEFINE_CODECAPI_GUID( AVEncDDLoRoSurroundMixLvl_x10, "e725cff6-eb56-40c7-8450-2b9367e91555", 0xe725cff6, 0xeb56, 0x40c7, 0x84, 0x50, 0x2b, 0x93, 0x67, 0xe9, 0x15, 0x55 )

// AVEncDDAtoDConverterType (UINT32)
DEFINE_CODECAPI_GUID( AVEncDDAtoDConverterType, "719f9612-81a1-47e0-9a05-d94ad5fca948", 0x719f9612, 0x81a1, 0x47e0, 0x9a, 0x05, 0xd9, 0x4a, 0xd5, 0xfc, 0xa9, 0x48 )

enum eAVEncDDAtoDConverterType
{
    eAVEncDDAtoDConverterType_Standard = 0,
    eAVEncDDAtoDConverterType_HDCD     = 1
};

// AVEncDDHeadphoneMode (UINT32)
DEFINE_CODECAPI_GUID( AVEncDDHeadphoneMode, "4052dbec-52f5-42f5-9b00-d134b1341b9d", 0x4052dbec, 0x52f5, 0x42f5, 0x9b, 0x00, 0xd1, 0x34, 0xb1, 0x34, 0x1b, 0x9d )

enum eAVEncDDHeadphoneMode
{
    eAVEncDDHeadphoneMode_NotIndicated = 0,
    eAVEncDDHeadphoneMode_NotEncoded   = 1,
    eAVEncDDHeadphoneMode_Encoded      = 2
};

//
// WMV Video Encoding Interface
//

//
// WMV Video Specific Parameters
//

// AVEncWMVKeyFrameDistance (UINT32)
DEFINE_CODECAPI_GUID( AVEncWMVKeyFrameDistance, "5569055e-e268-4771-b83e-9555ea28aed3", 0x5569055e, 0xe268, 0x4771, 0xb8, 0x3e, 0x95, 0x55, 0xea, 0x28, 0xae, 0xd3 )

// AVEncWMVInterlacedEncoding (UINT32)
DEFINE_CODECAPI_GUID( AVEncWMVInterlacedEncoding, "e3d00f8a-c6f5-4e14-a588-0ec87a726f9b", 0xe3d00f8a, 0xc6f5, 0x4e14, 0xa5, 0x88, 0x0e, 0xc8, 0x7a, 0x72, 0x6f, 0x9b )

// AVEncWMVDecoderComplexity (UINT32)
DEFINE_CODECAPI_GUID( AVEncWMVDecoderComplexity, "f32c0dab-f3cb-4217-b79f-8762768b5f67", 0xf32c0dab, 0xf3cb, 0x4217, 0xb7, 0x9f, 0x87, 0x62, 0x76, 0x8b, 0x5f, 0x67 )

// AVEncWMVHasKeyFrameBufferLevelMarker (BOOL)
DEFINE_CODECAPI_GUID( AVEncWMVKeyFrameBufferLevelMarker, "51ff1115-33ac-426c-a1b1-09321bdf96b4", 0x51ff1115, 0x33ac, 0x426c, 0xa1, 0xb1, 0x09, 0x32, 0x1b, 0xdf, 0x96, 0xb4 )

// AVEncWMVProduceDummyFrames (UINT32)
DEFINE_CODECAPI_GUID( AVEncWMVProduceDummyFrames, "d669d001-183c-42e3-a3ca-2f4586d2396c", 0xd669d001, 0x183c, 0x42e3, 0xa3, 0xca, 0x2f, 0x45, 0x86, 0xd2, 0x39, 0x6c )

//
// WMV Post-Encode Statistical Parameters
//

// AVEncStatWMVCBAvg (UINT32/UINT32)
DEFINE_CODECAPI_GUID( AVEncStatWMVCBAvg,        "6aa6229f-d602-4b9d-b68c-c1ad78884bef", 0x6aa6229f, 0xd602, 0x4b9d, 0xb6, 0x8c, 0xc1, 0xad, 0x78, 0x88, 0x4b, 0xef )

// AVEncStatWMVCBMax (UINT32/UINT32)
DEFINE_CODECAPI_GUID( AVEncStatWMVCBMax,        "e976bef8-00fe-44b4-b625-8f238bc03499", 0xe976bef8, 0x00fe, 0x44b4, 0xb6, 0x25, 0x8f, 0x23, 0x8b, 0xc0, 0x34, 0x99 )

// AVEncStatWMVDecoderComplexityProfile (UINT32)
DEFINE_CODECAPI_GUID( AVEncStatWMVDecoderComplexityProfile, "89e69fc3-0f9b-436c-974a-df821227c90d", 0x89e69fc3, 0x0f9b, 0x436c, 0x97, 0x4a, 0xdf, 0x82, 0x12, 0x27, 0xc9, 0x0d )

// AVEncStatMPVSkippedEmptyFrames (UINT32)
DEFINE_CODECAPI_GUID( AVEncStatMPVSkippedEmptyFrames, "32195fd3-590d-4812-a7ed-6d639a1f9711", 0x32195fd3, 0x590d, 0x4812, 0xa7, 0xed, 0x6d, 0x63, 0x9a, 0x1f, 0x97, 0x11 )

//
// MPEG1/2 Multiplexer Interfaces
//

//
// MPEG1/2 Packetizer Interface
//

// Shared with Mux:
// AVEncMP12MuxEarliestPTS (UINT32)
// AVEncMP12MuxLargestPacketSize (UINT32)
// AVEncMP12MuxSysSTDBufferBound (UINT32)

// AVEncMP12PktzSTDBuffer (UINT32)
DEFINE_CODECAPI_GUID( AVEncMP12PktzSTDBuffer,   "0b751bd0-819e-478c-9435-75208926b377", 0x0b751bd0, 0x819e, 0x478c, 0x94, 0x35, 0x75, 0x20, 0x89, 0x26, 0xb3, 0x77 )

// AVEncMP12PktzStreamID (UINT32)
DEFINE_CODECAPI_GUID( AVEncMP12PktzStreamID,    "c834d038-f5e8-4408-9b60-88f36493fedf", 0xc834d038, 0xf5e8, 0x4408, 0x9b, 0x60, 0x88, 0xf3, 0x64, 0x93, 0xfe, 0xdf )

// AVEncMP12PktzInitialPTS (UINT32)
DEFINE_CODECAPI_GUID( AVEncMP12PktzInitialPTS,  "2a4f2065-9a63-4d20-ae22-0a1bc896a315", 0x2a4f2065, 0x9a63, 0x4d20, 0xae, 0x22, 0x0a, 0x1b, 0xc8, 0x96, 0xa3, 0x15 )

// AVEncMP12PktzPacketSize (UINT32)
DEFINE_CODECAPI_GUID( AVEncMP12PktzPacketSize,  "ab71347a-1332-4dde-a0e5-ccf7da8a0f22", 0xab71347a, 0x1332, 0x4dde, 0xa0, 0xe5, 0xcc, 0xf7, 0xda, 0x8a, 0x0f, 0x22 )

// AVEncMP12PktzCopyright (BOOL)
DEFINE_CODECAPI_GUID( AVEncMP12PktzCopyright,   "c8f4b0c1-094c-43c7-8e68-a595405a6ef8", 0xc8f4b0c1, 0x094c, 0x43c7, 0x8e, 0x68, 0xa5, 0x95, 0x40, 0x5a, 0x6e, 0xf8 )

// AVEncMP12PktzOriginal (BOOL)
DEFINE_CODECAPI_GUID( AVEncMP12PktzOriginal,    "6b178416-31b9-4964-94cb-6bff866cdf83", 0x6b178416, 0x31b9, 0x4964, 0x94, 0xcb, 0x6b, 0xff, 0x86, 0x6c, 0xdf, 0x83 )

//
// MPEG1/2 Multiplexer Interface
//

// AVEncMP12MuxPacketOverhead (UINT32)
DEFINE_CODECAPI_GUID( AVEncMP12MuxPacketOverhead, "e40bd720-3955-4453-acf9-b79132a38fa0", 0xe40bd720, 0x3955, 0x4453, 0xac, 0xf9, 0xb7, 0x91, 0x32, 0xa3, 0x8f, 0xa0 )

// AVEncMP12MuxNumStreams (UINT32)
DEFINE_CODECAPI_GUID( AVEncMP12MuxNumStreams,   "f7164a41-dced-4659-a8f2-fb693f2a4cd0", 0xf7164a41, 0xdced, 0x4659, 0xa8, 0xf2, 0xfb, 0x69, 0x3f, 0x2a, 0x4c, 0xd0 )

// AVEncMP12MuxEarliestPTS (UINT32)
DEFINE_CODECAPI_GUID( AVEncMP12MuxEarliestPTS,  "157232b6-f809-474e-9464-a7f93014a817", 0x157232b6, 0xf809, 0x474e, 0x94, 0x64, 0xa7, 0xf9, 0x30, 0x14, 0xa8, 0x17 )

// AVEncMP12MuxLargestPacketSize (UINT32)
DEFINE_CODECAPI_GUID( AVEncMP12MuxLargestPacketSize, "35ceb711-f461-4b92-a4ef-17b6841ed254", 0x35ceb711, 0xf461, 0x4b92, 0xa4, 0xef, 0x17, 0xb6, 0x84, 0x1e, 0xd2, 0x54 )

// AVEncMP12MuxInitialSCR (UINT32)
DEFINE_CODECAPI_GUID( AVEncMP12MuxInitialSCR,   "3433ad21-1b91-4a0b-b190-2b77063b63a4", 0x3433ad21, 0x1b91, 0x4a0b, 0xb1, 0x90, 0x2b, 0x77, 0x06, 0x3b, 0x63, 0xa4 )

// AVEncMP12MuxMuxRate (UINT32)
DEFINE_CODECAPI_GUID( AVEncMP12MuxMuxRate,      "ee047c72-4bdb-4a9d-8e21-41926c823da7", 0xee047c72, 0x4bdb, 0x4a9d, 0x8e, 0x21, 0x41, 0x92, 0x6c, 0x82, 0x3d, 0xa7 )

// AVEncMP12MuxPackSize (UINT32)
DEFINE_CODECAPI_GUID( AVEncMP12MuxPackSize,     "f916053a-1ce8-4faf-aa0b-ba31c80034b8", 0xf916053a, 0x1ce8, 0x4faf, 0xaa, 0x0b, 0xba, 0x31, 0xc8, 0x00, 0x34, 0xb8 )

// AVEncMP12MuxSysSTDBufferBound (UINT32)
DEFINE_CODECAPI_GUID( AVEncMP12MuxSysSTDBufferBound, "35746903-b545-43e7-bb35-c5e0a7d5093c", 0x35746903, 0xb545, 0x43e7, 0xbb, 0x35, 0xc5, 0xe0, 0xa7, 0xd5, 0x09, 0x3c )

// AVEncMP12MuxSysRateBound (UINT32)
DEFINE_CODECAPI_GUID( AVEncMP12MuxSysRateBound, "05f0428a-ee30-489d-ae28-205c72446710", 0x05f0428a, 0xee30, 0x489d, 0xae, 0x28, 0x20, 0x5c, 0x72, 0x44, 0x67, 0x10 )

// AVEncMP12MuxTargetPacketizer (UINT32)
DEFINE_CODECAPI_GUID( AVEncMP12MuxTargetPacketizer, "d862212a-2015-45dd-9a32-1b3aa88205a0", 0xd862212a, 0x2015, 0x45dd, 0x9a, 0x32, 0x1b, 0x3a, 0xa8, 0x82, 0x05, 0xa0 )

// AVEncMP12MuxSysFixed (UINT32)
DEFINE_CODECAPI_GUID( AVEncMP12MuxSysFixed,     "cefb987e-894f-452e-8f89-a4ef8cec063a", 0xcefb987e, 0x894f, 0x452e, 0x8f, 0x89, 0xa4, 0xef, 0x8c, 0xec, 0x06, 0x3a )

// AVEncMP12MuxSysCSPS (UINT32)
DEFINE_CODECAPI_GUID( AVEncMP12MuxSysCSPS,      "7952ff45-9c0d-4822-bc82-8ad772e02993", 0x7952ff45, 0x9c0d, 0x4822, 0xbc, 0x82, 0x8a, 0xd7, 0x72, 0xe0, 0x29, 0x93 )

// AVEncMP12MuxSysVideoLock (BOOL)
DEFINE_CODECAPI_GUID( AVEncMP12MuxSysVideoLock, "b8296408-2430-4d37-a2a1-95b3e435a91d", 0xb8296408, 0x2430, 0x4d37, 0xa2, 0xa1, 0x95, 0xb3, 0xe4, 0x35, 0xa9, 0x1d )

// AVEncMP12MuxSysAudioLock (BOOL)
DEFINE_CODECAPI_GUID( AVEncMP12MuxSysAudioLock, "0fbb5752-1d43-47bf-bd79-f2293d8ce337", 0x0fbb5752, 0x1d43, 0x47bf, 0xbd, 0x79, 0xf2, 0x29, 0x3d, 0x8c, 0xe3, 0x37 )

// AVEncMP12MuxDVDNavPacks (BOOL)
DEFINE_CODECAPI_GUID( AVEncMP12MuxDVDNavPacks,  "c7607ced-8cf1-4a99-83a1-ee5461be3574", 0xc7607ced, 0x8cf1, 0x4a99, 0x83, 0xa1, 0xee, 0x54, 0x61, 0xbe, 0x35, 0x74 )

//
// Decoding Interface
//


// format values are GUIDs as VARIANT BSTRs 
DEFINE_CODECAPI_GUID( AVDecCommonInputFormat,       "E5005239-BD89-4be3-9C0F-5DDE317988CC", 0xe5005239, 0xbd89, 0x4be3, 0x9c, 0x0f, 0x5d, 0xde, 0x31, 0x79, 0x88, 0xcc)
DEFINE_CODECAPI_GUID( AVDecCommonOutputFormat, "3c790028-c0ce-4256-b1a2-1b0fc8b1dcdc", 0x3c790028, 0xc0ce, 0x4256, 0xb1, 0xa2, 0x1b, 0x0f, 0xc8, 0xb1, 0xdc, 0xdc)

// AVDecCommonMeanBitRate - Mean bitrate in mbits/sec (UINT32)
DEFINE_CODECAPI_GUID( AVDecCommonMeanBitRate,       "59488217-007A-4f7a-8E41-5C48B1EAC5C6", 0x59488217, 0x007a, 0x4f7a, 0x8e, 0x41, 0x5c, 0x48, 0xb1, 0xea, 0xc5, 0xc6)
// AVDecCommonMeanBitRateInterval - Mean bitrate interval (in 100ns) (UINT64)
DEFINE_CODECAPI_GUID( AVDecCommonMeanBitRateInterval,     "0EE437C6-38A7-4c5c-944C-68AB42116B85", 0x0ee437c6, 0x38a7, 0x4c5c, 0x94, 0x4c, 0x68, 0xab, 0x42, 0x11, 0x6b, 0x85)

//
// Audio Decoding Interface
//

// Value GUIDS
// The following 6 GUIDs are values of the AVDecCommonOutputFormat property
//
// Stereo PCM output using matrix-encoded stereo down mix (aka Lt/Rt) 
DEFINE_CODECAPI_GUID( GUID_AVDecAudioOutputFormat_PCM_Stereo_MatrixEncoded,  "696E1D30-548F-4036-825F-7026C60011BD", 0x696e1d30, 0x548f, 0x4036, 0x82, 0x5f, 0x70, 0x26, 0xc6, 0x00, 0x11, 0xbd)
//
// Regular PCM output (any number of channels) 
DEFINE_CODECAPI_GUID( GUID_AVDecAudioOutputFormat_PCM,                       "696E1D31-548F-4036-825F-7026C60011BD", 0x696e1d31, 0x548f, 0x4036, 0x82, 0x5f, 0x70, 0x26, 0xc6, 0x00, 0x11, 0xbd)
//
// SPDIF PCM (IEC 60958) stereo output. Type of stereo down mix should
// be specified by the application.
DEFINE_CODECAPI_GUID( GUID_AVDecAudioOutputFormat_SPDIF_PCM,                 "696E1D32-548F-4036-825F-7026C60011BD", 0x696e1d32, 0x548f, 0x4036, 0x82, 0x5f, 0x70, 0x26, 0xc6, 0x00, 0x11, 0xbd)
//
// SPDIF bitstream (IEC 61937) output, such as AC3, MPEG or DTS.
DEFINE_CODECAPI_GUID( GUID_AVDecAudioOutputFormat_SPDIF_Bitstream,           "696E1D33-548F-4036-825F-7026C60011BD", 0x696e1d33, 0x548f, 0x4036, 0x82, 0x5f, 0x70, 0x26, 0xc6, 0x00, 0x11, 0xbd)
//
// Stereo PCM output using regular stereo down mix (aka Lo/Ro)
DEFINE_CODECAPI_GUID( GUID_AVDecAudioOutputFormat_PCM_Headphones,            "696E1D34-548F-4036-825F-7026C60011BD", 0x696e1d34, 0x548f, 0x4036, 0x82, 0x5f, 0x70, 0x26, 0xc6, 0x00, 0x11, 0xbd)

// Stereo PCM output using automatic selection of stereo down mix 
// mode (Lo/Ro or Lt/Rt). Use this when the input stream includes
// information about the preferred downmix mode (such as Annex D of AC3).
// Default down mix mode should be specified by the application.
DEFINE_CODECAPI_GUID( GUID_AVDecAudioOutputFormat_PCM_Stereo_Auto,           "696E1D35-548F-4036-825F-7026C60011BD", 0x696e1d34, 0x548f, 0x4036, 0x82, 0x5f, 0x70, 0x26, 0xc6, 0x00, 0x11, 0xbd)

//
// Video Decoder properties
//

// AVDecVideoImageSize (UINT32) - High UINT16 width, low UINT16 height
DEFINE_CODECAPI_GUID( AVDecVideoImageSize,          "5EE5747C-6801-4cab-AAF1-6248FA841BA4", 0x5ee5747c, 0x6801, 0x4cab, 0xaa, 0xf1, 0x62, 0x48, 0xfa, 0x84, 0x1b, 0xa4)

// AVDecVideoPixelAspectRatio (UINT32 as UINT16/UNIT16) - High UINT16 width, low UINT16 height
DEFINE_CODECAPI_GUID( AVDecVideoPixelAspectRatio,   "B0CF8245-F32D-41df-B02C-87BD304D12AB", 0xb0cf8245, 0xf32d, 0x41df, 0xb0, 0x2c, 0x87, 0xbd, 0x30, 0x4d, 0x12, 0xab)

// AVDecVideoInputScanType (UINT32)
DEFINE_CODECAPI_GUID( AVDecVideoInputScanType,      "38477E1F-0EA7-42cd-8CD1-130CED57C580", 0x38477e1f, 0x0ea7, 0x42cd, 0x8c, 0xd1, 0x13, 0x0c, 0xed, 0x57, 0xc5, 0x80)
enum eAVDecVideoInputScanType
{
    eAVDecVideoInputScan_Unknown           = 0,
    eAVDecVideoInputScan_Progressive       = 1, 
    eAVDecVideoInputScan_Interlaced_UpperFieldFirst = 2,
    eAVDecVideoInputScan_Interlaced_LowerFieldFirst = 3
};

//
// Audio Decoder properties
//


DEFINE_CODECAPI_GUID( GUID_AVDecAudioInputWMA,          "C95E8DCF-4058-4204-8C42-CB24D91E4B9B", 0xc95e8dcf, 0x4058, 0x4204, 0x8c, 0x42, 0xcb, 0x24, 0xd9, 0x1e, 0x4b, 0x9b)
DEFINE_CODECAPI_GUID( GUID_AVDecAudioInputWMAPro,       "0128B7C7-DA72-4fe3-BEF8-5C52E3557704", 0x0128b7c7, 0xda72, 0x4fe3, 0xbe, 0xf8, 0x5c, 0x52, 0xe3, 0x55, 0x77, 0x04)
DEFINE_CODECAPI_GUID( GUID_AVDecAudioInputDolby,        "8E4228A0-F000-4e0b-8F54-AB8D24AD61A2", 0x8e4228a0, 0xf000, 0x4e0b, 0x8f, 0x54, 0xab, 0x8d, 0x24, 0xad, 0x61, 0xa2)
DEFINE_CODECAPI_GUID( GUID_AVDecAudioInputDTS,          "600BC0CA-6A1F-4e91-B241-1BBEB1CB19E0", 0x600bc0ca, 0x6a1f, 0x4e91, 0xb2, 0x41, 0x1b, 0xbe, 0xb1, 0xcb, 0x19, 0xe0)
DEFINE_CODECAPI_GUID( GUID_AVDecAudioInputPCM,          "F2421DA5-BBB4-4cd5-A996-933C6B5D1347", 0xf2421da5, 0xbbb4, 0x4cd5, 0xa9, 0x96, 0x93, 0x3c, 0x6b, 0x5d, 0x13, 0x47)
DEFINE_CODECAPI_GUID( GUID_AVDecAudioInputMPEG,         "91106F36-02C5-4f75-9719-3B7ABF75E1F6", 0x91106f36, 0x02c5, 0x4f75, 0x97, 0x19, 0x3b, 0x7a, 0xbf, 0x75, 0xe1, 0xf6)

// AVDecAudioDualMono (UINT32) - Read only
// The input bitstream header might have a field indicating whether the 2-ch bitstream
// is dual mono or not. Use this property to read this field.
// If it's dual mono, the application can set AVDecAudioDualMonoReproMode to determine
// one of 4 reproduction modes
DEFINE_CODECAPI_GUID( AVDecAudioDualMono,"4a52cda8-30f8-4216-be0f-ba0b2025921d", 0x4a52cda8, 0x30f8, 0x4216, 0xbe, 0x0f, 0xba, 0x0b, 0x20, 0x25, 0x92, 0x1d )

enum eAVDecAudioDualMono
{
    eAVDecAudioDualMono_IsNotDualMono = 0, // 2-ch bitstream input is not dual mono
    eAVDecAudioDualMono_IsDualMono    = 1, // 2-ch bitstream input is dual mono
    eAVDecAudioDualMono_UnSpecified   = 2  // There is no indication in the bitstream 
}; 

// AVDecAudioDualMonoReproMode (UINT32)
// Reproduction modes for programs containing two independent mono channels (Ch1 & Ch2).
// In case of 2-ch input, the decoder should get AVDecAudioDualMono to check if the input
// is regular stereo or dual mono. If dual mono, the application can ask the user to set the playback
// mode by setting AVDecAudioDualReproMonoMode. If output is not stereo, use AVDecDDMatrixDecodingMode or
// equivalent.
DEFINE_CODECAPI_GUID( AVDecAudioDualMonoReproMode,"a5106186-cc94-4bc9-8cd9-aa2f61f6807e", 0xa5106186, 0xcc94, 0x4bc9, 0x8c, 0xd9, 0xaa, 0x2f, 0x61, 0xf6, 0x80, 0x7e )

enum eAVDecAudioDualMonoReproMode
{
    eAVDecAudioDualMonoReproMode_STEREO      = 0, // Ch1+Ch2 for mono output, (Ch1 left,     Ch2 right) for stereo output
    eAVDecAudioDualMonoReproMode_LEFT_MONO   = 1, // Ch1 for mono output,     (Ch1 left,     Ch1 right) for stereo output
    eAVDecAudioDualMonoReproMode_RIGHT_MONO  = 2, // Ch2 for mono output,     (Ch2 left,     Ch2 right) for stereo output
    eAVDecAudioDualMonoReproMode_MIX_MONO    = 3, // Ch1+Ch2 for mono output, (Ch1+Ch2 left, Ch1+Ch2 right) for stereo output
};

//
// Audio Common Properties
//

// AVAudioChannelCount (UINT32)
// Total number of audio channels, including LFE if it exists.
DEFINE_CODECAPI_GUID( AVAudioChannelCount,          "1d3583c4-1583-474e-b71a-5ee463c198e4", 0x1d3583c4, 0x1583, 0x474e, 0xb7, 0x1a, 0x5e, 0xe4, 0x63, 0xc1, 0x98, 0xe4 )

// AVAudioChannelConfig (UINT32)
// A bit-wise OR of any number of enum values specified by eAVAudioChannelConfig
DEFINE_CODECAPI_GUID( AVAudioChannelConfig,         "17f89cb3-c38d-4368-9ede-63b94d177f9f", 0x17f89cb3, 0xc38d, 0x4368, 0x9e, 0xde, 0x63, 0xb9, 0x4d, 0x17, 0x7f, 0x9f )

// Enumerated values for  AVAudioChannelConfig are identical 
// to the speaker positions defined in ksmedia.h and used 
// in WAVE_FORMAT_EXTENSIBLE. Configurations for 5.1 and
// 7.1 channels should be identical to KSAUDIO_SPEAKER_5POINT1_SURROUND
// and KSAUDIO_SPEAKER_7POINT1_SURROUND in ksmedia.h. This means:
// 5.1 ch -> LOW_FREQUENCY | FRONT_LEFT | FRONT_RIGHT | FRONT_CENTER | SIDE_LEFT | SIDE_RIGHT 
// 7.1 ch -> LOW_FREQUENCY | FRONT_LEFT | FRONT_RIGHT | FRONT_CENTER | SIDE_LEFT | SIDE_RIGHT | BACK_LEFT | BACK_RIGHT
//
enum eAVAudioChannelConfig
{
    eAVAudioChannelConfig_FRONT_LEFT    = 0x1, 
    eAVAudioChannelConfig_FRONT_RIGHT   = 0x2, 
    eAVAudioChannelConfig_FRONT_CENTER  = 0x4, 
    eAVAudioChannelConfig_LOW_FREQUENCY = 0x8,  // aka LFE
    eAVAudioChannelConfig_BACK_LEFT     = 0x10, 
    eAVAudioChannelConfig_BACK_RIGHT    = 0x20, 
    eAVAudioChannelConfig_FRONT_LEFT_OF_CENTER  = 0x40, 
    eAVAudioChannelConfig_FRONT_RIGHT_OF_CENTER = 0x80, 
    eAVAudioChannelConfig_BACK_CENTER = 0x100,  // aka Mono Surround 
    eAVAudioChannelConfig_SIDE_LEFT   = 0x200,  // aka Left Surround
    eAVAudioChannelConfig_SIDE_RIGHT  = 0x400,  // aka Right Surround
    eAVAudioChannelConfig_TOP_CENTER  = 0x800, 
    eAVAudioChannelConfig_TOP_FRONT_LEFT   = 0x1000, 
    eAVAudioChannelConfig_TOP_FRONT_CENTER = 0x2000, 
    eAVAudioChannelConfig_TOP_FRONT_RIGHT  = 0x4000, 
    eAVAudioChannelConfig_TOP_BACK_LEFT    = 0x8000, 
    eAVAudioChannelConfig_TOP_BACK_CENTER  = 0x10000, 
    eAVAudioChannelConfig_TOP_BACK_RIGHT   = 0x20000 
};

// AVAudioSampleRate (UINT32)
// In samples per second (Hz)
DEFINE_CODECAPI_GUID( AVAudioSampleRate,            "971d2723-1acb-42e7-855c-520a4b70a5f2", 0x971d2723, 0x1acb, 0x42e7, 0x85, 0x5c, 0x52, 0x0a, 0x4b, 0x70, 0xa5, 0xf2 )

//
// Dolby Digital(TM) Audio Specific Parameters
//

// AVDDSurroundMode (UINT32) common to encoder/decoder
DEFINE_CODECAPI_GUID( AVDDSurroundMode,            "99f2f386-98d1-4452-a163-abc78a6eb770", 0x99f2f386, 0x98d1, 0x4452, 0xa1, 0x63, 0xab, 0xc7, 0x8a, 0x6e, 0xb7, 0x70 )

enum eAVDDSurroundMode
{
    eAVDDSurroundMode_NotIndicated = 0,
    eAVDDSurroundMode_No           = 1,
    eAVDDSurroundMode_Yes          = 2
};

// AVDecDDOperationalMode (UINT32)
DEFINE_CODECAPI_GUID( AVDecDDOperationalMode,"d6d6c6d1-064e-4fdd-a40e-3ecbfcb7ebd0", 0xd6d6c6d1, 0x064e, 0x4fdd, 0xa4, 0x0e, 0x3e, 0xcb, 0xfc, 0xb7, 0xeb, 0xd0 )

enum eAVDecDDOperationalMode
{
    eAVDecDDOperationalMode_NONE    = 0,
    eAVDecDDOperationalMode_LINE    = 1,// Dialnorm enabled, dialogue at -31dBFS, dynrng used, high/low scaling allowed  
    eAVDecDDOperationalMode_RF      = 2,// Dialnorm enabled, dialogue at -20dBFS, dynrng & compr used, high/low scaling NOT allowed (always fully compressed)
    eAVDecDDOperationalMode_CUSTOM0 = 3,// Analog dialnorm (dialogue normalization not part of the decoder)
    eAVDecDDOperationalMode_CUSTOM1 = 4 // Digital dialnorm (dialogue normalization is part of the decoder)
};

// AVDecDDMatrixDecodingMode(UINT32)
// A ProLogic decoder has a built-in auto-detection feature. When the Dolby Digital decoder 
// is set to the 6-channel output configuration and it is fed a 2/0 bit stream to decode, it can 
// do one of the following: 
// a) decode the bit stream and output it on the two front channels (eAVDecDDMatrixDecodingMode_OFF), 
// b) decode the bit stream followed by ProLogic decoding to create 6-channels (eAVDecDDMatrixDecodingMode_ON). 
// c) the decoder will look at the Surround bit ("dsurmod") in the bit stream to determine whether 
//    apply ProLogic decoding or not (eAVDecDDMatrixDecodingMode_AUTO).
DEFINE_CODECAPI_GUID( AVDecDDMatrixDecodingMode,"ddc811a5-04ed-4bf3-a0ca-d00449f9355f", 0xddc811a5, 0x04ed, 0x4bf3, 0xa0, 0xca, 0xd0, 0x04, 0x49, 0xf9, 0x35, 0x5f )

enum eAVDecDDMatrixDecodingMode
{
    eAVDecDDMatrixDecodingMode_OFF  = 0,  
    eAVDecDDMatrixDecodingMode_ON   = 1,  
    eAVDecDDMatrixDecodingMode_AUTO = 2   
};

// AVDecDDDynamicRangeScaleHigh (UINT32) 
// Indicates what fraction of the dynamic range compression
// to apply. Relevant for negative values of dynrng only.
// Linear range 0-100, where:
//   0 - No dynamic range compression (preserve full dynamic range)
// 100 - Apply full dynamic range compression 
DEFINE_CODECAPI_GUID( AVDecDDDynamicRangeScaleHigh,"50196c21-1f33-4af5-b296-11426d6c8789", 0x50196c21, 0x1f33, 0x4af5, 0xb2, 0x96, 0x11, 0x42, 0x6d, 0x6c, 0x87, 0x89 )


// AVDecDDDynamicRangeScaleLow (UINT32) 
// Indicates what fraction of the dynamic range compression
// to apply. Relevant for positive values of dynrng only.
// Linear range 0-100, where:
//   0 - No dynamic range compression (preserve full dynamic range)
// 100 - Apply full dynamic range compression 
DEFINE_CODECAPI_GUID( AVDecDDDynamicRangeScaleLow,"044e62e4-11a5-42d5-a3b2-3bb2c7c2d7cf", 0x044e62e4, 0x11a5, 0x42d5, 0xa3, 0xb2, 0x3b, 0xb2, 0xc7, 0xc2, 0xd7, 0xcf )


#ifndef UUID_GEN
// { GUID refs
    #define CODECAPI_AVEncCommonFormatConstraint DEFINE_CODECAPI_GUIDNAMED( AVEncCommonFormatConstraint )
    #define CODECAPI_GUID_AVEncCommonFormatUnSpecified  DEFINE_CODECAPI_GUIDNAMED( GUID_AVEncCommonFormatUnSpecified    )
    #define CODECAPI_GUID_AVEncCommonFormatDVD_V    DEFINE_CODECAPI_GUIDNAMED( GUID_AVEncCommonFormatDVD_V )
    #define CODECAPI_GUID_AVEncCommonFormatDVD_DashVR   DEFINE_CODECAPI_GUIDNAMED( GUID_AVEncCommonFormatDVD_DashVR )
    #define CODECAPI_GUID_AVEncCommonFormatDVD_PlusVR   DEFINE_CODECAPI_GUIDNAMED( GUID_AVEncCommonFormatDVD_PlusVR )
    #define CODECAPI_GUID_AVEncCommonFormatVCD  DEFINE_CODECAPI_GUIDNAMED( GUID_AVEncCommonFormatVCD )
    #define CODECAPI_GUID_AVEncCommonFormatSVCD DEFINE_CODECAPI_GUIDNAMED( GUID_AVEncCommonFormatSVCD )
    #define CODECAPI_GUID_AVEncCommonFormatATSC DEFINE_CODECAPI_GUIDNAMED( GUID_AVEncCommonFormatATSC )
    #define CODECAPI_GUID_AVEncCommonFormatDVB  DEFINE_CODECAPI_GUIDNAMED( GUID_AVEncCommonFormatDVB )
    #define CODECAPI_GUID_AVEncCommonFormatMP3  DEFINE_CODECAPI_GUIDNAMED( GUID_AVEncCommonFormatMP3 )
    #define CODECAPI_GUID_AVEncCommonFormatHighMAT  DEFINE_CODECAPI_GUIDNAMED( GUID_AVEncCommonFormatHighMAT )
    #define CODECAPI_GUID_AVEncCommonFormatHighMPV  DEFINE_CODECAPI_GUIDNAMED( GUID_AVEncCommonFormatHighMPV )
    #define CODECAPI_AVEncCodecType DEFINE_CODECAPI_GUIDNAMED( AVEncCodecType )
    #define CODECAPI_GUID_AVEncMPEG1Video   DEFINE_CODECAPI_GUIDNAMED( GUID_AVEncMPEG1Video )
    #define CODECAPI_GUID_AVEncMPEG2Video   DEFINE_CODECAPI_GUIDNAMED( GUID_AVEncMPEG2Video )
    #define CODECAPI_GUID_AVEncMPEG1Audio   DEFINE_CODECAPI_GUIDNAMED( GUID_AVEncMPEG1Audio )
    #define CODECAPI_GUID_AVEncMPEG2Audio   DEFINE_CODECAPI_GUIDNAMED( GUID_AVEncMPEG2Audio )
    #define CODECAPI_GUID_AVEncWMV  DEFINE_CODECAPI_GUIDNAMED( GUID_AVEncWMV )
    #define CODECAPI_GUID_AVEndMPEG4Video   DEFINE_CODECAPI_GUIDNAMED( GUID_AVEndMPEG4Video )
    #define CODECAPI_GUID_AVEncH264Video    DEFINE_CODECAPI_GUIDNAMED( GUID_AVEncH264Video )
    #define CODECAPI_GUID_AVEncDV   DEFINE_CODECAPI_GUIDNAMED( GUID_AVEncDV )
    #define CODECAPI_GUID_AVEncWMAPro   DEFINE_CODECAPI_GUIDNAMED( GUID_AVEncWMAPro )
    #define CODECAPI_GUID_AVEncWMALossless  DEFINE_CODECAPI_GUIDNAMED( GUID_AVEncWMALossless )
    #define CODECAPI_GUID_AVEncWMAVoice DEFINE_CODECAPI_GUIDNAMED( GUID_AVEncWMAVoice )
    #define CODECAPI_GUID_AVEncDolbyDigitalPro      DEFINE_CODECAPI_GUIDNAMED( GUID_AVEncDolbyDigitalPro )
    #define CODECAPI_GUID_AVEncDolbyDigitalConsumer DEFINE_CODECAPI_GUIDNAMED( GUID_AVEncDolbyDigitalConsumer )
    #define CODECAPI_GUID_AVEncDolbyDigitalPlus     DEFINE_CODECAPI_GUIDNAMED( GUID_AVEncDolbyDigitalPlus )
    #define CODECAPI_GUID_AVEncDTSHD                DEFINE_CODECAPI_GUIDNAMED( GUID_AVEncDTSHD )
    #define CODECAPI_GUID_AVEncDTS  DEFINE_CODECAPI_GUIDNAMED( GUID_AVEncDTS )
    #define CODECAPI_GUID_AVEncMLP  DEFINE_CODECAPI_GUIDNAMED( GUID_AVEncMLP )
    #define CODECAPI_GUID_AVEncPCM  DEFINE_CODECAPI_GUIDNAMED( GUID_AVEncPCM )
    #define CODECAPI_GUID_AVEncSDDS DEFINE_CODECAPI_GUIDNAMED( GUID_AVEncSDDS )
    #define CODECAPI_AVEncCommonRateControlMode DEFINE_CODECAPI_GUIDNAMED( AVEncCommonRateControlMode )
    #define CODECAPI_AVEncCommonLowLatency  DEFINE_CODECAPI_GUIDNAMED( AVEncCommonLowLatency )
    #define CODECAPI_AVEncCommonMultipassMode   DEFINE_CODECAPI_GUIDNAMED( AVEncCommonMultipassMode )
    #define CODECAPI_AVEncCommonPassStart   DEFINE_CODECAPI_GUIDNAMED( AVEncCommonPassStart )
    #define CODECAPI_AVEncCommonPassEnd DEFINE_CODECAPI_GUIDNAMED( AVEncCommonPassEnd )
    #define CODECAPI_AVEncCommonRealTime    DEFINE_CODECAPI_GUIDNAMED( AVEncCommonRealTime )
    #define CODECAPI_AVEncCommonQuality DEFINE_CODECAPI_GUIDNAMED( AVEncCommonQuality )
    #define CODECAPI_AVEncCommonQualityVsSpeed  DEFINE_CODECAPI_GUIDNAMED( AVEncCommonQualityVsSpeed )
    #define CODECAPI_AVEncCommonMeanBitRate DEFINE_CODECAPI_GUIDNAMED( AVEncCommonMeanBitRate )
    #define CODECAPI_AVEncCommonMeanBitRateInterval DEFINE_CODECAPI_GUIDNAMED( AVEncCommonMeanBitRateInterval )
    #define CODECAPI_AVEncCommonMaxBitRate  DEFINE_CODECAPI_GUIDNAMED( AVEncCommonMaxBitRate )
    #define CODECAPI_AVEncCommonMinBitRate  DEFINE_CODECAPI_GUIDNAMED( AVEncCommonMinBitRate )
    #define CODECAPI_AVEncCommonBufferSize  DEFINE_CODECAPI_GUIDNAMED( AVEncCommonBufferSize )
    #define CODECAPI_AVEncCommonBufferInLevel   DEFINE_CODECAPI_GUIDNAMED( AVEncCommonBufferInLevel )
    #define CODECAPI_AVEncCommonBufferOutLevel  DEFINE_CODECAPI_GUIDNAMED( AVEncCommonBufferOutLevel )
    #define CODECAPI_AVEncCommonStreamEndHandling   DEFINE_CODECAPI_GUIDNAMED( AVEncCommonStreamEndHandling )
    #define CODECAPI_AVEncStatCommonCompletedPasses DEFINE_CODECAPI_GUIDNAMED( AVEncStatCommonCompletedPasses )
    #define CODECAPI_AVEncVideoOutputFrameRate  DEFINE_CODECAPI_GUIDNAMED( AVEncVideoOutputFrameRate )
    #define CODECAPI_AVEncVideoOutputFrameRateConversion    DEFINE_CODECAPI_GUIDNAMED( AVEncVideoOutputFrameRateConversion )
    #define CODECAPI_AVEncVideoPixelAspectRatio DEFINE_CODECAPI_GUIDNAMED( AVEncVideoPixelAspectRatio )
    #define CODECAPI_AVEncVideoForceSourceScanType  DEFINE_CODECAPI_GUIDNAMED( AVEncVideoForceSourceScanType )
    #define CODECAPI_AVEncVideoNoOfFieldsToEncode   DEFINE_CODECAPI_GUIDNAMED( AVEncVideoNoOfFieldsToEncode )
    #define CODECAPI_AVEncVideoNoOfFieldsToSkip DEFINE_CODECAPI_GUIDNAMED( AVEncVideoNoOfFieldsToSkip )
    #define CODECAPI_AVEncVideoEncodeDimension  DEFINE_CODECAPI_GUIDNAMED( AVEncVideoEncodeDimension )
    #define CODECAPI_AVEncVideoEncodeOffsetOrigin   DEFINE_CODECAPI_GUIDNAMED( AVEncVideoEncodeOffsetOrigin )
    #define CODECAPI_AVEncVideoDisplayDimension DEFINE_CODECAPI_GUIDNAMED( AVEncVideoDisplayDimension )
    #define CODECAPI_AVEncVideoOutputScanType   DEFINE_CODECAPI_GUIDNAMED( AVEncVideoOutputScanType )
    #define CODECAPI_AVEncVideoInverseTelecineEnable    DEFINE_CODECAPI_GUIDNAMED( AVEncVideoInverseTelecineEnable )
    #define CODECAPI_AVEncVideoInverseTelecineThreshold DEFINE_CODECAPI_GUIDNAMED( AVEncVideoInverseTelecineThreshold )
    #define CODECAPI_AVEncVideoSourceFilmContent    DEFINE_CODECAPI_GUIDNAMED( AVEncVideoSourceFilmContent )
    #define CODECAPI_AVEncVideoSourceIsBW   DEFINE_CODECAPI_GUIDNAMED( AVEncVideoSourceIsBW )
    #define CODECAPI_AVEncVideoFieldSwap    DEFINE_CODECAPI_GUIDNAMED( AVEncVideoFieldSwap )
    #define CODECAPI_AVEncVideoInputChromaResolution    DEFINE_CODECAPI_GUIDNAMED( AVEncVideoInputChromaResolution )
    #define CODECAPI_AVEncVideoOutputChromaResolution   DEFINE_CODECAPI_GUIDNAMED( AVEncVideoOutputChromaResolution )
    #define CODECAPI_AVEncVideoInputChromaSubsampling   DEFINE_CODECAPI_GUIDNAMED( AVEncVideoInputChromaSubsampling )
    #define CODECAPI_AVEncVideoOutputChromaSubsampling  DEFINE_CODECAPI_GUIDNAMED( AVEncVideoOutputChromaSubsampling )
    #define CODECAPI_AVEncVideoInputColorPrimaries  DEFINE_CODECAPI_GUIDNAMED( AVEncVideoInputColorPrimaries )
    #define CODECAPI_AVEncVideoOutputColorPrimaries DEFINE_CODECAPI_GUIDNAMED( AVEncVideoOutputColorPrimaries )
    #define CODECAPI_AVEncVideoInputColorTransferFunction   DEFINE_CODECAPI_GUIDNAMED( AVEncVideoInputColorTransferFunction )
    #define CODECAPI_AVEncVideoOutputColorTransferFunction  DEFINE_CODECAPI_GUIDNAMED( AVEncVideoOutputColorTransferFunction )
    #define CODECAPI_AVEncVideoInputColorTransferMatrix DEFINE_CODECAPI_GUIDNAMED( AVEncVideoInputColorTransferMatrix )
    #define CODECAPI_AVEncVideoOutputColorTransferMatrix    DEFINE_CODECAPI_GUIDNAMED( AVEncVideoOutputColorTransferMatrix  )
    #define CODECAPI_AVEncVideoInputColorLighting   DEFINE_CODECAPI_GUIDNAMED( AVEncVideoInputColorLighting )
    #define CODECAPI_AVEncVideoOutputColorLighting  DEFINE_CODECAPI_GUIDNAMED( AVEncVideoOutputColorLighting  )
    #define CODECAPI_AVEncVideoInputColorNominalRange   DEFINE_CODECAPI_GUIDNAMED( AVEncVideoInputColorNominalRange )
    #define CODECAPI_AVEncVideoOutputColorNominalRange  DEFINE_CODECAPI_GUIDNAMED( AVEncVideoOutputColorNominalRange  )
    #define CODECAPI_AVEncInputVideoSystem  DEFINE_CODECAPI_GUIDNAMED( AVEncInputVideoSystem )
    #define CODECAPI_AVEncVideoHeaderDropFrame  DEFINE_CODECAPI_GUIDNAMED( AVEncVideoHeaderDropFrame )
    #define CODECAPI_AVEncVideoHeaderHours  DEFINE_CODECAPI_GUIDNAMED( AVEncVideoHeaderHours )
    #define CODECAPI_AVEncVideoHeaderMinutes    DEFINE_CODECAPI_GUIDNAMED( AVEncVideoHeaderMinutes )
    #define CODECAPI_AVEncVideoHeaderSeconds    DEFINE_CODECAPI_GUIDNAMED( AVEncVideoHeaderSeconds )
    #define CODECAPI_AVEncVideoHeaderFrames DEFINE_CODECAPI_GUIDNAMED( AVEncVideoHeaderFrames )
    #define CODECAPI_AVEncVideoDefaultUpperFieldDominant    DEFINE_CODECAPI_GUIDNAMED( AVEncVideoDefaultUpperFieldDominant )
    #define CODECAPI_AVEncVideoCBRMotionTradeoff    DEFINE_CODECAPI_GUIDNAMED( AVEncVideoCBRMotionTradeoff )
    #define CODECAPI_AVEncVideoCodedVideoAccessUnitSize DEFINE_CODECAPI_GUIDNAMED( AVEncVideoCodedVideoAccessUnitSize )
    #define CODECAPI_AVEncVideoMaxKeyframeDistance DEFINE_CODECAPI_GUIDNAMED( AVEncVideoMaxKeyframeDistance )
    #define CODECAPI_AVEncStatVideoOutputFrameRate  DEFINE_CODECAPI_GUIDNAMED( AVEncStatVideoOutputFrameRate )
    #define CODECAPI_AVEncStatVideoCodedFrames  DEFINE_CODECAPI_GUIDNAMED( AVEncStatVideoCodedFrames )
    #define CODECAPI_AVEncStatVideoTotalFrames  DEFINE_CODECAPI_GUIDNAMED( AVEncStatVideoTotalFrames )
    #define CODECAPI_AVEncAudioIntervalToEncode DEFINE_CODECAPI_GUIDNAMED( AVEncAudioIntervalToEncode )
    #define CODECAPI_AVEncAudioIntervalToSkip   DEFINE_CODECAPI_GUIDNAMED( AVEncAudioIntervalToSkip )
    #define CODECAPI_AVEncAudioDualMono         DEFINE_CODECAPI_GUIDNAMED( AVEncAudioDualMono )


    #define CODECAPI_AVEncAudioMapDestChannel0  DEFINE_CODECAPI_GUIDNAMED( AVEncAudioMapDestChannel0 )
    #define CODECAPI_AVEncAudioMapDestChannel1  DEFINE_CODECAPI_GUIDNAMED( AVEncAudioMapDestChannel1 )
    #define CODECAPI_AVEncAudioMapDestChannel2  DEFINE_CODECAPI_GUIDNAMED( AVEncAudioMapDestChannel2 )
    #define CODECAPI_AVEncAudioMapDestChannel3  DEFINE_CODECAPI_GUIDNAMED( AVEncAudioMapDestChannel3 )
    #define CODECAPI_AVEncAudioMapDestChannel4  DEFINE_CODECAPI_GUIDNAMED( AVEncAudioMapDestChannel4 )
    #define CODECAPI_AVEncAudioMapDestChannel5  DEFINE_CODECAPI_GUIDNAMED( AVEncAudioMapDestChannel5 )
    #define CODECAPI_AVEncAudioMapDestChannel6  DEFINE_CODECAPI_GUIDNAMED( AVEncAudioMapDestChannel6 )
    #define CODECAPI_AVEncAudioMapDestChannel7  DEFINE_CODECAPI_GUIDNAMED( AVEncAudioMapDestChannel7 )
    #define CODECAPI_AVEncAudioMapDestChannel8  DEFINE_CODECAPI_GUIDNAMED( AVEncAudioMapDestChannel8 )
    #define CODECAPI_AVEncAudioMapDestChannel9  DEFINE_CODECAPI_GUIDNAMED( AVEncAudioMapDestChannel9 )
    #define CODECAPI_AVEncAudioMapDestChannel10 DEFINE_CODECAPI_GUIDNAMED( AVEncAudioMapDestChannel10 )
    #define CODECAPI_AVEncAudioMapDestChannel11 DEFINE_CODECAPI_GUIDNAMED( AVEncAudioMapDestChannel11 )
    #define CODECAPI_AVEncAudioMapDestChannel12 DEFINE_CODECAPI_GUIDNAMED( AVEncAudioMapDestChannel12 )
    #define CODECAPI_AVEncAudioMapDestChannel13 DEFINE_CODECAPI_GUIDNAMED( AVEncAudioMapDestChannel13 )
    #define CODECAPI_AVEncAudioMapDestChannel14 DEFINE_CODECAPI_GUIDNAMED( AVEncAudioMapDestChannel14 )
    #define CODECAPI_AVEncAudioMapDestChannel15 DEFINE_CODECAPI_GUIDNAMED( AVEncAudioMapDestChannel15 )
    
    #define CODECAPI_AVEncAudioInputContent DEFINE_CODECAPI_GUIDNAMED( AVEncAudioInputContent )
    #define CODECAPI_AVEncStatAudioPeakPCMValue DEFINE_CODECAPI_GUIDNAMED( AVEncStatAudioPeakPCMValue )
    #define CODECAPI_AVEncStatAudioAveragePCMValue  DEFINE_CODECAPI_GUIDNAMED( AVEncStatAudioAveragePCMValue )
    #define CODECAPI_AVEncStatAudioAverageBPS   DEFINE_CODECAPI_GUIDNAMED( AVEncStatAudioAverageBPS )
    #define CODECAPI_AVEncMPVGOPSize    DEFINE_CODECAPI_GUIDNAMED( AVEncMPVGOPSize )
    #define CODECAPI_AVEncMPVGOPOpen    DEFINE_CODECAPI_GUIDNAMED( AVEncMPVGOPOpen )
    #define CODECAPI_AVEncMPVDefaultBPictureCount   DEFINE_CODECAPI_GUIDNAMED( AVEncMPVDefaultBPictureCount )
    #define CODECAPI_AVEncMPVProfile    DEFINE_CODECAPI_GUIDNAMED( AVEncMPVProfile )
    #define CODECAPI_AVEncMPVLevel  DEFINE_CODECAPI_GUIDNAMED( AVEncMPVLevel )
    #define CODECAPI_AVEncMPVFrameFieldMode DEFINE_CODECAPI_GUIDNAMED( AVEncMPVFrameFieldMode )
    #define CODECAPI_AVEncMPVAddSeqEndCode  DEFINE_CODECAPI_GUIDNAMED( AVEncMPVAddSeqEndCode )
    #define CODECAPI_AVEncMPVGOPSInSeq  DEFINE_CODECAPI_GUIDNAMED( AVEncMPVGOPSInSeq )
    #define CODECAPI_AVEncMPVUseConcealmentMotionVectors    DEFINE_CODECAPI_GUIDNAMED( AVEncMPVUseConcealmentMotionVectors )
    #define CODECAPI_AVEncMPVSceneDetection DEFINE_CODECAPI_GUIDNAMED( AVEncMPVSceneDetection )
    #define CODECAPI_AVEncMPVGenerateHeaderSeqExt   DEFINE_CODECAPI_GUIDNAMED( AVEncMPVGenerateHeaderSeqExt )
    #define CODECAPI_AVEncMPVGenerateHeaderSeqDispExt   DEFINE_CODECAPI_GUIDNAMED( AVEncMPVGenerateHeaderSeqDispExt )
    #define CODECAPI_AVEncMPVGenerateHeaderPicExt   DEFINE_CODECAPI_GUIDNAMED( AVEncMPVGenerateHeaderPicExt )
    #define CODECAPI_AVEncMPVGenerateHeaderPicDispExt   DEFINE_CODECAPI_GUIDNAMED( AVEncMPVGenerateHeaderPicDispExt )
    #define CODECAPI_AVEncMPVGenerateHeaderSeqScaleExt  DEFINE_CODECAPI_GUIDNAMED( AVEncMPVGenerateHeaderSeqScaleExt )
    #define CODECAPI_AVEncMPVScanPattern    DEFINE_CODECAPI_GUIDNAMED( AVEncMPVScanPattern )
    #define CODECAPI_AVEncMPVIntraDCPrecision   DEFINE_CODECAPI_GUIDNAMED( AVEncMPVIntraDCPrecision )
    #define CODECAPI_AVEncMPVQScaleType DEFINE_CODECAPI_GUIDNAMED( AVEncMPVQScaleType )
    #define CODECAPI_AVEncMPVIntraVLCTable  DEFINE_CODECAPI_GUIDNAMED( AVEncMPVIntraVLCTable )
    #define CODECAPI_AVEncMPVQuantMatrixIntra   DEFINE_CODECAPI_GUIDNAMED( AVEncMPVQuantMatrixIntra )
    #define CODECAPI_AVEncMPVQuantMatrixNonIntra    DEFINE_CODECAPI_GUIDNAMED( AVEncMPVQuantMatrixNonIntra )
    #define CODECAPI_AVEncMPVQuantMatrixChromaIntra DEFINE_CODECAPI_GUIDNAMED( AVEncMPVQuantMatrixChromaIntra )
    #define CODECAPI_AVEncMPVQuantMatrixChromaNonIntra  DEFINE_CODECAPI_GUIDNAMED( AVEncMPVQuantMatrixChromaNonIntra )
    #define CODECAPI_AVEncMPALayer  DEFINE_CODECAPI_GUIDNAMED( AVEncMPALayer )
    #define CODECAPI_AVEncMPACodingMode DEFINE_CODECAPI_GUIDNAMED( AVEncMPACodingMode )
    #define CODECAPI_AVEncDDService DEFINE_CODECAPI_GUIDNAMED( AVEncDDService )
    #define CODECAPI_AVEncDDDialogNormalization DEFINE_CODECAPI_GUIDNAMED( AVEncDDDialogNormalization )
    #define CODECAPI_AVEncDDCentreDownMixLevel  DEFINE_CODECAPI_GUIDNAMED( AVEncDDCentreDownMixLevel )
    #define CODECAPI_AVEncDDSurroundDownMixLevel    DEFINE_CODECAPI_GUIDNAMED( AVEncDDSurroundDownMixLevel )
    #define CODECAPI_AVEncDDProductionInfoExists    DEFINE_CODECAPI_GUIDNAMED( AVEncDDProductionInfoExists )
    #define CODECAPI_AVEncDDProductionRoomType  DEFINE_CODECAPI_GUIDNAMED( AVEncDDProductionRoomType )
    #define CODECAPI_AVEncDDProductionMixLevel  DEFINE_CODECAPI_GUIDNAMED( AVEncDDProductionMixLevel )
    #define CODECAPI_AVEncDDCopyright   DEFINE_CODECAPI_GUIDNAMED( AVEncDDCopyright )
    #define CODECAPI_AVEncDDOriginalBitstream   DEFINE_CODECAPI_GUIDNAMED( AVEncDDOriginalBitstream )
    #define CODECAPI_AVEncDDDigitalDeemphasis   DEFINE_CODECAPI_GUIDNAMED( AVEncDDDigitalDeemphasis )
    #define CODECAPI_AVEncDDDCHighPassFilter    DEFINE_CODECAPI_GUIDNAMED( AVEncDDDCHighPassFilter )
    #define CODECAPI_AVEncDDChannelBWLowPassFilter  DEFINE_CODECAPI_GUIDNAMED( AVEncDDChannelBWLowPassFilter )
    #define CODECAPI_AVEncDDLFELowPassFilter    DEFINE_CODECAPI_GUIDNAMED( AVEncDDLFELowPassFilter )
    #define CODECAPI_AVEncDDSurround90DegreeePhaseShift DEFINE_CODECAPI_GUIDNAMED( AVEncDDSurround90DegreeePhaseShift )
    #define CODECAPI_AVEncDDSurround3dBAttenuation  DEFINE_CODECAPI_GUIDNAMED( AVEncDDSurround3dBAttenuation )
    #define CODECAPI_AVEncDDDynamicRangeCompressionControl  DEFINE_CODECAPI_GUIDNAMED( AVEncDDDynamicRangeCompressionControl )
    #define CODECAPI_AVEncDDRFPreEmphasisFilter DEFINE_CODECAPI_GUIDNAMED( AVEncDDRFPreEmphasisFilter )
    #define CODECAPI_AVEncDDSurroundExMode  DEFINE_CODECAPI_GUIDNAMED( AVEncDDSurroundExMode )
    #define CODECAPI_AVEncDDPreferredStereoDownMixMode  DEFINE_CODECAPI_GUIDNAMED( AVEncDDPreferredStereoDownMixMode )
    #define CODECAPI_AVEncDDLtRtCenterMixLvl_x10    DEFINE_CODECAPI_GUIDNAMED( AVEncDDLtRtCenterMixLvl_x10 )
    #define CODECAPI_AVEncDDLtRtSurroundMixLvl_x10  DEFINE_CODECAPI_GUIDNAMED( AVEncDDLtRtSurroundMixLvl_x10 )
    #define CODECAPI_AVEncDDLoRoCenterMixLvl_x10    DEFINE_CODECAPI_GUIDNAMED( AVEncDDLoRoCenterMixLvl_x10 )
    #define CODECAPI_AVEncDDLoRoSurroundMixLvl_x10  DEFINE_CODECAPI_GUIDNAMED( AVEncDDLoRoSurroundMixLvl_x10 )
    #define CODECAPI_AVEncDDAtoDConverterType   DEFINE_CODECAPI_GUIDNAMED( AVEncDDAtoDConverterType )
    #define CODECAPI_AVEncDDHeadphoneMode   DEFINE_CODECAPI_GUIDNAMED( AVEncDDHeadphoneMode )
    #define CODECAPI_AVEncWMVKeyFrameDistance   DEFINE_CODECAPI_GUIDNAMED( AVEncWMVKeyFrameDistance )
    #define CODECAPI_AVEncWMVInterlacedEncoding DEFINE_CODECAPI_GUIDNAMED( AVEncWMVInterlacedEncoding )
    #define CODECAPI_AVEncWMVDecoderComplexity  DEFINE_CODECAPI_GUIDNAMED( AVEncWMVDecoderComplexity )
    #define CODECAPI_AVEncWMVKeyFrameBufferLevelMarker  DEFINE_CODECAPI_GUIDNAMED( AVEncWMVKeyFrameBufferLevelMarker )
    #define CODECAPI_AVEncWMVProduceDummyFrames DEFINE_CODECAPI_GUIDNAMED( AVEncWMVProduceDummyFrames )
    #define CODECAPI_AVEncStatWMVCBAvg  DEFINE_CODECAPI_GUIDNAMED( AVEncStatWMVCBAvg )
    #define CODECAPI_AVEncStatWMVCBMax  DEFINE_CODECAPI_GUIDNAMED( AVEncStatWMVCBMax )
    #define CODECAPI_AVEncStatWMVDecoderComplexityProfile   DEFINE_CODECAPI_GUIDNAMED( AVEncStatWMVDecoderComplexityProfile )
    #define CODECAPI_AVEncStatMPVSkippedEmptyFrames DEFINE_CODECAPI_GUIDNAMED( AVEncStatMPVSkippedEmptyFrames )
    #define CODECAPI_AVEncMP12PktzSTDBuffer DEFINE_CODECAPI_GUIDNAMED( AVEncMP12PktzSTDBuffer )
    #define CODECAPI_AVEncMP12PktzStreamID  DEFINE_CODECAPI_GUIDNAMED( AVEncMP12PktzStreamID )
    #define CODECAPI_AVEncMP12PktzInitialPTS    DEFINE_CODECAPI_GUIDNAMED( AVEncMP12PktzInitialPTS )
    #define CODECAPI_AVEncMP12PktzPacketSize    DEFINE_CODECAPI_GUIDNAMED( AVEncMP12PktzPacketSize )
    #define CODECAPI_AVEncMP12PktzCopyright DEFINE_CODECAPI_GUIDNAMED( AVEncMP12PktzCopyright )
    #define CODECAPI_AVEncMP12PktzOriginal  DEFINE_CODECAPI_GUIDNAMED( AVEncMP12PktzOriginal )
    #define CODECAPI_AVEncMP12MuxPacketOverhead DEFINE_CODECAPI_GUIDNAMED( AVEncMP12MuxPacketOverhead )
    #define CODECAPI_AVEncMP12MuxNumStreams DEFINE_CODECAPI_GUIDNAMED( AVEncMP12MuxNumStreams )
    #define CODECAPI_AVEncMP12MuxEarliestPTS    DEFINE_CODECAPI_GUIDNAMED( AVEncMP12MuxEarliestPTS )
    #define CODECAPI_AVEncMP12MuxLargestPacketSize  DEFINE_CODECAPI_GUIDNAMED( AVEncMP12MuxLargestPacketSize )
    #define CODECAPI_AVEncMP12MuxInitialSCR DEFINE_CODECAPI_GUIDNAMED( AVEncMP12MuxInitialSCR )
    #define CODECAPI_AVEncMP12MuxMuxRate    DEFINE_CODECAPI_GUIDNAMED( AVEncMP12MuxMuxRate )
    #define CODECAPI_AVEncMP12MuxPackSize   DEFINE_CODECAPI_GUIDNAMED( AVEncMP12MuxPackSize )
    #define CODECAPI_AVEncMP12MuxSysSTDBufferBound  DEFINE_CODECAPI_GUIDNAMED( AVEncMP12MuxSysSTDBufferBound )
    #define CODECAPI_AVEncMP12MuxSysRateBound   DEFINE_CODECAPI_GUIDNAMED( AVEncMP12MuxSysRateBound )
    #define CODECAPI_AVEncMP12MuxTargetPacketizer   DEFINE_CODECAPI_GUIDNAMED( AVEncMP12MuxTargetPacketizer )
    #define CODECAPI_AVEncMP12MuxSysFixed   DEFINE_CODECAPI_GUIDNAMED( AVEncMP12MuxSysFixed )
    #define CODECAPI_AVEncMP12MuxSysCSPS    DEFINE_CODECAPI_GUIDNAMED( AVEncMP12MuxSysCSPS )
    #define CODECAPI_AVEncMP12MuxSysVideoLock   DEFINE_CODECAPI_GUIDNAMED( AVEncMP12MuxSysVideoLock )
    #define CODECAPI_AVEncMP12MuxSysAudioLock   DEFINE_CODECAPI_GUIDNAMED( AVEncMP12MuxSysAudioLock )
    #define CODECAPI_AVEncMP12MuxDVDNavPacks    DEFINE_CODECAPI_GUIDNAMED( AVEncMP12MuxDVDNavPacks )
    
    #define CODECAPI_AVEncMPACopyright                  DEFINE_CODECAPI_GUIDNAMED( AVEncMPACopyright )
    #define CODECAPI_AVEncMPAOriginalBitstream          DEFINE_CODECAPI_GUIDNAMED( AVEncMPAOriginalBitstream )
    #define CODECAPI_AVEncMPAEnableRedundancyProtection  DEFINE_CODECAPI_GUIDNAMED( AVEncMPAEnableRedundancyProtection )
    #define CODECAPI_AVEncMPAPrivateUserBit            DEFINE_CODECAPI_GUIDNAMED( AVEncMPAPrivateUserBit )
    #define CODECAPI_AVEncMPAEmphasisType               DEFINE_CODECAPI_GUIDNAMED( AVEncMPAEmphasisType )

    #define CODECAPI_AVDecCommonOutputFormat                        DEFINE_CODECAPI_GUIDNAMED( AVDecCommonOutputFormat )
    #define CODECAPI_AVDecCommonInputFormat     DEFINE_CODECAPI_GUIDNAMED( AVDecCommonInputFormat )
    #define CODECAPI_AVDecCommonMeanBitRate         DEFINE_CODECAPI_GUIDNAMED( AVDecCommonMeanBitRate )
    #define CODECAPI_AVDecCommonMeanBitRateInterval DEFINE_CODECAPI_GUIDNAMED( AVDecCommonMeanBitRateInterval )

    #define CODECAPI_GUID_AVDecAudioOutputFormat_PCM_Stereo_MatrixEncoded   DEFINE_CODECAPI_GUIDNAMED( GUID_AVDecAudioOutputFormat_PCM_Stereo_MatrixEncoded )
    #define CODECAPI_GUID_AVDecAudioOutputFormat_PCM            DEFINE_CODECAPI_GUIDNAMED( GUID_AVDecAudioOutputFormat_PCM )
    #define CODECAPI_GUID_AVDecAudioOutputFormat_SPDIF_PCM      DEFINE_CODECAPI_GUIDNAMED( GUID_AVDecAudioOutputFormat_SPDIF_PCM )
    #define CODECAPI_GUID_AVDecAudioOutputFormat_SPDIF_Bitstream    DEFINE_CODECAPI_GUIDNAMED( GUID_AVDecAudioOutputFormat_SPDIF_Bitstream )
    #define CODECAPI_GUID_AVDecAudioOutputFormat_PCM_Headphones DEFINE_CODECAPI_GUIDNAMED( GUID_AVDecAudioOutputFormat_PCM_Headphones )
    #define CODECAPI_GUID_AVDecAudioOutputFormat_PCM_Stereo_Auto DEFINE_CODECAPI_GUIDNAMED( GUID_AVDecAudioOutputFormat_PCM_Stereo_Auto )

    #define CODECAPI_AVDecVideoImageSize            DEFINE_CODECAPI_GUIDNAMED( AVDecVideoImageSize )
    #define CODECAPI_AVDecVideoInputScanType        DEFINE_CODECAPI_GUIDNAMED( AVDecVideoInputScanType )
    #define CODECAPI_AVDecVideoPixelAspectRatio     DEFINE_CODECAPI_GUIDNAMED( AVDecVideoPixelAspectRatio )

    #define CODECAPI_GUID_AVDecAudioInputWMA        DEFINE_CODECAPI_GUIDNAMED( GUID_AVDecAudioInputWMA )
    #define CODECAPI_GUID_AVDecAudioInputWMAPro     DEFINE_CODECAPI_GUIDNAMED( GUID_AVDecAudioInputWMAPro )
    #define CODECAPI_GUID_AVDecAudioInputDolby      DEFINE_CODECAPI_GUIDNAMED( GUID_AVDecAudioInputDolby )
    #define CODECAPI_GUID_AVDecAudioInputDTS        DEFINE_CODECAPI_GUIDNAMED( GUID_AVDecAudioInputDTS )
    #define CODECAPI_GUID_AVDecAudioInputPCM        DEFINE_CODECAPI_GUIDNAMED( GUID_AVDecAudioInputPCM )
    #define CODECAPI_GUID_AVDecAudioInputMPEG       DEFINE_CODECAPI_GUIDNAMED( GUID_AVDecAudioInputMPEG )
    #define CODECAPI_AVDecAudioDualMono             DEFINE_CODECAPI_GUIDNAMED( AVDecAudioDualMono)
    #define CODECAPI_AVDecAudioDualMonoReproMode    DEFINE_CODECAPI_GUIDNAMED( AVDecAudioDualMonoReproMode )

    #define CODECAPI_AVAudioChannelCount            DEFINE_CODECAPI_GUIDNAMED( AVAudioChannelCount )
    #define CODECAPI_AVAudioChannelConfig           DEFINE_CODECAPI_GUIDNAMED( AVAudioChannelConfig )
    #define CODECAPI_AVAudioSampleRate              DEFINE_CODECAPI_GUIDNAMED( AVAudioSampleRate )

    #define CODECAPI_AVDDSurroundMode               DEFINE_CODECAPI_GUIDNAMED( AVDDSurroundMode )
    #define CODECAPI_AVDecDDOperationalMode         DEFINE_CODECAPI_GUIDNAMED( AVDecDDOperationalMode )
    #define CODECAPI_AVDecDDMatrixDecodingMode      DEFINE_CODECAPI_GUIDNAMED( AVDecDDMatrixDecodingMode )
    #define CODECAPI_AVDecDDDynamicRangeScaleHigh   DEFINE_CODECAPI_GUIDNAMED( AVDecDDDynamicRangeScaleHigh )
    #define CODECAPI_AVDecDDDynamicRangeScaleLow    DEFINE_CODECAPI_GUIDNAMED( AVDecDDDynamicRangeScaleLow )

#endif


#endif // !defined(_CODECAPI_)
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\vs9sp1\sdk\include\colldispid.h ===
//***************************************************************************** 
// 
// Microsoft Windows Media 
// Copyright (C) Microsoft Corporation. All rights reserved. 
//
// FileName:            colldispid.h
//
// Abstract:
//
//*****************************************************************************

#pragma once

#ifndef __COLLDISPID_H_
#define __COLLDISPID_H_

#ifndef DISPID_LISTITEM
#define DISPID_LISTITEM     0
#endif

//
// Standard collection count defined in olectl.h.
//
#ifndef DISPID_LISTCOUNT
#define DISPID_LISTCOUNT    (-531)
#endif

//
// Create a non standard one for length which is the Java equivalent to Count
//
#ifndef DISPID_COLLCOUNT
#define DISPID_COLLCOUNT    (-530)
#endif

#ifndef DISPID_NEWENUM
#define DISPID_NEWENUM      (-4)
#endif

//
// A macro to create the standard collection Methods & Properties: Item, Count, length & _NewEnum
// Count and length return the same thing but one is geared towards VB/Automation
// collections (COUNT) and the other towards Java/JScript (length).
#define COLLECTION_METHODS( type, strHelp ) \
        [propget, id(DISPID_LISTITEM), helpstring( strHelp )] HRESULT \
    Item([in] const VARIANT varIndex, [out, retval] type *pVal);         \
        [propget, id(DISPID_LISTCOUNT), helpstring("Retrieves the number of items in the collection.")] HRESULT \
    Count([out, retval] long *pVal); \
        [propget, id(DISPID_COLLCOUNT), helpstring("Retrieves the number of items in the collection.")] HRESULT \
    length([out, retval] long *pVal); \
        [propget, id(DISPID_NEWENUM), restricted, hidden] HRESULT \
    _NewEnum([out, retval] IUnknown* *pVal);

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\vs9sp1\sdk\include\ColorDlg.h ===
/*++

Copyright (c) 1990-1999,  Microsoft Corporation  All rights reserved.

Module Name:

    colordlg.h

Abstract:

    This module contains the header information for the Win32 color dialog.

Revision History:

--*/


#if _MSC_VER > 1000
#pragma once
#endif


//
//  Constant Declarations.
//

#define DLG_COLOR            10

#define COLOR_HUESCROLL      700            // color dialog
#define COLOR_SATSCROLL      701
#define COLOR_LUMSCROLL      702
#define COLOR_HUE            703
#define COLOR_SAT            704
#define COLOR_LUM            705
#define COLOR_RED            706
#define COLOR_GREEN          707
#define COLOR_BLUE           708
#define COLOR_CURRENT        709
#define COLOR_RAINBOW        710
#define COLOR_SAVE           711
#define COLOR_ADD            712
#define COLOR_SOLID          713
#define COLOR_TUNE           714
#define COLOR_SCHEMES        715
#define COLOR_ELEMENT        716
#define COLOR_SAMPLES        717
#define COLOR_PALETTE        718
#define COLOR_MIX            719
#define COLOR_BOX1           720
#define COLOR_CUSTOM1        721

#define COLOR_HUEACCEL       723
#define COLOR_SATACCEL       724
#define COLOR_LUMACCEL       725
#define COLOR_REDACCEL       726
#define COLOR_GREENACCEL     727
#define COLOR_BLUEACCEL      728

#define COLOR_SOLID_LEFT     730
#define COLOR_SOLID_RIGHT    731

#define NUM_BASIC_COLORS     48
#define NUM_CUSTOM_COLORS    16
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\vs9sp1\sdk\include\ComCat.h ===
/* this ALWAYS GENERATED file contains the definitions for the interfaces */


 /* File created by MIDL compiler version 7.00.0499 */
/* Compiler settings for comcat.idl:
    Oicf, W1, Zp8, env=Win32 (32b run)
    protocol : dce , ms_ext, c_ext, robust
    error checks: allocation ref bounds_check enum stub_data 
    VC __declspec() decoration level: 
         __declspec(uuid()), __declspec(selectany), __declspec(novtable)
         DECLSPEC_UUID(), MIDL_INTERFACE()
*/
//@@MIDL_FILE_HEADING(  )

#pragma warning( disable: 4049 )  /* more than 64k source lines */


/* verify that the <rpcndr.h> version is high enough to compile this file*/
#ifndef __REQUIRED_RPCNDR_H_VERSION__
#define __REQUIRED_RPCNDR_H_VERSION__ 500
#endif

/* verify that the <rpcsal.h> version is high enough to compile this file*/
#ifndef __REQUIRED_RPCSAL_H_VERSION__
#define __REQUIRED_RPCSAL_H_VERSION__ 100
#endif

#include "rpc.h"
#include "rpcndr.h"

#ifndef __RPCNDR_H_VERSION__
#error this stub requires an updated version of <rpcndr.h>
#endif // __RPCNDR_H_VERSION__

#ifndef COM_NO_WINDOWS_H
#include "windows.h"
#include "ole2.h"
#endif /*COM_NO_WINDOWS_H*/

#ifndef __comcat_h__
#define __comcat_h__

#if defined(_MSC_VER) && (_MSC_VER >= 1020)
#pragma once
#endif

/* Forward Declarations */ 

#ifndef __IEnumGUID_FWD_DEFINED__
#define __IEnumGUID_FWD_DEFINED__
typedef interface IEnumGUID IEnumGUID;
#endif 	/* __IEnumGUID_FWD_DEFINED__ */


#ifndef __IEnumCATEGORYINFO_FWD_DEFINED__
#define __IEnumCATEGORYINFO_FWD_DEFINED__
typedef interface IEnumCATEGORYINFO IEnumCATEGORYINFO;
#endif 	/* __IEnumCATEGORYINFO_FWD_DEFINED__ */


#ifndef __ICatRegister_FWD_DEFINED__
#define __ICatRegister_FWD_DEFINED__
typedef interface ICatRegister ICatRegister;
#endif 	/* __ICatRegister_FWD_DEFINED__ */


#ifndef __ICatInformation_FWD_DEFINED__
#define __ICatInformation_FWD_DEFINED__
typedef interface ICatInformation ICatInformation;
#endif 	/* __ICatInformation_FWD_DEFINED__ */


/* header files for imported files */
#include "unknwn.h"

#ifdef __cplusplus
extern "C"{
#endif 


/* interface __MIDL_itf_comcat_0000_0000 */
/* [local] */ 

//=--------------------------------------------------------------------------=
// ComCat.h
//=--------------------------------------------------------------------------=
// Copyright (c) Microsoft Corporation. All rights reserved.
//
// THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF
// ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO
// THE IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A
// PARTICULAR PURPOSE.
//=--------------------------------------------------------------------------=

#pragma comment(lib,"uuid.lib")

//=--------------------------------------------------------------------------=
// OLE Componet Categories Interfaces.
//=--------------------------------------------------------------------------=
//




EXTERN_C const CLSID CLSID_StdComponentCategoriesMgr;

////////////////////////////////////////////////////////////////////////////
//  Types
typedef GUID CATID;

typedef REFGUID REFCATID;

#define IID_IEnumCLSID              IID_IEnumGUID
#define IEnumCLSID                  IEnumGUID
#define LPENUMCLSID                 LPENUMGUID
#define CATID_NULL                   GUID_NULL
#define IsEqualCATID(rcatid1, rcatid2)       IsEqualGUID(rcatid1, rcatid2)
#define IID_IEnumCATID       IID_IEnumGUID
#define IEnumCATID           IEnumGUID

////////////////////////////////////////////////////////////////////////////
//  Category IDs (link to uuid3.lib)
EXTERN_C const CATID CATID_Insertable;
EXTERN_C const CATID CATID_Control;
EXTERN_C const CATID CATID_Programmable;
EXTERN_C const CATID CATID_IsShortcut;
EXTERN_C const CATID CATID_NeverShowExt;
EXTERN_C const CATID CATID_DocObject;
EXTERN_C const CATID CATID_Printable;
EXTERN_C const CATID CATID_RequiresDataPathHost;
EXTERN_C const CATID CATID_PersistsToMoniker;
EXTERN_C const CATID CATID_PersistsToStorage;
EXTERN_C const CATID CATID_PersistsToStreamInit;
EXTERN_C const CATID CATID_PersistsToStream;
EXTERN_C const CATID CATID_PersistsToMemory;
EXTERN_C const CATID CATID_PersistsToFile;
EXTERN_C const CATID CATID_PersistsToPropertyBag;
EXTERN_C const CATID CATID_InternetAware;
EXTERN_C const CATID CATID_DesignTimeUIActivatableControl;

////////////////////////////////////////////////////////////////////////////
//  Interface Definitions
#ifndef _LPENUMGUID_DEFINED
#define _LPENUMGUID_DEFINED


extern RPC_IF_HANDLE __MIDL_itf_comcat_0000_0000_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_comcat_0000_0000_v0_0_s_ifspec;

#ifndef __IEnumGUID_INTERFACE_DEFINED__
#define __IEnumGUID_INTERFACE_DEFINED__

/* interface IEnumGUID */
/* [unique][uuid][object] */ 

typedef /* [unique] */  __RPC_unique_pointer IEnumGUID *LPENUMGUID;


EXTERN_C const IID IID_IEnumGUID;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("0002E000-0000-0000-C000-000000000046")
    IEnumGUID : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE Next( 
            /* [in] */ ULONG celt,
            /* [length_is][size_is][out] */ __RPC__out_ecount_part(celt, *pceltFetched) GUID *rgelt,
            /* [out] */ __RPC__out ULONG *pceltFetched) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Skip( 
            /* [in] */ ULONG celt) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Reset( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Clone( 
            /* [out] */ __RPC__deref_out_opt IEnumGUID **ppenum) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IEnumGUIDVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IEnumGUID * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IEnumGUID * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IEnumGUID * This);
        
        HRESULT ( STDMETHODCALLTYPE *Next )( 
            IEnumGUID * This,
            /* [in] */ ULONG celt,
            /* [length_is][size_is][out] */ __RPC__out_ecount_part(celt, *pceltFetched) GUID *rgelt,
            /* [out] */ __RPC__out ULONG *pceltFetched);
        
        HRESULT ( STDMETHODCALLTYPE *Skip )( 
            IEnumGUID * This,
            /* [in] */ ULONG celt);
        
        HRESULT ( STDMETHODCALLTYPE *Reset )( 
            IEnumGUID * This);
        
        HRESULT ( STDMETHODCALLTYPE *Clone )( 
            IEnumGUID * This,
            /* [out] */ __RPC__deref_out_opt IEnumGUID **ppenum);
        
        END_INTERFACE
    } IEnumGUIDVtbl;

    interface IEnumGUID
    {
        CONST_VTBL struct IEnumGUIDVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IEnumGUID_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IEnumGUID_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IEnumGUID_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IEnumGUID_Next(This,celt,rgelt,pceltFetched)	\
    ( (This)->lpVtbl -> Next(This,celt,rgelt,pceltFetched) ) 

#define IEnumGUID_Skip(This,celt)	\
    ( (This)->lpVtbl -> Skip(This,celt) ) 

#define IEnumGUID_Reset(This)	\
    ( (This)->lpVtbl -> Reset(This) ) 

#define IEnumGUID_Clone(This,ppenum)	\
    ( (This)->lpVtbl -> Clone(This,ppenum) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IEnumGUID_INTERFACE_DEFINED__ */


/* interface __MIDL_itf_comcat_0000_0001 */
/* [local] */ 

#endif
#ifndef _LPENUMCATEGORYINFO_DEFINED
#define _LPENUMCATEGORYINFO_DEFINED


extern RPC_IF_HANDLE __MIDL_itf_comcat_0000_0001_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_comcat_0000_0001_v0_0_s_ifspec;

#ifndef __IEnumCATEGORYINFO_INTERFACE_DEFINED__
#define __IEnumCATEGORYINFO_INTERFACE_DEFINED__

/* interface IEnumCATEGORYINFO */
/* [unique][uuid][object] */ 

typedef /* [unique] */  __RPC_unique_pointer IEnumCATEGORYINFO *LPENUMCATEGORYINFO;

typedef struct tagCATEGORYINFO
    {
    CATID catid;
    LCID lcid;
    OLECHAR szDescription[ 128 ];
    } 	CATEGORYINFO;

typedef struct tagCATEGORYINFO *LPCATEGORYINFO;


EXTERN_C const IID IID_IEnumCATEGORYINFO;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("0002E011-0000-0000-C000-000000000046")
    IEnumCATEGORYINFO : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE Next( 
            /* [in] */ ULONG celt,
            /* [length_is][size_is][out] */ __RPC__out_ecount_part(celt, *pceltFetched) CATEGORYINFO *rgelt,
            /* [out] */ __RPC__out ULONG *pceltFetched) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Skip( 
            /* [in] */ ULONG celt) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Reset( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Clone( 
            /* [out] */ __RPC__deref_out_opt IEnumCATEGORYINFO **ppenum) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IEnumCATEGORYINFOVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IEnumCATEGORYINFO * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IEnumCATEGORYINFO * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IEnumCATEGORYINFO * This);
        
        HRESULT ( STDMETHODCALLTYPE *Next )( 
            IEnumCATEGORYINFO * This,
            /* [in] */ ULONG celt,
            /* [length_is][size_is][out] */ __RPC__out_ecount_part(celt, *pceltFetched) CATEGORYINFO *rgelt,
            /* [out] */ __RPC__out ULONG *pceltFetched);
        
        HRESULT ( STDMETHODCALLTYPE *Skip )( 
            IEnumCATEGORYINFO * This,
            /* [in] */ ULONG celt);
        
        HRESULT ( STDMETHODCALLTYPE *Reset )( 
            IEnumCATEGORYINFO * This);
        
        HRESULT ( STDMETHODCALLTYPE *Clone )( 
            IEnumCATEGORYINFO * This,
            /* [out] */ __RPC__deref_out_opt IEnumCATEGORYINFO **ppenum);
        
        END_INTERFACE
    } IEnumCATEGORYINFOVtbl;

    interface IEnumCATEGORYINFO
    {
        CONST_VTBL struct IEnumCATEGORYINFOVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IEnumCATEGORYINFO_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IEnumCATEGORYINFO_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IEnumCATEGORYINFO_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IEnumCATEGORYINFO_Next(This,celt,rgelt,pceltFetched)	\
    ( (This)->lpVtbl -> Next(This,celt,rgelt,pceltFetched) ) 

#define IEnumCATEGORYINFO_Skip(This,celt)	\
    ( (This)->lpVtbl -> Skip(This,celt) ) 

#define IEnumCATEGORYINFO_Reset(This)	\
    ( (This)->lpVtbl -> Reset(This) ) 

#define IEnumCATEGORYINFO_Clone(This,ppenum)	\
    ( (This)->lpVtbl -> Clone(This,ppenum) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IEnumCATEGORYINFO_INTERFACE_DEFINED__ */


/* interface __MIDL_itf_comcat_0000_0002 */
/* [local] */ 

#endif
#ifndef _LPCATREGISTER_DEFINED
#define _LPCATREGISTER_DEFINED


extern RPC_IF_HANDLE __MIDL_itf_comcat_0000_0002_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_comcat_0000_0002_v0_0_s_ifspec;

#ifndef __ICatRegister_INTERFACE_DEFINED__
#define __ICatRegister_INTERFACE_DEFINED__

/* interface ICatRegister */
/* [unique][uuid][object] */ 

typedef /* [unique] */  __RPC_unique_pointer ICatRegister *LPCATREGISTER;


EXTERN_C const IID IID_ICatRegister;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("0002E012-0000-0000-C000-000000000046")
    ICatRegister : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE RegisterCategories( 
            /* [in] */ ULONG cCategories,
            /* [size_is][in] */ __RPC__in_ecount_full(cCategories) CATEGORYINFO rgCategoryInfo[  ]) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE UnRegisterCategories( 
            /* [in] */ ULONG cCategories,
            /* [size_is][in] */ __RPC__in_ecount_full(cCategories) CATID rgcatid[  ]) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE RegisterClassImplCategories( 
            /* [in] */ __RPC__in REFCLSID rclsid,
            /* [in] */ ULONG cCategories,
            /* [size_is][in] */ __RPC__in_ecount_full(cCategories) CATID rgcatid[  ]) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE UnRegisterClassImplCategories( 
            /* [in] */ __RPC__in REFCLSID rclsid,
            /* [in] */ ULONG cCategories,
            /* [size_is][in] */ __RPC__in_ecount_full(cCategories) CATID rgcatid[  ]) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE RegisterClassReqCategories( 
            /* [in] */ __RPC__in REFCLSID rclsid,
            /* [in] */ ULONG cCategories,
            /* [size_is][in] */ __RPC__in_ecount_full(cCategories) CATID rgcatid[  ]) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE UnRegisterClassReqCategories( 
            /* [in] */ __RPC__in REFCLSID rclsid,
            /* [in] */ ULONG cCategories,
            /* [size_is][in] */ __RPC__in_ecount_full(cCategories) CATID rgcatid[  ]) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct ICatRegisterVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            ICatRegister * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            ICatRegister * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            ICatRegister * This);
        
        HRESULT ( STDMETHODCALLTYPE *RegisterCategories )( 
            ICatRegister * This,
            /* [in] */ ULONG cCategories,
            /* [size_is][in] */ __RPC__in_ecount_full(cCategories) CATEGORYINFO rgCategoryInfo[  ]);
        
        HRESULT ( STDMETHODCALLTYPE *UnRegisterCategories )( 
            ICatRegister * This,
            /* [in] */ ULONG cCategories,
            /* [size_is][in] */ __RPC__in_ecount_full(cCategories) CATID rgcatid[  ]);
        
        HRESULT ( STDMETHODCALLTYPE *RegisterClassImplCategories )( 
            ICatRegister * This,
            /* [in] */ __RPC__in REFCLSID rclsid,
            /* [in] */ ULONG cCategories,
            /* [size_is][in] */ __RPC__in_ecount_full(cCategories) CATID rgcatid[  ]);
        
        HRESULT ( STDMETHODCALLTYPE *UnRegisterClassImplCategories )( 
            ICatRegister * This,
            /* [in] */ __RPC__in REFCLSID rclsid,
            /* [in] */ ULONG cCategories,
            /* [size_is][in] */ __RPC__in_ecount_full(cCategories) CATID rgcatid[  ]);
        
        HRESULT ( STDMETHODCALLTYPE *RegisterClassReqCategories )( 
            ICatRegister * This,
            /* [in] */ __RPC__in REFCLSID rclsid,
            /* [in] */ ULONG cCategories,
            /* [size_is][in] */ __RPC__in_ecount_full(cCategories) CATID rgcatid[  ]);
        
        HRESULT ( STDMETHODCALLTYPE *UnRegisterClassReqCategories )( 
            ICatRegister * This,
            /* [in] */ __RPC__in REFCLSID rclsid,
            /* [in] */ ULONG cCategories,
            /* [size_is][in] */ __RPC__in_ecount_full(cCategories) CATID rgcatid[  ]);
        
        END_INTERFACE
    } ICatRegisterVtbl;

    interface ICatRegister
    {
        CONST_VTBL struct ICatRegisterVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define ICatRegister_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define ICatRegister_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define ICatRegister_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define ICatRegister_RegisterCategories(This,cCategories,rgCategoryInfo)	\
    ( (This)->lpVtbl -> RegisterCategories(This,cCategories,rgCategoryInfo) ) 

#define ICatRegister_UnRegisterCategories(This,cCategories,rgcatid)	\
    ( (This)->lpVtbl -> UnRegisterCategories(This,cCategories,rgcatid) ) 

#define ICatRegister_RegisterClassImplCategories(This,rclsid,cCategories,rgcatid)	\
    ( (This)->lpVtbl -> RegisterClassImplCategories(This,rclsid,cCategories,rgcatid) ) 

#define ICatRegister_UnRegisterClassImplCategories(This,rclsid,cCategories,rgcatid)	\
    ( (This)->lpVtbl -> UnRegisterClassImplCategories(This,rclsid,cCategories,rgcatid) ) 

#define ICatRegister_RegisterClassReqCategories(This,rclsid,cCategories,rgcatid)	\
    ( (This)->lpVtbl -> RegisterClassReqCategories(This,rclsid,cCategories,rgcatid) ) 

#define ICatRegister_UnRegisterClassReqCategories(This,rclsid,cCategories,rgcatid)	\
    ( (This)->lpVtbl -> UnRegisterClassReqCategories(This,rclsid,cCategories,rgcatid) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __ICatRegister_INTERFACE_DEFINED__ */


/* interface __MIDL_itf_comcat_0000_0003 */
/* [local] */ 

#endif
#ifndef _LPCATINFORMATION_DEFINED
#define _LPCATINFORMATION_DEFINED


extern RPC_IF_HANDLE __MIDL_itf_comcat_0000_0003_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_comcat_0000_0003_v0_0_s_ifspec;

#ifndef __ICatInformation_INTERFACE_DEFINED__
#define __ICatInformation_INTERFACE_DEFINED__

/* interface ICatInformation */
/* [unique][uuid][object] */ 

typedef /* [unique] */  __RPC_unique_pointer ICatInformation *LPCATINFORMATION;


EXTERN_C const IID IID_ICatInformation;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("0002E013-0000-0000-C000-000000000046")
    ICatInformation : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE EnumCategories( 
            /* [in] */ LCID lcid,
            /* [out] */ __RPC__deref_out_opt IEnumCATEGORYINFO **ppenumCategoryInfo) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetCategoryDesc( 
            /* [in] */ __RPC__in REFCATID rcatid,
            /* [in] */ LCID lcid,
            /* [out] */ __RPC__deref_out_opt LPWSTR *pszDesc) = 0;
        
        virtual /* [local] */ HRESULT STDMETHODCALLTYPE EnumClassesOfCategories( 
            /* [in] */ ULONG cImplemented,
            /* [size_is][in] */ const CATID rgcatidImpl[  ],
            /* [in] */ ULONG cRequired,
            /* [size_is][in] */ const CATID rgcatidReq[  ],
            /* [out] */ IEnumGUID **ppenumClsid) = 0;
        
        virtual /* [local] */ HRESULT STDMETHODCALLTYPE IsClassOfCategories( 
            /* [in] */ REFCLSID rclsid,
            /* [in] */ ULONG cImplemented,
            /* [size_is][in] */ const CATID rgcatidImpl[  ],
            /* [in] */ ULONG cRequired,
            /* [size_is][in] */ const CATID rgcatidReq[  ]) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE EnumImplCategoriesOfClass( 
            /* [in] */ __RPC__in REFCLSID rclsid,
            /* [out] */ __RPC__deref_out_opt IEnumGUID **ppenumCatid) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE EnumReqCategoriesOfClass( 
            /* [in] */ __RPC__in REFCLSID rclsid,
            /* [out] */ __RPC__deref_out_opt IEnumGUID **ppenumCatid) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct ICatInformationVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            ICatInformation * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            ICatInformation * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            ICatInformation * This);
        
        HRESULT ( STDMETHODCALLTYPE *EnumCategories )( 
            ICatInformation * This,
            /* [in] */ LCID lcid,
            /* [out] */ __RPC__deref_out_opt IEnumCATEGORYINFO **ppenumCategoryInfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetCategoryDesc )( 
            ICatInformation * This,
            /* [in] */ __RPC__in REFCATID rcatid,
            /* [in] */ LCID lcid,
            /* [out] */ __RPC__deref_out_opt LPWSTR *pszDesc);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE *EnumClassesOfCategories )( 
            ICatInformation * This,
            /* [in] */ ULONG cImplemented,
            /* [size_is][in] */ const CATID rgcatidImpl[  ],
            /* [in] */ ULONG cRequired,
            /* [size_is][in] */ const CATID rgcatidReq[  ],
            /* [out] */ IEnumGUID **ppenumClsid);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE *IsClassOfCategories )( 
            ICatInformation * This,
            /* [in] */ REFCLSID rclsid,
            /* [in] */ ULONG cImplemented,
            /* [size_is][in] */ const CATID rgcatidImpl[  ],
            /* [in] */ ULONG cRequired,
            /* [size_is][in] */ const CATID rgcatidReq[  ]);
        
        HRESULT ( STDMETHODCALLTYPE *EnumImplCategoriesOfClass )( 
            ICatInformation * This,
            /* [in] */ __RPC__in REFCLSID rclsid,
            /* [out] */ __RPC__deref_out_opt IEnumGUID **ppenumCatid);
        
        HRESULT ( STDMETHODCALLTYPE *EnumReqCategoriesOfClass )( 
            ICatInformation * This,
            /* [in] */ __RPC__in REFCLSID rclsid,
            /* [out] */ __RPC__deref_out_opt IEnumGUID **ppenumCatid);
        
        END_INTERFACE
    } ICatInformationVtbl;

    interface ICatInformation
    {
        CONST_VTBL struct ICatInformationVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define ICatInformation_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define ICatInformation_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define ICatInformation_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define ICatInformation_EnumCategories(This,lcid,ppenumCategoryInfo)	\
    ( (This)->lpVtbl -> EnumCategories(This,lcid,ppenumCategoryInfo) ) 

#define ICatInformation_GetCategoryDesc(This,rcatid,lcid,pszDesc)	\
    ( (This)->lpVtbl -> GetCategoryDesc(This,rcatid,lcid,pszDesc) ) 

#define ICatInformation_EnumClassesOfCategories(This,cImplemented,rgcatidImpl,cRequired,rgcatidReq,ppenumClsid)	\
    ( (This)->lpVtbl -> EnumClassesOfCategories(This,cImplemented,rgcatidImpl,cRequired,rgcatidReq,ppenumClsid) ) 

#define ICatInformation_IsClassOfCategories(This,rclsid,cImplemented,rgcatidImpl,cRequired,rgcatidReq)	\
    ( (This)->lpVtbl -> IsClassOfCategories(This,rclsid,cImplemented,rgcatidImpl,cRequired,rgcatidReq) ) 

#define ICatInformation_EnumImplCategoriesOfClass(This,rclsid,ppenumCatid)	\
    ( (This)->lpVtbl -> EnumImplCategoriesOfClass(This,rclsid,ppenumCatid) ) 

#define ICatInformation_EnumReqCategoriesOfClass(This,rclsid,ppenumCatid)	\
    ( (This)->lpVtbl -> EnumReqCategoriesOfClass(This,rclsid,ppenumCatid) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [call_as] */ HRESULT STDMETHODCALLTYPE ICatInformation_RemoteEnumClassesOfCategories_Proxy( 
    ICatInformation * This,
    /* [in] */ ULONG cImplemented,
    /* [size_is][unique][in] */ __RPC__in_ecount_full_opt(cImplemented) const CATID rgcatidImpl[  ],
    /* [in] */ ULONG cRequired,
    /* [size_is][unique][in] */ __RPC__in_ecount_full_opt(cRequired) const CATID rgcatidReq[  ],
    /* [out] */ __RPC__deref_out_opt IEnumGUID **ppenumClsid);


void __RPC_STUB ICatInformation_RemoteEnumClassesOfCategories_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [call_as] */ HRESULT STDMETHODCALLTYPE ICatInformation_RemoteIsClassOfCategories_Proxy( 
    ICatInformation * This,
    /* [in] */ __RPC__in REFCLSID rclsid,
    /* [in] */ ULONG cImplemented,
    /* [size_is][unique][in] */ __RPC__in_ecount_full_opt(cImplemented) const CATID rgcatidImpl[  ],
    /* [in] */ ULONG cRequired,
    /* [size_is][unique][in] */ __RPC__in_ecount_full_opt(cRequired) const CATID rgcatidReq[  ]);


void __RPC_STUB ICatInformation_RemoteIsClassOfCategories_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __ICatInformation_INTERFACE_DEFINED__ */


/* interface __MIDL_itf_comcat_0000_0004 */
/* [local] */ 

#endif


extern RPC_IF_HANDLE __MIDL_itf_comcat_0000_0004_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_comcat_0000_0004_v0_0_s_ifspec;

/* Additional Prototypes for ALL interfaces */

/* [local] */ HRESULT STDMETHODCALLTYPE ICatInformation_EnumClassesOfCategories_Proxy( 
    ICatInformation * This,
    /* [in] */ ULONG cImplemented,
    /* [size_is][in] */ const CATID rgcatidImpl[  ],
    /* [in] */ ULONG cRequired,
    /* [size_is][in] */ const CATID rgcatidReq[  ],
    /* [out] */ IEnumGUID **ppenumClsid);


/* [call_as] */ HRESULT STDMETHODCALLTYPE ICatInformation_EnumClassesOfCategories_Stub( 
    ICatInformation * This,
    /* [in] */ ULONG cImplemented,
    /* [size_is][unique][in] */ __RPC__in_ecount_full_opt(cImplemented) const CATID rgcatidImpl[  ],
    /* [in] */ ULONG cRequired,
    /* [size_is][unique][in] */ __RPC__in_ecount_full_opt(cRequired) const CATID rgcatidReq[  ],
    /* [out] */ __RPC__deref_out_opt IEnumGUID **ppenumClsid);

/* [local] */ HRESULT STDMETHODCALLTYPE ICatInformation_IsClassOfCategories_Proxy( 
    ICatInformation * This,
    /* [in] */ REFCLSID rclsid,
    /* [in] */ ULONG cImplemented,
    /* [size_is][in] */ const CATID rgcatidImpl[  ],
    /* [in] */ ULONG cRequired,
    /* [size_is][in] */ const CATID rgcatidReq[  ]);


/* [call_as] */ HRESULT STDMETHODCALLTYPE ICatInformation_IsClassOfCategories_Stub( 
    ICatInformation * This,
    /* [in] */ __RPC__in REFCLSID rclsid,
    /* [in] */ ULONG cImplemented,
    /* [size_is][unique][in] */ __RPC__in_ecount_full_opt(cImplemented) const CATID rgcatidImpl[  ],
    /* [in] */ ULONG cRequired,
    /* [size_is][unique][in] */ __RPC__in_ecount_full_opt(cRequired) const CATID rgcatidReq[  ]);



/* end of Additional Prototypes */

#ifdef __cplusplus
}
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\vs9sp1\sdk\include\Codecs.h ===
//****************************************************************************
//  File: CODECS.H
//  Content:    
//              
//
//  Copyright (c) Microsoft Corporation 1999-2002.  All Rights Reserved
//
// THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF 
// ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO 
// THE IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A 
// PARTICULAR PURPOSE.
//****************************************************************************

#include <pshpack8.h> /* Assume 8 byte packing throughout */
#include "appavcap.h"

/*
 *	Constants
 */

// hresult codes, facility IC = 0x301
#define IC_E_CAPS_INSTANTIATION_FAILURE		0x83010001	// could not instantiate a required caps object
#define IC_E_CAPS_INITIALIZATION_FAILURE	0x83010002	// could not initialize a required bject
#define IC_E_NO_FORMATS						0x83010003	// no formats available
#define IC_E_NO_SUCH_FORMAT					0x83010005	// no matching AC</VCM format was found
#define IC_E_INTERNAL_ERROR					0x83010006	// the Network Audio/Video Controller
														// reported a system error

/*
 *	Macros
 */

/*
 *	Data Structures
 */

/*
 *	Functions
 */

/*
 *	Interfaces
 */

#ifndef DECLARE_INTERFACE_PTR
#ifdef __cplusplus
#define DECLARE_INTERFACE_PTR(iface, piface)                       \
	interface iface; typedef iface FAR * piface
#else
#define DECLARE_INTERFACE_PTR(iface, piface)                       \
	typedef interface iface iface, FAR * piface
#endif
#endif /* DECLARE_INTERFACE_PTR */


#define IUNKNOWN_METHODS(IPURE)										\
    STDMETHOD (QueryInterface)                                      \
        (THIS_ REFIID riid, LPVOID FAR * ppvObj) IPURE;				\
    STDMETHOD_(ULONG,AddRef)  (THIS) IPURE;							\
    STDMETHOD_(ULONG,Release) (THIS) IPURE;							\

#define IINSTALLAUDIOCODECS_METHODS(IPURE)							\
	STDMETHOD(AddACMFormat)											\
		(THIS_ LPWAVEFORMATEX lpwfx, PAUDCAP_INFO pAudCapInfo) IPURE;	\
	STDMETHOD (RemoveACMFormat)										\
		(THIS_ LPWAVEFORMATEX lpwfx) IPURE;	\
	STDMETHOD (ReorderFormats)										\
		(THIS_ PAUDCAP_INFO_LIST pAudCapInfoList) IPURE;			\
	STDMETHOD (EnumFormats)											\
		(THIS_ PAUDCAP_INFO_LIST *ppAudCapInfoList) IPURE;	\
	STDMETHOD (FreeBuffer) (THIS_ LPVOID lpBuffer) IPURE;			\

#define IINSTALLVIDEOCODECS_METHODS(IPURE)							\
	STDMETHOD(AddVCMFormat)											\
		(THIS_ PVIDCAP_INFO pVidCapInfo) IPURE;	\
	STDMETHOD (RemoveVCMFormat)										\
		(THIS_ PVIDCAP_INFO pVidCapInfo) IPURE;	\
	STDMETHOD (ReorderFormats)										\
		(THIS_ PVIDCAP_INFO_LIST pVidCapInfoList) IPURE;			\
	STDMETHOD (EnumFormats)											\
		(THIS_ PVIDCAP_INFO_LIST *ppVidCapInfoList) IPURE;	\
	STDMETHOD (FreeBuffer) (THIS_ LPVOID lpBuffer) IPURE;			\

// IInstallAudioCodecs
#undef       INTERFACE
#define      INTERFACE  IInstallAudioCodecs
DECLARE_INTERFACE_(IInstallAudioCodecs, IUnknown)
{
    IUNKNOWN_METHODS(PURE)
	IINSTALLAUDIOCODECS_METHODS(PURE)
};
DECLARE_INTERFACE_PTR(IInstallAudioCodecs, LPINSTALLAUDIOCODECS);

// IInstallVideooCodecs
#undef       INTERFACE
#define      INTERFACE  IInstallVideoCodecs
DECLARE_INTERFACE_(IInstallVideoCodecs, IUnknown)
{
    IUNKNOWN_METHODS(PURE)
	IINSTALLVIDEOCODECS_METHODS(PURE)
};
DECLARE_INTERFACE_PTR(IInstallVideoCodecs, LPINSTALLVIDEOCODECS);

// IInstallAudioCodecs
#undef       INTERFACE
#define      INTERFACE  IInstallCodecs
DECLARE_INTERFACE_(IInstallCodecs, IUnknown)
{
    IUNKNOWN_METHODS(PURE)
};
DECLARE_INTERFACE_PTR(IInstallCodecs, LPINSTALLCODECS);

EXTERN_C HRESULT WINAPI CreateInstallCodecs (
								IUnknown *punkOuter,
								REFIID riid,
								void **ppv);

typedef HRESULT (WINAPI *PFNCREATEINSTALLCODECS)
				(IUnknown *punkOuter, REFIID riid, void **ppv);


// {8ED14CC0-7A1F-11d0-92F6-00A0C922E6B2}
DEFINE_GUID(CLSID_InstallCodecs, 0x8ed14cc0, 0x7a1f, 0x11d0, 0x92, 0xf6, 0x0, 0xa0, 0xc9, 0x22, 0xe6, 0xb2);
// {8ED14CC1-7A1F-11d0-92F6-00A0C922E6B2}
DEFINE_GUID(IID_IInstallCodecs, 0x8ed14cc1, 0x7a1f, 0x11d0, 0x92, 0xf6, 0x0, 0xa0, 0xc9, 0x22, 0xe6, 0xb2);
// {8ED14CC2-7A1F-11d0-92F6-00A0C922E6B2}
DEFINE_GUID(IID_IInstallAudioCodecs, 0x8ed14cc2, 0x7a1f, 0x11d0, 0x92, 0xf6, 0x0, 0xa0, 0xc9, 0x22, 0xe6, 0xb2);
// {8ED14CC3-7A1F-11d0-92F6-00A0C922E6B2}
DEFINE_GUID(IID_IInstallVideoCodecs, 0x8ed14cc3, 0x7a1f, 0x11d0, 0x92, 0xf6, 0x0, 0xa0, 0xc9, 0x22, 0xe6, 0xb2);

#include <poppack.h> /* End byte packing */
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\vs9sp1\sdk\include\CommDlg.h ===
/************************************************************************
*                                                                       *
*   commdlg.h -- This module defines the 32-Bit Common Dialog APIs      *
*                                                                       *
*   Copyright (c) Microsoft Corporation. All rights reserved.           *
*                                                                       *
************************************************************************/


#ifndef _INC_COMMDLG
#define _INC_COMMDLG


#if(WINVER >= 0x0500)

#ifdef DEFINE_GUID

//
//  IPrintDialogCallback interface id used by PrintDlgEx.
//
//  {5852A2C3-6530-11D1-B6A3-0000F8757BF9}
//
DEFINE_GUID(IID_IPrintDialogCallback, 0x5852a2c3, 0x6530, 0x11d1, 0xb6, 0xa3, 0x0, 0x0, 0xf8, 0x75, 0x7b, 0xf9);

//
//  IPrintDialogServices interface id used by PrintDlgEx.
//
//  {509AAEDA-5639-11D1-B6A1-0000F8757BF9}
//
DEFINE_GUID(IID_IPrintDialogServices, 0x509aaeda, 0x5639, 0x11d1, 0xb6, 0xa1, 0x0, 0x0, 0xf8, 0x75, 0x7b, 0xf9);

#endif

#endif /* WINVER >= 0x0500 */


#ifndef GUID_DEFS_ONLY

#include <prsht.h>

#if !defined(_WIN64)
#include <pshpack1.h>         /* Assume byte packing throughout */
#endif

#ifdef __cplusplus
extern "C" {            /* Assume C declarations for C++ */
#endif  /* __cplusplus */

//
// Define API decoration for direct importing of DLL references.
//
#ifndef WINCOMMDLGAPI
#if !defined(_COMDLG32_)
#define WINCOMMDLGAPI DECLSPEC_IMPORT
#else
#define WINCOMMDLGAPI
#endif
#endif // WINCOMMDLGAPI


#if(WINVER >= 0x0400)
#ifndef SNDMSG
#ifdef __cplusplus
#ifndef _MAC
#define SNDMSG ::SendMessage
#else
#define SNDMSG ::AfxSendMessage
#endif
#else   /* __cplusplus */
#ifndef _MAC
#define SNDMSG SendMessage
#else
#define SNDMSG AfxSendMessage
#endif
#endif  /* __cplusplus */
#endif  // ifndef SNDMSG
#endif /* WINVER >= 0x0400 */

#ifdef _MAC
typedef struct tagEDITMENU
{
   HMENU   hmenu;
   WORD    idEdit;
   WORD    idCut;
   WORD    idCopy;
   WORD    idPaste;
   WORD    idClear;
   WORD    idUndo;
} EDITMENU;
typedef EDITMENU *LPEDITMENU;
#endif

typedef UINT_PTR (CALLBACK *LPOFNHOOKPROC) (HWND, UINT, WPARAM, LPARAM);


#ifndef CDSIZEOF_STRUCT
#define CDSIZEOF_STRUCT(structname, member)  (((int)((LPBYTE)(&((structname*)0)->member) - ((LPBYTE)((structname*)0)))) + sizeof(((structname*)0)->member))
#endif

//
// For compilers that don't support nameless unions
//
#ifndef DUMMYUNIONNAME
#ifdef NONAMELESSUNION
#define DUMMYUNIONNAME   u
#endif // NONAMELESSUNION
#endif // DUMMYUNIONNAME

typedef struct tagOFN_NT4A {
   DWORD        lStructSize;
   HWND         hwndOwner;
   HINSTANCE    hInstance;
   LPCSTR       lpstrFilter;
   LPSTR        lpstrCustomFilter;
   DWORD        nMaxCustFilter;
   DWORD        nFilterIndex;
   LPSTR        lpstrFile;
   DWORD        nMaxFile;
   LPSTR        lpstrFileTitle;
   DWORD        nMaxFileTitle;
   LPCSTR       lpstrInitialDir;
   LPCSTR       lpstrTitle;
   DWORD        Flags;
   WORD         nFileOffset;
   WORD         nFileExtension;
   LPCSTR       lpstrDefExt;
   LPARAM       lCustData;
   LPOFNHOOKPROC lpfnHook;
   LPCSTR       lpTemplateName;
} OPENFILENAME_NT4A, *LPOPENFILENAME_NT4A;
typedef struct tagOFN_NT4W {
   DWORD        lStructSize;
   HWND         hwndOwner;
   HINSTANCE    hInstance;
   LPCWSTR      lpstrFilter;
   LPWSTR       lpstrCustomFilter;
   DWORD        nMaxCustFilter;
   DWORD        nFilterIndex;
   LPWSTR       lpstrFile;
   DWORD        nMaxFile;
   LPWSTR       lpstrFileTitle;
   DWORD        nMaxFileTitle;
   LPCWSTR      lpstrInitialDir;
   LPCWSTR      lpstrTitle;
   DWORD        Flags;
   WORD         nFileOffset;
   WORD         nFileExtension;
   LPCWSTR      lpstrDefExt;
   LPARAM       lCustData;
   LPOFNHOOKPROC lpfnHook;
   LPCWSTR      lpTemplateName;
} OPENFILENAME_NT4W, *LPOPENFILENAME_NT4W;
#ifdef UNICODE
typedef OPENFILENAME_NT4W OPENFILENAME_NT4;
typedef LPOPENFILENAME_NT4W LPOPENFILENAME_NT4;
#else
typedef OPENFILENAME_NT4A OPENFILENAME_NT4;
typedef LPOPENFILENAME_NT4A LPOPENFILENAME_NT4;
#endif // UNICODE

typedef struct tagOFNA {
   DWORD        lStructSize;
   HWND         hwndOwner;
   HINSTANCE    hInstance;
   LPCSTR       lpstrFilter;
   LPSTR        lpstrCustomFilter;
   DWORD        nMaxCustFilter;
   DWORD        nFilterIndex;
   LPSTR        lpstrFile;
   DWORD        nMaxFile;
   LPSTR        lpstrFileTitle;
   DWORD        nMaxFileTitle;
   LPCSTR       lpstrInitialDir;
   LPCSTR       lpstrTitle;
   DWORD        Flags;
   WORD         nFileOffset;
   WORD         nFileExtension;
   LPCSTR       lpstrDefExt;
   LPARAM       lCustData;
   LPOFNHOOKPROC lpfnHook;
   LPCSTR       lpTemplateName;
#ifdef _MAC
   LPEDITMENU   lpEditInfo;
   LPCSTR       lpstrPrompt;
#endif
#if (_WIN32_WINNT >= 0x0500)
   void *        pvReserved;
   DWORD        dwReserved;
   DWORD        FlagsEx;
#endif // (_WIN32_WINNT >= 0x0500)
} OPENFILENAMEA, *LPOPENFILENAMEA;
typedef struct tagOFNW {
   DWORD        lStructSize;
   HWND         hwndOwner;
   HINSTANCE    hInstance;
   LPCWSTR      lpstrFilter;
   LPWSTR       lpstrCustomFilter;
   DWORD        nMaxCustFilter;
   DWORD        nFilterIndex;
   LPWSTR       lpstrFile;
   DWORD        nMaxFile;
   LPWSTR       lpstrFileTitle;
   DWORD        nMaxFileTitle;
   LPCWSTR      lpstrInitialDir;
   LPCWSTR      lpstrTitle;
   DWORD        Flags;
   WORD         nFileOffset;
   WORD         nFileExtension;
   LPCWSTR      lpstrDefExt;
   LPARAM       lCustData;
   LPOFNHOOKPROC lpfnHook;
   LPCWSTR      lpTemplateName;
#ifdef _MAC
   LPEDITMENU   lpEditInfo;
   LPCSTR       lpstrPrompt;
#endif
#if (_WIN32_WINNT >= 0x0500)
   void *        pvReserved;
   DWORD        dwReserved;
   DWORD        FlagsEx;
#endif // (_WIN32_WINNT >= 0x0500)
} OPENFILENAMEW, *LPOPENFILENAMEW;
#ifdef UNICODE
typedef OPENFILENAMEW OPENFILENAME;
typedef LPOPENFILENAMEW LPOPENFILENAME;
#else
typedef OPENFILENAMEA OPENFILENAME;
typedef LPOPENFILENAMEA LPOPENFILENAME;
#endif // UNICODE

#if (_WIN32_WINNT >= 0x0500)
#define OPENFILENAME_SIZE_VERSION_400A  CDSIZEOF_STRUCT(OPENFILENAMEA,lpTemplateName)
#define OPENFILENAME_SIZE_VERSION_400W  CDSIZEOF_STRUCT(OPENFILENAMEW,lpTemplateName)
#ifdef UNICODE
#define OPENFILENAME_SIZE_VERSION_400  OPENFILENAME_SIZE_VERSION_400W
#else
#define OPENFILENAME_SIZE_VERSION_400  OPENFILENAME_SIZE_VERSION_400A
#endif // !UNICODE
#endif // (_WIN32_WINNT >= 0x0500)


WINCOMMDLGAPI BOOL  APIENTRY GetOpenFileNameA(LPOPENFILENAMEA);
WINCOMMDLGAPI BOOL  APIENTRY GetOpenFileNameW(LPOPENFILENAMEW);
#ifdef UNICODE
#define GetOpenFileName  GetOpenFileNameW
#else
#define GetOpenFileName  GetOpenFileNameA
#endif // !UNICODE
WINCOMMDLGAPI BOOL  APIENTRY GetSaveFileNameA(LPOPENFILENAMEA);
WINCOMMDLGAPI BOOL  APIENTRY GetSaveFileNameW(LPOPENFILENAMEW);
#ifdef UNICODE
#define GetSaveFileName  GetSaveFileNameW
#else
#define GetSaveFileName  GetSaveFileNameA
#endif // !UNICODE


WINCOMMDLGAPI short APIENTRY GetFileTitleA(LPCSTR, __out_ecount(cchSize) LPSTR Buf, __in WORD cchSize);
WINCOMMDLGAPI short APIENTRY GetFileTitleW(LPCWSTR, __out_ecount(cchSize) LPWSTR Buf, __in WORD cchSize);
#ifdef UNICODE
#define GetFileTitle  GetFileTitleW
#else
#define GetFileTitle  GetFileTitleA
#endif // !UNICODE

#define OFN_READONLY                 0x00000001
#define OFN_OVERWRITEPROMPT          0x00000002
#define OFN_HIDEREADONLY             0x00000004
#define OFN_NOCHANGEDIR              0x00000008
#define OFN_SHOWHELP                 0x00000010
#define OFN_ENABLEHOOK               0x00000020
#define OFN_ENABLETEMPLATE           0x00000040
#define OFN_ENABLETEMPLATEHANDLE     0x00000080
#define OFN_NOVALIDATE               0x00000100
#define OFN_ALLOWMULTISELECT         0x00000200
#define OFN_EXTENSIONDIFFERENT       0x00000400
#define OFN_PATHMUSTEXIST            0x00000800
#define OFN_FILEMUSTEXIST            0x00001000
#define OFN_CREATEPROMPT             0x00002000
#define OFN_SHAREAWARE               0x00004000
#define OFN_NOREADONLYRETURN         0x00008000
#define OFN_NOTESTFILECREATE         0x00010000
#define OFN_NONETWORKBUTTON          0x00020000
#define OFN_NOLONGNAMES              0x00040000     // force no long names for 4.x modules
#if(WINVER >= 0x0400)
#define OFN_EXPLORER                 0x00080000     // new look commdlg
#define OFN_NODEREFERENCELINKS       0x00100000
#define OFN_LONGNAMES                0x00200000     // force long names for 3.x modules
// OFN_ENABLEINCLUDENOTIFY and OFN_ENABLESIZING require
// Windows 2000 or higher to have any effect.
#define OFN_ENABLEINCLUDENOTIFY      0x00400000     // send include message to callback
#define OFN_ENABLESIZING             0x00800000
#endif /* WINVER >= 0x0400 */
#if (_WIN32_WINNT >= 0x0500)
#define OFN_DONTADDTORECENT          0x02000000
#define OFN_FORCESHOWHIDDEN          0x10000000    // Show All files including System and hidden files
#endif // (_WIN32_WINNT >= 0x0500)

//FlagsEx Values
#if (_WIN32_WINNT >= 0x0500)
#define  OFN_EX_NOPLACESBAR         0x00000001
#endif // (_WIN32_WINNT >= 0x0500)

// Return values for the registered message sent to the hook function
// when a sharing violation occurs.  OFN_SHAREFALLTHROUGH allows the
// filename to be accepted, OFN_SHARENOWARN rejects the name but puts
// up no warning (returned when the app has already put up a warning
// message), and OFN_SHAREWARN puts up the default warning message
// for sharing violations.
//
// Note:  Undefined return values map to OFN_SHAREWARN, but are
//        reserved for future use.

#define OFN_SHAREFALLTHROUGH     2
#define OFN_SHARENOWARN          1
#define OFN_SHAREWARN            0

typedef UINT_PTR (CALLBACK *LPCCHOOKPROC) (HWND, UINT, WPARAM, LPARAM);

#if(WINVER >= 0x0400)
// Structure used for all file based OpenFileName notifications
typedef struct _OFNOTIFYA
{
        NMHDR           hdr;
        LPOPENFILENAMEA lpOFN;
        LPSTR           pszFile;        // May be NULL
} OFNOTIFYA, *LPOFNOTIFYA;
// Structure used for all file based OpenFileName notifications
typedef struct _OFNOTIFYW
{
        NMHDR           hdr;
        LPOPENFILENAMEW lpOFN;
        LPWSTR          pszFile;        // May be NULL
} OFNOTIFYW, *LPOFNOTIFYW;
#ifdef UNICODE
typedef OFNOTIFYW OFNOTIFY;
typedef LPOFNOTIFYW LPOFNOTIFY;
#else
typedef OFNOTIFYA OFNOTIFY;
typedef LPOFNOTIFYA LPOFNOTIFY;
#endif // UNICODE


// Structure used for all object based OpenFileName notifications
typedef struct _OFNOTIFYEXA
{
        NMHDR           hdr;
        LPOPENFILENAMEA lpOFN;
        LPVOID          psf;
        LPVOID          pidl;          // May be NULL
} OFNOTIFYEXA, *LPOFNOTIFYEXA;
// Structure used for all object based OpenFileName notifications
typedef struct _OFNOTIFYEXW
{
        NMHDR           hdr;
        LPOPENFILENAMEW lpOFN;
        LPVOID          psf;
        LPVOID          pidl;          // May be NULL
} OFNOTIFYEXW, *LPOFNOTIFYEXW;
#ifdef UNICODE
typedef OFNOTIFYEXW OFNOTIFYEX;
typedef LPOFNOTIFYEXW LPOFNOTIFYEX;
#else
typedef OFNOTIFYEXA OFNOTIFYEX;
typedef LPOFNOTIFYEXA LPOFNOTIFYEX;
#endif // UNICODE


#define CDN_FIRST   (0U-601U)
#define CDN_LAST    (0U-699U)

// Notifications from Open or Save dialog
#define CDN_INITDONE            (CDN_FIRST - 0x0000)
#define CDN_SELCHANGE           (CDN_FIRST - 0x0001)
#define CDN_FOLDERCHANGE        (CDN_FIRST - 0x0002)
#define CDN_SHAREVIOLATION      (CDN_FIRST - 0x0003)
#define CDN_HELP                (CDN_FIRST - 0x0004)
#define CDN_FILEOK              (CDN_FIRST - 0x0005)
#define CDN_TYPECHANGE          (CDN_FIRST - 0x0006)
#if (NTDDI_VERSION >= NTDDI_WIN2K)
#define CDN_INCLUDEITEM         (CDN_FIRST - 0x0007)
#endif // (NTDDI_VERSION >= NTDDI_WIN2K)


#define CDM_FIRST       (WM_USER + 100)
#define CDM_LAST        (WM_USER + 200)

// Messages to query information from the Open or Save dialogs

// lParam = pointer to text buffer that gets filled in
// wParam = max number of characters of the text buffer (including NULL)
// return = < 0 if error; number of characters needed (including NULL)
#define CDM_GETSPEC             (CDM_FIRST + 0x0000)
#define CommDlg_OpenSave_GetSpecA(_hdlg, _psz, _cbmax) \
        (int)SNDMSG(_hdlg, CDM_GETSPEC, (WPARAM)(_cbmax), (LPARAM)(LPSTR)(_psz))
#define CommDlg_OpenSave_GetSpecW(_hdlg, _psz, _cbmax) \
        (int)SNDMSG(_hdlg, CDM_GETSPEC, (WPARAM)(_cbmax), (LPARAM)(LPWSTR)(_psz))
#ifdef UNICODE
#define CommDlg_OpenSave_GetSpec  CommDlg_OpenSave_GetSpecW
#else
#define CommDlg_OpenSave_GetSpec  CommDlg_OpenSave_GetSpecA
#endif // !UNICODE

// lParam = pointer to text buffer that gets filled in
// wParam = max number of characters of the text buffer (including NULL)
// return = < 0 if error; number of characters needed (including NULL)
#define CDM_GETFILEPATH         (CDM_FIRST + 0x0001)
#define CommDlg_OpenSave_GetFilePathA(_hdlg, _psz, _cbmax) \
        (int)SNDMSG(_hdlg, CDM_GETFILEPATH, (WPARAM)(_cbmax), (LPARAM)(LPSTR)(_psz))
#define CommDlg_OpenSave_GetFilePathW(_hdlg, _psz, _cbmax) \
        (int)SNDMSG(_hdlg, CDM_GETFILEPATH, (WPARAM)(_cbmax), (LPARAM)(LPWSTR)(_psz))
#ifdef UNICODE
#define CommDlg_OpenSave_GetFilePath  CommDlg_OpenSave_GetFilePathW
#else
#define CommDlg_OpenSave_GetFilePath  CommDlg_OpenSave_GetFilePathA
#endif // !UNICODE

// lParam = pointer to text buffer that gets filled in
// wParam = max number of characters of the text buffer (including NULL)
// return = < 0 if error; number of characters needed (including NULL)
#define CDM_GETFOLDERPATH       (CDM_FIRST + 0x0002)
#define CommDlg_OpenSave_GetFolderPathA(_hdlg, _psz, _cbmax) \
        (int)SNDMSG(_hdlg, CDM_GETFOLDERPATH, (WPARAM)(_cbmax), (LPARAM)(LPSTR)(_psz))
#define CommDlg_OpenSave_GetFolderPathW(_hdlg, _psz, _cbmax) \
        (int)SNDMSG(_hdlg, CDM_GETFOLDERPATH, (WPARAM)(_cbmax), (LPARAM)(LPWSTR)(_psz))
#ifdef UNICODE
#define CommDlg_OpenSave_GetFolderPath  CommDlg_OpenSave_GetFolderPathW
#else
#define CommDlg_OpenSave_GetFolderPath  CommDlg_OpenSave_GetFolderPathA
#endif // !UNICODE

// lParam = pointer to ITEMIDLIST buffer that gets filled in
// wParam = size of the ITEMIDLIST buffer
// return = < 0 if error; length of buffer needed
#define CDM_GETFOLDERIDLIST     (CDM_FIRST + 0x0003)
#define CommDlg_OpenSave_GetFolderIDList(_hdlg, _pidl, _cbmax) \
        (int)SNDMSG(_hdlg, CDM_GETFOLDERIDLIST, (WPARAM)(_cbmax), (LPARAM)(LPVOID)(_pidl))

// lParam = pointer to a string
// wParam = ID of control to change
// return = not used
#define CDM_SETCONTROLTEXT      (CDM_FIRST + 0x0004)
#define CommDlg_OpenSave_SetControlText(_hdlg, _id, _text) \
        (void)SNDMSG(_hdlg, CDM_SETCONTROLTEXT, (WPARAM)(_id), (LPARAM)(LPSTR)(_text))

// lParam = not used
// wParam = ID of control to change
// return = not used
#define CDM_HIDECONTROL         (CDM_FIRST + 0x0005)
#define CommDlg_OpenSave_HideControl(_hdlg, _id) \
        (void)SNDMSG(_hdlg, CDM_HIDECONTROL, (WPARAM)(_id), 0)

// lParam = pointer to default extension (no dot)
// wParam = not used
// return = not used
#define CDM_SETDEFEXT           (CDM_FIRST + 0x0006)
#define CommDlg_OpenSave_SetDefExt(_hdlg, _pszext) \
        (void)SNDMSG(_hdlg, CDM_SETDEFEXT, 0, (LPARAM)(LPSTR)(_pszext))
#endif /* WINVER >= 0x0400 */

#ifndef _MAC
typedef struct tagCHOOSECOLORA {
   DWORD        lStructSize;
   HWND         hwndOwner;
   HWND         hInstance;
   COLORREF     rgbResult;
   COLORREF*    lpCustColors;
   DWORD        Flags;
   LPARAM       lCustData;
   LPCCHOOKPROC lpfnHook;
   LPCSTR       lpTemplateName;
} CHOOSECOLORA, *LPCHOOSECOLORA;
typedef struct tagCHOOSECOLORW {
   DWORD        lStructSize;
   HWND         hwndOwner;
   HWND         hInstance;
   COLORREF     rgbResult;
   COLORREF*    lpCustColors;
   DWORD        Flags;
   LPARAM       lCustData;
   LPCCHOOKPROC lpfnHook;
   LPCWSTR      lpTemplateName;
} CHOOSECOLORW, *LPCHOOSECOLORW;
#ifdef UNICODE
typedef CHOOSECOLORW CHOOSECOLOR;
typedef LPCHOOSECOLORW LPCHOOSECOLOR;
#else
typedef CHOOSECOLORA CHOOSECOLOR;
typedef LPCHOOSECOLORA LPCHOOSECOLOR;
#endif // UNICODE
#else
typedef struct tagCHOOSECOLORA {
   DWORD        lStructSize;
   HWND         hwndOwner;
   HWND         hInstance;
   COLORREF     rgbResult;
   COLORREF*    lpCustColors;
   DWORD        Flags;
   LPARAM       lCustData;
   LPCCHOOKPROC lpfnHook;
   LPCSTR       lpTemplateName;
   LPEDITMENU   lpEditInfo;
} CHOOSECOLORA, *LPCHOOSECOLORA;
typedef struct tagCHOOSECOLORW {
   DWORD        lStructSize;
   HWND         hwndOwner;
   HWND         hInstance;
   COLORREF     rgbResult;
   COLORREF*    lpCustColors;
   DWORD        Flags;
   LPARAM       lCustData;
   LPCCHOOKPROC lpfnHook;
   LPCWSTR      lpTemplateName;
   LPEDITMENU   lpEditInfo;
} CHOOSECOLORW, *LPCHOOSECOLORW;
#ifdef UNICODE
typedef CHOOSECOLORW CHOOSECOLOR;
typedef LPCHOOSECOLORW LPCHOOSECOLOR;
#else
typedef CHOOSECOLORA CHOOSECOLOR;
typedef LPCHOOSECOLORA LPCHOOSECOLOR;
#endif // UNICODE
#endif //_MAC

WINCOMMDLGAPI BOOL APIENTRY ChooseColorA(LPCHOOSECOLORA);
WINCOMMDLGAPI BOOL APIENTRY ChooseColorW(LPCHOOSECOLORW);
#ifdef UNICODE
#define ChooseColor  ChooseColorW
#else
#define ChooseColor  ChooseColorA
#endif // !UNICODE

#define CC_RGBINIT               0x00000001
#define CC_FULLOPEN              0x00000002
#define CC_PREVENTFULLOPEN       0x00000004
#define CC_SHOWHELP              0x00000008
#define CC_ENABLEHOOK            0x00000010
#define CC_ENABLETEMPLATE        0x00000020
#define CC_ENABLETEMPLATEHANDLE  0x00000040
#if(WINVER >= 0x0400)
#define CC_SOLIDCOLOR            0x00000080
#define CC_ANYCOLOR              0x00000100
#endif /* WINVER >= 0x0400 */

typedef UINT_PTR (CALLBACK *LPFRHOOKPROC) (HWND, UINT, WPARAM, LPARAM);

typedef struct tagFINDREPLACEA {
   DWORD        lStructSize;        // size of this struct 0x20
   HWND         hwndOwner;          // handle to owner's window
   HINSTANCE    hInstance;          // instance handle of.EXE that
                                    //   contains cust. dlg. template
   DWORD        Flags;              // one or more of the FR_??
   LPSTR        lpstrFindWhat;      // ptr. to search string
   LPSTR        lpstrReplaceWith;   // ptr. to replace string
   WORD         wFindWhatLen;       // size of find buffer
   WORD         wReplaceWithLen;    // size of replace buffer
   LPARAM       lCustData;          // data passed to hook fn.
   LPFRHOOKPROC lpfnHook;           // ptr. to hook fn. or NULL
   LPCSTR       lpTemplateName;     // custom template name
} FINDREPLACEA, *LPFINDREPLACEA;
typedef struct tagFINDREPLACEW {
   DWORD        lStructSize;        // size of this struct 0x20
   HWND         hwndOwner;          // handle to owner's window
   HINSTANCE    hInstance;          // instance handle of.EXE that
                                    //   contains cust. dlg. template
   DWORD        Flags;              // one or more of the FR_??
   LPWSTR       lpstrFindWhat;      // ptr. to search string
   LPWSTR       lpstrReplaceWith;   // ptr. to replace string
   WORD         wFindWhatLen;       // size of find buffer
   WORD         wReplaceWithLen;    // size of replace buffer
   LPARAM       lCustData;          // data passed to hook fn.
   LPFRHOOKPROC lpfnHook;           // ptr. to hook fn. or NULL
   LPCWSTR      lpTemplateName;     // custom template name
} FINDREPLACEW, *LPFINDREPLACEW;
#ifdef UNICODE
typedef FINDREPLACEW FINDREPLACE;
typedef LPFINDREPLACEW LPFINDREPLACE;
#else
typedef FINDREPLACEA FINDREPLACE;
typedef LPFINDREPLACEA LPFINDREPLACE;
#endif // UNICODE

#define FR_DOWN                         0x00000001
#define FR_WHOLEWORD                    0x00000002
#define FR_MATCHCASE                    0x00000004
#define FR_FINDNEXT                     0x00000008
#define FR_REPLACE                      0x00000010
#define FR_REPLACEALL                   0x00000020
#define FR_DIALOGTERM                   0x00000040
#define FR_SHOWHELP                     0x00000080
#define FR_ENABLEHOOK                   0x00000100
#define FR_ENABLETEMPLATE               0x00000200
#define FR_NOUPDOWN                     0x00000400
#define FR_NOMATCHCASE                  0x00000800
#define FR_NOWHOLEWORD                  0x00001000
#define FR_ENABLETEMPLATEHANDLE         0x00002000
#define FR_HIDEUPDOWN                   0x00004000
#define FR_HIDEMATCHCASE                0x00008000
#define FR_HIDEWHOLEWORD                0x00010000
#if (NTDDI_VERSION >= NTDDI_WIN2K)
#define FR_RAW                          0x00020000
#define FR_MATCHDIAC                    0x20000000
#define FR_MATCHKASHIDA                 0x40000000
#define FR_MATCHALEFHAMZA               0x80000000
#endif // (NTDDI_VERSION >= NTDDI_WIN2K)

WINCOMMDLGAPI HWND APIENTRY FindTextA(LPFINDREPLACEA);
WINCOMMDLGAPI HWND APIENTRY FindTextW(LPFINDREPLACEW);
#ifdef UNICODE
#define FindText  FindTextW
#else
#define FindText  FindTextA
#endif // !UNICODE
#ifndef _MAC
WINCOMMDLGAPI HWND APIENTRY ReplaceTextA(LPFINDREPLACEA);
WINCOMMDLGAPI HWND APIENTRY ReplaceTextW(LPFINDREPLACEW);
#ifdef UNICODE
#define ReplaceText  ReplaceTextW
#else
#define ReplaceText  ReplaceTextA
#endif // !UNICODE
#else
WINCOMMDLGAPI HWND APIENTRY AfxReplaceTextA(LPFINDREPLACEA);
WINCOMMDLGAPI HWND APIENTRY AfxReplaceTextW(LPFINDREPLACEW);
#ifdef UNICODE
#define AfxReplaceText  AfxReplaceTextW
#else
#define AfxReplaceText  AfxReplaceTextA
#endif // !UNICODE
#endif

typedef UINT_PTR (CALLBACK *LPCFHOOKPROC) (HWND, UINT, WPARAM, LPARAM);

typedef struct tagCHOOSEFONTA {
   DWORD           lStructSize;
   HWND            hwndOwner;          // caller's window handle
   HDC             hDC;                // printer DC/IC or NULL
   LPLOGFONTA      lpLogFont;          // ptr. to a LOGFONT struct
   INT             iPointSize;         // 10 * size in points of selected font
   DWORD           Flags;              // enum. type flags
   COLORREF        rgbColors;          // returned text color
   LPARAM          lCustData;          // data passed to hook fn.
   LPCFHOOKPROC    lpfnHook;           // ptr. to hook function
   LPCSTR          lpTemplateName;     // custom template name
   HINSTANCE       hInstance;          // instance handle of.EXE that
                                       //   contains cust. dlg. template
   LPSTR           lpszStyle;          // return the style field here
                                       // must be LF_FACESIZE or bigger
   WORD            nFontType;          // same value reported to the EnumFonts
                                       //   call back with the extra FONTTYPE_
                                       //   bits added
   WORD            ___MISSING_ALIGNMENT__;
   INT             nSizeMin;           // minimum pt size allowed &
   INT             nSizeMax;           // max pt size allowed if
                                       //   CF_LIMITSIZE is used
} CHOOSEFONTA;
typedef struct tagCHOOSEFONTW {
   DWORD           lStructSize;
   HWND            hwndOwner;          // caller's window handle
   HDC             hDC;                // printer DC/IC or NULL
   LPLOGFONTW      lpLogFont;          // ptr. to a LOGFONT struct
   INT             iPointSize;         // 10 * size in points of selected font
   DWORD           Flags;              // enum. type flags
   COLORREF        rgbColors;          // returned text color
   LPARAM          lCustData;          // data passed to hook fn.
   LPCFHOOKPROC    lpfnHook;           // ptr. to hook function
   LPCWSTR         lpTemplateName;     // custom template name
   HINSTANCE       hInstance;          // instance handle of.EXE that
                                       //   contains cust. dlg. template
   LPWSTR          lpszStyle;          // return the style field here
                                       // must be LF_FACESIZE or bigger
   WORD            nFontType;          // same value reported to the EnumFonts
                                       //   call back with the extra FONTTYPE_
                                       //   bits added
   WORD            ___MISSING_ALIGNMENT__;
   INT             nSizeMin;           // minimum pt size allowed &
   INT             nSizeMax;           // max pt size allowed if
                                       //   CF_LIMITSIZE is used
} CHOOSEFONTW;
#ifdef UNICODE
typedef CHOOSEFONTW CHOOSEFONT;
#else
typedef CHOOSEFONTA CHOOSEFONT;
#endif // UNICODE
typedef CHOOSEFONTA *LPCHOOSEFONTA;
typedef CHOOSEFONTW *LPCHOOSEFONTW;
#ifdef UNICODE
typedef LPCHOOSEFONTW LPCHOOSEFONT;
#else
typedef LPCHOOSEFONTA LPCHOOSEFONT;
#endif // UNICODE
typedef const CHOOSEFONTA *PCCHOOSEFONTA;
typedef const CHOOSEFONTW *PCCHOOSEFONTW;
#ifdef UNICODE
typedef CHOOSEFONTW CHOOSEFONT;
typedef PCCHOOSEFONTW PCCHOOSEFONT;
#else
typedef CHOOSEFONTA CHOOSEFONT;
typedef PCCHOOSEFONTA PCCHOOSEFONT;
#endif // UNICODE

WINCOMMDLGAPI BOOL APIENTRY ChooseFontA(LPCHOOSEFONTA);
WINCOMMDLGAPI BOOL APIENTRY ChooseFontW(LPCHOOSEFONTW);
#ifdef UNICODE
#define ChooseFont  ChooseFontW
#else
#define ChooseFont  ChooseFontA
#endif // !UNICODE

#define CF_SCREENFONTS             0x00000001
#define CF_PRINTERFONTS            0x00000002
#define CF_BOTH                    (CF_SCREENFONTS | CF_PRINTERFONTS)
#define CF_SHOWHELP                0x00000004L
#define CF_ENABLEHOOK              0x00000008L
#define CF_ENABLETEMPLATE          0x00000010L
#define CF_ENABLETEMPLATEHANDLE    0x00000020L
#define CF_INITTOLOGFONTSTRUCT     0x00000040L
#define CF_USESTYLE                0x00000080L
#define CF_EFFECTS                 0x00000100L
#define CF_APPLY                   0x00000200L
#define CF_ANSIONLY                0x00000400L
#if(WINVER >= 0x0400)
#define CF_SCRIPTSONLY             CF_ANSIONLY
#endif /* WINVER >= 0x0400 */
#define CF_NOVECTORFONTS           0x00000800L
#define CF_NOOEMFONTS              CF_NOVECTORFONTS
#define CF_NOSIMULATIONS           0x00001000L
#define CF_LIMITSIZE               0x00002000L
#define CF_FIXEDPITCHONLY          0x00004000L
#define CF_WYSIWYG                 0x00008000L // must also have CF_SCREENFONTS & CF_PRINTERFONTS
#define CF_FORCEFONTEXIST          0x00010000L
#define CF_SCALABLEONLY            0x00020000L
#define CF_TTONLY                  0x00040000L
#define CF_NOFACESEL               0x00080000L
#define CF_NOSTYLESEL              0x00100000L
#define CF_NOSIZESEL               0x00200000L
#if(WINVER >= 0x0400)
#define CF_SELECTSCRIPT            0x00400000L
#define CF_NOSCRIPTSEL             0x00800000L
#define CF_NOVERTFONTS             0x01000000L
#endif /* WINVER >= 0x0400 */

// these are extra nFontType bits that are added to what is returned to the
// EnumFonts callback routine

#define SIMULATED_FONTTYPE    0x8000
#define PRINTER_FONTTYPE      0x4000
#define SCREEN_FONTTYPE       0x2000
#define BOLD_FONTTYPE         0x0100
#define ITALIC_FONTTYPE       0x0200
#define REGULAR_FONTTYPE      0x0400

// EnumFonts callback routine only uses these bits, so we can use the rest

// #define RASTER_FONTTYPE     0x001
// #define DEVICE_FONTTYPE     0x002
// #define TRUETYPE_FONTTYPE   0x004

#if (NTDDI_VERSION >= NTDDI_WIN2K)
#define PS_OPENTYPE_FONTTYPE  0x10000
#define TT_OPENTYPE_FONTTYPE  0x20000
#define TYPE1_FONTTYPE        0x40000
#endif // (NTDDI_VERSION >= NTDDI_WIN2K)

#define WM_CHOOSEFONT_GETLOGFONT      (WM_USER + 1)
#if (NTDDI_VERSION >= NTDDI_WIN2K)
#define WM_CHOOSEFONT_SETLOGFONT      (WM_USER + 101)
#define WM_CHOOSEFONT_SETFLAGS        (WM_USER + 102)
#endif // (NTDDI_VERSION >= NTDDI_WIN2K)

// strings used to obtain unique window message for communication
// between dialog and caller

#define LBSELCHSTRINGA  "commdlg_LBSelChangedNotify"
#define SHAREVISTRINGA  "commdlg_ShareViolation"
#define FILEOKSTRINGA   "commdlg_FileNameOK"
#define COLOROKSTRINGA  "commdlg_ColorOK"
#define SETRGBSTRINGA   "commdlg_SetRGBColor"
#define HELPMSGSTRINGA  "commdlg_help"
#define FINDMSGSTRINGA  "commdlg_FindReplace"

#define LBSELCHSTRINGW  L"commdlg_LBSelChangedNotify"
#define SHAREVISTRINGW  L"commdlg_ShareViolation"
#define FILEOKSTRINGW   L"commdlg_FileNameOK"
#define COLOROKSTRINGW  L"commdlg_ColorOK"
#define SETRGBSTRINGW   L"commdlg_SetRGBColor"
#define HELPMSGSTRINGW  L"commdlg_help"
#define FINDMSGSTRINGW  L"commdlg_FindReplace"

#ifdef UNICODE
#define LBSELCHSTRING  LBSELCHSTRINGW
#define SHAREVISTRING  SHAREVISTRINGW
#define FILEOKSTRING   FILEOKSTRINGW
#define COLOROKSTRING  COLOROKSTRINGW
#define SETRGBSTRING   SETRGBSTRINGW
#define HELPMSGSTRING  HELPMSGSTRINGW
#define FINDMSGSTRING  FINDMSGSTRINGW
#else
#define LBSELCHSTRING  LBSELCHSTRINGA
#define SHAREVISTRING  SHAREVISTRINGA
#define FILEOKSTRING   FILEOKSTRINGA
#define COLOROKSTRING  COLOROKSTRINGA
#define SETRGBSTRING   SETRGBSTRINGA
#define HELPMSGSTRING  HELPMSGSTRINGA
#define FINDMSGSTRING  FINDMSGSTRINGA
#endif

// HIWORD values for lParam of commdlg_LBSelChangeNotify message
#define CD_LBSELNOITEMS -1
#define CD_LBSELCHANGE   0
#define CD_LBSELSUB      1
#define CD_LBSELADD      2

typedef UINT_PTR (CALLBACK *LPPRINTHOOKPROC) (HWND, UINT, WPARAM, LPARAM);
typedef UINT_PTR (CALLBACK *LPSETUPHOOKPROC) (HWND, UINT, WPARAM, LPARAM);

typedef struct tagPDA {
   DWORD            lStructSize;
   HWND             hwndOwner;
   HGLOBAL          hDevMode;
   HGLOBAL          hDevNames;
   HDC              hDC;
   DWORD            Flags;
   WORD             nFromPage;
   WORD             nToPage;
   WORD             nMinPage;
   WORD             nMaxPage;
   WORD             nCopies;
   HINSTANCE        hInstance;
   LPARAM           lCustData;
   LPPRINTHOOKPROC  lpfnPrintHook;
   LPSETUPHOOKPROC  lpfnSetupHook;
   LPCSTR           lpPrintTemplateName;
   LPCSTR           lpSetupTemplateName;
   HGLOBAL          hPrintTemplate;
   HGLOBAL          hSetupTemplate;
} PRINTDLGA, *LPPRINTDLGA;
typedef struct tagPDW {
   DWORD            lStructSize;
   HWND             hwndOwner;
   HGLOBAL          hDevMode;
   HGLOBAL          hDevNames;
   HDC              hDC;
   DWORD            Flags;
   WORD             nFromPage;
   WORD             nToPage;
   WORD             nMinPage;
   WORD             nMaxPage;
   WORD             nCopies;
   HINSTANCE        hInstance;
   LPARAM           lCustData;
   LPPRINTHOOKPROC  lpfnPrintHook;
   LPSETUPHOOKPROC  lpfnSetupHook;
   LPCWSTR          lpPrintTemplateName;
   LPCWSTR          lpSetupTemplateName;
   HGLOBAL          hPrintTemplate;
   HGLOBAL          hSetupTemplate;
} PRINTDLGW, *LPPRINTDLGW;
#ifdef UNICODE
typedef PRINTDLGW PRINTDLG;
typedef LPPRINTDLGW LPPRINTDLG;
#else
typedef PRINTDLGA PRINTDLG;
typedef LPPRINTDLGA LPPRINTDLG;
#endif // UNICODE

WINCOMMDLGAPI BOOL APIENTRY PrintDlgA(LPPRINTDLGA);
WINCOMMDLGAPI BOOL APIENTRY PrintDlgW(LPPRINTDLGW);
#ifdef UNICODE
#define PrintDlg  PrintDlgW
#else
#define PrintDlg  PrintDlgA
#endif // !UNICODE


#if(WINVER >= 0x0500)

#ifdef STDMETHOD

//-------------------------------------------------------------------------
//
//  IPrintDialogCallback Interface
//
//  IPrintDialogCallback::InitDone()
//    This function is called by PrintDlgEx when the system has finished
//    initializing the main page of the print dialog.  This function
//    should return S_OK if it has processed the action or S_FALSE to let
//    PrintDlgEx perform the default action.
//
//  IPrintDialogCallback::SelectionChange()
//    This function is called by PrintDlgEx when a selection change occurs
//    in the list view that displays the currently installed printers.
//    This function should return S_OK if it has processed the action or
//    S_FALSE to let PrintDlgEx perform the default action.
//
//  IPrintDialogCallback::HandleMessage(hDlg, uMsg, wParam, lParam, pResult)
//    This function is called by PrintDlgEx when a message is sent to the
//    child window of the main page of the print dialog.  This function
//    should return S_OK if it has processed the action or S_FALSE to let
//    PrintDlgEx perform the default action.
//
//  IObjectWithSite::SetSite(punkSite)
//    IPrintDialogCallback usually paired with IObjectWithSite.
//    Provides the IUnknown pointer of the site to QI for the
//    IPrintDialogServices interface.
//
//-------------------------------------------------------------------------

#undef  INTERFACE
#define INTERFACE   IPrintDialogCallback

DECLARE_INTERFACE_IID_(IPrintDialogCallback, IUnknown, "5852A2C3-6530-11D1-B6A3-0000F8757BF9")
{
    // *** IUnknown methods ***
    STDMETHOD(QueryInterface) (THIS_ REFIID riid, LPVOID *ppvObj) PURE;
    STDMETHOD_(ULONG, AddRef) (THIS) PURE;
    STDMETHOD_(ULONG, Release) (THIS) PURE;

    // *** IPrintDialogCallback methods ***
    STDMETHOD(InitDone) (THIS) PURE;
    STDMETHOD(SelectionChange) (THIS) PURE;
    STDMETHOD(HandleMessage) (THIS_ HWND hDlg, UINT uMsg, WPARAM wParam, LPARAM lParam, LRESULT *pResult) PURE;
};


//-------------------------------------------------------------------------
//
//  IPrintDialogServices Interface
//
//  IPrintDialogServices::GetCurrentDevMode(pDevMode, pcbSize)
//    Returns the DEVMODE structure for the currently selected printer.
//
//  IPrintDialogServices::GetCurrentPrinterName(pPrinterName, pcchSize)
//    Returns the printer name for the currently selected printer.
//
//  IPrintDialogServices::GetCurrentPortName(pPortName, pcchSize)
//    Returns the port name for the currently selected printer.
//
//-------------------------------------------------------------------------

#undef  INTERFACE
#define INTERFACE   IPrintDialogServices

DECLARE_INTERFACE_IID_(IPrintDialogServices, IUnknown, "509AAEDA-5639-11D1-B6A1-0000F8757BF9")
{
    // *** IUnknown methods ***
    STDMETHOD(QueryInterface) (THIS_ REFIID riid, LPVOID *ppvObj) PURE;
    STDMETHOD_(ULONG, AddRef) (THIS) PURE;
    STDMETHOD_(ULONG, Release) (THIS) PURE;

    // *** IPrintDialogServices methods ***
    STDMETHOD(GetCurrentDevMode) (THIS_ __inout LPDEVMODE pDevMode, __inout UINT *pcbSize) PURE;
    STDMETHOD(GetCurrentPrinterName) (THIS_ __out_ecount_opt(*pcchSize) LPWSTR pPrinterName, __inout UINT *pcchSize) PURE;
    STDMETHOD(GetCurrentPortName) (THIS_ __out_ecount_opt(*pcchSize) LPWSTR pPortName, __inout UINT *pcchSize) PURE;
};


//
//  Page Range structure for PrintDlgEx.
//
typedef struct tagPRINTPAGERANGE {
   DWORD  nFromPage;
   DWORD  nToPage;
} PRINTPAGERANGE;
typedef PRINTPAGERANGE *LPPRINTPAGERANGE;
typedef const PRINTPAGERANGE *PCPRINTPAGERANGE;


//
//  PrintDlgEx structure.
//
typedef struct tagPDEXA {
   DWORD                 lStructSize;          // size of structure in bytes
   HWND                  hwndOwner;            // caller's window handle
   HGLOBAL               hDevMode;             // handle to DevMode
   HGLOBAL               hDevNames;            // handle to DevNames
   HDC                   hDC;                  // printer DC/IC or NULL
   DWORD                 Flags;                // PD_ flags
   DWORD                 Flags2;               // reserved
   DWORD                 ExclusionFlags;       // items to exclude from driver pages
   DWORD                 nPageRanges;          // number of page ranges
   DWORD                 nMaxPageRanges;       // max number of page ranges
   LPPRINTPAGERANGE      lpPageRanges;         // array of page ranges
   DWORD                 nMinPage;             // min page number
   DWORD                 nMaxPage;             // max page number
   DWORD                 nCopies;              // number of copies
   HINSTANCE             hInstance;            // instance handle
   LPCSTR                lpPrintTemplateName;  // template name for app specific area
   LPUNKNOWN             lpCallback;           // app callback interface
   DWORD                 nPropertyPages;       // number of app property pages in lphPropertyPages
   HPROPSHEETPAGE       *lphPropertyPages;     // array of app property page handles
   DWORD                 nStartPage;           // start page id
   DWORD                 dwResultAction;       // result action if S_OK is returned
} PRINTDLGEXA, *LPPRINTDLGEXA;
//
//  PrintDlgEx structure.
//
typedef struct tagPDEXW {
   DWORD                 lStructSize;          // size of structure in bytes
   HWND                  hwndOwner;            // caller's window handle
   HGLOBAL               hDevMode;             // handle to DevMode
   HGLOBAL               hDevNames;            // handle to DevNames
   HDC                   hDC;                  // printer DC/IC or NULL
   DWORD                 Flags;                // PD_ flags
   DWORD                 Flags2;               // reserved
   DWORD                 ExclusionFlags;       // items to exclude from driver pages
   DWORD                 nPageRanges;          // number of page ranges
   DWORD                 nMaxPageRanges;       // max number of page ranges
   LPPRINTPAGERANGE      lpPageRanges;         // array of page ranges
   DWORD                 nMinPage;             // min page number
   DWORD                 nMaxPage;             // max page number
   DWORD                 nCopies;              // number of copies
   HINSTANCE             hInstance;            // instance handle
   LPCWSTR               lpPrintTemplateName;  // template name for app specific area
   LPUNKNOWN             lpCallback;           // app callback interface
   DWORD                 nPropertyPages;       // number of app property pages in lphPropertyPages
   HPROPSHEETPAGE       *lphPropertyPages;     // array of app property page handles
   DWORD                 nStartPage;           // start page id
   DWORD                 dwResultAction;       // result action if S_OK is returned
} PRINTDLGEXW, *LPPRINTDLGEXW;
#ifdef UNICODE
typedef PRINTDLGEXW PRINTDLGEX;
typedef LPPRINTDLGEXW LPPRINTDLGEX;
#else
typedef PRINTDLGEXA PRINTDLGEX;
typedef LPPRINTDLGEXA LPPRINTDLGEX;
#endif // UNICODE



WINCOMMDLGAPI HRESULT APIENTRY PrintDlgExA(LPPRINTDLGEXA);
WINCOMMDLGAPI HRESULT APIENTRY PrintDlgExW(LPPRINTDLGEXW);
#ifdef UNICODE
#define PrintDlgEx  PrintDlgExW
#else
#define PrintDlgEx  PrintDlgExA
#endif // !UNICODE

#endif

#endif /* WINVER >= 0x0500 */

//
//  Flags for PrintDlg and PrintDlgEx.
//
#define PD_ALLPAGES                    0x00000000
#define PD_SELECTION                   0x00000001
#define PD_PAGENUMS                    0x00000002
#define PD_NOSELECTION                 0x00000004
#define PD_NOPAGENUMS                  0x00000008
#define PD_COLLATE                     0x00000010
#define PD_PRINTTOFILE                 0x00000020
#define PD_PRINTSETUP                  0x00000040
#define PD_NOWARNING                   0x00000080
#define PD_RETURNDC                    0x00000100
#define PD_RETURNIC                    0x00000200
#define PD_RETURNDEFAULT               0x00000400
#define PD_SHOWHELP                    0x00000800
#define PD_ENABLEPRINTHOOK             0x00001000
#define PD_ENABLESETUPHOOK             0x00002000
#define PD_ENABLEPRINTTEMPLATE         0x00004000
#define PD_ENABLESETUPTEMPLATE         0x00008000
#define PD_ENABLEPRINTTEMPLATEHANDLE   0x00010000
#define PD_ENABLESETUPTEMPLATEHANDLE   0x00020000
#define PD_USEDEVMODECOPIES            0x00040000
#define PD_USEDEVMODECOPIESANDCOLLATE  0x00040000
#define PD_DISABLEPRINTTOFILE          0x00080000
#define PD_HIDEPRINTTOFILE             0x00100000
#define PD_NONETWORKBUTTON             0x00200000
#if(WINVER >= 0x0500)
#define PD_CURRENTPAGE                 0x00400000
#define PD_NOCURRENTPAGE               0x00800000
#define PD_EXCLUSIONFLAGS              0x01000000
#define PD_USELARGETEMPLATE            0x10000000
#endif /* WINVER >= 0x0500 */

#if(WINVER >= 0x0500)

//
//  Exclusion flags for PrintDlgEx.
//
#define PD_EXCL_COPIESANDCOLLATE       (DM_COPIES | DM_COLLATE)


//
//  Define the start page for the print dialog when using PrintDlgEx.
//
#define START_PAGE_GENERAL             0xffffffff


//
//  Result action ids for PrintDlgEx.
//
#define PD_RESULT_CANCEL               0
#define PD_RESULT_PRINT                1
#define PD_RESULT_APPLY                2


#endif /* WINVER >= 0x0500 */

//
//  Device Names structure for PrintDlg and PrintDlgEx.
//
typedef struct tagDEVNAMES {
   WORD wDriverOffset;
   WORD wDeviceOffset;
   WORD wOutputOffset;
   WORD wDefault;
} DEVNAMES;
typedef DEVNAMES *LPDEVNAMES;
typedef const DEVNAMES *PCDEVNAMES;

#define DN_DEFAULTPRN      0x0001


WINCOMMDLGAPI DWORD APIENTRY CommDlgExtendedError(VOID);

#if(WINVER >= 0x0400)
#define WM_PSD_PAGESETUPDLG     (WM_USER  )
#define WM_PSD_FULLPAGERECT     (WM_USER+1)
#define WM_PSD_MINMARGINRECT    (WM_USER+2)
#define WM_PSD_MARGINRECT       (WM_USER+3)
#define WM_PSD_GREEKTEXTRECT    (WM_USER+4)
#define WM_PSD_ENVSTAMPRECT     (WM_USER+5)
#define WM_PSD_YAFULLPAGERECT   (WM_USER+6)

typedef UINT_PTR (CALLBACK* LPPAGEPAINTHOOK)( HWND, UINT, WPARAM, LPARAM );
typedef UINT_PTR (CALLBACK* LPPAGESETUPHOOK)( HWND, UINT, WPARAM, LPARAM );

typedef struct tagPSDA
{
    DWORD           lStructSize;
    HWND            hwndOwner;
    HGLOBAL         hDevMode;
    HGLOBAL         hDevNames;
    DWORD           Flags;
    POINT           ptPaperSize;
    RECT            rtMinMargin;
    RECT            rtMargin;
    HINSTANCE       hInstance;
    LPARAM          lCustData;
    LPPAGESETUPHOOK lpfnPageSetupHook;
    LPPAGEPAINTHOOK lpfnPagePaintHook;
    LPCSTR          lpPageSetupTemplateName;
    HGLOBAL         hPageSetupTemplate;
} PAGESETUPDLGA, * LPPAGESETUPDLGA;
typedef struct tagPSDW
{
    DWORD           lStructSize;
    HWND            hwndOwner;
    HGLOBAL         hDevMode;
    HGLOBAL         hDevNames;
    DWORD           Flags;
    POINT           ptPaperSize;
    RECT            rtMinMargin;
    RECT            rtMargin;
    HINSTANCE       hInstance;
    LPARAM          lCustData;
    LPPAGESETUPHOOK lpfnPageSetupHook;
    LPPAGEPAINTHOOK lpfnPagePaintHook;
    LPCWSTR         lpPageSetupTemplateName;
    HGLOBAL         hPageSetupTemplate;
} PAGESETUPDLGW, * LPPAGESETUPDLGW;
#ifdef UNICODE
typedef PAGESETUPDLGW PAGESETUPDLG;
typedef LPPAGESETUPDLGW LPPAGESETUPDLG;
#else
typedef PAGESETUPDLGA PAGESETUPDLG;
typedef LPPAGESETUPDLGA LPPAGESETUPDLG;
#endif // UNICODE

WINCOMMDLGAPI BOOL APIENTRY PageSetupDlgA( LPPAGESETUPDLGA );
WINCOMMDLGAPI BOOL APIENTRY PageSetupDlgW( LPPAGESETUPDLGW );
#ifdef UNICODE
#define PageSetupDlg  PageSetupDlgW
#else
#define PageSetupDlg  PageSetupDlgA
#endif // !UNICODE

#define PSD_DEFAULTMINMARGINS             0x00000000 // default (printer's)
#define PSD_INWININIINTLMEASURE           0x00000000 // 1st of 4 possible

#define PSD_MINMARGINS                    0x00000001 // use caller's
#define PSD_MARGINS                       0x00000002 // use caller's
#define PSD_INTHOUSANDTHSOFINCHES         0x00000004 // 2nd of 4 possible
#define PSD_INHUNDREDTHSOFMILLIMETERS     0x00000008 // 3rd of 4 possible
#define PSD_DISABLEMARGINS                0x00000010
#define PSD_DISABLEPRINTER                0x00000020
#define PSD_NOWARNING                     0x00000080 // must be same as PD_*
#define PSD_DISABLEORIENTATION            0x00000100
#define PSD_RETURNDEFAULT                 0x00000400 // must be same as PD_*
#define PSD_DISABLEPAPER                  0x00000200
#define PSD_SHOWHELP                      0x00000800 // must be same as PD_*
#define PSD_ENABLEPAGESETUPHOOK           0x00002000 // must be same as PD_*
#define PSD_ENABLEPAGESETUPTEMPLATE       0x00008000 // must be same as PD_*
#define PSD_ENABLEPAGESETUPTEMPLATEHANDLE 0x00020000 // must be same as PD_*
#define PSD_ENABLEPAGEPAINTHOOK           0x00040000
#define PSD_DISABLEPAGEPAINTING           0x00080000
#define PSD_NONETWORKBUTTON               0x00200000 // must be same as PD_*
#endif /* WINVER >= 0x0400 */



#if !defined(RC_INVOKED) /* RC complains about long symbols in #ifs */
#if defined(ISOLATION_AWARE_ENABLED) && (ISOLATION_AWARE_ENABLED != 0)
#include "commdlg.inl"
#endif /* ISOLATION_AWARE_ENABLED */
#endif /* RC */

#ifdef __cplusplus
}
#endif  /* __cplusplus */

#if !defined(_WIN64)
#include <poppack.h>
#endif
#endif  /* GUID_DEFS_ONLY */
#endif  /* !_INC_COMMDLG */
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\vs9sp1\sdk\include\comlite.h ===
//------------------------------------------------------------------------------
// File: COMLite.h
//
// Desc: This header file is to provide a migration path for users of 
//       ActiveMovie betas 1 and 2.
//
// Copyright (c) 1992 - 2001, Microsoft Corporation.  All rights reserved.
//------------------------------------------------------------------------------


#ifndef _INC_COMLITE_
#define _INC_COMLITE_

#define QzInitialize            CoInitialize
#define QzUninitialize          CoUninitialize
#define QzFreeUnusedLibraries   CoFreeUnusedLibraries

#define QzGetMalloc             CoGetMalloc
#define QzTaskMemAlloc          CoTaskMemAlloc
#define QzTaskMemRealloc        CoTaskMemRealloc
#define QzTaskMemFree           CoTaskMemFree
#define QzCreateFilterObject    CoCreateInstance
#define QzCLSIDFromString       CLSIDFromString
#define QzStringFromGUID2       StringFromGUID2

#endif  // _INC_COMLITE_
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\vs9sp1\sdk\include\CommCtrl.h ===
/*****************************************************************************\
*                                                                             *
* commctrl.h - - Interface for the Windows Common Controls                    *
*                                                                             *
* Version 1.2                                                                 *
*                                                                             *
* Copyright (c) Microsoft Corporation. All rights reserved.                   *
*                                                                             *
\*****************************************************************************/



#ifndef _INC_COMMCTRL
#define _INC_COMMCTRL

#ifndef _HRESULT_DEFINED
#define _HRESULT_DEFINED
typedef __success(return >= 0) long HRESULT;
#endif // !_HRESULT_DEFINED

#ifndef NOUSER


//
// Define API decoration for direct importing of DLL references.
//
#ifndef WINCOMMCTRLAPI
#if !defined(_COMCTL32_) && defined(_WIN32)
#define WINCOMMCTRLAPI DECLSPEC_IMPORT
#else
#define WINCOMMCTRLAPI
#endif
#endif // WINCOMMCTRLAPI

//
// For compilers that don't support nameless unions
//
#ifndef DUMMYUNIONNAME
#ifdef NONAMELESSUNION
#define DUMMYUNIONNAME   u
#define DUMMYUNIONNAME2  u2
#define DUMMYUNIONNAME3  u3
#define DUMMYUNIONNAME4  u4
#define DUMMYUNIONNAME5  u5
#else
#define DUMMYUNIONNAME
#define DUMMYUNIONNAME2
#define DUMMYUNIONNAME3
#define DUMMYUNIONNAME4
#define DUMMYUNIONNAME5
#endif
#endif // DUMMYUNIONNAME

#if defined(_MSC_VER) && (_MSC_VER >= 1200)
#pragma warning(push)
#pragma warning(disable:4201) /* nonstandard extension used : nameless struct/union */
#pragma once
#endif

#ifdef __cplusplus
extern "C" {
#endif

//
// Users of this header may define any number of these constants to avoid
// the definitions of each functional group.
//
//    NOTOOLBAR    Customizable bitmap-button toolbar control.
//    NOUPDOWN     Up and Down arrow increment/decrement control.
//    NOSTATUSBAR  Status bar control.
//    NOMENUHELP   APIs to help manage menus, especially with a status bar.
//    NOTRACKBAR   Customizable column-width tracking control.
//    NODRAGLIST   APIs to make a listbox source and sink drag&drop actions.
//    NOPROGRESS   Progress gas gauge.
//    NOHOTKEY     HotKey control
//    NOHEADER     Header bar control.
//    NOIMAGEAPIS  ImageList apis.
//    NOLISTVIEW   ListView control.
//    NOTREEVIEW   TreeView control.
//    NOTABCONTROL Tab control.
//    NOANIMATE    Animate control.
//    NOBUTTON     Button control.
//    NOSTATIC     Static control.
//    NOEDIT       Edit control.
//    NOLISTBOX    Listbox control.
//    NOCOMBOBOX   Combobox control.
//    NOSCROLLBAR  Scrollbar control.
//    NOTASKDIALOG Task Dialog.
//
//=============================================================================

#include <prsht.h>

#ifndef SNDMSG
#ifdef __cplusplus
#ifndef _MAC
#define SNDMSG ::SendMessage
#else
#define SNDMSG ::AfxSendMessage
#endif
#else
#ifndef _MAC
#define SNDMSG SendMessage
#else
#define SNDMSG AfxSendMessage
#endif //_MAC
#endif
#endif // ifndef SNDMSG

#ifdef _MAC
#ifndef RC_INVOKED
#ifndef _WLM_NOFORCE_LIBS

#ifndef _WLMDLL
    #ifdef _DEBUG
        #pragma comment(lib, "comctld.lib")
    #else
        #pragma comment(lib, "comctl.lib")
    #endif
    #pragma comment(linker, "/macres:comctl.rsc")
    #else
    #ifdef _DEBUG
        #pragma comment(lib, "msvcctld.lib")
    #else
        #pragma comment(lib, "msvcctl.lib")
    #endif
#endif // _WLMDLL

#endif // _WLM_NOFORCE_LIBS
#endif // RC_INVOKED
#endif //_MAC

WINCOMMCTRLAPI void WINAPI InitCommonControls(void);

#if (_WIN32_IE >= 0x0300)
typedef struct tagINITCOMMONCONTROLSEX {
    DWORD dwSize;             // size of this structure
    DWORD dwICC;              // flags indicating which classes to be initialized
} INITCOMMONCONTROLSEX, *LPINITCOMMONCONTROLSEX;
#define ICC_LISTVIEW_CLASSES   0x00000001 // listview, header
#define ICC_TREEVIEW_CLASSES   0x00000002 // treeview, tooltips
#define ICC_BAR_CLASSES        0x00000004 // toolbar, statusbar, trackbar, tooltips
#define ICC_TAB_CLASSES        0x00000008 // tab, tooltips
#define ICC_UPDOWN_CLASS       0x00000010 // updown
#define ICC_PROGRESS_CLASS     0x00000020 // progress
#define ICC_HOTKEY_CLASS       0x00000040 // hotkey
#define ICC_ANIMATE_CLASS      0x00000080 // animate
#define ICC_WIN95_CLASSES      0x000000FF
#define ICC_DATE_CLASSES       0x00000100 // month picker, date picker, time picker, updown
#define ICC_USEREX_CLASSES     0x00000200 // comboex
#define ICC_COOL_CLASSES       0x00000400 // rebar (coolbar) control
#if (_WIN32_IE >= 0x0400)
#define ICC_INTERNET_CLASSES   0x00000800
#define ICC_PAGESCROLLER_CLASS 0x00001000   // page scroller
#define ICC_NATIVEFNTCTL_CLASS 0x00002000   // native font control
#endif
#if (_WIN32_WINNT >= 0x0501)
#define ICC_STANDARD_CLASSES   0x00004000
#define ICC_LINK_CLASS         0x00008000
#endif // (_WIN32_WINNT >= 0x0501)


WINCOMMCTRLAPI BOOL WINAPI InitCommonControlsEx(const INITCOMMONCONTROLSEX *picce);
#endif      // _WIN32_IE >= 0x0300

#define ODT_HEADER              100
#define ODT_TAB                 101
#define ODT_LISTVIEW            102


//====== Ranges for control message IDs =======================================

#define LVM_FIRST               0x1000      // ListView messages
#define TV_FIRST                0x1100      // TreeView messages
#define HDM_FIRST               0x1200      // Header messages
#define TCM_FIRST               0x1300      // Tab control messages

#if (_WIN32_IE >= 0x0400)
#define PGM_FIRST               0x1400      // Pager control messages

#if (_WIN32_WINNT >= 0x0501)
#define ECM_FIRST               0x1500      // Edit control messages
#define BCM_FIRST               0x1600      // Button control messages
#define CBM_FIRST               0x1700      // Combobox control messages
#endif // _WIN32_WINNT >= 0x0501

#define CCM_FIRST               0x2000      // Common control shared messages
#define CCM_LAST                (CCM_FIRST + 0x200)


#define CCM_SETBKCOLOR          (CCM_FIRST + 1) // lParam is bkColor

typedef struct tagCOLORSCHEME {
   DWORD            dwSize;
   COLORREF         clrBtnHighlight;       // highlight color
   COLORREF         clrBtnShadow;          // shadow color
} COLORSCHEME, *LPCOLORSCHEME;

#define CCM_SETCOLORSCHEME      (CCM_FIRST + 2) // lParam is color scheme
#define CCM_GETCOLORSCHEME      (CCM_FIRST + 3) // fills in COLORSCHEME pointed to by lParam
#define CCM_GETDROPTARGET       (CCM_FIRST + 4)
#define CCM_SETUNICODEFORMAT    (CCM_FIRST + 5)
#define CCM_GETUNICODEFORMAT    (CCM_FIRST + 6)

#if (_WIN32_IE >= 0x0500)
#if (_WIN32_WINNT >= 0x0501)
#define COMCTL32_VERSION  6
#else
#define COMCTL32_VERSION  5
#endif

#define CCM_SETVERSION          (CCM_FIRST + 0x7)
#define CCM_GETVERSION          (CCM_FIRST + 0x8)
#define CCM_SETNOTIFYWINDOW     (CCM_FIRST + 0x9) // wParam == hwndParent.
#if (_WIN32_WINNT >= 0x0501)
#define CCM_SETWINDOWTHEME      (CCM_FIRST + 0xb)
#define CCM_DPISCALE            (CCM_FIRST + 0xc) // wParam == Awareness
#endif
#endif // (_WIN32_IE >= 0x0500)

#endif // (_WIN32_IE >= 0x0400)

#if (_WIN32_IE >= 0x0400)
// for tooltips
#define INFOTIPSIZE 1024
#endif

//====== WM_NOTIFY Macros =====================================================

#define HANDLE_WM_NOTIFY(hwnd, wParam, lParam, fn) \
    (fn)((hwnd), (int)(wParam), (NMHDR *)(lParam))
#define FORWARD_WM_NOTIFY(hwnd, idFrom, pnmhdr, fn) \
    (LRESULT)(fn)((hwnd), WM_NOTIFY, (WPARAM)(int)(idFrom), (LPARAM)(NMHDR *)(pnmhdr))


//====== Generic WM_NOTIFY notification codes =================================

#define NM_OUTOFMEMORY          (NM_FIRST-1)
#define NM_CLICK                (NM_FIRST-2)    // uses NMCLICK struct
#define NM_DBLCLK               (NM_FIRST-3)
#define NM_RETURN               (NM_FIRST-4)
#define NM_RCLICK               (NM_FIRST-5)    // uses NMCLICK struct
#define NM_RDBLCLK              (NM_FIRST-6)
#define NM_SETFOCUS             (NM_FIRST-7)
#define NM_KILLFOCUS            (NM_FIRST-8)
#if (_WIN32_IE >= 0x0300)
#define NM_CUSTOMDRAW           (NM_FIRST-12)
#define NM_HOVER                (NM_FIRST-13)
#endif
#if (_WIN32_IE >= 0x0400)
#define NM_NCHITTEST            (NM_FIRST-14)   // uses NMMOUSE struct
#define NM_KEYDOWN              (NM_FIRST-15)   // uses NMKEY struct
#define NM_RELEASEDCAPTURE      (NM_FIRST-16)
#define NM_SETCURSOR            (NM_FIRST-17)   // uses NMMOUSE struct
#define NM_CHAR                 (NM_FIRST-18)   // uses NMCHAR struct
#endif
#if (_WIN32_IE >= 0x0401)
#define NM_TOOLTIPSCREATED      (NM_FIRST-19)   // notify of when the tooltips window is create
#endif
#if (_WIN32_IE >= 0x0500)
#define NM_LDOWN                (NM_FIRST-20)
#define NM_RDOWN                (NM_FIRST-21)
#define NM_THEMECHANGED         (NM_FIRST-22)
#endif

#if _WIN32_WINNT >= 0x0600
#define NM_FONTCHANGED          (NM_FIRST-23)
#define NM_CUSTOMTEXT           (NM_FIRST-24)   // uses NMCUSTOMTEXT struct
#define NM_TVSTATEIMAGECHANGING (NM_FIRST-24)   // uses NMTVSTATEIMAGECHANGING struct, defined after HTREEITEM
#endif

#ifndef CCSIZEOF_STRUCT
#define CCSIZEOF_STRUCT(structname, member)  (((int)((LPBYTE)(&((structname*)0)->member) - ((LPBYTE)((structname*)0)))) + sizeof(((structname*)0)->member))
#endif

//====== Generic WM_NOTIFY notification structures ============================
#if (_WIN32_IE >= 0x0401)
typedef struct tagNMTOOLTIPSCREATED
{
    NMHDR hdr;
    HWND hwndToolTips;
} NMTOOLTIPSCREATED, * LPNMTOOLTIPSCREATED;
#endif

#if (_WIN32_IE >= 0x0400)
typedef struct tagNMMOUSE {
    NMHDR   hdr;
    DWORD_PTR dwItemSpec;
    DWORD_PTR dwItemData;
    POINT   pt;
    LPARAM  dwHitInfo; // any specifics about where on the item or control the mouse is
} NMMOUSE, *LPNMMOUSE;

typedef NMMOUSE NMCLICK;
typedef LPNMMOUSE LPNMCLICK;

// Generic structure to request an object of a specific type.

typedef struct tagNMOBJECTNOTIFY {
    NMHDR   hdr;
    int     iItem;
#ifdef __IID_DEFINED__
    const IID *piid;
#else
    const void *piid;
#endif
    void *pObject;
    HRESULT hResult;
    DWORD dwFlags;    // control specific flags (hints as to where in iItem it hit)
} NMOBJECTNOTIFY, *LPNMOBJECTNOTIFY;

// Generic structure for a key

typedef struct tagNMKEY
{
    NMHDR hdr;
    UINT  nVKey;
    UINT  uFlags;
} NMKEY, *LPNMKEY;

// Generic structure for a character

typedef struct tagNMCHAR {
    NMHDR   hdr;
    UINT    ch;
    DWORD   dwItemPrev;     // Item previously selected
    DWORD   dwItemNext;     // Item to be selected
} NMCHAR, *LPNMCHAR;

#endif           // _WIN32_IE >= 0x0400

#if (_WIN32_IE >= 0x0600)

typedef struct tagNMCUSTOMTEXT
{
    NMHDR hdr;
    HDC hDC;
    LPCWSTR lpString;
    int nCount;
    LPRECT lpRect;
    UINT uFormat;
    BOOL fLink;
} NMCUSTOMTEXT, *LPNMCUSTOMTEXT;

#endif           // _WIN32_IE >= 0x0600
//====== WM_NOTIFY codes (NMHDR.code values) ==================================

#define NM_FIRST                (0U-  0U)       // generic to all controls
#define NM_LAST                 (0U- 99U)

#define LVN_FIRST               (0U-100U)       // listview
#define LVN_LAST                (0U-199U)

// Property sheet reserved      (0U-200U) -  (0U-299U) - see prsht.h

#define HDN_FIRST               (0U-300U)       // header
#define HDN_LAST                (0U-399U)

#define TVN_FIRST               (0U-400U)       // treeview
#define TVN_LAST                (0U-499U)

#define TTN_FIRST               (0U-520U)       // tooltips
#define TTN_LAST                (0U-549U)

#define TCN_FIRST               (0U-550U)       // tab control
#define TCN_LAST                (0U-580U)

// Shell reserved               (0U-580U) -  (0U-589U)

#define CDN_FIRST               (0U-601U)       // common dialog (new)
#define CDN_LAST                (0U-699U)

#define TBN_FIRST               (0U-700U)       // toolbar
#define TBN_LAST                (0U-720U)

#define UDN_FIRST               (0U-721U)        // updown
#define UDN_LAST                (0U-729U)
#if (_WIN32_IE >= 0x0300)
#define DTN_FIRST               (0U-740U)       // datetimepick
#define DTN_LAST                (0U-745U)       // DTN_FIRST - 5

#define MCN_FIRST               (0U-746U)       // monthcal
#define MCN_LAST                (0U-752U)       // MCN_FIRST - 6

#define DTN_FIRST2              (0U-753U)       // datetimepick2
#define DTN_LAST2               (0U-799U)

#define CBEN_FIRST              (0U-800U)       // combo box ex
#define CBEN_LAST               (0U-830U)

#define RBN_FIRST               (0U-831U)       // rebar
#define RBN_LAST                (0U-859U)
#endif

#if (_WIN32_IE >= 0x0400)
#define IPN_FIRST               (0U-860U)       // internet address
#define IPN_LAST                (0U-879U)       // internet address

#define SBN_FIRST               (0U-880U)       // status bar
#define SBN_LAST                (0U-899U)

#define PGN_FIRST               (0U-900U)       // Pager Control
#define PGN_LAST                (0U-950U)

#endif

#if (_WIN32_IE >= 0x0500)
#ifndef WMN_FIRST
#define WMN_FIRST               (0U-1000U)
#define WMN_LAST                (0U-1200U)
#endif
#endif

#if (_WIN32_WINNT >= 0x0501)
#define BCN_FIRST               (0U-1250U)
#define BCN_LAST                (0U-1350U)
#endif


#if (_WIN32_WINNT >= 0x0600)
#define TRBN_FIRST              (0U-1501U)       // trackbar
#define TRBN_LAST               (0U-1519U)
#endif

#define MSGF_COMMCTRL_BEGINDRAG     0x4200
#define MSGF_COMMCTRL_SIZEHEADER    0x4201
#define MSGF_COMMCTRL_DRAGSELECT    0x4202
#define MSGF_COMMCTRL_TOOLBARCUST   0x4203

#if (_WIN32_IE >= 0x0300)
//==================== CUSTOM DRAW ==========================================


// custom draw return flags
// values under 0x00010000 are reserved for global custom draw values.
// above that are for specific controls
#define CDRF_DODEFAULT          0x00000000
#define CDRF_NEWFONT            0x00000002
#define CDRF_SKIPDEFAULT        0x00000004
#define CDRF_DOERASE            0x00000008 // draw the background
#define CDRF_SKIPPOSTPAINT      0x00000100 // don't draw the focus rect

#define CDRF_NOTIFYPOSTPAINT    0x00000010
#define CDRF_NOTIFYITEMDRAW     0x00000020
#if (_WIN32_IE >= 0x0400)
#define CDRF_NOTIFYSUBITEMDRAW  0x00000020  // flags are the same, we can distinguish by context
#endif
#define CDRF_NOTIFYPOSTERASE    0x00000040

// drawstage flags
// values under 0x00010000 are reserved for global custom draw values.
// above that are for specific controls
#define CDDS_PREPAINT           0x00000001
#define CDDS_POSTPAINT          0x00000002
#define CDDS_PREERASE           0x00000003
#define CDDS_POSTERASE          0x00000004
// the 0x000010000 bit means it's individual item specific
#define CDDS_ITEM               0x00010000
#define CDDS_ITEMPREPAINT       (CDDS_ITEM | CDDS_PREPAINT)
#define CDDS_ITEMPOSTPAINT      (CDDS_ITEM | CDDS_POSTPAINT)
#define CDDS_ITEMPREERASE       (CDDS_ITEM | CDDS_PREERASE)
#define CDDS_ITEMPOSTERASE      (CDDS_ITEM | CDDS_POSTERASE)
#if (_WIN32_IE >= 0x0400)
#define CDDS_SUBITEM            0x00020000
#endif

// itemState flags
#define CDIS_SELECTED           0x0001
#define CDIS_GRAYED             0x0002
#define CDIS_DISABLED           0x0004
#define CDIS_CHECKED            0x0008
#define CDIS_FOCUS              0x0010
#define CDIS_DEFAULT            0x0020
#define CDIS_HOT                0x0040
#define CDIS_MARKED             0x0080
#define CDIS_INDETERMINATE      0x0100
#if (_WIN32_WINNT >= 0x0501)
#define CDIS_SHOWKEYBOARDCUES   0x0200
#endif
#if (_WIN32_WINNT >= 0x0600)
#define CDIS_NEARHOT            0x0400
#define CDIS_OTHERSIDEHOT       0x0800
#define CDIS_DROPHILITED        0x1000
#endif

typedef struct tagNMCUSTOMDRAWINFO
{
    NMHDR hdr;
    DWORD dwDrawStage;
    HDC hdc;
    RECT rc;
    DWORD_PTR dwItemSpec;  // this is control specific, but it's how to specify an item.  valid only with CDDS_ITEM bit set
    UINT  uItemState;
    LPARAM lItemlParam;
} NMCUSTOMDRAW, *LPNMCUSTOMDRAW;

typedef struct tagNMTTCUSTOMDRAW
{
    NMCUSTOMDRAW nmcd;
    UINT uDrawFlags;
} NMTTCUSTOMDRAW, *LPNMTTCUSTOMDRAW;

typedef struct tagNMCUSTOMSPLITRECTINFO
{
    NMHDR hdr;
    RECT rcClient;
    RECT rcButton;
    RECT rcSplit;
} NMCUSTOMSPLITRECTINFO, *LPNMCUSTOMSPLITRECTINFO;

#define NM_GETCUSTOMSPLITRECT       (BCN_FIRST + 0x0003)

#endif      // _WIN32_IE >= 0x0300


//====== IMAGE APIS ===========================================================

#ifndef NOIMAGEAPIS

#define CLR_NONE                0xFFFFFFFFL
#define CLR_DEFAULT             0xFF000000L


#ifndef HIMAGELIST
struct _IMAGELIST;
typedef struct _IMAGELIST* HIMAGELIST;
#endif

#ifndef IMAGELISTDRAWPARAMS
#if (_WIN32_IE >= 0x0300)
typedef struct _IMAGELISTDRAWPARAMS
{
    DWORD       cbSize;
    HIMAGELIST  himl;
    int         i;
    HDC         hdcDst;
    int         x;
    int         y;
    int         cx;
    int         cy;
    int         xBitmap;        // x offest from the upperleft of bitmap
    int         yBitmap;        // y offset from the upperleft of bitmap
    COLORREF    rgbBk;
    COLORREF    rgbFg;
    UINT        fStyle;
    DWORD       dwRop;
#if (_WIN32_IE >= 0x0501)
    DWORD       fState;
    DWORD       Frame;
    COLORREF    crEffect;
#endif
} IMAGELISTDRAWPARAMS, *LPIMAGELISTDRAWPARAMS;

#define IMAGELISTDRAWPARAMS_V3_SIZE CCSIZEOF_STRUCT(IMAGELISTDRAWPARAMS, dwRop)

#endif      // _WIN32_IE >= 0x0300
#endif

#define ILC_MASK                0x00000001
#define ILC_COLOR               0x00000000
#define ILC_COLORDDB            0x000000FE
#define ILC_COLOR4              0x00000004
#define ILC_COLOR8              0x00000008
#define ILC_COLOR16             0x00000010
#define ILC_COLOR24             0x00000018
#define ILC_COLOR32             0x00000020
#define ILC_PALETTE             0x00000800      // (not implemented)
#if (_WIN32_WINNT >= 0x0501)
#define ILC_MIRROR              0x00002000      // Mirror the icons contained, if the process is mirrored
#define ILC_PERITEMMIRROR       0x00008000      // Causes the mirroring code to mirror each item when inserting a set of images, verses the whole strip
#endif
#if _WIN32_WINNT >= 0x0600
#define ILC_ORIGINALSIZE        0x00010000      // Imagelist should accept smaller than set images and apply OriginalSize based on image added
#define ILC_HIGHQUALITYSCALE    0x00020000      // Imagelist should enable use of the high quality scaler.
#endif
WINCOMMCTRLAPI HIMAGELIST  WINAPI ImageList_Create(int cx, int cy, UINT flags, int cInitial, int cGrow);
WINCOMMCTRLAPI BOOL        WINAPI ImageList_Destroy(HIMAGELIST himl);

WINCOMMCTRLAPI int         WINAPI ImageList_GetImageCount(HIMAGELIST himl);
#if (_WIN32_IE >= 0x0300)
WINCOMMCTRLAPI BOOL        WINAPI ImageList_SetImageCount(HIMAGELIST himl, UINT uNewCount);
#endif

WINCOMMCTRLAPI int         WINAPI ImageList_Add(HIMAGELIST himl, HBITMAP hbmImage, HBITMAP hbmMask);

WINCOMMCTRLAPI int         WINAPI ImageList_ReplaceIcon(HIMAGELIST himl, int i, HICON hicon);
WINCOMMCTRLAPI COLORREF    WINAPI ImageList_SetBkColor(HIMAGELIST himl, COLORREF clrBk);
WINCOMMCTRLAPI COLORREF    WINAPI ImageList_GetBkColor(HIMAGELIST himl);
WINCOMMCTRLAPI BOOL        WINAPI ImageList_SetOverlayImage(HIMAGELIST himl, int iImage, int iOverlay);

#define     ImageList_AddIcon(himl, hicon) ImageList_ReplaceIcon(himl, -1, hicon)

#define ILD_NORMAL              0x00000000
#define ILD_TRANSPARENT         0x00000001
#define ILD_MASK                0x00000010
#define ILD_IMAGE               0x00000020
#if (_WIN32_IE >= 0x0300)
#define ILD_ROP                 0x00000040
#endif
#define ILD_BLEND25             0x00000002
#define ILD_BLEND50             0x00000004
#define ILD_OVERLAYMASK         0x00000F00
#define INDEXTOOVERLAYMASK(i)   ((i) << 8)
#define ILD_PRESERVEALPHA       0x00001000  // This preserves the alpha channel in dest
#define ILD_SCALE               0x00002000  // Causes the image to be scaled to cx, cy instead of clipped
#define ILD_DPISCALE            0x00004000
#if _WIN32_WINNT >= 0x0600
#define ILD_ASYNC               0x00008000
#endif

#define ILD_SELECTED            ILD_BLEND50
#define ILD_FOCUS               ILD_BLEND25
#define ILD_BLEND               ILD_BLEND50
#define CLR_HILIGHT             CLR_DEFAULT

#define ILS_NORMAL              0x00000000
#define ILS_GLOW                0x00000001
#define ILS_SHADOW              0x00000002
#define ILS_SATURATE            0x00000004
#define ILS_ALPHA               0x00000008

#if _WIN32_WINNT >= 0x0600
#define ILGT_NORMAL             0x00000000
#define ILGT_ASYNC              0x00000001
#endif

WINCOMMCTRLAPI BOOL WINAPI ImageList_Draw(HIMAGELIST himl, int i, HDC hdcDst, int x, int y, UINT fStyle);


#ifdef _WIN32

#if _WIN32_WINNT >= 0x0600
#define HBITMAP_CALLBACK               ((HBITMAP)-1)       // only for SparseImageList
#endif

WINCOMMCTRLAPI BOOL        WINAPI ImageList_Replace(HIMAGELIST himl, int i, HBITMAP hbmImage, HBITMAP hbmMask);

WINCOMMCTRLAPI int         WINAPI ImageList_AddMasked(HIMAGELIST himl, HBITMAP hbmImage, COLORREF crMask);
WINCOMMCTRLAPI BOOL        WINAPI ImageList_DrawEx(HIMAGELIST himl, int i, HDC hdcDst, int x, int y, int dx, int dy, COLORREF rgbBk, COLORREF rgbFg, UINT fStyle);
#if (_WIN32_IE >= 0x0300)
WINCOMMCTRLAPI BOOL        WINAPI ImageList_DrawIndirect(IMAGELISTDRAWPARAMS* pimldp);
#endif
WINCOMMCTRLAPI BOOL        WINAPI ImageList_Remove(HIMAGELIST himl, int i);
WINCOMMCTRLAPI HICON       WINAPI ImageList_GetIcon(HIMAGELIST himl, int i, UINT flags);
WINCOMMCTRLAPI HIMAGELIST  WINAPI ImageList_LoadImageA(HINSTANCE hi, LPCSTR lpbmp, int cx, int cGrow, COLORREF crMask, UINT uType, UINT uFlags);
WINCOMMCTRLAPI HIMAGELIST  WINAPI ImageList_LoadImageW(HINSTANCE hi, LPCWSTR lpbmp, int cx, int cGrow, COLORREF crMask, UINT uType, UINT uFlags);

#ifdef UNICODE
#define ImageList_LoadImage     ImageList_LoadImageW
#else
#define ImageList_LoadImage     ImageList_LoadImageA
#endif

#if (_WIN32_IE >= 0x0300)
#define ILCF_MOVE   (0x00000000)
#define ILCF_SWAP   (0x00000001)
WINCOMMCTRLAPI BOOL        WINAPI ImageList_Copy(HIMAGELIST himlDst, int iDst, HIMAGELIST himlSrc, int iSrc, UINT uFlags);
#endif

WINCOMMCTRLAPI BOOL        WINAPI ImageList_BeginDrag(HIMAGELIST himlTrack, int iTrack, int dxHotspot, int dyHotspot);
WINCOMMCTRLAPI void        WINAPI ImageList_EndDrag(void);
WINCOMMCTRLAPI BOOL        WINAPI ImageList_DragEnter(HWND hwndLock, int x, int y);
WINCOMMCTRLAPI BOOL        WINAPI ImageList_DragLeave(HWND hwndLock);
WINCOMMCTRLAPI BOOL        WINAPI ImageList_DragMove(int x, int y);
WINCOMMCTRLAPI BOOL        WINAPI ImageList_SetDragCursorImage(HIMAGELIST himlDrag, int iDrag, int dxHotspot, int dyHotspot);

WINCOMMCTRLAPI BOOL        WINAPI ImageList_DragShowNolock(BOOL fShow);
WINCOMMCTRLAPI HIMAGELIST  WINAPI ImageList_GetDragImage(POINT *ppt,POINT *pptHotspot);

#define     ImageList_RemoveAll(himl) ImageList_Remove(himl, -1)
#define     ImageList_ExtractIcon(hi, himl, i) ImageList_GetIcon(himl, i, 0)
#define     ImageList_LoadBitmap(hi, lpbmp, cx, cGrow, crMask) ImageList_LoadImage(hi, lpbmp, cx, cGrow, crMask, IMAGE_BITMAP, 0)

#ifdef __IStream_INTERFACE_DEFINED__

WINCOMMCTRLAPI HIMAGELIST WINAPI ImageList_Read(LPSTREAM pstm);
WINCOMMCTRLAPI BOOL       WINAPI ImageList_Write(HIMAGELIST himl, LPSTREAM pstm);

#if (_WIN32_WINNT >= 0x0501)
#define ILP_NORMAL          0           // Writes or reads the stream using new sematics for this version of comctl32
#define ILP_DOWNLEVEL       1           // Write or reads the stream using downlevel sematics.


WINCOMMCTRLAPI HRESULT WINAPI ImageList_ReadEx(DWORD dwFlags, LPSTREAM pstm, REFIID riid, PVOID* ppv);
WINCOMMCTRLAPI HRESULT WINAPI ImageList_WriteEx(HIMAGELIST himl, DWORD dwFlags, LPSTREAM pstm);
#endif

#endif


#ifndef IMAGEINFO
typedef struct _IMAGEINFO
{
    HBITMAP hbmImage;
    HBITMAP hbmMask;
    int     Unused1;
    int     Unused2;
    RECT    rcImage;
} IMAGEINFO, *LPIMAGEINFO;
#endif

WINCOMMCTRLAPI BOOL        WINAPI ImageList_GetIconSize(HIMAGELIST himl, int *cx, int *cy);
WINCOMMCTRLAPI BOOL        WINAPI ImageList_SetIconSize(HIMAGELIST himl, int cx, int cy);
WINCOMMCTRLAPI BOOL        WINAPI ImageList_GetImageInfo(HIMAGELIST himl, int i, IMAGEINFO *pImageInfo);
WINCOMMCTRLAPI HIMAGELIST  WINAPI ImageList_Merge(HIMAGELIST himl1, int i1, HIMAGELIST himl2, int i2, int dx, int dy);
#if (_WIN32_IE >= 0x0400)
WINCOMMCTRLAPI HIMAGELIST  WINAPI ImageList_Duplicate(HIMAGELIST himl);
#endif


#endif

#if (_WIN32_WINNT >= 0x0501)
WINCOMMCTRLAPI HRESULT WINAPI HIMAGELIST_QueryInterface(HIMAGELIST himl, REFIID riid, void** ppv);

#ifdef __cplusplus
FORCEINLINE HIMAGELIST IImageListToHIMAGELIST(struct IImageList *himl)
{
    return reinterpret_cast<HIMAGELIST>(himl);
}
#else
#define IImageListToHIMAGELIST(himl) ((HIMAGELIST)(himl))
#endif

#endif


#endif


//====== HEADER CONTROL =======================================================

#ifndef NOHEADER

#ifdef _WIN32
#define WC_HEADERA              "SysHeader32"
#define WC_HEADERW              L"SysHeader32"

#ifdef UNICODE
#define WC_HEADER               WC_HEADERW
#else
#define WC_HEADER               WC_HEADERA
#endif

#else
#define WC_HEADER               "SysHeader"
#endif

// begin_r_commctrl

#define HDS_HORZ                0x0000
#define HDS_BUTTONS             0x0002
#if (_WIN32_IE >= 0x0300)
#define HDS_HOTTRACK            0x0004
#endif
#define HDS_HIDDEN              0x0008

#if (_WIN32_IE >= 0x0300)
#define HDS_DRAGDROP            0x0040
#define HDS_FULLDRAG            0x0080
#endif
#if (_WIN32_IE >= 0x0500)
#define HDS_FILTERBAR           0x0100
#endif

#if (_WIN32_WINNT >= 0x0501)
#define HDS_FLAT                0x0200
#endif

#if _WIN32_WINNT >= 0x0600
#define HDS_CHECKBOXES          0x0400
#define HDS_NOSIZING            0x0800
#define HDS_OVERFLOW            0x1000
#endif
// end_r_commctrl

#if (_WIN32_IE >= 0x0500)

#define HDFT_ISSTRING       0x0000      // HD_ITEM.pvFilter points to a HD_TEXTFILTER
#define HDFT_ISNUMBER       0x0001      // HD_ITEM.pvFilter points to a INT
#define HDFT_ISDATE         0x0002      // HD_ITEM.pvFilter points to a DWORD (dos date)

#define HDFT_HASNOVALUE     0x8000      // clear the filter, by setting this bit

#ifdef UNICODE
#define HD_TEXTFILTER HD_TEXTFILTERW
#define HDTEXTFILTER HD_TEXTFILTERW
#define LPHD_TEXTFILTER LPHD_TEXTFILTERW
#define LPHDTEXTFILTER LPHD_TEXTFILTERW
#else
#define HD_TEXTFILTER HD_TEXTFILTERA
#define HDTEXTFILTER HD_TEXTFILTERA
#define LPHD_TEXTFILTER LPHD_TEXTFILTERA
#define LPHDTEXTFILTER LPHD_TEXTFILTERA
#endif

typedef struct _HD_TEXTFILTERA
{
    LPSTR pszText;                      // [in] pointer to the buffer containing the filter (ANSI)
    INT cchTextMax;                     // [in] max size of buffer/edit control buffer
} HD_TEXTFILTERA, *LPHD_TEXTFILTERA;

typedef struct _HD_TEXTFILTERW
{
    LPWSTR pszText;                     // [in] pointer to the buffer contiaining the filter (UNICODE)
    INT cchTextMax;                     // [in] max size of buffer/edit control buffer
} HD_TEXTFILTERW, *LPHD_TEXTFILTERW;

#endif  // _WIN32_IE >= 0x0500

#if (_WIN32_IE >= 0x0300)
#define HD_ITEMA HDITEMA
#define HD_ITEMW HDITEMW
#else
#define HDITEMW  HD_ITEMW
#define HDITEMA  HD_ITEMA
#endif
#define HD_ITEM HDITEM

typedef struct _HD_ITEMA
{
    UINT    mask;
    int     cxy;
    LPSTR   pszText;
    HBITMAP hbm;
    int     cchTextMax;
    int     fmt;
    LPARAM  lParam;
#if (_WIN32_IE >= 0x0300)
    int     iImage;        // index of bitmap in ImageList
    int     iOrder;        // where to draw this item
#endif
#if (_WIN32_IE >= 0x0500)
    UINT    type;           // [in] filter type (defined what pvFilter is a pointer to)
    void *  pvFilter;       // [in] filter data see above
#endif
#if _WIN32_WINNT >= 0x0600
    UINT   state;
#endif
} HDITEMA, *LPHDITEMA;

#define HDITEMA_V1_SIZE CCSIZEOF_STRUCT(HDITEMA, lParam)
#define HDITEMW_V1_SIZE CCSIZEOF_STRUCT(HDITEMW, lParam)


typedef struct _HD_ITEMW
{
    UINT    mask;
    int     cxy;
    LPWSTR  pszText;
    HBITMAP hbm;
    int     cchTextMax;
    int     fmt;
    LPARAM  lParam;
#if (_WIN32_IE >= 0x0300)
    int     iImage;        // index of bitmap in ImageList
    int     iOrder;
#endif
#if (_WIN32_IE >= 0x0500)
    UINT    type;           // [in] filter type (defined what pvFilter is a pointer to)
    void *  pvFilter;       // [in] fillter data see above
#endif
#if _WIN32_WINNT >= 0x0600
    UINT   state;
#endif
} HDITEMW, *LPHDITEMW;

#ifdef UNICODE
#define HDITEM HDITEMW
#define LPHDITEM LPHDITEMW
#define HDITEM_V1_SIZE HDITEMW_V1_SIZE
#else
#define HDITEM HDITEMA
#define LPHDITEM LPHDITEMA
#define HDITEM_V1_SIZE HDITEMA_V1_SIZE
#endif


#define HDI_WIDTH               0x0001
#define HDI_HEIGHT              HDI_WIDTH
#define HDI_TEXT                0x0002
#define HDI_FORMAT              0x0004
#define HDI_LPARAM              0x0008
#define HDI_BITMAP              0x0010
#if (_WIN32_IE >= 0x0300)
#define HDI_IMAGE               0x0020
#define HDI_DI_SETITEM          0x0040
#define HDI_ORDER               0x0080
#endif
#if (_WIN32_IE >= 0x0500)
#define HDI_FILTER              0x0100
#endif
#if _WIN32_WINNT >= 0x0600
#define HDI_STATE               0x0200
#endif

// HDF_ flags are shared with the listview control (LVCFMT_ flags)

#define HDF_LEFT                0x0000 // Same as LVCFMT_LEFT
#define HDF_RIGHT               0x0001 // Same as LVCFMT_RIGHT
#define HDF_CENTER              0x0002 // Same as LVCFMT_CENTER
#define HDF_JUSTIFYMASK         0x0003 // Same as LVCFMT_JUSTIFYMASK
#define HDF_RTLREADING          0x0004 // Same as LVCFMT_LEFT

#define HDF_BITMAP              0x2000
#define HDF_STRING              0x4000
#define HDF_OWNERDRAW           0x8000 // Same as LVCFMT_COL_HAS_IMAGES
#if (_WIN32_IE >= 0x0300)
#define HDF_IMAGE               0x0800 // Same as LVCFMT_IMAGE
#define HDF_BITMAP_ON_RIGHT     0x1000 // Same as LVCFMT_BITMAP_ON_RIGHT
#endif

#if (_WIN32_WINNT >= 0x0501)
#define HDF_SORTUP              0x0400
#define HDF_SORTDOWN            0x0200
#endif

#if _WIN32_WINNT >= 0x0600
#define HDF_CHECKBOX            0x0040
#define HDF_CHECKED             0x0080
#define HDF_FIXEDWIDTH          0x0100 // Can't resize the column; same as LVCFMT_FIXED_WIDTH
#define HDF_SPLITBUTTON      0x1000000 // Column is a split button; same as LVCFMT_SPLITBUTTON
#endif

#if _WIN32_WINNT >= 0x0600
#define HDIS_FOCUSED            0x00000001
#endif

#define HDM_GETITEMCOUNT        (HDM_FIRST + 0)
#define Header_GetItemCount(hwndHD) \
    (int)SNDMSG((hwndHD), HDM_GETITEMCOUNT, 0, 0L)


#define HDM_INSERTITEMA         (HDM_FIRST + 1)
#define HDM_INSERTITEMW         (HDM_FIRST + 10)

#ifdef UNICODE
#define HDM_INSERTITEM          HDM_INSERTITEMW
#else
#define HDM_INSERTITEM          HDM_INSERTITEMA
#endif

#define Header_InsertItem(hwndHD, i, phdi) \
    (int)SNDMSG((hwndHD), HDM_INSERTITEM, (WPARAM)(int)(i), (LPARAM)(const HD_ITEM *)(phdi))


#define HDM_DELETEITEM          (HDM_FIRST + 2)
#define Header_DeleteItem(hwndHD, i) \
    (BOOL)SNDMSG((hwndHD), HDM_DELETEITEM, (WPARAM)(int)(i), 0L)


#define HDM_GETITEMA            (HDM_FIRST + 3)
#define HDM_GETITEMW            (HDM_FIRST + 11)

#ifdef UNICODE
#define HDM_GETITEM             HDM_GETITEMW
#else
#define HDM_GETITEM             HDM_GETITEMA
#endif

#define Header_GetItem(hwndHD, i, phdi) \
    (BOOL)SNDMSG((hwndHD), HDM_GETITEM, (WPARAM)(int)(i), (LPARAM)(HD_ITEM *)(phdi))


#define HDM_SETITEMA            (HDM_FIRST + 4)
#define HDM_SETITEMW            (HDM_FIRST + 12)

#ifdef UNICODE
#define HDM_SETITEM             HDM_SETITEMW
#else
#define HDM_SETITEM             HDM_SETITEMA
#endif

#define Header_SetItem(hwndHD, i, phdi) \
    (BOOL)SNDMSG((hwndHD), HDM_SETITEM, (WPARAM)(int)(i), (LPARAM)(const HD_ITEM *)(phdi))

#if (_WIN32_IE >= 0x0300)
#define HD_LAYOUT  HDLAYOUT
#else
#define HDLAYOUT   HD_LAYOUT
#endif

typedef struct _HD_LAYOUT
{
    RECT *prc;
    WINDOWPOS *pwpos;
} HDLAYOUT, *LPHDLAYOUT;


#define HDM_LAYOUT              (HDM_FIRST + 5)
#define Header_Layout(hwndHD, playout) \
    (BOOL)SNDMSG((hwndHD), HDM_LAYOUT, 0, (LPARAM)(HD_LAYOUT *)(playout))


#define HHT_NOWHERE             0x0001
#define HHT_ONHEADER            0x0002
#define HHT_ONDIVIDER           0x0004
#define HHT_ONDIVOPEN           0x0008
#if (_WIN32_IE >= 0x0500)
#define HHT_ONFILTER            0x0010
#define HHT_ONFILTERBUTTON      0x0020
#endif
#define HHT_ABOVE               0x0100
#define HHT_BELOW               0x0200
#define HHT_TORIGHT             0x0400
#define HHT_TOLEFT              0x0800
#if _WIN32_WINNT >= 0x0600
#define HHT_ONITEMSTATEICON     0x1000
#define HHT_ONDROPDOWN          0x2000
#define HHT_ONOVERFLOW          0x4000
#endif

#if (_WIN32_IE >= 0x0300)
#define HD_HITTESTINFO HDHITTESTINFO
#else
#define HDHITTESTINFO  HD_HITTESTINFO
#endif

typedef struct _HD_HITTESTINFO
{
    POINT pt;
    UINT flags;
    int iItem;
} HDHITTESTINFO, *LPHDHITTESTINFO;

#define HDSIL_NORMAL            0
#define HDSIL_STATE             1

#define HDM_HITTEST             (HDM_FIRST + 6)

#if (_WIN32_IE >= 0x0300)

#define HDM_GETITEMRECT         (HDM_FIRST + 7)
#define Header_GetItemRect(hwnd, iItem, lprc) \
        (BOOL)SNDMSG((hwnd), HDM_GETITEMRECT, (WPARAM)(iItem), (LPARAM)(lprc))

#define HDM_SETIMAGELIST        (HDM_FIRST + 8)
#define Header_SetImageList(hwnd, himl) \
        (HIMAGELIST)SNDMSG((hwnd), HDM_SETIMAGELIST, HDSIL_NORMAL, (LPARAM)(himl))
#define Header_SetStateImageList(hwnd, himl) \
        (HIMAGELIST)SNDMSG((hwnd), HDM_SETIMAGELIST, HDSIL_STATE, (LPARAM)(himl))

#define HDM_GETIMAGELIST        (HDM_FIRST + 9)
#define Header_GetImageList(hwnd) \
        (HIMAGELIST)SNDMSG((hwnd), HDM_GETIMAGELIST, HDSIL_NORMAL, 0)
#define Header_GetStateImageList(hwnd) \
        (HIMAGELIST)SNDMSG((hwnd), HDM_GETIMAGELIST, HDSIL_STATE, 0)

#define HDM_ORDERTOINDEX        (HDM_FIRST + 15)
#define Header_OrderToIndex(hwnd, i) \
        (int)SNDMSG((hwnd), HDM_ORDERTOINDEX, (WPARAM)(i), 0)

#define HDM_CREATEDRAGIMAGE     (HDM_FIRST + 16)  // wparam = which item (by index)
#define Header_CreateDragImage(hwnd, i) \
        (HIMAGELIST)SNDMSG((hwnd), HDM_CREATEDRAGIMAGE, (WPARAM)(i), 0)

#define HDM_GETORDERARRAY       (HDM_FIRST + 17)
#define Header_GetOrderArray(hwnd, iCount, lpi) \
        (BOOL)SNDMSG((hwnd), HDM_GETORDERARRAY, (WPARAM)(iCount), (LPARAM)(lpi))

#define HDM_SETORDERARRAY       (HDM_FIRST + 18)
#define Header_SetOrderArray(hwnd, iCount, lpi) \
        (BOOL)SNDMSG((hwnd), HDM_SETORDERARRAY, (WPARAM)(iCount), (LPARAM)(lpi))
// lparam = int array of size HDM_GETITEMCOUNT
// the array specifies the order that all items should be displayed.
// e.g.  { 2, 0, 1}
// says the index 2 item should be shown in the 0ths position
//      index 0 should be shown in the 1st position
//      index 1 should be shown in the 2nd position


#define HDM_SETHOTDIVIDER          (HDM_FIRST + 19)
#define Header_SetHotDivider(hwnd, fPos, dw) \
        (int)SNDMSG((hwnd), HDM_SETHOTDIVIDER, (WPARAM)(fPos), (LPARAM)(dw))
// convenience message for external dragdrop
// wParam = BOOL  specifying whether the lParam is a dwPos of the cursor
//              position or the index of which divider to hotlight
// lParam = depends on wParam  (-1 and wParm = FALSE turns off hotlight)
#endif      // _WIN32_IE >= 0x0300

#if (_WIN32_IE >= 0x0500)

#define HDM_SETBITMAPMARGIN          (HDM_FIRST + 20)
#define Header_SetBitmapMargin(hwnd, iWidth) \
        (int)SNDMSG((hwnd), HDM_SETBITMAPMARGIN, (WPARAM)(iWidth), 0)

#define HDM_GETBITMAPMARGIN          (HDM_FIRST + 21)
#define Header_GetBitmapMargin(hwnd) \
        (int)SNDMSG((hwnd), HDM_GETBITMAPMARGIN, 0, 0)
#endif


#if (_WIN32_IE >= 0x0400)
#define HDM_SETUNICODEFORMAT   CCM_SETUNICODEFORMAT
#define Header_SetUnicodeFormat(hwnd, fUnicode)  \
    (BOOL)SNDMSG((hwnd), HDM_SETUNICODEFORMAT, (WPARAM)(fUnicode), 0)

#define HDM_GETUNICODEFORMAT   CCM_GETUNICODEFORMAT
#define Header_GetUnicodeFormat(hwnd)  \
    (BOOL)SNDMSG((hwnd), HDM_GETUNICODEFORMAT, 0, 0)
#endif

#if (_WIN32_IE >= 0x0500)
#define HDM_SETFILTERCHANGETIMEOUT  (HDM_FIRST+22)
#define Header_SetFilterChangeTimeout(hwnd, i) \
        (int)SNDMSG((hwnd), HDM_SETFILTERCHANGETIMEOUT, 0, (LPARAM)(i))

#define HDM_EDITFILTER          (HDM_FIRST+23)
#define Header_EditFilter(hwnd, i, fDiscardChanges) \
        (int)SNDMSG((hwnd), HDM_EDITFILTER, (WPARAM)(i), MAKELPARAM(fDiscardChanges, 0))

// Clear filter takes -1 as a column value to indicate that all
// the filter should be cleared.  When this happens you will
// only receive a single filter changed notification.

#define HDM_CLEARFILTER         (HDM_FIRST+24)
#define Header_ClearFilter(hwnd, i) \
        (int)SNDMSG((hwnd), HDM_CLEARFILTER, (WPARAM)(i), 0)
#define Header_ClearAllFilters(hwnd) \
        (int)SNDMSG((hwnd), HDM_CLEARFILTER, (WPARAM)-1, 0)
#endif

#if (_WIN32_IE >= 0x0600)
#define HDM_TRANSLATEACCELERATOR    CCM_TRANSLATEACCELERATOR
#endif

#if (_WIN32_WINNT >= 0x600)

#define HDM_GETITEMDROPDOWNRECT (HDM_FIRST+25)  // rect of item's drop down button
#define Header_GetItemDropDownRect(hwnd, iItem, lprc) \
        (BOOL)SNDMSG((hwnd), HDM_GETITEMDROPDOWNRECT, (WPARAM)(iItem), (LPARAM)(lprc))

#define HDM_GETOVERFLOWRECT (HDM_FIRST+26)  // rect of overflow button
#define Header_GetOverflowRect(hwnd, lprc) \
        (BOOL)SNDMSG((hwnd), HDM_GETOVERFLOWRECT, 0, (LPARAM)(lprc))

#define HDM_GETFOCUSEDITEM (HDM_FIRST+27)
#define Header_GetFocusedItem(hwnd) \
        (int)SNDMSG((hwnd), HDM_GETFOCUSEDITEM, (WPARAM)(0), (LPARAM)(0))

#define HDM_SETFOCUSEDITEM (HDM_FIRST+28)
#define Header_SetFocusedItem(hwnd, iItem) \
        (BOOL)SNDMSG((hwnd), HDM_SETFOCUSEDITEM, (WPARAM)(0), (LPARAM)(iItem))

#endif // _WIN32_WINNT >= 0x600

#define HDN_ITEMCHANGINGA       (HDN_FIRST-0)
#define HDN_ITEMCHANGINGW       (HDN_FIRST-20)
#define HDN_ITEMCHANGEDA        (HDN_FIRST-1)
#define HDN_ITEMCHANGEDW        (HDN_FIRST-21)
#define HDN_ITEMCLICKA          (HDN_FIRST-2)
#define HDN_ITEMCLICKW          (HDN_FIRST-22)
#define HDN_ITEMDBLCLICKA       (HDN_FIRST-3)
#define HDN_ITEMDBLCLICKW       (HDN_FIRST-23)
#define HDN_DIVIDERDBLCLICKA    (HDN_FIRST-5)
#define HDN_DIVIDERDBLCLICKW    (HDN_FIRST-25)
#define HDN_BEGINTRACKA         (HDN_FIRST-6)
#define HDN_BEGINTRACKW         (HDN_FIRST-26)
#define HDN_ENDTRACKA           (HDN_FIRST-7)
#define HDN_ENDTRACKW           (HDN_FIRST-27)
#define HDN_TRACKA              (HDN_FIRST-8)
#define HDN_TRACKW              (HDN_FIRST-28)
#if (_WIN32_IE >= 0x0300)
#define HDN_GETDISPINFOA        (HDN_FIRST-9)
#define HDN_GETDISPINFOW        (HDN_FIRST-29)
#define HDN_BEGINDRAG           (HDN_FIRST-10)
#define HDN_ENDDRAG             (HDN_FIRST-11)
#endif
#if (_WIN32_IE >= 0x0500)
#define HDN_FILTERCHANGE        (HDN_FIRST-12)
#define HDN_FILTERBTNCLICK      (HDN_FIRST-13)
#endif

#if (_WIN32_IE >= 0x0600)
#define HDN_BEGINFILTEREDIT     (HDN_FIRST-14)
#define HDN_ENDFILTEREDIT       (HDN_FIRST-15)
#endif

#if _WIN32_WINNT >= 0x0600
#define HDN_ITEMSTATEICONCLICK  (HDN_FIRST-16)
#define HDN_ITEMKEYDOWN         (HDN_FIRST-17)
#define HDN_DROPDOWN            (HDN_FIRST-18)
#define HDN_OVERFLOWCLICK       (HDN_FIRST-19)
#endif

#ifdef UNICODE
#define HDN_ITEMCHANGING         HDN_ITEMCHANGINGW
#define HDN_ITEMCHANGED          HDN_ITEMCHANGEDW
#define HDN_ITEMCLICK            HDN_ITEMCLICKW
#define HDN_ITEMDBLCLICK         HDN_ITEMDBLCLICKW
#define HDN_DIVIDERDBLCLICK      HDN_DIVIDERDBLCLICKW
#define HDN_BEGINTRACK           HDN_BEGINTRACKW
#define HDN_ENDTRACK             HDN_ENDTRACKW
#define HDN_TRACK                HDN_TRACKW
#if (_WIN32_IE >= 0x0300)
#define HDN_GETDISPINFO          HDN_GETDISPINFOW
#endif
#else
#define HDN_ITEMCHANGING         HDN_ITEMCHANGINGA
#define HDN_ITEMCHANGED          HDN_ITEMCHANGEDA
#define HDN_ITEMCLICK            HDN_ITEMCLICKA
#define HDN_ITEMDBLCLICK         HDN_ITEMDBLCLICKA
#define HDN_DIVIDERDBLCLICK      HDN_DIVIDERDBLCLICKA
#define HDN_BEGINTRACK           HDN_BEGINTRACKA
#define HDN_ENDTRACK             HDN_ENDTRACKA
#define HDN_TRACK                HDN_TRACKA
#if (_WIN32_IE >= 0x0300)
#define HDN_GETDISPINFO          HDN_GETDISPINFOA
#endif
#endif



#if (_WIN32_IE >= 0x0300)
#define HD_NOTIFYA              NMHEADERA
#define HD_NOTIFYW              NMHEADERW
#else
#define tagNMHEADERA            _HD_NOTIFY
#define NMHEADERA               HD_NOTIFYA
#define tagHMHEADERW            _HD_NOTIFYW
#define NMHEADERW               HD_NOTIFYW
#endif
#define HD_NOTIFY               NMHEADER

typedef struct tagNMHEADERA
{
    NMHDR   hdr;
    int     iItem;
    int     iButton;
    HDITEMA *pitem;
}  NMHEADERA, *LPNMHEADERA;


typedef struct tagNMHEADERW
{
    NMHDR   hdr;
    int     iItem;
    int     iButton;
    HDITEMW *pitem;
} NMHEADERW, *LPNMHEADERW;

#ifdef UNICODE
#define NMHEADER                NMHEADERW
#define LPNMHEADER              LPNMHEADERW
#else
#define NMHEADER                NMHEADERA
#define LPNMHEADER              LPNMHEADERA
#endif

typedef struct tagNMHDDISPINFOW
{
    NMHDR   hdr;
    int     iItem;
    UINT    mask;
    LPWSTR  pszText;
    int     cchTextMax;
    int     iImage;
    LPARAM  lParam;
} NMHDDISPINFOW, *LPNMHDDISPINFOW;

typedef struct tagNMHDDISPINFOA
{
    NMHDR   hdr;
    int     iItem;
    UINT    mask;
    LPSTR   pszText;
    int     cchTextMax;
    int     iImage;
    LPARAM  lParam;
} NMHDDISPINFOA, *LPNMHDDISPINFOA;


#ifdef UNICODE
#define NMHDDISPINFO            NMHDDISPINFOW
#define LPNMHDDISPINFO          LPNMHDDISPINFOW
#else
#define NMHDDISPINFO            NMHDDISPINFOA
#define LPNMHDDISPINFO          LPNMHDDISPINFOA
#endif

#if (_WIN32_IE >= 0x0500)
typedef struct tagNMHDFILTERBTNCLICK
{
    NMHDR hdr;
    INT iItem;
    RECT rc;
} NMHDFILTERBTNCLICK, *LPNMHDFILTERBTNCLICK;
#endif

#endif      // NOHEADER


//====== TOOLBAR CONTROL ======================================================

#ifndef NOTOOLBAR

#ifdef _WIN32
#define TOOLBARCLASSNAMEW       L"ToolbarWindow32"
#define TOOLBARCLASSNAMEA       "ToolbarWindow32"

#ifdef  UNICODE
#define TOOLBARCLASSNAME        TOOLBARCLASSNAMEW
#else
#define TOOLBARCLASSNAME        TOOLBARCLASSNAMEA
#endif

#else
#define TOOLBARCLASSNAME        "ToolbarWindow"
#endif

typedef struct _TBBUTTON {
    int iBitmap;
    int idCommand;
    BYTE fsState;
    BYTE fsStyle;
#ifdef _WIN64
    BYTE bReserved[6];          // padding for alignment
#elif defined(_WIN32)
    BYTE bReserved[2];          // padding for alignment
#endif
    DWORD_PTR dwData;
    INT_PTR iString;
} TBBUTTON, NEAR* PTBBUTTON, *LPTBBUTTON;
typedef const TBBUTTON *LPCTBBUTTON;


typedef struct _COLORMAP {
    COLORREF from;
    COLORREF to;
} COLORMAP, *LPCOLORMAP;

WINCOMMCTRLAPI HWND WINAPI CreateToolbarEx(HWND hwnd, DWORD ws, UINT wID, int nBitmaps,
                        HINSTANCE hBMInst, UINT_PTR wBMID, LPCTBBUTTON lpButtons,
                        int iNumButtons, int dxButton, int dyButton,
                        int dxBitmap, int dyBitmap, UINT uStructSize);

WINCOMMCTRLAPI HBITMAP WINAPI CreateMappedBitmap(HINSTANCE hInstance, INT_PTR idBitmap,
                                  UINT wFlags, __in_opt LPCOLORMAP lpColorMap,
                                  int iNumMaps);

#define CMB_MASKED              0x02
#define TBSTATE_CHECKED         0x01
#define TBSTATE_PRESSED         0x02
#define TBSTATE_ENABLED         0x04
#define TBSTATE_HIDDEN          0x08
#define TBSTATE_INDETERMINATE   0x10
#define TBSTATE_WRAP            0x20
#if (_WIN32_IE >= 0x0300)
#define TBSTATE_ELLIPSES        0x40
#endif
#if (_WIN32_IE >= 0x0400)
#define TBSTATE_MARKED          0x80
#endif

// begin_r_commctrl

#define TBSTYLE_BUTTON          0x0000  // obsolete; use BTNS_BUTTON instead
#define TBSTYLE_SEP             0x0001  // obsolete; use BTNS_SEP instead
#define TBSTYLE_CHECK           0x0002  // obsolete; use BTNS_CHECK instead
#define TBSTYLE_GROUP           0x0004  // obsolete; use BTNS_GROUP instead
#define TBSTYLE_CHECKGROUP      (TBSTYLE_GROUP | TBSTYLE_CHECK)     // obsolete; use BTNS_CHECKGROUP instead
#if (_WIN32_IE >= 0x0300)
#define TBSTYLE_DROPDOWN        0x0008  // obsolete; use BTNS_DROPDOWN instead
#endif
#if (_WIN32_IE >= 0x0400)
#define TBSTYLE_AUTOSIZE        0x0010  // obsolete; use BTNS_AUTOSIZE instead
#define TBSTYLE_NOPREFIX        0x0020  // obsolete; use BTNS_NOPREFIX instead
#endif

#define TBSTYLE_TOOLTIPS        0x0100
#define TBSTYLE_WRAPABLE        0x0200
#define TBSTYLE_ALTDRAG         0x0400
#if (_WIN32_IE >= 0x0300)
#define TBSTYLE_FLAT            0x0800
#define TBSTYLE_LIST            0x1000
#define TBSTYLE_CUSTOMERASE     0x2000
#endif
#if (_WIN32_IE >= 0x0400)
#define TBSTYLE_REGISTERDROP    0x4000
#define TBSTYLE_TRANSPARENT     0x8000

// end_r_commctrl

#define TBSTYLE_EX_DRAWDDARROWS 0x00000001

// begin_r_commctrl
#endif

#if (_WIN32_IE >= 0x0500)
#define BTNS_BUTTON     TBSTYLE_BUTTON      // 0x0000
#define BTNS_SEP        TBSTYLE_SEP         // 0x0001
#define BTNS_CHECK      TBSTYLE_CHECK       // 0x0002
#define BTNS_GROUP      TBSTYLE_GROUP       // 0x0004
#define BTNS_CHECKGROUP TBSTYLE_CHECKGROUP  // (TBSTYLE_GROUP | TBSTYLE_CHECK)
#define BTNS_DROPDOWN   TBSTYLE_DROPDOWN    // 0x0008
#define BTNS_AUTOSIZE   TBSTYLE_AUTOSIZE    // 0x0010; automatically calculate the cx of the button
#define BTNS_NOPREFIX   TBSTYLE_NOPREFIX    // 0x0020; this button should not have accel prefix
#if (_WIN32_IE >= 0x0501)
#define BTNS_SHOWTEXT   0x0040              // ignored unless TBSTYLE_EX_MIXEDBUTTONS is set
#endif  // 0x0501
#define BTNS_WHOLEDROPDOWN  0x0080          // draw drop-down arrow, but without split arrow section
#endif

// end_r_commctrl

#if (_WIN32_IE >= 0x0501)
#define TBSTYLE_EX_MIXEDBUTTONS             0x00000008
#define TBSTYLE_EX_HIDECLIPPEDBUTTONS       0x00000010  // don't show partially obscured buttons
#endif  // 0x0501


#if (_WIN32_WINNT >= 0x0501)
#define TBSTYLE_EX_DOUBLEBUFFER             0x00000080 // Double Buffer the toolbar
#endif


#if (_WIN32_IE >= 0x0400)
// Custom Draw Structure
typedef struct _NMTBCUSTOMDRAW {
    NMCUSTOMDRAW nmcd;
    HBRUSH hbrMonoDither;
    HBRUSH hbrLines;                // For drawing lines on buttons
    HPEN hpenLines;                 // For drawing lines on buttons

    COLORREF clrText;               // Color of text
    COLORREF clrMark;               // Color of text bk when marked. (only if TBSTATE_MARKED)
    COLORREF clrTextHighlight;      // Color of text when highlighted
    COLORREF clrBtnFace;            // Background of the button
    COLORREF clrBtnHighlight;       // 3D highlight
    COLORREF clrHighlightHotTrack;  // In conjunction with fHighlightHotTrack
                                    // will cause button to highlight like a menu
    RECT rcText;                    // Rect for text

    int nStringBkMode;
    int nHLStringBkMode;
#if (_WIN32_WINNT >= 0x0501)
    int iListGap;
#endif
} NMTBCUSTOMDRAW, * LPNMTBCUSTOMDRAW;

// Toolbar custom draw return flags
#define TBCDRF_NOEDGES              0x00010000  // Don't draw button edges
#define TBCDRF_HILITEHOTTRACK       0x00020000  // Use color of the button bk when hottracked
#define TBCDRF_NOOFFSET             0x00040000  // Don't offset button if pressed
#define TBCDRF_NOMARK               0x00080000  // Don't draw default highlight of image/text for TBSTATE_MARKED
#define TBCDRF_NOETCHEDEFFECT       0x00100000  // Don't draw etched effect for disabled items
#endif

#if (_WIN32_IE >= 0x0500)
#define TBCDRF_BLENDICON            0x00200000  // Use ILD_BLEND50 on the icon image
#define TBCDRF_NOBACKGROUND         0x00400000  // Use ILD_BLEND50 on the icon image
#endif
#if _WIN32_WINNT >= 0x0600
#define TBCDRF_USECDCOLORS          0x00800000  // Use CustomDrawColors to RenderText regardless of VisualStyle
#endif

#define TB_ENABLEBUTTON         (WM_USER + 1)
#define TB_CHECKBUTTON          (WM_USER + 2)
#define TB_PRESSBUTTON          (WM_USER + 3)
#define TB_HIDEBUTTON           (WM_USER + 4)
#define TB_INDETERMINATE        (WM_USER + 5)
#if (_WIN32_IE >= 0x0400)
#define TB_MARKBUTTON           (WM_USER + 6)
#endif
#define TB_ISBUTTONENABLED      (WM_USER + 9)
#define TB_ISBUTTONCHECKED      (WM_USER + 10)
#define TB_ISBUTTONPRESSED      (WM_USER + 11)
#define TB_ISBUTTONHIDDEN       (WM_USER + 12)
#define TB_ISBUTTONINDETERMINATE (WM_USER + 13)
#if (_WIN32_IE >= 0x0400)
#define TB_ISBUTTONHIGHLIGHTED  (WM_USER + 14)
#endif
#define TB_SETSTATE             (WM_USER + 17)
#define TB_GETSTATE             (WM_USER + 18)
#define TB_ADDBITMAP            (WM_USER + 19)

#ifdef _WIN32
typedef struct tagTBADDBITMAP {
        HINSTANCE       hInst;
        UINT_PTR        nID;
} TBADDBITMAP, *LPTBADDBITMAP;

#define HINST_COMMCTRL          ((HINSTANCE)-1)
#define IDB_STD_SMALL_COLOR     0
#define IDB_STD_LARGE_COLOR     1
#define IDB_VIEW_SMALL_COLOR    4
#define IDB_VIEW_LARGE_COLOR    5
#if (_WIN32_IE >= 0x0300)
#define IDB_HIST_SMALL_COLOR    8
#define IDB_HIST_LARGE_COLOR    9
#endif
#if (_WIN32_WINNT >= 0x600)
#define IDB_HIST_NORMAL         12
#define IDB_HIST_HOT            13
#define IDB_HIST_DISABLED       14
#define IDB_HIST_PRESSED        15
#endif // _WIN32_WINNT >= 0x600

// icon indexes for standard bitmap

#define STD_CUT                 0
#define STD_COPY                1
#define STD_PASTE               2
#define STD_UNDO                3
#define STD_REDOW               4
#define STD_DELETE              5
#define STD_FILENEW             6
#define STD_FILEOPEN            7
#define STD_FILESAVE            8
#define STD_PRINTPRE            9
#define STD_PROPERTIES          10
#define STD_HELP                11
#define STD_FIND                12
#define STD_REPLACE             13
#define STD_PRINT               14

// icon indexes for standard view bitmap

#define VIEW_LARGEICONS         0
#define VIEW_SMALLICONS         1
#define VIEW_LIST               2
#define VIEW_DETAILS            3
#define VIEW_SORTNAME           4
#define VIEW_SORTSIZE           5
#define VIEW_SORTDATE           6
#define VIEW_SORTTYPE           7
#define VIEW_PARENTFOLDER       8
#define VIEW_NETCONNECT         9
#define VIEW_NETDISCONNECT      10
#define VIEW_NEWFOLDER          11
#if (_WIN32_IE >= 0x0400)
#define VIEW_VIEWMENU           12
#endif

#if (_WIN32_IE >= 0x0300)
#define HIST_BACK               0
#define HIST_FORWARD            1
#define HIST_FAVORITES          2
#define HIST_ADDTOFAVORITES     3
#define HIST_VIEWTREE           4
#endif

#endif

#if (_WIN32_IE >= 0x0400)
#define TB_ADDBUTTONSA          (WM_USER + 20)
#define TB_INSERTBUTTONA        (WM_USER + 21)
#else
#define TB_ADDBUTTONS           (WM_USER + 20)
#define TB_INSERTBUTTON         (WM_USER + 21)
#endif

#define TB_DELETEBUTTON         (WM_USER + 22)
#define TB_GETBUTTON            (WM_USER + 23)
#define TB_BUTTONCOUNT          (WM_USER + 24)
#define TB_COMMANDTOINDEX       (WM_USER + 25)

#ifdef _WIN32

typedef struct tagTBSAVEPARAMSA {
    HKEY hkr;
    LPCSTR pszSubKey;
    LPCSTR pszValueName;
} TBSAVEPARAMSA, *LPTBSAVEPARAMSA;

typedef struct tagTBSAVEPARAMSW {
    HKEY hkr;
    LPCWSTR pszSubKey;
    LPCWSTR pszValueName;
} TBSAVEPARAMSW, *LPTBSAVEPARAMW;

#ifdef UNICODE
#define TBSAVEPARAMS            TBSAVEPARAMSW
#define LPTBSAVEPARAMS          LPTBSAVEPARAMSW
#else
#define TBSAVEPARAMS            TBSAVEPARAMSA
#define LPTBSAVEPARAMS          LPTBSAVEPARAMSA
#endif

#endif  // _WIN32

#define TB_SAVERESTOREA         (WM_USER + 26)
#define TB_SAVERESTOREW         (WM_USER + 76)
#define TB_CUSTOMIZE            (WM_USER + 27)
#define TB_ADDSTRINGA           (WM_USER + 28)
#define TB_ADDSTRINGW           (WM_USER + 77)
#define TB_GETITEMRECT          (WM_USER + 29)
#define TB_BUTTONSTRUCTSIZE     (WM_USER + 30)
#define TB_SETBUTTONSIZE        (WM_USER + 31)
#define TB_SETBITMAPSIZE        (WM_USER + 32)
#define TB_AUTOSIZE             (WM_USER + 33)
#define TB_GETTOOLTIPS          (WM_USER + 35)
#define TB_SETTOOLTIPS          (WM_USER + 36)
#define TB_SETPARENT            (WM_USER + 37)
#define TB_SETROWS              (WM_USER + 39)
#define TB_GETROWS              (WM_USER + 40)
#define TB_SETCMDID             (WM_USER + 42)
#define TB_CHANGEBITMAP         (WM_USER + 43)
#define TB_GETBITMAP            (WM_USER + 44)
#define TB_GETBUTTONTEXTA       (WM_USER + 45)
#define TB_GETBUTTONTEXTW       (WM_USER + 75)
#define TB_REPLACEBITMAP        (WM_USER + 46)
#if (_WIN32_IE >= 0x0300)
#define TB_SETINDENT            (WM_USER + 47)
#define TB_SETIMAGELIST         (WM_USER + 48)
#define TB_GETIMAGELIST         (WM_USER + 49)
#define TB_LOADIMAGES           (WM_USER + 50)
#define TB_GETRECT              (WM_USER + 51) // wParam is the Cmd instead of index
#define TB_SETHOTIMAGELIST      (WM_USER + 52)
#define TB_GETHOTIMAGELIST      (WM_USER + 53)
#define TB_SETDISABLEDIMAGELIST (WM_USER + 54)
#define TB_GETDISABLEDIMAGELIST (WM_USER + 55)
#define TB_SETSTYLE             (WM_USER + 56)
#define TB_GETSTYLE             (WM_USER + 57)
#define TB_GETBUTTONSIZE        (WM_USER + 58)
#define TB_SETBUTTONWIDTH       (WM_USER + 59)
#define TB_SETMAXTEXTROWS       (WM_USER + 60)
#define TB_GETTEXTROWS          (WM_USER + 61)
#endif      // _WIN32_IE >= 0x0300

#ifdef UNICODE
#define TB_GETBUTTONTEXT        TB_GETBUTTONTEXTW
#define TB_SAVERESTORE          TB_SAVERESTOREW
#define TB_ADDSTRING            TB_ADDSTRINGW
#else
#define TB_GETBUTTONTEXT        TB_GETBUTTONTEXTA
#define TB_SAVERESTORE          TB_SAVERESTOREA
#define TB_ADDSTRING            TB_ADDSTRINGA
#endif
#if (_WIN32_IE >= 0x0400)
#define TB_GETOBJECT            (WM_USER + 62)  // wParam == IID, lParam void **ppv
#define TB_GETHOTITEM           (WM_USER + 71)
#define TB_SETHOTITEM           (WM_USER + 72)  // wParam == iHotItem
#define TB_SETANCHORHIGHLIGHT   (WM_USER + 73)  // wParam == TRUE/FALSE
#define TB_GETANCHORHIGHLIGHT   (WM_USER + 74)
#define TB_MAPACCELERATORA      (WM_USER + 78)  // wParam == ch, lParam int * pidBtn

typedef struct {
    int   iButton;
    DWORD dwFlags;
} TBINSERTMARK, * LPTBINSERTMARK;
#define TBIMHT_AFTER      0x00000001 // TRUE = insert After iButton, otherwise before
#define TBIMHT_BACKGROUND 0x00000002 // TRUE iff missed buttons completely

#define TB_GETINSERTMARK        (WM_USER + 79)  // lParam == LPTBINSERTMARK
#define TB_SETINSERTMARK        (WM_USER + 80)  // lParam == LPTBINSERTMARK
#define TB_INSERTMARKHITTEST    (WM_USER + 81)  // wParam == LPPOINT lParam == LPTBINSERTMARK
#define TB_MOVEBUTTON           (WM_USER + 82)
#define TB_GETMAXSIZE           (WM_USER + 83)  // lParam == LPSIZE
#define TB_SETEXTENDEDSTYLE     (WM_USER + 84)  // For TBSTYLE_EX_*
#define TB_GETEXTENDEDSTYLE     (WM_USER + 85)  // For TBSTYLE_EX_*
#define TB_GETPADDING           (WM_USER + 86)
#define TB_SETPADDING           (WM_USER + 87)
#define TB_SETINSERTMARKCOLOR   (WM_USER + 88)
#define TB_GETINSERTMARKCOLOR   (WM_USER + 89)

#define TB_SETCOLORSCHEME       CCM_SETCOLORSCHEME  // lParam is color scheme
#define TB_GETCOLORSCHEME       CCM_GETCOLORSCHEME      // fills in COLORSCHEME pointed to by lParam

#define TB_SETUNICODEFORMAT     CCM_SETUNICODEFORMAT
#define TB_GETUNICODEFORMAT     CCM_GETUNICODEFORMAT

#define TB_MAPACCELERATORW      (WM_USER + 90)  // wParam == ch, lParam int * pidBtn
#ifdef UNICODE
#define TB_MAPACCELERATOR       TB_MAPACCELERATORW
#else
#define TB_MAPACCELERATOR       TB_MAPACCELERATORA
#endif

#endif  // _WIN32_IE >= 0x0400

typedef struct {
    HINSTANCE       hInstOld;
    UINT_PTR        nIDOld;
    HINSTANCE       hInstNew;
    UINT_PTR        nIDNew;
    int             nButtons;
} TBREPLACEBITMAP, *LPTBREPLACEBITMAP;

#ifdef _WIN32

#define TBBF_LARGE              0x0001

#define TB_GETBITMAPFLAGS       (WM_USER + 41)

#if (_WIN32_IE >= 0x0400)
#define TBIF_IMAGE              0x00000001
#define TBIF_TEXT               0x00000002
#define TBIF_STATE              0x00000004
#define TBIF_STYLE              0x00000008
#define TBIF_LPARAM             0x00000010
#define TBIF_COMMAND            0x00000020
#define TBIF_SIZE               0x00000040

#if (_WIN32_IE >= 0x0500)
#define TBIF_BYINDEX            0x80000000 // this specifies that the wparam in Get/SetButtonInfo is an index, not id
#endif

typedef struct {
    UINT cbSize;
    DWORD dwMask;
    int idCommand;
    int iImage;
    BYTE fsState;
    BYTE fsStyle;
    WORD cx;
    DWORD_PTR lParam;
    LPSTR pszText;
    int cchText;
} TBBUTTONINFOA, *LPTBBUTTONINFOA;

typedef struct {
    UINT cbSize;
    DWORD dwMask;
    int idCommand;
    int iImage;
    BYTE fsState;
    BYTE fsStyle;
    WORD cx;
    DWORD_PTR lParam;
    LPWSTR pszText;
    int cchText;
} TBBUTTONINFOW, *LPTBBUTTONINFOW;

#ifdef UNICODE
#define TBBUTTONINFO TBBUTTONINFOW
#define LPTBBUTTONINFO LPTBBUTTONINFOW
#else
#define TBBUTTONINFO TBBUTTONINFOA
#define LPTBBUTTONINFO LPTBBUTTONINFOA
#endif

// BUTTONINFO APIs do NOT support the string pool.
#define TB_GETBUTTONINFOW        (WM_USER + 63)
#define TB_SETBUTTONINFOW        (WM_USER + 64)
#define TB_GETBUTTONINFOA        (WM_USER + 65)
#define TB_SETBUTTONINFOA        (WM_USER + 66)
#ifdef UNICODE
#define TB_GETBUTTONINFO        TB_GETBUTTONINFOW
#define TB_SETBUTTONINFO        TB_SETBUTTONINFOW
#else
#define TB_GETBUTTONINFO        TB_GETBUTTONINFOA
#define TB_SETBUTTONINFO        TB_SETBUTTONINFOA
#endif


#define TB_INSERTBUTTONW        (WM_USER + 67)
#define TB_ADDBUTTONSW          (WM_USER + 68)

#define TB_HITTEST              (WM_USER + 69)

// New post Win95/NT4 for InsertButton and AddButton.  if iString member
// is a pointer to a string, it will be handled as a string like listview
// (although LPSTR_TEXTCALLBACK is not supported).
#ifdef UNICODE
#define TB_INSERTBUTTON         TB_INSERTBUTTONW
#define TB_ADDBUTTONS           TB_ADDBUTTONSW
#else
#define TB_INSERTBUTTON         TB_INSERTBUTTONA
#define TB_ADDBUTTONS           TB_ADDBUTTONSA
#endif

#define TB_SETDRAWTEXTFLAGS     (WM_USER + 70)  // wParam == mask lParam == bit values

#endif  // _WIN32_IE >= 0x0400

#if (_WIN32_IE >= 0x0500)

#define TB_GETSTRINGW           (WM_USER + 91)
#define TB_GETSTRINGA           (WM_USER + 92)
#ifdef UNICODE
#define TB_GETSTRING            TB_GETSTRINGW
#else
#define TB_GETSTRING            TB_GETSTRINGA
#endif


#endif  // _WIN32_IE >= 0x0500

#if (_WIN32_WINNT >= 0x0501)
#define TBMF_PAD                0x00000001
#define TBMF_BARPAD             0x00000002
#define TBMF_BUTTONSPACING      0x00000004

typedef struct {
    UINT cbSize;
    DWORD dwMask;

    int cxPad;        // PAD
    int cyPad;
    int cxBarPad;     // BARPAD
    int cyBarPad;
    int cxButtonSpacing;   // BUTTONSPACING
    int cyButtonSpacing;
} TBMETRICS, * LPTBMETRICS;

#define TB_GETMETRICS           (WM_USER + 101)
#define TB_SETMETRICS           (WM_USER + 102)
#endif

#if (_WIN32_WINNT >= 0x600)
#define TB_SETPRESSEDIMAGELIST  (WM_USER + 104)
#define TB_GETPRESSEDIMAGELIST  (WM_USER + 105)
#endif // _WIN32_WINNT >= 0x600

#if (_WIN32_WINNT >= 0x0501)
#define TB_SETWINDOWTHEME       CCM_SETWINDOWTHEME
#endif

#define TBN_GETBUTTONINFOA      (TBN_FIRST-0)
#define TBN_BEGINDRAG           (TBN_FIRST-1)
#define TBN_ENDDRAG             (TBN_FIRST-2)
#define TBN_BEGINADJUST         (TBN_FIRST-3)
#define TBN_ENDADJUST           (TBN_FIRST-4)
#define TBN_RESET               (TBN_FIRST-5)
#define TBN_QUERYINSERT         (TBN_FIRST-6)
#define TBN_QUERYDELETE         (TBN_FIRST-7)
#define TBN_TOOLBARCHANGE       (TBN_FIRST-8)
#define TBN_CUSTHELP            (TBN_FIRST-9)
#if (_WIN32_IE >= 0x0300)
#define TBN_DROPDOWN            (TBN_FIRST - 10)
#endif
#if (_WIN32_IE >= 0x0400)
#define TBN_GETOBJECT           (TBN_FIRST - 12)

// Structure for TBN_HOTITEMCHANGE notification
//
typedef struct tagNMTBHOTITEM
{
    NMHDR   hdr;
    int     idOld;
    int     idNew;
    DWORD   dwFlags;           // HICF_*
} NMTBHOTITEM, * LPNMTBHOTITEM;

// Hot item change flags
#define HICF_OTHER          0x00000000
#define HICF_MOUSE          0x00000001          // Triggered by mouse
#define HICF_ARROWKEYS      0x00000002          // Triggered by arrow keys
#define HICF_ACCELERATOR    0x00000004          // Triggered by accelerator
#define HICF_DUPACCEL       0x00000008          // This accelerator is not unique
#define HICF_ENTERING       0x00000010          // idOld is invalid
#define HICF_LEAVING        0x00000020          // idNew is invalid
#define HICF_RESELECT       0x00000040          // hot item reselected
#define HICF_LMOUSE         0x00000080          // left mouse button selected
#define HICF_TOGGLEDROPDOWN 0x00000100          // Toggle button's dropdown state


#define TBN_HOTITEMCHANGE       (TBN_FIRST - 13)
#define TBN_DRAGOUT             (TBN_FIRST - 14) // this is sent when the user clicks down on a button then drags off the button
#define TBN_DELETINGBUTTON      (TBN_FIRST - 15) // uses TBNOTIFY
#define TBN_GETDISPINFOA        (TBN_FIRST - 16) // This is sent when the  toolbar needs  some display information
#define TBN_GETDISPINFOW        (TBN_FIRST - 17) // This is sent when the  toolbar needs  some display information
#define TBN_GETINFOTIPA         (TBN_FIRST - 18)
#define TBN_GETINFOTIPW         (TBN_FIRST - 19)
#define TBN_GETBUTTONINFOW      (TBN_FIRST - 20)
#if (_WIN32_IE >= 0x0500)
#define TBN_RESTORE             (TBN_FIRST - 21)
#define TBN_SAVE                (TBN_FIRST - 22)
#define TBN_INITCUSTOMIZE       (TBN_FIRST - 23)
#define    TBNRF_HIDEHELP       0x00000001
#define    TBNRF_ENDCUSTOMIZE   0x00000002
#endif // (_WIN32_IE >= 0x0500)



#if (_WIN32_IE >= 0x0500)

typedef struct tagNMTBSAVE
{
    NMHDR hdr;
    DWORD* pData;
    DWORD* pCurrent;
    UINT cbData;
    int iItem;
    int cButtons;
    TBBUTTON tbButton;
} NMTBSAVE, *LPNMTBSAVE;

typedef struct tagNMTBRESTORE
{
    NMHDR hdr;
    DWORD* pData;
    DWORD* pCurrent;
    UINT cbData;
    int iItem;
    int cButtons;
    int cbBytesPerRecord;
    TBBUTTON tbButton;
} NMTBRESTORE, *LPNMTBRESTORE;
#endif // (_WIN32_IE >= 0x0500)

typedef struct tagNMTBGETINFOTIPA
{
    NMHDR hdr;
    LPSTR pszText;
    int cchTextMax;
    int iItem;
    LPARAM lParam;
} NMTBGETINFOTIPA, *LPNMTBGETINFOTIPA;

typedef struct tagNMTBGETINFOTIPW
{
    NMHDR hdr;
    LPWSTR pszText;
    int cchTextMax;
    int iItem;
    LPARAM lParam;
} NMTBGETINFOTIPW, *LPNMTBGETINFOTIPW;

#ifdef UNICODE
#define TBN_GETINFOTIP          TBN_GETINFOTIPW
#define NMTBGETINFOTIP          NMTBGETINFOTIPW
#define LPNMTBGETINFOTIP        LPNMTBGETINFOTIPW
#else
#define TBN_GETINFOTIP          TBN_GETINFOTIPA
#define NMTBGETINFOTIP          NMTBGETINFOTIPA
#define LPNMTBGETINFOTIP        LPNMTBGETINFOTIPA
#endif

#define TBNF_IMAGE              0x00000001
#define TBNF_TEXT               0x00000002
#define TBNF_DI_SETITEM         0x10000000

typedef struct {
    NMHDR  hdr;
    DWORD dwMask;     // [in] Specifies the values requested .[out] Client ask the data to be set for future use
    int idCommand;    // [in] id of button we're requesting info for
    DWORD_PTR lParam;  // [in] lParam of button
    int iImage;       // [out] image index
    LPSTR pszText;    // [out] new text for item
    int cchText;      // [in] size of buffer pointed to by pszText
} NMTBDISPINFOA, *LPNMTBDISPINFOA;

typedef struct {
    NMHDR hdr;
    DWORD dwMask;      //[in] Specifies the values requested .[out] Client ask the data to be set for future use
    int idCommand;    // [in] id of button we're requesting info for
    DWORD_PTR lParam;  // [in] lParam of button
    int iImage;       // [out] image index
    LPWSTR pszText;   // [out] new text for item
    int cchText;      // [in] size of buffer pointed to by pszText
} NMTBDISPINFOW, *LPNMTBDISPINFOW;


#ifdef UNICODE
#define TBN_GETDISPINFO       TBN_GETDISPINFOW
#define NMTBDISPINFO          NMTBDISPINFOW
#define LPNMTBDISPINFO        LPNMTBDISPINFOW
#else
#define TBN_GETDISPINFO       TBN_GETDISPINFOA
#define NMTBDISPINFO          NMTBDISPINFOA
#define LPNMTBDISPINFO        LPNMTBDISPINFOA
#endif

// Return codes for TBN_DROPDOWN
#define TBDDRET_DEFAULT         0
#define TBDDRET_NODEFAULT       1
#define TBDDRET_TREATPRESSED    2       // Treat as a standard press button

#endif


#ifdef UNICODE
#define TBN_GETBUTTONINFO       TBN_GETBUTTONINFOW
#else
#define TBN_GETBUTTONINFO       TBN_GETBUTTONINFOA
#endif

#if (_WIN32_IE >= 0x0300)
#define TBNOTIFYA NMTOOLBARA
#define TBNOTIFYW NMTOOLBARW
#define LPTBNOTIFYA LPNMTOOLBARA
#define LPTBNOTIFYW LPNMTOOLBARW
#else
#define tagNMTOOLBARA  tagTBNOTIFYA
#define NMTOOLBARA     TBNOTIFYA
#define LPNMTOOLBARA   LPTBNOTIFYA
#define tagNMTOOLBARW  tagTBNOTIFYW
#define NMTOOLBARW     TBNOTIFYW
#define LPNMTOOLBARW   LPTBNOTIFYW
#endif

#define TBNOTIFY       NMTOOLBAR
#define LPTBNOTIFY     LPNMTOOLBAR

#if (_WIN32_IE >= 0x0300)
typedef struct tagNMTOOLBARA {
    NMHDR   hdr;
    int     iItem;
    TBBUTTON tbButton;
    int     cchText;
    LPSTR   pszText;
#if (_WIN32_IE >= 0x500)
    RECT    rcButton;
#endif
} NMTOOLBARA, *LPNMTOOLBARA;
#endif


#if (_WIN32_IE >= 0x0300)
typedef struct tagNMTOOLBARW {
    NMHDR   hdr;
    int     iItem;
    TBBUTTON tbButton;
    int     cchText;
    LPWSTR   pszText;
#if (_WIN32_IE >= 0x500)
    RECT    rcButton;
#endif
} NMTOOLBARW, *LPNMTOOLBARW;
#endif


#ifdef UNICODE
#define NMTOOLBAR               NMTOOLBARW
#define LPNMTOOLBAR             LPNMTOOLBARW
#else
#define NMTOOLBAR               NMTOOLBARA
#define LPNMTOOLBAR             LPNMTOOLBARA
#endif

#endif

#endif      // NOTOOLBAR


#if (_WIN32_IE >= 0x0300)
//====== REBAR CONTROL ========================================================

#ifndef NOREBAR

#ifdef _WIN32
#define REBARCLASSNAMEW         L"ReBarWindow32"
#define REBARCLASSNAMEA         "ReBarWindow32"

#ifdef  UNICODE
#define REBARCLASSNAME          REBARCLASSNAMEW
#else
#define REBARCLASSNAME          REBARCLASSNAMEA
#endif

#else
#define REBARCLASSNAME          "ReBarWindow"
#endif

#define RBIM_IMAGELIST   0x00000001

// begin_r_commctrl

#define RBS_TOOLTIPS                  0x00000100
#define RBS_VARHEIGHT                 0x00000200
#define RBS_BANDBORDERS               0x00000400
#define RBS_FIXEDORDER                0x00000800
#if (_WIN32_IE >= 0x0400)
#define RBS_REGISTERDROP              0x00001000
#define RBS_AUTOSIZE                  0x00002000
#define RBS_VERTICALGRIPPER           0x00004000  // this always has the vertical gripper (default for horizontal mode)
#define RBS_DBLCLKTOGGLE              0x00008000
#endif      // _WIN32_IE >= 0x0400

// end_r_commctrl

typedef struct tagREBARINFO
{
    UINT        cbSize;
    UINT        fMask;
#ifndef NOIMAGEAPIS
    HIMAGELIST  himl;
#else
    HANDLE      himl;
#endif
}   REBARINFO, *LPREBARINFO;


#define RBBS_BREAK          0x00000001  // break to new line
#define RBBS_FIXEDSIZE      0x00000002  // band can't be sized
#define RBBS_CHILDEDGE      0x00000004  // edge around top & bottom of child window
#define RBBS_HIDDEN         0x00000008  // don't show
#define RBBS_NOVERT         0x00000010  // don't show when vertical
#define RBBS_FIXEDBMP       0x00000020  // bitmap doesn't move during band resize
#if (_WIN32_IE >= 0x0400)               //
#define RBBS_VARIABLEHEIGHT 0x00000040  // allow autosizing of this child vertically
#define RBBS_GRIPPERALWAYS  0x00000080  // always show the gripper
#define RBBS_NOGRIPPER      0x00000100  // never show the gripper
#if (_WIN32_IE >= 0x0500)               //
#define RBBS_USECHEVRON     0x00000200  // display drop-down button for this band if it's sized smaller than ideal width
#if (_WIN32_IE >= 0x0501)               //
#define RBBS_HIDETITLE      0x00000400  // keep band title hidden
#define RBBS_TOPALIGN       0x00000800  // keep band in top row
#endif // 0x0501                        //
#endif // 0x0500                        //
#endif // 0x0400                        //
#if (_WIN32_WINNT >= 0x0600)
#endif



#define RBBIM_STYLE         0x00000001
#define RBBIM_COLORS        0x00000002
#define RBBIM_TEXT          0x00000004
#define RBBIM_IMAGE         0x00000008
#define RBBIM_CHILD         0x00000010
#define RBBIM_CHILDSIZE     0x00000020
#define RBBIM_SIZE          0x00000040
#define RBBIM_BACKGROUND    0x00000080
#define RBBIM_ID            0x00000100
#if (_WIN32_IE >= 0x0400)
#define RBBIM_IDEALSIZE     0x00000200
#define RBBIM_LPARAM        0x00000400
#define RBBIM_HEADERSIZE    0x00000800  // control the size of the header
#endif
#if (_WIN32_WINNT >= 0x0600)
#define RBBIM_CHEVRONLOCATION 0x00001000
#define RBBIM_CHEVRONSTATE    0x00002000
#endif

typedef struct tagREBARBANDINFOA
{
    UINT        cbSize;
    UINT        fMask;
    UINT        fStyle;
    COLORREF    clrFore;
    COLORREF    clrBack;
    LPSTR       lpText;
    UINT        cch;
    int         iImage;
    HWND        hwndChild;
    UINT        cxMinChild;
    UINT        cyMinChild;
    UINT        cx;
    HBITMAP     hbmBack;
    UINT        wID;
#if (_WIN32_IE >= 0x0400)
    UINT        cyChild;
    UINT        cyMaxChild;
    UINT        cyIntegral;
    UINT        cxIdeal;
    LPARAM      lParam;
    UINT        cxHeader;
#endif
#if (_WIN32_WINNT >= 0x0600)
    RECT        rcChevronLocation;  // the rect is in client co-ord wrt hwndChild
    UINT        uChevronState;      // STATE_SYSTEM_*
#endif
}   REBARBANDINFOA, *LPREBARBANDINFOA;
typedef REBARBANDINFOA CONST *LPCREBARBANDINFOA;

#define REBARBANDINFOA_V3_SIZE CCSIZEOF_STRUCT(REBARBANDINFOA, wID)
#define REBARBANDINFOW_V3_SIZE CCSIZEOF_STRUCT(REBARBANDINFOW, wID)

#define REBARBANDINFOA_V6_SIZE CCSIZEOF_STRUCT(REBARBANDINFOA, cxHeader)
#define REBARBANDINFOW_V6_SIZE CCSIZEOF_STRUCT(REBARBANDINFOW, cxHeader)

typedef struct tagREBARBANDINFOW
{
    UINT        cbSize;
    UINT        fMask;
    UINT        fStyle;
    COLORREF    clrFore;
    COLORREF    clrBack;
    LPWSTR      lpText;
    UINT        cch;
    int         iImage;
    HWND        hwndChild;
    UINT        cxMinChild;
    UINT        cyMinChild;
    UINT        cx;
    HBITMAP     hbmBack;
    UINT        wID;
#if (_WIN32_IE >= 0x0400)
    UINT        cyChild;
    UINT        cyMaxChild;
    UINT        cyIntegral;
    UINT        cxIdeal;
    LPARAM      lParam;
    UINT        cxHeader;
#endif
#if (_WIN32_WINNT >= 0x0600)
    RECT        rcChevronLocation;    // the rect is in client co-ord wrt hwndChild
    UINT        uChevronState; // STATE_SYSTEM_*
#endif
}   REBARBANDINFOW, *LPREBARBANDINFOW;
typedef REBARBANDINFOW CONST *LPCREBARBANDINFOW;

#ifdef UNICODE
#define REBARBANDINFO       REBARBANDINFOW
#define LPREBARBANDINFO     LPREBARBANDINFOW
#define LPCREBARBANDINFO    LPCREBARBANDINFOW
#define REBARBANDINFO_V3_SIZE REBARBANDINFOW_V3_SIZE
#define REBARBANDINFO_V6_SIZE REBARBANDINFOW_V6_SIZE
#else
#define REBARBANDINFO       REBARBANDINFOA
#define LPREBARBANDINFO     LPREBARBANDINFOA
#define LPCREBARBANDINFO    LPCREBARBANDINFOA
#define REBARBANDINFO_V3_SIZE REBARBANDINFOA_V3_SIZE
#define REBARBANDINFO_V6_SIZE REBARBANDINFOA_V6_SIZE
#endif

#define RB_INSERTBANDA  (WM_USER +  1)
#define RB_DELETEBAND   (WM_USER +  2)
#define RB_GETBARINFO   (WM_USER +  3)
#define RB_SETBARINFO   (WM_USER +  4)
#if (_WIN32_IE < 0x0400)
#define RB_GETBANDINFO  (WM_USER +  5)
#endif
#define RB_SETBANDINFOA (WM_USER +  6)
#define RB_SETPARENT    (WM_USER +  7)
#if (_WIN32_IE >= 0x0400)
#define RB_HITTEST      (WM_USER +  8)
#define RB_GETRECT      (WM_USER +  9)
#endif
#define RB_INSERTBANDW  (WM_USER +  10)
#define RB_SETBANDINFOW (WM_USER +  11)
#define RB_GETBANDCOUNT (WM_USER +  12)
#define RB_GETROWCOUNT  (WM_USER +  13)
#define RB_GETROWHEIGHT (WM_USER +  14)
#if (_WIN32_IE >= 0x0400)
#define RB_IDTOINDEX    (WM_USER +  16) // wParam == id
#define RB_GETTOOLTIPS  (WM_USER +  17)
#define RB_SETTOOLTIPS  (WM_USER +  18)
#define RB_SETBKCOLOR   (WM_USER +  19) // sets the default BK color
#define RB_GETBKCOLOR   (WM_USER +  20) // defaults to CLR_NONE
#define RB_SETTEXTCOLOR (WM_USER +  21)
#define RB_GETTEXTCOLOR (WM_USER +  22) // defaults to 0x00000000

#if (_WIN32_WINNT >= 0x0501)
#define RBSTR_CHANGERECT            0x0001   // flags for RB_SIZETORECT
#endif

#define RB_SIZETORECT   (WM_USER +  23) // resize the rebar/break bands and such to this rect (lparam)
#endif      // _WIN32_IE >= 0x0400

#define RB_SETCOLORSCHEME   CCM_SETCOLORSCHEME  // lParam is color scheme
#define RB_GETCOLORSCHEME   CCM_GETCOLORSCHEME  // fills in COLORSCHEME pointed to by lParam

#ifdef UNICODE
#define RB_INSERTBAND   RB_INSERTBANDW
#define RB_SETBANDINFO   RB_SETBANDINFOW
#else
#define RB_INSERTBAND   RB_INSERTBANDA
#define RB_SETBANDINFO   RB_SETBANDINFOA
#endif

#if (_WIN32_IE >= 0x0400)
// for manual drag control
// lparam == cursor pos
        // -1 means do it yourself.
        // -2 means use what you had saved before
#define RB_BEGINDRAG    (WM_USER + 24)
#define RB_ENDDRAG      (WM_USER + 25)
#define RB_DRAGMOVE     (WM_USER + 26)
#define RB_GETBARHEIGHT (WM_USER + 27)
#define RB_GETBANDINFOW (WM_USER + 28)
#define RB_GETBANDINFOA (WM_USER + 29)

#ifdef UNICODE
#define RB_GETBANDINFO   RB_GETBANDINFOW
#else
#define RB_GETBANDINFO   RB_GETBANDINFOA
#endif

#define RB_MINIMIZEBAND (WM_USER + 30)
#define RB_MAXIMIZEBAND (WM_USER + 31)

#define RB_GETDROPTARGET (CCM_GETDROPTARGET)

#define RB_GETBANDBORDERS (WM_USER + 34)  // returns in lparam = lprc the amount of edges added to band wparam

#define RB_SHOWBAND     (WM_USER + 35)      // show/hide band
#define RB_SETPALETTE   (WM_USER + 37)
#define RB_GETPALETTE   (WM_USER + 38)
#define RB_MOVEBAND     (WM_USER + 39)

#define RB_SETUNICODEFORMAT     CCM_SETUNICODEFORMAT
#define RB_GETUNICODEFORMAT     CCM_GETUNICODEFORMAT

#endif      // _WIN32_IE >= 0x0400

#if (_WIN32_WINNT >= 0x0501)
#define RB_GETBANDMARGINS   (WM_USER + 40)
#define RB_SETWINDOWTHEME       CCM_SETWINDOWTHEME
#endif

#if (_WIN32_IE >= 0x0600)
#define RB_SETEXTENDEDSTYLE (WM_USER + 41)
#define RB_GETEXTENDEDSTYLE (WM_USER + 42)
#endif      // _WIN32_IE >= 0x0600

#if (_WIN32_IE >= 0x0500)
#define RB_PUSHCHEVRON      (WM_USER + 43)
#endif      // _WIN32_IE >= 0x0500

#if (_WIN32_WINNT >= 0x0600)
#define RB_SETBANDWIDTH     (WM_USER + 44)   // set width for docked band
#endif      // _WIN32_WINNT >= 0x0600

#define RBN_HEIGHTCHANGE    (RBN_FIRST - 0)

#if (_WIN32_IE >= 0x0400)
#define RBN_GETOBJECT       (RBN_FIRST - 1)
#define RBN_LAYOUTCHANGED   (RBN_FIRST - 2)
#define RBN_AUTOSIZE        (RBN_FIRST - 3)
#define RBN_BEGINDRAG       (RBN_FIRST - 4)
#define RBN_ENDDRAG         (RBN_FIRST - 5)
#define RBN_DELETINGBAND    (RBN_FIRST - 6)     // Uses NMREBAR
#define RBN_DELETEDBAND     (RBN_FIRST - 7)     // Uses NMREBAR
#define RBN_CHILDSIZE       (RBN_FIRST - 8)

#if (_WIN32_IE >= 0x0500)
#define RBN_CHEVRONPUSHED   (RBN_FIRST - 10)
#endif      // _WIN32_IE >= 0x0500

#if (_WIN32_IE >= 0x0600)
#define RBN_SPLITTERDRAG    (RBN_FIRST - 11)
#endif      // _WIN32_IE >= 0x0600


#if (_WIN32_IE >= 0x0500)
#define RBN_MINMAX          (RBN_FIRST - 21)
#endif

#if (_WIN32_WINNT >= 0x0501)
#define RBN_AUTOBREAK       (RBN_FIRST - 22)
#endif

typedef struct tagNMREBARCHILDSIZE
{
    NMHDR hdr;
    UINT uBand;
    UINT wID;
    RECT rcChild;
    RECT rcBand;
} NMREBARCHILDSIZE, *LPNMREBARCHILDSIZE;

typedef struct tagNMREBAR
{
    NMHDR   hdr;
    DWORD   dwMask;           // RBNM_*
    UINT    uBand;
    UINT    fStyle;
    UINT    wID;
    LPARAM  lParam;
} NMREBAR, *LPNMREBAR;

// Mask flags for NMREBAR
#define RBNM_ID         0x00000001
#define RBNM_STYLE      0x00000002
#define RBNM_LPARAM     0x00000004


typedef struct tagNMRBAUTOSIZE
{
    NMHDR hdr;
    BOOL fChanged;
    RECT rcTarget;
    RECT rcActual;
} NMRBAUTOSIZE, *LPNMRBAUTOSIZE;

#if (_WIN32_IE >= 0x0500)
typedef struct tagNMREBARCHEVRON
{
    NMHDR hdr;
    UINT uBand;
    UINT wID;
    LPARAM lParam;
    RECT rc;
    LPARAM lParamNM;
} NMREBARCHEVRON, *LPNMREBARCHEVRON;
#endif

#if (_WIN32_IE >= 0x0600)
typedef struct tagNMREBARSPLITTER
{
    NMHDR hdr;
    RECT  rcSizing;
} NMREBARSPLITTER, *LPNMREBARSPLITTER;
#endif

#if (_WIN32_WINNT >= 0x0501)
#define RBAB_AUTOSIZE   0x0001   // These are not flags and are all mutually exclusive
#define RBAB_ADDBAND    0x0002

typedef struct tagNMREBARAUTOBREAK
{
    NMHDR hdr;
    UINT uBand;
    UINT wID;
    LPARAM lParam;
    UINT uMsg;
    UINT fStyleCurrent;
    BOOL fAutoBreak;
} NMREBARAUTOBREAK, *LPNMREBARAUTOBREAK;
#endif

#define RBHT_NOWHERE    0x0001
#define RBHT_CAPTION    0x0002
#define RBHT_CLIENT     0x0003
#define RBHT_GRABBER    0x0004
#if (_WIN32_IE >= 0x0500)
#define RBHT_CHEVRON    0x0008
#endif
#if (_WIN32_IE >= 0x0600)
#define RBHT_SPLITTER   0x0010
#endif

typedef struct _RB_HITTESTINFO
{
    POINT pt;
    UINT flags;
    int iBand;
} RBHITTESTINFO, *LPRBHITTESTINFO;

#endif      // _WIN32_IE >= 0x0400

#endif      // NOREBAR

#endif      // _WIN32_IE >= 0x0300

//====== TOOLTIPS CONTROL =====================================================

#ifndef NOTOOLTIPS

#ifdef _WIN32

#define TOOLTIPS_CLASSW         L"tooltips_class32"
#define TOOLTIPS_CLASSA         "tooltips_class32"

#ifdef UNICODE
#define TOOLTIPS_CLASS          TOOLTIPS_CLASSW
#else
#define TOOLTIPS_CLASS          TOOLTIPS_CLASSA
#endif

#else
#define TOOLTIPS_CLASS          "tooltips_class"
#endif

#if (_WIN32_IE >= 0x0300)
#define LPTOOLINFOA   LPTTTOOLINFOA
#define LPTOOLINFOW   LPTTTOOLINFOW
#define TOOLINFOA       TTTOOLINFOA
#define TOOLINFOW       TTTOOLINFOW
#else
#define   TTTOOLINFOA   TOOLINFOA
#define LPTTTOOLINFOA LPTOOLINFOA
#define   TTTOOLINFOW   TOOLINFOW
#define LPTTTOOLINFOW LPTOOLINFOW
#endif

#define LPTOOLINFO    LPTTTOOLINFO
#define TOOLINFO        TTTOOLINFO

#define TTTOOLINFOA_V1_SIZE CCSIZEOF_STRUCT(TTTOOLINFOA, lpszText)
#define TTTOOLINFOW_V1_SIZE CCSIZEOF_STRUCT(TTTOOLINFOW, lpszText)
#define TTTOOLINFOA_V2_SIZE CCSIZEOF_STRUCT(TTTOOLINFOA, lParam)
#define TTTOOLINFOW_V2_SIZE CCSIZEOF_STRUCT(TTTOOLINFOW, lParam)
#define TTTOOLINFOA_V3_SIZE CCSIZEOF_STRUCT(TTTOOLINFOA, lpReserved)
#define TTTOOLINFOW_V3_SIZE CCSIZEOF_STRUCT(TTTOOLINFOW, lpReserved)

typedef struct tagTOOLINFOA {
    UINT cbSize;
    UINT uFlags;
    HWND hwnd;
    UINT_PTR uId;
    RECT rect;
    HINSTANCE hinst;
    LPSTR lpszText;
#if (_WIN32_IE >= 0x0300)
    LPARAM lParam;
#endif
#if (_WIN32_WINNT >= 0x0501)
    void *lpReserved;
#endif
} TTTOOLINFOA, NEAR *PTOOLINFOA, *LPTTTOOLINFOA;

typedef struct tagTOOLINFOW {
    UINT cbSize;
    UINT uFlags;
    HWND hwnd;
    UINT_PTR uId;
    RECT rect;
    HINSTANCE hinst;
    LPWSTR lpszText;
#if (_WIN32_IE >= 0x0300)
    LPARAM lParam;
#endif
#if (_WIN32_WINNT >= 0x0501)
    void *lpReserved;
#endif
} TTTOOLINFOW, NEAR *PTOOLINFOW, *LPTTTOOLINFOW;

#ifdef UNICODE
#define TTTOOLINFO              TTTOOLINFOW
#define PTOOLINFO               PTOOLINFOW
#define LPTTTOOLINFO            LPTTTOOLINFOW
#define TTTOOLINFO_V1_SIZE TTTOOLINFOW_V1_SIZE
#else
#define PTOOLINFO               PTOOLINFOA
#define TTTOOLINFO              TTTOOLINFOA
#define LPTTTOOLINFO            LPTTTOOLINFOA
#define TTTOOLINFO_V1_SIZE TTTOOLINFOA_V1_SIZE
#endif

// begin_r_commctrl

#define TTS_ALWAYSTIP           0x01
#define TTS_NOPREFIX            0x02
#if (_WIN32_IE >= 0x0500)
#define TTS_NOANIMATE           0x10
#define TTS_NOFADE              0x20
#define TTS_BALLOON             0x40
#define TTS_CLOSE               0x80
#endif
#if _WIN32_WINNT >= 0x0600
#define TTS_USEVISUALSTYLE      0x100  // Use themed hyperlinks

#endif

// end_r_commctrl

#define TTF_IDISHWND            0x0001

// Use this to center around trackpoint in trackmode
// -OR- to center around tool in normal mode.
// Use TTF_ABSOLUTE to place the tip exactly at the track coords when
// in tracking mode.  TTF_ABSOLUTE can be used in conjunction with TTF_CENTERTIP
// to center the tip absolutely about the track point.

#define TTF_CENTERTIP           0x0002
#define TTF_RTLREADING          0x0004
#define TTF_SUBCLASS            0x0010
#if (_WIN32_IE >= 0x0300)
#define TTF_TRACK               0x0020
#define TTF_ABSOLUTE            0x0080
#define TTF_TRANSPARENT         0x0100
#if (_WIN32_IE >= 0x0501)
#define TTF_PARSELINKS          0x1000
#endif // _WIN32_IE >= 0x0501
#define TTF_DI_SETITEM          0x8000       // valid only on the TTN_NEEDTEXT callback
#endif      // _WIN32_IE >= 0x0300


#define TTDT_AUTOMATIC          0
#define TTDT_RESHOW             1
#define TTDT_AUTOPOP            2
#define TTDT_INITIAL            3

// ToolTip Icons (Set with TTM_SETTITLE)
#define TTI_NONE                0
#define TTI_INFO                1
#define TTI_WARNING             2
#define TTI_ERROR               3
#if (_WIN32_WINNT >= 0x0600)
#define TTI_INFO_LARGE          4
#define TTI_WARNING_LARGE       5
#define TTI_ERROR_LARGE         6
#endif  // (_WIN32_WINNT >= 0x0600)

// Tool Tip Messages
#define TTM_ACTIVATE            (WM_USER + 1)
#define TTM_SETDELAYTIME        (WM_USER + 3)
#define TTM_ADDTOOLA            (WM_USER + 4)
#define TTM_ADDTOOLW            (WM_USER + 50)
#define TTM_DELTOOLA            (WM_USER + 5)
#define TTM_DELTOOLW            (WM_USER + 51)
#define TTM_NEWTOOLRECTA        (WM_USER + 6)
#define TTM_NEWTOOLRECTW        (WM_USER + 52)
#define TTM_RELAYEVENT          (WM_USER + 7)

#define TTM_GETTOOLINFOA        (WM_USER + 8)
#define TTM_GETTOOLINFOW        (WM_USER + 53)

#define TTM_SETTOOLINFOA        (WM_USER + 9)
#define TTM_SETTOOLINFOW        (WM_USER + 54)

#define TTM_HITTESTA            (WM_USER +10)
#define TTM_HITTESTW            (WM_USER +55)
#define TTM_GETTEXTA            (WM_USER +11)
#define TTM_GETTEXTW            (WM_USER +56)
#define TTM_UPDATETIPTEXTA      (WM_USER +12)
#define TTM_UPDATETIPTEXTW      (WM_USER +57)
#define TTM_GETTOOLCOUNT        (WM_USER +13)
#define TTM_ENUMTOOLSA          (WM_USER +14)
#define TTM_ENUMTOOLSW          (WM_USER +58)
#define TTM_GETCURRENTTOOLA     (WM_USER + 15)
#define TTM_GETCURRENTTOOLW     (WM_USER + 59)
#define TTM_WINDOWFROMPOINT     (WM_USER + 16)
#if (_WIN32_IE >= 0x0300)
#define TTM_TRACKACTIVATE       (WM_USER + 17)  // wParam = TRUE/FALSE start end  lparam = LPTOOLINFO
#define TTM_TRACKPOSITION       (WM_USER + 18)  // lParam = dwPos
#define TTM_SETTIPBKCOLOR       (WM_USER + 19)
#define TTM_SETTIPTEXTCOLOR     (WM_USER + 20)
#define TTM_GETDELAYTIME        (WM_USER + 21)
#define TTM_GETTIPBKCOLOR       (WM_USER + 22)
#define TTM_GETTIPTEXTCOLOR     (WM_USER + 23)
#define TTM_SETMAXTIPWIDTH      (WM_USER + 24)
#define TTM_GETMAXTIPWIDTH      (WM_USER + 25)
#define TTM_SETMARGIN           (WM_USER + 26)  // lParam = lprc
#define TTM_GETMARGIN           (WM_USER + 27)  // lParam = lprc
#define TTM_POP                 (WM_USER + 28)
#endif
#if (_WIN32_IE >= 0x0400)
#define TTM_UPDATE              (WM_USER + 29)
#endif
#if (_WIN32_IE >= 0x0500)
#define TTM_GETBUBBLESIZE       (WM_USER + 30)
#define TTM_ADJUSTRECT          (WM_USER + 31)
#define TTM_SETTITLEA           (WM_USER + 32)  // wParam = TTI_*, lParam = char* szTitle
#define TTM_SETTITLEW           (WM_USER + 33)  // wParam = TTI_*, lParam = wchar* szTitle
#endif

#if (_WIN32_WINNT >= 0x0501)
#define TTM_POPUP               (WM_USER + 34)
#define TTM_GETTITLE            (WM_USER + 35) // wParam = 0, lParam = TTGETTITLE*

typedef struct _TTGETTITLE
{
    DWORD dwSize;
    UINT uTitleBitmap;
    UINT cch;
    WCHAR* pszTitle;
} TTGETTITLE, *PTTGETTITLE;
#endif

#ifdef UNICODE
#define TTM_ADDTOOL             TTM_ADDTOOLW
#define TTM_DELTOOL             TTM_DELTOOLW
#define TTM_NEWTOOLRECT         TTM_NEWTOOLRECTW
#define TTM_GETTOOLINFO         TTM_GETTOOLINFOW
#define TTM_SETTOOLINFO         TTM_SETTOOLINFOW
#define TTM_HITTEST             TTM_HITTESTW
#define TTM_GETTEXT             TTM_GETTEXTW
#define TTM_UPDATETIPTEXT       TTM_UPDATETIPTEXTW
#define TTM_ENUMTOOLS           TTM_ENUMTOOLSW
#define TTM_GETCURRENTTOOL      TTM_GETCURRENTTOOLW
#if (_WIN32_IE >= 0x0500)
#define TTM_SETTITLE            TTM_SETTITLEW
#endif
#else
#define TTM_ADDTOOL             TTM_ADDTOOLA
#define TTM_DELTOOL             TTM_DELTOOLA
#define TTM_NEWTOOLRECT         TTM_NEWTOOLRECTA
#define TTM_GETTOOLINFO         TTM_GETTOOLINFOA
#define TTM_SETTOOLINFO         TTM_SETTOOLINFOA
#define TTM_HITTEST             TTM_HITTESTA
#define TTM_GETTEXT             TTM_GETTEXTA
#define TTM_UPDATETIPTEXT       TTM_UPDATETIPTEXTA
#define TTM_ENUMTOOLS           TTM_ENUMTOOLSA
#define TTM_GETCURRENTTOOL      TTM_GETCURRENTTOOLA
#if (_WIN32_IE >= 0x0500)
#define TTM_SETTITLE            TTM_SETTITLEA
#endif
#endif

#if (_WIN32_WINNT >= 0x0501)
#define TTM_SETWINDOWTHEME      CCM_SETWINDOWTHEME
#endif


#if (_WIN32_IE >= 0x0300)
#define LPHITTESTINFOW    LPTTHITTESTINFOW
#define LPHITTESTINFOA    LPTTHITTESTINFOA
#else
#define LPTTHITTESTINFOA  LPHITTESTINFOA
#define LPTTHITTESTINFOW  LPHITTESTINFOW
#endif

#define LPHITTESTINFO     LPTTHITTESTINFO

typedef struct _TT_HITTESTINFOA {
    HWND hwnd;
    POINT pt;
    TTTOOLINFOA ti;
} TTHITTESTINFOA, *LPTTHITTESTINFOA;

typedef struct _TT_HITTESTINFOW {
    HWND hwnd;
    POINT pt;
    TTTOOLINFOW ti;
} TTHITTESTINFOW, *LPTTHITTESTINFOW;

#ifdef UNICODE
#define TTHITTESTINFO           TTHITTESTINFOW
#define LPTTHITTESTINFO         LPTTHITTESTINFOW
#else
#define TTHITTESTINFO           TTHITTESTINFOA
#define LPTTHITTESTINFO         LPTTHITTESTINFOA
#endif

#define TTN_GETDISPINFOA        (TTN_FIRST - 0)
#define TTN_GETDISPINFOW        (TTN_FIRST - 10)
#define TTN_SHOW                (TTN_FIRST - 1)
#define TTN_POP                 (TTN_FIRST - 2)
#define TTN_LINKCLICK           (TTN_FIRST - 3)

#ifdef UNICODE
#define TTN_GETDISPINFO         TTN_GETDISPINFOW
#else
#define TTN_GETDISPINFO         TTN_GETDISPINFOA
#endif

#define TTN_NEEDTEXT            TTN_GETDISPINFO
#define TTN_NEEDTEXTA           TTN_GETDISPINFOA
#define TTN_NEEDTEXTW           TTN_GETDISPINFOW

#if (_WIN32_IE >= 0x0300)
#define TOOLTIPTEXTW NMTTDISPINFOW
#define TOOLTIPTEXTA NMTTDISPINFOA
#define LPTOOLTIPTEXTA LPNMTTDISPINFOA
#define LPTOOLTIPTEXTW LPNMTTDISPINFOW
#else
#define tagNMTTDISPINFOA  tagTOOLTIPTEXTA
#define NMTTDISPINFOA     TOOLTIPTEXTA
#define LPNMTTDISPINFOA   LPTOOLTIPTEXTA
#define tagNMTTDISPINFOW  tagTOOLTIPTEXTW
#define NMTTDISPINFOW     TOOLTIPTEXTW
#define LPNMTTDISPINFOW   LPTOOLTIPTEXTW
#endif

#define TOOLTIPTEXT    NMTTDISPINFO
#define LPTOOLTIPTEXT  LPNMTTDISPINFO

#define NMTTDISPINFOA_V1_SIZE CCSIZEOF_STRUCT(NMTTDISPINFOA, uFlags)
#define NMTTDISPINFOW_V1_SIZE CCSIZEOF_STRUCT(NMTTDISPINFOW, uFlags)

typedef struct tagNMTTDISPINFOA {
    NMHDR hdr;
    LPSTR lpszText;
    char szText[80];
    HINSTANCE hinst;
    UINT uFlags;
#if (_WIN32_IE >= 0x0300)
    LPARAM lParam;
#endif
} NMTTDISPINFOA, *LPNMTTDISPINFOA;

typedef struct tagNMTTDISPINFOW {
    NMHDR hdr;
    LPWSTR lpszText;
    WCHAR szText[80];
    HINSTANCE hinst;
    UINT uFlags;
#if (_WIN32_IE >= 0x0300)
    LPARAM lParam;
#endif
} NMTTDISPINFOW, *LPNMTTDISPINFOW;

#ifdef UNICODE
#define NMTTDISPINFO            NMTTDISPINFOW
#define LPNMTTDISPINFO          LPNMTTDISPINFOW
#define NMTTDISPINFO_V1_SIZE NMTTDISPINFOW_V1_SIZE
#else
#define NMTTDISPINFO            NMTTDISPINFOA
#define LPNMTTDISPINFO          LPNMTTDISPINFOA
#define NMTTDISPINFO_V1_SIZE NMTTDISPINFOA_V1_SIZE
#endif

#endif      // NOTOOLTIPS


//====== STATUS BAR CONTROL ===================================================

#ifndef NOSTATUSBAR

// begin_r_commctrl

#define SBARS_SIZEGRIP          0x0100
#if (_WIN32_IE >= 0x0500)
#define SBARS_TOOLTIPS          0x0800
#endif

#if (_WIN32_IE >= 0x0400)
// this is a status bar flag, preference to SBARS_TOOLTIPS
#define SBT_TOOLTIPS            0x0800
#endif

// end_r_commctrl

WINCOMMCTRLAPI void WINAPI DrawStatusTextA(HDC hDC, LPCRECT lprc, LPCSTR pszText, UINT uFlags);
WINCOMMCTRLAPI void WINAPI DrawStatusTextW(HDC hDC, LPCRECT lprc, LPCWSTR pszText, UINT uFlags);

WINCOMMCTRLAPI HWND WINAPI CreateStatusWindowA(LONG style, LPCSTR lpszText, HWND hwndParent, UINT wID);
WINCOMMCTRLAPI HWND WINAPI CreateStatusWindowW(LONG style, LPCWSTR lpszText, HWND hwndParent, UINT wID);

#ifdef UNICODE
#define CreateStatusWindow      CreateStatusWindowW
#define DrawStatusText          DrawStatusTextW
#else
#define CreateStatusWindow      CreateStatusWindowA
#define DrawStatusText          DrawStatusTextA
#endif

#ifdef _WIN32
#define STATUSCLASSNAMEW        L"msctls_statusbar32"
#define STATUSCLASSNAMEA        "msctls_statusbar32"

#ifdef UNICODE
#define STATUSCLASSNAME         STATUSCLASSNAMEW
#else
#define STATUSCLASSNAME         STATUSCLASSNAMEA
#endif

#else
#define STATUSCLASSNAME         "msctls_statusbar"
#endif

#define SB_SETTEXTA             (WM_USER+1)
#define SB_SETTEXTW             (WM_USER+11)
#define SB_GETTEXTA             (WM_USER+2)
#define SB_GETTEXTW             (WM_USER+13)
#define SB_GETTEXTLENGTHA       (WM_USER+3)
#define SB_GETTEXTLENGTHW       (WM_USER+12)

#ifdef UNICODE
#define SB_GETTEXT              SB_GETTEXTW
#define SB_SETTEXT              SB_SETTEXTW
#define SB_GETTEXTLENGTH        SB_GETTEXTLENGTHW
#if (_WIN32_IE >= 0x0400)
#define SB_SETTIPTEXT           SB_SETTIPTEXTW
#define SB_GETTIPTEXT           SB_GETTIPTEXTW
#endif
#else
#define SB_GETTEXT              SB_GETTEXTA
#define SB_SETTEXT              SB_SETTEXTA
#define SB_GETTEXTLENGTH        SB_GETTEXTLENGTHA
#if (_WIN32_IE >= 0x0400)
#define SB_SETTIPTEXT           SB_SETTIPTEXTA
#define SB_GETTIPTEXT           SB_GETTIPTEXTA
#endif
#endif


#define SB_SETPARTS             (WM_USER+4)
#define SB_GETPARTS             (WM_USER+6)
#define SB_GETBORDERS           (WM_USER+7)
#define SB_SETMINHEIGHT         (WM_USER+8)
#define SB_SIMPLE               (WM_USER+9)
#define SB_GETRECT              (WM_USER+10)
#if (_WIN32_IE >= 0x0300)
#define SB_ISSIMPLE             (WM_USER+14)
#endif
#if (_WIN32_IE >= 0x0400)
#define SB_SETICON              (WM_USER+15)
#define SB_SETTIPTEXTA          (WM_USER+16)
#define SB_SETTIPTEXTW          (WM_USER+17)
#define SB_GETTIPTEXTA          (WM_USER+18)
#define SB_GETTIPTEXTW          (WM_USER+19)
#define SB_GETICON              (WM_USER+20)
#define SB_SETUNICODEFORMAT     CCM_SETUNICODEFORMAT
#define SB_GETUNICODEFORMAT     CCM_GETUNICODEFORMAT
#endif

#define SBT_OWNERDRAW            0x1000
#define SBT_NOBORDERS            0x0100
#define SBT_POPOUT               0x0200
#define SBT_RTLREADING           0x0400
#if (_WIN32_IE >= 0x0500)
#define SBT_NOTABPARSING         0x0800
#endif

#define SB_SETBKCOLOR           CCM_SETBKCOLOR      // lParam = bkColor

// status bar notifications
#if (_WIN32_IE >= 0x0400)
#define SBN_SIMPLEMODECHANGE    (SBN_FIRST - 0)
#endif

#if (_WIN32_IE >= 0x0500)
// refers to the data saved for simple mode
#define SB_SIMPLEID  0x00ff
#endif

#endif      // NOSTATUSBAR

//====== MENU HELP ============================================================

#ifndef NOMENUHELP

WINCOMMCTRLAPI void WINAPI MenuHelp(UINT uMsg, WPARAM wParam, LPARAM lParam, HMENU hMainMenu, HINSTANCE hInst, HWND hwndStatus, __in_ecount(4) UINT *lpwIDs);
WINCOMMCTRLAPI BOOL WINAPI ShowHideMenuCtl(HWND hWnd, UINT_PTR uFlags, __in __nullterminated LPINT lpInfo);
WINCOMMCTRLAPI void WINAPI GetEffectiveClientRect(HWND hWnd, LPRECT lprc,  __in __nullterminated const INT *lpInfo);

#define MINSYSCOMMAND   SC_SIZE

#endif


//====== TRACKBAR CONTROL =====================================================

#ifndef NOTRACKBAR

#ifdef _WIN32

#define TRACKBAR_CLASSA         "msctls_trackbar32"
#define TRACKBAR_CLASSW         L"msctls_trackbar32"

#ifdef UNICODE
#define  TRACKBAR_CLASS         TRACKBAR_CLASSW
#else
#define  TRACKBAR_CLASS         TRACKBAR_CLASSA
#endif

#else
#define TRACKBAR_CLASS          "msctls_trackbar"
#endif


// begin_r_commctrl

#define TBS_AUTOTICKS           0x0001
#define TBS_VERT                0x0002
#define TBS_HORZ                0x0000
#define TBS_TOP                 0x0004
#define TBS_BOTTOM              0x0000
#define TBS_LEFT                0x0004
#define TBS_RIGHT               0x0000
#define TBS_BOTH                0x0008
#define TBS_NOTICKS             0x0010
#define TBS_ENABLESELRANGE      0x0020
#define TBS_FIXEDLENGTH         0x0040
#define TBS_NOTHUMB             0x0080
#if (_WIN32_IE >= 0x0300)
#define TBS_TOOLTIPS            0x0100
#endif
#if (_WIN32_IE >= 0x0500)
#define TBS_REVERSED            0x0200  // Accessibility hint: the smaller number (usually the min value) means "high" and the larger number (usually the max value) means "low"
#endif

#if (_WIN32_IE >= 0x0501)
#define TBS_DOWNISLEFT          0x0400  // Down=Left and Up=Right (default is Down=Right and Up=Left)
#endif

#if (_WIN32_IE >= 0x0600)
#define TBS_NOTIFYBEFOREMOVE    0x0800  // Trackbar should notify parent before repositioning the slider due to user action (enables snapping)
#endif

#if (NTDDI_VERSION >= NTDDI_LONGHORN)
#define TBS_TRANSPARENTBKGND    0x1000  // Background is painted by the parent via WM_PRINTCLIENT
#endif

// end_r_commctrl

#define TBM_GETPOS              (WM_USER)
#define TBM_GETRANGEMIN         (WM_USER+1)
#define TBM_GETRANGEMAX         (WM_USER+2)
#define TBM_GETTIC              (WM_USER+3)
#define TBM_SETTIC              (WM_USER+4)
#define TBM_SETPOS              (WM_USER+5)
#define TBM_SETRANGE            (WM_USER+6)
#define TBM_SETRANGEMIN         (WM_USER+7)
#define TBM_SETRANGEMAX         (WM_USER+8)
#define TBM_CLEARTICS           (WM_USER+9)
#define TBM_SETSEL              (WM_USER+10)
#define TBM_SETSELSTART         (WM_USER+11)
#define TBM_SETSELEND           (WM_USER+12)
#define TBM_GETPTICS            (WM_USER+14)
#define TBM_GETTICPOS           (WM_USER+15)
#define TBM_GETNUMTICS          (WM_USER+16)
#define TBM_GETSELSTART         (WM_USER+17)
#define TBM_GETSELEND           (WM_USER+18)
#define TBM_CLEARSEL            (WM_USER+19)
#define TBM_SETTICFREQ          (WM_USER+20)
#define TBM_SETPAGESIZE         (WM_USER+21)
#define TBM_GETPAGESIZE         (WM_USER+22)
#define TBM_SETLINESIZE         (WM_USER+23)
#define TBM_GETLINESIZE         (WM_USER+24)
#define TBM_GETTHUMBRECT        (WM_USER+25)
#define TBM_GETCHANNELRECT      (WM_USER+26)
#define TBM_SETTHUMBLENGTH      (WM_USER+27)
#define TBM_GETTHUMBLENGTH      (WM_USER+28)
#if (_WIN32_IE >= 0x0300)
#define TBM_SETTOOLTIPS         (WM_USER+29)
#define TBM_GETTOOLTIPS         (WM_USER+30)
#define TBM_SETTIPSIDE          (WM_USER+31)
// TrackBar Tip Side flags
#define TBTS_TOP                0
#define TBTS_LEFT               1
#define TBTS_BOTTOM             2
#define TBTS_RIGHT              3

#define TBM_SETBUDDY            (WM_USER+32) // wparam = BOOL fLeft; (or right)
#define TBM_GETBUDDY            (WM_USER+33) // wparam = BOOL fLeft; (or right)
#endif
#if (_WIN32_IE >= 0x0400)
#define TBM_SETUNICODEFORMAT    CCM_SETUNICODEFORMAT
#define TBM_GETUNICODEFORMAT    CCM_GETUNICODEFORMAT
#endif


#define TB_LINEUP               0
#define TB_LINEDOWN             1
#define TB_PAGEUP               2
#define TB_PAGEDOWN             3
#define TB_THUMBPOSITION        4
#define TB_THUMBTRACK           5
#define TB_TOP                  6
#define TB_BOTTOM               7
#define TB_ENDTRACK             8


#if (_WIN32_IE >= 0x0300)
// custom draw item specs
#define TBCD_TICS    0x0001
#define TBCD_THUMB   0x0002
#define TBCD_CHANNEL 0x0003
#endif

#if (_WIN32_WINNT >= 0x0600)
#define TRBN_THUMBPOSCHANGING       (TRBN_FIRST-1)

// Structure for Trackbar's TRBN_THUMBPOSCHANGING notification
typedef struct tagTRBTHUMBPOSCHANGING
{
    NMHDR hdr;
    DWORD dwPos;
    int nReason;
} NMTRBTHUMBPOSCHANGING;
#endif

#endif // trackbar

//====== DRAG LIST CONTROL ====================================================

#ifndef NODRAGLIST

typedef struct tagDRAGLISTINFO {
    UINT uNotification;
    HWND hWnd;
    POINT ptCursor;
} DRAGLISTINFO, *LPDRAGLISTINFO;

#define DL_BEGINDRAG            (WM_USER+133)
#define DL_DRAGGING             (WM_USER+134)
#define DL_DROPPED              (WM_USER+135)
#define DL_CANCELDRAG           (WM_USER+136)

#define DL_CURSORSET            0
#define DL_STOPCURSOR           1
#define DL_COPYCURSOR           2
#define DL_MOVECURSOR           3

#define DRAGLISTMSGSTRING       TEXT("commctrl_DragListMsg")

WINCOMMCTRLAPI BOOL WINAPI MakeDragList(HWND hLB);
WINCOMMCTRLAPI void WINAPI DrawInsert(HWND handParent, HWND hLB, int nItem);

WINCOMMCTRLAPI int WINAPI LBItemFromPt(HWND hLB, POINT pt, BOOL bAutoScroll);

#endif


//====== UPDOWN CONTROL =======================================================

#ifndef NOUPDOWN

#ifdef _WIN32

#define UPDOWN_CLASSA           "msctls_updown32"
#define UPDOWN_CLASSW           L"msctls_updown32"

#ifdef UNICODE
#define  UPDOWN_CLASS           UPDOWN_CLASSW
#else
#define  UPDOWN_CLASS           UPDOWN_CLASSA
#endif

#else
#define UPDOWN_CLASS            "msctls_updown"
#endif


typedef struct _UDACCEL {
    UINT nSec;
    UINT nInc;
} UDACCEL, *LPUDACCEL;

#define UD_MAXVAL               0x7fff
#define UD_MINVAL               (-UD_MAXVAL)

// begin_r_commctrl

#define UDS_WRAP                0x0001
#define UDS_SETBUDDYINT         0x0002
#define UDS_ALIGNRIGHT          0x0004
#define UDS_ALIGNLEFT           0x0008
#define UDS_AUTOBUDDY           0x0010
#define UDS_ARROWKEYS           0x0020
#define UDS_HORZ                0x0040
#define UDS_NOTHOUSANDS         0x0080
#if (_WIN32_IE >= 0x0300)
#define UDS_HOTTRACK            0x0100
#endif

// end_r_commctrl

#define UDM_SETRANGE            (WM_USER+101)
#define UDM_GETRANGE            (WM_USER+102)
#define UDM_SETPOS              (WM_USER+103)
#define UDM_GETPOS              (WM_USER+104)
#define UDM_SETBUDDY            (WM_USER+105)
#define UDM_GETBUDDY            (WM_USER+106)
#define UDM_SETACCEL            (WM_USER+107)
#define UDM_GETACCEL            (WM_USER+108)
#define UDM_SETBASE             (WM_USER+109)
#define UDM_GETBASE             (WM_USER+110)
#if (_WIN32_IE >= 0x0400)
#define UDM_SETRANGE32          (WM_USER+111)
#define UDM_GETRANGE32          (WM_USER+112) // wParam & lParam are LPINT
#define UDM_SETUNICODEFORMAT    CCM_SETUNICODEFORMAT
#define UDM_GETUNICODEFORMAT    CCM_GETUNICODEFORMAT
#endif
#if (_WIN32_IE >= 0x0500)
#define UDM_SETPOS32            (WM_USER+113)
#define UDM_GETPOS32            (WM_USER+114)
#endif

WINCOMMCTRLAPI HWND WINAPI CreateUpDownControl(DWORD dwStyle, int x, int y, int cx, int cy,
                                HWND hParent, int nID, HINSTANCE hInst,
                                HWND hBuddy,
                                int nUpper, int nLower, int nPos);

#if (_WIN32_IE >= 0x0300)
#define NM_UPDOWN      NMUPDOWN
#define LPNM_UPDOWN  LPNMUPDOWN
#else
#define NMUPDOWN      NM_UPDOWN
#define LPNMUPDOWN  LPNM_UPDOWN
#endif

typedef struct _NM_UPDOWN
{
    NMHDR hdr;
    int iPos;
    int iDelta;
} NMUPDOWN, *LPNMUPDOWN;

#define UDN_DELTAPOS            (UDN_FIRST - 1)

#endif  // NOUPDOWN


//====== PROGRESS CONTROL =====================================================

#ifndef NOPROGRESS

#ifdef _WIN32

#define PROGRESS_CLASSA         "msctls_progress32"
#define PROGRESS_CLASSW         L"msctls_progress32"


#ifdef UNICODE
#define  PROGRESS_CLASS         PROGRESS_CLASSW
#else
#define  PROGRESS_CLASS         PROGRESS_CLASSA
#endif

#else
#define PROGRESS_CLASS          "msctls_progress"
#endif

// begin_r_commctrl

#if (_WIN32_IE >= 0x0300)
#define PBS_SMOOTH              0x01
#define PBS_VERTICAL            0x04
#endif

// end_r_commctrl

#define PBM_SETRANGE            (WM_USER+1)
#define PBM_SETPOS              (WM_USER+2)
#define PBM_DELTAPOS            (WM_USER+3)
#define PBM_SETSTEP             (WM_USER+4)
#define PBM_STEPIT              (WM_USER+5)
#if (_WIN32_IE >= 0x0300)
#define PBM_SETRANGE32          (WM_USER+6)  // lParam = high, wParam = low
typedef struct
{
   int iLow;
   int iHigh;
} PBRANGE, *PPBRANGE;
#define PBM_GETRANGE            (WM_USER+7)  // wParam = return (TRUE ? low : high). lParam = PPBRANGE or NULL
#define PBM_GETPOS              (WM_USER+8)
#if (_WIN32_IE >= 0x0400)
#define PBM_SETBARCOLOR         (WM_USER+9)             // lParam = bar color
#endif      // _WIN32_IE >= 0x0400
#define PBM_SETBKCOLOR          CCM_SETBKCOLOR  // lParam = bkColor
#endif      // _WIN32_IE >= 0x0300


// begin_r_commctrl

#if (_WIN32_WINNT >= 0x0501)
#define PBS_MARQUEE             0x08
#endif       // _WIN32_WINNT >= 0x0501

// end_r_commctrl

#if (_WIN32_WINNT >= 0x0501)
#define PBM_SETMARQUEE          (WM_USER+10)
#endif      // _WIN32_WINNT >= 0x0501

// begin_r_commctrl
#if _WIN32_WINNT >= 0x0600
#define PBS_SMOOTHREVERSE       0x10
#endif       // _WIN32_WINNT >= 0x0600

// end_r_commctrl

#if _WIN32_WINNT >= 0x0600

#define PBM_GETSTEP             (WM_USER+13)
#define PBM_GETBKCOLOR          (WM_USER+14)
#define PBM_GETBARCOLOR         (WM_USER+15)
#define PBM_SETSTATE            (WM_USER+16) // wParam = PBST_[State] (NORMAL, ERROR, PAUSED)
#define PBM_GETSTATE            (WM_USER+17)

#define PBST_NORMAL             0x0001
#define PBST_ERROR              0x0002
#define PBST_PAUSED             0x0003
#endif      // _WIN32_WINNT >= 0x0600

#endif  // NOPROGRESS


//====== HOTKEY CONTROL =======================================================

#ifndef NOHOTKEY

#define HOTKEYF_SHIFT           0x01
#define HOTKEYF_CONTROL         0x02
#define HOTKEYF_ALT             0x04
#ifdef _MAC
#define HOTKEYF_EXT             0x80
#else
#define HOTKEYF_EXT             0x08
#endif

#define HKCOMB_NONE             0x0001
#define HKCOMB_S                0x0002
#define HKCOMB_C                0x0004
#define HKCOMB_A                0x0008
#define HKCOMB_SC               0x0010
#define HKCOMB_SA               0x0020
#define HKCOMB_CA               0x0040
#define HKCOMB_SCA              0x0080


#define HKM_SETHOTKEY           (WM_USER+1)
#define HKM_GETHOTKEY           (WM_USER+2)
#define HKM_SETRULES            (WM_USER+3)

#ifdef _WIN32

#define HOTKEY_CLASSA           "msctls_hotkey32"
#define HOTKEY_CLASSW           L"msctls_hotkey32"

#ifdef UNICODE
#define HOTKEY_CLASS            HOTKEY_CLASSW
#else
#define HOTKEY_CLASS            HOTKEY_CLASSA
#endif

#else
#define HOTKEY_CLASS            "msctls_hotkey"
#endif

#endif  // NOHOTKEY

// begin_r_commctrl

//====== COMMON CONTROL STYLES ================================================

#define CCS_TOP                 0x00000001L
#define CCS_NOMOVEY             0x00000002L
#define CCS_BOTTOM              0x00000003L
#define CCS_NORESIZE            0x00000004L
#define CCS_NOPARENTALIGN       0x00000008L
#define CCS_ADJUSTABLE          0x00000020L
#define CCS_NODIVIDER           0x00000040L
#if (_WIN32_IE >= 0x0300)
#define CCS_VERT                0x00000080L
#define CCS_LEFT                (CCS_VERT | CCS_TOP)
#define CCS_RIGHT               (CCS_VERT | CCS_BOTTOM)
#define CCS_NOMOVEX             (CCS_VERT | CCS_NOMOVEY)
#endif

// end_r_commctrl

//====== SysLink control =========================================

#ifdef _WIN32
#if (_WIN32_WINNT >= 0x0501)

#define INVALID_LINK_INDEX  (-1)
#define MAX_LINKID_TEXT     48
#define L_MAX_URL_LENGTH    (2048 + 32 + sizeof("://"))

#define WC_LINK         L"SysLink"

// begin_r_commctrl

#define LWS_TRANSPARENT     0x0001
#define LWS_IGNORERETURN    0x0002
#if _WIN32_WINNT >= 0x0600
#define LWS_NOPREFIX        0x0004
#define LWS_USEVISUALSTYLE  0x0008
#define LWS_USECUSTOMTEXT   0x0010
#define LWS_RIGHT           0x0020
#endif // _WIN32_WINNT >= 0x600

// end_r_commctrl

#define LIF_ITEMINDEX    0x00000001
#define LIF_STATE        0x00000002
#define LIF_ITEMID       0x00000004
#define LIF_URL          0x00000008

#define LIS_FOCUSED         0x00000001
#define LIS_ENABLED         0x00000002
#define LIS_VISITED         0x00000004
#if _WIN32_WINNT >= 0x0600
#define LIS_HOTTRACK        0x00000008
#define LIS_DEFAULTCOLORS   0x00000010 // Don't use any custom text colors
#endif

typedef struct tagLITEM
{
    UINT        mask ;
    int         iLink ;
    UINT        state ;
    UINT        stateMask ;
    WCHAR       szID[MAX_LINKID_TEXT] ;
    WCHAR       szUrl[L_MAX_URL_LENGTH] ;
} LITEM, * PLITEM ;

typedef struct tagLHITTESTINFO
{
    POINT       pt ;
    LITEM     item ;
} LHITTESTINFO, *PLHITTESTINFO ;

typedef struct tagNMLINK
{
    NMHDR       hdr;
    LITEM     item ;
} NMLINK,  *PNMLINK;

//  SysLink notifications
//  NM_CLICK   // wParam: control ID, lParam: PNMLINK, ret: ignored.

//  LinkWindow messages
#define LM_HITTEST         (WM_USER+0x300)  // wParam: n/a, lparam: PLHITTESTINFO, ret: BOOL
#define LM_GETIDEALHEIGHT  (WM_USER+0x301)  // wParam: cxMaxWidth, lparam: n/a, ret: cy
#define LM_SETITEM         (WM_USER+0x302)  // wParam: n/a, lparam: LITEM*, ret: BOOL
#define LM_GETITEM         (WM_USER+0x303)  // wParam: n/a, lparam: LITEM*, ret: BOOL
#define LM_GETIDEALSIZE    (LM_GETIDEALHEIGHT)  // wParam: cxMaxWidth, lparam: SIZE*, ret: cy

#endif

#endif // _WIN32
//====== End SysLink control =========================================


//====== LISTVIEW CONTROL =====================================================

#ifndef NOLISTVIEW

#ifdef _WIN32

#define WC_LISTVIEWA            "SysListView32"
#define WC_LISTVIEWW            L"SysListView32"

#ifdef UNICODE
#define WC_LISTVIEW             WC_LISTVIEWW
#else
#define WC_LISTVIEW             WC_LISTVIEWA
#endif

#else
#define WC_LISTVIEW             "SysListView"
#endif

// begin_r_commctrl

#define LVS_ICON                0x0000
#define LVS_REPORT              0x0001
#define LVS_SMALLICON           0x0002
#define LVS_LIST                0x0003
#define LVS_TYPEMASK            0x0003
#define LVS_SINGLESEL           0x0004
#define LVS_SHOWSELALWAYS       0x0008
#define LVS_SORTASCENDING       0x0010
#define LVS_SORTDESCENDING      0x0020
#define LVS_SHAREIMAGELISTS     0x0040
#define LVS_NOLABELWRAP         0x0080
#define LVS_AUTOARRANGE         0x0100
#define LVS_EDITLABELS          0x0200
#if (_WIN32_IE >= 0x0300)
#define LVS_OWNERDATA           0x1000
#endif
#define LVS_NOSCROLL            0x2000

#define LVS_TYPESTYLEMASK       0xfc00

#define LVS_ALIGNTOP            0x0000
#define LVS_ALIGNLEFT           0x0800
#define LVS_ALIGNMASK           0x0c00

#define LVS_OWNERDRAWFIXED      0x0400
#define LVS_NOCOLUMNHEADER      0x4000
#define LVS_NOSORTHEADER        0x8000

// end_r_commctrl

#if (_WIN32_IE >= 0x0400)
#define LVM_SETUNICODEFORMAT     CCM_SETUNICODEFORMAT
#define ListView_SetUnicodeFormat(hwnd, fUnicode)  \
    (BOOL)SNDMSG((hwnd), LVM_SETUNICODEFORMAT, (WPARAM)(fUnicode), 0)

#define LVM_GETUNICODEFORMAT     CCM_GETUNICODEFORMAT
#define ListView_GetUnicodeFormat(hwnd)  \
    (BOOL)SNDMSG((hwnd), LVM_GETUNICODEFORMAT, 0, 0)
#endif

#define LVM_GETBKCOLOR          (LVM_FIRST + 0)
#define ListView_GetBkColor(hwnd)  \
    (COLORREF)SNDMSG((hwnd), LVM_GETBKCOLOR, 0, 0L)

#define LVM_SETBKCOLOR          (LVM_FIRST + 1)
#define ListView_SetBkColor(hwnd, clrBk) \
    (BOOL)SNDMSG((hwnd), LVM_SETBKCOLOR, 0, (LPARAM)(COLORREF)(clrBk))

#define LVM_GETIMAGELIST        (LVM_FIRST + 2)
#define ListView_GetImageList(hwnd, iImageList) \
    (HIMAGELIST)SNDMSG((hwnd), LVM_GETIMAGELIST, (WPARAM)(INT)(iImageList), 0L)

#define LVSIL_NORMAL            0
#define LVSIL_SMALL             1
#define LVSIL_STATE             2
#define LVSIL_GROUPHEADER       3

#define LVM_SETIMAGELIST        (LVM_FIRST + 3)
#define ListView_SetImageList(hwnd, himl, iImageList) \
    (HIMAGELIST)SNDMSG((hwnd), LVM_SETIMAGELIST, (WPARAM)(iImageList), (LPARAM)(HIMAGELIST)(himl))

#define LVM_GETITEMCOUNT        (LVM_FIRST + 4)
#define ListView_GetItemCount(hwnd) \
    (int)SNDMSG((hwnd), LVM_GETITEMCOUNT, 0, 0L)


#define LVIF_TEXT               0x00000001
#define LVIF_IMAGE              0x00000002
#define LVIF_PARAM              0x00000004
#define LVIF_STATE              0x00000008
#if (_WIN32_IE >= 0x0300)
#define LVIF_INDENT             0x00000010
#define LVIF_NORECOMPUTE        0x00000800
#endif
#if (_WIN32_WINNT >= 0x0501)
#define LVIF_GROUPID            0x00000100
#define LVIF_COLUMNS            0x00000200
#endif

#if _WIN32_WINNT >= 0x0600
#define LVIF_COLFMT             0x00010000 // The piColFmt member is valid in addition to puColumns
#endif

#define LVIS_FOCUSED            0x0001
#define LVIS_SELECTED           0x0002
#define LVIS_CUT                0x0004
#define LVIS_DROPHILITED        0x0008
#define LVIS_GLOW               0x0010
#define LVIS_ACTIVATING         0x0020

#define LVIS_OVERLAYMASK        0x0F00
#define LVIS_STATEIMAGEMASK     0xF000

#define INDEXTOSTATEIMAGEMASK(i) ((i) << 12)

#if (_WIN32_IE >= 0x0300)
#define I_INDENTCALLBACK        (-1)
#define LV_ITEMA LVITEMA
#define LV_ITEMW LVITEMW
#else
#define tagLVITEMA    _LV_ITEMA
#define LVITEMA       LV_ITEMA
#define tagLVITEMW    _LV_ITEMW
#define LVITEMW       LV_ITEMW
#endif

#if (_WIN32_WINNT >= 0x0501)
#define I_GROUPIDCALLBACK   (-1)
#define I_GROUPIDNONE       (-2)
#endif
#define LV_ITEM LVITEM

#define LVITEMA_V1_SIZE CCSIZEOF_STRUCT(LVITEMA, lParam)
#define LVITEMW_V1_SIZE CCSIZEOF_STRUCT(LVITEMW, lParam)

#if _WIN32_WINNT >= 0x0600 // Will be unused downlevel, but sizeof(LVITEMA) must be equal to sizeof(LVITEMW)
#define LVITEMA_V5_SIZE CCSIZEOF_STRUCT(LVITEMA, puColumns)
#define LVITEMW_V5_SIZE CCSIZEOF_STRUCT(LVITEMW, puColumns)

#ifdef UNICODE
#define LVITEM_V5_SIZE LVITEMW_V5_SIZE
#else
#define LVITEM_V5_SIZE LVITEMA_V5_SIZE
#endif
#endif

typedef struct tagLVITEMA
{
    UINT mask;
    int iItem;
    int iSubItem;
    UINT state;
    UINT stateMask;
    LPSTR pszText;
    int cchTextMax;
    int iImage;
    LPARAM lParam;
#if (_WIN32_IE >= 0x0300)
    int iIndent;
#endif
#if (_WIN32_WINNT >= 0x0501)
    int iGroupId;
    UINT cColumns; // tile view columns
    PUINT puColumns;
#endif
#if _WIN32_WINNT >= 0x0600 // Will be unused downlevel, but sizeof(LVITEMA) must be equal to sizeof(LVITEMW)
    int* piColFmt;
    int iGroup; // readonly. only valid for owner data.
#endif
} LVITEMA, *LPLVITEMA;

typedef struct tagLVITEMW
{
    UINT mask;
    int iItem;
    int iSubItem;
    UINT state;
    UINT stateMask;
    LPWSTR pszText;
    int cchTextMax;
    int iImage;
    LPARAM lParam;
#if (_WIN32_IE >= 0x0300)
    int iIndent;
#endif
#if (_WIN32_WINNT >= 0x0501)
    int iGroupId;
    UINT cColumns; // tile view columns
    PUINT puColumns;
#endif
#if _WIN32_WINNT >= 0x0600
    int* piColFmt;
    int iGroup; // readonly. only valid for owner data.
#endif
} LVITEMW, *LPLVITEMW;

#ifdef UNICODE
#define LVITEM    LVITEMW
#define LPLVITEM  LPLVITEMW
#define LVITEM_V1_SIZE LVITEMW_V1_SIZE
#else
#define LVITEM    LVITEMA
#define LPLVITEM  LPLVITEMA
#define LVITEM_V1_SIZE LVITEMA_V1_SIZE
#endif

#define LPSTR_TEXTCALLBACKW     ((LPWSTR)-1L)
#define LPSTR_TEXTCALLBACKA     ((LPSTR)-1L)
#ifdef UNICODE
#define LPSTR_TEXTCALLBACK      LPSTR_TEXTCALLBACKW
#else
#define LPSTR_TEXTCALLBACK      LPSTR_TEXTCALLBACKA
#endif

#define I_IMAGECALLBACK         (-1)
#if (_WIN32_IE >= 0x0501)
#define I_IMAGENONE             (-2)
#endif  // 0x0501

#if (_WIN32_WINNT >= 0x0501)
// For tileview
#define I_COLUMNSCALLBACK       ((UINT)-1)
#endif

#define LVM_GETITEMA            (LVM_FIRST + 5)
#define LVM_GETITEMW            (LVM_FIRST + 75)
#ifdef UNICODE
#define LVM_GETITEM             LVM_GETITEMW
#else
#define LVM_GETITEM             LVM_GETITEMA
#endif

#define ListView_GetItem(hwnd, pitem) \
    (BOOL)SNDMSG((hwnd), LVM_GETITEM, 0, (LPARAM)(LV_ITEM *)(pitem))


#define LVM_SETITEMA            (LVM_FIRST + 6)
#define LVM_SETITEMW            (LVM_FIRST + 76)
#ifdef UNICODE
#define LVM_SETITEM             LVM_SETITEMW
#else
#define LVM_SETITEM             LVM_SETITEMA
#endif

#define ListView_SetItem(hwnd, pitem) \
    (BOOL)SNDMSG((hwnd), LVM_SETITEM, 0, (LPARAM)(const LV_ITEM *)(pitem))


#define LVM_INSERTITEMA         (LVM_FIRST + 7)
#define LVM_INSERTITEMW         (LVM_FIRST + 77)
#ifdef UNICODE
#define LVM_INSERTITEM          LVM_INSERTITEMW
#else
#define LVM_INSERTITEM          LVM_INSERTITEMA
#endif
#define ListView_InsertItem(hwnd, pitem)   \
    (int)SNDMSG((hwnd), LVM_INSERTITEM, 0, (LPARAM)(const LV_ITEM *)(pitem))


#define LVM_DELETEITEM          (LVM_FIRST + 8)
#define ListView_DeleteItem(hwnd, i) \
    (BOOL)SNDMSG((hwnd), LVM_DELETEITEM, (WPARAM)(int)(i), 0L)


#define LVM_DELETEALLITEMS      (LVM_FIRST + 9)
#define ListView_DeleteAllItems(hwnd) \
    (BOOL)SNDMSG((hwnd), LVM_DELETEALLITEMS, 0, 0L)


#define LVM_GETCALLBACKMASK     (LVM_FIRST + 10)
#define ListView_GetCallbackMask(hwnd) \
    (BOOL)SNDMSG((hwnd), LVM_GETCALLBACKMASK, 0, 0)


#define LVM_SETCALLBACKMASK     (LVM_FIRST + 11)
#define ListView_SetCallbackMask(hwnd, mask) \
    (BOOL)SNDMSG((hwnd), LVM_SETCALLBACKMASK, (WPARAM)(UINT)(mask), 0)


#define LVNI_ALL                0x0000

#define LVNI_FOCUSED            0x0001
#define LVNI_SELECTED           0x0002
#define LVNI_CUT                0x0004
#define LVNI_DROPHILITED        0x0008
#define LVNI_STATEMASK          (LVNI_FOCUSED | LVNI_SELECTED | LVNI_CUT | LVNI_DROPHILITED)

#define LVNI_VISIBLEORDER       0x0010
#define LVNI_PREVIOUS           0x0020
#define LVNI_VISIBLEONLY        0x0040
#define LVNI_SAMEGROUPONLY      0x0080

#define LVNI_ABOVE              0x0100
#define LVNI_BELOW              0x0200
#define LVNI_TOLEFT             0x0400
#define LVNI_TORIGHT            0x0800
#define LVNI_DIRECTIONMASK      (LVNI_ABOVE | LVNI_BELOW | LVNI_TOLEFT | LVNI_TORIGHT)


#define LVM_GETNEXTITEM         (LVM_FIRST + 12)
#define ListView_GetNextItem(hwnd, i, flags) \
    (int)SNDMSG((hwnd), LVM_GETNEXTITEM, (WPARAM)(int)(i), MAKELPARAM((flags), 0))

#define LVFI_PARAM              0x0001
#define LVFI_STRING             0x0002
#define LVFI_SUBSTRING          0x0004  // Same as LVFI_PARTIAL
#define LVFI_PARTIAL            0x0008
#define LVFI_WRAP               0x0020
#define LVFI_NEARESTXY          0x0040

#if (_WIN32_IE >= 0x0300)
#define LV_FINDINFOA    LVFINDINFOA
#define LV_FINDINFOW    LVFINDINFOW
#else
#define tagLVFINDINFOA  _LV_FINDINFOA
#define    LVFINDINFOA   LV_FINDINFOA
#define tagLVFINDINFOW  _LV_FINDINFOW
#define    LVFINDINFOW   LV_FINDINFOW
#endif

#define LV_FINDINFO  LVFINDINFO

typedef struct tagLVFINDINFOA
{
    UINT flags;
    LPCSTR psz;
    LPARAM lParam;
    POINT pt;
    UINT vkDirection;
} LVFINDINFOA, *LPFINDINFOA;

typedef struct tagLVFINDINFOW
{
    UINT flags;
    LPCWSTR psz;
    LPARAM lParam;
    POINT pt;
    UINT vkDirection;
} LVFINDINFOW, *LPFINDINFOW;

#ifdef UNICODE
#define  LVFINDINFO            LVFINDINFOW
#else
#define  LVFINDINFO            LVFINDINFOA
#endif

#define LVM_FINDITEMA           (LVM_FIRST + 13)
#define LVM_FINDITEMW           (LVM_FIRST + 83)
#ifdef UNICODE
#define  LVM_FINDITEM           LVM_FINDITEMW
#else
#define  LVM_FINDITEM           LVM_FINDITEMA
#endif

#define ListView_FindItem(hwnd, iStart, plvfi) \
    (int)SNDMSG((hwnd), LVM_FINDITEM, (WPARAM)(int)(iStart), (LPARAM)(const LV_FINDINFO *)(plvfi))

#define LVIR_BOUNDS             0
#define LVIR_ICON               1
#define LVIR_LABEL              2
#define LVIR_SELECTBOUNDS       3


#define LVM_GETITEMRECT         (LVM_FIRST + 14)
#define ListView_GetItemRect(hwnd, i, prc, code) \
     (BOOL)SNDMSG((hwnd), LVM_GETITEMRECT, (WPARAM)(int)(i), \
           ((prc) ? (((RECT *)(prc))->left = (code),(LPARAM)(RECT *)(prc)) : (LPARAM)(RECT *)NULL))


#define LVM_SETITEMPOSITION     (LVM_FIRST + 15)
#define ListView_SetItemPosition(hwndLV, i, x, y) \
    (BOOL)SNDMSG((hwndLV), LVM_SETITEMPOSITION, (WPARAM)(int)(i), MAKELPARAM((x), (y)))


#define LVM_GETITEMPOSITION     (LVM_FIRST + 16)
#define ListView_GetItemPosition(hwndLV, i, ppt) \
    (BOOL)SNDMSG((hwndLV), LVM_GETITEMPOSITION, (WPARAM)(int)(i), (LPARAM)(POINT *)(ppt))


#define LVM_GETSTRINGWIDTHA     (LVM_FIRST + 17)
#define LVM_GETSTRINGWIDTHW     (LVM_FIRST + 87)
#ifdef UNICODE
#define  LVM_GETSTRINGWIDTH     LVM_GETSTRINGWIDTHW
#else
#define  LVM_GETSTRINGWIDTH     LVM_GETSTRINGWIDTHA
#endif

#define ListView_GetStringWidth(hwndLV, psz) \
    (int)SNDMSG((hwndLV), LVM_GETSTRINGWIDTH, 0, (LPARAM)(LPCTSTR)(psz))


#define LVHT_NOWHERE            0x00000001
#define LVHT_ONITEMICON         0x00000002
#define LVHT_ONITEMLABEL        0x00000004
#define LVHT_ONITEMSTATEICON    0x00000008
#define LVHT_ONITEM             (LVHT_ONITEMICON | LVHT_ONITEMLABEL | LVHT_ONITEMSTATEICON)

#define LVHT_ABOVE              0x00000008
#define LVHT_BELOW              0x00000010
#define LVHT_TORIGHT            0x00000020
#define LVHT_TOLEFT             0x00000040


#define LVHT_EX_GROUP_HEADER       0x10000000
#define LVHT_EX_GROUP_FOOTER       0x20000000
#define LVHT_EX_GROUP_COLLAPSE     0x40000000
#define LVHT_EX_GROUP_BACKGROUND   0x80000000
#define LVHT_EX_GROUP_STATEICON    0x01000000
#define LVHT_EX_GROUP_SUBSETLINK   0x02000000
#define LVHT_EX_GROUP              (LVHT_EX_GROUP_BACKGROUND | LVHT_EX_GROUP_COLLAPSE | LVHT_EX_GROUP_FOOTER | LVHT_EX_GROUP_HEADER | LVHT_EX_GROUP_STATEICON | LVHT_EX_GROUP_SUBSETLINK)
#define LVHT_EX_ONCONTENTS         0x04000000 // On item AND not on the background
#define LVHT_EX_FOOTER             0x08000000

#if (_WIN32_IE >= 0x0300)
#define LV_HITTESTINFO LVHITTESTINFO
#else
#define tagLVHITTESTINFO  _LV_HITTESTINFO
#define    LVHITTESTINFO   LV_HITTESTINFO
#endif

#define LVHITTESTINFO_V1_SIZE CCSIZEOF_STRUCT(LVHITTESTINFO, iItem)

typedef struct tagLVHITTESTINFO
{
    POINT pt;
    UINT flags;
    int iItem;
#if (_WIN32_IE >= 0x0300)
    int iSubItem;    // this is was NOT in win95.  valid only for LVM_SUBITEMHITTEST
#endif
#if _WIN32_WINNT >= 0x0600
    int iGroup; // readonly. index of group. only valid for owner data.
                // supports single item in multiple groups.
#endif
} LVHITTESTINFO, *LPLVHITTESTINFO;

#define LVM_HITTEST             (LVM_FIRST + 18)
#define ListView_HitTest(hwndLV, pinfo) \
    (int)SNDMSG((hwndLV), LVM_HITTEST, 0, (LPARAM)(LV_HITTESTINFO *)(pinfo))
#define ListView_HitTestEx(hwndLV, pinfo) \
    (int)SNDMSG((hwndLV), LVM_HITTEST, (WPARAM)-1, (LPARAM)(LV_HITTESTINFO *)(pinfo))


#define LVM_ENSUREVISIBLE       (LVM_FIRST + 19)
#define ListView_EnsureVisible(hwndLV, i, fPartialOK) \
    (BOOL)SNDMSG((hwndLV), LVM_ENSUREVISIBLE, (WPARAM)(int)(i), MAKELPARAM((fPartialOK), 0))


#define LVM_SCROLL              (LVM_FIRST + 20)
#define ListView_Scroll(hwndLV, dx, dy) \
    (BOOL)SNDMSG((hwndLV), LVM_SCROLL, (WPARAM)(int)(dx), (LPARAM)(int)(dy))


#define LVM_REDRAWITEMS         (LVM_FIRST + 21)
#define ListView_RedrawItems(hwndLV, iFirst, iLast) \
    (BOOL)SNDMSG((hwndLV), LVM_REDRAWITEMS, (WPARAM)(int)(iFirst), (LPARAM)(int)(iLast))


#define LVA_DEFAULT             0x0000
#define LVA_ALIGNLEFT           0x0001
#define LVA_ALIGNTOP            0x0002
#define LVA_SNAPTOGRID          0x0005


#define LVM_ARRANGE             (LVM_FIRST + 22)
#define ListView_Arrange(hwndLV, code) \
    (BOOL)SNDMSG((hwndLV), LVM_ARRANGE, (WPARAM)(UINT)(code), 0L)


#define LVM_EDITLABELA          (LVM_FIRST + 23)
#define LVM_EDITLABELW          (LVM_FIRST + 118)
#ifdef UNICODE
#define LVM_EDITLABEL           LVM_EDITLABELW
#else
#define LVM_EDITLABEL           LVM_EDITLABELA
#endif

#define ListView_EditLabel(hwndLV, i) \
    (HWND)SNDMSG((hwndLV), LVM_EDITLABEL, (WPARAM)(int)(i), 0L)

#define LVM_GETEDITCONTROL      (LVM_FIRST + 24)
#define ListView_GetEditControl(hwndLV) \
    (HWND)SNDMSG((hwndLV), LVM_GETEDITCONTROL, 0, 0L)


#if (_WIN32_IE >= 0x0300)
#define LV_COLUMNA      LVCOLUMNA
#define LV_COLUMNW      LVCOLUMNW
#else
#define tagLVCOLUMNA    _LV_COLUMNA
#define    LVCOLUMNA     LV_COLUMNA
#define tagLVCOLUMNW    _LV_COLUMNW
#define    LVCOLUMNW     LV_COLUMNW
#endif

#define LV_COLUMN       LVCOLUMN

#define LVCOLUMNA_V1_SIZE CCSIZEOF_STRUCT(LVCOLUMNA, iSubItem)
#define LVCOLUMNW_V1_SIZE CCSIZEOF_STRUCT(LVCOLUMNW, iSubItem)

typedef struct tagLVCOLUMNA
{
    UINT mask;
    int fmt;
    int cx;
    LPSTR pszText;
    int cchTextMax;
    int iSubItem;
#if (_WIN32_IE >= 0x0300)
    int iImage;
    int iOrder;
#endif
#if _WIN32_WINNT >= 0x0600
    int cxMin;       // min snap point
    int cxDefault;   // default snap point
    int cxIdeal;     // read only. ideal may not eqaul current width if auto sized (LVS_EX_AUTOSIZECOLUMNS) to a lesser width.
#endif
} LVCOLUMNA, *LPLVCOLUMNA;

typedef struct tagLVCOLUMNW
{
    UINT mask;
    int fmt;
    int cx;
    LPWSTR pszText;
    int cchTextMax;
    int iSubItem;
#if (_WIN32_IE >= 0x0300)
    int iImage;
    int iOrder;
#endif
#if _WIN32_WINNT >= 0x0600
    int cxMin;       // min snap point
    int cxDefault;   // default snap point
    int cxIdeal;     // read only. ideal may not eqaul current width if auto sized (LVS_EX_AUTOSIZECOLUMNS) to a lesser width.
#endif
} LVCOLUMNW, *LPLVCOLUMNW;

#ifdef UNICODE
#define  LVCOLUMN               LVCOLUMNW
#define  LPLVCOLUMN             LPLVCOLUMNW
#define LVCOLUMN_V1_SIZE LVCOLUMNW_V1_SIZE
#else
#define  LVCOLUMN               LVCOLUMNA
#define  LPLVCOLUMN             LPLVCOLUMNA
#define LVCOLUMN_V1_SIZE LVCOLUMNA_V1_SIZE
#endif


#define LVCF_FMT                0x0001
#define LVCF_WIDTH              0x0002
#define LVCF_TEXT               0x0004
#define LVCF_SUBITEM            0x0008
#if (_WIN32_IE >= 0x0300)
#define LVCF_IMAGE              0x0010
#define LVCF_ORDER              0x0020
#endif
#if _WIN32_WINNT >= 0x0600
#define LVCF_MINWIDTH           0x0040
#define LVCF_DEFAULTWIDTH       0x0080
#define LVCF_IDEALWIDTH         0x0100
#endif

// LVCFMT_ flags up to FFFF are shared with the header control (HDF_ flags).
// Flags above FFFF are listview-specific.

#define LVCFMT_LEFT                 0x0000 // Same as HDF_LEFT
#define LVCFMT_RIGHT                0x0001 // Same as HDF_RIGHT
#define LVCFMT_CENTER               0x0002 // Same as HDF_CENTER
#define LVCFMT_JUSTIFYMASK          0x0003 // Same as HDF_JUSTIFYMASK

#if (_WIN32_IE >= 0x0300)
#define LVCFMT_IMAGE                0x0800 // Same as HDF_IMAGE
#define LVCFMT_BITMAP_ON_RIGHT      0x1000 // Same as HDF_BITMAP_ON_RIGHT
#define LVCFMT_COL_HAS_IMAGES       0x8000 // Same as HDF_OWNERDRAW
#endif

#if _WIN32_WINNT >= 0x0600
#define LVCFMT_FIXED_WIDTH          0x00100  // Can't resize the column; same as HDF_FIXEDWIDTH
#define LVCFMT_NO_DPI_SCALE         0x40000  // If not set, CCM_DPISCALE will govern scaling up fixed width
#define LVCFMT_FIXED_RATIO          0x80000  // Width will augment with the row height

// The following flags
#define LVCFMT_LINE_BREAK          0x100000 // Move to the top of the next list of columns
#define LVCFMT_FILL                0x200000 // Fill the remainder of the tile area. Might have a title.
#define LVCFMT_WRAP                0x400000 // This sub-item can be wrapped.
#define LVCFMT_NO_TITLE            0x800000  // This sub-item doesn't have an title.
#define LVCFMT_TILE_PLACEMENTMASK (LVCFMT_LINE_BREAK | LVCFMT_FILL)

#define LVCFMT_SPLITBUTTON        0x1000000 // Column is a split button; same as HDF_SPLITBUTTON
#endif

#define LVM_GETCOLUMNA          (LVM_FIRST + 25)
#define LVM_GETCOLUMNW          (LVM_FIRST + 95)
#ifdef UNICODE
#define  LVM_GETCOLUMN          LVM_GETCOLUMNW
#else
#define  LVM_GETCOLUMN          LVM_GETCOLUMNA
#endif

#define ListView_GetColumn(hwnd, iCol, pcol) \
    (BOOL)SNDMSG((hwnd), LVM_GETCOLUMN, (WPARAM)(int)(iCol), (LPARAM)(LV_COLUMN *)(pcol))

#define LVM_SETCOLUMNA          (LVM_FIRST + 26)
#define LVM_SETCOLUMNW          (LVM_FIRST + 96)
#ifdef UNICODE
#define  LVM_SETCOLUMN          LVM_SETCOLUMNW
#else
#define  LVM_SETCOLUMN          LVM_SETCOLUMNA
#endif

#define ListView_SetColumn(hwnd, iCol, pcol) \
    (BOOL)SNDMSG((hwnd), LVM_SETCOLUMN, (WPARAM)(int)(iCol), (LPARAM)(const LV_COLUMN *)(pcol))


#define LVM_INSERTCOLUMNA       (LVM_FIRST + 27)
#define LVM_INSERTCOLUMNW       (LVM_FIRST + 97)
#ifdef UNICODE
#   define  LVM_INSERTCOLUMN    LVM_INSERTCOLUMNW
#else
#   define  LVM_INSERTCOLUMN    LVM_INSERTCOLUMNA
#endif

#define ListView_InsertColumn(hwnd, iCol, pcol) \
    (int)SNDMSG((hwnd), LVM_INSERTCOLUMN, (WPARAM)(int)(iCol), (LPARAM)(const LV_COLUMN *)(pcol))


#define LVM_DELETECOLUMN        (LVM_FIRST + 28)
#define ListView_DeleteColumn(hwnd, iCol) \
    (BOOL)SNDMSG((hwnd), LVM_DELETECOLUMN, (WPARAM)(int)(iCol), 0)


#define LVM_GETCOLUMNWIDTH      (LVM_FIRST + 29)
#define ListView_GetColumnWidth(hwnd, iCol) \
    (int)SNDMSG((hwnd), LVM_GETCOLUMNWIDTH, (WPARAM)(int)(iCol), 0)


#define LVSCW_AUTOSIZE              -1
#define LVSCW_AUTOSIZE_USEHEADER    -2
#define LVM_SETCOLUMNWIDTH          (LVM_FIRST + 30)

#define ListView_SetColumnWidth(hwnd, iCol, cx) \
    (BOOL)SNDMSG((hwnd), LVM_SETCOLUMNWIDTH, (WPARAM)(int)(iCol), MAKELPARAM((cx), 0))

#if (_WIN32_IE >= 0x0300)
#define LVM_GETHEADER               (LVM_FIRST + 31)
#define ListView_GetHeader(hwnd)\
    (HWND)SNDMSG((hwnd), LVM_GETHEADER, 0, 0L)
#endif

#define LVM_CREATEDRAGIMAGE     (LVM_FIRST + 33)
#define ListView_CreateDragImage(hwnd, i, lpptUpLeft) \
    (HIMAGELIST)SNDMSG((hwnd), LVM_CREATEDRAGIMAGE, (WPARAM)(int)(i), (LPARAM)(LPPOINT)(lpptUpLeft))


#define LVM_GETVIEWRECT         (LVM_FIRST + 34)
#define ListView_GetViewRect(hwnd, prc) \
    (BOOL)SNDMSG((hwnd), LVM_GETVIEWRECT, 0, (LPARAM)(RECT *)(prc))


#define LVM_GETTEXTCOLOR        (LVM_FIRST + 35)
#define ListView_GetTextColor(hwnd)  \
    (COLORREF)SNDMSG((hwnd), LVM_GETTEXTCOLOR, 0, 0L)


#define LVM_SETTEXTCOLOR        (LVM_FIRST + 36)
#define ListView_SetTextColor(hwnd, clrText) \
    (BOOL)SNDMSG((hwnd), LVM_SETTEXTCOLOR, 0, (LPARAM)(COLORREF)(clrText))


#define LVM_GETTEXTBKCOLOR      (LVM_FIRST + 37)
#define ListView_GetTextBkColor(hwnd)  \
    (COLORREF)SNDMSG((hwnd), LVM_GETTEXTBKCOLOR, 0, 0L)


#define LVM_SETTEXTBKCOLOR      (LVM_FIRST + 38)
#define ListView_SetTextBkColor(hwnd, clrTextBk) \
    (BOOL)SNDMSG((hwnd), LVM_SETTEXTBKCOLOR, 0, (LPARAM)(COLORREF)(clrTextBk))


#define LVM_GETTOPINDEX         (LVM_FIRST + 39)
#define ListView_GetTopIndex(hwndLV) \
    (int)SNDMSG((hwndLV), LVM_GETTOPINDEX, 0, 0)


#define LVM_GETCOUNTPERPAGE     (LVM_FIRST + 40)
#define ListView_GetCountPerPage(hwndLV) \
    (int)SNDMSG((hwndLV), LVM_GETCOUNTPERPAGE, 0, 0)


#define LVM_GETORIGIN           (LVM_FIRST + 41)
#define ListView_GetOrigin(hwndLV, ppt) \
    (BOOL)SNDMSG((hwndLV), LVM_GETORIGIN, (WPARAM)0, (LPARAM)(POINT *)(ppt))


#define LVM_UPDATE              (LVM_FIRST + 42)
#define ListView_Update(hwndLV, i) \
    (BOOL)SNDMSG((hwndLV), LVM_UPDATE, (WPARAM)(i), 0L)


#define LVM_SETITEMSTATE        (LVM_FIRST + 43)
#define ListView_SetItemState(hwndLV, i, data, mask) \
{ LV_ITEM _macro_lvi;\
  _macro_lvi.stateMask = (mask);\
  _macro_lvi.state = (data);\
  SNDMSG((hwndLV), LVM_SETITEMSTATE, (WPARAM)(i), (LPARAM)(LV_ITEM *)&_macro_lvi);\
}

#if (_WIN32_IE >= 0x0300)
#define ListView_SetCheckState(hwndLV, i, fCheck) \
  ListView_SetItemState(hwndLV, i, INDEXTOSTATEIMAGEMASK((fCheck)?2:1), LVIS_STATEIMAGEMASK)
#endif

#define LVM_GETITEMSTATE        (LVM_FIRST + 44)
#define ListView_GetItemState(hwndLV, i, mask) \
   (UINT)SNDMSG((hwndLV), LVM_GETITEMSTATE, (WPARAM)(i), (LPARAM)(mask))

#if (_WIN32_IE >= 0x0300)
#define ListView_GetCheckState(hwndLV, i) \
   ((((UINT)(SNDMSG((hwndLV), LVM_GETITEMSTATE, (WPARAM)(i), LVIS_STATEIMAGEMASK))) >> 12) -1)
#endif

#define LVM_GETITEMTEXTA        (LVM_FIRST + 45)
#define LVM_GETITEMTEXTW        (LVM_FIRST + 115)

#ifdef UNICODE
#define  LVM_GETITEMTEXT        LVM_GETITEMTEXTW
#else
#define  LVM_GETITEMTEXT        LVM_GETITEMTEXTA
#endif

#define ListView_GetItemText(hwndLV, i, iSubItem_, pszText_, cchTextMax_) \
{ LV_ITEM _macro_lvi;\
  _macro_lvi.iSubItem = (iSubItem_);\
  _macro_lvi.cchTextMax = (cchTextMax_);\
  _macro_lvi.pszText = (pszText_);\
  SNDMSG((hwndLV), LVM_GETITEMTEXT, (WPARAM)(i), (LPARAM)(LV_ITEM *)&_macro_lvi);\
}


#define LVM_SETITEMTEXTA        (LVM_FIRST + 46)
#define LVM_SETITEMTEXTW        (LVM_FIRST + 116)

#ifdef UNICODE
#define  LVM_SETITEMTEXT        LVM_SETITEMTEXTW
#else
#define  LVM_SETITEMTEXT        LVM_SETITEMTEXTA
#endif

#define ListView_SetItemText(hwndLV, i, iSubItem_, pszText_) \
{ LV_ITEM _macro_lvi;\
  _macro_lvi.iSubItem = (iSubItem_);\
  _macro_lvi.pszText = (pszText_);\
  SNDMSG((hwndLV), LVM_SETITEMTEXT, (WPARAM)(i), (LPARAM)(LV_ITEM *)&_macro_lvi);\
}

#if (_WIN32_IE >= 0x0300)
// these flags only apply to LVS_OWNERDATA listviews in report or list mode
#define LVSICF_NOINVALIDATEALL  0x00000001
#define LVSICF_NOSCROLL         0x00000002
#endif

#define LVM_SETITEMCOUNT        (LVM_FIRST + 47)
#define ListView_SetItemCount(hwndLV, cItems) \
  SNDMSG((hwndLV), LVM_SETITEMCOUNT, (WPARAM)(cItems), 0)

#if (_WIN32_IE >= 0x0300)
#define ListView_SetItemCountEx(hwndLV, cItems, dwFlags) \
  SNDMSG((hwndLV), LVM_SETITEMCOUNT, (WPARAM)(cItems), (LPARAM)(dwFlags))
#endif

typedef int (CALLBACK *PFNLVCOMPARE)(LPARAM, LPARAM, LPARAM);


#define LVM_SORTITEMS           (LVM_FIRST + 48)
#define ListView_SortItems(hwndLV, _pfnCompare, _lPrm) \
  (BOOL)SNDMSG((hwndLV), LVM_SORTITEMS, (WPARAM)(LPARAM)(_lPrm), \
  (LPARAM)(PFNLVCOMPARE)(_pfnCompare))


#define LVM_SETITEMPOSITION32   (LVM_FIRST + 49)
#define ListView_SetItemPosition32(hwndLV, i, x0, y0) \
{   POINT ptNewPos; \
    ptNewPos.x = (x0); ptNewPos.y = (y0); \
    SNDMSG((hwndLV), LVM_SETITEMPOSITION32, (WPARAM)(int)(i), (LPARAM)&ptNewPos); \
}


#define LVM_GETSELECTEDCOUNT    (LVM_FIRST + 50)
#define ListView_GetSelectedCount(hwndLV) \
    (UINT)SNDMSG((hwndLV), LVM_GETSELECTEDCOUNT, 0, 0L)

#define LVM_GETITEMSPACING      (LVM_FIRST + 51)
#define ListView_GetItemSpacing(hwndLV, fSmall) \
        (DWORD)SNDMSG((hwndLV), LVM_GETITEMSPACING, fSmall, 0L)


#define LVM_GETISEARCHSTRINGA   (LVM_FIRST + 52)
#define LVM_GETISEARCHSTRINGW   (LVM_FIRST + 117)

#ifdef UNICODE
#define LVM_GETISEARCHSTRING    LVM_GETISEARCHSTRINGW
#else
#define LVM_GETISEARCHSTRING    LVM_GETISEARCHSTRINGA
#endif

#define ListView_GetISearchString(hwndLV, lpsz) \
        (BOOL)SNDMSG((hwndLV), LVM_GETISEARCHSTRING, 0, (LPARAM)(LPTSTR)(lpsz))

#if (_WIN32_IE >= 0x0300)
#define LVM_SETICONSPACING      (LVM_FIRST + 53)
// -1 for cx and cy means we'll use the default (system settings)
// 0 for cx or cy means use the current setting (allows you to change just one param)
#define ListView_SetIconSpacing(hwndLV, cx, cy) \
        (DWORD)SNDMSG((hwndLV), LVM_SETICONSPACING, 0, MAKELONG(cx,cy))


#define LVM_SETEXTENDEDLISTVIEWSTYLE (LVM_FIRST + 54)   // optional wParam == mask
#define ListView_SetExtendedListViewStyle(hwndLV, dw)\
        (DWORD)SNDMSG((hwndLV), LVM_SETEXTENDEDLISTVIEWSTYLE, 0, dw)
#if (_WIN32_IE >= 0x0400)
#define ListView_SetExtendedListViewStyleEx(hwndLV, dwMask, dw)\
        (DWORD)SNDMSG((hwndLV), LVM_SETEXTENDEDLISTVIEWSTYLE, dwMask, dw)
#endif

#define LVM_GETEXTENDEDLISTVIEWSTYLE (LVM_FIRST + 55)
#define ListView_GetExtendedListViewStyle(hwndLV)\
        (DWORD)SNDMSG((hwndLV), LVM_GETEXTENDEDLISTVIEWSTYLE, 0, 0)

#define LVS_EX_GRIDLINES        0x00000001
#define LVS_EX_SUBITEMIMAGES    0x00000002
#define LVS_EX_CHECKBOXES       0x00000004
#define LVS_EX_TRACKSELECT      0x00000008
#define LVS_EX_HEADERDRAGDROP   0x00000010
#define LVS_EX_FULLROWSELECT    0x00000020 // applies to report mode only
#define LVS_EX_ONECLICKACTIVATE 0x00000040
#define LVS_EX_TWOCLICKACTIVATE 0x00000080
#if (_WIN32_IE >= 0x0400)
#define LVS_EX_FLATSB           0x00000100
#define LVS_EX_REGIONAL         0x00000200
#define LVS_EX_INFOTIP          0x00000400 // listview does InfoTips for you
#define LVS_EX_UNDERLINEHOT     0x00000800
#define LVS_EX_UNDERLINECOLD    0x00001000
#define LVS_EX_MULTIWORKAREAS   0x00002000
#endif
#if (_WIN32_IE >= 0x0500)
#define LVS_EX_LABELTIP         0x00004000 // listview unfolds partly hidden labels if it does not have infotip text
#define LVS_EX_BORDERSELECT     0x00008000 // border selection style instead of highlight
#endif  // End (_WIN32_IE >= 0x0500)
#if (_WIN32_WINNT >= 0x0501)
#define LVS_EX_DOUBLEBUFFER     0x00010000
#define LVS_EX_HIDELABELS       0x00020000
#define LVS_EX_SINGLEROW        0x00040000
#define LVS_EX_SNAPTOGRID       0x00080000  // Icons automatically snap to grid.
#define LVS_EX_SIMPLESELECT     0x00100000  // Also changes overlay rendering to top right for icon mode.
#endif
#if _WIN32_WINNT >= 0x0600
#define LVS_EX_JUSTIFYCOLUMNS   0x00200000  // Icons are lined up in columns that use up the whole view area.
#define LVS_EX_TRANSPARENTBKGND 0x00400000  // Background is painted by the parent via WM_PRINTCLIENT
#define LVS_EX_TRANSPARENTSHADOWTEXT 0x00800000  // Enable shadow text on transparent backgrounds only (useful with bitmaps)
#define LVS_EX_AUTOAUTOARRANGE  0x01000000  // Icons automatically arrange if no icon positions have been set
#define LVS_EX_HEADERINALLVIEWS 0x02000000  // Display column header in all view modes
#define LVS_EX_AUTOCHECKSELECT  0x08000000
#define LVS_EX_AUTOSIZECOLUMNS  0x10000000
#define LVS_EX_COLUMNSNAPPOINTS 0x40000000
#define LVS_EX_COLUMNOVERFLOW   0x80000000

#endif

#define LVM_GETSUBITEMRECT      (LVM_FIRST + 56)
#define ListView_GetSubItemRect(hwnd, iItem, iSubItem, code, prc) \
        (BOOL)SNDMSG((hwnd), LVM_GETSUBITEMRECT, (WPARAM)(int)(iItem), \
                ((prc) ? ((((LPRECT)(prc))->top = (iSubItem)), (((LPRECT)(prc))->left = (code)), (LPARAM)(prc)) : (LPARAM)(LPRECT)NULL))

#define LVM_SUBITEMHITTEST      (LVM_FIRST + 57)
#define ListView_SubItemHitTest(hwnd, plvhti) \
        (int)SNDMSG((hwnd), LVM_SUBITEMHITTEST, 0, (LPARAM)(LPLVHITTESTINFO)(plvhti))
#define ListView_SubItemHitTestEx(hwnd, plvhti) \
        (int)SNDMSG((hwnd), LVM_SUBITEMHITTEST, (WPARAM)-1, (LPARAM)(LPLVHITTESTINFO)(plvhti))

#define LVM_SETCOLUMNORDERARRAY (LVM_FIRST + 58)
#define ListView_SetColumnOrderArray(hwnd, iCount, pi) \
        (BOOL)SNDMSG((hwnd), LVM_SETCOLUMNORDERARRAY, (WPARAM)(iCount), (LPARAM)(LPINT)(pi))

#define LVM_GETCOLUMNORDERARRAY (LVM_FIRST + 59)
#define ListView_GetColumnOrderArray(hwnd, iCount, pi) \
        (BOOL)SNDMSG((hwnd), LVM_GETCOLUMNORDERARRAY, (WPARAM)(iCount), (LPARAM)(LPINT)(pi))

#define LVM_SETHOTITEM  (LVM_FIRST + 60)
#define ListView_SetHotItem(hwnd, i) \
        (int)SNDMSG((hwnd), LVM_SETHOTITEM, (WPARAM)(i), 0)

#define LVM_GETHOTITEM  (LVM_FIRST + 61)
#define ListView_GetHotItem(hwnd) \
        (int)SNDMSG((hwnd), LVM_GETHOTITEM, 0, 0)

#define LVM_SETHOTCURSOR  (LVM_FIRST + 62)
#define ListView_SetHotCursor(hwnd, hcur) \
        (HCURSOR)SNDMSG((hwnd), LVM_SETHOTCURSOR, 0, (LPARAM)(hcur))

#define LVM_GETHOTCURSOR  (LVM_FIRST + 63)
#define ListView_GetHotCursor(hwnd) \
        (HCURSOR)SNDMSG((hwnd), LVM_GETHOTCURSOR, 0, 0)

#define LVM_APPROXIMATEVIEWRECT (LVM_FIRST + 64)
#define ListView_ApproximateViewRect(hwnd, iWidth, iHeight, iCount) \
        (DWORD)SNDMSG((hwnd), LVM_APPROXIMATEVIEWRECT, (WPARAM)(iCount), MAKELPARAM(iWidth, iHeight))
#endif      // _WIN32_IE >= 0x0300

#if (_WIN32_IE >= 0x0400)

#define LV_MAX_WORKAREAS         16
#define LVM_SETWORKAREAS         (LVM_FIRST + 65)
#define ListView_SetWorkAreas(hwnd, nWorkAreas, prc) \
    (BOOL)SNDMSG((hwnd), LVM_SETWORKAREAS, (WPARAM)(int)(nWorkAreas), (LPARAM)(RECT *)(prc))

#define LVM_GETWORKAREAS        (LVM_FIRST + 70)
#define ListView_GetWorkAreas(hwnd, nWorkAreas, prc) \
    (BOOL)SNDMSG((hwnd), LVM_GETWORKAREAS, (WPARAM)(int)(nWorkAreas), (LPARAM)(RECT *)(prc))


#define LVM_GETNUMBEROFWORKAREAS  (LVM_FIRST + 73)
#define ListView_GetNumberOfWorkAreas(hwnd, pnWorkAreas) \
    (BOOL)SNDMSG((hwnd), LVM_GETNUMBEROFWORKAREAS, 0, (LPARAM)(UINT *)(pnWorkAreas))


#define LVM_GETSELECTIONMARK    (LVM_FIRST + 66)
#define ListView_GetSelectionMark(hwnd) \
    (int)SNDMSG((hwnd), LVM_GETSELECTIONMARK, 0, 0)

#define LVM_SETSELECTIONMARK    (LVM_FIRST + 67)
#define ListView_SetSelectionMark(hwnd, i) \
    (int)SNDMSG((hwnd), LVM_SETSELECTIONMARK, 0, (LPARAM)(i))

#define LVM_SETHOVERTIME        (LVM_FIRST + 71)
#define ListView_SetHoverTime(hwndLV, dwHoverTimeMs)\
        (DWORD)SNDMSG((hwndLV), LVM_SETHOVERTIME, 0, (LPARAM)(dwHoverTimeMs))

#define LVM_GETHOVERTIME        (LVM_FIRST + 72)
#define ListView_GetHoverTime(hwndLV)\
        (DWORD)SNDMSG((hwndLV), LVM_GETHOVERTIME, 0, 0)

#define LVM_SETTOOLTIPS       (LVM_FIRST + 74)
#define ListView_SetToolTips(hwndLV, hwndNewHwnd)\
        (HWND)SNDMSG((hwndLV), LVM_SETTOOLTIPS, (WPARAM)(hwndNewHwnd), 0)

#define LVM_GETTOOLTIPS       (LVM_FIRST + 78)
#define ListView_GetToolTips(hwndLV)\
        (HWND)SNDMSG((hwndLV), LVM_GETTOOLTIPS, 0, 0)


#define LVM_SORTITEMSEX          (LVM_FIRST + 81)
#define ListView_SortItemsEx(hwndLV, _pfnCompare, _lPrm) \
  (BOOL)SNDMSG((hwndLV), LVM_SORTITEMSEX, (WPARAM)(LPARAM)(_lPrm), (LPARAM)(PFNLVCOMPARE)(_pfnCompare))

typedef struct tagLVBKIMAGEA
{
    ULONG ulFlags;              // LVBKIF_*
    HBITMAP hbm;
    LPSTR pszImage;
    UINT cchImageMax;
    int xOffsetPercent;
    int yOffsetPercent;
} LVBKIMAGEA, *LPLVBKIMAGEA;
typedef struct tagLVBKIMAGEW
{
    ULONG ulFlags;              // LVBKIF_*
    HBITMAP hbm;
    LPWSTR pszImage;
    UINT cchImageMax;
    int xOffsetPercent;
    int yOffsetPercent;
} LVBKIMAGEW, *LPLVBKIMAGEW;

#define LVBKIF_SOURCE_NONE      0x00000000
#define LVBKIF_SOURCE_HBITMAP   0x00000001
#define LVBKIF_SOURCE_URL       0x00000002
#define LVBKIF_SOURCE_MASK      0x00000003
#define LVBKIF_STYLE_NORMAL     0x00000000
#define LVBKIF_STYLE_TILE       0x00000010
#define LVBKIF_STYLE_MASK       0x00000010
#if (_WIN32_WINNT >= 0x0501)
#define LVBKIF_FLAG_TILEOFFSET  0x00000100
#define LVBKIF_TYPE_WATERMARK   0x10000000
#define LVBKIF_FLAG_ALPHABLEND  0x20000000
#endif

#define LVM_SETBKIMAGEA         (LVM_FIRST + 68)
#define LVM_SETBKIMAGEW         (LVM_FIRST + 138)
#define LVM_GETBKIMAGEA         (LVM_FIRST + 69)
#define LVM_GETBKIMAGEW         (LVM_FIRST + 139)

#if (_WIN32_WINNT >= 0x0501)
#define LVM_SETSELECTEDCOLUMN         (LVM_FIRST + 140)
#define ListView_SetSelectedColumn(hwnd, iCol) \
    SNDMSG((hwnd), LVM_SETSELECTEDCOLUMN, (WPARAM)(iCol), 0)

#define LV_VIEW_ICON            0x0000
#define LV_VIEW_DETAILS         0x0001
#define LV_VIEW_SMALLICON       0x0002
#define LV_VIEW_LIST            0x0003
#define LV_VIEW_TILE            0x0004
#define LV_VIEW_MAX             0x0004

#define LVM_SETVIEW         (LVM_FIRST + 142)
#define ListView_SetView(hwnd, iView) \
    (DWORD)SNDMSG((hwnd), LVM_SETVIEW, (WPARAM)(DWORD)(iView), 0)

#define LVM_GETVIEW         (LVM_FIRST + 143)
#define ListView_GetView(hwnd) \
    (DWORD)SNDMSG((hwnd), LVM_GETVIEW, 0, 0)


#define LVGF_NONE           0x00000000
#define LVGF_HEADER         0x00000001
#define LVGF_FOOTER         0x00000002
#define LVGF_STATE          0x00000004
#define LVGF_ALIGN          0x00000008
#define LVGF_GROUPID        0x00000010
#if _WIN32_WINNT >= 0x0600
#define LVGF_SUBTITLE           0x00000100  // pszSubtitle is valid
#define LVGF_TASK               0x00000200  // pszTask is valid
#define LVGF_DESCRIPTIONTOP     0x00000400  // pszDescriptionTop is valid
#define LVGF_DESCRIPTIONBOTTOM  0x00000800  // pszDescriptionBottom is valid
#define LVGF_TITLEIMAGE         0x00001000  // iTitleImage is valid
#define LVGF_EXTENDEDIMAGE      0x00002000  // iExtendedImage is valid
#define LVGF_ITEMS              0x00004000  // iFirstItem and cItems are valid
#define LVGF_SUBSET             0x00008000  // pszSubsetTitle is valid
#define LVGF_SUBSETITEMS        0x00010000  // readonly, cItems holds count of items in visible subset, iFirstItem is valid
#endif

#define LVGS_NORMAL             0x00000000
#define LVGS_COLLAPSED          0x00000001
#define LVGS_HIDDEN             0x00000002
#define LVGS_NOHEADER           0x00000004
#define LVGS_COLLAPSIBLE        0x00000008
#define LVGS_FOCUSED            0x00000010
#define LVGS_SELECTED           0x00000020
#define LVGS_SUBSETED           0x00000040
#define LVGS_SUBSETLINKFOCUSED  0x00000080

#define LVGA_HEADER_LEFT    0x00000001
#define LVGA_HEADER_CENTER  0x00000002
#define LVGA_HEADER_RIGHT   0x00000004  // Don't forget to validate exclusivity
#define LVGA_FOOTER_LEFT    0x00000008
#define LVGA_FOOTER_CENTER  0x00000010
#define LVGA_FOOTER_RIGHT   0x00000020  // Don't forget to validate exclusivity

typedef struct tagLVGROUP
{
    UINT    cbSize;
    UINT    mask;
    LPWSTR  pszHeader;
    int     cchHeader;

    LPWSTR  pszFooter;
    int     cchFooter;

    int     iGroupId;

    UINT    stateMask;
    UINT    state;
    UINT    uAlign;
#if _WIN32_WINNT >= 0x0600
    LPWSTR  pszSubtitle;
    UINT    cchSubtitle;
    LPWSTR  pszTask;
    UINT    cchTask;
    LPWSTR  pszDescriptionTop;
    UINT    cchDescriptionTop;
    LPWSTR  pszDescriptionBottom;
    UINT    cchDescriptionBottom;
    int     iTitleImage;
    int     iExtendedImage;
    int     iFirstItem;         // Read only
    UINT    cItems;             // Read only
    LPWSTR  pszSubsetTitle;     // NULL if group is not subset
    UINT    cchSubsetTitle;

#define LVGROUP_V5_SIZE CCSIZEOF_STRUCT(LVGROUP, uAlign)

#endif
} LVGROUP, *PLVGROUP;

#define LVM_INSERTGROUP         (LVM_FIRST + 145)
#define ListView_InsertGroup(hwnd, index, pgrp) \
    SNDMSG((hwnd), LVM_INSERTGROUP, (WPARAM)(index), (LPARAM)(pgrp))

#define LVM_SETGROUPINFO         (LVM_FIRST + 147)
#define ListView_SetGroupInfo(hwnd, iGroupId, pgrp) \
    SNDMSG((hwnd), LVM_SETGROUPINFO, (WPARAM)(iGroupId), (LPARAM)(pgrp))

#define LVM_GETGROUPINFO         (LVM_FIRST + 149)
#define ListView_GetGroupInfo(hwnd, iGroupId, pgrp) \
    SNDMSG((hwnd), LVM_GETGROUPINFO, (WPARAM)(iGroupId), (LPARAM)(pgrp))

#define LVM_REMOVEGROUP         (LVM_FIRST + 150)
#define ListView_RemoveGroup(hwnd, iGroupId) \
    SNDMSG((hwnd), LVM_REMOVEGROUP, (WPARAM)(iGroupId), 0)

#define LVM_MOVEGROUP         (LVM_FIRST + 151)
#define ListView_MoveGroup(hwnd, iGroupId, toIndex) \
    SNDMSG((hwnd), LVM_MOVEGROUP, (WPARAM)(iGroupId), (LPARAM)(toIndex))

#define LVM_GETGROUPCOUNT         (LVM_FIRST + 152)
#define ListView_GetGroupCount(hwnd) \
    SNDMSG((hwnd), LVM_GETGROUPCOUNT, (WPARAM)0, (LPARAM)0)

#define LVM_GETGROUPINFOBYINDEX         (LVM_FIRST + 153)
#define ListView_GetGroupInfoByIndex(hwnd, iIndex, pgrp) \
    SNDMSG((hwnd), LVM_GETGROUPINFOBYINDEX, (WPARAM)(iIndex), (LPARAM)(pgrp))

#define LVM_MOVEITEMTOGROUP            (LVM_FIRST + 154)
#define ListView_MoveItemToGroup(hwnd, idItemFrom, idGroupTo) \
    SNDMSG((hwnd), LVM_MOVEITEMTOGROUP, (WPARAM)(idItemFrom), (LPARAM)(idGroupTo))

#define LVGGR_GROUP         0 // Entire expanded group
#define LVGGR_HEADER        1 // Header only (collapsed group)
#define LVGGR_LABEL         2 // Label only
#define LVGGR_SUBSETLINK    3 // subset link only

#define LVM_GETGROUPRECT               (LVM_FIRST + 98)
#define ListView_GetGroupRect(hwnd, iGroupId, type, prc) \
    SNDMSG((hwnd), LVM_GETGROUPRECT, (WPARAM)(iGroupId), \
        ((prc) ? (((RECT*)(prc))->top = (type)), (LPARAM)(RECT*)(prc) : (LPARAM)(RECT*)NULL))

#define LVGMF_NONE          0x00000000
#define LVGMF_BORDERSIZE    0x00000001
#define LVGMF_BORDERCOLOR   0x00000002
#define LVGMF_TEXTCOLOR     0x00000004

typedef struct tagLVGROUPMETRICS
{
    UINT cbSize;
    UINT mask;
    UINT Left;
    UINT Top;
    UINT Right;
    UINT Bottom;
    COLORREF crLeft;
    COLORREF crTop;
    COLORREF crRight;
    COLORREF crBottom;
    COLORREF crHeader;
    COLORREF crFooter;
} LVGROUPMETRICS, *PLVGROUPMETRICS;

#define LVM_SETGROUPMETRICS         (LVM_FIRST + 155)
#define ListView_SetGroupMetrics(hwnd, pGroupMetrics) \
    SNDMSG((hwnd), LVM_SETGROUPMETRICS, 0, (LPARAM)(pGroupMetrics))

#define LVM_GETGROUPMETRICS         (LVM_FIRST + 156)
#define ListView_GetGroupMetrics(hwnd, pGroupMetrics) \
    SNDMSG((hwnd), LVM_GETGROUPMETRICS, 0, (LPARAM)(pGroupMetrics))

#define LVM_ENABLEGROUPVIEW         (LVM_FIRST + 157)
#define ListView_EnableGroupView(hwnd, fEnable) \
    SNDMSG((hwnd), LVM_ENABLEGROUPVIEW, (WPARAM)(fEnable), 0)

typedef int (CALLBACK *PFNLVGROUPCOMPARE)(int, int, void *);

#define LVM_SORTGROUPS         (LVM_FIRST + 158)
#define ListView_SortGroups(hwnd, _pfnGroupCompate, _plv) \
    SNDMSG((hwnd), LVM_SORTGROUPS, (WPARAM)(_pfnGroupCompate), (LPARAM)(_plv))

typedef struct tagLVINSERTGROUPSORTED
{
    PFNLVGROUPCOMPARE pfnGroupCompare;
    void *pvData;
    LVGROUP lvGroup;
}LVINSERTGROUPSORTED, *PLVINSERTGROUPSORTED;

#define LVM_INSERTGROUPSORTED           (LVM_FIRST + 159)
#define ListView_InsertGroupSorted(hwnd, structInsert) \
    SNDMSG((hwnd), LVM_INSERTGROUPSORTED, (WPARAM)(structInsert), 0)

#define LVM_REMOVEALLGROUPS             (LVM_FIRST + 160)
#define ListView_RemoveAllGroups(hwnd) \
    SNDMSG((hwnd), LVM_REMOVEALLGROUPS, 0, 0)

#define LVM_HASGROUP                    (LVM_FIRST + 161)
#define ListView_HasGroup(hwnd, dwGroupId) \
    SNDMSG((hwnd), LVM_HASGROUP, dwGroupId, 0)

#define ListView_SetGroupState(hwnd, dwGroupId, dwMask, dwState) \
{ LVGROUP _macro_lvg;\
  _macro_lvg.cbSize = sizeof(_macro_lvg);\
  _macro_lvg.mask = LVGF_STATE;\
  _macro_lvg.stateMask = dwMask;\
  _macro_lvg.state = dwState;\
  SNDMSG((hwnd), LVM_SETGROUPINFO, (WPARAM)(dwGroupId), (LPARAM)(LVGROUP *)&_macro_lvg);\
}
#define LVM_GETGROUPSTATE               (LVM_FIRST + 92)
#define ListView_GetGroupState(hwnd, dwGroupId, dwMask) \
  (UINT) SNDMSG((hwnd), LVM_GETGROUPSTATE, (WPARAM)(dwGroupId), (LPARAM)(dwMask))

#define LVM_GETFOCUSEDGROUP             (LVM_FIRST + 93)
#define ListView_GetFocusedGroup(hwnd) \
    SNDMSG((hwnd), LVM_GETFOCUSEDGROUP, 0, 0)

#define LVTVIF_AUTOSIZE       0x00000000
#define LVTVIF_FIXEDWIDTH     0x00000001
#define LVTVIF_FIXEDHEIGHT    0x00000002
#define LVTVIF_FIXEDSIZE      0x00000003
#if _WIN32_WINNT >= 0x0600
#define LVTVIF_EXTENDED       0x00000004
#endif

#define LVTVIM_TILESIZE       0x00000001
#define LVTVIM_COLUMNS        0x00000002
#define LVTVIM_LABELMARGIN    0x00000004

typedef struct tagLVTILEVIEWINFO
{
    UINT    cbSize;
    DWORD   dwMask;     //LVTVIM_*
    DWORD   dwFlags;    //LVTVIF_*
    SIZE    sizeTile;
    int     cLines;
    RECT    rcLabelMargin;
} LVTILEVIEWINFO, *PLVTILEVIEWINFO;

typedef struct tagLVTILEINFO
{
    UINT    cbSize;
    int     iItem;
    UINT    cColumns;
    PUINT   puColumns;
#if _WIN32_WINNT >= 0x0600
    int*    piColFmt;
#endif
} LVTILEINFO, *PLVTILEINFO;

#define LVTILEINFO_V5_SIZE CCSIZEOF_STRUCT(LVTILEINFO, puColumns)

#define LVM_SETTILEVIEWINFO                 (LVM_FIRST + 162)
#define ListView_SetTileViewInfo(hwnd, ptvi) \
    SNDMSG((hwnd), LVM_SETTILEVIEWINFO, 0, (LPARAM)(ptvi))

#define LVM_GETTILEVIEWINFO                 (LVM_FIRST + 163)
#define ListView_GetTileViewInfo(hwnd, ptvi) \
    SNDMSG((hwnd), LVM_GETTILEVIEWINFO, 0, (LPARAM)(ptvi))

#define LVM_SETTILEINFO                     (LVM_FIRST + 164)
#define ListView_SetTileInfo(hwnd, pti) \
    SNDMSG((hwnd), LVM_SETTILEINFO, 0, (LPARAM)(pti))

#define LVM_GETTILEINFO                     (LVM_FIRST + 165)
#define ListView_GetTileInfo(hwnd, pti) \
    SNDMSG((hwnd), LVM_GETTILEINFO, 0, (LPARAM)(pti))

typedef struct
{
    UINT cbSize;
    DWORD dwFlags;
    int iItem;
    DWORD dwReserved;
} LVINSERTMARK, * LPLVINSERTMARK;

#define LVIM_AFTER      0x00000001 // TRUE = insert After iItem, otherwise before

#define LVM_SETINSERTMARK                   (LVM_FIRST + 166)
#define ListView_SetInsertMark(hwnd, lvim) \
    (BOOL)SNDMSG((hwnd), LVM_SETINSERTMARK, (WPARAM) 0, (LPARAM) (lvim))

#define LVM_GETINSERTMARK                   (LVM_FIRST + 167)
#define ListView_GetInsertMark(hwnd, lvim) \
    (BOOL)SNDMSG((hwnd), LVM_GETINSERTMARK, (WPARAM) 0, (LPARAM) (lvim))

#define LVM_INSERTMARKHITTEST               (LVM_FIRST + 168)
#define ListView_InsertMarkHitTest(hwnd, point, lvim) \
    (int)SNDMSG((hwnd), LVM_INSERTMARKHITTEST, (WPARAM)(LPPOINT)(point), (LPARAM)(LPLVINSERTMARK)(lvim))

#define LVM_GETINSERTMARKRECT               (LVM_FIRST + 169)
#define ListView_GetInsertMarkRect(hwnd, rc) \
    (int)SNDMSG((hwnd), LVM_GETINSERTMARKRECT, (WPARAM)0, (LPARAM)(LPRECT)(rc))

#define LVM_SETINSERTMARKCOLOR                 (LVM_FIRST + 170)
#define ListView_SetInsertMarkColor(hwnd, color) \
    (COLORREF)SNDMSG((hwnd), LVM_SETINSERTMARKCOLOR, (WPARAM)0, (LPARAM)(COLORREF)(color))

#define LVM_GETINSERTMARKCOLOR                 (LVM_FIRST + 171)
#define ListView_GetInsertMarkColor(hwnd) \
    (COLORREF)SNDMSG((hwnd), LVM_GETINSERTMARKCOLOR, (WPARAM)0, (LPARAM)0)

typedef struct tagLVSETINFOTIP
{
    UINT cbSize;
    DWORD dwFlags;
    LPWSTR pszText;
    int iItem;
    int iSubItem;
} LVSETINFOTIP, *PLVSETINFOTIP;

#define  LVM_SETINFOTIP         (LVM_FIRST + 173)

#define ListView_SetInfoTip(hwndLV, plvInfoTip)\
        (BOOL)SNDMSG((hwndLV), LVM_SETINFOTIP, (WPARAM)0, (LPARAM)(plvInfoTip))

#define LVM_GETSELECTEDCOLUMN   (LVM_FIRST + 174)
#define ListView_GetSelectedColumn(hwnd) \
    (UINT)SNDMSG((hwnd), LVM_GETSELECTEDCOLUMN, 0, 0)

#define LVM_ISGROUPVIEWENABLED  (LVM_FIRST + 175)
#define ListView_IsGroupViewEnabled(hwnd) \
    (BOOL)SNDMSG((hwnd), LVM_ISGROUPVIEWENABLED, 0, 0)

#define LVM_GETOUTLINECOLOR     (LVM_FIRST + 176)
#define ListView_GetOutlineColor(hwnd) \
    (COLORREF)SNDMSG((hwnd), LVM_GETOUTLINECOLOR, 0, 0)

#define LVM_SETOUTLINECOLOR     (LVM_FIRST + 177)
#define ListView_SetOutlineColor(hwnd, color) \
    (COLORREF)SNDMSG((hwnd), LVM_SETOUTLINECOLOR, (WPARAM)0, (LPARAM)(COLORREF)(color))


#define LVM_CANCELEDITLABEL     (LVM_FIRST + 179)
#define ListView_CancelEditLabel(hwnd) \
    (VOID)SNDMSG((hwnd), LVM_CANCELEDITLABEL, (WPARAM)0, (LPARAM)0)

// These next to methods make it easy to identify an item that can be repositioned
// within listview. For example: Many developers use the lParam to store an identifier that is
// unique. Unfortunatly, in order to find this item, they have to iterate through all of the items
// in the listview. Listview will maintain a unique identifier.  The upper bound is the size of a DWORD.
#define LVM_MAPINDEXTOID     (LVM_FIRST + 180)
#define ListView_MapIndexToID(hwnd, index) \
    (UINT)SNDMSG((hwnd), LVM_MAPINDEXTOID, (WPARAM)(index), (LPARAM)0)

#define LVM_MAPIDTOINDEX     (LVM_FIRST + 181)
#define ListView_MapIDToIndex(hwnd, id) \
    (UINT)SNDMSG((hwnd), LVM_MAPIDTOINDEX, (WPARAM)(id), (LPARAM)0)

#define LVM_ISITEMVISIBLE    (LVM_FIRST + 182)
#define ListView_IsItemVisible(hwnd, index) \
    (UINT)SNDMSG((hwnd), LVM_ISITEMVISIBLE, (WPARAM)(index), (LPARAM)0)


#if _WIN32_WINNT >= 0x0600
#define ListView_SetGroupHeaderImageList(hwnd, himl) \
    (HIMAGELIST)SNDMSG((hwnd), LVM_SETIMAGELIST, (WPARAM)LVSIL_GROUPHEADER, (LPARAM)(HIMAGELIST)(himl))

#define ListView_GetGroupHeaderImageList(hwnd) \
    (HIMAGELIST)SNDMSG((hwnd), LVM_GETIMAGELIST, (WPARAM)LVSIL_GROUPHEADER, 0L)

#define LVM_GETEMPTYTEXT (LVM_FIRST + 204)
#define ListView_GetEmptyText(hwnd, pszText, cchText) \
    (BOOL)SNDMSG((hwnd), LVM_GETEMPTYTEXT, (WPARAM)(cchText), (LPARAM)(pszText))

#define LVM_GETFOOTERRECT (LVM_FIRST + 205)
#define ListView_GetFooterRect(hwnd, prc) \
    (BOOL)SNDMSG((hwnd), LVM_GETFOOTERRECT, (WPARAM)(0), (LPARAM)(prc))

// footer flags
#define LVFF_ITEMCOUNT          0x00000001

typedef struct tagLVFOOTERINFO
{
    UINT mask;          // LVFF_*
    LPWSTR pszText;
    int cchTextMax;
    UINT cItems;
} LVFOOTERINFO, *LPLVFOOTERINFO;

#define LVM_GETFOOTERINFO (LVM_FIRST + 206)
#define ListView_GetFooterInfo(hwnd, plvfi) \
    (BOOL)SNDMSG((hwnd), LVM_GETFOOTERINFO, (WPARAM)(0), (LPARAM)(plvfi))

#define LVM_GETFOOTERITEMRECT (LVM_FIRST + 207)
#define ListView_GetFooterItemRect(hwnd, iItem, prc) \
    (BOOL)SNDMSG((hwnd), LVM_GETFOOTERITEMRECT, (WPARAM)(iItem), (LPARAM)(prc))

// footer item flags
#define LVFIF_TEXT               0x00000001
#define LVFIF_STATE              0x00000002

// footer item state
#define LVFIS_FOCUSED            0x0001

typedef struct tagLVFOOTERITEM
{
    UINT mask;          // LVFIF_*
    int iItem;
    LPWSTR pszText;
    int cchTextMax;
    UINT state;         // LVFIS_*
    UINT stateMask;     // LVFIS_*
} LVFOOTERITEM, *LPLVFOOTERITEM;

#define LVM_GETFOOTERITEM (LVM_FIRST + 208)
#define ListView_GetFooterItem(hwnd, iItem, pfi) \
    (BOOL)SNDMSG((hwnd), LVM_GETFOOTERITEM, (WPARAM)(iItem), (LPARAM)(pfi))

// supports a single item in multiple groups.
typedef struct tagLVITEMINDEX
{
    int iItem;          // listview item index
    int iGroup;         // group index (must be -1 if group view is not enabled)
} LVITEMINDEX, *PLVITEMINDEX;

#define LVM_GETITEMINDEXRECT    (LVM_FIRST + 209)
#define ListView_GetItemIndexRect(hwnd, plvii, iSubItem, code, prc) \
        (BOOL)SNDMSG((hwnd), LVM_GETITEMINDEXRECT, (WPARAM)(LVITEMINDEX*)(plvii), \
                ((prc) ? ((((LPRECT)(prc))->top = (iSubItem)), (((LPRECT)(prc))->left = (code)), (LPARAM)(prc)) : (LPARAM)(LPRECT)NULL))

#define LVM_SETITEMINDEXSTATE   (LVM_FIRST + 210)
#define ListView_SetItemIndexState(hwndLV, plvii, data, mask) \
{ LV_ITEM _macro_lvi;\
  _macro_lvi.stateMask = (mask);\
  _macro_lvi.state = (data);\
  SNDMSG((hwndLV), LVM_SETITEMINDEXSTATE, (WPARAM)(LVITEMINDEX*)(plvii), (LPARAM)(LV_ITEM *)&_macro_lvi);\
}

#define LVM_GETNEXTITEMINDEX    (LVM_FIRST + 211)
#define ListView_GetNextItemIndex(hwnd, plvii, flags) \
    (BOOL)SNDMSG((hwnd), LVM_GETNEXTITEMINDEX, (WPARAM)(LVITEMINDEX*)(plvii), MAKELPARAM((flags), 0))

#endif

#endif


#ifdef UNICODE
#define LVBKIMAGE               LVBKIMAGEW
#define LPLVBKIMAGE             LPLVBKIMAGEW
#define LVM_SETBKIMAGE          LVM_SETBKIMAGEW
#define LVM_GETBKIMAGE          LVM_GETBKIMAGEW
#else
#define LVBKIMAGE               LVBKIMAGEA
#define LPLVBKIMAGE             LPLVBKIMAGEA
#define LVM_SETBKIMAGE          LVM_SETBKIMAGEA
#define LVM_GETBKIMAGE          LVM_GETBKIMAGEA
#endif

#define ListView_SetBkImage(hwnd, plvbki) \
    (BOOL)SNDMSG((hwnd), LVM_SETBKIMAGE, 0, (LPARAM)(plvbki))

#define ListView_GetBkImage(hwnd, plvbki) \
    (BOOL)SNDMSG((hwnd), LVM_GETBKIMAGE, 0, (LPARAM)(plvbki))


#endif      // _WIN32_IE >= 0x0400


#if (_WIN32_IE >= 0x0300)
#define LPNM_LISTVIEW   LPNMLISTVIEW
#define NM_LISTVIEW     NMLISTVIEW
#else
#define tagNMLISTVIEW   _NM_LISTVIEW
#define    NMLISTVIEW    NM_LISTVIEW
#define  LPNMLISTVIEW  LPNM_LISTVIEW
#endif

typedef struct tagNMLISTVIEW
{
    NMHDR   hdr;
    int     iItem;
    int     iSubItem;
    UINT    uNewState;
    UINT    uOldState;
    UINT    uChanged;
    POINT   ptAction;
    LPARAM  lParam;
} NMLISTVIEW, *LPNMLISTVIEW;


#if (_WIN32_IE >= 0x400)
// NMITEMACTIVATE is used instead of NMLISTVIEW in IE >= 0x400
// therefore all the fields are the same except for extra uKeyFlags
// they are used to store key flags at the time of the single click with
// delayed activation - because by the time the timer goes off a user may
// not hold the keys (shift, ctrl) any more
typedef struct tagNMITEMACTIVATE
{
    NMHDR   hdr;
    int     iItem;
    int     iSubItem;
    UINT    uNewState;
    UINT    uOldState;
    UINT    uChanged;
    POINT   ptAction;
    LPARAM  lParam;
    UINT    uKeyFlags;
} NMITEMACTIVATE, *LPNMITEMACTIVATE;

// key flags stored in uKeyFlags
#define LVKF_ALT       0x0001
#define LVKF_CONTROL   0x0002
#define LVKF_SHIFT     0x0004
#endif //(_WIN32_IE >= 0x0400)


#if (_WIN32_IE >= 0x0300)
#define NMLVCUSTOMDRAW_V3_SIZE CCSIZEOF_STRUCT(NMLVCUSTOMDRAW, clrTextBk)

typedef struct tagNMLVCUSTOMDRAW
{
    NMCUSTOMDRAW nmcd;
    COLORREF clrText;
    COLORREF clrTextBk;
#if (_WIN32_IE >= 0x0400)
    int iSubItem;
#endif
#if (_WIN32_WINNT >= 0x0501)
    DWORD dwItemType;

    // Item custom draw
    COLORREF clrFace;
    int iIconEffect;
    int iIconPhase;
    int iPartId;
    int iStateId;

    // Group Custom Draw
    RECT rcText;
    UINT uAlign;      // Alignment. Use LVGA_HEADER_CENTER, LVGA_HEADER_RIGHT, LVGA_HEADER_LEFT
#endif
} NMLVCUSTOMDRAW, *LPNMLVCUSTOMDRAW;

// dwItemType
#define LVCDI_ITEM      0x00000000
#define LVCDI_GROUP     0x00000001

// ListView custom draw return values
#define LVCDRF_NOSELECT             0x00010000
#define LVCDRF_NOGROUPFRAME         0x00020000


typedef struct tagNMLVCACHEHINT
{
    NMHDR   hdr;
    int     iFrom;
    int     iTo;
} NMLVCACHEHINT, *LPNMLVCACHEHINT;

#define LPNM_CACHEHINT  LPNMLVCACHEHINT
#define PNM_CACHEHINT   LPNMLVCACHEHINT
#define NM_CACHEHINT    NMLVCACHEHINT

typedef struct tagNMLVFINDITEMA
{
    NMHDR   hdr;
    int     iStart;
    LVFINDINFOA lvfi;
} NMLVFINDITEMA, *LPNMLVFINDITEMA;

typedef struct tagNMLVFINDITEMW
{
    NMHDR   hdr;
    int     iStart;
    LVFINDINFOW lvfi;
} NMLVFINDITEMW, *LPNMLVFINDITEMW;

#define PNM_FINDITEMA   LPNMLVFINDITEMA
#define LPNM_FINDITEMA  LPNMLVFINDITEMA
#define NM_FINDITEMA    NMLVFINDITEMA

#define PNM_FINDITEMW   LPNMLVFINDITEMW
#define LPNM_FINDITEMW  LPNMLVFINDITEMW
#define NM_FINDITEMW    NMLVFINDITEMW

#ifdef UNICODE
#define PNM_FINDITEM    PNM_FINDITEMW
#define LPNM_FINDITEM   LPNM_FINDITEMW
#define NM_FINDITEM     NM_FINDITEMW
#define NMLVFINDITEM    NMLVFINDITEMW
#define LPNMLVFINDITEM  LPNMLVFINDITEMW
#else
#define PNM_FINDITEM    PNM_FINDITEMA
#define LPNM_FINDITEM   LPNM_FINDITEMA
#define NM_FINDITEM     NM_FINDITEMA
#define NMLVFINDITEM    NMLVFINDITEMA
#define LPNMLVFINDITEM  LPNMLVFINDITEMA
#endif

typedef struct tagNMLVODSTATECHANGE
{
    NMHDR hdr;
    int iFrom;
    int iTo;
    UINT uNewState;
    UINT uOldState;
} NMLVODSTATECHANGE, *LPNMLVODSTATECHANGE;

#define PNM_ODSTATECHANGE   LPNMLVODSTATECHANGE
#define LPNM_ODSTATECHANGE  LPNMLVODSTATECHANGE
#define NM_ODSTATECHANGE    NMLVODSTATECHANGE
#endif      // _WIN32_IE >= 0x0300


#define LVN_ITEMCHANGING        (LVN_FIRST-0)
#define LVN_ITEMCHANGED         (LVN_FIRST-1)
#define LVN_INSERTITEM          (LVN_FIRST-2)
#define LVN_DELETEITEM          (LVN_FIRST-3)
#define LVN_DELETEALLITEMS      (LVN_FIRST-4)
#define LVN_BEGINLABELEDITA     (LVN_FIRST-5)
#define LVN_BEGINLABELEDITW     (LVN_FIRST-75)
#define LVN_ENDLABELEDITA       (LVN_FIRST-6)
#define LVN_ENDLABELEDITW       (LVN_FIRST-76)
#define LVN_COLUMNCLICK         (LVN_FIRST-8)
#define LVN_BEGINDRAG           (LVN_FIRST-9)
#define LVN_BEGINRDRAG          (LVN_FIRST-11)

#if (_WIN32_IE >= 0x0300)
#define LVN_ODCACHEHINT         (LVN_FIRST-13)
#define LVN_ODFINDITEMA         (LVN_FIRST-52)
#define LVN_ODFINDITEMW         (LVN_FIRST-79)

#define LVN_ITEMACTIVATE        (LVN_FIRST-14)
#define LVN_ODSTATECHANGED      (LVN_FIRST-15)

#ifdef UNICODE
#define LVN_ODFINDITEM          LVN_ODFINDITEMW
#else
#define LVN_ODFINDITEM          LVN_ODFINDITEMA
#endif
#endif      // _WIN32_IE >= 0x0300


#if (_WIN32_IE >= 0x0400)
#define LVN_HOTTRACK            (LVN_FIRST-21)
#endif

#define LVN_GETDISPINFOA        (LVN_FIRST-50)
#define LVN_GETDISPINFOW        (LVN_FIRST-77)
#define LVN_SETDISPINFOA        (LVN_FIRST-51)
#define LVN_SETDISPINFOW        (LVN_FIRST-78)

#ifdef UNICODE
#define LVN_BEGINLABELEDIT      LVN_BEGINLABELEDITW
#define LVN_ENDLABELEDIT        LVN_ENDLABELEDITW
#define LVN_GETDISPINFO         LVN_GETDISPINFOW
#define LVN_SETDISPINFO         LVN_SETDISPINFOW
#else
#define LVN_BEGINLABELEDIT      LVN_BEGINLABELEDITA
#define LVN_ENDLABELEDIT        LVN_ENDLABELEDITA
#define LVN_GETDISPINFO         LVN_GETDISPINFOA
#define LVN_SETDISPINFO         LVN_SETDISPINFOA
#endif


#define LVIF_DI_SETITEM         0x1000

#if (_WIN32_IE >= 0x0300)
#define LV_DISPINFOA    NMLVDISPINFOA
#define LV_DISPINFOW    NMLVDISPINFOW
#else
#define tagLVDISPINFO   _LV_DISPINFO
#define NMLVDISPINFOA    LV_DISPINFOA
#define tagLVDISPINFOW  _LV_DISPINFOW
#define NMLVDISPINFOW    LV_DISPINFOW
#endif

#define LV_DISPINFO     NMLVDISPINFO

typedef struct tagLVDISPINFO {
    NMHDR hdr;
    LVITEMA item;
} NMLVDISPINFOA, *LPNMLVDISPINFOA;

typedef struct tagLVDISPINFOW {
    NMHDR hdr;
    LVITEMW item;
} NMLVDISPINFOW, *LPNMLVDISPINFOW;

#ifdef UNICODE
#define  NMLVDISPINFO           NMLVDISPINFOW
#else
#define  NMLVDISPINFO           NMLVDISPINFOA
#endif

#define LVN_KEYDOWN             (LVN_FIRST-55)

#if (_WIN32_IE >= 0x0300)
#define LV_KEYDOWN              NMLVKEYDOWN
#else
#define tagLVKEYDOWN            _LV_KEYDOWN
#define NMLVKEYDOWN              LV_KEYDOWN
#endif

#ifdef _WIN32
#include <pshpack1.h>
#endif

typedef struct tagLVKEYDOWN
{
    NMHDR hdr;
    WORD wVKey;
    UINT flags;
} NMLVKEYDOWN, *LPNMLVKEYDOWN;

#ifdef _WIN32
#include <poppack.h>
#endif

#if (_WIN32_IE >= 0x0300)
#define LVN_MARQUEEBEGIN        (LVN_FIRST-56)
#endif

#if _WIN32_WINNT >= 0x0600
typedef struct tagNMLVLINK
{
    NMHDR       hdr;
    LITEM       link;
    int         iItem;
    int         iSubItem;
} NMLVLINK,  *PNMLVLINK;
#endif

#if (_WIN32_IE >= 0x0400)
typedef struct tagNMLVGETINFOTIPA
{
    NMHDR hdr;
    DWORD dwFlags;
    LPSTR pszText;
    int cchTextMax;
    int iItem;
    int iSubItem;
    LPARAM lParam;
} NMLVGETINFOTIPA, *LPNMLVGETINFOTIPA;

typedef struct tagNMLVGETINFOTIPW
{
    NMHDR hdr;
    DWORD dwFlags;
    LPWSTR pszText;
    int cchTextMax;
    int iItem;
    int iSubItem;
    LPARAM lParam;
} NMLVGETINFOTIPW, *LPNMLVGETINFOTIPW;

// NMLVGETINFOTIPA.dwFlag values

#define LVGIT_UNFOLDED  0x0001

#define LVN_GETINFOTIPA          (LVN_FIRST-57)
#define LVN_GETINFOTIPW          (LVN_FIRST-58)

#ifdef UNICODE
#define LVN_GETINFOTIP          LVN_GETINFOTIPW
#define NMLVGETINFOTIP          NMLVGETINFOTIPW
#define LPNMLVGETINFOTIP        LPNMLVGETINFOTIPW
#else
#define LVN_GETINFOTIP          LVN_GETINFOTIPA
#define NMLVGETINFOTIP          NMLVGETINFOTIPA
#define LPNMLVGETINFOTIP        LPNMLVGETINFOTIPA
#endif


#endif      // _WIN32_IE >= 0x0400

#if (_WIN32_IE >= 0x0500)

//
//  LVN_INCREMENTALSEARCH gives the app the opportunity to customize
//  incremental search.  For example, if the items are numeric,
//  the app can do numerical search instead of string search.
//
//  ListView notifies the app with NMLVFINDITEM.
//  The app sets pnmfi->lvfi.lParam to the result of the incremental search,
//  or to LVNSCH_DEFAULT if ListView should do the default search,
//  or to LVNSCH_ERROR to fail the search and just beep,
//  or to LVNSCH_IGNORE to stop all ListView processing.
//
//  The return value is not used.

#define LVNSCH_DEFAULT  -1
#define LVNSCH_ERROR    -2
#define LVNSCH_IGNORE   -3

#define LVN_INCREMENTALSEARCHA   (LVN_FIRST-62)
#define LVN_INCREMENTALSEARCHW   (LVN_FIRST-63)

#ifdef UNICODE
#define LVN_INCREMENTALSEARCH    LVN_INCREMENTALSEARCHW
#else
#define LVN_INCREMENTALSEARCH    LVN_INCREMENTALSEARCHA
#endif

#endif      // _WIN32_IE >= 0x0500

#if _WIN32_WINNT >= 0x0600
#define LVN_COLUMNDROPDOWN       (LVN_FIRST-64)


#define LVN_COLUMNOVERFLOWCLICK  (LVN_FIRST-66)

#endif // _WIN32_WINNT >= 0x0600

#if (_WIN32_WINNT >= 0x0501)
typedef struct tagNMLVSCROLL
{
    NMHDR   hdr;
    int     dx;
    int     dy;
} NMLVSCROLL, *LPNMLVSCROLL;

#define LVN_BEGINSCROLL          (LVN_FIRST-80)
#define LVN_ENDSCROLL            (LVN_FIRST-81)
#endif


#if _WIN32_WINNT >= 0x0600
#define LVN_LINKCLICK           (LVN_FIRST-84)


#define EMF_CENTERED            0x00000001  // render markup centered in the listview area

typedef struct tagNMLVEMPTYMARKUP
{
    NMHDR hdr;
    // out params from client back to listview
    DWORD dwFlags;                      // EMF_*
    WCHAR szMarkup[L_MAX_URL_LENGTH];   // markup displayed
} NMLVEMPTYMARKUP;

#define LVN_GETEMPTYMARKUP      (LVN_FIRST-87)


#endif

#endif // NOLISTVIEW

//====== TREEVIEW CONTROL =====================================================

#ifndef NOTREEVIEW

#ifdef _WIN32
#define WC_TREEVIEWA            "SysTreeView32"
#define WC_TREEVIEWW            L"SysTreeView32"

#ifdef UNICODE
#define  WC_TREEVIEW            WC_TREEVIEWW
#else
#define  WC_TREEVIEW            WC_TREEVIEWA
#endif

#else
#define WC_TREEVIEW             "SysTreeView"
#endif

// begin_r_commctrl

#define TVS_HASBUTTONS          0x0001
#define TVS_HASLINES            0x0002
#define TVS_LINESATROOT         0x0004
#define TVS_EDITLABELS          0x0008
#define TVS_DISABLEDRAGDROP     0x0010
#define TVS_SHOWSELALWAYS       0x0020
#if (_WIN32_IE >= 0x0300)
#define TVS_RTLREADING          0x0040

#define TVS_NOTOOLTIPS          0x0080
#define TVS_CHECKBOXES          0x0100
#define TVS_TRACKSELECT         0x0200
#if (_WIN32_IE >= 0x0400)
#define TVS_SINGLEEXPAND        0x0400
#define TVS_INFOTIP             0x0800
#define TVS_FULLROWSELECT       0x1000
#define TVS_NOSCROLL            0x2000
#define TVS_NONEVENHEIGHT       0x4000
#endif
#if (_WIN32_IE >= 0x500)
#define TVS_NOHSCROLL           0x8000  // TVS_NOSCROLL overrides this
#endif
#endif


#if (_WIN32_WINNT >= 0x0600)
#define TVS_EX_MULTISELECT          0x0002
#define TVS_EX_DOUBLEBUFFER         0x0004
#define TVS_EX_NOINDENTSTATE        0x0008
#define TVS_EX_RICHTOOLTIP          0x0010
#define TVS_EX_AUTOHSCROLL          0x0020
#define TVS_EX_FADEINOUTEXPANDOS    0x0040
#define TVS_EX_PARTIALCHECKBOXES    0x0080
#define TVS_EX_EXCLUSIONCHECKBOXES  0x0100
#define TVS_EX_DIMMEDCHECKBOXES     0x0200
#define TVS_EX_DRAWIMAGEASYNC       0x0400
#endif

// end_r_commctrl

struct _TREEITEM;
typedef struct _TREEITEM *HTREEITEM;

#define TVIF_TEXT               0x0001
#define TVIF_IMAGE              0x0002
#define TVIF_PARAM              0x0004
#define TVIF_STATE              0x0008
#define TVIF_HANDLE             0x0010
#define TVIF_SELECTEDIMAGE      0x0020
#define TVIF_CHILDREN           0x0040
#if (_WIN32_IE >= 0x0400)
#define TVIF_INTEGRAL           0x0080
#endif
#if (_WIN32_IE >= 0x0600)
#define TVIF_STATEEX            0x0100
#define TVIF_EXPANDEDIMAGE      0x0200
#endif
#define TVIS_SELECTED           0x0002
#define TVIS_CUT                0x0004
#define TVIS_DROPHILITED        0x0008
#define TVIS_BOLD               0x0010
#define TVIS_EXPANDED           0x0020
#define TVIS_EXPANDEDONCE       0x0040
#if (_WIN32_IE >= 0x0300)
#define TVIS_EXPANDPARTIAL      0x0080
#endif

#define TVIS_OVERLAYMASK        0x0F00
#define TVIS_STATEIMAGEMASK     0xF000
#define TVIS_USERMASK           0xF000

#if (_WIN32_IE >= 0x0600)
#define TVIS_EX_FLAT            0x0001
#if (_WIN32_WINNT >= 0x0600)
#define TVIS_EX_DISABLED        0x0002
#endif
#define TVIS_EX_ALL             0x0002

// Structure for TreeView's NM_TVSTATEIMAGECHANGING notification
typedef struct tagNMTVSTATEIMAGECHANGING
{
    NMHDR hdr;
    HTREEITEM hti;
    int iOldStateImageIndex;
    int iNewStateImageIndex;
} NMTVSTATEIMAGECHANGING, *LPNMTVSTATEIMAGECHANGING;
#endif

#define I_CHILDRENCALLBACK  (-1)

#if (_WIN32_IE >= 0x0300)
#define LPTV_ITEMW              LPTVITEMW
#define LPTV_ITEMA              LPTVITEMA
#define TV_ITEMW                TVITEMW
#define TV_ITEMA                TVITEMA
#else
#define tagTVITEMA             _TV_ITEMA
#define    TVITEMA              TV_ITEMA
#define  LPTVITEMA            LPTV_ITEMA
#define tagTVITEMW             _TV_ITEMW
#define    TVITEMW              TV_ITEMW
#define  LPTVITEMW            LPTV_ITEMW
#endif

#define LPTV_ITEM               LPTVITEM
#define TV_ITEM                 TVITEM

typedef struct tagTVITEMA {
    UINT      mask;
    HTREEITEM hItem;
    UINT      state;
    UINT      stateMask;
    LPSTR     pszText;
    int       cchTextMax;
    int       iImage;
    int       iSelectedImage;
    int       cChildren;
    LPARAM    lParam;
} TVITEMA, *LPTVITEMA;

typedef struct tagTVITEMW {
    UINT      mask;
    HTREEITEM hItem;
    UINT      state;
    UINT      stateMask;
    LPWSTR    pszText;
    int       cchTextMax;
    int       iImage;
    int       iSelectedImage;
    int       cChildren;
    LPARAM    lParam;
} TVITEMW, *LPTVITEMW;

#if (_WIN32_IE >= 0x0400)
// only used for Get and Set messages.  no notifies
typedef struct tagTVITEMEXA {
    UINT      mask;
    HTREEITEM hItem;
    UINT      state;
    UINT      stateMask;
    LPSTR     pszText;
    int       cchTextMax;
    int       iImage;
    int       iSelectedImage;
    int       cChildren;
    LPARAM    lParam;
    int       iIntegral;
#if (_WIN32_IE >= 0x0600)
    UINT      uStateEx;
    HWND      hwnd;
    int       iExpandedImage;
#endif
} TVITEMEXA, *LPTVITEMEXA;
// only used for Get and Set messages.  no notifies
typedef struct tagTVITEMEXW {
    UINT      mask;
    HTREEITEM hItem;
    UINT      state;
    UINT      stateMask;
    LPWSTR    pszText;
    int       cchTextMax;
    int       iImage;
    int       iSelectedImage;
    int       cChildren;
    LPARAM    lParam;
    int       iIntegral;
#if (_WIN32_IE >= 0x0600)
    UINT      uStateEx;
    HWND      hwnd;
    int       iExpandedImage;
#endif
} TVITEMEXW, *LPTVITEMEXW;
#ifdef UNICODE
typedef TVITEMEXW TVITEMEX;
typedef LPTVITEMEXW LPTVITEMEX;
#else
typedef TVITEMEXA TVITEMEX;
typedef LPTVITEMEXA LPTVITEMEX;
#endif // UNICODE

#endif

#ifdef UNICODE
#define  TVITEM                 TVITEMW
#define  LPTVITEM               LPTVITEMW
#else
#define  TVITEM                 TVITEMA
#define  LPTVITEM               LPTVITEMA
#endif


#define TVI_ROOT                ((HTREEITEM)(ULONG_PTR)-0x10000)
#define TVI_FIRST               ((HTREEITEM)(ULONG_PTR)-0x0FFFF)
#define TVI_LAST                ((HTREEITEM)(ULONG_PTR)-0x0FFFE)
#define TVI_SORT                ((HTREEITEM)(ULONG_PTR)-0x0FFFD)

#if (_WIN32_IE >= 0x0300)
#define LPTV_INSERTSTRUCTA      LPTVINSERTSTRUCTA
#define LPTV_INSERTSTRUCTW      LPTVINSERTSTRUCTW
#define TV_INSERTSTRUCTA        TVINSERTSTRUCTA
#define TV_INSERTSTRUCTW        TVINSERTSTRUCTW
#else
#define tagTVINSERTSTRUCTA     _TV_INSERTSTRUCTA
#define    TVINSERTSTRUCTA      TV_INSERTSTRUCTA
#define  LPTVINSERTSTRUCTA    LPTV_INSERTSTRUCTA
#define tagTVINSERTSTRUCTW     _TV_INSERTSTRUCTW
#define    TVINSERTSTRUCTW      TV_INSERTSTRUCTW
#define  LPTVINSERTSTRUCTW    LPTV_INSERTSTRUCTW
#endif

#define TV_INSERTSTRUCT         TVINSERTSTRUCT
#define LPTV_INSERTSTRUCT       LPTVINSERTSTRUCT


#define TVINSERTSTRUCTA_V1_SIZE CCSIZEOF_STRUCT(TVINSERTSTRUCTA, item)
#define TVINSERTSTRUCTW_V1_SIZE CCSIZEOF_STRUCT(TVINSERTSTRUCTW, item)

typedef struct tagTVINSERTSTRUCTA {
    HTREEITEM hParent;
    HTREEITEM hInsertAfter;
#if (_WIN32_IE >= 0x0400)
    union
    {
        TVITEMEXA itemex;
        TV_ITEMA  item;
    } DUMMYUNIONNAME;
#else
    TV_ITEMA item;
#endif
} TVINSERTSTRUCTA, *LPTVINSERTSTRUCTA;

typedef struct tagTVINSERTSTRUCTW {
    HTREEITEM hParent;
    HTREEITEM hInsertAfter;
#if (_WIN32_IE >= 0x0400)
    union
    {
        TVITEMEXW itemex;
        TV_ITEMW  item;
    } DUMMYUNIONNAME;
#else
    TV_ITEMW item;
#endif
} TVINSERTSTRUCTW, *LPTVINSERTSTRUCTW;

#ifdef UNICODE
#define  TVINSERTSTRUCT         TVINSERTSTRUCTW
#define  LPTVINSERTSTRUCT       LPTVINSERTSTRUCTW
#define TVINSERTSTRUCT_V1_SIZE TVINSERTSTRUCTW_V1_SIZE
#else
#define  TVINSERTSTRUCT         TVINSERTSTRUCTA
#define  LPTVINSERTSTRUCT       LPTVINSERTSTRUCTA
#define TVINSERTSTRUCT_V1_SIZE TVINSERTSTRUCTA_V1_SIZE
#endif

#define TVM_INSERTITEMA         (TV_FIRST + 0)
#define TVM_INSERTITEMW         (TV_FIRST + 50)
#ifdef UNICODE
#define  TVM_INSERTITEM         TVM_INSERTITEMW
#else
#define  TVM_INSERTITEM         TVM_INSERTITEMA
#endif

#define TreeView_InsertItem(hwnd, lpis) \
    (HTREEITEM)SNDMSG((hwnd), TVM_INSERTITEM, 0, (LPARAM)(LPTV_INSERTSTRUCT)(lpis))


#define TVM_DELETEITEM          (TV_FIRST + 1)
#define TreeView_DeleteItem(hwnd, hitem) \
    (BOOL)SNDMSG((hwnd), TVM_DELETEITEM, 0, (LPARAM)(HTREEITEM)(hitem))


#define TreeView_DeleteAllItems(hwnd) \
    (BOOL)SNDMSG((hwnd), TVM_DELETEITEM, 0, (LPARAM)TVI_ROOT)


#define TVM_EXPAND              (TV_FIRST + 2)
#define TreeView_Expand(hwnd, hitem, code) \
    (BOOL)SNDMSG((hwnd), TVM_EXPAND, (WPARAM)(code), (LPARAM)(HTREEITEM)(hitem))


#define TVE_COLLAPSE            0x0001
#define TVE_EXPAND              0x0002
#define TVE_TOGGLE              0x0003
#if (_WIN32_IE >= 0x0300)
#define TVE_EXPANDPARTIAL       0x4000
#endif
#define TVE_COLLAPSERESET       0x8000


#define TVM_GETITEMRECT         (TV_FIRST + 4)
#define TreeView_GetItemRect(hwnd, hitem, prc, code) \
    (*(HTREEITEM *)(prc) = (hitem), (BOOL)SNDMSG((hwnd), TVM_GETITEMRECT, (WPARAM)(code), (LPARAM)(RECT *)(prc)))


#define TVM_GETCOUNT            (TV_FIRST + 5)
#define TreeView_GetCount(hwnd) \
    (UINT)SNDMSG((hwnd), TVM_GETCOUNT, 0, 0)


#define TVM_GETINDENT           (TV_FIRST + 6)
#define TreeView_GetIndent(hwnd) \
    (UINT)SNDMSG((hwnd), TVM_GETINDENT, 0, 0)


#define TVM_SETINDENT           (TV_FIRST + 7)
#define TreeView_SetIndent(hwnd, indent) \
    (BOOL)SNDMSG((hwnd), TVM_SETINDENT, (WPARAM)(indent), 0)


#define TVM_GETIMAGELIST        (TV_FIRST + 8)
#define TreeView_GetImageList(hwnd, iImage) \
    (HIMAGELIST)SNDMSG((hwnd), TVM_GETIMAGELIST, iImage, 0)


#define TVSIL_NORMAL            0
#define TVSIL_STATE             2


#define TVM_SETIMAGELIST        (TV_FIRST + 9)
#define TreeView_SetImageList(hwnd, himl, iImage) \
    (HIMAGELIST)SNDMSG((hwnd), TVM_SETIMAGELIST, iImage, (LPARAM)(HIMAGELIST)(himl))


#define TVM_GETNEXTITEM         (TV_FIRST + 10)
#define TreeView_GetNextItem(hwnd, hitem, code) \
    (HTREEITEM)SNDMSG((hwnd), TVM_GETNEXTITEM, (WPARAM)(code), (LPARAM)(HTREEITEM)(hitem))


#define TVGN_ROOT               0x0000
#define TVGN_NEXT               0x0001
#define TVGN_PREVIOUS           0x0002
#define TVGN_PARENT             0x0003
#define TVGN_CHILD              0x0004
#define TVGN_FIRSTVISIBLE       0x0005
#define TVGN_NEXTVISIBLE        0x0006
#define TVGN_PREVIOUSVISIBLE    0x0007
#define TVGN_DROPHILITE         0x0008
#define TVGN_CARET              0x0009
#if (_WIN32_IE >= 0x0400)
#define TVGN_LASTVISIBLE        0x000A
#endif      // _WIN32_IE >= 0x0400
#if (_WIN32_IE >= 0x0600)
#define TVGN_NEXTSELECTED       0x000B
#endif

#if (_WIN32_WINNT >= 0x0501)
#define TVSI_NOSINGLEEXPAND    0x8000 // Should not conflict with TVGN flags.
#endif

#define TreeView_GetChild(hwnd, hitem)          TreeView_GetNextItem(hwnd, hitem, TVGN_CHILD)
#define TreeView_GetNextSibling(hwnd, hitem)    TreeView_GetNextItem(hwnd, hitem, TVGN_NEXT)
#define TreeView_GetPrevSibling(hwnd, hitem)    TreeView_GetNextItem(hwnd, hitem, TVGN_PREVIOUS)
#define TreeView_GetParent(hwnd, hitem)         TreeView_GetNextItem(hwnd, hitem, TVGN_PARENT)
#define TreeView_GetFirstVisible(hwnd)          TreeView_GetNextItem(hwnd, NULL,  TVGN_FIRSTVISIBLE)
#define TreeView_GetNextVisible(hwnd, hitem)    TreeView_GetNextItem(hwnd, hitem, TVGN_NEXTVISIBLE)
#define TreeView_GetPrevVisible(hwnd, hitem)    TreeView_GetNextItem(hwnd, hitem, TVGN_PREVIOUSVISIBLE)
#define TreeView_GetSelection(hwnd)             TreeView_GetNextItem(hwnd, NULL,  TVGN_CARET)
#define TreeView_GetDropHilight(hwnd)           TreeView_GetNextItem(hwnd, NULL,  TVGN_DROPHILITE)
#define TreeView_GetRoot(hwnd)                  TreeView_GetNextItem(hwnd, NULL,  TVGN_ROOT)
#if (_WIN32_IE >= 0x0400)
#define TreeView_GetLastVisible(hwnd)           TreeView_GetNextItem(hwnd, NULL,  TVGN_LASTVISIBLE)
#endif      // _WIN32_IE >= 0x0400
#if (_WIN32_IE >= 0x0600)
#define TreeView_GetNextSelected(hwnd, hitem)   TreeView_GetNextItem(hwnd, hitem,  TVGN_NEXTSELECTED)
#endif

#define TVM_SELECTITEM          (TV_FIRST + 11)
#define TreeView_Select(hwnd, hitem, code) \
    (BOOL)SNDMSG((hwnd), TVM_SELECTITEM, (WPARAM)(code), (LPARAM)(HTREEITEM)(hitem))


#define TreeView_SelectItem(hwnd, hitem)            TreeView_Select(hwnd, hitem, TVGN_CARET)
#define TreeView_SelectDropTarget(hwnd, hitem)      TreeView_Select(hwnd, hitem, TVGN_DROPHILITE)
#define TreeView_SelectSetFirstVisible(hwnd, hitem) TreeView_Select(hwnd, hitem, TVGN_FIRSTVISIBLE)

#define TVM_GETITEMA            (TV_FIRST + 12)
#define TVM_GETITEMW            (TV_FIRST + 62)

#ifdef UNICODE
#define  TVM_GETITEM            TVM_GETITEMW
#else
#define  TVM_GETITEM            TVM_GETITEMA
#endif

#define TreeView_GetItem(hwnd, pitem) \
    (BOOL)SNDMSG((hwnd), TVM_GETITEM, 0, (LPARAM)(TV_ITEM *)(pitem))


#define TVM_SETITEMA            (TV_FIRST + 13)
#define TVM_SETITEMW            (TV_FIRST + 63)

#ifdef UNICODE
#define  TVM_SETITEM            TVM_SETITEMW
#else
#define  TVM_SETITEM            TVM_SETITEMA
#endif

#define TreeView_SetItem(hwnd, pitem) \
    (BOOL)SNDMSG((hwnd), TVM_SETITEM, 0, (LPARAM)(const TV_ITEM *)(pitem))


#define TVM_EDITLABELA          (TV_FIRST + 14)
#define TVM_EDITLABELW          (TV_FIRST + 65)
#ifdef UNICODE
#define TVM_EDITLABEL           TVM_EDITLABELW
#else
#define TVM_EDITLABEL           TVM_EDITLABELA
#endif

#define TreeView_EditLabel(hwnd, hitem) \
    (HWND)SNDMSG((hwnd), TVM_EDITLABEL, 0, (LPARAM)(HTREEITEM)(hitem))


#define TVM_GETEDITCONTROL      (TV_FIRST + 15)
#define TreeView_GetEditControl(hwnd) \
    (HWND)SNDMSG((hwnd), TVM_GETEDITCONTROL, 0, 0)


#define TVM_GETVISIBLECOUNT     (TV_FIRST + 16)
#define TreeView_GetVisibleCount(hwnd) \
    (UINT)SNDMSG((hwnd), TVM_GETVISIBLECOUNT, 0, 0)


#define TVM_HITTEST             (TV_FIRST + 17)
#define TreeView_HitTest(hwnd, lpht) \
    (HTREEITEM)SNDMSG((hwnd), TVM_HITTEST, 0, (LPARAM)(LPTV_HITTESTINFO)(lpht))


#if (_WIN32_IE >= 0x0300)
#define LPTV_HITTESTINFO   LPTVHITTESTINFO
#define   TV_HITTESTINFO     TVHITTESTINFO
#else
#define tagTVHITTESTINFO    _TV_HITTESTINFO
#define    TVHITTESTINFO     TV_HITTESTINFO
#define  LPTVHITTESTINFO   LPTV_HITTESTINFO
#endif

typedef struct tagTVHITTESTINFO {
    POINT       pt;
    UINT        flags;
    HTREEITEM   hItem;
} TVHITTESTINFO, *LPTVHITTESTINFO;

#define TVHT_NOWHERE            0x0001
#define TVHT_ONITEMICON         0x0002
#define TVHT_ONITEMLABEL        0x0004
#define TVHT_ONITEM             (TVHT_ONITEMICON | TVHT_ONITEMLABEL | TVHT_ONITEMSTATEICON)
#define TVHT_ONITEMINDENT       0x0008
#define TVHT_ONITEMBUTTON       0x0010
#define TVHT_ONITEMRIGHT        0x0020
#define TVHT_ONITEMSTATEICON    0x0040

#define TVHT_ABOVE              0x0100
#define TVHT_BELOW              0x0200
#define TVHT_TORIGHT            0x0400
#define TVHT_TOLEFT             0x0800


#define TVM_CREATEDRAGIMAGE     (TV_FIRST + 18)
#define TreeView_CreateDragImage(hwnd, hitem) \
    (HIMAGELIST)SNDMSG((hwnd), TVM_CREATEDRAGIMAGE, 0, (LPARAM)(HTREEITEM)(hitem))


#define TVM_SORTCHILDREN        (TV_FIRST + 19)
#define TreeView_SortChildren(hwnd, hitem, recurse) \
    (BOOL)SNDMSG((hwnd), TVM_SORTCHILDREN, (WPARAM)(recurse), (LPARAM)(HTREEITEM)(hitem))


#define TVM_ENSUREVISIBLE       (TV_FIRST + 20)
#define TreeView_EnsureVisible(hwnd, hitem) \
    (BOOL)SNDMSG((hwnd), TVM_ENSUREVISIBLE, 0, (LPARAM)(HTREEITEM)(hitem))


#define TVM_SORTCHILDRENCB      (TV_FIRST + 21)
#define TreeView_SortChildrenCB(hwnd, psort, recurse) \
    (BOOL)SNDMSG((hwnd), TVM_SORTCHILDRENCB, (WPARAM)(recurse), \
    (LPARAM)(LPTV_SORTCB)(psort))


#define TVM_ENDEDITLABELNOW     (TV_FIRST + 22)
#define TreeView_EndEditLabelNow(hwnd, fCancel) \
    (BOOL)SNDMSG((hwnd), TVM_ENDEDITLABELNOW, (WPARAM)(fCancel), 0)


#define TVM_GETISEARCHSTRINGA   (TV_FIRST + 23)
#define TVM_GETISEARCHSTRINGW   (TV_FIRST + 64)

#ifdef UNICODE
#define TVM_GETISEARCHSTRING     TVM_GETISEARCHSTRINGW
#else
#define TVM_GETISEARCHSTRING     TVM_GETISEARCHSTRINGA
#endif

#if (_WIN32_IE >= 0x0300)
#define TVM_SETTOOLTIPS         (TV_FIRST + 24)
#define TreeView_SetToolTips(hwnd,  hwndTT) \
    (HWND)SNDMSG((hwnd), TVM_SETTOOLTIPS, (WPARAM)(hwndTT), 0)
#define TVM_GETTOOLTIPS         (TV_FIRST + 25)
#define TreeView_GetToolTips(hwnd) \
    (HWND)SNDMSG((hwnd), TVM_GETTOOLTIPS, 0, 0)
#endif

#define TreeView_GetISearchString(hwndTV, lpsz) \
        (BOOL)SNDMSG((hwndTV), TVM_GETISEARCHSTRING, 0, (LPARAM)(LPTSTR)(lpsz))

#if (_WIN32_IE >= 0x0400)
#define TVM_SETINSERTMARK       (TV_FIRST + 26)
#define TreeView_SetInsertMark(hwnd, hItem, fAfter) \
        (BOOL)SNDMSG((hwnd), TVM_SETINSERTMARK, (WPARAM) (fAfter), (LPARAM) (hItem))

#define TVM_SETUNICODEFORMAT     CCM_SETUNICODEFORMAT
#define TreeView_SetUnicodeFormat(hwnd, fUnicode)  \
    (BOOL)SNDMSG((hwnd), TVM_SETUNICODEFORMAT, (WPARAM)(fUnicode), 0)

#define TVM_GETUNICODEFORMAT     CCM_GETUNICODEFORMAT
#define TreeView_GetUnicodeFormat(hwnd)  \
    (BOOL)SNDMSG((hwnd), TVM_GETUNICODEFORMAT, 0, 0)

#endif

#if (_WIN32_IE >= 0x0400)
#define TVM_SETITEMHEIGHT         (TV_FIRST + 27)
#define TreeView_SetItemHeight(hwnd,  iHeight) \
    (int)SNDMSG((hwnd), TVM_SETITEMHEIGHT, (WPARAM)(iHeight), 0)
#define TVM_GETITEMHEIGHT         (TV_FIRST + 28)
#define TreeView_GetItemHeight(hwnd) \
    (int)SNDMSG((hwnd), TVM_GETITEMHEIGHT, 0, 0)

#define TVM_SETBKCOLOR              (TV_FIRST + 29)
#define TreeView_SetBkColor(hwnd, clr) \
    (COLORREF)SNDMSG((hwnd), TVM_SETBKCOLOR, 0, (LPARAM)(clr))

#define TVM_SETTEXTCOLOR              (TV_FIRST + 30)
#define TreeView_SetTextColor(hwnd, clr) \
    (COLORREF)SNDMSG((hwnd), TVM_SETTEXTCOLOR, 0, (LPARAM)(clr))

#define TVM_GETBKCOLOR              (TV_FIRST + 31)
#define TreeView_GetBkColor(hwnd) \
    (COLORREF)SNDMSG((hwnd), TVM_GETBKCOLOR, 0, 0)

#define TVM_GETTEXTCOLOR              (TV_FIRST + 32)
#define TreeView_GetTextColor(hwnd) \
    (COLORREF)SNDMSG((hwnd), TVM_GETTEXTCOLOR, 0, 0)

#define TVM_SETSCROLLTIME              (TV_FIRST + 33)
#define TreeView_SetScrollTime(hwnd, uTime) \
    (UINT)SNDMSG((hwnd), TVM_SETSCROLLTIME, uTime, 0)

#define TVM_GETSCROLLTIME              (TV_FIRST + 34)
#define TreeView_GetScrollTime(hwnd) \
    (UINT)SNDMSG((hwnd), TVM_GETSCROLLTIME, 0, 0)


#define TVM_SETINSERTMARKCOLOR              (TV_FIRST + 37)
#define TreeView_SetInsertMarkColor(hwnd, clr) \
    (COLORREF)SNDMSG((hwnd), TVM_SETINSERTMARKCOLOR, 0, (LPARAM)(clr))
#define TVM_GETINSERTMARKCOLOR              (TV_FIRST + 38)
#define TreeView_GetInsertMarkColor(hwnd) \
    (COLORREF)SNDMSG((hwnd), TVM_GETINSERTMARKCOLOR, 0, 0)

#endif  /* (_WIN32_IE >= 0x0400) */

#if (_WIN32_IE >= 0x0500)
// tvm_?etitemstate only uses mask, state and stateMask.
// so unicode or ansi is irrelevant.
#define TreeView_SetItemState(hwndTV, hti, data, _mask) \
{ TVITEM _ms_TVi;\
  _ms_TVi.mask = TVIF_STATE; \
  _ms_TVi.hItem = (hti); \
  _ms_TVi.stateMask = (_mask);\
  _ms_TVi.state = (data);\
  SNDMSG((hwndTV), TVM_SETITEM, 0, (LPARAM)(TV_ITEM *)&_ms_TVi);\
}

#define TreeView_SetCheckState(hwndTV, hti, fCheck) \
  TreeView_SetItemState(hwndTV, hti, INDEXTOSTATEIMAGEMASK((fCheck)?2:1), TVIS_STATEIMAGEMASK)

#define TVM_GETITEMSTATE        (TV_FIRST + 39)
#define TreeView_GetItemState(hwndTV, hti, mask) \
   (UINT)SNDMSG((hwndTV), TVM_GETITEMSTATE, (WPARAM)(hti), (LPARAM)(mask))

#define TreeView_GetCheckState(hwndTV, hti) \
   ((((UINT)(SNDMSG((hwndTV), TVM_GETITEMSTATE, (WPARAM)(hti), TVIS_STATEIMAGEMASK))) >> 12) -1)


#define TVM_SETLINECOLOR            (TV_FIRST + 40)
#define TreeView_SetLineColor(hwnd, clr) \
    (COLORREF)SNDMSG((hwnd), TVM_SETLINECOLOR, 0, (LPARAM)(clr))

#define TVM_GETLINECOLOR            (TV_FIRST + 41)
#define TreeView_GetLineColor(hwnd) \
    (COLORREF)SNDMSG((hwnd), TVM_GETLINECOLOR, 0, 0)

#endif

#if (_WIN32_WINNT >= 0x0501)
#define TVM_MAPACCIDTOHTREEITEM     (TV_FIRST + 42)
#define TreeView_MapAccIDToHTREEITEM(hwnd, id) \
    (HTREEITEM)SNDMSG((hwnd), TVM_MAPACCIDTOHTREEITEM, id, 0)

#define TVM_MAPHTREEITEMTOACCID     (TV_FIRST + 43)
#define TreeView_MapHTREEITEMToAccID(hwnd, htreeitem) \
    (UINT)SNDMSG((hwnd), TVM_MAPHTREEITEMTOACCID, (WPARAM)(htreeitem), 0)

#define TVM_SETEXTENDEDSTYLE      (TV_FIRST + 44)
#define TreeView_SetExtendedStyle(hwnd, dw, mask) \
    (DWORD)SNDMSG((hwnd), TVM_SETEXTENDEDSTYLE, mask, dw)

#define TVM_GETEXTENDEDSTYLE      (TV_FIRST + 45)
#define TreeView_GetExtendedStyle(hwnd) \
    (DWORD)SNDMSG((hwnd), TVM_GETEXTENDEDSTYLE, 0, 0)


#define TVM_SETAUTOSCROLLINFO   (TV_FIRST + 59)
#define TreeView_SetAutoScrollInfo(hwnd, uPixPerSec, uUpdateTime) \
    SNDMSG((hwnd), TVM_SETAUTOSCROLLINFO, (WPARAM)(uPixPerSec), (LPARAM)(uUpdateTime))
#endif

#if (_WIN32_WINNT >= 0x0600)
#define TVM_GETSELECTEDCOUNT       (TV_FIRST + 70)
#define TreeView_GetSelectedCount(hwnd) \
    (DWORD)SNDMSG((hwnd), TVM_GETSELECTEDCOUNT, 0, 0)

#define TVM_SHOWINFOTIP            (TV_FIRST + 71)
#define TreeView_ShowInfoTip(hwnd, hitem) \
    (DWORD)SNDMSG((hwnd), TVM_SHOWINFOTIP, 0, (LPARAM)(hitem))

typedef enum _TVITEMPART
{
	TVGIPR_BUTTON  = 0x0001,
} TVITEMPART;

typedef struct tagTVGETITEMPARTRECTINFO {
    HTREEITEM hti;
    RECT*     prc;
    TVITEMPART partID;
} TVGETITEMPARTRECTINFO;

#define TVM_GETITEMPARTRECT         (TV_FIRST + 72)
#define TreeView_GetItemPartRect(hwnd, hitem, prc, partid) \
{ TVGETITEMPARTRECTINFO info; \
  info.hti = (hitem); \
  info.prc = (prc); \
  info.partID = (partid); \
  (BOOL)SNDMSG((hwnd), TVM_GETITEMPARTRECT, 0, (LPARAM)&info); \
}

#endif

typedef int (CALLBACK *PFNTVCOMPARE)(LPARAM lParam1, LPARAM lParam2, LPARAM lParamSort);

#if (_WIN32_IE >= 0x0300)
#define LPTV_SORTCB    LPTVSORTCB
#define   TV_SORTCB      TVSORTCB
#else
#define tagTVSORTCB    _TV_SORTCB
#define    TVSORTCB     TV_SORTCB
#define  LPTVSORTCB   LPTV_SORTCB
#endif

typedef struct tagTVSORTCB
{
    HTREEITEM       hParent;
    PFNTVCOMPARE    lpfnCompare;
    LPARAM          lParam;
} TVSORTCB, *LPTVSORTCB;


#if (_WIN32_IE >= 0x0300)
#define LPNM_TREEVIEWA          LPNMTREEVIEWA
#define LPNM_TREEVIEWW          LPNMTREEVIEWW
#define NM_TREEVIEWW            NMTREEVIEWW
#define NM_TREEVIEWA            NMTREEVIEWA
#else
#define tagNMTREEVIEWA          _NM_TREEVIEWA
#define tagNMTREEVIEWW          _NM_TREEVIEWW
#define NMTREEVIEWA             NM_TREEVIEWA
#define NMTREEVIEWW             NM_TREEVIEWW
#define LPNMTREEVIEWA           LPNM_TREEVIEWA
#define LPNMTREEVIEWW           LPNM_TREEVIEWW
#endif

#define LPNM_TREEVIEW           LPNMTREEVIEW
#define NM_TREEVIEW             NMTREEVIEW

typedef struct tagNMTREEVIEWA {
    NMHDR       hdr;
    UINT        action;
    TVITEMA    itemOld;
    TVITEMA    itemNew;
    POINT       ptDrag;
} NMTREEVIEWA, *LPNMTREEVIEWA;


typedef struct tagNMTREEVIEWW {
    NMHDR       hdr;
    UINT        action;
    TVITEMW    itemOld;
    TVITEMW    itemNew;
    POINT       ptDrag;
} NMTREEVIEWW, *LPNMTREEVIEWW;


#ifdef UNICODE
#define  NMTREEVIEW             NMTREEVIEWW
#define  LPNMTREEVIEW           LPNMTREEVIEWW
#else
#define  NMTREEVIEW             NMTREEVIEWA
#define  LPNMTREEVIEW           LPNMTREEVIEWA
#endif


#define TVN_SELCHANGINGA        (TVN_FIRST-1)
#define TVN_SELCHANGINGW        (TVN_FIRST-50)
#define TVN_SELCHANGEDA         (TVN_FIRST-2)
#define TVN_SELCHANGEDW         (TVN_FIRST-51)

#define TVC_UNKNOWN             0x0000
#define TVC_BYMOUSE             0x0001
#define TVC_BYKEYBOARD          0x0002

#define TVN_GETDISPINFOA        (TVN_FIRST-3)
#define TVN_GETDISPINFOW        (TVN_FIRST-52)
#define TVN_SETDISPINFOA        (TVN_FIRST-4)
#define TVN_SETDISPINFOW        (TVN_FIRST-53)

#define TVIF_DI_SETITEM         0x1000

#if (_WIN32_IE >= 0x0300)
#define TV_DISPINFOA            NMTVDISPINFOA
#define TV_DISPINFOW            NMTVDISPINFOW
#else
#define tagTVDISPINFOA  _TV_DISPINFOA
#define NMTVDISPINFOA    TV_DISPINFOA
#define tagTVDISPINFOW  _TV_DISPINFOW
#define NMTVDISPINFOW    TV_DISPINFOW
#endif

#define TV_DISPINFO             NMTVDISPINFO

typedef struct tagTVDISPINFOA {
    NMHDR hdr;
    TVITEMA item;
} NMTVDISPINFOA, *LPNMTVDISPINFOA;

typedef struct tagTVDISPINFOW {
    NMHDR hdr;
    TVITEMW item;
} NMTVDISPINFOW, *LPNMTVDISPINFOW;

#ifdef UNICODE
#define NMTVDISPINFO            NMTVDISPINFOW
#define LPNMTVDISPINFO          LPNMTVDISPINFOW
#else
#define NMTVDISPINFO            NMTVDISPINFOA
#define LPNMTVDISPINFO          LPNMTVDISPINFOA
#endif

#if (_WIN32_IE >= 0x0600)

typedef struct tagTVDISPINFOEXA {
    NMHDR hdr;
    TVITEMEXA item;
} NMTVDISPINFOEXA, *LPNMTVDISPINFOEXA;

typedef struct tagTVDISPINFOEXW {
    NMHDR hdr;
    TVITEMEXW item;
} NMTVDISPINFOEXW, *LPNMTVDISPINFOEXW;

#ifdef UNICODE
#define NMTVDISPINFOEX          NMTVDISPINFOEXW
#define LPNMTVDISPINFOEX        LPNMTVDISPINFOEXW
#else
#define NMTVDISPINFOEX          NMTVDISPINFOEXA
#define LPNMTVDISPINFOEX        LPNMTVDISPINFOEXA
#endif

#define TV_DISPINFOEXA          NMTVDISPINFOEXA
#define TV_DISPINFOEXW          NMTVDISPINFOEXW
#define TV_DISPINFOEX           NMTVDISPINFOEX

#endif
#define TVN_ITEMEXPANDINGA      (TVN_FIRST-5)
#define TVN_ITEMEXPANDINGW      (TVN_FIRST-54)
#define TVN_ITEMEXPANDEDA       (TVN_FIRST-6)
#define TVN_ITEMEXPANDEDW       (TVN_FIRST-55)
#define TVN_BEGINDRAGA          (TVN_FIRST-7)
#define TVN_BEGINDRAGW          (TVN_FIRST-56)
#define TVN_BEGINRDRAGA         (TVN_FIRST-8)
#define TVN_BEGINRDRAGW         (TVN_FIRST-57)
#define TVN_DELETEITEMA         (TVN_FIRST-9)
#define TVN_DELETEITEMW         (TVN_FIRST-58)
#define TVN_BEGINLABELEDITA     (TVN_FIRST-10)
#define TVN_BEGINLABELEDITW     (TVN_FIRST-59)
#define TVN_ENDLABELEDITA       (TVN_FIRST-11)
#define TVN_ENDLABELEDITW       (TVN_FIRST-60)
#define TVN_KEYDOWN             (TVN_FIRST-12)

#if (_WIN32_IE >= 0x0400)
#define TVN_GETINFOTIPA         (TVN_FIRST-13)
#define TVN_GETINFOTIPW         (TVN_FIRST-14)
#define TVN_SINGLEEXPAND        (TVN_FIRST-15)

#define TVNRET_DEFAULT          0
#define TVNRET_SKIPOLD          1
#define TVNRET_SKIPNEW          2
#endif // 0x400

#if (_WIN32_IE >= 0x0600)
#define TVN_ITEMCHANGINGA       (TVN_FIRST-16)
#define TVN_ITEMCHANGINGW       (TVN_FIRST-17)
#define TVN_ITEMCHANGEDA        (TVN_FIRST-18)
#define TVN_ITEMCHANGEDW        (TVN_FIRST-19)
#define TVN_ASYNCDRAW           (TVN_FIRST-20)
#endif

#if (_WIN32_IE >= 0x0300)
#define TV_KEYDOWN      NMTVKEYDOWN
#else
#define tagTVKEYDOWN    _TV_KEYDOWN
#define  NMTVKEYDOWN     TV_KEYDOWN
#endif

#ifdef _WIN32
#include <pshpack1.h>
#endif

typedef struct tagTVKEYDOWN {
    NMHDR hdr;
    WORD wVKey;
    UINT flags;
} NMTVKEYDOWN, *LPNMTVKEYDOWN;

#ifdef _WIN32
#include <poppack.h>
#endif


#ifdef UNICODE
#define TVN_SELCHANGING         TVN_SELCHANGINGW
#define TVN_SELCHANGED          TVN_SELCHANGEDW
#define TVN_GETDISPINFO         TVN_GETDISPINFOW
#define TVN_SETDISPINFO         TVN_SETDISPINFOW
#define TVN_ITEMEXPANDING       TVN_ITEMEXPANDINGW
#define TVN_ITEMEXPANDED        TVN_ITEMEXPANDEDW
#define TVN_BEGINDRAG           TVN_BEGINDRAGW
#define TVN_BEGINRDRAG          TVN_BEGINRDRAGW
#define TVN_DELETEITEM          TVN_DELETEITEMW
#define TVN_BEGINLABELEDIT      TVN_BEGINLABELEDITW
#define TVN_ENDLABELEDIT        TVN_ENDLABELEDITW
#else
#define TVN_SELCHANGING         TVN_SELCHANGINGA
#define TVN_SELCHANGED          TVN_SELCHANGEDA
#define TVN_GETDISPINFO         TVN_GETDISPINFOA
#define TVN_SETDISPINFO         TVN_SETDISPINFOA
#define TVN_ITEMEXPANDING       TVN_ITEMEXPANDINGA
#define TVN_ITEMEXPANDED        TVN_ITEMEXPANDEDA
#define TVN_BEGINDRAG           TVN_BEGINDRAGA
#define TVN_BEGINRDRAG          TVN_BEGINRDRAGA
#define TVN_DELETEITEM          TVN_DELETEITEMA
#define TVN_BEGINLABELEDIT      TVN_BEGINLABELEDITA
#define TVN_ENDLABELEDIT        TVN_ENDLABELEDITA
#endif

#if (_WIN32_IE >= 0x0300)
#define NMTVCUSTOMDRAW_V3_SIZE CCSIZEOF_STRUCT(NMTVCUSTOMDRAW, clrTextBk)

typedef struct tagNMTVCUSTOMDRAW
{
    NMCUSTOMDRAW nmcd;
    COLORREF     clrText;
    COLORREF     clrTextBk;
#if (_WIN32_IE >= 0x0400)
    int iLevel;
#endif
} NMTVCUSTOMDRAW, *LPNMTVCUSTOMDRAW;
#endif


#if (_WIN32_IE >= 0x0400)

// for tooltips

typedef struct tagNMTVGETINFOTIPA
{
    NMHDR hdr;
    LPSTR pszText;
    int cchTextMax;
    HTREEITEM hItem;
    LPARAM lParam;
} NMTVGETINFOTIPA, *LPNMTVGETINFOTIPA;

typedef struct tagNMTVGETINFOTIPW
{
    NMHDR hdr;
    LPWSTR pszText;
    int cchTextMax;
    HTREEITEM hItem;
    LPARAM lParam;
} NMTVGETINFOTIPW, *LPNMTVGETINFOTIPW;


#ifdef UNICODE
#define TVN_GETINFOTIP          TVN_GETINFOTIPW
#define NMTVGETINFOTIP          NMTVGETINFOTIPW
#define LPNMTVGETINFOTIP        LPNMTVGETINFOTIPW
#else
#define TVN_GETINFOTIP          TVN_GETINFOTIPA
#define NMTVGETINFOTIP          NMTVGETINFOTIPA
#define LPNMTVGETINFOTIP        LPNMTVGETINFOTIPA
#endif

// treeview's customdraw return meaning don't draw images.  valid on CDRF_NOTIFYITEMPREPAINT
#define TVCDRF_NOIMAGES         0x00010000

#endif      // _WIN32_IE >= 0x0400

#if (_WIN32_IE > 0x0600)
typedef struct tagTVITEMCHANGE {
    NMHDR hdr;
    UINT uChanged;
    HTREEITEM hItem;
    UINT uStateNew;
    UINT uStateOld;
    LPARAM lParam;
} NMTVITEMCHANGE;

typedef struct tagNMTVASYNCDRAW
{
    NMHDR     hdr;
    IMAGELISTDRAWPARAMS *pimldp;    // the draw that failed
    HRESULT   hr;                   // why it failed
    HTREEITEM hItem;                // item that failed to draw icon
    LPARAM    lParam;               // its data
    // Out Params
    DWORD     dwRetFlags;           // What listview should do on return
    int       iRetImageIndex;       // used if ADRF_DRAWIMAGE is returned
} NMTVASYNCDRAW;

#ifdef UNICODE
#define TVN_ITEMCHANGING        TVN_ITEMCHANGINGW
#define TVN_ITEMCHANGED         TVN_ITEMCHANGEDW
#else
#define TVN_ITEMCHANGING        TVN_ITEMCHANGINGA
#define TVN_ITEMCHANGED         TVN_ITEMCHANGEDA
#endif

#endif      // _WIN32_IE >= 0x0600

#endif      // NOTREEVIEW

#if (_WIN32_IE >= 0x0300)

#ifndef NOUSEREXCONTROLS

////////////////////  ComboBoxEx ////////////////////////////////

#define WC_COMBOBOXEXW         L"ComboBoxEx32"
#define WC_COMBOBOXEXA         "ComboBoxEx32"


#ifdef UNICODE
#define WC_COMBOBOXEX          WC_COMBOBOXEXW
#else
#define WC_COMBOBOXEX          WC_COMBOBOXEXA
#endif


#define CBEIF_TEXT              0x00000001
#define CBEIF_IMAGE             0x00000002
#define CBEIF_SELECTEDIMAGE     0x00000004
#define CBEIF_OVERLAY           0x00000008
#define CBEIF_INDENT            0x00000010
#define CBEIF_LPARAM            0x00000020

#define CBEIF_DI_SETITEM        0x10000000

typedef struct tagCOMBOBOXEXITEMA
{
    UINT mask;
    INT_PTR iItem;
    LPSTR pszText;
    int cchTextMax;
    int iImage;
    int iSelectedImage;
    int iOverlay;
    int iIndent;
    LPARAM lParam;
} COMBOBOXEXITEMA, *PCOMBOBOXEXITEMA;
typedef COMBOBOXEXITEMA CONST *PCCOMBOEXITEMA;


typedef struct tagCOMBOBOXEXITEMW
{
    UINT mask;
    INT_PTR iItem;
    LPWSTR pszText;
    int cchTextMax;
    int iImage;
    int iSelectedImage;
    int iOverlay;
    int iIndent;
    LPARAM lParam;
} COMBOBOXEXITEMW, *PCOMBOBOXEXITEMW;
typedef COMBOBOXEXITEMW CONST *PCCOMBOEXITEMW;

#ifdef UNICODE
#define COMBOBOXEXITEM            COMBOBOXEXITEMW
#define PCOMBOBOXEXITEM           PCOMBOBOXEXITEMW
#define PCCOMBOBOXEXITEM          PCCOMBOBOXEXITEMW
#else
#define COMBOBOXEXITEM            COMBOBOXEXITEMA
#define PCOMBOBOXEXITEM           PCOMBOBOXEXITEMA
#define PCCOMBOBOXEXITEM          PCCOMBOBOXEXITEMA
#endif

#define CBEM_INSERTITEMA        (WM_USER + 1)
#define CBEM_SETIMAGELIST       (WM_USER + 2)
#define CBEM_GETIMAGELIST       (WM_USER + 3)
#define CBEM_GETITEMA           (WM_USER + 4)
#define CBEM_SETITEMA           (WM_USER + 5)
#define CBEM_DELETEITEM         CB_DELETESTRING
#define CBEM_GETCOMBOCONTROL    (WM_USER + 6)
#define CBEM_GETEDITCONTROL     (WM_USER + 7)
#if (_WIN32_IE >= 0x0400)
#define CBEM_SETEXSTYLE         (WM_USER + 8)  // use  SETEXTENDEDSTYLE instead
#define CBEM_SETEXTENDEDSTYLE   (WM_USER + 14)   // lparam == new style, wParam (optional) == mask
#define CBEM_GETEXSTYLE         (WM_USER + 9) // use GETEXTENDEDSTYLE instead
#define CBEM_GETEXTENDEDSTYLE   (WM_USER + 9)
#define CBEM_SETUNICODEFORMAT   CCM_SETUNICODEFORMAT
#define CBEM_GETUNICODEFORMAT   CCM_GETUNICODEFORMAT
#else
#define CBEM_SETEXSTYLE         (WM_USER + 8)
#define CBEM_GETEXSTYLE         (WM_USER + 9)
#endif
#define CBEM_HASEDITCHANGED     (WM_USER + 10)
#define CBEM_INSERTITEMW        (WM_USER + 11)
#define CBEM_SETITEMW           (WM_USER + 12)
#define CBEM_GETITEMW           (WM_USER + 13)

#ifdef UNICODE
#define CBEM_INSERTITEM         CBEM_INSERTITEMW
#define CBEM_SETITEM            CBEM_SETITEMW
#define CBEM_GETITEM            CBEM_GETITEMW
#else
#define CBEM_INSERTITEM         CBEM_INSERTITEMA
#define CBEM_SETITEM            CBEM_SETITEMA
#define CBEM_GETITEM            CBEM_GETITEMA
#endif

#if (_WIN32_WINNT >= 0x0501)
#define CBEM_SETWINDOWTHEME     CCM_SETWINDOWTHEME
#endif


#define CBES_EX_NOEDITIMAGE          0x00000001
#define CBES_EX_NOEDITIMAGEINDENT    0x00000002
#define CBES_EX_PATHWORDBREAKPROC    0x00000004
#if (_WIN32_IE >= 0x0400)
#define CBES_EX_NOSIZELIMIT          0x00000008
#define CBES_EX_CASESENSITIVE        0x00000010
#if (_WIN32_WINNT >= 0x0600)
#define CBES_EX_TEXTENDELLIPSIS      0x00000020
#endif

typedef struct {
    NMHDR hdr;
    COMBOBOXEXITEMA ceItem;
} NMCOMBOBOXEXA, *PNMCOMBOBOXEXA;

typedef struct {
    NMHDR hdr;
    COMBOBOXEXITEMW ceItem;
} NMCOMBOBOXEXW, *PNMCOMBOBOXEXW;

#ifdef UNICODE
#define NMCOMBOBOXEX            NMCOMBOBOXEXW
#define PNMCOMBOBOXEX           PNMCOMBOBOXEXW
#define CBEN_GETDISPINFO        CBEN_GETDISPINFOW
#else
#define NMCOMBOBOXEX            NMCOMBOBOXEXA
#define PNMCOMBOBOXEX           PNMCOMBOBOXEXA
#define CBEN_GETDISPINFO        CBEN_GETDISPINFOA
#endif

#else
typedef struct {
    NMHDR hdr;
    COMBOBOXEXITEM ceItem;
} NMCOMBOBOXEX, *PNMCOMBOBOXEX;

#define CBEN_GETDISPINFO         (CBEN_FIRST - 0)

#endif      // _WIN32_IE >= 0x0400

#if (_WIN32_IE >= 0x0400)
#define CBEN_GETDISPINFOA        (CBEN_FIRST - 0)
#endif
#define CBEN_INSERTITEM          (CBEN_FIRST - 1)
#define CBEN_DELETEITEM          (CBEN_FIRST - 2)
#define CBEN_BEGINEDIT           (CBEN_FIRST - 4)
#define CBEN_ENDEDITA            (CBEN_FIRST - 5)
#define CBEN_ENDEDITW            (CBEN_FIRST - 6)

#if (_WIN32_IE >= 0x0400)
#define CBEN_GETDISPINFOW        (CBEN_FIRST - 7)
#endif

#if (_WIN32_IE >= 0x0400)
#define CBEN_DRAGBEGINA                  (CBEN_FIRST - 8)
#define CBEN_DRAGBEGINW                  (CBEN_FIRST - 9)

#ifdef UNICODE
#define CBEN_DRAGBEGIN CBEN_DRAGBEGINW
#else
#define CBEN_DRAGBEGIN CBEN_DRAGBEGINA
#endif

#endif  //(_WIN32_IE >= 0x0400)

// lParam specifies why the endedit is happening
#ifdef UNICODE
#define CBEN_ENDEDIT CBEN_ENDEDITW
#else
#define CBEN_ENDEDIT CBEN_ENDEDITA
#endif

#define CBENF_KILLFOCUS         1
#define CBENF_RETURN            2
#define CBENF_ESCAPE            3
#define CBENF_DROPDOWN          4

#define CBEMAXSTRLEN 260

#if (_WIN32_IE >= 0x0400)
// CBEN_DRAGBEGIN sends this information ...

typedef struct {
    NMHDR hdr;
    int   iItemid;
    WCHAR szText[CBEMAXSTRLEN];
}NMCBEDRAGBEGINW, *LPNMCBEDRAGBEGINW, *PNMCBEDRAGBEGINW;


typedef struct {
    NMHDR hdr;
    int   iItemid;
    char szText[CBEMAXSTRLEN];
}NMCBEDRAGBEGINA, *LPNMCBEDRAGBEGINA, *PNMCBEDRAGBEGINA;

#ifdef UNICODE
#define  NMCBEDRAGBEGIN NMCBEDRAGBEGINW
#define  LPNMCBEDRAGBEGIN LPNMCBEDRAGBEGINW
#define  PNMCBEDRAGBEGIN PNMCBEDRAGBEGINW
#else
#define  NMCBEDRAGBEGIN NMCBEDRAGBEGINA
#define  LPNMCBEDRAGBEGIN LPNMCBEDRAGBEGINA
#define  PNMCBEDRAGBEGIN PNMCBEDRAGBEGINA
#endif
#endif      // _WIN32_IE >= 0x0400

// CBEN_ENDEDIT sends this information...
// fChanged if the user actually did anything
// iNewSelection gives what would be the new selection unless the notify is failed
//                      iNewSelection may be CB_ERR if there's no match
typedef struct {
        NMHDR hdr;
        BOOL fChanged;
        int iNewSelection;
        WCHAR szText[CBEMAXSTRLEN];
        int iWhy;
} NMCBEENDEDITW, *LPNMCBEENDEDITW, *PNMCBEENDEDITW;

typedef struct {
        NMHDR hdr;
        BOOL fChanged;
        int iNewSelection;
        char szText[CBEMAXSTRLEN];
        int iWhy;
} NMCBEENDEDITA, *LPNMCBEENDEDITA,*PNMCBEENDEDITA;

#ifdef UNICODE
#define  NMCBEENDEDIT NMCBEENDEDITW
#define  LPNMCBEENDEDIT LPNMCBEENDEDITW
#define  PNMCBEENDEDIT PNMCBEENDEDITW
#else
#define  NMCBEENDEDIT NMCBEENDEDITA
#define  LPNMCBEENDEDIT LPNMCBEENDEDITA
#define  PNMCBEENDEDIT PNMCBEENDEDITA
#endif

#endif

#endif      // _WIN32_IE >= 0x0300



//====== TAB CONTROL ==========================================================

#ifndef NOTABCONTROL

#ifdef _WIN32

#define WC_TABCONTROLA          "SysTabControl32"
#define WC_TABCONTROLW          L"SysTabControl32"

#ifdef UNICODE
#define  WC_TABCONTROL          WC_TABCONTROLW
#else
#define  WC_TABCONTROL          WC_TABCONTROLA
#endif

#else
#define WC_TABCONTROL           "SysTabControl"
#endif

// begin_r_commctrl

#if (_WIN32_IE >= 0x0300)
#define TCS_SCROLLOPPOSITE      0x0001   // assumes multiline tab
#define TCS_BOTTOM              0x0002
#define TCS_RIGHT               0x0002
#define TCS_MULTISELECT         0x0004  // allow multi-select in button mode
#endif
#if (_WIN32_IE >= 0x0400)
#define TCS_FLATBUTTONS         0x0008
#endif
#define TCS_FORCEICONLEFT       0x0010
#define TCS_FORCELABELLEFT      0x0020
#if (_WIN32_IE >= 0x0300)
#define TCS_HOTTRACK            0x0040
#define TCS_VERTICAL            0x0080
#endif
#define TCS_TABS                0x0000
#define TCS_BUTTONS             0x0100
#define TCS_SINGLELINE          0x0000
#define TCS_MULTILINE           0x0200
#define TCS_RIGHTJUSTIFY        0x0000
#define TCS_FIXEDWIDTH          0x0400
#define TCS_RAGGEDRIGHT         0x0800
#define TCS_FOCUSONBUTTONDOWN   0x1000
#define TCS_OWNERDRAWFIXED      0x2000
#define TCS_TOOLTIPS            0x4000
#define TCS_FOCUSNEVER          0x8000

// end_r_commctrl

#if (_WIN32_IE >= 0x0400)
// EX styles for use with TCM_SETEXTENDEDSTYLE
#define TCS_EX_FLATSEPARATORS   0x00000001
#define TCS_EX_REGISTERDROP     0x00000002
#endif


#define TCM_GETIMAGELIST        (TCM_FIRST + 2)
#define TabCtrl_GetImageList(hwnd) \
    (HIMAGELIST)SNDMSG((hwnd), TCM_GETIMAGELIST, 0, 0L)


#define TCM_SETIMAGELIST        (TCM_FIRST + 3)
#define TabCtrl_SetImageList(hwnd, himl) \
    (HIMAGELIST)SNDMSG((hwnd), TCM_SETIMAGELIST, 0, (LPARAM)(HIMAGELIST)(himl))


#define TCM_GETITEMCOUNT        (TCM_FIRST + 4)
#define TabCtrl_GetItemCount(hwnd) \
    (int)SNDMSG((hwnd), TCM_GETITEMCOUNT, 0, 0L)


#define TCIF_TEXT               0x0001
#define TCIF_IMAGE              0x0002
#define TCIF_RTLREADING         0x0004
#define TCIF_PARAM              0x0008
#if (_WIN32_IE >= 0x0300)
#define TCIF_STATE              0x0010


#define TCIS_BUTTONPRESSED      0x0001
#endif
#if (_WIN32_IE >= 0x0400)
#define TCIS_HIGHLIGHTED        0x0002
#endif

#if (_WIN32_IE >= 0x0300)
#define TC_ITEMHEADERA         TCITEMHEADERA
#define TC_ITEMHEADERW         TCITEMHEADERW
#else
#define tagTCITEMHEADERA       _TC_ITEMHEADERA
#define    TCITEMHEADERA        TC_ITEMHEADERA
#define tagTCITEMHEADERW       _TC_ITEMHEADERW
#define    TCITEMHEADERW        TC_ITEMHEADERW
#endif
#define TC_ITEMHEADER          TCITEMHEADER

typedef struct tagTCITEMHEADERA
{
    UINT mask;
    UINT lpReserved1;
    UINT lpReserved2;
    LPSTR pszText;
    int cchTextMax;
    int iImage;
} TCITEMHEADERA, *LPTCITEMHEADERA;

typedef struct tagTCITEMHEADERW
{
    UINT mask;
    UINT lpReserved1;
    UINT lpReserved2;
    LPWSTR pszText;
    int cchTextMax;
    int iImage;
} TCITEMHEADERW, *LPTCITEMHEADERW;

#ifdef UNICODE
#define  TCITEMHEADER          TCITEMHEADERW
#define  LPTCITEMHEADER        LPTCITEMHEADERW
#else
#define  TCITEMHEADER          TCITEMHEADERA
#define  LPTCITEMHEADER        LPTCITEMHEADERA
#endif


#if (_WIN32_IE >= 0x0300)
#define TC_ITEMA                TCITEMA
#define TC_ITEMW                TCITEMW
#else
#define tagTCITEMA              _TC_ITEMA
#define    TCITEMA               TC_ITEMA
#define tagTCITEMW              _TC_ITEMW
#define    TCITEMW               TC_ITEMW
#endif
#define TC_ITEM                 TCITEM

typedef struct tagTCITEMA
{
    UINT mask;
#if (_WIN32_IE >= 0x0300)
    DWORD dwState;
    DWORD dwStateMask;
#else
    UINT lpReserved1;
    UINT lpReserved2;
#endif
    LPSTR pszText;
    int cchTextMax;
    int iImage;

    LPARAM lParam;
} TCITEMA, *LPTCITEMA;

typedef struct tagTCITEMW
{
    UINT mask;
#if (_WIN32_IE >= 0x0300)
    DWORD dwState;
    DWORD dwStateMask;
#else
    UINT lpReserved1;
    UINT lpReserved2;
#endif
    LPWSTR pszText;
    int cchTextMax;
    int iImage;

    LPARAM lParam;
} TCITEMW, *LPTCITEMW;

#ifdef UNICODE
#define  TCITEM                 TCITEMW
#define  LPTCITEM               LPTCITEMW
#else
#define  TCITEM                 TCITEMA
#define  LPTCITEM               LPTCITEMA
#endif


#define TCM_GETITEMA            (TCM_FIRST + 5)
#define TCM_GETITEMW            (TCM_FIRST + 60)

#ifdef UNICODE
#define TCM_GETITEM             TCM_GETITEMW
#else
#define TCM_GETITEM             TCM_GETITEMA
#endif

#define TabCtrl_GetItem(hwnd, iItem, pitem) \
    (BOOL)SNDMSG((hwnd), TCM_GETITEM, (WPARAM)(int)(iItem), (LPARAM)(TC_ITEM *)(pitem))


#define TCM_SETITEMA            (TCM_FIRST + 6)
#define TCM_SETITEMW            (TCM_FIRST + 61)

#ifdef UNICODE
#define TCM_SETITEM             TCM_SETITEMW
#else
#define TCM_SETITEM             TCM_SETITEMA
#endif

#define TabCtrl_SetItem(hwnd, iItem, pitem) \
    (BOOL)SNDMSG((hwnd), TCM_SETITEM, (WPARAM)(int)(iItem), (LPARAM)(TC_ITEM *)(pitem))


#define TCM_INSERTITEMA         (TCM_FIRST + 7)
#define TCM_INSERTITEMW         (TCM_FIRST + 62)

#ifdef UNICODE
#define TCM_INSERTITEM          TCM_INSERTITEMW
#else
#define TCM_INSERTITEM          TCM_INSERTITEMA
#endif

#define TabCtrl_InsertItem(hwnd, iItem, pitem)   \
    (int)SNDMSG((hwnd), TCM_INSERTITEM, (WPARAM)(int)(iItem), (LPARAM)(const TC_ITEM *)(pitem))


#define TCM_DELETEITEM          (TCM_FIRST + 8)
#define TabCtrl_DeleteItem(hwnd, i) \
    (BOOL)SNDMSG((hwnd), TCM_DELETEITEM, (WPARAM)(int)(i), 0L)


#define TCM_DELETEALLITEMS      (TCM_FIRST + 9)
#define TabCtrl_DeleteAllItems(hwnd) \
    (BOOL)SNDMSG((hwnd), TCM_DELETEALLITEMS, 0, 0L)


#define TCM_GETITEMRECT         (TCM_FIRST + 10)
#define TabCtrl_GetItemRect(hwnd, i, prc) \
    (BOOL)SNDMSG((hwnd), TCM_GETITEMRECT, (WPARAM)(int)(i), (LPARAM)(RECT *)(prc))


#define TCM_GETCURSEL           (TCM_FIRST + 11)
#define TabCtrl_GetCurSel(hwnd) \
    (int)SNDMSG((hwnd), TCM_GETCURSEL, 0, 0)


#define TCM_SETCURSEL           (TCM_FIRST + 12)
#define TabCtrl_SetCurSel(hwnd, i) \
    (int)SNDMSG((hwnd), TCM_SETCURSEL, (WPARAM)(i), 0)


#define TCHT_NOWHERE            0x0001
#define TCHT_ONITEMICON         0x0002
#define TCHT_ONITEMLABEL        0x0004
#define TCHT_ONITEM             (TCHT_ONITEMICON | TCHT_ONITEMLABEL)

#if (_WIN32_IE >= 0x0300)
#define LPTC_HITTESTINFO        LPTCHITTESTINFO
#define TC_HITTESTINFO          TCHITTESTINFO
#else
#define tagTCHITTESTINFO        _TC_HITTESTINFO
#define    TCHITTESTINFO         TC_HITTESTINFO
#define  LPTCHITTESTINFO       LPTC_HITTESTINFO
#endif

typedef struct tagTCHITTESTINFO
{
    POINT pt;
    UINT flags;
} TCHITTESTINFO, *LPTCHITTESTINFO;

#define TCM_HITTEST             (TCM_FIRST + 13)
#define TabCtrl_HitTest(hwndTC, pinfo) \
    (int)SNDMSG((hwndTC), TCM_HITTEST, 0, (LPARAM)(TC_HITTESTINFO *)(pinfo))


#define TCM_SETITEMEXTRA        (TCM_FIRST + 14)
#define TabCtrl_SetItemExtra(hwndTC, cb) \
    (BOOL)SNDMSG((hwndTC), TCM_SETITEMEXTRA, (WPARAM)(cb), 0L)


#define TCM_ADJUSTRECT          (TCM_FIRST + 40)
#define TabCtrl_AdjustRect(hwnd, bLarger, prc) \
    (int)SNDMSG(hwnd, TCM_ADJUSTRECT, (WPARAM)(BOOL)(bLarger), (LPARAM)(RECT *)(prc))


#define TCM_SETITEMSIZE         (TCM_FIRST + 41)
#define TabCtrl_SetItemSize(hwnd, x, y) \
    (DWORD)SNDMSG((hwnd), TCM_SETITEMSIZE, 0, MAKELPARAM(x,y))


#define TCM_REMOVEIMAGE         (TCM_FIRST + 42)
#define TabCtrl_RemoveImage(hwnd, i) \
        (void)SNDMSG((hwnd), TCM_REMOVEIMAGE, i, 0L)


#define TCM_SETPADDING          (TCM_FIRST + 43)
#define TabCtrl_SetPadding(hwnd,  cx, cy) \
        (void)SNDMSG((hwnd), TCM_SETPADDING, 0, MAKELPARAM(cx, cy))


#define TCM_GETROWCOUNT         (TCM_FIRST + 44)
#define TabCtrl_GetRowCount(hwnd) \
        (int)SNDMSG((hwnd), TCM_GETROWCOUNT, 0, 0L)


#define TCM_GETTOOLTIPS         (TCM_FIRST + 45)
#define TabCtrl_GetToolTips(hwnd) \
        (HWND)SNDMSG((hwnd), TCM_GETTOOLTIPS, 0, 0L)


#define TCM_SETTOOLTIPS         (TCM_FIRST + 46)
#define TabCtrl_SetToolTips(hwnd, hwndTT) \
        (void)SNDMSG((hwnd), TCM_SETTOOLTIPS, (WPARAM)(hwndTT), 0L)


#define TCM_GETCURFOCUS         (TCM_FIRST + 47)
#define TabCtrl_GetCurFocus(hwnd) \
    (int)SNDMSG((hwnd), TCM_GETCURFOCUS, 0, 0)

#define TCM_SETCURFOCUS         (TCM_FIRST + 48)
#define TabCtrl_SetCurFocus(hwnd, i) \
    SNDMSG((hwnd),TCM_SETCURFOCUS, i, 0)

#if (_WIN32_IE >= 0x0300)
#define TCM_SETMINTABWIDTH      (TCM_FIRST + 49)
#define TabCtrl_SetMinTabWidth(hwnd, x) \
        (int)SNDMSG((hwnd), TCM_SETMINTABWIDTH, 0, x)


#define TCM_DESELECTALL         (TCM_FIRST + 50)
#define TabCtrl_DeselectAll(hwnd, fExcludeFocus)\
        (void)SNDMSG((hwnd), TCM_DESELECTALL, fExcludeFocus, 0)
#endif

#if (_WIN32_IE >= 0x0400)

#define TCM_HIGHLIGHTITEM       (TCM_FIRST + 51)
#define TabCtrl_HighlightItem(hwnd, i, fHighlight) \
    (BOOL)SNDMSG((hwnd), TCM_HIGHLIGHTITEM, (WPARAM)(i), (LPARAM)MAKELONG (fHighlight, 0))

#define TCM_SETEXTENDEDSTYLE    (TCM_FIRST + 52)  // optional wParam == mask
#define TabCtrl_SetExtendedStyle(hwnd, dw)\
        (DWORD)SNDMSG((hwnd), TCM_SETEXTENDEDSTYLE, 0, dw)

#define TCM_GETEXTENDEDSTYLE    (TCM_FIRST + 53)
#define TabCtrl_GetExtendedStyle(hwnd)\
        (DWORD)SNDMSG((hwnd), TCM_GETEXTENDEDSTYLE, 0, 0)

#define TCM_SETUNICODEFORMAT     CCM_SETUNICODEFORMAT
#define TabCtrl_SetUnicodeFormat(hwnd, fUnicode)  \
    (BOOL)SNDMSG((hwnd), TCM_SETUNICODEFORMAT, (WPARAM)(fUnicode), 0)

#define TCM_GETUNICODEFORMAT     CCM_GETUNICODEFORMAT
#define TabCtrl_GetUnicodeFormat(hwnd)  \
    (BOOL)SNDMSG((hwnd), TCM_GETUNICODEFORMAT, 0, 0)

#endif      // _WIN32_IE >= 0x0400

#define TCN_KEYDOWN             (TCN_FIRST - 0)

#if (_WIN32_IE >= 0x0300)
#define TC_KEYDOWN              NMTCKEYDOWN
#else
#define tagTCKEYDOWN            _TC_KEYDOWN
#define  NMTCKEYDOWN             TC_KEYDOWN
#endif

#ifdef _WIN32
#include <pshpack1.h>
#endif

typedef struct tagTCKEYDOWN
{
    NMHDR hdr;
    WORD wVKey;
    UINT flags;
} NMTCKEYDOWN;

#ifdef _WIN32
#include <poppack.h>
#endif

#define TCN_SELCHANGE           (TCN_FIRST - 1)
#define TCN_SELCHANGING         (TCN_FIRST - 2)
#if (_WIN32_IE >= 0x0400)
#define TCN_GETOBJECT           (TCN_FIRST - 3)
#endif      // _WIN32_IE >= 0x0400
#if (_WIN32_IE >= 0x0500)
#define TCN_FOCUSCHANGE         (TCN_FIRST - 4)
#endif      // _WIN32_IE >= 0x0500
#endif      // NOTABCONTROL


//====== ANIMATE CONTROL ======================================================

#ifndef NOANIMATE

#ifdef _WIN32

#define ANIMATE_CLASSW          L"SysAnimate32"
#define ANIMATE_CLASSA          "SysAnimate32"


#ifdef UNICODE
#define ANIMATE_CLASS           ANIMATE_CLASSW
#else
#define ANIMATE_CLASS           ANIMATE_CLASSA
#endif

// begin_r_commctrl

#define ACS_CENTER              0x0001
#define ACS_TRANSPARENT         0x0002
#define ACS_AUTOPLAY            0x0004
#if (_WIN32_IE >= 0x0300)
#define ACS_TIMER               0x0008  // don't use threads... use timers
#endif

// end_r_commctrl

#define ACM_OPENA               (WM_USER+100)
#define ACM_OPENW               (WM_USER+103)

#ifdef UNICODE
#define ACM_OPEN                ACM_OPENW
#else
#define ACM_OPEN                ACM_OPENA
#endif

#define ACM_PLAY                (WM_USER+101)
#define ACM_STOP                (WM_USER+102)
#define ACM_ISPLAYING           (WM_USER+104)

#define ACN_START               1
#define ACN_STOP                2


#define Animate_Create(hwndP, id, dwStyle, hInstance)   \
            CreateWindow(ANIMATE_CLASS, NULL,           \
                dwStyle, 0, 0, 0, 0, hwndP, (HMENU)(id), hInstance, NULL)

#define Animate_Open(hwnd, szName)          (BOOL)SNDMSG(hwnd, ACM_OPEN, 0, (LPARAM)(LPTSTR)(szName))
#define Animate_OpenEx(hwnd, hInst, szName) (BOOL)SNDMSG(hwnd, ACM_OPEN, (WPARAM)(hInst), (LPARAM)(LPTSTR)(szName))
#define Animate_Play(hwnd, from, to, rep)   (BOOL)SNDMSG(hwnd, ACM_PLAY, (WPARAM)(rep), (LPARAM)MAKELONG(from, to))
#define Animate_Stop(hwnd)                  (BOOL)SNDMSG(hwnd, ACM_STOP, 0, 0)
#define Animate_IsPlaying(hwnd)             (BOOL)SNDMSG(hwnd, ACM_ISPLAYING, 0, 0)
#define Animate_Close(hwnd)                 Animate_Open(hwnd, NULL)
#define Animate_Seek(hwnd, frame)           Animate_Play(hwnd, frame, frame, 1)
#endif

#endif      // NOANIMATE

#if (_WIN32_IE >= 0x0300)
//====== MONTHCAL CONTROL ======================================================

#ifndef NOMONTHCAL
#ifdef _WIN32

#define MONTHCAL_CLASSW          L"SysMonthCal32"
#define MONTHCAL_CLASSA          "SysMonthCal32"

#ifdef UNICODE
#define MONTHCAL_CLASS           MONTHCAL_CLASSW
#else
#define MONTHCAL_CLASS           MONTHCAL_CLASSA
#endif

// bit-packed array of "bold" info for a month
// if a bit is on, that day is drawn bold
typedef DWORD MONTHDAYSTATE, *LPMONTHDAYSTATE;


#define MCM_FIRST           0x1000

// BOOL MonthCal_GetCurSel(HWND hmc, LPSYSTEMTIME pst)
//   returns FALSE if MCS_MULTISELECT
//   returns TRUE and sets *pst to the currently selected date otherwise
#define MCM_GETCURSEL       (MCM_FIRST + 1)
#define MonthCal_GetCurSel(hmc, pst)    (BOOL)SNDMSG(hmc, MCM_GETCURSEL, 0, (LPARAM)(pst))

// BOOL MonthCal_SetCurSel(HWND hmc, LPSYSTEMTIME pst)
//   returns FALSE if MCS_MULTISELECT
//   returns TURE and sets the currently selected date to *pst otherwise
#define MCM_SETCURSEL       (MCM_FIRST + 2)
#define MonthCal_SetCurSel(hmc, pst)    (BOOL)SNDMSG(hmc, MCM_SETCURSEL, 0, (LPARAM)(pst))

// DWORD MonthCal_GetMaxSelCount(HWND hmc)
//   returns the maximum number of selectable days allowed
#define MCM_GETMAXSELCOUNT  (MCM_FIRST + 3)
#define MonthCal_GetMaxSelCount(hmc)    (DWORD)SNDMSG(hmc, MCM_GETMAXSELCOUNT, 0, 0L)

// BOOL MonthCal_SetMaxSelCount(HWND hmc, UINT n)
//   sets the max number days that can be selected iff MCS_MULTISELECT
#define MCM_SETMAXSELCOUNT  (MCM_FIRST + 4)
#define MonthCal_SetMaxSelCount(hmc, n) (BOOL)SNDMSG(hmc, MCM_SETMAXSELCOUNT, (WPARAM)(n), 0L)

// BOOL MonthCal_GetSelRange(HWND hmc, LPSYSTEMTIME rgst)
//   sets rgst[0] to the first day of the selection range
//   sets rgst[1] to the last day of the selection range
#define MCM_GETSELRANGE     (MCM_FIRST + 5)
#define MonthCal_GetSelRange(hmc, rgst) SNDMSG(hmc, MCM_GETSELRANGE, 0, (LPARAM)(rgst))

// BOOL MonthCal_SetSelRange(HWND hmc, LPSYSTEMTIME rgst)
//   selects the range of days from rgst[0] to rgst[1]
#define MCM_SETSELRANGE     (MCM_FIRST + 6)
#define MonthCal_SetSelRange(hmc, rgst) SNDMSG(hmc, MCM_SETSELRANGE, 0, (LPARAM)(rgst))

// DWORD MonthCal_GetMonthRange(HWND hmc, DWORD gmr, LPSYSTEMTIME rgst)
//   if rgst specified, sets rgst[0] to the starting date and
//      and rgst[1] to the ending date of the the selectable (non-grayed)
//      days if GMR_VISIBLE or all the displayed days (including grayed)
//      if GMR_DAYSTATE.
//   returns the number of months spanned by the above range.
#define MCM_GETMONTHRANGE   (MCM_FIRST + 7)
#define MonthCal_GetMonthRange(hmc, gmr, rgst)  (DWORD)SNDMSG(hmc, MCM_GETMONTHRANGE, (WPARAM)(gmr), (LPARAM)(rgst))

// BOOL MonthCal_SetDayState(HWND hmc, int cbds, DAYSTATE *rgds)
//   cbds is the count of DAYSTATE items in rgds and it must be equal
//   to the value returned from MonthCal_GetMonthRange(hmc, GMR_DAYSTATE, NULL)
//   This sets the DAYSTATE bits for each month (grayed and non-grayed
//   days) displayed in the calendar. The first bit in a month's DAYSTATE
//   corresponts to bolding day 1, the second bit affects day 2, etc.
#define MCM_SETDAYSTATE     (MCM_FIRST + 8)
#define MonthCal_SetDayState(hmc, cbds, rgds)   SNDMSG(hmc, MCM_SETDAYSTATE, (WPARAM)(cbds), (LPARAM)(rgds))

// BOOL MonthCal_GetMinReqRect(HWND hmc, LPRECT prc)
//   sets *prc the minimal size needed to display one month
//   To display two months, undo the AdjustWindowRect calculation already done to
//   this rect, double the width, and redo the AdjustWindowRect calculation --
//   the monthcal control will display two calendars in this window (if you also
//   double the vertical size, you will get 4 calendars)
//   NOTE: if you want to gurantee that the "Today" string is not clipped,
//   get the MCM_GETMAXTODAYWIDTH and use the max of that width and this width
#define MCM_GETMINREQRECT   (MCM_FIRST + 9)
#define MonthCal_GetMinReqRect(hmc, prc)        SNDMSG(hmc, MCM_GETMINREQRECT, 0, (LPARAM)(prc))

// set colors to draw control with -- see MCSC_ bits below
#define MCM_SETCOLOR            (MCM_FIRST + 10)
#define MonthCal_SetColor(hmc, iColor, clr) SNDMSG(hmc, MCM_SETCOLOR, iColor, clr)

#define MCM_GETCOLOR            (MCM_FIRST + 11)
#define MonthCal_GetColor(hmc, iColor) SNDMSG(hmc, MCM_GETCOLOR, iColor, 0)

#define MCSC_BACKGROUND   0   // the background color (between months)
#define MCSC_TEXT         1   // the dates
#define MCSC_TITLEBK      2   // background of the title
#define MCSC_TITLETEXT    3
#define MCSC_MONTHBK      4   // background within the month cal
#define MCSC_TRAILINGTEXT 5   // the text color of header & trailing days

// set what day is "today"   send NULL to revert back to real date
#define MCM_SETTODAY    (MCM_FIRST + 12)
#define MonthCal_SetToday(hmc, pst)             SNDMSG(hmc, MCM_SETTODAY, 0, (LPARAM)(pst))

// get what day is "today"
// returns BOOL for success/failure
#define MCM_GETTODAY    (MCM_FIRST + 13)
#define MonthCal_GetToday(hmc, pst)             (BOOL)SNDMSG(hmc, MCM_GETTODAY, 0, (LPARAM)(pst))

// determine what pinfo->pt is over
#define MCM_HITTEST          (MCM_FIRST + 14)
#define MonthCal_HitTest(hmc, pinfo) \
        SNDMSG(hmc, MCM_HITTEST, 0, (LPARAM)(PMCHITTESTINFO)(pinfo))


typedef struct {
        UINT cbSize;
        POINT pt;

        UINT uHit;   // out param
        SYSTEMTIME st;
#if (NTDDI_VERSION >= NTDDI_LONGHORN)
        RECT rc;
        int iOffset;
        int iRow;
        int iCol;
#endif
} MCHITTESTINFO, *PMCHITTESTINFO;

#define MCHITTESTINFO_V1_SIZE CCSIZEOF_STRUCT(MCHITTESTINFO, st)

#define MCHT_TITLE                      0x00010000
#define MCHT_CALENDAR                   0x00020000
#define MCHT_TODAYLINK                  0x00030000

#if (NTDDI_VERSION >= NTDDI_LONGHORN)
#define MCHT_CALENDARCONTROL            0x00100000
#endif

#define MCHT_NEXT                       0x01000000   // these indicate that hitting
#define MCHT_PREV                       0x02000000  // here will go to the next/prev month

#define MCHT_NOWHERE                    0x00000000

#define MCHT_TITLEBK                    (MCHT_TITLE)
#define MCHT_TITLEMONTH                 (MCHT_TITLE | 0x0001)
#define MCHT_TITLEYEAR                  (MCHT_TITLE | 0x0002)
#define MCHT_TITLEBTNNEXT               (MCHT_TITLE | MCHT_NEXT | 0x0003)
#define MCHT_TITLEBTNPREV               (MCHT_TITLE | MCHT_PREV | 0x0003)

#define MCHT_CALENDARBK                 (MCHT_CALENDAR)
#define MCHT_CALENDARDATE               (MCHT_CALENDAR | 0x0001)
#define MCHT_CALENDARDATENEXT           (MCHT_CALENDARDATE | MCHT_NEXT)
#define MCHT_CALENDARDATEPREV           (MCHT_CALENDARDATE | MCHT_PREV)
#define MCHT_CALENDARDAY                (MCHT_CALENDAR | 0x0002)
#define MCHT_CALENDARWEEKNUM            (MCHT_CALENDAR | 0x0003)
#define MCHT_CALENDARDATEMIN            (MCHT_CALENDAR | 0x0004)
#define MCHT_CALENDARDATEMAX            (MCHT_CALENDAR | 0x0005)

// set first day of week to iDay:
// 0 for Monday, 1 for Tuesday, ..., 6 for Sunday
// -1 for means use locale info
#define MCM_SETFIRSTDAYOFWEEK (MCM_FIRST + 15)
#define MonthCal_SetFirstDayOfWeek(hmc, iDay) \
        SNDMSG(hmc, MCM_SETFIRSTDAYOFWEEK, 0, iDay)

// DWORD result...  low word has the day.  high word is bool if this is app set
// or not (FALSE == using locale info)
#define MCM_GETFIRSTDAYOFWEEK (MCM_FIRST + 16)
#define MonthCal_GetFirstDayOfWeek(hmc) \
        (DWORD)SNDMSG(hmc, MCM_GETFIRSTDAYOFWEEK, 0, 0)

// DWORD MonthCal_GetRange(HWND hmc, LPSYSTEMTIME rgst)
//   modifies rgst[0] to be the minimum ALLOWABLE systemtime (or 0 if no minimum)
//   modifies rgst[1] to be the maximum ALLOWABLE systemtime (or 0 if no maximum)
//   returns GDTR_MIN|GDTR_MAX if there is a minimum|maximum limit
#define MCM_GETRANGE (MCM_FIRST + 17)
#define MonthCal_GetRange(hmc, rgst) \
        (DWORD)SNDMSG(hmc, MCM_GETRANGE, 0, (LPARAM)(rgst))

// BOOL MonthCal_SetRange(HWND hmc, DWORD gdtr, LPSYSTEMTIME rgst)
//   if GDTR_MIN, sets the minimum ALLOWABLE systemtime to rgst[0], otherwise removes minimum
//   if GDTR_MAX, sets the maximum ALLOWABLE systemtime to rgst[1], otherwise removes maximum
//   returns TRUE on success, FALSE on error (such as invalid parameters)
#define MCM_SETRANGE (MCM_FIRST + 18)
#define MonthCal_SetRange(hmc, gd, rgst) \
        (BOOL)SNDMSG(hmc, MCM_SETRANGE, (WPARAM)(gd), (LPARAM)(rgst))

// int MonthCal_GetMonthDelta(HWND hmc)
//   returns the number of months one click on a next/prev button moves by
#define MCM_GETMONTHDELTA (MCM_FIRST + 19)
#define MonthCal_GetMonthDelta(hmc) \
        (int)SNDMSG(hmc, MCM_GETMONTHDELTA, 0, 0)

// int MonthCal_SetMonthDelta(HWND hmc, int n)
//   sets the month delta to n. n==0 reverts to moving by a page of months
//   returns the previous value of n.
#define MCM_SETMONTHDELTA (MCM_FIRST + 20)
#define MonthCal_SetMonthDelta(hmc, n) \
        (int)SNDMSG(hmc, MCM_SETMONTHDELTA, n, 0)

// DWORD MonthCal_GetMaxTodayWidth(HWND hmc, LPSIZE psz)
//   sets *psz to the maximum width/height of the "Today" string displayed
//   at the bottom of the calendar (as long as MCS_NOTODAY is not specified)
#define MCM_GETMAXTODAYWIDTH (MCM_FIRST + 21)
#define MonthCal_GetMaxTodayWidth(hmc) \
        (DWORD)SNDMSG(hmc, MCM_GETMAXTODAYWIDTH, 0, 0)

#if (_WIN32_IE >= 0x0400)
#define MCM_SETUNICODEFORMAT     CCM_SETUNICODEFORMAT
#define MonthCal_SetUnicodeFormat(hwnd, fUnicode)  \
    (BOOL)SNDMSG((hwnd), MCM_SETUNICODEFORMAT, (WPARAM)(fUnicode), 0)

#define MCM_GETUNICODEFORMAT     CCM_GETUNICODEFORMAT
#define MonthCal_GetUnicodeFormat(hwnd)  \
    (BOOL)SNDMSG((hwnd), MCM_GETUNICODEFORMAT, 0, 0)
#endif

#if (NTDDI_VERSION >= NTDDI_LONGHORN)
// View
#define MCMV_MONTH      0
#define MCMV_YEAR       1
#define MCMV_DECADE     2
#define MCMV_CENTURY    3
#define MCMV_MAX        MCMV_CENTURY

#define MCM_GETCURRENTVIEW (MCM_FIRST + 22)
#define MonthCal_GetCurrentView(hmc) \
        (DWORD)SNDMSG(hmc, MCM_GETCURRENTVIEW, 0, 0)

#define MCM_GETCALENDARCOUNT (MCM_FIRST + 23)
#define MonthCal_GetCalendarCount(hmc) \
        (DWORD)SNDMSG(hmc, MCM_GETCALENDARCOUNT, 0, 0)

// Part
#define MCGIP_CALENDARCONTROL      0
#define MCGIP_NEXT                 1
#define MCGIP_PREV                 2
#define MCGIP_FOOTER               3
#define MCGIP_CALENDAR             4
#define MCGIP_CALENDARHEADER       5
#define MCGIP_CALENDARBODY         6
#define MCGIP_CALENDARROW          7
#define MCGIP_CALENDARCELL         8

#define MCGIF_DATE                 0x00000001
#define MCGIF_RECT                 0x00000002
#define MCGIF_NAME                 0x00000004

// Note: iRow of -1 refers to the row header and iCol of -1 refers to the col header.
typedef struct tagMCGRIDINFO {
    UINT cbSize;
    DWORD dwPart;
    DWORD dwFlags;
    int iCalendar;
    int iRow;
    int iCol;
    BOOL bSelected;
    SYSTEMTIME stStart;
    SYSTEMTIME stEnd;
    RECT rc;
    PWSTR pszName;
    size_t cchName;
} MCGRIDINFO, *PMCGRIDINFO;

#define MCM_GETCALENDARGRIDINFO (MCM_FIRST + 24)
#define MonthCal_GetCalendarGridInfo(hmc, pmcGridInfo) \
        (BOOL)SNDMSG(hmc, MCM_GETCALENDARGRIDINFO, 0, (LPARAM)(PMCGRIDINFO)(pmcGridInfo))

#define MCM_GETCALID (MCM_FIRST + 27)
#define MonthCal_GetCALID(hmc) \
        (CALID)SNDMSG(hmc, MCM_GETCALID, 0, 0)

#define MCM_SETCALID (MCM_FIRST + 28)
#define MonthCal_SetCALID(hmc, calid) \
        SNDMSG(hmc, MCM_SETCALID, (WPARAM)(calid), 0)

// Returns the min rect that will fit the max number of calendars for the passed in rect.
#define MCM_SIZERECTTOMIN (MCM_FIRST + 29)
#define MonthCal_SizeRectToMin(hmc, prc) \
        SNDMSG(hmc, MCM_SIZERECTTOMIN, 0, (LPARAM)(prc))

#define MCM_SETCALENDARBORDER (MCM_FIRST + 30)
#define MonthCal_SetCalendarBorder(hmc, fset, xyborder) \
        SNDMSG(hmc, MCM_SETCALENDARBORDER, (WPARAM)(fset), (LPARAM)(xyborder))

#define MCM_GETCALENDARBORDER (MCM_FIRST + 31)
#define MonthCal_GetCalendarBorder(hmc) \
        (int)SNDMSG(hmc, MCM_GETCALENDARBORDER, 0, 0)

#define MCM_SETCURRENTVIEW (MCM_FIRST + 32)
#define MonthCal_SetCurrentView(hmc, dwNewView) \
        (BOOL)SNDMSG(hmc, MCM_SETCURRENTVIEW, 0, (LPARAM)(dwNewView))

#endif

// MCN_SELCHANGE is sent whenever the currently displayed date changes
// via month change, year change, keyboard navigation, prev/next button
//
typedef struct tagNMSELCHANGE
{
    NMHDR           nmhdr;  // this must be first, so we don't break WM_NOTIFY

    SYSTEMTIME      stSelStart;
    SYSTEMTIME      stSelEnd;
} NMSELCHANGE, *LPNMSELCHANGE;

#define MCN_SELCHANGE       (MCN_FIRST - 3) // -749

// MCN_GETDAYSTATE is sent for MCS_DAYSTATE controls whenever new daystate
// information is needed (month or year scroll) to draw bolding information.
// The app must fill in cDayState months worth of information starting from
// stStart date. The app may fill in the array at prgDayState or change
// prgDayState to point to a different array out of which the information
// will be copied. (similar to tooltips)
//
typedef struct tagNMDAYSTATE
{
    NMHDR           nmhdr;  // this must be first, so we don't break WM_NOTIFY

    SYSTEMTIME      stStart;
    int             cDayState;

    LPMONTHDAYSTATE prgDayState; // points to cDayState MONTHDAYSTATEs
} NMDAYSTATE, *LPNMDAYSTATE;

#define MCN_GETDAYSTATE     (MCN_FIRST - 1) // -747

// MCN_SELECT is sent whenever a selection has occured (via mouse or keyboard)
//
typedef NMSELCHANGE NMSELECT, *LPNMSELECT;


#define MCN_SELECT          (MCN_FIRST) // -746

typedef struct tagNMVIEWCHANGE
{
    NMHDR           nmhdr;  // this must be first, so we don't break WM_NOTIFY
    DWORD           dwOldView;
    DWORD           dwNewView;
} NMVIEWCHANGE, *LPNMVIEWCHANGE;

#define MCN_VIEWCHANGE      (MCN_FIRST - 4) // -750


// begin_r_commctrl

#define MCS_DAYSTATE        0x0001
#define MCS_MULTISELECT     0x0002
#define MCS_WEEKNUMBERS     0x0004
#if (_WIN32_IE >= 0x0400)
#define MCS_NOTODAYCIRCLE   0x0008
#define MCS_NOTODAY         0x0010
#else
#define MCS_NOTODAY         0x0008
#endif
#if (NTDDI_VERSION >= NTDDI_LONGHORN)
#define MCS_NOTRAILINGDATES  0x0040
#define MCS_SHORTDAYSOFWEEK  0x0080
#define MCS_NOSELCHANGEONNAV 0x0100
#endif


// end_r_commctrl

#define GMR_VISIBLE     0       // visible portion of display
#define GMR_DAYSTATE    1       // above plus the grayed out parts of
                                // partially displayed months


#endif // _WIN32
#endif // NOMONTHCAL


//====== DATETIMEPICK CONTROL ==================================================

#ifndef NODATETIMEPICK
#ifdef _WIN32

#define DATETIMEPICK_CLASSW          L"SysDateTimePick32"
#define DATETIMEPICK_CLASSA          "SysDateTimePick32"

#ifdef UNICODE
#define DATETIMEPICK_CLASS           DATETIMEPICK_CLASSW
#else
#define DATETIMEPICK_CLASS           DATETIMEPICK_CLASSA
#endif

#if (NTDDI_VERSION >= NTDDI_LONGHORN)

typedef struct tagDATETIMEPICKERINFO
{
    DWORD cbSize;

    RECT rcCheck;
    DWORD stateCheck;

    RECT rcButton;
    DWORD stateButton;

    HWND hwndEdit;
    HWND hwndUD;
    HWND hwndDropDown;
} DATETIMEPICKERINFO, *LPDATETIMEPICKERINFO;

#endif // (NTDDI_VERSION >= NTDDI_LONGHORN)

#define DTM_FIRST        0x1000

// DWORD DateTimePick_GetSystemtime(HWND hdp, LPSYSTEMTIME pst)
//   returns GDT_NONE if "none" is selected (DTS_SHOWNONE only)
//   returns GDT_VALID and modifies *pst to be the currently selected value
#define DTM_GETSYSTEMTIME   (DTM_FIRST + 1)
#define DateTime_GetSystemtime(hdp, pst)    (DWORD)SNDMSG(hdp, DTM_GETSYSTEMTIME, 0, (LPARAM)(pst))

// BOOL DateTime_SetSystemtime(HWND hdp, DWORD gd, LPSYSTEMTIME pst)
//   if gd==GDT_NONE, sets datetimepick to None (DTS_SHOWNONE only)
//   if gd==GDT_VALID, sets datetimepick to *pst
//   returns TRUE on success, FALSE on error (such as bad params)
#define DTM_SETSYSTEMTIME   (DTM_FIRST + 2)
#define DateTime_SetSystemtime(hdp, gd, pst)    (BOOL)SNDMSG(hdp, DTM_SETSYSTEMTIME, (WPARAM)(gd), (LPARAM)(pst))

// DWORD DateTime_GetRange(HWND hdp, LPSYSTEMTIME rgst)
//   modifies rgst[0] to be the minimum ALLOWABLE systemtime (or 0 if no minimum)
//   modifies rgst[1] to be the maximum ALLOWABLE systemtime (or 0 if no maximum)
//   returns GDTR_MIN|GDTR_MAX if there is a minimum|maximum limit
#define DTM_GETRANGE (DTM_FIRST + 3)
#define DateTime_GetRange(hdp, rgst)  (DWORD)SNDMSG(hdp, DTM_GETRANGE, 0, (LPARAM)(rgst))

// BOOL DateTime_SetRange(HWND hdp, DWORD gdtr, LPSYSTEMTIME rgst)
//   if GDTR_MIN, sets the minimum ALLOWABLE systemtime to rgst[0], otherwise removes minimum
//   if GDTR_MAX, sets the maximum ALLOWABLE systemtime to rgst[1], otherwise removes maximum
//   returns TRUE on success, FALSE on error (such as invalid parameters)
#define DTM_SETRANGE (DTM_FIRST + 4)
#define DateTime_SetRange(hdp, gd, rgst)  (BOOL)SNDMSG(hdp, DTM_SETRANGE, (WPARAM)(gd), (LPARAM)(rgst))

// BOOL DateTime_SetFormat(HWND hdp, LPCTSTR sz)
//   sets the display formatting string to sz (see GetDateFormat and GetTimeFormat for valid formatting chars)
//   NOTE: 'X' is a valid formatting character which indicates that the application
//   will determine how to display information. Such apps must support DTN_WMKEYDOWN,
//   DTN_FORMAT, and DTN_FORMATQUERY.
#define DTM_SETFORMATA (DTM_FIRST + 5)
#define DTM_SETFORMATW (DTM_FIRST + 50)

#ifdef UNICODE
#define DTM_SETFORMAT       DTM_SETFORMATW
#else
#define DTM_SETFORMAT       DTM_SETFORMATA
#endif

#define DateTime_SetFormat(hdp, sz)  (BOOL)SNDMSG(hdp, DTM_SETFORMAT, 0, (LPARAM)(sz))


#define DTM_SETMCCOLOR    (DTM_FIRST + 6)
#define DateTime_SetMonthCalColor(hdp, iColor, clr) SNDMSG(hdp, DTM_SETMCCOLOR, iColor, clr)

#define DTM_GETMCCOLOR    (DTM_FIRST + 7)
#define DateTime_GetMonthCalColor(hdp, iColor) SNDMSG(hdp, DTM_GETMCCOLOR, iColor, 0)

// HWND DateTime_GetMonthCal(HWND hdp)
//   returns the HWND of the MonthCal popup window. Only valid
// between DTN_DROPDOWN and DTN_CLOSEUP notifications.
#define DTM_GETMONTHCAL   (DTM_FIRST + 8)
#define DateTime_GetMonthCal(hdp) (HWND)SNDMSG(hdp, DTM_GETMONTHCAL, 0, 0)

#if (_WIN32_IE >= 0x0400)

#define DTM_SETMCFONT     (DTM_FIRST + 9)
#define DateTime_SetMonthCalFont(hdp, hfont, fRedraw) SNDMSG(hdp, DTM_SETMCFONT, (WPARAM)(hfont), (LPARAM)(fRedraw))

#define DTM_GETMCFONT     (DTM_FIRST + 10)
#define DateTime_GetMonthCalFont(hdp) SNDMSG(hdp, DTM_GETMCFONT, 0, 0)

#endif      // _WIN32_IE >= 0x0400

#if (NTDDI_VERSION >= NTDDI_LONGHORN)

#define DTM_SETMCSTYLE    (DTM_FIRST + 11)
#define DateTime_SetMonthCalStyle(hdp, dwStyle) SNDMSG(hdp, DTM_SETMCSTYLE, 0, (LPARAM)dwStyle)

#define DTM_GETMCSTYLE    (DTM_FIRST + 12)
#define DateTime_GetMonthCalStyle(hdp) SNDMSG(hdp, DTM_GETMCSTYLE, 0, 0)

#define DTM_CLOSEMONTHCAL (DTM_FIRST + 13)
#define DateTime_CloseMonthCal(hdp) SNDMSG(hdp, DTM_CLOSEMONTHCAL, 0, 0)

// DateTime_GetDateTimePickerInfo(HWND hdp, DATETIMEPICKERINFO* pdtpi)
// Retrieves information about the selected date time picker.
#define DTM_GETDATETIMEPICKERINFO (DTM_FIRST + 14)
#define DateTime_GetDateTimePickerInfo(hdp, pdtpi) SNDMSG(hdp, DTM_GETDATETIMEPICKERINFO, 0, (LPARAM)(pdtpi))

#define DTM_GETIDEALSIZE (DTM_FIRST + 15)
#define DateTime_GetIdealSize(hdp, psize) (BOOL)SNDMSG((hdp), DTM_GETIDEALSIZE, 0, (LPARAM)(psize))

#endif // (NTDDI_VERSION >= NTDDI_LONGHORN)

// begin_r_commctrl

#define DTS_UPDOWN          0x0001 // use UPDOWN instead of MONTHCAL
#define DTS_SHOWNONE        0x0002 // allow a NONE selection
#define DTS_SHORTDATEFORMAT 0x0000 // use the short date format (app must forward WM_WININICHANGE messages)
#define DTS_LONGDATEFORMAT  0x0004 // use the long date format (app must forward WM_WININICHANGE messages)
#if (_WIN32_IE >= 0x500)
#define DTS_SHORTDATECENTURYFORMAT 0x000C// short date format with century (app must forward WM_WININICHANGE messages)
#endif // (_WIN32_IE >= 0x500)
#define DTS_TIMEFORMAT      0x0009 // use the time format (app must forward WM_WININICHANGE messages)
#define DTS_APPCANPARSE     0x0010 // allow user entered strings (app MUST respond to DTN_USERSTRING)
#define DTS_RIGHTALIGN      0x0020 // right-align popup instead of left-align it

// end_r_commctrl

#define DTN_DATETIMECHANGE  (DTN_FIRST2 - 6) // the systemtime has changed, -759
typedef struct tagNMDATETIMECHANGE
{
    NMHDR       nmhdr;
    DWORD       dwFlags;    // GDT_VALID or GDT_NONE
    SYSTEMTIME  st;         // valid iff dwFlags==GDT_VALID
} NMDATETIMECHANGE, *LPNMDATETIMECHANGE;

#define DTN_USERSTRINGA  (DTN_FIRST2 - 5) // the user has entered a string, -758
#define DTN_USERSTRINGW  (DTN_FIRST - 5) // -745
typedef struct tagNMDATETIMESTRINGA
{
    NMHDR      nmhdr;
    LPCSTR     pszUserString;  // string user entered
    SYSTEMTIME st;             // app fills this in
    DWORD      dwFlags;        // GDT_VALID or GDT_NONE
} NMDATETIMESTRINGA, *LPNMDATETIMESTRINGA;

typedef struct tagNMDATETIMESTRINGW
{
    NMHDR      nmhdr;
    LPCWSTR    pszUserString;  // string user entered
    SYSTEMTIME st;             // app fills this in
    DWORD      dwFlags;        // GDT_VALID or GDT_NONE
} NMDATETIMESTRINGW, *LPNMDATETIMESTRINGW;

#ifdef UNICODE
#define DTN_USERSTRING          DTN_USERSTRINGW
#define NMDATETIMESTRING        NMDATETIMESTRINGW
#define LPNMDATETIMESTRING      LPNMDATETIMESTRINGW
#else
#define DTN_USERSTRING          DTN_USERSTRINGA
#define NMDATETIMESTRING        NMDATETIMESTRINGA
#define LPNMDATETIMESTRING      LPNMDATETIMESTRINGA
#endif


#define DTN_WMKEYDOWNA  (DTN_FIRST2 - 4) // modify keydown on app format field (X), , -757
#define DTN_WMKEYDOWNW  (DTN_FIRST - 4) // -744
typedef struct tagNMDATETIMEWMKEYDOWNA
{
    NMHDR      nmhdr;
    int        nVirtKey;  // virtual key code of WM_KEYDOWN which MODIFIES an X field
    LPCSTR     pszFormat; // format substring
    SYSTEMTIME st;        // current systemtime, app should modify based on key
} NMDATETIMEWMKEYDOWNA, *LPNMDATETIMEWMKEYDOWNA;

typedef struct tagNMDATETIMEWMKEYDOWNW
{
    NMHDR      nmhdr;
    int        nVirtKey;  // virtual key code of WM_KEYDOWN which MODIFIES an X field
    LPCWSTR    pszFormat; // format substring
    SYSTEMTIME st;        // current systemtime, app should modify based on key
} NMDATETIMEWMKEYDOWNW, *LPNMDATETIMEWMKEYDOWNW;

#ifdef UNICODE
#define DTN_WMKEYDOWN           DTN_WMKEYDOWNW
#define NMDATETIMEWMKEYDOWN     NMDATETIMEWMKEYDOWNW
#define LPNMDATETIMEWMKEYDOWN   LPNMDATETIMEWMKEYDOWNW
#else
#define DTN_WMKEYDOWN           DTN_WMKEYDOWNA
#define NMDATETIMEWMKEYDOWN     NMDATETIMEWMKEYDOWNA
#define LPNMDATETIMEWMKEYDOWN   LPNMDATETIMEWMKEYDOWNA
#endif


#define DTN_FORMATA  (DTN_FIRST2 - 3) // query display for app format field (X), -756
#define DTN_FORMATW  (DTN_FIRST - 3) // -743
typedef struct tagNMDATETIMEFORMATA
{
    NMHDR nmhdr;
    LPCSTR  pszFormat;   // format substring
    SYSTEMTIME st;       // current systemtime
    LPCSTR pszDisplay;   // string to display
    CHAR szDisplay[64];  // buffer pszDisplay originally points at
} NMDATETIMEFORMATA, *LPNMDATETIMEFORMATA;

typedef struct tagNMDATETIMEFORMATW
{
    NMHDR nmhdr;
    LPCWSTR pszFormat;   // format substring
    SYSTEMTIME st;       // current systemtime
    LPCWSTR pszDisplay;  // string to display
    WCHAR szDisplay[64]; // buffer pszDisplay originally points at
} NMDATETIMEFORMATW, *LPNMDATETIMEFORMATW;

#ifdef UNICODE
#define DTN_FORMAT             DTN_FORMATW
#define NMDATETIMEFORMAT        NMDATETIMEFORMATW
#define LPNMDATETIMEFORMAT      LPNMDATETIMEFORMATW
#else
#define DTN_FORMAT             DTN_FORMATA
#define NMDATETIMEFORMAT        NMDATETIMEFORMATA
#define LPNMDATETIMEFORMAT      LPNMDATETIMEFORMATA
#endif


#define DTN_FORMATQUERYA  (DTN_FIRST2 - 2) // query formatting info for app format field (X), -755
#define DTN_FORMATQUERYW (DTN_FIRST - 2) // -742
typedef struct tagNMDATETIMEFORMATQUERYA
{
    NMHDR nmhdr;
    LPCSTR pszFormat;  // format substring
    SIZE szMax;        // max bounding rectangle app will use for this format string
} NMDATETIMEFORMATQUERYA, *LPNMDATETIMEFORMATQUERYA;

typedef struct tagNMDATETIMEFORMATQUERYW
{
    NMHDR nmhdr;
    LPCWSTR pszFormat; // format substring
    SIZE szMax;        // max bounding rectangle app will use for this format string
} NMDATETIMEFORMATQUERYW, *LPNMDATETIMEFORMATQUERYW;

#ifdef UNICODE
#define DTN_FORMATQUERY         DTN_FORMATQUERYW
#define NMDATETIMEFORMATQUERY   NMDATETIMEFORMATQUERYW
#define LPNMDATETIMEFORMATQUERY LPNMDATETIMEFORMATQUERYW
#else
#define DTN_FORMATQUERY         DTN_FORMATQUERYA
#define NMDATETIMEFORMATQUERY   NMDATETIMEFORMATQUERYA
#define LPNMDATETIMEFORMATQUERY LPNMDATETIMEFORMATQUERYA
#endif


#define DTN_DROPDOWN    (DTN_FIRST2 - 1) // MonthCal has dropped down, -754
#define DTN_CLOSEUP     (DTN_FIRST2) // MonthCal is popping up, -753


#define GDTR_MIN     0x0001
#define GDTR_MAX     0x0002

#define GDT_ERROR    -1
#define GDT_VALID    0
#define GDT_NONE     1


#endif // _WIN32
#endif // NODATETIMEPICK


#if (_WIN32_IE >= 0x0400)

#ifndef NOIPADDRESS

///////////////////////////////////////////////
//    IP Address edit control

// Messages sent to IPAddress controls

#define IPM_CLEARADDRESS (WM_USER+100) // no parameters
#define IPM_SETADDRESS   (WM_USER+101) // lparam = TCP/IP address
#define IPM_GETADDRESS   (WM_USER+102) // lresult = # of non black fields.  lparam = LPDWORD for TCP/IP address
#define IPM_SETRANGE (WM_USER+103) // wparam = field, lparam = range
#define IPM_SETFOCUS (WM_USER+104) // wparam = field
#define IPM_ISBLANK  (WM_USER+105) // no parameters

#define WC_IPADDRESSW           L"SysIPAddress32"
#define WC_IPADDRESSA           "SysIPAddress32"

#ifdef UNICODE
#define WC_IPADDRESS          WC_IPADDRESSW
#else
#define WC_IPADDRESS          WC_IPADDRESSA
#endif

#define IPN_FIELDCHANGED                (IPN_FIRST - 0)
typedef struct tagNMIPADDRESS
{
        NMHDR hdr;
        int iField;
        int iValue;
} NMIPADDRESS, *LPNMIPADDRESS;

// The following is a useful macro for passing the range values in the
// IPM_SETRANGE message.

#define MAKEIPRANGE(low, high)    ((LPARAM)(WORD)(((BYTE)(high) << 8) + (BYTE)(low)))

// And this is a useful macro for making the IP Address to be passed
// as a LPARAM.

#define MAKEIPADDRESS(b1,b2,b3,b4)  ((LPARAM)(((DWORD)(b1)<<24)+((DWORD)(b2)<<16)+((DWORD)(b3)<<8)+((DWORD)(b4))))

// Get individual number
#define FIRST_IPADDRESS(x)  (((x) >> 24) & 0xff)
#define SECOND_IPADDRESS(x) (((x) >> 16) & 0xff)
#define THIRD_IPADDRESS(x)  (((x) >> 8) & 0xff)
#define FOURTH_IPADDRESS(x) ((x) & 0xff)


#endif // NOIPADDRESS


//---------------------------------------------------------------------------------------
//---------------------------------------------------------------------------------------
//  ====================== Pager Control =============================
//---------------------------------------------------------------------------------------
//---------------------------------------------------------------------------------------

#ifndef NOPAGESCROLLER

//Pager Class Name
#define WC_PAGESCROLLERW           L"SysPager"
#define WC_PAGESCROLLERA           "SysPager"

#ifdef UNICODE
#define WC_PAGESCROLLER          WC_PAGESCROLLERW
#else
#define WC_PAGESCROLLER          WC_PAGESCROLLERA
#endif


//---------------------------------------------------------------------------------------
// Pager Control Styles
//---------------------------------------------------------------------------------------
// begin_r_commctrl

#define PGS_VERT                0x00000000
#define PGS_HORZ                0x00000001
#define PGS_AUTOSCROLL          0x00000002
#define PGS_DRAGNDROP           0x00000004

// end_r_commctrl


//---------------------------------------------------------------------------------------
// Pager Button State
//---------------------------------------------------------------------------------------
//The scroll can be in one of the following control State
#define  PGF_INVISIBLE   0      // Scroll button is not visible
#define  PGF_NORMAL      1      // Scroll button is in normal state
#define  PGF_GRAYED      2      // Scroll button is in grayed state
#define  PGF_DEPRESSED   4      // Scroll button is in depressed state
#define  PGF_HOT         8      // Scroll button is in hot state


// The following identifiers specifies the button control
#define PGB_TOPORLEFT       0
#define PGB_BOTTOMORRIGHT   1

//---------------------------------------------------------------------------------------
// Pager Control  Messages
//---------------------------------------------------------------------------------------
#define PGM_SETCHILD            (PGM_FIRST + 1)  // lParam == hwnd
#define Pager_SetChild(hwnd, hwndChild) \
        (void)SNDMSG((hwnd), PGM_SETCHILD, 0, (LPARAM)(hwndChild))

#define PGM_RECALCSIZE          (PGM_FIRST + 2)
#define Pager_RecalcSize(hwnd) \
        (void)SNDMSG((hwnd), PGM_RECALCSIZE, 0, 0)

#define PGM_FORWARDMOUSE        (PGM_FIRST + 3)
#define Pager_ForwardMouse(hwnd, bForward) \
        (void)SNDMSG((hwnd), PGM_FORWARDMOUSE, (WPARAM)(bForward), 0)

#define PGM_SETBKCOLOR          (PGM_FIRST + 4)
#define Pager_SetBkColor(hwnd, clr) \
        (COLORREF)SNDMSG((hwnd), PGM_SETBKCOLOR, 0, (LPARAM)(clr))

#define PGM_GETBKCOLOR          (PGM_FIRST + 5)
#define Pager_GetBkColor(hwnd) \
        (COLORREF)SNDMSG((hwnd), PGM_GETBKCOLOR, 0, 0)

#define PGM_SETBORDER          (PGM_FIRST + 6)
#define Pager_SetBorder(hwnd, iBorder) \
        (int)SNDMSG((hwnd), PGM_SETBORDER, 0, (LPARAM)(iBorder))

#define PGM_GETBORDER          (PGM_FIRST + 7)
#define Pager_GetBorder(hwnd) \
        (int)SNDMSG((hwnd), PGM_GETBORDER, 0, 0)

#define PGM_SETPOS              (PGM_FIRST + 8)
#define Pager_SetPos(hwnd, iPos) \
        (int)SNDMSG((hwnd), PGM_SETPOS, 0, (LPARAM)(iPos))

#define PGM_GETPOS              (PGM_FIRST + 9)
#define Pager_GetPos(hwnd) \
        (int)SNDMSG((hwnd), PGM_GETPOS, 0, 0)

#define PGM_SETBUTTONSIZE       (PGM_FIRST + 10)
#define Pager_SetButtonSize(hwnd, iSize) \
        (int)SNDMSG((hwnd), PGM_SETBUTTONSIZE, 0, (LPARAM)(iSize))

#define PGM_GETBUTTONSIZE       (PGM_FIRST + 11)
#define Pager_GetButtonSize(hwnd) \
        (int)SNDMSG((hwnd), PGM_GETBUTTONSIZE, 0,0)

#define PGM_GETBUTTONSTATE      (PGM_FIRST + 12)
#define Pager_GetButtonState(hwnd, iButton) \
        (DWORD)SNDMSG((hwnd), PGM_GETBUTTONSTATE, 0, (LPARAM)(iButton))

#define PGM_GETDROPTARGET       CCM_GETDROPTARGET
#define Pager_GetDropTarget(hwnd, ppdt) \
        (void)SNDMSG((hwnd), PGM_GETDROPTARGET, 0, (LPARAM)(ppdt))
//---------------------------------------------------------------------------------------
//Pager Control Notification Messages
//---------------------------------------------------------------------------------------


// PGN_SCROLL Notification Message

#define PGN_SCROLL          (PGN_FIRST-1)

#define PGF_SCROLLUP        1
#define PGF_SCROLLDOWN      2
#define PGF_SCROLLLEFT      4
#define PGF_SCROLLRIGHT     8


//Keys down
#define PGK_SHIFT           1
#define PGK_CONTROL         2
#define PGK_MENU            4


#ifdef _WIN32
#include <pshpack1.h>
#endif

// This structure is sent along with PGN_SCROLL notifications
typedef struct {
    NMHDR hdr;
    WORD fwKeys;            // Specifies which keys are down when this notification is send
    RECT rcParent;          // Contains Parent Window Rect
    int  iDir;              // Scrolling Direction
    int  iXpos;             // Horizontal scroll position
    int  iYpos;             // Vertical scroll position
    int  iScroll;           // [in/out] Amount to scroll
}NMPGSCROLL, *LPNMPGSCROLL;

#ifdef _WIN32
#include <poppack.h>
#endif

// PGN_CALCSIZE Notification Message

#define PGN_CALCSIZE        (PGN_FIRST-2)

#define PGF_CALCWIDTH       1
#define PGF_CALCHEIGHT      2

typedef struct {
    NMHDR   hdr;
    DWORD   dwFlag;
    int     iWidth;
    int     iHeight;
}NMPGCALCSIZE, *LPNMPGCALCSIZE;


// PGN_HOTITEMCHANGE Notification Message

#define PGN_HOTITEMCHANGE   (PGN_FIRST-3)

/*
The PGN_HOTITEMCHANGE notification uses these notification
flags defined in TOOLBAR:

#define HICF_ENTERING       0x00000010          // idOld is invalid
#define HICF_LEAVING        0x00000020          // idNew is invalid
*/

// Structure for PGN_HOTITEMCHANGE notification
//
typedef struct tagNMPGHOTITEM
{
    NMHDR   hdr;
    int     idOld;
    int     idNew;
    DWORD   dwFlags;           // HICF_*
} NMPGHOTITEM, * LPNMPGHOTITEM;

#endif // NOPAGESCROLLER

////======================  End Pager Control ==========================================

//
// === Native Font Control ===
//
#ifndef NONATIVEFONTCTL
//NativeFont Class Name
#define WC_NATIVEFONTCTLW           L"NativeFontCtl"
#define WC_NATIVEFONTCTLA           "NativeFontCtl"

#ifdef UNICODE
#define WC_NATIVEFONTCTL          WC_NATIVEFONTCTLW
#else
#define WC_NATIVEFONTCTL          WC_NATIVEFONTCTLA
#endif

// begin_r_commctrl

// style definition
#define NFS_EDIT                0x0001
#define NFS_STATIC              0x0002
#define NFS_LISTCOMBO           0x0004
#define NFS_BUTTON              0x0008
#define NFS_ALL                 0x0010
#define NFS_USEFONTASSOC        0x0020

// end_r_commctrl

#endif // NONATIVEFONTCTL
// === End Native Font Control ===

// ====================== Button Control =============================

#ifndef NOBUTTON

#ifdef _WIN32

// Button Class Name
#define WC_BUTTONA              "Button"
#define WC_BUTTONW              L"Button"

#ifdef UNICODE
#define WC_BUTTON               WC_BUTTONW
#else
#define WC_BUTTON               WC_BUTTONA
#endif

#else
#define WC_BUTTON               "Button"
#endif

#if (_WIN32_WINNT >= 0x0501)
#define BUTTON_IMAGELIST_ALIGN_LEFT     0
#define BUTTON_IMAGELIST_ALIGN_RIGHT    1
#define BUTTON_IMAGELIST_ALIGN_TOP      2
#define BUTTON_IMAGELIST_ALIGN_BOTTOM   3
#define BUTTON_IMAGELIST_ALIGN_CENTER   4       // Doesn't draw text

typedef struct
{
    HIMAGELIST  himl;   // Images: Normal, Hot, Pushed, Disabled. If count is less than 4, we use index 1
    RECT        margin; // Margin around icon.
    UINT        uAlign;
} BUTTON_IMAGELIST, *PBUTTON_IMAGELIST;

#define BCM_GETIDEALSIZE        (BCM_FIRST + 0x0001)
#define Button_GetIdealSize(hwnd, psize)\
    (BOOL)SNDMSG((hwnd), BCM_GETIDEALSIZE, 0, (LPARAM)(psize))

#define BCM_SETIMAGELIST        (BCM_FIRST + 0x0002)
#define Button_SetImageList(hwnd, pbuttonImagelist)\
    (BOOL)SNDMSG((hwnd), BCM_SETIMAGELIST, 0, (LPARAM)(pbuttonImagelist))

#define BCM_GETIMAGELIST        (BCM_FIRST + 0x0003)
#define Button_GetImageList(hwnd, pbuttonImagelist)\
    (BOOL)SNDMSG((hwnd), BCM_GETIMAGELIST, 0, (LPARAM)(pbuttonImagelist))

#define BCM_SETTEXTMARGIN       (BCM_FIRST + 0x0004)
#define Button_SetTextMargin(hwnd, pmargin)\
    (BOOL)SNDMSG((hwnd), BCM_SETTEXTMARGIN, 0, (LPARAM)(pmargin))
#define BCM_GETTEXTMARGIN       (BCM_FIRST + 0x0005)
#define Button_GetTextMargin(hwnd, pmargin)\
    (BOOL)SNDMSG((hwnd), BCM_GETTEXTMARGIN, 0, (LPARAM)(pmargin))

typedef struct tagNMBCHOTITEM
{
    NMHDR   hdr;
    DWORD   dwFlags;           // HICF_*
} NMBCHOTITEM, * LPNMBCHOTITEM;

#define BCN_HOTITEMCHANGE       (BCN_FIRST + 0x0001)

#define BST_HOT            0x0200

#endif // _WIN32_WINNT >= 0x0501

#if _WIN32_WINNT >= 0x0600

// BUTTON STATE FLAGS
#define BST_DROPDOWNPUSHED      0x0400

// begin_r_commctrl

// BUTTON STYLES
#define BS_SPLITBUTTON          0x0000000CL
#define BS_DEFSPLITBUTTON       0x0000000DL
#define BS_COMMANDLINK          0x0000000EL
#define BS_DEFCOMMANDLINK       0x0000000FL

// SPLIT BUTTON INFO mask flags
#define BCSIF_GLYPH             0x0001
#define BCSIF_IMAGE             0x0002
#define BCSIF_STYLE             0x0004
#define BCSIF_SIZE              0x0008

// SPLIT BUTTON STYLE flags
#define BCSS_NOSPLIT            0x0001
#define BCSS_STRETCH            0x0002
#define BCSS_ALIGNLEFT          0x0004
#define BCSS_IMAGE              0x0008

// end_r_commctrl

// BUTTON STRUCTURES
typedef struct tagBUTTON_SPLITINFO
{
    UINT        mask;
    HIMAGELIST  himlGlyph;         // interpreted as WCHAR if BCSIF_GLYPH is set
    UINT        uSplitStyle;
    SIZE        size;
} BUTTON_SPLITINFO, * PBUTTON_SPLITINFO;

// BUTTON MESSAGES
#define BCM_SETDROPDOWNSTATE     (BCM_FIRST + 0x0006)
#define Button_SetDropDownState(hwnd, fDropDown) \
    (BOOL)SNDMSG((hwnd), BCM_SETDROPDOWNSTATE, (WPARAM)(fDropDown), 0)

#define BCM_SETSPLITINFO         (BCM_FIRST + 0x0007)
#define Button_SetSplitInfo(hwnd, pInfo) \
    (BOOL)SNDMSG((hwnd), BCM_SETSPLITINFO, 0, (LPARAM)(pInfo))

#define BCM_GETSPLITINFO         (BCM_FIRST + 0x0008)
#define Button_GetSplitInfo(hwnd, pInfo) \
    (BOOL)SNDMSG((hwnd), BCM_GETSPLITINFO, 0, (LPARAM)(pInfo))

#define BCM_SETNOTE              (BCM_FIRST + 0x0009)
#define Button_SetNote(hwnd, psz) \
    (BOOL)SNDMSG((hwnd), BCM_SETNOTE, 0, (LPARAM)(psz))

#define BCM_GETNOTE              (BCM_FIRST + 0x000A)
#define Button_GetNote(hwnd, psz, pcc) \
    (BOOL)SNDMSG((hwnd), BCM_GETNOTE, (WPARAM)pcc, (LPARAM)psz)

#define BCM_GETNOTELENGTH        (BCM_FIRST + 0x000B)
#define Button_GetNoteLength(hwnd) \
    (LRESULT)SNDMSG((hwnd), BCM_GETNOTELENGTH, 0, 0)


#if _WIN32_WINNT >= 0x0600
// Macro to use on a button or command link to display an elevated icon
#define BCM_SETSHIELD            (BCM_FIRST + 0x000C)
#define Button_SetElevationRequiredState(hwnd, fRequired) \
    (LRESULT)SNDMSG((hwnd), BCM_SETSHIELD, 0, (LPARAM)fRequired)
#endif /* _WIN32_WINNT >= 0x0600 */

// Value to pass to BCM_SETIMAGELIST to indicate that no glyph should be
// displayed
#define BCCL_NOGLYPH  (HIMAGELIST)(-1)

// NOTIFICATION MESSAGES
typedef struct tagNMBCDROPDOWN
{
    NMHDR   hdr;
    RECT    rcButton;
} NMBCDROPDOWN, * LPNMBCDROPDOWN;

#define BCN_DROPDOWN            (BCN_FIRST + 0x0002)

#endif // _WIN32_WINNT >= 0x600

#endif // NOBUTTON

// =====================  End Button Control =========================

// ====================== Static Control =============================

#ifndef NOSTATIC

#ifdef _WIN32

// Static Class Name
#define WC_STATICA              "Static"
#define WC_STATICW              L"Static"

#ifdef UNICODE
#define WC_STATIC               WC_STATICW
#else
#define WC_STATIC               WC_STATICA
#endif

#else
#define WC_STATIC               "Static"
#endif

#endif // NOSTATIC

// =====================  End Static Control =========================

// ====================== Edit Control =============================

#ifndef NOEDIT

#ifdef _WIN32

// Edit Class Name
#define WC_EDITA                "Edit"
#define WC_EDITW                L"Edit"

#ifdef UNICODE
#define WC_EDIT                 WC_EDITW
#else
#define WC_EDIT                 WC_EDITA
#endif

#else
#define WC_EDIT                 "Edit"
#endif

#if (_WIN32_WINNT >= 0x0501)
#define EM_SETCUEBANNER     (ECM_FIRST + 1)     // Set the cue banner with the lParm = LPCWSTR
#define Edit_SetCueBannerText(hwnd, lpcwText) \
        (BOOL)SNDMSG((hwnd), EM_SETCUEBANNER, 0, (LPARAM)(lpcwText))
#define Edit_SetCueBannerTextFocused(hwnd, lpcwText, fDrawFocused) \
        (BOOL)SNDMSG((hwnd), EM_SETCUEBANNER, (WPARAM)fDrawFocused, (LPARAM)lpcwText)
#define EM_GETCUEBANNER     (ECM_FIRST + 2)     // Set the cue banner with the lParm = LPCWSTR
#define Edit_GetCueBannerText(hwnd, lpwText, cchText) \
        (BOOL)SNDMSG((hwnd), EM_GETCUEBANNER, (WPARAM)(lpwText), (LPARAM)(cchText))

typedef struct _tagEDITBALLOONTIP
{
    DWORD   cbStruct;
    LPCWSTR pszTitle;
    LPCWSTR pszText;
    INT     ttiIcon; // From TTI_*
} EDITBALLOONTIP, *PEDITBALLOONTIP;
#define EM_SHOWBALLOONTIP   (ECM_FIRST + 3)     // Show a balloon tip associated to the edit control
#define Edit_ShowBalloonTip(hwnd, peditballoontip) \
        (BOOL)SNDMSG((hwnd), EM_SHOWBALLOONTIP, 0, (LPARAM)(peditballoontip))
#define EM_HIDEBALLOONTIP   (ECM_FIRST + 4)     // Hide any balloon tip associated with the edit control
#define Edit_HideBalloonTip(hwnd) \
        (BOOL)SNDMSG((hwnd), EM_HIDEBALLOONTIP, 0, 0)
#endif

#if _WIN32_WINNT >= 0x0600
#define EM_SETHILITE        (ECM_FIRST + 5)
#define Edit_SetHilite(hwndCtl, ichStart, ichEnd)  ((void)SNDMSG((hwndCtl), EM_SETHILITE, (ichStart), (ichEnd)))
#define EM_GETHILITE        (ECM_FIRST + 6)
#define Edit_GetHilite(hwndCtl)                    ((DWORD)SNDMSG((hwndCtl), EM_GETHILITE, 0L, 0L))


#endif



#endif // NOEDIT

// =====================  End Edit Control =========================

// ====================== Listbox Control =============================

#ifndef NOLISTBOX

#ifdef _WIN32

// Listbox Class Name
#define WC_LISTBOXA             "ListBox"
#define WC_LISTBOXW             L"ListBox"

#ifdef UNICODE
#define WC_LISTBOX              WC_LISTBOXW
#else
#define WC_LISTBOX              WC_LISTBOXA
#endif

#else
#define WC_LISTBOX              "ListBox"
#endif

#endif // NOLISTBOX


// =====================  End Listbox Control =========================

// ====================== Combobox Control =============================

#ifndef NOCOMBOBOX

#ifdef _WIN32

// Combobox Class Name
#define WC_COMBOBOXA            "ComboBox"
#define WC_COMBOBOXW            L"ComboBox"

#ifdef UNICODE
#define WC_COMBOBOX             WC_COMBOBOXW
#else
#define WC_COMBOBOX             WC_COMBOBOXA
#endif

#else
#define WC_COMBOBOX             "ComboBox"
#endif

#endif // NOCOMBOBOX


#if (_WIN32_WINNT >= 0x0501)

// custom combobox control messages
#define CB_SETMINVISIBLE        (CBM_FIRST + 1)
#define CB_GETMINVISIBLE        (CBM_FIRST + 2)
#define CB_SETCUEBANNER         (CBM_FIRST + 3)
#define CB_GETCUEBANNER         (CBM_FIRST + 4)

#define ComboBox_SetMinVisible(hwnd, iMinVisible) \
            (BOOL)SNDMSG((hwnd), CB_SETMINVISIBLE, (WPARAM)(iMinVisible), 0)

#define ComboBox_GetMinVisible(hwnd) \
            (int)SNDMSG((hwnd), CB_GETMINVISIBLE, 0, 0)

#define ComboBox_SetCueBannerText(hwnd, lpcwText)   \
            (BOOL)SNDMSG((hwnd), CB_SETCUEBANNER, 0, (LPARAM)(lpcwText))

#define ComboBox_GetCueBannerText(hwnd, lpwText, cchText) \
            (BOOL)SNDMSG((hwnd), CB_GETCUEBANNER, (WPARAM)(lpwText), (LPARAM)(cchText))

#endif

// =====================  End Combobox Control =========================

// ====================== Scrollbar Control ============================

#ifndef NOSCROLLBAR

#ifdef _WIN32

// Scrollbar Class Name
#define WC_SCROLLBARA            "ScrollBar"
#define WC_SCROLLBARW            L"ScrollBar"

#ifdef UNICODE
#define WC_SCROLLBAR             WC_SCROLLBARW
#else
#define WC_SCROLLBAR             WC_SCROLLBARA
#endif

#else
#define WC_SCROLLBAR             "ScrollBar"
#endif

#endif // NOSCROLLBAR


// ===================== End Scrollbar Control =========================

// ===================== Task Dialog =========================
#ifndef NOTASKDIALOG

#ifdef _WIN32
#include <pshpack1.h>
#endif

typedef HRESULT (CALLBACK *PFTASKDIALOGCALLBACK)(__in HWND hwnd, __in UINT msg, __in WPARAM wParam, __in LPARAM lParam, __in LONG_PTR lpRefData);

enum _TASKDIALOG_FLAGS
{
    TDF_ENABLE_HYPERLINKS               = 0x0001,
    TDF_USE_HICON_MAIN                  = 0x0002,
    TDF_USE_HICON_FOOTER                = 0x0004,
    TDF_ALLOW_DIALOG_CANCELLATION       = 0x0008,
    TDF_USE_COMMAND_LINKS               = 0x0010,
    TDF_USE_COMMAND_LINKS_NO_ICON       = 0x0020,
    TDF_EXPAND_FOOTER_AREA              = 0x0040,
    TDF_EXPANDED_BY_DEFAULT             = 0x0080,
    TDF_VERIFICATION_FLAG_CHECKED       = 0x0100,
    TDF_SHOW_PROGRESS_BAR               = 0x0200,
    TDF_SHOW_MARQUEE_PROGRESS_BAR       = 0x0400,
    TDF_CALLBACK_TIMER                  = 0x0800,
    TDF_POSITION_RELATIVE_TO_WINDOW     = 0x1000,
    TDF_RTL_LAYOUT                      = 0x2000,
    TDF_NO_DEFAULT_RADIO_BUTTON         = 0x4000,
    TDF_CAN_BE_MINIMIZED                = 0x8000
};
typedef int TASKDIALOG_FLAGS;                         // Note: _TASKDIALOG_FLAGS is an int

typedef enum _TASKDIALOG_MESSAGES
{
    TDM_NAVIGATE_PAGE                   = WM_USER+101,
    TDM_CLICK_BUTTON                    = WM_USER+102, // wParam = Button ID
    TDM_SET_MARQUEE_PROGRESS_BAR        = WM_USER+103, // wParam = 0 (nonMarque) wParam != 0 (Marquee)
    TDM_SET_PROGRESS_BAR_STATE          = WM_USER+104, // wParam = new progress state
    TDM_SET_PROGRESS_BAR_RANGE          = WM_USER+105, // lParam = MAKELPARAM(nMinRange, nMaxRange)
    TDM_SET_PROGRESS_BAR_POS            = WM_USER+106, // wParam = new position
    TDM_SET_PROGRESS_BAR_MARQUEE        = WM_USER+107, // wParam = 0 (stop marquee), wParam != 0 (start marquee), lparam = speed (milliseconds between repaints)
    TDM_SET_ELEMENT_TEXT                = WM_USER+108, // wParam = element (TASKDIALOG_ELEMENTS), lParam = new element text (LPCWSTR)
    TDM_CLICK_RADIO_BUTTON              = WM_USER+110, // wParam = Radio Button ID
    TDM_ENABLE_BUTTON                   = WM_USER+111, // lParam = 0 (disable), lParam != 0 (enable), wParam = Button ID
    TDM_ENABLE_RADIO_BUTTON             = WM_USER+112, // lParam = 0 (disable), lParam != 0 (enable), wParam = Radio Button ID
    TDM_CLICK_VERIFICATION              = WM_USER+113, // wParam = 0 (unchecked), 1 (checked), lParam = 1 (set key focus)
    TDM_UPDATE_ELEMENT_TEXT             = WM_USER+114, // wParam = element (TASKDIALOG_ELEMENTS), lParam = new element text (LPCWSTR)
    TDM_SET_BUTTON_ELEVATION_REQUIRED_STATE = WM_USER+115, // wParam = Button ID, lParam = 0 (elevation not required), lParam != 0 (elevation required)
    TDM_UPDATE_ICON                     = WM_USER+116  // wParam = icon element (TASKDIALOG_ICON_ELEMENTS), lParam = new icon (hIcon if TDF_USE_HICON_* was set, PCWSTR otherwise)
} TASKDIALOG_MESSAGES;

typedef enum _TASKDIALOG_NOTIFICATIONS
{
    TDN_CREATED                         = 0,
    TDN_NAVIGATED                       = 1,
    TDN_BUTTON_CLICKED                  = 2,            // wParam = Button ID
    TDN_HYPERLINK_CLICKED               = 3,            // lParam = (LPCWSTR)pszHREF
    TDN_TIMER                           = 4,            // wParam = Milliseconds since dialog created or timer reset
    TDN_DESTROYED                       = 5,
    TDN_RADIO_BUTTON_CLICKED            = 6,            // wParam = Radio Button ID
    TDN_DIALOG_CONSTRUCTED              = 7,
    TDN_VERIFICATION_CLICKED            = 8,             // wParam = 1 if checkbox checked, 0 if not, lParam is unused and always 0
    TDN_HELP                            = 9,
    TDN_EXPANDO_BUTTON_CLICKED          = 10            // wParam = 0 (dialog is now collapsed), wParam != 0 (dialog is now expanded)
} TASKDIALOG_NOTIFICATIONS;

typedef struct _TASKDIALOG_BUTTON
{
    int     nButtonID;
    PCWSTR  pszButtonText;
} TASKDIALOG_BUTTON;

typedef enum _TASKDIALOG_ELEMENTS
{
    TDE_CONTENT,
    TDE_EXPANDED_INFORMATION,
    TDE_FOOTER,
    TDE_MAIN_INSTRUCTION
} TASKDIALOG_ELEMENTS;

typedef enum _TASKDIALOG_ICON_ELEMENTS
{
    TDIE_ICON_MAIN,
    TDIE_ICON_FOOTER
} TASKDIALOG_ICON_ELEMENTS;

#define TD_WARNING_ICON         MAKEINTRESOURCEW(-1)
#define TD_ERROR_ICON           MAKEINTRESOURCEW(-2)
#define TD_INFORMATION_ICON     MAKEINTRESOURCEW(-3)
#define TD_SHIELD_ICON          MAKEINTRESOURCEW(-4)


enum _TASKDIALOG_COMMON_BUTTON_FLAGS
{
    TDCBF_OK_BUTTON            = 0x0001, // selected control return value IDOK
    TDCBF_YES_BUTTON           = 0x0002, // selected control return value IDYES
    TDCBF_NO_BUTTON            = 0x0004, // selected control return value IDNO
    TDCBF_CANCEL_BUTTON        = 0x0008, // selected control return value IDCANCEL
    TDCBF_RETRY_BUTTON         = 0x0010, // selected control return value IDRETRY
    TDCBF_CLOSE_BUTTON         = 0x0020  // selected control return value IDCLOSE
};
typedef int TASKDIALOG_COMMON_BUTTON_FLAGS;           // Note: _TASKDIALOG_COMMON_BUTTON_FLAGS is an int

typedef struct _TASKDIALOGCONFIG
{
    UINT        cbSize;
    HWND        hwndParent;
    HINSTANCE   hInstance;                              // used for MAKEINTRESOURCE() strings
    TASKDIALOG_FLAGS                dwFlags;            // TASKDIALOG_FLAGS (TDF_XXX) flags
    TASKDIALOG_COMMON_BUTTON_FLAGS  dwCommonButtons;    // TASKDIALOG_COMMON_BUTTON (TDCBF_XXX) flags
    PCWSTR      pszWindowTitle;                         // string or MAKEINTRESOURCE()
    union
    {
        HICON   hMainIcon;
        PCWSTR  pszMainIcon;
    };
    PCWSTR      pszMainInstruction;
    PCWSTR      pszContent;
    UINT        cButtons;
    const TASKDIALOG_BUTTON  *pButtons;
    int         nDefaultButton;
    UINT        cRadioButtons;
    const TASKDIALOG_BUTTON  *pRadioButtons;
    int         nDefaultRadioButton;
    PCWSTR      pszVerificationText;
    PCWSTR      pszExpandedInformation;
    PCWSTR      pszExpandedControlText;
    PCWSTR      pszCollapsedControlText;
    union
    {
        HICON   hFooterIcon;
        PCWSTR  pszFooterIcon;
    };
    PCWSTR      pszFooter;
    PFTASKDIALOGCALLBACK pfCallback;
    LONG_PTR    lpCallbackData;
    UINT        cxWidth;                                // width of the Task Dialog's client area in DLU's. If 0, Task Dialog will calculate the ideal width.
} TASKDIALOGCONFIG;

WINCOMMCTRLAPI HRESULT WINAPI TaskDialogIndirect(const TASKDIALOGCONFIG *pTaskConfig, __out_opt int *pnButton, __out_opt int *pnRadioButton, __out_opt BOOL *pfVerificationFlagChecked);
WINCOMMCTRLAPI HRESULT WINAPI TaskDialog(__in_opt HWND hwndParent, __in_opt HINSTANCE hInstance, __in_opt PCWSTR pszWindowTitle, __in_opt PCWSTR pszMainInstruction, __in_opt PCWSTR pszContent, TASKDIALOG_COMMON_BUTTON_FLAGS dwCommonButtons, __in_opt PCWSTR pszIcon, __out_opt int *pnButton);

#ifdef _WIN32
#include <poppack.h>
#endif

#endif // NOTASKDIALOG

// ==================== End TaskDialog =======================


//
// === MUI APIs ===
//
#ifndef NOMUI
void WINAPI InitMUILanguage(LANGID uiLang);


LANGID WINAPI GetMUILanguage(void);
#endif  // NOMUI

#endif      // _WIN32_IE >= 0x0400

#ifndef NO_COMMCTRL_DA
#define __COMMCTRL_DA_DEFINED__
//
//====== Dynamic Array routines ==========================================
//
// Note that the STL and other libraries have similar functionality.
// The routines here are specific to Windows and may not be as convenient
// or fully functional as those in other libraries.
//

#define DA_LAST         (0x7FFFFFFF)
#define DA_ERR          (-1)

typedef int (CALLBACK *PFNDAENUMCALLBACK)(__in void *p, __in_opt void *pData);
typedef int (CALLBACK *PFNDAENUMCALLBACKCONST)(__in const void *p, __in_opt void *pData);
typedef int (CALLBACK *PFNDACOMPARE)(__in void *p1, __in void *p2, __in LPARAM lParam);
typedef int (CALLBACK *PFNDACOMPARECONST)(__in const void *p1, __in const void *p2, __in LPARAM lParam);

// Dynamic structure array
struct _DSA;
typedef struct _DSA *HDSA;


WINCOMMCTRLAPI HDSA   WINAPI DSA_Create(int cbItem, int cItemGrow);
WINCOMMCTRLAPI BOOL   WINAPI DSA_Destroy(__in HDSA hdsa);
WINCOMMCTRLAPI void   WINAPI DSA_DestroyCallback(__in HDSA hdsa, __in PFNDAENUMCALLBACK pfnCB, __in_opt void *pData);
#ifdef __cplusplus
extern "C++" __inline void DSA_DestroyCallback(__in HDSA hdsa, __in PFNDAENUMCALLBACKCONST pfnCB, __in_opt void *pData)
{
    DSA_DestroyCallback(hdsa, (PFNDAENUMCALLBACK)pfnCB, pData);
}
#endif
WINCOMMCTRLAPI BOOL   WINAPI DSA_DeleteItem(__in HDSA hdsa, __in int i);
WINCOMMCTRLAPI BOOL   WINAPI DSA_DeleteAllItems(__in HDSA hdsa);
WINCOMMCTRLAPI void   WINAPI DSA_EnumCallback(__in HDSA hdsa, __in PFNDAENUMCALLBACK pfnCB, __in_opt void *pData);
#ifdef __cplusplus
extern "C++" __inline void DSA_EnumCallback(__in HDSA hdsa, __in PFNDAENUMCALLBACKCONST pfnCB, __in_opt void *pData)
{
    DSA_EnumCallback(hdsa, (PFNDAENUMCALLBACK)pfnCB, pData);
}
#endif
WINCOMMCTRLAPI int    WINAPI DSA_InsertItem(__in HDSA hdsa, __in int i, __in const void *pitem);
WINCOMMCTRLAPI PVOID  WINAPI DSA_GetItemPtr(__in HDSA hdsa, __in int i);
WINCOMMCTRLAPI BOOL   WINAPI DSA_GetItem(__in HDSA hdsa, __in int i, __out_xcount(pdsa->cbItem) void *pitem);
WINCOMMCTRLAPI BOOL   WINAPI DSA_SetItem(__in HDSA hdsa, __in int i, __in const void *pitem);
#define DSA_GetItemCount(hdsa)      (*(int *)(hdsa))
#define DSA_AppendItem(hdsa, pitem) DSA_InsertItem(hdsa, DA_LAST, pitem)

#if (NTDDI_VERSION >= NTDDI_LONGHORN)
WINCOMMCTRLAPI HDSA   WINAPI DSA_Clone(__in HDSA hdsa);
WINCOMMCTRLAPI ULONGLONG WINAPI DSA_GetSize(__in HDSA hdsa);
WINCOMMCTRLAPI BOOL   WINAPI DSA_Sort(__in HDSA pdsa, __in PFNDACOMPARE pfnCompare, __in LPARAM lParam);
#ifdef __cplusplus
extern "C++" __inline BOOL DSA_Sort(__in HDSA hdsa, __in PFNDACOMPARECONST pfnCompare, __in LPARAM lParam)
{
    return DSA_Sort(hdsa, (PFNDACOMPARE)(pfnCompare), lParam);
}
#endif
#endif  // NTDDI_LONGHORN

#define DSA_APPEND      DA_LAST
#define DSA_ERR         DA_ERR

#define PFNDSAENUMCALLBACK          PFNDAENUMCALLBACK
#define PFNDSAENUMCALLBACKCONST     PFNDAENUMCALLBACKCONST
#define PFNDSACOMPARE               PFNDACOMPARE
#define PFNDSACOMPARECONST          PFNDACOMPARECONST

// Dynamic pointer array
struct _DPA;
typedef struct _DPA *HDPA;


WINCOMMCTRLAPI HDPA   WINAPI DPA_Create(int cItemGrow);
WINCOMMCTRLAPI HDPA   WINAPI DPA_CreateEx(__in int cpGrow, __in_opt HANDLE hheap);
WINCOMMCTRLAPI HDPA   WINAPI DPA_Clone(__in const HDPA hdpa, __in HDPA hdpaNew);
WINCOMMCTRLAPI BOOL   WINAPI DPA_Destroy(__in HDPA hdpa);
WINCOMMCTRLAPI void   WINAPI DPA_DestroyCallback(__in HDPA hdpa, __in PFNDAENUMCALLBACK pfnCB, __in_opt void *pData);
#ifdef __cplusplus
extern "C++" __inline void DPA_DestroyCallback(__in HDPA hdpa, __in PFNDAENUMCALLBACKCONST pfnCB, __in_opt void *pData)
{
    DPA_DestroyCallback(hdpa, (PFNDAENUMCALLBACK)pfnCB, pData);
}
#endif
WINCOMMCTRLAPI PVOID  WINAPI DPA_DeletePtr(__in HDPA hdpa, __in int i);
WINCOMMCTRLAPI BOOL   WINAPI DPA_DeleteAllPtrs(__in HDPA hdpa);
WINCOMMCTRLAPI void   WINAPI DPA_EnumCallback(__in HDPA hdpa, __in PFNDAENUMCALLBACK pfnCB, __in_opt void *pData);
#ifdef __cplusplus
extern "C++" __inline void DPA_EnumCallback(__in HDPA hdpa, __in PFNDAENUMCALLBACKCONST pfnCB, __in_opt void *pData)
{
    DPA_EnumCallback(hdpa, (PFNDAENUMCALLBACK)pfnCB, pData);
}
#endif
WINCOMMCTRLAPI BOOL   WINAPI DPA_Grow(__in HDPA pdpa, __in int cp);
WINCOMMCTRLAPI int    WINAPI DPA_InsertPtr(__in HDPA hdpa, __in int i, __in_opt void *p);
WINCOMMCTRLAPI BOOL   WINAPI DPA_SetPtr(__in HDPA hdpa, __in int i, __in_opt void *p);
WINCOMMCTRLAPI PVOID  WINAPI DPA_GetPtr(__in HDPA hdpa, __in INT_PTR i);
WINCOMMCTRLAPI int    WINAPI DPA_GetPtrIndex(__in HDPA hdpa, __in const void *p);

#define DPA_GetPtrCount(hdpa)       (*(int *)(hdpa))
#define DPA_FastDeleteLastPtr(hdpa) (--*(int *)(hdpa))
#define DPA_GetPtrPtr(hdpa)         (*((void * **)((BYTE *)(hdpa) + sizeof(void *))))
#define DPA_FastGetPtr(hdpa, i)     (DPA_GetPtrPtr(hdpa)[i])
#define DPA_AppendPtr(hdpa, pitem)  DPA_InsertPtr(hdpa, DA_LAST, pitem)

#if (NTDDI_VERSION >= NTDDI_LONGHORN)
WINCOMMCTRLAPI ULONGLONG WINAPI DPA_GetSize(__in HDPA hdpa);
#endif  // NTDDI_LONGHORN

WINCOMMCTRLAPI BOOL   WINAPI DPA_Sort(__in HDPA hdpa, __in PFNDACOMPARE pfnCompare, __in LPARAM lParam);
#ifdef __cplusplus
extern "C++" __inline BOOL DPA_Sort(__in HDPA hdpa, __in PFNDACOMPARECONST pfnCompare, __in LPARAM lParam)
{
    return DPA_Sort(hdpa, (PFNDACOMPARE)(pfnCompare), lParam);
}
#endif

//
// Save to and load from a stream.  The stream callback gets a pointer to
// a DPASTREAMINFO structure.
//
// For DPA_SaveStream, the callback is responsible for writing the pvItem
// info to the stream.  (It's not necessary to write the iPos to the
// stream.)  Return S_OK if the element was saved, S_FALSE if it wasn't
// but continue anyway, or some failure.
//
// For DPA_LoadStream, the callback is responsible for allocating an
// item and setting the pvItem field to the new pointer.  Return S_OK
// if the element was loaded, S_FALSE it it wasn't but continue anyway,
// or some failure.
//

typedef struct _DPASTREAMINFO
{
    int    iPos;        // Index of item
    void *pvItem;
} DPASTREAMINFO;

struct IStream;
typedef HRESULT (CALLBACK *PFNDPASTREAM)(__in DPASTREAMINFO * pinfo, __in struct IStream * pstream, __in_opt void *pvInstData);

WINCOMMCTRLAPI HRESULT WINAPI DPA_LoadStream(__out HDPA * phdpa, __in PFNDPASTREAM pfn, __in struct IStream * pstream, __in_opt void *pvInstData);
WINCOMMCTRLAPI HRESULT WINAPI DPA_SaveStream(__in HDPA hdpa, __in PFNDPASTREAM pfn, __in struct IStream * pstream, __in_opt void *pvInstData);

// Merge two DPAs.  This takes two (optionally) presorted arrays and merges
// the source array into the dest.  DPA_Merge uses the provided callbacks
// to perform comparison and merge operations.  The merge callback is
// called when two elements (one in each list) match according to the
// compare function.  This allows portions of an element in one list to
// be merged with the respective element in the second list.
//
// The first DPA (hdpaDest) is the output array.
//
// Merge options:
//
//    DPAM_SORTED       The arrays are already sorted; don't sort
//    DPAM_UNION        The resulting array is the union of all elements
//                      in both arrays (DPAMM_INSERT may be sent for
//                      this merge option.)
//    DPAM_INTERSECT    Only elements in the source array that intersect
//                      with the dest array are merged.  (DPAMM_DELETE
//                      may be sent for this merge option.)
//    DPAM_NORMAL       Like DPAM_INTERSECT except the dest array
//                      also maintains its original, additional elements.
//
#define DPAM_SORTED             0x00000001
#define DPAM_NORMAL             0x00000002
#define DPAM_UNION              0x00000004
#define DPAM_INTERSECT          0x00000008

// The merge callback should merge contents of the two items and return
// the pointer of the merged item.  It's okay to simply use pvDest
// as the returned pointer.
//
typedef void* (CALLBACK *PFNDPAMERGE)(__in UINT uMsg, __in void *pvDest, __in void *pvSrc, __in LPARAM lParam);
typedef const void* (CALLBACK *PFNDPAMERGECONST)(__in UINT uMsg, __in const void *pvDest, __in const void *pvSrc, __in LPARAM lParam);

// Messages for merge callback
#define DPAMM_MERGE     1
#define DPAMM_DELETE    2
#define DPAMM_INSERT    3

WINCOMMCTRLAPI BOOL WINAPI DPA_Merge(__in HDPA hdpaDest, __in HDPA hdpaSrc, __in DWORD dwFlags, __in PFNDACOMPARE pfnCompare, __in PFNDPAMERGE pfnMerge, __in LPARAM lParam);
#ifdef __cplusplus
extern "C++" __inline BOOL DPA_Merge(__in HDPA hdpaDest, __in HDPA hdpaSrc, __in DWORD dwFlags, __in PFNDACOMPARECONST pfnCompare, __in PFNDPAMERGECONST pfnMerge, __in LPARAM lParam)
{
    return DPA_Merge(hdpaDest, hdpaSrc, dwFlags, (PFNDACOMPARE)pfnCompare, (PFNDPAMERGE)pfnMerge, lParam);
}
#endif

//
// Search array.  If DPAS_SORTED, then array is assumed to be sorted
// according to pfnCompare, and binary search algorithm is used.
// Otherwise, linear search is used.
//
// Searching starts at iStart (0 to start search at beginning).
//
// DPAS_INSERTBEFORE/AFTER govern what happens if an exact match is not
// found.  If neither are specified, this function returns -1 if no exact
// match is found.  Otherwise, the index of the item before or after the
// closest (including exact) match is returned.
//
// Search option flags
//
#define DPAS_SORTED             0x0001
#define DPAS_INSERTBEFORE       0x0002
#define DPAS_INSERTAFTER        0x0004

WINCOMMCTRLAPI int WINAPI DPA_Search(__in HDPA hdpa, __in_opt void *pFind, __in int iStart, __in PFNDACOMPARE pfnCompare, __in LPARAM lParam, __in UINT options);
#ifdef __cplusplus
extern "C++" __inline int DPA_Search(__in HDPA hdpa, __in_opt const void *pFind, __in int iStart, __in PFNDACOMPARECONST pfnCompare, __in LPARAM lParam, __in UINT options)
{
    return DPA_Search(hdpa, const_cast<void *>(pFind), iStart, (PFNDACOMPARE)pfnCompare, lParam, options);
}
#endif

#define DPA_SortedInsertPtr(hdpa, pFind, iStart, pfnCompare, lParam, options, pitem)  \
            DPA_InsertPtr(hdpa, DPA_Search(hdpa, pFind, iStart, pfnCompare, lParam, (DPAS_SORTED | (options))), (pitem))

#define DPA_APPEND      DA_LAST
#define DPA_ERR         DA_ERR

#define PFNDPAENUMCALLBACK          PFNDAENUMCALLBACK
#define PFNDPAENUMCALLBACKCONST     PFNDAENUMCALLBACKCONST
#define PFNDPACOMPARE               PFNDACOMPARE
#define PFNDPACOMPARECONST          PFNDACOMPARECONST

#endif // NO_COMMCTRL_DA


WINCOMMCTRLAPI BOOL WINAPI Str_SetPtrW(__deref_inout_opt LPWSTR * ppsz, LPCWSTR psz);

#ifdef _WIN32
//====== TrackMouseEvent  =====================================================

#ifndef NOTRACKMOUSEEVENT

//
// If the messages for TrackMouseEvent have not been defined then define them
// now.
//
#ifndef WM_MOUSEHOVER
#define WM_MOUSEHOVER                   0x02A1
#define WM_MOUSELEAVE                   0x02A3
#endif

//
// If the TRACKMOUSEEVENT structure and associated flags havent been declared
// then declare them now.
//
#ifndef TME_HOVER

#define TME_HOVER       0x00000001
#define TME_LEAVE       0x00000002
#if (WINVER >= 0x0500)
#define TME_NONCLIENT   0x00000010
#endif /* WINVER >= 0x0500 */
#define TME_QUERY       0x40000000
#define TME_CANCEL      0x80000000



#define HOVER_DEFAULT   0xFFFFFFFF

typedef struct tagTRACKMOUSEEVENT {
    DWORD cbSize;
    DWORD dwFlags;
    HWND  hwndTrack;
    DWORD dwHoverTime;
} TRACKMOUSEEVENT, *LPTRACKMOUSEEVENT;

#endif // !TME_HOVER


//
// Declare _TrackMouseEvent.  This API tries to use the window manager's
// implementation of TrackMouseEvent if it is present, otherwise it emulates.
//
WINCOMMCTRLAPI
BOOL
WINAPI
_TrackMouseEvent(
    __inout LPTRACKMOUSEEVENT lpEventTrack);

#endif // !NOTRACKMOUSEEVENT

#if (_WIN32_IE >= 0x0400)

//====== Flat Scrollbar APIs=========================================
#ifndef NOFLATSBAPIS

#define WSB_PROP_CYVSCROLL  0x00000001L
#define WSB_PROP_CXHSCROLL  0x00000002L
#define WSB_PROP_CYHSCROLL  0x00000004L
#define WSB_PROP_CXVSCROLL  0x00000008L
#define WSB_PROP_CXHTHUMB   0x00000010L
#define WSB_PROP_CYVTHUMB   0x00000020L
#define WSB_PROP_VBKGCOLOR  0x00000040L
#define WSB_PROP_HBKGCOLOR  0x00000080L
#define WSB_PROP_VSTYLE     0x00000100L
#define WSB_PROP_HSTYLE     0x00000200L
#define WSB_PROP_WINSTYLE   0x00000400L
#define WSB_PROP_PALETTE    0x00000800L
#define WSB_PROP_MASK       0x00000FFFL

#define FSB_FLAT_MODE           2
#define FSB_ENCARTA_MODE        1
#define FSB_REGULAR_MODE        0

WINCOMMCTRLAPI BOOL WINAPI FlatSB_EnableScrollBar(HWND, int, UINT);
WINCOMMCTRLAPI BOOL WINAPI FlatSB_ShowScrollBar(HWND, int code, BOOL);

WINCOMMCTRLAPI BOOL WINAPI FlatSB_GetScrollRange(HWND, int code, LPINT, LPINT);
WINCOMMCTRLAPI BOOL WINAPI FlatSB_GetScrollInfo(HWND, int code, LPSCROLLINFO);

WINCOMMCTRLAPI int WINAPI FlatSB_GetScrollPos(HWND, int code);


WINCOMMCTRLAPI BOOL WINAPI FlatSB_GetScrollProp(HWND, int propIndex, LPINT);
#ifdef _WIN64
WINCOMMCTRLAPI BOOL WINAPI FlatSB_GetScrollPropPtr(HWND, int propIndex, PINT_PTR);
#else
#define FlatSB_GetScrollPropPtr  FlatSB_GetScrollProp
#endif


WINCOMMCTRLAPI int WINAPI FlatSB_SetScrollPos(HWND, int code, int pos, BOOL fRedraw);

WINCOMMCTRLAPI int WINAPI FlatSB_SetScrollInfo(HWND, int code, LPSCROLLINFO psi, BOOL fRedraw);


WINCOMMCTRLAPI int WINAPI FlatSB_SetScrollRange(HWND, int code, int min, int max, BOOL fRedraw);
WINCOMMCTRLAPI BOOL WINAPI FlatSB_SetScrollProp(HWND, UINT index, INT_PTR newValue, BOOL);
#define FlatSB_SetScrollPropPtr FlatSB_SetScrollProp

WINCOMMCTRLAPI BOOL WINAPI InitializeFlatSB(HWND);
WINCOMMCTRLAPI HRESULT WINAPI UninitializeFlatSB(HWND);

#endif  //  NOFLATSBAPIS

#endif      // _WIN32_IE >= 0x0400

#endif /* _WIN32 */

#endif      // _WIN32_IE >= 0x0300

#if (_WIN32_WINNT >= 0x0501)
//
// subclassing stuff
//
typedef LRESULT (CALLBACK *SUBCLASSPROC)(HWND hWnd, UINT uMsg, WPARAM wParam,
    LPARAM lParam, UINT_PTR uIdSubclass, DWORD_PTR dwRefData);


BOOL WINAPI SetWindowSubclass(HWND hWnd, SUBCLASSPROC pfnSubclass, UINT_PTR uIdSubclass,
    DWORD_PTR dwRefData);
BOOL WINAPI GetWindowSubclass(HWND hWnd, SUBCLASSPROC pfnSubclass, UINT_PTR uIdSubclass,
    DWORD_PTR *pdwRefData);
BOOL WINAPI RemoveWindowSubclass(HWND hWnd, SUBCLASSPROC pfnSubclass,
    UINT_PTR uIdSubclass);

LRESULT WINAPI DefSubclassProc(HWND hWnd, UINT uMsg, WPARAM wParam, LPARAM lParam);
#endif

#if (NTDDI_VERSION >= NTDDI_LONGHORN)

enum _LI_METRIC
{
   LIM_SMALL, // corresponds to SM_CXSMICON/SM_CYSMICON
   LIM_LARGE, // corresponds to SM_CXICON/SM_CYICON
};

WINCOMMCTRLAPI HRESULT WINAPI LoadIconMetric(HINSTANCE hinst, PCWSTR pszName, int lims, __out HICON *phico);
WINCOMMCTRLAPI HRESULT WINAPI LoadIconWithScaleDown(HINSTANCE hinst, PCWSTR pszName, int cx, int cy, __out HICON *phico);

#endif // NTDDI_LONGHORN

#if (_WIN32_WINNT >= 0x0501)

int WINAPI DrawShadowText(HDC hdc, __in_ecount(cch) LPCWSTR pszText, UINT cch, RECT* prc, DWORD dwFlags, COLORREF crText, COLORREF crShadow,
    int ixOffset, int iyOffset);
#endif




#if !defined(RC_INVOKED) /* RC complains about long symbols in #ifs */
#if defined(ISOLATION_AWARE_ENABLED) && (ISOLATION_AWARE_ENABLED != 0)
#include "commctrl.inl"
#endif /* ISOLATION_AWARE_ENABLED */
#endif /* RC */

#ifdef __cplusplus
}
#endif

#endif


#if defined(_MSC_VER) && (_MSC_VER >= 1200)
#pragma warning(pop)
#endif

#endif  // _INC_COMMCTRL
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\vs9sp1\sdk\include\commdlg.inl ===
/* Copyright (c) 2001-2006, Microsoft Corp. All rights reserved. */

#if _MSC_VER > 1000
#pragma once
#endif

#if defined(__cplusplus)
extern "C" {
#endif


#if !defined(RC_INVOKED) /* RC complains about long symbols in #ifs */
#if defined(ISOLATION_AWARE_ENABLED) && (ISOLATION_AWARE_ENABLED != 0)


#if !defined(ISOLATION_AWARE_USE_STATIC_LIBRARY)
#define ISOLATION_AWARE_USE_STATIC_LIBRARY 0
#endif

#if !defined(ISOLATION_AWARE_BUILD_STATIC_LIBRARY)
#define ISOLATION_AWARE_BUILD_STATIC_LIBRARY 0
#endif

#if !defined(ISOLATION_AWARE_INLINE)
#if ISOLATION_AWARE_BUILD_STATIC_LIBRARY
#define ISOLATION_AWARE_INLINE /* nothing */
#else
#if defined(__cplusplus)
#define ISOLATION_AWARE_INLINE inline
#else
#define ISOLATION_AWARE_INLINE __inline
#endif
#endif
#endif

#if !ISOLATION_AWARE_USE_STATIC_LIBRARY
FARPROC IsolationAwarePrivatenCv CommdlgIsolationAwarePrivatetRgCebPnQQeRff_pbZQYTQP_QYY(LPCSTR pszProcName);

#endif /* ISOLATION_AWARE_USE_STATIC_LIBRARY */
BOOL IsolationAwarePrivatenCv IsolationAwareGetOpenFileNameA(LPOPENFILENAMEA unnamed1);
BOOL IsolationAwarePrivatenCv IsolationAwareGetOpenFileNameW(LPOPENFILENAMEW unnamed1);
BOOL IsolationAwarePrivatenCv IsolationAwareGetSaveFileNameA(LPOPENFILENAMEA unnamed1);
BOOL IsolationAwarePrivatenCv IsolationAwareGetSaveFileNameW(LPOPENFILENAMEW unnamed1);
short IsolationAwarePrivatenCv IsolationAwareGetFileTitleA(LPCSTR unnamed1,__out_ecount(cchSize) LPSTR Buf,__in WORD cchSize);
short IsolationAwarePrivatenCv IsolationAwareGetFileTitleW(LPCWSTR unnamed1,__out_ecount(cchSize) LPWSTR Buf,__in WORD cchSize);
BOOL IsolationAwarePrivatenCv IsolationAwareChooseColorA(LPCHOOSECOLORA unnamed1);
BOOL IsolationAwarePrivatenCv IsolationAwareChooseColorW(LPCHOOSECOLORW unnamed1);
HWND IsolationAwarePrivatenCv IsolationAwareFindTextA(LPFINDREPLACEA unnamed1);
HWND IsolationAwarePrivatenCv IsolationAwareFindTextW(LPFINDREPLACEW unnamed1);
HWND IsolationAwarePrivatenCv IsolationAwareReplaceTextA(LPFINDREPLACEA unnamed1);
HWND IsolationAwarePrivatenCv IsolationAwareReplaceTextW(LPFINDREPLACEW unnamed1);
BOOL IsolationAwarePrivatenCv IsolationAwareChooseFontA(LPCHOOSEFONTA unnamed1);
BOOL IsolationAwarePrivatenCv IsolationAwareChooseFontW(LPCHOOSEFONTW unnamed1);
BOOL IsolationAwarePrivatenCv IsolationAwarePrintDlgA(LPPRINTDLGA unnamed1);
BOOL IsolationAwarePrivatenCv IsolationAwarePrintDlgW(LPPRINTDLGW unnamed1);
#if defined(STDMETHOD) && (WINVER >= 0x0500)
HRESULT IsolationAwarePrivatenCv IsolationAwarePrintDlgExA(LPPRINTDLGEXA unnamed1);
HRESULT IsolationAwarePrivatenCv IsolationAwarePrintDlgExW(LPPRINTDLGEXW unnamed1);
#endif /* defined(STDMETHOD) && (WINVER >= 0x0500) */
DWORD IsolationAwarePrivatenCv IsolationAwareCommDlgExtendedError(void);
BOOL IsolationAwarePrivatenCv IsolationAwarePageSetupDlgA(LPPAGESETUPDLGA unnamed1);
BOOL IsolationAwarePrivatenCv IsolationAwarePageSetupDlgW(LPPAGESETUPDLGW unnamed1);

ISOLATION_AWARE_INLINE HRESULT CommdlgIsolationAwarePrivateJVaQPGbueRfhYg(void)
{
    DWORD dwLastError = GetLastError();
    if (dwLastError == NO_ERROR)
        dwLastError = ERROR_INTERNAL_ERROR;
    return HRESULT_FROM_WIN32(dwLastError);
}

#if defined(UNICODE)

#define IsolationAwareChooseColor IsolationAwareChooseColorW
#define IsolationAwareChooseFont IsolationAwareChooseFontW
#define IsolationAwareFindText IsolationAwareFindTextW
#define IsolationAwareGetFileTitle IsolationAwareGetFileTitleW
#define IsolationAwareGetOpenFileName IsolationAwareGetOpenFileNameW
#define IsolationAwareGetSaveFileName IsolationAwareGetSaveFileNameW
#define IsolationAwarePageSetupDlg IsolationAwarePageSetupDlgW
#define IsolationAwarePrintDlg IsolationAwarePrintDlgW
#define IsolationAwarePrintDlgEx IsolationAwarePrintDlgExW
#define IsolationAwareReplaceText IsolationAwareReplaceTextW

#else /* UNICODE */

#define IsolationAwareChooseColor IsolationAwareChooseColorA
#define IsolationAwareChooseFont IsolationAwareChooseFontA
#define IsolationAwareFindText IsolationAwareFindTextA
#define IsolationAwareGetFileTitle IsolationAwareGetFileTitleA
#define IsolationAwareGetOpenFileName IsolationAwareGetOpenFileNameA
#define IsolationAwareGetSaveFileName IsolationAwareGetSaveFileNameA
#define IsolationAwarePageSetupDlg IsolationAwarePageSetupDlgA
#define IsolationAwarePrintDlg IsolationAwarePrintDlgA
#define IsolationAwarePrintDlgEx IsolationAwarePrintDlgExA
#define IsolationAwareReplaceText IsolationAwareReplaceTextA

#endif /* UNICODE */

#if !ISOLATION_AWARE_USE_STATIC_LIBRARY
ISOLATION_AWARE_INLINE BOOL IsolationAwarePrivatenCv IsolationAwareGetOpenFileNameA(LPOPENFILENAMEA unnamed1)
{
    BOOL fResult = FALSE;
    typedef BOOL (WINAPI* PFN)(LPOPENFILENAMEA unnamed1);
    static PFN s_pfn;
    ULONG_PTR  ulpCookie = 0;
    const BOOL fActivateActCtxSuccess =
#ifdef _M_IX86
        IsolationAwarePrivateT_SqbjaYRiRY ||
#endif
        IsolationAwarePrivatenPgViNgRzlnPgpgk(&ulpCookie);
    if (!fActivateActCtxSuccess)
        return fResult;
    __try
    {
        if (s_pfn == NULL)
        {
            s_pfn = (PFN)CommdlgIsolationAwarePrivatetRgCebPnQQeRff_pbZQYTQP_QYY("GetOpenFileNameA");
            if (s_pfn == NULL)
                __leave;
        }
        fResult = s_pfn(unnamed1);
    }
    __finally
    {
#ifdef _M_IX86
        if (!IsolationAwarePrivateT_SqbjaYRiRY)
#endif
        {
            const BOOL fPreserveLastError = (fResult == FALSE);
            const DWORD dwLastError = fPreserveLastError ? GetLastError() : NO_ERROR;
            (void)IsolationAwareDeactivateActCtx(0, ulpCookie);
            if (fPreserveLastError)
                SetLastError(dwLastError);
        }
    }
    return fResult;
}

ISOLATION_AWARE_INLINE BOOL IsolationAwarePrivatenCv IsolationAwareGetOpenFileNameW(LPOPENFILENAMEW unnamed1)
{
    BOOL fResult = FALSE;
    typedef BOOL (WINAPI* PFN)(LPOPENFILENAMEW unnamed1);
    static PFN s_pfn;
    ULONG_PTR  ulpCookie = 0;
    const BOOL fActivateActCtxSuccess =
#ifdef _M_IX86
        IsolationAwarePrivateT_SqbjaYRiRY ||
#endif
        IsolationAwarePrivatenPgViNgRzlnPgpgk(&ulpCookie);
    if (!fActivateActCtxSuccess)
        return fResult;
    __try
    {
        if (s_pfn == NULL)
        {
            s_pfn = (PFN)CommdlgIsolationAwarePrivatetRgCebPnQQeRff_pbZQYTQP_QYY("GetOpenFileNameW");
            if (s_pfn == NULL)
                __leave;
        }
        fResult = s_pfn(unnamed1);
    }
    __finally
    {
#ifdef _M_IX86
        if (!IsolationAwarePrivateT_SqbjaYRiRY)
#endif
        {
            const BOOL fPreserveLastError = (fResult == FALSE);
            const DWORD dwLastError = fPreserveLastError ? GetLastError() : NO_ERROR;
            (void)IsolationAwareDeactivateActCtx(0, ulpCookie);
            if (fPreserveLastError)
                SetLastError(dwLastError);
        }
    }
    return fResult;
}

ISOLATION_AWARE_INLINE BOOL IsolationAwarePrivatenCv IsolationAwareGetSaveFileNameA(LPOPENFILENAMEA unnamed1)
{
    BOOL fResult = FALSE;
    typedef BOOL (WINAPI* PFN)(LPOPENFILENAMEA unnamed1);
    static PFN s_pfn;
    ULONG_PTR  ulpCookie = 0;
    const BOOL fActivateActCtxSuccess =
#ifdef _M_IX86
        IsolationAwarePrivateT_SqbjaYRiRY ||
#endif
        IsolationAwarePrivatenPgViNgRzlnPgpgk(&ulpCookie);
    if (!fActivateActCtxSuccess)
        return fResult;
    __try
    {
        if (s_pfn == NULL)
        {
            s_pfn = (PFN)CommdlgIsolationAwarePrivatetRgCebPnQQeRff_pbZQYTQP_QYY("GetSaveFileNameA");
            if (s_pfn == NULL)
                __leave;
        }
        fResult = s_pfn(unnamed1);
    }
    __finally
    {
#ifdef _M_IX86
        if (!IsolationAwarePrivateT_SqbjaYRiRY)
#endif
        {
            const BOOL fPreserveLastError = (fResult == FALSE);
            const DWORD dwLastError = fPreserveLastError ? GetLastError() : NO_ERROR;
            (void)IsolationAwareDeactivateActCtx(0, ulpCookie);
            if (fPreserveLastError)
                SetLastError(dwLastError);
        }
    }
    return fResult;
}

ISOLATION_AWARE_INLINE BOOL IsolationAwarePrivatenCv IsolationAwareGetSaveFileNameW(LPOPENFILENAMEW unnamed1)
{
    BOOL fResult = FALSE;
    typedef BOOL (WINAPI* PFN)(LPOPENFILENAMEW unnamed1);
    static PFN s_pfn;
    ULONG_PTR  ulpCookie = 0;
    const BOOL fActivateActCtxSuccess =
#ifdef _M_IX86
        IsolationAwarePrivateT_SqbjaYRiRY ||
#endif
        IsolationAwarePrivatenPgViNgRzlnPgpgk(&ulpCookie);
    if (!fActivateActCtxSuccess)
        return fResult;
    __try
    {
        if (s_pfn == NULL)
        {
            s_pfn = (PFN)CommdlgIsolationAwarePrivatetRgCebPnQQeRff_pbZQYTQP_QYY("GetSaveFileNameW");
            if (s_pfn == NULL)
                __leave;
        }
        fResult = s_pfn(unnamed1);
    }
    __finally
    {
#ifdef _M_IX86
        if (!IsolationAwarePrivateT_SqbjaYRiRY)
#endif
        {
            const BOOL fPreserveLastError = (fResult == FALSE);
            const DWORD dwLastError = fPreserveLastError ? GetLastError() : NO_ERROR;
            (void)IsolationAwareDeactivateActCtx(0, ulpCookie);
            if (fPreserveLastError)
                SetLastError(dwLastError);
        }
    }
    return fResult;
}

ISOLATION_AWARE_INLINE short IsolationAwarePrivatenCv IsolationAwareGetFileTitleA(LPCSTR unnamed1,__out_ecount(cchSize) LPSTR Buf,__in WORD cchSize)
{
    short nResult = -1;
    typedef short (WINAPI* PFN)(LPCSTR unnamed1,__out_ecount(cchSize) LPSTR Buf,__in WORD cchSize);
    static PFN s_pfn;
    ULONG_PTR  ulpCookie = 0;
    const BOOL fActivateActCtxSuccess =
#ifdef _M_IX86
        IsolationAwarePrivateT_SqbjaYRiRY ||
#endif
        IsolationAwarePrivatenPgViNgRzlnPgpgk(&ulpCookie);
    if (!fActivateActCtxSuccess)
        return nResult;
    __try
    {
        if (s_pfn == NULL)
        {
            s_pfn = (PFN)CommdlgIsolationAwarePrivatetRgCebPnQQeRff_pbZQYTQP_QYY("GetFileTitleA");
            if (s_pfn == NULL)
                __leave;
        }
        nResult = s_pfn(unnamed1,Buf,cchSize);
    }
    __finally
    {
#ifdef _M_IX86
        if (!IsolationAwarePrivateT_SqbjaYRiRY)
#endif
        {
            const BOOL fPreserveLastError = (nResult == -1);
            const DWORD dwLastError = fPreserveLastError ? GetLastError() : NO_ERROR;
            (void)IsolationAwareDeactivateActCtx(0, ulpCookie);
            if (fPreserveLastError)
                SetLastError(dwLastError);
        }
    }
    return nResult;
}

ISOLATION_AWARE_INLINE short IsolationAwarePrivatenCv IsolationAwareGetFileTitleW(LPCWSTR unnamed1,__out_ecount(cchSize) LPWSTR Buf,__in WORD cchSize)
{
    short nResult = -1;
    typedef short (WINAPI* PFN)(LPCWSTR unnamed1,__out_ecount(cchSize) LPWSTR Buf,__in WORD cchSize);
    static PFN s_pfn;
    ULONG_PTR  ulpCookie = 0;
    const BOOL fActivateActCtxSuccess =
#ifdef _M_IX86
        IsolationAwarePrivateT_SqbjaYRiRY ||
#endif
        IsolationAwarePrivatenPgViNgRzlnPgpgk(&ulpCookie);
    if (!fActivateActCtxSuccess)
        return nResult;
    __try
    {
        if (s_pfn == NULL)
        {
            s_pfn = (PFN)CommdlgIsolationAwarePrivatetRgCebPnQQeRff_pbZQYTQP_QYY("GetFileTitleW");
            if (s_pfn == NULL)
                __leave;
        }
        nResult = s_pfn(unnamed1,Buf,cchSize);
    }
    __finally
    {
#ifdef _M_IX86
        if (!IsolationAwarePrivateT_SqbjaYRiRY)
#endif
        {
            const BOOL fPreserveLastError = (nResult == -1);
            const DWORD dwLastError = fPreserveLastError ? GetLastError() : NO_ERROR;
            (void)IsolationAwareDeactivateActCtx(0, ulpCookie);
            if (fPreserveLastError)
                SetLastError(dwLastError);
        }
    }
    return nResult;
}

ISOLATION_AWARE_INLINE BOOL IsolationAwarePrivatenCv IsolationAwareChooseColorA(LPCHOOSECOLORA unnamed1)
{
    BOOL fResult = FALSE;
    typedef BOOL (WINAPI* PFN)(LPCHOOSECOLORA unnamed1);
    static PFN s_pfn;
    ULONG_PTR  ulpCookie = 0;
    const BOOL fActivateActCtxSuccess =
#ifdef _M_IX86
        IsolationAwarePrivateT_SqbjaYRiRY ||
#endif
        IsolationAwarePrivatenPgViNgRzlnPgpgk(&ulpCookie);
    if (!fActivateActCtxSuccess)
        return fResult;
    __try
    {
        if (s_pfn == NULL)
        {
            s_pfn = (PFN)CommdlgIsolationAwarePrivatetRgCebPnQQeRff_pbZQYTQP_QYY("ChooseColorA");
            if (s_pfn == NULL)
                __leave;
        }
        fResult = s_pfn(unnamed1);
    }
    __finally
    {
#ifdef _M_IX86
        if (!IsolationAwarePrivateT_SqbjaYRiRY)
#endif
        {
            const BOOL fPreserveLastError = (fResult == FALSE);
            const DWORD dwLastError = fPreserveLastError ? GetLastError() : NO_ERROR;
            (void)IsolationAwareDeactivateActCtx(0, ulpCookie);
            if (fPreserveLastError)
                SetLastError(dwLastError);
        }
    }
    return fResult;
}

ISOLATION_AWARE_INLINE BOOL IsolationAwarePrivatenCv IsolationAwareChooseColorW(LPCHOOSECOLORW unnamed1)
{
    BOOL fResult = FALSE;
    typedef BOOL (WINAPI* PFN)(LPCHOOSECOLORW unnamed1);
    static PFN s_pfn;
    ULONG_PTR  ulpCookie = 0;
    const BOOL fActivateActCtxSuccess =
#ifdef _M_IX86
        IsolationAwarePrivateT_SqbjaYRiRY ||
#endif
        IsolationAwarePrivatenPgViNgRzlnPgpgk(&ulpCookie);
    if (!fActivateActCtxSuccess)
        return fResult;
    __try
    {
        if (s_pfn == NULL)
        {
            s_pfn = (PFN)CommdlgIsolationAwarePrivatetRgCebPnQQeRff_pbZQYTQP_QYY("ChooseColorW");
            if (s_pfn == NULL)
                __leave;
        }
        fResult = s_pfn(unnamed1);
    }
    __finally
    {
#ifdef _M_IX86
        if (!IsolationAwarePrivateT_SqbjaYRiRY)
#endif
        {
            const BOOL fPreserveLastError = (fResult == FALSE);
            const DWORD dwLastError = fPreserveLastError ? GetLastError() : NO_ERROR;
            (void)IsolationAwareDeactivateActCtx(0, ulpCookie);
            if (fPreserveLastError)
                SetLastError(dwLastError);
        }
    }
    return fResult;
}

ISOLATION_AWARE_INLINE HWND IsolationAwarePrivatenCv IsolationAwareFindTextA(LPFINDREPLACEA unnamed1)
{
    HWND windowResult = NULL;
    typedef HWND (WINAPI* PFN)(LPFINDREPLACEA unnamed1);
    static PFN s_pfn;
    ULONG_PTR  ulpCookie = 0;
    const BOOL fActivateActCtxSuccess =
#ifdef _M_IX86
        IsolationAwarePrivateT_SqbjaYRiRY ||
#endif
        IsolationAwarePrivatenPgViNgRzlnPgpgk(&ulpCookie);
    if (!fActivateActCtxSuccess)
        return windowResult;
    __try
    {
        if (s_pfn == NULL)
        {
            s_pfn = (PFN)CommdlgIsolationAwarePrivatetRgCebPnQQeRff_pbZQYTQP_QYY("FindTextA");
            if (s_pfn == NULL)
                __leave;
        }
        windowResult = s_pfn(unnamed1);
    }
    __finally
    {
#ifdef _M_IX86
        if (!IsolationAwarePrivateT_SqbjaYRiRY)
#endif
        {
            const BOOL fPreserveLastError = (windowResult == NULL);
            const DWORD dwLastError = fPreserveLastError ? GetLastError() : NO_ERROR;
            (void)IsolationAwareDeactivateActCtx(0, ulpCookie);
            if (fPreserveLastError)
                SetLastError(dwLastError);
        }
    }
    return windowResult;
}

ISOLATION_AWARE_INLINE HWND IsolationAwarePrivatenCv IsolationAwareFindTextW(LPFINDREPLACEW unnamed1)
{
    HWND windowResult = NULL;
    typedef HWND (WINAPI* PFN)(LPFINDREPLACEW unnamed1);
    static PFN s_pfn;
    ULONG_PTR  ulpCookie = 0;
    const BOOL fActivateActCtxSuccess =
#ifdef _M_IX86
        IsolationAwarePrivateT_SqbjaYRiRY ||
#endif
        IsolationAwarePrivatenPgViNgRzlnPgpgk(&ulpCookie);
    if (!fActivateActCtxSuccess)
        return windowResult;
    __try
    {
        if (s_pfn == NULL)
        {
            s_pfn = (PFN)CommdlgIsolationAwarePrivatetRgCebPnQQeRff_pbZQYTQP_QYY("FindTextW");
            if (s_pfn == NULL)
                __leave;
        }
        windowResult = s_pfn(unnamed1);
    }
    __finally
    {
#ifdef _M_IX86
        if (!IsolationAwarePrivateT_SqbjaYRiRY)
#endif
        {
            const BOOL fPreserveLastError = (windowResult == NULL);
            const DWORD dwLastError = fPreserveLastError ? GetLastError() : NO_ERROR;
            (void)IsolationAwareDeactivateActCtx(0, ulpCookie);
            if (fPreserveLastError)
                SetLastError(dwLastError);
        }
    }
    return windowResult;
}

ISOLATION_AWARE_INLINE HWND IsolationAwarePrivatenCv IsolationAwareReplaceTextA(LPFINDREPLACEA unnamed1)
{
    HWND windowResult = NULL;
    typedef HWND (WINAPI* PFN)(LPFINDREPLACEA unnamed1);
    static PFN s_pfn;
    ULONG_PTR  ulpCookie = 0;
    const BOOL fActivateActCtxSuccess =
#ifdef _M_IX86
        IsolationAwarePrivateT_SqbjaYRiRY ||
#endif
        IsolationAwarePrivatenPgViNgRzlnPgpgk(&ulpCookie);
    if (!fActivateActCtxSuccess)
        return windowResult;
    __try
    {
        if (s_pfn == NULL)
        {
            s_pfn = (PFN)CommdlgIsolationAwarePrivatetRgCebPnQQeRff_pbZQYTQP_QYY("ReplaceTextA");
            if (s_pfn == NULL)
                __leave;
        }
        windowResult = s_pfn(unnamed1);
    }
    __finally
    {
#ifdef _M_IX86
        if (!IsolationAwarePrivateT_SqbjaYRiRY)
#endif
        {
            const BOOL fPreserveLastError = (windowResult == NULL);
            const DWORD dwLastError = fPreserveLastError ? GetLastError() : NO_ERROR;
            (void)IsolationAwareDeactivateActCtx(0, ulpCookie);
            if (fPreserveLastError)
                SetLastError(dwLastError);
        }
    }
    return windowResult;
}

ISOLATION_AWARE_INLINE HWND IsolationAwarePrivatenCv IsolationAwareReplaceTextW(LPFINDREPLACEW unnamed1)
{
    HWND windowResult = NULL;
    typedef HWND (WINAPI* PFN)(LPFINDREPLACEW unnamed1);
    static PFN s_pfn;
    ULONG_PTR  ulpCookie = 0;
    const BOOL fActivateActCtxSuccess =
#ifdef _M_IX86
        IsolationAwarePrivateT_SqbjaYRiRY ||
#endif
        IsolationAwarePrivatenPgViNgRzlnPgpgk(&ulpCookie);
    if (!fActivateActCtxSuccess)
        return windowResult;
    __try
    {
        if (s_pfn == NULL)
        {
            s_pfn = (PFN)CommdlgIsolationAwarePrivatetRgCebPnQQeRff_pbZQYTQP_QYY("ReplaceTextW");
            if (s_pfn == NULL)
                __leave;
        }
        windowResult = s_pfn(unnamed1);
    }
    __finally
    {
#ifdef _M_IX86
        if (!IsolationAwarePrivateT_SqbjaYRiRY)
#endif
        {
            const BOOL fPreserveLastError = (windowResult == NULL);
            const DWORD dwLastError = fPreserveLastError ? GetLastError() : NO_ERROR;
            (void)IsolationAwareDeactivateActCtx(0, ulpCookie);
            if (fPreserveLastError)
                SetLastError(dwLastError);
        }
    }
    return windowResult;
}

ISOLATION_AWARE_INLINE BOOL IsolationAwarePrivatenCv IsolationAwareChooseFontA(LPCHOOSEFONTA unnamed1)
{
    BOOL fResult = FALSE;
    typedef BOOL (WINAPI* PFN)(LPCHOOSEFONTA unnamed1);
    static PFN s_pfn;
    ULONG_PTR  ulpCookie = 0;
    const BOOL fActivateActCtxSuccess =
#ifdef _M_IX86
        IsolationAwarePrivateT_SqbjaYRiRY ||
#endif
        IsolationAwarePrivatenPgViNgRzlnPgpgk(&ulpCookie);
    if (!fActivateActCtxSuccess)
        return fResult;
    __try
    {
        if (s_pfn == NULL)
        {
            s_pfn = (PFN)CommdlgIsolationAwarePrivatetRgCebPnQQeRff_pbZQYTQP_QYY("ChooseFontA");
            if (s_pfn == NULL)
                __leave;
        }
        fResult = s_pfn(unnamed1);
    }
    __finally
    {
#ifdef _M_IX86
        if (!IsolationAwarePrivateT_SqbjaYRiRY)
#endif
        {
            const BOOL fPreserveLastError = (fResult == FALSE);
            const DWORD dwLastError = fPreserveLastError ? GetLastError() : NO_ERROR;
            (void)IsolationAwareDeactivateActCtx(0, ulpCookie);
            if (fPreserveLastError)
                SetLastError(dwLastError);
        }
    }
    return fResult;
}

ISOLATION_AWARE_INLINE BOOL IsolationAwarePrivatenCv IsolationAwareChooseFontW(LPCHOOSEFONTW unnamed1)
{
    BOOL fResult = FALSE;
    typedef BOOL (WINAPI* PFN)(LPCHOOSEFONTW unnamed1);
    static PFN s_pfn;
    ULONG_PTR  ulpCookie = 0;
    const BOOL fActivateActCtxSuccess =
#ifdef _M_IX86
        IsolationAwarePrivateT_SqbjaYRiRY ||
#endif
        IsolationAwarePrivatenPgViNgRzlnPgpgk(&ulpCookie);
    if (!fActivateActCtxSuccess)
        return fResult;
    __try
    {
        if (s_pfn == NULL)
        {
            s_pfn = (PFN)CommdlgIsolationAwarePrivatetRgCebPnQQeRff_pbZQYTQP_QYY("ChooseFontW");
            if (s_pfn == NULL)
                __leave;
        }
        fResult = s_pfn(unnamed1);
    }
    __finally
    {
#ifdef _M_IX86
        if (!IsolationAwarePrivateT_SqbjaYRiRY)
#endif
        {
            const BOOL fPreserveLastError = (fResult == FALSE);
            const DWORD dwLastError = fPreserveLastError ? GetLastError() : NO_ERROR;
            (void)IsolationAwareDeactivateActCtx(0, ulpCookie);
            if (fPreserveLastError)
                SetLastError(dwLastError);
        }
    }
    return fResult;
}

ISOLATION_AWARE_INLINE BOOL IsolationAwarePrivatenCv IsolationAwarePrintDlgA(LPPRINTDLGA unnamed1)
{
    BOOL fResult = FALSE;
    typedef BOOL (WINAPI* PFN)(LPPRINTDLGA unnamed1);
    static PFN s_pfn;
    ULONG_PTR  ulpCookie = 0;
    const BOOL fActivateActCtxSuccess =
#ifdef _M_IX86
        IsolationAwarePrivateT_SqbjaYRiRY ||
#endif
        IsolationAwarePrivatenPgViNgRzlnPgpgk(&ulpCookie);
    if (!fActivateActCtxSuccess)
        return fResult;
    __try
    {
        if (s_pfn == NULL)
        {
            s_pfn = (PFN)CommdlgIsolationAwarePrivatetRgCebPnQQeRff_pbZQYTQP_QYY("PrintDlgA");
            if (s_pfn == NULL)
                __leave;
        }
        fResult = s_pfn(unnamed1);
    }
    __finally
    {
#ifdef _M_IX86
        if (!IsolationAwarePrivateT_SqbjaYRiRY)
#endif
        {
            const BOOL fPreserveLastError = (fResult == FALSE);
            const DWORD dwLastError = fPreserveLastError ? GetLastError() : NO_ERROR;
            (void)IsolationAwareDeactivateActCtx(0, ulpCookie);
            if (fPreserveLastError)
                SetLastError(dwLastError);
        }
    }
    return fResult;
}

ISOLATION_AWARE_INLINE BOOL IsolationAwarePrivatenCv IsolationAwarePrintDlgW(LPPRINTDLGW unnamed1)
{
    BOOL fResult = FALSE;
    typedef BOOL (WINAPI* PFN)(LPPRINTDLGW unnamed1);
    static PFN s_pfn;
    ULONG_PTR  ulpCookie = 0;
    const BOOL fActivateActCtxSuccess =
#ifdef _M_IX86
        IsolationAwarePrivateT_SqbjaYRiRY ||
#endif
        IsolationAwarePrivatenPgViNgRzlnPgpgk(&ulpCookie);
    if (!fActivateActCtxSuccess)
        return fResult;
    __try
    {
        if (s_pfn == NULL)
        {
            s_pfn = (PFN)CommdlgIsolationAwarePrivatetRgCebPnQQeRff_pbZQYTQP_QYY("PrintDlgW");
            if (s_pfn == NULL)
                __leave;
        }
        fResult = s_pfn(unnamed1);
    }
    __finally
    {
#ifdef _M_IX86
        if (!IsolationAwarePrivateT_SqbjaYRiRY)
#endif
        {
            const BOOL fPreserveLastError = (fResult == FALSE);
            const DWORD dwLastError = fPreserveLastError ? GetLastError() : NO_ERROR;
            (void)IsolationAwareDeactivateActCtx(0, ulpCookie);
            if (fPreserveLastError)
                SetLastError(dwLastError);
        }
    }
    return fResult;
}

#if defined(STDMETHOD) && (WINVER >= 0x0500)

ISOLATION_AWARE_INLINE HRESULT IsolationAwarePrivatenCv IsolationAwarePrintDlgExA(LPPRINTDLGEXA unnamed1)
{
    HRESULT result = S_OK;
    typedef HRESULT (WINAPI* PFN)(LPPRINTDLGEXA unnamed1);
    static PFN s_pfn;
    ULONG_PTR  ulpCookie = 0;
    const BOOL fActivateActCtxSuccess =
#ifdef _M_IX86
        IsolationAwarePrivateT_SqbjaYRiRY ||
#endif
        IsolationAwarePrivatenPgViNgRzlnPgpgk(&ulpCookie);
    if (!fActivateActCtxSuccess)
        return CommdlgIsolationAwarePrivateJVaQPGbueRfhYg();
    __try
    {
        if (s_pfn == NULL)
        {
            s_pfn = (PFN)CommdlgIsolationAwarePrivatetRgCebPnQQeRff_pbZQYTQP_QYY("PrintDlgExA");
            if (s_pfn == NULL)
            {
                result = CommdlgIsolationAwarePrivateJVaQPGbueRfhYg();
                __leave;
            }
        }
        result = s_pfn(unnamed1);
    }
    __finally
    {
#ifdef _M_IX86
        if (!IsolationAwarePrivateT_SqbjaYRiRY)
#endif
        {
            (void)IsolationAwareDeactivateActCtx(0, ulpCookie);
        }
    }
    return result;
}

ISOLATION_AWARE_INLINE HRESULT IsolationAwarePrivatenCv IsolationAwarePrintDlgExW(LPPRINTDLGEXW unnamed1)
{
    HRESULT result = S_OK;
    typedef HRESULT (WINAPI* PFN)(LPPRINTDLGEXW unnamed1);
    static PFN s_pfn;
    ULONG_PTR  ulpCookie = 0;
    const BOOL fActivateActCtxSuccess =
#ifdef _M_IX86
        IsolationAwarePrivateT_SqbjaYRiRY ||
#endif
        IsolationAwarePrivatenPgViNgRzlnPgpgk(&ulpCookie);
    if (!fActivateActCtxSuccess)
        return CommdlgIsolationAwarePrivateJVaQPGbueRfhYg();
    __try
    {
        if (s_pfn == NULL)
        {
            s_pfn = (PFN)CommdlgIsolationAwarePrivatetRgCebPnQQeRff_pbZQYTQP_QYY("PrintDlgExW");
            if (s_pfn == NULL)
            {
                result = CommdlgIsolationAwarePrivateJVaQPGbueRfhYg();
                __leave;
            }
        }
        result = s_pfn(unnamed1);
    }
    __finally
    {
#ifdef _M_IX86
        if (!IsolationAwarePrivateT_SqbjaYRiRY)
#endif
        {
            (void)IsolationAwareDeactivateActCtx(0, ulpCookie);
        }
    }
    return result;
}

#endif /* defined(STDMETHOD) && (WINVER >= 0x0500) */

ISOLATION_AWARE_INLINE DWORD IsolationAwarePrivatenCv IsolationAwareCommDlgExtendedError(void)
{
    DWORD nResult = 0 ;
    typedef DWORD (WINAPI* PFN)(void);
    static PFN s_pfn;
    ULONG_PTR  ulpCookie = 0;
    const BOOL fActivateActCtxSuccess =
#ifdef _M_IX86
        IsolationAwarePrivateT_SqbjaYRiRY ||
#endif
        IsolationAwarePrivatenPgViNgRzlnPgpgk(&ulpCookie);
    if (!fActivateActCtxSuccess)
        return nResult;
    __try
    {
        if (s_pfn == NULL)
        {
            s_pfn = (PFN)CommdlgIsolationAwarePrivatetRgCebPnQQeRff_pbZQYTQP_QYY("CommDlgExtendedError");
            if (s_pfn == NULL)
                __leave;
        }
        nResult = s_pfn();
    }
    __finally
    {
#ifdef _M_IX86
        if (!IsolationAwarePrivateT_SqbjaYRiRY)
#endif
        {
            const BOOL fPreserveLastError = (nResult == 0 );
            const DWORD dwLastError = fPreserveLastError ? GetLastError() : NO_ERROR;
            (void)IsolationAwareDeactivateActCtx(0, ulpCookie);
            if (fPreserveLastError)
                SetLastError(dwLastError);
        }
    }
    return nResult;
}

ISOLATION_AWARE_INLINE BOOL IsolationAwarePrivatenCv IsolationAwarePageSetupDlgA(LPPAGESETUPDLGA unnamed1)
{
    BOOL fResult = FALSE;
    typedef BOOL (WINAPI* PFN)(LPPAGESETUPDLGA unnamed1);
    static PFN s_pfn;
    ULONG_PTR  ulpCookie = 0;
    const BOOL fActivateActCtxSuccess =
#ifdef _M_IX86
        IsolationAwarePrivateT_SqbjaYRiRY ||
#endif
        IsolationAwarePrivatenPgViNgRzlnPgpgk(&ulpCookie);
    if (!fActivateActCtxSuccess)
        return fResult;
    __try
    {
        if (s_pfn == NULL)
        {
            s_pfn = (PFN)CommdlgIsolationAwarePrivatetRgCebPnQQeRff_pbZQYTQP_QYY("PageSetupDlgA");
            if (s_pfn == NULL)
                __leave;
        }
        fResult = s_pfn(unnamed1);
    }
    __finally
    {
#ifdef _M_IX86
        if (!IsolationAwarePrivateT_SqbjaYRiRY)
#endif
        {
            const BOOL fPreserveLastError = (fResult == FALSE);
            const DWORD dwLastError = fPreserveLastError ? GetLastError() : NO_ERROR;
            (void)IsolationAwareDeactivateActCtx(0, ulpCookie);
            if (fPreserveLastError)
                SetLastError(dwLastError);
        }
    }
    return fResult;
}

ISOLATION_AWARE_INLINE BOOL IsolationAwarePrivatenCv IsolationAwarePageSetupDlgW(LPPAGESETUPDLGW unnamed1)
{
    BOOL fResult = FALSE;
    typedef BOOL (WINAPI* PFN)(LPPAGESETUPDLGW unnamed1);
    static PFN s_pfn;
    ULONG_PTR  ulpCookie = 0;
    const BOOL fActivateActCtxSuccess =
#ifdef _M_IX86
        IsolationAwarePrivateT_SqbjaYRiRY ||
#endif
        IsolationAwarePrivatenPgViNgRzlnPgpgk(&ulpCookie);
    if (!fActivateActCtxSuccess)
        return fResult;
    __try
    {
        if (s_pfn == NULL)
        {
            s_pfn = (PFN)CommdlgIsolationAwarePrivatetRgCebPnQQeRff_pbZQYTQP_QYY("PageSetupDlgW");
            if (s_pfn == NULL)
                __leave;
        }
        fResult = s_pfn(unnamed1);
    }
    __finally
    {
#ifdef _M_IX86
        if (!IsolationAwarePrivateT_SqbjaYRiRY)
#endif
        {
            const BOOL fPreserveLastError = (fResult == FALSE);
            const DWORD dwLastError = fPreserveLastError ? GetLastError() : NO_ERROR;
            (void)IsolationAwareDeactivateActCtx(0, ulpCookie);
            if (fPreserveLastError)
                SetLastError(dwLastError);
        }
    }
    return fResult;
}

ISOLATION_AWARE_INLINE FARPROC IsolationAwarePrivatenCv CommdlgIsolationAwarePrivatetRgCebPnQQeRff_pbZQYTQP_QYY(LPCSTR pszProcName)
/* This function is shared by the other stubs in this header. */
{
    FARPROC proc = NULL;
    static HMODULE s_module;
    BOOL fActivateActCtxSuccess = FALSE;
    ULONG_PTR ulpCookie = 0;
#ifndef _M_CEE_PURE
    const static IsolationAwarePrivatepBAFGnAG_zBqHyr_vAsB
        c = { IsolationAwarePrivatezlybNQyVOeNelJ, L"Comdlg32.dll"
#ifdef _M_IX86
             , IsolationAwarePrivatezlybNQyVOeNeln, "Comdlg32.dll"
#endif
    };
#else
    static IsolationAwarePrivatepBAFGnAG_zBqHyr_vAsB c;
    c.WinbaseIsolationAwarePrivateybNQJ = IsolationAwarePrivatezlybNQyVOeNelJ;
    c.WinbaseIsolationAwarePrivateANZRJ = L"Comdlg32.dll";
#ifdef _M_IX86
    c.WinbaseIsolationAwarePrivateybNQn = IsolationAwarePrivatezlybNQyVOeNeln;
    c.WinbaseIsolationAwarePrivateANZRn = "Comdlg32.dll";
#endif
#endif
    static IsolationAwarePrivatezHGnoyr_zBqHyr_vAsB m;

    __try
    {
#ifdef _M_IX86
        if (!IsolationAwarePrivateT_SqbjaYRiRY)
#endif
        {
            fActivateActCtxSuccess = IsolationAwarePrivatenPgViNgRzlnPgpgk(&ulpCookie);
            if (!fActivateActCtxSuccess)
                __leave;
        }
        proc = IsolationAwarePrivatezltRgCebPnQQeRff(&c, &m, pszProcName);
    }
    __finally
    {
        if (
#ifdef _M_IX86
            !IsolationAwarePrivateT_SqbjaYRiRY &&
#endif
            fActivateActCtxSuccess)
        {
            const DWORD dwLastError = (proc == NULL) ? GetLastError() : NO_ERROR;
            (void)IsolationAwareDeactivateActCtx(0, ulpCookie);
            if (proc == NULL)
                SetLastError(dwLastError);
        }
    }
    return proc;
}

#endif /* ISOLATION_AWARE_USE_STATIC_LIBRARY */

#define ChooseColorA IsolationAwareChooseColorA
#define ChooseColorW IsolationAwareChooseColorW
#define ChooseFontA IsolationAwareChooseFontA
#define ChooseFontW IsolationAwareChooseFontW
#define CommDlgExtendedError IsolationAwareCommDlgExtendedError
#define FindTextA IsolationAwareFindTextA
#define FindTextW IsolationAwareFindTextW
#define GetFileTitleA IsolationAwareGetFileTitleA
#define GetFileTitleW IsolationAwareGetFileTitleW
#define GetOpenFileNameA IsolationAwareGetOpenFileNameA
#define GetOpenFileNameW IsolationAwareGetOpenFileNameW
#define GetSaveFileNameA IsolationAwareGetSaveFileNameA
#define GetSaveFileNameW IsolationAwareGetSaveFileNameW
#define PageSetupDlgA IsolationAwarePageSetupDlgA
#define PageSetupDlgW IsolationAwarePageSetupDlgW
#define PrintDlgA IsolationAwarePrintDlgA
#define PrintDlgExA IsolationAwarePrintDlgExA
#define PrintDlgExW IsolationAwarePrintDlgExW
#define PrintDlgW IsolationAwarePrintDlgW
#define ReplaceTextA IsolationAwareReplaceTextA
#define ReplaceTextW IsolationAwareReplaceTextW

#endif /* ISOLATION_AWARE_ENABLED */
#endif /* RC */


#if defined(__cplusplus)
} /* __cplusplus */
#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\vs9sp1\sdk\include\commctrl.inl ===
/* Copyright (c) 2001-2006, Microsoft Corp. All rights reserved. */

#if _MSC_VER > 1000
#pragma once
#endif

#if defined(__cplusplus)
extern "C" {
#endif


#if !defined(RC_INVOKED) /* RC complains about long symbols in #ifs */
#if defined(ISOLATION_AWARE_ENABLED) && (ISOLATION_AWARE_ENABLED != 0)


#if !defined(ISOLATION_AWARE_USE_STATIC_LIBRARY)
#define ISOLATION_AWARE_USE_STATIC_LIBRARY 0
#endif

#if !defined(ISOLATION_AWARE_BUILD_STATIC_LIBRARY)
#define ISOLATION_AWARE_BUILD_STATIC_LIBRARY 0
#endif

#if !defined(ISOLATION_AWARE_INLINE)
#if ISOLATION_AWARE_BUILD_STATIC_LIBRARY
#define ISOLATION_AWARE_INLINE /* nothing */
#else
#if defined(__cplusplus)
#define ISOLATION_AWARE_INLINE inline
#else
#define ISOLATION_AWARE_INLINE __inline
#endif
#endif
#endif

#if !ISOLATION_AWARE_USE_STATIC_LIBRARY
FARPROC IsolationAwarePrivatenCv CommctrlIsolationAwarePrivatetRgCebPnQQeRff_pbZPgYQP_QYY(LPCSTR pszProcName);

#endif /* ISOLATION_AWARE_USE_STATIC_LIBRARY */

#if !defined(ISOLATIONAWARECOMMCTRL_LPSTREAM)
#if !defined(__IStream_INTERFACE_DEFINED__)
  #if defined(interface)
    interface IStream; typedef interface IStream IStream;
  #else
    struct IStream; typedef struct IStream IStream;
  #endif
#endif
typedef IStream *ISOLATIONAWARECOMMCTRL_LPSTREAM;
#define ISOLATIONAWARECOMMCTRL_LPSTREAM ISOLATIONAWARECOMMCTRL_LPSTREAM
#endif
void IsolationAwarePrivatenCv IsolationAwareInitCommonControls(void);
BOOL IsolationAwarePrivatenCv IsolationAwareInitCommonControlsEx(const INITCOMMONCONTROLSEX*picce);
HIMAGELIST IsolationAwarePrivatenCv IsolationAwareImageList_Create(int cx,int cy,UINT flags,int cInitial,int cGrow);
BOOL IsolationAwarePrivatenCv IsolationAwareImageList_Destroy(HIMAGELIST himl);
int IsolationAwarePrivatenCv IsolationAwareImageList_GetImageCount(HIMAGELIST himl);
BOOL IsolationAwarePrivatenCv IsolationAwareImageList_SetImageCount(HIMAGELIST himl,UINT uNewCount);
int IsolationAwarePrivatenCv IsolationAwareImageList_Add(HIMAGELIST himl,HBITMAP hbmImage,HBITMAP hbmMask);
int IsolationAwarePrivatenCv IsolationAwareImageList_ReplaceIcon(HIMAGELIST himl,int i,HICON hicon);
COLORREF IsolationAwarePrivatenCv IsolationAwareImageList_SetBkColor(HIMAGELIST himl,COLORREF clrBk);
COLORREF IsolationAwarePrivatenCv IsolationAwareImageList_GetBkColor(HIMAGELIST himl);
BOOL IsolationAwarePrivatenCv IsolationAwareImageList_SetOverlayImage(HIMAGELIST himl,int iImage,int iOverlay);
BOOL IsolationAwarePrivatenCv IsolationAwareImageList_Draw(HIMAGELIST himl,int i,HDC hdcDst,int x,int y,UINT fStyle);
BOOL IsolationAwarePrivatenCv IsolationAwareImageList_Replace(HIMAGELIST himl,int i,HBITMAP hbmImage,HBITMAP hbmMask);
int IsolationAwarePrivatenCv IsolationAwareImageList_AddMasked(HIMAGELIST himl,HBITMAP hbmImage,COLORREF crMask);
BOOL IsolationAwarePrivatenCv IsolationAwareImageList_DrawEx(HIMAGELIST himl,int i,HDC hdcDst,int x,int y,int dx,int dy,COLORREF rgbBk,COLORREF rgbFg,UINT fStyle);
BOOL IsolationAwarePrivatenCv IsolationAwareImageList_DrawIndirect(IMAGELISTDRAWPARAMS*pimldp);
BOOL IsolationAwarePrivatenCv IsolationAwareImageList_Remove(HIMAGELIST himl,int i);
HICON IsolationAwarePrivatenCv IsolationAwareImageList_GetIcon(HIMAGELIST himl,int i,UINT flags);
HIMAGELIST IsolationAwarePrivatenCv IsolationAwareImageList_LoadImageA(HINSTANCE hi,LPCSTR lpbmp,int cx,int cGrow,COLORREF crMask,UINT uType,UINT uFlags);
HIMAGELIST IsolationAwarePrivatenCv IsolationAwareImageList_LoadImageW(HINSTANCE hi,LPCWSTR lpbmp,int cx,int cGrow,COLORREF crMask,UINT uType,UINT uFlags);
BOOL IsolationAwarePrivatenCv IsolationAwareImageList_Copy(HIMAGELIST himlDst,int iDst,HIMAGELIST himlSrc,int iSrc,UINT uFlags);
BOOL IsolationAwarePrivatenCv IsolationAwareImageList_BeginDrag(HIMAGELIST himlTrack,int iTrack,int dxHotspot,int dyHotspot);
void IsolationAwarePrivatenCv IsolationAwareImageList_EndDrag(void);
BOOL IsolationAwarePrivatenCv IsolationAwareImageList_DragEnter(HWND hwndLock,int x,int y);
BOOL IsolationAwarePrivatenCv IsolationAwareImageList_DragLeave(HWND hwndLock);
BOOL IsolationAwarePrivatenCv IsolationAwareImageList_DragMove(int x,int y);
BOOL IsolationAwarePrivatenCv IsolationAwareImageList_SetDragCursorImage(HIMAGELIST himlDrag,int iDrag,int dxHotspot,int dyHotspot);
BOOL IsolationAwarePrivatenCv IsolationAwareImageList_DragShowNolock(BOOL fShow);
HIMAGELIST IsolationAwarePrivatenCv IsolationAwareImageList_GetDragImage(POINT*ppt,POINT*pptHotspot);
HIMAGELIST IsolationAwarePrivatenCv IsolationAwareImageList_Read(ISOLATIONAWARECOMMCTRL_LPSTREAM pstm);
BOOL IsolationAwarePrivatenCv IsolationAwareImageList_Write(HIMAGELIST himl,ISOLATIONAWARECOMMCTRL_LPSTREAM pstm);
#if (_WIN32_WINNT >= 0x0501)
HRESULT IsolationAwarePrivatenCv IsolationAwareImageList_ReadEx(DWORD dwFlags,ISOLATIONAWARECOMMCTRL_LPSTREAM pstm,REFIID riid,PVOID*ppv);
HRESULT IsolationAwarePrivatenCv IsolationAwareImageList_WriteEx(HIMAGELIST himl,DWORD dwFlags,ISOLATIONAWARECOMMCTRL_LPSTREAM pstm);
#endif /* (_WIN32_WINNT >= 0x0501) */
BOOL IsolationAwarePrivatenCv IsolationAwareImageList_GetIconSize(HIMAGELIST himl,int*cx,int*cy);
BOOL IsolationAwarePrivatenCv IsolationAwareImageList_SetIconSize(HIMAGELIST himl,int cx,int cy);
BOOL IsolationAwarePrivatenCv IsolationAwareImageList_GetImageInfo(HIMAGELIST himl,int i,IMAGEINFO*pImageInfo);
HIMAGELIST IsolationAwarePrivatenCv IsolationAwareImageList_Merge(HIMAGELIST himl1,int i1,HIMAGELIST himl2,int i2,int dx,int dy);
HIMAGELIST IsolationAwarePrivatenCv IsolationAwareImageList_Duplicate(HIMAGELIST himl);
HRESULT IsolationAwarePrivatenCv IsolationAwareHIMAGELIST_QueryInterface(HIMAGELIST himl,REFIID riid,void**ppv);
HWND IsolationAwarePrivatenCv IsolationAwareCreateToolbarEx(HWND hwnd,DWORD ws,UINT wID,int nBitmaps,HINSTANCE hBMInst,UINT_PTR wBMID,LPCTBBUTTON lpButtons,int iNumButtons,int dxButton,int dyButton,int dxBitmap,int dyBitmap,UINT uStructSize);
HBITMAP IsolationAwarePrivatenCv IsolationAwareCreateMappedBitmap(HINSTANCE hInstance,INT_PTR idBitmap,UINT wFlags,__in_opt LPCOLORMAP lpColorMap,int iNumMaps);
void IsolationAwarePrivatenCv IsolationAwareDrawStatusTextA(HDC hDC,LPCRECT lprc,LPCSTR pszText,UINT uFlags);
void IsolationAwarePrivatenCv IsolationAwareDrawStatusTextW(HDC hDC,LPCRECT lprc,LPCWSTR pszText,UINT uFlags);
HWND IsolationAwarePrivatenCv IsolationAwareCreateStatusWindowA(long style,LPCSTR lpszText,HWND hwndParent,UINT wID);
HWND IsolationAwarePrivatenCv IsolationAwareCreateStatusWindowW(long style,LPCWSTR lpszText,HWND hwndParent,UINT wID);
void IsolationAwarePrivatenCv IsolationAwareMenuHelp(UINT uMsg,WPARAM wParam,LPARAM lParam,HMENU hMainMenu,HINSTANCE hInst,HWND hwndStatus,__in_ecount(4) UINT*lpwIDs);
BOOL IsolationAwarePrivatenCv IsolationAwareShowHideMenuCtl(HWND hWnd,UINT_PTR uFlags,__in __nullterminated LPINT lpInfo);
void IsolationAwarePrivatenCv IsolationAwareGetEffectiveClientRect(HWND hWnd,LPRECT lprc,__in __nullterminated const int*lpInfo);
BOOL IsolationAwarePrivatenCv IsolationAwareMakeDragList(HWND hLB);
void IsolationAwarePrivatenCv IsolationAwareDrawInsert(HWND handParent,HWND hLB,int nItem);
int IsolationAwarePrivatenCv IsolationAwareLBItemFromPt(HWND hLB,POINT pt,BOOL bAutoScroll);
HWND IsolationAwarePrivatenCv IsolationAwareCreateUpDownControl(DWORD dwStyle,int x,int y,int cx,int cy,HWND hParent,int nID,HINSTANCE hInst,HWND hBuddy,int nUpper,int nLower,int nPos);
HRESULT IsolationAwarePrivatenCv IsolationAwareTaskDialogIndirect(const TASKDIALOGCONFIG*pTaskConfig,__out_opt int*pnButton,__out_opt int*pnRadioButton,__out_opt BOOL*pfVerificationFlagChecked);
HRESULT IsolationAwarePrivatenCv IsolationAwareTaskDialog(__in_opt HWND hwndParent,__in_opt HINSTANCE hInstance,__in_opt PCWSTR pszWindowTitle,__in_opt PCWSTR pszMainInstruction,__in_opt PCWSTR pszContent,TASKDIALOG_COMMON_BUTTON_FLAGS dwCommonButtons,__in_opt PCWSTR pszIcon,__out_opt int*pnButton);
void IsolationAwarePrivatenCv IsolationAwareInitMUILanguage(LANGID uiLang);
LANGID IsolationAwarePrivatenCv IsolationAwareGetMUILanguage(void);
HDSA IsolationAwarePrivatenCv IsolationAwareDSA_Create(int cbItem,int cItemGrow);
BOOL IsolationAwarePrivatenCv IsolationAwareDSA_Destroy(__in HDSA hdsa);
void IsolationAwarePrivatenCv IsolationAwareDSA_DestroyCallback(__in HDSA hdsa,__in PFNDAENUMCALLBACK pfnCB,__in_opt void*pData);
BOOL IsolationAwarePrivatenCv IsolationAwareDSA_DeleteItem(__in HDSA hdsa,__in int i);
BOOL IsolationAwarePrivatenCv IsolationAwareDSA_DeleteAllItems(__in HDSA hdsa);
void IsolationAwarePrivatenCv IsolationAwareDSA_EnumCallback(__in HDSA hdsa,__in PFNDAENUMCALLBACK pfnCB,__in_opt void*pData);
int IsolationAwarePrivatenCv IsolationAwareDSA_InsertItem(__in HDSA hdsa,__in int i,__in const void*pitem);
PVOID IsolationAwarePrivatenCv IsolationAwareDSA_GetItemPtr(__in HDSA hdsa,__in int i);
BOOL IsolationAwarePrivatenCv IsolationAwareDSA_GetItem(__in HDSA hdsa,__in int i,__out_xcount(pdsa->cbItem) void*pitem);
BOOL IsolationAwarePrivatenCv IsolationAwareDSA_SetItem(__in HDSA hdsa,__in int i,__in const void*pitem);
HDSA IsolationAwarePrivatenCv IsolationAwareDSA_Clone(__in HDSA hdsa);
ULONGLONG IsolationAwarePrivatenCv IsolationAwareDSA_GetSize(__in HDSA hdsa);
BOOL IsolationAwarePrivatenCv IsolationAwareDSA_Sort(__in HDSA pdsa,__in PFNDACOMPARE pfnCompare,__in LPARAM lParam);
HDPA IsolationAwarePrivatenCv IsolationAwareDPA_Create(int cItemGrow);
HDPA IsolationAwarePrivatenCv IsolationAwareDPA_CreateEx(__in int cpGrow,__in_opt HANDLE hheap);
HDPA IsolationAwarePrivatenCv IsolationAwareDPA_Clone(__in const HDPA hdpa,__in HDPA hdpaNew);
BOOL IsolationAwarePrivatenCv IsolationAwareDPA_Destroy(__in HDPA hdpa);
void IsolationAwarePrivatenCv IsolationAwareDPA_DestroyCallback(__in HDPA hdpa,__in PFNDAENUMCALLBACK pfnCB,__in_opt void*pData);
PVOID IsolationAwarePrivatenCv IsolationAwareDPA_DeletePtr(__in HDPA hdpa,__in int i);
BOOL IsolationAwarePrivatenCv IsolationAwareDPA_DeleteAllPtrs(__in HDPA hdpa);
void IsolationAwarePrivatenCv IsolationAwareDPA_EnumCallback(__in HDPA hdpa,__in PFNDAENUMCALLBACK pfnCB,__in_opt void*pData);
BOOL IsolationAwarePrivatenCv IsolationAwareDPA_Grow(__in HDPA pdpa,__in int cp);
int IsolationAwarePrivatenCv IsolationAwareDPA_InsertPtr(__in HDPA hdpa,__in int i,__in_opt void*p);
BOOL IsolationAwarePrivatenCv IsolationAwareDPA_SetPtr(__in HDPA hdpa,__in int i,__in_opt void*p);
PVOID IsolationAwarePrivatenCv IsolationAwareDPA_GetPtr(__in HDPA hdpa,__in INT_PTR i);
int IsolationAwarePrivatenCv IsolationAwareDPA_GetPtrIndex(__in HDPA hdpa,__in const void*p);
ULONGLONG IsolationAwarePrivatenCv IsolationAwareDPA_GetSize(__in HDPA hdpa);
BOOL IsolationAwarePrivatenCv IsolationAwareDPA_Sort(__in HDPA hdpa,__in PFNDACOMPARE pfnCompare,__in LPARAM lParam);
HRESULT IsolationAwarePrivatenCv IsolationAwareDPA_LoadStream(__out HDPA*phdpa,__in PFNDPASTREAM pfn,__in struct IStream*pstream,__in_opt void*pvInstData);
HRESULT IsolationAwarePrivatenCv IsolationAwareDPA_SaveStream(__in HDPA hdpa,__in PFNDPASTREAM pfn,__in struct IStream*pstream,__in_opt void*pvInstData);
BOOL IsolationAwarePrivatenCv IsolationAwareDPA_Merge(__in HDPA hdpaDest,__in HDPA hdpaSrc,__in DWORD dwFlags,__in PFNDACOMPARE pfnCompare,__in PFNDPAMERGE pfnMerge,__in LPARAM lParam);
int IsolationAwarePrivatenCv IsolationAwareDPA_Search(__in HDPA hdpa,__in_opt void*pFind,__in int iStart,__in PFNDACOMPARE pfnCompare,__in LPARAM lParam,__in UINT options);
BOOL IsolationAwarePrivatenCv IsolationAwareStr_SetPtrW(__deref_inout_opt LPWSTR*ppsz,LPCWSTR psz);
#if !defined(NOTRACKMOUSEEVENT)
BOOL IsolationAwarePrivatenCv IsolationAware_TrackMouseEvent(__inout LPTRACKMOUSEEVENT lpEventTrack);
#endif /* !defined(NOTRACKMOUSEEVENT) */
BOOL IsolationAwarePrivatenCv IsolationAwareFlatSB_EnableScrollBar(HWND unnamed1,int unnamed2,UINT unnamed3);
BOOL IsolationAwarePrivatenCv IsolationAwareFlatSB_ShowScrollBar(HWND unnamed1,int code,BOOL unnamed2);
BOOL IsolationAwarePrivatenCv IsolationAwareFlatSB_GetScrollRange(HWND unnamed1,int code,LPINT unnamed2,LPINT unnamed3);
BOOL IsolationAwarePrivatenCv IsolationAwareFlatSB_GetScrollInfo(HWND unnamed1,int code,LPSCROLLINFO unnamed2);
int IsolationAwarePrivatenCv IsolationAwareFlatSB_GetScrollPos(HWND unnamed1,int code);
BOOL IsolationAwarePrivatenCv IsolationAwareFlatSB_GetScrollProp(HWND unnamed1,int propIndex,LPINT unnamed2);
BOOL IsolationAwarePrivatenCv IsolationAwareFlatSB_GetScrollPropPtr(HWND unnamed1,int propIndex,PINT_PTR unnamed2);
int IsolationAwarePrivatenCv IsolationAwareFlatSB_SetScrollPos(HWND unnamed1,int code,int pos,BOOL fRedraw);
int IsolationAwarePrivatenCv IsolationAwareFlatSB_SetScrollInfo(HWND unnamed1,int code,LPSCROLLINFO psi,BOOL fRedraw);
int IsolationAwarePrivatenCv IsolationAwareFlatSB_SetScrollRange(HWND unnamed1,int code,int min,int max,BOOL fRedraw);
BOOL IsolationAwarePrivatenCv IsolationAwareFlatSB_SetScrollProp(HWND unnamed1,UINT index,INT_PTR newValue,BOOL unnamed2);
BOOL IsolationAwarePrivatenCv IsolationAwareInitializeFlatSB(HWND unnamed1);
HRESULT IsolationAwarePrivatenCv IsolationAwareUninitializeFlatSB(HWND unnamed1);
#if (_WIN32_IE >= 0x560)
BOOL IsolationAwarePrivatenCv IsolationAwareSetWindowSubclass(HWND hWnd,SUBCLASSPROC pfnSubclass,UINT_PTR uIdSubclass,DWORD_PTR dwRefData);
BOOL IsolationAwarePrivatenCv IsolationAwareGetWindowSubclass(HWND hWnd,SUBCLASSPROC pfnSubclass,UINT_PTR uIdSubclass,DWORD_PTR*pdwRefData);
BOOL IsolationAwarePrivatenCv IsolationAwareRemoveWindowSubclass(HWND hWnd,SUBCLASSPROC pfnSubclass,UINT_PTR uIdSubclass);
#endif /* (_WIN32_IE >= 0x560) */
LRESULT IsolationAwarePrivatenCv IsolationAwareDefSubclassProc(HWND hWnd,UINT uMsg,WPARAM wParam,LPARAM lParam);
HRESULT IsolationAwarePrivatenCv IsolationAwareLoadIconMetric(HINSTANCE hinst,PCWSTR pszName,int lims,__out HICON*phico);
HRESULT IsolationAwarePrivatenCv IsolationAwareLoadIconWithScaleDown(HINSTANCE hinst,PCWSTR pszName,int cx,int cy,__out HICON*phico);
int IsolationAwarePrivatenCv IsolationAwareDrawShadowText(HDC hdc,__in_ecount(cch) LPCWSTR pszText,UINT cch,RECT*prc,DWORD dwFlags,COLORREF crText,COLORREF crShadow,int ixOffset,int iyOffset);

ISOLATION_AWARE_INLINE HRESULT CommctrlIsolationAwarePrivateJVaQPGbueRfhYg(void)
{
    DWORD dwLastError = GetLastError();
    if (dwLastError == NO_ERROR)
        dwLastError = ERROR_INTERNAL_ERROR;
    return HRESULT_FROM_WIN32(dwLastError);
}

#if defined(UNICODE)

#define IsolationAwareCreateStatusWindow IsolationAwareCreateStatusWindowW
#define IsolationAwareDrawStatusText IsolationAwareDrawStatusTextW
#define IsolationAwareImageList_LoadImage IsolationAwareImageList_LoadImageW

#else /* UNICODE */

#define IsolationAwareCreateStatusWindow IsolationAwareCreateStatusWindowA
#define IsolationAwareDrawStatusText IsolationAwareDrawStatusTextA
#define IsolationAwareImageList_LoadImage IsolationAwareImageList_LoadImageA

#endif /* UNICODE */

#if !ISOLATION_AWARE_USE_STATIC_LIBRARY
ISOLATION_AWARE_INLINE void IsolationAwarePrivatenCv IsolationAwareInitCommonControls(void)
{
    typedef void (WINAPI* PFN)(void);
    static PFN s_pfn;
    ULONG_PTR  ulpCookie = 0;
    const BOOL fActivateActCtxSuccess =
#ifdef _M_IX86
        IsolationAwarePrivateT_SqbjaYRiRY ||
#endif
        IsolationAwarePrivatenPgViNgRzlnPgpgk(&ulpCookie);
    if (!fActivateActCtxSuccess)
        return;
    __try
    {
        if (s_pfn == NULL)
        {
            s_pfn = (PFN)CommctrlIsolationAwarePrivatetRgCebPnQQeRff_pbZPgYQP_QYY("InitCommonControls");
            if (s_pfn == NULL)
                __leave;
        }
        s_pfn();
    }
    __finally
    {
#ifdef _M_IX86
        if (!IsolationAwarePrivateT_SqbjaYRiRY)
#endif
        {
            (void)IsolationAwareDeactivateActCtx(0, ulpCookie);
        }
    }
    return;
}

ISOLATION_AWARE_INLINE BOOL IsolationAwarePrivatenCv IsolationAwareInitCommonControlsEx(const INITCOMMONCONTROLSEX*picce)
{
    BOOL fResult = FALSE;
    typedef BOOL (WINAPI* PFN)(const INITCOMMONCONTROLSEX*picce);
    static PFN s_pfn;
    ULONG_PTR  ulpCookie = 0;
    const BOOL fActivateActCtxSuccess =
#ifdef _M_IX86
        IsolationAwarePrivateT_SqbjaYRiRY ||
#endif
        IsolationAwarePrivatenPgViNgRzlnPgpgk(&ulpCookie);
    if (!fActivateActCtxSuccess)
        return fResult;
    __try
    {
        if (s_pfn == NULL)
        {
            s_pfn = (PFN)CommctrlIsolationAwarePrivatetRgCebPnQQeRff_pbZPgYQP_QYY("InitCommonControlsEx");
            if (s_pfn == NULL)
                __leave;
        }
        fResult = s_pfn(picce);
    }
    __finally
    {
#ifdef _M_IX86
        if (!IsolationAwarePrivateT_SqbjaYRiRY)
#endif
        {
            const BOOL fPreserveLastError = (fResult == FALSE);
            const DWORD dwLastError = fPreserveLastError ? GetLastError() : NO_ERROR;
            (void)IsolationAwareDeactivateActCtx(0, ulpCookie);
            if (fPreserveLastError)
                SetLastError(dwLastError);
        }
    }
    return fResult;
}

ISOLATION_AWARE_INLINE HIMAGELIST IsolationAwarePrivatenCv IsolationAwareImageList_Create(int cx,int cy,UINT flags,int cInitial,int cGrow)
{
    HIMAGELIST imagelistResult = NULL;
    typedef HIMAGELIST (WINAPI* PFN)(int cx,int cy,UINT flags,int cInitial,int cGrow);
    static PFN s_pfn;
    ULONG_PTR  ulpCookie = 0;
    const BOOL fActivateActCtxSuccess =
#ifdef _M_IX86
        IsolationAwarePrivateT_SqbjaYRiRY ||
#endif
        IsolationAwarePrivatenPgViNgRzlnPgpgk(&ulpCookie);
    if (!fActivateActCtxSuccess)
        return imagelistResult;
    __try
    {
        if (s_pfn == NULL)
        {
            s_pfn = (PFN)CommctrlIsolationAwarePrivatetRgCebPnQQeRff_pbZPgYQP_QYY("ImageList_Create");
            if (s_pfn == NULL)
                __leave;
        }
        imagelistResult = s_pfn(cx,cy,flags,cInitial,cGrow);
    }
    __finally
    {
#ifdef _M_IX86
        if (!IsolationAwarePrivateT_SqbjaYRiRY)
#endif
        {
            const BOOL fPreserveLastError = (imagelistResult == NULL);
            const DWORD dwLastError = fPreserveLastError ? GetLastError() : NO_ERROR;
            (void)IsolationAwareDeactivateActCtx(0, ulpCookie);
            if (fPreserveLastError)
                SetLastError(dwLastError);
        }
    }
    return imagelistResult;
}

ISOLATION_AWARE_INLINE BOOL IsolationAwarePrivatenCv IsolationAwareImageList_Destroy(HIMAGELIST himl)
{
    BOOL fResult = FALSE;
    typedef BOOL (WINAPI* PFN)(HIMAGELIST himl);
    static PFN s_pfn;
    ULONG_PTR  ulpCookie = 0;
    const BOOL fActivateActCtxSuccess =
#ifdef _M_IX86
        IsolationAwarePrivateT_SqbjaYRiRY ||
#endif
        IsolationAwarePrivatenPgViNgRzlnPgpgk(&ulpCookie);
    if (!fActivateActCtxSuccess)
        return fResult;
    __try
    {
        if (s_pfn == NULL)
        {
            s_pfn = (PFN)CommctrlIsolationAwarePrivatetRgCebPnQQeRff_pbZPgYQP_QYY("ImageList_Destroy");
            if (s_pfn == NULL)
                __leave;
        }
        fResult = s_pfn(himl);
    }
    __finally
    {
#ifdef _M_IX86
        if (!IsolationAwarePrivateT_SqbjaYRiRY)
#endif
        {
            const BOOL fPreserveLastError = (fResult == FALSE);
            const DWORD dwLastError = fPreserveLastError ? GetLastError() : NO_ERROR;
            (void)IsolationAwareDeactivateActCtx(0, ulpCookie);
            if (fPreserveLastError)
                SetLastError(dwLastError);
        }
    }
    return fResult;
}

ISOLATION_AWARE_INLINE int IsolationAwarePrivatenCv IsolationAwareImageList_GetImageCount(HIMAGELIST himl)
{
    int nResult = 0 ;
    typedef int (WINAPI* PFN)(HIMAGELIST himl);
    static PFN s_pfn;
    ULONG_PTR  ulpCookie = 0;
    const BOOL fActivateActCtxSuccess =
#ifdef _M_IX86
        IsolationAwarePrivateT_SqbjaYRiRY ||
#endif
        IsolationAwarePrivatenPgViNgRzlnPgpgk(&ulpCookie);
    if (!fActivateActCtxSuccess)
        return nResult;
    __try
    {
        if (s_pfn == NULL)
        {
            s_pfn = (PFN)CommctrlIsolationAwarePrivatetRgCebPnQQeRff_pbZPgYQP_QYY("ImageList_GetImageCount");
            if (s_pfn == NULL)
                __leave;
        }
        nResult = s_pfn(himl);
    }
    __finally
    {
#ifdef _M_IX86
        if (!IsolationAwarePrivateT_SqbjaYRiRY)
#endif
        {
            const BOOL fPreserveLastError = (nResult == 0 );
            const DWORD dwLastError = fPreserveLastError ? GetLastError() : NO_ERROR;
            (void)IsolationAwareDeactivateActCtx(0, ulpCookie);
            if (fPreserveLastError)
                SetLastError(dwLastError);
        }
    }
    return nResult;
}

ISOLATION_AWARE_INLINE BOOL IsolationAwarePrivatenCv IsolationAwareImageList_SetImageCount(HIMAGELIST himl,UINT uNewCount)
{
    BOOL fResult = FALSE;
    typedef BOOL (WINAPI* PFN)(HIMAGELIST himl,UINT uNewCount);
    static PFN s_pfn;
    ULONG_PTR  ulpCookie = 0;
    const BOOL fActivateActCtxSuccess =
#ifdef _M_IX86
        IsolationAwarePrivateT_SqbjaYRiRY ||
#endif
        IsolationAwarePrivatenPgViNgRzlnPgpgk(&ulpCookie);
    if (!fActivateActCtxSuccess)
        return fResult;
    __try
    {
        if (s_pfn == NULL)
        {
            s_pfn = (PFN)CommctrlIsolationAwarePrivatetRgCebPnQQeRff_pbZPgYQP_QYY("ImageList_SetImageCount");
            if (s_pfn == NULL)
                __leave;
        }
        fResult = s_pfn(himl,uNewCount);
    }
    __finally
    {
#ifdef _M_IX86
        if (!IsolationAwarePrivateT_SqbjaYRiRY)
#endif
        {
            const BOOL fPreserveLastError = (fResult == FALSE);
            const DWORD dwLastError = fPreserveLastError ? GetLastError() : NO_ERROR;
            (void)IsolationAwareDeactivateActCtx(0, ulpCookie);
            if (fPreserveLastError)
                SetLastError(dwLastError);
        }
    }
    return fResult;
}

ISOLATION_AWARE_INLINE int IsolationAwarePrivatenCv IsolationAwareImageList_Add(HIMAGELIST himl,HBITMAP hbmImage,HBITMAP hbmMask)
{
    int nResult = -1;
    typedef int (WINAPI* PFN)(HIMAGELIST himl,HBITMAP hbmImage,HBITMAP hbmMask);
    static PFN s_pfn;
    ULONG_PTR  ulpCookie = 0;
    const BOOL fActivateActCtxSuccess =
#ifdef _M_IX86
        IsolationAwarePrivateT_SqbjaYRiRY ||
#endif
        IsolationAwarePrivatenPgViNgRzlnPgpgk(&ulpCookie);
    if (!fActivateActCtxSuccess)
        return nResult;
    __try
    {
        if (s_pfn == NULL)
        {
            s_pfn = (PFN)CommctrlIsolationAwarePrivatetRgCebPnQQeRff_pbZPgYQP_QYY("ImageList_Add");
            if (s_pfn == NULL)
                __leave;
        }
        nResult = s_pfn(himl,hbmImage,hbmMask);
    }
    __finally
    {
#ifdef _M_IX86
        if (!IsolationAwarePrivateT_SqbjaYRiRY)
#endif
        {
            const BOOL fPreserveLastError = (nResult == -1);
            const DWORD dwLastError = fPreserveLastError ? GetLastError() : NO_ERROR;
            (void)IsolationAwareDeactivateActCtx(0, ulpCookie);
            if (fPreserveLastError)
                SetLastError(dwLastError);
        }
    }
    return nResult;
}

ISOLATION_AWARE_INLINE int IsolationAwarePrivatenCv IsolationAwareImageList_ReplaceIcon(HIMAGELIST himl,int i,HICON hicon)
{
    int nResult = -1;
    typedef int (WINAPI* PFN)(HIMAGELIST himl,int i,HICON hicon);
    static PFN s_pfn;
    ULONG_PTR  ulpCookie = 0;
    const BOOL fActivateActCtxSuccess =
#ifdef _M_IX86
        IsolationAwarePrivateT_SqbjaYRiRY ||
#endif
        IsolationAwarePrivatenPgViNgRzlnPgpgk(&ulpCookie);
    if (!fActivateActCtxSuccess)
        return nResult;
    __try
    {
        if (s_pfn == NULL)
        {
            s_pfn = (PFN)CommctrlIsolationAwarePrivatetRgCebPnQQeRff_pbZPgYQP_QYY("ImageList_ReplaceIcon");
            if (s_pfn == NULL)
                __leave;
        }
        nResult = s_pfn(himl,i,hicon);
    }
    __finally
    {
#ifdef _M_IX86
        if (!IsolationAwarePrivateT_SqbjaYRiRY)
#endif
        {
            const BOOL fPreserveLastError = (nResult == -1);
            const DWORD dwLastError = fPreserveLastError ? GetLastError() : NO_ERROR;
            (void)IsolationAwareDeactivateActCtx(0, ulpCookie);
            if (fPreserveLastError)
                SetLastError(dwLastError);
        }
    }
    return nResult;
}

ISOLATION_AWARE_INLINE COLORREF IsolationAwarePrivatenCv IsolationAwareImageList_SetBkColor(HIMAGELIST himl,COLORREF clrBk)
{
    COLORREF colorResult = RGB(0,0,0);
    typedef COLORREF (WINAPI* PFN)(HIMAGELIST himl,COLORREF clrBk);
    static PFN s_pfn;
    ULONG_PTR  ulpCookie = 0;
    const BOOL fActivateActCtxSuccess =
#ifdef _M_IX86
        IsolationAwarePrivateT_SqbjaYRiRY ||
#endif
        IsolationAwarePrivatenPgViNgRzlnPgpgk(&ulpCookie);
    if (!fActivateActCtxSuccess)
        return colorResult;
    __try
    {
        if (s_pfn == NULL)
        {
            s_pfn = (PFN)CommctrlIsolationAwarePrivatetRgCebPnQQeRff_pbZPgYQP_QYY("ImageList_SetBkColor");
            if (s_pfn == NULL)
                __leave;
        }
        colorResult = s_pfn(himl,clrBk);
    }
    __finally
    {
#ifdef _M_IX86
        if (!IsolationAwarePrivateT_SqbjaYRiRY)
#endif
        {
            const BOOL fPreserveLastError = (colorResult == RGB(0,0,0));
            const DWORD dwLastError = fPreserveLastError ? GetLastError() : NO_ERROR;
            (void)IsolationAwareDeactivateActCtx(0, ulpCookie);
            if (fPreserveLastError)
                SetLastError(dwLastError);
        }
    }
    return colorResult;
}

ISOLATION_AWARE_INLINE COLORREF IsolationAwarePrivatenCv IsolationAwareImageList_GetBkColor(HIMAGELIST himl)
{
    COLORREF colorResult = RGB(0,0,0);
    typedef COLORREF (WINAPI* PFN)(HIMAGELIST himl);
    static PFN s_pfn;
    ULONG_PTR  ulpCookie = 0;
    const BOOL fActivateActCtxSuccess =
#ifdef _M_IX86
        IsolationAwarePrivateT_SqbjaYRiRY ||
#endif
        IsolationAwarePrivatenPgViNgRzlnPgpgk(&ulpCookie);
    if (!fActivateActCtxSuccess)
        return colorResult;
    __try
    {
        if (s_pfn == NULL)
        {
            s_pfn = (PFN)CommctrlIsolationAwarePrivatetRgCebPnQQeRff_pbZPgYQP_QYY("ImageList_GetBkColor");
            if (s_pfn == NULL)
                __leave;
        }
        colorResult = s_pfn(himl);
    }
    __finally
    {
#ifdef _M_IX86
        if (!IsolationAwarePrivateT_SqbjaYRiRY)
#endif
        {
            const BOOL fPreserveLastError = (colorResult == RGB(0,0,0));
            const DWORD dwLastError = fPreserveLastError ? GetLastError() : NO_ERROR;
            (void)IsolationAwareDeactivateActCtx(0, ulpCookie);
            if (fPreserveLastError)
                SetLastError(dwLastError);
        }
    }
    return colorResult;
}

ISOLATION_AWARE_INLINE BOOL IsolationAwarePrivatenCv IsolationAwareImageList_SetOverlayImage(HIMAGELIST himl,int iImage,int iOverlay)
{
    BOOL fResult = FALSE;
    typedef BOOL (WINAPI* PFN)(HIMAGELIST himl,int iImage,int iOverlay);
    static PFN s_pfn;
    ULONG_PTR  ulpCookie = 0;
    const BOOL fActivateActCtxSuccess =
#ifdef _M_IX86
        IsolationAwarePrivateT_SqbjaYRiRY ||
#endif
        IsolationAwarePrivatenPgViNgRzlnPgpgk(&ulpCookie);
    if (!fActivateActCtxSuccess)
        return fResult;
    __try
    {
        if (s_pfn == NULL)
        {
            s_pfn = (PFN)CommctrlIsolationAwarePrivatetRgCebPnQQeRff_pbZPgYQP_QYY("ImageList_SetOverlayImage");
            if (s_pfn == NULL)
                __leave;
        }
        fResult = s_pfn(himl,iImage,iOverlay);
    }
    __finally
    {
#ifdef _M_IX86
        if (!IsolationAwarePrivateT_SqbjaYRiRY)
#endif
        {
            const BOOL fPreserveLastError = (fResult == FALSE);
            const DWORD dwLastError = fPreserveLastError ? GetLastError() : NO_ERROR;
            (void)IsolationAwareDeactivateActCtx(0, ulpCookie);
            if (fPreserveLastError)
                SetLastError(dwLastError);
        }
    }
    return fResult;
}

ISOLATION_AWARE_INLINE BOOL IsolationAwarePrivatenCv IsolationAwareImageList_Draw(HIMAGELIST himl,int i,HDC hdcDst,int x,int y,UINT fStyle)
{
    BOOL fResult = FALSE;
    typedef BOOL (WINAPI* PFN)(HIMAGELIST himl,int i,HDC hdcDst,int x,int y,UINT fStyle);
    static PFN s_pfn;
    ULONG_PTR  ulpCookie = 0;
    const BOOL fActivateActCtxSuccess =
#ifdef _M_IX86
        IsolationAwarePrivateT_SqbjaYRiRY ||
#endif
        IsolationAwarePrivatenPgViNgRzlnPgpgk(&ulpCookie);
    if (!fActivateActCtxSuccess)
        return fResult;
    __try
    {
        if (s_pfn == NULL)
        {
            s_pfn = (PFN)CommctrlIsolationAwarePrivatetRgCebPnQQeRff_pbZPgYQP_QYY("ImageList_Draw");
            if (s_pfn == NULL)
                __leave;
        }
        fResult = s_pfn(himl,i,hdcDst,x,y,fStyle);
    }
    __finally
    {
#ifdef _M_IX86
        if (!IsolationAwarePrivateT_SqbjaYRiRY)
#endif
        {
            const BOOL fPreserveLastError = (fResult == FALSE);
            const DWORD dwLastError = fPreserveLastError ? GetLastError() : NO_ERROR;
            (void)IsolationAwareDeactivateActCtx(0, ulpCookie);
            if (fPreserveLastError)
                SetLastError(dwLastError);
        }
    }
    return fResult;
}

ISOLATION_AWARE_INLINE BOOL IsolationAwarePrivatenCv IsolationAwareImageList_Replace(HIMAGELIST himl,int i,HBITMAP hbmImage,HBITMAP hbmMask)
{
    BOOL fResult = FALSE;
    typedef BOOL (WINAPI* PFN)(HIMAGELIST himl,int i,HBITMAP hbmImage,HBITMAP hbmMask);
    static PFN s_pfn;
    ULONG_PTR  ulpCookie = 0;
    const BOOL fActivateActCtxSuccess =
#ifdef _M_IX86
        IsolationAwarePrivateT_SqbjaYRiRY ||
#endif
        IsolationAwarePrivatenPgViNgRzlnPgpgk(&ulpCookie);
    if (!fActivateActCtxSuccess)
        return fResult;
    __try
    {
        if (s_pfn == NULL)
        {
            s_pfn = (PFN)CommctrlIsolationAwarePrivatetRgCebPnQQeRff_pbZPgYQP_QYY("ImageList_Replace");
            if (s_pfn == NULL)
                __leave;
        }
        fResult = s_pfn(himl,i,hbmImage,hbmMask);
    }
    __finally
    {
#ifdef _M_IX86
        if (!IsolationAwarePrivateT_SqbjaYRiRY)
#endif
        {
            const BOOL fPreserveLastError = (fResult == FALSE);
            const DWORD dwLastError = fPreserveLastError ? GetLastError() : NO_ERROR;
            (void)IsolationAwareDeactivateActCtx(0, ulpCookie);
            if (fPreserveLastError)
                SetLastError(dwLastError);
        }
    }
    return fResult;
}

ISOLATION_AWARE_INLINE int IsolationAwarePrivatenCv IsolationAwareImageList_AddMasked(HIMAGELIST himl,HBITMAP hbmImage,COLORREF crMask)
{
    int nResult = -1;
    typedef int (WINAPI* PFN)(HIMAGELIST himl,HBITMAP hbmImage,COLORREF crMask);
    static PFN s_pfn;
    ULONG_PTR  ulpCookie = 0;
    const BOOL fActivateActCtxSuccess =
#ifdef _M_IX86
        IsolationAwarePrivateT_SqbjaYRiRY ||
#endif
        IsolationAwarePrivatenPgViNgRzlnPgpgk(&ulpCookie);
    if (!fActivateActCtxSuccess)
        return nResult;
    __try
    {
        if (s_pfn == NULL)
        {
            s_pfn = (PFN)CommctrlIsolationAwarePrivatetRgCebPnQQeRff_pbZPgYQP_QYY("ImageList_AddMasked");
            if (s_pfn == NULL)
                __leave;
        }
        nResult = s_pfn(himl,hbmImage,crMask);
    }
    __finally
    {
#ifdef _M_IX86
        if (!IsolationAwarePrivateT_SqbjaYRiRY)
#endif
        {
            const BOOL fPreserveLastError = (nResult == -1);
            const DWORD dwLastError = fPreserveLastError ? GetLastError() : NO_ERROR;
            (void)IsolationAwareDeactivateActCtx(0, ulpCookie);
            if (fPreserveLastError)
                SetLastError(dwLastError);
        }
    }
    return nResult;
}

ISOLATION_AWARE_INLINE BOOL IsolationAwarePrivatenCv IsolationAwareImageList_DrawEx(HIMAGELIST himl,int i,HDC hdcDst,int x,int y,int dx,int dy,COLORREF rgbBk,COLORREF rgbFg,UINT fStyle)
{
    BOOL fResult = FALSE;
    typedef BOOL (WINAPI* PFN)(HIMAGELIST himl,int i,HDC hdcDst,int x,int y,int dx,int dy,COLORREF rgbBk,COLORREF rgbFg,UINT fStyle);
    static PFN s_pfn;
    ULONG_PTR  ulpCookie = 0;
    const BOOL fActivateActCtxSuccess =
#ifdef _M_IX86
        IsolationAwarePrivateT_SqbjaYRiRY ||
#endif
        IsolationAwarePrivatenPgViNgRzlnPgpgk(&ulpCookie);
    if (!fActivateActCtxSuccess)
        return fResult;
    __try
    {
        if (s_pfn == NULL)
        {
            s_pfn = (PFN)CommctrlIsolationAwarePrivatetRgCebPnQQeRff_pbZPgYQP_QYY("ImageList_DrawEx");
            if (s_pfn == NULL)
                __leave;
        }
        fResult = s_pfn(himl,i,hdcDst,x,y,dx,dy,rgbBk,rgbFg,fStyle);
    }
    __finally
    {
#ifdef _M_IX86
        if (!IsolationAwarePrivateT_SqbjaYRiRY)
#endif
        {
            const BOOL fPreserveLastError = (fResult == FALSE);
            const DWORD dwLastError = fPreserveLastError ? GetLastError() : NO_ERROR;
            (void)IsolationAwareDeactivateActCtx(0, ulpCookie);
            if (fPreserveLastError)
                SetLastError(dwLastError);
        }
    }
    return fResult;
}

ISOLATION_AWARE_INLINE BOOL IsolationAwarePrivatenCv IsolationAwareImageList_DrawIndirect(IMAGELISTDRAWPARAMS*pimldp)
{
    BOOL fResult = FALSE;
    typedef BOOL (WINAPI* PFN)(IMAGELISTDRAWPARAMS*pimldp);
    static PFN s_pfn;
    ULONG_PTR  ulpCookie = 0;
    const BOOL fActivateActCtxSuccess =
#ifdef _M_IX86
        IsolationAwarePrivateT_SqbjaYRiRY ||
#endif
        IsolationAwarePrivatenPgViNgRzlnPgpgk(&ulpCookie);
    if (!fActivateActCtxSuccess)
        return fResult;
    __try
    {
        if (s_pfn == NULL)
        {
            s_pfn = (PFN)CommctrlIsolationAwarePrivatetRgCebPnQQeRff_pbZPgYQP_QYY("ImageList_DrawIndirect");
            if (s_pfn == NULL)
                __leave;
        }
        fResult = s_pfn(pimldp);
    }
    __finally
    {
#ifdef _M_IX86
        if (!IsolationAwarePrivateT_SqbjaYRiRY)
#endif
        {
            const BOOL fPreserveLastError = (fResult == FALSE);
            const DWORD dwLastError = fPreserveLastError ? GetLastError() : NO_ERROR;
            (void)IsolationAwareDeactivateActCtx(0, ulpCookie);
            if (fPreserveLastError)
                SetLastError(dwLastError);
        }
    }
    return fResult;
}

ISOLATION_AWARE_INLINE BOOL IsolationAwarePrivatenCv IsolationAwareImageList_Remove(HIMAGELIST himl,int i)
{
    BOOL fResult = FALSE;
    typedef BOOL (WINAPI* PFN)(HIMAGELIST himl,int i);
    static PFN s_pfn;
    ULONG_PTR  ulpCookie = 0;
    const BOOL fActivateActCtxSuccess =
#ifdef _M_IX86
        IsolationAwarePrivateT_SqbjaYRiRY ||
#endif
        IsolationAwarePrivatenPgViNgRzlnPgpgk(&ulpCookie);
    if (!fActivateActCtxSuccess)
        return fResult;
    __try
    {
        if (s_pfn == NULL)
        {
            s_pfn = (PFN)CommctrlIsolationAwarePrivatetRgCebPnQQeRff_pbZPgYQP_QYY("ImageList_Remove");
            if (s_pfn == NULL)
                __leave;
        }
        fResult = s_pfn(himl,i);
    }
    __finally
    {
#ifdef _M_IX86
        if (!IsolationAwarePrivateT_SqbjaYRiRY)
#endif
        {
            const BOOL fPreserveLastError = (fResult == FALSE);
            const DWORD dwLastError = fPreserveLastError ? GetLastError() : NO_ERROR;
            (void)IsolationAwareDeactivateActCtx(0, ulpCookie);
            if (fPreserveLastError)
                SetLastError(dwLastError);
        }
    }
    return fResult;
}

ISOLATION_AWARE_INLINE HICON IsolationAwarePrivatenCv IsolationAwareImageList_GetIcon(HIMAGELIST himl,int i,UINT flags)
{
    HICON iconResult = NULL;
    typedef HICON (WINAPI* PFN)(HIMAGELIST himl,int i,UINT flags);
    static PFN s_pfn;
    ULONG_PTR  ulpCookie = 0;
    const BOOL fActivateActCtxSuccess =
#ifdef _M_IX86
        IsolationAwarePrivateT_SqbjaYRiRY ||
#endif
        IsolationAwarePrivatenPgViNgRzlnPgpgk(&ulpCookie);
    if (!fActivateActCtxSuccess)
        return iconResult;
    __try
    {
        if (s_pfn == NULL)
        {
            s_pfn = (PFN)CommctrlIsolationAwarePrivatetRgCebPnQQeRff_pbZPgYQP_QYY("ImageList_GetIcon");
            if (s_pfn == NULL)
                __leave;
        }
        iconResult = s_pfn(himl,i,flags);
    }
    __finally
    {
#ifdef _M_IX86
        if (!IsolationAwarePrivateT_SqbjaYRiRY)
#endif
        {
            const BOOL fPreserveLastError = (iconResult == NULL);
            const DWORD dwLastError = fPreserveLastError ? GetLastError() : NO_ERROR;
            (void)IsolationAwareDeactivateActCtx(0, ulpCookie);
            if (fPreserveLastError)
                SetLastError(dwLastError);
        }
    }
    return iconResult;
}

ISOLATION_AWARE_INLINE HIMAGELIST IsolationAwarePrivatenCv IsolationAwareImageList_LoadImageA(HINSTANCE hi,LPCSTR lpbmp,int cx,int cGrow,COLORREF crMask,UINT uType,UINT uFlags)
{
    HIMAGELIST imagelistResult = NULL;
    typedef HIMAGELIST (WINAPI* PFN)(HINSTANCE hi,LPCSTR lpbmp,int cx,int cGrow,COLORREF crMask,UINT uType,UINT uFlags);
    static PFN s_pfn;
    ULONG_PTR  ulpCookie = 0;
    const BOOL fActivateActCtxSuccess =
#ifdef _M_IX86
        IsolationAwarePrivateT_SqbjaYRiRY ||
#endif
        IsolationAwarePrivatenPgViNgRzlnPgpgk(&ulpCookie);
    if (!fActivateActCtxSuccess)
        return imagelistResult;
    __try
    {
        if (s_pfn == NULL)
        {
            s_pfn = (PFN)CommctrlIsolationAwarePrivatetRgCebPnQQeRff_pbZPgYQP_QYY("ImageList_LoadImageA");
            if (s_pfn == NULL)
                __leave;
        }
        imagelistResult = s_pfn(hi,lpbmp,cx,cGrow,crMask,uType,uFlags);
    }
    __finally
    {
#ifdef _M_IX86
        if (!IsolationAwarePrivateT_SqbjaYRiRY)
#endif
        {
            const BOOL fPreserveLastError = (imagelistResult == NULL);
            const DWORD dwLastError = fPreserveLastError ? GetLastError() : NO_ERROR;
            (void)IsolationAwareDeactivateActCtx(0, ulpCookie);
            if (fPreserveLastError)
                SetLastError(dwLastError);
        }
    }
    return imagelistResult;
}

ISOLATION_AWARE_INLINE HIMAGELIST IsolationAwarePrivatenCv IsolationAwareImageList_LoadImageW(HINSTANCE hi,LPCWSTR lpbmp,int cx,int cGrow,COLORREF crMask,UINT uType,UINT uFlags)
{
    HIMAGELIST imagelistResult = NULL;
    typedef HIMAGELIST (WINAPI* PFN)(HINSTANCE hi,LPCWSTR lpbmp,int cx,int cGrow,COLORREF crMask,UINT uType,UINT uFlags);
    static PFN s_pfn;
    ULONG_PTR  ulpCookie = 0;
    const BOOL fActivateActCtxSuccess =
#ifdef _M_IX86
        IsolationAwarePrivateT_SqbjaYRiRY ||
#endif
        IsolationAwarePrivatenPgViNgRzlnPgpgk(&ulpCookie);
    if (!fActivateActCtxSuccess)
        return imagelistResult;
    __try
    {
        if (s_pfn == NULL)
        {
            s_pfn = (PFN)CommctrlIsolationAwarePrivatetRgCebPnQQeRff_pbZPgYQP_QYY("ImageList_LoadImageW");
            if (s_pfn == NULL)
                __leave;
        }
        imagelistResult = s_pfn(hi,lpbmp,cx,cGrow,crMask,uType,uFlags);
    }
    __finally
    {
#ifdef _M_IX86
        if (!IsolationAwarePrivateT_SqbjaYRiRY)
#endif
        {
            const BOOL fPreserveLastError = (imagelistResult == NULL);
            const DWORD dwLastError = fPreserveLastError ? GetLastError() : NO_ERROR;
            (void)IsolationAwareDeactivateActCtx(0, ulpCookie);
            if (fPreserveLastError)
                SetLastError(dwLastError);
        }
    }
    return imagelistResult;
}

ISOLATION_AWARE_INLINE BOOL IsolationAwarePrivatenCv IsolationAwareImageList_Copy(HIMAGELIST himlDst,int iDst,HIMAGELIST himlSrc,int iSrc,UINT uFlags)
{
    BOOL fResult = FALSE;
    typedef BOOL (WINAPI* PFN)(HIMAGELIST himlDst,int iDst,HIMAGELIST himlSrc,int iSrc,UINT uFlags);
    static PFN s_pfn;
    ULONG_PTR  ulpCookie = 0;
    const BOOL fActivateActCtxSuccess =
#ifdef _M_IX86
        IsolationAwarePrivateT_SqbjaYRiRY ||
#endif
        IsolationAwarePrivatenPgViNgRzlnPgpgk(&ulpCookie);
    if (!fActivateActCtxSuccess)
        return fResult;
    __try
    {
        if (s_pfn == NULL)
        {
            s_pfn = (PFN)CommctrlIsolationAwarePrivatetRgCebPnQQeRff_pbZPgYQP_QYY("ImageList_Copy");
            if (s_pfn == NULL)
                __leave;
        }
        fResult = s_pfn(himlDst,iDst,himlSrc,iSrc,uFlags);
    }
    __finally
    {
#ifdef _M_IX86
        if (!IsolationAwarePrivateT_SqbjaYRiRY)
#endif
        {
            const BOOL fPreserveLastError = (fResult == FALSE);
            const DWORD dwLastError = fPreserveLastError ? GetLastError() : NO_ERROR;
            (void)IsolationAwareDeactivateActCtx(0, ulpCookie);
            if (fPreserveLastError)
                SetLastError(dwLastError);
        }
    }
    return fResult;
}

ISOLATION_AWARE_INLINE BOOL IsolationAwarePrivatenCv IsolationAwareImageList_BeginDrag(HIMAGELIST himlTrack,int iTrack,int dxHotspot,int dyHotspot)
{
    BOOL fResult = FALSE;
    typedef BOOL (WINAPI* PFN)(HIMAGELIST himlTrack,int iTrack,int dxHotspot,int dyHotspot);
    static PFN s_pfn;
    ULONG_PTR  ulpCookie = 0;
    const BOOL fActivateActCtxSuccess =
#ifdef _M_IX86
        IsolationAwarePrivateT_SqbjaYRiRY ||
#endif
        IsolationAwarePrivatenPgViNgRzlnPgpgk(&ulpCookie);
    if (!fActivateActCtxSuccess)
        return fResult;
    __try
    {
        if (s_pfn == NULL)
        {
            s_pfn = (PFN)CommctrlIsolationAwarePrivatetRgCebPnQQeRff_pbZPgYQP_QYY("ImageList_BeginDrag");
            if (s_pfn == NULL)
                __leave;
        }
        fResult = s_pfn(himlTrack,iTrack,dxHotspot,dyHotspot);
    }
    __finally
    {
#ifdef _M_IX86
        if (!IsolationAwarePrivateT_SqbjaYRiRY)
#endif
        {
            const BOOL fPreserveLastError = (fResult == FALSE);
            const DWORD dwLastError = fPreserveLastError ? GetLastError() : NO_ERROR;
            (void)IsolationAwareDeactivateActCtx(0, ulpCookie);
            if (fPreserveLastError)
                SetLastError(dwLastError);
        }
    }
    return fResult;
}

ISOLATION_AWARE_INLINE void IsolationAwarePrivatenCv IsolationAwareImageList_EndDrag(void)
{
    typedef void (WINAPI* PFN)(void);
    static PFN s_pfn;
    ULONG_PTR  ulpCookie = 0;
    const BOOL fActivateActCtxSuccess =
#ifdef _M_IX86
        IsolationAwarePrivateT_SqbjaYRiRY ||
#endif
        IsolationAwarePrivatenPgViNgRzlnPgpgk(&ulpCookie);
    if (!fActivateActCtxSuccess)
        return;
    __try
    {
        if (s_pfn == NULL)
        {
            s_pfn = (PFN)CommctrlIsolationAwarePrivatetRgCebPnQQeRff_pbZPgYQP_QYY("ImageList_EndDrag");
            if (s_pfn == NULL)
                __leave;
        }
        s_pfn();
    }
    __finally
    {
#ifdef _M_IX86
        if (!IsolationAwarePrivateT_SqbjaYRiRY)
#endif
        {
            (void)IsolationAwareDeactivateActCtx(0, ulpCookie);
        }
    }
    return;
}

ISOLATION_AWARE_INLINE BOOL IsolationAwarePrivatenCv IsolationAwareImageList_DragEnter(HWND hwndLock,int x,int y)
{
    BOOL fResult = FALSE;
    typedef BOOL (WINAPI* PFN)(HWND hwndLock,int x,int y);
    static PFN s_pfn;
    ULONG_PTR  ulpCookie = 0;
    const BOOL fActivateActCtxSuccess =
#ifdef _M_IX86
        IsolationAwarePrivateT_SqbjaYRiRY ||
#endif
        IsolationAwarePrivatenPgViNgRzlnPgpgk(&ulpCookie);
    if (!fActivateActCtxSuccess)
        return fResult;
    __try
    {
        if (s_pfn == NULL)
        {
            s_pfn = (PFN)CommctrlIsolationAwarePrivatetRgCebPnQQeRff_pbZPgYQP_QYY("ImageList_DragEnter");
            if (s_pfn == NULL)
                __leave;
        }
        fResult = s_pfn(hwndLock,x,y);
    }
    __finally
    {
#ifdef _M_IX86
        if (!IsolationAwarePrivateT_SqbjaYRiRY)
#endif
        {
            const BOOL fPreserveLastError = (fResult == FALSE);
            const DWORD dwLastError = fPreserveLastError ? GetLastError() : NO_ERROR;
            (void)IsolationAwareDeactivateActCtx(0, ulpCookie);
            if (fPreserveLastError)
                SetLastError(dwLastError);
        }
    }
    return fResult;
}

ISOLATION_AWARE_INLINE BOOL IsolationAwarePrivatenCv IsolationAwareImageList_DragLeave(HWND hwndLock)
{
    BOOL fResult = FALSE;
    typedef BOOL (WINAPI* PFN)(HWND hwndLock);
    static PFN s_pfn;
    ULONG_PTR  ulpCookie = 0;
    const BOOL fActivateActCtxSuccess =
#ifdef _M_IX86
        IsolationAwarePrivateT_SqbjaYRiRY ||
#endif
        IsolationAwarePrivatenPgViNgRzlnPgpgk(&ulpCookie);
    if (!fActivateActCtxSuccess)
        return fResult;
    __try
    {
        if (s_pfn == NULL)
        {
            s_pfn = (PFN)CommctrlIsolationAwarePrivatetRgCebPnQQeRff_pbZPgYQP_QYY("ImageList_DragLeave");
            if (s_pfn == NULL)
                __leave;
        }
        fResult = s_pfn(hwndLock);
    }
    __finally
    {
#ifdef _M_IX86
        if (!IsolationAwarePrivateT_SqbjaYRiRY)
#endif
        {
            const BOOL fPreserveLastError = (fResult == FALSE);
            const DWORD dwLastError = fPreserveLastError ? GetLastError() : NO_ERROR;
            (void)IsolationAwareDeactivateActCtx(0, ulpCookie);
            if (fPreserveLastError)
                SetLastError(dwLastError);
        }
    }
    return fResult;
}

ISOLATION_AWARE_INLINE BOOL IsolationAwarePrivatenCv IsolationAwareImageList_DragMove(int x,int y)
{
    BOOL fResult = FALSE;
    typedef BOOL (WINAPI* PFN)(int x,int y);
    static PFN s_pfn;
    ULONG_PTR  ulpCookie = 0;
    const BOOL fActivateActCtxSuccess =
#ifdef _M_IX86
        IsolationAwarePrivateT_SqbjaYRiRY ||
#endif
        IsolationAwarePrivatenPgViNgRzlnPgpgk(&ulpCookie);
    if (!fActivateActCtxSuccess)
        return fResult;
    __try
    {
        if (s_pfn == NULL)
        {
            s_pfn = (PFN)CommctrlIsolationAwarePrivatetRgCebPnQQeRff_pbZPgYQP_QYY("ImageList_DragMove");
            if (s_pfn == NULL)
                __leave;
        }
        fResult = s_pfn(x,y);
    }
    __finally
    {
#ifdef _M_IX86
        if (!IsolationAwarePrivateT_SqbjaYRiRY)
#endif
        {
            const BOOL fPreserveLastError = (fResult == FALSE);
            const DWORD dwLastError = fPreserveLastError ? GetLastError() : NO_ERROR;
            (void)IsolationAwareDeactivateActCtx(0, ulpCookie);
            if (fPreserveLastError)
                SetLastError(dwLastError);
        }
    }
    return fResult;
}

ISOLATION_AWARE_INLINE BOOL IsolationAwarePrivatenCv IsolationAwareImageList_SetDragCursorImage(HIMAGELIST himlDrag,int iDrag,int dxHotspot,int dyHotspot)
{
    BOOL fResult = FALSE;
    typedef BOOL (WINAPI* PFN)(HIMAGELIST himlDrag,int iDrag,int dxHotspot,int dyHotspot);
    static PFN s_pfn;
    ULONG_PTR  ulpCookie = 0;
    const BOOL fActivateActCtxSuccess =
#ifdef _M_IX86
        IsolationAwarePrivateT_SqbjaYRiRY ||
#endif
        IsolationAwarePrivatenPgViNgRzlnPgpgk(&ulpCookie);
    if (!fActivateActCtxSuccess)
        return fResult;
    __try
    {
        if (s_pfn == NULL)
        {
            s_pfn = (PFN)CommctrlIsolationAwarePrivatetRgCebPnQQeRff_pbZPgYQP_QYY("ImageList_SetDragCursorImage");
            if (s_pfn == NULL)
                __leave;
        }
        fResult = s_pfn(himlDrag,iDrag,dxHotspot,dyHotspot);
    }
    __finally
    {
#ifdef _M_IX86
        if (!IsolationAwarePrivateT_SqbjaYRiRY)
#endif
        {
            const BOOL fPreserveLastError = (fResult == FALSE);
            const DWORD dwLastError = fPreserveLastError ? GetLastError() : NO_ERROR;
            (void)IsolationAwareDeactivateActCtx(0, ulpCookie);
            if (fPreserveLastError)
                SetLastError(dwLastError);
        }
    }
    return fResult;
}

ISOLATION_AWARE_INLINE BOOL IsolationAwarePrivatenCv IsolationAwareImageList_DragShowNolock(BOOL fShow)
{
    BOOL fResult = FALSE;
    typedef BOOL (WINAPI* PFN)(BOOL fShow);
    static PFN s_pfn;
    ULONG_PTR  ulpCookie = 0;
    const BOOL fActivateActCtxSuccess =
#ifdef _M_IX86
        IsolationAwarePrivateT_SqbjaYRiRY ||
#endif
        IsolationAwarePrivatenPgViNgRzlnPgpgk(&ulpCookie);
    if (!fActivateActCtxSuccess)
        return fResult;
    __try
    {
        if (s_pfn == NULL)
        {
            s_pfn = (PFN)CommctrlIsolationAwarePrivatetRgCebPnQQeRff_pbZPgYQP_QYY("ImageList_DragShowNolock");
            if (s_pfn == NULL)
                __leave;
        }
        fResult = s_pfn(fShow);
    }
    __finally
    {
#ifdef _M_IX86
        if (!IsolationAwarePrivateT_SqbjaYRiRY)
#endif
        {
            const BOOL fPreserveLastError = (fResult == FALSE);
            const DWORD dwLastError = fPreserveLastError ? GetLastError() : NO_ERROR;
            (void)IsolationAwareDeactivateActCtx(0, ulpCookie);
            if (fPreserveLastError)
                SetLastError(dwLastError);
        }
    }
    return fResult;
}

ISOLATION_AWARE_INLINE HIMAGELIST IsolationAwarePrivatenCv IsolationAwareImageList_GetDragImage(POINT*ppt,POINT*pptHotspot)
{
    HIMAGELIST imagelistResult = NULL;
    typedef HIMAGELIST (WINAPI* PFN)(POINT*ppt,POINT*pptHotspot);
    static PFN s_pfn;
    ULONG_PTR  ulpCookie = 0;
    const BOOL fActivateActCtxSuccess =
#ifdef _M_IX86
        IsolationAwarePrivateT_SqbjaYRiRY ||
#endif
        IsolationAwarePrivatenPgViNgRzlnPgpgk(&ulpCookie);
    if (!fActivateActCtxSuccess)
        return imagelistResult;
    __try
    {
        if (s_pfn == NULL)
        {
            s_pfn = (PFN)CommctrlIsolationAwarePrivatetRgCebPnQQeRff_pbZPgYQP_QYY("ImageList_GetDragImage");
            if (s_pfn == NULL)
                __leave;
        }
        imagelistResult = s_pfn(ppt,pptHotspot);
    }
    __finally
    {
#ifdef _M_IX86
        if (!IsolationAwarePrivateT_SqbjaYRiRY)
#endif
        {
            const BOOL fPreserveLastError = (imagelistResult == NULL);
            const DWORD dwLastError = fPreserveLastError ? GetLastError() : NO_ERROR;
            (void)IsolationAwareDeactivateActCtx(0, ulpCookie);
            if (fPreserveLastError)
                SetLastError(dwLastError);
        }
    }
    return imagelistResult;
}

ISOLATION_AWARE_INLINE HIMAGELIST IsolationAwarePrivatenCv IsolationAwareImageList_Read(ISOLATIONAWARECOMMCTRL_LPSTREAM pstm)
{
    HIMAGELIST imagelistResult = NULL;
    typedef HIMAGELIST (WINAPI* PFN)(ISOLATIONAWARECOMMCTRL_LPSTREAM pstm);
    static PFN s_pfn;
    ULONG_PTR  ulpCookie = 0;
    const BOOL fActivateActCtxSuccess =
#ifdef _M_IX86
        IsolationAwarePrivateT_SqbjaYRiRY ||
#endif
        IsolationAwarePrivatenPgViNgRzlnPgpgk(&ulpCookie);
    if (!fActivateActCtxSuccess)
        return imagelistResult;
    __try
    {
        if (s_pfn == NULL)
        {
            s_pfn = (PFN)CommctrlIsolationAwarePrivatetRgCebPnQQeRff_pbZPgYQP_QYY("ImageList_Read");
            if (s_pfn == NULL)
                __leave;
        }
        imagelistResult = s_pfn(pstm);
    }
    __finally
    {
#ifdef _M_IX86
        if (!IsolationAwarePrivateT_SqbjaYRiRY)
#endif
        {
            const BOOL fPreserveLastError = (imagelistResult == NULL);
            const DWORD dwLastError = fPreserveLastError ? GetLastError() : NO_ERROR;
            (void)IsolationAwareDeactivateActCtx(0, ulpCookie);
            if (fPreserveLastError)
                SetLastError(dwLastError);
        }
    }
    return imagelistResult;
}

ISOLATION_AWARE_INLINE BOOL IsolationAwarePrivatenCv IsolationAwareImageList_Write(HIMAGELIST himl,ISOLATIONAWARECOMMCTRL_LPSTREAM pstm)
{
    BOOL fResult = FALSE;
    typedef BOOL (WINAPI* PFN)(HIMAGELIST himl,ISOLATIONAWARECOMMCTRL_LPSTREAM pstm);
    static PFN s_pfn;
    ULONG_PTR  ulpCookie = 0;
    const BOOL fActivateActCtxSuccess =
#ifdef _M_IX86
        IsolationAwarePrivateT_SqbjaYRiRY ||
#endif
        IsolationAwarePrivatenPgViNgRzlnPgpgk(&ulpCookie);
    if (!fActivateActCtxSuccess)
        return fResult;
    __try
    {
        if (s_pfn == NULL)
        {
            s_pfn = (PFN)CommctrlIsolationAwarePrivatetRgCebPnQQeRff_pbZPgYQP_QYY("ImageList_Write");
            if (s_pfn == NULL)
                __leave;
        }
        fResult = s_pfn(himl,pstm);
    }
    __finally
    {
#ifdef _M_IX86
        if (!IsolationAwarePrivateT_SqbjaYRiRY)
#endif
        {
            const BOOL fPreserveLastError = (fResult == FALSE);
            const DWORD dwLastError = fPreserveLastError ? GetLastError() : NO_ERROR;
            (void)IsolationAwareDeactivateActCtx(0, ulpCookie);
            if (fPreserveLastError)
                SetLastError(dwLastError);
        }
    }
    return fResult;
}

#if (_WIN32_WINNT >= 0x0501)

ISOLATION_AWARE_INLINE HRESULT IsolationAwarePrivatenCv IsolationAwareImageList_ReadEx(DWORD dwFlags,ISOLATIONAWARECOMMCTRL_LPSTREAM pstm,REFIID riid,PVOID*ppv)
{
    HRESULT result = S_OK;
    typedef HRESULT (WINAPI* PFN)(DWORD dwFlags,ISOLATIONAWARECOMMCTRL_LPSTREAM pstm,REFIID riid,PVOID*ppv);
    static PFN s_pfn;
    ULONG_PTR  ulpCookie = 0;
    const BOOL fActivateActCtxSuccess =
#ifdef _M_IX86
        IsolationAwarePrivateT_SqbjaYRiRY ||
#endif
        IsolationAwarePrivatenPgViNgRzlnPgpgk(&ulpCookie);
    if (!fActivateActCtxSuccess)
        return CommctrlIsolationAwarePrivateJVaQPGbueRfhYg();
    __try
    {
        if (s_pfn == NULL)
        {
            s_pfn = (PFN)CommctrlIsolationAwarePrivatetRgCebPnQQeRff_pbZPgYQP_QYY("ImageList_ReadEx");
            if (s_pfn == NULL)
            {
                result = CommctrlIsolationAwarePrivateJVaQPGbueRfhYg();
                __leave;
            }
        }
        result = s_pfn(dwFlags,pstm,riid,ppv);
    }
    __finally
    {
#ifdef _M_IX86
        if (!IsolationAwarePrivateT_SqbjaYRiRY)
#endif
        {
            (void)IsolationAwareDeactivateActCtx(0, ulpCookie);
        }
    }
    return result;
}

ISOLATION_AWARE_INLINE HRESULT IsolationAwarePrivatenCv IsolationAwareImageList_WriteEx(HIMAGELIST himl,DWORD dwFlags,ISOLATIONAWARECOMMCTRL_LPSTREAM pstm)
{
    HRESULT result = S_OK;
    typedef HRESULT (WINAPI* PFN)(HIMAGELIST himl,DWORD dwFlags,ISOLATIONAWARECOMMCTRL_LPSTREAM pstm);
    static PFN s_pfn;
    ULONG_PTR  ulpCookie = 0;
    const BOOL fActivateActCtxSuccess =
#ifdef _M_IX86
        IsolationAwarePrivateT_SqbjaYRiRY ||
#endif
        IsolationAwarePrivatenPgViNgRzlnPgpgk(&ulpCookie);
    if (!fActivateActCtxSuccess)
        return CommctrlIsolationAwarePrivateJVaQPGbueRfhYg();
    __try
    {
        if (s_pfn == NULL)
        {
            s_pfn = (PFN)CommctrlIsolationAwarePrivatetRgCebPnQQeRff_pbZPgYQP_QYY("ImageList_WriteEx");
            if (s_pfn == NULL)
            {
                result = CommctrlIsolationAwarePrivateJVaQPGbueRfhYg();
                __leave;
            }
        }
        result = s_pfn(himl,dwFlags,pstm);
    }
    __finally
    {
#ifdef _M_IX86
        if (!IsolationAwarePrivateT_SqbjaYRiRY)
#endif
        {
            (void)IsolationAwareDeactivateActCtx(0, ulpCookie);
        }
    }
    return result;
}

#endif /* (_WIN32_WINNT >= 0x0501) */

ISOLATION_AWARE_INLINE BOOL IsolationAwarePrivatenCv IsolationAwareImageList_GetIconSize(HIMAGELIST himl,int*cx,int*cy)
{
    BOOL fResult = FALSE;
    typedef BOOL (WINAPI* PFN)(HIMAGELIST himl,int*cx,int*cy);
    static PFN s_pfn;
    ULONG_PTR  ulpCookie = 0;
    const BOOL fActivateActCtxSuccess =
#ifdef _M_IX86
        IsolationAwarePrivateT_SqbjaYRiRY ||
#endif
        IsolationAwarePrivatenPgViNgRzlnPgpgk(&ulpCookie);
    if (!fActivateActCtxSuccess)
        return fResult;
    __try
    {
        if (s_pfn == NULL)
        {
            s_pfn = (PFN)CommctrlIsolationAwarePrivatetRgCebPnQQeRff_pbZPgYQP_QYY("ImageList_GetIconSize");
            if (s_pfn == NULL)
                __leave;
        }
        fResult = s_pfn(himl,cx,cy);
    }
    __finally
    {
#ifdef _M_IX86
        if (!IsolationAwarePrivateT_SqbjaYRiRY)
#endif
        {
            const BOOL fPreserveLastError = (fResult == FALSE);
            const DWORD dwLastError = fPreserveLastError ? GetLastError() : NO_ERROR;
            (void)IsolationAwareDeactivateActCtx(0, ulpCookie);
            if (fPreserveLastError)
                SetLastError(dwLastError);
        }
    }
    return fResult;
}

ISOLATION_AWARE_INLINE BOOL IsolationAwarePrivatenCv IsolationAwareImageList_SetIconSize(HIMAGELIST himl,int cx,int cy)
{
    BOOL fResult = FALSE;
    typedef BOOL (WINAPI* PFN)(HIMAGELIST himl,int cx,int cy);
    static PFN s_pfn;
    ULONG_PTR  ulpCookie = 0;
    const BOOL fActivateActCtxSuccess =
#ifdef _M_IX86
        IsolationAwarePrivateT_SqbjaYRiRY ||
#endif
        IsolationAwarePrivatenPgViNgRzlnPgpgk(&ulpCookie);
    if (!fActivateActCtxSuccess)
        return fResult;
    __try
    {
        if (s_pfn == NULL)
        {
            s_pfn = (PFN)CommctrlIsolationAwarePrivatetRgCebPnQQeRff_pbZPgYQP_QYY("ImageList_SetIconSize");
            if (s_pfn == NULL)
                __leave;
        }
        fResult = s_pfn(himl,cx,cy);
    }
    __finally
    {
#ifdef _M_IX86
        if (!IsolationAwarePrivateT_SqbjaYRiRY)
#endif
        {
            const BOOL fPreserveLastError = (fResult == FALSE);
            const DWORD dwLastError = fPreserveLastError ? GetLastError() : NO_ERROR;
            (void)IsolationAwareDeactivateActCtx(0, ulpCookie);
            if (fPreserveLastError)
                SetLastError(dwLastError);
        }
    }
    return fResult;
}

ISOLATION_AWARE_INLINE BOOL IsolationAwarePrivatenCv IsolationAwareImageList_GetImageInfo(HIMAGELIST himl,int i,IMAGEINFO*pImageInfo)
{
    BOOL fResult = FALSE;
    typedef BOOL (WINAPI* PFN)(HIMAGELIST himl,int i,IMAGEINFO*pImageInfo);
    static PFN s_pfn;
    ULONG_PTR  ulpCookie = 0;
    const BOOL fActivateActCtxSuccess =
#ifdef _M_IX86
        IsolationAwarePrivateT_SqbjaYRiRY ||
#endif
        IsolationAwarePrivatenPgViNgRzlnPgpgk(&ulpCookie);
    if (!fActivateActCtxSuccess)
        return fResult;
    __try
    {
        if (s_pfn == NULL)
        {
            s_pfn = (PFN)CommctrlIsolationAwarePrivatetRgCebPnQQeRff_pbZPgYQP_QYY("ImageList_GetImageInfo");
            if (s_pfn == NULL)
                __leave;
        }
        fResult = s_pfn(himl,i,pImageInfo);
    }
    __finally
    {
#ifdef _M_IX86
        if (!IsolationAwarePrivateT_SqbjaYRiRY)
#endif
        {
            const BOOL fPreserveLastError = (fResult == FALSE);
            const DWORD dwLastError = fPreserveLastError ? GetLastError() : NO_ERROR;
            (void)IsolationAwareDeactivateActCtx(0, ulpCookie);
            if (fPreserveLastError)
                SetLastError(dwLastError);
        }
    }
    return fResult;
}

ISOLATION_AWARE_INLINE HIMAGELIST IsolationAwarePrivatenCv IsolationAwareImageList_Merge(HIMAGELIST himl1,int i1,HIMAGELIST himl2,int i2,int dx,int dy)
{
    HIMAGELIST imagelistResult = NULL;
    typedef HIMAGELIST (WINAPI* PFN)(HIMAGELIST himl1,int i1,HIMAGELIST himl2,int i2,int dx,int dy);
    static PFN s_pfn;
    ULONG_PTR  ulpCookie = 0;
    const BOOL fActivateActCtxSuccess =
#ifdef _M_IX86
        IsolationAwarePrivateT_SqbjaYRiRY ||
#endif
        IsolationAwarePrivatenPgViNgRzlnPgpgk(&ulpCookie);
    if (!fActivateActCtxSuccess)
        return imagelistResult;
    __try
    {
        if (s_pfn == NULL)
        {
            s_pfn = (PFN)CommctrlIsolationAwarePrivatetRgCebPnQQeRff_pbZPgYQP_QYY("ImageList_Merge");
            if (s_pfn == NULL)
                __leave;
        }
        imagelistResult = s_pfn(himl1,i1,himl2,i2,dx,dy);
    }
    __finally
    {
#ifdef _M_IX86
        if (!IsolationAwarePrivateT_SqbjaYRiRY)
#endif
        {
            const BOOL fPreserveLastError = (imagelistResult == NULL);
            const DWORD dwLastError = fPreserveLastError ? GetLastError() : NO_ERROR;
            (void)IsolationAwareDeactivateActCtx(0, ulpCookie);
            if (fPreserveLastError)
                SetLastError(dwLastError);
        }
    }
    return imagelistResult;
}

ISOLATION_AWARE_INLINE HIMAGELIST IsolationAwarePrivatenCv IsolationAwareImageList_Duplicate(HIMAGELIST himl)
{
    HIMAGELIST imagelistResult = NULL;
    typedef HIMAGELIST (WINAPI* PFN)(HIMAGELIST himl);
    static PFN s_pfn;
    ULONG_PTR  ulpCookie = 0;
    const BOOL fActivateActCtxSuccess =
#ifdef _M_IX86
        IsolationAwarePrivateT_SqbjaYRiRY ||
#endif
        IsolationAwarePrivatenPgViNgRzlnPgpgk(&ulpCookie);
    if (!fActivateActCtxSuccess)
        return imagelistResult;
    __try
    {
        if (s_pfn == NULL)
        {
            s_pfn = (PFN)CommctrlIsolationAwarePrivatetRgCebPnQQeRff_pbZPgYQP_QYY("ImageList_Duplicate");
            if (s_pfn == NULL)
                __leave;
        }
        imagelistResult = s_pfn(himl);
    }
    __finally
    {
#ifdef _M_IX86
        if (!IsolationAwarePrivateT_SqbjaYRiRY)
#endif
        {
            const BOOL fPreserveLastError = (imagelistResult == NULL);
            const DWORD dwLastError = fPreserveLastError ? GetLastError() : NO_ERROR;
            (void)IsolationAwareDeactivateActCtx(0, ulpCookie);
            if (fPreserveLastError)
                SetLastError(dwLastError);
        }
    }
    return imagelistResult;
}

ISOLATION_AWARE_INLINE HRESULT IsolationAwarePrivatenCv IsolationAwareHIMAGELIST_QueryInterface(HIMAGELIST himl,REFIID riid,void**ppv)
{
    HRESULT result = S_OK;
    typedef HRESULT (WINAPI* PFN)(HIMAGELIST himl,REFIID riid,void**ppv);
    static PFN s_pfn;
    ULONG_PTR  ulpCookie = 0;
    const BOOL fActivateActCtxSuccess =
#ifdef _M_IX86
        IsolationAwarePrivateT_SqbjaYRiRY ||
#endif
        IsolationAwarePrivatenPgViNgRzlnPgpgk(&ulpCookie);
    if (!fActivateActCtxSuccess)
        return CommctrlIsolationAwarePrivateJVaQPGbueRfhYg();
    __try
    {
        if (s_pfn == NULL)
        {
            s_pfn = (PFN)CommctrlIsolationAwarePrivatetRgCebPnQQeRff_pbZPgYQP_QYY("HIMAGELIST_QueryInterface");
            if (s_pfn == NULL)
            {
                result = CommctrlIsolationAwarePrivateJVaQPGbueRfhYg();
                __leave;
            }
        }
        result = s_pfn(himl,riid,ppv);
    }
    __finally
    {
#ifdef _M_IX86
        if (!IsolationAwarePrivateT_SqbjaYRiRY)
#endif
        {
            (void)IsolationAwareDeactivateActCtx(0, ulpCookie);
        }
    }
    return result;
}

ISOLATION_AWARE_INLINE HWND IsolationAwarePrivatenCv IsolationAwareCreateToolbarEx(HWND hwnd,DWORD ws,UINT wID,int nBitmaps,HINSTANCE hBMInst,UINT_PTR wBMID,LPCTBBUTTON lpButtons,int iNumButtons,int dxButton,int dyButton,int dxBitmap,int dyBitmap,UINT uStructSize)
{
    HWND windowResult = NULL;
    typedef HWND (WINAPI* PFN)(HWND hwnd,DWORD ws,UINT wID,int nBitmaps,HINSTANCE hBMInst,UINT_PTR wBMID,LPCTBBUTTON lpButtons,int iNumButtons,int dxButton,int dyButton,int dxBitmap,int dyBitmap,UINT uStructSize);
    static PFN s_pfn;
    ULONG_PTR  ulpCookie = 0;
    const BOOL fActivateActCtxSuccess =
#ifdef _M_IX86
        IsolationAwarePrivateT_SqbjaYRiRY ||
#endif
        IsolationAwarePrivatenPgViNgRzlnPgpgk(&ulpCookie);
    if (!fActivateActCtxSuccess)
        return windowResult;
    __try
    {
        if (s_pfn == NULL)
        {
            s_pfn = (PFN)CommctrlIsolationAwarePrivatetRgCebPnQQeRff_pbZPgYQP_QYY("CreateToolbarEx");
            if (s_pfn == NULL)
                __leave;
        }
        windowResult = s_pfn(hwnd,ws,wID,nBitmaps,hBMInst,wBMID,lpButtons,iNumButtons,dxButton,dyButton,dxBitmap,dyBitmap,uStructSize);
    }
    __finally
    {
#ifdef _M_IX86
        if (!IsolationAwarePrivateT_SqbjaYRiRY)
#endif
        {
            const BOOL fPreserveLastError = (windowResult == NULL);
            const DWORD dwLastError = fPreserveLastError ? GetLastError() : NO_ERROR;
            (void)IsolationAwareDeactivateActCtx(0, ulpCookie);
            if (fPreserveLastError)
                SetLastError(dwLastError);
        }
    }
    return windowResult;
}

ISOLATION_AWARE_INLINE HBITMAP IsolationAwarePrivatenCv IsolationAwareCreateMappedBitmap(HINSTANCE hInstance,INT_PTR idBitmap,UINT wFlags,__in_opt LPCOLORMAP lpColorMap,int iNumMaps)
{
    HBITMAP bitmapResult = NULL;
    typedef HBITMAP (WINAPI* PFN)(HINSTANCE hInstance,INT_PTR idBitmap,UINT wFlags,__in_opt LPCOLORMAP lpColorMap,int iNumMaps);
    static PFN s_pfn;
    ULONG_PTR  ulpCookie = 0;
    const BOOL fActivateActCtxSuccess =
#ifdef _M_IX86
        IsolationAwarePrivateT_SqbjaYRiRY ||
#endif
        IsolationAwarePrivatenPgViNgRzlnPgpgk(&ulpCookie);
    if (!fActivateActCtxSuccess)
        return bitmapResult;
    __try
    {
        if (s_pfn == NULL)
        {
            s_pfn = (PFN)CommctrlIsolationAwarePrivatetRgCebPnQQeRff_pbZPgYQP_QYY("CreateMappedBitmap");
            if (s_pfn == NULL)
                __leave;
        }
        bitmapResult = s_pfn(hInstance,idBitmap,wFlags,lpColorMap,iNumMaps);
    }
    __finally
    {
#ifdef _M_IX86
        if (!IsolationAwarePrivateT_SqbjaYRiRY)
#endif
        {
            const BOOL fPreserveLastError = (bitmapResult == NULL);
            const DWORD dwLastError = fPreserveLastError ? GetLastError() : NO_ERROR;
            (void)IsolationAwareDeactivateActCtx(0, ulpCookie);
            if (fPreserveLastError)
                SetLastError(dwLastError);
        }
    }
    return bitmapResult;
}

ISOLATION_AWARE_INLINE void IsolationAwarePrivatenCv IsolationAwareDrawStatusTextA(HDC hDC,LPCRECT lprc,LPCSTR pszText,UINT uFlags)
{
    typedef void (WINAPI* PFN)(HDC hDC,LPCRECT lprc,LPCSTR pszText,UINT uFlags);
    static PFN s_pfn;
    ULONG_PTR  ulpCookie = 0;
    const BOOL fActivateActCtxSuccess =
#ifdef _M_IX86
        IsolationAwarePrivateT_SqbjaYRiRY ||
#endif
        IsolationAwarePrivatenPgViNgRzlnPgpgk(&ulpCookie);
    if (!fActivateActCtxSuccess)
        return;
    __try
    {
        if (s_pfn == NULL)
        {
            s_pfn = (PFN)CommctrlIsolationAwarePrivatetRgCebPnQQeRff_pbZPgYQP_QYY("DrawStatusTextA");
            if (s_pfn == NULL)
                __leave;
        }
        s_pfn(hDC,lprc,pszText,uFlags);
    }
    __finally
    {
#ifdef _M_IX86
        if (!IsolationAwarePrivateT_SqbjaYRiRY)
#endif
        {
            (void)IsolationAwareDeactivateActCtx(0, ulpCookie);
        }
    }
    return;
}

ISOLATION_AWARE_INLINE void IsolationAwarePrivatenCv IsolationAwareDrawStatusTextW(HDC hDC,LPCRECT lprc,LPCWSTR pszText,UINT uFlags)
{
    typedef void (WINAPI* PFN)(HDC hDC,LPCRECT lprc,LPCWSTR pszText,UINT uFlags);
    static PFN s_pfn;
    ULONG_PTR  ulpCookie = 0;
    const BOOL fActivateActCtxSuccess =
#ifdef _M_IX86
        IsolationAwarePrivateT_SqbjaYRiRY ||
#endif
        IsolationAwarePrivatenPgViNgRzlnPgpgk(&ulpCookie);
    if (!fActivateActCtxSuccess)
        return;
    __try
    {
        if (s_pfn == NULL)
        {
            s_pfn = (PFN)CommctrlIsolationAwarePrivatetRgCebPnQQeRff_pbZPgYQP_QYY("DrawStatusTextW");
            if (s_pfn == NULL)
                __leave;
        }
        s_pfn(hDC,lprc,pszText,uFlags);
    }
    __finally
    {
#ifdef _M_IX86
        if (!IsolationAwarePrivateT_SqbjaYRiRY)
#endif
        {
            (void)IsolationAwareDeactivateActCtx(0, ulpCookie);
        }
    }
    return;
}

ISOLATION_AWARE_INLINE HWND IsolationAwarePrivatenCv IsolationAwareCreateStatusWindowA(long style,LPCSTR lpszText,HWND hwndParent,UINT wID)
{
    HWND windowResult = NULL;
    typedef HWND (WINAPI* PFN)(long style,LPCSTR lpszText,HWND hwndParent,UINT wID);
    static PFN s_pfn;
    ULONG_PTR  ulpCookie = 0;
    const BOOL fActivateActCtxSuccess =
#ifdef _M_IX86
        IsolationAwarePrivateT_SqbjaYRiRY ||
#endif
        IsolationAwarePrivatenPgViNgRzlnPgpgk(&ulpCookie);
    if (!fActivateActCtxSuccess)
        return windowResult;
    __try
    {
        if (s_pfn == NULL)
        {
            s_pfn = (PFN)CommctrlIsolationAwarePrivatetRgCebPnQQeRff_pbZPgYQP_QYY("CreateStatusWindowA");
            if (s_pfn == NULL)
                __leave;
        }
        windowResult = s_pfn(style,lpszText,hwndParent,wID);
    }
    __finally
    {
#ifdef _M_IX86
        if (!IsolationAwarePrivateT_SqbjaYRiRY)
#endif
        {
            const BOOL fPreserveLastError = (windowResult == NULL);
            const DWORD dwLastError = fPreserveLastError ? GetLastError() : NO_ERROR;
            (void)IsolationAwareDeactivateActCtx(0, ulpCookie);
            if (fPreserveLastError)
                SetLastError(dwLastError);
        }
    }
    return windowResult;
}

ISOLATION_AWARE_INLINE HWND IsolationAwarePrivatenCv IsolationAwareCreateStatusWindowW(long style,LPCWSTR lpszText,HWND hwndParent,UINT wID)
{
    HWND windowResult = NULL;
    typedef HWND (WINAPI* PFN)(long style,LPCWSTR lpszText,HWND hwndParent,UINT wID);
    static PFN s_pfn;
    ULONG_PTR  ulpCookie = 0;
    const BOOL fActivateActCtxSuccess =
#ifdef _M_IX86
        IsolationAwarePrivateT_SqbjaYRiRY ||
#endif
        IsolationAwarePrivatenPgViNgRzlnPgpgk(&ulpCookie);
    if (!fActivateActCtxSuccess)
        return windowResult;
    __try
    {
        if (s_pfn == NULL)
        {
            s_pfn = (PFN)CommctrlIsolationAwarePrivatetRgCebPnQQeRff_pbZPgYQP_QYY("CreateStatusWindowW");
            if (s_pfn == NULL)
                __leave;
        }
        windowResult = s_pfn(style,lpszText,hwndParent,wID);
    }
    __finally
    {
#ifdef _M_IX86
        if (!IsolationAwarePrivateT_SqbjaYRiRY)
#endif
        {
            const BOOL fPreserveLastError = (windowResult == NULL);
            const DWORD dwLastError = fPreserveLastError ? GetLastError() : NO_ERROR;
            (void)IsolationAwareDeactivateActCtx(0, ulpCookie);
            if (fPreserveLastError)
                SetLastError(dwLastError);
        }
    }
    return windowResult;
}

ISOLATION_AWARE_INLINE void IsolationAwarePrivatenCv IsolationAwareMenuHelp(UINT uMsg,WPARAM wParam,LPARAM lParam,HMENU hMainMenu,HINSTANCE hInst,HWND hwndStatus,__in_ecount(4) UINT*lpwIDs)
{
    typedef void (WINAPI* PFN)(UINT uMsg,WPARAM wParam,LPARAM lParam,HMENU hMainMenu,HINSTANCE hInst,HWND hwndStatus,__in_ecount(4) UINT*lpwIDs);
    static PFN s_pfn;
    ULONG_PTR  ulpCookie = 0;
    const BOOL fActivateActCtxSuccess =
#ifdef _M_IX86
        IsolationAwarePrivateT_SqbjaYRiRY ||
#endif
        IsolationAwarePrivatenPgViNgRzlnPgpgk(&ulpCookie);
    if (!fActivateActCtxSuccess)
        return;
    __try
    {
        if (s_pfn == NULL)
        {
            s_pfn = (PFN)CommctrlIsolationAwarePrivatetRgCebPnQQeRff_pbZPgYQP_QYY("MenuHelp");
            if (s_pfn == NULL)
                __leave;
        }
        s_pfn(uMsg,wParam,lParam,hMainMenu,hInst,hwndStatus,lpwIDs);
    }
    __finally
    {
#ifdef _M_IX86
        if (!IsolationAwarePrivateT_SqbjaYRiRY)
#endif
        {
            (void)IsolationAwareDeactivateActCtx(0, ulpCookie);
        }
    }
    return;
}

ISOLATION_AWARE_INLINE BOOL IsolationAwarePrivatenCv IsolationAwareShowHideMenuCtl(HWND hWnd,UINT_PTR uFlags,__in __nullterminated LPINT lpInfo)
{
    BOOL fResult = FALSE;
    typedef BOOL (WINAPI* PFN)(HWND hWnd,UINT_PTR uFlags,__in __nullterminated LPINT lpInfo);
    static PFN s_pfn;
    ULONG_PTR  ulpCookie = 0;
    const BOOL fActivateActCtxSuccess =
#ifdef _M_IX86
        IsolationAwarePrivateT_SqbjaYRiRY ||
#endif
        IsolationAwarePrivatenPgViNgRzlnPgpgk(&ulpCookie);
    if (!fActivateActCtxSuccess)
        return fResult;
    __try
    {
        if (s_pfn == NULL)
        {
            s_pfn = (PFN)CommctrlIsolationAwarePrivatetRgCebPnQQeRff_pbZPgYQP_QYY("ShowHideMenuCtl");
            if (s_pfn == NULL)
                __leave;
        }
        fResult = s_pfn(hWnd,uFlags,lpInfo);
    }
    __finally
    {
#ifdef _M_IX86
        if (!IsolationAwarePrivateT_SqbjaYRiRY)
#endif
        {
            const BOOL fPreserveLastError = (fResult == FALSE);
            const DWORD dwLastError = fPreserveLastError ? GetLastError() : NO_ERROR;
            (void)IsolationAwareDeactivateActCtx(0, ulpCookie);
            if (fPreserveLastError)
                SetLastError(dwLastError);
        }
    }
    return fResult;
}

ISOLATION_AWARE_INLINE void IsolationAwarePrivatenCv IsolationAwareGetEffectiveClientRect(HWND hWnd,LPRECT lprc,__in __nullterminated const int*lpInfo)
{
    typedef void (WINAPI* PFN)(HWND hWnd,LPRECT lprc,__in __nullterminated const int*lpInfo);
    static PFN s_pfn;
    ULONG_PTR  ulpCookie = 0;
    const BOOL fActivateActCtxSuccess =
#ifdef _M_IX86
        IsolationAwarePrivateT_SqbjaYRiRY ||
#endif
        IsolationAwarePrivatenPgViNgRzlnPgpgk(&ulpCookie);
    if (!fActivateActCtxSuccess)
        return;
    __try
    {
        if (s_pfn == NULL)
        {
            s_pfn = (PFN)CommctrlIsolationAwarePrivatetRgCebPnQQeRff_pbZPgYQP_QYY("GetEffectiveClientRect");
            if (s_pfn == NULL)
                __leave;
        }
        s_pfn(hWnd,lprc,lpInfo);
    }
    __finally
    {
#ifdef _M_IX86
        if (!IsolationAwarePrivateT_SqbjaYRiRY)
#endif
        {
            (void)IsolationAwareDeactivateActCtx(0, ulpCookie);
        }
    }
    return;
}

ISOLATION_AWARE_INLINE BOOL IsolationAwarePrivatenCv IsolationAwareMakeDragList(HWND hLB)
{
    BOOL fResult = FALSE;
    typedef BOOL (WINAPI* PFN)(HWND hLB);
    static PFN s_pfn;
    ULONG_PTR  ulpCookie = 0;
    const BOOL fActivateActCtxSuccess =
#ifdef _M_IX86
        IsolationAwarePrivateT_SqbjaYRiRY ||
#endif
        IsolationAwarePrivatenPgViNgRzlnPgpgk(&ulpCookie);
    if (!fActivateActCtxSuccess)
        return fResult;
    __try
    {
        if (s_pfn == NULL)
        {
            s_pfn = (PFN)CommctrlIsolationAwarePrivatetRgCebPnQQeRff_pbZPgYQP_QYY("MakeDragList");
            if (s_pfn == NULL)
                __leave;
        }
        fResult = s_pfn(hLB);
    }
    __finally
    {
#ifdef _M_IX86
        if (!IsolationAwarePrivateT_SqbjaYRiRY)
#endif
        {
            const BOOL fPreserveLastError = (fResult == FALSE);
            const DWORD dwLastError = fPreserveLastError ? GetLastError() : NO_ERROR;
            (void)IsolationAwareDeactivateActCtx(0, ulpCookie);
            if (fPreserveLastError)
                SetLastError(dwLastError);
        }
    }
    return fResult;
}

ISOLATION_AWARE_INLINE void IsolationAwarePrivatenCv IsolationAwareDrawInsert(HWND handParent,HWND hLB,int nItem)
{
    typedef void (WINAPI* PFN)(HWND handParent,HWND hLB,int nItem);
    static PFN s_pfn;
    ULONG_PTR  ulpCookie = 0;
    const BOOL fActivateActCtxSuccess =
#ifdef _M_IX86
        IsolationAwarePrivateT_SqbjaYRiRY ||
#endif
        IsolationAwarePrivatenPgViNgRzlnPgpgk(&ulpCookie);
    if (!fActivateActCtxSuccess)
        return;
    __try
    {
        if (s_pfn == NULL)
        {
            s_pfn = (PFN)CommctrlIsolationAwarePrivatetRgCebPnQQeRff_pbZPgYQP_QYY("DrawInsert");
            if (s_pfn == NULL)
                __leave;
        }
        s_pfn(handParent,hLB,nItem);
    }
    __finally
    {
#ifdef _M_IX86
        if (!IsolationAwarePrivateT_SqbjaYRiRY)
#endif
        {
            (void)IsolationAwareDeactivateActCtx(0, ulpCookie);
        }
    }
    return;
}

ISOLATION_AWARE_INLINE int IsolationAwarePrivatenCv IsolationAwareLBItemFromPt(HWND hLB,POINT pt,BOOL bAutoScroll)
{
    int nResult = -1;
    typedef int (WINAPI* PFN)(HWND hLB,POINT pt,BOOL bAutoScroll);
    static PFN s_pfn;
    ULONG_PTR  ulpCookie = 0;
    const BOOL fActivateActCtxSuccess =
#ifdef _M_IX86
        IsolationAwarePrivateT_SqbjaYRiRY ||
#endif
        IsolationAwarePrivatenPgViNgRzlnPgpgk(&ulpCookie);
    if (!fActivateActCtxSuccess)
        return nResult;
    __try
    {
        if (s_pfn == NULL)
        {
            s_pfn = (PFN)CommctrlIsolationAwarePrivatetRgCebPnQQeRff_pbZPgYQP_QYY("LBItemFromPt");
            if (s_pfn == NULL)
                __leave;
        }
        nResult = s_pfn(hLB,pt,bAutoScroll);
    }
    __finally
    {
#ifdef _M_IX86
        if (!IsolationAwarePrivateT_SqbjaYRiRY)
#endif
        {
            const BOOL fPreserveLastError = (nResult == -1);
            const DWORD dwLastError = fPreserveLastError ? GetLastError() : NO_ERROR;
            (void)IsolationAwareDeactivateActCtx(0, ulpCookie);
            if (fPreserveLastError)
                SetLastError(dwLastError);
        }
    }
    return nResult;
}

ISOLATION_AWARE_INLINE HWND IsolationAwarePrivatenCv IsolationAwareCreateUpDownControl(DWORD dwStyle,int x,int y,int cx,int cy,HWND hParent,int nID,HINSTANCE hInst,HWND hBuddy,int nUpper,int nLower,int nPos)
{
    HWND windowResult = NULL;
    typedef HWND (WINAPI* PFN)(DWORD dwStyle,int x,int y,int cx,int cy,HWND hParent,int nID,HINSTANCE hInst,HWND hBuddy,int nUpper,int nLower,int nPos);
    static PFN s_pfn;
    ULONG_PTR  ulpCookie = 0;
    const BOOL fActivateActCtxSuccess =
#ifdef _M_IX86
        IsolationAwarePrivateT_SqbjaYRiRY ||
#endif
        IsolationAwarePrivatenPgViNgRzlnPgpgk(&ulpCookie);
    if (!fActivateActCtxSuccess)
        return windowResult;
    __try
    {
        if (s_pfn == NULL)
        {
            s_pfn = (PFN)CommctrlIsolationAwarePrivatetRgCebPnQQeRff_pbZPgYQP_QYY("CreateUpDownControl");
            if (s_pfn == NULL)
                __leave;
        }
        windowResult = s_pfn(dwStyle,x,y,cx,cy,hParent,nID,hInst,hBuddy,nUpper,nLower,nPos);
    }
    __finally
    {
#ifdef _M_IX86
        if (!IsolationAwarePrivateT_SqbjaYRiRY)
#endif
        {
            const BOOL fPreserveLastError = (windowResult == NULL);
            const DWORD dwLastError = fPreserveLastError ? GetLastError() : NO_ERROR;
            (void)IsolationAwareDeactivateActCtx(0, ulpCookie);
            if (fPreserveLastError)
                SetLastError(dwLastError);
        }
    }
    return windowResult;
}

ISOLATION_AWARE_INLINE HRESULT IsolationAwarePrivatenCv IsolationAwareTaskDialogIndirect(const TASKDIALOGCONFIG*pTaskConfig,__out_opt int*pnButton,__out_opt int*pnRadioButton,__out_opt BOOL*pfVerificationFlagChecked)
{
    HRESULT result = S_OK;
    typedef HRESULT (WINAPI* PFN)(const TASKDIALOGCONFIG*pTaskConfig,__out_opt int*pnButton,__out_opt int*pnRadioButton,__out_opt BOOL*pfVerificationFlagChecked);
    static PFN s_pfn;
    ULONG_PTR  ulpCookie = 0;
    const BOOL fActivateActCtxSuccess =
#ifdef _M_IX86
        IsolationAwarePrivateT_SqbjaYRiRY ||
#endif
        IsolationAwarePrivatenPgViNgRzlnPgpgk(&ulpCookie);
    if (!fActivateActCtxSuccess)
        return CommctrlIsolationAwarePrivateJVaQPGbueRfhYg();
    __try
    {
        if (s_pfn == NULL)
        {
            s_pfn = (PFN)CommctrlIsolationAwarePrivatetRgCebPnQQeRff_pbZPgYQP_QYY("TaskDialogIndirect");
            if (s_pfn == NULL)
            {
                result = CommctrlIsolationAwarePrivateJVaQPGbueRfhYg();
                __leave;
            }
        }
        result = s_pfn(pTaskConfig,pnButton,pnRadioButton,pfVerificationFlagChecked);
    }
    __finally
    {
#ifdef _M_IX86
        if (!IsolationAwarePrivateT_SqbjaYRiRY)
#endif
        {
            (void)IsolationAwareDeactivateActCtx(0, ulpCookie);
        }
    }
    return result;
}

ISOLATION_AWARE_INLINE HRESULT IsolationAwarePrivatenCv IsolationAwareTaskDialog(__in_opt HWND hwndParent,__in_opt HINSTANCE hInstance,__in_opt PCWSTR pszWindowTitle,__in_opt PCWSTR pszMainInstruction,__in_opt PCWSTR pszContent,TASKDIALOG_COMMON_BUTTON_FLAGS dwCommonButtons,__in_opt PCWSTR pszIcon,__out_opt int*pnButton)
{
    HRESULT result = S_OK;
    typedef HRESULT (WINAPI* PFN)(__in_opt HWND hwndParent,__in_opt HINSTANCE hInstance,__in_opt PCWSTR pszWindowTitle,__in_opt PCWSTR pszMainInstruction,__in_opt PCWSTR pszContent,TASKDIALOG_COMMON_BUTTON_FLAGS dwCommonButtons,__in_opt PCWSTR pszIcon,__out_opt int*pnButton);
    static PFN s_pfn;
    ULONG_PTR  ulpCookie = 0;
    const BOOL fActivateActCtxSuccess =
#ifdef _M_IX86
        IsolationAwarePrivateT_SqbjaYRiRY ||
#endif
        IsolationAwarePrivatenPgViNgRzlnPgpgk(&ulpCookie);
    if (!fActivateActCtxSuccess)
        return CommctrlIsolationAwarePrivateJVaQPGbueRfhYg();
    __try
    {
        if (s_pfn == NULL)
        {
            s_pfn = (PFN)CommctrlIsolationAwarePrivatetRgCebPnQQeRff_pbZPgYQP_QYY("TaskDialog");
            if (s_pfn == NULL)
            {
                result = CommctrlIsolationAwarePrivateJVaQPGbueRfhYg();
                __leave;
            }
        }
        result = s_pfn(hwndParent,hInstance,pszWindowTitle,pszMainInstruction,pszContent,dwCommonButtons,pszIcon,pnButton);
    }
    __finally
    {
#ifdef _M_IX86
        if (!IsolationAwarePrivateT_SqbjaYRiRY)
#endif
        {
            (void)IsolationAwareDeactivateActCtx(0, ulpCookie);
        }
    }
    return result;
}

ISOLATION_AWARE_INLINE void IsolationAwarePrivatenCv IsolationAwareInitMUILanguage(LANGID uiLang)
{
    typedef void (WINAPI* PFN)(LANGID uiLang);
    static PFN s_pfn;
    ULONG_PTR  ulpCookie = 0;
    const BOOL fActivateActCtxSuccess =
#ifdef _M_IX86
        IsolationAwarePrivateT_SqbjaYRiRY ||
#endif
        IsolationAwarePrivatenPgViNgRzlnPgpgk(&ulpCookie);
    if (!fActivateActCtxSuccess)
        return;
    __try
    {
        if (s_pfn == NULL)
        {
            s_pfn = (PFN)CommctrlIsolationAwarePrivatetRgCebPnQQeRff_pbZPgYQP_QYY("InitMUILanguage");
            if (s_pfn == NULL)
                __leave;
        }
        s_pfn(uiLang);
    }
    __finally
    {
#ifdef _M_IX86
        if (!IsolationAwarePrivateT_SqbjaYRiRY)
#endif
        {
            (void)IsolationAwareDeactivateActCtx(0, ulpCookie);
        }
    }
    return;
}

ISOLATION_AWARE_INLINE LANGID IsolationAwarePrivatenCv IsolationAwareGetMUILanguage(void)
{
    LANGID languageIdResult = MAKELANGID(LANG_NEUTRAL, SUBLANG_NEUTRAL);
    typedef LANGID (WINAPI* PFN)(void);
    static PFN s_pfn;
    ULONG_PTR  ulpCookie = 0;
    const BOOL fActivateActCtxSuccess =
#ifdef _M_IX86
        IsolationAwarePrivateT_SqbjaYRiRY ||
#endif
        IsolationAwarePrivatenPgViNgRzlnPgpgk(&ulpCookie);
    if (!fActivateActCtxSuccess)
        return languageIdResult;
    __try
    {
        if (s_pfn == NULL)
        {
            s_pfn = (PFN)CommctrlIsolationAwarePrivatetRgCebPnQQeRff_pbZPgYQP_QYY("GetMUILanguage");
            if (s_pfn == NULL)
                __leave;
        }
        languageIdResult = s_pfn();
    }
    __finally
    {
#ifdef _M_IX86
        if (!IsolationAwarePrivateT_SqbjaYRiRY)
#endif
        {
            const BOOL fPreserveLastError = (languageIdResult == MAKELANGID(LANG_NEUTRAL, SUBLANG_NEUTRAL));
            const DWORD dwLastError = fPreserveLastError ? GetLastError() : NO_ERROR;
            (void)IsolationAwareDeactivateActCtx(0, ulpCookie);
            if (fPreserveLastError)
                SetLastError(dwLastError);
        }
    }
    return languageIdResult;
}

ISOLATION_AWARE_INLINE HDSA IsolationAwarePrivatenCv IsolationAwareDSA_Create(int cbItem,int cItemGrow)
{
    HDSA result = NULL;
    typedef HDSA (WINAPI* PFN)(int cbItem,int cItemGrow);
    static PFN s_pfn;
    ULONG_PTR  ulpCookie = 0;
    const BOOL fActivateActCtxSuccess =
#ifdef _M_IX86
        IsolationAwarePrivateT_SqbjaYRiRY ||
#endif
        IsolationAwarePrivatenPgViNgRzlnPgpgk(&ulpCookie);
    if (!fActivateActCtxSuccess)
        return result;
    __try
    {
        if (s_pfn == NULL)
        {
            s_pfn = (PFN)CommctrlIsolationAwarePrivatetRgCebPnQQeRff_pbZPgYQP_QYY("DSA_Create");
            if (s_pfn == NULL)
                __leave;
        }
        result = s_pfn(cbItem,cItemGrow);
    }
    __finally
    {
#ifdef _M_IX86
        if (!IsolationAwarePrivateT_SqbjaYRiRY)
#endif
        {
            const BOOL fPreserveLastError = (result == NULL);
            const DWORD dwLastError = fPreserveLastError ? GetLastError() : NO_ERROR;
            (void)IsolationAwareDeactivateActCtx(0, ulpCookie);
            if (fPreserveLastError)
                SetLastError(dwLastError);
        }
    }
    return result;
}

ISOLATION_AWARE_INLINE BOOL IsolationAwarePrivatenCv IsolationAwareDSA_Destroy(__in HDSA hdsa)
{
    BOOL fResult = FALSE;
    typedef BOOL (WINAPI* PFN)(__in HDSA hdsa);
    static PFN s_pfn;
    ULONG_PTR  ulpCookie = 0;
    const BOOL fActivateActCtxSuccess =
#ifdef _M_IX86
        IsolationAwarePrivateT_SqbjaYRiRY ||
#endif
        IsolationAwarePrivatenPgViNgRzlnPgpgk(&ulpCookie);
    if (!fActivateActCtxSuccess)
        return fResult;
    __try
    {
        if (s_pfn == NULL)
        {
            s_pfn = (PFN)CommctrlIsolationAwarePrivatetRgCebPnQQeRff_pbZPgYQP_QYY("DSA_Destroy");
            if (s_pfn == NULL)
                __leave;
        }
        fResult = s_pfn(hdsa);
    }
    __finally
    {
#ifdef _M_IX86
        if (!IsolationAwarePrivateT_SqbjaYRiRY)
#endif
        {
            const BOOL fPreserveLastError = (fResult == FALSE);
            const DWORD dwLastError = fPreserveLastError ? GetLastError() : NO_ERROR;
            (void)IsolationAwareDeactivateActCtx(0, ulpCookie);
            if (fPreserveLastError)
                SetLastError(dwLastError);
        }
    }
    return fResult;
}

ISOLATION_AWARE_INLINE void IsolationAwarePrivatenCv IsolationAwareDSA_DestroyCallback(__in HDSA hdsa,__in PFNDAENUMCALLBACK pfnCB,__in_opt void*pData)
{
    typedef void (WINAPI* PFN)(__in HDSA hdsa,__in PFNDAENUMCALLBACK pfnCB,__in_opt void*pData);
    static PFN s_pfn;
    ULONG_PTR  ulpCookie = 0;
    const BOOL fActivateActCtxSuccess =
#ifdef _M_IX86
        IsolationAwarePrivateT_SqbjaYRiRY ||
#endif
        IsolationAwarePrivatenPgViNgRzlnPgpgk(&ulpCookie);
    if (!fActivateActCtxSuccess)
        return;
    __try
    {
        if (s_pfn == NULL)
        {
            s_pfn = (PFN)CommctrlIsolationAwarePrivatetRgCebPnQQeRff_pbZPgYQP_QYY("DSA_DestroyCallback");
            if (s_pfn == NULL)
                __leave;
        }
        s_pfn(hdsa,pfnCB,pData);
    }
    __finally
    {
#ifdef _M_IX86
        if (!IsolationAwarePrivateT_SqbjaYRiRY)
#endif
        {
            (void)IsolationAwareDeactivateActCtx(0, ulpCookie);
        }
    }
    return;
}

ISOLATION_AWARE_INLINE BOOL IsolationAwarePrivatenCv IsolationAwareDSA_DeleteItem(__in HDSA hdsa,__in int i)
{
    BOOL fResult = FALSE;
    typedef BOOL (WINAPI* PFN)(__in HDSA hdsa,__in int i);
    static PFN s_pfn;
    ULONG_PTR  ulpCookie = 0;
    const BOOL fActivateActCtxSuccess =
#ifdef _M_IX86
        IsolationAwarePrivateT_SqbjaYRiRY ||
#endif
        IsolationAwarePrivatenPgViNgRzlnPgpgk(&ulpCookie);
    if (!fActivateActCtxSuccess)
        return fResult;
    __try
    {
        if (s_pfn == NULL)
        {
            s_pfn = (PFN)CommctrlIsolationAwarePrivatetRgCebPnQQeRff_pbZPgYQP_QYY("DSA_DeleteItem");
            if (s_pfn == NULL)
                __leave;
        }
        fResult = s_pfn(hdsa,i);
    }
    __finally
    {
#ifdef _M_IX86
        if (!IsolationAwarePrivateT_SqbjaYRiRY)
#endif
        {
            const BOOL fPreserveLastError = (fResult == FALSE);
            const DWORD dwLastError = fPreserveLastError ? GetLastError() : NO_ERROR;
            (void)IsolationAwareDeactivateActCtx(0, ulpCookie);
            if (fPreserveLastError)
                SetLastError(dwLastError);
        }
    }
    return fResult;
}

ISOLATION_AWARE_INLINE BOOL IsolationAwarePrivatenCv IsolationAwareDSA_DeleteAllItems(__in HDSA hdsa)
{
    BOOL fResult = FALSE;
    typedef BOOL (WINAPI* PFN)(__in HDSA hdsa);
    static PFN s_pfn;
    ULONG_PTR  ulpCookie = 0;
    const BOOL fActivateActCtxSuccess =
#ifdef _M_IX86
        IsolationAwarePrivateT_SqbjaYRiRY ||
#endif
        IsolationAwarePrivatenPgViNgRzlnPgpgk(&ulpCookie);
    if (!fActivateActCtxSuccess)
        return fResult;
    __try
    {
        if (s_pfn == NULL)
        {
            s_pfn = (PFN)CommctrlIsolationAwarePrivatetRgCebPnQQeRff_pbZPgYQP_QYY("DSA_DeleteAllItems");
            if (s_pfn == NULL)
                __leave;
        }
        fResult = s_pfn(hdsa);
    }
    __finally
    {
#ifdef _M_IX86
        if (!IsolationAwarePrivateT_SqbjaYRiRY)
#endif
        {
            const BOOL fPreserveLastError = (fResult == FALSE);
            const DWORD dwLastError = fPreserveLastError ? GetLastError() : NO_ERROR;
            (void)IsolationAwareDeactivateActCtx(0, ulpCookie);
            if (fPreserveLastError)
                SetLastError(dwLastError);
        }
    }
    return fResult;
}

ISOLATION_AWARE_INLINE void IsolationAwarePrivatenCv IsolationAwareDSA_EnumCallback(__in HDSA hdsa,__in PFNDAENUMCALLBACK pfnCB,__in_opt void*pData)
{
    typedef void (WINAPI* PFN)(__in HDSA hdsa,__in PFNDAENUMCALLBACK pfnCB,__in_opt void*pData);
    static PFN s_pfn;
    ULONG_PTR  ulpCookie = 0;
    const BOOL fActivateActCtxSuccess =
#ifdef _M_IX86
        IsolationAwarePrivateT_SqbjaYRiRY ||
#endif
        IsolationAwarePrivatenPgViNgRzlnPgpgk(&ulpCookie);
    if (!fActivateActCtxSuccess)
        return;
    __try
    {
        if (s_pfn == NULL)
        {
            s_pfn = (PFN)CommctrlIsolationAwarePrivatetRgCebPnQQeRff_pbZPgYQP_QYY("DSA_EnumCallback");
            if (s_pfn == NULL)
                __leave;
        }
        s_pfn(hdsa,pfnCB,pData);
    }
    __finally
    {
#ifdef _M_IX86
        if (!IsolationAwarePrivateT_SqbjaYRiRY)
#endif
        {
            (void)IsolationAwareDeactivateActCtx(0, ulpCookie);
        }
    }
    return;
}

ISOLATION_AWARE_INLINE int IsolationAwarePrivatenCv IsolationAwareDSA_InsertItem(__in HDSA hdsa,__in int i,__in const void*pitem)
{
    int nResult = -1;
    typedef int (WINAPI* PFN)(__in HDSA hdsa,__in int i,__in const void*pitem);
    static PFN s_pfn;
    ULONG_PTR  ulpCookie = 0;
    const BOOL fActivateActCtxSuccess =
#ifdef _M_IX86
        IsolationAwarePrivateT_SqbjaYRiRY ||
#endif
        IsolationAwarePrivatenPgViNgRzlnPgpgk(&ulpCookie);
    if (!fActivateActCtxSuccess)
        return nResult;
    __try
    {
        if (s_pfn == NULL)
        {
            s_pfn = (PFN)CommctrlIsolationAwarePrivatetRgCebPnQQeRff_pbZPgYQP_QYY("DSA_InsertItem");
            if (s_pfn == NULL)
                __leave;
        }
        nResult = s_pfn(hdsa,i,pitem);
    }
    __finally
    {
#ifdef _M_IX86
        if (!IsolationAwarePrivateT_SqbjaYRiRY)
#endif
        {
            const BOOL fPreserveLastError = (nResult == -1);
            const DWORD dwLastError = fPreserveLastError ? GetLastError() : NO_ERROR;
            (void)IsolationAwareDeactivateActCtx(0, ulpCookie);
            if (fPreserveLastError)
                SetLastError(dwLastError);
        }
    }
    return nResult;
}

ISOLATION_AWARE_INLINE PVOID IsolationAwarePrivatenCv IsolationAwareDSA_GetItemPtr(__in HDSA hdsa,__in int i)
{
    PVOID vResult = NULL;
    typedef PVOID (WINAPI* PFN)(__in HDSA hdsa,__in int i);
    static PFN s_pfn;
    ULONG_PTR  ulpCookie = 0;
    const BOOL fActivateActCtxSuccess =
#ifdef _M_IX86
        IsolationAwarePrivateT_SqbjaYRiRY ||
#endif
        IsolationAwarePrivatenPgViNgRzlnPgpgk(&ulpCookie);
    if (!fActivateActCtxSuccess)
        return vResult;
    __try
    {
        if (s_pfn == NULL)
        {
            s_pfn = (PFN)CommctrlIsolationAwarePrivatetRgCebPnQQeRff_pbZPgYQP_QYY("DSA_GetItemPtr");
            if (s_pfn == NULL)
                __leave;
        }
        vResult = s_pfn(hdsa,i);
    }
    __finally
    {
#ifdef _M_IX86
        if (!IsolationAwarePrivateT_SqbjaYRiRY)
#endif
        {
            const BOOL fPreserveLastError = (vResult == NULL);
            const DWORD dwLastError = fPreserveLastError ? GetLastError() : NO_ERROR;
            (void)IsolationAwareDeactivateActCtx(0, ulpCookie);
            if (fPreserveLastError)
                SetLastError(dwLastError);
        }
    }
    return vResult;
}

ISOLATION_AWARE_INLINE BOOL IsolationAwarePrivatenCv IsolationAwareDSA_GetItem(__in HDSA hdsa,__in int i,__out_xcount(pdsa->cbItem) void*pitem)
{
    BOOL fResult = FALSE;
    typedef BOOL (WINAPI* PFN)(__in HDSA hdsa,__in int i,__out_xcount(pdsa->cbItem) void*pitem);
    static PFN s_pfn;
    ULONG_PTR  ulpCookie = 0;
    const BOOL fActivateActCtxSuccess =
#ifdef _M_IX86
        IsolationAwarePrivateT_SqbjaYRiRY ||
#endif
        IsolationAwarePrivatenPgViNgRzlnPgpgk(&ulpCookie);
    if (!fActivateActCtxSuccess)
        return fResult;
    __try
    {
        if (s_pfn == NULL)
        {
            s_pfn = (PFN)CommctrlIsolationAwarePrivatetRgCebPnQQeRff_pbZPgYQP_QYY("DSA_GetItem");
            if (s_pfn == NULL)
                __leave;
        }
        fResult = s_pfn(hdsa,i,pitem);
    }
    __finally
    {
#ifdef _M_IX86
        if (!IsolationAwarePrivateT_SqbjaYRiRY)
#endif
        {
            const BOOL fPreserveLastError = (fResult == FALSE);
            const DWORD dwLastError = fPreserveLastError ? GetLastError() : NO_ERROR;
            (void)IsolationAwareDeactivateActCtx(0, ulpCookie);
            if (fPreserveLastError)
                SetLastError(dwLastError);
        }
    }
    return fResult;
}

ISOLATION_AWARE_INLINE BOOL IsolationAwarePrivatenCv IsolationAwareDSA_SetItem(__in HDSA hdsa,__in int i,__in const void*pitem)
{
    BOOL fResult = FALSE;
    typedef BOOL (WINAPI* PFN)(__in HDSA hdsa,__in int i,__in const void*pitem);
    static PFN s_pfn;
    ULONG_PTR  ulpCookie = 0;
    const BOOL fActivateActCtxSuccess =
#ifdef _M_IX86
        IsolationAwarePrivateT_SqbjaYRiRY ||
#endif
        IsolationAwarePrivatenPgViNgRzlnPgpgk(&ulpCookie);
    if (!fActivateActCtxSuccess)
        return fResult;
    __try
    {
        if (s_pfn == NULL)
        {
            s_pfn = (PFN)CommctrlIsolationAwarePrivatetRgCebPnQQeRff_pbZPgYQP_QYY("DSA_SetItem");
            if (s_pfn == NULL)
                __leave;
        }
        fResult = s_pfn(hdsa,i,pitem);
    }
    __finally
    {
#ifdef _M_IX86
        if (!IsolationAwarePrivateT_SqbjaYRiRY)
#endif
        {
            const BOOL fPreserveLastError = (fResult == FALSE);
            const DWORD dwLastError = fPreserveLastError ? GetLastError() : NO_ERROR;
            (void)IsolationAwareDeactivateActCtx(0, ulpCookie);
            if (fPreserveLastError)
                SetLastError(dwLastError);
        }
    }
    return fResult;
}

ISOLATION_AWARE_INLINE HDSA IsolationAwarePrivatenCv IsolationAwareDSA_Clone(__in HDSA hdsa)
{
    HDSA result = NULL;
    typedef HDSA (WINAPI* PFN)(__in HDSA hdsa);
    static PFN s_pfn;
    ULONG_PTR  ulpCookie = 0;
    const BOOL fActivateActCtxSuccess =
#ifdef _M_IX86
        IsolationAwarePrivateT_SqbjaYRiRY ||
#endif
        IsolationAwarePrivatenPgViNgRzlnPgpgk(&ulpCookie);
    if (!fActivateActCtxSuccess)
        return result;
    __try
    {
        if (s_pfn == NULL)
        {
            s_pfn = (PFN)CommctrlIsolationAwarePrivatetRgCebPnQQeRff_pbZPgYQP_QYY("DSA_Clone");
            if (s_pfn == NULL)
                __leave;
        }
        result = s_pfn(hdsa);
    }
    __finally
    {
#ifdef _M_IX86
        if (!IsolationAwarePrivateT_SqbjaYRiRY)
#endif
        {
            const BOOL fPreserveLastError = (result == NULL);
            const DWORD dwLastError = fPreserveLastError ? GetLastError() : NO_ERROR;
            (void)IsolationAwareDeactivateActCtx(0, ulpCookie);
            if (fPreserveLastError)
                SetLastError(dwLastError);
        }
    }
    return result;
}

ISOLATION_AWARE_INLINE ULONGLONG IsolationAwarePrivatenCv IsolationAwareDSA_GetSize(__in HDSA hdsa)
{
    ULONGLONG result = 0 ;
    typedef ULONGLONG (WINAPI* PFN)(__in HDSA hdsa);
    static PFN s_pfn;
    ULONG_PTR  ulpCookie = 0;
    const BOOL fActivateActCtxSuccess =
#ifdef _M_IX86
        IsolationAwarePrivateT_SqbjaYRiRY ||
#endif
        IsolationAwarePrivatenPgViNgRzlnPgpgk(&ulpCookie);
    if (!fActivateActCtxSuccess)
        return result;
    __try
    {
        if (s_pfn == NULL)
        {
            s_pfn = (PFN)CommctrlIsolationAwarePrivatetRgCebPnQQeRff_pbZPgYQP_QYY("DSA_GetSize");
            if (s_pfn == NULL)
                __leave;
        }
        result = s_pfn(hdsa);
    }
    __finally
    {
#ifdef _M_IX86
        if (!IsolationAwarePrivateT_SqbjaYRiRY)
#endif
        {
            const BOOL fPreserveLastError = (result == 0 );
            const DWORD dwLastError = fPreserveLastError ? GetLastError() : NO_ERROR;
            (void)IsolationAwareDeactivateActCtx(0, ulpCookie);
            if (fPreserveLastError)
                SetLastError(dwLastError);
        }
    }
    return result;
}

ISOLATION_AWARE_INLINE BOOL IsolationAwarePrivatenCv IsolationAwareDSA_Sort(__in HDSA pdsa,__in PFNDACOMPARE pfnCompare,__in LPARAM lParam)
{
    BOOL fResult = FALSE;
    typedef BOOL (WINAPI* PFN)(__in HDSA pdsa,__in PFNDACOMPARE pfnCompare,__in LPARAM lParam);
    static PFN s_pfn;
    ULONG_PTR  ulpCookie = 0;
    const BOOL fActivateActCtxSuccess =
#ifdef _M_IX86
        IsolationAwarePrivateT_SqbjaYRiRY ||
#endif
        IsolationAwarePrivatenPgViNgRzlnPgpgk(&ulpCookie);
    if (!fActivateActCtxSuccess)
        return fResult;
    __try
    {
        if (s_pfn == NULL)
        {
            s_pfn = (PFN)CommctrlIsolationAwarePrivatetRgCebPnQQeRff_pbZPgYQP_QYY("DSA_Sort");
            if (s_pfn == NULL)
                __leave;
        }
        fResult = s_pfn(pdsa,pfnCompare,lParam);
    }
    __finally
    {
#ifdef _M_IX86
        if (!IsolationAwarePrivateT_SqbjaYRiRY)
#endif
        {
            const BOOL fPreserveLastError = (fResult == FALSE);
            const DWORD dwLastError = fPreserveLastError ? GetLastError() : NO_ERROR;
            (void)IsolationAwareDeactivateActCtx(0, ulpCookie);
            if (fPreserveLastError)
                SetLastError(dwLastError);
        }
    }
    return fResult;
}

ISOLATION_AWARE_INLINE HDPA IsolationAwarePrivatenCv IsolationAwareDPA_Create(int cItemGrow)
{
    HDPA result = NULL;
    typedef HDPA (WINAPI* PFN)(int cItemGrow);
    static PFN s_pfn;
    ULONG_PTR  ulpCookie = 0;
    const BOOL fActivateActCtxSuccess =
#ifdef _M_IX86
        IsolationAwarePrivateT_SqbjaYRiRY ||
#endif
        IsolationAwarePrivatenPgViNgRzlnPgpgk(&ulpCookie);
    if (!fActivateActCtxSuccess)
        return result;
    __try
    {
        if (s_pfn == NULL)
        {
            s_pfn = (PFN)CommctrlIsolationAwarePrivatetRgCebPnQQeRff_pbZPgYQP_QYY("DPA_Create");
            if (s_pfn == NULL)
                __leave;
        }
        result = s_pfn(cItemGrow);
    }
    __finally
    {
#ifdef _M_IX86
        if (!IsolationAwarePrivateT_SqbjaYRiRY)
#endif
        {
            const BOOL fPreserveLastError = (result == NULL);
            const DWORD dwLastError = fPreserveLastError ? GetLastError() : NO_ERROR;
            (void)IsolationAwareDeactivateActCtx(0, ulpCookie);
            if (fPreserveLastError)
                SetLastError(dwLastError);
        }
    }
    return result;
}

ISOLATION_AWARE_INLINE HDPA IsolationAwarePrivatenCv IsolationAwareDPA_CreateEx(__in int cpGrow,__in_opt HANDLE hheap)
{
    HDPA result = NULL;
    typedef HDPA (WINAPI* PFN)(__in int cpGrow,__in_opt HANDLE hheap);
    static PFN s_pfn;
    ULONG_PTR  ulpCookie = 0;
    const BOOL fActivateActCtxSuccess =
#ifdef _M_IX86
        IsolationAwarePrivateT_SqbjaYRiRY ||
#endif
        IsolationAwarePrivatenPgViNgRzlnPgpgk(&ulpCookie);
    if (!fActivateActCtxSuccess)
        return result;
    __try
    {
        if (s_pfn == NULL)
        {
            s_pfn = (PFN)CommctrlIsolationAwarePrivatetRgCebPnQQeRff_pbZPgYQP_QYY("DPA_CreateEx");
            if (s_pfn == NULL)
                __leave;
        }
        result = s_pfn(cpGrow,hheap);
    }
    __finally
    {
#ifdef _M_IX86
        if (!IsolationAwarePrivateT_SqbjaYRiRY)
#endif
        {
            const BOOL fPreserveLastError = (result == NULL);
            const DWORD dwLastError = fPreserveLastError ? GetLastError() : NO_ERROR;
            (void)IsolationAwareDeactivateActCtx(0, ulpCookie);
            if (fPreserveLastError)
                SetLastError(dwLastError);
        }
    }
    return result;
}

ISOLATION_AWARE_INLINE HDPA IsolationAwarePrivatenCv IsolationAwareDPA_Clone(__in const HDPA hdpa,__in HDPA hdpaNew)
{
    HDPA result = NULL;
    typedef HDPA (WINAPI* PFN)(__in const HDPA hdpa,__in HDPA hdpaNew);
    static PFN s_pfn;
    ULONG_PTR  ulpCookie = 0;
    const BOOL fActivateActCtxSuccess =
#ifdef _M_IX86
        IsolationAwarePrivateT_SqbjaYRiRY ||
#endif
        IsolationAwarePrivatenPgViNgRzlnPgpgk(&ulpCookie);
    if (!fActivateActCtxSuccess)
        return result;
    __try
    {
        if (s_pfn == NULL)
        {
            s_pfn = (PFN)CommctrlIsolationAwarePrivatetRgCebPnQQeRff_pbZPgYQP_QYY("DPA_Clone");
            if (s_pfn == NULL)
                __leave;
        }
        result = s_pfn(hdpa,hdpaNew);
    }
    __finally
    {
#ifdef _M_IX86
        if (!IsolationAwarePrivateT_SqbjaYRiRY)
#endif
        {
            const BOOL fPreserveLastError = (result == NULL);
            const DWORD dwLastError = fPreserveLastError ? GetLastError() : NO_ERROR;
            (void)IsolationAwareDeactivateActCtx(0, ulpCookie);
            if (fPreserveLastError)
                SetLastError(dwLastError);
        }
    }
    return result;
}

ISOLATION_AWARE_INLINE BOOL IsolationAwarePrivatenCv IsolationAwareDPA_Destroy(__in HDPA hdpa)
{
    BOOL fResult = FALSE;
    typedef BOOL (WINAPI* PFN)(__in HDPA hdpa);
    static PFN s_pfn;
    ULONG_PTR  ulpCookie = 0;
    const BOOL fActivateActCtxSuccess =
#ifdef _M_IX86
        IsolationAwarePrivateT_SqbjaYRiRY ||
#endif
        IsolationAwarePrivatenPgViNgRzlnPgpgk(&ulpCookie);
    if (!fActivateActCtxSuccess)
        return fResult;
    __try
    {
        if (s_pfn == NULL)
        {
            s_pfn = (PFN)CommctrlIsolationAwarePrivatetRgCebPnQQeRff_pbZPgYQP_QYY("DPA_Destroy");
            if (s_pfn == NULL)
                __leave;
        }
        fResult = s_pfn(hdpa);
    }
    __finally
    {
#ifdef _M_IX86
        if (!IsolationAwarePrivateT_SqbjaYRiRY)
#endif
        {
            const BOOL fPreserveLastError = (fResult == FALSE);
            const DWORD dwLastError = fPreserveLastError ? GetLastError() : NO_ERROR;
            (void)IsolationAwareDeactivateActCtx(0, ulpCookie);
            if (fPreserveLastError)
                SetLastError(dwLastError);
        }
    }
    return fResult;
}

ISOLATION_AWARE_INLINE void IsolationAwarePrivatenCv IsolationAwareDPA_DestroyCallback(__in HDPA hdpa,__in PFNDAENUMCALLBACK pfnCB,__in_opt void*pData)
{
    typedef void (WINAPI* PFN)(__in HDPA hdpa,__in PFNDAENUMCALLBACK pfnCB,__in_opt void*pData);
    static PFN s_pfn;
    ULONG_PTR  ulpCookie = 0;
    const BOOL fActivateActCtxSuccess =
#ifdef _M_IX86
        IsolationAwarePrivateT_SqbjaYRiRY ||
#endif
        IsolationAwarePrivatenPgViNgRzlnPgpgk(&ulpCookie);
    if (!fActivateActCtxSuccess)
        return;
    __try
    {
        if (s_pfn == NULL)
        {
            s_pfn = (PFN)CommctrlIsolationAwarePrivatetRgCebPnQQeRff_pbZPgYQP_QYY("DPA_DestroyCallback");
            if (s_pfn == NULL)
                __leave;
        }
        s_pfn(hdpa,pfnCB,pData);
    }
    __finally
    {
#ifdef _M_IX86
        if (!IsolationAwarePrivateT_SqbjaYRiRY)
#endif
        {
            (void)IsolationAwareDeactivateActCtx(0, ulpCookie);
        }
    }
    return;
}

ISOLATION_AWARE_INLINE PVOID IsolationAwarePrivatenCv IsolationAwareDPA_DeletePtr(__in HDPA hdpa,__in int i)
{
    PVOID vResult = NULL;
    typedef PVOID (WINAPI* PFN)(__in HDPA hdpa,__in int i);
    static PFN s_pfn;
    ULONG_PTR  ulpCookie = 0;
    const BOOL fActivateActCtxSuccess =
#ifdef _M_IX86
        IsolationAwarePrivateT_SqbjaYRiRY ||
#endif
        IsolationAwarePrivatenPgViNgRzlnPgpgk(&ulpCookie);
    if (!fActivateActCtxSuccess)
        return vResult;
    __try
    {
        if (s_pfn == NULL)
        {
            s_pfn = (PFN)CommctrlIsolationAwarePrivatetRgCebPnQQeRff_pbZPgYQP_QYY("DPA_DeletePtr");
            if (s_pfn == NULL)
                __leave;
        }
        vResult = s_pfn(hdpa,i);
    }
    __finally
    {
#ifdef _M_IX86
        if (!IsolationAwarePrivateT_SqbjaYRiRY)
#endif
        {
            const BOOL fPreserveLastError = (vResult == NULL);
            const DWORD dwLastError = fPreserveLastError ? GetLastError() : NO_ERROR;
            (void)IsolationAwareDeactivateActCtx(0, ulpCookie);
            if (fPreserveLastError)
                SetLastError(dwLastError);
        }
    }
    return vResult;
}

ISOLATION_AWARE_INLINE BOOL IsolationAwarePrivatenCv IsolationAwareDPA_DeleteAllPtrs(__in HDPA hdpa)
{
    BOOL fResult = FALSE;
    typedef BOOL (WINAPI* PFN)(__in HDPA hdpa);
    static PFN s_pfn;
    ULONG_PTR  ulpCookie = 0;
    const BOOL fActivateActCtxSuccess =
#ifdef _M_IX86
        IsolationAwarePrivateT_SqbjaYRiRY ||
#endif
        IsolationAwarePrivatenPgViNgRzlnPgpgk(&ulpCookie);
    if (!fActivateActCtxSuccess)
        return fResult;
    __try
    {
        if (s_pfn == NULL)
        {
            s_pfn = (PFN)CommctrlIsolationAwarePrivatetRgCebPnQQeRff_pbZPgYQP_QYY("DPA_DeleteAllPtrs");
            if (s_pfn == NULL)
                __leave;
        }
        fResult = s_pfn(hdpa);
    }
    __finally
    {
#ifdef _M_IX86
        if (!IsolationAwarePrivateT_SqbjaYRiRY)
#endif
        {
            const BOOL fPreserveLastError = (fResult == FALSE);
            const DWORD dwLastError = fPreserveLastError ? GetLastError() : NO_ERROR;
            (void)IsolationAwareDeactivateActCtx(0, ulpCookie);
            if (fPreserveLastError)
                SetLastError(dwLastError);
        }
    }
    return fResult;
}

ISOLATION_AWARE_INLINE void IsolationAwarePrivatenCv IsolationAwareDPA_EnumCallback(__in HDPA hdpa,__in PFNDAENUMCALLBACK pfnCB,__in_opt void*pData)
{
    typedef void (WINAPI* PFN)(__in HDPA hdpa,__in PFNDAENUMCALLBACK pfnCB,__in_opt void*pData);
    static PFN s_pfn;
    ULONG_PTR  ulpCookie = 0;
    const BOOL fActivateActCtxSuccess =
#ifdef _M_IX86
        IsolationAwarePrivateT_SqbjaYRiRY ||
#endif
        IsolationAwarePrivatenPgViNgRzlnPgpgk(&ulpCookie);
    if (!fActivateActCtxSuccess)
        return;
    __try
    {
        if (s_pfn == NULL)
        {
            s_pfn = (PFN)CommctrlIsolationAwarePrivatetRgCebPnQQeRff_pbZPgYQP_QYY("DPA_EnumCallback");
            if (s_pfn == NULL)
                __leave;
        }
        s_pfn(hdpa,pfnCB,pData);
    }
    __finally
    {
#ifdef _M_IX86
        if (!IsolationAwarePrivateT_SqbjaYRiRY)
#endif
        {
            (void)IsolationAwareDeactivateActCtx(0, ulpCookie);
        }
    }
    return;
}

ISOLATION_AWARE_INLINE BOOL IsolationAwarePrivatenCv IsolationAwareDPA_Grow(__in HDPA pdpa,__in int cp)
{
    BOOL fResult = FALSE;
    typedef BOOL (WINAPI* PFN)(__in HDPA pdpa,__in int cp);
    static PFN s_pfn;
    ULONG_PTR  ulpCookie = 0;
    const BOOL fActivateActCtxSuccess =
#ifdef _M_IX86
        IsolationAwarePrivateT_SqbjaYRiRY ||
#endif
        IsolationAwarePrivatenPgViNgRzlnPgpgk(&ulpCookie);
    if (!fActivateActCtxSuccess)
        return fResult;
    __try
    {
        if (s_pfn == NULL)
        {
            s_pfn = (PFN)CommctrlIsolationAwarePrivatetRgCebPnQQeRff_pbZPgYQP_QYY("DPA_Grow");
            if (s_pfn == NULL)
                __leave;
        }
        fResult = s_pfn(pdpa,cp);
    }
    __finally
    {
#ifdef _M_IX86
        if (!IsolationAwarePrivateT_SqbjaYRiRY)
#endif
        {
            const BOOL fPreserveLastError = (fResult == FALSE);
            const DWORD dwLastError = fPreserveLastError ? GetLastError() : NO_ERROR;
            (void)IsolationAwareDeactivateActCtx(0, ulpCookie);
            if (fPreserveLastError)
                SetLastError(dwLastError);
        }
    }
    return fResult;
}

ISOLATION_AWARE_INLINE int IsolationAwarePrivatenCv IsolationAwareDPA_InsertPtr(__in HDPA hdpa,__in int i,__in_opt void*p)
{
    int nResult = -1;
    typedef int (WINAPI* PFN)(__in HDPA hdpa,__in int i,__in_opt void*p);
    static PFN s_pfn;
    ULONG_PTR  ulpCookie = 0;
    const BOOL fActivateActCtxSuccess =
#ifdef _M_IX86
        IsolationAwarePrivateT_SqbjaYRiRY ||
#endif
        IsolationAwarePrivatenPgViNgRzlnPgpgk(&ulpCookie);
    if (!fActivateActCtxSuccess)
        return nResult;
    __try
    {
        if (s_pfn == NULL)
        {
            s_pfn = (PFN)CommctrlIsolationAwarePrivatetRgCebPnQQeRff_pbZPgYQP_QYY("DPA_InsertPtr");
            if (s_pfn == NULL)
                __leave;
        }
        nResult = s_pfn(hdpa,i,p);
    }
    __finally
    {
#ifdef _M_IX86
        if (!IsolationAwarePrivateT_SqbjaYRiRY)
#endif
        {
            const BOOL fPreserveLastError = (nResult == -1);
            const DWORD dwLastError = fPreserveLastError ? GetLastError() : NO_ERROR;
            (void)IsolationAwareDeactivateActCtx(0, ulpCookie);
            if (fPreserveLastError)
                SetLastError(dwLastError);
        }
    }
    return nResult;
}

ISOLATION_AWARE_INLINE BOOL IsolationAwarePrivatenCv IsolationAwareDPA_SetPtr(__in HDPA hdpa,__in int i,__in_opt void*p)
{
    BOOL fResult = FALSE;
    typedef BOOL (WINAPI* PFN)(__in HDPA hdpa,__in int i,__in_opt void*p);
    static PFN s_pfn;
    ULONG_PTR  ulpCookie = 0;
    const BOOL fActivateActCtxSuccess =
#ifdef _M_IX86
        IsolationAwarePrivateT_SqbjaYRiRY ||
#endif
        IsolationAwarePrivatenPgViNgRzlnPgpgk(&ulpCookie);
    if (!fActivateActCtxSuccess)
        return fResult;
    __try
    {
        if (s_pfn == NULL)
        {
            s_pfn = (PFN)CommctrlIsolationAwarePrivatetRgCebPnQQeRff_pbZPgYQP_QYY("DPA_SetPtr");
            if (s_pfn == NULL)
                __leave;
        }
        fResult = s_pfn(hdpa,i,p);
    }
    __finally
    {
#ifdef _M_IX86
        if (!IsolationAwarePrivateT_SqbjaYRiRY)
#endif
        {
            const BOOL fPreserveLastError = (fResult == FALSE);
            const DWORD dwLastError = fPreserveLastError ? GetLastError() : NO_ERROR;
            (void)IsolationAwareDeactivateActCtx(0, ulpCookie);
            if (fPreserveLastError)
                SetLastError(dwLastError);
        }
    }
    return fResult;
}

ISOLATION_AWARE_INLINE PVOID IsolationAwarePrivatenCv IsolationAwareDPA_GetPtr(__in HDPA hdpa,__in INT_PTR i)
{
    PVOID vResult = NULL;
    typedef PVOID (WINAPI* PFN)(__in HDPA hdpa,__in INT_PTR i);
    static PFN s_pfn;
    ULONG_PTR  ulpCookie = 0;
    const BOOL fActivateActCtxSuccess =
#ifdef _M_IX86
        IsolationAwarePrivateT_SqbjaYRiRY ||
#endif
        IsolationAwarePrivatenPgViNgRzlnPgpgk(&ulpCookie);
    if (!fActivateActCtxSuccess)
        return vResult;
    __try
    {
        if (s_pfn == NULL)
        {
            s_pfn = (PFN)CommctrlIsolationAwarePrivatetRgCebPnQQeRff_pbZPgYQP_QYY("DPA_GetPtr");
            if (s_pfn == NULL)
                __leave;
        }
        vResult = s_pfn(hdpa,i);
    }
    __finally
    {
#ifdef _M_IX86
        if (!IsolationAwarePrivateT_SqbjaYRiRY)
#endif
        {
            const BOOL fPreserveLastError = (vResult == NULL);
            const DWORD dwLastError = fPreserveLastError ? GetLastError() : NO_ERROR;
            (void)IsolationAwareDeactivateActCtx(0, ulpCookie);
            if (fPreserveLastError)
                SetLastError(dwLastError);
        }
    }
    return vResult;
}

ISOLATION_AWARE_INLINE int IsolationAwarePrivatenCv IsolationAwareDPA_GetPtrIndex(__in HDPA hdpa,__in const void*p)
{
    int nResult = -1;
    typedef int (WINAPI* PFN)(__in HDPA hdpa,__in const void*p);
    static PFN s_pfn;
    ULONG_PTR  ulpCookie = 0;
    const BOOL fActivateActCtxSuccess =
#ifdef _M_IX86
        IsolationAwarePrivateT_SqbjaYRiRY ||
#endif
        IsolationAwarePrivatenPgViNgRzlnPgpgk(&ulpCookie);
    if (!fActivateActCtxSuccess)
        return nResult;
    __try
    {
        if (s_pfn == NULL)
        {
            s_pfn = (PFN)CommctrlIsolationAwarePrivatetRgCebPnQQeRff_pbZPgYQP_QYY("DPA_GetPtrIndex");
            if (s_pfn == NULL)
                __leave;
        }
        nResult = s_pfn(hdpa,p);
    }
    __finally
    {
#ifdef _M_IX86
        if (!IsolationAwarePrivateT_SqbjaYRiRY)
#endif
        {
            const BOOL fPreserveLastError = (nResult == -1);
            const DWORD dwLastError = fPreserveLastError ? GetLastError() : NO_ERROR;
            (void)IsolationAwareDeactivateActCtx(0, ulpCookie);
            if (fPreserveLastError)
                SetLastError(dwLastError);
        }
    }
    return nResult;
}

ISOLATION_AWARE_INLINE ULONGLONG IsolationAwarePrivatenCv IsolationAwareDPA_GetSize(__in HDPA hdpa)
{
    ULONGLONG result = 0 ;
    typedef ULONGLONG (WINAPI* PFN)(__in HDPA hdpa);
    static PFN s_pfn;
    ULONG_PTR  ulpCookie = 0;
    const BOOL fActivateActCtxSuccess =
#ifdef _M_IX86
        IsolationAwarePrivateT_SqbjaYRiRY ||
#endif
        IsolationAwarePrivatenPgViNgRzlnPgpgk(&ulpCookie);
    if (!fActivateActCtxSuccess)
        return result;
    __try
    {
        if (s_pfn == NULL)
        {
            s_pfn = (PFN)CommctrlIsolationAwarePrivatetRgCebPnQQeRff_pbZPgYQP_QYY("DPA_GetSize");
            if (s_pfn == NULL)
                __leave;
        }
        result = s_pfn(hdpa);
    }
    __finally
    {
#ifdef _M_IX86
        if (!IsolationAwarePrivateT_SqbjaYRiRY)
#endif
        {
            const BOOL fPreserveLastError = (result == 0 );
            const DWORD dwLastError = fPreserveLastError ? GetLastError() : NO_ERROR;
            (void)IsolationAwareDeactivateActCtx(0, ulpCookie);
            if (fPreserveLastError)
                SetLastError(dwLastError);
        }
    }
    return result;
}

ISOLATION_AWARE_INLINE BOOL IsolationAwarePrivatenCv IsolationAwareDPA_Sort(__in HDPA hdpa,__in PFNDACOMPARE pfnCompare,__in LPARAM lParam)
{
    BOOL fResult = FALSE;
    typedef BOOL (WINAPI* PFN)(__in HDPA hdpa,__in PFNDACOMPARE pfnCompare,__in LPARAM lParam);
    static PFN s_pfn;
    ULONG_PTR  ulpCookie = 0;
    const BOOL fActivateActCtxSuccess =
#ifdef _M_IX86
        IsolationAwarePrivateT_SqbjaYRiRY ||
#endif
        IsolationAwarePrivatenPgViNgRzlnPgpgk(&ulpCookie);
    if (!fActivateActCtxSuccess)
        return fResult;
    __try
    {
        if (s_pfn == NULL)
        {
            s_pfn = (PFN)CommctrlIsolationAwarePrivatetRgCebPnQQeRff_pbZPgYQP_QYY("DPA_Sort");
            if (s_pfn == NULL)
                __leave;
        }
        fResult = s_pfn(hdpa,pfnCompare,lParam);
    }
    __finally
    {
#ifdef _M_IX86
        if (!IsolationAwarePrivateT_SqbjaYRiRY)
#endif
        {
            const BOOL fPreserveLastError = (fResult == FALSE);
            const DWORD dwLastError = fPreserveLastError ? GetLastError() : NO_ERROR;
            (void)IsolationAwareDeactivateActCtx(0, ulpCookie);
            if (fPreserveLastError)
                SetLastError(dwLastError);
        }
    }
    return fResult;
}

ISOLATION_AWARE_INLINE HRESULT IsolationAwarePrivatenCv IsolationAwareDPA_LoadStream(__out HDPA*phdpa,__in PFNDPASTREAM pfn,__in struct IStream*pstream,__in_opt void*pvInstData)
{
    HRESULT result = S_OK;
    typedef HRESULT (WINAPI* PFN)(__out HDPA*phdpa,__in PFNDPASTREAM pfn,__in struct IStream*pstream,__in_opt void*pvInstData);
    static PFN s_pfn;
    ULONG_PTR  ulpCookie = 0;
    const BOOL fActivateActCtxSuccess =
#ifdef _M_IX86
        IsolationAwarePrivateT_SqbjaYRiRY ||
#endif
        IsolationAwarePrivatenPgViNgRzlnPgpgk(&ulpCookie);
    if (!fActivateActCtxSuccess)
        return CommctrlIsolationAwarePrivateJVaQPGbueRfhYg();
    __try
    {
        if (s_pfn == NULL)
        {
            s_pfn = (PFN)CommctrlIsolationAwarePrivatetRgCebPnQQeRff_pbZPgYQP_QYY("DPA_LoadStream");
            if (s_pfn == NULL)
            {
                result = CommctrlIsolationAwarePrivateJVaQPGbueRfhYg();
                __leave;
            }
        }
        result = s_pfn(phdpa,pfn,pstream,pvInstData);
    }
    __finally
    {
#ifdef _M_IX86
        if (!IsolationAwarePrivateT_SqbjaYRiRY)
#endif
        {
            (void)IsolationAwareDeactivateActCtx(0, ulpCookie);
        }
    }
    return result;
}

ISOLATION_AWARE_INLINE HRESULT IsolationAwarePrivatenCv IsolationAwareDPA_SaveStream(__in HDPA hdpa,__in PFNDPASTREAM pfn,__in struct IStream*pstream,__in_opt void*pvInstData)
{
    HRESULT result = S_OK;
    typedef HRESULT (WINAPI* PFN)(__in HDPA hdpa,__in PFNDPASTREAM pfn,__in struct IStream*pstream,__in_opt void*pvInstData);
    static PFN s_pfn;
    ULONG_PTR  ulpCookie = 0;
    const BOOL fActivateActCtxSuccess =
#ifdef _M_IX86
        IsolationAwarePrivateT_SqbjaYRiRY ||
#endif
        IsolationAwarePrivatenPgViNgRzlnPgpgk(&ulpCookie);
    if (!fActivateActCtxSuccess)
        return CommctrlIsolationAwarePrivateJVaQPGbueRfhYg();
    __try
    {
        if (s_pfn == NULL)
        {
            s_pfn = (PFN)CommctrlIsolationAwarePrivatetRgCebPnQQeRff_pbZPgYQP_QYY("DPA_SaveStream");
            if (s_pfn == NULL)
            {
                result = CommctrlIsolationAwarePrivateJVaQPGbueRfhYg();
                __leave;
            }
        }
        result = s_pfn(hdpa,pfn,pstream,pvInstData);
    }
    __finally
    {
#ifdef _M_IX86
        if (!IsolationAwarePrivateT_SqbjaYRiRY)
#endif
        {
            (void)IsolationAwareDeactivateActCtx(0, ulpCookie);
        }
    }
    return result;
}

ISOLATION_AWARE_INLINE BOOL IsolationAwarePrivatenCv IsolationAwareDPA_Merge(__in HDPA hdpaDest,__in HDPA hdpaSrc,__in DWORD dwFlags,__in PFNDACOMPARE pfnCompare,__in PFNDPAMERGE pfnMerge,__in LPARAM lParam)
{
    BOOL fResult = FALSE;
    typedef BOOL (WINAPI* PFN)(__in HDPA hdpaDest,__in HDPA hdpaSrc,__in DWORD dwFlags,__in PFNDACOMPARE pfnCompare,__in PFNDPAMERGE pfnMerge,__in LPARAM lParam);
    static PFN s_pfn;
    ULONG_PTR  ulpCookie = 0;
    const BOOL fActivateActCtxSuccess =
#ifdef _M_IX86
        IsolationAwarePrivateT_SqbjaYRiRY ||
#endif
        IsolationAwarePrivatenPgViNgRzlnPgpgk(&ulpCookie);
    if (!fActivateActCtxSuccess)
        return fResult;
    __try
    {
        if (s_pfn == NULL)
        {
            s_pfn = (PFN)CommctrlIsolationAwarePrivatetRgCebPnQQeRff_pbZPgYQP_QYY("DPA_Merge");
            if (s_pfn == NULL)
                __leave;
        }
        fResult = s_pfn(hdpaDest,hdpaSrc,dwFlags,pfnCompare,pfnMerge,lParam);
    }
    __finally
    {
#ifdef _M_IX86
        if (!IsolationAwarePrivateT_SqbjaYRiRY)
#endif
        {
            const BOOL fPreserveLastError = (fResult == FALSE);
            const DWORD dwLastError = fPreserveLastError ? GetLastError() : NO_ERROR;
            (void)IsolationAwareDeactivateActCtx(0, ulpCookie);
            if (fPreserveLastError)
                SetLastError(dwLastError);
        }
    }
    return fResult;
}

ISOLATION_AWARE_INLINE int IsolationAwarePrivatenCv IsolationAwareDPA_Search(__in HDPA hdpa,__in_opt void*pFind,__in int iStart,__in PFNDACOMPARE pfnCompare,__in LPARAM lParam,__in UINT options)
{
    int nResult = -1;
    typedef int (WINAPI* PFN)(__in HDPA hdpa,__in_opt void*pFind,__in int iStart,__in PFNDACOMPARE pfnCompare,__in LPARAM lParam,__in UINT options);
    static PFN s_pfn;
    ULONG_PTR  ulpCookie = 0;
    const BOOL fActivateActCtxSuccess =
#ifdef _M_IX86
        IsolationAwarePrivateT_SqbjaYRiRY ||
#endif
        IsolationAwarePrivatenPgViNgRzlnPgpgk(&ulpCookie);
    if (!fActivateActCtxSuccess)
        return nResult;
    __try
    {
        if (s_pfn == NULL)
        {
            s_pfn = (PFN)CommctrlIsolationAwarePrivatetRgCebPnQQeRff_pbZPgYQP_QYY("DPA_Search");
            if (s_pfn == NULL)
                __leave;
        }
        nResult = s_pfn(hdpa,pFind,iStart,pfnCompare,lParam,options);
    }
    __finally
    {
#ifdef _M_IX86
        if (!IsolationAwarePrivateT_SqbjaYRiRY)
#endif
        {
            const BOOL fPreserveLastError = (nResult == -1);
            const DWORD dwLastError = fPreserveLastError ? GetLastError() : NO_ERROR;
            (void)IsolationAwareDeactivateActCtx(0, ulpCookie);
            if (fPreserveLastError)
                SetLastError(dwLastError);
        }
    }
    return nResult;
}

ISOLATION_AWARE_INLINE BOOL IsolationAwarePrivatenCv IsolationAwareStr_SetPtrW(__deref_inout_opt LPWSTR*ppsz,LPCWSTR psz)
{
    BOOL fResult = FALSE;
    typedef BOOL (WINAPI* PFN)(__deref_inout_opt LPWSTR*ppsz,LPCWSTR psz);
    static PFN s_pfn;
    ULONG_PTR  ulpCookie = 0;
    const BOOL fActivateActCtxSuccess =
#ifdef _M_IX86
        IsolationAwarePrivateT_SqbjaYRiRY ||
#endif
        IsolationAwarePrivatenPgViNgRzlnPgpgk(&ulpCookie);
    if (!fActivateActCtxSuccess)
        return fResult;
    __try
    {
        if (s_pfn == NULL)
        {
            s_pfn = (PFN)CommctrlIsolationAwarePrivatetRgCebPnQQeRff_pbZPgYQP_QYY("Str_SetPtrW");
            if (s_pfn == NULL)
                __leave;
        }
        fResult = s_pfn(ppsz,psz);
    }
    __finally
    {
#ifdef _M_IX86
        if (!IsolationAwarePrivateT_SqbjaYRiRY)
#endif
        {
            const BOOL fPreserveLastError = (fResult == FALSE);
            const DWORD dwLastError = fPreserveLastError ? GetLastError() : NO_ERROR;
            (void)IsolationAwareDeactivateActCtx(0, ulpCookie);
            if (fPreserveLastError)
                SetLastError(dwLastError);
        }
    }
    return fResult;
}

#if !defined(NOTRACKMOUSEEVENT)

ISOLATION_AWARE_INLINE BOOL IsolationAwarePrivatenCv IsolationAware_TrackMouseEvent(__inout LPTRACKMOUSEEVENT lpEventTrack)
{
    BOOL fResult = FALSE;
    typedef BOOL (WINAPI* PFN)(__inout LPTRACKMOUSEEVENT lpEventTrack);
    static PFN s_pfn;
    ULONG_PTR  ulpCookie = 0;
    const BOOL fActivateActCtxSuccess =
#ifdef _M_IX86
        IsolationAwarePrivateT_SqbjaYRiRY ||
#endif
        IsolationAwarePrivatenPgViNgRzlnPgpgk(&ulpCookie);
    if (!fActivateActCtxSuccess)
        return fResult;
    __try
    {
        if (s_pfn == NULL)
        {
            s_pfn = (PFN)CommctrlIsolationAwarePrivatetRgCebPnQQeRff_pbZPgYQP_QYY("_TrackMouseEvent");
            if (s_pfn == NULL)
                __leave;
        }
        fResult = s_pfn(lpEventTrack);
    }
    __finally
    {
#ifdef _M_IX86
        if (!IsolationAwarePrivateT_SqbjaYRiRY)
#endif
        {
            const BOOL fPreserveLastError = (fResult == FALSE);
            const DWORD dwLastError = fPreserveLastError ? GetLastError() : NO_ERROR;
            (void)IsolationAwareDeactivateActCtx(0, ulpCookie);
            if (fPreserveLastError)
                SetLastError(dwLastError);
        }
    }
    return fResult;
}

#endif /* !defined(NOTRACKMOUSEEVENT) */

ISOLATION_AWARE_INLINE BOOL IsolationAwarePrivatenCv IsolationAwareFlatSB_EnableScrollBar(HWND unnamed1,int unnamed2,UINT unnamed3)
{
    BOOL fResult = FALSE;
    typedef BOOL (WINAPI* PFN)(HWND unnamed1,int unnamed2,UINT unnamed3);
    static PFN s_pfn;
    ULONG_PTR  ulpCookie = 0;
    const BOOL fActivateActCtxSuccess =
#ifdef _M_IX86
        IsolationAwarePrivateT_SqbjaYRiRY ||
#endif
        IsolationAwarePrivatenPgViNgRzlnPgpgk(&ulpCookie);
    if (!fActivateActCtxSuccess)
        return fResult;
    __try
    {
        if (s_pfn == NULL)
        {
            s_pfn = (PFN)CommctrlIsolationAwarePrivatetRgCebPnQQeRff_pbZPgYQP_QYY("FlatSB_EnableScrollBar");
            if (s_pfn == NULL)
                __leave;
        }
        fResult = s_pfn(unnamed1,unnamed2,unnamed3);
    }
    __finally
    {
#ifdef _M_IX86
        if (!IsolationAwarePrivateT_SqbjaYRiRY)
#endif
        {
            const BOOL fPreserveLastError = (fResult == FALSE);
            const DWORD dwLastError = fPreserveLastError ? GetLastError() : NO_ERROR;
            (void)IsolationAwareDeactivateActCtx(0, ulpCookie);
            if (fPreserveLastError)
                SetLastError(dwLastError);
        }
    }
    return fResult;
}

ISOLATION_AWARE_INLINE BOOL IsolationAwarePrivatenCv IsolationAwareFlatSB_ShowScrollBar(HWND unnamed1,int code,BOOL unnamed2)
{
    BOOL fResult = FALSE;
    typedef BOOL (WINAPI* PFN)(HWND unnamed1,int code,BOOL unnamed2);
    static PFN s_pfn;
    ULONG_PTR  ulpCookie = 0;
    const BOOL fActivateActCtxSuccess =
#ifdef _M_IX86
        IsolationAwarePrivateT_SqbjaYRiRY ||
#endif
        IsolationAwarePrivatenPgViNgRzlnPgpgk(&ulpCookie);
    if (!fActivateActCtxSuccess)
        return fResult;
    __try
    {
        if (s_pfn == NULL)
        {
            s_pfn = (PFN)CommctrlIsolationAwarePrivatetRgCebPnQQeRff_pbZPgYQP_QYY("FlatSB_ShowScrollBar");
            if (s_pfn == NULL)
                __leave;
        }
        fResult = s_pfn(unnamed1,code,unnamed2);
    }
    __finally
    {
#ifdef _M_IX86
        if (!IsolationAwarePrivateT_SqbjaYRiRY)
#endif
        {
            const BOOL fPreserveLastError = (fResult == FALSE);
            const DWORD dwLastError = fPreserveLastError ? GetLastError() : NO_ERROR;
            (void)IsolationAwareDeactivateActCtx(0, ulpCookie);
            if (fPreserveLastError)
                SetLastError(dwLastError);
        }
    }
    return fResult;
}

ISOLATION_AWARE_INLINE BOOL IsolationAwarePrivatenCv IsolationAwareFlatSB_GetScrollRange(HWND unnamed1,int code,LPINT unnamed2,LPINT unnamed3)
{
    BOOL fResult = FALSE;
    typedef BOOL (WINAPI* PFN)(HWND unnamed1,int code,LPINT unnamed2,LPINT unnamed3);
    static PFN s_pfn;
    ULONG_PTR  ulpCookie = 0;
    const BOOL fActivateActCtxSuccess =
#ifdef _M_IX86
        IsolationAwarePrivateT_SqbjaYRiRY ||
#endif
        IsolationAwarePrivatenPgViNgRzlnPgpgk(&ulpCookie);
    if (!fActivateActCtxSuccess)
        return fResult;
    __try
    {
        if (s_pfn == NULL)
        {
            s_pfn = (PFN)CommctrlIsolationAwarePrivatetRgCebPnQQeRff_pbZPgYQP_QYY("FlatSB_GetScrollRange");
            if (s_pfn == NULL)
                __leave;
        }
        fResult = s_pfn(unnamed1,code,unnamed2,unnamed3);
    }
    __finally
    {
#ifdef _M_IX86
        if (!IsolationAwarePrivateT_SqbjaYRiRY)
#endif
        {
            const BOOL fPreserveLastError = (fResult == FALSE);
            const DWORD dwLastError = fPreserveLastError ? GetLastError() : NO_ERROR;
            (void)IsolationAwareDeactivateActCtx(0, ulpCookie);
            if (fPreserveLastError)
                SetLastError(dwLastError);
        }
    }
    return fResult;
}

ISOLATION_AWARE_INLINE BOOL IsolationAwarePrivatenCv IsolationAwareFlatSB_GetScrollInfo(HWND unnamed1,int code,LPSCROLLINFO unnamed2)
{
    BOOL fResult = FALSE;
    typedef BOOL (WINAPI* PFN)(HWND unnamed1,int code,LPSCROLLINFO unnamed2);
    static PFN s_pfn;
    ULONG_PTR  ulpCookie = 0;
    const BOOL fActivateActCtxSuccess =
#ifdef _M_IX86
        IsolationAwarePrivateT_SqbjaYRiRY ||
#endif
        IsolationAwarePrivatenPgViNgRzlnPgpgk(&ulpCookie);
    if (!fActivateActCtxSuccess)
        return fResult;
    __try
    {
        if (s_pfn == NULL)
        {
            s_pfn = (PFN)CommctrlIsolationAwarePrivatetRgCebPnQQeRff_pbZPgYQP_QYY("FlatSB_GetScrollInfo");
            if (s_pfn == NULL)
                __leave;
        }
        fResult = s_pfn(unnamed1,code,unnamed2);
    }
    __finally
    {
#ifdef _M_IX86
        if (!IsolationAwarePrivateT_SqbjaYRiRY)
#endif
        {
            const BOOL fPreserveLastError = (fResult == FALSE);
            const DWORD dwLastError = fPreserveLastError ? GetLastError() : NO_ERROR;
            (void)IsolationAwareDeactivateActCtx(0, ulpCookie);
            if (fPreserveLastError)
                SetLastError(dwLastError);
        }
    }
    return fResult;
}

ISOLATION_AWARE_INLINE int IsolationAwarePrivatenCv IsolationAwareFlatSB_GetScrollPos(HWND unnamed1,int code)
{
    int nResult = 0 ;
    typedef int (WINAPI* PFN)(HWND unnamed1,int code);
    static PFN s_pfn;
    ULONG_PTR  ulpCookie = 0;
    const BOOL fActivateActCtxSuccess =
#ifdef _M_IX86
        IsolationAwarePrivateT_SqbjaYRiRY ||
#endif
        IsolationAwarePrivatenPgViNgRzlnPgpgk(&ulpCookie);
    if (!fActivateActCtxSuccess)
        return nResult;
    __try
    {
        if (s_pfn == NULL)
        {
            s_pfn = (PFN)CommctrlIsolationAwarePrivatetRgCebPnQQeRff_pbZPgYQP_QYY("FlatSB_GetScrollPos");
            if (s_pfn == NULL)
                __leave;
        }
        nResult = s_pfn(unnamed1,code);
    }
    __finally
    {
#ifdef _M_IX86
        if (!IsolationAwarePrivateT_SqbjaYRiRY)
#endif
        {
            const BOOL fPreserveLastError = (nResult == 0 );
            const DWORD dwLastError = fPreserveLastError ? GetLastError() : NO_ERROR;
            (void)IsolationAwareDeactivateActCtx(0, ulpCookie);
            if (fPreserveLastError)
                SetLastError(dwLastError);
        }
    }
    return nResult;
}

ISOLATION_AWARE_INLINE BOOL IsolationAwarePrivatenCv IsolationAwareFlatSB_GetScrollProp(HWND unnamed1,int propIndex,LPINT unnamed2)
{
    BOOL fResult = FALSE;
    typedef BOOL (WINAPI* PFN)(HWND unnamed1,int propIndex,LPINT unnamed2);
    static PFN s_pfn;
    ULONG_PTR  ulpCookie = 0;
    const BOOL fActivateActCtxSuccess =
#ifdef _M_IX86
        IsolationAwarePrivateT_SqbjaYRiRY ||
#endif
        IsolationAwarePrivatenPgViNgRzlnPgpgk(&ulpCookie);
    if (!fActivateActCtxSuccess)
        return fResult;
    __try
    {
        if (s_pfn == NULL)
        {
            s_pfn = (PFN)CommctrlIsolationAwarePrivatetRgCebPnQQeRff_pbZPgYQP_QYY("FlatSB_GetScrollProp");
            if (s_pfn == NULL)
                __leave;
        }
        fResult = s_pfn(unnamed1,propIndex,unnamed2);
    }
    __finally
    {
#ifdef _M_IX86
        if (!IsolationAwarePrivateT_SqbjaYRiRY)
#endif
        {
            const BOOL fPreserveLastError = (fResult == FALSE);
            const DWORD dwLastError = fPreserveLastError ? GetLastError() : NO_ERROR;
            (void)IsolationAwareDeactivateActCtx(0, ulpCookie);
            if (fPreserveLastError)
                SetLastError(dwLastError);
        }
    }
    return fResult;
}

ISOLATION_AWARE_INLINE BOOL IsolationAwarePrivatenCv IsolationAwareFlatSB_GetScrollPropPtr(HWND unnamed1,int propIndex,PINT_PTR unnamed2)
{
    BOOL fResult = FALSE;
    typedef BOOL (WINAPI* PFN)(HWND unnamed1,int propIndex,PINT_PTR unnamed2);
    static PFN s_pfn;
    ULONG_PTR  ulpCookie = 0;
    const BOOL fActivateActCtxSuccess =
#ifdef _M_IX86
        IsolationAwarePrivateT_SqbjaYRiRY ||
#endif
        IsolationAwarePrivatenPgViNgRzlnPgpgk(&ulpCookie);
    if (!fActivateActCtxSuccess)
        return fResult;
    __try
    {
        if (s_pfn == NULL)
        {
            s_pfn = (PFN)CommctrlIsolationAwarePrivatetRgCebPnQQeRff_pbZPgYQP_QYY(
#ifdef _WIN64
            "FlatSB_GetScrollPropPtr"
#else
            "FlatSB_GetScrollProp"
#endif
            );
            if (s_pfn == NULL)
                __leave;
        }
        fResult = s_pfn(unnamed1,propIndex,unnamed2);
    }
    __finally
    {
#ifdef _M_IX86
        if (!IsolationAwarePrivateT_SqbjaYRiRY)
#endif
        {
            const BOOL fPreserveLastError = (fResult == FALSE);
            const DWORD dwLastError = fPreserveLastError ? GetLastError() : NO_ERROR;
            (void)IsolationAwareDeactivateActCtx(0, ulpCookie);
            if (fPreserveLastError)
                SetLastError(dwLastError);
        }
    }
    return fResult;
}

ISOLATION_AWARE_INLINE int IsolationAwarePrivatenCv IsolationAwareFlatSB_SetScrollPos(HWND unnamed1,int code,int pos,BOOL fRedraw)
{
    int nResult = 0 ;
    typedef int (WINAPI* PFN)(HWND unnamed1,int code,int pos,BOOL fRedraw);
    static PFN s_pfn;
    ULONG_PTR  ulpCookie = 0;
    const BOOL fActivateActCtxSuccess =
#ifdef _M_IX86
        IsolationAwarePrivateT_SqbjaYRiRY ||
#endif
        IsolationAwarePrivatenPgViNgRzlnPgpgk(&ulpCookie);
    if (!fActivateActCtxSuccess)
        return nResult;
    __try
    {
        if (s_pfn == NULL)
        {
            s_pfn = (PFN)CommctrlIsolationAwarePrivatetRgCebPnQQeRff_pbZPgYQP_QYY("FlatSB_SetScrollPos");
            if (s_pfn == NULL)
                __leave;
        }
        nResult = s_pfn(unnamed1,code,pos,fRedraw);
    }
    __finally
    {
#ifdef _M_IX86
        if (!IsolationAwarePrivateT_SqbjaYRiRY)
#endif
        {
            const BOOL fPreserveLastError = (nResult == 0 );
            const DWORD dwLastError = fPreserveLastError ? GetLastError() : NO_ERROR;
            (void)IsolationAwareDeactivateActCtx(0, ulpCookie);
            if (fPreserveLastError)
                SetLastError(dwLastError);
        }
    }
    return nResult;
}

ISOLATION_AWARE_INLINE int IsolationAwarePrivatenCv IsolationAwareFlatSB_SetScrollInfo(HWND unnamed1,int code,LPSCROLLINFO psi,BOOL fRedraw)
{
    int nResult = 0 ;
    typedef int (WINAPI* PFN)(HWND unnamed1,int code,LPSCROLLINFO psi,BOOL fRedraw);
    static PFN s_pfn;
    ULONG_PTR  ulpCookie = 0;
    const BOOL fActivateActCtxSuccess =
#ifdef _M_IX86
        IsolationAwarePrivateT_SqbjaYRiRY ||
#endif
        IsolationAwarePrivatenPgViNgRzlnPgpgk(&ulpCookie);
    if (!fActivateActCtxSuccess)
        return nResult;
    __try
    {
        if (s_pfn == NULL)
        {
            s_pfn = (PFN)CommctrlIsolationAwarePrivatetRgCebPnQQeRff_pbZPgYQP_QYY("FlatSB_SetScrollInfo");
            if (s_pfn == NULL)
                __leave;
        }
        nResult = s_pfn(unnamed1,code,psi,fRedraw);
    }
    __finally
    {
#ifdef _M_IX86
        if (!IsolationAwarePrivateT_SqbjaYRiRY)
#endif
        {
            const BOOL fPreserveLastError = (nResult == 0 );
            const DWORD dwLastError = fPreserveLastError ? GetLastError() : NO_ERROR;
            (void)IsolationAwareDeactivateActCtx(0, ulpCookie);
            if (fPreserveLastError)
                SetLastError(dwLastError);
        }
    }
    return nResult;
}

ISOLATION_AWARE_INLINE int IsolationAwarePrivatenCv IsolationAwareFlatSB_SetScrollRange(HWND unnamed1,int code,int min,int max,BOOL fRedraw)
{
    int nResult = 0 ;
    typedef int (WINAPI* PFN)(HWND unnamed1,int code,int min,int max,BOOL fRedraw);
    static PFN s_pfn;
    ULONG_PTR  ulpCookie = 0;
    const BOOL fActivateActCtxSuccess =
#ifdef _M_IX86
        IsolationAwarePrivateT_SqbjaYRiRY ||
#endif
        IsolationAwarePrivatenPgViNgRzlnPgpgk(&ulpCookie);
    if (!fActivateActCtxSuccess)
        return nResult;
    __try
    {
        if (s_pfn == NULL)
        {
            s_pfn = (PFN)CommctrlIsolationAwarePrivatetRgCebPnQQeRff_pbZPgYQP_QYY("FlatSB_SetScrollRange");
            if (s_pfn == NULL)
                __leave;
        }
        nResult = s_pfn(unnamed1,code,min,max,fRedraw);
    }
    __finally
    {
#ifdef _M_IX86
        if (!IsolationAwarePrivateT_SqbjaYRiRY)
#endif
        {
            const BOOL fPreserveLastError = (nResult == 0 );
            const DWORD dwLastError = fPreserveLastError ? GetLastError() : NO_ERROR;
            (void)IsolationAwareDeactivateActCtx(0, ulpCookie);
            if (fPreserveLastError)
                SetLastError(dwLastError);
        }
    }
    return nResult;
}

ISOLATION_AWARE_INLINE BOOL IsolationAwarePrivatenCv IsolationAwareFlatSB_SetScrollProp(HWND unnamed1,UINT index,INT_PTR newValue,BOOL unnamed2)
{
    BOOL fResult = FALSE;
    typedef BOOL (WINAPI* PFN)(HWND unnamed1,UINT index,INT_PTR newValue,BOOL unnamed2);
    static PFN s_pfn;
    ULONG_PTR  ulpCookie = 0;
    const BOOL fActivateActCtxSuccess =
#ifdef _M_IX86
        IsolationAwarePrivateT_SqbjaYRiRY ||
#endif
        IsolationAwarePrivatenPgViNgRzlnPgpgk(&ulpCookie);
    if (!fActivateActCtxSuccess)
        return fResult;
    __try
    {
        if (s_pfn == NULL)
        {
            s_pfn = (PFN)CommctrlIsolationAwarePrivatetRgCebPnQQeRff_pbZPgYQP_QYY("FlatSB_SetScrollProp");
            if (s_pfn == NULL)
                __leave;
        }
        fResult = s_pfn(unnamed1,index,newValue,unnamed2);
    }
    __finally
    {
#ifdef _M_IX86
        if (!IsolationAwarePrivateT_SqbjaYRiRY)
#endif
        {
            const BOOL fPreserveLastError = (fResult == FALSE);
            const DWORD dwLastError = fPreserveLastError ? GetLastError() : NO_ERROR;
            (void)IsolationAwareDeactivateActCtx(0, ulpCookie);
            if (fPreserveLastError)
                SetLastError(dwLastError);
        }
    }
    return fResult;
}

ISOLATION_AWARE_INLINE BOOL IsolationAwarePrivatenCv IsolationAwareInitializeFlatSB(HWND unnamed1)
{
    BOOL fResult = FALSE;
    typedef BOOL (WINAPI* PFN)(HWND unnamed1);
    static PFN s_pfn;
    ULONG_PTR  ulpCookie = 0;
    const BOOL fActivateActCtxSuccess =
#ifdef _M_IX86
        IsolationAwarePrivateT_SqbjaYRiRY ||
#endif
        IsolationAwarePrivatenPgViNgRzlnPgpgk(&ulpCookie);
    if (!fActivateActCtxSuccess)
        return fResult;
    __try
    {
        if (s_pfn == NULL)
        {
            s_pfn = (PFN)CommctrlIsolationAwarePrivatetRgCebPnQQeRff_pbZPgYQP_QYY("InitializeFlatSB");
            if (s_pfn == NULL)
                __leave;
        }
        fResult = s_pfn(unnamed1);
    }
    __finally
    {
#ifdef _M_IX86
        if (!IsolationAwarePrivateT_SqbjaYRiRY)
#endif
        {
            const BOOL fPreserveLastError = (fResult == FALSE);
            const DWORD dwLastError = fPreserveLastError ? GetLastError() : NO_ERROR;
            (void)IsolationAwareDeactivateActCtx(0, ulpCookie);
            if (fPreserveLastError)
                SetLastError(dwLastError);
        }
    }
    return fResult;
}

ISOLATION_AWARE_INLINE HRESULT IsolationAwarePrivatenCv IsolationAwareUninitializeFlatSB(HWND unnamed1)
{
    HRESULT result = S_OK;
    typedef HRESULT (WINAPI* PFN)(HWND unnamed1);
    static PFN s_pfn;
    ULONG_PTR  ulpCookie = 0;
    const BOOL fActivateActCtxSuccess =
#ifdef _M_IX86
        IsolationAwarePrivateT_SqbjaYRiRY ||
#endif
        IsolationAwarePrivatenPgViNgRzlnPgpgk(&ulpCookie);
    if (!fActivateActCtxSuccess)
        return CommctrlIsolationAwarePrivateJVaQPGbueRfhYg();
    __try
    {
        if (s_pfn == NULL)
        {
            s_pfn = (PFN)CommctrlIsolationAwarePrivatetRgCebPnQQeRff_pbZPgYQP_QYY("UninitializeFlatSB");
            if (s_pfn == NULL)
            {
                result = CommctrlIsolationAwarePrivateJVaQPGbueRfhYg();
                __leave;
            }
        }
        result = s_pfn(unnamed1);
    }
    __finally
    {
#ifdef _M_IX86
        if (!IsolationAwarePrivateT_SqbjaYRiRY)
#endif
        {
            (void)IsolationAwareDeactivateActCtx(0, ulpCookie);
        }
    }
    return result;
}

#if (_WIN32_IE >= 0x560)

ISOLATION_AWARE_INLINE BOOL IsolationAwarePrivatenCv IsolationAwareSetWindowSubclass(HWND hWnd,SUBCLASSPROC pfnSubclass,UINT_PTR uIdSubclass,DWORD_PTR dwRefData)
{
    BOOL fResult = FALSE;
    typedef BOOL (WINAPI* PFN)(HWND hWnd,SUBCLASSPROC pfnSubclass,UINT_PTR uIdSubclass,DWORD_PTR dwRefData);
    static PFN s_pfn;
    ULONG_PTR  ulpCookie = 0;
    const BOOL fActivateActCtxSuccess =
#ifdef _M_IX86
        IsolationAwarePrivateT_SqbjaYRiRY ||
#endif
        IsolationAwarePrivatenPgViNgRzlnPgpgk(&ulpCookie);
    if (!fActivateActCtxSuccess)
        return fResult;
    __try
    {
        if (s_pfn == NULL)
        {
            s_pfn = (PFN)CommctrlIsolationAwarePrivatetRgCebPnQQeRff_pbZPgYQP_QYY("SetWindowSubclass");
            if (s_pfn == NULL)
                __leave;
        }
        fResult = s_pfn(hWnd,pfnSubclass,uIdSubclass,dwRefData);
    }
    __finally
    {
#ifdef _M_IX86
        if (!IsolationAwarePrivateT_SqbjaYRiRY)
#endif
        {
            const BOOL fPreserveLastError = (fResult == FALSE);
            const DWORD dwLastError = fPreserveLastError ? GetLastError() : NO_ERROR;
            (void)IsolationAwareDeactivateActCtx(0, ulpCookie);
            if (fPreserveLastError)
                SetLastError(dwLastError);
        }
    }
    return fResult;
}

ISOLATION_AWARE_INLINE BOOL IsolationAwarePrivatenCv IsolationAwareGetWindowSubclass(HWND hWnd,SUBCLASSPROC pfnSubclass,UINT_PTR uIdSubclass,DWORD_PTR*pdwRefData)
{
    BOOL fResult = FALSE;
    typedef BOOL (WINAPI* PFN)(HWND hWnd,SUBCLASSPROC pfnSubclass,UINT_PTR uIdSubclass,DWORD_PTR*pdwRefData);
    static PFN s_pfn;
    ULONG_PTR  ulpCookie = 0;
    const BOOL fActivateActCtxSuccess =
#ifdef _M_IX86
        IsolationAwarePrivateT_SqbjaYRiRY ||
#endif
        IsolationAwarePrivatenPgViNgRzlnPgpgk(&ulpCookie);
    if (!fActivateActCtxSuccess)
        return fResult;
    __try
    {
        if (s_pfn == NULL)
        {
            s_pfn = (PFN)CommctrlIsolationAwarePrivatetRgCebPnQQeRff_pbZPgYQP_QYY("GetWindowSubclass");
            if (s_pfn == NULL)
                __leave;
        }
        fResult = s_pfn(hWnd,pfnSubclass,uIdSubclass,pdwRefData);
    }
    __finally
    {
#ifdef _M_IX86
        if (!IsolationAwarePrivateT_SqbjaYRiRY)
#endif
        {
            const BOOL fPreserveLastError = (fResult == FALSE);
            const DWORD dwLastError = fPreserveLastError ? GetLastError() : NO_ERROR;
            (void)IsolationAwareDeactivateActCtx(0, ulpCookie);
            if (fPreserveLastError)
                SetLastError(dwLastError);
        }
    }
    return fResult;
}

ISOLATION_AWARE_INLINE BOOL IsolationAwarePrivatenCv IsolationAwareRemoveWindowSubclass(HWND hWnd,SUBCLASSPROC pfnSubclass,UINT_PTR uIdSubclass)
{
    BOOL fResult = FALSE;
    typedef BOOL (WINAPI* PFN)(HWND hWnd,SUBCLASSPROC pfnSubclass,UINT_PTR uIdSubclass);
    static PFN s_pfn;
    ULONG_PTR  ulpCookie = 0;
    const BOOL fActivateActCtxSuccess =
#ifdef _M_IX86
        IsolationAwarePrivateT_SqbjaYRiRY ||
#endif
        IsolationAwarePrivatenPgViNgRzlnPgpgk(&ulpCookie);
    if (!fActivateActCtxSuccess)
        return fResult;
    __try
    {
        if (s_pfn == NULL)
        {
            s_pfn = (PFN)CommctrlIsolationAwarePrivatetRgCebPnQQeRff_pbZPgYQP_QYY("RemoveWindowSubclass");
            if (s_pfn == NULL)
                __leave;
        }
        fResult = s_pfn(hWnd,pfnSubclass,uIdSubclass);
    }
    __finally
    {
#ifdef _M_IX86
        if (!IsolationAwarePrivateT_SqbjaYRiRY)
#endif
        {
            const BOOL fPreserveLastError = (fResult == FALSE);
            const DWORD dwLastError = fPreserveLastError ? GetLastError() : NO_ERROR;
            (void)IsolationAwareDeactivateActCtx(0, ulpCookie);
            if (fPreserveLastError)
                SetLastError(dwLastError);
        }
    }
    return fResult;
}

#endif /* (_WIN32_IE >= 0x560) */

ISOLATION_AWARE_INLINE LRESULT IsolationAwarePrivatenCv IsolationAwareDefSubclassProc(HWND hWnd,UINT uMsg,WPARAM wParam,LPARAM lParam)
{
    LRESULT result = 0 ;
    typedef LRESULT (WINAPI* PFN)(HWND hWnd,UINT uMsg,WPARAM wParam,LPARAM lParam);
    static PFN s_pfn;
    ULONG_PTR  ulpCookie = 0;
    const BOOL fActivateActCtxSuccess =
#ifdef _M_IX86
        IsolationAwarePrivateT_SqbjaYRiRY ||
#endif
        IsolationAwarePrivatenPgViNgRzlnPgpgk(&ulpCookie);
    if (!fActivateActCtxSuccess)
        return result;
    __try
    {
        if (s_pfn == NULL)
        {
            s_pfn = (PFN)CommctrlIsolationAwarePrivatetRgCebPnQQeRff_pbZPgYQP_QYY("DefSubclassProc");
            if (s_pfn == NULL)
                __leave;
        }
        result = s_pfn(hWnd,uMsg,wParam,lParam);
    }
    __finally
    {
#ifdef _M_IX86
        if (!IsolationAwarePrivateT_SqbjaYRiRY)
#endif
        {
            const BOOL fPreserveLastError = (result == 0 );
            const DWORD dwLastError = fPreserveLastError ? GetLastError() : NO_ERROR;
            (void)IsolationAwareDeactivateActCtx(0, ulpCookie);
            if (fPreserveLastError)
                SetLastError(dwLastError);
        }
    }
    return result;
}

ISOLATION_AWARE_INLINE HRESULT IsolationAwarePrivatenCv IsolationAwareLoadIconMetric(HINSTANCE hinst,PCWSTR pszName,int lims,__out HICON*phico)
{
    HRESULT result = S_OK;
    typedef HRESULT (WINAPI* PFN)(HINSTANCE hinst,PCWSTR pszName,int lims,__out HICON*phico);
    static PFN s_pfn;
    ULONG_PTR  ulpCookie = 0;
    const BOOL fActivateActCtxSuccess =
#ifdef _M_IX86
        IsolationAwarePrivateT_SqbjaYRiRY ||
#endif
        IsolationAwarePrivatenPgViNgRzlnPgpgk(&ulpCookie);
    if (!fActivateActCtxSuccess)
        return CommctrlIsolationAwarePrivateJVaQPGbueRfhYg();
    __try
    {
        if (s_pfn == NULL)
        {
            s_pfn = (PFN)CommctrlIsolationAwarePrivatetRgCebPnQQeRff_pbZPgYQP_QYY("LoadIconMetric");
            if (s_pfn == NULL)
            {
                result = CommctrlIsolationAwarePrivateJVaQPGbueRfhYg();
                __leave;
            }
        }
        result = s_pfn(hinst,pszName,lims,phico);
    }
    __finally
    {
#ifdef _M_IX86
        if (!IsolationAwarePrivateT_SqbjaYRiRY)
#endif
        {
            (void)IsolationAwareDeactivateActCtx(0, ulpCookie);
        }
    }
    return result;
}

ISOLATION_AWARE_INLINE HRESULT IsolationAwarePrivatenCv IsolationAwareLoadIconWithScaleDown(HINSTANCE hinst,PCWSTR pszName,int cx,int cy,__out HICON*phico)
{
    HRESULT result = S_OK;
    typedef HRESULT (WINAPI* PFN)(HINSTANCE hinst,PCWSTR pszName,int cx,int cy,__out HICON*phico);
    static PFN s_pfn;
    ULONG_PTR  ulpCookie = 0;
    const BOOL fActivateActCtxSuccess =
#ifdef _M_IX86
        IsolationAwarePrivateT_SqbjaYRiRY ||
#endif
        IsolationAwarePrivatenPgViNgRzlnPgpgk(&ulpCookie);
    if (!fActivateActCtxSuccess)
        return CommctrlIsolationAwarePrivateJVaQPGbueRfhYg();
    __try
    {
        if (s_pfn == NULL)
        {
            s_pfn = (PFN)CommctrlIsolationAwarePrivatetRgCebPnQQeRff_pbZPgYQP_QYY("LoadIconWithScaleDown");
            if (s_pfn == NULL)
            {
                result = CommctrlIsolationAwarePrivateJVaQPGbueRfhYg();
                __leave;
            }
        }
        result = s_pfn(hinst,pszName,cx,cy,phico);
    }
    __finally
    {
#ifdef _M_IX86
        if (!IsolationAwarePrivateT_SqbjaYRiRY)
#endif
        {
            (void)IsolationAwareDeactivateActCtx(0, ulpCookie);
        }
    }
    return result;
}

ISOLATION_AWARE_INLINE int IsolationAwarePrivatenCv IsolationAwareDrawShadowText(HDC hdc,__in_ecount(cch) LPCWSTR pszText,UINT cch,RECT*prc,DWORD dwFlags,COLORREF crText,COLORREF crShadow,int ixOffset,int iyOffset)
{
    int nResult = -1;
    typedef int (WINAPI* PFN)(HDC hdc,__in_ecount(cch) LPCWSTR pszText,UINT cch,RECT*prc,DWORD dwFlags,COLORREF crText,COLORREF crShadow,int ixOffset,int iyOffset);
    static PFN s_pfn;
    ULONG_PTR  ulpCookie = 0;
    const BOOL fActivateActCtxSuccess =
#ifdef _M_IX86
        IsolationAwarePrivateT_SqbjaYRiRY ||
#endif
        IsolationAwarePrivatenPgViNgRzlnPgpgk(&ulpCookie);
    if (!fActivateActCtxSuccess)
        return nResult;
    __try
    {
        if (s_pfn == NULL)
        {
            s_pfn = (PFN)CommctrlIsolationAwarePrivatetRgCebPnQQeRff_pbZPgYQP_QYY("DrawShadowText");
            if (s_pfn == NULL)
                __leave;
        }
        nResult = s_pfn(hdc,pszText,cch,prc,dwFlags,crText,crShadow,ixOffset,iyOffset);
    }
    __finally
    {
#ifdef _M_IX86
        if (!IsolationAwarePrivateT_SqbjaYRiRY)
#endif
        {
            const BOOL fPreserveLastError = (nResult == -1);
            const DWORD dwLastError = fPreserveLastError ? GetLastError() : NO_ERROR;
            (void)IsolationAwareDeactivateActCtx(0, ulpCookie);
            if (fPreserveLastError)
                SetLastError(dwLastError);
        }
    }
    return nResult;
}

ISOLATION_AWARE_INLINE FARPROC IsolationAwarePrivatenCv CommctrlIsolationAwarePrivatetRgCebPnQQeRff_pbZPgYQP_QYY(LPCSTR pszProcName)
/* This function is shared by the other stubs in this header. */
{
    FARPROC proc = NULL;
    static HMODULE s_module;
    BOOL fActivateActCtxSuccess = FALSE;
    ULONG_PTR ulpCookie = 0;
#ifndef _M_CEE_PURE
    const static IsolationAwarePrivatepBAFGnAG_zBqHyr_vAsB
        c = { IsolationAwarePrivatezlybNQyVOeNelJ, L"Comctl32.dll"
#ifdef _M_IX86
             , IsolationAwarePrivatezlybNQyVOeNeln, "Comctl32.dll"
#endif
    };
#else
    static IsolationAwarePrivatepBAFGnAG_zBqHyr_vAsB c;
    c.WinbaseIsolationAwarePrivateybNQJ = IsolationAwarePrivatezlybNQyVOeNelJ;
    c.WinbaseIsolationAwarePrivateANZRJ = L"Comctl32.dll";
#ifdef _M_IX86
    c.WinbaseIsolationAwarePrivateybNQn = IsolationAwarePrivatezlybNQyVOeNeln;
    c.WinbaseIsolationAwarePrivateANZRn = "Comctl32.dll";
#endif
#endif
    static IsolationAwarePrivatezHGnoyr_zBqHyr_vAsB m;

    __try
    {
#ifdef _M_IX86
        if (!IsolationAwarePrivateT_SqbjaYRiRY)
#endif
        {
            fActivateActCtxSuccess = IsolationAwarePrivatenPgViNgRzlnPgpgk(&ulpCookie);
            if (!fActivateActCtxSuccess)
                __leave;
        }
        proc = IsolationAwarePrivatezltRgCebPnQQeRff(&c, &m, pszProcName);
    }
    __finally
    {
        if (
#ifdef _M_IX86
            !IsolationAwarePrivateT_SqbjaYRiRY &&
#endif
            fActivateActCtxSuccess)
        {
            const DWORD dwLastError = (proc == NULL) ? GetLastError() : NO_ERROR;
            (void)IsolationAwareDeactivateActCtx(0, ulpCookie);
            if (proc == NULL)
                SetLastError(dwLastError);
        }
    }
    return proc;
}

#endif /* ISOLATION_AWARE_USE_STATIC_LIBRARY */

#define CreateMappedBitmap IsolationAwareCreateMappedBitmap
#define CreateStatusWindowA IsolationAwareCreateStatusWindowA
#define CreateStatusWindowW IsolationAwareCreateStatusWindowW
#define CreateToolbarEx IsolationAwareCreateToolbarEx
#define CreateUpDownControl IsolationAwareCreateUpDownControl
#define DPA_Clone IsolationAwareDPA_Clone
#define DPA_Create IsolationAwareDPA_Create
#define DPA_CreateEx IsolationAwareDPA_CreateEx
#define DPA_DeleteAllPtrs IsolationAwareDPA_DeleteAllPtrs
#define DPA_DeletePtr IsolationAwareDPA_DeletePtr
#define DPA_Destroy IsolationAwareDPA_Destroy
#define DPA_DestroyCallback IsolationAwareDPA_DestroyCallback
#define DPA_EnumCallback IsolationAwareDPA_EnumCallback
#define DPA_GetPtr IsolationAwareDPA_GetPtr
#define DPA_GetPtrIndex IsolationAwareDPA_GetPtrIndex
#define DPA_GetSize IsolationAwareDPA_GetSize
#define DPA_Grow IsolationAwareDPA_Grow
#define DPA_InsertPtr IsolationAwareDPA_InsertPtr
#define DPA_LoadStream IsolationAwareDPA_LoadStream
#define DPA_Merge IsolationAwareDPA_Merge
#define DPA_SaveStream IsolationAwareDPA_SaveStream
#define DPA_Search IsolationAwareDPA_Search
#define DPA_SetPtr IsolationAwareDPA_SetPtr
#define DPA_Sort IsolationAwareDPA_Sort
#define DSA_Clone IsolationAwareDSA_Clone
#define DSA_Create IsolationAwareDSA_Create
#define DSA_DeleteAllItems IsolationAwareDSA_DeleteAllItems
#define DSA_DeleteItem IsolationAwareDSA_DeleteItem
#define DSA_Destroy IsolationAwareDSA_Destroy
#define DSA_DestroyCallback IsolationAwareDSA_DestroyCallback
#define DSA_EnumCallback IsolationAwareDSA_EnumCallback
#define DSA_GetItem IsolationAwareDSA_GetItem
#define DSA_GetItemPtr IsolationAwareDSA_GetItemPtr
#define DSA_GetSize IsolationAwareDSA_GetSize
#define DSA_InsertItem IsolationAwareDSA_InsertItem
#define DSA_SetItem IsolationAwareDSA_SetItem
#define DSA_Sort IsolationAwareDSA_Sort
#define DefSubclassProc IsolationAwareDefSubclassProc
#define DrawInsert IsolationAwareDrawInsert
#define DrawShadowText IsolationAwareDrawShadowText
#define DrawStatusTextA IsolationAwareDrawStatusTextA
#define DrawStatusTextW IsolationAwareDrawStatusTextW
#define FlatSB_EnableScrollBar IsolationAwareFlatSB_EnableScrollBar
#define FlatSB_GetScrollInfo IsolationAwareFlatSB_GetScrollInfo
#define FlatSB_GetScrollPos IsolationAwareFlatSB_GetScrollPos
#define FlatSB_GetScrollProp IsolationAwareFlatSB_GetScrollProp
#if defined(FlatSB_GetScrollPropPtr)
#undef FlatSB_GetScrollPropPtr
#endif
#define FlatSB_GetScrollPropPtr IsolationAwareFlatSB_GetScrollPropPtr
#define FlatSB_GetScrollRange IsolationAwareFlatSB_GetScrollRange
#define FlatSB_SetScrollInfo IsolationAwareFlatSB_SetScrollInfo
#define FlatSB_SetScrollPos IsolationAwareFlatSB_SetScrollPos
#define FlatSB_SetScrollProp IsolationAwareFlatSB_SetScrollProp
#define FlatSB_SetScrollRange IsolationAwareFlatSB_SetScrollRange
#define FlatSB_ShowScrollBar IsolationAwareFlatSB_ShowScrollBar
#define GetEffectiveClientRect IsolationAwareGetEffectiveClientRect
#define GetMUILanguage IsolationAwareGetMUILanguage
#define GetWindowSubclass IsolationAwareGetWindowSubclass
#define HIMAGELIST_QueryInterface IsolationAwareHIMAGELIST_QueryInterface
#define ImageList_Add IsolationAwareImageList_Add
#define ImageList_AddMasked IsolationAwareImageList_AddMasked
#define ImageList_BeginDrag IsolationAwareImageList_BeginDrag
#define ImageList_Copy IsolationAwareImageList_Copy
#define ImageList_Create IsolationAwareImageList_Create
#define ImageList_Destroy IsolationAwareImageList_Destroy
#define ImageList_DragEnter IsolationAwareImageList_DragEnter
#define ImageList_DragLeave IsolationAwareImageList_DragLeave
#define ImageList_DragMove IsolationAwareImageList_DragMove
#define ImageList_DragShowNolock IsolationAwareImageList_DragShowNolock
#define ImageList_Draw IsolationAwareImageList_Draw
#define ImageList_DrawEx IsolationAwareImageList_DrawEx
#define ImageList_DrawIndirect IsolationAwareImageList_DrawIndirect
#define ImageList_Duplicate IsolationAwareImageList_Duplicate
#define ImageList_EndDrag IsolationAwareImageList_EndDrag
#define ImageList_GetBkColor IsolationAwareImageList_GetBkColor
#define ImageList_GetDragImage IsolationAwareImageList_GetDragImage
#define ImageList_GetIcon IsolationAwareImageList_GetIcon
#define ImageList_GetIconSize IsolationAwareImageList_GetIconSize
#define ImageList_GetImageCount IsolationAwareImageList_GetImageCount
#define ImageList_GetImageInfo IsolationAwareImageList_GetImageInfo
#define ImageList_LoadImageA IsolationAwareImageList_LoadImageA
#define ImageList_LoadImageW IsolationAwareImageList_LoadImageW
#define ImageList_Merge IsolationAwareImageList_Merge
#define ImageList_Read IsolationAwareImageList_Read
#define ImageList_ReadEx IsolationAwareImageList_ReadEx
#define ImageList_Remove IsolationAwareImageList_Remove
#define ImageList_Replace IsolationAwareImageList_Replace
#define ImageList_ReplaceIcon IsolationAwareImageList_ReplaceIcon
#define ImageList_SetBkColor IsolationAwareImageList_SetBkColor
#define ImageList_SetDragCursorImage IsolationAwareImageList_SetDragCursorImage
#define ImageList_SetIconSize IsolationAwareImageList_SetIconSize
#define ImageList_SetImageCount IsolationAwareImageList_SetImageCount
#define ImageList_SetOverlayImage IsolationAwareImageList_SetOverlayImage
#define ImageList_Write IsolationAwareImageList_Write
#define ImageList_WriteEx IsolationAwareImageList_WriteEx
#define InitCommonControls IsolationAwareInitCommonControls
#define InitCommonControlsEx IsolationAwareInitCommonControlsEx
#define InitMUILanguage IsolationAwareInitMUILanguage
#define InitializeFlatSB IsolationAwareInitializeFlatSB
#define LBItemFromPt IsolationAwareLBItemFromPt
#define LoadIconMetric IsolationAwareLoadIconMetric
#define LoadIconWithScaleDown IsolationAwareLoadIconWithScaleDown
#define MakeDragList IsolationAwareMakeDragList
#define MenuHelp IsolationAwareMenuHelp
#define RemoveWindowSubclass IsolationAwareRemoveWindowSubclass
#define SetWindowSubclass IsolationAwareSetWindowSubclass
#define ShowHideMenuCtl IsolationAwareShowHideMenuCtl
#define Str_SetPtrW IsolationAwareStr_SetPtrW
#define TaskDialog IsolationAwareTaskDialog
#define TaskDialogIndirect IsolationAwareTaskDialogIndirect
#define UninitializeFlatSB IsolationAwareUninitializeFlatSB
#define _TrackMouseEvent IsolationAware_TrackMouseEvent

#endif /* ISOLATION_AWARE_ENABLED */
#endif /* RC */


#if defined(__cplusplus)
} /* __cplusplus */
#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\vs9sp1\sdk\include\CompObj.h ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992-1999.
//
//  File:       compobj.h
//
//----------------------------------------------------------------------------

#if _MSC_VER > 1000
#pragma once
#endif

#ifndef RC_INVOKED
#pragma message("WARNING: your code should #include objbase.h instead of compobj.h")
#endif /* !RC_INVOKED */

#include <objbase.h>
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\vs9sp1\sdk\include\ComAdmin.h ===
/* this ALWAYS GENERATED file contains the definitions for the interfaces */


 /* File created by MIDL compiler version 7.00.0499 */
/* Compiler settings for comadmin.idl:
    Oicf, W1, Zp8, env=Win32 (32b run)
    protocol : dce , ms_ext, c_ext, robust
    error checks: allocation ref bounds_check enum stub_data 
    VC __declspec() decoration level: 
         __declspec(uuid()), __declspec(selectany), __declspec(novtable)
         DECLSPEC_UUID(), MIDL_INTERFACE()
*/
//@@MIDL_FILE_HEADING(  )

#pragma warning( disable: 4049 )  /* more than 64k source lines */


/* verify that the <rpcndr.h> version is high enough to compile this file*/
#ifndef __REQUIRED_RPCNDR_H_VERSION__
#define __REQUIRED_RPCNDR_H_VERSION__ 500
#endif

/* verify that the <rpcsal.h> version is high enough to compile this file*/
#ifndef __REQUIRED_RPCSAL_H_VERSION__
#define __REQUIRED_RPCSAL_H_VERSION__ 100
#endif

#include "rpc.h"
#include "rpcndr.h"

#ifndef __RPCNDR_H_VERSION__
#error this stub requires an updated version of <rpcndr.h>
#endif // __RPCNDR_H_VERSION__

#ifndef COM_NO_WINDOWS_H
#include "windows.h"
#include "ole2.h"
#endif /*COM_NO_WINDOWS_H*/

#ifndef __comadmin_h__
#define __comadmin_h__

#if defined(_MSC_VER) && (_MSC_VER >= 1020)
#pragma once
#endif

/* Forward Declarations */ 

#ifndef __ICOMAdminCatalog_FWD_DEFINED__
#define __ICOMAdminCatalog_FWD_DEFINED__
typedef interface ICOMAdminCatalog ICOMAdminCatalog;
#endif 	/* __ICOMAdminCatalog_FWD_DEFINED__ */


#ifndef __ICOMAdminCatalog2_FWD_DEFINED__
#define __ICOMAdminCatalog2_FWD_DEFINED__
typedef interface ICOMAdminCatalog2 ICOMAdminCatalog2;
#endif 	/* __ICOMAdminCatalog2_FWD_DEFINED__ */


#ifndef __ICatalogObject_FWD_DEFINED__
#define __ICatalogObject_FWD_DEFINED__
typedef interface ICatalogObject ICatalogObject;
#endif 	/* __ICatalogObject_FWD_DEFINED__ */


#ifndef __ICatalogCollection_FWD_DEFINED__
#define __ICatalogCollection_FWD_DEFINED__
typedef interface ICatalogCollection ICatalogCollection;
#endif 	/* __ICatalogCollection_FWD_DEFINED__ */


#ifndef __COMAdminCatalog_FWD_DEFINED__
#define __COMAdminCatalog_FWD_DEFINED__

#ifdef __cplusplus
typedef class COMAdminCatalog COMAdminCatalog;
#else
typedef struct COMAdminCatalog COMAdminCatalog;
#endif /* __cplusplus */

#endif 	/* __COMAdminCatalog_FWD_DEFINED__ */


#ifndef __COMAdminCatalogObject_FWD_DEFINED__
#define __COMAdminCatalogObject_FWD_DEFINED__

#ifdef __cplusplus
typedef class COMAdminCatalogObject COMAdminCatalogObject;
#else
typedef struct COMAdminCatalogObject COMAdminCatalogObject;
#endif /* __cplusplus */

#endif 	/* __COMAdminCatalogObject_FWD_DEFINED__ */


#ifndef __COMAdminCatalogCollection_FWD_DEFINED__
#define __COMAdminCatalogCollection_FWD_DEFINED__

#ifdef __cplusplus
typedef class COMAdminCatalogCollection COMAdminCatalogCollection;
#else
typedef struct COMAdminCatalogCollection COMAdminCatalogCollection;
#endif /* __cplusplus */

#endif 	/* __COMAdminCatalogCollection_FWD_DEFINED__ */


/* header files for imported files */
#include "unknwn.h"
#include "oaidl.h"

#ifdef __cplusplus
extern "C"{
#endif 


/* interface __MIDL_itf_comadmin_0000_0000 */
/* [local] */ 

// -----------------------------------------------------------------------   
// comadmin.h  -- COM Administration Programming Interfaces                  
//                                                                           
// This file provides the prototypes for the APIs and COM interfaces         
// used by Microsoft COM applications.                                       
//                                                                           
// Copyright (c) 1995-2001 Microsoft Corporation.  All Rights Reserved.      
// -----------------------------------------------------------------------   
#include <objbase.h>
#ifndef DECLSPEC_UUID
#if (_MSC_VER >= 1100) && defined (__cplusplus)
#define DECLSPEC_UUID(x)    __declspec(uuid(x))
#else
#define DECLSPEC_UUID(x)
#endif
#endif
#pragma once
#pragma once
#pragma once


extern RPC_IF_HANDLE __MIDL_itf_comadmin_0000_0000_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_comadmin_0000_0000_v0_0_s_ifspec;

#ifndef __ICOMAdminCatalog_INTERFACE_DEFINED__
#define __ICOMAdminCatalog_INTERFACE_DEFINED__

/* interface ICOMAdminCatalog */
/* [unique][helpstring][dual][uuid][object] */ 




EXTERN_C const IID IID_ICOMAdminCatalog;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("DD662187-DFC2-11d1-A2CF-00805FC79235")
    ICOMAdminCatalog : public IDispatch
    {
    public:
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE GetCollection( 
            /* [in] */ __RPC__in BSTR bstrCollName,
            /* [retval][out] */ __RPC__deref_out_opt IDispatch **ppCatalogCollection) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE Connect( 
            /* [in] */ __RPC__in BSTR bstrCatalogServerName,
            /* [retval][out] */ __RPC__deref_out_opt IDispatch **ppCatalogCollection) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_MajorVersion( 
            /* [retval][out] */ __RPC__out long *plMajorVersion) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_MinorVersion( 
            /* [retval][out] */ __RPC__out long *plMinorVersion) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE GetCollectionByQuery( 
            /* [in] */ __RPC__in BSTR bstrCollName,
            /* [in] */ __RPC__deref_in_opt SAFEARRAY * *ppsaVarQuery,
            /* [retval][out] */ __RPC__deref_out_opt IDispatch **ppCatalogCollection) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE ImportComponent( 
            /* [in] */ __RPC__in BSTR bstrApplIDOrName,
            /* [in] */ __RPC__in BSTR bstrCLSIDOrProgID) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE InstallComponent( 
            /* [in] */ __RPC__in BSTR bstrApplIDOrName,
            /* [in] */ __RPC__in BSTR bstrDLL,
            /* [in] */ __RPC__in BSTR bstrTLB,
            /* [in] */ __RPC__in BSTR bstrPSDLL) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE ShutdownApplication( 
            /* [in] */ __RPC__in BSTR bstrApplIDOrName) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE ExportApplication( 
            /* [in] */ __RPC__in BSTR bstrApplIDOrName,
            /* [in] */ __RPC__in BSTR bstrApplicationFile,
            /* [in] */ long lOptions) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE InstallApplication( 
            /* [in] */ __RPC__in BSTR bstrApplicationFile,
            /* [optional][in] */ __RPC__in BSTR bstrDestinationDirectory,
            /* [optional][in] */ long lOptions,
            /* [optional][in] */ __RPC__in BSTR bstrUserId,
            /* [optional][in] */ __RPC__in BSTR bstrPassword,
            /* [optional][in] */ __RPC__in BSTR bstrRSN) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE StopRouter( void) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE RefreshRouter( void) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE StartRouter( void) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE Reserved1( void) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE Reserved2( void) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE InstallMultipleComponents( 
            /* [in] */ __RPC__in BSTR bstrApplIDOrName,
            /* [in] */ __RPC__deref_in_opt SAFEARRAY * *ppsaVarFileNames,
            /* [in] */ __RPC__deref_in_opt SAFEARRAY * *ppsaVarCLSIDs) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE GetMultipleComponentsInfo( 
            /* [in] */ __RPC__in BSTR bstrApplIdOrName,
            /* [in] */ __RPC__deref_in_opt SAFEARRAY * *ppsaVarFileNames,
            /* [out] */ __RPC__deref_out_opt SAFEARRAY * *ppsaVarCLSIDs,
            /* [out] */ __RPC__deref_out_opt SAFEARRAY * *ppsaVarClassNames,
            /* [out] */ __RPC__deref_out_opt SAFEARRAY * *ppsaVarFileFlags,
            /* [out] */ __RPC__deref_out_opt SAFEARRAY * *ppsaVarComponentFlags) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE RefreshComponents( void) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE BackupREGDB( 
            /* [in] */ __RPC__in BSTR bstrBackupFilePath) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE RestoreREGDB( 
            /* [in] */ __RPC__in BSTR bstrBackupFilePath) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE QueryApplicationFile( 
            /* [in] */ __RPC__in BSTR bstrApplicationFile,
            /* [out] */ __RPC__deref_out_opt BSTR *pbstrApplicationName,
            /* [out] */ __RPC__deref_out_opt BSTR *pbstrApplicationDescription,
            /* [out] */ __RPC__out VARIANT_BOOL *pbHasUsers,
            /* [out] */ __RPC__out VARIANT_BOOL *pbIsProxy,
            /* [out] */ __RPC__deref_out_opt SAFEARRAY * *ppsaVarFileNames) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE StartApplication( 
            /* [in] */ __RPC__in BSTR bstrApplIdOrName) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE ServiceCheck( 
            /* [in] */ long lService,
            /* [retval][out] */ __RPC__out long *plStatus) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE InstallMultipleEventClasses( 
            /* [in] */ __RPC__in BSTR bstrApplIdOrName,
            /* [in] */ __RPC__deref_in_opt SAFEARRAY * *ppsaVarFileNames,
            /* [in] */ __RPC__deref_in_opt SAFEARRAY * *ppsaVarCLSIDS) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE InstallEventClass( 
            /* [in] */ __RPC__in BSTR bstrApplIdOrName,
            /* [in] */ __RPC__in BSTR bstrDLL,
            /* [in] */ __RPC__in BSTR bstrTLB,
            /* [in] */ __RPC__in BSTR bstrPSDLL) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE GetEventClassesForIID( 
            /* [in] */ __RPC__in BSTR bstrIID,
            /* [out] */ __RPC__deref_out_opt SAFEARRAY * *ppsaVarCLSIDs,
            /* [out] */ __RPC__deref_out_opt SAFEARRAY * *ppsaVarProgIDs,
            /* [out] */ __RPC__deref_out_opt SAFEARRAY * *ppsaVarDescriptions) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct ICOMAdminCatalogVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            ICOMAdminCatalog * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            ICOMAdminCatalog * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            ICOMAdminCatalog * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfoCount )( 
            ICOMAdminCatalog * This,
            /* [out] */ __RPC__out UINT *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfo )( 
            ICOMAdminCatalog * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ __RPC__deref_out_opt ITypeInfo **ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetIDsOfNames )( 
            ICOMAdminCatalog * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [size_is][in] */ __RPC__in_ecount_full(cNames) LPOLESTR *rgszNames,
            /* [range][in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ __RPC__out_ecount_full(cNames) DISPID *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE *Invoke )( 
            ICOMAdminCatalog * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS *pDispParams,
            /* [out] */ VARIANT *pVarResult,
            /* [out] */ EXCEPINFO *pExcepInfo,
            /* [out] */ UINT *puArgErr);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *GetCollection )( 
            ICOMAdminCatalog * This,
            /* [in] */ __RPC__in BSTR bstrCollName,
            /* [retval][out] */ __RPC__deref_out_opt IDispatch **ppCatalogCollection);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *Connect )( 
            ICOMAdminCatalog * This,
            /* [in] */ __RPC__in BSTR bstrCatalogServerName,
            /* [retval][out] */ __RPC__deref_out_opt IDispatch **ppCatalogCollection);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_MajorVersion )( 
            ICOMAdminCatalog * This,
            /* [retval][out] */ __RPC__out long *plMajorVersion);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_MinorVersion )( 
            ICOMAdminCatalog * This,
            /* [retval][out] */ __RPC__out long *plMinorVersion);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *GetCollectionByQuery )( 
            ICOMAdminCatalog * This,
            /* [in] */ __RPC__in BSTR bstrCollName,
            /* [in] */ __RPC__deref_in_opt SAFEARRAY * *ppsaVarQuery,
            /* [retval][out] */ __RPC__deref_out_opt IDispatch **ppCatalogCollection);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *ImportComponent )( 
            ICOMAdminCatalog * This,
            /* [in] */ __RPC__in BSTR bstrApplIDOrName,
            /* [in] */ __RPC__in BSTR bstrCLSIDOrProgID);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *InstallComponent )( 
            ICOMAdminCatalog * This,
            /* [in] */ __RPC__in BSTR bstrApplIDOrName,
            /* [in] */ __RPC__in BSTR bstrDLL,
            /* [in] */ __RPC__in BSTR bstrTLB,
            /* [in] */ __RPC__in BSTR bstrPSDLL);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *ShutdownApplication )( 
            ICOMAdminCatalog * This,
            /* [in] */ __RPC__in BSTR bstrApplIDOrName);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *ExportApplication )( 
            ICOMAdminCatalog * This,
            /* [in] */ __RPC__in BSTR bstrApplIDOrName,
            /* [in] */ __RPC__in BSTR bstrApplicationFile,
            /* [in] */ long lOptions);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *InstallApplication )( 
            ICOMAdminCatalog * This,
            /* [in] */ __RPC__in BSTR bstrApplicationFile,
            /* [optional][in] */ __RPC__in BSTR bstrDestinationDirectory,
            /* [optional][in] */ long lOptions,
            /* [optional][in] */ __RPC__in BSTR bstrUserId,
            /* [optional][in] */ __RPC__in BSTR bstrPassword,
            /* [optional][in] */ __RPC__in BSTR bstrRSN);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *StopRouter )( 
            ICOMAdminCatalog * This);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *RefreshRouter )( 
            ICOMAdminCatalog * This);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *StartRouter )( 
            ICOMAdminCatalog * This);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *Reserved1 )( 
            ICOMAdminCatalog * This);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *Reserved2 )( 
            ICOMAdminCatalog * This);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *InstallMultipleComponents )( 
            ICOMAdminCatalog * This,
            /* [in] */ __RPC__in BSTR bstrApplIDOrName,
            /* [in] */ __RPC__deref_in_opt SAFEARRAY * *ppsaVarFileNames,
            /* [in] */ __RPC__deref_in_opt SAFEARRAY * *ppsaVarCLSIDs);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *GetMultipleComponentsInfo )( 
            ICOMAdminCatalog * This,
            /* [in] */ __RPC__in BSTR bstrApplIdOrName,
            /* [in] */ __RPC__deref_in_opt SAFEARRAY * *ppsaVarFileNames,
            /* [out] */ __RPC__deref_out_opt SAFEARRAY * *ppsaVarCLSIDs,
            /* [out] */ __RPC__deref_out_opt SAFEARRAY * *ppsaVarClassNames,
            /* [out] */ __RPC__deref_out_opt SAFEARRAY * *ppsaVarFileFlags,
            /* [out] */ __RPC__deref_out_opt SAFEARRAY * *ppsaVarComponentFlags);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *RefreshComponents )( 
            ICOMAdminCatalog * This);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *BackupREGDB )( 
            ICOMAdminCatalog * This,
            /* [in] */ __RPC__in BSTR bstrBackupFilePath);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *RestoreREGDB )( 
            ICOMAdminCatalog * This,
            /* [in] */ __RPC__in BSTR bstrBackupFilePath);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *QueryApplicationFile )( 
            ICOMAdminCatalog * This,
            /* [in] */ __RPC__in BSTR bstrApplicationFile,
            /* [out] */ __RPC__deref_out_opt BSTR *pbstrApplicationName,
            /* [out] */ __RPC__deref_out_opt BSTR *pbstrApplicationDescription,
            /* [out] */ __RPC__out VARIANT_BOOL *pbHasUsers,
            /* [out] */ __RPC__out VARIANT_BOOL *pbIsProxy,
            /* [out] */ __RPC__deref_out_opt SAFEARRAY * *ppsaVarFileNames);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *StartApplication )( 
            ICOMAdminCatalog * This,
            /* [in] */ __RPC__in BSTR bstrApplIdOrName);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *ServiceCheck )( 
            ICOMAdminCatalog * This,
            /* [in] */ long lService,
            /* [retval][out] */ __RPC__out long *plStatus);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *InstallMultipleEventClasses )( 
            ICOMAdminCatalog * This,
            /* [in] */ __RPC__in BSTR bstrApplIdOrName,
            /* [in] */ __RPC__deref_in_opt SAFEARRAY * *ppsaVarFileNames,
            /* [in] */ __RPC__deref_in_opt SAFEARRAY * *ppsaVarCLSIDS);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *InstallEventClass )( 
            ICOMAdminCatalog * This,
            /* [in] */ __RPC__in BSTR bstrApplIdOrName,
            /* [in] */ __RPC__in BSTR bstrDLL,
            /* [in] */ __RPC__in BSTR bstrTLB,
            /* [in] */ __RPC__in BSTR bstrPSDLL);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *GetEventClassesForIID )( 
            ICOMAdminCatalog * This,
            /* [in] */ __RPC__in BSTR bstrIID,
            /* [out] */ __RPC__deref_out_opt SAFEARRAY * *ppsaVarCLSIDs,
            /* [out] */ __RPC__deref_out_opt SAFEARRAY * *ppsaVarProgIDs,
            /* [out] */ __RPC__deref_out_opt SAFEARRAY * *ppsaVarDescriptions);
        
        END_INTERFACE
    } ICOMAdminCatalogVtbl;

    interface ICOMAdminCatalog
    {
        CONST_VTBL struct ICOMAdminCatalogVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define ICOMAdminCatalog_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define ICOMAdminCatalog_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define ICOMAdminCatalog_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define ICOMAdminCatalog_GetTypeInfoCount(This,pctinfo)	\
    ( (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo) ) 

#define ICOMAdminCatalog_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    ( (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo) ) 

#define ICOMAdminCatalog_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    ( (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId) ) 

#define ICOMAdminCatalog_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    ( (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr) ) 


#define ICOMAdminCatalog_GetCollection(This,bstrCollName,ppCatalogCollection)	\
    ( (This)->lpVtbl -> GetCollection(This,bstrCollName,ppCatalogCollection) ) 

#define ICOMAdminCatalog_Connect(This,bstrCatalogServerName,ppCatalogCollection)	\
    ( (This)->lpVtbl -> Connect(This,bstrCatalogServerName,ppCatalogCollection) ) 

#define ICOMAdminCatalog_get_MajorVersion(This,plMajorVersion)	\
    ( (This)->lpVtbl -> get_MajorVersion(This,plMajorVersion) ) 

#define ICOMAdminCatalog_get_MinorVersion(This,plMinorVersion)	\
    ( (This)->lpVtbl -> get_MinorVersion(This,plMinorVersion) ) 

#define ICOMAdminCatalog_GetCollectionByQuery(This,bstrCollName,ppsaVarQuery,ppCatalogCollection)	\
    ( (This)->lpVtbl -> GetCollectionByQuery(This,bstrCollName,ppsaVarQuery,ppCatalogCollection) ) 

#define ICOMAdminCatalog_ImportComponent(This,bstrApplIDOrName,bstrCLSIDOrProgID)	\
    ( (This)->lpVtbl -> ImportComponent(This,bstrApplIDOrName,bstrCLSIDOrProgID) ) 

#define ICOMAdminCatalog_InstallComponent(This,bstrApplIDOrName,bstrDLL,bstrTLB,bstrPSDLL)	\
    ( (This)->lpVtbl -> InstallComponent(This,bstrApplIDOrName,bstrDLL,bstrTLB,bstrPSDLL) ) 

#define ICOMAdminCatalog_ShutdownApplication(This,bstrApplIDOrName)	\
    ( (This)->lpVtbl -> ShutdownApplication(This,bstrApplIDOrName) ) 

#define ICOMAdminCatalog_ExportApplication(This,bstrApplIDOrName,bstrApplicationFile,lOptions)	\
    ( (This)->lpVtbl -> ExportApplication(This,bstrApplIDOrName,bstrApplicationFile,lOptions) ) 

#define ICOMAdminCatalog_InstallApplication(This,bstrApplicationFile,bstrDestinationDirectory,lOptions,bstrUserId,bstrPassword,bstrRSN)	\
    ( (This)->lpVtbl -> InstallApplication(This,bstrApplicationFile,bstrDestinationDirectory,lOptions,bstrUserId,bstrPassword,bstrRSN) ) 

#define ICOMAdminCatalog_StopRouter(This)	\
    ( (This)->lpVtbl -> StopRouter(This) ) 

#define ICOMAdminCatalog_RefreshRouter(This)	\
    ( (This)->lpVtbl -> RefreshRouter(This) ) 

#define ICOMAdminCatalog_StartRouter(This)	\
    ( (This)->lpVtbl -> StartRouter(This) ) 

#define ICOMAdminCatalog_Reserved1(This)	\
    ( (This)->lpVtbl -> Reserved1(This) ) 

#define ICOMAdminCatalog_Reserved2(This)	\
    ( (This)->lpVtbl -> Reserved2(This) ) 

#define ICOMAdminCatalog_InstallMultipleComponents(This,bstrApplIDOrName,ppsaVarFileNames,ppsaVarCLSIDs)	\
    ( (This)->lpVtbl -> InstallMultipleComponents(This,bstrApplIDOrName,ppsaVarFileNames,ppsaVarCLSIDs) ) 

#define ICOMAdminCatalog_GetMultipleComponentsInfo(This,bstrApplIdOrName,ppsaVarFileNames,ppsaVarCLSIDs,ppsaVarClassNames,ppsaVarFileFlags,ppsaVarComponentFlags)	\
    ( (This)->lpVtbl -> GetMultipleComponentsInfo(This,bstrApplIdOrName,ppsaVarFileNames,ppsaVarCLSIDs,ppsaVarClassNames,ppsaVarFileFlags,ppsaVarComponentFlags) ) 

#define ICOMAdminCatalog_RefreshComponents(This)	\
    ( (This)->lpVtbl -> RefreshComponents(This) ) 

#define ICOMAdminCatalog_BackupREGDB(This,bstrBackupFilePath)	\
    ( (This)->lpVtbl -> BackupREGDB(This,bstrBackupFilePath) ) 

#define ICOMAdminCatalog_RestoreREGDB(This,bstrBackupFilePath)	\
    ( (This)->lpVtbl -> RestoreREGDB(This,bstrBackupFilePath) ) 

#define ICOMAdminCatalog_QueryApplicationFile(This,bstrApplicationFile,pbstrApplicationName,pbstrApplicationDescription,pbHasUsers,pbIsProxy,ppsaVarFileNames)	\
    ( (This)->lpVtbl -> QueryApplicationFile(This,bstrApplicationFile,pbstrApplicationName,pbstrApplicationDescription,pbHasUsers,pbIsProxy,ppsaVarFileNames) ) 

#define ICOMAdminCatalog_StartApplication(This,bstrApplIdOrName)	\
    ( (This)->lpVtbl -> StartApplication(This,bstrApplIdOrName) ) 

#define ICOMAdminCatalog_ServiceCheck(This,lService,plStatus)	\
    ( (This)->lpVtbl -> ServiceCheck(This,lService,plStatus) ) 

#define ICOMAdminCatalog_InstallMultipleEventClasses(This,bstrApplIdOrName,ppsaVarFileNames,ppsaVarCLSIDS)	\
    ( (This)->lpVtbl -> InstallMultipleEventClasses(This,bstrApplIdOrName,ppsaVarFileNames,ppsaVarCLSIDS) ) 

#define ICOMAdminCatalog_InstallEventClass(This,bstrApplIdOrName,bstrDLL,bstrTLB,bstrPSDLL)	\
    ( (This)->lpVtbl -> InstallEventClass(This,bstrApplIdOrName,bstrDLL,bstrTLB,bstrPSDLL) ) 

#define ICOMAdminCatalog_GetEventClassesForIID(This,bstrIID,ppsaVarCLSIDs,ppsaVarProgIDs,ppsaVarDescriptions)	\
    ( (This)->lpVtbl -> GetEventClassesForIID(This,bstrIID,ppsaVarCLSIDs,ppsaVarProgIDs,ppsaVarDescriptions) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __ICOMAdminCatalog_INTERFACE_DEFINED__ */


/* interface __MIDL_itf_comadmin_0000_0001 */
/* [local] */ 

typedef /* [helpstring] */ 
enum COMAdminInUse
    {	COMAdminNotInUse	= 0,
	COMAdminInUseByCatalog	= 0x1,
	COMAdminInUseByRegistryUnknown	= 0x2,
	COMAdminInUseByRegistryProxyStub	= 0x3,
	COMAdminInUseByRegistryTypeLib	= 0x4,
	COMAdminInUseByRegistryClsid	= 0x5
    } 	COMAdminInUse;



extern RPC_IF_HANDLE __MIDL_itf_comadmin_0000_0001_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_comadmin_0000_0001_v0_0_s_ifspec;

#ifndef __ICOMAdminCatalog2_INTERFACE_DEFINED__
#define __ICOMAdminCatalog2_INTERFACE_DEFINED__

/* interface ICOMAdminCatalog2 */
/* [unique][helpstring][dual][uuid][object] */ 


EXTERN_C const IID IID_ICOMAdminCatalog2;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("790C6E0B-9194-4cc9-9426-A48A63185696")
    ICOMAdminCatalog2 : public ICOMAdminCatalog
    {
    public:
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE GetCollectionByQuery2( 
            /* [in] */ __RPC__in BSTR bstrCollectionName,
            /* [in] */ __RPC__in VARIANT *pVarQueryStrings,
            /* [retval][out] */ __RPC__deref_out_opt IDispatch **ppCatalogCollection) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE GetApplicationInstanceIDFromProcessID( 
            /* [in] */ long lProcessID,
            /* [retval][out] */ __RPC__deref_out_opt BSTR *pbstrApplicationInstanceID) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE ShutdownApplicationInstances( 
            /* [in] */ __RPC__in VARIANT *pVarApplicationInstanceID) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE PauseApplicationInstances( 
            /* [in] */ __RPC__in VARIANT *pVarApplicationInstanceID) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE ResumeApplicationInstances( 
            /* [in] */ __RPC__in VARIANT *pVarApplicationInstanceID) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE RecycleApplicationInstances( 
            /* [in] */ __RPC__in VARIANT *pVarApplicationInstanceID,
            /* [in] */ long lReasonCode) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE AreApplicationInstancesPaused( 
            /* [in] */ __RPC__in VARIANT *pVarApplicationInstanceID,
            /* [retval][out] */ __RPC__out VARIANT_BOOL *pVarBoolPaused) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE DumpApplicationInstance( 
            /* [in] */ __RPC__in BSTR bstrApplicationInstanceID,
            /* [in] */ __RPC__in BSTR bstrDirectory,
            /* [in] */ long lMaxImages,
            /* [retval][out] */ __RPC__deref_out_opt BSTR *pbstrDumpFile) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_IsApplicationInstanceDumpSupported( 
            /* [retval][out] */ __RPC__out VARIANT_BOOL *pVarBoolDumpSupported) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE CreateServiceForApplication( 
            /* [in] */ __RPC__in BSTR bstrApplicationIDOrName,
            /* [in] */ __RPC__in BSTR bstrServiceName,
            /* [in] */ __RPC__in BSTR bstrStartType,
            /* [in] */ __RPC__in BSTR bstrErrorControl,
            /* [in] */ __RPC__in BSTR bstrDependencies,
            /* [in] */ __RPC__in BSTR bstrRunAs,
            /* [in] */ __RPC__in BSTR bstrPassword,
            /* [in] */ VARIANT_BOOL bDesktopOk) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE DeleteServiceForApplication( 
            /* [in] */ __RPC__in BSTR bstrApplicationIDOrName) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE GetPartitionID( 
            /* [in] */ __RPC__in BSTR bstrApplicationIDOrName,
            /* [retval][out] */ __RPC__deref_out_opt BSTR *pbstrPartitionID) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE GetPartitionName( 
            /* [in] */ __RPC__in BSTR bstrApplicationIDOrName,
            /* [retval][out] */ __RPC__deref_out_opt BSTR *pbstrPartitionName) = 0;
        
        virtual /* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE put_CurrentPartition( 
            /* [in] */ __RPC__in BSTR bstrPartitionIDOrName) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_CurrentPartitionID( 
            /* [retval][out] */ __RPC__deref_out_opt BSTR *pbstrPartitionID) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_CurrentPartitionName( 
            /* [retval][out] */ __RPC__deref_out_opt BSTR *pbstrPartitionName) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_GlobalPartitionID( 
            /* [retval][out] */ __RPC__deref_out_opt BSTR *pbstrGlobalPartitionID) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE FlushPartitionCache( void) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE CopyApplications( 
            /* [in] */ __RPC__in BSTR bstrSourcePartitionIDOrName,
            /* [in] */ __RPC__in VARIANT *pVarApplicationID,
            /* [in] */ __RPC__in BSTR bstrDestinationPartitionIDOrName) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE CopyComponents( 
            /* [in] */ __RPC__in BSTR bstrSourceApplicationIDOrName,
            /* [in] */ __RPC__in VARIANT *pVarCLSIDOrProgID,
            /* [in] */ __RPC__in BSTR bstrDestinationApplicationIDOrName) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE MoveComponents( 
            /* [in] */ __RPC__in BSTR bstrSourceApplicationIDOrName,
            /* [in] */ __RPC__in VARIANT *pVarCLSIDOrProgID,
            /* [in] */ __RPC__in BSTR bstrDestinationApplicationIDOrName) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE AliasComponent( 
            /* [in] */ __RPC__in BSTR bstrSrcApplicationIDOrName,
            /* [in] */ __RPC__in BSTR bstrCLSIDOrProgID,
            /* [in] */ __RPC__in BSTR bstrDestApplicationIDOrName,
            /* [in] */ __RPC__in BSTR bstrNewProgId,
            /* [in] */ __RPC__in BSTR bstrNewClsid) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE IsSafeToDelete( 
            /* [in] */ __RPC__in BSTR bstrDllName,
            /* [retval][out] */ __RPC__out COMAdminInUse *pCOMAdminInUse) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE ImportUnconfiguredComponents( 
            /* [in] */ __RPC__in BSTR bstrApplicationIDOrName,
            /* [in] */ __RPC__in VARIANT *pVarCLSIDOrProgID,
            /* [optional][in] */ __RPC__in VARIANT *pVarComponentType) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE PromoteUnconfiguredComponents( 
            /* [in] */ __RPC__in BSTR bstrApplicationIDOrName,
            /* [in] */ __RPC__in VARIANT *pVarCLSIDOrProgID,
            /* [optional][in] */ __RPC__in VARIANT *pVarComponentType) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE ImportComponents( 
            /* [in] */ __RPC__in BSTR bstrApplicationIDOrName,
            /* [in] */ __RPC__in VARIANT *pVarCLSIDOrProgID,
            /* [optional][in] */ __RPC__in VARIANT *pVarComponentType) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_Is64BitCatalogServer( 
            /* [retval][out] */ __RPC__out VARIANT_BOOL *pbIs64Bit) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE ExportPartition( 
            /* [in] */ __RPC__in BSTR bstrPartitionIDOrName,
            /* [in] */ __RPC__in BSTR bstrPartitionFileName,
            /* [in] */ long lOptions) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE InstallPartition( 
            /* [in] */ __RPC__in BSTR bstrFileName,
            /* [in] */ __RPC__in BSTR bstrDestDirectory,
            /* [in] */ long lOptions,
            /* [in] */ __RPC__in BSTR bstrUserID,
            /* [in] */ __RPC__in BSTR bstrPassword,
            /* [in] */ __RPC__in BSTR bstrRSN) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE QueryApplicationFile2( 
            /* [in] */ __RPC__in BSTR bstrApplicationFile,
            /* [retval][out] */ __RPC__deref_out_opt IDispatch **ppFilesForImport) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE GetComponentVersionCount( 
            /* [in] */ __RPC__in BSTR bstrCLSIDOrProgID,
            /* [retval][out] */ __RPC__out long *plVersionCount) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct ICOMAdminCatalog2Vtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            ICOMAdminCatalog2 * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            ICOMAdminCatalog2 * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            ICOMAdminCatalog2 * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfoCount )( 
            ICOMAdminCatalog2 * This,
            /* [out] */ __RPC__out UINT *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfo )( 
            ICOMAdminCatalog2 * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ __RPC__deref_out_opt ITypeInfo **ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetIDsOfNames )( 
            ICOMAdminCatalog2 * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [size_is][in] */ __RPC__in_ecount_full(cNames) LPOLESTR *rgszNames,
            /* [range][in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ __RPC__out_ecount_full(cNames) DISPID *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE *Invoke )( 
            ICOMAdminCatalog2 * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS *pDispParams,
            /* [out] */ VARIANT *pVarResult,
            /* [out] */ EXCEPINFO *pExcepInfo,
            /* [out] */ UINT *puArgErr);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *GetCollection )( 
            ICOMAdminCatalog2 * This,
            /* [in] */ __RPC__in BSTR bstrCollName,
            /* [retval][out] */ __RPC__deref_out_opt IDispatch **ppCatalogCollection);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *Connect )( 
            ICOMAdminCatalog2 * This,
            /* [in] */ __RPC__in BSTR bstrCatalogServerName,
            /* [retval][out] */ __RPC__deref_out_opt IDispatch **ppCatalogCollection);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_MajorVersion )( 
            ICOMAdminCatalog2 * This,
            /* [retval][out] */ __RPC__out long *plMajorVersion);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_MinorVersion )( 
            ICOMAdminCatalog2 * This,
            /* [retval][out] */ __RPC__out long *plMinorVersion);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *GetCollectionByQuery )( 
            ICOMAdminCatalog2 * This,
            /* [in] */ __RPC__in BSTR bstrCollName,
            /* [in] */ __RPC__deref_in_opt SAFEARRAY * *ppsaVarQuery,
            /* [retval][out] */ __RPC__deref_out_opt IDispatch **ppCatalogCollection);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *ImportComponent )( 
            ICOMAdminCatalog2 * This,
            /* [in] */ __RPC__in BSTR bstrApplIDOrName,
            /* [in] */ __RPC__in BSTR bstrCLSIDOrProgID);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *InstallComponent )( 
            ICOMAdminCatalog2 * This,
            /* [in] */ __RPC__in BSTR bstrApplIDOrName,
            /* [in] */ __RPC__in BSTR bstrDLL,
            /* [in] */ __RPC__in BSTR bstrTLB,
            /* [in] */ __RPC__in BSTR bstrPSDLL);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *ShutdownApplication )( 
            ICOMAdminCatalog2 * This,
            /* [in] */ __RPC__in BSTR bstrApplIDOrName);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *ExportApplication )( 
            ICOMAdminCatalog2 * This,
            /* [in] */ __RPC__in BSTR bstrApplIDOrName,
            /* [in] */ __RPC__in BSTR bstrApplicationFile,
            /* [in] */ long lOptions);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *InstallApplication )( 
            ICOMAdminCatalog2 * This,
            /* [in] */ __RPC__in BSTR bstrApplicationFile,
            /* [optional][in] */ __RPC__in BSTR bstrDestinationDirectory,
            /* [optional][in] */ long lOptions,
            /* [optional][in] */ __RPC__in BSTR bstrUserId,
            /* [optional][in] */ __RPC__in BSTR bstrPassword,
            /* [optional][in] */ __RPC__in BSTR bstrRSN);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *StopRouter )( 
            ICOMAdminCatalog2 * This);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *RefreshRouter )( 
            ICOMAdminCatalog2 * This);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *StartRouter )( 
            ICOMAdminCatalog2 * This);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *Reserved1 )( 
            ICOMAdminCatalog2 * This);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *Reserved2 )( 
            ICOMAdminCatalog2 * This);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *InstallMultipleComponents )( 
            ICOMAdminCatalog2 * This,
            /* [in] */ __RPC__in BSTR bstrApplIDOrName,
            /* [in] */ __RPC__deref_in_opt SAFEARRAY * *ppsaVarFileNames,
            /* [in] */ __RPC__deref_in_opt SAFEARRAY * *ppsaVarCLSIDs);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *GetMultipleComponentsInfo )( 
            ICOMAdminCatalog2 * This,
            /* [in] */ __RPC__in BSTR bstrApplIdOrName,
            /* [in] */ __RPC__deref_in_opt SAFEARRAY * *ppsaVarFileNames,
            /* [out] */ __RPC__deref_out_opt SAFEARRAY * *ppsaVarCLSIDs,
            /* [out] */ __RPC__deref_out_opt SAFEARRAY * *ppsaVarClassNames,
            /* [out] */ __RPC__deref_out_opt SAFEARRAY * *ppsaVarFileFlags,
            /* [out] */ __RPC__deref_out_opt SAFEARRAY * *ppsaVarComponentFlags);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *RefreshComponents )( 
            ICOMAdminCatalog2 * This);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *BackupREGDB )( 
            ICOMAdminCatalog2 * This,
            /* [in] */ __RPC__in BSTR bstrBackupFilePath);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *RestoreREGDB )( 
            ICOMAdminCatalog2 * This,
            /* [in] */ __RPC__in BSTR bstrBackupFilePath);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *QueryApplicationFile )( 
            ICOMAdminCatalog2 * This,
            /* [in] */ __RPC__in BSTR bstrApplicationFile,
            /* [out] */ __RPC__deref_out_opt BSTR *pbstrApplicationName,
            /* [out] */ __RPC__deref_out_opt BSTR *pbstrApplicationDescription,
            /* [out] */ __RPC__out VARIANT_BOOL *pbHasUsers,
            /* [out] */ __RPC__out VARIANT_BOOL *pbIsProxy,
            /* [out] */ __RPC__deref_out_opt SAFEARRAY * *ppsaVarFileNames);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *StartApplication )( 
            ICOMAdminCatalog2 * This,
            /* [in] */ __RPC__in BSTR bstrApplIdOrName);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *ServiceCheck )( 
            ICOMAdminCatalog2 * This,
            /* [in] */ long lService,
            /* [retval][out] */ __RPC__out long *plStatus);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *InstallMultipleEventClasses )( 
            ICOMAdminCatalog2 * This,
            /* [in] */ __RPC__in BSTR bstrApplIdOrName,
            /* [in] */ __RPC__deref_in_opt SAFEARRAY * *ppsaVarFileNames,
            /* [in] */ __RPC__deref_in_opt SAFEARRAY * *ppsaVarCLSIDS);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *InstallEventClass )( 
            ICOMAdminCatalog2 * This,
            /* [in] */ __RPC__in BSTR bstrApplIdOrName,
            /* [in] */ __RPC__in BSTR bstrDLL,
            /* [in] */ __RPC__in BSTR bstrTLB,
            /* [in] */ __RPC__in BSTR bstrPSDLL);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *GetEventClassesForIID )( 
            ICOMAdminCatalog2 * This,
            /* [in] */ __RPC__in BSTR bstrIID,
            /* [out] */ __RPC__deref_out_opt SAFEARRAY * *ppsaVarCLSIDs,
            /* [out] */ __RPC__deref_out_opt SAFEARRAY * *ppsaVarProgIDs,
            /* [out] */ __RPC__deref_out_opt SAFEARRAY * *ppsaVarDescriptions);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *GetCollectionByQuery2 )( 
            ICOMAdminCatalog2 * This,
            /* [in] */ __RPC__in BSTR bstrCollectionName,
            /* [in] */ __RPC__in VARIANT *pVarQueryStrings,
            /* [retval][out] */ __RPC__deref_out_opt IDispatch **ppCatalogCollection);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *GetApplicationInstanceIDFromProcessID )( 
            ICOMAdminCatalog2 * This,
            /* [in] */ long lProcessID,
            /* [retval][out] */ __RPC__deref_out_opt BSTR *pbstrApplicationInstanceID);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *ShutdownApplicationInstances )( 
            ICOMAdminCatalog2 * This,
            /* [in] */ __RPC__in VARIANT *pVarApplicationInstanceID);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *PauseApplicationInstances )( 
            ICOMAdminCatalog2 * This,
            /* [in] */ __RPC__in VARIANT *pVarApplicationInstanceID);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *ResumeApplicationInstances )( 
            ICOMAdminCatalog2 * This,
            /* [in] */ __RPC__in VARIANT *pVarApplicationInstanceID);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *RecycleApplicationInstances )( 
            ICOMAdminCatalog2 * This,
            /* [in] */ __RPC__in VARIANT *pVarApplicationInstanceID,
            /* [in] */ long lReasonCode);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *AreApplicationInstancesPaused )( 
            ICOMAdminCatalog2 * This,
            /* [in] */ __RPC__in VARIANT *pVarApplicationInstanceID,
            /* [retval][out] */ __RPC__out VARIANT_BOOL *pVarBoolPaused);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *DumpApplicationInstance )( 
            ICOMAdminCatalog2 * This,
            /* [in] */ __RPC__in BSTR bstrApplicationInstanceID,
            /* [in] */ __RPC__in BSTR bstrDirectory,
            /* [in] */ long lMaxImages,
            /* [retval][out] */ __RPC__deref_out_opt BSTR *pbstrDumpFile);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_IsApplicationInstanceDumpSupported )( 
            ICOMAdminCatalog2 * This,
            /* [retval][out] */ __RPC__out VARIANT_BOOL *pVarBoolDumpSupported);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *CreateServiceForApplication )( 
            ICOMAdminCatalog2 * This,
            /* [in] */ __RPC__in BSTR bstrApplicationIDOrName,
            /* [in] */ __RPC__in BSTR bstrServiceName,
            /* [in] */ __RPC__in BSTR bstrStartType,
            /* [in] */ __RPC__in BSTR bstrErrorControl,
            /* [in] */ __RPC__in BSTR bstrDependencies,
            /* [in] */ __RPC__in BSTR bstrRunAs,
            /* [in] */ __RPC__in BSTR bstrPassword,
            /* [in] */ VARIANT_BOOL bDesktopOk);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *DeleteServiceForApplication )( 
            ICOMAdminCatalog2 * This,
            /* [in] */ __RPC__in BSTR bstrApplicationIDOrName);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *GetPartitionID )( 
            ICOMAdminCatalog2 * This,
            /* [in] */ __RPC__in BSTR bstrApplicationIDOrName,
            /* [retval][out] */ __RPC__deref_out_opt BSTR *pbstrPartitionID);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *GetPartitionName )( 
            ICOMAdminCatalog2 * This,
            /* [in] */ __RPC__in BSTR bstrApplicationIDOrName,
            /* [retval][out] */ __RPC__deref_out_opt BSTR *pbstrPartitionName);
        
        /* [helpstring][id][propput] */ HRESULT ( STDMETHODCALLTYPE *put_CurrentPartition )( 
            ICOMAdminCatalog2 * This,
            /* [in] */ __RPC__in BSTR bstrPartitionIDOrName);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_CurrentPartitionID )( 
            ICOMAdminCatalog2 * This,
            /* [retval][out] */ __RPC__deref_out_opt BSTR *pbstrPartitionID);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_CurrentPartitionName )( 
            ICOMAdminCatalog2 * This,
            /* [retval][out] */ __RPC__deref_out_opt BSTR *pbstrPartitionName);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_GlobalPartitionID )( 
            ICOMAdminCatalog2 * This,
            /* [retval][out] */ __RPC__deref_out_opt BSTR *pbstrGlobalPartitionID);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *FlushPartitionCache )( 
            ICOMAdminCatalog2 * This);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *CopyApplications )( 
            ICOMAdminCatalog2 * This,
            /* [in] */ __RPC__in BSTR bstrSourcePartitionIDOrName,
            /* [in] */ __RPC__in VARIANT *pVarApplicationID,
            /* [in] */ __RPC__in BSTR bstrDestinationPartitionIDOrName);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *CopyComponents )( 
            ICOMAdminCatalog2 * This,
            /* [in] */ __RPC__in BSTR bstrSourceApplicationIDOrName,
            /* [in] */ __RPC__in VARIANT *pVarCLSIDOrProgID,
            /* [in] */ __RPC__in BSTR bstrDestinationApplicationIDOrName);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *MoveComponents )( 
            ICOMAdminCatalog2 * This,
            /* [in] */ __RPC__in BSTR bstrSourceApplicationIDOrName,
            /* [in] */ __RPC__in VARIANT *pVarCLSIDOrProgID,
            /* [in] */ __RPC__in BSTR bstrDestinationApplicationIDOrName);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *AliasComponent )( 
            ICOMAdminCatalog2 * This,
            /* [in] */ __RPC__in BSTR bstrSrcApplicationIDOrName,
            /* [in] */ __RPC__in BSTR bstrCLSIDOrProgID,
            /* [in] */ __RPC__in BSTR bstrDestApplicationIDOrName,
            /* [in] */ __RPC__in BSTR bstrNewProgId,
            /* [in] */ __RPC__in BSTR bstrNewClsid);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *IsSafeToDelete )( 
            ICOMAdminCatalog2 * This,
            /* [in] */ __RPC__in BSTR bstrDllName,
            /* [retval][out] */ __RPC__out COMAdminInUse *pCOMAdminInUse);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *ImportUnconfiguredComponents )( 
            ICOMAdminCatalog2 * This,
            /* [in] */ __RPC__in BSTR bstrApplicationIDOrName,
            /* [in] */ __RPC__in VARIANT *pVarCLSIDOrProgID,
            /* [optional][in] */ __RPC__in VARIANT *pVarComponentType);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *PromoteUnconfiguredComponents )( 
            ICOMAdminCatalog2 * This,
            /* [in] */ __RPC__in BSTR bstrApplicationIDOrName,
            /* [in] */ __RPC__in VARIANT *pVarCLSIDOrProgID,
            /* [optional][in] */ __RPC__in VARIANT *pVarComponentType);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *ImportComponents )( 
            ICOMAdminCatalog2 * This,
            /* [in] */ __RPC__in BSTR bstrApplicationIDOrName,
            /* [in] */ __RPC__in VARIANT *pVarCLSIDOrProgID,
            /* [optional][in] */ __RPC__in VARIANT *pVarComponentType);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_Is64BitCatalogServer )( 
            ICOMAdminCatalog2 * This,
            /* [retval][out] */ __RPC__out VARIANT_BOOL *pbIs64Bit);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *ExportPartition )( 
            ICOMAdminCatalog2 * This,
            /* [in] */ __RPC__in BSTR bstrPartitionIDOrName,
            /* [in] */ __RPC__in BSTR bstrPartitionFileName,
            /* [in] */ long lOptions);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *InstallPartition )( 
            ICOMAdminCatalog2 * This,
            /* [in] */ __RPC__in BSTR bstrFileName,
            /* [in] */ __RPC__in BSTR bstrDestDirectory,
            /* [in] */ long lOptions,
            /* [in] */ __RPC__in BSTR bstrUserID,
            /* [in] */ __RPC__in BSTR bstrPassword,
            /* [in] */ __RPC__in BSTR bstrRSN);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *QueryApplicationFile2 )( 
            ICOMAdminCatalog2 * This,
            /* [in] */ __RPC__in BSTR bstrApplicationFile,
            /* [retval][out] */ __RPC__deref_out_opt IDispatch **ppFilesForImport);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *GetComponentVersionCount )( 
            ICOMAdminCatalog2 * This,
            /* [in] */ __RPC__in BSTR bstrCLSIDOrProgID,
            /* [retval][out] */ __RPC__out long *plVersionCount);
        
        END_INTERFACE
    } ICOMAdminCatalog2Vtbl;

    interface ICOMAdminCatalog2
    {
        CONST_VTBL struct ICOMAdminCatalog2Vtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define ICOMAdminCatalog2_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define ICOMAdminCatalog2_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define ICOMAdminCatalog2_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define ICOMAdminCatalog2_GetTypeInfoCount(This,pctinfo)	\
    ( (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo) ) 

#define ICOMAdminCatalog2_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    ( (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo) ) 

#define ICOMAdminCatalog2_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    ( (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId) ) 

#define ICOMAdminCatalog2_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    ( (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr) ) 


#define ICOMAdminCatalog2_GetCollection(This,bstrCollName,ppCatalogCollection)	\
    ( (This)->lpVtbl -> GetCollection(This,bstrCollName,ppCatalogCollection) ) 

#define ICOMAdminCatalog2_Connect(This,bstrCatalogServerName,ppCatalogCollection)	\
    ( (This)->lpVtbl -> Connect(This,bstrCatalogServerName,ppCatalogCollection) ) 

#define ICOMAdminCatalog2_get_MajorVersion(This,plMajorVersion)	\
    ( (This)->lpVtbl -> get_MajorVersion(This,plMajorVersion) ) 

#define ICOMAdminCatalog2_get_MinorVersion(This,plMinorVersion)	\
    ( (This)->lpVtbl -> get_MinorVersion(This,plMinorVersion) ) 

#define ICOMAdminCatalog2_GetCollectionByQuery(This,bstrCollName,ppsaVarQuery,ppCatalogCollection)	\
    ( (This)->lpVtbl -> GetCollectionByQuery(This,bstrCollName,ppsaVarQuery,ppCatalogCollection) ) 

#define ICOMAdminCatalog2_ImportComponent(This,bstrApplIDOrName,bstrCLSIDOrProgID)	\
    ( (This)->lpVtbl -> ImportComponent(This,bstrApplIDOrName,bstrCLSIDOrProgID) ) 

#define ICOMAdminCatalog2_InstallComponent(This,bstrApplIDOrName,bstrDLL,bstrTLB,bstrPSDLL)	\
    ( (This)->lpVtbl -> InstallComponent(This,bstrApplIDOrName,bstrDLL,bstrTLB,bstrPSDLL) ) 

#define ICOMAdminCatalog2_ShutdownApplication(This,bstrApplIDOrName)	\
    ( (This)->lpVtbl -> ShutdownApplication(This,bstrApplIDOrName) ) 

#define ICOMAdminCatalog2_ExportApplication(This,bstrApplIDOrName,bstrApplicationFile,lOptions)	\
    ( (This)->lpVtbl -> ExportApplication(This,bstrApplIDOrName,bstrApplicationFile,lOptions) ) 

#define ICOMAdminCatalog2_InstallApplication(This,bstrApplicationFile,bstrDestinationDirectory,lOptions,bstrUserId,bstrPassword,bstrRSN)	\
    ( (This)->lpVtbl -> InstallApplication(This,bstrApplicationFile,bstrDestinationDirectory,lOptions,bstrUserId,bstrPassword,bstrRSN) ) 

#define ICOMAdminCatalog2_StopRouter(This)	\
    ( (This)->lpVtbl -> StopRouter(This) ) 

#define ICOMAdminCatalog2_RefreshRouter(This)	\
    ( (This)->lpVtbl -> RefreshRouter(This) ) 

#define ICOMAdminCatalog2_StartRouter(This)	\
    ( (This)->lpVtbl -> StartRouter(This) ) 

#define ICOMAdminCatalog2_Reserved1(This)	\
    ( (This)->lpVtbl -> Reserved1(This) ) 

#define ICOMAdminCatalog2_Reserved2(This)	\
    ( (This)->lpVtbl -> Reserved2(This) ) 

#define ICOMAdminCatalog2_InstallMultipleComponents(This,bstrApplIDOrName,ppsaVarFileNames,ppsaVarCLSIDs)	\
    ( (This)->lpVtbl -> InstallMultipleComponents(This,bstrApplIDOrName,ppsaVarFileNames,ppsaVarCLSIDs) ) 

#define ICOMAdminCatalog2_GetMultipleComponentsInfo(This,bstrApplIdOrName,ppsaVarFileNames,ppsaVarCLSIDs,ppsaVarClassNames,ppsaVarFileFlags,ppsaVarComponentFlags)	\
    ( (This)->lpVtbl -> GetMultipleComponentsInfo(This,bstrApplIdOrName,ppsaVarFileNames,ppsaVarCLSIDs,ppsaVarClassNames,ppsaVarFileFlags,ppsaVarComponentFlags) ) 

#define ICOMAdminCatalog2_RefreshComponents(This)	\
    ( (This)->lpVtbl -> RefreshComponents(This) ) 

#define ICOMAdminCatalog2_BackupREGDB(This,bstrBackupFilePath)	\
    ( (This)->lpVtbl -> BackupREGDB(This,bstrBackupFilePath) ) 

#define ICOMAdminCatalog2_RestoreREGDB(This,bstrBackupFilePath)	\
    ( (This)->lpVtbl -> RestoreREGDB(This,bstrBackupFilePath) ) 

#define ICOMAdminCatalog2_QueryApplicationFile(This,bstrApplicationFile,pbstrApplicationName,pbstrApplicationDescription,pbHasUsers,pbIsProxy,ppsaVarFileNames)	\
    ( (This)->lpVtbl -> QueryApplicationFile(This,bstrApplicationFile,pbstrApplicationName,pbstrApplicationDescription,pbHasUsers,pbIsProxy,ppsaVarFileNames) ) 

#define ICOMAdminCatalog2_StartApplication(This,bstrApplIdOrName)	\
    ( (This)->lpVtbl -> StartApplication(This,bstrApplIdOrName) ) 

#define ICOMAdminCatalog2_ServiceCheck(This,lService,plStatus)	\
    ( (This)->lpVtbl -> ServiceCheck(This,lService,plStatus) ) 

#define ICOMAdminCatalog2_InstallMultipleEventClasses(This,bstrApplIdOrName,ppsaVarFileNames,ppsaVarCLSIDS)	\
    ( (This)->lpVtbl -> InstallMultipleEventClasses(This,bstrApplIdOrName,ppsaVarFileNames,ppsaVarCLSIDS) ) 

#define ICOMAdminCatalog2_InstallEventClass(This,bstrApplIdOrName,bstrDLL,bstrTLB,bstrPSDLL)	\
    ( (This)->lpVtbl -> InstallEventClass(This,bstrApplIdOrName,bstrDLL,bstrTLB,bstrPSDLL) ) 

#define ICOMAdminCatalog2_GetEventClassesForIID(This,bstrIID,ppsaVarCLSIDs,ppsaVarProgIDs,ppsaVarDescriptions)	\
    ( (This)->lpVtbl -> GetEventClassesForIID(This,bstrIID,ppsaVarCLSIDs,ppsaVarProgIDs,ppsaVarDescriptions) ) 


#define ICOMAdminCatalog2_GetCollectionByQuery2(This,bstrCollectionName,pVarQueryStrings,ppCatalogCollection)	\
    ( (This)->lpVtbl -> GetCollectionByQuery2(This,bstrCollectionName,pVarQueryStrings,ppCatalogCollection) ) 

#define ICOMAdminCatalog2_GetApplicationInstanceIDFromProcessID(This,lProcessID,pbstrApplicationInstanceID)	\
    ( (This)->lpVtbl -> GetApplicationInstanceIDFromProcessID(This,lProcessID,pbstrApplicationInstanceID) ) 

#define ICOMAdminCatalog2_ShutdownApplicationInstances(This,pVarApplicationInstanceID)	\
    ( (This)->lpVtbl -> ShutdownApplicationInstances(This,pVarApplicationInstanceID) ) 

#define ICOMAdminCatalog2_PauseApplicationInstances(This,pVarApplicationInstanceID)	\
    ( (This)->lpVtbl -> PauseApplicationInstances(This,pVarApplicationInstanceID) ) 

#define ICOMAdminCatalog2_ResumeApplicationInstances(This,pVarApplicationInstanceID)	\
    ( (This)->lpVtbl -> ResumeApplicationInstances(This,pVarApplicationInstanceID) ) 

#define ICOMAdminCatalog2_RecycleApplicationInstances(This,pVarApplicationInstanceID,lReasonCode)	\
    ( (This)->lpVtbl -> RecycleApplicationInstances(This,pVarApplicationInstanceID,lReasonCode) ) 

#define ICOMAdminCatalog2_AreApplicationInstancesPaused(This,pVarApplicationInstanceID,pVarBoolPaused)	\
    ( (This)->lpVtbl -> AreApplicationInstancesPaused(This,pVarApplicationInstanceID,pVarBoolPaused) ) 

#define ICOMAdminCatalog2_DumpApplicationInstance(This,bstrApplicationInstanceID,bstrDirectory,lMaxImages,pbstrDumpFile)	\
    ( (This)->lpVtbl -> DumpApplicationInstance(This,bstrApplicationInstanceID,bstrDirectory,lMaxImages,pbstrDumpFile) ) 

#define ICOMAdminCatalog2_get_IsApplicationInstanceDumpSupported(This,pVarBoolDumpSupported)	\
    ( (This)->lpVtbl -> get_IsApplicationInstanceDumpSupported(This,pVarBoolDumpSupported) ) 

#define ICOMAdminCatalog2_CreateServiceForApplication(This,bstrApplicationIDOrName,bstrServiceName,bstrStartType,bstrErrorControl,bstrDependencies,bstrRunAs,bstrPassword,bDesktopOk)	\
    ( (This)->lpVtbl -> CreateServiceForApplication(This,bstrApplicationIDOrName,bstrServiceName,bstrStartType,bstrErrorControl,bstrDependencies,bstrRunAs,bstrPassword,bDesktopOk) ) 

#define ICOMAdminCatalog2_DeleteServiceForApplication(This,bstrApplicationIDOrName)	\
    ( (This)->lpVtbl -> DeleteServiceForApplication(This,bstrApplicationIDOrName) ) 

#define ICOMAdminCatalog2_GetPartitionID(This,bstrApplicationIDOrName,pbstrPartitionID)	\
    ( (This)->lpVtbl -> GetPartitionID(This,bstrApplicationIDOrName,pbstrPartitionID) ) 

#define ICOMAdminCatalog2_GetPartitionName(This,bstrApplicationIDOrName,pbstrPartitionName)	\
    ( (This)->lpVtbl -> GetPartitionName(This,bstrApplicationIDOrName,pbstrPartitionName) ) 

#define ICOMAdminCatalog2_put_CurrentPartition(This,bstrPartitionIDOrName)	\
    ( (This)->lpVtbl -> put_CurrentPartition(This,bstrPartitionIDOrName) ) 

#define ICOMAdminCatalog2_get_CurrentPartitionID(This,pbstrPartitionID)	\
    ( (This)->lpVtbl -> get_CurrentPartitionID(This,pbstrPartitionID) ) 

#define ICOMAdminCatalog2_get_CurrentPartitionName(This,pbstrPartitionName)	\
    ( (This)->lpVtbl -> get_CurrentPartitionName(This,pbstrPartitionName) ) 

#define ICOMAdminCatalog2_get_GlobalPartitionID(This,pbstrGlobalPartitionID)	\
    ( (This)->lpVtbl -> get_GlobalPartitionID(This,pbstrGlobalPartitionID) ) 

#define ICOMAdminCatalog2_FlushPartitionCache(This)	\
    ( (This)->lpVtbl -> FlushPartitionCache(This) ) 

#define ICOMAdminCatalog2_CopyApplications(This,bstrSourcePartitionIDOrName,pVarApplicationID,bstrDestinationPartitionIDOrName)	\
    ( (This)->lpVtbl -> CopyApplications(This,bstrSourcePartitionIDOrName,pVarApplicationID,bstrDestinationPartitionIDOrName) ) 

#define ICOMAdminCatalog2_CopyComponents(This,bstrSourceApplicationIDOrName,pVarCLSIDOrProgID,bstrDestinationApplicationIDOrName)	\
    ( (This)->lpVtbl -> CopyComponents(This,bstrSourceApplicationIDOrName,pVarCLSIDOrProgID,bstrDestinationApplicationIDOrName) ) 

#define ICOMAdminCatalog2_MoveComponents(This,bstrSourceApplicationIDOrName,pVarCLSIDOrProgID,bstrDestinationApplicationIDOrName)	\
    ( (This)->lpVtbl -> MoveComponents(This,bstrSourceApplicationIDOrName,pVarCLSIDOrProgID,bstrDestinationApplicationIDOrName) ) 

#define ICOMAdminCatalog2_AliasComponent(This,bstrSrcApplicationIDOrName,bstrCLSIDOrProgID,bstrDestApplicationIDOrName,bstrNewProgId,bstrNewClsid)	\
    ( (This)->lpVtbl -> AliasComponent(This,bstrSrcApplicationIDOrName,bstrCLSIDOrProgID,bstrDestApplicationIDOrName,bstrNewProgId,bstrNewClsid) ) 

#define ICOMAdminCatalog2_IsSafeToDelete(This,bstrDllName,pCOMAdminInUse)	\
    ( (This)->lpVtbl -> IsSafeToDelete(This,bstrDllName,pCOMAdminInUse) ) 

#define ICOMAdminCatalog2_ImportUnconfiguredComponents(This,bstrApplicationIDOrName,pVarCLSIDOrProgID,pVarComponentType)	\
    ( (This)->lpVtbl -> ImportUnconfiguredComponents(This,bstrApplicationIDOrName,pVarCLSIDOrProgID,pVarComponentType) ) 

#define ICOMAdminCatalog2_PromoteUnconfiguredComponents(This,bstrApplicationIDOrName,pVarCLSIDOrProgID,pVarComponentType)	\
    ( (This)->lpVtbl -> PromoteUnconfiguredComponents(This,bstrApplicationIDOrName,pVarCLSIDOrProgID,pVarComponentType) ) 

#define ICOMAdminCatalog2_ImportComponents(This,bstrApplicationIDOrName,pVarCLSIDOrProgID,pVarComponentType)	\
    ( (This)->lpVtbl -> ImportComponents(This,bstrApplicationIDOrName,pVarCLSIDOrProgID,pVarComponentType) ) 

#define ICOMAdminCatalog2_get_Is64BitCatalogServer(This,pbIs64Bit)	\
    ( (This)->lpVtbl -> get_Is64BitCatalogServer(This,pbIs64Bit) ) 

#define ICOMAdminCatalog2_ExportPartition(This,bstrPartitionIDOrName,bstrPartitionFileName,lOptions)	\
    ( (This)->lpVtbl -> ExportPartition(This,bstrPartitionIDOrName,bstrPartitionFileName,lOptions) ) 

#define ICOMAdminCatalog2_InstallPartition(This,bstrFileName,bstrDestDirectory,lOptions,bstrUserID,bstrPassword,bstrRSN)	\
    ( (This)->lpVtbl -> InstallPartition(This,bstrFileName,bstrDestDirectory,lOptions,bstrUserID,bstrPassword,bstrRSN) ) 

#define ICOMAdminCatalog2_QueryApplicationFile2(This,bstrApplicationFile,ppFilesForImport)	\
    ( (This)->lpVtbl -> QueryApplicationFile2(This,bstrApplicationFile,ppFilesForImport) ) 

#define ICOMAdminCatalog2_GetComponentVersionCount(This,bstrCLSIDOrProgID,plVersionCount)	\
    ( (This)->lpVtbl -> GetComponentVersionCount(This,bstrCLSIDOrProgID,plVersionCount) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __ICOMAdminCatalog2_INTERFACE_DEFINED__ */


#ifndef __ICatalogObject_INTERFACE_DEFINED__
#define __ICatalogObject_INTERFACE_DEFINED__

/* interface ICatalogObject */
/* [unique][helpstring][dual][uuid][object] */ 


EXTERN_C const IID IID_ICatalogObject;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("6eb22871-8a19-11d0-81b6-00a0c9231c29")
    ICatalogObject : public IDispatch
    {
    public:
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_Value( 
            /* [in] */ __RPC__in BSTR bstrPropName,
            /* [retval][out] */ __RPC__out VARIANT *pvarRetVal) = 0;
        
        virtual /* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE put_Value( 
            /* [in] */ __RPC__in BSTR bstrPropName,
            /* [in] */ VARIANT val) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_Key( 
            /* [retval][out] */ __RPC__out VARIANT *pvarRetVal) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_Name( 
            /* [retval][out] */ __RPC__out VARIANT *pvarRetVal) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE IsPropertyReadOnly( 
            /* [in] */ __RPC__in BSTR bstrPropName,
            /* [retval][out] */ __RPC__out VARIANT_BOOL *pbRetVal) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_Valid( 
            /* [retval][out] */ __RPC__out VARIANT_BOOL *pbRetVal) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE IsPropertyWriteOnly( 
            /* [in] */ __RPC__in BSTR bstrPropName,
            /* [retval][out] */ __RPC__out VARIANT_BOOL *pbRetVal) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct ICatalogObjectVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            ICatalogObject * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            ICatalogObject * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            ICatalogObject * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfoCount )( 
            ICatalogObject * This,
            /* [out] */ __RPC__out UINT *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfo )( 
            ICatalogObject * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ __RPC__deref_out_opt ITypeInfo **ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetIDsOfNames )( 
            ICatalogObject * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [size_is][in] */ __RPC__in_ecount_full(cNames) LPOLESTR *rgszNames,
            /* [range][in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ __RPC__out_ecount_full(cNames) DISPID *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE *Invoke )( 
            ICatalogObject * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS *pDispParams,
            /* [out] */ VARIANT *pVarResult,
            /* [out] */ EXCEPINFO *pExcepInfo,
            /* [out] */ UINT *puArgErr);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_Value )( 
            ICatalogObject * This,
            /* [in] */ __RPC__in BSTR bstrPropName,
            /* [retval][out] */ __RPC__out VARIANT *pvarRetVal);
        
        /* [helpstring][id][propput] */ HRESULT ( STDMETHODCALLTYPE *put_Value )( 
            ICatalogObject * This,
            /* [in] */ __RPC__in BSTR bstrPropName,
            /* [in] */ VARIANT val);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_Key )( 
            ICatalogObject * This,
            /* [retval][out] */ __RPC__out VARIANT *pvarRetVal);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_Name )( 
            ICatalogObject * This,
            /* [retval][out] */ __RPC__out VARIANT *pvarRetVal);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *IsPropertyReadOnly )( 
            ICatalogObject * This,
            /* [in] */ __RPC__in BSTR bstrPropName,
            /* [retval][out] */ __RPC__out VARIANT_BOOL *pbRetVal);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_Valid )( 
            ICatalogObject * This,
            /* [retval][out] */ __RPC__out VARIANT_BOOL *pbRetVal);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *IsPropertyWriteOnly )( 
            ICatalogObject * This,
            /* [in] */ __RPC__in BSTR bstrPropName,
            /* [retval][out] */ __RPC__out VARIANT_BOOL *pbRetVal);
        
        END_INTERFACE
    } ICatalogObjectVtbl;

    interface ICatalogObject
    {
        CONST_VTBL struct ICatalogObjectVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define ICatalogObject_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define ICatalogObject_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define ICatalogObject_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define ICatalogObject_GetTypeInfoCount(This,pctinfo)	\
    ( (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo) ) 

#define ICatalogObject_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    ( (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo) ) 

#define ICatalogObject_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    ( (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId) ) 

#define ICatalogObject_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    ( (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr) ) 


#define ICatalogObject_get_Value(This,bstrPropName,pvarRetVal)	\
    ( (This)->lpVtbl -> get_Value(This,bstrPropName,pvarRetVal) ) 

#define ICatalogObject_put_Value(This,bstrPropName,val)	\
    ( (This)->lpVtbl -> put_Value(This,bstrPropName,val) ) 

#define ICatalogObject_get_Key(This,pvarRetVal)	\
    ( (This)->lpVtbl -> get_Key(This,pvarRetVal) ) 

#define ICatalogObject_get_Name(This,pvarRetVal)	\
    ( (This)->lpVtbl -> get_Name(This,pvarRetVal) ) 

#define ICatalogObject_IsPropertyReadOnly(This,bstrPropName,pbRetVal)	\
    ( (This)->lpVtbl -> IsPropertyReadOnly(This,bstrPropName,pbRetVal) ) 

#define ICatalogObject_get_Valid(This,pbRetVal)	\
    ( (This)->lpVtbl -> get_Valid(This,pbRetVal) ) 

#define ICatalogObject_IsPropertyWriteOnly(This,bstrPropName,pbRetVal)	\
    ( (This)->lpVtbl -> IsPropertyWriteOnly(This,bstrPropName,pbRetVal) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __ICatalogObject_INTERFACE_DEFINED__ */


#ifndef __ICatalogCollection_INTERFACE_DEFINED__
#define __ICatalogCollection_INTERFACE_DEFINED__

/* interface ICatalogCollection */
/* [unique][helpstring][dual][uuid][object] */ 


EXTERN_C const IID IID_ICatalogCollection;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("6eb22872-8a19-11d0-81b6-00a0c9231c29")
    ICatalogCollection : public IDispatch
    {
    public:
        virtual /* [id][restricted][propget] */ HRESULT STDMETHODCALLTYPE get__NewEnum( 
            /* [retval][out] */ __RPC__deref_out_opt IUnknown **ppEnumVariant) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_Item( 
            /* [in] */ long lIndex,
            /* [retval][out] */ __RPC__deref_out_opt IDispatch **ppCatalogObject) = 0;
        
        virtual /* [helpstring][propget] */ HRESULT STDMETHODCALLTYPE get_Count( 
            /* [retval][out] */ __RPC__out long *plObjectCount) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE Remove( 
            /* [in] */ long lIndex) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE Add( 
            /* [retval][out] */ __RPC__deref_out_opt IDispatch **ppCatalogObject) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE Populate( void) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE SaveChanges( 
            /* [retval][out] */ __RPC__out long *pcChanges) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE GetCollection( 
            /* [in] */ __RPC__in BSTR bstrCollName,
            /* [in] */ VARIANT varObjectKey,
            /* [retval][out] */ __RPC__deref_out_opt IDispatch **ppCatalogCollection) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_Name( 
            /* [retval][out] */ __RPC__out VARIANT *pVarNamel) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_AddEnabled( 
            /* [retval][out] */ __RPC__out VARIANT_BOOL *pVarBool) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_RemoveEnabled( 
            /* [retval][out] */ __RPC__out VARIANT_BOOL *pVarBool) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE GetUtilInterface( 
            /* [retval][out] */ __RPC__deref_out_opt IDispatch **ppIDispatch) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_DataStoreMajorVersion( 
            /* [retval][out] */ __RPC__out long *plMajorVersion) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_DataStoreMinorVersion( 
            /* [retval][out] */ __RPC__out long *plMinorVersionl) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE PopulateByKey( 
            /* [in] */ __RPC__in SAFEARRAY * psaKeys) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE PopulateByQuery( 
            /* [in] */ __RPC__in BSTR bstrQueryString,
            /* [in] */ long lQueryType) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct ICatalogCollectionVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            ICatalogCollection * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            ICatalogCollection * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            ICatalogCollection * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfoCount )( 
            ICatalogCollection * This,
            /* [out] */ __RPC__out UINT *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfo )( 
            ICatalogCollection * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ __RPC__deref_out_opt ITypeInfo **ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetIDsOfNames )( 
            ICatalogCollection * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [size_is][in] */ __RPC__in_ecount_full(cNames) LPOLESTR *rgszNames,
            /* [range][in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ __RPC__out_ecount_full(cNames) DISPID *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE *Invoke )( 
            ICatalogCollection * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS *pDispParams,
            /* [out] */ VARIANT *pVarResult,
            /* [out] */ EXCEPINFO *pExcepInfo,
            /* [out] */ UINT *puArgErr);
        
        /* [id][restricted][propget] */ HRESULT ( STDMETHODCALLTYPE *get__NewEnum )( 
            ICatalogCollection * This,
            /* [retval][out] */ __RPC__deref_out_opt IUnknown **ppEnumVariant);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_Item )( 
            ICatalogCollection * This,
            /* [in] */ long lIndex,
            /* [retval][out] */ __RPC__deref_out_opt IDispatch **ppCatalogObject);
        
        /* [helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE *get_Count )( 
            ICatalogCollection * This,
            /* [retval][out] */ __RPC__out long *plObjectCount);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *Remove )( 
            ICatalogCollection * This,
            /* [in] */ long lIndex);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *Add )( 
            ICatalogCollection * This,
            /* [retval][out] */ __RPC__deref_out_opt IDispatch **ppCatalogObject);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *Populate )( 
            ICatalogCollection * This);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *SaveChanges )( 
            ICatalogCollection * This,
            /* [retval][out] */ __RPC__out long *pcChanges);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *GetCollection )( 
            ICatalogCollection * This,
            /* [in] */ __RPC__in BSTR bstrCollName,
            /* [in] */ VARIANT varObjectKey,
            /* [retval][out] */ __RPC__deref_out_opt IDispatch **ppCatalogCollection);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_Name )( 
            ICatalogCollection * This,
            /* [retval][out] */ __RPC__out VARIANT *pVarNamel);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_AddEnabled )( 
            ICatalogCollection * This,
            /* [retval][out] */ __RPC__out VARIANT_BOOL *pVarBool);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_RemoveEnabled )( 
            ICatalogCollection * This,
            /* [retval][out] */ __RPC__out VARIANT_BOOL *pVarBool);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *GetUtilInterface )( 
            ICatalogCollection * This,
            /* [retval][out] */ __RPC__deref_out_opt IDispatch **ppIDispatch);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_DataStoreMajorVersion )( 
            ICatalogCollection * This,
            /* [retval][out] */ __RPC__out long *plMajorVersion);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_DataStoreMinorVersion )( 
            ICatalogCollection * This,
            /* [retval][out] */ __RPC__out long *plMinorVersionl);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *PopulateByKey )( 
            ICatalogCollection * This,
            /* [in] */ __RPC__in SAFEARRAY * psaKeys);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *PopulateByQuery )( 
            ICatalogCollection * This,
            /* [in] */ __RPC__in BSTR bstrQueryString,
            /* [in] */ long lQueryType);
        
        END_INTERFACE
    } ICatalogCollectionVtbl;

    interface ICatalogCollection
    {
        CONST_VTBL struct ICatalogCollectionVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define ICatalogCollection_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define ICatalogCollection_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define ICatalogCollection_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define ICatalogCollection_GetTypeInfoCount(This,pctinfo)	\
    ( (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo) ) 

#define ICatalogCollection_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    ( (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo) ) 

#define ICatalogCollection_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    ( (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId) ) 

#define ICatalogCollection_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    ( (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr) ) 


#define ICatalogCollection_get__NewEnum(This,ppEnumVariant)	\
    ( (This)->lpVtbl -> get__NewEnum(This,ppEnumVariant) ) 

#define ICatalogCollection_get_Item(This,lIndex,ppCatalogObject)	\
    ( (This)->lpVtbl -> get_Item(This,lIndex,ppCatalogObject) ) 

#define ICatalogCollection_get_Count(This,plObjectCount)	\
    ( (This)->lpVtbl -> get_Count(This,plObjectCount) ) 

#define ICatalogCollection_Remove(This,lIndex)	\
    ( (This)->lpVtbl -> Remove(This,lIndex) ) 

#define ICatalogCollection_Add(This,ppCatalogObject)	\
    ( (This)->lpVtbl -> Add(This,ppCatalogObject) ) 

#define ICatalogCollection_Populate(This)	\
    ( (This)->lpVtbl -> Populate(This) ) 

#define ICatalogCollection_SaveChanges(This,pcChanges)	\
    ( (This)->lpVtbl -> SaveChanges(This,pcChanges) ) 

#define ICatalogCollection_GetCollection(This,bstrCollName,varObjectKey,ppCatalogCollection)	\
    ( (This)->lpVtbl -> GetCollection(This,bstrCollName,varObjectKey,ppCatalogCollection) ) 

#define ICatalogCollection_get_Name(This,pVarNamel)	\
    ( (This)->lpVtbl -> get_Name(This,pVarNamel) ) 

#define ICatalogCollection_get_AddEnabled(This,pVarBool)	\
    ( (This)->lpVtbl -> get_AddEnabled(This,pVarBool) ) 

#define ICatalogCollection_get_RemoveEnabled(This,pVarBool)	\
    ( (This)->lpVtbl -> get_RemoveEnabled(This,pVarBool) ) 

#define ICatalogCollection_GetUtilInterface(This,ppIDispatch)	\
    ( (This)->lpVtbl -> GetUtilInterface(This,ppIDispatch) ) 

#define ICatalogCollection_get_DataStoreMajorVersion(This,plMajorVersion)	\
    ( (This)->lpVtbl -> get_DataStoreMajorVersion(This,plMajorVersion) ) 

#define ICatalogCollection_get_DataStoreMinorVersion(This,plMinorVersionl)	\
    ( (This)->lpVtbl -> get_DataStoreMinorVersion(This,plMinorVersionl) ) 

#define ICatalogCollection_PopulateByKey(This,psaKeys)	\
    ( (This)->lpVtbl -> PopulateByKey(This,psaKeys) ) 

#define ICatalogCollection_PopulateByQuery(This,bstrQueryString,lQueryType)	\
    ( (This)->lpVtbl -> PopulateByQuery(This,bstrQueryString,lQueryType) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __ICatalogCollection_INTERFACE_DEFINED__ */



#ifndef __COMAdmin_LIBRARY_DEFINED__
#define __COMAdmin_LIBRARY_DEFINED__

/* library COMAdmin */
/* [helpstring][version][uuid] */ 

typedef /* [helpstring] */ 
enum COMAdminComponentType
    {	COMAdmin32BitComponent	= 0x1,
	COMAdmin64BitComponent	= 0x2
    } 	COMAdminComponentType;

typedef /* [helpstring] */ 
enum COMAdminApplicationInstallOptions
    {	COMAdminInstallNoUsers	= 0,
	COMAdminInstallUsers	= 1,
	COMAdminInstallForceOverwriteOfFiles	= 2
    } 	COMAdminApplicationInstallOptions;

typedef /* [helpstring] */ 
enum COMAdminApplicationExportOptions
    {	COMAdminExportNoUsers	= 0,
	COMAdminExportUsers	= 1,
	COMAdminExportApplicationProxy	= 2,
	COMAdminExportForceOverwriteOfFiles	= 4,
	COMAdminExportIn10Format	= 16
    } 	COMAdminApplicationExportOptions;

typedef /* [helpstring] */ 
enum COMAdminThreadingModels
    {	COMAdminThreadingModelApartment	= 0,
	COMAdminThreadingModelFree	= 1,
	COMAdminThreadingModelMain	= 2,
	COMAdminThreadingModelBoth	= 3,
	COMAdminThreadingModelNeutral	= 4,
	COMAdminThreadingModelNotSpecified	= 5
    } 	COMAdminThreadingModels;

typedef /* [helpstring] */ 
enum COMAdminTransactionOptions
    {	COMAdminTransactionIgnored	= 0,
	COMAdminTransactionNone	= 1,
	COMAdminTransactionSupported	= 2,
	COMAdminTransactionRequired	= 3,
	COMAdminTransactionRequiresNew	= 4
    } 	COMAdminTransactionOptions;

typedef /* [helpstring] */ 
enum COMAdminTxIsolationLevelOptions
    {	COMAdminTxIsolationLevelAny	= 0,
	COMAdminTxIsolationLevelReadUnCommitted	= ( COMAdminTxIsolationLevelAny + 1 ) ,
	COMAdminTxIsolationLevelReadCommitted	= ( COMAdminTxIsolationLevelReadUnCommitted + 1 ) ,
	COMAdminTxIsolationLevelRepeatableRead	= ( COMAdminTxIsolationLevelReadCommitted + 1 ) ,
	COMAdminTxIsolationLevelSerializable	= ( COMAdminTxIsolationLevelRepeatableRead + 1 ) 
    } 	COMAdminTxIsolationLevelOptions;

typedef /* [helpstring] */ 
enum COMAdminSynchronizationOptions
    {	COMAdminSynchronizationIgnored	= 0,
	COMAdminSynchronizationNone	= 1,
	COMAdminSynchronizationSupported	= 2,
	COMAdminSynchronizationRequired	= 3,
	COMAdminSynchronizationRequiresNew	= 4
    } 	COMAdminSynchronizationOptions;

typedef /* [helpstring] */ 
enum COMAdminActivationOptions
    {	COMAdminActivationInproc	= 0,
	COMAdminActivationLocal	= 1
    } 	COMAdminActivationOptions;

typedef /* [helpstring] */ 
enum COMAdminAccessChecksLevelOptions
    {	COMAdminAccessChecksApplicationLevel	= 0,
	COMAdminAccessChecksApplicationComponentLevel	= 1
    } 	COMAdminAccessChecksLevelOptions;

typedef /* [helpstring] */ 
enum COMAdminAuthenticationLevelOptions
    {	COMAdminAuthenticationDefault	= 0,
	COMAdminAuthenticationNone	= 1,
	COMAdminAuthenticationConnect	= 2,
	COMAdminAuthenticationCall	= 3,
	COMAdminAuthenticationPacket	= 4,
	COMAdminAuthenticationIntegrity	= 5,
	COMAdminAuthenticationPrivacy	= 6
    } 	COMAdminAuthenticationLevelOptions;

typedef /* [helpstring] */ 
enum COMAdminImpersonationLevelOptions
    {	COMAdminImpersonationAnonymous	= 1,
	COMAdminImpersonationIdentify	= 2,
	COMAdminImpersonationImpersonate	= 3,
	COMAdminImpersonationDelegate	= 4
    } 	COMAdminImpersonationLevelOptions;

typedef /* [helpstring] */ 
enum COMAdminAuthenticationCapabilitiesOptions
    {	COMAdminAuthenticationCapabilitiesNone	= 0,
	COMAdminAuthenticationCapabilitiesSecureReference	= 0x2,
	COMAdminAuthenticationCapabilitiesStaticCloaking	= 0x20,
	COMAdminAuthenticationCapabilitiesDynamicCloaking	= 0x40
    } 	COMAdminAuthenticationCapabilitiesOptions;

typedef /* [helpstring] */ 
enum COMAdminOS
    {	COMAdminOSNotInitialized	= 0,
	COMAdminOSWindows3_1	= 1,
	COMAdminOSWindows9x	= 2,
	COMAdminOSWindows2000	= 3,
	COMAdminOSWindows2000AdvancedServer	= 4,
	COMAdminOSWindows2000Unknown	= 5,
	COMAdminOSUnknown	= 6,
	COMAdminOSWindowsXPPersonal	= 11,
	COMAdminOSWindowsXPProfessional	= 12,
	COMAdminOSWindowsNETStandardServer	= 13,
	COMAdminOSWindowsNETEnterpriseServer	= 14,
	COMAdminOSWindowsNETDatacenterServer	= 15,
	COMAdminOSWindowsNETWebServer	= 16,
	COMAdminOSWindowsLonghornPersonal	= 17,
	COMAdminOSWindowsLonghornProfessional	= 18,
	COMAdminOSWindowsLonghornStandardServer	= 19,
	COMAdminOSWindowsLonghornEnterpriseServer	= 20,
	COMAdminOSWindowsLonghornDatacenterServer	= 21,
	COMAdminOSWindowsLonghornWebServer	= 22
    } 	COMAdminOS;

typedef /* [helpstring] */ 
enum COMAdminServiceOptions
    {	COMAdminServiceLoadBalanceRouter	= 1
    } 	COMAdminServiceOptions;

typedef /* [helpstring] */ 
enum COMAdminServiceStatusOptions
    {	COMAdminServiceStopped	= 0,
	COMAdminServiceStartPending	= ( COMAdminServiceStopped + 1 ) ,
	COMAdminServiceStopPending	= ( COMAdminServiceStartPending + 1 ) ,
	COMAdminServiceRunning	= ( COMAdminServiceStopPending + 1 ) ,
	COMAdminServiceContinuePending	= ( COMAdminServiceRunning + 1 ) ,
	COMAdminServicePausePending	= ( COMAdminServiceContinuePending + 1 ) ,
	COMAdminServicePaused	= ( COMAdminServicePausePending + 1 ) ,
	COMAdminServiceUnknownState	= ( COMAdminServicePaused + 1 ) 
    } 	COMAdminServiceStatusOptions;

typedef /* [helpstring] */ 
enum COMAdminQCMessageAuthenticateOptions
    {	COMAdminQCMessageAuthenticateSecureApps	= 0,
	COMAdminQCMessageAuthenticateOff	= 1,
	COMAdminQCMessageAuthenticateOn	= 2
    } 	COMAdminQCMessageAuthenticateOptions;

typedef /* [helpstring] */ 
enum COMAdminFileFlags
    {	COMAdminFileFlagLoadable	= 0x1,
	COMAdminFileFlagCOM	= 0x2,
	COMAdminFileFlagContainsPS	= 0x4,
	COMAdminFileFlagContainsComp	= 0x8,
	COMAdminFileFlagContainsTLB	= 0x10,
	COMAdminFileFlagSelfReg	= 0x20,
	COMAdminFileFlagSelfUnReg	= 0x40,
	COMAdminFileFlagUnloadableDLL	= 0x80,
	COMAdminFileFlagDoesNotExist	= 0x100,
	COMAdminFileFlagAlreadyInstalled	= 0x200,
	COMAdminFileFlagBadTLB	= 0x400,
	COMAdminFileFlagGetClassObjFailed	= 0x800,
	COMAdminFileFlagClassNotAvailable	= 0x1000,
	COMAdminFileFlagRegistrar	= 0x2000,
	COMAdminFileFlagNoRegistrar	= 0x4000,
	COMAdminFileFlagDLLRegsvrFailed	= 0x8000,
	COMAdminFileFlagRegTLBFailed	= 0x10000,
	COMAdminFileFlagRegistrarFailed	= 0x20000,
	COMAdminFileFlagError	= 0x40000
    } 	COMAdminFileFlags;

typedef /* [helpstring] */ 
enum COMAdminComponentFlags
    {	COMAdminCompFlagTypeInfoFound	= 0x1,
	COMAdminCompFlagCOMPlusPropertiesFound	= 0x2,
	COMAdminCompFlagProxyFound	= 0x4,
	COMAdminCompFlagInterfacesFound	= 0x8,
	COMAdminCompFlagAlreadyInstalled	= 0x10,
	COMAdminCompFlagNotInApplication	= 0x20
    } 	COMAdminComponentFlags;

#define	COMAdminCollectionRoot	( "Root" )

#define	COMAdminCollectionApplications	( "Applications" )

#define	COMAdminCollectionComponents	( "Components" )

#define	COMAdminCollectionComputerList	( "ComputerList" )

#define	COMAdminCollectionApplicationCluster	( "ApplicationCluster" )

#define	COMAdminCollectionLocalComputer	( "LocalComputer" )

#define	COMAdminCollectionInprocServers	( "InprocServers" )

#define	COMAdminCollectionRelatedCollectionInfo	( "RelatedCollectionInfo" )

#define	COMAdminCollectionPropertyInfo	( "PropertyInfo" )

#define	COMAdminCollectionRoles	( "Roles" )

#define	COMAdminCollectionErrorInfo	( "ErrorInfo" )

#define	COMAdminCollectionInterfacesForComponent	( "InterfacesForComponent" )

#define	COMAdminCollectionRolesForComponent	( "RolesForComponent" )

#define	COMAdminCollectionMethodsForInterface	( "MethodsForInterface" )

#define	COMAdminCollectionRolesForInterface	( "RolesForInterface" )

#define	COMAdminCollectionRolesForMethod	( "RolesForMethod" )

#define	COMAdminCollectionUsersInRole	( "UsersInRole" )

#define	COMAdminCollectionDCOMProtocols	( "DCOMProtocols" )

#define	COMAdminCollectionPartitions	( "Partitions" )

typedef /* [helpstring] */ 
enum COMAdminErrorCodes
    {	COMAdminErrObjectErrors	= ( HRESULT  )0x80110401L,
	COMAdminErrObjectInvalid	= ( HRESULT  )0x80110402L,
	COMAdminErrKeyMissing	= ( HRESULT  )0x80110403L,
	COMAdminErrAlreadyInstalled	= ( HRESULT  )0x80110404L,
	COMAdminErrAppFileWriteFail	= ( HRESULT  )0x80110407L,
	COMAdminErrAppFileReadFail	= ( HRESULT  )0x80110408L,
	COMAdminErrAppFileVersion	= ( HRESULT  )0x80110409L,
	COMAdminErrBadPath	= ( HRESULT  )0x8011040aL,
	COMAdminErrApplicationExists	= ( HRESULT  )0x8011040bL,
	COMAdminErrRoleExists	= ( HRESULT  )0x8011040cL,
	COMAdminErrCantCopyFile	= ( HRESULT  )0x8011040dL,
	COMAdminErrNoUser	= ( HRESULT  )0x8011040fL,
	COMAdminErrInvalidUserids	= ( HRESULT  )0x80110410L,
	COMAdminErrNoRegistryCLSID	= ( HRESULT  )0x80110411L,
	COMAdminErrBadRegistryProgID	= ( HRESULT  )0x80110412L,
	COMAdminErrAuthenticationLevel	= ( HRESULT  )0x80110413L,
	COMAdminErrUserPasswdNotValid	= ( HRESULT  )0x80110414L,
	COMAdminErrCLSIDOrIIDMismatch	= ( HRESULT  )0x80110418L,
	COMAdminErrRemoteInterface	= ( HRESULT  )0x80110419L,
	COMAdminErrDllRegisterServer	= ( HRESULT  )0x8011041aL,
	COMAdminErrNoServerShare	= ( HRESULT  )0x8011041bL,
	COMAdminErrDllLoadFailed	= ( HRESULT  )0x8011041dL,
	COMAdminErrBadRegistryLibID	= ( HRESULT  )0x8011041eL,
	COMAdminErrAppDirNotFound	= ( HRESULT  )0x8011041fL,
	COMAdminErrRegistrarFailed	= ( HRESULT  )0x80110423L,
	COMAdminErrCompFileDoesNotExist	= ( HRESULT  )0x80110424L,
	COMAdminErrCompFileLoadDLLFail	= ( HRESULT  )0x80110425L,
	COMAdminErrCompFileGetClassObj	= ( HRESULT  )0x80110426L,
	COMAdminErrCompFileClassNotAvail	= ( HRESULT  )0x80110427L,
	COMAdminErrCompFileBadTLB	= ( HRESULT  )0x80110428L,
	COMAdminErrCompFileNotInstallable	= ( HRESULT  )0x80110429L,
	COMAdminErrNotChangeable	= ( HRESULT  )0x8011042aL,
	COMAdminErrNotDeletable	= ( HRESULT  )0x8011042bL,
	COMAdminErrSession	= ( HRESULT  )0x8011042cL,
	COMAdminErrCompMoveLocked	= ( HRESULT  )0x8011042dL,
	COMAdminErrCompMoveBadDest	= ( HRESULT  )0x8011042eL,
	COMAdminErrRegisterTLB	= ( HRESULT  )0x80110430L,
	COMAdminErrSystemApp	= ( HRESULT  )0x80110433L,
	COMAdminErrCompFileNoRegistrar	= ( HRESULT  )0x80110434L,
	COMAdminErrCoReqCompInstalled	= ( HRESULT  )0x80110435L,
	COMAdminErrServiceNotInstalled	= ( HRESULT  )0x80110436L,
	COMAdminErrPropertySaveFailed	= ( HRESULT  )0x80110437L,
	COMAdminErrObjectExists	= ( HRESULT  )0x80110438L,
	COMAdminErrComponentExists	= ( HRESULT  )0x80110439L,
	COMAdminErrRegFileCorrupt	= ( HRESULT  )0x8011043bL,
	COMAdminErrPropertyOverflow	= ( HRESULT  )0x8011043cL,
	COMAdminErrNotInRegistry	= ( HRESULT  )0x8011043eL,
	COMAdminErrObjectNotPoolable	= ( HRESULT  )0x8011043fL,
	COMAdminErrApplidMatchesClsid	= ( HRESULT  )0x80110446L,
	COMAdminErrRoleDoesNotExist	= ( HRESULT  )0x80110447L,
	COMAdminErrStartAppNeedsComponents	= ( HRESULT  )0x80110448L,
	COMAdminErrRequiresDifferentPlatform	= ( HRESULT  )0x80110449L,
	COMAdminErrQueuingServiceNotAvailable	= ( HRESULT  )0x80110602L,
	COMAdminErrObjectParentMissing	= ( HRESULT  )0x80110808L,
	COMAdminErrObjectDoesNotExist	= ( HRESULT  )0x80110809L,
	COMAdminErrCanNotExportAppProxy	= ( HRESULT  )0x8011044aL,
	COMAdminErrCanNotStartApp	= ( HRESULT  )0x8011044bL,
	COMAdminErrCanNotExportSystemApp	= ( HRESULT  )0x8011044cL,
	COMAdminErrCanNotSubscribeToComponent	= ( HRESULT  )0x8011044dL,
	COMAdminErrAppNotRunning	= ( HRESULT  )0x8011080aL,
	COMAdminErrEventClassCannotBeSubscriber	= ( HRESULT  )0x8011044eL,
	COMAdminErrLibAppProxyIncompatible	= ( HRESULT  )0x8011044fL,
	COMAdminErrBasePartitionOnly	= ( HRESULT  )0x80110450L,
	COMAdminErrDuplicatePartitionName	= ( HRESULT  )0x80110457L,
	COMAdminErrPartitionInUse	= ( HRESULT  )0x80110459L,
	COMAdminErrImportedComponentsNotAllowed	= ( HRESULT  )0x8011045bL,
	COMAdminErrRegdbNotInitialized	= ( HRESULT  )0x80110472L,
	COMAdminErrRegdbNotOpen	= ( HRESULT  )0x80110473L,
	COMAdminErrRegdbSystemErr	= ( HRESULT  )0x80110474L,
	COMAdminErrRegdbAlreadyRunning	= ( HRESULT  )0x80110475L,
	COMAdminErrMigVersionNotSupported	= ( HRESULT  )0x80110480L,
	COMAdminErrMigSchemaNotFound	= ( HRESULT  )0x80110481L,
	COMAdminErrCatBitnessMismatch	= ( HRESULT  )0x80110482L,
	COMAdminErrCatUnacceptableBitness	= ( HRESULT  )0x80110483L,
	COMAdminErrCatWrongAppBitnessBitness	= ( HRESULT  )0x80110484L,
	COMAdminErrCatPauseResumeNotSupported	= ( HRESULT  )0x80110485L,
	COMAdminErrCatServerFault	= ( HRESULT  )0x80110486L,
	COMAdminErrCantRecycleLibraryApps	= ( HRESULT  )0x8011080fL,
	COMAdminErrCantRecycleServiceApps	= ( HRESULT  )0x80110811L,
	COMAdminErrProcessAlreadyRecycled	= ( HRESULT  )0x80110812L,
	COMAdminErrPausedProcessMayNotBeRecycled	= ( HRESULT  )0x80110813L,
	COMAdminErrInvalidPartition	= ( HRESULT  )0x8011080bL,
	COMAdminErrPartitionMsiOnly	= ( HRESULT  )0x80110819L,
	COMAdminErrStartAppDisabled	= ( HRESULT  )0x80110451L,
	COMAdminErrCompMoveSource	= ( HRESULT  )0x8011081cL,
	COMAdminErrCompMoveDest	= ( HRESULT  )0x8011081dL,
	COMAdminErrCompMovePrivate	= ( HRESULT  )0x8011081eL,
	COMAdminErrCannotCopyEventClass	= ( HRESULT  )0x80110820L
    } 	COMAdminErrorCodes;


EXTERN_C const IID LIBID_COMAdmin;

EXTERN_C const CLSID CLSID_COMAdminCatalog;

#ifdef __cplusplus

class DECLSPEC_UUID("F618C514-DFB8-11d1-A2CF-00805FC79235")
COMAdminCatalog;
#endif

EXTERN_C const CLSID CLSID_COMAdminCatalogObject;

#ifdef __cplusplus

class DECLSPEC_UUID("F618C515-DFB8-11d1-A2CF-00805FC79235")
COMAdminCatalogObject;
#endif

EXTERN_C const CLSID CLSID_COMAdminCatalogCollection;

#ifdef __cplusplus

class DECLSPEC_UUID("F618C516-DFB8-11d1-A2CF-00805FC79235")
COMAdminCatalogCollection;
#endif
#endif /* __COMAdmin_LIBRARY_DEFINED__ */

/* Additional Prototypes for ALL interfaces */

unsigned long             __RPC_USER  BSTR_UserSize(     unsigned long *, unsigned long            , BSTR * ); 
unsigned char * __RPC_USER  BSTR_UserMarshal(  unsigned long *, unsigned char *, BSTR * ); 
unsigned char * __RPC_USER  BSTR_UserUnmarshal(unsigned long *, unsigned char *, BSTR * ); 
void                      __RPC_USER  BSTR_UserFree(     unsigned long *, BSTR * ); 

unsigned long             __RPC_USER  LPSAFEARRAY_UserSize(     unsigned long *, unsigned long            , LPSAFEARRAY * ); 
unsigned char * __RPC_USER  LPSAFEARRAY_UserMarshal(  unsigned long *, unsigned char *, LPSAFEARRAY * ); 
unsigned char * __RPC_USER  LPSAFEARRAY_UserUnmarshal(unsigned long *, unsigned char *, LPSAFEARRAY * ); 
void                      __RPC_USER  LPSAFEARRAY_UserFree(     unsigned long *, LPSAFEARRAY * ); 

unsigned long             __RPC_USER  VARIANT_UserSize(     unsigned long *, unsigned long            , VARIANT * ); 
unsigned char * __RPC_USER  VARIANT_UserMarshal(  unsigned long *, unsigned char *, VARIANT * ); 
unsigned char * __RPC_USER  VARIANT_UserUnmarshal(unsigned long *, unsigned char *, VARIANT * ); 
void                      __RPC_USER  VARIANT_UserFree(     unsigned long *, VARIANT * ); 

unsigned long             __RPC_USER  BSTR_UserSize64(     unsigned long *, unsigned long            , BSTR * ); 
unsigned char * __RPC_USER  BSTR_UserMarshal64(  unsigned long *, unsigned char *, BSTR * ); 
unsigned char * __RPC_USER  BSTR_UserUnmarshal64(unsigned long *, unsigned char *, BSTR * ); 
void                      __RPC_USER  BSTR_UserFree64(     unsigned long *, BSTR * ); 

unsigned long             __RPC_USER  LPSAFEARRAY_UserSize64(     unsigned long *, unsigned long            , LPSAFEARRAY * ); 
unsigned char * __RPC_USER  LPSAFEARRAY_UserMarshal64(  unsigned long *, unsigned char *, LPSAFEARRAY * ); 
unsigned char * __RPC_USER  LPSAFEARRAY_UserUnmarshal64(unsigned long *, unsigned char *, LPSAFEARRAY * ); 
void                      __RPC_USER  LPSAFEARRAY_UserFree64(     unsigned long *, LPSAFEARRAY * ); 

unsigned long             __RPC_USER  VARIANT_UserSize64(     unsigned long *, unsigned long            , VARIANT * ); 
unsigned char * __RPC_USER  VARIANT_UserMarshal64(  unsigned long *, unsigned char *, VARIANT * ); 
unsigned char * __RPC_USER  VARIANT_UserUnmarshal64(unsigned long *, unsigned char *, VARIANT * ); 
void                      __RPC_USER  VARIANT_UserFree64(     unsigned long *, VARIANT * ); 

/* end of Additional Prototypes */

#ifdef __cplusplus
}
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\vs9sp1\sdk\include\contentpartner.h ===
/* this ALWAYS GENERATED file contains the definitions for the interfaces */


 /* File created by MIDL compiler version 7.00.0499 */
/* Compiler settings for contentpartner.idl:
    Oicf, W1, Zp8, env=Win32 (32b run)
    protocol : dce , ms_ext, c_ext, robust
    error checks: allocation ref bounds_check enum stub_data 
    VC __declspec() decoration level: 
         __declspec(uuid()), __declspec(selectany), __declspec(novtable)
         DECLSPEC_UUID(), MIDL_INTERFACE()
*/
//@@MIDL_FILE_HEADING(  )

#pragma warning( disable: 4049 )  /* more than 64k source lines */


/* verify that the <rpcndr.h> version is high enough to compile this file*/
#ifndef __REQUIRED_RPCNDR_H_VERSION__
#define __REQUIRED_RPCNDR_H_VERSION__ 500
#endif

/* verify that the <rpcsal.h> version is high enough to compile this file*/
#ifndef __REQUIRED_RPCSAL_H_VERSION__
#define __REQUIRED_RPCSAL_H_VERSION__ 100
#endif

#include "rpc.h"
#include "rpcndr.h"

#ifndef __RPCNDR_H_VERSION__
#error this stub requires an updated version of <rpcndr.h>
#endif // __RPCNDR_H_VERSION__

#ifndef COM_NO_WINDOWS_H
#include "windows.h"
#include "ole2.h"
#endif /*COM_NO_WINDOWS_H*/

#ifndef __contentpartner_h__
#define __contentpartner_h__

#if defined(_MSC_VER) && (_MSC_VER >= 1020)
#pragma once
#endif

/* Forward Declarations */ 

#ifndef __IWMPContentContainer_FWD_DEFINED__
#define __IWMPContentContainer_FWD_DEFINED__
typedef interface IWMPContentContainer IWMPContentContainer;
#endif 	/* __IWMPContentContainer_FWD_DEFINED__ */


#ifndef __IWMPContentContainerList_FWD_DEFINED__
#define __IWMPContentContainerList_FWD_DEFINED__
typedef interface IWMPContentContainerList IWMPContentContainerList;
#endif 	/* __IWMPContentContainerList_FWD_DEFINED__ */


#ifndef __IWMPContentPartnerCallback_FWD_DEFINED__
#define __IWMPContentPartnerCallback_FWD_DEFINED__
typedef interface IWMPContentPartnerCallback IWMPContentPartnerCallback;
#endif 	/* __IWMPContentPartnerCallback_FWD_DEFINED__ */


#ifndef __IWMPContentPartner_FWD_DEFINED__
#define __IWMPContentPartner_FWD_DEFINED__
typedef interface IWMPContentPartner IWMPContentPartner;
#endif 	/* __IWMPContentPartner_FWD_DEFINED__ */


/* header files for imported files */
#include "oaidl.h"
#include "ocidl.h"

#ifdef __cplusplus
extern "C"{
#endif 


/* interface __MIDL_itf_contentpartner_0000_0000 */
/* [local] */ 

//=========================================================================
//
// Microsoft Windows Media Technologies
// Copyright (C) Microsoft Corporation. All rights reserved.
//
//=========================================================================

///////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// These constants are used in the IWMPContentPartner::GetContentPartnerInfo API for the bstrInfoName parameter.

static const WCHAR g_szContentPartnerInfo_LoginState[]             = L"LoginState";

// Synopsis: IWMPContentPartner::GetContentPartnerInfo
//              /*out parameter*/   VARIANT *pData    -> Type must be VT_BOOL, indicates whether the user is logged into the services

static const WCHAR g_szContentPartnerInfo_MediaPlayerAccountType[] = L"MediaPlayerAccountType";

// Synopsis: IWMPContentPartner::GetContentPartnerInfo
//              /*out parameter*/   VARIANT *pData    -> Type must be VT_UI4,  - Represents a WMPAccountType value, this value is interpreted by the media player

static const WCHAR g_szContentPartnerInfo_AccountType[]            = L"AccountType";

// Synopsis: IWMPContentPartner::GetContentPartnerInfo
//              /*out parameter*/   VARIANT *pData    -> Type must be VT_BSTR,  - Represents subscriptions services account type as a string
//                                                    -> This value is not interpreted by the media player, and may be shown to the user

static const WCHAR g_szContentPartnerInfo_HasCachedCredentials[]   = L"HasCachedCredentials";   // VT_BOOL - Returns whether plugin has cached credentials

// Synopsis: IWMPContentPartner::GetContentPartnerInfo
//              /*out parameter*/   VARIANT *pData    -> Type must be VT_BOOL, indicates whether the pluggin has cached
//                                                    -> credentials necessary to log in to the service

static const WCHAR g_szContentPartnerInfo_LicenseRefreshAdvanceWarning[] = L"LicenseRefreshAdvanceWarning";

// Synopsis: IWMPContentPartner::GetContentPartnerInfo
//              /*out parameter*/   VARIANT *pData    -> Type must be VT_UI4, representing days  - This value is used by the player to pre-emptively refresh licenses that will expire soon.
//                                                    -> For example, if the plugin can support refreshing a playback license 5 days before it expires, then pData->ulVal should be set to 5.
//                                                    -> This value is a global setting, and cannot be different for different licenses, users, etc.

static const WCHAR g_szContentPartnerInfo_PurchasedTrackRequiresReDownload[] = L"PurchasedTrackRequiresReDownload";
//              /*out parameter*/   VARIANT *pData    -> Type must be VT_BOOL, represents whether a purchased track must be redownloaded if the content had been previously downloaded.

static const WCHAR g_szContentPartnerInfo_MaximumTrackPurchasePerPurchase[]  = L"MaximumNumberOfTracksPerPurchase";
//              /*out parameter*/   VARIANT *pData    -> Type must be VT_UI4, indicates the maximum number of tracks that can be handled in a single IWMPContentParnter::Buy call.
//                                                       0 indicates no maximum.

static const WCHAR g_szContentPartnerInfo_AccountBalance[]  = L"AccountBalance";
//              /*out parameter*/   VARIANT *pData    -> Type must be VT_BSTR,  - Represents account balance as a string
//                                                    -> This value is not interpreted by the media player, and may be shown to the user

static const WCHAR g_szContentPartnerInfo_UserName[]  = L"UserName";
//              /*out parameter*/   VARIANT *pData    -> Type must be VT_BSTR,  - Represents user's account friendly name as a string
//                                                    -> This value is not interpreted by the media player, and may be shown to the user


///////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// These constants are returned to the HTML templates hosted in the player (returned from IWMPContentPartner::GetTemplate
// from the window.external.task API

static const WCHAR g_szMediaPlayerTask_Burn[]                    = L"Burn";
static const WCHAR g_szMediaPlayerTask_Browse[]                  = L"Browse";
static const WCHAR g_szMediaPlayerTask_Sync[]                    = L"Sync";

///////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// These constants are used in the IWMPContentPartner::GetItemInfo API for the bstrInfoName parameter

static const WCHAR g_szItemInfo_PopupURL[]                       = L"Popup";

// Synopsis: IWMPContentPartner::GetItemInfo
//              /*input parameter*/ VARIANT *pContext -> Type is VT_I4, indicates index of popup URL to return
//              /*out parameter*/   VARIANT *pData    -> Type must be VT_BSTR, indicates URL to host in HTML based dialog

static const WCHAR g_szItemInfo_AuthenticationSuccessURL[]       = L"AuthenticationSuccessURL";

// Synopsis: IWMPContentPartner::GetItemInfo
//              /*input parameter*/ VARIANT *pContext -> Type is VT_I4, indicates index of Authentication URL to return
//              /*out parameter*/   VARIANT *pData    -> Type must be VT_BSTR, indicates URL to navigate if authentication is successful

static const WCHAR g_szItemInfo_LoginFailureURL[]                = L"LoginFailureURL";

// Synopsis: IWMPContentPartner::GetItemInfo
//              /*input parameter*/ VARIANT *pContext -> Type is VT_UI4, indicates index of LoginFailureURL to query.  This value was passed to the player via Notify( wmpcnLoginStateChange, <value
//              /*out parameter*/   VARIANT *pData    -> Type must be VT_BSTR, indicates URL to navigate when loginstatechange 

static const WCHAR g_szItemInfo_HTMLViewURL[]                = L"HTMLViewURL";

// Synopsis: IWMPContentPartner::GetItemInfo
//              /*input parameter*/ VARIANT *pContext -> Type is VT_BSTR, this is the string specified in the ASX file.  For example: <param name="HTMLFLINK" value="foo" \> 
//              /*out parameter*/   VARIANT *pData    -> Type must be VT_BSTR, indicates URL to use for the HTMLView 

static const WCHAR g_szItemInfo_PopupCaption[]                   = L"PopupCaption";

// Synopsis: IWMPContentPartner::GetItemInfo
//              /*input parameter*/ VARIANT *pContext -> Type is VT_I4, indicates index of popup URL to return
//              /*out parameter*/   VARIANT *pData    -> Type must be VT_BSTR, indicates caption for the HTML based dialog

static const WCHAR g_szItemInfo_ALTLoginURL[]              = L"ALTLoginURL";

// Synopsis: IWMPContentPartner::GetItemInfo
//              /*input parameter*/ VARIANT *pContext -> Type is VT_EMPTY, contains nothing
//              /*out parameter*/   VARIANT *pData    -> Type must be VT_BSTR, indicates URL for the alternative login

static const WCHAR g_szItemInfo_ALTLoginCaption[]              = L"ALTLoginCaption";

// Synopsis: IWMPContentPartner::GetItemInfo
//              /*input parameter*/ VARIANT *pContext -> Type is VT_EMPTY, contains nothing
//              /*out parameter*/   VARIANT *pData    -> Type must be VT_BSTR, indicates caption for the alternative login

static const WCHAR g_szItemInfo_ForgetPasswordURL[]              = L"ForgotPassword";

// Synopsis: IWMPContentPartner::GetItemInfo
//              /*input parameter*/ VARIANT *pContext -> Type is VT_EMPTY, contains nothing
//              /*out parameter*/   VARIANT *pData    -> Type must be VT_BSTR, indicates URL to navigate the service plane
//                                                    -> in the event the user has forgotten their password

static const WCHAR g_szItemInfo_CreateAccountURL[]               = L"CreateAccount";

// Synopsis: IWMPContentPartner::GetItemInfo
//              /*input parameter*/ VARIANT *pContext -> Type is VT_EMPTY, contains nothing
//              /*out parameter*/   VARIANT *pData    -> Type must be VT_BSTR, indicates URL to navigate the service plane
//                                                    -> which the user can manage their account

static const WCHAR g_szItemInfo_ArtistArtURL[]                   = L"ArtistArt";

// Synopsis: IWMPContentPartner::GetItemInfo
//              /*input parameter*/ VARIANT *pContext -> Type is VT_UI4, containing the aritst ID from the catalog
//              /*out parameter*/   VARIANT *pData    -> Type must be VT_BSTR, indicates URL to retrieve artist art

static const WCHAR g_szItemInfo_AlbumArtURL[]                    = L"AlbumArt";

// Synopsis: IWMPContentPartner::GetItemInfo
//              /*input parameter*/ VARIANT *pContext -> Type is VT_UI4, containing the album ID from the catalog
//              /*out parameter*/   VARIANT *pData    -> Type must be VT_BSTR, indicates URL to retrieve album art

static const WCHAR g_szItemInfo_ListArtURL[]                     = L"ListArt";

// Synopsis: IWMPContentPartner::GetItemInfo
//              /*input parameter*/ VARIANT *pContext -> Type is VT_UI4, containing the list ID from the catalog
//              /*out parameter*/   VARIANT *pData    -> Type must be VT_BSTR, indicates URL to retrieve list art

static const WCHAR g_szItemInfo_GenreArtURL[]                    = L"GenreArt";

// Synopsis: IWMPContentPartner::GetItemInfo
//              /*input parameter*/ VARIANT *pContext -> Type is VT_UI4, containing the genre ID from the catalog
//              /*out parameter*/   VARIANT *pData    -> Type must be VT_BSTR, indicates URL to retrieve genre art

static const WCHAR g_szItemInfo_SubGenreArtURL[]                 = L"SubGenreArt";

// Synopsis: IWMPContentPartner::GetItemInfo
//              /*input parameter*/ VARIANT *pContext -> Type is VT_UI4, containing the sub-genre ID from the catalog
//              /*out parameter*/   VARIANT *pData    -> Type must be VT_BSTR, indicates URL to retrieve sub-genre art

static const WCHAR g_szItemInfo_RadioArtURL[]                 = L"RadioArt";

// Synopsis: IWMPContentPartner::GetItemInfo
//              /*input parameter*/ VARIANT *pContext -> Type is VT_UI4, containing the radio ID from the catalog
//              /*out parameter*/   VARIANT *pData    -> Type must be VT_BSTR, indicates URL to retrieve radio art

static const WCHAR g_szItemInfo_TreeListIconURL[]                 = L"CPListIDIcon";

// Synopsis: IWMPContentPartner::GetItemInfo
//              /*input parameter*/ VARIANT *pContext -> Type is VT_UI4, containing the list ID from the catalog
//              /*out parameter*/   VARIANT *pData    -> Type must be VT_BSTR, indicates URL to retrieve list icon art

static const WCHAR g_szItemInfo_ErrorDescription[]                = L"CPErrorDescription";

// Synopsis: IWMPContentPartner::GetItemInfo
//              /*input parameter*/ VARIANT *pContext -> Type is VT_ERROR, containing the error code
//              /*out parameter*/   VARIANT *pData    -> Type must be VT_BSTR, text describing the error.
//                                                       Fail this call if you do not understand error code

static const WCHAR g_szItemInfo_ErrorURL[]                        = L"CPErrorURL";

// Synopsis: IWMPContentPartner::GetItemInfo
//              /*input parameter*/ VARIANT *pContext -> Type is VT_ERROR, containing the error code
//              /*out parameter*/   VARIANT *pData    -> Type must be VT_BSTR, url that the service pane will be navigated
//                                                       to when then user clicks the resolve link

static const WCHAR g_szItemInfo_ErrorURLLinkText[]                    = L"CPErrorURLLinkText";

// Synopsis: IWMPContentPartner::GetItemInfo
//              /*input parameter*/ VARIANT *pContext -> Type is VT_ERROR, containing the error code
//              /*out parameter*/   VARIANT *pData    -> Type must be VT_BSTR, text that will be used for the hyperlink
//                                                       text for the URL returned from g_szItemInfo_ErrorURL


///////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// These constants are used in the all the IWMPContentPartner and IWMPContentPartnerCallback APIs
// that deal with some sort of location or object type.

static const WCHAR g_szUnknownLocation[]                         = L"UnknownLocation";

// Passed when the media player cannot determine a valid location to pass to the plugin.
// should rarely happen

static const WCHAR g_szRootLocation[]                            = L"RootLocation";           // Passed when the user is on the 'root' tree node of the service

// Passed when the action is taking place on the root content-partner node in the media player's lbrary tree

static const WCHAR g_szFlyoutMenu[]                            = L"FlyoutMenu";                 // Passed when the user selects the flyout menu of the service

// Passed when the user selects the flyout menu of the service

static const WCHAR g_szOnlineStore[]                           = L"OnlineStore";               // Used to navigate the player to the online stores page in the call to IWMPContentPartnerCallback::ChangeView

static const WCHAR g_szVideoRecent[]                           = L"VideoRecent";               // Used to navigate the player to the online stores page in the call to IWMPContentPartnerCallback::ChangeView

static const WCHAR g_szVideoRoot[]                           = L"VideoRoot";               // Used to navigate the player to the online stores page in the call to IWMPContentPartnerCallback::ChangeView

// These constants are used in the all the IWMPContentPartner and IWMPContentPartnerCallback APIs
// They indicate either a location in the library (see IWMPContentPartner::GetTemplate) or
// a type being returned via a callback (see IWMPContentPartner::GetListContents and
// IWMPContentPartnerCallback::AddListContents

static const WCHAR g_szCPListID[]                                   = L"CPListID"; 
static const WCHAR g_szAllCPListIDs[]                               = L"AllCPListIDs"; 
static const WCHAR g_szCPTrackID[]                                  = L"CPTrackID"; 
static const WCHAR g_szAllCPTrackIDs[]                              = L"AllCPTrackIDs"; 
static const WCHAR g_szCPArtistID[]                                 = L"CPArtistID"; 
static const WCHAR g_szAllCPArtistIDs[]                             = L"AllCPArtistIDs"; 
static const WCHAR g_szCPAlbumID[]                                  = L"CPAlbumID"; 
static const WCHAR g_szAllCPAlbumIDs[]                              = L"AllCPAlbumIDs"; 
static const WCHAR g_szCPGenreID[]                                  = L"CPGenreID"; 
static const WCHAR g_szAllCPGenreIDs[]                              = L"AllCPGenreIDs"; 
static const WCHAR g_szCPAlbumSubGenreID[]                          = L"CPAlbumSubGenreID"; 
static const WCHAR g_szAllCPAlbumSubGenreIDs[]                      = L"AllCPAlbumSubGenreIDs"; 
static const WCHAR g_szReleaseDateYear[]                            = L"ReleaseDateYear"; 
static const WCHAR g_szAllReleaseDateYears[]                        = L"AllReleaseDateYears"; 
static const WCHAR g_szCPRadioID[]                                  = L"CPRadioID"; 
static const WCHAR g_szAllCPRadioIDs[]                              = L"AllCPRadioIDs"; 
static const WCHAR g_szAuthor[]                                     = L"Author"; 
static const WCHAR g_szAllAuthors[]                                 = L"AllAuthors"; 
static const WCHAR g_szWMParentalRating[]                           = L"WMParentalRating"; 
static const WCHAR g_szAllWMParentalRatings[]                       = L"AllWMParentalRatings"; 
static const WCHAR g_szAllUserEffectiveRatingStarss[]               = L"AllUserEffectiveRatingStarss"; 
static const WCHAR g_szUserEffectiveRatingStars[]                   = L"UserEffectiveRatingStars"; 
static const WCHAR g_szUserPlaylist[]                               = L"UserPlaylist"; 
static ULONG g_knReservedCPTrackID_NotFound                         = (DWORD)-1; 

///////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// These constants are to be used by the window.external.changeViewOnlineList for the bstrViewMode parameter

static const WCHAR g_szViewMode_Report[]                          = L"ViewModeReport";         // Display dynamic list contents in report mode
static const WCHAR g_szViewMode_Details[]                         = L"ViewModeDetails";        // Display dynamic list contents in details mode
static const WCHAR g_szViewMode_Icon[]                            = L"ViewModeIcon";           // Display dynamic list contents in icon mode
static const WCHAR g_szViewMode_Tile[]                            = L"ViewModeTile";           // Display dynamic list contents in tile mode
static const WCHAR g_szViewMode_OrderedList[]                     = L"ViewModeOrderedList";    // Display dynamic list contents in ordered list mode

///////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// These constants are used in the IWMPContentContainer APIs for detecting fixed pricing

static const WCHAR g_szContentPrice_Unknown[]                     = L"PriceUnknown";           // The price of the content is unknown
static const WCHAR g_szContentPrice_CannotBuy[]                   = L"PriceCannotBuy";         // The content cannot be bought
static const WCHAR g_szContentPrice_Free[]                        = L"PriceFree";              // The content is free
//////////////////////////////////////////////////////////////////////
//          SERVICE CAPABILITIES THAT APPLY TO CONTENT-PARTNER-PLUGINS
//
// NOTE: If SUBSCRIPTION_CAP_IS_CONTENTPARTNER is not present, the 
// content partner plugin will NOT load
//
// These values are written in the registry as a DWORD value called 'Capabilities'
// under HKEY_LOCAL_MACHINE\SOFTWARE\Microsoft\MediaPlayer\Subscriptions\<ContentPartnerPluginKey>
// See the MSDN section on Online Stores Programming Reference in the Windows Media SDK
//////////////////////////////////////////////////////////////////////
#ifndef SUBSCRIPTION_CAP_DEVICEAVAILABLE
#define SUBSCRIPTION_CAP_DEVICEAVAILABLE        0x00000010
#endif
#ifndef SUBSCRIPTION_CAP_BACKGROUNDPROCESSING
#define SUBSCRIPTION_CAP_BACKGROUNDPROCESSING   0x00000008
#endif
#ifndef SUBSCRIPTION_CAP_IS_CONTENTPARTNER
#define SUBSCRIPTION_CAP_IS_CONTENTPARTNER      0x00000040
#endif
#ifndef SUBSCRIPTION_CAP_ALTLOGIN
#define SUBSCRIPTION_CAP_ALTLOGIN      0x00000080
#endif

///////////////////////////////////////////////////////////////////////////////////////////////////////////////////

// The WMPPartnerNotification enum values are passed to the IWMPContentPartner::Notify API

// Synopsis - IWMPContentPartner::Notify( wmpsnBackgroundProcessingBegin 
//                                           /*input*/ VARIANT *pContenxt, type must be VT_EMPTY
// Remarks: the plugin can start background processing

// Synopsis - IWMPContentPartner::Notify( wmpsnBackgroundProcessingEnd 
//                                           /*input*/ VARIANT *pContenxt, type must be VT_EMPTY
// Remarks: the plugin should stop background processing, this enables the player to use more CPU for playback

// Synopsis - IWMPContentPartner::Notify( wmpsnCatalogDownloadFailure 
//                                           /*input*/ VARIANT *pContenxt, type must be VT_ERROR
// Remarks: indicates a failure while downloading the catalog

// Synopsis - IWMPContentPartner::Notify( wmpsnCatalogDownloadComplete 
//                                           /*input*/ VARIANT *pContenxt, type must be VT_EMPTY
// Remarks: indicates the catalog was downloaded successfully


///////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// These constants are used in the IWMPContentPartner::RefreshLicesnse APIs for the reason

static const WCHAR g_szRefreshLicensePlay[]                     = L"RefreshForPlay";
static const WCHAR g_szRefreshLicenseBurn[]                     = L"RefreshForBurn";
static const WCHAR g_szRefreshLicenseSync[]                     = L"RefreshForSync";

///////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// These constants are used in the IWMPContentPartner::VerifyPermission APIs

static const WCHAR g_szVerifyPermissionSync[]                     = L"VerifyPermissionSync";
#ifndef __WMPNotifySubscriptionPluginAddRemove
#define __WMPNotifySubscriptionPluginAddRemove
__inline BOOL WMPNotifySubscriptionPluginAddRemove()
{
    BOOL fRet = FALSE;
    UINT  msg = RegisterWindowMessageA( "WMPlayer_PluginAddRemove" );
    if( 0 != msg ) 
     {
        fRet = PostMessage( HWND_BROADCAST, msg, 1, 0 );
     }
     return fRet;
}
#endif
typedef /* [public] */ 
enum WMPPartnerNotification
    {	wmpsnBackgroundProcessingBegin	= 1,
	wmpsnBackgroundProcessingEnd	= 2,
	wmpsnCatalogDownloadFailure	= 3,
	wmpsnCatalogDownloadComplete	= 4
    } 	WMPPartnerNotification;


///////////////////////////////////////////////////////////////////////////////////////////////////////////////////

// The WMPCallbackNotification enum values are passed to the IWMPContentPartner::Notify API

// Synopsis - IWMPContentPartnerCallback::Notify( wmpcnLoginStateChange 
//                                           /*input*/ VARIANT *pContext, type must be VT_BOOL or VT_UI4
// Remarks: indicates a new login state. VT_BOOL indicates a normal success or failure, while setting the type to VT_UI4 indicates
// a special condition (expired or canceled account, etc) in which case the player will query the plugin via
// GetItemInfo( g_szItemInfo_LoginFailureURL, <VT_UI4 value returned with wmpcnLoginStateChange>, <VARIANT * to receive the URL as VT_BSTR> )

// Synopsis - IWMPContentPartnerCallback::Notify( wmpcnAuthResult 
//                                           /*input*/ VARIANT *pContext, type must be VT_BOOL
// Remarks: indicates a successful auth

// Synopsis - IWMPContentPartnerCallback::Notify( wmpcnLicenseUpdated 
//                                           /*input*/ VARIANT *pContext, type must be VT_UI4
// Remarks: represents the content ID whose license has been update

// Synopsis - IWMPContentPartnerCallback::Notify( wmpcnNewCatalogAvailable 
//                                           /*input*/ VARIANT *pContext, type must be VT_EMPTY
// Remarks: Instructs the player to download a new catalog

// Synopsis - IWMPContentPartnerCallback::CallbackNotify( wmpcnNewPluginAvailable 
//                                           /*input*/ VARIANT *pContext, type must be VT_BOOL
// Remarks: Instructs the player to download a new plugin, if pContext is VARIANT_TRUE, this indicates
//          that an upgrade is required

// Synopsis - IWMPContentPartnerCallback::CallbackNotify( wmpcnDisableRadioSkipping 
//                                           /*input*/ VARIANT *pContext, type must be VT_EMPTY
// Remarks: Instructs the player to not allow any skipping of items in a radio playlist
typedef /* [public] */ 
enum WMPCallbackNotification
    {	wmpcnLoginStateChange	= 1,
	wmpcnAuthResult	= 2,
	wmpcnLicenseUpdated	= 3,
	wmpcnNewCatalogAvailable	= 4,
	wmpcnNewPluginAvailable	= 5,
	wmpcnDisableRadioSkipping	= 6
    } 	WMPCallbackNotification;


///////////////////////////////////////////////////////////////////////////////////////////////////////////////////

// The WMPTaskType enum values are passed to the IWMPContentPartner::GetTemplate API

// Synopsis - IWMPContentPartner::GetTemplate( wmpttBrowse 
// Remarks: Indicates that the player is in the Library task

// Synopsis - IWMPContentPartner::GetTemplate( wmpttSync 
// Remarks: Indicates that the player is in the Sync task

// Synopsis - IWMPContentPartner::GetTemplate( wmpttBurn 
// Remarks: Indicates that the player is in the Burn task

// Synopsis - IWMPContentPartner::GetTemplate( wmpttCurrent 
// Remarks: Indicates that the player is in something other than the Library, Sync or Burn task

typedef /* [public] */ 
enum WMPTaskType
    {	wmpttBrowse	= 1,
	wmpttSync	= 2,
	wmpttBurn	= 3,
	wmpttCurrent	= 4
    } 	WMPTaskType;


///////////////////////////////////////////////////////////////////////////////////////////////////////////////////

// The WMPContextMenuInfo is returned from the IWMPContentPartner::GetCommands API

// Synopsis - struct WMPContextMenuInfo

// Member - dwID -> Indicates the value for the command from the plugin. A value of zero will
//                  cause the media player to insert a separator in the context menu

// Member - bstrMenuText -> Indicates the text that will be show in the context menu

// Member - bstrHelpText -> Indicates help text that could be shown when the user is
//                           highlighting this menu option

typedef /* [public] */ struct WMPContextMenuInfo
    {
    DWORD dwID;
    BSTR bstrMenuText;
    BSTR bstrHelpText;
    } 	WMPContextMenuInfo;


///////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// These constants are to be used in the IWMPContentPartner::StationEvent

static const WCHAR g_szStationEvent_Started[]                          = L"TrackStarted";  
static const WCHAR g_szStationEvent_Complete[]                         = L"TrackComplete"; 
static const WCHAR g_szStationEvent_Skipped[]                          = L"TrackSkipped";  


extern RPC_IF_HANDLE __MIDL_itf_contentpartner_0000_0000_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_contentpartner_0000_0000_v0_0_s_ifspec;

#ifndef __IWMPContentContainer_INTERFACE_DEFINED__
#define __IWMPContentContainer_INTERFACE_DEFINED__

/* interface IWMPContentContainer */
/* [unique][uuid][object] */ 


// Synopsis - GetID-> This function returns the ID for this container


// Synopsis - GetPrice-> This function returns the price for this container


// Synopsis - GetType -> This returns the type of this container. Can return g_szCPAlbumID, g_szCPListID, or g_szUnknownLocation


// Synopsis - GetContentCount -> Returns the content count held in this container.


// Synopsis - GetContentPrice -> Returns the price for a piece of content.
//               /*input*/ idxContent -> index of content to get price for. Should be less than value returned by GetContentCount
//               /*output*/ pbstrPrice -> string content the price or g_szContentPrice_Unknown, g_szContentPrice_Free, or g_szContentPrice_CannotBuy


// Synopsis - GetContentID-> Returns the identifier for a piece of content.
//               /*input*/ idxContent -> index of content to indentifier for. Should be less than value returned by GetContentCount
//               /*output*/ pContentID -> indentifier of the content


EXTERN_C const IID IID_IWMPContentContainer;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("ad7f4d9c-1a9f-4ed2-9815-ecc0b58cb616")
    IWMPContentContainer : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE GetID( 
            /* [out] */ __RPC__out ULONG *pContentID) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetPrice( 
            /* [out] */ __RPC__deref_out_opt BSTR *pbstrPrice) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetType( 
            /* [out] */ __RPC__deref_out_opt BSTR *pbstrType) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetContentCount( 
            /* [out] */ __RPC__out ULONG *pcContent) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetContentPrice( 
            /* [in] */ ULONG idxContent,
            /* [out] */ __RPC__deref_out_opt BSTR *pbstrPrice) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetContentID( 
            /* [in] */ ULONG idxContent,
            /* [out] */ __RPC__out ULONG *pContentID) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IWMPContentContainerVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IWMPContentContainer * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IWMPContentContainer * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IWMPContentContainer * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetID )( 
            IWMPContentContainer * This,
            /* [out] */ __RPC__out ULONG *pContentID);
        
        HRESULT ( STDMETHODCALLTYPE *GetPrice )( 
            IWMPContentContainer * This,
            /* [out] */ __RPC__deref_out_opt BSTR *pbstrPrice);
        
        HRESULT ( STDMETHODCALLTYPE *GetType )( 
            IWMPContentContainer * This,
            /* [out] */ __RPC__deref_out_opt BSTR *pbstrType);
        
        HRESULT ( STDMETHODCALLTYPE *GetContentCount )( 
            IWMPContentContainer * This,
            /* [out] */ __RPC__out ULONG *pcContent);
        
        HRESULT ( STDMETHODCALLTYPE *GetContentPrice )( 
            IWMPContentContainer * This,
            /* [in] */ ULONG idxContent,
            /* [out] */ __RPC__deref_out_opt BSTR *pbstrPrice);
        
        HRESULT ( STDMETHODCALLTYPE *GetContentID )( 
            IWMPContentContainer * This,
            /* [in] */ ULONG idxContent,
            /* [out] */ __RPC__out ULONG *pContentID);
        
        END_INTERFACE
    } IWMPContentContainerVtbl;

    interface IWMPContentContainer
    {
        CONST_VTBL struct IWMPContentContainerVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IWMPContentContainer_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IWMPContentContainer_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IWMPContentContainer_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IWMPContentContainer_GetID(This,pContentID)	\
    ( (This)->lpVtbl -> GetID(This,pContentID) ) 

#define IWMPContentContainer_GetPrice(This,pbstrPrice)	\
    ( (This)->lpVtbl -> GetPrice(This,pbstrPrice) ) 

#define IWMPContentContainer_GetType(This,pbstrType)	\
    ( (This)->lpVtbl -> GetType(This,pbstrType) ) 

#define IWMPContentContainer_GetContentCount(This,pcContent)	\
    ( (This)->lpVtbl -> GetContentCount(This,pcContent) ) 

#define IWMPContentContainer_GetContentPrice(This,idxContent,pbstrPrice)	\
    ( (This)->lpVtbl -> GetContentPrice(This,idxContent,pbstrPrice) ) 

#define IWMPContentContainer_GetContentID(This,idxContent,pContentID)	\
    ( (This)->lpVtbl -> GetContentID(This,idxContent,pContentID) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IWMPContentContainer_INTERFACE_DEFINED__ */


/* interface __MIDL_itf_contentpartner_0000_0001 */
/* [local] */ 


///////////////////////////////////////////////////////////////////////////////////////////////////////////////////

// The WMPTransactionType enum values are passed to the IWMPContentContainerList::GetTransactionType API

// Synopsis - wmpttNoTransaction
// Remarks: Undefined transaction, not currently used

// Synopsis - wmpttDownload
// Remarks: Indicates that this IWMPContentContainerList is to be used for a download transaction

// Synopsis - wmpttBuy
// Remarks: Indicates that this IWMPContentContainerList is to be used for a buy transaction

typedef /* [public] */ 
enum WMPTransactionType
    {	wmpttNoTransaction	= 0,
	wmpttDownload	= 1,
	wmpttBuy	= 2
    } 	WMPTransactionType;



extern RPC_IF_HANDLE __MIDL_itf_contentpartner_0000_0001_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_contentpartner_0000_0001_v0_0_s_ifspec;

#ifndef __IWMPContentContainerList_INTERFACE_DEFINED__
#define __IWMPContentContainerList_INTERFACE_DEFINED__

/* interface IWMPContentContainerList */
/* [unique][uuid][object] */ 


// Synopsis - GetTransactionType-> Returns the transaction type.
//               /*output*/ WMPTransactionType *pwmptt -> indicates whether this IWMPContentContainerList will be used to a buy or download


// Synopsis - GetContainerCount-> Returns the number of IWMPContentContainer(s) present in this container list.
//               /*output*/ ULONG *pcContainer -> returns the number of containers


// Synopsis - GetContainer-> Returns the IWMPContentContainer given an index.
//               /*input*/ ULONG idxContainer -> the index of the desired container, should be less than the number returned
//                                               by IWMPContentContainerList::GetContainerCount
//               /*output*/ IWMPContentContainer **ppContent -> will containe the requested IWMPContentContainer on success


EXTERN_C const IID IID_IWMPContentContainerList;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("a9937f78-0802-4af8-8b8d-e3f045bc8ab5")
    IWMPContentContainerList : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE GetTransactionType( 
            /* [out] */ __RPC__out WMPTransactionType *pwmptt) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetContainerCount( 
            /* [out] */ __RPC__out ULONG *pcContainer) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetContainer( 
            /* [in] */ ULONG idxContainer,
            /* [out] */ __RPC__deref_out_opt IWMPContentContainer **ppContent) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IWMPContentContainerListVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IWMPContentContainerList * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IWMPContentContainerList * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IWMPContentContainerList * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetTransactionType )( 
            IWMPContentContainerList * This,
            /* [out] */ __RPC__out WMPTransactionType *pwmptt);
        
        HRESULT ( STDMETHODCALLTYPE *GetContainerCount )( 
            IWMPContentContainerList * This,
            /* [out] */ __RPC__out ULONG *pcContainer);
        
        HRESULT ( STDMETHODCALLTYPE *GetContainer )( 
            IWMPContentContainerList * This,
            /* [in] */ ULONG idxContainer,
            /* [out] */ __RPC__deref_out_opt IWMPContentContainer **ppContent);
        
        END_INTERFACE
    } IWMPContentContainerListVtbl;

    interface IWMPContentContainerList
    {
        CONST_VTBL struct IWMPContentContainerListVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IWMPContentContainerList_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IWMPContentContainerList_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IWMPContentContainerList_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IWMPContentContainerList_GetTransactionType(This,pwmptt)	\
    ( (This)->lpVtbl -> GetTransactionType(This,pwmptt) ) 

#define IWMPContentContainerList_GetContainerCount(This,pcContainer)	\
    ( (This)->lpVtbl -> GetContainerCount(This,pcContainer) ) 

#define IWMPContentContainerList_GetContainer(This,idxContainer,ppContent)	\
    ( (This)->lpVtbl -> GetContainer(This,idxContainer,ppContent) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IWMPContentContainerList_INTERFACE_DEFINED__ */


/* interface __MIDL_itf_contentpartner_0000_0002 */
/* [local] */ 


///////////////////////////////////////////////////////////////////////////////////////////////////////////////////

// The WMPTemplateSize enum values are returned from the IWMPContentPartner::GetTemplate API

// Synopsis - wmptsSmall
// Remarks: indicates the media player will allocate 100 pixels in height for the template

// Synopsis - wmptsMedium
// Remarks: indicates the media player will allocate 250 pixels in height for the template

// Synopsis - wmptsLarge
// Remarks: indicates the media player will allocate all of the room expect for the necessary space
//          for the list-control to display a small set of items for the template

typedef /* [public] */ 
enum WMPTemplateSize
    {	wmptsSmall	= 0,
	wmptsMedium	= ( wmptsSmall + 1 ) ,
	wmptsLarge	= ( wmptsMedium + 1 ) 
    } 	WMPTemplateSize;


///////////////////////////////////////////////////////////////////////////////////////////////////////////////////

// The WMPStreamingType enum values are passed to the returned from the IWMPContentPartner::GetStreamingULR API

// Synopsis - wmpstMusic
// Remarks: indicates the plugin should return an URL for music content

// Synopsis - wmpstVideo
// Remarks: indicates the plugin should return an URL for video content

// Synopsis - wmpstRadio
// Remarks: indicates the plugin should return an URL for radio content

typedef /* [public] */ 
enum WMPStreamingType
    {	wmpstUnknown	= 0,
	wmpstMusic	= 1,
	wmpstVideo	= 2,
	wmpstRadio	= 3
    } 	WMPStreamingType;


///////////////////////////////////////////////////////////////////////////////////////////////////////////////////

// The WMPAccountType enum values are returned from the IWMPContentPartner::GetPartnerInfo when API
// the string is g_szContentPartnerInfo_MediaPlayerAccountType passed

// Synopsis - wmpatBuyOnly
// Remarks: indicates the user only has the option to buy content

// Synopsis - wmpatSubscription
// Remarks: indicates the user has a subcription account, which indicates buy is also required for sync to Janus device

// Synopsis - wmpatJanus
// Remarks: indicates the user has a subcirption account, and the ability to sync to Janus devices without having to buy

typedef /* [public] */ 
enum WMPAccountType
    {	wmpatBuyOnly	= 1,
	wmpatSubscription	= 2,
	wmpatJanus	= 3
    } 	WMPAccountType;



extern RPC_IF_HANDLE __MIDL_itf_contentpartner_0000_0002_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_contentpartner_0000_0002_v0_0_s_ifspec;

#ifndef __IWMPContentPartnerCallback_INTERFACE_DEFINED__
#define __IWMPContentPartnerCallback_INTERFACE_DEFINED__

/* interface IWMPContentPartnerCallback */
/* [unique][helpstring][uuid][object] */ 


// Synopsis - Notify-> This function is called to notify the media player of plugin events
//            /*input*/  WMPCallbackNotification type - Event that the plugin is notifying the player of
//            /*input*/  VARIANT * pContext - The context depends on the notification being sent. See
//                           remakrs for WMPCallbackNotification


// Synopsis - BuyComplete -> This function is called to notify the media player of that a purchase has completed
//            /*input*/  HRESULT hrResult - The success or error code of the purchase operation.
//            /*input*/  DWORD dwBuyCookie - The cookie passed to IWMPContentPartner::Buy.

// Remarks: This method should ONLY be called on SUCCESS AFTER all licenses have been delivered.

// Synopsis - DownloadTrack -> This function is called in response to a IWMPContentPartner::Download
//            /*input*/  DWORD dwCookie - The cookie passed to IWMPContentPartner::Download.
//            /*input*/  BSTR bstrTrackURL - The URL to download.
//            /*input*/  DWORD dwServiceTrackID - The content identifier of the content to download.
//            /*input*/  BSTR bstrDownloadParams - A string containing data to be passed to
//                                    IWMPContentPartnerCallback::DownloadTrackComplete.
//            /*input*/  HRESULT hrDownload - The success or error code of download operation.

// Remarks: This method should ONLY be called on SUCCESS AFTER all licenses have been delivered.
// Remarks: The tracks will NOT be download if hrDownload is not a success code.

// Synopsis - GetCatalogVersion -> This function is called to retrieve the current catalog version.
//            /*output*/  DWORD *pdwVersion- The major version of the catalog being used.
//            /*output*/  DWORD *pdwSchemaVersion - The schema of the catalog being used.
//            /*output*/  LCID *plcid- The language of the catalog being used.


// Synopsis - UpdateDeviceComplete -> This function is called to indicate that IWMPContentPartner::UpdateDevice has completed.
//            /*input*/  BSTR bstrDeviceName - The device name passed to IWMPContentPartner::UpdateDevice.


// Synopsis - ChangeView-> This function is called to navigate the media player UI
//            /*input*/  BSTR bstrType - a content partner string ID such as g_szCPArtistID, or g_szOnlineStore
//            /*input*/  BSTR bstrID -   The identifier to navigate to
//            /*input*/  BSTR bstrFilter - A filter to place in the 'word wheel' after navigating

// Remarks: When using g_szOnlineStore for bstrType, the bstrID ss a full URL to navigate the browser to
// Remarks: Use 'Back' or 'Forward' in bstrType to simulate pressing the applications back and forward navigation buttons
// Remarks: Use g_szRootLocation in bstrType to navigate to the service's root node in the libary UI


// Synopsis - AddListContents-> This function is called to add content identifiers to a list as a rsult of the 
//                               IWMPContentPartner::GetListContents API being called
//            /*input*/  DWORD dwListCookie - Cookie sent during IWMPContentParnter::GetListContents
//            /*input*/  DWORD cItems - The number of content identifiers being passed in the prgItems parameter
//            /*input*/  DWORD *prgItems - An array of content identifiers


// Synopsis - ListContentsComplete-> This function is called to indicate that the plugin has completed a IWMPContentPartner::GetListContents call
//            /*input*/  DWORD dwListCookie - Cookie sent during IWMPContentParnter::GetListContents 
//            /*input*/  HRESULT hrSuccess - The success or error code of the GetListContents operation


// Synopsis - SendMessageComplete-> This function is called to indicate that the plugin has completed a IWMPContentPartner::SendMessage call
//            /*input*/  BSTR bstrMsg - Message text sent in IWMPContentPartner::SendMessage
//            /*input*/  BSTR bstrParam - Parameter text sent in IWMPContentPartner::SendMessage
//            /*input*/  BSTR bstrResult - Result text


// Synopsis - GetContentIDsInLibrary-> This function is called to retrieve the content identifiers that are in the users
//                                     library that have been purchased or downloaded.
//            /*output*/  ULONG pcContentIDs - The number of content identifiers returned.
//            /*output*/  ULONG **pprgIDs    - An array of ULONGs containing the content identifiers. Free this array with CoTaskMemFree.


// Synopsis - RefreshLicenseComplete -> This function is called to indicate that a license refresh call has completed
//            /*input*/   DWORD dwCookie - This should be the same cookie passed to IWMPContentPartner::RefreshLicense.
//            /*input*/   ULOING contentID - This should be the same content identifier passed to IWMPContentPartner::RefreshLicense.
//            /*input*/   HRESULT hrRefresh - The success or error code of the refresh operation.


// Synopsis - ShowPopup -> This function is called to have the player show a popup dialog. Usually this happens 
//                          as a result of IWMPContentPartner::InvokeCommand being called.
//            /*input*/   long lIndex - The URL index to request from the IWMPContentPartner::GetItemInfo( g_szItemInfo_PopupURL, ... ) API.
//            /*input*/   BSTR bstrParameters - The parameters that are concatenated onto the URL returned by IWMPContentPartner::GetItemInfo( g_szItemInfo_PopupURL, ... ) API


// Synopsis - VerifyPermission-> This function is called to indicate that permission verification is complete
//            /*input*/ BSTR bstrPermission - Indicates action for which permission was requested.
//            /*input*/   VARIANT * pContext - If sync, this is the canonical name of the device. This is the same thing that was passed in as pContext in VerifyPermission.
//            /*input*/   HRESULT hrPermission - Result of permission verification.


EXTERN_C const IID IID_IWMPContentPartnerCallback;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("9E8F7DA2-0695-403c-B697-DA10FAFAA676")
    IWMPContentPartnerCallback : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE Notify( 
            /* [in] */ WMPCallbackNotification type,
            /* [in] */ __RPC__in VARIANT *pContext) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE BuyComplete( 
            /* [in] */ HRESULT hrResult,
            /* [in] */ DWORD dwBuyCookie) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE DownloadTrack( 
            /* [in] */ DWORD cookie,
            /* [in] */ __RPC__in BSTR bstrTrackURL,
            /* [in] */ DWORD dwServiceTrackID,
            /* [in] */ __RPC__in BSTR bstrDownloadParams,
            /* [in] */ HRESULT hrDownload) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetCatalogVersion( 
            /* [out] */ __RPC__out DWORD *pdwVersion,
            /* [out] */ __RPC__out DWORD *pdwSchemaVersion,
            /* [out] */ __RPC__out LCID *plcid) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE UpdateDeviceComplete( 
            /* [in] */ __RPC__in BSTR bstrDeviceName) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE ChangeView( 
            /* [in] */ __RPC__in BSTR bstrType,
            /* [in] */ __RPC__in BSTR bstrID,
            /* [in] */ __RPC__in BSTR bstrFilter) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE AddListContents( 
            /* [in] */ DWORD dwListCookie,
            /* [in] */ DWORD cItems,
            /* [size_is][in] */ __RPC__in_ecount_full(cItems) DWORD *prgItems) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE ListContentsComplete( 
            /* [in] */ DWORD dwListCookie,
            /* [in] */ HRESULT hrSuccess) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SendMessageComplete( 
            /* [in] */ __RPC__in BSTR bstrMsg,
            /* [in] */ __RPC__in BSTR bstrParam,
            /* [in] */ __RPC__in BSTR bstrResult) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetContentIDsInLibrary( 
            /* [out] */ __RPC__out ULONG *pcContentIDs,
            /* [size_is][size_is][out] */ __RPC__deref_out_ecount_full_opt(*pcContentIDs) ULONG **pprgIDs) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE RefreshLicenseComplete( 
            /* [in] */ DWORD dwCookie,
            /* [in] */ ULONG contentID,
            /* [in] */ HRESULT hrRefresh) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE ShowPopup( 
            /* [in] */ long lIndex,
            /* [in] */ __RPC__in BSTR bstrParameters) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE VerifyPermissionComplete( 
            /* [in] */ __RPC__in BSTR bstrPermission,
            /* [in] */ __RPC__in VARIANT *pContext,
            /* [in] */ HRESULT hrPermission) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IWMPContentPartnerCallbackVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IWMPContentPartnerCallback * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IWMPContentPartnerCallback * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IWMPContentPartnerCallback * This);
        
        HRESULT ( STDMETHODCALLTYPE *Notify )( 
            IWMPContentPartnerCallback * This,
            /* [in] */ WMPCallbackNotification type,
            /* [in] */ __RPC__in VARIANT *pContext);
        
        HRESULT ( STDMETHODCALLTYPE *BuyComplete )( 
            IWMPContentPartnerCallback * This,
            /* [in] */ HRESULT hrResult,
            /* [in] */ DWORD dwBuyCookie);
        
        HRESULT ( STDMETHODCALLTYPE *DownloadTrack )( 
            IWMPContentPartnerCallback * This,
            /* [in] */ DWORD cookie,
            /* [in] */ __RPC__in BSTR bstrTrackURL,
            /* [in] */ DWORD dwServiceTrackID,
            /* [in] */ __RPC__in BSTR bstrDownloadParams,
            /* [in] */ HRESULT hrDownload);
        
        HRESULT ( STDMETHODCALLTYPE *GetCatalogVersion )( 
            IWMPContentPartnerCallback * This,
            /* [out] */ __RPC__out DWORD *pdwVersion,
            /* [out] */ __RPC__out DWORD *pdwSchemaVersion,
            /* [out] */ __RPC__out LCID *plcid);
        
        HRESULT ( STDMETHODCALLTYPE *UpdateDeviceComplete )( 
            IWMPContentPartnerCallback * This,
            /* [in] */ __RPC__in BSTR bstrDeviceName);
        
        HRESULT ( STDMETHODCALLTYPE *ChangeView )( 
            IWMPContentPartnerCallback * This,
            /* [in] */ __RPC__in BSTR bstrType,
            /* [in] */ __RPC__in BSTR bstrID,
            /* [in] */ __RPC__in BSTR bstrFilter);
        
        HRESULT ( STDMETHODCALLTYPE *AddListContents )( 
            IWMPContentPartnerCallback * This,
            /* [in] */ DWORD dwListCookie,
            /* [in] */ DWORD cItems,
            /* [size_is][in] */ __RPC__in_ecount_full(cItems) DWORD *prgItems);
        
        HRESULT ( STDMETHODCALLTYPE *ListContentsComplete )( 
            IWMPContentPartnerCallback * This,
            /* [in] */ DWORD dwListCookie,
            /* [in] */ HRESULT hrSuccess);
        
        HRESULT ( STDMETHODCALLTYPE *SendMessageComplete )( 
            IWMPContentPartnerCallback * This,
            /* [in] */ __RPC__in BSTR bstrMsg,
            /* [in] */ __RPC__in BSTR bstrParam,
            /* [in] */ __RPC__in BSTR bstrResult);
        
        HRESULT ( STDMETHODCALLTYPE *GetContentIDsInLibrary )( 
            IWMPContentPartnerCallback * This,
            /* [out] */ __RPC__out ULONG *pcContentIDs,
            /* [size_is][size_is][out] */ __RPC__deref_out_ecount_full_opt(*pcContentIDs) ULONG **pprgIDs);
        
        HRESULT ( STDMETHODCALLTYPE *RefreshLicenseComplete )( 
            IWMPContentPartnerCallback * This,
            /* [in] */ DWORD dwCookie,
            /* [in] */ ULONG contentID,
            /* [in] */ HRESULT hrRefresh);
        
        HRESULT ( STDMETHODCALLTYPE *ShowPopup )( 
            IWMPContentPartnerCallback * This,
            /* [in] */ long lIndex,
            /* [in] */ __RPC__in BSTR bstrParameters);
        
        HRESULT ( STDMETHODCALLTYPE *VerifyPermissionComplete )( 
            IWMPContentPartnerCallback * This,
            /* [in] */ __RPC__in BSTR bstrPermission,
            /* [in] */ __RPC__in VARIANT *pContext,
            /* [in] */ HRESULT hrPermission);
        
        END_INTERFACE
    } IWMPContentPartnerCallbackVtbl;

    interface IWMPContentPartnerCallback
    {
        CONST_VTBL struct IWMPContentPartnerCallbackVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IWMPContentPartnerCallback_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IWMPContentPartnerCallback_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IWMPContentPartnerCallback_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IWMPContentPartnerCallback_Notify(This,type,pContext)	\
    ( (This)->lpVtbl -> Notify(This,type,pContext) ) 

#define IWMPContentPartnerCallback_BuyComplete(This,hrResult,dwBuyCookie)	\
    ( (This)->lpVtbl -> BuyComplete(This,hrResult,dwBuyCookie) ) 

#define IWMPContentPartnerCallback_DownloadTrack(This,cookie,bstrTrackURL,dwServiceTrackID,bstrDownloadParams,hrDownload)	\
    ( (This)->lpVtbl -> DownloadTrack(This,cookie,bstrTrackURL,dwServiceTrackID,bstrDownloadParams,hrDownload) ) 

#define IWMPContentPartnerCallback_GetCatalogVersion(This,pdwVersion,pdwSchemaVersion,plcid)	\
    ( (This)->lpVtbl -> GetCatalogVersion(This,pdwVersion,pdwSchemaVersion,plcid) ) 

#define IWMPContentPartnerCallback_UpdateDeviceComplete(This,bstrDeviceName)	\
    ( (This)->lpVtbl -> UpdateDeviceComplete(This,bstrDeviceName) ) 

#define IWMPContentPartnerCallback_ChangeView(This,bstrType,bstrID,bstrFilter)	\
    ( (This)->lpVtbl -> ChangeView(This,bstrType,bstrID,bstrFilter) ) 

#define IWMPContentPartnerCallback_AddListContents(This,dwListCookie,cItems,prgItems)	\
    ( (This)->lpVtbl -> AddListContents(This,dwListCookie,cItems,prgItems) ) 

#define IWMPContentPartnerCallback_ListContentsComplete(This,dwListCookie,hrSuccess)	\
    ( (This)->lpVtbl -> ListContentsComplete(This,dwListCookie,hrSuccess) ) 

#define IWMPContentPartnerCallback_SendMessageComplete(This,bstrMsg,bstrParam,bstrResult)	\
    ( (This)->lpVtbl -> SendMessageComplete(This,bstrMsg,bstrParam,bstrResult) ) 

#define IWMPContentPartnerCallback_GetContentIDsInLibrary(This,pcContentIDs,pprgIDs)	\
    ( (This)->lpVtbl -> GetContentIDsInLibrary(This,pcContentIDs,pprgIDs) ) 

#define IWMPContentPartnerCallback_RefreshLicenseComplete(This,dwCookie,contentID,hrRefresh)	\
    ( (This)->lpVtbl -> RefreshLicenseComplete(This,dwCookie,contentID,hrRefresh) ) 

#define IWMPContentPartnerCallback_ShowPopup(This,lIndex,bstrParameters)	\
    ( (This)->lpVtbl -> ShowPopup(This,lIndex,bstrParameters) ) 

#define IWMPContentPartnerCallback_VerifyPermissionComplete(This,bstrPermission,pContext,hrPermission)	\
    ( (This)->lpVtbl -> VerifyPermissionComplete(This,bstrPermission,pContext,hrPermission) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IWMPContentPartnerCallback_INTERFACE_DEFINED__ */


#ifndef __IWMPContentPartner_INTERFACE_DEFINED__
#define __IWMPContentPartner_INTERFACE_DEFINED__

/* interface IWMPContentPartner */
/* [unique][helpstring][uuid][object] */ 


// Synopsis - SetCallback-> This function allows gives the pugin the ability to store a callback pointer
//                          that will be necessary to communicate with the player
//             /*input*/ pCallback -> interface pointer to the media player's implementation of the IWMPContentPartnerCallback
//
// Remarks: The player will call this with a null value during its shutdown process. The plugin can use


// Synopsis - Notify-> This function is called by the player to notify the plugin of certain events
//            /*input*/ WMPPartnerNotification type - see comments for WMPPartnerNotification enum
//            /*input*/ VARIANT *pContext - see comments for WMPPartnerNotification enum


// Synopsis - GetItemInfo-> This function is called to retrieve different properties about content
//            /*input*/ VARIANT *pContext - see comments above for the strings passed into this API
//            /*out*/   VARIANT *pData - see comments abouve for the strings passed into this API


// Synopsis - GetContentPartnerInfo-> This function is called to retrieve different properties about the content partner
//            /*input*/ BSTR bstrInfoName - see comments above for the strings passed into this API 
//            /*out*/   VARIANT *pData - see comments above for the strings passed into this API


// Synopsis - GetCommands-> This function allows the plugin to return commands to be displayed in context menus
//             /*input*/  BSTR location -> location in the library (such as g_szCPArtistID)
//             /*input*/  VARIANT *pLocationContext -> location in the library (such as VT_UI4, 1231231)
//             /*input*/  BSTR itemLocation -> item type selected in library (such as g_szCPTrackID)
//             /*input*/  ULONG cItemIDs -> the number of selected items of type itemLocation
//             /*input*/  ULONG prgItemIDs -> the array of content identifiers
//             /*output*/ ULONG *pcItemIDs -> the number of context menu commands returned in pprgItems
//             /*output*/ WMPContextMenuInfo **pprgItems -> Array of WMPContenxtMenuInfo items allocated by CoTaskMemAlloc

//             Remarks: See comments for WMPContextMenuInfo for more information


// Synopsis - InvokeCommand-> This function is called when the user selects an option fro a context menu command
//                            returned by IWMPContentPartner::GetCommands
//             /*input*/  DWORD dwCommandID -> Command ID from the select WMPContextMenuInfo
//             /*input*/  The remaining parameters are the same as those passed to IWMPContentPartner::GetCommands

//             Remarks: See comments for WMPContextMenuInfo and IWMPContentPartner::GetCommands for more information


// Synopsis - GetCatalogURL -> This function is called by the player to retrieve the streaming URL
//             /*input*/  WMPStreamingType -> indicates whether the streaming type is for radio\music\video
//             /*input*/  VARIANT *pStreamContext -> VT_UI4, contains the content identifier
//             /*ouptut*/ BSTR *pbstrURL-> recieves the streaming URL of the content

//             Remarks: The streaming URL for Radio and Video must be contained in an ASX


// Synopsis - GetCatalogURL -> This function is called by the player to retrieve the catalog download URL
//             /*input*/  DWORD dwCatalogVersion -> current catalog version, or zero if none exists
//             /*input*/  DWORD dwCatalogSchemaVesrion -> current catalog schema
//             /*input*/  LCID catalogLCID -> current catalog version
//             /*output*/ DWORD *pdwNewCatalogVersion -> version of catalog that URL represents
//             /*ouptut*/ BSTR *pbstrCatalogURL-> recieves URL that the player will use to download catalog
//             /*output*/ VARIANT *pExpirationData-> Must be of type VT_DATE. This is the date at which the player will
//                           will call IWMPContentPartner::GetCatalogURL to retrieve a new catalog.


// Synopsis - UpdateDevice -> This function is called during sync to allow the plugin to do device updates.
//             /*input*/ BSTR bstrDeviceName-> name of device to update
//
// Remarks: This call should function asynchronously. Call IWMPContentPartnerCallback::UpdateDeviceComplete when finsihed.


// Synopsis - Login-> This function indicates to the plugin to begin logging in to the service
//             /*input*/ BLOB userInfo, an encrypted blob containing the user's login name
//             /*input*/ BLOB pwdInfo,  an encrypted blob containing the user's login password
//             /*input*/ VARIANT_BOOL fUsedCachedCreds, indicates to the plugin to attempt to use cached credentials
//                                                       for login if present.
//             /*input*/ VARIANT_BOOL fOkToCache, indicates that it is acceptable for the plugin to cache
//                                                 the users credential.
//
// Remarks: The plugin is responsible for calling IWMPContentPartner::Notify to indicate login state change
//
// Remarks: To unencrypt the user and password name, use 
//   CryptUnprotectData( blob, NULL, NULL, NULL, NULL, CRYPTPROTECT_UI_FORBIDDEN, &outBlob)


// Synopsis - Authenticate-> This function indicates to the plugin to Authenticate the credentials with the service
//             /*input*/ BLOB userInfo, an encrypted blob containing the user's login name
//             /*input*/ BLOB pwdInfo,  an encrypted blob containing the user's login password
//
// Remarks: To unencrypt the user and password name, use 
//   CryptUnprotectData( blob, NULL, NULL, NULL, NULL, CRYPTPROTECT_UI_FORBIDDEN, &outBlob)


// Synopsis - Logout-> This function indicates to the plugin to begin logging out from the service
// 
// Remarks: The plugin is responsible for calling IWMPContentPartner::Notify to indicate login state change
//
// Remarks: The plugin should delete any cached credentials when this API is called


// Synopsis - SendMessage -> This function allows HTML templates returned from IWMPContentPartner::GetTemplate
//                          to communicate to the plugin
//             /*input*/ bstrMsg -> value send directly from the template returned by IWMPContentPartner::GetTemplate
//                               -> via the window.external.sendMessage API
//             /*input*/ bstrParam -> parameter for the message, also sent from the window.external.sendMessage API
//
//Remarks: The plugin is reponsible for calling IWMPContentPartnerCallback::OnSendMessageComplete in order for
//         the HTML template to know that processing of the message occurs. This will be sent to the template
//         via the window.external.OnSendMessageComplete notificaiton


// Synopsis - CompareContainerListPrices-> This function is called to preform a comparison operation on tow IWMPContentContainerLists
//            /*input*/   IWMPContentContainerList *pListBase - 
//            /*input*/   IWMPContentContainerList *pListCompare - 
//            /*output*/  long *pResult* - Return less than 0 when pListBase is less than pListCompare, 0 for equal, and greather than 0 when pListBase is more than pListCompare


// Synopsis - VerifyPermission-> This function is called to get permission to perform an action
//            /*input*/ BSTR bstrPermission - Indicates action for which permission is requested
//            /*input*/   VARIANT * pContext - If sync, this is the canonical name of the device. This needs to be returned in VerifyPermissionComplete.


EXTERN_C const IID IID_IWMPContentPartner;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("55455073-41B5-4e75-87B8-F13BDB291D08")
    IWMPContentPartner : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE SetCallback( 
            /* [in] */ __RPC__in_opt IWMPContentPartnerCallback *pCallback) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Notify( 
            /* [in] */ WMPPartnerNotification type,
            /* [in] */ __RPC__in VARIANT *pContext) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetItemInfo( 
            /* [in] */ __RPC__in BSTR bstrInfoName,
            /* [in] */ __RPC__in VARIANT *pContext,
            /* [out] */ __RPC__out VARIANT *pData) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetContentPartnerInfo( 
            /* [in] */ __RPC__in BSTR bstrInfoName,
            /* [out] */ __RPC__out VARIANT *pData) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetCommands( 
            /* [in] */ __RPC__in BSTR location,
            /* [in] */ __RPC__in VARIANT *pLocationContext,
            /* [in] */ __RPC__in BSTR itemLocation,
            /* [in] */ ULONG cItemIDs,
            /* [size_is][in] */ __RPC__in_ecount_full(cItemIDs) ULONG *prgItemIDs,
            /* [out] */ __RPC__out ULONG *pcItemIDs,
            /* [size_is][size_is][out] */ __RPC__deref_out_ecount_full_opt(*pcItemIDs) WMPContextMenuInfo **pprgItems) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE InvokeCommand( 
            /* [in] */ DWORD dwCommandID,
            /* [in] */ __RPC__in BSTR location,
            /* [in] */ __RPC__in VARIANT *pLocationContext,
            /* [in] */ __RPC__in BSTR itemLocation,
            /* [in] */ ULONG cItemIDs,
            /* [size_is][in] */ __RPC__in_ecount_full(cItemIDs) ULONG *rgItemIDs) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE CanBuySilent( 
            /* [in] */ __RPC__in_opt IWMPContentContainerList *pInfo,
            /* [out] */ __RPC__deref_out_opt BSTR *pbstrTotalPrice,
            /* [out] */ __RPC__out VARIANT_BOOL *pSilentOK) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Buy( 
            /* [in] */ __RPC__in_opt IWMPContentContainerList *pInfo,
            /* [in] */ DWORD cookie) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetStreamingURL( 
            /* [in] */ WMPStreamingType st,
            /* [in] */ __RPC__in VARIANT *pStreamContext,
            /* [out] */ __RPC__deref_out_opt BSTR *pbstrURL) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Download( 
            /* [in] */ __RPC__in_opt IWMPContentContainerList *pInfo,
            /* [in] */ DWORD cookie) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE DownloadTrackComplete( 
            /* [in] */ HRESULT hrResult,
            /* [in] */ ULONG contentID,
            /* [in] */ __RPC__in BSTR downloadTrackParam) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE RefreshLicense( 
            /* [in] */ DWORD dwCookie,
            /* [in] */ VARIANT_BOOL fLocal,
            /* [unique][in] */ __RPC__in_opt BSTR bstrURL,
            /* [in] */ WMPStreamingType type,
            /* [in] */ ULONG contentID,
            /* [in] */ __RPC__in BSTR bstrRefreshReason,
            /* [in] */ __RPC__in VARIANT *pReasonContext) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetCatalogURL( 
            /* [in] */ DWORD dwCatalogVersion,
            /* [in] */ DWORD dwCatalogSchemaVersion,
            /* [in] */ LCID catalogLCID,
            /* [out] */ __RPC__out DWORD *pdwNewCatalogVersion,
            /* [out] */ __RPC__deref_out_opt BSTR *pbstrCatalogURL,
            /* [out] */ __RPC__out VARIANT *pExpirationDate) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetTemplate( 
            /* [in] */ WMPTaskType task,
            /* [in] */ __RPC__in BSTR location,
            /* [in] */ __RPC__in VARIANT *pContext,
            /* [in] */ __RPC__in BSTR clickLocation,
            /* [in] */ __RPC__in VARIANT *pClickContext,
            /* [in] */ __RPC__in BSTR bstrFilter,
            /* [in] */ __RPC__in BSTR bstrViewParams,
            /* [out] */ __RPC__deref_out_opt BSTR *pbstrTemplateURL,
            /* [out] */ __RPC__out WMPTemplateSize *pTemplateSize) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE UpdateDevice( 
            /* [in] */ __RPC__in BSTR bstrDeviceName) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetListContents( 
            /* [in] */ __RPC__in BSTR location,
            /* [in] */ __RPC__in VARIANT *pContext,
            /* [in] */ __RPC__in BSTR bstrListType,
            /* [in] */ __RPC__in BSTR bstrParams,
            /* [in] */ DWORD dwListCookie) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Login( 
            /* [in] */ BLOB userInfo,
            /* [in] */ BLOB pwdInfo,
            /* [in] */ VARIANT_BOOL fUsedCachedCreds,
            /* [in] */ VARIANT_BOOL fOkToCache) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Authenticate( 
            /* [in] */ BLOB userInfo,
            /* [in] */ BLOB pwdInfo) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Logout( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SendMessage( 
            /* [in] */ __RPC__in BSTR bstrMsg,
            /* [in] */ __RPC__in BSTR bstrParam) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE StationEvent( 
            /* [in] */ __RPC__in BSTR bstrStationEventType,
            /* [in] */ ULONG StationId,
            /* [in] */ ULONG PlaylistIndex,
            /* [in] */ ULONG TrackID,
            /* [in] */ __RPC__in BSTR TrackData,
            /* [in] */ DWORD dwSecondsPlayed) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE CompareContainerListPrices( 
            /* [in] */ __RPC__in_opt IWMPContentContainerList *pListBase,
            /* [in] */ __RPC__in_opt IWMPContentContainerList *pListCompare,
            /* [out] */ __RPC__out long *pResult) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE VerifyPermission( 
            /* [in] */ __RPC__in BSTR bstrPermission,
            /* [in] */ __RPC__in VARIANT *pContext) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IWMPContentPartnerVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IWMPContentPartner * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IWMPContentPartner * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IWMPContentPartner * This);
        
        HRESULT ( STDMETHODCALLTYPE *SetCallback )( 
            IWMPContentPartner * This,
            /* [in] */ __RPC__in_opt IWMPContentPartnerCallback *pCallback);
        
        HRESULT ( STDMETHODCALLTYPE *Notify )( 
            IWMPContentPartner * This,
            /* [in] */ WMPPartnerNotification type,
            /* [in] */ __RPC__in VARIANT *pContext);
        
        HRESULT ( STDMETHODCALLTYPE *GetItemInfo )( 
            IWMPContentPartner * This,
            /* [in] */ __RPC__in BSTR bstrInfoName,
            /* [in] */ __RPC__in VARIANT *pContext,
            /* [out] */ __RPC__out VARIANT *pData);
        
        HRESULT ( STDMETHODCALLTYPE *GetContentPartnerInfo )( 
            IWMPContentPartner * This,
            /* [in] */ __RPC__in BSTR bstrInfoName,
            /* [out] */ __RPC__out VARIANT *pData);
        
        HRESULT ( STDMETHODCALLTYPE *GetCommands )( 
            IWMPContentPartner * This,
            /* [in] */ __RPC__in BSTR location,
            /* [in] */ __RPC__in VARIANT *pLocationContext,
            /* [in] */ __RPC__in BSTR itemLocation,
            /* [in] */ ULONG cItemIDs,
            /* [size_is][in] */ __RPC__in_ecount_full(cItemIDs) ULONG *prgItemIDs,
            /* [out] */ __RPC__out ULONG *pcItemIDs,
            /* [size_is][size_is][out] */ __RPC__deref_out_ecount_full_opt(*pcItemIDs) WMPContextMenuInfo **pprgItems);
        
        HRESULT ( STDMETHODCALLTYPE *InvokeCommand )( 
            IWMPContentPartner * This,
            /* [in] */ DWORD dwCommandID,
            /* [in] */ __RPC__in BSTR location,
            /* [in] */ __RPC__in VARIANT *pLocationContext,
            /* [in] */ __RPC__in BSTR itemLocation,
            /* [in] */ ULONG cItemIDs,
            /* [size_is][in] */ __RPC__in_ecount_full(cItemIDs) ULONG *rgItemIDs);
        
        HRESULT ( STDMETHODCALLTYPE *CanBuySilent )( 
            IWMPContentPartner * This,
            /* [in] */ __RPC__in_opt IWMPContentContainerList *pInfo,
            /* [out] */ __RPC__deref_out_opt BSTR *pbstrTotalPrice,
            /* [out] */ __RPC__out VARIANT_BOOL *pSilentOK);
        
        HRESULT ( STDMETHODCALLTYPE *Buy )( 
            IWMPContentPartner * This,
            /* [in] */ __RPC__in_opt IWMPContentContainerList *pInfo,
            /* [in] */ DWORD cookie);
        
        HRESULT ( STDMETHODCALLTYPE *GetStreamingURL )( 
            IWMPContentPartner * This,
            /* [in] */ WMPStreamingType st,
            /* [in] */ __RPC__in VARIANT *pStreamContext,
            /* [out] */ __RPC__deref_out_opt BSTR *pbstrURL);
        
        HRESULT ( STDMETHODCALLTYPE *Download )( 
            IWMPContentPartner * This,
            /* [in] */ __RPC__in_opt IWMPContentContainerList *pInfo,
            /* [in] */ DWORD cookie);
        
        HRESULT ( STDMETHODCALLTYPE *DownloadTrackComplete )( 
            IWMPContentPartner * This,
            /* [in] */ HRESULT hrResult,
            /* [in] */ ULONG contentID,
            /* [in] */ __RPC__in BSTR downloadTrackParam);
        
        HRESULT ( STDMETHODCALLTYPE *RefreshLicense )( 
            IWMPContentPartner * This,
            /* [in] */ DWORD dwCookie,
            /* [in] */ VARIANT_BOOL fLocal,
            /* [unique][in] */ __RPC__in_opt BSTR bstrURL,
            /* [in] */ WMPStreamingType type,
            /* [in] */ ULONG contentID,
            /* [in] */ __RPC__in BSTR bstrRefreshReason,
            /* [in] */ __RPC__in VARIANT *pReasonContext);
        
        HRESULT ( STDMETHODCALLTYPE *GetCatalogURL )( 
            IWMPContentPartner * This,
            /* [in] */ DWORD dwCatalogVersion,
            /* [in] */ DWORD dwCatalogSchemaVersion,
            /* [in] */ LCID catalogLCID,
            /* [out] */ __RPC__out DWORD *pdwNewCatalogVersion,
            /* [out] */ __RPC__deref_out_opt BSTR *pbstrCatalogURL,
            /* [out] */ __RPC__out VARIANT *pExpirationDate);
        
        HRESULT ( STDMETHODCALLTYPE *GetTemplate )( 
            IWMPContentPartner * This,
            /* [in] */ WMPTaskType task,
            /* [in] */ __RPC__in BSTR location,
            /* [in] */ __RPC__in VARIANT *pContext,
            /* [in] */ __RPC__in BSTR clickLocation,
            /* [in] */ __RPC__in VARIANT *pClickContext,
            /* [in] */ __RPC__in BSTR bstrFilter,
            /* [in] */ __RPC__in BSTR bstrViewParams,
            /* [out] */ __RPC__deref_out_opt BSTR *pbstrTemplateURL,
            /* [out] */ __RPC__out WMPTemplateSize *pTemplateSize);
        
        HRESULT ( STDMETHODCALLTYPE *UpdateDevice )( 
            IWMPContentPartner * This,
            /* [in] */ __RPC__in BSTR bstrDeviceName);
        
        HRESULT ( STDMETHODCALLTYPE *GetListContents )( 
            IWMPContentPartner * This,
            /* [in] */ __RPC__in BSTR location,
            /* [in] */ __RPC__in VARIANT *pContext,
            /* [in] */ __RPC__in BSTR bstrListType,
            /* [in] */ __RPC__in BSTR bstrParams,
            /* [in] */ DWORD dwListCookie);
        
        HRESULT ( STDMETHODCALLTYPE *Login )( 
            IWMPContentPartner * This,
            /* [in] */ BLOB userInfo,
            /* [in] */ BLOB pwdInfo,
            /* [in] */ VARIANT_BOOL fUsedCachedCreds,
            /* [in] */ VARIANT_BOOL fOkToCache);
        
        HRESULT ( STDMETHODCALLTYPE *Authenticate )( 
            IWMPContentPartner * This,
            /* [in] */ BLOB userInfo,
            /* [in] */ BLOB pwdInfo);
        
        HRESULT ( STDMETHODCALLTYPE *Logout )( 
            IWMPContentPartner * This);
        
        HRESULT ( STDMETHODCALLTYPE *SendMessage )( 
            IWMPContentPartner * This,
            /* [in] */ __RPC__in BSTR bstrMsg,
            /* [in] */ __RPC__in BSTR bstrParam);
        
        HRESULT ( STDMETHODCALLTYPE *StationEvent )( 
            IWMPContentPartner * This,
            /* [in] */ __RPC__in BSTR bstrStationEventType,
            /* [in] */ ULONG StationId,
            /* [in] */ ULONG PlaylistIndex,
            /* [in] */ ULONG TrackID,
            /* [in] */ __RPC__in BSTR TrackData,
            /* [in] */ DWORD dwSecondsPlayed);
        
        HRESULT ( STDMETHODCALLTYPE *CompareContainerListPrices )( 
            IWMPContentPartner * This,
            /* [in] */ __RPC__in_opt IWMPContentContainerList *pListBase,
            /* [in] */ __RPC__in_opt IWMPContentContainerList *pListCompare,
            /* [out] */ __RPC__out long *pResult);
        
        HRESULT ( STDMETHODCALLTYPE *VerifyPermission )( 
            IWMPContentPartner * This,
            /* [in] */ __RPC__in BSTR bstrPermission,
            /* [in] */ __RPC__in VARIANT *pContext);
        
        END_INTERFACE
    } IWMPContentPartnerVtbl;

    interface IWMPContentPartner
    {
        CONST_VTBL struct IWMPContentPartnerVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IWMPContentPartner_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IWMPContentPartner_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IWMPContentPartner_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IWMPContentPartner_SetCallback(This,pCallback)	\
    ( (This)->lpVtbl -> SetCallback(This,pCallback) ) 

#define IWMPContentPartner_Notify(This,type,pContext)	\
    ( (This)->lpVtbl -> Notify(This,type,pContext) ) 

#define IWMPContentPartner_GetItemInfo(This,bstrInfoName,pContext,pData)	\
    ( (This)->lpVtbl -> GetItemInfo(This,bstrInfoName,pContext,pData) ) 

#define IWMPContentPartner_GetContentPartnerInfo(This,bstrInfoName,pData)	\
    ( (This)->lpVtbl -> GetContentPartnerInfo(This,bstrInfoName,pData) ) 

#define IWMPContentPartner_GetCommands(This,location,pLocationContext,itemLocation,cItemIDs,prgItemIDs,pcItemIDs,pprgItems)	\
    ( (This)->lpVtbl -> GetCommands(This,location,pLocationContext,itemLocation,cItemIDs,prgItemIDs,pcItemIDs,pprgItems) ) 

#define IWMPContentPartner_InvokeCommand(This,dwCommandID,location,pLocationContext,itemLocation,cItemIDs,rgItemIDs)	\
    ( (This)->lpVtbl -> InvokeCommand(This,dwCommandID,location,pLocationContext,itemLocation,cItemIDs,rgItemIDs) ) 

#define IWMPContentPartner_CanBuySilent(This,pInfo,pbstrTotalPrice,pSilentOK)	\
    ( (This)->lpVtbl -> CanBuySilent(This,pInfo,pbstrTotalPrice,pSilentOK) ) 

#define IWMPContentPartner_Buy(This,pInfo,cookie)	\
    ( (This)->lpVtbl -> Buy(This,pInfo,cookie) ) 

#define IWMPContentPartner_GetStreamingURL(This,st,pStreamContext,pbstrURL)	\
    ( (This)->lpVtbl -> GetStreamingURL(This,st,pStreamContext,pbstrURL) ) 

#define IWMPContentPartner_Download(This,pInfo,cookie)	\
    ( (This)->lpVtbl -> Download(This,pInfo,cookie) ) 

#define IWMPContentPartner_DownloadTrackComplete(This,hrResult,contentID,downloadTrackParam)	\
    ( (This)->lpVtbl -> DownloadTrackComplete(This,hrResult,contentID,downloadTrackParam) ) 

#define IWMPContentPartner_RefreshLicense(This,dwCookie,fLocal,bstrURL,type,contentID,bstrRefreshReason,pReasonContext)	\
    ( (This)->lpVtbl -> RefreshLicense(This,dwCookie,fLocal,bstrURL,type,contentID,bstrRefreshReason,pReasonContext) ) 

#define IWMPContentPartner_GetCatalogURL(This,dwCatalogVersion,dwCatalogSchemaVersion,catalogLCID,pdwNewCatalogVersion,pbstrCatalogURL,pExpirationDate)	\
    ( (This)->lpVtbl -> GetCatalogURL(This,dwCatalogVersion,dwCatalogSchemaVersion,catalogLCID,pdwNewCatalogVersion,pbstrCatalogURL,pExpirationDate) ) 

#define IWMPContentPartner_GetTemplate(This,task,location,pContext,clickLocation,pClickContext,bstrFilter,bstrViewParams,pbstrTemplateURL,pTemplateSize)	\
    ( (This)->lpVtbl -> GetTemplate(This,task,location,pContext,clickLocation,pClickContext,bstrFilter,bstrViewParams,pbstrTemplateURL,pTemplateSize) ) 

#define IWMPContentPartner_UpdateDevice(This,bstrDeviceName)	\
    ( (This)->lpVtbl -> UpdateDevice(This,bstrDeviceName) ) 

#define IWMPContentPartner_GetListContents(This,location,pContext,bstrListType,bstrParams,dwListCookie)	\
    ( (This)->lpVtbl -> GetListContents(This,location,pContext,bstrListType,bstrParams,dwListCookie) ) 

#define IWMPContentPartner_Login(This,userInfo,pwdInfo,fUsedCachedCreds,fOkToCache)	\
    ( (This)->lpVtbl -> Login(This,userInfo,pwdInfo,fUsedCachedCreds,fOkToCache) ) 

#define IWMPContentPartner_Authenticate(This,userInfo,pwdInfo)	\
    ( (This)->lpVtbl -> Authenticate(This,userInfo,pwdInfo) ) 

#define IWMPContentPartner_Logout(This)	\
    ( (This)->lpVtbl -> Logout(This) ) 

#define IWMPContentPartner_SendMessage(This,bstrMsg,bstrParam)	\
    ( (This)->lpVtbl -> SendMessage(This,bstrMsg,bstrParam) ) 

#define IWMPContentPartner_StationEvent(This,bstrStationEventType,StationId,PlaylistIndex,TrackID,TrackData,dwSecondsPlayed)	\
    ( (This)->lpVtbl -> StationEvent(This,bstrStationEventType,StationId,PlaylistIndex,TrackID,TrackData,dwSecondsPlayed) ) 

#define IWMPContentPartner_CompareContainerListPrices(This,pListBase,pListCompare,pResult)	\
    ( (This)->lpVtbl -> CompareContainerListPrices(This,pListBase,pListCompare,pResult) ) 

#define IWMPContentPartner_VerifyPermission(This,bstrPermission,pContext)	\
    ( (This)->lpVtbl -> VerifyPermission(This,bstrPermission,pContext) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IWMPContentPartner_INTERFACE_DEFINED__ */


/* Additional Prototypes for ALL interfaces */

unsigned long             __RPC_USER  BSTR_UserSize(     unsigned long *, unsigned long            , BSTR * ); 
unsigned char * __RPC_USER  BSTR_UserMarshal(  unsigned long *, unsigned char *, BSTR * ); 
unsigned char * __RPC_USER  BSTR_UserUnmarshal(unsigned long *, unsigned char *, BSTR * ); 
void                      __RPC_USER  BSTR_UserFree(     unsigned long *, BSTR * ); 

unsigned long             __RPC_USER  VARIANT_UserSize(     unsigned long *, unsigned long            , VARIANT * ); 
unsigned char * __RPC_USER  VARIANT_UserMarshal(  unsigned long *, unsigned char *, VARIANT * ); 
unsigned char * __RPC_USER  VARIANT_UserUnmarshal(unsigned long *, unsigned char *, VARIANT * ); 
void                      __RPC_USER  VARIANT_UserFree(     unsigned long *, VARIANT * ); 

unsigned long             __RPC_USER  BSTR_UserSize64(     unsigned long *, unsigned long            , BSTR * ); 
unsigned char * __RPC_USER  BSTR_UserMarshal64(  unsigned long *, unsigned char *, BSTR * ); 
unsigned char * __RPC_USER  BSTR_UserUnmarshal64(unsigned long *, unsigned char *, BSTR * ); 
void                      __RPC_USER  BSTR_UserFree64(     unsigned long *, BSTR * ); 

unsigned long             __RPC_USER  VARIANT_UserSize64(     unsigned long *, unsigned long            , VARIANT * ); 
unsigned char * __RPC_USER  VARIANT_UserMarshal64(  unsigned long *, unsigned char *, VARIANT * ); 
unsigned char * __RPC_USER  VARIANT_UserUnmarshal64(unsigned long *, unsigned char *, VARIANT * ); 
void                      __RPC_USER  VARIANT_UserFree64(     unsigned long *, VARIANT * ); 

/* end of Additional Prototypes */

#ifdef __cplusplus
}
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\vs9sp1\sdk\include\control.h ===
/* this ALWAYS GENERATED file contains the definitions for the interfaces */


 /* File created by MIDL compiler version 7.00.0499 */
/* Compiler settings for control.odl:
    Oicf, W0, Zp8, env=Win32 (32b run)
    protocol : dce , ms_ext, c_ext, robust
    error checks: allocation ref bounds_check enum stub_data 
    VC __declspec() decoration level: 
         __declspec(uuid()), __declspec(selectany), __declspec(novtable)
         DECLSPEC_UUID(), MIDL_INTERFACE()
*/
//@@MIDL_FILE_HEADING(  )

#pragma warning( disable: 4049 )  /* more than 64k source lines */


/* verify that the <rpcndr.h> version is high enough to compile this file*/
#ifndef __REQUIRED_RPCNDR_H_VERSION__
#define __REQUIRED_RPCNDR_H_VERSION__ 500
#endif

/* verify that the <rpcsal.h> version is high enough to compile this file*/
#ifndef __REQUIRED_RPCSAL_H_VERSION__
#define __REQUIRED_RPCSAL_H_VERSION__ 100
#endif

#include "rpc.h"
#include "rpcndr.h"

#ifndef __RPCNDR_H_VERSION__
#error this stub requires an updated version of <rpcndr.h>
#endif // __RPCNDR_H_VERSION__


#ifndef __control_h__
#define __control_h__

#if defined(_MSC_VER) && (_MSC_VER >= 1020)
#pragma once
#endif

/* Forward Declarations */ 

#ifndef __IAMCollection_FWD_DEFINED__
#define __IAMCollection_FWD_DEFINED__
typedef interface IAMCollection IAMCollection;
#endif 	/* __IAMCollection_FWD_DEFINED__ */


#ifndef __IMediaControl_FWD_DEFINED__
#define __IMediaControl_FWD_DEFINED__
typedef interface IMediaControl IMediaControl;
#endif 	/* __IMediaControl_FWD_DEFINED__ */


#ifndef __IMediaEvent_FWD_DEFINED__
#define __IMediaEvent_FWD_DEFINED__
typedef interface IMediaEvent IMediaEvent;
#endif 	/* __IMediaEvent_FWD_DEFINED__ */


#ifndef __IMediaEventEx_FWD_DEFINED__
#define __IMediaEventEx_FWD_DEFINED__
typedef interface IMediaEventEx IMediaEventEx;
#endif 	/* __IMediaEventEx_FWD_DEFINED__ */


#ifndef __IMediaPosition_FWD_DEFINED__
#define __IMediaPosition_FWD_DEFINED__
typedef interface IMediaPosition IMediaPosition;
#endif 	/* __IMediaPosition_FWD_DEFINED__ */


#ifndef __IBasicAudio_FWD_DEFINED__
#define __IBasicAudio_FWD_DEFINED__
typedef interface IBasicAudio IBasicAudio;
#endif 	/* __IBasicAudio_FWD_DEFINED__ */


#ifndef __IVideoWindow_FWD_DEFINED__
#define __IVideoWindow_FWD_DEFINED__
typedef interface IVideoWindow IVideoWindow;
#endif 	/* __IVideoWindow_FWD_DEFINED__ */


#ifndef __IBasicVideo_FWD_DEFINED__
#define __IBasicVideo_FWD_DEFINED__
typedef interface IBasicVideo IBasicVideo;
#endif 	/* __IBasicVideo_FWD_DEFINED__ */


#ifndef __IBasicVideo2_FWD_DEFINED__
#define __IBasicVideo2_FWD_DEFINED__
typedef interface IBasicVideo2 IBasicVideo2;
#endif 	/* __IBasicVideo2_FWD_DEFINED__ */


#ifndef __IDeferredCommand_FWD_DEFINED__
#define __IDeferredCommand_FWD_DEFINED__
typedef interface IDeferredCommand IDeferredCommand;
#endif 	/* __IDeferredCommand_FWD_DEFINED__ */


#ifndef __IQueueCommand_FWD_DEFINED__
#define __IQueueCommand_FWD_DEFINED__
typedef interface IQueueCommand IQueueCommand;
#endif 	/* __IQueueCommand_FWD_DEFINED__ */


#ifndef __FilgraphManager_FWD_DEFINED__
#define __FilgraphManager_FWD_DEFINED__

#ifdef __cplusplus
typedef class FilgraphManager FilgraphManager;
#else
typedef struct FilgraphManager FilgraphManager;
#endif /* __cplusplus */

#endif 	/* __FilgraphManager_FWD_DEFINED__ */


#ifndef __IFilterInfo_FWD_DEFINED__
#define __IFilterInfo_FWD_DEFINED__
typedef interface IFilterInfo IFilterInfo;
#endif 	/* __IFilterInfo_FWD_DEFINED__ */


#ifndef __IRegFilterInfo_FWD_DEFINED__
#define __IRegFilterInfo_FWD_DEFINED__
typedef interface IRegFilterInfo IRegFilterInfo;
#endif 	/* __IRegFilterInfo_FWD_DEFINED__ */


#ifndef __IMediaTypeInfo_FWD_DEFINED__
#define __IMediaTypeInfo_FWD_DEFINED__
typedef interface IMediaTypeInfo IMediaTypeInfo;
#endif 	/* __IMediaTypeInfo_FWD_DEFINED__ */


#ifndef __IPinInfo_FWD_DEFINED__
#define __IPinInfo_FWD_DEFINED__
typedef interface IPinInfo IPinInfo;
#endif 	/* __IPinInfo_FWD_DEFINED__ */


#ifndef __IAMStats_FWD_DEFINED__
#define __IAMStats_FWD_DEFINED__
typedef interface IAMStats IAMStats;
#endif 	/* __IAMStats_FWD_DEFINED__ */


#ifdef __cplusplus
extern "C"{
#endif 



#ifndef __QuartzTypeLib_LIBRARY_DEFINED__
#define __QuartzTypeLib_LIBRARY_DEFINED__

/* library QuartzTypeLib */
/* [version][lcid][helpstring][uuid] */ 

typedef double REFTIME;

typedef LONG_PTR OAEVENT;

typedef LONG_PTR OAHWND;

typedef long OAFilterState;


DEFINE_GUID(LIBID_QuartzTypeLib,0x56a868b0,0x0ad4,0x11ce,0xb0,0x3a,0x00,0x20,0xaf,0x0b,0xa7,0x70);

#ifndef __IAMCollection_INTERFACE_DEFINED__
#define __IAMCollection_INTERFACE_DEFINED__

/* interface IAMCollection */
/* [object][dual][oleautomation][helpstring][uuid] */ 


DEFINE_GUID(IID_IAMCollection,0x56a868b9,0x0ad4,0x11ce,0xb0,0x3a,0x00,0x20,0xaf,0x0b,0xa7,0x70);

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("56a868b9-0ad4-11ce-b03a-0020af0ba770")
    IAMCollection : public IDispatch
    {
    public:
        virtual /* [propget] */ HRESULT STDMETHODCALLTYPE get_Count( 
            /* [retval][out] */ __RPC__out LONG *plCount) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Item( 
            /* [in] */ long lItem,
            /* [out] */ __RPC__deref_out_opt IUnknown **ppUnk) = 0;
        
        virtual /* [propget] */ HRESULT STDMETHODCALLTYPE get__NewEnum( 
            /* [retval][out] */ __RPC__deref_out_opt IUnknown **ppUnk) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IAMCollectionVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IAMCollection * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IAMCollection * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IAMCollection * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfoCount )( 
            IAMCollection * This,
            /* [out] */ __RPC__out UINT *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfo )( 
            IAMCollection * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ __RPC__deref_out_opt ITypeInfo **ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetIDsOfNames )( 
            IAMCollection * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [size_is][in] */ __RPC__in_ecount_full(cNames) LPOLESTR *rgszNames,
            /* [range][in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ __RPC__out_ecount_full(cNames) DISPID *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE *Invoke )( 
            IAMCollection * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS *pDispParams,
            /* [out] */ VARIANT *pVarResult,
            /* [out] */ EXCEPINFO *pExcepInfo,
            /* [out] */ UINT *puArgErr);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_Count )( 
            IAMCollection * This,
            /* [retval][out] */ __RPC__out LONG *plCount);
        
        HRESULT ( STDMETHODCALLTYPE *Item )( 
            IAMCollection * This,
            /* [in] */ long lItem,
            /* [out] */ __RPC__deref_out_opt IUnknown **ppUnk);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get__NewEnum )( 
            IAMCollection * This,
            /* [retval][out] */ __RPC__deref_out_opt IUnknown **ppUnk);
        
        END_INTERFACE
    } IAMCollectionVtbl;

    interface IAMCollection
    {
        CONST_VTBL struct IAMCollectionVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IAMCollection_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IAMCollection_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IAMCollection_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IAMCollection_GetTypeInfoCount(This,pctinfo)	\
    ( (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo) ) 

#define IAMCollection_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    ( (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo) ) 

#define IAMCollection_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    ( (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId) ) 

#define IAMCollection_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    ( (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr) ) 


#define IAMCollection_get_Count(This,plCount)	\
    ( (This)->lpVtbl -> get_Count(This,plCount) ) 

#define IAMCollection_Item(This,lItem,ppUnk)	\
    ( (This)->lpVtbl -> Item(This,lItem,ppUnk) ) 

#define IAMCollection_get__NewEnum(This,ppUnk)	\
    ( (This)->lpVtbl -> get__NewEnum(This,ppUnk) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IAMCollection_INTERFACE_DEFINED__ */


#ifndef __IMediaControl_INTERFACE_DEFINED__
#define __IMediaControl_INTERFACE_DEFINED__

/* interface IMediaControl */
/* [object][dual][oleautomation][helpstring][uuid] */ 


DEFINE_GUID(IID_IMediaControl,0x56a868b1,0x0ad4,0x11ce,0xb0,0x3a,0x00,0x20,0xaf,0x0b,0xa7,0x70);

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("56a868b1-0ad4-11ce-b03a-0020af0ba770")
    IMediaControl : public IDispatch
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE Run( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Pause( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Stop( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetState( 
            /* [in] */ LONG msTimeout,
            /* [out] */ __RPC__out OAFilterState *pfs) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE RenderFile( 
            /* [in] */ __RPC__in BSTR strFilename) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE AddSourceFilter( 
            /* [in] */ __RPC__in BSTR strFilename,
            /* [out] */ __RPC__deref_out_opt IDispatch **ppUnk) = 0;
        
        virtual /* [propget] */ HRESULT STDMETHODCALLTYPE get_FilterCollection( 
            /* [retval][out] */ __RPC__deref_out_opt IDispatch **ppUnk) = 0;
        
        virtual /* [propget] */ HRESULT STDMETHODCALLTYPE get_RegFilterCollection( 
            /* [retval][out] */ __RPC__deref_out_opt IDispatch **ppUnk) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE StopWhenReady( void) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IMediaControlVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IMediaControl * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IMediaControl * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IMediaControl * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfoCount )( 
            IMediaControl * This,
            /* [out] */ __RPC__out UINT *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfo )( 
            IMediaControl * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ __RPC__deref_out_opt ITypeInfo **ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetIDsOfNames )( 
            IMediaControl * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [size_is][in] */ __RPC__in_ecount_full(cNames) LPOLESTR *rgszNames,
            /* [range][in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ __RPC__out_ecount_full(cNames) DISPID *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE *Invoke )( 
            IMediaControl * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS *pDispParams,
            /* [out] */ VARIANT *pVarResult,
            /* [out] */ EXCEPINFO *pExcepInfo,
            /* [out] */ UINT *puArgErr);
        
        HRESULT ( STDMETHODCALLTYPE *Run )( 
            IMediaControl * This);
        
        HRESULT ( STDMETHODCALLTYPE *Pause )( 
            IMediaControl * This);
        
        HRESULT ( STDMETHODCALLTYPE *Stop )( 
            IMediaControl * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetState )( 
            IMediaControl * This,
            /* [in] */ LONG msTimeout,
            /* [out] */ __RPC__out OAFilterState *pfs);
        
        HRESULT ( STDMETHODCALLTYPE *RenderFile )( 
            IMediaControl * This,
            /* [in] */ __RPC__in BSTR strFilename);
        
        HRESULT ( STDMETHODCALLTYPE *AddSourceFilter )( 
            IMediaControl * This,
            /* [in] */ __RPC__in BSTR strFilename,
            /* [out] */ __RPC__deref_out_opt IDispatch **ppUnk);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_FilterCollection )( 
            IMediaControl * This,
            /* [retval][out] */ __RPC__deref_out_opt IDispatch **ppUnk);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_RegFilterCollection )( 
            IMediaControl * This,
            /* [retval][out] */ __RPC__deref_out_opt IDispatch **ppUnk);
        
        HRESULT ( STDMETHODCALLTYPE *StopWhenReady )( 
            IMediaControl * This);
        
        END_INTERFACE
    } IMediaControlVtbl;

    interface IMediaControl
    {
        CONST_VTBL struct IMediaControlVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IMediaControl_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IMediaControl_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IMediaControl_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IMediaControl_GetTypeInfoCount(This,pctinfo)	\
    ( (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo) ) 

#define IMediaControl_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    ( (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo) ) 

#define IMediaControl_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    ( (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId) ) 

#define IMediaControl_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    ( (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr) ) 


#define IMediaControl_Run(This)	\
    ( (This)->lpVtbl -> Run(This) ) 

#define IMediaControl_Pause(This)	\
    ( (This)->lpVtbl -> Pause(This) ) 

#define IMediaControl_Stop(This)	\
    ( (This)->lpVtbl -> Stop(This) ) 

#define IMediaControl_GetState(This,msTimeout,pfs)	\
    ( (This)->lpVtbl -> GetState(This,msTimeout,pfs) ) 

#define IMediaControl_RenderFile(This,strFilename)	\
    ( (This)->lpVtbl -> RenderFile(This,strFilename) ) 

#define IMediaControl_AddSourceFilter(This,strFilename,ppUnk)	\
    ( (This)->lpVtbl -> AddSourceFilter(This,strFilename,ppUnk) ) 

#define IMediaControl_get_FilterCollection(This,ppUnk)	\
    ( (This)->lpVtbl -> get_FilterCollection(This,ppUnk) ) 

#define IMediaControl_get_RegFilterCollection(This,ppUnk)	\
    ( (This)->lpVtbl -> get_RegFilterCollection(This,ppUnk) ) 

#define IMediaControl_StopWhenReady(This)	\
    ( (This)->lpVtbl -> StopWhenReady(This) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IMediaControl_INTERFACE_DEFINED__ */


#ifndef __IMediaEvent_INTERFACE_DEFINED__
#define __IMediaEvent_INTERFACE_DEFINED__

/* interface IMediaEvent */
/* [object][dual][oleautomation][helpstring][uuid] */ 


DEFINE_GUID(IID_IMediaEvent,0x56a868b6,0x0ad4,0x11ce,0xb0,0x3a,0x00,0x20,0xaf,0x0b,0xa7,0x70);

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("56a868b6-0ad4-11ce-b03a-0020af0ba770")
    IMediaEvent : public IDispatch
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE GetEventHandle( 
            /* [out] */ __RPC__out OAEVENT *hEvent) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetEvent( 
            /* [out] */ __RPC__out long *lEventCode,
            /* [out] */ __RPC__out LONG_PTR *lParam1,
            /* [out] */ __RPC__out LONG_PTR *lParam2,
            /* [in] */ long msTimeout) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE WaitForCompletion( 
            /* [in] */ long msTimeout,
            /* [out] */ __RPC__out long *pEvCode) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE CancelDefaultHandling( 
            /* [in] */ long lEvCode) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE RestoreDefaultHandling( 
            /* [in] */ long lEvCode) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE FreeEventParams( 
            /* [in] */ long lEvCode,
            /* [in] */ LONG_PTR lParam1,
            /* [in] */ LONG_PTR lParam2) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IMediaEventVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IMediaEvent * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IMediaEvent * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IMediaEvent * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfoCount )( 
            IMediaEvent * This,
            /* [out] */ __RPC__out UINT *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfo )( 
            IMediaEvent * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ __RPC__deref_out_opt ITypeInfo **ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetIDsOfNames )( 
            IMediaEvent * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [size_is][in] */ __RPC__in_ecount_full(cNames) LPOLESTR *rgszNames,
            /* [range][in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ __RPC__out_ecount_full(cNames) DISPID *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE *Invoke )( 
            IMediaEvent * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS *pDispParams,
            /* [out] */ VARIANT *pVarResult,
            /* [out] */ EXCEPINFO *pExcepInfo,
            /* [out] */ UINT *puArgErr);
        
        HRESULT ( STDMETHODCALLTYPE *GetEventHandle )( 
            IMediaEvent * This,
            /* [out] */ __RPC__out OAEVENT *hEvent);
        
        HRESULT ( STDMETHODCALLTYPE *GetEvent )( 
            IMediaEvent * This,
            /* [out] */ __RPC__out long *lEventCode,
            /* [out] */ __RPC__out LONG_PTR *lParam1,
            /* [out] */ __RPC__out LONG_PTR *lParam2,
            /* [in] */ long msTimeout);
        
        HRESULT ( STDMETHODCALLTYPE *WaitForCompletion )( 
            IMediaEvent * This,
            /* [in] */ long msTimeout,
            /* [out] */ __RPC__out long *pEvCode);
        
        HRESULT ( STDMETHODCALLTYPE *CancelDefaultHandling )( 
            IMediaEvent * This,
            /* [in] */ long lEvCode);
        
        HRESULT ( STDMETHODCALLTYPE *RestoreDefaultHandling )( 
            IMediaEvent * This,
            /* [in] */ long lEvCode);
        
        HRESULT ( STDMETHODCALLTYPE *FreeEventParams )( 
            IMediaEvent * This,
            /* [in] */ long lEvCode,
            /* [in] */ LONG_PTR lParam1,
            /* [in] */ LONG_PTR lParam2);
        
        END_INTERFACE
    } IMediaEventVtbl;

    interface IMediaEvent
    {
        CONST_VTBL struct IMediaEventVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IMediaEvent_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IMediaEvent_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IMediaEvent_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IMediaEvent_GetTypeInfoCount(This,pctinfo)	\
    ( (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo) ) 

#define IMediaEvent_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    ( (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo) ) 

#define IMediaEvent_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    ( (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId) ) 

#define IMediaEvent_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    ( (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr) ) 


#define IMediaEvent_GetEventHandle(This,hEvent)	\
    ( (This)->lpVtbl -> GetEventHandle(This,hEvent) ) 

#define IMediaEvent_GetEvent(This,lEventCode,lParam1,lParam2,msTimeout)	\
    ( (This)->lpVtbl -> GetEvent(This,lEventCode,lParam1,lParam2,msTimeout) ) 

#define IMediaEvent_WaitForCompletion(This,msTimeout,pEvCode)	\
    ( (This)->lpVtbl -> WaitForCompletion(This,msTimeout,pEvCode) ) 

#define IMediaEvent_CancelDefaultHandling(This,lEvCode)	\
    ( (This)->lpVtbl -> CancelDefaultHandling(This,lEvCode) ) 

#define IMediaEvent_RestoreDefaultHandling(This,lEvCode)	\
    ( (This)->lpVtbl -> RestoreDefaultHandling(This,lEvCode) ) 

#define IMediaEvent_FreeEventParams(This,lEvCode,lParam1,lParam2)	\
    ( (This)->lpVtbl -> FreeEventParams(This,lEvCode,lParam1,lParam2) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IMediaEvent_INTERFACE_DEFINED__ */


#ifndef __IMediaEventEx_INTERFACE_DEFINED__
#define __IMediaEventEx_INTERFACE_DEFINED__

/* interface IMediaEventEx */
/* [object][helpstring][uuid] */ 


DEFINE_GUID(IID_IMediaEventEx,0x56a868c0,0x0ad4,0x11ce,0xb0,0x3a,0x00,0x20,0xaf,0x0b,0xa7,0x70);

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("56a868c0-0ad4-11ce-b03a-0020af0ba770")
    IMediaEventEx : public IMediaEvent
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE SetNotifyWindow( 
            /* [in] */ OAHWND hwnd,
            /* [in] */ long lMsg,
            /* [in] */ LONG_PTR lInstanceData) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetNotifyFlags( 
            /* [in] */ long lNoNotifyFlags) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetNotifyFlags( 
            /* [out] */ __RPC__out long *lplNoNotifyFlags) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IMediaEventExVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IMediaEventEx * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IMediaEventEx * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IMediaEventEx * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfoCount )( 
            IMediaEventEx * This,
            /* [out] */ __RPC__out UINT *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfo )( 
            IMediaEventEx * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ __RPC__deref_out_opt ITypeInfo **ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetIDsOfNames )( 
            IMediaEventEx * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [size_is][in] */ __RPC__in_ecount_full(cNames) LPOLESTR *rgszNames,
            /* [range][in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ __RPC__out_ecount_full(cNames) DISPID *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE *Invoke )( 
            IMediaEventEx * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS *pDispParams,
            /* [out] */ VARIANT *pVarResult,
            /* [out] */ EXCEPINFO *pExcepInfo,
            /* [out] */ UINT *puArgErr);
        
        HRESULT ( STDMETHODCALLTYPE *GetEventHandle )( 
            IMediaEventEx * This,
            /* [out] */ __RPC__out OAEVENT *hEvent);
        
        HRESULT ( STDMETHODCALLTYPE *GetEvent )( 
            IMediaEventEx * This,
            /* [out] */ __RPC__out long *lEventCode,
            /* [out] */ __RPC__out LONG_PTR *lParam1,
            /* [out] */ __RPC__out LONG_PTR *lParam2,
            /* [in] */ long msTimeout);
        
        HRESULT ( STDMETHODCALLTYPE *WaitForCompletion )( 
            IMediaEventEx * This,
            /* [in] */ long msTimeout,
            /* [out] */ __RPC__out long *pEvCode);
        
        HRESULT ( STDMETHODCALLTYPE *CancelDefaultHandling )( 
            IMediaEventEx * This,
            /* [in] */ long lEvCode);
        
        HRESULT ( STDMETHODCALLTYPE *RestoreDefaultHandling )( 
            IMediaEventEx * This,
            /* [in] */ long lEvCode);
        
        HRESULT ( STDMETHODCALLTYPE *FreeEventParams )( 
            IMediaEventEx * This,
            /* [in] */ long lEvCode,
            /* [in] */ LONG_PTR lParam1,
            /* [in] */ LONG_PTR lParam2);
        
        HRESULT ( STDMETHODCALLTYPE *SetNotifyWindow )( 
            IMediaEventEx * This,
            /* [in] */ OAHWND hwnd,
            /* [in] */ long lMsg,
            /* [in] */ LONG_PTR lInstanceData);
        
        HRESULT ( STDMETHODCALLTYPE *SetNotifyFlags )( 
            IMediaEventEx * This,
            /* [in] */ long lNoNotifyFlags);
        
        HRESULT ( STDMETHODCALLTYPE *GetNotifyFlags )( 
            IMediaEventEx * This,
            /* [out] */ __RPC__out long *lplNoNotifyFlags);
        
        END_INTERFACE
    } IMediaEventExVtbl;

    interface IMediaEventEx
    {
        CONST_VTBL struct IMediaEventExVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IMediaEventEx_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IMediaEventEx_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IMediaEventEx_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IMediaEventEx_GetTypeInfoCount(This,pctinfo)	\
    ( (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo) ) 

#define IMediaEventEx_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    ( (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo) ) 

#define IMediaEventEx_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    ( (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId) ) 

#define IMediaEventEx_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    ( (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr) ) 


#define IMediaEventEx_GetEventHandle(This,hEvent)	\
    ( (This)->lpVtbl -> GetEventHandle(This,hEvent) ) 

#define IMediaEventEx_GetEvent(This,lEventCode,lParam1,lParam2,msTimeout)	\
    ( (This)->lpVtbl -> GetEvent(This,lEventCode,lParam1,lParam2,msTimeout) ) 

#define IMediaEventEx_WaitForCompletion(This,msTimeout,pEvCode)	\
    ( (This)->lpVtbl -> WaitForCompletion(This,msTimeout,pEvCode) ) 

#define IMediaEventEx_CancelDefaultHandling(This,lEvCode)	\
    ( (This)->lpVtbl -> CancelDefaultHandling(This,lEvCode) ) 

#define IMediaEventEx_RestoreDefaultHandling(This,lEvCode)	\
    ( (This)->lpVtbl -> RestoreDefaultHandling(This,lEvCode) ) 

#define IMediaEventEx_FreeEventParams(This,lEvCode,lParam1,lParam2)	\
    ( (This)->lpVtbl -> FreeEventParams(This,lEvCode,lParam1,lParam2) ) 


#define IMediaEventEx_SetNotifyWindow(This,hwnd,lMsg,lInstanceData)	\
    ( (This)->lpVtbl -> SetNotifyWindow(This,hwnd,lMsg,lInstanceData) ) 

#define IMediaEventEx_SetNotifyFlags(This,lNoNotifyFlags)	\
    ( (This)->lpVtbl -> SetNotifyFlags(This,lNoNotifyFlags) ) 

#define IMediaEventEx_GetNotifyFlags(This,lplNoNotifyFlags)	\
    ( (This)->lpVtbl -> GetNotifyFlags(This,lplNoNotifyFlags) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IMediaEventEx_INTERFACE_DEFINED__ */


#ifndef __IMediaPosition_INTERFACE_DEFINED__
#define __IMediaPosition_INTERFACE_DEFINED__

/* interface IMediaPosition */
/* [object][dual][oleautomation][helpstring][uuid] */ 


DEFINE_GUID(IID_IMediaPosition,0x56a868b2,0x0ad4,0x11ce,0xb0,0x3a,0x00,0x20,0xaf,0x0b,0xa7,0x70);

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("56a868b2-0ad4-11ce-b03a-0020af0ba770")
    IMediaPosition : public IDispatch
    {
    public:
        virtual /* [propget] */ HRESULT STDMETHODCALLTYPE get_Duration( 
            /* [retval][out] */ __RPC__out REFTIME *plength) = 0;
        
        virtual /* [propput] */ HRESULT STDMETHODCALLTYPE put_CurrentPosition( 
            /* [in] */ REFTIME llTime) = 0;
        
        virtual /* [propget] */ HRESULT STDMETHODCALLTYPE get_CurrentPosition( 
            /* [retval][out] */ __RPC__out REFTIME *pllTime) = 0;
        
        virtual /* [propget] */ HRESULT STDMETHODCALLTYPE get_StopTime( 
            /* [retval][out] */ __RPC__out REFTIME *pllTime) = 0;
        
        virtual /* [propput] */ HRESULT STDMETHODCALLTYPE put_StopTime( 
            /* [in] */ REFTIME llTime) = 0;
        
        virtual /* [propget] */ HRESULT STDMETHODCALLTYPE get_PrerollTime( 
            /* [retval][out] */ __RPC__out REFTIME *pllTime) = 0;
        
        virtual /* [propput] */ HRESULT STDMETHODCALLTYPE put_PrerollTime( 
            /* [in] */ REFTIME llTime) = 0;
        
        virtual /* [propput] */ HRESULT STDMETHODCALLTYPE put_Rate( 
            /* [in] */ double dRate) = 0;
        
        virtual /* [propget] */ HRESULT STDMETHODCALLTYPE get_Rate( 
            /* [retval][out] */ __RPC__out double *pdRate) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE CanSeekForward( 
            /* [retval][out] */ __RPC__out LONG *pCanSeekForward) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE CanSeekBackward( 
            /* [retval][out] */ __RPC__out LONG *pCanSeekBackward) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IMediaPositionVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IMediaPosition * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IMediaPosition * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IMediaPosition * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfoCount )( 
            IMediaPosition * This,
            /* [out] */ __RPC__out UINT *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfo )( 
            IMediaPosition * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ __RPC__deref_out_opt ITypeInfo **ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetIDsOfNames )( 
            IMediaPosition * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [size_is][in] */ __RPC__in_ecount_full(cNames) LPOLESTR *rgszNames,
            /* [range][in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ __RPC__out_ecount_full(cNames) DISPID *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE *Invoke )( 
            IMediaPosition * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS *pDispParams,
            /* [out] */ VARIANT *pVarResult,
            /* [out] */ EXCEPINFO *pExcepInfo,
            /* [out] */ UINT *puArgErr);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_Duration )( 
            IMediaPosition * This,
            /* [retval][out] */ __RPC__out REFTIME *plength);
        
        /* [propput] */ HRESULT ( STDMETHODCALLTYPE *put_CurrentPosition )( 
            IMediaPosition * This,
            /* [in] */ REFTIME llTime);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_CurrentPosition )( 
            IMediaPosition * This,
            /* [retval][out] */ __RPC__out REFTIME *pllTime);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_StopTime )( 
            IMediaPosition * This,
            /* [retval][out] */ __RPC__out REFTIME *pllTime);
        
        /* [propput] */ HRESULT ( STDMETHODCALLTYPE *put_StopTime )( 
            IMediaPosition * This,
            /* [in] */ REFTIME llTime);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_PrerollTime )( 
            IMediaPosition * This,
            /* [retval][out] */ __RPC__out REFTIME *pllTime);
        
        /* [propput] */ HRESULT ( STDMETHODCALLTYPE *put_PrerollTime )( 
            IMediaPosition * This,
            /* [in] */ REFTIME llTime);
        
        /* [propput] */ HRESULT ( STDMETHODCALLTYPE *put_Rate )( 
            IMediaPosition * This,
            /* [in] */ double dRate);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_Rate )( 
            IMediaPosition * This,
            /* [retval][out] */ __RPC__out double *pdRate);
        
        HRESULT ( STDMETHODCALLTYPE *CanSeekForward )( 
            IMediaPosition * This,
            /* [retval][out] */ __RPC__out LONG *pCanSeekForward);
        
        HRESULT ( STDMETHODCALLTYPE *CanSeekBackward )( 
            IMediaPosition * This,
            /* [retval][out] */ __RPC__out LONG *pCanSeekBackward);
        
        END_INTERFACE
    } IMediaPositionVtbl;

    interface IMediaPosition
    {
        CONST_VTBL struct IMediaPositionVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IMediaPosition_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IMediaPosition_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IMediaPosition_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IMediaPosition_GetTypeInfoCount(This,pctinfo)	\
    ( (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo) ) 

#define IMediaPosition_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    ( (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo) ) 

#define IMediaPosition_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    ( (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId) ) 

#define IMediaPosition_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    ( (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr) ) 


#define IMediaPosition_get_Duration(This,plength)	\
    ( (This)->lpVtbl -> get_Duration(This,plength) ) 

#define IMediaPosition_put_CurrentPosition(This,llTime)	\
    ( (This)->lpVtbl -> put_CurrentPosition(This,llTime) ) 

#define IMediaPosition_get_CurrentPosition(This,pllTime)	\
    ( (This)->lpVtbl -> get_CurrentPosition(This,pllTime) ) 

#define IMediaPosition_get_StopTime(This,pllTime)	\
    ( (This)->lpVtbl -> get_StopTime(This,pllTime) ) 

#define IMediaPosition_put_StopTime(This,llTime)	\
    ( (This)->lpVtbl -> put_StopTime(This,llTime) ) 

#define IMediaPosition_get_PrerollTime(This,pllTime)	\
    ( (This)->lpVtbl -> get_PrerollTime(This,pllTime) ) 

#define IMediaPosition_put_PrerollTime(This,llTime)	\
    ( (This)->lpVtbl -> put_PrerollTime(This,llTime) ) 

#define IMediaPosition_put_Rate(This,dRate)	\
    ( (This)->lpVtbl -> put_Rate(This,dRate) ) 

#define IMediaPosition_get_Rate(This,pdRate)	\
    ( (This)->lpVtbl -> get_Rate(This,pdRate) ) 

#define IMediaPosition_CanSeekForward(This,pCanSeekForward)	\
    ( (This)->lpVtbl -> CanSeekForward(This,pCanSeekForward) ) 

#define IMediaPosition_CanSeekBackward(This,pCanSeekBackward)	\
    ( (This)->lpVtbl -> CanSeekBackward(This,pCanSeekBackward) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IMediaPosition_INTERFACE_DEFINED__ */


#ifndef __IBasicAudio_INTERFACE_DEFINED__
#define __IBasicAudio_INTERFACE_DEFINED__

/* interface IBasicAudio */
/* [object][dual][oleautomation][helpstring][uuid] */ 


DEFINE_GUID(IID_IBasicAudio,0x56a868b3,0x0ad4,0x11ce,0xb0,0x3a,0x00,0x20,0xaf,0x0b,0xa7,0x70);

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("56a868b3-0ad4-11ce-b03a-0020af0ba770")
    IBasicAudio : public IDispatch
    {
    public:
        virtual /* [propput] */ HRESULT STDMETHODCALLTYPE put_Volume( 
            /* [in] */ long lVolume) = 0;
        
        virtual /* [propget] */ HRESULT STDMETHODCALLTYPE get_Volume( 
            /* [retval][out] */ __RPC__out long *plVolume) = 0;
        
        virtual /* [propput] */ HRESULT STDMETHODCALLTYPE put_Balance( 
            /* [in] */ long lBalance) = 0;
        
        virtual /* [propget] */ HRESULT STDMETHODCALLTYPE get_Balance( 
            /* [retval][out] */ __RPC__out long *plBalance) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IBasicAudioVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IBasicAudio * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IBasicAudio * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IBasicAudio * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfoCount )( 
            IBasicAudio * This,
            /* [out] */ __RPC__out UINT *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfo )( 
            IBasicAudio * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ __RPC__deref_out_opt ITypeInfo **ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetIDsOfNames )( 
            IBasicAudio * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [size_is][in] */ __RPC__in_ecount_full(cNames) LPOLESTR *rgszNames,
            /* [range][in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ __RPC__out_ecount_full(cNames) DISPID *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE *Invoke )( 
            IBasicAudio * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS *pDispParams,
            /* [out] */ VARIANT *pVarResult,
            /* [out] */ EXCEPINFO *pExcepInfo,
            /* [out] */ UINT *puArgErr);
        
        /* [propput] */ HRESULT ( STDMETHODCALLTYPE *put_Volume )( 
            IBasicAudio * This,
            /* [in] */ long lVolume);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_Volume )( 
            IBasicAudio * This,
            /* [retval][out] */ __RPC__out long *plVolume);
        
        /* [propput] */ HRESULT ( STDMETHODCALLTYPE *put_Balance )( 
            IBasicAudio * This,
            /* [in] */ long lBalance);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_Balance )( 
            IBasicAudio * This,
            /* [retval][out] */ __RPC__out long *plBalance);
        
        END_INTERFACE
    } IBasicAudioVtbl;

    interface IBasicAudio
    {
        CONST_VTBL struct IBasicAudioVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IBasicAudio_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IBasicAudio_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IBasicAudio_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IBasicAudio_GetTypeInfoCount(This,pctinfo)	\
    ( (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo) ) 

#define IBasicAudio_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    ( (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo) ) 

#define IBasicAudio_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    ( (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId) ) 

#define IBasicAudio_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    ( (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr) ) 


#define IBasicAudio_put_Volume(This,lVolume)	\
    ( (This)->lpVtbl -> put_Volume(This,lVolume) ) 

#define IBasicAudio_get_Volume(This,plVolume)	\
    ( (This)->lpVtbl -> get_Volume(This,plVolume) ) 

#define IBasicAudio_put_Balance(This,lBalance)	\
    ( (This)->lpVtbl -> put_Balance(This,lBalance) ) 

#define IBasicAudio_get_Balance(This,plBalance)	\
    ( (This)->lpVtbl -> get_Balance(This,plBalance) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IBasicAudio_INTERFACE_DEFINED__ */


#ifndef __IVideoWindow_INTERFACE_DEFINED__
#define __IVideoWindow_INTERFACE_DEFINED__

/* interface IVideoWindow */
/* [object][dual][oleautomation][helpstring][uuid] */ 


DEFINE_GUID(IID_IVideoWindow,0x56a868b4,0x0ad4,0x11ce,0xb0,0x3a,0x00,0x20,0xaf,0x0b,0xa7,0x70);

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("56a868b4-0ad4-11ce-b03a-0020af0ba770")
    IVideoWindow : public IDispatch
    {
    public:
        virtual /* [propput] */ HRESULT STDMETHODCALLTYPE put_Caption( 
            /* [in] */ __RPC__in BSTR strCaption) = 0;
        
        virtual /* [propget] */ HRESULT STDMETHODCALLTYPE get_Caption( 
            /* [retval][out] */ __RPC__deref_out_opt BSTR *strCaption) = 0;
        
        virtual /* [propput] */ HRESULT STDMETHODCALLTYPE put_WindowStyle( 
            /* [in] */ long WindowStyle) = 0;
        
        virtual /* [propget] */ HRESULT STDMETHODCALLTYPE get_WindowStyle( 
            /* [retval][out] */ __RPC__out long *WindowStyle) = 0;
        
        virtual /* [propput] */ HRESULT STDMETHODCALLTYPE put_WindowStyleEx( 
            /* [in] */ long WindowStyleEx) = 0;
        
        virtual /* [propget] */ HRESULT STDMETHODCALLTYPE get_WindowStyleEx( 
            /* [retval][out] */ __RPC__out long *WindowStyleEx) = 0;
        
        virtual /* [propput] */ HRESULT STDMETHODCALLTYPE put_AutoShow( 
            /* [in] */ long AutoShow) = 0;
        
        virtual /* [propget] */ HRESULT STDMETHODCALLTYPE get_AutoShow( 
            /* [retval][out] */ __RPC__out long *AutoShow) = 0;
        
        virtual /* [propput] */ HRESULT STDMETHODCALLTYPE put_WindowState( 
            /* [in] */ long WindowState) = 0;
        
        virtual /* [propget] */ HRESULT STDMETHODCALLTYPE get_WindowState( 
            /* [retval][out] */ __RPC__out long *WindowState) = 0;
        
        virtual /* [propput] */ HRESULT STDMETHODCALLTYPE put_BackgroundPalette( 
            /* [in] */ long BackgroundPalette) = 0;
        
        virtual /* [propget] */ HRESULT STDMETHODCALLTYPE get_BackgroundPalette( 
            /* [retval][out] */ __RPC__out long *pBackgroundPalette) = 0;
        
        virtual /* [propput] */ HRESULT STDMETHODCALLTYPE put_Visible( 
            /* [in] */ long Visible) = 0;
        
        virtual /* [propget] */ HRESULT STDMETHODCALLTYPE get_Visible( 
            /* [retval][out] */ __RPC__out long *pVisible) = 0;
        
        virtual /* [propput] */ HRESULT STDMETHODCALLTYPE put_Left( 
            /* [in] */ long Left) = 0;
        
        virtual /* [propget] */ HRESULT STDMETHODCALLTYPE get_Left( 
            /* [retval][out] */ __RPC__out long *pLeft) = 0;
        
        virtual /* [propput] */ HRESULT STDMETHODCALLTYPE put_Width( 
            /* [in] */ long Width) = 0;
        
        virtual /* [propget] */ HRESULT STDMETHODCALLTYPE get_Width( 
            /* [retval][out] */ __RPC__out long *pWidth) = 0;
        
        virtual /* [propput] */ HRESULT STDMETHODCALLTYPE put_Top( 
            /* [in] */ long Top) = 0;
        
        virtual /* [propget] */ HRESULT STDMETHODCALLTYPE get_Top( 
            /* [retval][out] */ __RPC__out long *pTop) = 0;
        
        virtual /* [propput] */ HRESULT STDMETHODCALLTYPE put_Height( 
            /* [in] */ long Height) = 0;
        
        virtual /* [propget] */ HRESULT STDMETHODCALLTYPE get_Height( 
            /* [retval][out] */ __RPC__out long *pHeight) = 0;
        
        virtual /* [propput] */ HRESULT STDMETHODCALLTYPE put_Owner( 
            /* [in] */ OAHWND Owner) = 0;
        
        virtual /* [propget] */ HRESULT STDMETHODCALLTYPE get_Owner( 
            /* [retval][out] */ __RPC__out OAHWND *Owner) = 0;
        
        virtual /* [propput] */ HRESULT STDMETHODCALLTYPE put_MessageDrain( 
            /* [in] */ OAHWND Drain) = 0;
        
        virtual /* [propget] */ HRESULT STDMETHODCALLTYPE get_MessageDrain( 
            /* [retval][out] */ __RPC__out OAHWND *Drain) = 0;
        
        virtual /* [propget] */ HRESULT STDMETHODCALLTYPE get_BorderColor( 
            /* [retval][out] */ __RPC__out long *Color) = 0;
        
        virtual /* [propput] */ HRESULT STDMETHODCALLTYPE put_BorderColor( 
            /* [in] */ long Color) = 0;
        
        virtual /* [propget] */ HRESULT STDMETHODCALLTYPE get_FullScreenMode( 
            /* [retval][out] */ __RPC__out long *FullScreenMode) = 0;
        
        virtual /* [propput] */ HRESULT STDMETHODCALLTYPE put_FullScreenMode( 
            /* [in] */ long FullScreenMode) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetWindowForeground( 
            /* [in] */ long Focus) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE NotifyOwnerMessage( 
            /* [in] */ OAHWND hwnd,
            /* [in] */ long uMsg,
            /* [in] */ LONG_PTR wParam,
            /* [in] */ LONG_PTR lParam) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetWindowPosition( 
            /* [in] */ long Left,
            /* [in] */ long Top,
            /* [in] */ long Width,
            /* [in] */ long Height) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetWindowPosition( 
            /* [out] */ __RPC__out long *pLeft,
            /* [out] */ __RPC__out long *pTop,
            /* [out] */ __RPC__out long *pWidth,
            /* [out] */ __RPC__out long *pHeight) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetMinIdealImageSize( 
            /* [out] */ __RPC__out long *pWidth,
            /* [out] */ __RPC__out long *pHeight) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetMaxIdealImageSize( 
            /* [out] */ __RPC__out long *pWidth,
            /* [out] */ __RPC__out long *pHeight) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetRestorePosition( 
            /* [out] */ __RPC__out long *pLeft,
            /* [out] */ __RPC__out long *pTop,
            /* [out] */ __RPC__out long *pWidth,
            /* [out] */ __RPC__out long *pHeight) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE HideCursor( 
            /* [in] */ long HideCursor) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE IsCursorHidden( 
            /* [out] */ __RPC__out long *CursorHidden) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IVideoWindowVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IVideoWindow * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IVideoWindow * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IVideoWindow * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfoCount )( 
            IVideoWindow * This,
            /* [out] */ __RPC__out UINT *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfo )( 
            IVideoWindow * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ __RPC__deref_out_opt ITypeInfo **ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetIDsOfNames )( 
            IVideoWindow * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [size_is][in] */ __RPC__in_ecount_full(cNames) LPOLESTR *rgszNames,
            /* [range][in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ __RPC__out_ecount_full(cNames) DISPID *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE *Invoke )( 
            IVideoWindow * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS *pDispParams,
            /* [out] */ VARIANT *pVarResult,
            /* [out] */ EXCEPINFO *pExcepInfo,
            /* [out] */ UINT *puArgErr);
        
        /* [propput] */ HRESULT ( STDMETHODCALLTYPE *put_Caption )( 
            IVideoWindow * This,
            /* [in] */ __RPC__in BSTR strCaption);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_Caption )( 
            IVideoWindow * This,
            /* [retval][out] */ __RPC__deref_out_opt BSTR *strCaption);
        
        /* [propput] */ HRESULT ( STDMETHODCALLTYPE *put_WindowStyle )( 
            IVideoWindow * This,
            /* [in] */ long WindowStyle);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_WindowStyle )( 
            IVideoWindow * This,
            /* [retval][out] */ __RPC__out long *WindowStyle);
        
        /* [propput] */ HRESULT ( STDMETHODCALLTYPE *put_WindowStyleEx )( 
            IVideoWindow * This,
            /* [in] */ long WindowStyleEx);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_WindowStyleEx )( 
            IVideoWindow * This,
            /* [retval][out] */ __RPC__out long *WindowStyleEx);
        
        /* [propput] */ HRESULT ( STDMETHODCALLTYPE *put_AutoShow )( 
            IVideoWindow * This,
            /* [in] */ long AutoShow);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_AutoShow )( 
            IVideoWindow * This,
            /* [retval][out] */ __RPC__out long *AutoShow);
        
        /* [propput] */ HRESULT ( STDMETHODCALLTYPE *put_WindowState )( 
            IVideoWindow * This,
            /* [in] */ long WindowState);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_WindowState )( 
            IVideoWindow * This,
            /* [retval][out] */ __RPC__out long *WindowState);
        
        /* [propput] */ HRESULT ( STDMETHODCALLTYPE *put_BackgroundPalette )( 
            IVideoWindow * This,
            /* [in] */ long BackgroundPalette);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_BackgroundPalette )( 
            IVideoWindow * This,
            /* [retval][out] */ __RPC__out long *pBackgroundPalette);
        
        /* [propput] */ HRESULT ( STDMETHODCALLTYPE *put_Visible )( 
            IVideoWindow * This,
            /* [in] */ long Visible);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_Visible )( 
            IVideoWindow * This,
            /* [retval][out] */ __RPC__out long *pVisible);
        
        /* [propput] */ HRESULT ( STDMETHODCALLTYPE *put_Left )( 
            IVideoWindow * This,
            /* [in] */ long Left);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_Left )( 
            IVideoWindow * This,
            /* [retval][out] */ __RPC__out long *pLeft);
        
        /* [propput] */ HRESULT ( STDMETHODCALLTYPE *put_Width )( 
            IVideoWindow * This,
            /* [in] */ long Width);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_Width )( 
            IVideoWindow * This,
            /* [retval][out] */ __RPC__out long *pWidth);
        
        /* [propput] */ HRESULT ( STDMETHODCALLTYPE *put_Top )( 
            IVideoWindow * This,
            /* [in] */ long Top);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_Top )( 
            IVideoWindow * This,
            /* [retval][out] */ __RPC__out long *pTop);
        
        /* [propput] */ HRESULT ( STDMETHODCALLTYPE *put_Height )( 
            IVideoWindow * This,
            /* [in] */ long Height);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_Height )( 
            IVideoWindow * This,
            /* [retval][out] */ __RPC__out long *pHeight);
        
        /* [propput] */ HRESULT ( STDMETHODCALLTYPE *put_Owner )( 
            IVideoWindow * This,
            /* [in] */ OAHWND Owner);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_Owner )( 
            IVideoWindow * This,
            /* [retval][out] */ __RPC__out OAHWND *Owner);
        
        /* [propput] */ HRESULT ( STDMETHODCALLTYPE *put_MessageDrain )( 
            IVideoWindow * This,
            /* [in] */ OAHWND Drain);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_MessageDrain )( 
            IVideoWindow * This,
            /* [retval][out] */ __RPC__out OAHWND *Drain);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_BorderColor )( 
            IVideoWindow * This,
            /* [retval][out] */ __RPC__out long *Color);
        
        /* [propput] */ HRESULT ( STDMETHODCALLTYPE *put_BorderColor )( 
            IVideoWindow * This,
            /* [in] */ long Color);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_FullScreenMode )( 
            IVideoWindow * This,
            /* [retval][out] */ __RPC__out long *FullScreenMode);
        
        /* [propput] */ HRESULT ( STDMETHODCALLTYPE *put_FullScreenMode )( 
            IVideoWindow * This,
            /* [in] */ long FullScreenMode);
        
        HRESULT ( STDMETHODCALLTYPE *SetWindowForeground )( 
            IVideoWindow * This,
            /* [in] */ long Focus);
        
        HRESULT ( STDMETHODCALLTYPE *NotifyOwnerMessage )( 
            IVideoWindow * This,
            /* [in] */ OAHWND hwnd,
            /* [in] */ long uMsg,
            /* [in] */ LONG_PTR wParam,
            /* [in] */ LONG_PTR lParam);
        
        HRESULT ( STDMETHODCALLTYPE *SetWindowPosition )( 
            IVideoWindow * This,
            /* [in] */ long Left,
            /* [in] */ long Top,
            /* [in] */ long Width,
            /* [in] */ long Height);
        
        HRESULT ( STDMETHODCALLTYPE *GetWindowPosition )( 
            IVideoWindow * This,
            /* [out] */ __RPC__out long *pLeft,
            /* [out] */ __RPC__out long *pTop,
            /* [out] */ __RPC__out long *pWidth,
            /* [out] */ __RPC__out long *pHeight);
        
        HRESULT ( STDMETHODCALLTYPE *GetMinIdealImageSize )( 
            IVideoWindow * This,
            /* [out] */ __RPC__out long *pWidth,
            /* [out] */ __RPC__out long *pHeight);
        
        HRESULT ( STDMETHODCALLTYPE *GetMaxIdealImageSize )( 
            IVideoWindow * This,
            /* [out] */ __RPC__out long *pWidth,
            /* [out] */ __RPC__out long *pHeight);
        
        HRESULT ( STDMETHODCALLTYPE *GetRestorePosition )( 
            IVideoWindow * This,
            /* [out] */ __RPC__out long *pLeft,
            /* [out] */ __RPC__out long *pTop,
            /* [out] */ __RPC__out long *pWidth,
            /* [out] */ __RPC__out long *pHeight);
        
        HRESULT ( STDMETHODCALLTYPE *HideCursor )( 
            IVideoWindow * This,
            /* [in] */ long HideCursor);
        
        HRESULT ( STDMETHODCALLTYPE *IsCursorHidden )( 
            IVideoWindow * This,
            /* [out] */ __RPC__out long *CursorHidden);
        
        END_INTERFACE
    } IVideoWindowVtbl;

    interface IVideoWindow
    {
        CONST_VTBL struct IVideoWindowVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IVideoWindow_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IVideoWindow_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IVideoWindow_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IVideoWindow_GetTypeInfoCount(This,pctinfo)	\
    ( (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo) ) 

#define IVideoWindow_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    ( (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo) ) 

#define IVideoWindow_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    ( (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId) ) 

#define IVideoWindow_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    ( (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr) ) 


#define IVideoWindow_put_Caption(This,strCaption)	\
    ( (This)->lpVtbl -> put_Caption(This,strCaption) ) 

#define IVideoWindow_get_Caption(This,strCaption)	\
    ( (This)->lpVtbl -> get_Caption(This,strCaption) ) 

#define IVideoWindow_put_WindowStyle(This,WindowStyle)	\
    ( (This)->lpVtbl -> put_WindowStyle(This,WindowStyle) ) 

#define IVideoWindow_get_WindowStyle(This,WindowStyle)	\
    ( (This)->lpVtbl -> get_WindowStyle(This,WindowStyle) ) 

#define IVideoWindow_put_WindowStyleEx(This,WindowStyleEx)	\
    ( (This)->lpVtbl -> put_WindowStyleEx(This,WindowStyleEx) ) 

#define IVideoWindow_get_WindowStyleEx(This,WindowStyleEx)	\
    ( (This)->lpVtbl -> get_WindowStyleEx(This,WindowStyleEx) ) 

#define IVideoWindow_put_AutoShow(This,AutoShow)	\
    ( (This)->lpVtbl -> put_AutoShow(This,AutoShow) ) 

#define IVideoWindow_get_AutoShow(This,AutoShow)	\
    ( (This)->lpVtbl -> get_AutoShow(This,AutoShow) ) 

#define IVideoWindow_put_WindowState(This,WindowState)	\
    ( (This)->lpVtbl -> put_WindowState(This,WindowState) ) 

#define IVideoWindow_get_WindowState(This,WindowState)	\
    ( (This)->lpVtbl -> get_WindowState(This,WindowState) ) 

#define IVideoWindow_put_BackgroundPalette(This,BackgroundPalette)	\
    ( (This)->lpVtbl -> put_BackgroundPalette(This,BackgroundPalette) ) 

#define IVideoWindow_get_BackgroundPalette(This,pBackgroundPalette)	\
    ( (This)->lpVtbl -> get_BackgroundPalette(This,pBackgroundPalette) ) 

#define IVideoWindow_put_Visible(This,Visible)	\
    ( (This)->lpVtbl -> put_Visible(This,Visible) ) 

#define IVideoWindow_get_Visible(This,pVisible)	\
    ( (This)->lpVtbl -> get_Visible(This,pVisible) ) 

#define IVideoWindow_put_Left(This,Left)	\
    ( (This)->lpVtbl -> put_Left(This,Left) ) 

#define IVideoWindow_get_Left(This,pLeft)	\
    ( (This)->lpVtbl -> get_Left(This,pLeft) ) 

#define IVideoWindow_put_Width(This,Width)	\
    ( (This)->lpVtbl -> put_Width(This,Width) ) 

#define IVideoWindow_get_Width(This,pWidth)	\
    ( (This)->lpVtbl -> get_Width(This,pWidth) ) 

#define IVideoWindow_put_Top(This,Top)	\
    ( (This)->lpVtbl -> put_Top(This,Top) ) 

#define IVideoWindow_get_Top(This,pTop)	\
    ( (This)->lpVtbl -> get_Top(This,pTop) ) 

#define IVideoWindow_put_Height(This,Height)	\
    ( (This)->lpVtbl -> put_Height(This,Height) ) 

#define IVideoWindow_get_Height(This,pHeight)	\
    ( (This)->lpVtbl -> get_Height(This,pHeight) ) 

#define IVideoWindow_put_Owner(This,Owner)	\
    ( (This)->lpVtbl -> put_Owner(This,Owner) ) 

#define IVideoWindow_get_Owner(This,Owner)	\
    ( (This)->lpVtbl -> get_Owner(This,Owner) ) 

#define IVideoWindow_put_MessageDrain(This,Drain)	\
    ( (This)->lpVtbl -> put_MessageDrain(This,Drain) ) 

#define IVideoWindow_get_MessageDrain(This,Drain)	\
    ( (This)->lpVtbl -> get_MessageDrain(This,Drain) ) 

#define IVideoWindow_get_BorderColor(This,Color)	\
    ( (This)->lpVtbl -> get_BorderColor(This,Color) ) 

#define IVideoWindow_put_BorderColor(This,Color)	\
    ( (This)->lpVtbl -> put_BorderColor(This,Color) ) 

#define IVideoWindow_get_FullScreenMode(This,FullScreenMode)	\
    ( (This)->lpVtbl -> get_FullScreenMode(This,FullScreenMode) ) 

#define IVideoWindow_put_FullScreenMode(This,FullScreenMode)	\
    ( (This)->lpVtbl -> put_FullScreenMode(This,FullScreenMode) ) 

#define IVideoWindow_SetWindowForeground(This,Focus)	\
    ( (This)->lpVtbl -> SetWindowForeground(This,Focus) ) 

#define IVideoWindow_NotifyOwnerMessage(This,hwnd,uMsg,wParam,lParam)	\
    ( (This)->lpVtbl -> NotifyOwnerMessage(This,hwnd,uMsg,wParam,lParam) ) 

#define IVideoWindow_SetWindowPosition(This,Left,Top,Width,Height)	\
    ( (This)->lpVtbl -> SetWindowPosition(This,Left,Top,Width,Height) ) 

#define IVideoWindow_GetWindowPosition(This,pLeft,pTop,pWidth,pHeight)	\
    ( (This)->lpVtbl -> GetWindowPosition(This,pLeft,pTop,pWidth,pHeight) ) 

#define IVideoWindow_GetMinIdealImageSize(This,pWidth,pHeight)	\
    ( (This)->lpVtbl -> GetMinIdealImageSize(This,pWidth,pHeight) ) 

#define IVideoWindow_GetMaxIdealImageSize(This,pWidth,pHeight)	\
    ( (This)->lpVtbl -> GetMaxIdealImageSize(This,pWidth,pHeight) ) 

#define IVideoWindow_GetRestorePosition(This,pLeft,pTop,pWidth,pHeight)	\
    ( (This)->lpVtbl -> GetRestorePosition(This,pLeft,pTop,pWidth,pHeight) ) 

#define IVideoWindow_HideCursor(This,HideCursor)	\
    ( (This)->lpVtbl -> HideCursor(This,HideCursor) ) 

#define IVideoWindow_IsCursorHidden(This,CursorHidden)	\
    ( (This)->lpVtbl -> IsCursorHidden(This,CursorHidden) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IVideoWindow_INTERFACE_DEFINED__ */


#ifndef __IBasicVideo_INTERFACE_DEFINED__
#define __IBasicVideo_INTERFACE_DEFINED__

/* interface IBasicVideo */
/* [object][dual][oleautomation][helpstring][uuid] */ 


DEFINE_GUID(IID_IBasicVideo,0x56a868b5,0x0ad4,0x11ce,0xb0,0x3a,0x00,0x20,0xaf,0x0b,0xa7,0x70);

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("56a868b5-0ad4-11ce-b03a-0020af0ba770")
    IBasicVideo : public IDispatch
    {
    public:
        virtual /* [propget] */ HRESULT STDMETHODCALLTYPE get_AvgTimePerFrame( 
            /* [retval][out] */ __RPC__out REFTIME *pAvgTimePerFrame) = 0;
        
        virtual /* [propget] */ HRESULT STDMETHODCALLTYPE get_BitRate( 
            /* [retval][out] */ __RPC__out long *pBitRate) = 0;
        
        virtual /* [propget] */ HRESULT STDMETHODCALLTYPE get_BitErrorRate( 
            /* [retval][out] */ __RPC__out long *pBitErrorRate) = 0;
        
        virtual /* [propget] */ HRESULT STDMETHODCALLTYPE get_VideoWidth( 
            /* [retval][out] */ __RPC__out long *pVideoWidth) = 0;
        
        virtual /* [propget] */ HRESULT STDMETHODCALLTYPE get_VideoHeight( 
            /* [retval][out] */ __RPC__out long *pVideoHeight) = 0;
        
        virtual /* [propput] */ HRESULT STDMETHODCALLTYPE put_SourceLeft( 
            /* [in] */ long SourceLeft) = 0;
        
        virtual /* [propget] */ HRESULT STDMETHODCALLTYPE get_SourceLeft( 
            /* [retval][out] */ __RPC__out long *pSourceLeft) = 0;
        
        virtual /* [propput] */ HRESULT STDMETHODCALLTYPE put_SourceWidth( 
            /* [in] */ long SourceWidth) = 0;
        
        virtual /* [propget] */ HRESULT STDMETHODCALLTYPE get_SourceWidth( 
            /* [retval][out] */ __RPC__out long *pSourceWidth) = 0;
        
        virtual /* [propput] */ HRESULT STDMETHODCALLTYPE put_SourceTop( 
            /* [in] */ long SourceTop) = 0;
        
        virtual /* [propget] */ HRESULT STDMETHODCALLTYPE get_SourceTop( 
            /* [retval][out] */ __RPC__out long *pSourceTop) = 0;
        
        virtual /* [propput] */ HRESULT STDMETHODCALLTYPE put_SourceHeight( 
            /* [in] */ long SourceHeight) = 0;
        
        virtual /* [propget] */ HRESULT STDMETHODCALLTYPE get_SourceHeight( 
            /* [retval][out] */ __RPC__out long *pSourceHeight) = 0;
        
        virtual /* [propput] */ HRESULT STDMETHODCALLTYPE put_DestinationLeft( 
            /* [in] */ long DestinationLeft) = 0;
        
        virtual /* [propget] */ HRESULT STDMETHODCALLTYPE get_DestinationLeft( 
            /* [retval][out] */ __RPC__out long *pDestinationLeft) = 0;
        
        virtual /* [propput] */ HRESULT STDMETHODCALLTYPE put_DestinationWidth( 
            /* [in] */ long DestinationWidth) = 0;
        
        virtual /* [propget] */ HRESULT STDMETHODCALLTYPE get_DestinationWidth( 
            /* [retval][out] */ __RPC__out long *pDestinationWidth) = 0;
        
        virtual /* [propput] */ HRESULT STDMETHODCALLTYPE put_DestinationTop( 
            /* [in] */ long DestinationTop) = 0;
        
        virtual /* [propget] */ HRESULT STDMETHODCALLTYPE get_DestinationTop( 
            /* [retval][out] */ __RPC__out long *pDestinationTop) = 0;
        
        virtual /* [propput] */ HRESULT STDMETHODCALLTYPE put_DestinationHeight( 
            /* [in] */ long DestinationHeight) = 0;
        
        virtual /* [propget] */ HRESULT STDMETHODCALLTYPE get_DestinationHeight( 
            /* [retval][out] */ __RPC__out long *pDestinationHeight) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetSourcePosition( 
            /* [in] */ long Left,
            /* [in] */ long Top,
            /* [in] */ long Width,
            /* [in] */ long Height) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetSourcePosition( 
            /* [out] */ __RPC__out long *pLeft,
            /* [out] */ __RPC__out long *pTop,
            /* [out] */ __RPC__out long *pWidth,
            /* [out] */ __RPC__out long *pHeight) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetDefaultSourcePosition( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetDestinationPosition( 
            /* [in] */ long Left,
            /* [in] */ long Top,
            /* [in] */ long Width,
            /* [in] */ long Height) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetDestinationPosition( 
            /* [out] */ __RPC__out long *pLeft,
            /* [out] */ __RPC__out long *pTop,
            /* [out] */ __RPC__out long *pWidth,
            /* [out] */ __RPC__out long *pHeight) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetDefaultDestinationPosition( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetVideoSize( 
            /* [out] */ __RPC__out long *pWidth,
            /* [out] */ __RPC__out long *pHeight) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetVideoPaletteEntries( 
            /* [in] */ long StartIndex,
            /* [in] */ long Entries,
            /* [out] */ __RPC__out long *pRetrieved,
            /* [out] */ __RPC__out long *pPalette) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetCurrentImage( 
            /* [out][in] */ __RPC__inout long *pBufferSize,
            /* [out] */ __RPC__out long *pDIBImage) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE IsUsingDefaultSource( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE IsUsingDefaultDestination( void) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IBasicVideoVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IBasicVideo * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IBasicVideo * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IBasicVideo * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfoCount )( 
            IBasicVideo * This,
            /* [out] */ __RPC__out UINT *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfo )( 
            IBasicVideo * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ __RPC__deref_out_opt ITypeInfo **ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetIDsOfNames )( 
            IBasicVideo * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [size_is][in] */ __RPC__in_ecount_full(cNames) LPOLESTR *rgszNames,
            /* [range][in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ __RPC__out_ecount_full(cNames) DISPID *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE *Invoke )( 
            IBasicVideo * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS *pDispParams,
            /* [out] */ VARIANT *pVarResult,
            /* [out] */ EXCEPINFO *pExcepInfo,
            /* [out] */ UINT *puArgErr);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_AvgTimePerFrame )( 
            IBasicVideo * This,
            /* [retval][out] */ __RPC__out REFTIME *pAvgTimePerFrame);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_BitRate )( 
            IBasicVideo * This,
            /* [retval][out] */ __RPC__out long *pBitRate);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_BitErrorRate )( 
            IBasicVideo * This,
            /* [retval][out] */ __RPC__out long *pBitErrorRate);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_VideoWidth )( 
            IBasicVideo * This,
            /* [retval][out] */ __RPC__out long *pVideoWidth);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_VideoHeight )( 
            IBasicVideo * This,
            /* [retval][out] */ __RPC__out long *pVideoHeight);
        
        /* [propput] */ HRESULT ( STDMETHODCALLTYPE *put_SourceLeft )( 
            IBasicVideo * This,
            /* [in] */ long SourceLeft);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_SourceLeft )( 
            IBasicVideo * This,
            /* [retval][out] */ __RPC__out long *pSourceLeft);
        
        /* [propput] */ HRESULT ( STDMETHODCALLTYPE *put_SourceWidth )( 
            IBasicVideo * This,
            /* [in] */ long SourceWidth);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_SourceWidth )( 
            IBasicVideo * This,
            /* [retval][out] */ __RPC__out long *pSourceWidth);
        
        /* [propput] */ HRESULT ( STDMETHODCALLTYPE *put_SourceTop )( 
            IBasicVideo * This,
            /* [in] */ long SourceTop);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_SourceTop )( 
            IBasicVideo * This,
            /* [retval][out] */ __RPC__out long *pSourceTop);
        
        /* [propput] */ HRESULT ( STDMETHODCALLTYPE *put_SourceHeight )( 
            IBasicVideo * This,
            /* [in] */ long SourceHeight);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_SourceHeight )( 
            IBasicVideo * This,
            /* [retval][out] */ __RPC__out long *pSourceHeight);
        
        /* [propput] */ HRESULT ( STDMETHODCALLTYPE *put_DestinationLeft )( 
            IBasicVideo * This,
            /* [in] */ long DestinationLeft);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_DestinationLeft )( 
            IBasicVideo * This,
            /* [retval][out] */ __RPC__out long *pDestinationLeft);
        
        /* [propput] */ HRESULT ( STDMETHODCALLTYPE *put_DestinationWidth )( 
            IBasicVideo * This,
            /* [in] */ long DestinationWidth);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_DestinationWidth )( 
            IBasicVideo * This,
            /* [retval][out] */ __RPC__out long *pDestinationWidth);
        
        /* [propput] */ HRESULT ( STDMETHODCALLTYPE *put_DestinationTop )( 
            IBasicVideo * This,
            /* [in] */ long DestinationTop);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_DestinationTop )( 
            IBasicVideo * This,
            /* [retval][out] */ __RPC__out long *pDestinationTop);
        
        /* [propput] */ HRESULT ( STDMETHODCALLTYPE *put_DestinationHeight )( 
            IBasicVideo * This,
            /* [in] */ long DestinationHeight);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_DestinationHeight )( 
            IBasicVideo * This,
            /* [retval][out] */ __RPC__out long *pDestinationHeight);
        
        HRESULT ( STDMETHODCALLTYPE *SetSourcePosition )( 
            IBasicVideo * This,
            /* [in] */ long Left,
            /* [in] */ long Top,
            /* [in] */ long Width,
            /* [in] */ long Height);
        
        HRESULT ( STDMETHODCALLTYPE *GetSourcePosition )( 
            IBasicVideo * This,
            /* [out] */ __RPC__out long *pLeft,
            /* [out] */ __RPC__out long *pTop,
            /* [out] */ __RPC__out long *pWidth,
            /* [out] */ __RPC__out long *pHeight);
        
        HRESULT ( STDMETHODCALLTYPE *SetDefaultSourcePosition )( 
            IBasicVideo * This);
        
        HRESULT ( STDMETHODCALLTYPE *SetDestinationPosition )( 
            IBasicVideo * This,
            /* [in] */ long Left,
            /* [in] */ long Top,
            /* [in] */ long Width,
            /* [in] */ long Height);
        
        HRESULT ( STDMETHODCALLTYPE *GetDestinationPosition )( 
            IBasicVideo * This,
            /* [out] */ __RPC__out long *pLeft,
            /* [out] */ __RPC__out long *pTop,
            /* [out] */ __RPC__out long *pWidth,
            /* [out] */ __RPC__out long *pHeight);
        
        HRESULT ( STDMETHODCALLTYPE *SetDefaultDestinationPosition )( 
            IBasicVideo * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetVideoSize )( 
            IBasicVideo * This,
            /* [out] */ __RPC__out long *pWidth,
            /* [out] */ __RPC__out long *pHeight);
        
        HRESULT ( STDMETHODCALLTYPE *GetVideoPaletteEntries )( 
            IBasicVideo * This,
            /* [in] */ long StartIndex,
            /* [in] */ long Entries,
            /* [out] */ __RPC__out long *pRetrieved,
            /* [out] */ __RPC__out long *pPalette);
        
        HRESULT ( STDMETHODCALLTYPE *GetCurrentImage )( 
            IBasicVideo * This,
            /* [out][in] */ __RPC__inout long *pBufferSize,
            /* [out] */ __RPC__out long *pDIBImage);
        
        HRESULT ( STDMETHODCALLTYPE *IsUsingDefaultSource )( 
            IBasicVideo * This);
        
        HRESULT ( STDMETHODCALLTYPE *IsUsingDefaultDestination )( 
            IBasicVideo * This);
        
        END_INTERFACE
    } IBasicVideoVtbl;

    interface IBasicVideo
    {
        CONST_VTBL struct IBasicVideoVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IBasicVideo_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IBasicVideo_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IBasicVideo_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IBasicVideo_GetTypeInfoCount(This,pctinfo)	\
    ( (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo) ) 

#define IBasicVideo_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    ( (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo) ) 

#define IBasicVideo_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    ( (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId) ) 

#define IBasicVideo_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    ( (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr) ) 


#define IBasicVideo_get_AvgTimePerFrame(This,pAvgTimePerFrame)	\
    ( (This)->lpVtbl -> get_AvgTimePerFrame(This,pAvgTimePerFrame) ) 

#define IBasicVideo_get_BitRate(This,pBitRate)	\
    ( (This)->lpVtbl -> get_BitRate(This,pBitRate) ) 

#define IBasicVideo_get_BitErrorRate(This,pBitErrorRate)	\
    ( (This)->lpVtbl -> get_BitErrorRate(This,pBitErrorRate) ) 

#define IBasicVideo_get_VideoWidth(This,pVideoWidth)	\
    ( (This)->lpVtbl -> get_VideoWidth(This,pVideoWidth) ) 

#define IBasicVideo_get_VideoHeight(This,pVideoHeight)	\
    ( (This)->lpVtbl -> get_VideoHeight(This,pVideoHeight) ) 

#define IBasicVideo_put_SourceLeft(This,SourceLeft)	\
    ( (This)->lpVtbl -> put_SourceLeft(This,SourceLeft) ) 

#define IBasicVideo_get_SourceLeft(This,pSourceLeft)	\
    ( (This)->lpVtbl -> get_SourceLeft(This,pSourceLeft) ) 

#define IBasicVideo_put_SourceWidth(This,SourceWidth)	\
    ( (This)->lpVtbl -> put_SourceWidth(This,SourceWidth) ) 

#define IBasicVideo_get_SourceWidth(This,pSourceWidth)	\
    ( (This)->lpVtbl -> get_SourceWidth(This,pSourceWidth) ) 

#define IBasicVideo_put_SourceTop(This,SourceTop)	\
    ( (This)->lpVtbl -> put_SourceTop(This,SourceTop) ) 

#define IBasicVideo_get_SourceTop(This,pSourceTop)	\
    ( (This)->lpVtbl -> get_SourceTop(This,pSourceTop) ) 

#define IBasicVideo_put_SourceHeight(This,SourceHeight)	\
    ( (This)->lpVtbl -> put_SourceHeight(This,SourceHeight) ) 

#define IBasicVideo_get_SourceHeight(This,pSourceHeight)	\
    ( (This)->lpVtbl -> get_SourceHeight(This,pSourceHeight) ) 

#define IBasicVideo_put_DestinationLeft(This,DestinationLeft)	\
    ( (This)->lpVtbl -> put_DestinationLeft(This,DestinationLeft) ) 

#define IBasicVideo_get_DestinationLeft(This,pDestinationLeft)	\
    ( (This)->lpVtbl -> get_DestinationLeft(This,pDestinationLeft) ) 

#define IBasicVideo_put_DestinationWidth(This,DestinationWidth)	\
    ( (This)->lpVtbl -> put_DestinationWidth(This,DestinationWidth) ) 

#define IBasicVideo_get_DestinationWidth(This,pDestinationWidth)	\
    ( (This)->lpVtbl -> get_DestinationWidth(This,pDestinationWidth) ) 

#define IBasicVideo_put_DestinationTop(This,DestinationTop)	\
    ( (This)->lpVtbl -> put_DestinationTop(This,DestinationTop) ) 

#define IBasicVideo_get_DestinationTop(This,pDestinationTop)	\
    ( (This)->lpVtbl -> get_DestinationTop(This,pDestinationTop) ) 

#define IBasicVideo_put_DestinationHeight(This,DestinationHeight)	\
    ( (This)->lpVtbl -> put_DestinationHeight(This,DestinationHeight) ) 

#define IBasicVideo_get_DestinationHeight(This,pDestinationHeight)	\
    ( (This)->lpVtbl -> get_DestinationHeight(This,pDestinationHeight) ) 

#define IBasicVideo_SetSourcePosition(This,Left,Top,Width,Height)	\
    ( (This)->lpVtbl -> SetSourcePosition(This,Left,Top,Width,Height) ) 

#define IBasicVideo_GetSourcePosition(This,pLeft,pTop,pWidth,pHeight)	\
    ( (This)->lpVtbl -> GetSourcePosition(This,pLeft,pTop,pWidth,pHeight) ) 

#define IBasicVideo_SetDefaultSourcePosition(This)	\
    ( (This)->lpVtbl -> SetDefaultSourcePosition(This) ) 

#define IBasicVideo_SetDestinationPosition(This,Left,Top,Width,Height)	\
    ( (This)->lpVtbl -> SetDestinationPosition(This,Left,Top,Width,Height) ) 

#define IBasicVideo_GetDestinationPosition(This,pLeft,pTop,pWidth,pHeight)	\
    ( (This)->lpVtbl -> GetDestinationPosition(This,pLeft,pTop,pWidth,pHeight) ) 

#define IBasicVideo_SetDefaultDestinationPosition(This)	\
    ( (This)->lpVtbl -> SetDefaultDestinationPosition(This) ) 

#define IBasicVideo_GetVideoSize(This,pWidth,pHeight)	\
    ( (This)->lpVtbl -> GetVideoSize(This,pWidth,pHeight) ) 

#define IBasicVideo_GetVideoPaletteEntries(This,StartIndex,Entries,pRetrieved,pPalette)	\
    ( (This)->lpVtbl -> GetVideoPaletteEntries(This,StartIndex,Entries,pRetrieved,pPalette) ) 

#define IBasicVideo_GetCurrentImage(This,pBufferSize,pDIBImage)	\
    ( (This)->lpVtbl -> GetCurrentImage(This,pBufferSize,pDIBImage) ) 

#define IBasicVideo_IsUsingDefaultSource(This)	\
    ( (This)->lpVtbl -> IsUsingDefaultSource(This) ) 

#define IBasicVideo_IsUsingDefaultDestination(This)	\
    ( (This)->lpVtbl -> IsUsingDefaultDestination(This) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IBasicVideo_INTERFACE_DEFINED__ */


#ifndef __IBasicVideo2_INTERFACE_DEFINED__
#define __IBasicVideo2_INTERFACE_DEFINED__

/* interface IBasicVideo2 */
/* [object][helpstring][uuid] */ 


DEFINE_GUID(IID_IBasicVideo2,0x329bb360,0xf6ea,0x11d1,0x90,0x38,0x00,0xa0,0xc9,0x69,0x72,0x98);

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("329bb360-f6ea-11d1-9038-00a0c9697298")
    IBasicVideo2 : public IBasicVideo
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE GetPreferredAspectRatio( 
            /* [out] */ __RPC__out long *plAspectX,
            /* [out] */ __RPC__out long *plAspectY) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IBasicVideo2Vtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IBasicVideo2 * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IBasicVideo2 * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IBasicVideo2 * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfoCount )( 
            IBasicVideo2 * This,
            /* [out] */ __RPC__out UINT *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfo )( 
            IBasicVideo2 * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ __RPC__deref_out_opt ITypeInfo **ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetIDsOfNames )( 
            IBasicVideo2 * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [size_is][in] */ __RPC__in_ecount_full(cNames) LPOLESTR *rgszNames,
            /* [range][in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ __RPC__out_ecount_full(cNames) DISPID *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE *Invoke )( 
            IBasicVideo2 * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS *pDispParams,
            /* [out] */ VARIANT *pVarResult,
            /* [out] */ EXCEPINFO *pExcepInfo,
            /* [out] */ UINT *puArgErr);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_AvgTimePerFrame )( 
            IBasicVideo2 * This,
            /* [retval][out] */ __RPC__out REFTIME *pAvgTimePerFrame);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_BitRate )( 
            IBasicVideo2 * This,
            /* [retval][out] */ __RPC__out long *pBitRate);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_BitErrorRate )( 
            IBasicVideo2 * This,
            /* [retval][out] */ __RPC__out long *pBitErrorRate);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_VideoWidth )( 
            IBasicVideo2 * This,
            /* [retval][out] */ __RPC__out long *pVideoWidth);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_VideoHeight )( 
            IBasicVideo2 * This,
            /* [retval][out] */ __RPC__out long *pVideoHeight);
        
        /* [propput] */ HRESULT ( STDMETHODCALLTYPE *put_SourceLeft )( 
            IBasicVideo2 * This,
            /* [in] */ long SourceLeft);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_SourceLeft )( 
            IBasicVideo2 * This,
            /* [retval][out] */ __RPC__out long *pSourceLeft);
        
        /* [propput] */ HRESULT ( STDMETHODCALLTYPE *put_SourceWidth )( 
            IBasicVideo2 * This,
            /* [in] */ long SourceWidth);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_SourceWidth )( 
            IBasicVideo2 * This,
            /* [retval][out] */ __RPC__out long *pSourceWidth);
        
        /* [propput] */ HRESULT ( STDMETHODCALLTYPE *put_SourceTop )( 
            IBasicVideo2 * This,
            /* [in] */ long SourceTop);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_SourceTop )( 
            IBasicVideo2 * This,
            /* [retval][out] */ __RPC__out long *pSourceTop);
        
        /* [propput] */ HRESULT ( STDMETHODCALLTYPE *put_SourceHeight )( 
            IBasicVideo2 * This,
            /* [in] */ long SourceHeight);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_SourceHeight )( 
            IBasicVideo2 * This,
            /* [retval][out] */ __RPC__out long *pSourceHeight);
        
        /* [propput] */ HRESULT ( STDMETHODCALLTYPE *put_DestinationLeft )( 
            IBasicVideo2 * This,
            /* [in] */ long DestinationLeft);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_DestinationLeft )( 
            IBasicVideo2 * This,
            /* [retval][out] */ __RPC__out long *pDestinationLeft);
        
        /* [propput] */ HRESULT ( STDMETHODCALLTYPE *put_DestinationWidth )( 
            IBasicVideo2 * This,
            /* [in] */ long DestinationWidth);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_DestinationWidth )( 
            IBasicVideo2 * This,
            /* [retval][out] */ __RPC__out long *pDestinationWidth);
        
        /* [propput] */ HRESULT ( STDMETHODCALLTYPE *put_DestinationTop )( 
            IBasicVideo2 * This,
            /* [in] */ long DestinationTop);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_DestinationTop )( 
            IBasicVideo2 * This,
            /* [retval][out] */ __RPC__out long *pDestinationTop);
        
        /* [propput] */ HRESULT ( STDMETHODCALLTYPE *put_DestinationHeight )( 
            IBasicVideo2 * This,
            /* [in] */ long DestinationHeight);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_DestinationHeight )( 
            IBasicVideo2 * This,
            /* [retval][out] */ __RPC__out long *pDestinationHeight);
        
        HRESULT ( STDMETHODCALLTYPE *SetSourcePosition )( 
            IBasicVideo2 * This,
            /* [in] */ long Left,
            /* [in] */ long Top,
            /* [in] */ long Width,
            /* [in] */ long Height);
        
        HRESULT ( STDMETHODCALLTYPE *GetSourcePosition )( 
            IBasicVideo2 * This,
            /* [out] */ __RPC__out long *pLeft,
            /* [out] */ __RPC__out long *pTop,
            /* [out] */ __RPC__out long *pWidth,
            /* [out] */ __RPC__out long *pHeight);
        
        HRESULT ( STDMETHODCALLTYPE *SetDefaultSourcePosition )( 
            IBasicVideo2 * This);
        
        HRESULT ( STDMETHODCALLTYPE *SetDestinationPosition )( 
            IBasicVideo2 * This,
            /* [in] */ long Left,
            /* [in] */ long Top,
            /* [in] */ long Width,
            /* [in] */ long Height);
        
        HRESULT ( STDMETHODCALLTYPE *GetDestinationPosition )( 
            IBasicVideo2 * This,
            /* [out] */ __RPC__out long *pLeft,
            /* [out] */ __RPC__out long *pTop,
            /* [out] */ __RPC__out long *pWidth,
            /* [out] */ __RPC__out long *pHeight);
        
        HRESULT ( STDMETHODCALLTYPE *SetDefaultDestinationPosition )( 
            IBasicVideo2 * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetVideoSize )( 
            IBasicVideo2 * This,
            /* [out] */ __RPC__out long *pWidth,
            /* [out] */ __RPC__out long *pHeight);
        
        HRESULT ( STDMETHODCALLTYPE *GetVideoPaletteEntries )( 
            IBasicVideo2 * This,
            /* [in] */ long StartIndex,
            /* [in] */ long Entries,
            /* [out] */ __RPC__out long *pRetrieved,
            /* [out] */ __RPC__out long *pPalette);
        
        HRESULT ( STDMETHODCALLTYPE *GetCurrentImage )( 
            IBasicVideo2 * This,
            /* [out][in] */ __RPC__inout long *pBufferSize,
            /* [out] */ __RPC__out long *pDIBImage);
        
        HRESULT ( STDMETHODCALLTYPE *IsUsingDefaultSource )( 
            IBasicVideo2 * This);
        
        HRESULT ( STDMETHODCALLTYPE *IsUsingDefaultDestination )( 
            IBasicVideo2 * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetPreferredAspectRatio )( 
            IBasicVideo2 * This,
            /* [out] */ __RPC__out long *plAspectX,
            /* [out] */ __RPC__out long *plAspectY);
        
        END_INTERFACE
    } IBasicVideo2Vtbl;

    interface IBasicVideo2
    {
        CONST_VTBL struct IBasicVideo2Vtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IBasicVideo2_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IBasicVideo2_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IBasicVideo2_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IBasicVideo2_GetTypeInfoCount(This,pctinfo)	\
    ( (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo) ) 

#define IBasicVideo2_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    ( (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo) ) 

#define IBasicVideo2_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    ( (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId) ) 

#define IBasicVideo2_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    ( (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr) ) 


#define IBasicVideo2_get_AvgTimePerFrame(This,pAvgTimePerFrame)	\
    ( (This)->lpVtbl -> get_AvgTimePerFrame(This,pAvgTimePerFrame) ) 

#define IBasicVideo2_get_BitRate(This,pBitRate)	\
    ( (This)->lpVtbl -> get_BitRate(This,pBitRate) ) 

#define IBasicVideo2_get_BitErrorRate(This,pBitErrorRate)	\
    ( (This)->lpVtbl -> get_BitErrorRate(This,pBitErrorRate) ) 

#define IBasicVideo2_get_VideoWidth(This,pVideoWidth)	\
    ( (This)->lpVtbl -> get_VideoWidth(This,pVideoWidth) ) 

#define IBasicVideo2_get_VideoHeight(This,pVideoHeight)	\
    ( (This)->lpVtbl -> get_VideoHeight(This,pVideoHeight) ) 

#define IBasicVideo2_put_SourceLeft(This,SourceLeft)	\
    ( (This)->lpVtbl -> put_SourceLeft(This,SourceLeft) ) 

#define IBasicVideo2_get_SourceLeft(This,pSourceLeft)	\
    ( (This)->lpVtbl -> get_SourceLeft(This,pSourceLeft) ) 

#define IBasicVideo2_put_SourceWidth(This,SourceWidth)	\
    ( (This)->lpVtbl -> put_SourceWidth(This,SourceWidth) ) 

#define IBasicVideo2_get_SourceWidth(This,pSourceWidth)	\
    ( (This)->lpVtbl -> get_SourceWidth(This,pSourceWidth) ) 

#define IBasicVideo2_put_SourceTop(This,SourceTop)	\
    ( (This)->lpVtbl -> put_SourceTop(This,SourceTop) ) 

#define IBasicVideo2_get_SourceTop(This,pSourceTop)	\
    ( (This)->lpVtbl -> get_SourceTop(This,pSourceTop) ) 

#define IBasicVideo2_put_SourceHeight(This,SourceHeight)	\
    ( (This)->lpVtbl -> put_SourceHeight(This,SourceHeight) ) 

#define IBasicVideo2_get_SourceHeight(This,pSourceHeight)	\
    ( (This)->lpVtbl -> get_SourceHeight(This,pSourceHeight) ) 

#define IBasicVideo2_put_DestinationLeft(This,DestinationLeft)	\
    ( (This)->lpVtbl -> put_DestinationLeft(This,DestinationLeft) ) 

#define IBasicVideo2_get_DestinationLeft(This,pDestinationLeft)	\
    ( (This)->lpVtbl -> get_DestinationLeft(This,pDestinationLeft) ) 

#define IBasicVideo2_put_DestinationWidth(This,DestinationWidth)	\
    ( (This)->lpVtbl -> put_DestinationWidth(This,DestinationWidth) ) 

#define IBasicVideo2_get_DestinationWidth(This,pDestinationWidth)	\
    ( (This)->lpVtbl -> get_DestinationWidth(This,pDestinationWidth) ) 

#define IBasicVideo2_put_DestinationTop(This,DestinationTop)	\
    ( (This)->lpVtbl -> put_DestinationTop(This,DestinationTop) ) 

#define IBasicVideo2_get_DestinationTop(This,pDestinationTop)	\
    ( (This)->lpVtbl -> get_DestinationTop(This,pDestinationTop) ) 

#define IBasicVideo2_put_DestinationHeight(This,DestinationHeight)	\
    ( (This)->lpVtbl -> put_DestinationHeight(This,DestinationHeight) ) 

#define IBasicVideo2_get_DestinationHeight(This,pDestinationHeight)	\
    ( (This)->lpVtbl -> get_DestinationHeight(This,pDestinationHeight) ) 

#define IBasicVideo2_SetSourcePosition(This,Left,Top,Width,Height)	\
    ( (This)->lpVtbl -> SetSourcePosition(This,Left,Top,Width,Height) ) 

#define IBasicVideo2_GetSourcePosition(This,pLeft,pTop,pWidth,pHeight)	\
    ( (This)->lpVtbl -> GetSourcePosition(This,pLeft,pTop,pWidth,pHeight) ) 

#define IBasicVideo2_SetDefaultSourcePosition(This)	\
    ( (This)->lpVtbl -> SetDefaultSourcePosition(This) ) 

#define IBasicVideo2_SetDestinationPosition(This,Left,Top,Width,Height)	\
    ( (This)->lpVtbl -> SetDestinationPosition(This,Left,Top,Width,Height) ) 

#define IBasicVideo2_GetDestinationPosition(This,pLeft,pTop,pWidth,pHeight)	\
    ( (This)->lpVtbl -> GetDestinationPosition(This,pLeft,pTop,pWidth,pHeight) ) 

#define IBasicVideo2_SetDefaultDestinationPosition(This)	\
    ( (This)->lpVtbl -> SetDefaultDestinationPosition(This) ) 

#define IBasicVideo2_GetVideoSize(This,pWidth,pHeight)	\
    ( (This)->lpVtbl -> GetVideoSize(This,pWidth,pHeight) ) 

#define IBasicVideo2_GetVideoPaletteEntries(This,StartIndex,Entries,pRetrieved,pPalette)	\
    ( (This)->lpVtbl -> GetVideoPaletteEntries(This,StartIndex,Entries,pRetrieved,pPalette) ) 

#define IBasicVideo2_GetCurrentImage(This,pBufferSize,pDIBImage)	\
    ( (This)->lpVtbl -> GetCurrentImage(This,pBufferSize,pDIBImage) ) 

#define IBasicVideo2_IsUsingDefaultSource(This)	\
    ( (This)->lpVtbl -> IsUsingDefaultSource(This) ) 

#define IBasicVideo2_IsUsingDefaultDestination(This)	\
    ( (This)->lpVtbl -> IsUsingDefaultDestination(This) ) 


#define IBasicVideo2_GetPreferredAspectRatio(This,plAspectX,plAspectY)	\
    ( (This)->lpVtbl -> GetPreferredAspectRatio(This,plAspectX,plAspectY) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IBasicVideo2_INTERFACE_DEFINED__ */


#ifndef __IDeferredCommand_INTERFACE_DEFINED__
#define __IDeferredCommand_INTERFACE_DEFINED__

/* interface IDeferredCommand */
/* [object][helpstring][uuid] */ 


DEFINE_GUID(IID_IDeferredCommand,0x56a868b8,0x0ad4,0x11ce,0xb0,0x3a,0x00,0x20,0xaf,0x0b,0xa7,0x70);

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("56a868b8-0ad4-11ce-b03a-0020af0ba770")
    IDeferredCommand : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE Cancel( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Confidence( 
            /* [out] */ __RPC__out LONG *pConfidence) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Postpone( 
            /* [in] */ REFTIME newtime) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetHResult( 
            /* [out] */ __RPC__out HRESULT *phrResult) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IDeferredCommandVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IDeferredCommand * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IDeferredCommand * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IDeferredCommand * This);
        
        HRESULT ( STDMETHODCALLTYPE *Cancel )( 
            IDeferredCommand * This);
        
        HRESULT ( STDMETHODCALLTYPE *Confidence )( 
            IDeferredCommand * This,
            /* [out] */ __RPC__out LONG *pConfidence);
        
        HRESULT ( STDMETHODCALLTYPE *Postpone )( 
            IDeferredCommand * This,
            /* [in] */ REFTIME newtime);
        
        HRESULT ( STDMETHODCALLTYPE *GetHResult )( 
            IDeferredCommand * This,
            /* [out] */ __RPC__out HRESULT *phrResult);
        
        END_INTERFACE
    } IDeferredCommandVtbl;

    interface IDeferredCommand
    {
        CONST_VTBL struct IDeferredCommandVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IDeferredCommand_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IDeferredCommand_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IDeferredCommand_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IDeferredCommand_Cancel(This)	\
    ( (This)->lpVtbl -> Cancel(This) ) 

#define IDeferredCommand_Confidence(This,pConfidence)	\
    ( (This)->lpVtbl -> Confidence(This,pConfidence) ) 

#define IDeferredCommand_Postpone(This,newtime)	\
    ( (This)->lpVtbl -> Postpone(This,newtime) ) 

#define IDeferredCommand_GetHResult(This,phrResult)	\
    ( (This)->lpVtbl -> GetHResult(This,phrResult) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IDeferredCommand_INTERFACE_DEFINED__ */


#ifndef __IQueueCommand_INTERFACE_DEFINED__
#define __IQueueCommand_INTERFACE_DEFINED__

/* interface IQueueCommand */
/* [object][helpstring][uuid] */ 


DEFINE_GUID(IID_IQueueCommand,0x56a868b7,0x0ad4,0x11ce,0xb0,0x3a,0x00,0x20,0xaf,0x0b,0xa7,0x70);

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("56a868b7-0ad4-11ce-b03a-0020af0ba770")
    IQueueCommand : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE InvokeAtStreamTime( 
            /* [out] */ __RPC__deref_out_opt IDeferredCommand **pCmd,
            /* [in] */ REFTIME time,
            /* [in] */ __RPC__in GUID *iid,
            /* [in] */ long dispidMethod,
            /* [in] */ short wFlags,
            /* [in] */ long cArgs,
            /* [in] */ __RPC__in VARIANT *pDispParams,
            /* [out][in] */ __RPC__inout VARIANT *pvarResult,
            /* [out] */ __RPC__out short *puArgErr) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE InvokeAtPresentationTime( 
            /* [out] */ __RPC__deref_out_opt IDeferredCommand **pCmd,
            /* [in] */ REFTIME time,
            /* [in] */ __RPC__in GUID *iid,
            /* [in] */ long dispidMethod,
            /* [in] */ short wFlags,
            /* [in] */ long cArgs,
            /* [in] */ __RPC__in VARIANT *pDispParams,
            /* [out][in] */ __RPC__inout VARIANT *pvarResult,
            /* [out] */ __RPC__out short *puArgErr) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IQueueCommandVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IQueueCommand * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IQueueCommand * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IQueueCommand * This);
        
        HRESULT ( STDMETHODCALLTYPE *InvokeAtStreamTime )( 
            IQueueCommand * This,
            /* [out] */ __RPC__deref_out_opt IDeferredCommand **pCmd,
            /* [in] */ REFTIME time,
            /* [in] */ __RPC__in GUID *iid,
            /* [in] */ long dispidMethod,
            /* [in] */ short wFlags,
            /* [in] */ long cArgs,
            /* [in] */ __RPC__in VARIANT *pDispParams,
            /* [out][in] */ __RPC__inout VARIANT *pvarResult,
            /* [out] */ __RPC__out short *puArgErr);
        
        HRESULT ( STDMETHODCALLTYPE *InvokeAtPresentationTime )( 
            IQueueCommand * This,
            /* [out] */ __RPC__deref_out_opt IDeferredCommand **pCmd,
            /* [in] */ REFTIME time,
            /* [in] */ __RPC__in GUID *iid,
            /* [in] */ long dispidMethod,
            /* [in] */ short wFlags,
            /* [in] */ long cArgs,
            /* [in] */ __RPC__in VARIANT *pDispParams,
            /* [out][in] */ __RPC__inout VARIANT *pvarResult,
            /* [out] */ __RPC__out short *puArgErr);
        
        END_INTERFACE
    } IQueueCommandVtbl;

    interface IQueueCommand
    {
        CONST_VTBL struct IQueueCommandVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IQueueCommand_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IQueueCommand_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IQueueCommand_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IQueueCommand_InvokeAtStreamTime(This,pCmd,time,iid,dispidMethod,wFlags,cArgs,pDispParams,pvarResult,puArgErr)	\
    ( (This)->lpVtbl -> InvokeAtStreamTime(This,pCmd,time,iid,dispidMethod,wFlags,cArgs,pDispParams,pvarResult,puArgErr) ) 

#define IQueueCommand_InvokeAtPresentationTime(This,pCmd,time,iid,dispidMethod,wFlags,cArgs,pDispParams,pvarResult,puArgErr)	\
    ( (This)->lpVtbl -> InvokeAtPresentationTime(This,pCmd,time,iid,dispidMethod,wFlags,cArgs,pDispParams,pvarResult,puArgErr) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IQueueCommand_INTERFACE_DEFINED__ */


DEFINE_GUID(CLSID_FilgraphManager,0xe436ebb3,0x524f,0x11ce,0x9f,0x53,0x00,0x20,0xaf,0x0b,0xa7,0x70);

#ifdef __cplusplus

class DECLSPEC_UUID("e436ebb3-524f-11ce-9f53-0020af0ba770")
FilgraphManager;
#endif

#ifndef __IFilterInfo_INTERFACE_DEFINED__
#define __IFilterInfo_INTERFACE_DEFINED__

/* interface IFilterInfo */
/* [object][dual][oleautomation][helpstring][uuid] */ 


DEFINE_GUID(IID_IFilterInfo,0x56a868ba,0x0ad4,0x11ce,0xb0,0x3a,0x00,0x20,0xaf,0x0b,0xa7,0x70);

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("56a868ba-0ad4-11ce-b03a-0020af0ba770")
    IFilterInfo : public IDispatch
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE FindPin( 
            /* [in] */ __RPC__in BSTR strPinID,
            /* [out] */ __RPC__deref_out_opt IDispatch **ppUnk) = 0;
        
        virtual /* [propget] */ HRESULT STDMETHODCALLTYPE get_Name( 
            /* [retval][out] */ __RPC__deref_out_opt BSTR *strName) = 0;
        
        virtual /* [propget] */ HRESULT STDMETHODCALLTYPE get_VendorInfo( 
            /* [retval][out] */ __RPC__deref_out_opt BSTR *strVendorInfo) = 0;
        
        virtual /* [propget] */ HRESULT STDMETHODCALLTYPE get_Filter( 
            /* [retval][out] */ __RPC__deref_out_opt IUnknown **ppUnk) = 0;
        
        virtual /* [propget] */ HRESULT STDMETHODCALLTYPE get_Pins( 
            /* [retval][out] */ __RPC__deref_out_opt IDispatch **ppUnk) = 0;
        
        virtual /* [propget] */ HRESULT STDMETHODCALLTYPE get_IsFileSource( 
            /* [retval][out] */ __RPC__out LONG *pbIsSource) = 0;
        
        virtual /* [propget] */ HRESULT STDMETHODCALLTYPE get_Filename( 
            /* [retval][out] */ __RPC__deref_out_opt BSTR *pstrFilename) = 0;
        
        virtual /* [propput] */ HRESULT STDMETHODCALLTYPE put_Filename( 
            /* [in] */ __RPC__in BSTR strFilename) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IFilterInfoVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IFilterInfo * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IFilterInfo * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IFilterInfo * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfoCount )( 
            IFilterInfo * This,
            /* [out] */ __RPC__out UINT *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfo )( 
            IFilterInfo * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ __RPC__deref_out_opt ITypeInfo **ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetIDsOfNames )( 
            IFilterInfo * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [size_is][in] */ __RPC__in_ecount_full(cNames) LPOLESTR *rgszNames,
            /* [range][in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ __RPC__out_ecount_full(cNames) DISPID *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE *Invoke )( 
            IFilterInfo * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS *pDispParams,
            /* [out] */ VARIANT *pVarResult,
            /* [out] */ EXCEPINFO *pExcepInfo,
            /* [out] */ UINT *puArgErr);
        
        HRESULT ( STDMETHODCALLTYPE *FindPin )( 
            IFilterInfo * This,
            /* [in] */ __RPC__in BSTR strPinID,
            /* [out] */ __RPC__deref_out_opt IDispatch **ppUnk);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_Name )( 
            IFilterInfo * This,
            /* [retval][out] */ __RPC__deref_out_opt BSTR *strName);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_VendorInfo )( 
            IFilterInfo * This,
            /* [retval][out] */ __RPC__deref_out_opt BSTR *strVendorInfo);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_Filter )( 
            IFilterInfo * This,
            /* [retval][out] */ __RPC__deref_out_opt IUnknown **ppUnk);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_Pins )( 
            IFilterInfo * This,
            /* [retval][out] */ __RPC__deref_out_opt IDispatch **ppUnk);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_IsFileSource )( 
            IFilterInfo * This,
            /* [retval][out] */ __RPC__out LONG *pbIsSource);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_Filename )( 
            IFilterInfo * This,
            /* [retval][out] */ __RPC__deref_out_opt BSTR *pstrFilename);
        
        /* [propput] */ HRESULT ( STDMETHODCALLTYPE *put_Filename )( 
            IFilterInfo * This,
            /* [in] */ __RPC__in BSTR strFilename);
        
        END_INTERFACE
    } IFilterInfoVtbl;

    interface IFilterInfo
    {
        CONST_VTBL struct IFilterInfoVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IFilterInfo_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IFilterInfo_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IFilterInfo_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IFilterInfo_GetTypeInfoCount(This,pctinfo)	\
    ( (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo) ) 

#define IFilterInfo_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    ( (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo) ) 

#define IFilterInfo_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    ( (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId) ) 

#define IFilterInfo_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    ( (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr) ) 


#define IFilterInfo_FindPin(This,strPinID,ppUnk)	\
    ( (This)->lpVtbl -> FindPin(This,strPinID,ppUnk) ) 

#define IFilterInfo_get_Name(This,strName)	\
    ( (This)->lpVtbl -> get_Name(This,strName) ) 

#define IFilterInfo_get_VendorInfo(This,strVendorInfo)	\
    ( (This)->lpVtbl -> get_VendorInfo(This,strVendorInfo) ) 

#define IFilterInfo_get_Filter(This,ppUnk)	\
    ( (This)->lpVtbl -> get_Filter(This,ppUnk) ) 

#define IFilterInfo_get_Pins(This,ppUnk)	\
    ( (This)->lpVtbl -> get_Pins(This,ppUnk) ) 

#define IFilterInfo_get_IsFileSource(This,pbIsSource)	\
    ( (This)->lpVtbl -> get_IsFileSource(This,pbIsSource) ) 

#define IFilterInfo_get_Filename(This,pstrFilename)	\
    ( (This)->lpVtbl -> get_Filename(This,pstrFilename) ) 

#define IFilterInfo_put_Filename(This,strFilename)	\
    ( (This)->lpVtbl -> put_Filename(This,strFilename) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IFilterInfo_INTERFACE_DEFINED__ */


#ifndef __IRegFilterInfo_INTERFACE_DEFINED__
#define __IRegFilterInfo_INTERFACE_DEFINED__

/* interface IRegFilterInfo */
/* [object][dual][oleautomation][helpstring][uuid] */ 


DEFINE_GUID(IID_IRegFilterInfo,0x56a868bb,0x0ad4,0x11ce,0xb0,0x3a,0x00,0x20,0xaf,0x0b,0xa7,0x70);

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("56a868bb-0ad4-11ce-b03a-0020af0ba770")
    IRegFilterInfo : public IDispatch
    {
    public:
        virtual /* [propget] */ HRESULT STDMETHODCALLTYPE get_Name( 
            /* [retval][out] */ __RPC__deref_out_opt BSTR *strName) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Filter( 
            /* [out] */ __RPC__deref_out_opt IDispatch **ppUnk) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IRegFilterInfoVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IRegFilterInfo * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IRegFilterInfo * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IRegFilterInfo * This);
        
        HRESUL