stem.Text;

using WSMonitor.Framework;
using WSMonitor.Framework.Exceptions;

using KeyCollection = System.Collections.Generic.Dictionary<string, object>.KeyCollection;
using ValueCollection = System.Collections.Generic.Dictionary<string, object>.ValueCollection;

namespace WSMonitor.Framework.Reporting {
   /// <summary>
   /// Reports are used to log and generate information pertaining to the execution of scripts and services.
   /// Reports are essentially hierarchical property bags.  The values in the reports is accumulated by a
   /// combination of automatic logging accomplished by aspects, or by reporting api exposed to script
   /// writers.
   /// </summary>
   [Serializable]
   public partial class Report {
      /// <summary>
      /// Static initializer for Report.
      /// </summary>
      static Report() { }

      #region Reporting API
      /// <summary>
      /// Initialized a new report.  Common nesting logic that will be present for
      /// all report types will be taken care of here.
      /// </summary>
      /// <param name="category">Category of the new report.</param>
      /// <param name="t">Type of report.  Must be a subclass of Report and contain a constructor that accepts category and parent.</param>
      /// <returns>Return the newly initialized Report.</returns>
      public static Report Create(ReportCategory category, Type reportSubclass) {
         ReportStackProperty ReportingStack = ReportStackProperty.GetProperty();
         GlobalInstanceProperty GlobalInstance = GlobalInstanceProperty.GetProperty();
         Report Parent, Result;

         ///Demand: must be called from a valid calling context
         if (null == ReportingStack)
            throw new InvalidReportException("Framework_Report_ContextMissingProperty ReportStack");
         if (null == GlobalInstance)
            throw new InvalidReportException("Framework_Report_ContextMissingProperty GlobalInstance");

         ///Demand: reportSubclass must be a subclass of Report
         if (!typeof(Report).IsAssignableFrom(reportSubclass))
            throw new InvalidReportException(reportSubclass.Name + " is not a subclass of Report");

         ///Demand: correct constructor signature
         Type[] Signature = new Type[] { typeof(ReportCategory), typeof(Report) };
         if (null == reportSubclass.GetConstructor(Signature))
            throw new InvalidReportException(reportSubclass.Name + " does not have a constructor with signature " +
               "(ReportCategory category, Report parent)");

         ///Grab the current stack and parent
         Parent = null;
         Parent = ReportingStack.Top;

         ///Demand: stack must contain a parent for non-container reports
         if (null == Parent && !_IsContainer(category))
            throw new InvalidContextException("No report container present.");

         Result = Activator.CreateInstance(reportSubclass, new object[] { category, Parent }) as Report;
         Result.instance = GlobalInstance.Instance;

         ///Push the new container if this is a container report
         if (_IsContainer(category))
            ReportingStack.Enter(Result);

         return Result;
      }
      /// <summary>
      /// Initialized a new report.  Common nesting logic that will be present for
      /// all report types will be taken care of here.
      /// </summary>
      /// <param name="category">Category of the new report.</param>
      /// <returns>Return the newly initialized Report.</returns>
      public static Report Create(ReportCategory category) {
         return Create(category, typeof(Report));
      }
      /// <summary>
      /// Creates a new message report.  The message report is immediately added to the
      /// current container and closed.  This method should only be called when 
      /// </summary>
      /// <param name="format">Message format.</param>
      /// <param name="args">Optional arguments for the formatted string.</param>
      public static void Message(string format, params object[] args)        
         { Message(ReportCategory.Message, format, args); }
      /// <summary>
      /// Create a new verbose message report.  The message report is immediately added to the
      /// current container and closed.  This method should only be called when 
      /// </summary>
      /// <param name="format">Message format.</param>
      /// <param name="args">Optional arguments for the formatted string.</param>
      public static void VerboseMessage(string format, params object[] args) 
         { Message(ReportCategory.VerboseMessage, format, args); }
      /// <summary>
      /// Create a new warning message report.  The message report is immediately added to the
      /// current container and closed.  This method should only be called when 
      /// </summary>
      /// <param name="format">Message format.</param>
      /// <param name="args">Optional arguments for the formatted string.</param>
      public static void WarningMessage(string format, params object[] args) 
         { Message(ReportCategory.WarningMessage, format, args); }
      /// <summary>
      /// Create a new error message report.  The message report is immediately added to the
      /// current container and closed.  This method should only be called when 
      /// </summary>
      /// <param name="format">Message format.</param>
      /// <param name="args">Optional arguments for the formatted string.</param>
      public static void ErrorMessage(string format, params object[] args)   
         { Message(ReportCategory.ErrorMessage, format, args); }
      /// <summary>
      /// Create a new exception message report.  The message report is immediately added to the
      /// current container and closed.  This method should only be called when 
      /// </summary>
      /// <param name="format">>Message format.</param>
      /// <param name="args">Optional arguments for the formatted string.</param>
      public static void ExceptionMessage(string format, params object[] args) 
         { Message(ReportCategory.ExceptionMessage, format, args); }
      /// <summary>
      /// Create a new exception message report.  The message report is immediately added to the
      /// current container and closed.  This method should only be called when 
      /// </summary>
      /// <param name="e">Exception to report.</param>
      public static void ExceptionMessage(Exception e) 
         { Message(ReportCategory.ExceptionMessage, "Encountered exception: {0}", e); }
      
      /// <summary>
      /// Writes a property to the current report.
      /// </summary>
      /// <param name="name">Name associated with the property.</param>
      /// <param name="value">Value associated with the property.</param>
      public static void WriteProperty(string name, object value) {
         ReportStackProperty ReportingStack = ReportStackProperty.GetProperty();
         Report Current;

         ///Demand: must be called from a valid calling context
         if (null == ReportingStack)
            throw new InvalidReportException("Framework_Report_ContextMissingProperty ReportStack");

         Current = ReportingStack.Top;
         if (null == Current)
            throw new InvalidReportException("Framework_Report_NoReportPresent");

         Current.Properties[name] = value;
      }
      #endregion

      #region Reporting API Support
      /// <summary>
      /// Generic method for creating a message report.
      /// </summary>
      /// <param name="category">The category of the message report.</param>
      /// <param name="formatting">Formatted message string that will be written to the message.</param>
      /// <param name="args">Arguments for formatted message string.</param>
      private static void Message(ReportCategory category, string formatting, params object[] args) {
         Report R;
         MessageReportProxy Proxy;

         R = (Report)Create(category, typeof(Report));
         Proxy = new MessageReportProxy(R);
         Proxy.Text = (null != args && 0 < args.Length) ? 
            string.Format(formatting, args) : 
            formatting;
         R.Close();
      }
      /// <summary>
      /// Indicates whether or not the current category is a container category.
      /// </summary>
      /// <param name="category">The category of interest.</param>
      /// <returns>True indicates it is a container category, false if not.</returns>
      private static bool _IsContainer(ReportCategory category) {
         return ReportCategory.Container == (category & ReportCategory.Container);
      }
      #endregion

      /// <summary>
      /// Initializes a new instance of a Report.  This should not be invoked directly by
      /// user code.
      /// </summary>
      [SecurityPermission(SecurityAction.LinkDemand,
         Flags=SecurityPermissionFlag.SerializationFormatter)]
      public Report() : this(ReportCategory.Message , null) { }

      /// <summary>
      /// Initializes a new instance of a Report.  This should not be invoked directly by
      /// user code.
      /// </summary>
      /// <param name="category">Category of the new report.</param>
      /// <param name="parent">Parent report of the new report.</param>
      [SecurityPermission(SecurityAction.LinkDemand,
         Flags=SecurityPermissionFlag.Infrastructure)]
      public Report(ReportCategory category, Report parent) : this(category, parent, Guid.NewGuid()) { }

      /// <summary>
      /// Initializes a new instance of a Report.  This is used primarily to create a report
      /// object from a previously serialized report.  This is why the Guid is specified.
      /// </summary>
      /// <param name="category">Category of the new report.</param>
      /// <param name="parent">Parent report of the new report.</param>
      /// <param name="guid">Guid to assign to the new report.</param>
      protected Report(ReportCategory category, Report parent, Guid guid) {
         this.category = category;
         this.guid = guid;
         this.parent = parent;
         this.isFinalized = false;
         
         //Allow children if and only if the category is a container category.
         if (Report._IsContainer(this.category))
            this.children = new List<Report>();

         this.properties = new Dictionary<string, object>();

         if (parent != null) {
            if (null == parent.children)
               throw new InvalidReportException("Framework_Report_ParentNotContainer");

            parent.children.Add(this);
         }
      }

      /// <summary>
      /// Marks the report as finished and distributes it to the registered ReportServer.
      /// </summary>
      /// <param name="forced">
      /// Indicates whether or not the close was forced.  A report is forced close if
      /// a parent is closed before it.
      /// </param>
      internal void _Close(bool forced) {
         if (!this.isFinalized) {
            this.isFinalized    = true;
            this.forcedFinalize = forced;

            //Force children to close.
            if (null != children) {
               foreach (Report child in children)
                  child._Close(true);
            }

            Distribute();
         }
      }

      /// <summary>
      /// Performs ReportStack management prior to marking the report as finished
      /// and distributing it to the registered ReportServer.
      /// </summary>
      public virtual void Close() {
         ReportStackProperty Property = ReportStackProperty.GetProperty();

         if (null == Property)
            throw new InvalidReportException("Framework_Report_ContextMissingProperty");
         
         //This will eventually invoke _Close.
         Property.Leave(this);
      }

      /// <summary>
      /// Sends the report to the ReportServer.
      /// </summary>
      /// <param name="report">The report to distribute</param>
      private void Distribute() {
         IReportServer Server;
         DeliveryFailure[] Failures;

         //Demand: There must be an active server registered.
         Server = ReportServer.ActiveServer;
         if (null == Server)
            throw new InvalidOperationException("Framework_Report_NoReportServer");

         //Dispatch report, failures result in an exception.
         Server.DispatchReport(this, out Failures);
         if (Failures.Length > 0)
            throw DeliveryFailure.CreateException(
               "Framework_Report_DeliveryFailures " + Failures.Length.ToString(),
               Failures);

      }

      #region Intrinsic Properties
      /// <summary>The instance associated with the outter most test script.</summary>
      public virtual long Instance { get { return instance; } }
      /// <summary>The report that this report is nested in.  This is null if we are at the outter most script.</summary>
      public virtual Report Parent { get { return parent; } }
      /// <summary>Unique Id associated with the report.</summary>
      public virtual Guid Guid { get { return guid; } }
      /// <summary>Category associated with the report.</summary>
      public virtual ReportCategory Category { get { return category; } }
      /// <summary>Property bag exposed by this report.</summary>
      public virtual Dictionary<string, object> Properties { get { return properties; } }
      /// <summary>Children for this report.  This value is non-null if and only if the report is a container category.</summary>
      public virtual Report[] Children {
         get {
            return null == children ?
               null :
               children.ToArray();
         }
      }
      #endregion

      /// <summary>
      /// Adds a child to the reports children.  The report must be a container otherwise an assertion
      /// will fail.
      /// </summary>
      /// <param name="child">The report to be added to the array of children.</param>
      internal void AttachChild(Report child) {
         System.Diagnostics.Debug.Assert(null != children, "Cannot attach a child to a non-container.");
         children.Add(child);
      }

      private   bool                       isFinalized;
      private   bool                       forcedFinalize;
      protected long                       instance;
      protected Report                     parent;
      protected List<Report>               children;
      protected Guid                       guid;
      protected ReportCategory             category;
      protected Dictionary<string, object> properties;
   }

   /// <summary>
   /// This class acts as a utility for the Report class.  The ReportProxy provides an easy way to
   /// wrap the key value pairs in the property bag of each report with named instance properties.
   /// Those properties would then handle reading/writing to the property bag, thus allowing the
   /// client to work without knowing the keys associated with the properties.
   /// </summary>
   [Serializable]
   public partial class ReportProxy : Report {
      /// <summary>
      /// Initializes a new instance of a ReportProxy.
      /// </summary>
      public ReportProxy() { this.report = new Report(); }

      /// <summary>
      /// Initializes a new instance of a ReportProxy.
      /// </summary>
      /// <param name="report">Report the proxy should direct its access to.</param>
      public ReportProxy(Report report) {
         this.report = report;
         if (null == report)
            throw new ArgumentNullException("report");
      }
      /// <summary>
      /// Retrieves a value from the property bag of the Report.  If the value is not present a
      /// default value is returned.
      /// </summary>
      /// <param name="key">The key associated with the value of interest.</param>
      /// <param name="default">The default value to return if the value is not present.</param>
      /// <returns>The value in the property bag, or the default value if that is not present.</returns>
      public object GetValue(string key, object @default) {
         if (Properties.ContainsKey(key))
            return Properties[key];
         return @default;
      }
      /// <summary>
      /// Writes a value to the property bag of the Report.
      /// </summary>
      /// <param name="key">The key associated with the value of interest.</param>
      /// <param name="value">The value that will be written to the property bag.</param>
      public void SetValue(string key, object value) {
         Properties[key] = value;
      }

      #region Proxied Members
      /// <summary>See <see cref="Report.Close"/></summary>
      public override void Close() { report.Close(); }
      /// <summary>See <see cref="Report.Category"/></summary>
      public override ReportCategory Category { get { return report.Category; } }
      /// <summary>See <see cref="Report.Guid"/></summary>
      public override Guid Guid { get { return report.Guid; } }
      /// <summary>See <see cref="Report.Children"/></summary>
      public override Report[] Children { get { return base.Children; } }
      /// <summary>See <see cref="Report.Parent"/></summary>
      public override Report Parent { get { return report.Parent; } }
      /// <summary>See <see cref="Report.Instance"/></summary>
      public override long Instance { get { return base.Instance; } }
      /// <summary>See <see cref="Report.Properties"/></summary>
      public override Dictionary<string, object> Properties { get { return report.Properties; } }
      #endregion
      
      /// <summary>Retrieves the nested report.</summary>
      public Report Report {
         get { return report; }
      }

      private Report      report;
      private static Type typeReport = typeof(Report);
      private static Type typeProxy  = typeof(ReportProxy);
   }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\wsmonitor\wsmFramework\Reporting.ReportServer.cs ===
using System;
using System.Collections;
using System.Collections.Generic;
using System.Text;
      
using SubscriberCollection = System.Collections.Generic.IEnumerable<WSMonitor.Framework.Reporting.IReportSubscriber>;

namespace WSMonitor.Framework.Reporting {
   public class ReportServer : ContextBoundObject, IReportServer, IReportSubscriber {
      public ReportServer(string name) {
         this.name = string.IsNullOrEmpty(name) ? "" : name;
         this.cacheLock = new object();
      }

      #region Static Controls
      public static IReportServer ActiveServer {
         get { return activeServer; }
         set {
            if (!configurationLocked)
               activeServer = value;
         }
      }

      public static void LockConfiguration() {
         configurationLocked = true;
      }
      #endregion

      public virtual void Dispatch(Report report, out DeliveryFailure[] failures) {
         List<DeliveryFailure> Failures;

         Failures = new List<DeliveryFailure>();
         if (null != report) {
            foreach (IReportSubscriber target in AcknowledgedSubscribers) {
               if (target.Accepting) {
                  try { target.ReceiveReport(report); }
                  catch (Exception e) {
                     Failures.Add(new DeliveryFailure(target, e));
                  }
               }
            }
         }

         failures = Failures.ToArray();
      }

      public void RegisterSubscriber(IReportSubscriber target, bool ignored) {
         lock (cacheLock) {
            subscribers[target] = ignored;
            acknowledgedCache = null;
            ignoredCache = null;
         }
      }

      public SubscriberCollection IgnoredSubscribers {
         get {
            if (null == ignoredCache) {
               lock (cacheLock) {
                  List<IReportSubscriber> Cache = new List<IReportSubscriber>();
                  foreach (IReportSubscriber target in subscribers.Keys)
                     if (subscribers[target])
                        Cache.Add(target);
                  ignoredCache = Cache.ToArray();
               }
            }

            return ignoredCache;

            
         }
      }

      public SubscriberCollection AcknowledgedSubscribers {
         get {
            if (null == acknowledgedCache) {
               lock (cacheLock) {
                  List<IReportSubscriber> Cache = new List<IReportSubscriber>();
                  foreach (IReportSubscriber target in subscribers.Keys)
                     if (!subscribers[target])
                        Cache.Add(target);
                  acknowledgedCache = Cache.ToArray();
               }
            }

            return acknowledgedCache;
         }
      }

      public SubscriberCollection AllSubscribers {
         get { return subscribers.Keys; }
      }

      #region IReportServer Implementation
      void IReportServer.RegisterSubscriber(IReportSubscriber t) { RegisterSubscriber(t, false); }
      public void UnregisterSubscriber(IReportSubscriber t) {
         lock (cacheLock) {
            if (subscribers.ContainsKey(t)) {
               subscribers.Remove(t);
               acknowledgedCache = null;
               ignoredCache = null;
            }
         }
      }
      void IReportServer.DispatchReport(Report r, out DeliveryFailure[] f) { Dispatch(r, out f); }

      SubscriberCollection IReportServer.Subscribers { get { return AllSubscribers; } }
      #endregion

      #region IReportSubscriber Implementation
      bool IReportSubscriber.Accepting { get { return true; } }
      void IReportSubscriber.ReceiveReport(Report report) {
         DeliveryFailure[] Failures;
         Dispatch(report, out Failures);
         if (Failures.Length > 0)
            throw DeliveryFailure.CreateException(
               "Framework_ReportServer_FailedReportDeliveries " + Failures.Length.ToString(),
               Failures);
      }
      string IReportSubscriber.Name { get { return this.name; } }
      #endregion

      private static IReportServer activeServer = null;
      private static bool          configurationLocked = false;

      protected Dictionary<IReportSubscriber, bool> subscribers;
      protected SubscriberCollection ignoredCache;
      protected SubscriberCollection acknowledgedCache;
      protected object cacheLock;
      private   string name;
   }

   [Serializable]
   public struct DeliveryFailure {
      public DeliveryFailure(IReportSubscriber subscriber, Exception e) {
         this.subscriber = subscriber.Name;
         this.exception  = e;
      }

      public static Exception CreateException(string message, IEnumerable<DeliveryFailure> failures) {
         StringBuilder Builder = new StringBuilder();
         Builder.AppendFormat("{0}\r\n\r\n", message);
         foreach (DeliveryFailure Failure in failures)
            Builder.AppendLine(Failure.ToString());

         return new Exception(Builder.ToString());
      }

      public string Subscriber { get { return this.subscriber; } }
      public Exception Exception { get { return this.exception; } }

      public override string ToString() {
         return string.Format(
            "Subscirber: {0}\r\nException: {1}",
            subscriber,
            exception);
      }

      private string subscriber;
      private Exception exception;
   }

   public interface IReportServer {
      void RegisterSubscriber(IReportSubscriber target);
      void UnregisterSubscriber(IReportSubscriber target);
      void DispatchReport(Report report, out DeliveryFailure[] failures);

      SubscriberCollection Subscribers { get; }
   }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\wsmonitor\wsmFramework\Reporting.ReportSubscriber.cs ===
using System;
using System.Collections;
using System.Collections.Generic;
using System.Text;

namespace WSMonitor.Framework.Reporting {
   public abstract class ReportSubscriber : ContextBoundObject, IReportSubscriber {
      public ReportSubscriber(string name, SubscriberFlags flags) {
         this.flags = flags;
         this.name = string.IsNullOrEmpty(name) ? "" : name;
      }

      public ReportSubscriber(string name) : this(name, SubscriberFlags.Default) { }

      public abstract void HandleReport(Report report);

      public SubscriberFlags Flags { get { return flags; } }

      #region IReportServer Implementation
      bool IReportSubscriber.Accepting { get { return true; } }
      void IReportSubscriber.ReceiveReport(Report report) {
         if ((flags | SubscriberFlags.IgnoreIncremental) == 0 || report.Parent == null)
            HandleReport(report);
      }
      string IReportSubscriber.Name { get { return this.name; } }
      #endregion

      protected SubscriberFlags flags;
      protected bool accepting;
      private string name;
   }

   public enum SubscriberFlags : int {
      Default = 0,
      IgnoreIncremental = 1
   }

   public interface IReportSubscriber {
      void ReceiveReport(Report report);

      string Name { get; }
      bool Accepting { get; }
   }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\wsmonitor\wsmFramework\Services.cs ===
namespace LiveServiceMonitor.Framework.Services
{
    #region Using Directives
    using System;
    using System.IO;

    using System.Collections;
    using System.Collections.Generic;

    using System.Runtime.Remoting.Channels;
    using System.Runtime.Remoting.Messaging;
    using System.Runtime.Serialization;

    using System.CodeDom;

    using System.Security.Permissions;
    #endregion

    /// <summary>
    /// Defines an interface for invoking service code building.
    /// </summary>
    public interface IServiceCodeGenerator
    {
        CodeCompileUnit GenerateCode(IDictionary context, out string typeName);
    }

    /// <summary>
    /// Each service protocol must be associated with an IServiceProtocol interface.
    /// This interface exposes properties required to construct and connect a service.
    /// </summary>
    public interface IServiceProtocol
    {
        /// <summary>
        /// Used to initialize the service protocol object.  As policy this must be invoked
        /// prior to accessing the exposed properties.
        /// </summary>
        /// <param name="context">
        /// Provides a bag of properties for initialization.  These properties are typically
        /// derived from a combination of service and environment properites.
        /// </param>
        void Initialize(IDictionary context);

        /// <summary>Activates a service object for this particular protocol</summary>
        /// <param name="serviceType">Type associated with the service</param>
        /// <param name="args">Constructor arguments</param>
        /// <returns>An instance of the desired service</returns>
        MarshalByRefObject ActivateService(Type serviceType, params object[] constructorArgs);

        /// <summary>Gets the object responsible for generating the source code.</summary>
        IServiceCodeGenerator CodeGenerator { get; }
        /// <summary>Gets the channel associated with sending.</summary>
        IChannelSender ChannelSender { get; }
        /// <summary>Gets the channel associated with receiving.</summary>
        IChannelReceiver ChannelReceiver { get; }
        /// <summary>Get the sink that prepares client state before sending across the communication channel.</summary>
        Type ContextSwitchSinkType { get; }
        /// <summary>Gets the scheme associated with the Uri, (example: http)</summary>
        string UriScheme { get; }
        /// <summary>Gets the secure scheme associated with the Uri, (example: https)</summary>
        string SecureUriScheme { get; }
    }

    public abstract class ServiceCodeGenerator : IServiceCodeGenerator
    {
        public abstract CodeCompileUnit GenerateCode(IDictionary context, out string typeName);

        public const string UriProperty = "__uri";
        public const string NamespaceProperty = "__namespace";
        public const string X509CertificateProperty = "__x509Certificate";
        public const string ConfigurationPathProperty = "__configurationPath";
        public const string ServiceAliasProperty = "__serviceAlias";
    }

    public abstract class ServiceProtocol : IServiceProtocol
    {
        /// <summary>
        /// Used to initialize the service protocol object.  As policy this must be invoked
        /// prior to accessing the exposed properties.
        /// </summary>
        /// <param name="context">
        /// Provides a bag of properties for initialization.  These properties are typically
        /// derived from a combination of service and environment properites.
        /// </param>
        public abstract void Initialize(IDictionary context);

        /// <summary>Activates a service object for this particular protocol</summary>
        /// <param name="serviceType">Type associated with the service</param>
        /// <param name="args">Constructor arguments</param>
        /// <returns>An instance of the desired service</returns>
        public virtual MarshalByRefObject ActivateService(Type serviceType, params object[] constructorArgs)
        {
            if (initialized)
            {
                if (typeof(MarshalByRefObject).IsAssignableFrom(serviceType))
                    return (MarshalByRefObject)Activator.CreateInstance(serviceType, constructorArgs);
                else
                    throw new InvalidOperationException(
                       string.Format("ServiceProtocol_InvalidType {0} isn't a subclass of MarshalByRefObject",
                          serviceType.FullName));
            }

            throw new ServiceProtocolUninitializedException();
        }

        /// <summary>Gets the object responsible for generating the source code.</summary>
        public virtual IServiceCodeGenerator CodeGenerator
        {
            get
            {
                if (initialized)
                    return codeGenerator;

                throw new ServiceProtocolUninitializedException();
            }
        }
        /// <summary>Gets the channel associated with sending.</summary>
        public virtual IChannelSender ChannelSender
        {
            get
            {
                if (initialized)
                    return channelSender;

                throw new ServiceProtocolUninitializedException();
            }
        }
        /// <summary>Gets the channel associated with receiving.</summary>
        public virtual IChannelReceiver ChannelReceiver
        {
            get
            {
                if (initialized)
                    return channelReceiver;

                throw new ServiceProtocolUninitializedException();
            }
        }
        /// <summary>Get the sink type that prepares client state before sending across the communication channel.</summary>
        public virtual Type ContextSwitchSinkType
        {
            get
            {
                if (initialized)
                    return contextSwitchSinkType;

                throw new ServiceProtocolUninitializedException();
            }
        }
        /// <summary>Gets the scheme associated with the Uri, (example: http)</summary>
        public abstract string UriScheme { get; }
        /// <summary>Gets the secure scheme associated with the Uri, (example: https)</summary>
        public abstract string SecureUriScheme { get; }

        /// <summary>
        /// Adds the specified property bag to the registar.
        /// </summary>
        /// <param name="properties">Propery bag to add</param>
        /// <returns>The unique id property bag is saved under.</returns>
        public static string RegisterPropertyBag(IDictionary properties)
        {
            string uid = Guid.NewGuid().ToString();

            if (null == propertyRegistar)
                propertyRegistar = new Hashtable();

            propertyRegistar[uid] = properties;

            return uid;
        }

        /// <summary>
        /// Gets a property bag stored with the specified unique identifier.
        /// </summary>
        /// <param name="uid">The unique identifier.</param>
        /// <returns>The property bag that was saved under this id, or null.</returns>
        public static IDictionary RetrievePropertyBag(string uid)
        {
            if (null == propertyRegistar || !propertyRegistar.ContainsKey(uid))
                return null;

            return (IDictionary)propertyRegistar[uid];
        }

        private static Hashtable propertyRegistar;

        protected bool initialized;
        protected IServiceCodeGenerator codeGenerator;
        protected IChannelSender channelSender;
        protected IChannelReceiver channelReceiver;
        protected Type contextSwitchSinkType;
    }

    #region Detailed Exceptions
    [Serializable]
    public sealed class ServiceCodeGeneratorException : Exception
    {
        public ServiceCodeGeneratorException() { }
        public ServiceCodeGeneratorException(string message) : base(message) { }
        public ServiceCodeGeneratorException(string message, Exception inner) : base(message, inner) { }
        private ServiceCodeGeneratorException(
            SerializationInfo info,
            StreamingContext context)
            : base(info, context) { }
    }

    [Serializable]
    public sealed class ServiceProtocolUninitializedException : Exception
    {
        public ServiceProtocolUninitializedException() { }
        public ServiceProtocolUninitializedException(string message) : base(message) { }
        public ServiceProtocolUninitializedException(string message, Exception inner) : base(message, inner) { }
        private ServiceProtocolUninitializedException(
           SerializationInfo info,
           StreamingContext context)
            : base(info, context) { }
    }

    [Serializable]
    public sealed class ContextMissingParameterException : Exception
    {
        public ContextMissingParameterException() { }
        public ContextMissingParameterException(string message) : this(message, null) { }
        public ContextMissingParameterException(string message, string property) : base(message) { this.property = property; }
        private ContextMissingParameterException(
           SerializationInfo info,
           StreamingContext context)
            : base(info, context)
        {
            property = info.GetString("__property");
        }

        [SecurityPermission(SecurityAction.LinkDemand, Flags = SecurityPermissionFlag.SerializationFormatter)]
        public override void GetObjectData(SerializationInfo info, StreamingContext context)
        {
            base.GetObjectData(info, context);
            info.AddValue("__property", property);
        }

        public override string Message
        {
            get
            {
                string message = base.Message;
                message = string.IsNullOrEmpty(message) ? "Context missing property" : message;
                return message + (string.IsNullOrEmpty(Property) ? "." : " : " + Property + ".");
            }
        }

        public string Property { get { return string.IsNullOrEmpty(property) ? "" : property; } }

        private string property;
    }
    #endregion
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\wsmonitor\wsmFramework\Services.ServiceProtocolManager.cs ===
namespace LiveServiceMonitor.Framework.Services {
   #region Using Directives
	using System;
	
   using System.Reflection;

   using System.Collections.Generic;
   
   using System.Xml.XPath;

   using System.Configuration;
	#endregion

   public class ServiceProtocolManager {
      private XPathNavigator managementRoot;

      public ServiceProtocolManager(XPathNavigator managementRoot) {
         this.managementRoot = managementRoot;
      }

      public Type GetServiceProtocolType(string protocol) {
         ServiceProtocolEntry Entry =
            ServiceProtocolEntry.Locate(managementRoot, protocol);

         if (null != Entry && typeof(IServiceProtocol).IsAssignableFrom(Entry.Handler))
            return Entry.Handler;

         return null;
      }

      public IServiceProtocol GetServiceProtocol(string protocol) {
         return GetServiceProtocol(protocol, new object[0]);
      }

      public IServiceProtocol GetServiceProtocol(string protocol, params object[] constructorArgs) {
         Type Handler;

         Handler = GetServiceProtocolType(protocol);
         if (null != Handler)
            return Activator.CreateInstance(Handler, constructorArgs) as IServiceProtocol;

         return null;
      }
   }

   /// <summary>
   /// This class is used to describe a service protocol entry.
   /// </summary>
   public sealed class ServiceProtocolEntry  {
      private XPathNavigator navigator;
      private XPathNavigator handler;

      public ServiceProtocolEntry(XPathNavigator navigator) {
         this.navigator = navigator.Clone();
         this.handler = this.navigator.SelectSingleNode("handler");
         if (handler == null)
            throw new InvalidOperationException("ServiceProtocolSection_MissingElement handler");
      }

      public string Protocol {
         get { return navigator.GetAttribute("protocol", ""); }
         set {
            if (!navigator.CanEdit)
               throw new InvalidOperationException("ServiceProtocolSection_ReadOnly");

            navigator.CreateAttribute("", "protocol", "", value);
         }
      }

      public Type Handler {
         get { return Type.GetType(handler.Value); }
         set { 
            if (!handler.CanEdit)
               throw new InvalidOperationException("ServiceProtocolSection_ReadOnly");

            handler.InnerXml = value.AssemblyQualifiedName;
         }
      }

      public static ServiceProtocolEntry Locate(XPathNavigator start, string protocol) {
         XPathNavigator Navigator;

         Navigator = start.SelectSingleNode(
            string.Format("entry[@protocol='{0}']", protocol));

         if (null == Navigator || Navigator.IsEmptyElement)
            return null;

         return new ServiceProtocolEntry(Navigator);
      }
   }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\wsmonitor\wsmFramework\Services.SoapServiceProtocol.cs ===
namespace LiveServiceMonitor.Framework.Services {
   #region Using Directives
   using System;
   using System.IO;

   using System.Collections;
   using System.Collections.Generic;

   using System.Runtime.Remoting.Channels;
   using System.Runtime.Remoting.Messaging;
   using System.Runtime.Serialization;

   using System.CodeDom;
   #endregion

   public sealed class SoapServiceProtocol : ServiceProtocol {
      public SoapServiceProtocol() { }

      public override void Initialize(IDictionary context) {
         string Uri, Namespace;

         Uri = null;
         if (context.Contains(ServiceCodeGenerator.UriProperty))
            Uri = context[ServiceCodeGenerator.UriProperty] as string;

         Namespace = null;
         if (context.Contains(ServiceCodeGenerator.NamespaceProperty))
            Namespace = context[ServiceCodeGenerator.NamespaceProperty] as string;

         codeGenerator = new SoapServiceCodeGenerator(Uri, Namespace);
         channelSender = null;
         channelReceiver = null;
         contextSwitchSinkType = typeof(HttpX509CertificateSink);

         initialized = true;
      }

      public override string UriScheme { get { return "http"; } }
      public override string SecureUriScheme { get { return "https"; } }
   }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\wsmonitor\wsmFramework\Services.HttpX509CertificateSink.cs ===
namespace LiveServiceMonitor.Framework.Services
{
    #region Using Directives
    using System;

    using System.Collections;

    using System.Runtime.Remoting.Messaging;

    using System.Security.Cryptography.X509Certificates;

    using System.Web.Services.Protocols;

    using System.Threading;
    using System.Net.Security;
    using System.Net;

    using System.Security.Permissions;
    #endregion

    public class HttpX509CertificateSink : IMessageSink
    {
        public HttpX509CertificateSink(IMessageSink next)
        {
            string rid;

            this.cert = null;
            this.next = next;

            rid = ServiceProxy.GetRegistarIdentifer();

            if (null != rid)
            {
                IDictionary PropertyBag = ServiceProtocol.RetrievePropertyBag(rid);
                if (PropertyBag.Contains(ServiceCodeGenerator.X509CertificateProperty))
                    cert = (X509Certificate)PropertyBag[ServiceCodeGenerator.X509CertificateProperty];
            }
        }

        #region IMessageSink Members
        [SecurityPermission(SecurityAction.LinkDemand, Flags = SecurityPermissionFlag.Infrastructure)]
        IMessageCtrl IMessageSink.AsyncProcessMessage(IMessage msg, IMessageSink replySink)
        {
            throw new NotSupportedException();
        }

        IMessageSink IMessageSink.NextSink
        {
            [SecurityPermission(SecurityAction.LinkDemand, Flags = SecurityPermissionFlag.Infrastructure)]
            get { return this.next; }
        }

        [SecurityPermission(SecurityAction.LinkDemand, Flags = SecurityPermissionFlag.Infrastructure)]
        IMessage IMessageSink.SyncProcessMessage(IMessage msg)
        {
            HttpWebClientProtocol Target = ServiceProxy.GetTarget(msg) as HttpWebClientProtocol;

            if (null != Target && null != cert)
            {
                if (!Target.ClientCertificates.Contains(cert))
                {
                    Target.ClientCertificates.Add(cert);
                    ServicePointManager.ServerCertificateValidationCallback =
                       new RemoteCertificateValidationCallback(RemoteCertficateValidator);
                }
            }

            return next.SyncProcessMessage(msg);
        }
        #endregion

        public static bool RemoteCertficateValidator(object sender, X509Certificate certificate, X509Chain chain, SslPolicyErrors sslPolicyErrors)
        {
            if ((sslPolicyErrors & SslPolicyErrors.RemoteCertificateChainErrors) == SslPolicyErrors.RemoteCertificateChainErrors)
                return false;
            else if ((sslPolicyErrors & SslPolicyErrors.RemoteCertificateNameMismatch) == SslPolicyErrors.RemoteCertificateNameMismatch)
                return false;

            return true;
        }

        private X509Certificate cert;
        private IMessageSink next;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\wsmonitor\wsmFramework\unit_Root.cs ===
namespace WSMonitor.Framework {
   #region Using Directives
   using LiveServiceMonitor.Test;
   #endregion

   [UnitTestRoot]
   public class UnitTestRoot : UnitTest {
      public UnitTestRoot()
         : base("Live Service Monitoring Framework - Framework Code Base") 
      {
         unitTests.Add(new Reporting.Report());
         unitTests.Add(new Reporting.ReportProxy());
      }
   }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\wsmonitor\wsmFramework\obj\i386\_generated.cs ===
[assembly:System.Runtime.InteropServices.ComVisible(false)]
[assembly:System.Reflection.AssemblyVersion("12.4.56.0")]
[assembly:System.Reflection.AssemblyProduct("Microsoft(R) Xbox(TM)")]
[assembly:System.Reflection.AssemblyCopyright("Copyright (c) Microsoft Corporation. All rights reserved.")]
[assembly:System.Reflection.AssemblyCompany("Microsoft Corporation")]
[assembly:System.Reflection.AssemblyFileVersion("12.4.56.0")]
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\wsmonitor\wsmFramework\obj\i386\_asmid.inc ===
ASSEMBLY_IDENTITY_KEY_FORM=msil_wsmframework_none_12.4.56.0_none_f656a7dbf6d7b01a
ASSEMBLY_IDENTITY_XP_KEY_FORM=msil_wsmframework_no-public-key_12.4.56.0_x-ww_63606810
ASSEMBLY_IDENTITY_CULTURE=
ASSEMBLY_IDENTITY_NAME=wsmframework
ASSEMBLY_IDENTITY_PROCESSOR_ARCHITECTURE=msil
ASSEMBLY_IDENTITY_PUBLIC_KEY=
ASSEMBLY_IDENTITY_PUBLIC_KEY_TOKEN=
ASSEMBLY_IDENTITY_TYPE=
ASSEMBLY_IDENTITY_TYPE_NAME=
ASSEMBLY_IDENTITY_VERSION=12.4.56.0
XP_KEY_FORM=msil_wsmframework_no-public-key_12.4.56.0_x-ww_63606810
XP_MANIFEST_DIRECTORY=manifests
XP_MANIFEST_NAME=msil_wsmframework_no-public-key_12.4.56.0_x-ww_63606810.manifest
XP_MANIFEST_PATH=manifests\msil_wsmframework_no-public-key_12.4.56.0_x-ww_63606810.manifest
XP_CATALOG_DIRECTORY=manifests
XP_CATALOG_NAME=msil_wsmframework_no-public-key_12.4.56.0_x-ww_63606810.cat
XP_CATALOG_PATH=manifests\msil_wsmframework_no-public-key_12.4.56.0_x-ww_63606810.cat
XP_PAYLOAD_PATH=msil_wsmframework_no-public-key_12.4.56.0_x-ww_63606810
_DELAY_SIGN=0
!if [set _ASMIDTOATTRIBS_TLBIMP=]
!endif
CODESIGN_TESTKEY=
_TLBIMP_FLAGS=$(_TLBIMP_FLAGS)  /asmversion:12.4.56.0
_ASSEMBLY_IDENTITY=wsmframework,processorArchitecture=msil,version=12.4.56.0,publicKeyToken=neutral
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\wsmonitor\wsmFramework\objd\i386\_asmid.inc ===
ASSEMBLY_IDENTITY_KEY_FORM=msil_wsmframework_none_12.4.56.0_none_f656a7dbf6d7b01a
ASSEMBLY_IDENTITY_XP_KEY_FORM=msil_wsmframework_no-public-key_12.4.56.0_x-ww_63606810
ASSEMBLY_IDENTITY_CULTURE=
ASSEMBLY_IDENTITY_NAME=wsmframework
ASSEMBLY_IDENTITY_PROCESSOR_ARCHITECTURE=msil
ASSEMBLY_IDENTITY_PUBLIC_KEY=
ASSEMBLY_IDENTITY_PUBLIC_KEY_TOKEN=
ASSEMBLY_IDENTITY_TYPE=
ASSEMBLY_IDENTITY_TYPE_NAME=
ASSEMBLY_IDENTITY_VERSION=12.4.56.0
XP_KEY_FORM=msil_wsmframework_no-public-key_12.4.56.0_x-ww_63606810
XP_MANIFEST_DIRECTORY=manifests
XP_MANIFEST_NAME=msil_wsmframework_no-public-key_12.4.56.0_x-ww_63606810.manifest
XP_MANIFEST_PATH=manifests\msil_wsmframework_no-public-key_12.4.56.0_x-ww_63606810.manifest
XP_CATALOG_DIRECTORY=manifests
XP_CATALOG_NAME=msil_wsmframework_no-public-key_12.4.56.0_x-ww_63606810.cat
XP_CATALOG_PATH=manifests\msil_wsmframework_no-public-key_12.4.56.0_x-ww_63606810.cat
XP_PAYLOAD_PATH=msil_wsmframework_no-public-key_12.4.56.0_x-ww_63606810
_DELAY_SIGN=0
!if [set _ASMIDTOATTRIBS_TLBIMP=]
!endif
CODESIGN_TESTKEY=
_TLBIMP_FLAGS=$(_TLBIMP_FLAGS)  /asmversion:12.4.56.0
_ASSEMBLY_IDENTITY=wsmframework,processorArchitecture=msil,version=12.4.56.0,publicKeyToken=neutral
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\wsmonitor\wsmFramework\Scripting.cs ===
using System;
using System.Reflection;
using System.Collections.Generic;
using System.Collections;

using WSMonitor.Framework.Exceptions;

namespace WSMonitor.Framework.Scripting {
   /// <summary>
   /// 
   /// </summary>
   /// <remarks>
   /// This class (and sub classes) must contain only 1 public constructor.
   /// </remarks>
   public abstract class Script : ContextBoundObject, IScript {
      protected const string HostEnvironment = "localhost";

      public Script() {
         throw new NotImplementedException();
      }

      [ScriptModelConstructor]
      public Script(long instance, Type[] aspectTypes) {
         this.instance        = instance;
         this.aspectTypes     = aspectTypes;
         this.acquired        = false;
      }

      /// <summary>
      /// Used by constructor generated for script.  This method will reflect on the
      /// type and locate the MethodInfo for the Method decorated with the Native.Start
      /// attribute.
      /// </summary>
      /// <param name="executionTarget">the located method is stored here.</param>
      /// <exception cref="ScriptException">Indicates the method could not be found.</exception>
      public void GetExecutionTarget(out MethodInfo executionTarget) {
         executionTarget = null;
         if (!acquired) {
            MethodInfo[] Methods;

            Methods     = GetType().GetMethods(BindingFlags.Instance | BindingFlags.Public | BindingFlags.DeclaredOnly);
            foreach (MethodInfo Method in Methods) {
               Native.StartAttribute[] Attribs;
               Attribs = (Native.StartAttribute[])Method.GetCustomAttributes(typeof(Native.StartAttribute), true);
               executionTarget = Method;
               break;
            }

            acquired = true;
         }
         if (null == executionTarget)
            throw new ScriptException("Framework_Script_NoNativeStart");
      }

      protected long   Instance { get { return instance; } }
      internal  Type[] AspectTypes { get { return aspectTypes; } }

      public virtual object Execute(object[] parameters) { throw new NotImplementedException(); }

      #region IScript Implementation
      public virtual void ExceptionNotification(Exception e) { }
      public virtual void FinishedNotification() { }
      #endregion

      public object Execute(string alias, params object[] args) { return Script.Execute(alias, Instance, args); }
      public bool   ExecuteTest(string alias) { return (bool)Script.Execute(alias, Instance, null); }

      #region Static Execution Members
      private static Type[] getScriptAspects(int identifier, ScriptType type) {
         List<Type> Aspects = new List<Type>();
         
         Aspects.AddRange(Configuration.Aspects[type]);
         foreach (Type aspect in Configuration.ScriptAspects[identifier]) {
            if (!Aspects.Contains(aspect))
               Aspects.Add(aspect);
         }

         return Aspects.ToArray();
      }

      public static object[] GetConstructorArgs(ScriptMetadataAttribute attribute, long instance) {
         return new object[] { instance, getScriptAspects(attribute.Id, attribute.Type) };
      }

      internal static object Execute(string alias, long instance, params object[] args) {
         if (registar.ContainsKey(alias)) {
            Script ScriptInstance;

            try {
               ScriptMetadataAttribute   Metadata;

               Metadata = Script.GetMetadata(registar[alias]);
               ScriptInstance = (Script)Activator.CreateInstance(
                  registar[alias],
                  GetConstructorArgs(Metadata, instance));
            }
            catch (Exception e) {
               throw new ScriptException(
                  string.Format("Framework_Script_CannotCreate {0}", alias), e);
            }

            object Result;

            try {
               System.Runtime.Remoting.Messaging.CallContext.SetData("instance", instance);
               Result = ScriptInstance.Execute(args); 
            }
            catch (Exception e) {
               try { ScriptInstance.ExceptionNotification(e); }
               catch { }
               throw e;
            }
            finally {
               try { ScriptInstance.FinishedNotification(); }
               catch { }
            }

            return Result;
         }

         throw new ScriptException(
            string.Format("Framework_Script_DoesNotExist {0}", alias));
      }

      public static void RegisterScript(Type s) {
         if (!Script.locked) {
            ScriptMetadataAttribute Metadata;

            Metadata = Script.GetMetadata(s);

            if (!typeof(Script).IsAssignableFrom(s))
               throw new ScriptException("Framework_Script_InvalidBaseInheritence");
            if (null == Metadata)
               throw new ScriptException("Framework_Script_MissingMetadata");
            if (registar.ContainsKey(Metadata.Alias))
               throw new ScriptException(string.Format("Framework_Script_DuplicateAlias {0}", Metadata.Alias));

            registar.Add(Metadata.Alias, s);

            return;
         }

         throw new InvalidOperationException("Framework_Script_RegistrationLocked");
      }

      public static void LockRegistration() {
         locked = true;
      }

      public static ScriptMetadataAttribute GetMetadata(Type t) {
         ScriptMetadataAttribute[] Attributes;
         Attributes = (ScriptMetadataAttribute[])t.GetCustomAttributes(smType, true);
         return null == Attributes || Attributes.Length < 1 ? null : Attributes[0];
      }

      public static ScriptMetadataAttribute GetMetadata(Script s) {
         return GetMetadata(s.GetType());
      }

      private static Type                       smType = typeof(ScriptMetadataAttribute);
      private static bool                       locked = false;
      private static Dictionary<string, Type>   registar = new Dictionary<string,Type>();
      #endregion

      #region Static Properties
      /// <summary>Exposes a globally scoped property bag.</summary>
      public static Hashtable Globals { get { return globals; } }

      private static readonly Hashtable globals = new Hashtable();
      #endregion

      private long instance;
      private Type[] aspectTypes;
      private bool acquired;

      public class Configuration {
         static Configuration() {
            aspects = new Dictionary<ScriptType, Type[]>();
            scriptAspects = new Dictionary<int, Type[]>();
         }

         public static Dictionary<ScriptType, Type[]> Aspects {
            get { return aspects; }
         }

         public static Dictionary<int, Type[]> ScriptAspects {
            get { return scriptAspects; }
         }

         private static Dictionary<ScriptType, Type[]> aspects;
         private static Dictionary<int, Type[]> scriptAspects;
      }
   }

   public enum ScriptType : int {
      General = 10,
      Test = 30
   }

   public interface IScript {
      void ExceptionNotification(Exception e);
      void FinishedNotification();
   }

   [AttributeUsage(AttributeTargets.Constructor, AllowMultiple = false, Inherited = true)]
   public class ScriptModelConstructorAttribute : Attribute {
      public ScriptModelConstructorAttribute() { }
   }

   [AttributeUsage(AttributeTargets.Class, AllowMultiple = false, Inherited = true)]
   public class ScriptMetadataAttribute : Attribute {
      public ScriptMetadataAttribute(string dummy) {
         throw new NotImplementedException("this method is only a placeholder to allow scripts to compile outside of lsmonitor.");
      }

      public ScriptMetadataAttribute(string alias, int id, ScriptType type) {
         System.Diagnostics.Debug.Assert(
            !string.IsNullOrEmpty(alias),
            "ScriptMetadataAttribute: Alias cannot be null or empty.");

         this.alias = alias;
         this.id = id;
         this.type = type;
      }

      public string Alias { get { return alias; } }
      public ScriptType Type { get { return type; } }
      public int Id { get { return id; } }

      private ScriptType type;
      private int id;
      private string alias;
   }

   public sealed class Native {
      public sealed class StartAttribute : Attribute {
         public StartAttribute() { }
      }
   }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\wsmonitor\wsmFramework\unit_Reporting.Report.cs ===
namespace WSMonitor.Framework.Reporting {
   #region Using Directives
   using System;
   using System.Collections.Generic;
   using System.Xml;
   using System.Reflection;
   using System.Text;
   using LiveServiceMonitor.Test;
   #endregion

   public partial class Report : IUnitTest {
      #region IUnitTest Implementation
      /// <summary>Gets the name of the unit test.</summary>
      string IUnitTest.Name { get { return "Report Functionality"; } }
      /// <summary>Gets the child test cases.</summary>
      IEnumerable<IUnitTest> IUnitTest.UnitTests {
         get {
            if (null == unitTests) {
               unitTests = new IUnitTest[] {
                  new DelegatedUnitTestLeaf(
                     "Single Report to XML to Report", 
                     new UnitTest.NodeTestDelegate(ut_SerializationDeserializationValues)),
                  new DelegatedUnitTestLeaf(
                     "Nested Report to XML to Report", 
                     new UnitTest.NodeTestDelegate(ut_SerializationDeserializationNesting))
               };
            }

            return unitTests;
         }
      }
      /// <summary>Performs the unit test.</summary>
      /// <param name="xmlLog">XmlLog to be written to.</param>
      /// <returns>True indicates the test passed.</returns>
      bool IUnitTest.Test(XmlWriter xmlLog) {
         return UnitTest.BasicUnitTest(this, null, xmlLog);
      }
      #endregion

      /// <summary>
      /// Verifies that the properties of the Report are preserved after being serialized
      /// and deserialized back to a Report.
      /// </summary>
      /// <param name="message">Output error messages.</param>
      /// <returns>True indicates the unit test passed.</returns>
      private static bool ut_SerializationDeserializationValues(out string message) {
         const string c1 = "Cat1";
         const string c2 = "Cat2";
         int v1 = 22;
         double v2 = 3.1415;

         Report report;
         XmlDocument doc;
         Guid originalGuid;
         ReportCategory originalCategory;
         
         try { report = new Report(); }
         catch (Exception e) {
            message = string.Format("ERROR: failed to create Report instance, exception={0}. ", e);
            return false;
         }

         report.Properties[c1] = v1;
         report.Properties[c2] = v2;

         originalGuid = report.Guid;
         originalCategory = report.Category;

         try { doc = ReportFactory.CreateDocument(report); }
         catch (Exception e) {
            message = string.Format("ERROR: failed to serialize Report to xml document, exception={0}. ", e);
            return false;
         }

         try { report = ReportFactory.CreateReport(doc); }
         catch (Exception e) {
            message = string.Format("ERROR: failed to deserialize report from xml document, exception={0}. ", e);
            return false;
         }

         bool Success;

         Success = true;
         message = "";
         
         if (!report.Properties.ContainsKey(c1)) {
            message += string.Format("ERROR: dictionary property {0} is missing from the deserialization. ", c1);
            Success = false;
         }
         else {
            if (0 != v1.CompareTo(report.Properties[c1])) {
               object o = report.Properties[c1];
               message += string.Format("ERROR: dictionary property {0} changed after the deserialization, expected={1}, actual={2}. ",
                  c1, v1, null == o ? "(null)" : o);
               Success = false;
            }
         }

         if (!report.Properties.ContainsKey(c2)) {
            message += string.Format("ERROR: dictionary property {0} is missing from the deserialization. ", c2);
            Success = false;
         }
         else {
            if (0 != v2.CompareTo(report.Properties[c2])) {
               object o = report.Properties[c2];
               message += string.Format("ERROR: dictionary property {0} changed after the deserialization, expected={1}, actual={2}. ",
                  c2, v2, null == o ? "(null)" : o);
               Success = false;
            }
         }

         if (originalGuid != report.Guid) {
            message += string.Format("ERROR: Guid changed after deserialization, expected={0}, actual={1}. ",
               originalGuid, report.Guid);
            Success = false;
         }

         if (originalCategory != report.Category) {
            message += string.Format("ERROR: Category changed after deserialization, expected={0}, actual={1}. ",
               originalCategory, report.Category);
            Success = false;
         }

         if (null != report.Parent) {
            message += string.Format("ERROR: Parent should be null after this deserialization. ");
            Success = false;
         }

         if (null != report.Children && 0 != report.Children.Length) {
            message += string.Format("ERROR: This report should not have children after its deserialization. ");
            Success = false;
         }

         return Success;
      }

      /// <summary>
      /// Verifies that the hierarchy of Reports is preserved after being serialized
      /// and deserialized back to a Report.
      /// </summary>
      /// <param name="message">Output error messages.</param>
      /// <returns>True indicates the unit test passed.</returns>
      private static bool ut_SerializationDeserializationNesting(out string message) {
         Report report0, report1;
         XmlDocument doc;
         bool Success;
         Guid originalGuid0, originalGuid1;

         try { report0 = new Report(ReportCategory.Container, null); }
         catch (Exception e) {
            message = string.Format("ERROR: failed to create parent Report instance, exception={0}. ", e);
            return false;
         }

         try { report1 = new Report(ReportCategory.Message, report0); }
         catch (Exception e) {
            message = string.Format("ERROR: failed to create child Report instance, exception={0}. ", e);
            return false;
         }

         if (report1.Parent != report0) {
            message = string.Format("ERROR: ctor failed to map the parent Report to the child.. ");
            return false;
         }

         if (null == report0.Children || report0.Children.Length == 0) {
            message = string.Format("ERROR: parent Report does not contain any children. ");
            return false;
         }

         if (report0.Children[0] != report1) {
            message = string.Format("ERROR: parent Report contains the wrong child. ");
            return false;
         }

         originalGuid0 = report0.Guid;
         originalGuid1 = report1.Guid;

         try { doc = ReportFactory.CreateDocument(report0); }
         catch (Exception e) {
            message = string.Format("ERROR: failed to serialize parent Report to xml document, exception={0}. ", e);
            return false;
         }

         try { report0 = ReportFactory.CreateReport(doc); }
         catch (Exception e) {
            message = string.Format("ERROR: failed to deserialize parent report from xml document, exception={0}. ", e);
            return false;
         }

         Success = true;
         message = "";

         message += string.Format("ParentGuid={0}, ChildGuid={1}. ", originalGuid0, originalGuid1);

         if (report0.Guid != originalGuid0) {
            message += string.Format("ERROR: parent report was not deserialized correctly, expectedGuid={0}, actualGuid={1}. ",
               originalGuid0, report0.Guid);
            Success = false;
         }

         if (null == report0.Children || report0.Children.Length == 0) {
            message += string.Format("ERROR: children of parent Report were not added after deserialization. ");
            Success = false;
         }
         else if (report0.Children[0].Guid != originalGuid1) {
            message += string.Format("ERROR: child report was not deserialized correctly, expectedGuid={0}, actualGuid={1}. ",
               originalGuid1, report1.Guid);
            Success = false;
         }
         else {
            report1 = report0.Children[0];

            if (null != report1.Children && report1.Children.Length != 0) {
               message += string.Format("ERROR: child report acquired children after deserialization. ");
               Success = false;
            }
         }

         return Success;
      }

      private IUnitTest[] unitTests;
   }

   public partial class ReportProxy : IUnitTest {
      #region IUnitTest Implementation
      /// <summary>Gets the name of the unit test.</summary>
      string IUnitTest.Name { get { return "Report Proxy"; } }
      /// <summary>Gets the child test cases.</summary>
      IEnumerable<IUnitTest> IUnitTest.UnitTests {
         get {
            if (null == unitTests) {
               unitTests = new IUnitTest[] {
                  new DelegatedUnitTestLeaf(
                     "PublicFieldsMap",
                     new UnitTest.NodeTestDelegate(ut_PublicFieldMap)),
                  new DelegatedUnitTestLeaf(
                     "PublicPropertiesMap",
                     new UnitTest.NodeTestDelegate(ut_PublicPropertyMap)),
                  new DelegatedUnitTestLeaf(
                     "PublicMethodsMap",
                     new UnitTest.NodeTestDelegate(ut_PublicMethodMap))
               };
            }

            return unitTests;
         }
      }
      /// <summary>Performs the unit test.</summary>
      /// <param name="xmlLog">XmlLog to be written to.</param>
      /// <returns>True indicates the test passed.</returns>
      bool IUnitTest.Test(XmlWriter xmlLog) {
         return UnitTest.BasicUnitTest(this, null, xmlLog);
      }
      #endregion

      #region Unit Test Cases
      /// <summary>
      /// Unit test case.
      /// Tests that properties are mapped correctly.
      /// </summary>
      /// <param name="message">Output error messages.</param>
      /// <returns>True indicates the unit test passed.</returns>
      private static bool ut_PublicPropertyMap(out string message) {
         Dictionary<string, PropertyInfo> collection;
         StringBuilder Messages;
         BindingFlags Binding;
         bool Passed;

         Binding = BindingFlags.Instance | BindingFlags.Public | BindingFlags.DeclaredOnly;

         //Populating maps with report public properties.
         collection = new Dictionary<string, PropertyInfo>();
         foreach (PropertyInfo prop in typeReport.GetProperties(Binding))
            collection[prop.Name] = prop;

         //Making sure all these maps have a corresponding proxy function in the proxy.
         Messages = new StringBuilder();
         Passed = true;
         foreach (PropertyInfo cur in typeProxy.GetProperties(Binding)) {
            if (collection.ContainsKey(cur.Name)) {
               PropertyInfo org = collection[cur.Name];

               if (cur.CanRead ^ org.CanRead || cur.CanWrite ^ org.CanWrite) {
                  Messages.AppendFormat(
                     "Property read/write match ({0}).  " +
                     "Public properties in ReportProxy should match those in Report.\r\n",
                     cur.Name);
                  Passed = false;
               }

               collection.Remove(cur.Name);
            }
         }

         //Verify that all properties are mapped
         foreach (string key in collection.Keys) {
            Passed = false;
            Messages.AppendFormat(
               "Property ({0}) in Report is not declared in ReportProxy.  " +
               "All properties in Report must have a corresponding proxy property in ReportProxy.\r\n",
               key);
         }

         message = Messages.ToString();
         return Passed;
      }

      /// <summary>
      /// Unit test case.
      /// Tests that fields are mapped correctly.
      /// </summary>
      /// <param name="message">Output error messages.</param>
      /// <returns>True indicates the unit test passed.</returns>
      private static bool ut_PublicFieldMap(out string message) {
         Dictionary<string, FieldInfo> collection;
         StringBuilder Messages;
         BindingFlags Binding;
         bool Passed;

         Binding = BindingFlags.Instance | BindingFlags.Public | BindingFlags.DeclaredOnly;

         //Populating maps with report public properties.
         collection = new Dictionary<string, FieldInfo>();
         foreach (FieldInfo cur in typeReport.GetFields(Binding))
            collection[cur.Name] = cur;

         //Making sure all these maps have a corresponding proxy function in the proxy.
         Messages = new StringBuilder();
         Passed = true;
         foreach (FieldInfo cur in typeProxy.GetFields(Binding)) {
            if (collection.ContainsKey(cur.Name))
               collection.Remove(cur.Name);
         }

         //Verify that all properties are mapped
         foreach (string key in collection.Keys) {
            Passed = false;
            Messages.AppendFormat(
               "Field ({0}) in Report is not declared in ReportProxy.  " +
               "All fields in Report must have a corresponding proxy field in ReportProxy.\r\n",
               key);
         }

         message = Messages.ToString();
         return Passed;
      }

      /// <summary>
      /// Unit test case.
      /// Tests that methods are mapped correctly.
      /// </summary>
      /// <param name="message">Output error messages.</param>
      /// <returns>True indicates the unit test passed.</returns>
      private static bool ut_PublicMethodMap(out string message) {
         Dictionary<string, MethodInfo> collection;
         StringBuilder Messages;
         BindingFlags Binding;
         bool Passed;

         Binding = BindingFlags.Instance | BindingFlags.Public | BindingFlags.DeclaredOnly;

         //Populating maps with report public properties.
         collection = new Dictionary<string, MethodInfo>();
         foreach (MethodInfo cur in typeReport.GetMethods(Binding))
            collection[cur.ToString()] = cur;

         Messages = new StringBuilder();
         Passed = true;

         //Remove the correctly mapped methods.
         foreach (MethodInfo cur in typeProxy.GetMethods(Binding)) {
            if (collection.ContainsKey(cur.ToString()))
               collection.Remove(cur.ToString());
         }

         //Verify that all properties are mapped
         foreach (string key in collection.Keys) {
            Passed = false;
            Messages.AppendFormat(
               "Method ({0}) in Report is not declared in ReportProxy.  " +
               "All methods in Report must have a corresponding proxy method in ReportProxy.\r\n",
               key);
         }

         message = Messages.ToString();
         return Passed;
      }
      #endregion

      private IUnitTest[] unitTests;
   }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\wsmonitor\wsmFramework\Services.ServiceProxy.cs ===
namespace LiveServiceMonitor.Framework.Services
{
    #region Using Directives
    using System;
    using System.IO;

    using System.Collections;
    using System.Collections.Generic;

    using System.Runtime.Remoting;
    using System.Runtime.Remoting.Channels;
    using System.Runtime.Remoting.Messaging;
    using System.Runtime.Remoting.Proxies;
    using System.Runtime.Serialization;

    using System.Threading;

    using System.CodeDom;

    using System.Security.Permissions;
    #endregion

    /// <summary>
    /// Proxy object used to wrap service calls.
    /// </summary>
    public class ServiceProxy : RealProxy
    {
        /// <summary>
        /// Gets an array of types from an array of assembly qualified type names.
        /// </summary>
        /// <param name="typeNames">An array of assembly qualified type names.</param>
        /// <returns>An array of types</returns>
        private static Type[] GetTypes(string[] typeNames)
        {
            List<Type> Types = new List<Type>();

            if (null != typeNames)
            {
                foreach (string Name in typeNames)
                    Types.Add(Type.GetType(Name));
            }

            return Types.ToArray();
        }

        /// <summary>
        /// Initializes a new instance of the service proxy.
        /// </summary>
        /// <param name="target">Target object to be wrapped in proxy.</param>
        /// <param name="contextSinkSwitchType">Type name of sink responsible for setting client properties.</param>
        /// <param name="aspectTypes">Type names associated with the aspects</param>
        public ServiceProxy(MarshalByRefObject target, string registarId, string contextSinkSwitchType, params string[] aspectTypes) :
            this(
              target,
              registarId,
              string.IsNullOrEmpty(contextSinkSwitchType) ? null : Type.GetType(contextSinkSwitchType),
              GetTypes(aspectTypes))
        { }

        /// <summary>
        /// Initializes a new instance of the service proxy.
        /// </summary>
        /// <param name="target">Target object to be wrapped in proxy.</param>
        /// <param name="contextSinkSwitchType">Type of sink responsible for setting client properties.</param>
        /// <param name="aspectTypes">Types associated with the aspects</param>
        public ServiceProxy(MarshalByRefObject target, string registarId, Type contextSinkSwitchType, params Type[] aspectTypes)
            : base(target.GetType())
        {
            this.registarId = registarId;
            this.target = target;
            this.chainHead = null;

            /// Initialize The call state : Make sure property bag dependent sinks can gain access to these properties
            LocalDataStoreSlot Slot = Thread.AllocateNamedDataSlot(RegistarIdentiferKey);

            Thread.SetData(Slot, this.registarId);

            try
            {
                /// Terminate the chain with a message dispatcher
                chainHead = new ServiceMessageSink(target);

                /// Grow the chain by adding reporting aspects to it
                if (null != aspectTypes)
                {
                    Type AspectType = typeof(WSMonitor.Framework.Reporting.Aspect);

                    foreach (Type Item in aspectTypes)
                    {
                        if (AspectType.IsAssignableFrom(Item))
                            chainHead = (IMessageSink)Activator.CreateInstance(Item, chainHead);
                    }
                }

                /// Grow the chain by adding context switch sink to it
                if (null != contextSinkSwitchType)
                {
                    if (typeof(IMessageSink).IsAssignableFrom(contextSinkSwitchType))
                        chainHead = (IMessageSink)Activator.CreateInstance(contextSinkSwitchType, chainHead);
                }
            }
            finally
            {
                Thread.FreeNamedDataSlot(RegistarIdentiferKey);
            }
        }

        /// <summary>
        /// Execute the message after allowing for the message to be intercepted by our sinks.
        /// </summary>
        /// <param name="msg">Object representing information about the method being invoked.</param>
        /// <returns>An object representing the return values of the invocation</returns>
        [SecurityPermission(SecurityAction.LinkDemand, Flags = SecurityPermissionFlag.Infrastructure)]
        public override IMessage Invoke(IMessage msg)
        {
            msg.Properties.Add(TargetIdentiferKey, this.target);
            return chainHead.SyncProcessMessage(msg);
        }

        /// <summary>Gets the Unique Id associated with the property bag in the registar for this service.</summary>
        public string RegistarId
        {
            get { return this.registarId; }
        }

        /// <summary>
        /// Creates a new instance of a 'service' and wraps it in the ServiceProxy.
        /// </summary>
        /// <param name="target">Type associated with the service.</param>
        /// <param name="contextSinkSwitchType">Type of sink responsible for setting client properties.</param>
        /// <param name="aspectTypes">Types associated with the aspects.</param>
        /// <returns>A new instance of the type specified by target.</returns>
        public static MarshalByRefObject CreateInstance(Type target, string registarId, Type contextSinkSwitchType, params Type[] aspectTypes)
        {
            if (MarshalByRefObjectType.IsAssignableFrom(target))
            {
                ServiceProxy Proxy = new ServiceProxy(
                   (MarshalByRefObject)Activator.CreateInstance(target),
                   registarId,
                   contextSinkSwitchType,
                   aspectTypes);

                return (MarshalByRefObject)Proxy.GetTransparentProxy();
            }

            return null;
        }

        /// <summary>
        /// Creates a new instance of a 'service' and wraps it in the ServiceProxy.
        /// </summary>
        /// <param name="target">Type associated with the service.</param>
        /// <param name="contextSinkSwitchType">Type name of sink responsible for setting client properties.</param>
        /// <param name="aspectTypes">Type namess associated with the aspects.</param>
        /// <returns>A new instance of the type specified by target.</returns>
        public static MarshalByRefObject CreateInstance(Type target, string registarId, string contextSinkSwitchType, params string[] aspectTypes)
        {
            if (MarshalByRefObjectType.IsAssignableFrom(target))
            {
                ServiceProxy Proxy = new ServiceProxy(
                   (MarshalByRefObject)Activator.CreateInstance(target),
                   registarId,
                   contextSinkSwitchType,
                   aspectTypes);

                return (MarshalByRefObject)Proxy.GetTransparentProxy();
            }
            else
                throw new InvalidOperationException("ServiceProxy_InvalidType " + target.FullName);
        }

        /// <summary>
        /// Gets the service registar unique identifier associated with the current calling context.
        /// </summary>
        /// <returns>The unique identifer.</returns>
        public static string GetRegistarIdentifer()
        {
            return (string)Thread.GetData(Thread.GetNamedDataSlot(RegistarIdentiferKey));
        }

        /// <summary>
        /// Gets the object associated with the current call.
        /// </summary>
        /// <param name="msg">Message representing the current call.</param>
        /// <returns>Object associated with the current call.</returns>
        public static MarshalByRefObject GetTarget(IMessage msg)
        {
            if (msg.Properties.Contains(TargetIdentiferKey))
                return (MarshalByRefObject)msg.Properties[TargetIdentiferKey];
            return null;
        }

        /// <summary>Key associated with the storage of the unique Id in the calling context.</summary>
        public const string RegistarIdentiferKey = "registar-id";
        /// <summary>Key associated with the storage of the target object of invocation.</summary>
        public const string TargetIdentiferKey = "target-object";

        private IMessageSink chainHead;
        private string registarId;
        private MarshalByRefObject target;

        private static Type MarshalByRefObjectType = typeof(MarshalByRefObject);
    }

    /// <summary>
    /// End point message sink that sends the message to Runtime Services for execution.
    /// </summary>
    class ServiceMessageSink : IMessageSink
    {
        /// <summary>
        /// Initializes a new instance of this object type.
        /// </summary>
        /// <param name="target">Object the sink will be executing on</param>
        public ServiceMessageSink(MarshalByRefObject target)
        {
            this.target = target;
        }

        #region IMessageSink Implementation
        /// <summary>This sink is the last one in the chain, next is always null.</summary>
        IMessageSink IMessageSink.NextSink { get { return null; } }
        /// <summary>The proxy only supports synchronous calls.</summary>
        IMessageCtrl IMessageSink.AsyncProcessMessage(IMessage msg, IMessageSink replySink)
        {
            throw new NotSupportedException();
        }
        /// <summary>Executes a synchronous call to the target object.</summary>
        IMessage IMessageSink.SyncProcessMessage(IMessage msg)
        {
            return RemotingServices.ExecuteMessage(target, (IMethodCallMessage)msg);
        }
        #endregion

        private MarshalByRefObject target;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\wsmonitor\wsmFramework\objd\i386\_generated.cs ===
[assembly:System.Runtime.InteropServices.ComVisible(false)]
[assembly:System.Reflection.AssemblyVersion("12.4.56.0")]
[assembly:System.Reflection.AssemblyProduct("Microsoft(R) Xbox(TM)")]
[assembly:System.Reflection.AssemblyCopyright("Copyright (c) Microsoft Corporation. All rights reserved.")]
[assembly:System.Reflection.AssemblyCompany("Microsoft Corporation")]
[assembly:System.Reflection.AssemblyFileVersion("12.4.56.0")]
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\wsmonitor\wsmManager\makefile.inc ===
!INCLUDE $(INETROOT)\build\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\wsmonitor\wsmFramework\Services.SoapServiceCodeGenerator.cs ===
namespace LiveServiceMonitor.Framework.Services {
   #region Using Directives
   using System;
   using System.IO;

   using System.Configuration;

   using System.Collections;
   using System.Collections.Generic;

   using System.Runtime.Remoting.Channels;
   using System.Runtime.Remoting.Messaging;
   using System.Runtime.Serialization;

   using System.Security.Cryptography.X509Certificates;

   using System.Web.Services.Description;
   using System.Web.Services.Discovery;

   using System.CodeDom;

   using Microsoft.CSharp;
   #endregion

   /// <summary>
   /// Generates a proxy wrapper for a web service.
   /// </summary>
   public sealed class SoapServiceCodeGenerator : ServiceCodeGenerator {
      #region Configuration Settings Strings
      
      #endregion

      #region Constructors
      /// <summary>
      /// Initializes a new instance of SoapServiceCodeGenerator.
      /// </summary>
      public SoapServiceCodeGenerator() : this("", "") { }
      /// <summary>
      /// SoapServiceCodeGenerator
      /// </summary>
      /// <param name="uri">Default url of web service wsdl request.</param>
      /// <param name="namespace">Default namespace to place service proxy in.</param>
      public SoapServiceCodeGenerator(string uri, string @namespace) {
         this.uri = string.IsNullOrEmpty(uri) ? null : new Uri(uri);
         this.@namespace = @namespace;
      }
      #endregion
      
      /// <summary>
      /// Collects the properties from the context property bag.  The Uri and Namespace
      /// must either have been provided already and/or provied in the context property
      /// bag.
      /// </summary>
      /// <param name="context">Property bag to pull the properties from.</param>
      /// <exception cref="ContextMissingParameterException">Indicates that one of the required parameters are missing.</exception>
      private void CollectProperties(IDictionary context) {
         string Uri = null;
         string Namespace = null;

         if (context != null) {
            if (context.Contains(UriProperty))
               Uri = context[UriProperty] as string;
            if (context.Contains(NamespaceProperty))
               Namespace = context[NamespaceProperty] as string;
            if (context.Contains(ConfigurationPathProperty))
               configPath = context[ConfigurationPathProperty] as string;
            if (context.Contains(ServiceAliasProperty))
               serviceAlias = context[ServiceAliasProperty] as string;
         }

         ///Makes Uri and Namespace optional if they have already been specified
         uri = string.IsNullOrEmpty(Uri) ? uri : new Uri(Uri);
         @namespace = string.IsNullOrEmpty(Namespace) ? @namespace : Namespace;

         if (uri == null)
            throw new ContextMissingParameterException(null, UriProperty);
         if (string.IsNullOrEmpty(@namespace))
            throw new ContextMissingParameterException(null, NamespaceProperty);
         if (configPath == null)
            throw new ContextMissingParameterException(null, ConfigurationPathProperty);
         if (serviceAlias == null)
            throw new ContextMissingParameterException(null, ServiceAliasProperty);
      }

      #region IServiceCodeGenerator Implementation
      /// <summary>
      /// Replaces the default URL for the proxy with the real service URL.
      /// </summary>
      /// <param name="proxy">The proxy which will be updated.</param>
      /// <param name="url">The URL to the service for a particular environment.</param>
      private void ReplaceUrl(CodeTypeDeclaration proxy, string url) {
         ///Search for the Proxy constructor
         for (int Member = 0; Member < proxy.Members.Count; Member++) {
            if (proxy.Members[Member] is CodeConstructor) {
               CodeConstructor Constructor = proxy.Members[Member] as CodeConstructor;

               ///Only 1 statement expected in the constructor
               if (Constructor.Statements.Count != 1) {
                  throw new ServiceCodeGeneratorException(
                     string.Format("Service Constructor - expected exactly 1 statement : {0} found.",
                        Constructor.Statements.Count));
               }

               ///That one statement is expected to be an assigment statement
               if (Constructor.Statements[0] is CodeAssignStatement) {
                  CodeAssignStatement Assignment = Constructor.Statements[0] as CodeAssignStatement;

                  ///The URL is a primitive value
                  if (Assignment.Right is CodePrimitiveExpression) {
                     CodePrimitiveExpression Expression = Assignment.Right as CodePrimitiveExpression;
                     Expression.Value = url;
                     return;
                  }
                  else {
                     throw new ServiceCodeGeneratorException(
                        string.Format("Service Constructor - expected CodePrimitiveExpression on right side of assignment : {0} found.",
                           Assignment.Right.GetType().Name));
                  }

               }
               else {
                  throw new ServiceCodeGeneratorException(
                     string.Format("Service Constructor - expected a CodeAssignmentStatement statement : {0} found.",
                        Constructor.Statements[0].GetType().Name));
               }
            }
         }

         throw new ServiceCodeGeneratorException("Service Constructor not found.");
      }

      /// <summary>
      /// Generates the service proxy code for a Soap based web service.
      /// </summary>
      /// <param name="context">Property bag to pull the properties from.</param>
      /// <param name="service">Output code compilation unit.</param>
      /// <returns></returns>
      public override CodeCompileUnit GenerateCode(IDictionary context, out string typeName) {
         DiscoveryClientProtocol DiscoveryClient = null;
         DiscoveryDocument       Document;
         WebReferenceCollection  References;
         WebReference            Reference;
         CSharpCodeProvider      CodeProvider = null;
         CodeCompileUnit         CompiledCode;
         WebReferenceOptions     Options;
         string                  WSDLFileLocation = null;

         try {
            ///Collecting the required properties consumed by the generator
            CollectProperties(context);

            ///Pointing document to WSDL Description
            DiscoveryClient = new DiscoveryClientProtocol();
            DiscoveryClient.AllowAutoRedirect = true;
            if (context != null && context.Contains(X509CertificateProperty))
               DiscoveryClient.ClientCertificates.Add((X509Certificate)context[X509CertificateProperty]);

            WSDLFileLocation = Path.Combine(configPath, serviceAlias + ".wsdl");

            ///Use the local WSDL if it exists, otherwise try to generate the proxy from the service uri
            if (File.Exists(WSDLFileLocation))
               Document = DiscoveryClient.DiscoverAny(WSDLFileLocation);
            else
               throw new ServiceCodeGeneratorException(
                  string.Format("Missing WSDL File : {0}", WSDLFileLocation));
            
            DiscoveryClient.ResolveAll();

            ///Creating web references and namespace for service
            References = new WebReferenceCollection();
            Reference = new WebReference(DiscoveryClient.Documents, new CodeNamespace(@namespace));
            References.Add(Reference);

            CompiledCode = new CodeCompileUnit();
            CompiledCode.Namespaces.Add(Reference.ProxyCode);

            ///Setting Reference Options
            Options = new WebReferenceOptions();

            ///Generate Proxy code from wsdl
            CodeProvider = new CSharpCodeProvider();

            ServiceDescriptionImporter.GenerateWebReferences(
               References, 
               CodeProvider,
               CompiledCode,
               Options);

            CodeNamespace Namespace = Reference.ProxyCode;

            ///Redirect the URL with the approapriate environment service url
            ReplaceUrl(Namespace.Types[0], uri.ToString());

            ///Modifying namespace name to prevent type collisions
            Namespace.Name += string.Format(".{0}Proxies", Namespace.Types[0].Name);
            
            ///Fetches the name of the SOAP service
            typeName = Namespace.Name + "." + Namespace.Types[0].Name;
         }
         catch (Exception inner) {
            typeName = null;
            CompiledCode = null;

            throw new ServiceCodeGeneratorException(
               string.Format("Unable to generate : {0}", uri),
               inner);
         }
         finally {
            if (null != DiscoveryClient)
               DiscoveryClient.Dispose();
            if (null != CodeProvider)
               CodeProvider.Dispose();
         }

         return CompiledCode;
      }
      #endregion

      #region Member Properties
      /// <summary>Gets the namespace that the service code will be generated to.</summary>
      public string Namespace {
         get {
            return string.IsNullOrEmpty(@namespace) ?
               "" :
               (string)@namespace.Clone();
         }
      }

      /// <summary>Gets the Uri that will be used to get the wsdl.</summary>
      public Uri Uri {
         get {
            return null == uri ?
               null :
               new Uri(uri.AbsoluteUri);
         }
      }
      #endregion

      #region Private Member Fields
      private Uri             uri;
      private string          @namespace;
      private string          configPath;
      private string          serviceAlias;
      #endregion
   }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\wsmonitor\wsmManager\obj\i386\_asmid.inc ===
ASSEMBLY_IDENTITY_KEY_FORM=msil_management_none_12.4.56.0_none_a77acba8e25dff44
ASSEMBLY_IDENTITY_XP_KEY_FORM=msil_management_no-public-key_12.4.56.0_x-ww_564d9566
ASSEMBLY_IDENTITY_CULTURE=
ASSEMBLY_IDENTITY_NAME=management
ASSEMBLY_IDENTITY_PROCESSOR_ARCHITECTURE=msil
ASSEMBLY_IDENTITY_PUBLIC_KEY=
ASSEMBLY_IDENTITY_PUBLIC_KEY_TOKEN=
ASSEMBLY_IDENTITY_TYPE=
ASSEMBLY_IDENTITY_TYPE_NAME=
ASSEMBLY_IDENTITY_VERSION=12.4.56.0
XP_KEY_FORM=msil_management_no-public-key_12.4.56.0_x-ww_564d9566
XP_MANIFEST_DIRECTORY=manifests
XP_MANIFEST_NAME=msil_management_no-public-key_12.4.56.0_x-ww_564d9566.manifest
XP_MANIFEST_PATH=manifests\msil_management_no-public-key_12.4.56.0_x-ww_564d9566.manifest
XP_CATALOG_DIRECTORY=manifests
XP_CATALOG_NAME=msil_management_no-public-key_12.4.56.0_x-ww_564d9566.cat
XP_CATALOG_PATH=manifests\msil_management_no-public-key_12.4.56.0_x-ww_564d9566.cat
XP_PAYLOAD_PATH=msil_management_no-public-key_12.4.56.0_x-ww_564d9566
_DELAY_SIGN=0
!if [set _ASMIDTOATTRIBS_TLBIMP=]
!endif
CODESIGN_TESTKEY=
_TLBIMP_FLAGS=$(_TLBIMP_FLAGS)  /asmversion:12.4.56.0
_ASSEMBLY_IDENTITY=management,processorArchitecture=msil,version=12.4.56.0,publicKeyToken=neutral
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\wsmonitor\wsmManager\obj\i386\_generated.cs ===
[assembly:System.Runtime.InteropServices.ComVisible(false)]
[assembly:System.Reflection.AssemblyVersion("12.4.56.0")]
[assembly:System.Reflection.AssemblyProduct("Microsoft(R) Xbox(TM)")]
[assembly:System.Reflection.AssemblyCopyright("Copyright (c) Microsoft Corporation. All rights reserved.")]
[assembly:System.Reflection.AssemblyCompany("Microsoft Corporation")]
[assembly:System.Reflection.AssemblyFileVersion("12.4.56.0")]
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\wsmonitor\wsmManager\objd\i386\_asmid.inc ===
ASSEMBLY_IDENTITY_KEY_FORM=msil_management_none_12.4.56.0_none_a77acba8e25dff44
ASSEMBLY_IDENTITY_XP_KEY_FORM=msil_management_no-public-key_12.4.56.0_x-ww_564d9566
ASSEMBLY_IDENTITY_CULTURE=
ASSEMBLY_IDENTITY_NAME=management
ASSEMBLY_IDENTITY_PROCESSOR_ARCHITECTURE=msil
ASSEMBLY_IDENTITY_PUBLIC_KEY=
ASSEMBLY_IDENTITY_PUBLIC_KEY_TOKEN=
ASSEMBLY_IDENTITY_TYPE=
ASSEMBLY_IDENTITY_TYPE_NAME=
ASSEMBLY_IDENTITY_VERSION=12.4.56.0
XP_KEY_FORM=msil_management_no-public-key_12.4.56.0_x-ww_564d9566
XP_MANIFEST_DIRECTORY=manifests
XP_MANIFEST_NAME=msil_management_no-public-key_12.4.56.0_x-ww_564d9566.manifest
XP_MANIFEST_PATH=manifests\msil_management_no-public-key_12.4.56.0_x-ww_564d9566.manifest
XP_CATALOG_DIRECTORY=manifests
XP_CATALOG_NAME=msil_management_no-public-key_12.4.56.0_x-ww_564d9566.cat
XP_CATALOG_PATH=manifests\msil_management_no-public-key_12.4.56.0_x-ww_564d9566.cat
XP_PAYLOAD_PATH=msil_management_no-public-key_12.4.56.0_x-ww_564d9566
_DELAY_SIGN=0
!if [set _ASMIDTOATTRIBS_TLBIMP=]
!endif
CODESIGN_TESTKEY=
_TLBIMP_FLAGS=$(_TLBIMP_FLAGS)  /asmversion:12.4.56.0
_ASSEMBLY_IDENTITY=management,processorArchitecture=msil,version=12.4.56.0,publicKeyToken=neutral
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\wsmonitor\wsmManager\objd\i386\_generated.cs ===
[assembly:System.Runtime.InteropServices.ComVisible(false)]
[assembly:System.Reflection.AssemblyVersion("12.4.56.0")]
[assembly:System.Reflection.AssemblyProduct("Microsoft(R) Xbox(TM)")]
[assembly:System.Reflection.AssemblyCopyright("Copyright (c) Microsoft Corporation. All rights reserved.")]
[assembly:System.Reflection.AssemblyCompany("Microsoft Corporation")]
[assembly:System.Reflection.AssemblyFileVersion("12.4.56.0")]
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\wsmonitor\wsmManager\Default.aspx.cs ===
using System;
using System.Data;
using System.Configuration;
using System.Web;
using System.Web.Security;
using System.Web.UI;
using System.Web.UI.WebControls;
using System.Web.UI.WebControls.WebParts;
using System.Web.UI.HtmlControls;
using System.Security.Principal;
using System.Collections;
using System.Collections.Specialized;
using System.Reflection;
using System.IO;
using System.Data.SqlTypes;

using System.Xml;
using System.Xml.Xsl;
using System.Xml.XPath;

using WSMCommon.Control;
using WSMCommon.Control.Command;

namespace XLSM.ManagementClient {
   public partial class _Manager : System.Web.UI.Page {
      public _Manager() {
         managementXSL     = Server.MapPath("App_Data\\presentation.xsl");
         stringsXML        = Server.MapPath("App_Data\\control.xml");
         authenticatedUser = User.Identity.Name.ToLower();

         settingsControlDatabase = "Control.Database";
      }

      private XslCompiledTransform GetTransform() {
         XslCompiledTransform Transform = new XslCompiledTransform();
         
         try {
            Transform.Load(managementXSL);
         }
         catch {
            Transform = null;
         }

         return Transform;
      }

      private string GetValueString(object o, out bool xml) {
         string ret = "";

         xml = false;
         if (o != null) {
            Type t = o.GetType();
            MethodInfo ToStr = t.GetMethod("ToString", Type.EmptyTypes);
            if (ToStr.DeclaringType != typeof(object))
               ret = o.ToString();
            else if (null != o as IConvertible)
               ret = Convert.ToString(o);
            else if (t == typeof(byte[])) {
               byte[] val = o as byte[];
               foreach (byte b in val)
                  ret += Convert.ToString(b, 16);
            }
            else if (t == typeof(SqlXml)) {
               xml = true;
               ret = (o as SqlXml).Value;
            }
            else if (t == typeof(int[])) 
               ret = string.Join(", ",Array.ConvertAll<int, string>((int[])o, delegate(int x) { return x.ToString(); }));
            else
               ret = string.Format("Unhandled_Type {0}", t.Name);
         }
         return ret;
      }

      private void CollectRuntimeData(XmlElement data, CommandLink link) {
         try {
            int         SubCategory;
            XmlElement  Enum, Status;

            SubCategory = (int)processor.Category;

            Processor.AddValue(data, "authenticatedUser", authenticatedUser);
            Processor.AddValue(data, "currentCategory", SubCategory.ToString());
            Processor.AddValue(data, "currentScope", processor.Scope.ToString());
            Processor.AddValue(data, "currentScopeName", processor.ScopeName);
            Processor.AddValue(data, "currentIdentifier", processor.Identifier.ToString());

            Enum = data.OwnerDocument.CreateElement("enumerated");
            data.AppendChild(Enum);
            Status = data.OwnerDocument.CreateElement("status-names");
            data.AppendChild(Status);

            processor.EnumerateCategory(Enum);
            if (null != processor.Selected) {
               XmlElement Sel;
               Type       SelType;

               Sel = data.OwnerDocument.CreateElement("selected");
               Sel.Attributes.Append(data.OwnerDocument.CreateAttribute("context")).Value = ((int)processor.Category).ToString();

               SelType = processor.Selected.GetType();
               foreach (PropertyInfo prop in SelType.GetProperties()) {
                  XmlElement Prop;
                  object val;
                  bool xml;
                  string result;

                  val = prop.GetValue(processor.Selected, null);

                  Prop = data.OwnerDocument.CreateElement("property");
                  Prop.Attributes.Append(data.OwnerDocument.CreateAttribute("name")).Value = prop.Name;
                  result = GetValueString(val, out xml);
                  if (xml)
                     Prop.InnerXml = result;
                  else
                     Prop.InnerText = result;

                  Sel.AppendChild(Prop);
               }

               data.AppendChild(Sel);
            }

            foreach (StatusName sn in processor.StatusNames) {
               XmlElement item = data.OwnerDocument.CreateElement("status");
               item.Attributes.Append(data.OwnerDocument.CreateAttribute("id")).Value = sn.Status.ToString();
               item.Attributes.Append(data.OwnerDocument.CreateAttribute("name")).Value = sn.Name;
               item.InnerText = sn.Description;
               Status.AppendChild(item);
            }

            foreach (Group grp in processor.Groups) {
               if (!string.IsNullOrEmpty(grp.Name)) {
                  XmlElement item = data.OwnerDocument.CreateElement("group");
                  item.Attributes.Append(data.OwnerDocument.CreateAttribute("name")).Value = grp.Name;
                  foreach (GroupEntry entry in grp.Entries) {
                     XmlElement sub = data.OwnerDocument.CreateElement("entry");
                     sub.Attributes.Append(data.OwnerDocument.CreateAttribute("id")).Value = entry.Identifier.ToString();
                     sub.Attributes.Append(data.OwnerDocument.CreateAttribute("name")).Value = entry.Name;
                     sub.Attributes.Append(data.OwnerDocument.CreateAttribute("member")).Value = entry.Member.ToString().ToLower();
                     item.AppendChild(sub);
                  }
                  data.AppendChild(item);
               }
            }
         }
         catch { }
      }

      private XmlDocument GetDocument(out XmlElement data) {
         XmlDocument Doc, Strings;
         XmlElement  Root;

         try {
            Doc     = new XmlDocument();
            Strings = new XmlDocument();

            Root = Doc.CreateElement("root");
            Doc.AppendChild(Root);

            Root.AppendChild(data = Doc.CreateElement("data"));

            Strings.Load(stringsXML);
            Root.AppendChild(Doc.ImportNode(Strings.DocumentElement, true));
         }
         catch {
            Doc = null;
            data = null;
         }

         return Doc;
      }

      protected void DumpError(string message, params object[] args) {
         Literal Error = new Literal();
         Error.Text = "<p style='text-align: left;'>";
         Error.Text+= string.Format(message, args);
         Error.Text += "</p>";
         Form.Controls.Add(Error);
      }

      protected void Page_Load(object sender, EventArgs e) {
         XslCompiledTransform Transform;
         XmlElement  Data, Errors;
         XmlDocument Document;
         CommandLink Link;

         Title = "XLSM - Management";

         if (null == (Transform = GetTransform())) {
            DumpError("Initialization_Failure no xsl");
            return;
         }

         if (null == (Document = GetDocument(out Data))) {
            DumpError("Initialization_Failure no xml");
            return;
         }

         Errors = Document.CreateElement("errors");
         Data.AppendChild(Errors);

         try {
            Link = new CommandLink(
               User.Identity as WindowsIdentity, 
               ConfigurationManager.AppSettings.Get(settingsControlDatabase));
         }
         catch (Exception exc) {
            DumpError("Connectivity_Failure {0}", 
               exc.ToString().Replace("\n", "<br />"));

            return;
         }

         processor = new Processor(this, Link);

         if (null == this.processor.User) {
            DumpError("Initialization_Failure user is not athenticated");
            return;
         }

         if (IsPostBack)
            processor.ProccessPost(this, Errors, Data);
         else
            processor.ProccessCommand(this, Errors, Data);

         CollectRuntimeData(Data, Link);

         using (StringWriter sw = new StringWriter()) {
            XmlTextWriter xtw = new XmlTextWriter(sw);
            try {
               Literal Content;

               Transform.Transform(Document, xtw);
               xtw.Flush(); sw.Flush();

               Content = new Literal();
               Content.Text = sw.ToString();

               Form.Controls.Add(Content);
            }
            catch (Exception exc) {
               DumpError("Connectivity_Failure {0}",
               exc.ToString().Replace("\n", "<br />"));

               return;
            }
         }
      }

      private Processor processor;
      private readonly string managementXSL;
      private readonly string stringsXML;
      private readonly string authenticatedUser;

      private readonly string settingsControlDatabase;
   }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\wsmonitor\wsmService\makefile.inc ===
!INCLUDE $(INETROOT)\build\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\wsmonitor\wsmManager\App_Code\Processor.cs ===
using System;
using System.Data;
using System.Configuration;
using System.Web;
using System.Web.Security;
using System.Web.UI;
using System.Web.UI.WebControls;
using System.Web.UI.WebControls.WebParts;
using System.Web.UI.HtmlControls;
using System.Globalization;
using System.IO;

using System.Security.Principal;

using System.Collections;
using System.Collections.Generic;
using System.Reflection;

using System.Xml;

using WSMCommon.Control;
using WSMCommon.Control.Command;

using System.Security.Cryptography.X509Certificates;
using System.Security.Cryptography;

namespace XLSM.ManagementClient {
   public enum SubCategories : int {
      None                 = 0,
      Environment          = 101,
      Service              = 102,
      Script               = 103,
      AspectGroup          = 104,
      Aspect               = 105,
      ScriptGroup          = 106,
      EnvironmentInstance  = 201,
      ScriptInstance       = 202,
   }

   /// <summary>
   /// Summary description for CommandProcessor
   /// </summary>
   public class Processor {
      public Processor(Page target, CommandLink link) {
         int temp;

         if (!int.TryParse(target.Request.Params["sub"], out temp))
            this.category = SubCategories.None;
         else {
            if (Enum.IsDefined(typeof(SubCategories), temp))
               this.category = (SubCategories)temp;
            else
               this.category = SubCategories.None;
         }

         if (!long.TryParse(target.Request.Params["scope"], out this.scope))
            this.scope = 0;

         if (!long.TryParse(target.Request.Params["uid"], out this.id))
            this.id = 0;


         if (null == target.Cache["statusNames"])
            target.Cache["statusNames"] = link.EnumerateStatusNames();

         statusNames = (StatusName[])target.Cache["statusNames"];
         
         this.verb = target.Request.Params["verb"];
         this.link = link;
         this.references = null;
         this.groups = new Group[0];

         this.user = null;
         if (target.User.Identity.AuthenticationType == "NTLM" || target.User.Identity.AuthenticationType == "Negotiate") {
            WindowsPrincipal User = (WindowsPrincipal)target.User;
            this.user = User.Identity.Name;
         }

         GetScopeName();
      }

      private void GetScopeName() {
         this.scopeName = null;

         if (category == SubCategories.Aspect) {
            AspectGroupInformation[] set = link.EnumerateAspectGroups();
            foreach (AspectGroupInformation info in set) {
               if (info.Identifier == (int)scope) {
                  scopeName = info.Name;
                  break;
               }
            }
            references = new ArrayList(set);
         }
         else if (category == SubCategories.Service) {
            EnvironmentInformation[] set = link.EnumerateEnvironments();
            foreach (EnvironmentInformation info in set) {
               if (info.Identifier == (int)scope) {
                  scopeName = info.Name;
                  break;
               }
            }
            references = new ArrayList(set);
         }
         else if (category == SubCategories.Script) {
            EnvironmentInformation[] set = link.EnumerateEnvironments();
            foreach (EnvironmentInformation info in set) {
               if (info.Identifier == (int)scope) {
                  scopeName = info.Name;
                  break;
               }
            }
            references = new ArrayList(link.EnumerateEnvironments());
         }
         else if (category == SubCategories.ScriptGroup) {
            EnvironmentInformation[] set = link.EnumerateEnvironments();
            foreach (EnvironmentInformation info in set) {
               if (info.Identifier == (int)scope) {
                  scopeName = info.Name;
                  break;
               }
            }
            references = new ArrayList(link.EnumerateEnvironments());
         }
         else if (category == SubCategories.ScriptInstance) {
            EnvironmentInstance[] set = link.EnumerateEnvironmentInstances();
            foreach (EnvironmentInstance info in set) {
               if (info.Instance == scope) {
                  scopeName = info.Name;
                  break;
               }
            }
            references = new ArrayList(set);
         }

         if (null == scopeName) {
            scopeName = "(Unscoped)";
            scope = 0;
         }
      }

      public static void AddError(XmlElement element, string value) {
         AddValue(element, "error", value);
      }

      public static void AddResponse(XmlElement element, string value) {
         AddValue(element, "response", value);
      }

      public static void AddValue(XmlElement element, string name, string value) {
         XmlElement Element;
         Element = element.OwnerDocument.CreateElement(name);
         Element.InnerText = value;
         element.AppendChild(Element);
      }

      private delegate int GetIdentifier<T>(T obj);
      private delegate string GetName<T>(T obj);

      private Group GenerateGroupEntries<T>(ArrayList all, ArrayList members, GetIdentifier<T> identifer, GetName<T> namer) {
         Dictionary<int, GroupEntry> Entries = new Dictionary<int, GroupEntry>();
         Group Group = new Group();

         if (all.Count > 0) {
            foreach (T Item in members) {
               GroupEntry Entry = new GroupEntry();
               Entry.Name = namer(Item);
               Entry.Identifier = identifer(Item);
               Entry.Member = true;
               Entries.Add(Entry.Identifier, Entry);
            }

            foreach (T Item in all) {
               GroupEntry Entry = new GroupEntry();
               Entry.Name = namer(Item);
               Entry.Identifier = identifer(Item);
               Entry.Member = false;
               if (!Entries.ContainsKey(Entry.Identifier))
                  Entries.Add(Entry.Identifier, Entry);
            }
         }

         Group.Entries = new GroupEntry[Entries.Count];
         Entries.Values.CopyTo(Group.Entries, 0);

         return Group;
      }

      public Group GenerateAspectGroupGroups(ArrayList groupAspectGroups, ArrayList groupMemberAspectGroups) {
         Group Group = GenerateGroupEntries<AspectGroupInformation>(
            groupAspectGroups,
            groupMemberAspectGroups,
            delegate(AspectGroupInformation t) { return t.Identifier; },
            delegate(AspectGroupInformation t) { return t.Name; });

         Group.Name = "Aspect Groups";

         groups = new Group[] { Group };

         return Group;
      }

      public Group GenerateEnvironmentGroups(ArrayList groupEnvironments, ArrayList groupMemberEnvironments) {
         Group Group = GenerateGroupEntries<EnvironmentInformation>(
            groupEnvironments,
            groupMemberEnvironments,
            delegate(EnvironmentInformation t) { return t.Identifier; },
            delegate(EnvironmentInformation t) { return t.Name; });

         Group.Name = "Environments";

         groups = new Group[] { Group };

         return Group;
      }

      public void EnumerateCategory(XmlElement enumlist) {
         ArrayList Enumerated;
         ArrayList Membership;

         enumlist.Attributes.Append(enumlist.OwnerDocument.CreateAttribute("category")).Value = ((int)category).ToString();
         selected = null;

         switch (category) {
            case SubCategories.Environment:
               Enumerated = new ArrayList(link.EnumerateEnvironments());
               selected = new EnvironmentInformation();
               foreach (EnvironmentInformation cur in Enumerated) {
                  if (cur.Identifier == (int)id) {
                     selected = cur;
                     break;
                  }
               }
               break;
            case SubCategories.Service:
               Enumerated = new ArrayList(link.EnumerateServices((int)scope));
               Membership = new ArrayList(link.EnumerateServiceEnvironments((int)id));
               selected = new ServiceInformation();
               foreach (ServiceInformation cur in Enumerated) {
                  if (cur.Identifier == (int)id) {
                     selected = cur;
                     break;
                  }
               }
               groups = new Group[] { GenerateEnvironmentGroups(references, Membership) };
               break;
            case SubCategories.Script:
               Enumerated = new ArrayList(link.EnumerateScripts((int)scope));
               Membership = new ArrayList(link.EnumerateScriptEnvironments((int)id));
               selected = new ScriptInformation();
               foreach (ScriptInformation cur in Enumerated) {
                  if (cur.Identifier == (int)id) {
                     selected = cur;
                     break;
                  }
               }
               groups = new Group[] { GenerateEnvironmentGroups(references, Membership) };
               break;
            case SubCategories.AspectGroup:
               Enumerated = new ArrayList(link.EnumerateAspectGroups());
               selected = new AspectGroupInformation();
               foreach (AspectGroupInformation cur in Enumerated) {
                  if (cur.Identifier == (int)id) {
                     selected = cur;
                     break;
                  }
               }
               break;
            case SubCategories.Aspect:
               Enumerated = new ArrayList(link.EnumerateAspects((int)scope));
               Membership = new ArrayList(link.EnumerateAspectAspectGroups((int)id));
               selected = new AspectInformation();
               foreach (AspectInformation cur in Enumerated) {
                  if (cur.Identifier == (int)id) {
                     selected = cur;
                     break;
                  }
               }
               groups = new Group[] { GenerateAspectGroupGroups(references, Membership) };
               break;
            case SubCategories.ScriptGroup:
               Enumerated = new ArrayList(link.EnumerateScriptGroups((int)scope));
               Membership = new ArrayList(link.EnumerateScriptGroupEnvironments((int)id));
               selected = new ScriptGroupInformation();
               foreach (ScriptGroupInformation cur in Enumerated) {
                  if (cur.Identifier == (int)id) {
                     selected = cur;
                     break;
                  }
               }
               groups = new Group[] { GenerateEnvironmentGroups(references, Membership) };
               break;
            case SubCategories.EnvironmentInstance:
               Enumerated = new ArrayList(link.EnumerateEnvironmentInstances());
               selected = new EnvironmentInstance();
               foreach (EnvironmentInstance cur in Enumerated) {
                  if (cur.Instance == (int)id) {
                     selected = cur;
                     break;
                  }
               }
               break;
            case SubCategories.ScriptInstance:
               Enumerated = new ArrayList(link.EnumerateScriptInstances(scope));
               selected = new ScriptInstance();
               foreach (ScriptInstance cur in Enumerated) {
                  if (cur.Instance == (int)id) {
                     selected = cur;
                     break;
                  }
               }
               break;
            default:
               Enumerated = null;
               break;
         }

         if (null != Enumerated && Enumerated.Count > 0)
            DumpArrayList(enumlist, Enumerated, null);

         if (null != references && references.Count > 0)
            DumpArrayList(enumlist, references, "reference");
      }

      private void DumpArrayList(XmlElement enumlist, ArrayList list, string nameOverride) {
         XmlElement item;
         Type itemType;
         PropertyInfo[] properties;

         itemType = list[0].GetType();
         properties = itemType.GetProperties(BindingFlags.DeclaredOnly | BindingFlags.Public | BindingFlags.Instance);

         if (null == nameOverride)
            nameOverride = category.ToString().ToLower();

         foreach (object Current in list) {
            item = enumlist.OwnerDocument.CreateElement(nameOverride);

            foreach (PropertyInfo Property in properties) {
               object Value = Property.GetValue(Current, null);

               if (null == Value)
                  AddValue(item, Property.Name, "(null)");
               else
                  AddValue(item, Property.Name, Value.ToString());
            }

            enumlist.AppendChild(item);
         }
      }

      public void SetEnvironments(ref ICommandParameters param) {
         if (typeof(ScriptUpdateParameters) == param.GetType()) {
            ScriptUpdateParameters p = (ScriptUpdateParameters)param;
            p.Environments = new int[] { (int)scope };
            param = p;
         }
         else if (typeof(ScriptAddParameters) == param.GetType()) {
            ScriptAddParameters p = (ScriptAddParameters)param;
            p.Environments = new int[] { (int)scope };
            param = p;
         }
         else if (typeof(ServiceUpdateParameters) == param.GetType()) {
            ServiceUpdateParameters p = (ServiceUpdateParameters)param;
            p.Environments = new int[] { (int)scope };
            param = p;
         }
         else if (typeof(ServiceAddParameters) == param.GetType()) {
            ServiceAddParameters p = (ServiceAddParameters)param;
            p.Environments = new int[] { (int)scope };
            param = p;
         }
         else if (typeof(ScriptGroupUpdateParameters) == param.GetType()) {
            ScriptGroupUpdateParameters p = (ScriptGroupUpdateParameters)param;
            p.Environments = new int[] { (int)scope };
            param = p;
         }
         else if (typeof(ScriptGroupAddParameters) == param.GetType()) {
            ScriptGroupAddParameters p = (ScriptGroupAddParameters)param;
            p.Environments = new int[] { (int)scope };
            param = p;
         }
      }

      public int[] GetEntryList(Page target) {
         List<int> Entries = new List<int>();
         
         foreach (string key in target.Request.Form.Keys) {
            int Entry;

            if (key.StartsWith("__entry")) {
               if (int.TryParse(target.Request.Form[key], out Entry))
                  Entries.Add(Entry);
            }
         }

         return Entries.ToArray();
      }

      public void ProccessPost(Page target, XmlElement errors, XmlElement data) {
         ICommandParameters Edit, New;
         object EditP, NewP;
         FieldInfo EditProp, NewProp;

         switch (category) {
            case SubCategories.Aspect:
               Edit = new AspectUpdateParameters();
               New = new AspectAddParameters();
               EditP = ((AspectUpdateParameters)Edit).Aspect;
               NewP = ((AspectAddParameters)New).Aspect;
               EditProp = typeof(AspectUpdateParameters).GetField("Aspect");
               NewProp = typeof(AspectAddParameters).GetField("Aspect");
               break;
            case SubCategories.AspectGroup:
               Edit = new AspectGroupUpdateParameters();
               New = new AspectGroupAddParameters();
               EditP = ((AspectGroupUpdateParameters)Edit).AspectGroup;
               NewP = ((AspectGroupAddParameters)New).AspectGroup;
               EditProp = typeof(AspectGroupUpdateParameters).GetField("AspectGroup");
               NewProp = typeof(AspectGroupAddParameters).GetField("AspectGroup");
               break;
            case SubCategories.Environment:
               Edit = new EnvironmentUpdateParameters();
               New = new EnvironmentAddParameters();
               EditP = ((EnvironmentUpdateParameters)Edit).Environment;
               NewP = ((EnvironmentAddParameters)New).Environment;
               EditProp = typeof(EnvironmentUpdateParameters).GetField("Environment");
               NewProp = typeof(EnvironmentAddParameters).GetField("Environment");
               break;
            case SubCategories.Script:
               Edit = new ScriptUpdateParameters();
               New = new ScriptAddParameters();
               EditP = ((ScriptUpdateParameters)Edit).Script;
               NewP = ((ScriptAddParameters)New).Script;
               EditProp = typeof(ScriptUpdateParameters).GetField("Script");
               NewProp = typeof(ScriptAddParameters).GetField("Script");
               break;
            case SubCategories.Service:
               Edit = new ServiceUpdateParameters();
               New = new ServiceAddParameters();
               EditP = ((ServiceUpdateParameters)Edit).Service;
               NewP = ((ServiceAddParameters)New).Service;
               EditProp = typeof(ServiceUpdateParameters).GetField("Service");
               NewProp = typeof(ServiceAddParameters).GetField("Service");
               break;
            case SubCategories.ScriptGroup:
               Edit = new ScriptGroupUpdateParameters();
               New = new ScriptGroupAddParameters();
               EditP = ((ScriptGroupUpdateParameters)Edit).ScriptGroup;
               NewP = ((ScriptGroupAddParameters)New).ScriptGroup;
               EditProp = typeof(ScriptGroupUpdateParameters).GetField("ScriptGroup");
               NewProp = typeof(ScriptGroupAddParameters).GetField("ScriptGroup");
               break;
            default:
               Edit = null;
               New = null;
               EditP = null;
               NewP = null;
               NewProp = null;
               EditProp = null;
               break;
         }

         if (null != Edit && null != New) {
            try {
               switch (target.Request.Form["__Verb"]) {
                  case "Save as New":
                     SetEnvironments(ref New);
                     foreach (PropertyInfo Property in NewP.GetType().GetProperties()) {
                        if (null != target.Request.Form[Property.Name])
                           ReadValue(Property, NewP, target.Request.Form[Property.Name]);
                     }
                     NewProp.SetValue(New, NewP);
                     link.SendCommand(New);

                     break;
                  case "Save":
                     SetEnvironments(ref Edit);
                     foreach (PropertyInfo Property in EditP.GetType().GetProperties()) {
                        if (null != target.Request.Form[Property.Name])
                           ReadValue(Property, EditP, target.Request.Form[Property.Name]);
                     }
                     EditProp.SetValue(Edit, EditP);
                     link.SendCommand(Edit);

                     break;
                  case "Add":
                     if (category == SubCategories.Script)
                        AddScriptEnvironments(target, errors);
                     else if (category == SubCategories.Service)
                        AddServiceEnvironments(target, errors);
                     else if (category == SubCategories.Aspect)
                        AddAspectAspectGroups(target, errors);
                     else if (category == SubCategories.ScriptGroup)
                        AddScriptGroupEnvironments(target, errors);

                     break;
                  case "Delete":
                     if (category == SubCategories.Script)
                        RemoveScriptEnvironments(target, errors);
                     else if (category == SubCategories.Service)
                        RemoveServiceEnvironments(target, errors);
                     else if (category == SubCategories.Aspect)
                        RemoveAspectAspectGroups(target, errors);
                     else if (category == SubCategories.ScriptGroup)
                        RemoveScriptGroupEnvironments(target, errors);

                     break;
               }
            }
            catch (System.Data.SqlClient.SqlException e) {
               AddError(errors, string.Format("encountered an error while executing command: exception={0}", e.Message));
            }
         }
      }

      private void RemoveAspectAspectGroups(Page target, XmlElement errors) {
         AspectRemoveParameters Params = new AspectRemoveParameters();
         Params.Identifier = (int)id;
         Params.AspectGroups = GetEntryList(target);
         if (Params.AspectGroups.Length > 0)
            link.SendCommand(Params);
      }

      private void AddAspectAspectGroups(Page target, XmlElement errors) {
         AspectInformation? Info = link.FetchAspect((int)id);

         if (Info.HasValue) {
            AspectUpdateParameters Params = new AspectUpdateParameters();

            Params.Aspect = Info.Value;
            Params.AspectGroups = GetEntryList(target);

            link.SendCommand(Params);
         }
      }

      private void RemoveServiceEnvironments(Page target, XmlElement errors) {
         ServiceRemoveParameters Params = new ServiceRemoveParameters();
         Params.Identifier = (int)id;
         Params.Environments = GetEntryList(target);
         if (Params.Environments.Length > 0)
            link.SendCommand(Params);
      }

      private void RemoveScriptEnvironments(Page target, XmlElement errors) {
         ScriptRemoveParameters Params = new ScriptRemoveParameters();
         Params.Identifier = (int)id;
         Params.Environments = GetEntryList(target);
         if (Params.Environments.Length > 0)
            link.SendCommand(Params);
      }

      private void RemoveScriptGroupEnvironments(Page target, XmlElement errors) {
         ScriptGroupRemoveParameters Params = new ScriptGroupRemoveParameters();
         Params.Identifier = (int)id;
         Params.Environments = GetEntryList(target);
         if (Params.Environments.Length > 0)
            link.SendCommand(Params);
      }

      private void AddServiceEnvironments(Page target, XmlElement errors) {
         ServiceInformation? Info = link.FetchService((int)id);
         PropertyInfo[] Properties = new PropertyInfo[] {
            typeof(ServiceInformation).GetProperty("Host"),
            typeof(ServiceInformation).GetProperty("Flag")
         };

         if (Info.HasValue) {
            ServiceUpdateParameters Params = new ServiceUpdateParameters();

            Params.Environments = GetEntryList(target);
            Params.Service = ReadObjectProperties<ServiceInformation>(
               target,
               Info.Value,
               Properties);

            link.SendCommand(Params);
         }
      }

      private void AddScriptEnvironments(Page target, XmlElement errors) {
         ScriptInformation? Info = link.FetchScript((int)id);
         PropertyInfo[] Properties = new PropertyInfo[] {
            typeof(ScriptInformation).GetProperty("Period"),
            typeof(ScriptInformation).GetProperty("Flag")
         };

         if (Info.HasValue) {
            ScriptUpdateParameters Params = new ScriptUpdateParameters();

            Params.Environments = GetEntryList(target);
            Params.Script = ReadObjectProperties<ScriptInformation>(
               target,
               Info.Value,
               Properties);

            link.SendCommand(Params);
         }
      }

      private void AddScriptGroupEnvironments(Page target, XmlElement errors) {
         ScriptGroupInformation? Info = link.FetchScriptGroup((int)id);
         PropertyInfo[] Properties = new PropertyInfo[] {
            typeof(ScriptGroupInformation).GetProperty("Period"),
            typeof(ScriptGroupInformation).GetProperty("Flag")
         };

         if (Info.HasValue) {
            ScriptGroupUpdateParameters Params = new ScriptGroupUpdateParameters();

            Params.Environments = GetEntryList(target);
            Params.ScriptGroup = ReadObjectProperties<ScriptGroupInformation>(
               target,
               Info.Value,
               Properties);

            link.SendCommand(Params);
         }
      }

      private T ReadObjectProperties<T>(Page target, object instance, PropertyInfo[] properties) {
         foreach (PropertyInfo Property in properties)
            ReadValue(Property, instance, target.Request.Form[Property.Name]);

         return (T)instance;
      }

      private byte[] GetHexBytes(string prop) {
         LinkedList<byte> Values = new LinkedList<byte>();
         
         prop = prop.Replace(" ", "").ToLower();
         prop = prop.Substring(prop.StartsWith("0x") ? 2 : 0);
         
         while (prop.Length > 0) {
            byte value;
            string read;

            read = prop.Substring(0, prop.Length > 1 ? 2 : 1);
            prop = prop.Length > 1 ? prop.Substring(2) : "";

            if (!byte.TryParse(read, NumberStyles.HexNumber, null, out value))
               return null;

            Values.AddLast(value);
         }

         return new List<byte>(Values).ToArray();
      }

      private byte[] GetCertificateBytes(string prop) {
         try {
            X509Certificate Certificate = new X509Certificate(prop);
            return Certificate.Export(X509ContentType.Cert);
         }
         catch (CryptographicException e) {
            if (e.Message == "The system cannot find the file specified.\r\n")
               return GetHexBytes(prop);
         }

         return null;
      }

      private bool ReadValue(PropertyInfo property, Type type, ref object instance, string prop) {
         if (type == typeof(int)) {
            int val;
            if (int.TryParse(prop, out val)) {
               property.SetValue(instance, val, null);
               return true;
            }
         }
         else if (type == typeof(long)) {
            long val;
            if (long.TryParse(prop, out val)) {
               property.SetValue(instance, val, null);
               return true;
            }
         }
         else if (type == typeof(string)) {
            property.SetValue(instance, prop, null);
            return true;
         }
         else if (type == typeof(int[])) {
            List<int> Values = new List<int>();
            Values.AddRange(Array.ConvertAll<string, int>(prop.Split(','), 
               delegate(string s) { int x; if (!int.TryParse(s, out x)) x=0; return x; }));
            Values.RemoveAll(delegate(int x) { return x == 0; });
            property.SetValue(instance, Values.ToArray(), null);
            return true;
         }
         else if (type == typeof(byte[])) {
            byte[] Values;

            if (property.Name == "Certificate")
               Values = GetCertificateBytes(prop);
            else
               Values = GetHexBytes(prop);

            if (null == Values)
               return false;

            property.SetValue(instance, Values, null);
         }

         return false;
      }
      private bool ReadValue(PropertyInfo property, object instance, string prop) {
         if ("Nullable`1" == property.PropertyType.Name)
            return ReadValue(property, property.PropertyType.GetGenericArguments()[0], ref instance, prop);
         else
            return ReadValue(property, property.PropertyType, ref instance, prop);
      }

      public void ProccessCommand(Page target, XmlElement errors, XmlElement data) {
         if (target.IsPostBack) {
            ProccessPost(target, errors, data);
            return;
         }

         if (string.IsNullOrEmpty(verb))
            return;

         try {
            CommandResponse resp = null;

            if (verb == "start") {
               if (category == SubCategories.Script) {
                  ScriptStartParameters p = new ScriptStartParameters();
                  p.Environments = new int[] { (int)scope };
                  p.Identifier = (int)id;
                  p.User = user;
                  resp = link.SendCommand(p);
               }
               else if (category == SubCategories.ScriptGroup) {
                  ScriptGroupStartParameters p = new ScriptGroupStartParameters();
                  p.Environment = (int)scope;
                  p.Identifier = (int)id;
                  p.User = user;
                  resp = link.SendCommand(p);
               }
            }
            else if (verb == "pause") {
               switch (category) {
                  case SubCategories.ScriptInstance:
                     {
                        ScriptPauseParameters p = new ScriptPauseParameters();
                        p.Instance = id;
                        p.User = user;
                        resp = link.SendCommand(p);
                        break;
                     }
                  case SubCategories.EnvironmentInstance:
                     {
                        EnvironmentPauseAllScriptsParameters p = new EnvironmentPauseAllScriptsParameters();
                        p.Instance = id;
                        p.User = user;
                        resp = link.SendCommand(p);
                        break;
                     }
               }
            }
            else if (verb == "resume") {
               switch (category) {
                  case SubCategories.ScriptInstance: {
                        ScriptResumeParameters p = new ScriptResumeParameters();
                        p.Instance = id;
                        p.User = user;
                        resp = link.SendCommand(p);
                        break;
                     }
                  case SubCategories.EnvironmentInstance: {
                        EnvironmentResumeAllScriptsParameters p = new EnvironmentResumeAllScriptsParameters();
                        p.Instance = id;
                        p.User = user;
                        resp = link.SendCommand(p);
                        break;
                     }
               }
            }
            else if (verb == "cancel") {
               switch (category) {
                  case SubCategories.ScriptInstance: {
                        ScriptCancelParameters p = new ScriptCancelParameters();
                        p.Instance = id;
                        p.User = user;
                        resp = link.SendCommand(p);
                        break;
                     }
                  case SubCategories.EnvironmentInstance: {
                        EnvironmentCancelAllScriptsParameters p = new EnvironmentCancelAllScriptsParameters();
                        p.Instance = id;
                        p.User = user;
                        resp = link.SendCommand(p);
                        break;
                     }
               }
            }
            else if (verb == "deprecate") {
               switch (category) {
                  case SubCategories.Environment: {
                        EnvironmentDeprecateParameters p = new EnvironmentDeprecateParameters();
                        p.Environment = (int)id;
                        p.User = user;
                        resp = link.SendCommand(p);
                        break;
                     }
               }
            }
            else if (verb == "del") {
               ICommandParameters cp;

               switch (category) {
                  case SubCategories.Aspect: {
                        AspectRemoveParameters p = new AspectRemoveParameters();
                        p.Identifier = (int)id;
                        cp = p;
                        break;
                     }
                  case SubCategories.AspectGroup: {
                        AspectGroupRemoveParameters p = new AspectGroupRemoveParameters();
                        p.Identifier = (int)id;
                        cp = p;
                        break;
                     }
                  case SubCategories.Environment: {
                        EnvironmentRemoveParameters p = new EnvironmentRemoveParameters();
                        p.Identifier = (int)id;
                        cp = p;
                        break;
                     }
                  case SubCategories.Script: {
                        ScriptRemoveParameters p = new ScriptRemoveParameters();
                        p.Identifier = (int)id;
                        cp = p;
                        break;
                     }
                  case SubCategories.Service: {
                        ServiceRemoveParameters p = new ServiceRemoveParameters();
                        p.Identifier = (int)id;
                        cp = p;
                        break;
                     }
                  case SubCategories.ScriptGroup: {
                        ScriptGroupRemoveParameters p = new ScriptGroupRemoveParameters();
                        p.Identifier = (int)id;
                        cp = p;
                        break;
                     }
                  default:
                     AddError(errors, string.Format("Delete_InvalidCateogry '{0}'", category));
                     return;
               }

               resp = link.SendCommand(cp);
            }
            else if (verb == "freeze") {
               ICommandParameters cp;
               switch (category) {
                  case SubCategories.Script: {
                     SchedulerFreezeScriptParameters p = new SchedulerFreezeScriptParameters();
                     p.Environment = (int)scope;
                     p.Script = (int)id;
                     p.User = user;
                     cp = p;
                     break;
                  }
                  case SubCategories.ScriptGroup: {
                     SchedulerFreezeScriptGroupParameters p = new SchedulerFreezeScriptGroupParameters();
                     p.Environment = (int)scope;
                     p.ScriptGroup = (int)id;
                     p.User = user;
                     cp = p;
                     break;
                  }
                  default:
                     AddError(errors, string.Format("Freeze_InvalidCategory '{0}'", category));
                     return;
               }

               resp = link.SendCommand(cp);
            }
            else if (verb == "thaw") {
               ICommandParameters cp;
               switch (category) {
                  case SubCategories.Script: {
                     SchedulerThawScriptParameters p = new SchedulerThawScriptParameters();
                     p.Environment = (int)scope;
                     p.Script = (int)id;
                     p.User = user;
                     cp = p;
                     break;
                  }
                  case SubCategories.ScriptGroup: {
                     SchedulerThawScriptGroupParameters p = new SchedulerThawScriptGroupParameters();
                     p.Environment = (int)scope;
                     p.ScriptGroup = (int)id;
                     p.User = user;
                     cp = p;
                     break;
                  }
                  default:
                     AddError(errors, string.Format("Thaw_InvalidCategory '{0}'", category));
                     return;
               }

               resp = link.SendCommand(cp);
            }

            if (null != resp)
               AddResponse(data, resp.XmlResult);
         }
         catch (Exception e) {
            AddError(errors, e.Message);
         }
      }

      public Group[] Groups { get { return this.groups; } }
      public object Selected { get { return this.selected; } }
      public string User { get { return this.user; } }
      public string Verb { get { return this.verb; } }
      public long Identifier { get { return this.id; } }
      public SubCategories Category { get { return this.category; } }
      public long Scope { get { return this.scope; } }
      public string ScopeName { get { return this.scopeName; } }
      public StatusName[] StatusNames { get { return this.statusNames; } } 

      private object        selected;
      private Group[]       groups;
      private StatusName[]  statusNames;
      private ArrayList     references;
      private string        scopeName;
      private string        user;
      private long          scope;
      private long          id;
      private string        verb;
      private SubCategories category;
      private CommandLink   link;
   }

   public struct Group {
      public string Name;
      public GroupEntry[] Entries;
   }

   public struct GroupEntry {
      public string Name;
      public bool Member;
      public int Identifier;
   }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\wsmonitor\wsmFramework\Properties\AssemblyInfo.cs ===
﻿using System.Reflection;
using System.Runtime.CompilerServices;
using System.Runtime.InteropServices;

// General Information about an assembly is controlled through the following 
// set of attributes. Change these attribute values to modify the information
// associated with an assembly.
[assembly: AssemblyTitle("wsmFramework")]
[assembly: AssemblyDescription("")]
[assembly: AssemblyConfiguration("")]
[assembly: AssemblyCompany("Microsoft")]
[assembly: AssemblyProduct("wsmFramework")]
[assembly: AssemblyCopyright("Copyright © Microsoft 2007")]
[assembly: AssemblyTrademark("")]
[assembly: AssemblyCulture("")]

// Setting ComVisible to false makes the types in this assembly not visible 
// to COM components.  If you need to access a type in this assembly from 
// COM, set the ComVisible attribute to true on that type.
[assembly: ComVisible(false)]

// The following GUID is for the ID of the typelib if this project is exposed to COM
[assembly: Guid("bbaf51c2-6968-40de-8fff-90ab8933d42e")]

// Version information for an assembly consists of the following four values:
//
//      Major Version
//      Minor Version 
//      Build Number
//      Revision
//
// You can specify all the values or you can default the Revision and Build Numbers 
// by using the '*' as shown below:
[assembly: AssemblyVersion("1.0.0.0")]
[assembly: AssemblyFileVersion("1.0.0.0")]
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\wsmonitor\wsmService\NTService.cs ===
using System;
using System.Collections.Generic;
using System.ComponentModel;
using System.Data;
using System.Diagnostics;
using System.ServiceProcess;
using System.Text;

using LiveServiceMonitor.Service;

namespace LiveServiceMonitor {
   public partial class NTService : ServiceBase {
      public const string EventSource          = "WSMonitor";

      public const int BugEventId              = 2000;
      public const int CommandExceptionEventId = 2010;

      public NTService() {
         InitializeComponent();
      }

      protected override void OnStart(string[] args) {
         DomainController.Startup(true);
      }

      protected override void OnStop() {
         DomainController.Shutdown();
      }
   }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\wsmonitor\wsmService\Service.DomainController_1.cs ===
///Partial DomainController Responsible For Environment Manager Logic

namespace LiveServiceMonitor.Service {
   #region Using Directives
   using System;
   using System.Collections.Generic;
   using System.Text;

   using System.Threading;

   using WSMCommon.Control;
   using WSMCommon.Control.Command;

   using Integration;

   using TrackList = System.Collections.Generic.List<DomainController.EnvironmentTracker>;
   using EnvScrLst = System.Collections.Generic.List<SchedulerItem>;
   using EnvScrCol = System.Collections.Generic.Dictionary<int, System.Collections.Generic.List<SchedulerItem>>;
   #endregion

   public partial class DomainController {
      /// <summary>
      /// Gathers essential environment state information.  This information is required by the
      /// environments to function properly.
      /// <remarks>This should be generated each time an environment is deprecated.</remarks>
      /// </summary>
      private void CollectAspectGroupInformation() {
         AspectGroupInformation[] Groups;
         AspectGroupInformation Empty = new AspectGroupInformation("", "");

         this.environmentState = new EnvironmentState();

         this.environmentState.MapAspectGroup(Empty);
         this.environmentState.MapAspectGroupAspects(Empty.Identifier, new AspectInformation[0]);

         Groups = this.clientCommandLink.EnumerateAspectGroups();
         foreach (AspectGroupInformation Group in Groups) {
            AspectInformation[] Aspects;
            Aspects = this.clientCommandLink.EnumerateAspectsInGroup(Group.Identifier);
            this.environmentState.MapAspectGroup(Group);
            this.environmentState.MapAspectGroupAspects(Group.Identifier, Aspects);
         }
      }

      private CommandStatus FreezeRelatedCommand(
         Predicate<SchedulerItem> stateTest,
         Action<SchedulerItem> stateChange,
         string missingEnvironment1,
         string missingItem2,
         string badState,
         string goodState,
         CommandDetails command,
         int environment,
         int script,
         int group) 
      {
         CommandStatus Status = new CommandStatus(command.Identifier, CommandState.Completed, "");
         StringBuilder Result = new StringBuilder();

         if (scheduledScripts.ContainsKey(environment)) {
            bool Found = false;

            foreach (SchedulerItem S in scheduledScripts[environment]) {
               if (isTargetScheduledItem(S, script, group)) {
                  Found = true;
                  if (stateTest(S)) {
                     stateChange(S);
                     if (canSetDeadline(S))
                        setDeadline(S);
                     Result.Append(ScriptManager.SuccessElement(goodState));
                  }
                  else {
                     Result.Append(ScriptManager.SuccessElement(badState));
                  }
                  break;
               }
            }

            if (!Found) {
               Status.Status = CommandState.Error;
               Result.Append(ScriptManager.ErrorElement(string.Format(missingItem2, group, script)));
            }
         }
         else {
            Status.Status = CommandState.Error;
            Result.Append(ScriptManager.ErrorElement(string.Format(missingEnvironment1, environment)));
         }

         Status.XmlResult = Result.ToString();

         return EnvironmentManager.PrepareResult(Status);
      }

      private CommandStatus UnthawScript(CommandDetails command, int environment, int script, int group) {
         return FreezeRelatedCommand(
            new Predicate<SchedulerItem>(isFrozen),
            new Action<SchedulerItem>(markThawed),
            "Environment not present: {0}",
            "Item is not present: Group={0} Script={1}",
            "Item is not frozen",
            "Item has been thawed",
            command,
            environment,
            script,
            group);
      }

      private CommandStatus FreezeScript(CommandDetails command, int environment, int script, int group) {
         return FreezeRelatedCommand(
            new Predicate<SchedulerItem>(isThawed),
            new Action<SchedulerItem>(markFrozen),
            "Environment not present: {0}",
            "Item is not present: Group={0} Script={1}",
            "Item is already frozen",
            "Item has been frozen",
            command,
            environment,
            script,
            group);
      }

      private CommandStatus DeprecateEnvironment(CommandDetails command, int? environment) {
         StringBuilder Builder      = new StringBuilder();
         TrackList       Environments = new TrackList();
         CommandStatus Result       = new CommandStatus(command.Identifier, CommandState.Completed, "");
         List<int>     PrefetchList = new List<int>();

         if (0 == (environment ?? 0)) {
            Environments.AddRange(mapActiveTrackers.Values);
            mapActiveTrackers.Clear();
         }
         else {
            try { 
               Environments.Add(mapActiveTrackers[environment.Value]);
               mapActiveTrackers.Remove(environment.Value);
            }
            catch (KeyNotFoundException) { }

            PrefetchList.Add(environment.Value);
         }

         CollectAspectGroupInformation();

         if (Environments.Count == 0) {
            Builder.Append(ScriptManager.WarningElement("No environments deprecated"));
            if (environment.HasValue) {
               ///Prefetch the scheduled scripts for each deprecated environment
               foreach (string scheduled in InitializeEnvironmentSchedule(environment.Value))
                  Builder.Append(ScriptManager.CreateElement("scheduled", scheduled));
            }
         }
         else {
            foreach (EnvironmentTracker tracker in Environments) {
               markEnvironmentDeprecated(tracker.Instance);

               Builder.Append(ScriptManager.SuccessElement(string.Format("Environment deprecated: {0}", tracker.Manager)));

               ///Prefetch the scheduled scripts for each deprecated environment
               foreach (string scheduled in InitializeEnvironmentSchedule(tracker.Identifier))
                  Builder.Append(ScriptManager.CreateElement("scheduled", scheduled));
            }
         }

         Result.XmlResult = Builder.ToString();
         
         return EnvironmentManager.PrepareResult(Result);
      }

      private void StartItem(object state) {
         SchedulerItem S = (SchedulerItem)state;
         CommandDetails Command;

         ///Generate the command
         if (S.Scripts.Length == 1 && S.ScriptIdentifier != 0)
            Command = CommandGenerator.CreateScriptStart(S.Environment, S.Scripts[0]);
         else
            Command = CommandGenerator.CreateScriptGroupStart(S.Environment, S.GroupIdentifier, S.Scripts);

         ///Dispatch the command
         ProcessCommand(Command);
      }

      private void ScheduleStartItem(SchedulerItem item) {
         //ThreadPool.QueueUserWorkItem(new WaitCallback(StartItem), item);
         //DEBUG: use sync mode to help steping through
         StartItem(item);
      }

      #region Scheduling Helpers
      private bool testFlag(ulong flags, ulong flag) {
         return flag == (flags & flag);
      }

      private IEnumerable<SchedulerItem> enumerateScheduledItems() {
         foreach (int Env in scheduledScripts.Keys)
            foreach (SchedulerItem S in scheduledScripts[Env])
               yield return S;
      }

      private bool isThawed(SchedulerItem item) {
         return !isFrozen(item);
      }

      private bool isFrozen(SchedulerItem item) {
         bool Result = true;
         Result &= testFlag(item.Flags, ScriptFrozenBit);
         return Result;
      }

      private bool hasExamined(SchedulerItem item) {
         bool Result = true;
         Result &= testFlag(item.Flags, ScriptExaminedBit);
         return Result;
      }

      private bool hasRun(SchedulerItem item) {
         bool Result = true;
         Result &= testFlag(item.Flags, ScriptRanOnceBit);
         return Result;
      }

      private bool canSchedule(SchedulerItem item) {
         bool Result = true;
         Result &= item.ScheduleDeadline <= DateTime.UtcNow;
         Result &= !testFlag(item.Flags, ScriptFrozenBit);
         return Result;
      }

      private bool canSetDeadline(SchedulerItem item) {
         bool Result = true;
         Result &= testFlag(item.Flags, (ulong)ScriptFlagEnum.Scheduled);
         return Result;
      }

      private bool canAutoStart(SchedulerItem item) {
         bool Result = true;
         Result &= testFlag(item.Flags, (ulong)ScriptFlagEnum.ScheduleStart);
         return Result;
      }

      private void setDeadline(SchedulerItem item) {
         TimeSpan Period;
         Period = new TimeSpan(TimeSpan.TicksPerMillisecond * (long)item.Period);
         item.ScheduleDeadline = DateTime.UtcNow + Period;
      }

      private void markExamined(SchedulerItem item) {
         item.Flags |= ScriptExaminedBit;
      }

      private void markRun(SchedulerItem item) {
         item.Flags |= ScriptRanOnceBit;
      }

      private void markFrozen(SchedulerItem item) {
         item.Flags |= ScriptFrozenBit;
      }

      private void markThawed(SchedulerItem item) {
         item.Flags &= ~ScriptFrozenBit;
      }

      private bool isSchedulable(SchedulerItem item) {
         bool Result = true;
         Result &= testFlag(item.Flags, (ulong)ScriptFlagEnum.Scheduled);
         return Result;
      }

      private void initializeScheduledItem(SchedulerItem item) {
         item.Flags &= ScriptFlagsMask;
         item.ScheduleDeadline = DateTime.MaxValue;
      }

      private bool isTargetScheduledItem(SchedulerItem item, int script, int group) {
         return (item.ScriptIdentifier == script) && (item.GroupIdentifier == group);
      }
      #endregion

      private void NotifyScheduleOfScriptRun(int script, int group) {
         foreach (SchedulerItem S in enumerateScheduledItems()) {
            if (isTargetScheduledItem(S, script, group)) {
               Monitor.Enter(schedulerTimerLock);
               try {
                  if (!hasRun(S)) {
                     markRun(S);
                     if (canSetDeadline(S))
                       setDeadline(S);
                  }
               }
               finally {
                  Monitor.Exit(schedulerTimerLock);
               }
            }
         }
      }

      private void ExamineSchedule(object state) {
         List<SchedulerItem> ItemsToStart = new List<SchedulerItem>();

         ///Dont allow multiple timer threads to Examine the schedule
         if (Monitor.TryEnter(schedulerTimerLock)) {
            try {
               foreach (SchedulerItem S in enumerateScheduledItems()) {
                  if (!hasExamined(S)) {
                     markExamined(S);
                     if (canAutoStart(S))
                        ItemsToStart.Add(S);
                  }
                  else if(canSchedule(S)) {
                     ItemsToStart.Add(S);
                     if (canSetDeadline(S))
                        setDeadline(S);
                  }
               }
            }
            finally {
               ///Release the timer lock
               Monitor.Exit(schedulerTimerLock);
            }
         }

         /// Avoid congestion in locked region
         foreach (SchedulerItem S in ItemsToStart)
            ScheduleStartItem(S);
      }

      /// <summary>
      /// 
      /// </summary>
      /// <param name="environment"></param>
      /// <returns></returns>
      private string[] InitializeEnvironmentSchedule(int? environment) {
         List<string> ScheduledScripts;
         EnvScrCol Collection;
         
         ///Grab a snap-shot of scheduled scripts
         lock (scheduledScriptsLock)
            Collection = new EnvScrCol(scheduledScripts);
         
         ScheduledScripts = new List<string>();

         if (0 == (environment ?? 0))
            Collection = new Dictionary<int, List<SchedulerItem>>();
         else
            Collection.Remove(environment.Value);

         foreach (SchedulerItem ES in commandProcessor.EnumerateScheduledItems(environment ?? 0)) {
            if (isSchedulable(ES)) {
               EnvScrLst ScriptList;

               if (!Collection.TryGetValue(ES.Environment, out ScriptList)) {
                  ScriptList = new EnvScrLst();
                  Collection[ES.Environment] = ScriptList;
               }

               initializeScheduledItem(ES);

               ScriptList.Add(ES);

               ScheduledScripts.Add(string.Format("{0} - {1}", ES.Environment, ES.Alias));
            }
         }

         ///Replace the hold scheduled scripts
         lock (scheduledScriptsLock)
            scheduledScripts = Collection;

         return ScheduledScripts.ToArray();
      }

      /// <summary>
      /// Initializes environment scheduling behavior.
      /// </summary>
      private void BeginEnvironmentScheduling() {
         scheduledScripts = new EnvScrCol();
         scheduledScriptsLock = new object();

         foreach (EnvironmentInformation Environment in clientCommandLink.EnumerateEnvironments())
            InitializeEnvironmentSchedule(Environment.Identifier);

         schedulerTimerLock = new object();
         schedulerTimer = new Timer(new TimerCallback(ExamineSchedule), null, 0, ScheduleTimerPeriod);
      }

      /// <summary>
      /// Terminates periodic environment scheduling behavior.
      /// </summary>
      private void EndEnvironmentScheduling() {
         schedulerTimer.Dispose();
         scheduledScripts.Clear();
      }

      const int  ScheduleTimerPeriod   = 200;

      const ulong ScriptFlagsMask      = 0x00FFFFFFFFFFFFFF;
      const ulong ScriptExaminedBit    = 0x8000000000000000;
      const ulong ScriptRanOnceBit     = 0x4000000000000000;
      const ulong ScriptFrozenBit      = 0x2000000000000000;
      
      EnvScrCol scheduledScripts;
      object    scheduledScriptsLock;
      object    schedulerTimerLock;
      Timer     schedulerTimer;
   }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\wsmonitor\wsmService\NTService.Designer.cs ===
namespace LiveServiceMonitor {
    partial class NTService {
        /// <summary> 
        /// Required designer variable.
        /// </summary>
        private System.ComponentModel.IContainer components = null;

        /// <summary>
        /// Clean up any resources being used.
        /// </summary>
        /// <param name="disposing">true if managed resources should be disposed; otherwise, false.</param>
        protected override void Dispose(bool disposing) {
            if (disposing && (components != null)) {
                components.Dispose();
            }
            base.Dispose(disposing);
        }

        #region Component Designer generated code

        /// <summary> 
        /// Required method for Designer support - do not modify 
        /// the contents of this method with the code editor.
        /// </summary>
        private void InitializeComponent() {
            components = new System.ComponentModel.Container();
            this.ServiceName = "WSMonitor";
        }

        #endregion
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\wsmonitor\wsmService\Application.cs ===
using System;
using System.Collections.Generic;
using System.ServiceProcess;

namespace LiveServiceMonitor {
   using System.IO;
   using WSMCommon;

   static class Application {
      /// <summary>
      /// The main entry point for the application.
      /// </summary>
      static void Main(string [] args) {
         List<string> Args = new List<string>(args);

         // More than one user Service may run within the same process. To add
         // another service to this process, change the following line to
         // create a second service object. For example,
         //
         //   ServicesToRun = new ServiceBase[] {new Service1(), new MySecondUserService()};

         ///Required by BVT's
         Type ForceLoadCommonAssembly = typeof(WSMCommon.UnitTestRoot);
         Type ForceLoadFrameworkAssembly = typeof(WSMonitor.Framework.Scripting.Script);

         if (Args.Contains("-bvtall")) {
            using (StreamWriter Output = new StreamWriter("bvt.xml")) {
               bool Pass;
               
               Pass = Test.Runner.Run(
                  Test.Runner.EnumerateUnitTests(AppDomain.CurrentDomain),
                  Output);
            }
         }
         else if (Args.Contains("-bvt")) {
            using (StreamWriter Output = new StreamWriter("bvt.xml")) {
               bool Pass;

               Pass = Test.Runner.Run(
                  Test.Runner.EnumerateUnitTests(),
                  Output);
               
               if (Pass) Console.ForegroundColor = ConsoleColor.Green;
               else Console.ForegroundColor = ConsoleColor.Red;
            }
         }
         else if (Args.Contains("-rap")) {
            Service.DomainController.Startup(false);
         }
         else {
            ServiceBase[] ServicesToRun;
            ServicesToRun = new ServiceBase[] { new NTService() };

            ServiceBase.Run(ServicesToRun);
         }
      }
   }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\wsmonitor\wsmService\Service.CommandProcessor.cs ===
using System;
using System.Collections.Generic;
using System.IO;
using System.Text;
using System.Xml;
using System.Data;
using System.Data.SqlClient;
using System.Data.SqlTypes;

using WSMCommon.Control.Command;

namespace LiveServiceMonitor.Service {
   using Utility;

   [Serializable]
   public class CommandDetails {
      public CommandDetails() {
         this.timestamp = null;
         this.identifer = 0;
         this.action = ActionIdentifierEnum.AspectAdd;
         this.parameters = null;
      }

      public byte[] Timestamp {
         get { return null == timestamp ? new byte[0] : timestamp; }
         set { timestamp = value; }
      }

      public long Identifier {
         get { return identifer; }
         set { identifer = value; }
      }

      public ActionIdentifierEnum Action {
         get { return action; }
         set { action = value; }
      }

      public SqlXml Parameters {
         get { return null == parameters ? SqlXml.Null : parameters; }
         set { parameters = value; }
      }

      private byte[]               timestamp;
      private long                 identifer;
      private ActionIdentifierEnum action;
      private SqlXml               parameters;
   }

   public class SchedulerItem {
      public int      Environment;
      public int      ScriptIdentifier;
      public int      GroupIdentifier;
      public int[]    Scripts;
      public ulong    Flags;
      public int      Period;
      public string   Alias;

      public DateTime ScheduleDeadline;
   }

   public class CommandProcessor : IDisposable {
      public CommandProcessor(string host) {
         string ConnectionString = string.Format("Server={0};Integrated Security=SSPI;Database=WSMControlDb", host);
         
         this.connection = new SqlConnection(ConnectionString);
         this.connection.Open();

         QueryLock = new object();
      }

      public void Open()  { this.connection.Open();  }
      public void Close() { this.connection.Close(); }

      #region IDisposable Implementation
      public void Dispose() {
         this.connection.Dispose();
      }
      #endregion

      #region Environment Instance Control
      public long CreateEnvironmentInstance(int environment, string name, int status) {
         return UpdateEnvironmentInstance(null, environment, name, status);
      }

      public long UpdateEnvironmentInstance(long instance, int status) {
         return UpdateEnvironmentInstance(instance, null, null, status);
      }

      private long UpdateEnvironmentInstance(
         long? instance,
         int? environment,
         string name,
         int status) {
         SqlCommand Command;
         SqlParameter Output;

         Command = new SqlCommand("p_update_environment", connection);
         Command.CommandType = CommandType.StoredProcedure;

         Command.Parameters.Add(new SqlParameter("@bi_environment", instance ?? 0));
         Command.Parameters.Add(new SqlParameter("@i_environment", environment ?? 0));
         Command.Parameters.Add(new SqlParameter("@i_status", status));
         Command.Parameters.Add(new SqlParameter("@vc_name", name ?? ""));
         Command.Parameters.Add(Output = new SqlParameter("@bi_result", SqlDbType.BigInt));

         Output.Direction = ParameterDirection.Output;

         lock (QueryLock) { Command.ExecuteNonQuery(); }

         return (long)Output.Value;
      }
      #endregion

      #region Script Instance Control
      public long CreateScriptInstance(
         long environment,
         int script,
         string name,
         int? status,
         string report) {
         return UpdateScriptInstance(null, environment, script, name, status, report);
      }

      private long UpdateScriptInstance(
         long? instance,
         long? environment,
         int? script,
         string name,
         int? status,
         string report) {
         SqlCommand Command;
         SqlParameter Report;
         SqlParameter Output;

         Command = new SqlCommand("p_update_script", connection);
         Command.CommandType = CommandType.StoredProcedure;

         Command.Parameters.Add(new SqlParameter("@bi_script", instance ?? 0));
         Command.Parameters.Add(new SqlParameter("@bi_environment", environment ?? 0));
         Command.Parameters.Add(new SqlParameter("@i_script", script ?? 0));
         Command.Parameters.Add(new SqlParameter("@i_status", status ?? 0));
         Command.Parameters.Add(new SqlParameter("@vc_name", name ?? ""));
         Command.Parameters.Add(Report = new SqlParameter("@xml_report", SqlDbType.Xml));
         Command.Parameters.Add(Output = new SqlParameter("@bi_result", SqlDbType.BigInt));

         Output.Direction = ParameterDirection.Output;
         Report.Value = SqlXml.Null;
         if (null != report) {
            using (StringReader sr = new StringReader(report)) {
               using (XmlTextReader xtr = new XmlTextReader(sr))
                  Report.Value = new SqlXml(xtr);
            }
         }

         lock (QueryLock) { Command.ExecuteNonQuery(); }

         return (long)Output.Value;
      }

      public long UpdateScriptInstance(long instance, string report) {
         return UpdateScriptInstance(instance, null, report);
      }

      public long UpdateScriptInstance(long instance, int status) {
         return UpdateScriptInstance(instance, status, null);
      }

      public long UpdateScriptInstance(long instance, int? status, string report) {
         return UpdateScriptInstance(instance, 0, 0, null, status, report);
      }
      #endregion

      public IEnumerable<SchedulerItem> EnumerateScheduledItems(int env) {
         List<SchedulerItem> Items = new List<SchedulerItem>();
         Items.AddRange(EnumerateEnvironmentScripts(env));
         Items.AddRange(EnumerateEnvironmentScriptGroups(env));
         return Items;
      }

      private SqlCommand NewCommand(string name) {
         SqlCommand Command;

         Command = new SqlCommand(name, connection);
         Command.CommandType = System.Data.CommandType.StoredProcedure;

         return Command;
      }

      private IEnumerable<SchedulerItem> EnumerateEnvironmentScriptGroups(int env) {
         SqlCommand Command = NewCommand("p_get_environment_scriptgroups");
         SqlDataReader Reader;

         Command.Parameters.Add(new SqlParameter("@i_environment", env));

         lock (QueryLock) {
            using (Reader = Command.ExecuteReader()) {
               int OrdScriptGroup = Reader.GetOrdinal("i_script_group");
               int OrdEnvironment = Reader.GetOrdinal("i_environment");
               int OrdScripts     = Reader.GetOrdinal("xml_scripts");
               int OrdFlags       = Reader.GetOrdinal("bi_flags");
               int OrdPeriod      = Reader.GetOrdinal("i_period");
               int OrdAlias       = Reader.GetOrdinal("vc_name");

               while (Reader.Read()) {
                  SchedulerItem Result = new SchedulerItem();
                  XmlReader XmlReader;

                  Result.GroupIdentifier = Reader.GetInt32(OrdScriptGroup);
                  Result.ScriptIdentifier = 0;
                  Result.Environment = Reader.GetInt32(OrdEnvironment);
                  Result.Flags       = (ulong)Reader.GetInt64(OrdFlags);
                  Result.Period      = Reader.GetInt32(OrdPeriod);
                  Result.Alias       = Reader.GetString(OrdAlias);

                  ///Collect scripts array from the xml
                  using (XmlReader = Reader.GetSqlXml(OrdScripts).CreateReader()) {
                     List<int> Scripts = new List<int>();
                     while (XmlReader.Read()) {
                        if (XmlReader.Name == "script") {
                           XmlReader.MoveToAttribute("id");
                           Scripts.Add(Convert.ToInt32(XmlReader.Value));
                        }
                     }
                     Result.Scripts = Scripts.ToArray();
                  }

                  yield return Result;
               }
            }
         }
      }

      private IEnumerable<SchedulerItem> EnumerateEnvironmentScripts(int env) {
         SqlCommand Command = NewCommand("p_get_environment_scripts");
         SqlDataReader Reader;

         Command.Parameters.Add(new SqlParameter("@i_environment", env));

         lock (QueryLock) {
            using (Reader = Command.ExecuteReader()) {
               int OrdEnvironment = Reader.GetOrdinal("i_environment");
               int OrdScript = Reader.GetOrdinal("i_script");
               int OrdFlags = Reader.GetOrdinal("bi_flags");
               int OrdPeriod = Reader.GetOrdinal("i_period");
               int OrdAlias = Reader.GetOrdinal("vc_alias");

               while (Reader.Read()) {
                  SchedulerItem Result = new SchedulerItem();
                  Result.GroupIdentifier = 0;
                  Result.ScriptIdentifier = Reader.GetInt32(OrdScript);
                  Result.Environment = Reader.GetInt32(OrdEnvironment);
                  Result.Scripts = new int[] { Result.ScriptIdentifier };
                  Result.Flags = (ulong)Reader.GetInt64(OrdFlags);
                  Result.Period = Reader.GetInt32(OrdPeriod);
                  Result.Alias = Reader.GetString(OrdAlias);
                  yield return Result;
               }
            }
         }
      }

      public CommandDetails NextCommand(ref byte[] timestamp) {
         SqlCommand Command;

         Command = new SqlCommand("p_read_command", connection);
         Command.CommandType = System.Data.CommandType.StoredProcedure;

         if (null != timestamp && timestamp.Length == 8) {
            SqlParameter Param;
            Param = new SqlParameter("@timestamp", SqlDbType.Timestamp);
            Param.Value = timestamp;
            Command.Parameters.Add(Param);
         }

         lock (QueryLock) {
            using (SqlDataReader Reader = Command.ExecuteReader()) {
               if (Reader.Read()) {
                  CommandDetails Details = new CommandDetails();
                  int iAction = (int)Reader["i_action"];
                  int oXml = Reader.GetOrdinal("xml_parameters");

                  timestamp = (byte[])Reader["dt_timestamp"];
                  Details.Identifier = (long)Reader["bi_command"];
                  Details.Parameters = Reader.GetSqlXml(oXml);
                  Details.Timestamp = timestamp;

                  if (Enum.IsDefined(typeof(ActionIdentifierEnum), iAction))
                     Details.Action = (ActionIdentifierEnum)iAction;
                  else
                     Details.Action = ActionIdentifierEnum.Invalid;

                  return Details;
               }
            }
         }

         return null;
      }

      private void PostState(CommandStatus state, bool moveToHistory) {
         ///Internally dispatched commands dont get written to control database
         if (InternalCommandIdentifier != state.Command) {
            SqlCommand Cmd;
            StringReader Reader = new StringReader(state.XmlResult);
            SqlXml Xml;

            if (string.IsNullOrEmpty(state.XmlResult))
               Xml = SqlXml.Null;
            else
               Xml = new SqlXml(XmlReader.Create(Reader));

            Cmd = new SqlCommand("p_write_result", connection);
            Cmd.CommandType = System.Data.CommandType.StoredProcedure;
            Cmd.Parameters.Add(new SqlParameter("@bi_command", state.Command));
            Cmd.Parameters.Add(new SqlParameter("@i_status", (int)state.Status));
            Cmd.Parameters.Add(new SqlParameter("@xml_result", Xml));
            Cmd.Parameters.Add(new SqlParameter("@i_flag", moveToHistory ? (int)1 : (int)0));

            lock (QueryLock) {
               Cmd.ExecuteNonQuery();
            }
         }
      }

      public void PostState(CommandStatus state) {
         PostState(state, FinalStateAttribute.IsFinal(state.Status));
      }

      private object QueryLock;
      private SqlConnection connection;

      public const long InternalCommandIdentifier = -1;
   }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\wsmonitor\wsmService\Service.DomainController.cs ===
using System;
using System.Collections;
using System.Collections.Generic;
using System.Threading;
using System.Reflection;
using System.Diagnostics;
using System.Xml;
using System.Xml.XPath;
using System.Runtime.Remoting.Lifetime;
using System.Security.Permissions;

using WSMCommon.Control;
using WSMCommon.Control.Command;
using WSMCommon.Control.Result;
using System.Security.Cryptography;

using System.IO;

namespace LiveServiceMonitor.Service {
   #region Using Directives
   using Utility;
   using Utility.Performance;

   using Health;
   using Framework.Services;
   #endregion

   using TrackList = System.Collections.Generic.List<DomainController.EnvironmentTracker>;

   /// <summary>
   /// The Domain Controller is the authority on communication between 
   /// the control database and the service.  This component manages delegating 
   /// commands to the approapriate environments as well as created and destroying
   /// environments.
   /// </summary>
   public partial class DomainController : ComponentHealth {
      /// <summary>
      /// DomainController static initializer.  The configuration file is read for
      /// </summary>
      static DomainController() {
         XPathDocument  Settings;
         string         ConfigPath;
         XPathNavigator Nav;
         
         controlDbHost = "";

         ConfigPath = System.IO.Path.Combine(BaseDirectory, "monitor.exe.xml");

         try {
            Settings = new XPathDocument(ConfigPath);

            Nav = Settings.CreateNavigator();
            Nav = Nav.SelectSingleNode(configControlDb);

            if (null == Nav)
               throw new XmlParserException("Configuration is missing control-db key", configControlDb);

            controlDbHost = Nav.GetAttribute("host", "");
         }
         catch (System.IO.FileNotFoundException e) {
            throw new System.IO.FileNotFoundException("Unable to locate configuration file", ConfigPath, e);
         }
      }

      /// <summary>
      /// Gets the directory that the service is running under.
      /// </summary>
      public static string BaseDirectory {
         get { return AppDomain.CurrentDomain.SetupInformation.ApplicationBase; }
      }

      /// <summary>
      /// Writes information about unhandled exceptions to the event log.
      /// </summary>
      /// <param name="sender">The source of the unhandled exception event.</param>
      /// <param name="args">An UnhandledExceptionEventArgs that contains the event data.</param>
      private static void ExceptionHandler(object sender, UnhandledExceptionEventArgs args) {
         System.Text.StringBuilder Message = new System.Text.StringBuilder();

         Message.AppendLine("Unhandled exception in monitor.exe");
         
         try {
            if (null != sender)
               Message.AppendFormat("Source   : {0}\r\n", sender);
         }
         catch { }

         try { Message.AppendFormat("Exception: {0}\r\n", args.ExceptionObject); }
         catch { }

         EventLog.WriteEntry(
            NTService.EventSource,
            Message.ToString());
      }

      /// <summary>
      /// Initializes singleton instance of the Domain Controller.
      /// </summary>
      /// <returns>Returns a pointer to the singleton Domain Controller.</returns>
      private static DomainController Initialize() {
         lock (instanceLock) {
            System.Diagnostics.Debug.Assert(null == instance, "Only one Domain Controller allowed per process");
            eventReset = new EventWaitHandle(true, EventResetMode.ManualReset);
            instance   = new DomainController();
            AppDomain.CurrentDomain.UnhandledException += new UnhandledExceptionEventHandler(ExceptionHandler);
         }
         return instance;
      }

      /// <summary>
      /// Initializes and Runs the controller.
      /// The controller is run on a new thread, so this call will return immediately.
      /// </summary>
      public static void Startup(bool async) {
         DomainController Controller = Initialize();
         if (async) {
            controllerThread = new Thread(StartupRun);
            controllerThread.Start();
         }
         else
            instance.Run();
      }

      /// <summary>
      /// Terminates the controller.
      /// </summary>
      public static void Shutdown() {
         eventReset.Reset();
         if (!controllerThread.Join(abortTimeout))
            controllerThread.Abort();
      }

      /// <summary>
      /// Thread entry point for the domain controller.
      /// </summary>
      private static void StartupRun() {
         instance.Run();
      }

      /// <summary>
      /// Initializes a new instance of a Domain Controller.
      /// </summary>
      private DomainController() : base("Domain Controller") {
         this.clientCommandLink = new CommandLink(null, controlDbHost);
         this.commandProcessor = new CommandProcessor(controlDbHost);
         this.mapInstances = new Dictionary<long, EnvironmentManager>();
         this.mapActiveTrackers = new Dictionary<int, EnvironmentTracker>();
         this.mapTrackers = new Dictionary<long,EnvironmentTracker>();
         this.domainDestructionQueue = new Queue<AppDomain>();
         this.environmentState = null;

         this.domainDestroyerThrottle = new Throttle(1000, 60000, 3.0f);
         this.commandPollThrottle = new Throttle(100, 4000, 1.5f);

         EnvironmentInstance[] Instances = clientCommandLink.EnumerateEnvironmentInstances();
         for (int c = 0; c < Instances.Length; c++) {
            if (Instances[c].Status < EnvironmentManager.MinimumCompleteStatus) {
               commandProcessor.UpdateEnvironmentInstance(
                  Instances[c].Instance, EnvironmentManager.StatusTerminated);
            }
         }
      }

      /// <summary>
      /// Transforms the controller Db command to a Domain Contoller and Environment Manager command.
      /// </summary>
      /// <param name="input">The command details from the controller database.</param>
      /// <param name="hostPart">The command details for the domain controller.</param>
      /// <param name="envPart">The command details for the environment manager.</param>
      /// <returns>Returns true when <paramref name="input">input</paramref> is not null.</returns>
      private bool CommandFork(CommandDetails input, out CommandDetails hostPart, out CommandDetails envPart) {
         hostPart = input;
         envPart  = input;

         return null != input;
      }

      private void DisposeDeadManager(EnvironmentTracker tracker) {
         domainDestructionQueue.Enqueue(tracker.Domain);
         destroyEnvironmentTracker(tracker);
         markEnvironmentDead(tracker.Instance);
      }

      private void DisposeDestroyedManager(EnvironmentTracker tracker) {
         domainDestructionQueue.Enqueue(tracker.Domain);
         destroyEnvironmentTracker(tracker);
         markEnvironmentDestroyed(tracker.Instance);
      }

      /// <summary>
      /// Runs the Domain Controller.
      /// </summary>
      private void Run() {
         
         byte[]    Timestamp   = null;

         ///Initializes environment management code
         BeginEnvironmentScheduling();

         ///Brings up the domain destroyer worker thread
         domainDestroyerThread = new Thread(new ThreadStart(DomainDestroyer));
         domainDestroyerThread.Start();
         
         ///Check to see if an abort is requested
         while (eventReset.WaitOne(0, false)) {
            TrackList DestroyList = new TrackList();
            TrackList DeadList    = new TrackList();

            bool activity = false;

            try {
               ///Process a new command if one is available
               activity = ProcessCommand(commandProcessor.NextCommand(ref Timestamp));

               ///Service environment managers
               foreach (EnvironmentTracker Tracker in mapTrackers.Values) {
                  EnvironmentManager Manager = Tracker.Manager;

                  try {
                     //The environment was inactive this pass, check to see if it is dead and deprecated.
                     if ((Manager.ScriptRunners < 1) && isEnvironmentDeprecated(Tracker)) {
                        //Queue up for destruction
                        DestroyList.Add(Tracker);
                     }
                  }
                  catch (System.Runtime.Remoting.RemotingException) {
                     DeadList.Add(Tracker);
                  }
               }

               //Remove reference to Manager and schedule its domain for destruction.
               foreach (EnvironmentTracker Tracker in DestroyList)
                  DisposeDestroyedManager(Tracker);
               //Remove reference to Manager and schedule its domain for destruction.
               foreach (EnvironmentTracker Tracker in DeadList)
                  DisposeDeadManager(Tracker);

               DestroyList.Clear();
               DeadList.Clear();
            }
            catch (ThreadAbortException) { break; }
            catch (Exception e) {
               System.Diagnostics.EventLog.WriteEntry(
                  NTService.EventSource,
                  "Unhandled exception.\r\n" + e.ToString(), 
                  System.Diagnostics.EventLogEntryType.Error,
                  NTService.BugEventId);

               //Bring down the application (make these unhandled exceptions more noticable)
               throw;
            }

            //Exponential backoff when service goes idle
            if (activity)
               commandPollThrottle.Decrease();
            else
               commandPollThrottle.Increase();

            commandPollThrottle.Wait();
         }

         //APPLICATION TERMINATING
         EndEnvironmentScheduling();

         //Cleanup environment instances (mark them as destroyed)
         foreach (long instance in mapTrackers.Keys) {
            markEnvironmentDestroyed(instance);
         }
      }

      #region Environment Event Handlers, Delegates, and Subscriber
      /// <summary>
      /// Subscribes to environment events.
      /// </summary>
      /// <param name="manager">Publisher of events that the domain controller will be subscribing to.</param>
      private void ConnectEventHandlers(EnvironmentManager manager) {
         manager.OnCommandResult += new EventHandler<EnvironmentManager.CommandResultArgs>(Handler_CommandUpdate);
         manager.OnInstanceChange += new EventHandler<EnvironmentManager.InstanceChangeArgs>(Handler_InstanceChange);
         manager.OnScriptUpdate += new EventHandler<EnvironmentManager.ScriptUpdateArgs>(Handler_ScriptUpdate);

         manager.ScriptInstanceGenerator = new EnvironmentManager.ScriptInstanceGeneratorDelegate(Generate_ScriptInstance);
         manager.ScriptGroupStartNotifier = new EnvironmentManager.ScriptGroupStartNotifierDelegate(Handle_ScriptGroupStart);
      }

      /// <summary>
      /// Notifies the scheduler that a script instance started.
      /// </summary>
      /// <param name="group">Unique identifier of the script group.</param>
      private void Handle_ScriptGroupStart(int group) {
         if (0 != group)
            NotifyScheduleOfScriptRun(0, group);
      }

      /// <summary>
      /// Generates a new script instance for the requester.
      /// </summary>
      /// <param name="environment">Environment instance the script instance will live under.</param>
      /// <param name="script">Unique numeric identifier associated with the script.</param>
      /// <param name="name">Unique name associated with the script.</param>
      /// <returns>A unique instance identifier for a newly created script.</returns>
      private long Generate_ScriptInstance(long environment, int script, string name) {
         long instance = commandProcessor.CreateScriptInstance(environment, script, name, 0, null);
         if (0 != instance)
            NotifyScheduleOfScriptRun(script, 0);
         return instance;
      }

      /// <summary>
      /// Handles mapping new, and unmapping instance mappings to the target Environment Manager.
      /// </summary>
      /// <param name="sender">The target environment manager.</param>
      /// <param name="args">Contains information about the instance mapping change.</param>
      private void Handler_InstanceChange(object sender, EnvironmentManager.InstanceChangeArgs args) {
         if (args.Deleted)
            mapInstances.Remove(args.Instance);
         else
            mapInstances[args.Instance] = (EnvironmentManager)sender;
      }

      /// <summary>
      /// Posts an updated status and report of script instance to the control database.
      /// </summary>
      /// <param name="sender">The target environment manager.</param>
      /// <param name="args">Contains information about the changed script.</param>
      private void Handler_ScriptUpdate(object sender, EnvironmentManager.ScriptUpdateArgs args) {
         commandProcessor.UpdateScriptInstance(args.Instance, args.Status, args.Report);
      }

      /// <summary>
      /// Updates the control database with information related to the executing command.
      /// </summary>
      /// <param name="sender">The target environment manager.</param>
      /// <param name="args">Contains information about the command to be updated.</param>
      private void Handler_CommandUpdate(object sender, EnvironmentManager.CommandResultArgs args) {
         commandProcessor.PostState(args.Status);
      }
      #endregion

      /// <summary>
      /// Searches for an environment based on the specified instance.
      /// </summary>
      /// <param name="instance">Instance value used to control lookup.</param>
      /// <param name="details">Command details.</param>
      /// <returns>
      /// An instance of an EnvironmentManager.  
      /// A value of null indicates that no EnvironmentManager is associated with the given instance.
      /// </returns>
      private EnvironmentManager GetEnvironmentByInstance(long instance, CommandDetails details) {
         EnvironmentManager Manager = null;

         if (mapInstances.ContainsKey(instance))
            Manager = mapInstances[instance];

         return Manager;
      }

      /// <summary>
      /// Searches for an environment based on the specified instance.  If the environment does not
      /// exist then a new environment is created.
      /// </summary>
      /// <param name="environment">Unique id associated with environment.</param>
      /// <param name="details">Command details.</param>
      /// <returns>An instance of an EnvironmentManager.  A value of null indicates that an error occurred.</returns>
      private EnvironmentManager GetEnvironmentById(int environment, CommandDetails details) {
         EnvironmentTracker Tracker = null;

         try {
            Tracker = mapActiveTrackers[environment];
         }
         catch (KeyNotFoundException) {
            Tracker = createEnvironmentTracker(environment);
            if (null != Tracker)
               registerEnvironmentTracker(Tracker);
         }

         return Tracker.Manager;
      }

      private void postError(CommandDetails command, string message, params object[] args) {
         CommandStatus Status = new CommandStatus(command.Identifier, CommandState.Error, "");
         Status.XmlResult = ScriptManager.ErrorElement(string.Format(message, args));
         commandProcessor.PostState(Status);
      }

      /// <summary>
      /// Dispatches command to the correct target(s).  Target(s) are determined by the instance or
      /// environment parameters.  The target host environment is located by instance mapping when
      /// instance parameters are specfied.  Otherwise they are mapped by environment values.
      /// If neither environment nor instance parameters are present the message will be discarded.
      /// </summary>
      /// <param name="Command">
      /// Details representing the command being pulled from the controller database.
      /// <remarks>If this value is null no action will be taken.</remarks>
      /// </param>
      private bool ProcessCommand(CommandDetails Command) {
         CommandDetails HostDetails, EMDetails;

         if (CommandFork(Command, out HostDetails, out EMDetails)) {
            XmlParser       Parser;
            long               Instance = 0;
            bool               Handled = false;

            Parser = new XmlParser(HostDetails.Parameters);
            switch (HostDetails.Action) {
               ///Domain controller is interested in this message
               case ActionIdentifierEnum.EnvironmentDeprecate: {
                     int? Parameter = null;

                     if (Parser.TryRead<long>(paramInstance, out Instance))
                        Parameter = (int)Instance;

                     commandProcessor.PostState(DeprecateEnvironment(HostDetails, Parameter));

                     break;
                  }
               case ActionIdentifierEnum.SchedulerFreezeGroup: {
                     int Environment;
                     int Group;

                     if (!Parser.TryRead<int>(paramEnvironment, out Environment))
                        postError(Command, "environment parameter missing");
                     else if (!Parser.TryRead<int>(paramItem, out Group))
                        postError(Command, "group parameter missing");
                     else
                        commandProcessor.PostState(FreezeScript(Command, Environment, 0, Group));

                     break;
                  }
               case ActionIdentifierEnum.SchedulerFreezeScript: {
                     int Environment;
                     int Script;

                     if (!Parser.TryRead<int>(paramEnvironment, out Environment))
                        postError(Command, "environment parameter missing");
                     else if (!Parser.TryRead<int>(paramItem, out Script))
                        postError(Command, "script parameter missing");
                     else
                        commandProcessor.PostState(FreezeScript(Command, Environment, Script, 0));

                     break;
                  }
               case ActionIdentifierEnum.SchedulerThawGroup: {
                     int Environment;
                     int Group;

                     if (!Parser.TryRead<int>(paramEnvironment, out Environment))
                        postError(Command, "environment parameter missing");
                     else if (!Parser.TryRead<int>(paramItem, out Group))
                        postError(Command, "group parameter missing");
                     else
                        commandProcessor.PostState(UnthawScript(Command, Environment, 0, Group));

                     break;
                  }
               case ActionIdentifierEnum.SchedulerThawScript: {
                     int Environment;
                     int Script;

                     if (!Parser.TryRead<int>(paramEnvironment, out Environment))
                        postError(Command, "environment parameter missing");
                     else if (!Parser.TryRead<int>(paramItem, out Script))
                        postError(Command, "script parameter missing");
                     else
                        commandProcessor.PostState(UnthawScript(Command, Environment, Script, 0));

                     break;
                  }
               default:
                  EnvironmentManager Manager = null;
                  CommandStatus Result = new CommandStatus(HostDetails.Identifier, CommandState.Error, "");

                  try {
                     ///Figure out which manager the command is targeted for
                     if (Parser.TryRead<long>(paramInstance, out Instance))
                        Manager = GetEnvironmentByInstance(Instance, HostDetails);
                     else {
                        int Environment;
                        if (Parser.TryRead<int>(paramEnvironment, out Environment)) {
                           Manager =
                              GetEnvironmentById(Environment, HostDetails);
                        }
                     }
                  }
                  catch (ServiceCodeGeneratorException e) {
                     Result.XmlResult = ScriptManager.ErrorElement(
                        string.Format("Service build failed: exception={0}", e.Message));

                     Handled = true;

                     //TODO: Report health incident for "Client configuration" component
                  }
                  catch (ScriptBuildErrorException e) {
                     Result.XmlResult = ScriptManager.ErrorElement(
                        string.Format("Script build failed: exception={0}", e.Message));

                     Handled = true;

                     //TODO: Report health incident for "Client configuration" component
                  }
                  catch (ScriptParserException e) {
                     Result.XmlResult = ScriptManager.ErrorElement(
                        string.Format("Script parse failed: exception={0}", e.Message));

                     Handled = true;

                     //TODO: Report health incident for "Client configuration" component
                  }
                  catch (CryptographicException e) {
                     Result.XmlResult = ScriptManager.ErrorElement(
                        string.Format("Certificate loading failed, please make sure the certificate is installed correctly: exception={0}", e.Message));

                     Handled = true;

                     //TODO: Report health incident for "Client configuration" component
                  }
                  catch (UriFormatException e) {
                     Result.XmlResult = ScriptManager.ErrorElement(
                        string.Format("Service URI format is not valid, please make sure service host/flag pairs are all configured correctly: exception={0}", e.Message));

                     Handled = true;

                     //TODO: Report health incident for "Client configuration" component
                  }
                  catch (Exception e) {
                     //CHANGE: Unhandled exceptions no longer bring down application, however they still cause event log writes.
                     //        These entries should be treated as bugs.
                     System.Diagnostics.EventLog.WriteEntry(
                        NTService.EventSource,
                        "Unexpected exception encountered while processing command.\r\n" + e.ToString(),
                        System.Diagnostics.EventLogEntryType.Error,
                        NTService.CommandExceptionEventId);

                     Result.XmlResult = ScriptManager.ErrorElement(
                        string.Format("Unexpected exception encountered while processing command: exception={0}", e));

                     Handled = true;

                     //TODO: Report health incident for "Environment" component
                  }

                  //Failed to locate environment
                  if (null == Manager && !Handled) {
                     Result.XmlResult = ScriptManager.ErrorElement("Unable to locate target environment manager");

                     //TODO: Report health incident for "External Clients" component
                  }
                  //Successfully located environment
                  else if (!Handled) {
                     try {
                        Manager.HandleCommand(EMDetails);
                        break;
                     }
                     catch (TargetInvocationException e) {
                        Result.XmlResult = ScriptManager.ErrorElement(
                           string.Format("Unable to dispatch command to environment: manager={0}, exception={1}", 
                           Manager, e.InnerException));
                     }
                     catch (Exception e) {
                        Result.XmlResult = ScriptManager.ErrorElement(
                           string.Format("Unable to dispatch command to environment: manager={0}, exception={1}",
                           Manager, e));

                        //TODO: Report health incident for "Environment Manager" component
                     }
                  }

                  commandProcessor.PostState(EnvironmentManager.PrepareResult(Result));

                  break;
            }

            return true;
         }

         return false;
      }

      [SecurityPermission(SecurityAction.LinkDemand, Flags = SecurityPermissionFlag.Infrastructure)]
      public override object InitializeLifetimeService()
      {
         return null;
      }

       /// <summary>
      /// Worker thread procedure designed for destruction of application domains.
      /// </summary>
      private void DomainDestroyer() {
         while (eventReset.WaitOne(0, false)) {
            AppDomain FirstFailure = null;
            bool Collect = false;

            while (domainDestructionQueue.Count > 0) {
               AppDomain Domain = domainDestructionQueue.Dequeue();

               //Dont allow this thread to get too busy.
               //Break out of the Active loop if we have failed here already.
               if (Domain == FirstFailure)
                  break;

               try { 
                  AppDomain.Unload(Domain);
                  Collect = true;
               }
               catch (CannotUnloadAppDomainException) {
                  //Indicate first failure if we have not already.
                  if (null == FirstFailure)
                     FirstFailure = Domain;

                  domainDestructionQueue.Enqueue(Domain);
               }

               domainDestroyerThrottle.WaitMin();
            }

            if (Collect)
               GC.Collect();

            domainDestroyerThrottle.WaitMax();
         }
      }

      private CommandLink                          clientCommandLink;
      private CommandProcessor                     commandProcessor;

      private Dictionary<int , EnvironmentTracker> mapActiveTrackers;
      private Dictionary<long, EnvironmentTracker> mapTrackers;
      private Dictionary<long, EnvironmentManager> mapInstances;

      private Queue<AppDomain>                     domainDestructionQueue;
      private EnvironmentState                     environmentState;
      private Throttle                             domainDestroyerThrottle;
      private Throttle                             commandPollThrottle;
      private Thread                               domainDestroyerThread;

      private static object                        instanceLock = new object();
      private static DomainController              instance     = null;
      private static Thread                        controllerThread = null;
      private static EventWaitHandle               eventReset = null;

      private static readonly string controlDbHost        = null;
      private const int abortTimeout                      = 1500;
      private const int maxStatusUpdatesPerSpin           = 5;
      private const int maxScriptCreatesPerSpin           = 10;
      private const string paramEnvironment               = "/command/environment/@id";
      private const string paramInstance                  = "/command/instance/@id";
      private const string paramItem                      = "/command/target/@id";
      private const string configControlDb                = "/application/config/control-db";

      internal class EnvironmentTracker {
         public AppDomain          Domain;
         public EnvironmentManager Manager;
         public ILease             Lease;
         public ClientSponsor      Sponsor;
         public long               Instance;
         public int                Identifier;
      }
   }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\wsmonitor\wsmService\Service.Reporting.Subscribers.cs ===
using System;

using WSMonitor.Framework.Reporting;

namespace LiveServiceMonitor.Service.Reporting {

}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\wsmonitor\wsmService\Service.EnvironmentManager.cs ===
using System;

using System.Collections;
using System.Collections.Generic;

using System.Text;
using System.Security.Cryptography.X509Certificates;
using System.Reflection;
using System.Runtime.Serialization;
using System.Xml;
using System.Xml.XPath;
using System.IO;
using System.Security.Permissions;

using System.CodeDom;
using System.CodeDom.Compiler;
using Microsoft.CSharp;

using WSMCommon.Control;
using WSMCommon.Control.Command;
using WSMCommon.Control.Result;

using WSMonitor.Framework.Reporting;
using WSMonitor.Framework.Exceptions;
using WSMonitor.Framework.Scripting;

using System.Runtime.Remoting.Lifetime;

namespace LiveServiceMonitor.Service {
   #region Using Directives
   using Test;
   using Framework.Services;
   using Utility;
   using Health;

   using AspectCache = Dictionary<int, Type[]>;
   #endregion

   internal partial class EnvironmentManager : ComponentHealth, IReportServer, IDisposable {
      void IDisposable.Dispose() {
      }

      public EnvironmentManager(long instance, IDictionary properties) : base("Environment Manager") {
         ServiceInformation[]    Services;
         XPathDocument           Document;
         string                  ConfigPath;
         string                  BasePath;
         List<ScriptInformation> Scripts;

         BasePath = DomainController.BaseDirectory;
         ConfigPath = Path.Combine(BasePath, "monitor.exe.xml");
         protocolConfigationRootPath = Path.Combine(BasePath, @"config\protocol");

         this.environmentState = (EnvironmentState)((EnvironmentState)properties[EnvStateProperty]).Clone();
         this.scriptManager = new ScriptManager(this, new XmlParser());
         this.environment = (EnvironmentInformation)properties[EnvInformationProperty];
         
         this.instance = instance;
         this.certificate = null;
         if (!string.IsNullOrEmpty(environment.Certificate))
            this.certificate = CertificateUtility.GetCertificate(environment.Certificate);

         Services = (ServiceInformation[])properties[ServicesProperty];
         Document = new XPathDocument(ConfigPath);

         Scripts = new List<ScriptInformation>();
         foreach (ScriptInformation Script in (ScriptInformation[])properties[ScriptsProperty]) {
            long Flag = Script.Flag ?? 0;
            
            scriptManager.ScriptFlagMap[Script.Identifier] = Flag;
            if (0 == (Flag & (long)ScriptFlagEnum.Disabled))
               Scripts.Add(Script);
            else
               Scripts.Add(ScriptGenerator.GetDisabledScript(Script));
         }

         AppDomain.CurrentDomain.AssemblyResolve += new ResolveEventHandler(ExtensionAssemblyResolver);
         
         InitializeEnvironment(Scripts.ToArray());

         BuildEnvironmentCodebase(
            Document.CreateNavigator().SelectSingleNode("/application/config"),
            Scripts.ToArray(), Services);
      }

      private static string GetExtensionsDir(string subPath) {
         string Base = Path.Combine(DomainController.BaseDirectory, "extensions\\");
         return string.IsNullOrEmpty(subPath) ? Base : Path.Combine(Base, subPath);
      }

      Assembly ExtensionAssemblyResolver(object sender, ResolveEventArgs args) {
         AssemblyName Name = new AssemblyName(args.Name);
         Assembly     Result = null;
         string       AssemblyPath = GetExtensionsDir(Name.Name + ".dll");

         try { 
            if (File.Exists(AssemblyPath))
               Result = Assembly.LoadFile(AssemblyPath); 
         }
         catch { }

         return Result;
      }

      #region IReportServer Implementation
      void IReportServer.RegisterSubscriber(IReportSubscriber target) { throw new NotSupportedException(); }
      void IReportServer.UnregisterSubscriber(IReportSubscriber target) { throw new NotSupportedException(); }
      void IReportServer.DispatchReport(Report report, out DeliveryFailure[] failures) {
         failures = new DeliveryFailure[0];

         if (report != null) {
            while (report.Parent != null)
               report = report.Parent;
            
            PostScriptUpdate(report.Instance, null, report);
         }
      }

      IEnumerable<IReportSubscriber> IReportServer.Subscribers { get { return new IReportSubscriber[0]; } }
      #endregion

      private void InitializeEnvironment(ScriptInformation[] scripts) {
         ReportServer.ActiveServer = this;
         ReportServer.LockConfiguration();

         InitializeAspectTable(scripts);
      }

      private List<Type> generateSinkList(AspectCache aspectCache, int? identifier) {
         List<Type> Result = new List<Type>();

         if (identifier.HasValue) {
            try {
               Result.AddRange(aspectCache[identifier.Value]);
            }
            catch (KeyNotFoundException) {
               AspectInformation[] Aspects;

               Aspects = environmentState.GetGroupAspects(identifier.Value);
               foreach (AspectInformation info in Aspects)
                  Result.Add(Type.GetType(info.TypeName + ", " + info.Assembly, true, false));

               aspectCache[identifier.Value] = Result.ToArray();
            }
         }

         return Result;
      }
      private void InitializeAspectTable(ScriptInformation[] scripts) {
         List<Type> Sinks;
         AspectCache AspectCache;

         Sinks = new List<Type>();
         AspectCache = new AspectCache();

         ///Creating Sinks for Test Scripts
         Sinks.Add(typeof(Reporting.ExecutionAspect));
         Sinks.AddRange(generateSinkList(AspectCache, environment.TestAspectGroup));
         Script.Configuration.Aspects[ScriptType.Test] = Sinks.ToArray();

         Sinks.Clear();

         ///Creating Sinks for General Scripts
         Sinks.Add(typeof(Reporting.ExecutionAspect));
         Sinks.AddRange(generateSinkList(AspectCache, environment.GeneralAspectGroup));
         Script.Configuration.Aspects[ScriptType.General] = Sinks.ToArray();
         
         foreach (ScriptInformation script in scripts) {
            Sinks.Clear();
            ///Creating Sinks for each Script
            Sinks.AddRange(generateSinkList(AspectCache, script.AspectGroup));
            Sinks.Add(typeof(Reporting.ReportEmitterAspect));
            Script.Configuration.ScriptAspects[script.Identifier] = Sinks.ToArray();
         }
      }

      #region Members Provided For Domain Controller
      private string[] GenerateSourceFiles(CSharpCodeProvider provider, List<CodeCompileUnit> units, string directory) {
         string Dir = Path.Combine(directory, "source");
         List<string> Files = new List<string>();
         CodeGeneratorOptions Options = new CodeGeneratorOptions();

         try { Directory.Delete(Dir, true); }
         catch { }

         try { Directory.CreateDirectory(Dir); }
         catch { }

         Options.IndentString = "   ";

         for (int c = 0; c < units.Count; c++) {
            try {
               string path = Path.Combine(Dir, string.Format("unit-{0}.cs", c));
               using (System.IO.StreamWriter w = new StreamWriter(path)) {
                  using (IndentedTextWriter writer = new IndentedTextWriter(w, "   ")) {
                     provider.GenerateCodeFromCompileUnit(units[c], writer, Options);
                     Files.Add(path);
                  }
               }
            }
            catch { }
         }

         return Files.ToArray();
      }

      private struct ServiceData {
         public ServiceData(string typename, string alias, string registarId, IServiceProtocol protocol, AspectInformation[] aspects) {
            Typename = typename;
            Alias = alias;
            Protocol = protocol;
            RegistarId = registarId;

            AspectTypenames = new List<string>();

            AspectTypenames.Add(typeof(Reporting.ExecutionAspect).AssemblyQualifiedName);
            if (null != aspects) {
               foreach (AspectInformation Aspect in aspects)
                  AspectTypenames.Add(Aspect.TypeName + ", " + Aspect.Assembly);
            }
            AspectTypenames.Add(typeof(Reporting.ReportEmitterAspect).AssemblyQualifiedName);
         }

         public string Typename;
         public string Alias;
         public string RegistarId;
         public IServiceProtocol Protocol;
         public List<string> AspectTypenames;
      }

      internal CodeCompileUnit[] GenerateServices(XPathNavigator config, ServiceInformation[] services) {
         List<CodeCompileUnit>   CompileUnit = new List<CodeCompileUnit>();
         ServiceProtocolManager  Manager;
         XPathNavigator          ProtocolManager;
         XPathNavigator          ServiceNamespace;
         string                  Namespace;
         Hashtable               ServiceMapping;
         
         ProtocolManager   = config.SelectSingleNode("protocol-manager");
         ServiceNamespace  = config.SelectSingleNode("service-namespace");
         Manager           = new ServiceProtocolManager(ProtocolManager);
         ServiceMapping    = new Hashtable();

         Namespace         = ServiceNamespace.Value.Trim();

         ///Building each services compilation unit
         foreach (ServiceInformation Service in services) {
            ///Verify that the service is fully specified
            if (Service.Flag.HasValue && !string.IsNullOrEmpty(Service.Host) && !string.IsNullOrEmpty(Service.Alias)) {
               ///Fetch the protocol handler
               IServiceProtocol Protocol = Manager.GetServiceProtocol(Service.Protocol);

               ///Construct the service url
               string url = environment.Host + "/";
               string registarId;

               if (0 != (Service.Flag.Value & (long)ServiceFlagEnum.AbsoluteUrl))
                  url = Service.Host;
               else
                  url += Service.Host.StartsWith("/") ? Service.Host.Substring(1) : Service.Host;

               //Add the uri scheme if the user has not already provided it
               if (!url.Contains("://")) {
                  string scheme = Protocol.UriScheme;

                  //Check to see if we should be using the secure scheme
                  if ((Service.Flag.Value & (long)ServiceFlagEnum.SecureScheme) != 0)
                     scheme = Protocol.SecureUriScheme;

                  url = string.Format("{0}://{1}", scheme, url);
               }

               ///Initialize properties use in the code gen process
               Hashtable PropertyBag = new Hashtable();

               PropertyBag.Add(ServiceCodeGenerator.ConfigurationPathProperty,
                  Path.Combine(protocolConfigationRootPath, Service.Protocol));
               PropertyBag.Add(ServiceCodeGenerator.ServiceAliasProperty, Service.Alias);
               PropertyBag.Add(ServiceCodeGenerator.UriProperty, url);
               PropertyBag.Add(ServiceCodeGenerator.NamespaceProperty, Namespace);
               if (null != this.certificate)
                  PropertyBag.Add(ServiceCodeGenerator.X509CertificateProperty, this.certificate);

               Protocol.Initialize(PropertyBag);
               registarId = ServiceProtocol.RegisterPropertyBag(PropertyBag);

               ///Build the new service proxy and map the new type to its unique alias
               string TypeName;
               
               CompileUnit.Add(Protocol.CodeGenerator.GenerateCode(PropertyBag, out TypeName));
               ServiceMapping.Add(
                  Service.Alias, 
                  new ServiceData(TypeName, Service.Alias, registarId, Protocol, environmentState.GetGroupAspects(Service.AspectGroup)));
            }
         }

         ///Building the aliased mapping of services
         CompileUnit.Add(GenerateServiceMapping(config, ServiceMapping));

         return CompileUnit.ToArray();
      }

      internal CodeCompileUnit GenerateServiceMapping(XPathNavigator config, Hashtable serviceMapping) {
         XPathNavigator ServiceNamespace;
         XPathNodeIterator NamespaceIterator;
         CodeCompileUnit Unit;

         ServiceNamespace = config.SelectSingleNode("service-namespace");
         NamespaceIterator = config.Select("namespace-imports/namespace");

         ///Create namespace for aliases and add imports
         CodeNamespace ns = new CodeNamespace(ServiceNamespace.Value.Trim());
         while (NamespaceIterator.MoveNext())
            ns.Imports.Add(new CodeNamespaceImport(NamespaceIterator.Current.GetAttribute("name", "")));

         ///Create service alias class
         CodeTypeDeclaration service = new CodeTypeDeclaration("Service");

         service.IsClass = true;

         foreach (object alias in serviceMapping.Keys) {
            CodeSnippetTypeMember Field;
            ServiceData Data = (ServiceData)serviceMapping[alias];

            Field = new CodeSnippetTypeMember(
               string.Format(
                  "      public static readonly {0} {1} =\r\n" +
                  "         ({0})ServiceProxy.CreateInstance(\r\n" +
                  "            typeof({0}),\r\n" +
                  "            \"{2}\",\r\n" +
                  "            {3},\r\n" +
                  "            {4});\r\n", 
                  Data.Typename, 
                  Data.Alias,
                  Data.RegistarId,
                  null == Data.Protocol.ContextSwitchSinkType ? 
                     "null" : 
                     "\"" + Data.Protocol.ContextSwitchSinkType.AssemblyQualifiedName + "\"",
                  0 == Data.AspectTypenames.Count ? 
                     "null" :
                     "\"" + string.Join("\",\r\n            \"", Data.AspectTypenames.ToArray()) + "\""));

            service.Members.Add(Field);
         }

         Unit = new CodeCompileUnit();
         Unit.Namespaces.Add(ns);
         ns.Types.Add(service);

         return Unit;
      }

      internal Assembly[] LoadExtensions() {
         ArrayList Assemblies;
         string Extensions;

         Assemblies = new ArrayList();
         Extensions = GetExtensionsDir("");

         if (Directory.Exists(Extensions)) {
            foreach (string Extension in Directory.GetFiles(Extensions, "*.dll")) {
               try { Assemblies.Add(Assembly.LoadFile(Extension)); }
               catch (BadImageFormatException) { /* Not an assembly */ }
            }
         }

         return (Assembly[])Assemblies.ToArray(typeof(Assembly));
      }

      internal CodeCompileUnit[] GenerateScripts(XPathNavigator config, ScriptInformation[] scripts, EnvironmentInformation environment) {
         List<CodeCompileUnit> CompileUnits = new List<CodeCompileUnit>();

         foreach (ScriptInformation Script in scripts) {
            ScriptData Data;
            CompileUnits.Add(ScriptGenerator.Generate(Script, environment, out Data));
         }

         return CompileUnits.ToArray();
      }

      internal void BuildEnvironmentCodebase(XPathNavigator config, ScriptInformation[] scripts, ServiceInformation[] services) {
         List<CodeCompileUnit> CompileUnits = new List<CodeCompileUnit>();
         string BuildPath = Path.Combine(DomainController.BaseDirectory, "build\\inst" + instance);
         Assembly[] Extensions;
         XPathNodeIterator ReferencedAssemblies;

         CompileUnits.AddRange(GenerateServices(config, services));
         CompileUnits.AddRange(GenerateScripts(config, scripts, this.environment));

         Extensions = LoadExtensions();
         ReferencedAssemblies = config.Select("referenced-assemblies/assembly");

         ///Setting up compiler options
         CompilerParameters Options;
         Options = new CompilerParameters();
         Options.GenerateExecutable = false;
         Options.OutputAssembly = Path.Combine(BuildPath, "environment.dll");
         Options.IncludeDebugInformation = true;
         Options.ReferencedAssemblies.Add(typeof(ServiceProtocol).Assembly.Location);
         Options.ReferencedAssemblies.Add(typeof(UnitTest).Assembly.Location);
         foreach (Assembly Extension in Extensions)
            Options.ReferencedAssemblies.Add(Extension.Location);
         while (ReferencedAssemblies.MoveNext())
            Options.ReferencedAssemblies.Add(ReferencedAssemblies.Current.GetAttribute("name", ""));

         ///Make sure that the output directory exists
         if (!Directory.Exists(BuildPath))
            Directory.CreateDirectory(BuildPath);
         
         ///For debugging purposes generate .cs files from each compile unit
         CSharpCodeProvider Provider;
         string[] Files;

         Provider = new CSharpCodeProvider();

         Files = GenerateSourceFiles(Provider, CompileUnits, BuildPath);

         ///Create an assembly from the compiler units.
         CompilerResults Results;
         Results = Provider.CompileAssemblyFromFile(Options, Files);
         if (Results.Errors.Count > 0)
            throw new ScriptBuildErrorException(
               "Failed to build scripts", Results.Errors);

         ///Load the compiled scripts into the script manager table
         scriptManager.ScanAssembly(Results.CompiledAssembly);

         WSMonitor.Framework.Scripting.Script.LockRegistration();
      }

      internal EnvironmentState EnvironmentState {
         get { return this.environmentState; }
      }

      public void HandleCommand(CommandDetails command) {
         try {
            scriptManager.DispatchCommand(command);
         }
         catch {
            //TODO: Report health incident for "Script Manager" component
            throw;
         }
      }

      public int Environment {
         get { return environment.Identifier; }
      }

      public long Instance {
         get { return instance; }
      }

      public AppDomain Domain {
         get { return AppDomain.CurrentDomain; }
      }

      public int ScriptRunners {
         get { return scriptManager.Count; }
      }
      #endregion

      #region Members Provided For Script Manager
      internal static  XmlDocument CreateStatusXml(CommandState state, string message, XmlNode details) {
         XmlDocument Doc = new XmlDocument();
         XmlElement Root, Current;
         XmlAttribute Attrib;

         Doc.AppendChild(Root = Doc.CreateElement("result"));

         Attrib = Doc.CreateAttribute("code");
         Attrib.Value = ((int)state).ToString();
         Root.Attributes.Append(Attrib);

         Attrib = Doc.CreateAttribute("category");
         Attrib.Value = state.ToString();
         Root.Attributes.Append(Attrib);

         Root.AppendChild(Current = Doc.CreateElement("message"));
         Current.AppendChild(Doc.CreateTextNode(message));

         Root.AppendChild(Current = Doc.CreateElement("details"));
         if (null != details)
            Current.AppendChild(Doc.ImportNode(details, true));

         return Doc;
      }

      /*
      public void QueueScript(long instance, string name, int id) {
         OnScriptUpdate(this,
            new ScriptUpdateArgs(instance, Instance, name, id, (int)WSMCommon.Control.Command.CommandState.Queued));
      }

      

      public void QueueStatus(CommandStatus status, bool prepared) {
         CommandStatus Status = prepared ? status : PrepareStatus(status);
         QueueStatus(Status);
      }

      public void QueueStatus(CommandState state, long command, string message, XmlNode details) {
         QueueStatus(new CommandStatus(command, state, 
            EnvironmentManager.CreateStatusXml(state, message, details)));
      }

      public void QueueStatus(CommandState state, long command, string message, string detailtext) {
         QueueStatus(state, command, message, XmlUtil.CreateTextNode(detailtext));
      }

      public void QueueStatus(long command, Exception e) {
         QueueStatus(CommandState.Error, command, "Error, an exception was encountered.", e.ToString());
      }

      

      public void QueueStatus(CommandStatus status) {
         OnCommandResult(this, new CommandResultArgs(this.instance, status));
      }
      */
      
      #endregion

      public override string ToString() {
         StringBuilder Builder = new StringBuilder(512);
         Builder.AppendLine  ("Environment Manager");
         Builder.AppendFormat("  Unique Instance : {0}\r\n", instance);
         Builder.AppendFormat("  Identifier      : {0}\r\n", environment.Identifier);
         Builder.AppendFormat("  Name            : {0}\r\n", environment.Name);
         Builder.AppendFormat("  Version         : {0}\r\n", environment.Version);
         Builder.AppendFormat("  Host            : {0}\r\n", environment.Host);
         Builder.AppendFormat("  Description     : {0}\r\n", environment.Description);
         Builder.AppendFormat("  Running Scripts : {0}\r\n", scriptManager.Count);
         return Builder.ToString();
      }

      private EnvironmentInformation environment;
      private EnvironmentState       environmentState;
      private long                   instance;
      private ScriptManager          scriptManager;
      private X509Certificate        certificate;
      private string                 protocolConfigationRootPath;

      public const int MinimumCompleteStatus = 9900;

      public const int StatusActivation   = 9000;
      public const int StatusBuilding     = 9001;
      public const int StatusReady        = 9100;
      public const int StatusDeprecated   = MinimumCompleteStatus + 0;
      public const int StatusDestroyed    = MinimumCompleteStatus + 1;
      public const int StatusFailure      = MinimumCompleteStatus + 2;
      public const int StatusDead         = MinimumCompleteStatus + 3;
      public const int StatusTerminated   = MinimumCompleteStatus + 4;
   }

   internal sealed class EnvironmentState : MarshalByRefObject, ICloneable {
      public EnvironmentState() {
         mapAG  = new Dictionary<int, AspectGroupInformation>();
         mapAGA = new Dictionary<int, AspectInformation[]>();
      }

      public object Clone() {
         EnvironmentState Ret = new EnvironmentState();
         
         foreach (int id in mapAG.Keys)
            Ret.mapAG[id] = mapAG[id];
         foreach (int id in mapAGA.Keys)
            Ret.mapAGA[id] = mapAGA[id];
         
         return Ret;
      }

      public void MapAspectGroup(AspectGroupInformation agi) {
         mapAG[agi.Identifier] = agi;
      }

      public void MapAspectGroupAspects(int id, AspectInformation[] ai) {
         mapAGA[id] = ai;
      }

      public AspectGroupInformation GetGroup(int id) {
         return mapAG[id];
      }

      public AspectInformation[] GetGroupAspects(params int[] ids) {
         Dictionary<int, AspectInformation> Col = new Dictionary<int, AspectInformation>();
         List<AspectInformation> Results = new List<AspectInformation>();

         foreach (int id in ids) {
            if (mapAGA.ContainsKey(id)) {
               foreach (AspectInformation aspect in mapAGA[id]) {
                  Col[aspect.Identifier] = aspect;
               }
            }
         }

         foreach (AspectInformation aspect in Col.Values)
            Results.Add(aspect);

         return Results.ToArray();
      }

      private Dictionary<int, AspectGroupInformation> mapAG;
      private Dictionary<int, AspectInformation[]>    mapAGA;
   }

   [Serializable]
   public class ScriptBuildErrorException : WSMException {
      public ScriptBuildErrorException(string message, CompilerErrorCollection errors, Exception inner)
         : base(message, inner)
      {
         List<string> ErrorList = new List<string>();

         if (null != errors)
            foreach (CompilerError Err in errors)
               ErrorList.Add(Err.ToString());
         
         this.errors = ErrorList.ToArray();
      }

      public ScriptBuildErrorException(string message, CompilerErrorCollection errors) : this(message, errors, null) { }
      public ScriptBuildErrorException(CompilerErrorCollection errors) : this("", errors) { }
      public ScriptBuildErrorException() : this(null) { }
      public ScriptBuildErrorException(SerializationInfo info, StreamingContext context) : base(info, context) {
         this.errors = (string[])info.GetValue("0", typeof(string[]));
      }

      [SecurityPermission(SecurityAction.LinkDemand, Flags = SecurityPermissionFlag.SerializationFormatter)]
      public override void GetObjectData(SerializationInfo info, StreamingContext context)
      {
         base.GetObjectData(info, context);
         info.AddValue("0", this.errors);
      }

      public override string Message {
         get {
            string Msg;
            Msg = base.Message;
            Msg = string.IsNullOrEmpty(Msg) ? "" : Msg;
            if (null != errors) {
               Msg += "\r\nCompiler Errors:\r\n";
               foreach (string Error in this.errors) {
                  Msg += string.Format("{0}\r\n", Error);
               }
            }
            return Msg;
         }
      }

      public string[] Errors {
         get { return errors; }
         set { errors = value; }
      }

      private string[] errors;
   }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\wsmonitor\wsmService\Service.DomainController_work.cs ===
namespace LiveServiceMonitor.Service {
   #region Using Directives
   using System;
   using System.Collections;
   using System.Diagnostics;
   using System.IO;
   using System.Reflection;
   using System.Runtime.Remoting.Lifetime;

   using WSMCommon.Control;
   using WSMCommon.Control.Command;
   using WSMCommon.Control.Result;
   #endregion

   public partial class DomainController {
      private readonly Type _EnvironmentManagerType = typeof(EnvironmentManager);

      /// <summary>
      /// Creates a new application domain for the target environment.
      /// </summary>
      /// <param name="info">Information describing the environment.</param>
      /// <param name="instance">Instance to associate with the new environment.</param>
      /// <returns>An instance of an AppDomain.</returns>
      private AppDomain createEnvironmentDomain(EnvironmentInformation info, long instance) {
         AppDomain      Domain;
         AppDomainSetup Setup;
         string         FriendlyName;
         string         Base;

         FriendlyName = string.Format(
            "Environment Id:{0} Instance:{1}.",
            info.Identifier,
            instance,
            info.Description);

         Base = AppDomain.CurrentDomain.BaseDirectory;
         Setup = new AppDomainSetup();
         Setup.ApplicationName = FriendlyName;
         Setup.ApplicationBase = Base;
         Setup.PrivateBinPath = "extensions";
         Setup.ShadowCopyDirectories = Path.Combine(Base, "extensions" + Path.DirectorySeparatorChar);
         Setup.ShadowCopyFiles = "true";
         Setup.CachePath = Path.Combine(Base, "aux" + Path.DirectorySeparatorChar);

         Domain = AppDomain.CreateDomain(FriendlyName, null, Setup);

         return Domain;
      }

      private Hashtable buildEnvironmentManagerPropertyBag(EnvironmentInformation info, ScriptInformation[] scripts) {
         ServiceInformation[] EnvServices;
         Hashtable            PropertyBag;

         EnvServices = clientCommandLink.EnumerateServices(info.Identifier);
         
         PropertyBag = new Hashtable();
         PropertyBag[EnvironmentManager.EnvInformationProperty] = info;
         PropertyBag[EnvironmentManager.EnvStateProperty] = this.environmentState;
         PropertyBag[EnvironmentManager.ServicesProperty] = EnvServices;
         PropertyBag[EnvironmentManager.ScriptsProperty] = scripts;

         return PropertyBag;
      }

      private void markEnvironmentReady(long instance) {
         commandProcessor.UpdateEnvironmentInstance(
           instance,
           EnvironmentManager.StatusReady);
      }

      private void markEnvironmentBuilding(long instance) {
         commandProcessor.UpdateEnvironmentInstance(
            instance,
            EnvironmentManager.StatusBuilding);
      }

      private void markEnvironmentDeprecated(long instance) {
         commandProcessor.UpdateEnvironmentInstance(
            instance,
            EnvironmentManager.StatusDeprecated);
      }

      private void markEnvironmentFailure(long instance) {
         commandProcessor.UpdateEnvironmentInstance(
            instance,
            EnvironmentManager.StatusFailure);
      }

      private void markEnvironmentDestroyed(long instance) {
         commandProcessor.UpdateEnvironmentInstance(
            instance,
            EnvironmentManager.StatusDestroyed);
      }

      private void markEnvironmentDead(long instance) {
         commandProcessor.UpdateEnvironmentInstance(
            instance,
            EnvironmentManager.StatusDead);
      }

      /// <summary>
      /// Creates a new Environment Manager.  This Environment Manager will
      /// be placed in a different application domain.
      /// </summary>
      /// <param name="environment">Unique identifier associated with the environment.</param>
      /// <param name="instance">New Instance associated with the new environment.</param>
      /// <returns>An instance of a EnvironmentManager.  A value of null indicates failure.</returns>
      private EnvironmentManager createEnvironmentManager(int environment, out long instance, out AppDomain domain) {
         EnvironmentInformation? EnvInformation;
         EnvironmentManager      Manager = null;

         CollectAspectGroupInformation();

         EnvInformation = clientCommandLink.FetchEnvironment(environment);
         instance = 0;
         domain = null;

         if (EnvInformation.HasValue) {
            ScriptInformation[] EnvScripts;

            EnvScripts = clientCommandLink.EnumerateScripts(environment);

            if (EnvScripts.Length > 0) {
               Hashtable PropertyBag;
               bool Failed = false;

               try {
                  object[] Parameters;

                  PropertyBag = buildEnvironmentManagerPropertyBag(EnvInformation.Value, EnvScripts);

                  instance = commandProcessor.CreateEnvironmentInstance(
                     EnvInformation.Value.Identifier,
                     EnvInformation.Value.Name,
                     EnvironmentManager.StatusActivation);

                  Parameters = new object[] { instance, PropertyBag };

                  domain = createEnvironmentDomain(EnvInformation.Value, instance);

                  markEnvironmentBuilding(instance);

                  Manager = (EnvironmentManager)domain.CreateInstanceAndUnwrap(
                     _EnvironmentManagerType.Assembly.FullName, //Environment Manager Fully Specified Assembly Name
                     _EnvironmentManagerType.FullName,          //Environment Manager Type Name
                     false,                                     //Ignore the case
                     BindingFlags.Default,                      //Use Default Binding
                     null,                                      //Use Default Binder
                     Parameters,                                //Invoke EnvironmentManager(int, long)
                     null,                                      //Use Default Culture
                     null,                                      //Use Default Acctivation Attributes
                     null);                                     //Use Default Security Attributes

                  ConnectEventHandlers(Manager);

                  markEnvironmentReady(instance);
               }
               catch (TargetInvocationException e) {
                  Failed = true;
                  throw e.InnerException;
               }
               catch (Exception) {
                  Failed = true;
                  throw;
               }
               finally {
                  if (Failed && 0 != instance)
                     markEnvironmentFailure(instance);
               }
            }
            else {
               EventLog.WriteEntry(
                  NTService.EventSource,
                  string.Format("Unable to complete command {0}, the environment {1} contains no scripts.",
                     instance, environment),
                  EventLogEntryType.Warning);
            }
         }
         else {
            EventLog.WriteEntry(
               NTService.EventSource,
               string.Format("Unable to get environment info for environment {0}, command {1}",
                  environment, instance),
               EventLogEntryType.Warning);
         }

         return Manager;
      }

      private EnvironmentTracker createEnvironmentTracker(int environment) {
         EnvironmentTracker Tracker;

         Tracker = new EnvironmentTracker();
         Tracker.Identifier = environment;
         Tracker.Manager = createEnvironmentManager(
            environment, 
            out Tracker.Instance,
            out Tracker.Domain);
         Tracker.Lease = (ILease)Tracker.Manager.GetLifetimeService();
         Tracker.Sponsor = new ClientSponsor();
         Tracker.Lease.Register(Tracker.Sponsor);

         return Tracker;
      }

      private void destroyEnvironmentTracker(EnvironmentTracker tracker) {
         mapInstances.Remove(tracker.Instance);
         mapTrackers.Remove(tracker.Instance);

         tracker.Lease.Unregister(tracker.Sponsor);
         tracker.Sponsor = null;
         tracker.Lease = null;
         tracker.Manager = null;
      }

      private void registerEnvironmentTracker(EnvironmentTracker tracker) {
         mapInstances[tracker.Instance] = tracker.Manager;
         mapTrackers[tracker.Instance]  = tracker;
         mapActiveTrackers[tracker.Identifier] = tracker;
      }

      private bool isEnvironmentDeprecated(EnvironmentTracker tracker) {
         if (!mapActiveTrackers.ContainsKey(tracker.Identifier))
            return true;
         else if (tracker != mapActiveTrackers[tracker.Identifier])
            return true;

         return false;
      }
   }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\wsmonitor\wsmService\Service.Reporting.Aspects.cs ===
using System;

using System.Reflection;

using System.Runtime.Remoting;
using System.Runtime.Remoting.Messaging;
using System.Runtime.Remoting.Activation;
using System.Runtime.Remoting.Proxies;
using System.Runtime.Remoting.Contexts;

using WSMCommon.Control;

using WSMonitor.Framework.Scripting;
using WSMonitor.Framework.Reporting;

namespace LiveServiceMonitor.Service.Reporting {
   /// <summary>
   /// An aspect designated for Scripts or Services.
   /// </summary>
   public class SSAspect : Aspect {
      public SSAspect(IMessageSink next) : base(next) { }

      public bool IsScript(IMethodMessage message) {
         return null != GetMetadata(message);
      }

      public ScriptMetadataAttribute GetMetadata(IMethodMessage message) {
         if (null != message)
            return Script.GetMetadata(message.MethodBase.DeclaringType);
         return null;
      }
   }

   /// <summary>
   /// Reports execution information about the current service or script call.
   /// </summary>
   /// <remarks>This aspect assumes it is either running for a service or a script.</remarks>
   public sealed class ExecutionAspect : SSAspect {
      public ExecutionAspect(IMessageSink next) : base(next) { }

      public override void Enter(Report report, IMethodMessage msg) {
         if (null != report) {
            ScriptMetadataAttribute Metadata;
            ExecutionReportProxy Proxy;

            Metadata = GetMetadata((IMethodMessage)msg);
            Proxy = new ExecutionReportProxy(report);

            if (null != Metadata)
               Proxy.Name = string.Format("Script.{0}.{1}", Metadata.Alias, msg.MethodName);
            else
               Proxy.Name = string.Format("{0}.{1}", msg.MethodBase.DeclaringType.Name, msg.MethodName);

            Proxy.ExecutionStart = DateTime.UtcNow;
         }
      }

      public override void Leave(Report report, IMethodReturnMessage result) {
         if (null != report) {
            DateTime Now;
            ScriptMetadataAttribute Metadata;
            ResultCode Code;
            TimeSpan Span;
            ExecutionReportProxy Proxy;

            Now = DateTime.UtcNow;
            Proxy = new ExecutionReportProxy(report);
            Span = Now - Proxy.ExecutionStart;
            Metadata = GetMetadata(result);

            Code = ResultCode.Finished;
            if (null != result.Exception) {
               if (typeof(System.Threading.ThreadAbortException) == result.Exception.GetType())
                  Code = ResultCode.Cancel;
               else {
                  Exception e = result.Exception;
                  
                  while (e is TargetInvocationException)
                     e = e.InnerException;

                  report.Properties["Exception"] = e.ToString();

                  Code = ResultCode.Exception;
               }
            }
            else if (null != Metadata) {
               if (ScriptType.Test == Metadata.Type)
                  Code = (bool)result.ReturnValue ? ResultCode.Success : ResultCode.Failed;
            }

            Proxy.ExecutionDuration = Span.Ticks;
            Proxy.ExecutionResult = Code;
         }
      }

      public static AspectInformation Describe() {
         Type Aspect = typeof(ExecutionAspect);

         return new AspectInformation(
            "Executing Timing",
            Aspect.Assembly.FullName,
            Aspect.FullName);
      }
   }

   /// <summary>
   /// Creates a new report for the service or script it is running under.
   /// </summary>
   /// <remarks>This aspect assumes it is either running for a service or a script.</remarks>
   public sealed class ReportEmitterAspect : SSAspect {
      public ReportEmitterAspect(IMessageSink next) : base(next) {
         createdReport = null;
      }

      private bool isSpecificScript(ScriptMetadataAttribute scriptMetadata, ScriptType scriptType) {
         return null != scriptMetadata && scriptMetadata.Type == scriptType;
      }

      private bool isTestScript(IMethodMessage methodMessage) {
         return isSpecificScript(GetMetadata(methodMessage), ScriptType.Test);
      }

      private bool isGeneralScript(IMethodMessage methodMessage) {
         return isSpecificScript(GetMetadata(methodMessage), ScriptType.General);
      }

      private bool isScriptMember(IMethodMessage methodMessage) {
         Type ScriptType = typeof(Script);
         return ScriptType.IsAssignableFrom(methodMessage.MethodBase.DeclaringType);
      }
      
      public override void Enter(Report report, IMethodMessage msg) {
         if (isTestScript(msg))
            createdReport = Report.Create(ReportCategory.TestScript);
         else if (isGeneralScript(msg))
            createdReport = Report.Create(ReportCategory.GeneralScript);
         else if (isScriptMember(msg))
            createdReport = Report.Create(ReportCategory.ScriptMember);
         else
            createdReport = Report.Create(ReportCategory.ServiceApi);
      }

      public override void Leave(Report report, IMethodReturnMessage result) {
         if (null != createdReport) {
            createdReport.Close();
            createdReport = null;
         }
      }

      public static AspectInformation Describe() {
         Type Aspect = typeof(ReportEmitterAspect);

         return new AspectInformation(
            "Report Emitter",
            Aspect.Assembly.FullName,
            Aspect.FullName);
      }

      private Report createdReport;
   }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\wsmonitor\wsmService\Service.EnvironmentManager_1.cs ===
///Partial EnvironmentManager Responsible For Callback and delegate exposure

namespace LiveServiceMonitor.Service {
   #region Using Directives
   using System;
   using WSMCommon.Control;
   using WSMCommon.Control.Command;
   using WSMonitor.Framework.Reporting;
   using System.Xml;
   #endregion

   internal partial class EnvironmentManager {
      public const int EnvInformationProperty = 1;
      public const int EnvStateProperty = 2;
      public const int ServicesProperty = 3;
      public const int ScriptsProperty = 4;
      public const int ControllerLeaseProperty = 5;

      [Serializable]
      public class CommandResultArgs : EventArgs {
         public CommandResultArgs(long manager, CommandStatus status) {
            this.Manager = manager;
            this.Status = status;
         }
         public long Manager;
         public CommandStatus Status;
      }

      [Serializable]
      public class InstanceChangeArgs : EventArgs {
         public InstanceChangeArgs(long manager, long instance, bool deleted) {
            this.Manager = manager;
            this.Instance = instance;
            this.Deleted = deleted;
         }
         public long Manager;
         public long Instance;
         public bool Deleted;
      }

      [Serializable]
      public class ScriptUpdateArgs : EventArgs {
         public ScriptUpdateArgs(long instance, int? status, string report) {
            this.Instance = instance;
            this.Status = status;
            this.Report = report;
         }
         public long    Instance;
         public int?    Status;
         public string  Report;
      }

      public delegate long ScriptInstanceGeneratorDelegate(long environment, int script, string name);
      public delegate void ScriptGroupStartNotifierDelegate(int group);

      public event EventHandler<CommandResultArgs>    OnCommandResult;
      public event EventHandler<InstanceChangeArgs>   OnInstanceChange;
      public event EventHandler<ScriptUpdateArgs>     OnScriptUpdate;

      public ScriptInstanceGeneratorDelegate          ScriptInstanceGenerator;
      public ScriptGroupStartNotifierDelegate         ScriptGroupStartNotifier;

      #region Event and Delegate Triggers
      public long GenerateScriptInstance(int script, string name) {
         try {
            return ScriptInstanceGenerator(this.Instance, script, name);
         }
         catch (System.Reflection.TargetInvocationException e) {
            throw e.InnerException;
         }
      }

      public void NotifyScriptGroupStart(int group) {
         try {
            ScriptGroupStartNotifier(group);
         }
         catch (System.Reflection.TargetInvocationException e) {
            throw e.InnerException;
         }
      }

      public void PostInstanceDelete(long instance) { PostInstanceChange(instance, true); }
      public void PostInstanceAdd(long instance) { PostInstanceChange(instance, false); }
      private void PostInstanceChange(long instance, bool deleted) {
         OnInstanceChange(this, new InstanceChangeArgs(this.instance, instance, deleted));
      }

      public void PostScriptUpdate(long instance, int? status, Report report) {
         XmlDocument doc = null;
         bool Debug;

         if (null != report)
            doc = Report.ReportFactory.CreateDocument(report);

         Debug = null == OnScriptUpdate;

         if (Debug == true)
            Debug = true;

         OnScriptUpdate(this, new ScriptUpdateArgs(
            instance, status, 
            doc == null ? null : doc.OuterXml));
      }

      public void PostCommandResult(CommandStatus result, bool prepared) {
         CommandStatus Status = prepared ? result : PrepareResult(result);
         PostCommandResult(Status);
      }

      private void PostCommandResult(CommandStatus result) {
         OnCommandResult(this, new CommandResultArgs(this.instance, result));
      }
      #endregion

      #region Event and Delegate Trigger Helpers
      internal static CommandStatus PrepareResult(CommandStatus status) {
         CommandStatus Status = new CommandStatus(status.Command, status.Status, "");
         XmlDocument Xml = new XmlDocument();
         XmlElement R, D;

         Xml.AppendChild(R = Xml.CreateElement("result"));
         R.Attributes.Append(Xml.CreateAttribute("value")).Value = ((int)status.Status).ToString();
         R.Attributes.Append(Xml.CreateAttribute("status")).Value = status.Status.ToString();
         R.AppendChild(D = Xml.CreateElement("details"));
         D.InnerXml = status.XmlResult;

         Status.XmlResult = R.OuterXml;

         return Status;
      }
      #endregion
   }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\wsmonitor\wsmService\WSMInstaller.cs ===
using System;
using System.Collections.Generic;
using System.ComponentModel;
using System.Configuration.Install;

namespace wsmService {
   [RunInstaller(true)]
   public partial class WSMInstaller : Installer {
      public WSMInstaller() {
         InitializeComponent();
      }
   }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\wsmonitor\wsmService\Utility.Performance.Throttle.cs ===
namespace LiveServiceMonitor.Utility.Performance {
   using System;
   using System.Threading;

   /// <summary>
   /// The Throttle class is used to control the amount of CPU time spent in busy loops.
   /// </summary>
   public sealed class Throttle {
      /// <summary>
      /// Initializes a new instance of this type.
      /// </summary>
      /// <param name="lower">Lower bound for throttling, the system will sleep for no less than this time.</param>
      /// <param name="upper">Upper bound for throttling, the system will sleep for no longer than this time.</param>
      /// <param name="rate">Indicates the rate of (un)throttling that will take place.</param>
      public Throttle(int lower, int upper, float rate) {
         this.lower = Math.Min(lower, upper);
         this.upper = Math.Max(lower, upper);
         this.rate = Math.Max(1.0f, rate);

         this.interval = this.lower;
      }

      /// <summary>Lower bound for throttling, the system will sleep for no less than this time.</summary>
      public int Lower {
         get { return this.lower; }
         set {
            this.lower = Math.Min(value, this.upper);
            this.upper = Math.Max(value, this.upper);

            this.interval = Math.Max(this.lower, this.interval);
         }
      }

      /// <summary>Upper bound for throttling, the system will sleep for no longer than this time.</summary>
      public int Upper {
         get { return this.upper; }
         set {
            this.upper = Math.Max(this.lower, value);
            this.lower = Math.Min(this.lower, value);
            
            this.interval = Math.Min(this.interval, this.upper);
         }
      }

      /// <summary>Current throttling interval.</summary>
      public int WaitInterval {
         get { return this.interval; }
         set {
            this.interval = Math.Min(value, this.upper);
            this.interval = Math.Max(this.interval, this.lower);
         }
      }

      /// <summary>Indicates the rate of (un)throttling that will take place.</summary>
      public float Rate {
         get { return this.rate; }
         set { this.rate = Math.Max(1.0f, value); }
      }

      /// <summary>Increases the wait interval by the specified rate.</summary>
      public void Increase() {
         int interval = (int)((float)Math.Max(this.interval, 1) * this.rate);
         interval = Math.Min(interval, this.upper);
      }

      /// <summary>Decrease the wait interval by the specified rate.</summary>
      public void Decrease() {
         int interval = (int)((float)this.interval / this.rate);
         interval = Math.Max(interval, this.lower);
      }

      /// <summary>Forces the thread to sleep for the current wait interval.</summary>
      public void Wait() {
         Thread.Sleep(WaitInterval);
      }

      /// <summary>Forces the thread to sleep for the lower bound interval.</summary>
      public void WaitMin() {
         Thread.Sleep(Lower);
      }

      /// <summary>Forces the thread to sleep for the upper bound interval.</summary>
      public void WaitMax() {
         Thread.Sleep(Upper);
      }

      private int interval;
      private int lower;
      private int upper;
      private float rate;
   }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\wsmonitor\wsmService\WSMInstaller.Designer.cs ===
using System.ServiceProcess;

namespace wsmService {
   partial class WSMInstaller {
      /// <summary>
      /// Required designer variable.
      /// </summary>
      private System.ComponentModel.IContainer components = null;

      /// <summary> 
      /// Clean up any resources being used.
      /// </summary>
      /// <param name="disposing">true if managed resources should be disposed; otherwise, false.</param>
      protected override void Dispose(bool disposing) {
         if (disposing && (components != null)) {
            components.Dispose();
         }
         base.Dispose(disposing);
      }

      #region Component Designer generated code

      /// <summary>
      /// Required method for Designer support - do not modify
      /// the contents of this method with the code editor.
      /// </summary>
      private void InitializeComponent() {
         this.serviceProcessInstaller = new ServiceProcessInstaller();
         this.serviceInstaller = new ServiceInstaller();

         ///Process Installer
         this.serviceProcessInstaller.Password = null;
         this.serviceProcessInstaller.Username = null;
         this.serviceProcessInstaller.Account = ServiceAccount.LocalSystem;

         ///Service Installer
         this.serviceInstaller.ServiceName = "WSMonitor";

         ///Project Installer
         this.Installers.AddRange(new System.Configuration.Install.Installer[] {
            this.serviceProcessInstaller,
            this.serviceInstaller
         });

      }

      #endregion

      private ServiceProcessInstaller serviceProcessInstaller;
      private ServiceInstaller serviceInstaller;

   }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\wsmonitor\wsmService\WSMonitor.Health.cs ===
using System;
using System.Collections;
using System.Collections.Generic;

namespace LiveServiceMonitor.Health {
   public enum HealthRating : int {
      Excellent = 1000,
      Good      = 900,
      OK        = 750,
      Bad       = 500,
      Poor      = 300,
      Owned     = 0
   }

   public struct Incident {
      public Incident(long id, string description, float initialCost, float subsequentCosts) {
         Id                = id;
         InitialCost       = initialCost;
         SubsequentCosts   = subsequentCosts;
         OccurenceNotes    = new List<string>();
         Occurences        = 0;
         FirstOccurence    = DateTime.MinValue;
         Description       = string.IsNullOrEmpty(description) ?
            string.Format("Incident: {0}", id) : description;
      }

      public Incident(long id, string description, float initialCost) : 
         this(id, description, initialCost, initialCost) { }

      public DateTime     FirstOccurence;
      public int          Occurences;
      public string       Description;
      public long         Id;
      public List<string> OccurenceNotes;
      public float        InitialCost;
      public float        SubsequentCosts;
   }

   public interface IHealthMonitor {
      HealthRating          Health             { get; }
      IEnumerable<Incident> Incidents          { get; }
      IEnumerable<Incident> PotentialIncidents { get; }
      string                ComponentName      { get; }

      IEnumerable<IHealthMonitor> GetChildComponents();
      void                        Reset();
   }

   public class ComponentHealth : MarshalByRefObject, IHealthMonitor {
      public const long IncidentUnexpectedException   = 0x10000000;
      public const long IncidentUnknownIncidentId     = 0x10000001;

      public ComponentHealth(string componentName) {
         this.componentName = string.IsNullOrEmpty(componentName) ? "(Unnamed)" : componentName;
         potentialIncidents = new Dictionary<long, Incident>();
         childMonitors = new List<IHealthMonitor>();
         
         AddIncident(
            IncidentUnexpectedException,
            "Component Encountered an unexpected exception.",
            250, 250);

         AddIncident(
            IncidentUnknownIncidentId,
            "Logging done on an unknown incident id.",
            50, 0);
      }

      #region IHealthMonitor Interface Implementation Region
      HealthRating IHealthMonitor.Health { 
         get { return Health; } 
      }
      
      IEnumerable<Incident> IHealthMonitor.Incidents {
         get { return Incidents; }
      }

      IEnumerable<Incident> IHealthMonitor.PotentialIncidents {
         get { return PotentialIncidents; }
      }

      string IHealthMonitor.ComponentName {
         get { return ComponentName; }
      }

      IEnumerable<IHealthMonitor> IHealthMonitor.GetChildComponents() {
         return GetChildComponents();
      }

      void IHealthMonitor.Reset() {
         Reset();
      }
      #endregion

      #region Virtual Implementation of IHealthMonitor Interface
      protected virtual HealthRating Health {
         get {
            float Score = CalculateHealthScore();
            if (Score < (float)HealthRating.Poor)
               return HealthRating.Owned;
            if (Score < (float)HealthRating.Bad)
               return HealthRating.Poor;
            if (Score < (float)HealthRating.OK)
               return HealthRating.Bad;
            if (Score < (float)HealthRating.Good)
               return HealthRating.OK;
            if (Score < (float)HealthRating.Excellent)
               return HealthRating.Good;
            return HealthRating.Excellent;
         }
      }

      protected virtual IEnumerable<Incident> Incidents {
         get {
            return potentialIncidents.Values;
         }
      }

      protected virtual IEnumerable<Incident> PotentialIncidents {
         get {
            return potentialIncidents.Values;
         }
      }

      protected virtual string ComponentName {
         get { return componentName; }
      }

      protected IEnumerable<IHealthMonitor> GetChildComponents() {
         return childMonitors.ToArray();
      }

      protected void Reset() {
         foreach (long id in potentialIncidents.Keys) {
            Incident I = potentialIncidents[id];

            I.Occurences = 0;
            I.OccurenceNotes.Clear();
            I.FirstOccurence = DateTime.MinValue;

            potentialIncidents[id] = I;
         }
      }
      #endregion

      protected virtual void LogIncident(long id, string message, params object[] args) {
         if (!potentialIncidents.ContainsKey(id)) {
            System.Diagnostics.Debug.Assert(IncidentUnknownIncidentId != id);
            string Message;

            Message = string.Format("missing id: {0}\r\nOriginal message: {1}", id,
                  string.IsNullOrEmpty(message) ? "(null)" : string.Format(message, args));
            LogIncident(IncidentUnknownIncidentId, Message);
         }
         else {
            Incident Incident = potentialIncidents[id];

            Incident.Occurences++;
            if (DateTime.MinValue == Incident.FirstOccurence)
               Incident.FirstOccurence = DateTime.Now;
            if (!string.IsNullOrEmpty(message))
               Incident.OccurenceNotes.Add(string.Format(message, args));

            potentialIncidents[id] = Incident;
         }
      }

      protected virtual void LogIncident(long id) {
         LogIncident(id, null);
      }

      protected virtual float CalculateHealthScore() {
         float Score = 1000;
         foreach (Incident i in Incidents) {
            if (i.Occurences > 0) {
               Score -= i.InitialCost;
               Score -= i.SubsequentCosts * (i.Occurences - 1);
            }
            if (Score < 0)
               break;
         }
         return Math.Max(0, Score);
      }

      protected void AddIncident(Incident i) {
         potentialIncidents.Add(i.Id, i);
      }

      protected void AddIncident(long id, string description, float initialConst, float subsequentCost) {
         AddIncident(new Incident(id, description, initialConst, subsequentCost));
      }

      protected List<IHealthMonitor> ChildMonitors {
         get { return ChildMonitors; }
      }

      private string                     componentName;
      private Dictionary<long, Incident> potentialIncidents;
      private List<IHealthMonitor>       childMonitors;
   }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\wsmonitor\wsmService\WSMonitor.Utility.ScriptParser.cs ===
using System;
using System.CodeDom;
using System.CodeDom.Compiler;
using System.Collections.Generic;
using System.IO;
using System.Text;
using System.Text.RegularExpressions;

using Microsoft.CSharp;

using System.Runtime.Serialization;

using WSMCommon.Control;
using WSMonitor.Framework;
using WSMonitor.Framework.Scripting;
using WSMonitor.Framework.Exceptions;

namespace LiveServiceMonitor.Utility {
   #region Using Directives
   using PriorityMatchLL = System.Collections.Generic.LinkedList<PriorityMatch>;
   using PriorityMatchNode = System.Collections.Generic.LinkedListNode<PriorityMatch>;
   #endregion

   internal struct PriorityMatch : IComparable, IComparer<object> {
      public Match Match;
      public int Priority;

      public int CompareTo(object other) {
         if (other is PriorityMatch) {
            PriorityMatch pm = (PriorityMatch)other;

            if (Match.Index < pm.Match.Index)
               return -1;
            else if (Match.Index > pm.Match.Index)
               return 1;
            else if (Priority < pm.Priority)
               return -1;
            else if (Priority > pm.Priority)
               return 1;

            return 0;
         }
         else if (other is int) {
            return Match.Value.CompareTo(other);
         }

         throw new ArgumentException("object is invalid");
      }
      int IComparer<object>.Compare(object x, object y) {
         return ((IComparable)x).CompareTo(y);
      }

      public static PriorityMatch Next(PriorityMatch m) {
         PriorityMatch Ret = new PriorityMatch();
         Ret.Match = m.Match.NextMatch();
         Ret.Priority = m.Priority;
         return Ret;
      }


   }

   internal class ScriptParser {
      private ScriptParser() {
         //Defines the search for our inherit text
         this.anchorMatch = new Regex(@":\s*Script\W");

         //Defines contexts under which a match for inherit text is invalid. (in tie breaking order)
         this.invalidMatches = new Regex[] {
            new Regex(@"/\*([^*]|\*[^/])*($|\*$|\*/)"), //Multiple line Comment (terminated | unterminated)
            new Regex(@"//.*"),                         //Single line Comment
            new Regex("\"([^\"\\r\\n]|\\\\)*[\\r\\n]"), //Unterminated string literal
            new Regex("\"[^\"]*\""),                    //Terminated string literal (assumed valid)
         };

         //Defines tokens
         this.tokenMatchStrings = new string[] {
            expressionMLComment + @"\s*", //Multi line comment token
            expressionSLComment,          //Single line comment token
            expressionString + @"\s*",    //Terminated string token
            @"\w+\s*;{0,1}",          //~identifier token
            @"\r\n",                  //crlf
            @"\n",                    //lf
            @"." + @"\s*"                   //pick up loose ends + some spaces
         };
      }

      private static Uri getEnvironmentHostEnvironment(EnvironmentInformation environment) {
         UriBuilder Builder;
         Builder = new UriBuilder(environment.Host);
         return Builder.Uri;
      }

      public static ScriptData Parse(ScriptInformation info, EnvironmentInformation environment) {
         ScriptParser Parser = new ScriptParser();
         ScriptData Result;

         Result = Parser._Parse(info);
         Result.HostAddress = getEnvironmentHostEnvironment(environment);

         return Result;
      }

      private PriorityMatchLL BuildPriorityMatchChain(Match anchor) {
         PriorityMatchLL Matches = new PriorityMatchLL();
         int FarOffset = anchor.Index + anchor.Length;
         int SearchLen = (FarOffset - anchorDynStart) + 1;

         for (int c = this.invalidMatches.Length - 1; c >= 0; c--) {
            PriorityMatch PMatch = new PriorityMatch();

            PMatch.Match = this.invalidMatches[c].Match(this.script, anchorDynStart, SearchLen);
            PMatch.Priority = c;

            if (PMatch.Match.Success) {
               PriorityMatchNode Node = Matches.First;

               while (null != Node && PMatch.CompareTo(Node.Value) > 0)
                  Node = Node.Next;

               if (null == Node)
                  Matches.AddLast(PMatch);
               else
                  Matches.AddBefore(Node, PMatch);
            }
         }

         return Matches;
      }

      private void PlaceNode(PriorityMatchLL ll, PriorityMatchNode node) {
         PriorityMatchNode Current = ll.First;
         
         while (Current != null && Current.Value.CompareTo(node.Value) < 0)
            Current = Current.Next;

         if (null == Current)
            ll.AddLast(node);
         else
            ll.AddBefore(Current, node);
      }

      private bool ValidateAnchor(Match anchor) {
         PriorityMatchLL Matches;

         Matches = BuildPriorityMatchChain(anchor);

         while (Matches.Count > 0) {
            PriorityMatchNode Front, Current, Anchor;

            Front = Matches.First;
            Current = Front.Next;
            Anchor = Front;

            anchorDynStart = Front.Value.Match.Index + Front.Value.Match.Length;
            
            //Check to see if our anchor is invalid
            if (anchor.Index < anchorDynStart)
               return false;

            //Advancing all the overlapping matches
            while (null != Current) {
               if (Current.Value.Match.Index < anchorDynStart) {
                  //Unlink current node
                  Matches.Remove(Current);

                  //Locate next match
                  Current = new PriorityMatchNode(PriorityMatch.Next(Current.Value));
                  if (Current.Value.Match.Success) {
                     PriorityMatchNode Next = Anchor.Next;

                     //Match still exists figure out where to add it
                     PlaceNode(Matches, Current);
                  }

                  Current = Anchor.Next;
               }
               else {
                  Anchor = Current;
                  Current = Current.Next;
               }
            }

            //Advance the front node
            Matches.Remove(Front);
            Front = new PriorityMatchNode(PriorityMatch.Next(Front.Value));
            if (Front.Value.Match.Success)
               PlaceNode(Matches, Front);
         }

         return true;
      }

      private void LocateInheritenceAnchor() {
         Match Match = anchorMatch.Match(script, 0);

         anchorStart = null;
         while (Match.Success) {
            if (ValidateAnchor(Match)) {
               anchorStart = Match;
               break;
            }

            Match = Match.NextMatch();
         }
      }

      private void CollectTokensBeforeAnchor() {
         Regex TokenMatch = new Regex("(" + string.Join(")|(", tokenMatchStrings) + ")");
         List<Match> Matches = new List<Match>();
         Match Current;

         Current = TokenMatch.Match(script, 0, anchorStart.Index);

         while (Current.Success) {
            Matches.Add(Current);
            Current = Current.NextMatch();
         }

         preAnchorTokens = Matches.ToArray();
      }

      private int GetBalance(Match match, int initial, out int initialIndex, out int finalIndex, out int balancedIndex) {
         int Balance = initial;

         initialIndex = -1;
         finalIndex = -1;
         balancedIndex = -1;

         while (match.Success) {
            if (match.Value == "{") {
               finalIndex = match.Index;
               if (initial == Balance)
                  initialIndex = match.Index;

               Balance++;
            }
            else if (match.Value == "}") {
               finalIndex = match.Index;
               Balance--;

               if (Balance < 0) {
                  throw new ScriptParserException(
                     string.Format("Unbalanced bracket '}}' at {0}", match.Index));
               }
               else if (initial == Balance)
                  balancedIndex = match.Index;
            }
            match = match.NextMatch();
         }

         return Balance;
      }

      private void LocateScriptBody() {
         string[] Expressions;
         Regex    Expression;
         Match    Match;
         int      Balance  = 0, b0, b1, bf;

         Expressions = new string[] 
         {
            expressionMLComment,
            expressionSLComment,
            expressionString,
            "{", "}"
         };

         Expression = new Regex("(" + string.Join(")|(", Expressions) + ")");
         
         //Get bracket balance before anchor
         Match = Expression.Match(script, 0, anchorStart.Index);
         Balance = GetBalance(Match, 0, out b0, out bf, out b1);

         //Get accumulated balance after anchor
         Match = Expression.Match(script, anchorStart.Index);
         Balance = GetBalance(Match, Balance, out b0, out bf, out b1);

         if (b0 == -1)
            throw new ScriptParserException("Unable to locate the beginning of the script body");

         if (b1 == -1)
            throw new ScriptParserException("Unexpected end of file while parsing script body");

         if (Balance > 0)
            throw new ScriptParserException(
               string.Format("Brackets unbalanced in script, there are {0} unmatched {{'s", Balance));

         this.bodyStart = b0 + 1;
         this.bodyLength = (b1 - this.bodyStart);

         this.compilationData.ClassBody = this.script.Substring(this.bodyStart, this.bodyLength);
      }

      private bool IsStringLiteral(string value, out string contents) {
         string trimmed = value.Trim();
         
         contents = null;
         if (trimmed.StartsWith("\"") && trimmed.EndsWith("\"")) {
            contents = trimmed.Substring(1, trimmed.Length - 2);
            return true;
         }

         return false;
      }

      //Attribute: < [ >< Identity >< ( >< string-literal >< , >< string-literal >< ) >< ] >
      //            -1       0        1          2           3          4           5    6
      private void LocateScriptMetadataAttribute() {
         Type SM = typeof(ScriptMetadataAttribute);
         List<string> NameOptions = new List<string>();

         NameOptions.Add("ScriptMetadata");
         NameOptions.Add("ScriptMetadataAttribute");
         NameOptions.Add(SM.Namespace + ".ScriptMetadata");
         NameOptions.Add(SM.Namespace + ".ScriptMetadataAttribute");
         for (int c = 0; c < NameOptions.Count; c++)
            NameOptions[c] = NameOptions[c].ToLower();

         for (int c = preAnchorTokens.Length - 5; c > 0; c--) {
            if (NameOptions.Contains(preAnchorTokens[c].Value.Trim().ToLower())) {
               if (
                  preAnchorTokens[c - 1].Value.Trim() == "[" &&
                  preAnchorTokens[c + 1].Value.Trim() == "(" &&
                  preAnchorTokens[c + 3].Value.Trim() == ")" &&
                  preAnchorTokens[c + 4].Value.Trim() == "]"
                  ) 
               {
                  Match Param1 = preAnchorTokens[c+2];
                  //Attribute found
                  this.attributeStartToken = c - 1;
                  this.attributeParam1Token = c + 2;
                  this.attributeEndToken = c + 4;

                  string ScrType;
                  if (!IsStringLiteral(Param1.Value, out ScrType))
                     throw new ScriptParserException(
                        string.Format("The first parameter of the ScriptMetadataAttribute is not a string literal: {0}", Param1.Value));
                  ScrType = ScrType.Trim().ToLower();
                  if (ScrType == ScriptType.General.ToString().ToLower())
                     compilationData.ScriptType = ScriptType.General;
                  else if (ScrType == ScriptType.Test.ToString().ToLower())
                     compilationData.ScriptType = ScriptType.Test;
                  else
                     throw new ScriptParserException(
                        string.Format("The second parameter of the ScriptMetadataAttribute ({0}) is not a valid ScriptType, " +
                           "select either \"{1}\", or \"{2}\".",
                           ScrType, ScriptType.General, ScriptType.Test));

                  return;
               }
            }
         }

         throw new ScriptParserException(
            "No ScriptMetadata attribute present.  " +
            "Make sure to prefix your script class with " +
            "[ScriptMetadata(\"Alias\", \"ScriptType\")].  Here is an example: " +
            "[ScriptMetadata(\"LeaderboardTest\", \"Test\")]");
      }

      private void ScanNamespaceImports() {
         List<string> Imports = new List<string>();
         bool scanning = false;
         int t = 0;
         Regex DelSemiColan = new Regex(";\\s*");

         while (t < this.attributeStartToken) {
            Match Token = preAnchorTokens[t];

            if (Token.Value.Trim() == "using") {
               string Snippit = "";

               t++;
               scanning = true;
               while (t <= this.attributeStartToken) {
                  Match NToken = preAnchorTokens[t];
                  if (t == preAnchorTokens.Length || NToken.Value.Trim() == "using")
                     throw new ScriptParserException("Missing semi-colan on a using declaration.");
                  Snippit += NToken.Value;
                  if (NToken.Value.Trim().EndsWith(";")) {
                     Imports.Add(DelSemiColan.Replace(Snippit, ""));
                     scanning = false;
                     break;
                  }

                  t++;
               }
            }

            t++;
         }

         if (scanning)
            throw new ScriptParserException("using statement missing ';' termination.");

         this.compilationData.ImortedNamespaces = Imports.ToArray();
      }

      private void ParseMemberAttributes() {
         this.compilationData.ClassAttributes =
            MemberAttributes.Public | MemberAttributes.Final;

         for (int c = this.attributeEndToken + 1; c < preAnchorTokens.Length; c++) {
            Match Token = preAnchorTokens[c];
            if (Token.Value.Trim() == "class")
               return;
         }

         throw new ScriptParserException("Script declaration missing class keyword.");
      }

      private ScriptData _Parse(ScriptInformation info) {
         this.script          = info.SourceCode;
         this.anchorStart     = null;
         this.anchorDynStart  = 0;
         this.bodyStart       = 0;
         this.bodyLength      = 0;
         this.compilationData = new ScriptData();

         //Generating a unique class name
         this.compilationData.ClassIdentifier =
            "Script" + Guid.NewGuid().ToString().Replace("-", "");

         //Getting the unique identifier
         this.compilationData.Identifier = info.Identifier;
         this.compilationData.Alias      = info.Alias;

         LocateInheritenceAnchor();
         if (null == anchorStart)
            throw new ScriptParserException("This script does not inherit from Script");

         //
         CollectTokensBeforeAnchor();

         //Locate the extents of the script source code. (updates compilation data)
         LocateScriptBody();

         //Update the compilation data with the metadata attribute details. (updates compilation data)
         LocateScriptMetadataAttribute();

         //Collect the set of using imports
         ScanNamespaceImports();

         //Final step, collect the class attributes
         ParseMemberAttributes();

         return this.compilationData;
      }

      private string script;

      private ScriptData compilationData;
      private int        anchorDynStart;       //Anchor validation start point
      private int        bodyStart;            //Start position of class body (1 character after {)
      private int        bodyLength;           //Length of the class body
      private Match      anchorStart;          //Match location of the script anchor
      private Match[]    preAnchorTokens;      //Tokens present before the anchor
      private int        attributeStartToken;  //Token index for attribute start (ScriptMetadataAttribute)
      private int        attributeEndToken;    //Token index for attribute end (ScriptMetadataAttribute)
      private int        attributeParam1Token; //Token index for attribute param 1 (ScriptMetadataAttribute) - Type

      private const string      expressionString    = "\"[^\"]*\"";
      private const string      expressionMLComment = @"/\*([^*]|\*[^/])*\*/";
      private const string      expressionSLComment = @"//.*";
      private readonly Regex    anchorMatch;
      private readonly Regex[]  invalidMatches;
      private readonly string[] tokenMatchStrings;
   }

   [Serializable]
   public class ScriptParserException : WSMException {
      public ScriptParserException(string message, Exception inner)
         : base(message, inner) { }
      public ScriptParserException(string message) : this(message, null) { }
      public ScriptParserException() : this("", null) { }
      public ScriptParserException(SerializationInfo info, StreamingContext context) : base(info, context) { }
   }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\wsmonitor\wsmService\WSMonitor.Utility.Certificates.cs ===
using System;
using System.Security.Cryptography.X509Certificates;
using CAPICOM;
using System.Runtime.Serialization;
using System.IO;
using System.Diagnostics;

namespace LiveServiceMonitor.Utility {
   
   [Serializable]
   public class CertificateException : Exception {
      public CertificateException() { }
      public CertificateException(string message) : base(message) { }
      public CertificateException(string message, Exception inner) : base(message, inner) { }
      protected CertificateException(SerializationInfo info, StreamingContext context) : base(info, context) { }
   }

   public class CertificateUtility {       
      #region GetCertificate Privates
      private static CertificateException createNoCertificatesException(string field, string value) {
         return new CertificateException(string.Format("no certificate found with {0} = \"{1}\"", field, value));
      }

      private static CertificateException createCertificateNotFoundException(string path, Exception inner) {
         return new CertificateException(string.Format("cannot find certificate {0}", path), inner);
      }

      private static void validateCertificateCollection(X509Certificate2Collection certificateCollection, string findType, string findValue) {
         if (certificateCollection.Count < 1)
            throw createNoCertificatesException(findType, findValue);
         else if (certificateCollection.Count > 1) {
            EventLog.WriteEntry(
               NTService.EventSource,
               string.Format(
                  "Ambiguous certificate {0} '{1}' specified; {2} certificates " +
                  "were found, the first in the collection will be used.",
                  findType, findValue, certificateCollection.Count),
               EventLogEntryType.Warning);
         }
      }

      private static bool isThumbprint(string certificateIdentifier) {
         return certificateIdentifier.ToLower().StartsWith("0x");
      }

      private static bool isCertificateFile(string certificateIdentifier) {
         try {
            string Extension;
            Extension = Path.GetExtension(certificateIdentifier);
            return (Extension == ".cer" || Extension == ".pfx");
         }
         catch (ArgumentException) { return false; }
      }

      private static X509Certificate getCertificateByThumbprint(X509Store personalStore, string thumbprint) {
         X509Certificate2Collection CertificateCollection;
         CertificateCollection = personalStore.Certificates.Find(X509FindType.FindByThumbprint, thumbprint, false);
         validateCertificateCollection(CertificateCollection, "thumbprint", thumbprint);
         return CertificateCollection[0];
      }

      private static X509Certificate getCertificateByFile(string certificatePath) {
         try { return (X509Certificate)X509Certificate.CreateFromCertFile(certificatePath); }
         catch (FileNotFoundException e) {
            throw createCertificateNotFoundException(certificatePath, e);
         }
      }

      private static X509Certificate getCertificateBySubjectName(X509Store personalStore, string subjectName) {
         X509Certificate2Collection CertificateCollection;
         CertificateCollection = personalStore.Certificates.Find(X509FindType.FindBySubjectName, subjectName, false);
         validateCertificateCollection(CertificateCollection, "subjectName", subjectName);
         return CertificateCollection[0];
      }
      #endregion

      public static X509Certificate GetCertificate(string certificateIdentifier) {
         X509Store personalStore;

         if (string.IsNullOrEmpty(certificateIdentifier))
            throw new ArgumentException("value cannot be null or empty", "certificateIdentifier");

         personalStore = new X509Store(StoreName.My, StoreLocation.CurrentUser);
         personalStore.Open(OpenFlags.ReadOnly);

         if (personalStore.Certificates.Count == 0) {
            personalStore = new X509Store(StoreName.My, StoreLocation.LocalMachine);
            personalStore.Open(OpenFlags.ReadOnly);
         }

         if (isThumbprint(certificateIdentifier))
            return getCertificateByThumbprint(personalStore, certificateIdentifier.Substring(2));
         else if (isCertificateFile(certificateIdentifier))
            return getCertificateByFile(certificateIdentifier);
         else
            return getCertificateBySubjectName(personalStore, certificateIdentifier);
      }
   }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\wsmonitor\wsmService\Service.Integration.CommandGenerator.cs ===
namespace LiveServiceMonitor.Service.Integration {
   #region Using Directives
   using System;
   using System.Xml;
   using System.Data.SqlTypes;
   using System.IO;
   using System.Collections.Generic;

   using WSMCommon.Control.Command;
   #endregion

   /// <summary>
   /// Provides static methods used for the construction of Service commands.
   /// </summary>
   /// <remarks>
   /// Coupling exists between the command generating stored procs and this class.
   /// The formats of the two need to stay in sync.
   /// </remarks>
   public static class CommandGenerator {
      /// <summary>
      /// Creates a new command.  There is a common bit of initialization that needs
      /// to be done to all commands, this is taken care of here.
      /// </summary>
      /// <param name="action">Action associated with the created command.</param>
      /// <returns>The partially initialized command.</returns>
      private static CommandDetails NewCommand(ActionIdentifierEnum action) {
         CommandDetails Command = new CommandDetails();

         Command.Identifier = CommandProcessor.InternalCommandIdentifier;
         Command.Action     = action;
         Command.Timestamp  = new byte[0];

         return Command;
      }

      /// <summary>
      /// Creates the xml body associated with a command.
      /// </summary>
      /// <param name="elements">Optional xml element strings.</param>
      /// <returns>The document element associated with the command xml body.</returns>
      private static XmlElement NewCommandXml(params string[] elements) {
         XmlDocument Doc;
         XmlElement  Cmd;

         Doc = new XmlDocument();
         Doc.AppendChild(Cmd = Doc.CreateElement("command"));

         if (null != elements) {
            for (int c = 0; c < elements.Length; c++)
               Cmd.InnerXml += elements[c];
         }

         return Cmd;
      }

      /// <summary>
      /// Creates the xml body associated with a command.
      /// </summary>
      /// <param name="elements">Optional xml element strings.</param>
      /// <returns>The SqlXml associated with the command xml body.</returns>
      private static SqlXml NewCommandSqlXml(params string[] elements) {
         return ConvertToSqlXml(NewCommandXml(elements));
      }

      /// <summary>
      /// Converts an XmlElement to SqlXml.
      /// </summary>
      /// <param name="element">The input XmlElement that is to be converted.</param>
      /// <returns>The new SqlXml value.</returns>
      private static SqlXml ConvertToSqlXml(XmlElement element) {
         using (StringReader Reader = new StringReader(element.OuterXml)) {
            return new SqlXml(XmlTextReader.Create(Reader));
         }
      }

      /// <summary>
      /// Generates a new start script command.  Since the command is internally generated
      /// there will be no corresponding command results dumped to the control
      /// database.
      /// </summary>
      /// <param name="environment">Target environment for the new script instance.</param>
      /// <param name="script">Target script for the new script instance.</param>
      /// <returns>The fully initialized script start command.</returns>
      public static CommandDetails CreateScriptStart(int environment, int script) {
         CommandDetails Command = NewCommand(ActionIdentifierEnum.ScriptStart);

         Command.Parameters = NewCommandSqlXml
            (
               string.Format("<environment id=\"{0}\"/>", environment),
               string.Format("<script id=\"{0}\"/>", script)
            );

         return Command;
      }

      /// <summary>
      /// Generates a new start script group command.  Since the command is internally
      /// generated there will be no corresponding command results dumped to the control
      /// database.
      /// </summary>
      /// <param name="environment">Target environment for the new script instance.</param>
      /// <param name="scripts">Scripts associated with the group of interest.</param>
      /// <returns>The fully initialized script group start command.</returns>
      public static CommandDetails CreateScriptGroupStart(int environment, int group, int[] scripts) {
         CommandDetails Command = NewCommand(ActionIdentifierEnum.ScriptGroupStart);
         List<string> Parameters = new List<string>(
            Array.ConvertAll<int, string>
               (
                  scripts,
                  delegate(int s) { return string.Format("<script id=\"{0}\"/>", s); }
               )
         );
         
         Parameters.Add(string.Format("<environment id=\"{0}\"/>", environment));
         Parameters.Add(string.Format("<group id=\"{0}\"/>", group));
         Command.Parameters = NewCommandSqlXml(Parameters.ToArray());

         return Command;
      }
   }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\wsmonitor\wsmService\obj\i386\_generated.cs ===
[assembly:System.Runtime.InteropServices.ComVisible(false)]
[assembly:System.Reflection.AssemblyVersion("12.4.56.0")]
[assembly:System.Reflection.AssemblyProduct("Microsoft(R) Xbox(TM)")]
[assembly:System.Reflection.AssemblyCopyright("Copyright (c) Microsoft Corporation. All rights reserved.")]
[assembly:System.Reflection.AssemblyCompany("Microsoft Corporation")]
[assembly:System.Reflection.AssemblyFileVersion("12.4.56.0")]
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\wsmonitor\wsmService\Service.ScriptRunner.cs ===
using System;
using System.Xml;
using System.Xml.XPath;
using System.Threading;
using System.Collections.Generic;
using System.Text.RegularExpressions;

using WSMCommon.Control;
using WSMCommon.Control.Command;

using WSMonitor.Framework;
using WSMonitor.Framework.Scripting;

using ScriptStatus = WSMCommon.Control.Command.CommandState;
using Map          = System.Collections.Generic.KeyValuePair<char, int>;

namespace LiveServiceMonitor.Service {
   internal delegate void ScriptChangeHandler(ScriptRunner target,bool release);

   internal class ScriptRunner : MarshalByRefObject {
      public ScriptStatus Status { get { lock (syncLock) { return state; } } }
      public long Instance { get { return instance; } }
      public int Identifier { get { return identifier; } }
      public IScript Script { get { return script; } }
      public ScriptType ScriptType { get { return scriptType; } }

      public Thread Worker { get { return worker; } set { worker = value; } }

      public ScriptRunner(ScriptChangeHandler handler, Script script, int id, long instance, ScriptType scriptType) {
         onChange += handler;

         this.instance   = instance;
         this.identifier = id;
         this.script     = script;
         this.state      = new StateManager();
         this.worker     = null;
         this.scriptType = scriptType;
         this.syncLock   = new object();
      }

      public void ThreadStartProc() {
         try {
            object result;
            System.Diagnostics.Debug.Assert(null != script);
            System.Runtime.Remoting.Messaging.CallContext.SetData("instance", instance);
            result = script.Execute(new object[0]);

            if (scriptType == ScriptType.General || result == null || result.GetType() != typeof(bool))
               state.Complete();
            else {
               if ((bool)result) state.Success();
               else state.Fail();
            }
         }
         catch (ThreadAbortException) {
            state.Cancel();
            result = "Test cancelled.";
         }
         catch (Exception e) {
            state.Exception();
            result = "Test failed, unexpected exception:\r\n" + e.ToString();
         }
         finally {
            onChange(this, true);
         }
      }

      private void CheckThread(ScriptStatus s) {
         if (s == ScriptStatus.Running) {
            if (null == worker) {
               worker = new Thread(ThreadStartProc);
               worker.Start();
            }
         }

      }

      public bool Queue() {
         ScriptStatus s0, s1;

         lock (syncLock) {
            s0 = state;
            state.Queue();
            s1 = state;
         }

         return s0 != s1;
      }

      private void _Suspend() {
#pragma warning disable 618
         worker.Suspend();
#pragma warning restore 618
      }

      private void _Resume() {
#pragma warning disable 618
         worker.Resume();
#pragma warning restore 618
      }

      public bool Pause() {
         ScriptStatus s0, s1;

         lock (syncLock) {
            s0 = state;
            state.Pause();
            s1 = state;
            
            if (s0 != s1) {
               //The script can only be marked suspended if it is running or queued
               if (null != worker)
                  _Suspend();

               onChange(this, false);
            }
         }
         
         return s0 != s1;
      }

      public bool Schedule() {
         ScriptStatus s0, s1;

         lock (syncLock) {
            s0 = state; 
            state.Schedule();
            s1 = state;
         }

         if (s1 != s0) {
            onChange(this, false);
            CheckThread(s1);
         }

         return true;
      }

      private bool IsResumable(Thread worker) {
         if (null == worker)
            return false;

         if ((worker.ThreadState & ThreadState.Suspended) == ThreadState.Suspended)
            return true;

         if ((worker.ThreadState & ThreadState.SuspendRequested) == ThreadState.SuspendRequested)
            return true;

         return false;
      }

      public bool Resume() {
         ScriptStatus s0, s1;

         lock (syncLock) {
            s0 = state;
            state.Resume();
            s1 = state;
         }

         if (s1 != s0) {
            onChange(this, false);
            CheckThread(s1);
            if (IsResumable(worker))
               _Resume();
         }

         return s0 != s1;
      }


      public bool Cancel() {
         ScriptStatus s0, s1;

         lock (syncLock) {
            s0 = state;
            state.Cancel();
            s1 = state;

            if (s0 != s1 && null != worker) {
               try { worker.Abort(); }
               catch (ThreadStateException) {
                  //This will cause the abort to fire
                  _Resume();
               }
            }
         }

         return s0 != s1;
      }

      public string Result {
         get { return this.result; }
      }

      private event ScriptChangeHandler onChange;
      private object             syncLock;
      private StateManager       state;
      private long               instance;
      private int                identifier;
      private Script             script;
      private Thread             worker;
      private string             result;
      private ScriptType         scriptType;

      private class StateManager {
         
         public StateManager() {
            this.state = _stateInitial;

            this.stateMachine = new Dictionary<int, List<KeyValuePair<char, int>>>();

            this.stateMachine.Add(_stateInitial,
               new List<Map>(
                  new Map[] {
                     new Map(_alphaQueue, _stateQueued)
                  }));

            this.stateMachine.Add(_stateQueued,
               new List<Map>(
                  new Map[] {
                     new Map(_alphaPause, _statePaused),
                     new Map(_alphaSchedule, _stateRunning),
                     new Map(_alphaCancel, _stateCancelled)
                  }));

            this.stateMachine.Add(_statePaused,
               new List<Map>(
                  new Map[] {
                     new Map(_alphaResume, _stateQueued),
                     new Map(_alphaCancel, _stateCancelled),
                     new Map(_alphaSchedule, _statePausedRunning)
                  }));
            
            this.stateMachine.Add(_statePausedRunning,
               new List<Map>(
                  new Map[] {
                     new Map(_alphaResume, _stateRunning),
                     new Map(_alphaCancel, _stateCancelled)
                  }));

            this.stateMachine.Add(_stateRunning,
               new List<Map>(
                  new Map[] {
                     new Map(_alphaCancel, _stateCancelled),
                     new Map(_alphaFail, _stateFailed),
                     new Map(_alphaSuccess, _stateSuccess),
                     new Map(_alphaComplete, _stateCompleted),
                     new Map(_alphaException, _stateException),
                     new Map(_alphaPause, _statePausedRunning),
                  }));

            this.stateMachine.Add(_stateCancelled, new List<Map>());
            this.stateMachine.Add(_stateCompleted, new List<Map>());
            this.stateMachine.Add(_stateFailed, new List<Map>());
            this.stateMachine.Add(_stateSuccess, new List<Map>());
            this.stateMachine.Add(_stateException, new List<Map>());
         }

         public void Pause()     { Feed(_alphaPause); }
         public void Queue()     { Feed(_alphaQueue); }
         public void Resume()    { Feed(_alphaResume); }
         public void Schedule()  { Feed(_alphaSchedule); }
         public void Cancel()    { Feed(_alphaCancel); }
         public void Fail()      { Feed(_alphaFail); }
         public void Success()   { Feed(_alphaSuccess); }
         public void Exception() { Feed(_alphaException); }
         public void Complete()  { Feed(_alphaComplete); }

         private void Feed(char c) {
            foreach (Map m in this.stateMachine[this.state]) {
               if (m.Key == c)
                  this.state = m.Value;
            }

            feedStream += c;
         }

         public static implicit operator ScriptStatus(StateManager manager) {
            return manager.Status;
         }

         public ScriptStatus Status {
            get {
               if (_stateQueued == state)
                  return ScriptStatus.Queued;
               if (_stateCancelled == state)
                  return ScriptStatus.Cancelled;
               if (_statePaused == state)
                  return ScriptStatus.Paused;
               if (_statePausedRunning == state)
                  return ScriptStatus.Paused;
               if (_stateRunning == state)
                  return ScriptStatus.Running;
               if (_stateCompleted == state)
                  return ScriptStatus.Completed;
               if (_stateFailed == state)
                  return ScriptStatus.Failed;
               if (_stateSuccess == state)
                  return ScriptStatus.Success;
               if (_stateException == state)
                  return ScriptStatus.Exception;

               return ScriptStatus.Unknown;
            }
         }

         private string feedStream;
         private Dictionary<int, List<Map>> stateMachine;

         private int state;

         private const char _alphaQueue = 'q';
         private const char _alphaPause = 'p';
         private const char _alphaResume = 'r';
         private const char _alphaSchedule = 's';
         private const char _alphaCancel = 'C';
         private const char _alphaFail = 'F';
         private const char _alphaSuccess = 'S';
         private const char _alphaComplete = 'E';
         private const char _alphaException = 'X';

         private const int _stateInitial = -1;
         private const int _stateQueued = 0;
         private const int _statePaused = 1;
         private const int _stateCancelled = 2;
         private const int _statePausedRunning = 3;
         private const int _stateRunning = 4;
         private const int _stateFailed = 5;
         private const int _stateCompleted = 6;
         private const int _stateSuccess = 7;
         private const int _stateException = 8;
      }
   }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\wsmonitor\wsmService\objd\i386\_generated.cs ===
[assembly:System.Runtime.InteropServices.ComVisible(false)]
[assembly:System.Reflection.AssemblyVersion("12.4.56.0")]
[assembly:System.Reflection.AssemblyProduct("Microsoft(R) Xbox(TM)")]
[assembly:System.Reflection.AssemblyCopyright("Copyright (c) Microsoft Corporation. All rights reserved.")]
[assembly:System.Reflection.AssemblyCompany("Microsoft Corporation")]
[assembly:System.Reflection.AssemblyFileVersion("12.4.56.0")]
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\wsmonitor\wsmService\obj\i386\_asmid.inc ===
ASSEMBLY_IDENTITY_KEY_FORM=msil_monitor_none_12.4.56.0_none_dd226b74b10dbf41
ASSEMBLY_IDENTITY_XP_KEY_FORM=msil_monitor_no-public-key_12.4.56.0_x-ww_a4beab5d
ASSEMBLY_IDENTITY_CULTURE=
ASSEMBLY_IDENTITY_NAME=monitor
ASSEMBLY_IDENTITY_PROCESSOR_ARCHITECTURE=msil
ASSEMBLY_IDENTITY_PUBLIC_KEY=
ASSEMBLY_IDENTITY_PUBLIC_KEY_TOKEN=
ASSEMBLY_IDENTITY_TYPE=
ASSEMBLY_IDENTITY_TYPE_NAME=
ASSEMBLY_IDENTITY_VERSION=12.4.56.0
XP_KEY_FORM=msil_monitor_no-public-key_12.4.56.0_x-ww_a4beab5d
XP_MANIFEST_DIRECTORY=manifests
XP_MANIFEST_NAME=msil_monitor_no-public-key_12.4.56.0_x-ww_a4beab5d.manifest
XP_MANIFEST_PATH=manifests\msil_monitor_no-public-key_12.4.56.0_x-ww_a4beab5d.manifest
XP_CATALOG_DIRECTORY=manifests
XP_CATALOG_NAME=msil_monitor_no-public-key_12.4.56.0_x-ww_a4beab5d.cat
XP_CATALOG_PATH=manifests\msil_monitor_no-public-key_12.4.56.0_x-ww_a4beab5d.cat
XP_PAYLOAD_PATH=msil_monitor_no-public-key_12.4.56.0_x-ww_a4beab5d
_DELAY_SIGN=0
!if [set _ASMIDTOATTRIBS_TLBIMP=]
!endif
CODESIGN_TESTKEY=
_TLBIMP_FLAGS=$(_TLBIMP_FLAGS)  /asmversion:12.4.56.0
_ASSEMBLY_IDENTITY=monitor,processorArchitecture=msil,version=12.4.56.0,publicKeyToken=neutral
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\wsmonitor\wsmService\WSMonitor.Utility.Xml.cs ===
using System;
using System.Xml;
using System.Xml.XPath;
using System.Data.SqlTypes;
using System.IO;

namespace LiveServiceMonitor.Utility {
   using Service;

   public class XmlUtil {
      public static bool IsXmlValid(string xml, out XmlDocument doc) {
         try {
            doc = new XmlDocument();
            doc.LoadXml(xml);
            return true;
         }
         catch {
            doc = null;
            return false;
         }
      }
      public static bool IsValidXml(string xml) {
         XmlDocument Doc;
         return IsXmlValid(xml, out Doc);
      }

      public static XmlDocument WrapInvalidXml(string xml, string root) {
         XmlDocument Doc;
         if (!IsXmlValid(xml, out Doc)) {
            Doc = new XmlDocument();
            Doc.LoadXml(string.Format("<{0}/>", root));
            Doc.DocumentElement.AppendChild(Doc.CreateTextNode(xml));
         }
         return Doc;
      }

      public static XmlNode CreateTextNode(string text) {
         XmlDocument Doc = new XmlDocument();
         return Doc.CreateTextNode(text);
      }

      public static XmlNode CreateNode(SqlXml xml) {
         XmlDocument Doc = new XmlDocument();
         Doc.Load(xml.CreateReader());
         return Doc.DocumentElement;
      }

      public static void WriteXmlDoc(XmlDocument doc, string path, bool rel) {
         if (rel)
            path = Path.Combine(DomainController.BaseDirectory, path);

         using (StreamWriter sw = new StreamWriter(path)) {
            using (XmlTextWriter xtw = new XmlTextWriter(sw)) {
               xtw.Formatting = Formatting.Indented;
               xtw.Indentation = 3;
               xtw.IndentChar = ' ';
               doc.WriteContentTo(xtw);
            }
         }
      }
   }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\wsmonitor\wsmUnit\makefile.inc ===
!INCLUDE $(INETROOT)\build\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\wsmonitor\wsmService\WSMonitor.Utility.ScriptGenerator.cs ===
using System;
using System.Collections.Generic;

using System.CodeDom;
using System.CodeDom.Compiler;

using System.Reflection;

using System.IO;
using System.Text;
using System.Text.RegularExpressions;

using Microsoft.CSharp;

using WSMCommon.Control;

using WSMonitor.Framework;
using WSMonitor.Framework.Reporting;
using WSMonitor.Framework.Scripting;

namespace LiveServiceMonitor.Utility {
   internal struct ScriptData {
      public Uri                 HostAddress;

      public string[]            ImortedNamespaces;
      public MemberAttributes    ClassAttributes;
      public string              ClassBody;
      public string              ClassIdentifier;

      public string              Alias;
      public ScriptType          ScriptType;
      public int                 Identifier;
   }

   internal sealed class ScriptGenerator {
      private ScriptGenerator() {
         this.namespaces      = new string[] {
            "System",
            "WSMonitor.Framework",
            "WSMonitor.Framework.Exceptions",
            "WSMonitor.Framework.Reporting",
            "LiveServiceMonitor.Framework.Services"
         };

         this.targetNamespace = "WSMonitor.Framework.Scripting";
      }

      public static CodeCompileUnit Generate(ScriptInformation info, EnvironmentInformation environment, out ScriptData data) {
         ScriptGenerator Generator = new ScriptGenerator();
         return Generator._Generate(info, environment, out data);
      }

      public string Name {
         get { return "Script" + guid.ToString().Replace("-", ""); }
      }

      private CodeNamespace CreateScriptNamespace(CodeCompileUnit ccu) {
         CodeNamespace Result = new CodeNamespace(targetNamespace);
         foreach (string ns in namespaces)
            Result.Imports.Add(new CodeNamespaceImport(ns));
         foreach (string ns in this.data.ImortedNamespaces)
            Result.Imports.Add(new CodeNamespaceImport(ns));

         return Result;
      }

      private CodeAttributeDeclaration CreateScriptAttribute(ScriptData data) {
         CodeAttributeDeclaration Ret;
         Ret = new CodeAttributeDeclaration(
            new CodeTypeReference(typeof(ScriptMetadataAttribute)),
            new CodeAttributeArgument(new CodePrimitiveExpression(data.Alias)),
            new CodeAttributeArgument(new CodePrimitiveExpression(data.Identifier)),
            new CodeAttributeArgument(new CodeFieldReferenceExpression(
               new CodeTypeReferenceExpression(typeof(ScriptType)),
               data.ScriptType.ToString()
            )));
         return Ret;
      }

      private CodeTypeDeclaration CreateScriptClass(ScriptData data) {
         CodeTypeDeclaration Ret = new CodeTypeDeclaration(data.ClassIdentifier);
         
         Ret.BaseTypes.Add(new CodeTypeReference(typeof(Script)));

         Ret.IsClass = true;
         Ret.Attributes = data.ClassAttributes;

         return Ret;
      }

      private CodeMemberMethod CreateExecuteMethod() {
         CodeMemberMethod Ret;
         CodeStatement    @try;
         CodeCatchClause  @catch;

         Ret = new CodeMemberMethod();

         Ret.Name = "Execute";
         Ret.ReturnType = new CodeTypeReference(typeof(object));
         Ret.Attributes = MemberAttributes.Public | MemberAttributes.Override;
         
         CodeParameterDeclarationExpression Parameter;

         Parameter = new CodeParameterDeclarationExpression(typeof(object[]), "parameters");
         Ret.Parameters.Add(Parameter);

         @try = new CodeMethodReturnStatement(
            new CodeMethodInvokeExpression(
               new CodeFieldReferenceExpression(new CodeThisReferenceExpression(), executionMethod),
               "Invoke",
               new CodeThisReferenceExpression(),
               new CodeVariableReferenceExpression("parameters")));

         @catch = new CodeCatchClause();
         @catch.Statements.Add(new CodeThrowExceptionStatement());

         Ret.Statements.Add(
            new CodeTryCatchFinallyStatement(
               new CodeStatement[] { @try },
               new CodeCatchClause[] { @catch }));

         return Ret;
      }

      private ConstructorInfo getTargetScriptConstructor() {
         foreach (ConstructorInfo constructor in typeof(Script).GetConstructors(BindingFlags.Public | BindingFlags.Instance)) {
            if (Attribute.IsDefined(constructor, typeof(ScriptModelConstructorAttribute)))
               return constructor;
         }

         throw new InvalidProgramException("Script class missing constructor with ScriptModelConstructor attribute.");
      }

      private CodeConstructor CreateScriptCtor(ScriptData data) {
         CodeExpression    Field;
         ConstructorInfo   TargetConstructor;
         CodeConstructor   Ret;

         Ret = new CodeConstructor();
         Ret.Attributes = MemberAttributes.Public;

         TargetConstructor = getTargetScriptConstructor();

         foreach (ParameterInfo Parameter in TargetConstructor.GetParameters()) {
            Ret.Parameters.Add(
               new CodeParameterDeclarationExpression(Parameter.ParameterType, Parameter.Name));
            Ret.BaseConstructorArgs.Add(
               new CodeVariableReferenceExpression(Parameter.Name));
         }

         Field = new CodeDirectionExpression(FieldDirection.Out,
            new CodeFieldReferenceExpression(new CodeThisReferenceExpression(), executionMethod));

         Ret.Statements.Add(
            new CodeMethodInvokeExpression(
                  new CodeBaseReferenceExpression(),
                  "GetExecutionTarget",
                  new CodeExpression[] { Field }));

         return Ret;   
      }

      private CodeTypeMember[] GenerateScriptFields(ScriptData data) {
         List<CodeTypeMember> Members;
         CodeMemberField Field;

         Members = new List<CodeTypeMember>();

         Members.Add(Field = new CodeMemberField(typeof(string), "HostEnvironment"));
         Field.Attributes = MemberAttributes.Private | MemberAttributes.Const | MemberAttributes.New;
         Field.InitExpression = new CodePrimitiveExpression(data.HostAddress.Host);

         return Members.ToArray();
      }

      private void GenerateScriptGraph(CodeCompileUnit ccu, ScriptData data) {
         CodeNamespace       Namespace;
         CodeTypeDeclaration Script;

         //Generate namespace for script
         ccu.Namespaces.Add(Namespace = CreateScriptNamespace(ccu));

         //Generate the script class
         Namespace.Types.Add(Script = CreateScriptClass(data));
         
         //Generate custom attributes
         Script.CustomAttributes = new CodeAttributeDeclarationCollection(
            new CodeAttributeDeclaration[] { 
               CreateScriptAttribute(data),
               new CodeAttributeDeclaration(new CodeTypeReference(typeof(ReportingAspectsAttribute)))
            });
         
         //Generate Script Parameters
         Script.Members.AddRange(GenerateScriptFields(data));

         //Generate the constructor
         Script.Members.Add(CreateScriptCtor(data));

         //Generate the Execute override
         Script.Members.Add(CreateExecuteMethod());

         Script.Members.Add(
            new CodeMemberField(typeof(MethodInfo), executionMethod));
         //Add native call methods
         Script.Members.Add(
            new CodeSnippetTypeMember(data.ClassBody));
      }

      private void ParseScriptMetadata(string source, out string alias, out ScriptType type) {
         alias = "";
         type = ScriptType.General;
      }

      private CodeCompileUnit _Generate(ScriptInformation info, EnvironmentInformation environment, out ScriptData data) {
         ccu  = new CodeCompileUnit();

         this.data = data = ScriptParser.Parse(info, environment);

         GenerateScriptGraph(ccu, data);

         return ccu;
      }

      internal static ScriptInformation GetDisabledScript(ScriptInformation source) {
         ScriptInformation Disabled = (ScriptInformation)source.Clone();
         Disabled.SourceCode =
            string.Format("namespace Disabled {{\n") +
            string.Format("   [ScriptMetadata(\"General\")]\n") +
            string.Format("   public class DisabledScript : Script {{\n") +
            string.Format("      [Native.Start]\n") +
            string.Format("      public void Run() {{\n") +
            string.Format("         throw new ScriptDisabledException(\"{0}\");\n", source.Alias) +
            string.Format("      }}") +
            string.Format("   }}") +
            string.Format("}}");
         return Disabled;
      }

      private ScriptData      data;
      private CodeCompileUnit ccu;
      private Guid            guid;
      
      private const    string    executionMethod = "executionMethod";

      private readonly string[]  namespaces;
      private readonly string    targetNamespace;
   }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\wsmonitor\wsmService\objd\i386\_asmid.inc ===
ASSEMBLY_IDENTITY_KEY_FORM=msil_monitor_none_12.4.56.0_none_dd226b74b10dbf41
ASSEMBLY_IDENTITY_XP_KEY_FORM=msil_monitor_no-public-key_12.4.56.0_x-ww_a4beab5d
ASSEMBLY_IDENTITY_CULTURE=
ASSEMBLY_IDENTITY_NAME=monitor
ASSEMBLY_IDENTITY_PROCESSOR_ARCHITECTURE=msil
ASSEMBLY_IDENTITY_PUBLIC_KEY=
ASSEMBLY_IDENTITY_PUBLIC_KEY_TOKEN=
ASSEMBLY_IDENTITY_TYPE=
ASSEMBLY_IDENTITY_TYPE_NAME=
ASSEMBLY_IDENTITY_VERSION=12.4.56.0
XP_KEY_FORM=msil_monitor_no-public-key_12.4.56.0_x-ww_a4beab5d
XP_MANIFEST_DIRECTORY=manifests
XP_MANIFEST_NAME=msil_monitor_no-public-key_12.4.56.0_x-ww_a4beab5d.manifest
XP_MANIFEST_PATH=manifests\msil_monitor_no-public-key_12.4.56.0_x-ww_a4beab5d.manifest
XP_CATALOG_DIRECTORY=manifests
XP_CATALOG_NAME=msil_monitor_no-public-key_12.4.56.0_x-ww_a4beab5d.cat
XP_CATALOG_PATH=manifests\msil_monitor_no-public-key_12.4.56.0_x-ww_a4beab5d.cat
XP_PAYLOAD_PATH=msil_monitor_no-public-key_12.4.56.0_x-ww_a4beab5d
_DELAY_SIGN=0
!if [set _ASMIDTOATTRIBS_TLBIMP=]
!endif
CODESIGN_TESTKEY=
_TLBIMP_FLAGS=$(_TLBIMP_FLAGS)  /asmversion:12.4.56.0
_ASSEMBLY_IDENTITY=monitor,processorArchitecture=msil,version=12.4.56.0,publicKeyToken=neutral
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\wsmonitor\wsmService\Service.ScriptManager.cs ===
using System;
using System.Xml;
using System.Xml.XPath;
using System.Threading;
using System.Collections;
using System.Collections.Generic;
using System.Reflection;
using System.Text;

using WSMCommon.Control;
using WSMCommon.Control.Command;
using WSMCommon.Control.Result;

using WSMonitor.Framework;
using WSMonitor.Framework.Scripting;
using WSMonitor.Framework.Exceptions;


namespace LiveServiceMonitor.Service {
   #region Using Directives
   using Framework.Services;
   using Utility;
   using Utility.Performance;
   using Health;

   using SRunnerList    = List<ScriptRunner>;
   using ScriptStatus   = CommandState;
   using RunnerMap      = Dictionary<long, ScriptRunner>;
   using InstanceMap    = Dictionary<ScriptRunner, long>;
   using ScriptTable    = Dictionary<int, Type>;
   using ScriptQueue    = LinkedList<ScriptRunner>;
   using CounterMap     = Dictionary<int, int>;
   #endregion

   internal class ScriptManager : MarshalByRefObject {
      /// <summary>
      /// Initializes a new instance of a script manager.
      /// </summary>
      /// <param name="manager">The environment manager that this script manager lives under.</param>
      /// <param name="config">Configuration settings that should be applied to the manager.</param>
      public ScriptManager(EnvironmentManager manager, XmlParser config) {
         if (null == manager) throw new ArgumentNullException("manager");

         this.manager         = manager;
         this.maxThreads      = config.Read<int>(configMaxThreads, defaultMaxThreads);
         this.scriptQueue     = new ScriptQueue();
         this.runnerMap       = new RunnerMap();
         this.instanceMap     = new InstanceMap();
         this.mapLock         = new object();
         this.scriptTable     = new ScriptTable();
         this.semaphore       = new Semaphore(maxThreads, maxThreads);
         this.scheduler       = new Thread(Schedule);
         this.scriptFlagMap   = new Dictionary<int, long>();
         this.counterMap      = new CounterMap();
         this.counterLock     = new object();
         
         if (this.maxThreads < 1)
            throw new XmlParserException("Setting must be greater than 1", configMaxThreads);

         this.scheduler.Start();
      }

      internal void ScanAssembly(Assembly assembly) {
         if (null == assembly)
            throw new ArgumentNullException("assembly");

         Type[] Exposed = assembly.GetExportedTypes();
         Type IScriptType = typeof(IScript);
         Type MetadataType = typeof(ScriptMetadataAttribute);

         foreach (Type Type in Exposed) {
            if (IScriptType.IsAssignableFrom(Type)) {
               ScriptMetadataAttribute Metadata;

               Metadata = Script.GetMetadata(Type);
               if (null != Metadata) {
                  this.scriptTable[Metadata.Id] = Type;
                  Script.RegisterScript(Type);
               }
            }
         }
      }

      #region Command Processing Logic
      private ScriptRunner GetScriptRunner(CommandDetails command, long instance) {
         lock (mapLock) {
            if (runnerMap.ContainsKey(instance))
               return runnerMap[instance];
         }

         return null;
      }

      private string NoChangeWarning(CommandDetails command, ScriptRunner runner) {
         return string.Format(
            "<warning>Warning execution {0} had no change on the state of the script.  " +
            "The script is still in state {1}.</warning>",
            command.Action,
            runner.Status);
      }

      private IEnumerable<ScriptRunner> EnumerateScriptRunners() {
         foreach (ScriptRunner Runner in scriptQueue)
            yield return Runner;

         foreach (ScriptRunner Runner in runnerMap.Values)
            yield return Runner;
      }

      private struct Class1_Action {
         public delegate bool Execute(ScriptRunner r);

         public string  WarningMissingRunner1;
         public string  WarningNoActiveScripts0;
         public string  SuccessExecuteItem1;
         public string  WarningExecuteNoOp2;
         public string  ErrorExecuteItem2;
         public Execute ActionExecuter;
      }

      internal static string CreateElement(string name, string v) {
         XmlDocument Doc = new XmlDocument();
         XmlElement E = Doc.CreateElement(name);
         XmlText T = Doc.CreateTextNode(v);
         E.AppendChild(T);
         return E.OuterXml;
      }

      internal static string SuccessElement(string v) { return CreateElement("success", v); }
      internal static string WarningElement(string v) { return CreateElement("warning", v); }
      internal static string ErrorElement(string v) { return CreateElement("error", v); }

      private CommandStatus Handle_Class1_Action(
         CommandDetails command,
         long? instance,
         Class1_Action action) 
      {
         CommandStatus Status = new CommandStatus(command.Identifier, CommandState.Completed, "");
         StringBuilder Result = new StringBuilder();
         List<ScriptRunner> Runners = new List<ScriptRunner>();

         Status.XmlResult = "";

         if (instance.HasValue) {
            ScriptRunner Runner;
            if (null == (Runner = GetScriptRunner(command, instance.Value)))
               Result.Append(WarningElement(string.Format(action.WarningMissingRunner1, instance)));
            else
               Runners.Add(Runner);
         }
         else {
            Runners.AddRange(EnumerateScriptRunners());
            if (Runners.Count == 0)
               Result.Append(WarningElement(action.WarningNoActiveScripts0));
         }

         foreach (ScriptRunner Runner in Runners) {
            try {
               if (action.ActionExecuter(Runner))
                  Result.Append(SuccessElement(string.Format(action.SuccessExecuteItem1, Runner.Instance)));
               else
                  Result.Append(WarningElement(string.Format(action.WarningExecuteNoOp2,Runner.Instance, Runner.Status)));
            }
            catch (Exception e) {
               Status.Status = CommandState.Failed;
               Result.Append(ErrorElement(string.Format(action.ErrorExecuteItem2,Runner.Instance, e)));
            }
         }

         Status.XmlResult = Result.ToString();

         return Status;
      }

      private CommandStatus Handle_Cancel(CommandDetails command, long? instance) {
         Class1_Action Action = new Class1_Action();

         Action.WarningMissingRunner1 = "Cannot cancel a completed script: id={0}";
         Action.WarningNoActiveScripts0 = "There are no active scripts to cancel";
         Action.SuccessExecuteItem1 = "Script cancelled: id={0}";
         Action.WarningExecuteNoOp2 = "Cancel had no affect on script: id={0}, state={1}";
         Action.ErrorExecuteItem2 = "Failed to cancel script: id={0} exception={1}";
         Action.ActionExecuter = new Class1_Action.Execute(CancelScript);

         return Handle_Class1_Action(command, instance, Action);
      }

      private CommandStatus Handle_Resume(CommandDetails command, long? instance) {
         Class1_Action Action = new Class1_Action();

         Action.WarningMissingRunner1 = "Cannot resume a completed script: id={0}";
         Action.WarningNoActiveScripts0 = "There are no active scripts to resume";
         Action.SuccessExecuteItem1 = "Script resumed: id={0}";
         Action.WarningExecuteNoOp2 = "Resume had no affect on script: id={0}, state={1}";
         Action.ErrorExecuteItem2 = "Failed to resume script: id={0} exception={1}";
         Action.ActionExecuter = new Class1_Action.Execute(ResumeScript);

         return Handle_Class1_Action(command, instance, Action);
      }

      private CommandStatus Handle_Pause(CommandDetails command, long? instance) {
         Class1_Action Action = new Class1_Action();

         Action.WarningMissingRunner1 = "Cannot pause a completed script: id={0}";
         Action.WarningNoActiveScripts0 = "There are no active scripts to pause";
         Action.SuccessExecuteItem1 = "Script paused: id={0}";
         Action.WarningExecuteNoOp2 = "Pause had no affect on script: id={0}, state={1}";
         Action.ErrorExecuteItem2 = "Failed to pause script: id={0} exception={1}";
         Action.ActionExecuter = new Class1_Action.Execute(PauseScript);

         return Handle_Class1_Action(command, instance, Action);
      }

      private CommandStatus Handle_GroupStart(CommandDetails command, int group, int[] identifiers) {
         CommandStatus Status = new CommandStatus(command.Identifier, CommandState.Completed, "");
         XmlDocument   Details = new XmlDocument();
         XmlElement    Root = Details.CreateElement("root");

         manager.NotifyScriptGroupStart(group);

         foreach (int identifier in identifiers) {
            CommandStatus StartResult = EnvironmentManager.PrepareResult(Handle_Start(command, identifier));
            XmlDocument Doc = new XmlDocument();
            XmlElement Result;

            Doc.LoadXml(StartResult.XmlResult);
            Result = (XmlElement)Details.ImportNode(Doc.DocumentElement, true);
            Result.Attributes.Append(Details.CreateAttribute("identifier")).Value = identifier.ToString();
            Root.AppendChild(Result);

            if (StartResult.Status != CommandState.Completed)
               Status.Status = CommandState.Failed;
         }

         Status.XmlResult = Root.InnerXml;

         return Status;
      }

      private CommandStatus Handle_Start(CommandDetails command, int identifier) {
         CommandStatus Status = new CommandStatus(command.Identifier, CommandState.Completed, "");
         StringBuilder Result = new StringBuilder();
         Type          ScriptType;
         long          Instance = 0;
         bool CounterMapAddedRef = false;
         bool CounterMapDropRef = false;

         Status.XmlResult = "";

         if (!scriptTable.TryGetValue(identifier, out ScriptType)) {
            Status.Status = CommandState.Failed;
            Result.Append(ErrorElement(string.Format("Cannot start script; script not found in table: id={0}", identifier)));
         }
         else {
            ScriptMetadataAttribute Metadata;
            Metadata = Script.GetMetadata(ScriptType);

            lock (counterLock) {
               long Flag = scriptFlagMap[identifier];

               if (0 != (Flag & (long)ScriptFlagEnum.Singleton)) {
                  int count;
                  
                  if (!counterMap.TryGetValue(identifier, out count))
                     count = 0;

                  if (0 != count) {
                     Status.Status = CommandState.Failed;
                     Result.Append(ErrorElement(string.Format("Rejected start script; only one instance of this script is allowed per environment.")));
                     goto Finished;
                  }
                  else {
                     counterMap[identifier] = 1;
                     CounterMapAddedRef = true;
                  }
               }
               try {
                  Instance = manager.GenerateScriptInstance(identifier, Metadata.Alias);
               }
               catch (Exception e) {
                  Status.Status = CommandState.Error;
                  Result.Append(ErrorElement(string.Format("Cannot start script; unable to acquire a script instance: exception={0}", e)));
                  CounterMapDropRef = true;
                  goto Finished;
               }
            }

            ///Indicate the script instance to the result
            Result.AppendFormat("<script-instance>{0}</script-instance>", Instance);

            Script ScriptInstance;
            try {
               ScriptInstance = (Script)Activator.CreateInstance(
                  ScriptType,
                  Script.GetConstructorArgs(Metadata, Instance));
            }
            catch (Exception e) {
               Status.Status = CommandState.Error;
               Result.Append(ErrorElement(string.Format("Cannot start script; unable to activate script object: exception={0}", e)));
               CounterMapDropRef = true;
               goto Finished;
            }

            try {
               ScriptRunner Runner;
               Runner = new ScriptRunner(
                  ChangeNotification,
                  ScriptInstance,
                  identifier,
                  Instance,
                  Metadata.Type);

               ///Map this script instance to environment
               manager.PostInstanceAdd(Instance);

               ///Indicate that this script is queue
               manager.PostScriptUpdate(Instance, (int)ScriptStatus.Queued, null);

               ///Change state to queued
               Runner.Queue();

               ///Queue the runner for execution
               scriptQueue.AddLast(Runner);

               Result.Append(SuccessElement("Script successufully queued."));
            }
            catch(Exception e) {
               Status.Status = CommandState.Error;
               Result.Append(ErrorElement(string.Format("Cannot start script; unable to completely register script: exception={0}", e)));
               CounterMapDropRef = true;

               ///Indicate that the script instance encountered an error
               manager.PostScriptUpdate(Instance, (int)CommandState.Error, null);
            }
         }

      Finished:
         if (CounterMapAddedRef && CounterMapDropRef)
            counterMap[identifier]--;

         Status.XmlResult = Result.ToString();

         return Status;
      }

      public void DispatchCommand(CommandDetails command) {
         XmlParser Parameters = new XmlParser(command.Parameters);
         CommandStatus Res = new CommandStatus(command.Identifier, CommandState.Error, "");

         ///We should never see this
         Res.XmlResult = ErrorElement(string.Format("Command unhandled: action={0}, value={1}", command.Action, (int)command.Action));

         try {
            switch (command.Action) {
               case ActionIdentifierEnum.EnvironmentCancelAllScripts:
                  Res = Handle_Cancel(command, null);
                  break;
               case ActionIdentifierEnum.EnvironmentPauseAllScripts:
                  Res = Handle_Pause(command, null);
                  break;
               case ActionIdentifierEnum.EnvironmentResumeAllScripts:
                  Res = Handle_Resume(command, null);
                  break;
               case ActionIdentifierEnum.ScriptGroupStart:
                  int[] Identifiers;
                  int Group;

                  Identifiers = Parameters.ReadAll<int>(paramScript);
                  Group = Parameters.Read<int>(paramGroup);
                  Res = Handle_GroupStart(command, Group, Identifiers);

                  break;
               case ActionIdentifierEnum.ScriptStart:
                  int Id;

                  if (!Parameters.TryRead<int>(paramScript, out Id)) {
                     Res.Status = CommandState.Failed;
                     Res.XmlResult = ErrorElement("Script identifier not specified");
                  }
                  else
                     Res = Handle_Start(command, Id);

                  break;
               case ActionIdentifierEnum.Invalid:
                  Res.Status = CommandState.Failed;
                  Res.XmlResult = ErrorElement(string.Format("Invalid action: value={0}", (int)command.Action));
                  break;
               default:
                  long Instance;

                  if (!Parameters.TryRead<long>(paramInstance, out Instance)) {
                     Res.Status = CommandState.Failed;
                     Res.XmlResult = ErrorElement("Script instance not specified");
                     break;
                  }

                  switch (command.Action) {
                     case ActionIdentifierEnum.ScriptCancel:
                        Res = Handle_Cancel(command, Instance);
                        break;
                     case ActionIdentifierEnum.ScriptPause:
                        Res = Handle_Pause(command, Instance);
                        break;
                     case ActionIdentifierEnum.ScriptResume:
                        Res = Handle_Resume(command, Instance);
                        break;
                     default:
                        Res.Status = CommandState.Failed;
                        Res.XmlResult = ErrorElement(string.Format("Unknown action: action={0}, value={1}", command.Action, (int)command.Action));
                        break;
                  }

                  break;
            }
         }
         catch (InvalidCastException e) {
            Res.Status = CommandState.Error;
            Res.XmlResult = ErrorElement(string.Format("Invalid command parameters: exception={0}", e));
         }
         catch (Exception e) {
            Res.Status = CommandState.Error;
            Res.XmlResult = ErrorElement(string.Format("Unexpected exception: action={0}, exception={1}", command.Action, e));
         }
         finally {
            manager.PostCommandResult(Res, false);
         }
      }
      #endregion

      public Dictionary<int, long> ScriptFlagMap {
         get { return this.scriptFlagMap; }
      }

      /// <summary>
      /// Change notification handler.
      /// </summary>
      /// <param name="runner">The target script.</param>
      /// <param name="release">A flag indicated whether or not the script should be removed from the active maps.</param>
      private void ChangeNotification(ScriptRunner runner, bool release) {
         manager.PostScriptUpdate(runner.Instance, (int)runner.Status, null);

         if (release) {
            lock (counterLock) {
               if (counterMap.ContainsKey(runner.Identifier))
                  counterMap[runner.Identifier]--;
            }

            manager.PostInstanceDelete(runner.Instance);
            instanceMap.Remove(runner);
            runnerMap.Remove(runner.Instance);
            semaphore.Release();
         }
      }

      private void Schedule() {
         Throttle Throttle = new Throttle(100, 1000, 2.0f);

         while (semaphore.WaitOne(Timeout.Infinite, false)) {
            if (scriptQueue.Count > 0) {
               ScriptRunner Runner;

               Runner = scriptQueue.First.Value;
               scriptQueue.RemoveFirst();

               instanceMap.Add(Runner, Runner.Instance);
               runnerMap.Add(Runner.Instance, Runner);

               Runner.Schedule();

               Throttle.Decrease();
            }
            else {
               semaphore.Release();
               Throttle.Increase();
            }

            Throttle.Wait();
         }
      }

      private bool PauseScript(ScriptRunner runner) {
         return runner.Pause();
      }
      private bool ResumeScript(ScriptRunner runner) {
         return runner.Resume();
      }
      
      private bool CancelScript(ScriptRunner runner) {
         return runner.Cancel();
      }

      public int Count {
         get { return scriptQueue.Count;  }
      }

      private Semaphore           semaphore;
      private EnvironmentManager  manager;
      private int                 maxThreads;
      private ScriptQueue         scriptQueue;
      private Dictionary<int, long> scriptFlagMap;
      private CounterMap          counterMap;
      private object              counterLock;

      private ScriptTable         scriptTable;
      private RunnerMap           runnerMap;
      private InstanceMap         instanceMap;
      private object              mapLock;
      private Thread              scheduler;

      //configuration settings
      private const string configMaxThreads  = "/script-manager/configuration/max-threads";
      private const string paramInstance     = "/command/instance/@id";
      private const string paramScript       = "/command/script/@id";
      private const string paramGroup        = "/command/group/@id";

      //default values
      private const int    defaultMaxThreads = 10;
   }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\wsmonitor\wsmUnit\obj\i386\_generated.cs ===
[assembly:System.Runtime.InteropServices.ComVisible(false)]
[assembly:System.Reflection.AssemblyVersion("12.4.56.0")]
[assembly:System.Reflection.AssemblyProduct("Microsoft(R) Xbox(TM)")]
[assembly:System.Reflection.AssemblyCopyright("Copyright (c) Microsoft Corporation. All rights reserved.")]
[assembly:System.Reflection.AssemblyCompany("Microsoft Corporation")]
[assembly:System.Reflection.AssemblyFileVersion("12.4.56.0")]
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\wsmonitor\wsmUnit\obj\i386\_asmid.inc ===
ASSEMBLY_IDENTITY_KEY_FORM=msil_wsmunit_none_12.4.56.0_none_855ac61e15b7d588
ASSEMBLY_IDENTITY_XP_KEY_FORM=msil_wsmunit_no-public-key_12.4.56.0_x-ww_f6397f58
ASSEMBLY_IDENTITY_CULTURE=
ASSEMBLY_IDENTITY_NAME=wsmunit
ASSEMBLY_IDENTITY_PROCESSOR_ARCHITECTURE=msil
ASSEMBLY_IDENTITY_PUBLIC_KEY=
ASSEMBLY_IDENTITY_PUBLIC_KEY_TOKEN=
ASSEMBLY_IDENTITY_TYPE=
ASSEMBLY_IDENTITY_TYPE_NAME=
ASSEMBLY_IDENTITY_VERSION=12.4.56.0
XP_KEY_FORM=msil_wsmunit_no-public-key_12.4.56.0_x-ww_f6397f58
XP_MANIFEST_DIRECTORY=manifests
XP_MANIFEST_NAME=msil_wsmunit_no-public-key_12.4.56.0_x-ww_f6397f58.manifest
XP_MANIFEST_PATH=manifests\msil_wsmunit_no-public-key_12.4.56.0_x-ww_f6397f58.manifest
XP_CATALOG_DIRECTORY=manifests
XP_CATALOG_NAME=msil_wsmunit_no-public-key_12.4.56.0_x-ww_f6397f58.cat
XP_CATALOG_PATH=manifests\msil_wsmunit_no-public-key_12.4.56.0_x-ww_f6397f58.cat
XP_PAYLOAD_PATH=msil_wsmunit_no-public-key_12.4.56.0_x-ww_f6397f58
_DELAY_SIGN=0
!if [set _ASMIDTOATTRIBS_TLBIMP=]
!endif
CODESIGN_TESTKEY=
_TLBIMP_FLAGS=$(_TLBIMP_FLAGS)  /asmversion:12.4.56.0
_ASSEMBLY_IDENTITY=wsmunit,processorArchitecture=msil,version=12.4.56.0,publicKeyToken=neutral
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\wsmonitor\wsmUnit\objd\i386\_generated.cs ===
[assembly:System.Runtime.InteropServices.ComVisible(false)]
[assembly:System.Reflection.AssemblyVersion("12.4.56.0")]
[assembly:System.Reflection.AssemblyProduct("Microsoft(R) Xbox(TM)")]
[assembly:System.Reflection.AssemblyCopyright("Copyright (c) Microsoft Corporation. All rights reserved.")]
[assembly:System.Reflection.AssemblyCompany("Microsoft Corporation")]
[assembly:System.Reflection.AssemblyFileVersion("12.4.56.0")]
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\wsmonitor\wsmUnit\Test.Unit.cs ===
namespace LiveServiceMonitor.Test {
   #region Using Directives
   using System;
   using System.IO;
   using System.Xml;
   using System.Collections.Generic;

   using TestCollection = System.Collections.Generic.IEnumerable<IUnitTest>;
   #endregion

   /// <summary>Interface defined for unit test cases.</summary>
   public interface IUnitTest {
      /// <summary>Name of the unit test.</summary>
      string          Name { get; }
      /// <summary>Performs unit test.</summary>
      bool            Test(XmlWriter xmlLog);
      /// <summary>Collection of child tests.</summary>
      TestCollection  UnitTests { get; }
   }

   /// <summary>
   /// Unit tests are nested in nature.  This attribute is used to mark the root
   /// of a unit test.
   /// </summary>
   [AttributeUsage(AttributeTargets.Class, AllowMultiple=false)]
   public class UnitTestRootAttribute : Attribute {
      /// <summary>
      /// Initializes a new instance of a UnitTestRootAttribute.
      /// </summary>
      public UnitTestRootAttribute() { }
   }

   /// <summary>
   /// This class acts as the default implementation of the IUnitTest interface.
   /// </summary>
   public class UnitTest : IUnitTest {
      /// <summary>
      /// Initializes a new instance of a UnitTest.  This overload allows for a name
      /// and child test cases to be specified.
      /// </summary>
      /// <param name="name">The name of the unit test.  This name need not be unique.</param>
      /// <param name="unitTests">Child unit tests.</param>
      public UnitTest(string name, IEnumerable<IUnitTest> unitTests) {
         this.name = string.IsNullOrEmpty(name) ? "" : name;
         this.unitTests = new List<IUnitTest>();
         if (null != unitTests)
            this.unitTests.AddRange(unitTests);
      }

      /// <summary>
      /// Initializes a new instance of a UnitTest.  All unit tests
      /// must be named.
      /// </summary>
      /// <param name="name">The name of the unit test.  This name need not be unique.</param>
      public UnitTest(string name) : this(name, null) { }

      /// <summary>
      /// Unit test method.  This method is provided for subclasses to override, it simplies
      /// the output scheme as well so they wont have to deal with putting together xml.
      /// </summary>
      /// <param name="message">Output messages.</param>
      /// <returns>True indicates that the test passed.</returns>
      protected virtual bool NodeTest(out string message) {
         message = null;
         return true;
      }

      #region IUnitTest Implementation
      /// <summary>Gets the name of this unit test.</summary>
      string         IUnitTest.Name { get { return name; } }
      /// <summary>Gets the collection of unit tests.</summary>
      TestCollection IUnitTest.UnitTests { get { return unitTests; } }
      /// <summary>
      /// Unit test execution method.  The Unit test method executes its test
      /// and all of its children.  The results are placed in a unit xml
      /// element.
      /// </summary>
      /// <param name="xmlLog">Writer to dump xml results into.</param>
      /// <returns>True indicates that the test and all of its children passed.</returns>
      bool           IUnitTest.Test(XmlWriter xmlLog) {
         return UnitTest.BasicUnitTest(
            this,
            new NodeTestDelegate(NodeTest),
            xmlLog);
      }
      #endregion

      /// <summary>
      /// Delegate to a simplied node test method.  This method need not deal with
      /// xml formatting instead it need only worry about reporting a single message
      /// and a true/false value indicating pass/fail.
      /// </summary>
      /// <param name="message">Output messages.</param>
      /// <returns>True indicates that the test passed.</returns>
      public delegate bool NodeTestDelegate(out string message);

      /// <summary>
      /// Default behavior of unit test.  This is provided so that implementations
      /// of IUnitTest do not have to re-invent this code if they are unable to
      /// inhert it from UnitTest.
      /// </summary>
      /// <param name="test">Unit test object.</param>
      /// <param name="nodeTest">Delegate to the simplified unit test.</param>
      /// <param name="xmlLog">Writer to dump xml results into.</param>
      /// <returns>True indicates that the test and all of its children passed.</returns>
      public static bool BasicUnitTest(
         IUnitTest test,
         NodeTestDelegate nodeTest,
         XmlWriter xmlLog) 
      {
         return BasicUnitTest(test.Name, nodeTest, test.UnitTests, xmlLog);
      }

      /// <summary>
      /// Default behavior of unit test.  This is provided so that implementations
      /// of IUnitTest do not have to re-invent this code if they are unable to
      /// inhert it from UnitTest.
      /// </summary>
      /// <param name="name">Name of the unit test.</param>
      /// <param name="nodeTest">Delegate to the simplified unit test.</param>
      /// <param name="unitTests">Child tests.</param>
      /// <param name="xmlLog">Writer to dump xml results into.</param>
      /// <returns>True indicates that the test and all of its children passed.</returns>
      public static bool BasicUnitTest(
         string           name,
         NodeTestDelegate nodeTest,
         TestCollection   unitTests,
         XmlWriter        xmlLog)
      {
         string message;
         bool node_pass, pass;
         List<IUnitTest> Tests;

         Tests     = new List<IUnitTest>(unitTests ?? new IUnitTest[0]);
         message   = null;
         node_pass = pass = null == nodeTest ? true : nodeTest(out message);
         xmlLog.WriteStartElement("unit");
            xmlLog.WriteAttributeString("name", name);
            if (!string.IsNullOrEmpty(message)) 
               xmlLog.WriteElementString("message", message);
            if (Tests.Count > 0) {
               xmlLog.WriteStartElement("children");
               foreach (IUnitTest child in unitTests)
                  pass &= child.Test(xmlLog);
               xmlLog.WriteEndElement();
            }
            xmlLog.WriteElementString("overall-pass", pass.ToString());
            if (!pass)
               xmlLog.WriteElementString("node-pass", node_pass.ToString());
         xmlLog.WriteEndElement();

         return pass;
      }

      protected string          name;
      protected List<IUnitTest> unitTests;
   }

   /// <summary>
   /// This class defines a unit test which has no children.
   /// </summary>
   public class UnitTestLeaf : UnitTest {
      /// <summary>
      /// Initializes a new instance of a UnitTestLeaf.  The name must be specified.
      /// </summary>
      /// <param name="name">Name of the unit test.</param>
      public UnitTestLeaf(string name) : base(name) { } 
   }

   /// <summary>
   /// This class defines a unit test which has no children.  The node test is delgated
   /// to the specified delegate.
   /// </summary>
   public class DelegatedUnitTestLeaf : UnitTestLeaf {
      /// <summary>
      /// Initializes a new instance of DelgatedUnitTestLeaf
      /// </summary>
      /// <param name="name">Name of the unit test.</param>
      /// <param name="leafTest">Code executed for the node test.</param>
      public DelegatedUnitTestLeaf(
         string name,
         UnitTest.NodeTestDelegate leafTest) : base(name)
      {
         this.leafTest = leafTest;
      }

      /// <summary>
      /// Executes the test delegate.  If the delegate is null the test automatically passes.
      /// </summary>
      /// <param name="message">Output message.</param>
      /// <returns>True indicates the test has passed.</returns>
      protected override bool NodeTest(out string message) {
         message = null;
         return null == leafTest ? true : leafTest(out message);
      }

      protected UnitTest.NodeTestDelegate leafTest;
   }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\wsmonitor\wsmUnit\Test.Runner.cs ===
namespace LiveServiceMonitor.Test {
   #region Using Directives
   using System;
   using System.Reflection;
   using System.Collections.Generic;
   using System.IO;
   using System.Xml;
   #endregion

   public static class Runner {
      /// <summary>
      /// Used to notify external user that a certain unit test failed to activate.
      /// </summary>
      private class ActivationFailureReplacement : UnitTest {
         /// <summary>
         /// Initializes a new instance of ActivationFailureReplacement.
         /// </summary>
         /// <param name="type">Type associated with unit test that failed to activate.</param>
         /// <param name="exception">Exception thrown due to failure to activate.</param>
         public ActivationFailureReplacement(Type type, Exception exception)
            : base("Activation Failure Replacement") {
            this.type = type;
            this.exception = exception;
         }

         /// <summary>
         /// Executes the test delegate.
         /// </summary>
         /// <param name="message">Output message.</param>
         /// <returns>True indicates the test has passed.</returns>
         protected override bool NodeTest(out string message) {
            message = string.Format(
               "UNIT-TEST-FAILURE! Failed to activate unit.\r\nType={0}\r\nException={1}",
               type.AssemblyQualifiedName, exception);

            return false;
         }

         private Type type;
         private Exception exception;
      }

      /// <summary>
      /// Collects all unit test roots in all the specified assemblies
      /// </summary>
      /// <param name="assemblies">Collection of assemblies to reflect on.</param>
      /// <returns>A collection of unit test roots.</returns>
      public static IEnumerable<IUnitTest> EnumerateUnitTests(Assembly[] assemblies) {
         Type IUT = typeof(IUnitTest);
         Type UTRA = typeof(UnitTestRootAttribute);

         for (int x = 0; x < assemblies.Length; x++) {
            string Name = assemblies[x].GetName().Name;

            if ("mscorlib" == Name) continue;
            if ("System" == Name) continue;
            if (Name.StartsWith("System.")) continue;
            if (Name.StartsWith("Microsoft.")) continue;

            Type[] Types = assemblies[x].GetExportedTypes();
            for (int y = 0; y < Types.Length; y++) {
               if (IUT.IsAssignableFrom(Types[y]) && Attribute.IsDefined(Types[y], UTRA, false)) {
                  IUnitTest Instance;

                  try { Instance = (IUnitTest)Activator.CreateInstance(Types[y]); }
                  catch (Exception e) { Instance = new ActivationFailureReplacement(Types[y], e); }

                  yield return Instance;
               }
            }
         }
      }
      /// <summary>
      /// Collects all unit test roots in all the assemblies present in the specified AppDomain.
      /// </summary>
      /// <param name="domain">The specified AppDomain.</param>
      /// <returns>A collection of unit test roots.</returns>
      public static IEnumerable<IUnitTest> EnumerateUnitTests(AppDomain domain) {
         return EnumerateUnitTests(domain.GetAssemblies());
      }
      /// <summary>
      /// Collects all unit test roots in the specified assembly.
      /// </summary>
      /// <param name="assembly">The target Assembly.</param>
      /// <returns>A collection of unit test roots.</returns>
      public static IEnumerable<IUnitTest> EnumerateUnitTests(Assembly assembly) {
         return EnumerateUnitTests(new Assembly[] { assembly });
      }
      /// <summary>
      /// Collects all unit test roots in the calling Assembly.
      /// </summary>
      /// <returns>A collection of unit test roots.</returns>
      public static IEnumerable<IUnitTest> EnumerateUnitTests() {
         return EnumerateUnitTests(Assembly.GetCallingAssembly());
      }
      /// <summary>
      /// Executes a collection of tests.
      /// </summary>
      /// <param name="tests">Collection of tests to execute.</param>
      /// <param name="output">Target stream for results.</param>
      /// <returns>True indicates the test has passed.</returns>
      public static bool Run(IEnumerable<IUnitTest> tests, TextWriter output) {
         bool Result = true;

         using (XmlTextWriter XWriter = new XmlTextWriter(output)) {
            XWriter.Formatting = Formatting.Indented;
            XWriter.Indentation = 3;
            XWriter.IndentChar = ' ';

            XWriter.WriteStartElement("test-run");
            XWriter.WriteAttributeString("time", DateTime.Now.ToString());

            foreach (IUnitTest test in tests) {
               using (StringWriter Writer = new StringWriter()) {
                  Exception failure;
                  string type;

                  ///Make sure the XWriter is never corrupted by failed tests
                  using (XmlTextWriter XWriter2 = new XmlTextWriter(Writer)) {
                     XWriter2.Formatting = Formatting.Indented;
                     XWriter2.IndentChar = ' ';
                     XWriter2.Indentation = 3;

                     try {
                        Result &= test.Test(XWriter2);
                        failure = null;
                        type = null;
                     }
                     catch (Exception e) {
                        failure = e;
                        try { type = test.GetType().AssemblyQualifiedName; }
                        catch { type = "unknown"; }
                        Result = false;
                     }
                  }

                  if (null == failure)
                     XWriter.WriteRaw(Writer.ToString());
                  else {
                     XWriter.WriteStartElement("bvt-exception");
                     XWriter.WriteAttributeString("type", type);
                     XWriter.WriteString(failure.ToString());
                     XWriter.WriteEndElement();
                  }
               }
            }

            XWriter.WriteElementString("passed", Result.ToString());
            XWriter.WriteEndElement();
         }

         return Result;
      }
   }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\wsmonitor\wsmService\Properties\AssemblyInfo.cs ===
﻿using System.Reflection;
using System.Runtime.CompilerServices;
using System.Runtime.InteropServices;

// General Information about an assembly is controlled through the following 
// set of attributes. Change these attribute values to modify the information
// associated with an assembly.
[assembly: AssemblyTitle("wsmService")]
[assembly: AssemblyDescription("")]
[assembly: AssemblyConfiguration("")]
[assembly: AssemblyCompany("Microsoft")]
[assembly: AssemblyProduct("wsmService")]
[assembly: AssemblyCopyright("Copyright © Microsoft 2007")]
[assembly: AssemblyTrademark("")]
[assembly: AssemblyCulture("")]

// Setting ComVisible to false makes the types in this assembly not visible 
// to COM components.  If you need to access a type in this assembly from 
// COM, set the ComVisible attribute to true on that type.
[assembly: ComVisible(false)]

// The following GUID is for the ID of the typelib if this project is exposed to COM
[assembly: Guid("7d155003-d6d4-443e-b058-122ada8e9f3e")]

// Version information for an assembly consists of the following four values:
//
//      Major Version
//      Minor Version 
//      Build Number
//      Revision
//
[assembly: AssemblyVersion("1.0.0.0")]
[assembly: AssemblyFileVersion("1.0.0.0")]
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\wsmonitor\wsmUnit\objd\i386\_asmid.inc ===
ASSEMBLY_IDENTITY_KEY_FORM=msil_wsmunit_none_12.4.56.0_none_855ac61e15b7d588
ASSEMBLY_IDENTITY_XP_KEY_FORM=msil_wsmunit_no-public-key_12.4.56.0_x-ww_f6397f58
ASSEMBLY_IDENTITY_CULTURE=
ASSEMBLY_IDENTITY_NAME=wsmunit
ASSEMBLY_IDENTITY_PROCESSOR_ARCHITECTURE=msil
ASSEMBLY_IDENTITY_PUBLIC_KEY=
ASSEMBLY_IDENTITY_PUBLIC_KEY_TOKEN=
ASSEMBLY_IDENTITY_TYPE=
ASSEMBLY_IDENTITY_TYPE_NAME=
ASSEMBLY_IDENTITY_VERSION=12.4.56.0
XP_KEY_FORM=msil_wsmunit_no-public-key_12.4.56.0_x-ww_f6397f58
XP_MANIFEST_DIRECTORY=manifests
XP_MANIFEST_NAME=msil_wsmunit_no-public-key_12.4.56.0_x-ww_f6397f58.manifest
XP_MANIFEST_PATH=manifests\msil_wsmunit_no-public-key_12.4.56.0_x-ww_f6397f58.manifest
XP_CATALOG_DIRECTORY=manifests
XP_CATALOG_NAME=msil_wsmunit_no-public-key_12.4.56.0_x-ww_f6397f58.cat
XP_CATALOG_PATH=manifests\msil_wsmunit_no-public-key_12.4.56.0_x-ww_f6397f58.cat
XP_PAYLOAD_PATH=msil_wsmunit_no-public-key_12.4.56.0_x-ww_f6397f58
_DELAY_SIGN=0
!if [set _ASMIDTOATTRIBS_TLBIMP=]
!endif
CODESIGN_TESTKEY=
_TLBIMP_FLAGS=$(_TLBIMP_FLAGS)  /asmversion:12.4.56.0
_ASSEMBLY_IDENTITY=wsmunit,processorArchitecture=msil,version=12.4.56.0,publicKeyToken=neutral
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\wsthash\wsthash.cpp ===
#include <conio.h>
#include <string.h>
#include <stdlib.h>
#include <stdio.h>

#define _ATL_NO_AUTOMATIC_NAMESPACE
#define _ATL_ALL_WARNINGS
#define _ATL_FREE_THREADED
#include <atlbase.h>
#include <atlcom.h>
#include <atlctl.h>
using namespace ATL;

#include <hashfunc.h>

unsigned long myhashNumber(__int64 qw)
{
    unsigned char rgby[sizeof(unsigned long)*2] = {0};

    unsigned long ulQwLow = (unsigned long)qw;
    unsigned long ulQwHigh = (unsigned long)(qw >> 32);
    memcpy(&rgby[0], &ulQwHigh, sizeof(unsigned long));
    memcpy(&rgby[sizeof(unsigned long)], &ulQwLow, sizeof(unsigned long));

    unsigned long h = 0;
    unsigned long a = PRIME_A;
    const unsigned long b = PRIME_B;
    const unsigned long k = PRIME_K; 

    for(long j = 0; j < sizeof(unsigned long)*2; j++)
    {
        h = (a * h + (unsigned long)rgby[j]) % k;

        a = a * b % (k-1);
    }

    return h % 420;
}

int myhashString(char *sz)
{
    int h = 0, a = PRIME_A, b = PRIME_B;

    while (*sz)
    {
        h = (a*h + *sz) % PRIME_K;

        a = a*b % (PRIME_K-1);
        sz++;
    }

    return h % 420;
}

unsigned long hashNumber(__int64 qw)
{
    LARGE_INTEGER li;
    li.QuadPart = qw;
    unsigned long i;
    HashLARGEINTEGER(li, 420, &i);
    return i;
}

unsigned long hashString(char *sz)
{
    USES_CONVERSION;
    unsigned long u;
    HashWSTR(A2W(sz), 420, &u);
    return u;
}

void Usage(char *sz)
{
    char *sz2 = strrchr(sz, '\\') ? strrchr(sz, '\\') + 1 : sz;
    printf("%s [num partitions] [-n] [-c] <value to hash>\n", sz2);
    printf("  num partitions defaults to 3\n");
    printf("  if -n is specified then value to hash is interpreted as a number\n");
    printf("  if -c is specified then value to hash is case sensitive\n");
}

int _cdecl main(int argc, char* argv[])
{
    if (argc < 2 || argc > 4 || (argc == 2 && (!strcmp(argv[1], "/?") || !strcmp(argv[1], "-?"))))
    {
        Usage(argv[0]);
        return 1;
    }

    bool fNumber = false;
    bool fCaseSensitive = false;
    int nPartitions = 3;

    int nShift = 0;
    while (argc - nShift > 2)
    {
        if (!strcmp(argv[1 + nShift], "-n"))
        {
            fNumber = true;
        }
        else if (!strcmp(argv[1 + nShift], "-c"))
        {
            fCaseSensitive = true;
        }
        else
        {
            nPartitions = atoi(argv[1]);
        }
        nShift++;
    }

    int nBucket = 0;
    int nBucket2 = 0;

    if (fNumber)
    {
        nBucket = hashNumber(_atoi64(argv[1 + nShift]));
        nBucket2 = myhashNumber(_atoi64(argv[1 + nShift]));
    }
    else
    {
        if (!fCaseSensitive)
        {
            for (unsigned int i = 0; i < strlen(argv[1 + nShift]); i++)
            {
                argv[1 + nShift][i] = argv[1 + nShift][i] >= 'A' && argv[1 + nShift][i] <= 'Z' ? argv[1 + nShift][i] + ('a' - 'A') : argv[1 + nShift][i];
            }
        }

        nBucket = hashString(argv[1 + nShift]);
        nBucket2 = myhashString(argv[1 + nShift]);
    }

    printf("%s\n", argv[1 + nShift]);
    printf("  bucket = %d\n", nBucket);
    if (nBucket != nBucket2)
    {
        printf("  bucket2 = %d\n", nBucket2);
    }
    printf("  partition = %d\n", nBucket / (420 / nPartitions) + 1);

    return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\wstrunner\console\exe\obj\i386\_generated.cs ===
[assembly:System.Runtime.InteropServices.ComVisible(false)]
[assembly:System.Reflection.AssemblyVersion("12.4.56.0")]
[assembly:System.Reflection.AssemblyProduct("DEPOT")]
[assembly:System.Reflection.AssemblyCopyright("")]
[assembly:System.Reflection.AssemblyCompany("")]
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\wstrunner\console\WstRunnerInstall.cs ===
﻿//====================================================
// Install portion of the wst runner command
//
// Parse install command params, run install processing
//=====================================================

using System;
using System.Collections.Generic;
using System.IO;
using System.Xml;

using xonline.tools.wstrunner.core;

namespace xonline.tools.wstrunner.console
{

    public partial class WstRunnerCmd
    {
        enum InstallPolicy {
            OKToInstall, DoNotInstall, InstallNotNecessary
        }

        /// <summary>
        /// Handles parsing of the command line arguments for installs
        /// </summary>
        /// <param name="args">The arguments to process.</param>
        public bool ParseInstallCommandLine(string[] args)
        {
            int numberOfArgs = args.Length;
            string currentArg;

            //we can skip the first two arguments which should have been the /job arg
            for (int currentArgIndex = 2; currentArgIndex < numberOfArgs; currentArgIndex++)
            {
                currentArg = args[currentArgIndex];

                if (String.Compare(currentArg, "/buildRoot", true) == 0)
                {   //REQUIRED
                    VerifyParameter(currentArg, currentArgIndex, numberOfArgs);
                    wstConfig.buildRoot = args[++currentArgIndex];
                }
                else if (String.Compare(currentArg, "/webRootDir", true) == 0)
                {   //REQUIRED
                    VerifyParameter(currentArg, currentArgIndex, numberOfArgs);
                    wstConfig.webRootDir = args[++currentArgIndex];
                }
                else if (String.Compare(currentArg, "/installDir", true) == 0)
                {   //REQUIRED
                    VerifyParameter(currentArg, currentArgIndex, numberOfArgs);
                    wstConfig.installDir = args[++currentArgIndex];
                }
                else if (String.Compare(currentArg, "/environment", true) == 0)
                {   //REQUIRED
                    VerifyParameter(currentArg, currentArgIndex, numberOfArgs);
                    wstConfig.environment = args[++currentArgIndex];
                }
                else if (String.Compare(currentArg, "/databaseName", true) == 0)
                {   //REQUIRED
                    VerifyParameter(currentArg, currentArgIndex, numberOfArgs);
                    wstConfig.databaseName = args[++currentArgIndex];
                }
                else if (String.Compare(currentArg, "/upgradePath", true) == 0)
                {   //REQUIRED
                    VerifyParameter(currentArg, currentArgIndex, numberOfArgs);
                    wstConfig.upgradePath = args[++currentArgIndex];
                }
                else if (String.Compare(currentArg, "/deployEnabled", true) == 0)
                {   //REQUIRED
                    VerifyParameter(currentArg, currentArgIndex, numberOfArgs);
                    wstConfig.deployEnabled = args[++currentArgIndex];
                }
                else if (String.Compare(currentArg, "/npdbServer", true) == 0)
                {   //REQUIRED
                    VerifyParameter(currentArg, currentArgIndex, numberOfArgs);
                    wstConfig.npdbServer = args[++currentArgIndex];
                }
                else if (String.Compare(currentArg, "/npdbDatabase", true) == 0)
                {   //REQUIRED
                    VerifyParameter(currentArg, currentArgIndex, numberOfArgs);
                    wstConfig.npdbDatabase = args[++currentArgIndex];
                }
                else if (String.Compare(currentArg, "/logRootDir", true) == 0)
                {
                    VerifyParameter(currentArg, currentArgIndex, numberOfArgs);
                    wstConfig.logRootDir = args[++currentArgIndex];
                }
                else if (String.Compare(currentArg, "/userAccount", true) == 0)
                {
                    VerifyParameter(currentArg, currentArgIndex, numberOfArgs);
                    wstConfig.userAccount = args[++currentArgIndex];
                }
                else if (String.Compare(currentArg, "/adminAccount", true) == 0)
                {
                    VerifyParameter(currentArg, currentArgIndex, numberOfArgs);
                    wstConfig.adminAccount = args[++currentArgIndex];
                }
                else if (String.Compare(currentArg, "/dataFilesDir", true) == 0)
                {
                    VerifyParameter(currentArg, currentArgIndex, numberOfArgs);
                    wstConfig.dataFilesDir = args[++currentArgIndex];
                }
                else if (String.Compare(currentArg, "/logFilesDir", true) == 0)
                {
                    VerifyParameter(currentArg, currentArgIndex, numberOfArgs);
                    wstConfig.logFilesDir = args[++currentArgIndex];
                }
                else if (String.Compare(currentArg, "/dataServerList", true) == 0)
                {
                    VerifyParameter(currentArg, currentArgIndex, numberOfArgs);
                    wstConfig.dataServerList = args[++currentArgIndex];
                }
                else if (String.Compare(currentArg, "/partitionCount", true) == 0)
                {
                    VerifyParameter(currentArg, currentArgIndex, numberOfArgs);
                    wstConfig.partitionCount = Convert.ToUInt32(args[++currentArgIndex]);
                }
                else if (String.Compare(currentArg, "/failSafeSetsPerServer", true) == 0)
                {
                    VerifyParameter(currentArg, currentArgIndex, numberOfArgs);
                    wstConfig.failSafeSetsPerServer = Convert.ToUInt32(args[++currentArgIndex]);
                }
                else if (String.Compare(currentArg, "/accountRoleMap", true) == 0)
                {
                    VerifyParameter(currentArg, currentArgIndex, numberOfArgs);
                    wstConfig.accountRoleMap = args[++currentArgIndex];
                }
                else if (String.Compare(currentArg, "/skipInterfaceConfig", true) == 0)
                {
                    VerifyParameter(currentArg, currentArgIndex, numberOfArgs);
                    wstConfig.skipInterfaceConfig = args[++currentArgIndex];
                }
                else if (String.Compare(currentArg, "/interfaceName", true) == 0)
                {
                    VerifyParameter(currentArg, currentArgIndex, numberOfArgs);
                    wstConfig.interfaceName = args[++currentArgIndex];
                }
                else if (String.Compare(currentArg, "/manifestPath", true) == 0)
                {
                    VerifyParameter(currentArg, currentArgIndex, numberOfArgs);
                    wstConfig.manifestPath = args[++currentArgIndex];
                }
                else if (String.Compare(currentArg, "/rollingUpgrade", true) == 0)
                {
                    VerifyParameter(currentArg, currentArgIndex, numberOfArgs);
                    string checkRolling = args[++currentArgIndex];
                    if ((String.Compare(checkRolling, "1") == 0) || (String.Compare(checkRolling, "true", true) == 0))
                    {
                        wstConfig.isRollingUpgrade = true;
                    }
                    else
                    {
                        wstConfig.isRollingUpgrade = false;
                    }
                }
                else if (String.Compare(currentArg, "/replTearDown", true) == 0)
                {
                    VerifyParameter(currentArg, currentArgIndex, numberOfArgs);
                    string checkReplTearDown = args[++currentArgIndex];
                    wstConfig.replTearDown = checkReplTearDown.Equals("1") || checkReplTearDown.Equals("true", StringComparison.CurrentCultureIgnoreCase);
                }
            }

            //Output the name arguments
            Console.WriteLine("buildRoot=            '" + wstConfig.buildRoot + "'");
            Console.WriteLine("webRootDir=           '" + wstConfig.webRootDir + "'");
            Console.WriteLine("installDir=           '" + wstConfig.installDir + "'");
            Console.WriteLine("environment=          '" + wstConfig.environment + "'");
            Console.WriteLine("databaseName=         '" + wstConfig.databaseName + "'");
            Console.WriteLine("upgradePath=          '" + wstConfig.upgradePath + "'");
            Console.WriteLine("deployEnabled=        '" + wstConfig.deployEnabled + "'");
            Console.WriteLine("npdbServer=           '" + wstConfig.npdbServer + "'");
            Console.WriteLine("npdbDatabase=         '" + wstConfig.npdbDatabase + "'");
            Console.WriteLine("userAccount=          '" + wstConfig.userAccount + "'");
            Console.WriteLine("adminAccount=         '" + wstConfig.adminAccount + "'");
            Console.WriteLine("dataFilesDir=         '" + wstConfig.dataFilesDir + "'");
            Console.WriteLine("logFilesDir=          '" + wstConfig.logFilesDir + "'");
            Console.WriteLine("dataServerList=       '" + wstConfig.dataServerList + "'");
            Console.WriteLine("partitionCount=       '" + wstConfig.partitionCount + "'");
            Console.WriteLine("failSafeSetsPerServer='" + wstConfig.failSafeSetsPerServer + "'");
            Console.WriteLine("accountRoleMap=       '" + wstConfig.accountRoleMap + "'");
            Console.WriteLine("skipInterfaceConfig=  '" + wstConfig.skipInterfaceConfig + "'");
            Console.WriteLine("interfaceName=        '" + wstConfig.interfaceName + "'");
            Console.WriteLine("manifestPath=         '" + wstConfig.manifestPath + "'");
            Console.WriteLine("rollingUpgrade=       '" + wstConfig.isRollingUpgrade.ToString() + "'");
            Console.WriteLine("replTearDown=         '" + wstConfig.replTearDown.ToString() + "'");
            Console.WriteLine();

            //check if we have all the required params
            if (wstConfig.buildRoot == null
                || wstConfig.webRootDir == null
                || wstConfig.installDir == null
                || wstConfig.environment == null
                || wstConfig.databaseName == null
                || wstConfig.upgradePath == null
                || wstConfig.deployEnabled == null
                || wstConfig.npdbServer == null
                || wstConfig.npdbDatabase == null)
            {
                Console.WriteLine("ERROR: Required parameters for Install are missing.");
                Console.WriteLine("Type \"WstRunner /?\" for usage help.");
                return false;
            }

            return true;
        }

        /// <summary>
        /// Determines the policy for installations based on fail safe set numbers.
        /// We deny deployment if, based on information describing the fail safe sets, we can reasonably
        /// believe that a deployment before this one failed.
        /// </summary>
        /// <param name="versionToInstall">The version that will be installed should setup proceed</param>
        /// <param name="deploymentName">The name of the deployment which will be installed.</param>
        /// <param name="reason">If the database should not be installed, a message explaining why. Otherwise an empty string.</param>
        /// <returns>Whether or not setup should be allowed to proceed.</returns>
        InstallPolicy ShouldInstallDatabaseAtVersion(string deploymentName, WstRunnerConfig.WSTVersion versionToInstall, out string reason)
        {
            InstallPolicy installPolicy = InstallPolicy.OKToInstall;
            reason = String.Empty; // silence the C# compiler -- we never use reason when it's okay to install.

            WstRunnerConfig.WSTVersion inProgressDeploymentVersion = GetVersionOfInProgressDeployment(deploymentName);
            WstRunnerConfig.WSTVersion actualDeploymentVersion = GetVersionFromDeployment(deploymentName);

            if ((inProgressDeploymentVersion != null) && (compare(inProgressDeploymentVersion, versionToInstall) < 0))
            {
                    reason = String.Format("A previous database deployment, versioned {0}, did not complete successfully. " +
                                           "Automated database deployment can not continue.", inProgressDeploymentVersion.strVersion);
                    installPolicy = InstallPolicy.DoNotInstall;
            }
            else if (actualDeploymentVersion != null)
            {
                // all versions are the same. Are they higher than or equal to ours?
                if (compare(versionToInstall, actualDeploymentVersion) < 0)
                {
                    reason = String.Format("No installation is necessary. The version of the currently deployed database, {0}, is higher than " +
                                           "the one that would be installed, {1}.", actualDeploymentVersion.strVersion, versionToInstall.strVersion);
                    installPolicy = InstallPolicy.InstallNotNecessary;
                }
                else if ((inProgressDeploymentVersion == null) && (compare(versionToInstall, actualDeploymentVersion) == 0))
                {
                    reason = String.Format("No installation is necessary. The deployed database is already at version {0}.", versionToInstall.strVersion);
                    installPolicy = InstallPolicy.InstallNotNecessary;
                }
            }

            return installPolicy;
        }

        /// <summary>
        /// Process the command parameter data
        /// </summary>
        /// <returns></returns>
        public bool ProcessInstall()
        {
            wstConfig.upgradePath = wstConfig.upgradePath.ToLower();

            if (wstConfig.skipInterfaceConfig == null)
            {
                wstConfig.skipInterfaceConfig = "false";
            }

            if (wstConfig.interfaceName == null || wstConfig.interfaceName.Length == 0)
            {
                wstConfig.interfaceName = wstConfig.databaseName;
            }

            if (wstConfig.manifestPath == null || wstConfig.manifestPath.Length == 0)
            {
                wstConfig.manifestPath = "manifest.xml";
            }

            wstConfig.computerName = Environment.MachineName;

            if (!Directory.Exists(wstConfig.buildRoot))
            {
                Console.WriteLine("Folder \"" + wstConfig.buildRoot + "\" does not exist.");
                return false;
            }

            wstConfig.srcDir = wstConfig.buildRoot + "\\database\\" + wstConfig.upgradePath + "\\" + wstConfig.databaseName;

            if (!Directory.Exists(wstConfig.srcDir))
            {
                Console.WriteLine("Folder \"" + wstConfig.srcDir + "\" does not exist.");
                return false;
            }

            wstConfig.installVersion = GetVersionFromManifest(wstConfig.srcDir + "\\" + wstConfig.manifestPath);

            if (wstConfig.installVersion == null)
            {
                Console.WriteLine("ERROR unable to determine manifest version.");
                return false;
            }

            wstConfig.dstDir = wstConfig.webRootDir + "\\" + wstConfig.installDir;

            //Check our policy for fail safe sets and see if install should be allowed to proceed.
                
            string reason;
            InstallPolicy policy = ShouldInstallDatabaseAtVersion(wstConfig.databaseName, wstConfig.installVersion, out reason);
            
            if (policy == InstallPolicy.DoNotInstall) 
            {
                Console.WriteLine("ERROR {0}", reason);
                return false;
            }
            else if (policy == InstallPolicy.InstallNotNecessary)
            {
                Console.WriteLine(reason);
                return true;
            }

            // This will need to go away but it is just here for now
            if (wstConfig.environment == "xblob")
            {
                if (wstConfig.userAccount == null)
                {
                    Console.WriteLine("ERROR xblob environment requires useraccount to be defined");
                    return false;
                }
            }

            if (wstConfig.accountRoleMap == null)
            {
                wstConfig.accountRoleMap = wstConfig.userAccount + "=ClientLib";
            }

            if (!Directory.Exists(wstConfig.webRootDir))
            {
                Console.WriteLine("WARNING : webRootDir -> " + wstConfig.webRootDir + " did not exist, creating it.");
                Directory.CreateDirectory(wstConfig.dstDir);
            }

            if (Directory.Exists(wstConfig.dstDir))
            {
                // if prodbase is database name already installed
                if (wstConfig.upgradePath == "prodbase" && wstConfig.manifestVersion != null && wstConfig.failSafeVersion != null)
                {
                    if (compare(wstConfig.failSafeVersion, wstConfig.manifestVersion) > 0)
                    {
                        Console.WriteLine(wstConfig.databaseName + " is already installed.");
                        return false;
                    }
                }

                // if prodbase is database an old version? if so uninstall
                if (wstConfig.upgradePath == "prodbase")
                {
                    if ((wstConfig.failSafeVersion == null) || (compare(wstConfig.failSafeVersion, wstConfig.manifestVersion) < 0))
                    {
                        Console.WriteLine(wstConfig.databaseName + " is old. Uninstalling...");

                        if (!UninstallDatabase())
                        {
                            return false;
                        }

                        Directory.CreateDirectory(wstConfig.dstDir);
                    }
                }
            }
            else
            {
                Directory.CreateDirectory(wstConfig.dstDir);
            }

            //  Copy the entire set of database files.  If this is an upgrade,
            //  then we need to copy prodbase DDL first, then upgrade.
            if (wstConfig.upgradePath != "prodbase")
            {
                //  If we are trying to upgrade over an existing upgrade, make sure we're coming
                //  in with a higher version number, otherwise it's a no-op.

                // if same or higher version number then skip upgrade
                if (wstConfig.manifestVersion != null && wstConfig.failSafeVersion != null)
                {
                    if (compare(wstConfig.failSafeVersion, wstConfig.manifestVersion) > 0)
                    {
                        Console.WriteLine("Same or higher existing version found, skipping upgrade.");
                        Console.WriteLine("\tExisting version = " + wstConfig.failSafeVersion.strVersion);
                        Console.WriteLine("\tInstall version  = " + wstConfig.manifestVersion.strVersion);
                        return false;
                    }
                }

                wstConfig.srcDirProdbaseDDL = wstConfig.buildRoot + "\\database\\prodbase\\" + wstConfig.databaseName + "\\ddl";
                wstConfig.dstDirDDL = wstConfig.dstDir + "\\ddl";

                if (Directory.Exists(wstConfig.srcDirProdbaseDDL))
                {
                    if (CopyDirectories(wstConfig.srcDirProdbaseDDL, wstConfig.dstDirDDL, true))
                    {
                        Console.WriteLine("Copied \"" + wstConfig.srcDirProdbaseDDL + "\" to \"" + wstConfig.dstDirDDL + "\".");
                    }
                    else
                    {
                        Console.WriteLine("FAILED Copying \"" + wstConfig.srcDirProdbaseDDL + "\" to \"" + wstConfig.dstDirDDL + "\".");
                        return false;
                    }
                }

                // BUG# 49600 - WstRuner wants to generate a deploymentxml file but there isn't one.
                string pathToProdbaseDeployment = wstConfig.buildRoot + "\\database\\prodbase\\" + wstConfig.databaseName + "\\deployment_" + wstConfig.environment + ".xml";
                string destinationForProdbaseDeployment = wstConfig.dstDir + "\\deployment.xml";

                if (File.Exists(pathToProdbaseDeployment))
                {
                    if (this.CopyFile(pathToProdbaseDeployment, destinationForProdbaseDeployment, true))
                    {
                        Console.WriteLine("Copied \"" + pathToProdbaseDeployment + "\" to \"" + destinationForProdbaseDeployment + "\".");
                    }
                    else
                    {
                        Console.WriteLine("FAILED Copying \"" + pathToProdbaseDeployment + "\" to \"" + destinationForProdbaseDeployment + "\".");
                        return false;
                    }
                }
                // END BUG# 49600


                if (wstConfig.databaseName.ToLower() == "rawcatalogdb")
                {
                    wstConfig.srcDirProdbaseDML = wstConfig.buildRoot + "\\database\\prodbase\\" + wstConfig.databaseName + "\\dml";
                    wstConfig.dstDirDML = wstConfig.dstDir + "\\dml";

                    if (Directory.Exists(wstConfig.srcDirProdbaseDML))
                    {
                        if (CopyDirectories(wstConfig.srcDirProdbaseDML, wstConfig.dstDirDML, true))
                        {
                            Console.WriteLine("Copied \"" + wstConfig.srcDirProdbaseDML + "\" to \"" + wstConfig.dstDirDML + "\".");
                        }
                        else
                        {
                            Console.WriteLine("FAILED Copying \"" + wstConfig.srcDirProdbaseDML + "\" to \"" + wstConfig.dstDirDML + "\".");
                            return false;
                        }

                    }

                    wstConfig.srcDirProdbaseOther = wstConfig.buildRoot + "\\database\\prodbase\\" + wstConfig.databaseName + "\\other";
                    wstConfig.dstDirOther = wstConfig.dstDir + "\\other";

                    if (Directory.Exists(wstConfig.srcDirProdbaseOther))
                    {
                        if (CopyDirectories(wstConfig.srcDirProdbaseOther, wstConfig.dstDirOther, true))
                        {
                            Console.WriteLine("Copied \"" + wstConfig.srcDirProdbaseOther + "\" to \"" + wstConfig.dstDirOther + "\".");
                        }
                        else
                        {
                            Console.WriteLine("FAILED Copying \"" + wstConfig.srcDirProdbaseOther + "\" to \"" + wstConfig.dstDirOther + "\".");
                            return false;
                        }
                    }
                }
            }

            if (wstConfig.upgradePath != "prodbase" && wstConfig.upgradePath != "upgrade")
            {
                wstConfig.srcDirProdbaseDDL = wstConfig.buildRoot + "\\database\\upgrade\\" + wstConfig.databaseName + "\\ddl";
                wstConfig.dstDirDDL = wstConfig.dstDir + "\\ddl";

                if (Directory.Exists(wstConfig.srcDirProdbaseDDL))
                {
                    if (CopyDirectories(wstConfig.srcDirProdbaseDDL, wstConfig.dstDirDDL, true))
                    {
                        Console.WriteLine("Copied \"" + wstConfig.srcDirProdbaseDDL + "\" to \"" + wstConfig.dstDirDDL + "\".");
                    }
                    else
                    {
                        Console.WriteLine("FAILED Copying \"" + wstConfig.srcDirProdbaseDDL + "\" to \"" + wstConfig.dstDirDDL + "\".");
                        return false;
                    }
                }

                if (wstConfig.databaseName.ToLower() == "rawcatalogdb")
                {
                    wstConfig.srcDirProdbaseDML = wstConfig.buildRoot + "\\database\\prodbase\\" + wstConfig.databaseName + "\\dml";
                    wstConfig.dstDirDML = wstConfig.dstDir + "\\dml";

                    if (Directory.Exists(wstConfig.srcDirProdbaseDML))
                    {
                        if (CopyDirectories(wstConfig.srcDirProdbaseDML, wstConfig.dstDirDML, true))
                        {
                            Console.WriteLine("Copied \"" + wstConfig.srcDirProdbaseDML + "\" to \"" + wstConfig.dstDirDML + "\".");
                        }
                        else
                        {
                            Console.WriteLine("FAILED Copying \"" + wstConfig.srcDirProdbaseDML + "\" to \"" + wstConfig.dstDirDML + "\".");
                            return false;
                        }
                    }

                    wstConfig.srcDirProdbaseOther = wstConfig.buildRoot + "\\database\\prodbase\\" + wstConfig.databaseName + "\\other";
                    wstConfig.dstDirOther = wstConfig.dstDir + "\\other";

                    if (Directory.Exists(wstConfig.srcDirProdbaseOther))
                    {
                        if (CopyDirectories(wstConfig.srcDirProdbaseOther, wstConfig.dstDirOther, true))
                        {
                            Console.WriteLine("Copied \"" + wstConfig.srcDirProdbaseOther + "\" to \"" + wstConfig.dstDirOther + "\".");
                        }
                        else
                        {
                            Console.WriteLine("FAILED Copying \"" + wstConfig.srcDirProdbaseOther + "\" to \"" + wstConfig.dstDirOther + "\".");
                            return false;
                        }
                    }
                }
            }

            if (CopyDirectories(wstConfig.srcDir, wstConfig.dstDir, true))
            {
                Console.WriteLine("Copied \"" + wstConfig.srcDir + "\" to \"" + wstConfig.dstDir + "\".");
            }

            //  If the database has specific files for the environment specified, copies those
            //  files into the correct location.
            wstConfig.dataDir = wstConfig.dstDir + "\\dml\\data\\";
            wstConfig.envDir = Path.Combine(wstConfig.dataDir, wstConfig.environment);

            if (Directory.Exists(wstConfig.envDir))
            {             
               DirectoryInfo envDirInfo = new DirectoryInfo(wstConfig.envDir);

               foreach (FileInfo fileInfo in envDirInfo.GetFiles("*.sql"))
                {             
                    CopyFile(fileInfo.FullName, Path.Combine(wstConfig.dataDir, fileInfo.Name), true);
                    Console.WriteLine("Copied SQL file from \"" + fileInfo.FullName + "\" to \"" + wstConfig.dataDir + "\".");
                }
     
            }

            //  Copy SetupLauncher.exe
            wstConfig.srcFile = wstConfig.buildRoot + "\\" + "tools\\SetupLauncher.exe";
            wstConfig.dstFile = wstConfig.dstDir + "\\" + "SetupLauncher.exe";

            if (File.Exists(wstConfig.srcFile))
            {
                if (!Directory.Exists(wstConfig.dstDir))
                {
                    //destination directory is not available, attempt to create it
                    try
                    {
                        Directory.CreateDirectory(wstConfig.dstDir);
                    }
                    catch (Exception e)
                    {
                        Console.WriteLine("FAILED to create directory -> " + wstConfig.dstDir + " with error -> " + e.ToString());
                        return false;
                    }
                }
                CopyFile(wstConfig.srcFile, wstConfig.dstFile, true);
                Console.WriteLine("Copied SetupLauncher.exe.");
            }
            else
            {
                Console.WriteLine("File \"" + wstConfig.srcFile + "\" not found.  Deployment cannot continue.");
                return false;
            }

            //  Copy TokenReplacer.exe
            wstConfig.srcFile = wstConfig.buildRoot + "\\" + "tools\\TokenReplacer.exe";
            wstConfig.dstFile = wstConfig.dstDir + "\\" + "TokenReplacer.exe";

            if (File.Exists(wstConfig.srcFile))
            {

                CopyFile(wstConfig.srcFile, wstConfig.dstFile, true);
                Console.WriteLine("Copied TokenReplacer.exe.");
            }
            else
            {
                Console.WriteLine("File \"" + wstConfig.srcFile + "\" not found.  Deployment cannot continue.");
                return false;
            }

            //  Copy utils.dll
            wstConfig.srcFile = wstConfig.buildRoot + "\\" + "tools\\utils.dll";
            wstConfig.dstFile = wstConfig.dstDir + "\\" + "utils.dll";

            if (File.Exists(wstConfig.srcFile))
            {
                CopyFile(wstConfig.srcFile, wstConfig.dstFile, true);
                Console.WriteLine("Copied utils.dll.");
            }
            else
            {
                Console.WriteLine("File \"" + wstConfig.srcFile + "\" not found.  Deployment cannot continue.");
                return false;
            }

            //  Copy XblConfig.dll
            wstConfig.srcFile = wstConfig.buildRoot + "\\" + "tools\\XblConfig.dll";
            wstConfig.dstFile = wstConfig.dstDir + "\\" + "XblConfig.dll";

            if (File.Exists(wstConfig.srcFile))
            {
                CopyFile(wstConfig.srcFile, wstConfig.dstFile, true);
                Console.WriteLine("Copied XblConfig.dll.");
            }
            else
            {
                Console.WriteLine("File \"" + wstConfig.srcFile + "\" not found.  Deployment cannot continue.");
                return false;
            }

            //  Copy confnpdb.exe
            wstConfig.srcFile = wstConfig.buildRoot + "\\tools\\confnpdb.exe";
            wstConfig.dstFile = wstConfig.dstDir + "\\confnpdb.exe";

            if (File.Exists(wstConfig.srcFile))
            {
                CopyFile(wstConfig.srcFile, wstConfig.dstFile, true);
                Console.WriteLine("Copied confnpdb.exe.");
            }
            else
            {
                Console.WriteLine("File \"" + wstConfig.srcFile + "\" not found.  Deployment cannot continue.");
                return false;
            }

            //  Copy xonline.tools.confnpdb.common.dll
            wstConfig.srcFile = wstConfig.buildRoot + "\\" + "tools\\xonline.tools.confnpdb.common.dll";
            wstConfig.dstFile = wstConfig.dstDir + "\\" + "xonline.tools.confnpdb.common.dll";

            if (File.Exists(wstConfig.srcFile))
            {
                CopyFile(wstConfig.srcFile, wstConfig.dstFile, true);
                Console.WriteLine("Copied xonline.tools.confnpdb.common.dll.");
            }
            else
            {
                Console.WriteLine("File \"" + wstConfig.srcFile + "\" not found.  Deployment cannot continue.");
                return false;
            }

            Console.WriteLine();

            //  Set NPDB reg key
            string appLine = wstConfig.dstDir + "\\confnpdb.exe";
            string cmdLine = " register-npdb " + wstConfig.npdbServer + " " + wstConfig.npdbDatabase;

            if (!DoExec(appLine, cmdLine))
            {
                return false;
            }

            //  If this is XBLOB, we need to do token-replacement.
            //  Copy over the relevant tools to get this done.
            if (wstConfig.environment.ToLower() == "xblob" && Directory.Exists(wstConfig.dataDir))
            {
                //  Generate tokens file
                Console.WriteLine("Generating token file.");

                appLine = wstConfig.dstDir + "\\SetupLauncher.exe";
                cmdLine = " /Command GetNetworkInfo" + " SERVER=" + wstConfig.computerName + " OUTPUTFILE=" + wstConfig.databaseName + "_tokens.txt";

                if (!DoExec(appLine, cmdLine))
                {
                    return false;
                }

                //  Token-replace _gen_data.sql and _gen_data_delete.sql.
                //  Token-replace all .sql files in the data directory.

                Console.WriteLine("Token-replacing sql data files.");

                string[] fileList = Directory.GetFiles(wstConfig.dataDir, "*.sql");
                appLine = wstConfig.dstDir + "\\TokenReplacer.exe";

                if (fileList.Length > 0)
                {
                    foreach (string sFile in fileList)
                    {
                        Console.WriteLine("Token-replacing " + sFile);

                        cmdLine = " /inputFile \"" + sFile + "\"" +
                                    " /outputFile \"" + sFile + "\"" +
                                    " /tokenFile " + wstConfig.databaseName + "_tokens.txt" +
                                    " #XBLOB_MACHINE#=" + wstConfig.computerName +
                                    " #XBLOB_USER_FQDN#=" + wstConfig.userAccount +
                                    " #XBLOB_ADMIN_FQDN#=" + wstConfig.adminAccount +
                                    " #XBLOB_USER#=" + wstConfig.userAccount.Split('\\')[1] +
                                    " #XBLOB_ADMIN#=" + wstConfig.adminAccount.Split('\\')[1] +
                                    " \"#XBLOB_WEBROOT#=" + wstConfig.webRootDir + "\"" +
                                    " \"#XBLOB_LOGROOT#=" + wstConfig.logRootDir + "\"" +
                                    " \"#XBLOB_DBROOT#=" + wstConfig.dataFilesDir + "\"" +
                                    " \"#XBLOB_DB_ROOT#=" + wstConfig.dataFilesDir + "\"";

                        if (!DoExec(appLine, cmdLine))
                        {
                            return false;
                        }
                    }

                }
                else
                {
                    Console.WriteLine("No SQL files found to do Token-replacing on \"" + wstConfig.dataDir + "\".");
                }
            }

            //  Check to see if there's a deployment file that we should be using.
            //  We should have already obtained the deployment file from calling get
            wstConfig.srcFile = wstConfig.srcDir + "\\deployment_" + wstConfig.environment + ".xml";
            wstConfig.setAction = WstRunner.SetupAction.Install;

            if (File.Exists(wstConfig.srcFile))
            {
                wstConfig.dstFile = wstConfig.dstDir + "\\deployment.xml";
                CopyFile(wstConfig.srcFile, wstConfig.dstFile, true);

                //Catalog has deployment files with Token
                if (wstConfig.environment.ToLower() == "xblob")
                {
                    appLine = wstConfig.dstDir + "\\TokenReplacer.exe";
                    cmdLine = " /inputFile " + "\"" + wstConfig.dstDir + "\\deployment.xml\"" + " /outputFile " + "\"" +
                              wstConfig.dstDir + "\\deployment.xml\"" + " #XBLOB_MACHINE#=" + wstConfig.computerName +
                              " #XBLOB_USER#=" + wstConfig.userAccount + " #SQLDATADIR#=" + wstConfig.dataFilesDir +
                              " #SQLLOGDIR#=" + wstConfig.logFilesDir;

                    Console.WriteLine(appLine + cmdLine);

                    if (!DoExec(appLine, cmdLine))
                    {
                        return false;
                    }
                }

                action = WstRunnerAction.Setup;

                // OLD Call
                //cmdLine = "\"" + dstDir + "\\WstRunner.exe\" /setup" +
                //          " /M \"" + dstDir + "\\" + manifestPath + "\"" +
                //          " /D \"" + dstDir + "\\deployment.xml\"";
            }
            else
            {
                string accountRoleMap = null;

                if (wstConfig.accountRoleMap != null && wstConfig.accountRoleMap != "")
                {
                    accountRoleMap = wstConfig.accountRoleMap;
                }
                else
                {
                    accountRoleMap = wstConfig.userAccount + "=ClientLib";
                }

                action = WstRunnerAction.Setup;

                // OLD Call
                //cmdLine = "\"" + dstDir + "\\WstRunner.exe\" /setup" +
                //         " /M \"" + dstDir + "\\" + manifestPath + "\"" +
                //         " /V \"dataFilePath=" + namedArgs.Item("dataFilesDir") + "\"" +
                //         " /V \"logFilePath=" + namedArgs.Item("logFilesDir") + "\"" +
                //         " /V configServerList=" + network.ComputerName +
                //         " /V dataServerList=" + namedArgs.Item("dataServerList") +
                //         " /V accountRoleMap=" + accountRoleMap +
                //         " /V databaseName=" + namedArgs.Item("databaseName") +
                //         " /V partitionCount=" + namedArgs.Item("partitionCount");

            }

            if (wstConfig.failSafeSetsPerServer != 0)
            {
                // OLD Call
                //cmdLine = cmdLine + " /V failSafeSetsPerServer=" + namedArgs.Item("failSafeSetsPerServer");
            }

            if (wstConfig.upgradePath != "prodbase")
            {
                // OLD Call
                // cmdLine = cmdLine + "/upgrade";

                wstConfig.isUpgrade = true;
                wstConfig.setAction = WstRunner.SetupAction.Upgrade;
            }

            if (wstConfig.deployEnabled == "1")
            {
                Console.WriteLine("Commencing database deployment.\r\n");

                if (RunIt() != 0)
                {
                    Console.WriteLine("Database deployment failed.");
                    return false;
                }

                // OLD Call
                //if (DoExec(cmdLine) != 0)
                //{
                //    WriteLine("Database deployment failed.");

                //    if (fso.FileExists(resultsFileName))
                //    {
                //        var resultsFile = fso.GetFile(resultsFileName);
                //        resultsFile.Attributes = 0;
                //        fso.DeleteFile(resultsFileName);
                //    }
                //
                //    WScript.Quit(1);
                //}
                Console.WriteLine("Database deployment complete.");
            }
            else
            {
                Console.WriteLine("Deployment skipped.");
            }

            return true;
        }

        /// <summary>
        /// 
        /// </summary>
        /// <returns></returns>
        public bool PostProcessInstall()
        {
            Console.WriteLine("Running Post Install Steps.");          

            //  Copy SetupLauncher.exe
            wstConfig.srcFile = wstConfig.buildRoot + "\\" + "tools\\SetupLauncher.exe";
            wstConfig.dstFile = wstConfig.dstDir + "\\" + "SetupLauncher.exe";
            if (!File.Exists(wstConfig.dstFile))
            {
                if (File.Exists(wstConfig.srcFile))
                {
                    if (!Directory.Exists(wstConfig.dstDir))
                    {
                        //destination directory is not available, attempt to create it
                        try
                        {
                            Directory.CreateDirectory(wstConfig.dstDir);
                        }
                        catch (Exception e)
                        {
                            Console.WriteLine("FAILED to create directory -> " + wstConfig.dstDir + " with error -> " + e.ToString());
                            return false;
                        }
                    }

                    CopyFile(wstConfig.srcFile, wstConfig.dstFile, true);
                    Console.WriteLine("Copied SetupLauncher.exe.");
                }
                else
                {
                    Console.WriteLine("File \"" + wstConfig.srcFile + "\" not found.  Deployment cannot continue.");
                    return false;
                }
            }

            //
            //  Now we need to add the interface to NPDB
            //
            if (wstConfig.skipInterfaceConfig == "false")
            {
                Console.WriteLine("Configuring interface:");

                string appLine = wstConfig.dstDir + "\\setuplauncher.exe";
                string cmdLine = " /Command AddServerConfigFromDeploymentXml" +
                          " ENVIRONMENT=" + wstConfig.environment +
                          " INTERFACE=" + wstConfig.interfaceName +
                          " DEPLOYMENTXML=\"" + wstConfig.dstDir + "\\" + "deployment.xml" + "\"";

                if (!DoExec(appLine, cmdLine))
                {
                    Console.WriteLine("Adding server interface to NPDB failed.");

                    return false;
                }
            }
            else
            {
                Console.WriteLine("Skipping interface configuration.");
            }

            Console.WriteLine("Post process install complete.");

            return true;
        }

    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\wstrunner\console\WstRunnerDisableAndStopJob.cs ===
﻿//=======================================================================
// DisableAndStopJob portion of the wst runner command
//
// Parse DisableAndStopJob command params, run DisableAndStopJob processing
//=======================================================================

using System;
using System.Collections.Generic;
using System.IO;
using System.Xml;

using xonline.tools.wstrunner.core;

namespace xonline.tools.wstrunner.console
{

    public partial class WstRunnerCmd
    {
        /// <summary>
        /// Handles parsing of the command line arguments for DisableAndStopJobs
        /// </summary>
        /// <param name="args">The arguments to process.</param>
        public bool ParseDisableAndStopJobCommandLine(string[] args)
        {
            int numberOfArgs = args.Length;
            string currentArg;

            for (int currentArgIndex = 2; currentArgIndex < numberOfArgs; currentArgIndex++)
            {
                currentArg = args[currentArgIndex];

                if (String.Compare(currentArg, "/buildRoot", true) == 0)
                {   //REQUIRED
                    VerifyParameter(currentArg, currentArgIndex, numberOfArgs);
                    wstConfig.buildRoot = args[++currentArgIndex];
                }
                else if (String.Compare(currentArg, "/webRootDir", true) == 0)
                {   //REQUIRED
                    VerifyParameter(currentArg, currentArgIndex, numberOfArgs);
                    wstConfig.webRootDir = args[++currentArgIndex];
                }
                else if (String.Compare(currentArg, "/installDir", true) == 0)
                {   //REQUIRED
                    VerifyParameter(currentArg, currentArgIndex, numberOfArgs);
                    wstConfig.installDir = args[++currentArgIndex];
                }
                else if (String.Compare(currentArg, "/sqlJobName", true) == 0)
                {   //REQUIRED
                    VerifyParameter(currentArg, currentArgIndex, numberOfArgs);
                    wstConfig.sqlJobName = args[++currentArgIndex];
                }

            }

            //Output the name arguments
            Console.WriteLine("buildRoot=            '" + wstConfig.buildRoot + "'");
            Console.WriteLine("webRootDir=           '" + wstConfig.webRootDir + "'");
            Console.WriteLine("installDir=           '" + wstConfig.installDir + "'");
            Console.WriteLine("sqlJobName=           '" + wstConfig.sqlJobName + "'");
            Console.WriteLine();

            //check if we have all the required params
            if (wstConfig.buildRoot == null
                || wstConfig.webRootDir == null
                || wstConfig.installDir == null
                || wstConfig.sqlJobName == null)
            {
                Console.WriteLine("ERROR: Required parameters for Install are missing.");
                Console.WriteLine("Type \"WstRunner /?\" for usage help.");
                return false;
            }

            return true;
        }


        /// <summary>
        /// Process the command parameter data
        /// </summary>
        /// <returns></returns>
        public bool ProcessDisableAndStopJob()
        {
            wstConfig.dstDir = wstConfig.webRootDir + "\\" + wstConfig.installDir;

            if (!Directory.Exists(wstConfig.dstDir))
            {
                Console.WriteLine("Directory \"" + wstConfig.dstDir + "\" does not exist, uninstall is not necessary.");
                return true;
            }

            //Copy over DisableJobs.sql file.
            string srcFile = wstConfig.buildRoot + "\\database\\DisableAndStopJob.sql";
            string dstFile = wstConfig.dstDir + "\\DisbleAndStopJob.sql";

            if (File.Exists(srcFile))
            {
                if (CopyFile(srcFile, dstFile, true))
                {
                    Console.WriteLine("Copied DisableAndStopJob script");
                }
                else
                {
                    Console.WriteLine("Copied of DisableAndStopJob failed from -> " + srcFile + " to -> " + dstFile);
                    return false;
                }
            }
            else
            {
                Console.WriteLine("File \"" + srcFile + "\" not found. Uinstall cannot continue.");
                return false;
            }

            // Disable the sql jobs so that they do not start or will not restart after being stopped
            // Stop any sql jobs that are running.
            string appLine = "sqlcmd";
            string cmdLine = " -S (local) -b -i \"" + dstFile + "\" -v SqlJobName=" + wstConfig.sqlJobName;

            if (!DoExec(appLine, cmdLine))
            {
                Console.WriteLine("ERROR failed to execute DisableAndStopJob script.");
                return false;
            }

            Console.WriteLine("Disabled and stopped sql job " + wstConfig.sqlJobName);

            return true;
        }
    }

}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\wstrunner\console\WstRunnerCmd.cs ===
/*******************************************************************
 *    FILE:         WstRunnerCmd.cs
 *
 *    DESCRIPTION:  WstRunner.exe console code.
 *
 *    OWNER:        darrenan
 *
 *    HISTORY:      11-8-2007   - Created 
 *
 *    Copyright <cp> 2008 Microsoft Corporation.  All Rights Reserved.
 *******************************************************************/

using System;
using System.Collections.Generic;
using System.IO;
using System.Xml;
using System.Diagnostics;

using xonline.tools.wstrunner.core;
using System.Runtime.InteropServices;
using System.ComponentModel;

namespace xonline.tools.wstrunner.console
{
    public class WstRunnerException : Exception
    {
        public WstRunnerException() : base() { }
        public WstRunnerException(string message) : base(message) { }
        public WstRunnerException(string message, Exception innerException) : base(message, innerException) { }        
    }

	/// <summary>
	/// Provides a command line interface to the core WstRunner functionality.
	/// </summary>
	public partial class WstRunnerCmd
	{
        private enum WstRunnerAction
        {
            None,
            Help,
            Setup,
            Drop,
            MarkNeedsRepair,
            Repair
        }

        private WstRunnerAction action = WstRunnerAction.None;
        private IWstRunnerFactory wstRunnerFactory = new WstRunnerFactory();
	    private IDeploymentFileFactory deploymentFactory = new DeploymentFileFactory();
        private IOracleFactory oracleFactory = new WebstoreOracleFactory();
        private readonly Dictionary<string, string> properties = new Dictionary<string, string>();
        private static readonly Log _log = Log.GetInstance();
        private WstRunnerConfig wstConfig = new WstRunnerConfig();

		/// <summary>
		/// The main entry point for the application.
		/// </summary>
		[MTAThread]
		static int Main(string[] args)
		{
            // Fix for backslash escapes on double quotes
            string commandLine = Environment.CommandLine;
            
            // Replace \" with \\"
            commandLine = commandLine.Replace("\\\"", "\\\\\"");

            // Split string and put back into args array
            string[] splittedArgs = SplitArgs(commandLine);
            args = new string[splittedArgs.Length - 1];
            Array.Copy(splittedArgs, 1, args, 0, args.Length);

            _log.Verbosity = LogLevel.Verbose;
		    _log.OnMessage += loggingEventHandler;
            WstRunnerCmd theCmd = new WstRunnerCmd();

            if (!theCmd.ParseCommandLine(args))
            {
                return 1;
            }

            return 0;
        }

        #region Properties

        public IWstRunnerFactory WstRunnerFactory
        {
            set { wstRunnerFactory = value; }
        }

        public IDeploymentFileFactory DeploymentFactory
        {
            set { deploymentFactory = value; }
        }

        #endregion

        #region Methods
    
        /// <summary>
        /// Handles parsing of the command line arguments, setting member variables 
        /// based on the options and arguments specified.
        /// </summary>
        /// <param name="args">The arguments to process.</param>
        public bool ParseCommandLine(string[] args)
        {
            bool result = false;

            try
            {
                Console.WriteLine();
                Console.WriteLine("WstRunner started processing at " + DateTime.Now);

                int numberOfArgs = args.Length;

                //First argument must be the /job param
                string currentArg = args[0];
                if (String.Compare(currentArg, "/job", true) == 0)
                {
                    VerifyParameter(currentArg, 0, args.Length);
                    wstConfig.jobType = args[1];
                }
                else
                {
                    if (String.Compare(currentArg, "/?", true) == 0)
                    {
                        RunHelp();
                        return true;
                    }
                    else
                    {
                        Console.WriteLine("ERROR: /job is required for first parameter.");
                        Console.WriteLine("Type \"WstRunner /?\" for usage help.");
                    }
                    return false;
                }


                //Job types are install, uninstall, ProdRestorePrep, DisableAndStopJob
                switch (wstConfig.jobType)
                {
                    case "install":
                        {
                            result = ParseInstallCommandLine(args);
                            if (result)
                            {
                                result = ProcessInstall();
                            }
                            if (result)
                            {
                                result = PostProcessInstall();
                            }

                        } break;

                    case "uninstall":
                        {
                            result = ParseUninstallCommandLine(args);
                            if (result)
                            {
                                result = ProcessUnInstall();
                            }
                        } break;

                    case "ProdRestorePrep":
                        {
                            result = ParseProdRestorePrepCommandLine(args);
                            if (result)
                            {
                                result = ProcessProdRestorePrep();
                            }
                        } break;

                    case "DisableAndStopJob":
                        {
                            result = ParseDisableAndStopJobCommandLine(args);
                            if (result)
                            {
                                result = ProcessDisableAndStopJob();
                            }
                        } break;

                    default:
                        {
                            Console.WriteLine("ERROR: A valid job type is required.");
                            Console.WriteLine("Type \"WstRunner /?\" for usage help.");
                        } break;
                }
            }
            catch (WstRunnerException)
            {
                result = false;
            }

            return result;
        }

        private static void VerifyParameter(string currentArg, int currentArgIndex, int numberOfArgs)
        {
            if (currentArgIndex + 1 >= numberOfArgs)
            {
                Console.WriteLine("ERROR: Option " + currentArg + " requires a value to be specified.");
                Console.WriteLine("Type \"WstRunner /?\" for usage help.");
                throw new WstRunnerException();
            }
        }

        /// <summary>
        /// Displays information about this program and its command line agruments. 
        /// </summary>
        public void ShowUsageInfo()
        {
            //                |----+----+----+----+----+----+----+----+----+----+----+----+----+----+----+----+
            Console.WriteLine("WstRunner /job install ");
            Console.WriteLine("WstRunner /job uninstall ");
            Console.WriteLine("WstRunner /job ProdRestorePrep ");
            Console.WriteLine("WstRunner /job DisableAndStopJob ");
            Console.WriteLine();
            Console.WriteLine("Description:");
            Console.WriteLine("    Installs or uninstalls the webstore application defined by the manifest");
            Console.WriteLine("    file.");
            Console.WriteLine("    All files needed for the deployment are assumed to be in the same");
            Console.WriteLine("    directory as the manifest file.  If the manifestFile does not contain");
            Console.WriteLine("    directory information, then the current directory will be used.");
            Console.WriteLine();
            Console.WriteLine("Parameter List:");
            Console.WriteLine("     [install]");
            Console.WriteLine("         /buildRoot     [required]   [Location of the build to install]");
            Console.WriteLine("         /webRootDir    [required]   [Root directory of the installation.]");
            Console.WriteLine("         /installDir    [required]   [Root directory for this component.]");
            Console.WriteLine("         /environment   [required]   [Environment being installed to.]");
            Console.WriteLine("         /databaseName  [required]   [Database being installed.]");
            Console.WriteLine("         /upgradePath   [required]   [Is this a database upgrade operation?]");
            Console.WriteLine("         /deployEnabled [required]   [Should webstore deployment occur?]");
            Console.WriteLine("         /npdbServer    [required]   [Name of NPDB server.]");
            Console.WriteLine("         /npdbDatabase  [required]   [Name of NPDB database.]");
            Console.WriteLine("         /logRootDir                 [Application log files directory. (XBLOB)]");
            Console.WriteLine("         /userAccount                [User Account.]");
            Console.WriteLine("         /adminAccount               [Admin Account.]");
            Console.WriteLine("         /dataFilesDir               [Database data files directory.]");
            Console.WriteLine("         /logFilesDir                [Database log files directory.]");
            Console.WriteLine("         /dataServerList             [Semi-colon separated list of database servers.]");
            Console.WriteLine("         /partitionCount             [Number of logical partitions.]");
            Console.WriteLine("         /failSafeSetsPerServer      [Number of fail safe sets to create on each physical server.  Default is 1.]");
            Console.WriteLine("         /accountRoleMap             [Account to role mappings.  If not provided, defaults to 'userAccount=ClientLib']");
            Console.WriteLine("         /skipInterfaceConfig        [Pass in 'true' if you don't want interface configuration to happen.]");
            Console.WriteLine("         /interfaceName              [Pass in the interface name to be configured]");
            Console.WriteLine("         /manifestPath               [Pass in the name of the webstore manifest file]");
            Console.WriteLine("         /rollingUpgrade             [Is this a rolling upgrade or not?]");
            Console.WriteLine();
            Console.WriteLine("     [uninstall]");
            Console.WriteLine("         /webRootDir    [required]   [Root directory of the installation.]");
            Console.WriteLine("         /installDir    [required]   [Root directory for this component.]");
            Console.WriteLine("         /upgradePath   [required]   [Is this a database upgrade operation?]");
            Console.WriteLine("         /databaseName  [required]   [Database being installed.]");
            Console.WriteLine("         /environment   [required]   [Environment being installed to.]");
            Console.WriteLine("         /skipInterfaceConfig        [Pass in 'true' if you don't want interface configuration to happen.]");
            Console.WriteLine("         /deployEnabled [required]   [Should webstore deployment occur?]");
            Console.WriteLine("         /interfaceName              [Pass in the interface name to be configured]");
            Console.WriteLine("         /manifestPath               [Pass in the name of the webstore manifest file]");
            Console.WriteLine();
            Console.WriteLine("     [ProdRestorePrep]");
            Console.WriteLine("         /buildRoot     [required]   [Location of the build to install]");
            Console.WriteLine("         /webRootDir    [required]   [Root directory of the installation.]");
            Console.WriteLine("         /installDir    [required]   [Root directory for this component.]");
            Console.WriteLine("         /environment   [required]   [Environment being installed to.]");
            Console.WriteLine("         /databaseName  [required]   [Database being installed.]");
            Console.WriteLine("         /upgradePath   [required]   [Is this a database upgrade operation?]");
            Console.WriteLine("         /bakFile       [required]   [Back up file location.]");
            Console.WriteLine("         /userAccount   [required]   [User Account.]");
            Console.WriteLine("         /prodPath      [required]   [Foler name for the Prodbase.]");
            Console.WriteLine("         /manifestPath               [Pass in the name of the webstore manifest file]");
            Console.WriteLine();
            Console.WriteLine("     [DisableAndStopJob]");
            Console.WriteLine("         /webRootDir    [required]   [Root directory of the installation.]");
            Console.WriteLine("         /installDir    [required]   [Root directory for this component.]");
            Console.WriteLine("         /buildRoot     [required]   [Location of the build to install]");
            Console.WriteLine("         /sqlJobName    [required]   [The name of the sql job to disable and stop.]");
            Console.WriteLine();
            Console.WriteLine("Examples:");
            Console.WriteLine("    WstRunner /job install /buildRoot [SourceLocation] /webRootDir [Webroot]");             
            Console.WriteLine("              /installDir npdb_upgrade /databaseName npdb /environment xblob /upgradePath upgrade /userAccount [userAccount]"); 
            Console.WriteLine("              /adminAccount [adminAccount] /dataFilesDir [SqlDataDir] /logFilesDir [logFileDir]"); 
            Console.WriteLine("              /dataServerList HXXBLOBLKG001 /partitionCount 24 /deployEnabled 1 /npdbServer [computerName] /npdbDatabase npdb"); 
            Console.WriteLine("              /logRootDir [logRootDir] /skipInterfaceConfig true");
            Console.WriteLine();
            //                |----+----+----+----+----+----+----+----+----+----+----+----+----+----+----+----+
        }

        /// <summary>
        /// Creates a WstRunnerStep object, configuring it based on the command line arguments,
        /// and executes it. 
        /// </summary>
        /// <returns>
        /// The errorlevel value that should be returned to the cmd environment.
        /// Returns 0 on success, 2 on failure. 
        ///</returns>
        public int RunIt()
        {
            Console.WriteLine();
            Console.WriteLine("WstRunner started processing at " + DateTime.Now);

            switch(action)
            {
                case WstRunnerAction.Setup:
                    return RunSetup();

                case WstRunnerAction.Drop:
                    return RunDrop();

                case WstRunnerAction.MarkNeedsRepair:
                    return MarkNeedsRepair();


                case WstRunnerAction.Repair:
                    return Repair();

                default:
                    return RunHelp();
            }
        }

        private int Repair()
        {
            FileInfo manifestFileInfo = new FileInfo(Path.Combine(wstConfig.dstDir, wstConfig.manifestPath));
            FileInfo deploymentFileInfo = new FileInfo(Path.Combine(wstConfig.dstDir, wstConfig.deploymentFilename));

            Console.WriteLine("     Manifest File = \"" + manifestFileInfo.FullName + "\"");
            Console.WriteLine("     Deployment File = \"" + deploymentFileInfo.FullName + "\"");
            Console.WriteLine();

            string workingPath;

            if (manifestFileInfo.DirectoryName.Length != 0 && Directory.Exists(manifestFileInfo.DirectoryName))
            {
                workingPath = manifestFileInfo.DirectoryName;
            }
            else if (deploymentFileInfo.DirectoryName.Length != 0 &&
                     Directory.Exists(deploymentFileInfo.DirectoryName))
            {
                workingPath = deploymentFileInfo.DirectoryName;
            }
            else
            {
                workingPath = Environment.CurrentDirectory;
            }

            IWstRunner runner = wstRunnerFactory.CreateInstance(
                    workingPath,
                    manifestFileInfo.Name,
                    deploymentFileInfo.Name);
            try
            {

                runner.RepairwithOnlinePromote();
            }

            catch (Exception e)
            {
                Console.WriteLine();
                Console.WriteLine();
                Console.WriteLine("ERROR: Exception encountered executing WstRunner. - " + e.Message);
                Console.WriteLine();
                Console.WriteLine();
                Console.WriteLine(e.ToString());
                Console.WriteLine();

                return 2;
            }
                Console.WriteLine();
                Console.WriteLine("WstRunner processing of '" + wstConfig.manifestPath + "' completed at " + DateTime.Now);
                Console.WriteLine();
                return 0;
            
        }
        /// <summary>
        /// Marks the databases as Needsrepair starting from secondary to primary
        /// </summary>
        /// <returns></returns>
        private int MarkNeedsRepair()
        {
            FileInfo manifestFileInfo = new FileInfo(Path.Combine(wstConfig.dstDir, wstConfig.manifestPath));
            FileInfo deploymentFileInfo = new FileInfo(Path.Combine(wstConfig.dstDir, wstConfig.deploymentFilename));

            Console.WriteLine("     Manifest File = \"" + manifestFileInfo.FullName + "\"");
            Console.WriteLine("     Deployment File = \"" + deploymentFileInfo.FullName + "\"");
            Console.WriteLine();

            string workingPath;

            if (manifestFileInfo.DirectoryName.Length != 0 && Directory.Exists(manifestFileInfo.DirectoryName))
            {
                workingPath = manifestFileInfo.DirectoryName;
            }
            else if (deploymentFileInfo.DirectoryName.Length != 0 &&
                     Directory.Exists(deploymentFileInfo.DirectoryName))
            {
                workingPath = deploymentFileInfo.DirectoryName;
            }
            else
            {
                workingPath = Environment.CurrentDirectory;
            }
            

            IWstRunner runner = wstRunnerFactory.CreateInstance(
                    workingPath,
                    manifestFileInfo.Name,
                    deploymentFileInfo.Name);

            try
            {
                runner.MarkNeedsRepair();
            }

            catch (Exception e)
            {
                Console.WriteLine();
                Console.WriteLine();
                Console.WriteLine("ERROR: Exception encountered executing WstRunner. - " + e.Message);
                Console.WriteLine();
                Console.WriteLine();
                Console.WriteLine(e.ToString());
                Console.WriteLine();

                return 2;
            }
           
                Console.WriteLine();
                Console.WriteLine("WstRunner processing of '" + wstConfig.manifestPath + "' completed at " + DateTime.Now);
                Console.WriteLine();
                return 0;
        }

        private int RunSetup()
        {
            string workingPath;
            FileInfo manifestFileInfo;
            FileInfo deploymentFileInfo;

            if (wstConfig.manifestPath == null || wstConfig.manifestPath.Length == 0)
            {
                Console.WriteLine("Manifest file name was not provided.  Exiting.");
                return 2;
            }

            manifestFileInfo = new FileInfo(Path.Combine(wstConfig.srcDir, wstConfig.manifestPath));
            Console.WriteLine("     Manifest File = \"" + wstConfig.manifestPath + "\"");

            if (wstConfig.deploymentFilename == null || wstConfig.deploymentFilename.Length == 0)
            {
                wstConfig.deploymentFilename = Path.Combine(Path.GetDirectoryName(wstConfig.dstDir + "\\" + wstConfig.databaseName), "deployment.xml");
            }
            Console.WriteLine("     Deployment File = \"" + wstConfig.deploymentFilename + "\"");

            deploymentFileInfo = new FileInfo(wstConfig.deploymentFilename);

            if (!deploymentFileInfo.Exists)
            {

                if (wstConfig.environment.ToLower() == "xblob")
                {
                    Console.WriteLine("    Deployment File for xblob environment does not exist, auto-generating it now.");

                    deploymentFileInfo = deploymentFactory.CreateDeployment(
                        manifestFileInfo,
                        deploymentFileInfo.FullName,
                        wstConfig.dataFilesDir,          //properties["dataFilePath"],
                        wstConfig.logFilesDir,           //properties["logFilePath"],
                        wstConfig.computerName,          //properties["configServerList"],
                        wstConfig.dataServerList,        //properties["dataServerList"],
                        wstConfig.failSafeSetsPerServer, //properties.ContainsKey("failSafeSetsPerServer") ? UInt32.Parse(properties["failSafeSetsPerServer"]) : 1,
                        wstConfig.accountRoleMap,        //properties["accountRoleMap"],
                        wstConfig.partitionCount,        //UInt32.Parse(properties["partitionCount"]),
                        wstConfig.databaseName);         //properties["databaseName"]);
                }

                if (deploymentFileInfo == null || !deploymentFileInfo.Exists)
                {
                    Console.WriteLine("Deployment File does not exist.  Exiting.");
                    return 2;
                }
            }

            //we need to get the manifest into the same directory as the deployment file
            //so that the working path for both files is the same
            if (manifestFileInfo.Exists)
            {
                if (!File.Exists(deploymentFileInfo.DirectoryName + "\\" + manifestFileInfo.Name))
                {
                    //CopyFile(manifestFileInfo.FullName, Path.Combine(deploymentFileInfo.DirectoryName, manifestFileInfo.Name));
                    Console.WriteLine("Manifest file did not get copied to -> " + deploymentFileInfo.DirectoryName + "\\" + manifestFileInfo.Name);
                    return 2;
                }
            }

            workingPath = deploymentFileInfo.DirectoryName;

            try
            {
                IWstRunner runner = wstRunnerFactory.CreateInstance(
                    workingPath,
                    manifestFileInfo.Name,
                    deploymentFileInfo.Name);

                runner.Setup(wstConfig.setAction, wstConfig.isRollingUpgrade, wstConfig.replTearDown);
            }
            catch (Exception e)
            {
                Console.WriteLine();
                Console.WriteLine();
                Console.WriteLine("ERROR: Exception encountered executing WstRunner. - " + e.Message);
                Console.WriteLine();
                Console.WriteLine();
                Console.WriteLine(e.ToString());
                Console.WriteLine();

                return 2;
            }

            Console.WriteLine();
            Console.WriteLine("WstRunner processing of '" + wstConfig.manifestPath + "' completed at " + DateTime.Now);
            Console.WriteLine();
            return 0;
        }

        private int RunDrop()
        {
            try
            {
                Console.WriteLine("     Manifest File = \"" + wstConfig.manifestPath + "\"");
                Console.WriteLine("     Deployment File = \"" + wstConfig.deploymentFilename + "\"");
                Console.WriteLine();

                FileInfo manifestFileInfo = new FileInfo(wstConfig.manifestPath);

                if (wstConfig.deploymentFilename == null)
                {
                    wstConfig.deploymentFilename = "deployment.xml";
                }

                FileInfo deploymentFileInfo = new FileInfo(wstConfig.deploymentFilename);
                string workingPath;

                if (manifestFileInfo.DirectoryName.Length != 0 && Directory.Exists(manifestFileInfo.DirectoryName))
                {
                    workingPath = manifestFileInfo.DirectoryName;
                }
                else if (deploymentFileInfo.DirectoryName.Length != 0 &&
                         Directory.Exists(deploymentFileInfo.DirectoryName))
                {
                    workingPath = deploymentFileInfo.DirectoryName;
                }
                else
                {
                    workingPath = Environment.CurrentDirectory;
                }

                IWstRunner runner = wstRunnerFactory.CreateInstance(
                    workingPath,
                    manifestFileInfo.Name,
                    deploymentFileInfo.Name);

                if (wstConfig.upgradePath != "prodbase")
                {
                    wstConfig.isUpgrade = true;
                }
                else
                {
                    wstConfig.isUpgrade = false;
                }

                runner.Remove(!wstConfig.isUpgrade);
            }
            catch(Exception e)
            {
                Console.WriteLine();
                Console.WriteLine();
                Console.WriteLine("ERROR: Exception encountered executing WstRunner. - " + e.Message);
                Console.WriteLine();
                Console.WriteLine();
                Console.WriteLine(e.ToString());
                return 2;
            }

            Console.WriteLine();
            Console.WriteLine("WstRunner processing completed at " + DateTime.Now);
            Console.WriteLine();
            return 0;
        }

        private int RunHelp()
        {
            ShowUsageInfo();
            return 0;
        }

        /// <summary>
        /// Event handler for WstRunnerStep's Message event which writes the message to the console.
        /// </summary>
        /// <param name="sender">The WstRunnerStep generating the event.</param>
        /// <param name="e">The MessageEventArgs sent by the event.</param>
        public static void loggingEventHandler(object sender, LoggingEventArgs e)
        {
            if(e == null)
                return;

            Console.WriteLine(e.Message);
        }

        /// <summary>
        /// Returns a list of the versions of the fail safe sets for the specified deployment
        /// </summary>
        /// <param name="deploymentName">The list of fail safe set version numbers or null if deploymentName references a non-existent deployment</param>
        /// <returns></returns>
        public WstRunnerConfig.WSTVersion GetVersionOfInProgressDeployment(string deploymentName)
        {            
            IOracle oracle = oracleFactory.CreateInstanceWithoutRefresh();
            if (!oracle.IsDeploymentImported(deploymentName))
                return null;

            WstRunnerConfig.WSTVersion returnVersion = null;

            string outputFile = Path.GetTempFileName();
            FileInfo deploymentStatusFileInfo = oracle.ExportDeploymentStatus(deploymentName, outputFile, false);

            if (deploymentStatusFileInfo != null && deploymentStatusFileInfo.Exists)
            {
                XmlDocument xmlDep = new XmlDocument();

                xmlDep.Load(deploymentStatusFileInfo.FullName);

                XmlNode manifestVersionNode = xmlDep.SelectSingleNode("Webstore/DeploymentStatus/Deployment/@ManifestVersion");
                if (manifestVersionNode != null)
                {
                    bool allVersionsConsistent = true;
                    XmlNodeList failSafeSetVersionNodes = xmlDep.SelectNodes("Webstore/DeploymentStatus/Deployment/SqlFailSafeSets/SqlFailSafeSet/@ManifestVersion");
                    foreach (XmlNode versionNode in failSafeSetVersionNodes)
                    {
                        if (versionNode.Value != manifestVersionNode.Value)
                            allVersionsConsistent = false;
                    }

                    if (!allVersionsConsistent) 
                    {
                        //format as version
                        string[] verComp = manifestVersionNode.Value.Split('.');

                        if (verComp.Length != 4)
                        {
                            Console.WriteLine("Fail Safe Version string \"" + manifestVersionNode.InnerText + "\" does not have four components.  Version strings must be in the form major.minor.build.dot.");
                        }
                        returnVersion = new WstRunnerConfig.WSTVersion();
                        returnVersion.major = Convert.ToInt32(verComp[0]);
                        returnVersion.minor = Convert.ToInt32(verComp[1]);
                        returnVersion.build = Convert.ToInt32(verComp[2]);
                        returnVersion.dot = Convert.ToInt32(verComp[3]);
                        returnVersion.strVersion = manifestVersionNode.Value;
                    }
                }
            }

            return returnVersion;
        }

        public WstRunnerConfig.WSTVersion GetVersionFromManifest(string manifestFileName)
        {
            XmlDocument xmlDoc = new XmlDocument();

            if (!File.Exists(manifestFileName))
            {
                Console.WriteLine("ERROR manifest file ->" + manifestFileName + " not found");
                return null;
            }

            xmlDoc.Load(manifestFileName);

            XmlNodeList nList = xmlDoc.GetElementsByTagName("Version");
            WstRunnerConfig.WSTVersion manifestVersion = null;
            if (nList.Count > 0)
            {
                //format as version
                string[] verComponents = nList[0].InnerText.Split('.');

                if (verComponents.Length != 4)
                {
                    Console.WriteLine("Manifest Version string \"" + nList[0].InnerText + "\" does not have four components.  Version strings must be in the form major.minor.build.dot.");
                    return null;
                }

                manifestVersion = new WstRunnerConfig.WSTVersion();

                manifestVersion.major = Convert.ToInt32(verComponents[0]);
                manifestVersion.minor = Convert.ToInt32(verComponents[1]);
                manifestVersion.build = Convert.ToInt32(verComponents[2]);
                manifestVersion.dot   = Convert.ToInt32(verComponents[3]);
                manifestVersion.strVersion = nList[0].InnerText;
            }

            return manifestVersion;
        }

        public WstRunnerConfig.WSTVersion GetVersionFromDeployment(string deploymentName)
        {
            IOracle oracle = oracleFactory.CreateInstanceWithoutRefresh();

            if (!oracle.IsDeploymentImported(deploymentName))
                return null;

            string deploymentVersionString = oracle.GetVersionForDeployment(deploymentName);
            string[] verComponents = oracle.GetVersionForDeployment(deploymentName).Split('.');

            if (verComponents.Length != 4)
            {
                Console.WriteLine("Deployment Version string \"" + deploymentVersionString + "\" does not have four components.  Version strings must be in the form major.minor.build.dot.");
                return null;
            }

            WstRunnerConfig.WSTVersion deploymentVersion = new WstRunnerConfig.WSTVersion();

            deploymentVersion.major = Convert.ToInt32(verComponents[0]);
            deploymentVersion.minor = Convert.ToInt32(verComponents[1]);
            deploymentVersion.build = Convert.ToInt32(verComponents[2]);
            deploymentVersion.dot = Convert.ToInt32(verComponents[3]);
            deploymentVersion.strVersion = deploymentVersionString;

            return deploymentVersion;
        }

        /// <summary>
        /// For shelling out and running external programs
        /// </summary>
        /// <param name="appLine"></param>
        /// <param name="cmdLine"></param>
        /// <returns></returns>
        public bool DoExec(string appLine, string cmdLine)
        {
            appLine = appLine.Trim();

            Console.WriteLine(appLine + cmdLine);
            Console.WriteLine();

            try
            {
                ProcessStartInfo startInfo = new ProcessStartInfo(appLine, cmdLine);
                startInfo.UseShellExecute = true;

                using (Process exeProcess = Process.Start(startInfo))
                {
                    exeProcess.WaitForExit();
                }
            }
            catch (System.IO.FileNotFoundException e)
            {
                Console.WriteLine("ERROR file not found -> " + appLine + " e -> " + e.Message.ToString());
                return false;
            }
            catch (Exception e)
            {
                Console.WriteLine("ERROR trying to execute -> " + appLine + " with these params -> " + cmdLine);
                Console.WriteLine(e.ToString());
                return false;
            }

            return true;
        }

        public bool CopyFile(string src, string dst)
        {
            return CopyFile(src, dst, false);
        }

        public bool CopyFile(string src, string dst, bool overWrite)
        {
            try
            {
                if (!Directory.Exists(dst))
                    Directory.CreateDirectory(Path.GetDirectoryName(dst));

                File.Copy(src, dst, overWrite);
            }
            catch (Exception e)
            {
                Console.WriteLine("Failed to copy \"" + src + "\" to \"" + dst + "\". Exception = \"" + e.Message.ToString() + "\".");
                throw new WstRunnerException();
            }

            return true;
        }

        public bool CopyDirectories(string src, string dst, bool overwrite)
        {
            try
            {
                if (!Directory.Exists(dst))
                {
                    Directory.CreateDirectory(dst);
                }

                string[] files = Directory.GetFiles(src);

                foreach (string file in files)
                {
                    string name = Path.GetFileName(file);
                    string dest = Path.Combine(dst, name);
                    File.Copy(file, dest, overwrite);
                }
                string[] folders = Directory.GetDirectories(src);

                foreach (string folder in folders)
                {
                    string name = Path.GetFileName(folder);
                    string dest = Path.Combine(dst, name);
                    CopyDirectories(folder, dest, overwrite);
                }
            }
            catch (Exception e)
            {
                Console.WriteLine("Failed to copy \"" + src + "\" to \"" + dst + "\". Exception = \"" + e.Message.ToString() + "\".");
                return false;
            }

            return true;
        }

        /// <summary>
        /// Iterate through a directory and remove all read only
        /// and hidden attributes
        /// </summary>
        /// <param name="dir"></param>
        public void SetFileAttributesNormal(DirectoryInfo dir)
        {
            // Remove flags from the current directory
            dir.Attributes = FileAttributes.Normal;

            // Remove flags from all files in the current directory
            foreach (FileInfo file in dir.GetFiles())
            {
                file.Attributes = FileAttributes.Normal;
            }

            // Do the same for all subdirectories
            foreach (DirectoryInfo subDir in dir.GetDirectories())
            {
                SetFileAttributesNormal(subDir);
            }
        }


        /// <summary>
        /// This function return -1, 0, or 1 depending
        /// on the two versions.  0 means they are equal.
        /// </summary>
        /// <param name="version1"></param>
        /// <param name="version2"></param>
        /// <returns></returns>
        public int compare(WstRunnerConfig.WSTVersion version1, WstRunnerConfig.WSTVersion version2)
        {
            if (version1.major < version2.major) return -1;
            if (version1.major > version2.major) return 1;
            if (version1.minor < version2.minor) return -1;
            if (version1.minor > version2.minor) return 1;
            if (version1.build < version2.build) return -1;
            if (version1.build > version2.build) return 1;
            if (version1.dot < version2.dot) return -1;
            if (version1.dot > version2.dot) return 1;
            return 0;    
        }

        static string[] SplitArgs(string unsplitArgumentLine)
        {
            int numberOfArgs;
            IntPtr ptrToSplitArgs;
            string[] splitArgs;

            ptrToSplitArgs = CommandLineToArgvW(unsplitArgumentLine, out numberOfArgs);

            // CommandLineToArgvW returns NULL upon failure.
            if (ptrToSplitArgs == IntPtr.Zero)
                throw new ArgumentException("Unable to split argument.", new Win32Exception());

            // Make sure the memory ptrToSplitArgs to is freed, even upon failure.
            try
            {
                splitArgs = new string[numberOfArgs];

                // ptrToSplitArgs is an array of pointers to null terminated Unicode strings.
                // Copy each of these strings into our split argument array.
                for (int i = 0; i < numberOfArgs; i++)
                    splitArgs[i] = Marshal.PtrToStringUni(
                        Marshal.ReadIntPtr(ptrToSplitArgs, i * IntPtr.Size));

                return splitArgs;
            }
            finally
            {
                // Free memory obtained by CommandLineToArgW.
                LocalFree(ptrToSplitArgs);
            }
        }

        [DllImport("shell32.dll", SetLastError = true)]
        static extern IntPtr CommandLineToArgvW(
           [MarshalAs(UnmanagedType.LPWStr)] string lpCmdLine,
           out int pNumArgs);

        [DllImport("kernel32.dll")]
        static extern IntPtr LocalFree(IntPtr hMem);

        #endregion

        #region Properties

	    public string ManifestFileName
	    {
            get { return wstConfig.manifestPath; }
	    }

	    public string DeploymentFileName
	    {
            get { return wstConfig.deploymentFilename; }
	    }

	    public IDictionary<string,string> Properties
	    {
	        get { return properties; }
	    }
        #endregion
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\wstrunner\console\exe\objd\i386\_generated.cs ===
[assembly:System.Runtime.InteropServices.ComVisible(false)]
[assembly:System.Reflection.AssemblyVersion("12.4.56.0")]
[assembly:System.Reflection.AssemblyProduct("DEPOT")]
[assembly:System.Reflection.AssemblyCopyright("")]
[assembly:System.Reflection.AssemblyCompany("")]
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\wsmonitor\wsmUnit\Properties\AssemblyInfo.cs ===
﻿using System.Reflection;
using System.Runtime.CompilerServices;
using System.Runtime.InteropServices;

// General Information about an assembly is controlled through the following 
// set of attributes. Change these attribute values to modify the information
// associated with an assembly.
[assembly: AssemblyTitle("wsmUnit")]
[assembly: AssemblyDescription("")]
[assembly: AssemblyConfiguration("")]
[assembly: AssemblyCompany("Microsoft")]
[assembly: AssemblyProduct("wsmUnit")]
[assembly: AssemblyCopyright("Copyright © Microsoft 2007")]
[assembly: AssemblyTrademark("")]
[assembly: AssemblyCulture("")]

// Setting ComVisible to false makes the types in this assembly not visible 
// to COM components.  If you need to access a type in this assembly from 
// COM, set the ComVisible attribute to true on that type.
[assembly: ComVisible(false)]

// The following GUID is for the ID of the typelib if this project is exposed to COM
[assembly: Guid("65860072-3248-4ba6-acbc-bfea56f4f6de")]

// Version information for an assembly consists of the following four values:
//
//      Major Version
//      Minor Version 
//      Build Number
//      Revision
//
// You can specify all the values or you can default the Revision and Build Numbers 
// by using the '*' as shown below:
[assembly: AssemblyVersion("1.0.0.0")]
[assembly: AssemblyFileVersion("1.0.0.0")]
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\wstrunner\console\WstRunnerProdRestorePrep.cs ===
﻿//=======================================================================
// ProdRestorePrep portion of the wst runner command
//
// Parse ProdRestorePrep command params, run ProdRestorePrep processing
//=======================================================================

using System;
using System.Collections.Generic;
using System.IO;
using System.Xml;

using xonline.tools.wstrunner.core;

namespace xonline.tools.wstrunner.console
{

    public partial class WstRunnerCmd
    {
        /// <summary>
        /// Handles parsing of the command line arguments for ProdRestrorePrep
        /// </summary>
        /// <param name="args">The arguments to process.</param>
        public bool ParseProdRestorePrepCommandLine(string[] args)
        {
            int numberOfArgs = args.Length;
            string currentArg;

            for (int currentArgIndex = 2; currentArgIndex < numberOfArgs; currentArgIndex++)
            {
                currentArg = args[currentArgIndex];

                if (String.Compare(currentArg, "/buildRoot", true) == 0)
                {   //REQUIRED
                    VerifyParameter(currentArg, currentArgIndex, numberOfArgs);
                    wstConfig.buildRoot = args[++currentArgIndex];
                }
                else if (String.Compare(currentArg, "/webRootDir", true) == 0)
                {   //REQUIRED
                    VerifyParameter(currentArg, currentArgIndex, numberOfArgs);
                    wstConfig.webRootDir = args[++currentArgIndex];
                }
                else if (String.Compare(currentArg, "/installDir", true) == 0)
                {   //REQUIRED
                    VerifyParameter(currentArg, currentArgIndex, numberOfArgs);
                    wstConfig.installDir = args[++currentArgIndex];
                }
                else if (String.Compare(currentArg, "/environment", true) == 0)
                {   //REQUIRED
                    VerifyParameter(currentArg, currentArgIndex, numberOfArgs);
                    wstConfig.environment = args[++currentArgIndex];
                }
                else if (String.Compare(currentArg, "/databaseName", true) == 0)
                {   //REQUIRED
                    VerifyParameter(currentArg, currentArgIndex, numberOfArgs);
                    wstConfig.databaseName = args[++currentArgIndex];
                }
                else if (String.Compare(currentArg, "/upgradePath", true) == 0)
                {   //REQUIRED
                    VerifyParameter(currentArg, currentArgIndex, numberOfArgs);
                    wstConfig.upgradePath = args[++currentArgIndex];
                }
                else if (String.Compare(currentArg, "/bakFile", true) == 0)
                {   //REQUIRED
                    VerifyParameter(currentArg, currentArgIndex, numberOfArgs);
                    wstConfig.bakFile = args[++currentArgIndex];
                }
                else if (String.Compare(currentArg, "/userAccount", true) == 0)
                {   //REQUIRED
                    VerifyParameter(currentArg, currentArgIndex, numberOfArgs);
                    wstConfig.userAccount = args[++currentArgIndex];
                }
                else if (String.Compare(currentArg, "/prodPath", true) == 0)
                {   //REQURIED
                    VerifyParameter(currentArg, currentArgIndex, numberOfArgs);
                    wstConfig.prodPath = args[++currentArgIndex];
                }
                else if (String.Compare(currentArg, "/manifestPath", true) == 0)
                {
                    VerifyParameter(currentArg, currentArgIndex, numberOfArgs);
                    wstConfig.manifestPath = args[++currentArgIndex];
                }
            }

            //Output the name arguments
            Console.WriteLine("buildRoot=            '" + wstConfig.buildRoot + "'");
            Console.WriteLine("webRootDir=           '" + wstConfig.webRootDir + "'");
            Console.WriteLine("installDir=           '" + wstConfig.installDir + "'");
            Console.WriteLine("environment=          '" + wstConfig.environment + "'");
            Console.WriteLine("databaseName=         '" + wstConfig.databaseName + "'");
            Console.WriteLine("upgradePath=          '" + wstConfig.upgradePath + "'");
            Console.WriteLine("bakFile=              '" + wstConfig.bakFile + "'");
            Console.WriteLine("userAccount=          '" + wstConfig.userAccount + "'");
            Console.WriteLine("prodPath=             '" + wstConfig.prodPath + "'");
            Console.WriteLine("manifestPath=         '" + wstConfig.manifestPath + "'");
            Console.WriteLine();

            //check if we have all the required params
            if (wstConfig.buildRoot == null
                || wstConfig.webRootDir == null
                || wstConfig.installDir == null
                || wstConfig.environment == null
                || wstConfig.databaseName == null
                || wstConfig.upgradePath == null
                || wstConfig.bakFile == null
                || wstConfig.userAccount == null
                || wstConfig.prodPath == null)
            {
                Console.WriteLine("ERROR: Required parameters for Install are missing.");
                Console.WriteLine("Type \"WstRunner /?\" for usage help.");
                return false;
            }

            return true;
        }

        /// <summary>
        /// Process the command parameter data
        /// </summary>
        /// <returns></returns>
        public bool ProcessProdRestorePrep()
        {
            if (wstConfig.bakFile != "")
            {
                string appLine = null;
                string cmdLine = null;

                // BUG# 49649 - dstDir can be null.
                // This should be sanitized and use Path.Combine()
                string deploymentXml = wstConfig.dstDir + "deployment.xml";
                wstConfig.deploymentFilename = deploymentXml;

                if (!File.Exists(wstConfig.bakFile))
                {
                    Console.WriteLine("backup file " + wstConfig.bakFile + " is invalid/not present");
                    return false;
                }

                if (!Directory.Exists(wstConfig.buildRoot))
                {
                    Console.WriteLine("Folder \"" + wstConfig.buildRoot + "\" does not exist.");
                    return false;
                }

                if (wstConfig.manifestPath == null || wstConfig.manifestPath.Length == 0)
                {
                    wstConfig.manifestPath = "manifest.xml";
                }

                wstConfig.srcDir = wstConfig.buildRoot + "\\database\\" + wstConfig.upgradePath + "\\" + wstConfig.databaseName;
                wstConfig.prodPath = wstConfig.buildRoot + "\\database\\" + wstConfig.prodPath + "\\" + wstConfig.databaseName;
                wstConfig.dstDir = wstConfig.webRootDir + "\\" + wstConfig.installDir;

                wstConfig.upgradeInstallDir = wstConfig.webRootDir + "\\" + wstConfig.databaseName + "_" + wstConfig.upgradePath;

                if (!Directory.Exists(wstConfig.dstDir))
                {
                    Directory.CreateDirectory(wstConfig.dstDir);
                }

                WstRunnerConfig.WSTVersion upgradeVersion = GetVersionFromManifest(wstConfig.srcDir + "\\" + wstConfig.manifestPath);

                string reason = null;

                InstallPolicy installCheck = ShouldInstallDatabaseAtVersion(wstConfig.databaseName, upgradeVersion, out reason);

                if (installCheck != InstallPolicy.OKToInstall)
                {
                    Console.WriteLine("Upgrade not performed -> " + reason);

                    //Broke the previous install
                    if (installCheck == InstallPolicy.DoNotInstall)
                        return false;

                    return true;
                }

                //  Copy utils.dll
                string srcFile = wstConfig.buildRoot + "\\" + "tools\\utils.dll";
                string dstFile = wstConfig.dstDir + "\\utils.dll";

                if (File.Exists(srcFile))
                {
                    if (CopyFile(srcFile, dstFile, true))
                    {
                        Console.WriteLine("Copied utils.dll.");
                    }
                    else
                    {
                        Console.WriteLine("Failed to copy utils.dll.");
                        return false;
                    }
                }
                else
                {
                    Console.WriteLine("File \"" + srcFile + "\" not found. Deployment cannot continue.");
                    return false;
                }

                srcFile = wstConfig.buildRoot + "\\tools\\TokenReplacer.exe";
                dstFile = wstConfig.dstDir + "\\TokenReplacer.exe";

                if (File.Exists(srcFile))
                {
                    if (CopyFile(srcFile, dstFile, true))
                    {
                        Console.WriteLine("Copied TokenReplacer.exe.");
                    }
                    else
                    {
                        Console.WriteLine("Failed to copy TokenReplacer.exe.");
                        return false;
                    }
                }
                else
                {
                    Console.WriteLine("File \"" + srcFile + "\" not found. Deployment cannot continue.");
                    return false;
                }

                wstConfig.installVersion = GetVersionFromManifest(wstConfig.srcDir + "\\" + wstConfig.manifestPath);

                if (wstConfig.installVersion == null)
                {
                    Console.WriteLine("ERROR unable to determine manifest version.");
                    return false;
                }

                // if same or higher version number then skip upgrade
                if (wstConfig.manifestVersion != null && wstConfig.failSafeVersion != null)
                {
                    if (compare(wstConfig.failSafeVersion, wstConfig.manifestVersion) > 0)
                    {
                        Console.WriteLine("upgraded to same or higher version, skipping pre-upgrade.");
                        Console.WriteLine("\tExisting version = " + wstConfig.failSafeVersion.strVersion);
                        Console.WriteLine("\tInstall version  = " + wstConfig.manifestVersion.strVersion);
                        return false;
                    }
                }                

                //Take down the database to offline state(closes any existing connections)
                appLine = "sqlcmd";
                cmdLine = " -S (local) -Q " + "\"" + "ALTER DATABASE  " + wstConfig.databaseName + " SET OFFLINE WITH ROLLBACK IMMEDIATE" + "\"" + " -E";
                Console.WriteLine(appLine + cmdLine);

                if (!DoExec(appLine, cmdLine))
                {
                    Console.WriteLine("Taking down the database to offline failed to execute.");
                    return false;
                }

                //Restore from backup
                cmdLine = " -S (local) -Q " + "\"" + "RESTORE DATABASE " + wstConfig.databaseName + " FROM DISK = '" + wstConfig.bakFile + "' with REPLACE\"" + "  -b";
                Console.WriteLine(appLine + cmdLine);

                if (!DoExec(appLine, cmdLine))
                {
                    Console.WriteLine("Restore from backup did not execute.");
                    return false;
                }

                //Bring the database online
                cmdLine = " -S (local) -Q " + "\"" + "ALTER DATABASE " + wstConfig.databaseName + " SET ONLINE WITH ROLLBACK IMMEDIATE" + "\"" + " -E";
                Console.WriteLine(appLine + cmdLine);

                if (!DoExec(appLine, cmdLine))
                {
                    Console.WriteLine("Failed to execute bringing database back online.");
                    return false;
                }

                //#BUG 50402 - should no longer set the compatibility mode of the database
                //Set the Compatibility Mode to sql 2008
                //cmdLine = " -S (local) -Q " + "\"" + "ALTER DATABASE " + wstConfig.databaseName + " SET COMPATIBILITY_LEVEL=100" + "\"" + " -E";
                //Console.WriteLine(appLine + cmdLine);

                //if (!DoExec(appLine, cmdLine))
                //{
                //    Console.WriteLine("Failed to execute setting of compatibility mode.");
                //    return false;
                //}

            }
            else
            {
                Console.WriteLine("No Backup File specified");
            }

            return true;
        }
    }

}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\wstrunner\core\Containers.cs ===
/*******************************************************************
 *    FILE:         Containers.cs
 *
 *    DESCRIPTION:  
 *
 *    OWNER:        gamagev
 *
 *    HISTORY:      04/08/2004      gamagev    Created
 *
 *    Copyright <cp> 2004 Microsoft Corporation.  All Rights Reserved.
 ********************************************************************
 */

namespace xonline.tools.wstrunner.core
{        
    public enum ServiceRoles 
    {
        wstadmin,
        wstclientlib,
        wstoperator
    }

    public enum RolePermissions 
    {
        Select,
        Insert,
        Delete,
        Update,
        Execute
    }

    public enum SetupStep
    {
        BeforeTables,
        Tables,
        AfterTables,
        Views,
        AfterViews,
        StoredProcedures,
        AfterStoredProcedures,
        SecurityRoles,
        Final
    }

    public enum ArticleCommands
    {
        Insert,
        Update,
        Delete
    }

    public enum WstSecondaryType
    {
        NoSecondaries,
        SingleMaster,
        MultiMaster,
        LogShipping,
        WriteAllCopies
    }

    public enum WstPartitionType
    {
        None,
        Variable,
        Fixed
    }

    public class Database
    {
        private readonly string _server;
        private readonly string _name;
        private readonly bool _primary;
        private readonly string _status;
        private readonly bool _hasSecondary;
        private readonly bool _isDefaultPrimary;

        public Database(string name, string server, bool primary, string status, bool hasSecondary,bool isDefaultPriamry)
        {
            _name = name;
            _server = server;
            _primary = primary;
            _status = status;
            _hasSecondary = hasSecondary;
            _isDefaultPrimary = isDefaultPriamry;
        }

        public string Name{ get { return _name; } } 
        public string Server{ get { return _server; } }
        public bool Primary{ get { return _primary; } } 
        public string Status{ get {return _status; } }
        public bool HasSecondary{ get { return _hasSecondary; } } 
        public bool IsDefaultPrimary{get {return _isDefaultPrimary;}}
    }        
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\wstrunner\core\Account.cs ===
/*******************************************************************
 *    FILE:         Account.cs
 *
 *    DESCRIPTION:  
 *
 *    OWNER:        gamagev
 *
 *    HISTORY:      01/29/2005      gamagev    Created
 *
 *    Copyright <cp> 2004 Microsoft Corporation.  All Rights Reserved.
 ********************************************************************
 */
using System;
using Microsoft.Webstore.Management.Wmo;

namespace xonline.tools.wstrunner.core
{
    /// <summary>
    /// Summary description for Accounts.
    /// </summary>
    public abstract class Account : IComparable
    {
        protected string  _account;
        
        public string Name { get { return _account; } }

        public abstract void Persist();        

        public abstract int CompareTo(object obj);

        protected Log log = Log.GetInstance();
    }

    public class ConfigAccount : Account
    {
        protected ServiceRoles _role;

        public ConfigAccount(string account, ServiceRoles role)
        {
            _account = account;
            _role = role;
        }


        /// <summary>
        /// Adds this account to the WstConfig Server with the given role
        /// </summary>
        public override void Persist()
        {
            log.WriteLine("Adding account:'{0}', role:'{1}' to config server...",
                _account, Enum.GetName(typeof(ServiceRoles), _role));

            WmoCommandEnvironment wstEnvironment = new WmoCommandEnvironment();

            wstEnvironment.UserName = _account;
            wstEnvironment.SecurityRole = Enum.GetName(typeof(ServiceRoles), _role);
            
            wstEnvironment.AddAccount();
            
            log.WriteLine("Done!");
        }

        public override int CompareTo(object obj)
        {
            if(obj is ConfigAccount)
            {
                ConfigAccount account = (ConfigAccount)obj;

                int strCompare = string.Compare(_account, account._account, true);

                if ( strCompare != 0 )
                    return strCompare;

                if ( _role != account._role)
                    return -1;

                return 0;
            }

            throw new ArgumentException("object is not a ConfigAccount object");
        }
    }

    public class ApplicationAccount : Account
    {
        protected string _deploymentName;
        protected string _role;

        public ApplicationAccount(string account, string role, string deploymentName)
        {
            _account = account;
            _role = role;
            _deploymentName = deploymentName;
        }

        /// <summary>
        /// Adds this account to the deployment with the given role
        /// </summary>
        public override void Persist()
        {
            log.WriteLine("Adding account:{0} role:'{1}' to deployment:{2}...",
                _account, _role, _deploymentName);

            WmoCommandDeployment wstDeployment = new WmoCommandDeployment();
            
            wstDeployment.UserName = _account;
            wstDeployment.SecurityRole = _role;
            wstDeployment.DeploymentName = _deploymentName;

            wstDeployment.AddAccount();
            
            log.WriteLine("Done!");
        }

        public override int CompareTo(object obj)
        {
            if(obj is ApplicationAccount)
            {
                ApplicationAccount account = (ApplicationAccount)obj;

                int strCompare = string.Compare(_account, account._account, true);

                if ( strCompare != 0 )
                    return strCompare;

                strCompare = string.Compare(_role, account._role, true);

                if ( strCompare != 0)
                    return strCompare;

                strCompare = string.Compare(_deploymentName, account._deploymentName, true);

                if ( strCompare != 0)
                    return strCompare;

                return 0;
            }

            throw new ArgumentException("object is not a ConfigAccount object");
        }

        public string Role
        {
            get { return _role; }
        }
    }

}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\wstrunner\console\WstRunnerUninstall.cs ===
﻿//====================================================
// Uninstall portion of the wst runner command
//
// Parse uninstall command params, run uninstall processing
//=====================================================

using System;
using System.Collections.Generic;
using System.IO;
using System.Xml;

using xonline.tools.wstrunner.core;

namespace xonline.tools.wstrunner.console
{

    public partial class WstRunnerCmd
    {
        /// <summary>
        /// Handles parsing of the command line arguments for uninstall
        /// </summary>
        /// <param name="args">The arguments to process.</param>
        public bool ParseUninstallCommandLine(string[] args)
        {
            int numberOfArgs = args.Length;
            string currentArg;

            for (int currentArgIndex = 2; currentArgIndex < numberOfArgs; currentArgIndex++)
            {
                currentArg = args[currentArgIndex];

                if (String.Compare(currentArg, "/webRootDir", true) == 0)
                {   //REQUIRED
                    VerifyParameter(currentArg, currentArgIndex, numberOfArgs);
                    wstConfig.webRootDir = args[++currentArgIndex];
                }
                else if (String.Compare(currentArg, "/installDir", true) == 0)
                {   //REQUIRED
                    VerifyParameter(currentArg, currentArgIndex, numberOfArgs);
                    wstConfig.installDir = args[++currentArgIndex];
                }
                else if (String.Compare(currentArg, "/upgradePath", true) == 0)
                {   //REQUIRED
                    VerifyParameter(currentArg, currentArgIndex, numberOfArgs);
                    wstConfig.upgradePath = args[++currentArgIndex];
                }
                else if (String.Compare(currentArg, "/databaseName", true) == 0)
                {   //REQUIRED
                    VerifyParameter(currentArg, currentArgIndex, numberOfArgs);
                    wstConfig.databaseName = args[++currentArgIndex];
                }
                else if (String.Compare(currentArg, "/environment", true) == 0)
                {   //REQUIRED
                    VerifyParameter(currentArg, currentArgIndex, numberOfArgs);
                    wstConfig.environment = args[++currentArgIndex];
                }
                else if (String.Compare(currentArg, "/deployEnabled", true) == 0)
                {   //REQUIRED
                    VerifyParameter(currentArg, currentArgIndex, numberOfArgs);
                    wstConfig.deployEnabled = args[++currentArgIndex];
                }
                else if (String.Compare(currentArg, "/computerName", true) == 0)
                {   
                    VerifyParameter(currentArg, currentArgIndex, numberOfArgs);
                    wstConfig.computerName = args[++currentArgIndex];
                }
                else if (String.Compare(currentArg, "/skipInterfaceConfig", true) == 0)
                {
                    VerifyParameter(currentArg, currentArgIndex, numberOfArgs);
                    wstConfig.skipInterfaceConfig = args[++currentArgIndex];
                }
                else if (String.Compare(currentArg, "/interfaceName", true) == 0)
                {
                    VerifyParameter(currentArg, currentArgIndex, numberOfArgs);
                    wstConfig.interfaceName = args[++currentArgIndex];
                }
                else if (String.Compare(currentArg, "/manifestPath", true) == 0)
                {
                    VerifyParameter(currentArg, currentArgIndex, numberOfArgs);
                    wstConfig.manifestPath = args[++currentArgIndex];
                }
            }

            //Output the name arguments
            Console.WriteLine("webRootDir=           '" + wstConfig.webRootDir + "'");
            Console.WriteLine("installDir=           '" + wstConfig.installDir + "'");
            Console.WriteLine("environment=          '" + wstConfig.environment + "'");
            Console.WriteLine("databaseName=         '" + wstConfig.databaseName + "'");
            Console.WriteLine("upgradePath=          '" + wstConfig.upgradePath + "'");
            Console.WriteLine("deployEnabled=        '" + wstConfig.deployEnabled + "'");
            Console.WriteLine("skipInterfaceConfig=  '" + wstConfig.skipInterfaceConfig + "'");
            Console.WriteLine("interfaceName=        '" + wstConfig.interfaceName + "'");
            // NEW parameter
            Console.WriteLine("computerName=         '" + wstConfig.computerName + "'");  
            Console.WriteLine();

            //check if we have all the required params
            if (wstConfig.webRootDir == null
                || wstConfig.installDir == null
                || wstConfig.upgradePath == null
                || wstConfig.databaseName == null
                || wstConfig.environment == null
                || wstConfig.deployEnabled == null)
            {
                Console.WriteLine("ERROR: Required parameters for UnInstall are missing.");
                Console.WriteLine("Type \"WstRunner /?\" for usage help.");
                return false;
            }

            if (wstConfig.computerName == null)
            {
                wstConfig.computerName = Environment.MachineName;
            }

            return true;
        }

        /// <summary>
        /// Process the command parameter data
        /// </summary>
        /// <returns></returns>
        public bool ProcessUnInstall()
        {
            wstConfig.upgradePath = wstConfig.upgradePath.ToLower();

            if (wstConfig.skipInterfaceConfig == null)
            {
                wstConfig.skipInterfaceConfig = "false";
            }

            if (wstConfig.interfaceName == null || wstConfig.interfaceName.Length == 0)
            {
                wstConfig.interfaceName = wstConfig.databaseName;
            }

            if (wstConfig.manifestPath == null || wstConfig.manifestPath.Length == 0)
            {
                wstConfig.manifestPath = "manifest.xml";
            }

            wstConfig.dstDir = wstConfig.webRootDir + "\\" + wstConfig.installDir;

            if (!Directory.Exists(wstConfig.dstDir))
            {
                Console.WriteLine("WARNING Folder \"" + wstConfig.dstDir + "\" does not exist.");
                //return true;
            }

            if (!UninstallDatabase())
            {
                return false;
            }

            return true;
        }

        public bool UninstallDatabase()
        {
            Console.WriteLine("Attempting to remove any existing deployment bits.");
            Console.WriteLine("Any existing database deployment will be dropped, and");
            Console.WriteLine("the installation folder will be removed.");

            string setupLauncherPath = wstConfig.dstDir + "\\setuplauncher.exe";
            string manifestXml = wstConfig.dstDir + "\\" + wstConfig.manifestPath;
            string deploymentXml = wstConfig.dstDir + "\\deployment.xml";
            string appLine = null;
            string cmdLine = null;

            if (!File.Exists(manifestXml))
            {
                Console.WriteLine("WARNING Uninstall manifest file does not exist ->" + manifestXml);
            }

            if (!File.Exists(deploymentXml))
            {
                Console.WriteLine("WARNING Uninstall deployment file does not exist ->" + deploymentXml);
            }

            if (File.Exists(manifestXml) && File.Exists(deploymentXml) && wstConfig.deployEnabled == "1")
            {
                Console.WriteLine("Commencing uninstall of " + wstConfig.databaseName + ".");
                Console.WriteLine();

                //Catalog has deployment files with Token and needs replacement
                if (wstConfig.environment.ToLower() == "xblob")
                {
                    appLine = wstConfig.dstDir + "\\TokenReplacer.exe";
                    cmdLine = " /inputFile " + "\"" + wstConfig.dstDir + "\\deployment.xml\"" + " /outputFile " + "\"" + wstConfig.dstDir + "\\deployment.xml\"" + " #XBLOB_MACHINE#=" + wstConfig.computerName;

                    if (!DoExec(appLine, cmdLine))
                    {
                        return false;
                    }
                }
                //  In this case we should have a complete old copy, including tools.
                //  Let's try to rollback any existing database before we start.        
                action = WstRunnerAction.Drop;

                if (wstConfig.upgradePath != "prodbase")
                {
                    wstConfig.isUpgrade = true;
                }
                else
                {
                    wstConfig.isUpgrade = false;
                }

                wstConfig.manifestPath = manifestXml;
                wstConfig.deploymentFilename = deploymentXml;

                if (RunDrop() != 0)
                {
                    Console.WriteLine("Failed to uninstall database.");
                    return false;
                }
            }
            
            //  Remove the interface from npdb
            if (File.Exists(setupLauncherPath) &&
                File.Exists(deploymentXml) &&
                wstConfig.skipInterfaceConfig == "false" &&
                wstConfig.deployEnabled == "1")
            {
                appLine = wstConfig.dstDir + "\\SetupLauncher.exe";
                cmdLine = " /Command RemoveServerConfigFromDeploymentXml ENVIRONMENT=" + wstConfig.environment
                                                                                       + " INTERFACE=" + wstConfig.interfaceName
                                                                                       + " DEPLOYMENTXML=\"" + wstConfig.dstDir + "\\deployment.xml";
                if (!DoExec(appLine, cmdLine))
                {
                    Console.WriteLine("Failed to remove interface from npdb.");
                    return false;
                }
            }

            if (Directory.GetParent(wstConfig.dstDir).Exists)
            {
                if (Directory.Exists(wstConfig.dstDir))
                {
                    DirectoryInfo DirInfo = new DirectoryInfo(wstConfig.dstDir);

                    if (DirInfo.Exists)
                    {
                        //Clean up file attributes make sure read only is removed 
                        //so we can delete the directory
                        SetFileAttributesNormal(DirInfo);

                        Directory.Delete(wstConfig.dstDir, true);
                        Console.WriteLine("Removed folder \"" + wstConfig.dstDir + "\".");
                    }
                    else
                    {
                        Console.WriteLine("WARNING Directory -> " + wstConfig.dstDir + " did not exist, nothing to delete");
                    }
                }
                else
                {
                    Console.WriteLine("WARNING directory ->" + wstConfig.dstDir + " does not exist for removal");
                }
            }

            Console.WriteLine("uninstall complete.");

            return true;
        }

    }

}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\wstrunner\core\IDatabase.cs ===
/*******************************************************************
 *    FILE:         IDatabase.cs
 *
 *    DESCRIPTION:  IDatabase interface.
 *
 *    OWNER:        darrenan
 *
 *    HISTORY:      5-1-2008   - Created 
 *
 *    Copyright <cp> 2008 Microsoft Corporation.  All Rights Reserved.
 *******************************************************************/

namespace xonline.tools.wstrunner.core
{
    public interface IDatabase
    {
        // Properties
        string Server { get; set; }
        string Database { get; set; }

        // Methods
        void NeedsRepair();
        void Repair();
        void MarkOnline();
        void Promote();
        void Repair(bool isForce);

    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\wstrunner\core\Globals.cs ===
/*******************************************************************
 *    FILE:         Account.cs
 *
 *    DESCRIPTION:  
 *
 *    OWNER:        gamagev
 *
 *    HISTORY:      01/29/2005      gamagev    Created
 *
 *    Copyright <cp> 2004 Microsoft Corporation.  All Rights Reserved.
 ********************************************************************
 */

using System;
using System.Diagnostics;
using System.Reflection;
using System.IO;

namespace xonline.tools.wstrunner.core
{
    public enum Action
    {
        InvalidAction,
        Install,
        SmartInstall,
        ReplaceTags,
        Help
    }

    /// <summary>
    /// Summary description for Globals.
    /// </summary>
    internal class Globals
    {
        internal static readonly string kWebstoreManifestXmlNamespace = "urn:WebstoreManifestSchema.xsd";
        internal static readonly string kWebstoreDeploymentXmlNamespace = "urn:WebstoreDeploymentSchema.xsd";

        internal static readonly string kAppXSDFileName = "Applications.xsd";
        internal static readonly string kPassportXMLNamespace = "urn:DMP.BackendSetup";

        FileInfo _applicationFile;
        readonly FileInfo _executableLocation;
        Action _action;
        string _labName;
        string _appName; // Hold the application name such as DMP, UserTransactions
        bool _skipOfflineDBs;
        bool _syncManifestHashbuckets;
        Version _version;
		
        public Globals()
        {
            // initilize globals to default values
            _action = Action.InvalidAction;
            _skipOfflineDBs = false;
            _syncManifestHashbuckets = false;
            _appName = "DMP"; // defaults to DMP

            Process process = Process.GetCurrentProcess();
            _executableLocation = new FileInfo(process.MainModule.FileName);
        }

        class InternalGlobal
        {
            InternalGlobal()
            {
            }

            internal static readonly Globals instance = new Globals();
        }

        internal static Action Action
        {
            get
            {
                return InternalGlobal.instance._action;
            }

            set
            {
                if (InternalGlobal.instance._action != Action.InvalidAction)
                {
                    throw new ArgumentException("Applications is already set");
                }
                else
                    InternalGlobal.instance._action = value;
            }
        }

        internal static FileInfo ApplicationFile
        {
            get
            {
                return InternalGlobal.instance._applicationFile;
            }

            set 
            {
                InternalGlobal.instance._applicationFile = value;

                if (!InternalGlobal.instance._applicationFile.Exists)
                {
                    throw new FileNotFoundException("Can not find application xml at path " + InternalGlobal.instance._applicationFile.FullName);
                }
            }
        }

        internal static FileInfo ExecutableLocation
        {
            get { return InternalGlobal.instance._executableLocation;}            
        }

        internal static string LabName
        {
            get { return InternalGlobal.instance._labName; }
            set { InternalGlobal.instance._labName = value; }
        }

        internal static string AppName
        {
            get { return InternalGlobal.instance._appName; }
            set { InternalGlobal.instance._appName = value; }
        }

        internal static bool SkipOfflineDBs
        {
            get { return InternalGlobal.instance._skipOfflineDBs; }
            set { InternalGlobal.instance._skipOfflineDBs = value; }
        }

        internal static bool SyncManifestHashbuckets
        {
            get { return InternalGlobal.instance._syncManifestHashbuckets; }
            set { InternalGlobal.instance._syncManifestHashbuckets = value; }
        }
        
        internal static Version Version
        {
            get 
            { 
                if (InternalGlobal.instance._version == null)
                {
                    Assembly assembly = Assembly.GetCallingAssembly();
                    AssemblyName assemblyName = assembly.GetName();

                    InternalGlobal.instance._version = assemblyName.Version;             
                }
                
                return InternalGlobal.instance._version;
            }
        }

    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\wstrunner\core\IDatabaseTemplate.cs ===
/*******************************************************************
 *    FILE:         IDatabaseTemplate.cs
 *
 *    DESCRIPTION:  IDatabaseTemplate interface.
 *
 *    OWNER:        darrenan
 *
 *    HISTORY:      10-22-2007   - Created 
 *
 *    Copyright <cp> 2007 Microsoft Corporation.  All Rights Reserved.
 *******************************************************************/

namespace xonline.tools.wstrunner.core
{
    public interface IDatabaseTemplate
    {
        // Methods
        void Purge();
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\wstrunner\core\IDatabaseFactory.cs ===
/*******************************************************************
 *    FILE:         IDatabaseFactory.cs
 *
 *    DESCRIPTION:  IDatabaseFactory interface.
 *
 *    OWNER:        darrenan
 *
 *    HISTORY:      4-18-2008   - Created 
 *
 *    Copyright <cp> 2008 Microsoft Corporation.  All Rights Reserved.
 *******************************************************************/

namespace xonline.tools.wstrunner.core
{
    public interface IDatabaseFactory
    {
        // Methods
        BaseDatabase CreateInstance();
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\wstrunner\core\IDeployment.cs ===
/*******************************************************************
 *    FILE:         IDeployment.cs
 *
 *    DESCRIPTION:  IDeployment interface.
 *
 *    OWNER:        darrenan
 *
 *    HISTORY:      10-22-2007   - Created 
 *
 *    Copyright <cp> 2007 Microsoft Corporation.  All Rights Reserved.
 *******************************************************************/

namespace xonline.tools.wstrunner.core
{
    public interface IDeployment
    {
        // Properties
        string InXmlPath { get; set; }
        string DeploymentName { get; set; }
        bool IsForce { get; set; }
        bool IsRollingUpgrade { get; set; }
        bool IsReplTearDown { get; set; }
        string NewManifestVersion { get; set; }
        string OutXmlPath { get; set; }
        bool IsVerbose { get; set; }

        // Methods
        void Import();
        void Setup();
        void Upgrade();
        void UpdateVersion();
        void Drop();
        void Status();
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\wstrunner\core\IDatabaseTemplateFactory.cs ===
/*******************************************************************
 *    FILE:         IDatabaseTemplateFactory.cs
 *
 *    DESCRIPTION:  IDatabaseTemplateFactory interface.
 *
 *    OWNER:        darrenan
 *
 *    HISTORY:      4-18-2008   - Created 
 *
 *    Copyright <cp> 2008 Microsoft Corporation.  All Rights Reserved.
 *******************************************************************/

namespace xonline.tools.wstrunner.core
{
    public interface IDatabaseTemplateFactory
    {
        // Methods
        BaseDatabaseTemplate CreateInstance();
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\wstrunner\core\Deployment.cs ===
/*******************************************************************
 *    FILE:         Deployment.cs
 *
 *    DESCRIPTION:  
 *
 *    OWNER:        gamagev
 *
 *    HISTORY:      1/15/2003   - Created 
 *
 *    Copyright <cp> 2003 Microsoft Corporation.  All Rights Reserved.
 *******************************************************************/

using System;
using System.IO;
using System.Xml;
using System.Text;
using System.Collections.Generic;

using Microsoft.Webstore.MetaData;
using Microsoft.Webstore.WstClient;

namespace xonline.tools.wstrunner.core
{
    public class DeploymentFileFactory : IDeploymentFileFactory
    {
        private static readonly Log log = Log.GetInstance();
        private static IManifestFactory manifestFactory = new WmoManifestFactory();
        private static IOracleFactory oracleFactory = new WebstoreOracleFactory();

        public static IManifestFactory ManifestFactory
        {
            set { manifestFactory = value; }
        }

        public static IOracleFactory OracleFactory
        {
            set { oracleFactory = value; }
        }

        public FileInfo CreateDeployment(
            FileInfo manifestXml,
            string deploymentXmlFileName,
            string dataFilePath,
            string logFilePath,
            string configServers,
            string dataServers,
            uint failSafeSetsPerServer,
            string accountRoleMap,
            uint partitionCount,
            string databaseName
            )
        {
            Manifest manifest = new Manifest(
                manifestFactory.CreateInstance(),
                oracleFactory.CreateInstance(),
                manifestXml.FullName);

            List<string> configServerList = new List<string>(configServers.Split(';'));
            log.WriteLine("Configuration Servers:");
            foreach (string s in configServerList)
            {
                log.WriteLine("\t" + s);
            }

            List<string> dataServerList = new List<string>(dataServers.Split(';'));
            log.WriteLine("Data Servers:");
            foreach (string s in dataServerList)
            {
                log.WriteLine("\t" + s);
            }

            log.WriteLine("Account-Role Mappings:");
            string[] accountsSplit = accountRoleMap.Split(';');
            List<ApplicationAccount> accountList = new List<ApplicationAccount>();
            for (int currentAccount = 0; currentAccount < accountsSplit.Length; ++currentAccount)
            {
                string[] accountParts = accountsSplit[currentAccount].Split('=');
                log.WriteLine("\t{0}={1}", accountParts[0], accountParts[1]);
                accountList.Add(new ApplicationAccount(accountParts[0], accountParts[1], manifest.Name));
            }

            log.WriteLine("Generating new deployment file...");

            XmlDocument deploymentDoc = GetDeployment(
                manifest.Name,
                manifest.Version,
                dataFilePath,
                logFilePath,
                configServerList,
                dataServerList,
                failSafeSetsPerServer,
                accountList,
                partitionCount,
                databaseName
                );

            deploymentDoc.Save(deploymentXmlFileName);

            log.WriteLine("Done.");

            return new FileInfo(deploymentXmlFileName);
        }

        public static XmlDocument GetDeployment(
            string manifestName,
            string manifestVersion,
            string dataFilePath,
            string logFilePath,
            List<string> configServers,
            List<string> appServers,
            uint failSafeSetsPerServer,
            List<ApplicationAccount> accounts,
            uint partitionCount,
            string databaseName)
        {
            XmlDocument deploymentDoc = new XmlDocument();

            //  If this is an upgrade, and no deployment file is provided, we want to
            //  make sure to use the previously imported deployment file.
            try
            {
                FileInfo existingDeploymentFile = WebstoreOracle.GetInstance().ExportDeployment(manifestName);
                if (existingDeploymentFile != null && existingDeploymentFile.Exists)
                {
                    deploymentDoc.Load(existingDeploymentFile.FullName);
                    return deploymentDoc;
                }
            }
            catch (Exception e)
            {
                //  We'll log this exception, but it's likely just 'deployment not found'.
                log.WriteLine(e.ToString());
            }

            XmlNode workingNode;
            XmlNode scopeNode;
            XmlNamespaceManager manager;

            try
            {
                deploymentDoc.LoadXml(Resources.deployment_template);
                manager = new XmlNamespaceManager(deploymentDoc.NameTable);
                manager.AddNamespace("ws", "urn:WebstoreDeploymentSchema.xsd");

                // Distribution Database Template

                scopeNode =
                    deploymentDoc.SelectSingleNode(
                        "//ws:DatabaseTemplates/ws:DatabaseTemplate[@Name=\"#DISTRIBUTION_TEMPLATE_NAME#\"]", manager);
                ((XmlElement)scopeNode).SetAttribute("Name", databaseName + "DistributionDatabaseTemplate");

                workingNode =
                    scopeNode.SelectSingleNode(
                        "ws:DataFileGroups/ws:FileGroup[@Name=\"Primary\"]/ws:LogicalFiles/ws:LogicalFile[@Name=\"modeldist\"]/ws:Path/text()",
                        manager);
                workingNode.Value = Path.Combine(dataFilePath, databaseName + "Data");

                workingNode =
                    scopeNode.SelectSingleNode("ws:LogFile/ws:LogicalFile[@Name=\"modeldist_log\"]/ws:Path/text()", manager);
                workingNode.Value = Path.Combine(logFilePath, databaseName + "Data");

                // Database Template

                scopeNode = deploymentDoc.SelectSingleNode("//ws:DatabaseTemplates/ws:DatabaseTemplate[@Name=\"#DATABASE_TEMPLATE_NAME#\"]", manager);
                ((XmlElement)scopeNode).SetAttribute("Name", databaseName + "DatabaseTemplate");

                workingNode = scopeNode.SelectSingleNode("ws:DataFileGroups/ws:FileGroup[@Name=\"Primary\"]/ws:LogicalFiles/ws:LogicalFile[@Name=\"DataFile\"]/ws:Path/text()", manager);
                workingNode.Value = Path.Combine(dataFilePath, databaseName + "Data");

                workingNode = scopeNode.SelectSingleNode("ws:LogFile/ws:LogicalFile[@Name=\"LogFile\"]/ws:Path/text()", manager);
                workingNode.Value = Path.Combine(logFilePath, databaseName + "Data");

                workingNode = scopeNode.SelectSingleNode("ws:Stripes/ws:Stripe/ws:Directory/text()", manager);
                workingNode.Value = Path.Combine(dataFilePath, "BAK");

                // Config Servers

                scopeNode = deploymentDoc.SelectSingleNode("//ws:Servers", manager);

                foreach (string appServer in appServers)
                {
                    XmlDocument serverDoc = new XmlDocument();
                    serverDoc.LoadXml(Resources.server);

                    XmlNode serverNode = scopeNode.AppendChild(deploymentDoc.ImportNode(serverDoc.DocumentElement, true));
                    ((XmlElement)serverNode).SetAttribute("Name", appServer);

                    workingNode = serverNode.SelectSingleNode("ws:DistributionDatabaseTemplate", manager);
                    ((XmlElement)workingNode).SetAttribute("Name", databaseName + "DistributionDatabaseTemplate");

                    workingNode = serverNode.SelectSingleNode("ws:ServerRoles/ws:ServerRole/text()", manager);
                    foreach (string configServer in configServers)
                    {
                        if (configServer == appServer)
                        {
                            workingNode.Value = "WstConfigServerRole";
                        }
                    }

                    if (workingNode.Value == "#SERVER_ROLE#")
                    {
                        workingNode.Value = "WstAppServerRole";
                    }
                }

                // Deployment Details

                scopeNode = deploymentDoc.SelectSingleNode("//ws:Deployment", manager);
                ((XmlElement)scopeNode).SetAttribute("Name", databaseName);

                workingNode = scopeNode.SelectSingleNode("ws:UseManifest/ws:ManifestName/text()", manager);
                workingNode.Value = manifestName;

                workingNode = scopeNode.SelectSingleNode("ws:UseManifest/ws:ManifestVersion/text()", manager);
                workingNode.Value = manifestVersion;

                // Accounts

                scopeNode = deploymentDoc.SelectSingleNode("//ws:Deployment/ws:DeploymentDefaults/ws:Accounts", manager);

                foreach (ApplicationAccount account in accounts)
                {
                    XmlDocument accountDoc = new XmlDocument();
                    accountDoc.LoadXml(Resources.account_template);

                    workingNode = scopeNode.AppendChild(deploymentDoc.ImportNode(accountDoc.DocumentElement, true));
                    ((XmlElement)workingNode).SetAttribute("Name", account.Name);

                    workingNode = workingNode.SelectSingleNode("ws:Role/text()", manager);
                    workingNode.Value = account.Role;
                }

                // SqlFailSafeSets

                scopeNode = deploymentDoc.SelectSingleNode("//ws:Deployment/ws:SqlFailSafeSets", manager);

                int currentFailSafeSet = 0;

                for (int currentAppServer = 0; currentAppServer < appServers.Count; ++currentAppServer)
                {
                    for (int currentServerFss = 0; currentServerFss < failSafeSetsPerServer; ++currentServerFss)
                    {
                        string currentDatabaseName = (failSafeSetsPerServer == 1) ? databaseName : string.Format("{0}{1}", databaseName, currentFailSafeSet.ToString("000"));

                        XmlDocument sqlFailSafeSetDoc = new XmlDocument();
                        sqlFailSafeSetDoc.LoadXml(Resources.sqlfailsafeset_template);

                        workingNode = scopeNode.AppendChild(deploymentDoc.ImportNode(sqlFailSafeSetDoc.DocumentElement, true));
                        ((XmlElement)workingNode).SetAttribute("Number", currentFailSafeSet.ToString());

                        workingNode = scopeNode.SelectSingleNode("ws:SqlFailSafeSet[@Number=\"" + currentFailSafeSet + "\"]/ws:DatabaseTemplate", manager);
                        ((XmlElement)workingNode).SetAttribute("Name", databaseName + "DatabaseTemplate");

                        XmlDocument databaseDoc = new XmlDocument();
                        XmlElement databaseElement;

                        workingNode = scopeNode.SelectSingleNode("ws:SqlFailSafeSet[@Number=\"" + currentFailSafeSet + "\"]/ws:Databases", manager);

                        // Primary Database
                        databaseDoc.LoadXml(Resources.database_template);
                        databaseElement = (XmlElement)workingNode.AppendChild(deploymentDoc.ImportNode(databaseDoc.DocumentElement, true));
                        databaseElement.SetAttribute("Name", currentDatabaseName);
                        databaseElement.SetAttribute("DataServer", appServers[currentAppServer]);

                        // Replica Database, no replica if there's only one database, webstore doesn't allow it.
                        if (appServers.Count > 1)
                        {
                            databaseDoc.LoadXml(Resources.database_template);
                            databaseElement =
                                (XmlElement)
                                workingNode.AppendChild(deploymentDoc.ImportNode(databaseDoc.DocumentElement, true));
                            databaseElement.SetAttribute("Name", currentDatabaseName + "Replica");
                            databaseElement.SetAttribute("DataServer", appServers[(currentAppServer + 1) % appServers.Count]);
                        }

                        // Default Primary Database
                        workingNode = scopeNode.SelectSingleNode("ws:SqlFailSafeSet[@Number=\"" + currentFailSafeSet + "\"]/ws:DefaultPrimaryDatabase", manager);
                        ((XmlElement)workingNode).SetAttribute("Database", currentDatabaseName);
                        ((XmlElement)workingNode).SetAttribute("DataServer", appServers[currentAppServer]);

                        // Primary Database
                        workingNode = scopeNode.SelectSingleNode("ws:SqlFailSafeSet[@Number=\"" + currentFailSafeSet + "\"]/ws:PrimaryDatabase", manager);
                        ((XmlElement)workingNode).SetAttribute("Database", currentDatabaseName);
                        ((XmlElement)workingNode).SetAttribute("DataServer", appServers[currentAppServer]);

                        ++currentFailSafeSet;
                    }
                }

                // Data Partitions

                scopeNode = deploymentDoc.SelectSingleNode("//ws:Deployment/ws:DataPartitions", manager);

                int partitionsPerSet = ((int)partitionCount / (appServers.Count * (int)failSafeSetsPerServer));
                for (int currentPartition = 0; currentPartition < partitionCount; ++currentPartition)
                {
                    XmlDocument dataPartitionDoc = new XmlDocument();
                    dataPartitionDoc.LoadXml(Resources.datapartition_template);

                    workingNode = scopeNode.AppendChild(deploymentDoc.ImportNode(dataPartitionDoc.DocumentElement, true));
                    ((XmlElement)workingNode).SetAttribute("Number", currentPartition.ToString());

                    workingNode = workingNode.SelectSingleNode("ws:SqlFailSafeSetNumber/text()", manager);
                    workingNode.Value = (currentPartition / partitionsPerSet).ToString();
                }
            }
            catch (Exception e)
            {
                log.Error("Exception occurred while generating deployment file.\r\n{0}", e.ToString());
                deploymentDoc = null;
            }

            return deploymentDoc;
        }

        //public static Deployment GetDeployment(string name)
        //{
        //}
    }

    public class Deployment
    {
        private readonly IDeployment _deployment;
        private readonly IDatabaseTemplate _databaseTemplate;
        private readonly IOracle _oracle;
        private readonly XmlDocument _deploymentDoc;
        private readonly XmlNamespaceManager _nsManager;
        private static readonly Log log = Log.GetInstance();
        private List<Database> _databases;
        private readonly List<Account> _accounts;
        

        private readonly string _name;
        private readonly string _manifestName;
        private readonly string _path;


        public Deployment(IDeployment deployment, IDatabaseTemplate databaseTemplate, IOracle oracle, string path) : this(deployment, databaseTemplate, oracle, null, path) { }

        public Deployment(IDeployment deployment, IDatabaseTemplate databaseTemplate, IOracle oracle, XmlDocument deploymentDoc, string path)
        {
            _path = path;
            _deployment = deployment;
            _databaseTemplate = databaseTemplate;
            _oracle = oracle;

            if (deploymentDoc == null)
            {
                _deploymentDoc = new XmlDocument();
                _deploymentDoc.Load(path);
            }
            else
                _deploymentDoc = deploymentDoc;

            _nsManager = new XmlNamespaceManager(new NameTable());
            _nsManager.AddNamespace("wst", Globals.kWebstoreDeploymentXmlNamespace);

            XmlNode deploymentNode = _deploymentDoc.SelectSingleNode("//wst:Webstore/wst:Deployment", _nsManager);
            _name = deploymentNode.Attributes["Name"].Value;

            XmlNode manifestNode = deploymentNode.SelectSingleNode("wst:UseManifest/wst:ManifestName", _nsManager);
            _manifestName = manifestNode.InnerText;

            _accounts = SecurityAccounts();
        }

        public string Name { get { return _name; } }
        public string ManifestName { get { return _manifestName; } }
        public string Path { get { return _path; } }

        public string PublisherName
        {
            get
            {
                XmlNode pubNode = _deploymentDoc.SelectSingleNode(
                    "//wst:Webstore/wst:Deployment/wst:DeploymentDefaults/wst:SecondaryPublication/wst:Name",
                    _nsManager);

                return (pubNode == null ? "" : pubNode.InnerText);
            }

        }

        public int DataPartionCount
        {
            get
            {
                XmlNodeList nodes = _deploymentDoc.SelectNodes(
                    "//wst:Webstore/wst:Deployment/wst:DataPartitions/wst:DataPartition",
                    _nsManager);

                return nodes.Count;
            }
        }

        public List<Database> Databases
        {
            get
            {
                if (_databases == null)
                    LoadTopology();

                return _databases;
            }
        }
        /// <summary>
        /// Default Primary Database
        /// </summary>
        public Database DefaultPrimary
        {
            get
            {
                if (this.Databases != null)
                {
                    return this.Databases.Find(delegate(Database db)
                        {
                            return db.IsDefaultPrimary == true;
                        });
                }
                else
                {
                    return null;
                }

            }

        }
        public List<Database> PrimaryDatabases
        {
            get
            {
                if (this.Databases != null)
                {
                    return Databases.FindAll(delegate(Database db)
                    {
                        return db.Primary == true;
                    });
                }
                else
                {
                    return null;
                }
            }
        }
        public List<Database> SecondaryDatabases
        {
            get
            {
                if (this.Databases != null)
                {
                    return Databases.FindAll(delegate(Database db)
                    {
                        return db.Primary == false;
                    });
                }
                else
                {
                    return null;
                }
            }
        }

        private void LoadTopology()
        {
            if (_oracle.IsDeploymentImported(_name))
            {
                LoadTopologyFromWebstore();
            }
            else
            {
                LoadTopologyFromXml();
            }
        }

        private void LoadTopologyFromWebstore()
        {
            List<Database> newDatabaseList = new List<Database>();

            using (WstConnection connection = new WstConnection(_name))
            {
                connection.Open();

                WebstoreSQLFssCollection collection = connection.SqlPartitions;
                foreach (WebstoreSQLFss partition in collection)
                {
                    foreach (WebstoreDatabase db in partition.Databases)
                    {
                        // if there is more then on database in the partition
                        // then we assume that replication must exist
                        bool hasSecondaries = (partition.Databases.Count > 1);
                        bool isDefaultPrimary = (partition.DefaultPrimaryDB.Name.Equals(db.Name)) ? true : false;
                        string status = "online";
                        if (!db.IsOnline)
                            status = "offline";
                        //if (db.Blacklisted)
                        //    status = "blacklisted";
                        newDatabaseList.Add(new Database(db.Name, db.ServerName, db.IsPrimary, status, hasSecondaries, isDefaultPrimary));
                    }
                }

                _databases = newDatabaseList;
            }
        }

        public void LoadTopologyFromXml()
        {
            List<Database> list = new List<Database>();
            string dbserver;
            string dbname;

            XmlNodeList failSafeSetNodes = _deploymentDoc.SelectNodes("//wst:Webstore/wst:Deployment/wst:SqlFailSafeSets/wst:SqlFailSafeSet", _nsManager);
            if (failSafeSetNodes == null) return;

            foreach (XmlNode failsafeSetNode in failSafeSetNodes)
            {
                //Get Server, db & status for the deployment
                XmlNodeList dbnodeList = failsafeSetNode.SelectNodes("wst:Databases/wst:Database", _nsManager);
                if (dbnodeList == null) continue;

                // if there is more then on database in the partition
                // then we assume that replication must exist
                bool hasSecondaries = (dbnodeList.Count > 1);

                foreach (XmlNode dbnode in dbnodeList)
                {

                    dbname = dbnode.Attributes["Name"].Value;
                    dbserver = dbnode.Attributes["DataServer"].Value;

                    string status;
                    status = dbnode["Status"] != null ? dbnode["Status"].InnerText : null;

                    //primary database is defined at //wst:Webstore/wst:Deployment/wst:SqlFailSafeSets/wst:SqlFailSafeSet/wst:PrimaryDatabase
                    XmlNode primaryNode = dbnode.ParentNode.ParentNode["PrimaryDatabase"];
                    XmlNode defaultPrimaryNode = dbnode.ParentNode.ParentNode["DefaultPrimaryDatabase"];
                    //check if the server & db is primary
                    bool primary;
                    if (primaryNode != null &&
                        primaryNode.Attributes["DataServer"].Value.ToLower() == dbserver.ToLower() &&
                        primaryNode.Attributes["Database"].Value.ToLower() == dbname.ToLower())
                        primary = true;
                    else
                        primary = false;

                    bool defaultPrimary;
                    if (defaultPrimaryNode != null &&
                        defaultPrimaryNode.Attributes["DataServer"].Value.ToLower() == dbserver.ToLower() &&
                        defaultPrimaryNode.Attributes["Database"].Value.ToLower() == dbname.ToLower())
                        defaultPrimary = true;
                    else
                        defaultPrimary = false;


                    list.Add(new Database(dbname, dbserver, primary, status, hasSecondaries, defaultPrimary));
                }
            }

            _databases = list;
        }

        List<Account> SecurityAccounts()
        {
            List<Account> accounts = new List<Account>();

            string query =
                "//wst:DeploymentDefaults/wst:Accounts/wst:Account";
            try
            {
                XmlNodeList accountNodes = _deploymentDoc.SelectNodes(query, _nsManager);

                foreach (XmlNode accountNode in accountNodes)
                {

                    string name = accountNode.Attributes["Name"].Value;

                    XmlNodeList roleNodes = accountNode.SelectNodes("./wst:Role", _nsManager);

                    foreach (XmlNode roleNode in roleNodes)
                    {
                        string role = roleNode.InnerText;
                        accounts.Add(new ApplicationAccount(name, role, _name));
                    }
                }
            }
            catch (Exception e)
            {
                StringBuilder error = new StringBuilder();
                error.AppendFormat("Exported deployment '{0}' at location '{1}' has a malformed Accounts node. ", _name, _path);
                error.Append("Make sure all accounts currently added to this deployment are valid.");
                log.Error(error.ToString());

                throw (new ApplicationException("Bad account listing in deployment Xml", e));
            }

            return accounts;
        }

        /// <summary>
        /// 
        /// </summary>
        /// <param name="beforeInstall">
        /// This flag allow the application to continue deployment from last leftover deployment.
        /// </param>
        /// <returns></returns>
        public bool VerifyDeployment(bool beforeInstall)
        {
            log.WriteLine("Verifying deployment " + _name + "...");

            //export the current deployment list from Webstore
            LoadTopologyFromWebstore();

            //Loop thru current status of a deployment
            foreach (Database deployeddb in _databases)
            {
                if (beforeInstall)
                {
                    if (deployeddb.Status.ToLower() == "notdeployed")
                    {
                        log.WriteLine("There exists a left over deployment last run for database " + deployeddb.Name + "...");
                        return false;
                    }
                }
                else if ((deployeddb.Status.ToLower() != "online"))
                {
                    //states other than offline is out of scope
                    log.Error("'{0}' - '{1}' status is not online. Current status: '{2}'",
                        deployeddb.Server, deployeddb.Name, deployeddb.Status);
                    return false;
                }

            }

            log.WriteLine(" Done!");

            return true;
        }

        public void Import()
        {
            log.WriteLine("Importing deployment {0}", _name);

            _deployment.InXmlPath = _path;
            _deployment.Import();

            log.WriteLine(" Done!");
        }

        public void Setup()
        {
            log.WriteLine("Webstore Setting up deployment {0}", _name);

            _deployment.DeploymentName = _name;
            _deployment.Setup();

            log.WriteLine(" Done!");
        }

        public void Upgrade(bool isRollingUpgrade, bool isReplTearDown, bool isForce)
        {
            log.WriteLine("Webstore upgrade a deployment {0}, rollingupgrade = {1}, isReplTearDown = {2}",
                _name,
                isRollingUpgrade,
                isReplTearDown);

            _deployment.DeploymentName = _name;
            if (isForce)
            {
                _deployment.IsForce = true;
            }
            else
            {
                _deployment.IsRollingUpgrade = isRollingUpgrade;
                _deployment.IsReplTearDown = isReplTearDown;
            }

            _deployment.Upgrade();
            log.WriteLine(" Done!");
        }

        public void UpdateVersion(string version)
        {
            log.WriteLine("Deployment version updating to {0}", version);

            _deployment.DeploymentName = _name;
            _deployment.NewManifestVersion = version;
            _deployment.UpdateVersion();

            log.WriteLine(" Done!");
        }

        public void Drop()
        {
            log.WriteLine("Dropping deployment {0}", _name);

            _deployment.IsForce = true;
            _deployment.DeploymentName = _name;
            _deployment.Drop();
            _databaseTemplate.Purge();

            log.WriteLine(" Done!");
        }

        public void UpdateSecurityAccounts()
        {
            log.WriteLine("Checking security accounts...", _name);

            Deployment currentDeployment;
            List<Account> currentAccounts = null;

            if (_oracle.IsDeploymentImported(_name))
            {
                FileInfo depFile = _oracle.ExportDeployment(_name);
                currentDeployment = new Deployment(_deployment, _databaseTemplate, _oracle, depFile.FullName);

                currentAccounts = currentDeployment._accounts;
            }

            foreach (Account account in _accounts)
            {
                if (currentAccounts != null)
                {
                    bool found = false;

                    foreach (Account currentAccount in currentAccounts)
                    {
                        if (account.CompareTo(currentAccount) == 0)
                        {
                            found = true;
                            break;
                        }
                    }

                    if (found)
                        continue;
                }

                account.Persist();
            }

            log.WriteLine("Done!");
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\wstrunner\core\IDeploymentFactory.cs ===
/*******************************************************************
 *    FILE:         IManifestFactory.cs
 *
 *    DESCRIPTION:  IManifestFactory interface.
 *
 *    OWNER:        darrenan
 *
 *    HISTORY:      4-18-2008   - Created 
 *
 *    Copyright <cp> 2008 Microsoft Corporation.  All Rights Reserved.
 *******************************************************************/

namespace xonline.tools.wstrunner.core
{
    public interface IDeploymentFactory
    {
        // Methods
        BaseDeployment CreateInstance();
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\wstrunner\core\IFailSafeSet.cs ===
/*******************************************************************
 *    FILE:         IFailSafeSet.cs
 *
 *    DESCRIPTION:  IFailSafeSet interface.
 *
 *    OWNER:        darrenan
 *
 *    HISTORY:      7-18-2008   - Created 
 *
 *    Copyright <cp> 2008 Microsoft Corporation.  All Rights Reserved.
 *******************************************************************/

namespace xonline.tools.wstrunner.core
{
    public interface IFailSafeSet
    {
        // Properties
        string DeploymentName { get; set; }
        int SQLFSSNum { get; set; }

        // Methods
        void Offline();
        void Demote();
        void DropRepl();
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\wstrunner\core\IManifest.cs ===
/*******************************************************************
 *    FILE:         IManifest.cs
 *
 *    DESCRIPTION:  IManifest interface.
 *
 *    OWNER:        darrenan
 *
 *    HISTORY:      10-22-2007   - Created 
 *
 *    Copyright <cp> 2007 Microsoft Corporation.  All Rights Reserved.
 *******************************************************************/

namespace xonline.tools.wstrunner.core
{
    public interface IManifest
    {
        // Properties
        string InXmlPath { get; set; }
        string ManifestName { get; set; }
        string ManifestVersion { get; set; }

        // Methods
        void Import();
        void Purge();
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\wstrunner\core\IFailSafeSetFactory.cs ===
/*******************************************************************
 *    FILE:         IFailSafeSetFactory.cs
 *
 *    DESCRIPTION:  IFailSafeSetFactory interface.
 *
 *    OWNER:        darrenan
 *
 *    HISTORY:      4-18-2008   - Created 
 *
 *    Copyright <cp> 2008 Microsoft Corporation.  All Rights Reserved.
 *******************************************************************/

namespace xonline.tools.wstrunner.core
{
    public interface IFailSafeSetFactory
    {
        // Methods
        BaseFailSafeSet CreateInstance();
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\wstrunner\core\IManifestFactory.cs ===
/*******************************************************************
 *    FILE:         IManifestFactory.cs
 *
 *    DESCRIPTION:  IManifestFactory interface.
 *
 *    OWNER:        darrenan
 *
 *    HISTORY:      4-18-2008   - Created 
 *
 *    Copyright <cp> 2008 Microsoft Corporation.  All Rights Reserved.
 *******************************************************************/

namespace xonline.tools.wstrunner.core
{
    public interface IManifestFactory
    {
        // Methods
        BaseManifest CreateInstance();
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\wstrunner\core\makefile.inc ===
!include $(INETROOT)\build\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\wstrunner\core\IOracle.cs ===
/*******************************************************************
 *    FILE:         IOracle.cs
 *
 *    DESCRIPTION:  IOracle interface.
 *
 *    OWNER:        darrenan
 *
 *    HISTORY:      4-18-2008   - Created 
 *
 *    Copyright <cp> 2008 Microsoft Corporation.  All Rights Reserved.
 *******************************************************************/

using System.Collections.Generic;
using System.IO;

namespace xonline.tools.wstrunner.core
{
    public interface IOracle
    {
        void Refresh();
        bool IsManifestImported(string manifestName, string version);
        bool IsManifestImported(string manifestName);
        bool IsDeploymentImported(string deploymentName);
        FileInfo ExportDeployment(string deploymentName);
        IList<string> ManifestVersions(string manifestName);
        string GetVersionForDeployment(string DeploymentName);
        void AddManifestToHashTable(string manifestName, string manifestVersion);
        FileInfo ExportManifest(string manifestName, string version, bool ExportObjects, bool ExportGeneratedObjects);
        FileInfo ExportDeploymentStatus(string deploymentName, string outXmlPath, bool isVerbose);
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\wstrunner\core\IDeploymentFileFactory.cs ===
/*******************************************************************
 *    FILE:         IDeploymentFactory.cs
 *
 *    DESCRIPTION:  IDeploymentFactory interface.
 *
 *    OWNER:        darrenan
 *
 *    HISTORY:      4-17-2008   - Created 
 *
 *    Copyright <cp> 2008 Microsoft Corporation.  All Rights Reserved.
 *******************************************************************/

using System.IO;

namespace xonline.tools.wstrunner.core
{
    public interface IDeploymentFileFactory
    {
        // Methods
        FileInfo CreateDeployment(
            FileInfo manifestXml,
            string deploymentXmlFileName,
            string dataFilePath,
            string logFilePath,
            string configServerList,
            string dataServerList,
            uint failSafeSetsPerServer,
            string accountRoleMap,
            uint partitionCount,
            string databaseName);
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\wstrunner\core\IWstRunnerFactory.cs ===
namespace xonline.tools.wstrunner.core
{
    public interface IWstRunnerFactory
    {
        IWstRunner CreateInstance(
            string workingPath,
            string manifestFile,
            string deploymentFile);
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\wstrunner\core\IWstRunner.cs ===
namespace xonline.tools.wstrunner.core
{
    public interface IWstRunner
    {
        #region Properties

        string WorkingPath { get; }
        string ManifestFile { get; }
        string DeploymentFile { get; }

        #endregion

        #region Methods

        void Setup(WstRunner.SetupAction sAction, bool isRollingUpgrade, bool replTearDown);
        void Remove(bool removeDatabase);
        void MarkNeedsRepair();
        void RepairwithOnlinePromote();

        #endregion
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\wstrunner\core\IOracleFactory.cs ===
/*******************************************************************
 *    FILE:         IOracleFactory.cs
 *
 *    DESCRIPTION:  IOracleFactory interface.
 *
 *    OWNER:        darrenan
 *
 *    HISTORY:      4-18-2008   - Created 
 *
 *    Copyright <cp> 2008 Microsoft Corporation.  All Rights Reserved.
 *******************************************************************/

namespace xonline.tools.wstrunner.core
{
    public interface IOracleFactory
    {
        // Methods
        IOracle CreateInstance();
        IOracle CreateInstanceWithoutRefresh();
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\wstrunner\core\Log.cs ===
/*******************************************************************
 *    FILE:         Log.cs
 *
 *    DESCRIPTION:  
 *
 *    OWNER:        gamagev
 *
 *    HISTORY:      04/08/2004      gamagev    Created
 *
 *    Copyright <cp> 2004 Microsoft Corporation.  All Rights Reserved.
 ********************************************************************
 */
using System;
using System.Text;

namespace xonline.tools.wstrunner.core
{
    public enum LogLevel
    {
        Error = 0,
        Warning = 1,
        Info = 2,
        Verbose = 3
    }

    /// <summary>
    /// Summary description for Log.
    /// </summary>
    public sealed class Log
    {
        private LogLevel _verbosity = LogLevel.Error;

        Log() 
        {
        }

        /// <summary>
        /// Need to make sure we have closed our file when we are finilized
        /// </summary>
        ~Log()
        {
        }

        public event EventHandler<LoggingEventArgs> OnMessage;

        public LogLevel Verbosity
        {
            get { return _verbosity; }
            set { _verbosity = value; }
        }

        /// <summary>
        /// Contains the static instance of us. This way is both 
        /// thread safe and lazy load.
        /// </summary>
        class InternalLogClass
        {
            InternalLogClass()
            {
            }

            internal static readonly Log instance = new Log();    
        }
        
        /// <summary>
        /// We are a singelton so this is the only way to get 
        /// an instance
        /// </summary>
        /// <returns>The singelton Log object</returns>
        public static Log GetInstance()
        {
            return InternalLogClass.instance;
        }

        public void Message(LogLevel level, string message)
        {
            //Trim Message to MaxEvent Log message size
            if (message.Length > 32000)
            {
                message = "Trimmed Message : " + message.Substring(0, 10000);
            }


            if (_verbosity >= level)
            {
                OnMessage(this, new LoggingEventArgs(level, message));
            }
        }
        public void Message(LogLevel level, string message, params Object[] args)
        {
            StringBuilder msg = new StringBuilder();
            msg.AppendFormat(message, args);

            Message(level, msg.ToString());        
        }

        public void WriteLine(string message)
        {
            Message(LogLevel.Verbose, message + "\r\n");           
        }

        public void WriteLine(string message, params Object[] args)
        {
            StringBuilder msg = new StringBuilder();
            msg.AppendFormat(message, args);

            WriteLine(msg.ToString());        
        }

        public void Write(string message)
        {
            Message(LogLevel.Verbose, message);
        }

        public void Write(string message, params Object[] args)
        {
            StringBuilder msg = new StringBuilder();
            msg.AppendFormat(message, args);

            Write(msg.ToString());        
        }
       

        public void Error(string message, params Object[] args)
        {
            StringBuilder msg = new StringBuilder();
            msg.AppendFormat(message, args);

            Error(msg.ToString());        
        }

        public void Error(string errorMessage)
        {
            Message(LogLevel.Error, errorMessage);
        }

        //public void Error(bool color, string errorMessage)
        //{
        //    if (color)
        //        ConsoleColor.SetForeGroundColor(ConsoleColor.ForeGroundColor.Red, true);

        //    Console.WriteLine(errorMessage);
        //    if (logStream != null)
        //        logStream.WriteLine(errorMessage);
 
        //    if (color)
        //        ConsoleColor.SetToDefaultForeGroundColor();
        //}

        //public void xmlValidationError(string errorMessage)
        //{
        //    ConsoleColor.SetForeGroundColor(ConsoleColor.ForeGroundColor.Red, true);
            
        //    Console.WriteLine("\nXML Validation Error");
        //    if (logStream != null)
        //        logStream.WriteLine("\nXML Validation Error");
            
        //    ConsoleColor.SetToDefaultForeGroundColor();
            
        //    Console.WriteLine("\nDetail: \n\t" + errorMessage);
        //    if (logStream != null)
        //        logStream.WriteLine("\nDetail: \n\t" + errorMessage);
        //}


    }

    /// <summary>
    /// 
    /// </summary>
    public class LoggingEventArgs : EventArgs
    {
        private readonly string _message;
        private readonly LogLevel _level;

        /// <summary>
        /// 
        /// </summary>
        /// <param name="level">
        /// </param>
        /// <param name="message"></param>
        public LoggingEventArgs(LogLevel level, string message)
        {
            _level = level;
            _message = message;
        }

        /// <summary>
        /// 
        /// </summary>
        public string Message
        {
            get { return _message; }
        }

        public LogLevel Level
        {
            get { return _level; }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\wstrunner\core\temp.cs ===
using System;
using System.IO;
using System.Reflection;
using System.Text;

namespace xonline.tools.wstrunner.core
{
    /// <summary>
    /// Summary description for Class1
    /// </summary>
    public class Temp
    {
        private readonly DirectoryInfo _directory;

        public Temp()
            : this(String.Empty)
        {
        }

        public Temp(string SubDirectoryName)
        {
            if (SubDirectoryName.Length == 0)
            {
                DateTime time = DateTime.Now;
                _directory = new DirectoryInfo(Path.Combine(Path.GetDirectoryName(Assembly.GetExecutingAssembly().Location), time.ToString("yyyy-MM-dd_HH.mm.ss")));
            }
            else
                _directory = new DirectoryInfo(Path.Combine(Path.GetDirectoryName(Assembly.GetExecutingAssembly().Location), SubDirectoryName));

            if (!_directory.Exists)
            {
                _directory.Create();
                _directory.Refresh();
            }
        }

        public DirectoryInfo Directory
        {
            get
            { return _directory; }
        }

        /// <summary>
        /// 
        /// </summary>
        /// <returns></returns>
        public string GetTempFileName()
        {
            return GetTempFileName("log");
        }

        /// <summary>
        /// 
        /// </summary>
        /// <param name="extension"></param>
        /// <returns></returns>
        public string GetTempFileName(string extension)
        {
            StringBuilder fileName = new StringBuilder();
            DateTime time = DateTime.Now;

            fileName.AppendFormat("{0}\\{1}_{2}.{3}"
                , _directory.FullName
                , _directory.Name
                , time.ToString("yyyy-MM-dd_HH.mm.ss")
                , extension);

            return fileName.ToString();
        }

        public string GetTempFileName(string prefix, string extension)
        {
            string filePrefix;

            StringBuilder fileName = new StringBuilder();
            DateTime time = DateTime.Now;

            if (prefix == null)
                filePrefix = _directory.Name;
            else
                filePrefix = prefix;

            fileName.AppendFormat("{0}\\{1}_{2}.{3}"
                , _directory.FullName
                , filePrefix
                , time.ToString("yyyy-MM-dd_HH.mm.ss")
                , extension);

            return fileName.ToString();
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\wstrunner\core\WmoDatabase.cs ===
/*******************************************************************
 *    FILE:         WmoDatabase.cs
 *
 *    DESCRIPTION:  IDatabase wrapper for WmoCommandDatabase class.
 *
 *    OWNER:        darrenan
 *
 *    HISTORY:      5-1-2008   - Created 
 *
 *    Copyright <cp> 2008 Microsoft Corporation.  All Rights Reserved.
 *******************************************************************/

using System;
using Microsoft.Webstore.Common;
using Microsoft.Webstore.Management.Wmo;

namespace xonline.tools.wstrunner.core
{
    public class WmoDatabaseFactory : IDatabaseFactory
    {
        public BaseDatabase CreateInstance()
        {
            return WmoDatabase.CreateInstance();
        }
    }
    
    public abstract class BaseDatabase : IDatabase
    {
        #region IDatabase Members

        public abstract string Server { get; set; }
        public abstract string Database { get; set; }

        public abstract void NeedsRepair();
        public abstract void Repair();
        public abstract void MarkOnline();
        public abstract void Promote();
        public abstract void Repair(bool isForce);

        #endregion
    }

    /// <summary>
    /// Wrap the WmoCommandDatabase class in a pass-through interface layer 
    /// for the purpose of mocking this in unit tests.
    /// </summary>
    public class WmoDatabase : BaseDatabase
    {
        private readonly WmoCommandDatabase wmoDatabase = new WmoCommandDatabase();
        private string server;
        private string database;
        private readonly Log log = Log.GetInstance();

        public static WmoDatabase CreateInstance()
        {
            return new WmoDatabase();
        }

        private WmoDatabase()
        {
            wmoDatabase.WmoStatusEvent += StatusEventHandler;
        }

        //  Properties

        //  Methods

        public void StatusEventHandler(Object sender, WmoStatusEventArgs eventArgs)
        {
            log.WriteLine(string.Format("{0}", eventArgs));
        }

        // IDatabase

        public override string Server
        {
            get
            {
                return server;
            }
            set
            {
                server = value;
            }
        }

        public override string Database
        {
            get
            {
                return database;
            }
            set
            {
                database = value;
            }
        }

        public override void NeedsRepair()
        {
           
                wmoDatabase.ServerName = server;
                wmoDatabase.DatabaseName = database;
                wmoDatabase.NeedsRepair();
           
        }
        public override void Repair(bool isForce)
        {
            wmoDatabase.ServerName = server;
            wmoDatabase.DatabaseName = database;
            wmoDatabase.IsForceRepair = isForce;
            wmoDatabase.Repair();
        }

        public override void Repair()
        {
            Repair(false);
        }



        public override void MarkOnline()
        {
            wmoDatabase.ServerName = server;
            wmoDatabase.DatabaseName = database;
            wmoDatabase.Online();
        }

        public override void Promote()
        {
            wmoDatabase.ServerName = server;
            wmoDatabase.DatabaseName = database;
            wmoDatabase.Promote();
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\wstrunner\core\WmoDatabaseTemplate.cs ===
/*******************************************************************
 *    FILE:         WmoDatabaseTemplate.cs
 *
 *    DESCRIPTION:  IDatabaseTemplate wrapper for WmoCommandDatabaseTemplate class.
 *
 *    OWNER:        darrenan
 *
 *    HISTORY:      10-22-2007   - Created 
 *
 *    Copyright <cp> 2007 Microsoft Corporation.  All Rights Reserved.
 *******************************************************************/

using System;
using Microsoft.Webstore.Common;
using Microsoft.Webstore.Management.Wmo;

namespace xonline.tools.wstrunner.core
{
    public class WmoDatabaseTemplateFactory : IDatabaseTemplateFactory
    {
        public BaseDatabaseTemplate CreateInstance()
        {
            return WmoDatabaseTemplate.CreateInstance();
        }
    }
    
    public abstract class BaseDatabaseTemplate : IDatabaseTemplate
    {
        #region IDatabaseTemplate Members

        public abstract void Purge();

        #endregion
    }

    /// <summary>
    /// Wrap the WmoCommandDatabaseTemplate class in a pass-through interface layer 
    /// for the purpose of mocking this in unit tests.
    /// </summary>
    public class WmoDatabaseTemplate : BaseDatabaseTemplate
    {
        private readonly WmoCommandDatabaseTemplate wmoDatabaseTemplate = new WmoCommandDatabaseTemplate();
        private readonly Log log = Log.GetInstance();

        public static WmoDatabaseTemplate CreateInstance()
        {
            return new WmoDatabaseTemplate();
        }

        private WmoDatabaseTemplate()
        {
            wmoDatabaseTemplate.WmoStatusEvent += StatusEventHandler;
        }

        //  Properties

        //  Methods

        public void StatusEventHandler(Object sender, WmoStatusEventArgs eventArgs)
        {
            log.WriteLine(string.Format("{0}", eventArgs));
        }


        // IDatabaseTemplate

        public override void Purge()
        {
            wmoDatabaseTemplate.Purge();
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\wstrunner\core\WebstoreOracle.cs ===
/*******************************************************************
 *    FILE:         WebstoreOracle.cs
 *
 *    DESCRIPTION:  
 *
 *    OWNER:        gamagev
 *
 *    HISTORY:      1/15/2003   - Created 
 *
 *    Copyright <cp> 2003 Microsoft Corporation.  All Rights Reserved.
 *******************************************************************/

using System;
using System.IO;
using System.Xml;
using System.Collections.Generic;
using Microsoft.Webstore.Management.Wmo;

namespace xonline.tools.wstrunner.core
{
    public class WebstoreOracleFactory : IOracleFactory
    {
        public IOracle CreateInstance()
        {
            return WebstoreOracle.GetInstance();
        }

        public IOracle CreateInstanceWithoutRefresh()
        {
            return WebstoreOracle.GetInstanceWithoutRefresh();
        }
    }

    /// <summary>
    /// This class contains all the logic for connecting to Webstore and querying about the current configuration.
    /// </summary>
	public sealed class WebstoreOracle : IOracle
	{
        private SortedDictionary<string, SortedList<string, object> > _manifests;
        private SortedDictionary<string, string[]> _deployments;
     
        private WebstoreOracle()
        {
            Refresh();
        }  

        /// <summary>
        /// Thread safe singelton
        /// </summary>
        class Oracle
        {
            Oracle()
            {
            }
            internal static readonly WebstoreOracle instance = new WebstoreOracle();            
        }

        /// <summary>
        /// </summary>
        /// <returns>Pointer to the singleton WebstoreOracle object</returns>
        public static WebstoreOracle GetInstance()
        {
            Oracle.instance.Refresh();
            return Oracle.instance;
        }

        /// <summary>
        /// 
        /// </summary>
        /// <returns></returns>
        public static WebstoreOracle GetInstanceWithoutRefresh()
        {
            return Oracle.instance;
        }

        /// <summary>
        /// Reloads all manifest and deployment information from the Webstore config server.
        /// </summary>
        public void Refresh()
        {
            WmoCommandManifest wmoManifest = new WmoCommandManifest();
            XmlDocument maniFestList = GetManifestListFromWebstore(wmoManifest);
            LoadHashTablesFromManifest(maniFestList);
        }

        private static XmlDocument GetManifestListFromWebstore(WmoCommandManifest wmoManifest)
        {
            Log log = Log.GetInstance();

            string tempFileName = Path.GetTempFileName();            

            wmoManifest.OutXmlPath = tempFileName;

            try
            {
                wmoManifest.List();
            }
            catch(Exception e)
            {                
                log.Error("\r\nError while getting manifest list from webstore\n\tDetail: {0}", e.Message);
                throw;
            }
            
            XmlDocument manifestList = new XmlDocument();

            try
            {
                manifestList.Load(tempFileName);
            }
            catch(XmlException e)
            {
                log.Error("\nError opening manifest list generated from webstore\nOutput XML at: {0}\n\tDetail: {1}", tempFileName, e.Message);
                throw;
            }

            return manifestList;
        }

        private void LoadHashTablesFromManifest(XmlDocument manifestList)
        {
            _manifests = new SortedDictionary<string, SortedList<string, object> >(StringComparer.InvariantCultureIgnoreCase);
            _deployments = new SortedDictionary<string, string[]>(StringComparer.InvariantCultureIgnoreCase);

            XmlNodeList manifestNodeList = manifestList.GetElementsByTagName("Manifest");
            
            foreach (XmlNode manifestNode in manifestNodeList)
            {                
                string manifestName = manifestNode.Attributes["Name"].Value;
                XmlElement versionElement = manifestNode["Version"];
                if(versionElement == null)
                {
                    throw new Exception("No <Version> found in manifest file.  This manifest is invalid.");
                }

                string manifestVersion = versionElement.InnerText;

                // add this manifest to the global list
                AddManifestToHashTable(manifestName, manifestVersion);
                                               
                XmlNodeList deploymentNodeList = manifestNode.SelectNodes("Deployments/Deployment");
                if(deploymentNodeList == null) continue;

                foreach (XmlNode deploymentNode in deploymentNodeList)
                {
                    string deploymentName = deploymentNode.InnerText;
              
                    // add it to the deplyment hastable
                    AddDeploymentToHashTable(deploymentName, manifestName, manifestVersion);
                }

            }
        }

        /// <summary>
        /// Adds a deployment to the internal container of deployemnts
        /// </summary>
        /// <param name="DeploymentName">Name of the deployment</param>
        /// <param name="manifestName">Name of the manifest refrenced in the deployemnt</param>
        /// <param name="manifestVersion">version of the manigest</param>
        public void AddDeploymentToHashTable(string DeploymentName, string manifestName, string manifestVersion)
        {
            if (!_deployments.ContainsKey(DeploymentName))
            {
                string[] ManifestNameVersion = new string[2];
                ManifestNameVersion[0] = manifestName;
                ManifestNameVersion[1] = manifestVersion;

                _deployments.Add(DeploymentName, ManifestNameVersion);
            }            
        }

        /// <summary>
        /// Adds a manifest to the internal container of manifests
        /// </summary>
        /// <param name="manifestName">Name of the manifest to be added</param>
        /// <param name="manifestVersion">version of the manifest</param>
        public void AddManifestToHashTable(string manifestName, string manifestVersion)
        {
            SortedList<string, object> versions;

            if (_manifests.ContainsKey(manifestName))
            {
                versions = _manifests[manifestName];
            }
            else
            {               
                versions = new SortedList<string, object>();

                _manifests.Add(manifestName, versions);
            }

            if (!versions.ContainsKey(manifestVersion))
            {
               versions.Add(manifestVersion, null);
            }
        }
        

        /// <summary>
        /// Checks the internal container of manifests to see if the given manifest and version 
        /// is already imported into Webstore
        /// </summary>
        /// <param name="manifestName">Name of the manieft to look up</param>
        /// <param name="version">version of the manifest to look up</param>
        /// <returns>Ture the manifest is already inported; False it is not imported</returns>
        public bool IsManifestImported(string manifestName, string version)
        {
            if(!_manifests.ContainsKey(manifestName))
            {
                return false;
            }

            SortedList<string, object> versions = _manifests[manifestName];

            return versions != null && versions.ContainsKey(version);
        }

        public bool IsManifestImported(string manifestName)
        {
            return _manifests.ContainsKey(manifestName);
        }

        public IList<string> ManifestVersions(string manifestName)
        {
            if(_manifests.ContainsKey(manifestName))
            {
                return _manifests[manifestName].Keys;
            }

            return null;
        }

        /// <summary>
        /// Check the internal container of deployments to see if the given deployment
        /// is already imported into Webstore
        /// </summary>
        /// <param name="DeploymentName">Name of the deployemt to check</param>
        /// <returns>True the deployment is already imported; False it is not</returns>
        public bool IsDeploymentImported(string DeploymentName)
        {
            return (_deployments.ContainsKey(DeploymentName));
        }

        /// <summary>
        /// Get the current manifest version for the given deployment
        /// </summary>
        /// <param name="DeploymentName">Name of the deployment to get the manifest version for</param>
        /// <returns>Manifest version number or Empty string if not found</returns>
        public string GetVersionForDeployment(string DeploymentName)
        {
            string[] ManifestNameVersion = _deployments[DeploymentName];

            return ManifestNameVersion != null ? ManifestNameVersion[1] : string.Empty;
        }

        /// <summary>
        /// Exports the named manifest and version number from the Webstore config DB
        /// </summary>
        /// <param name="manifestName">Name of the Manifest to export</param>
        /// <param name="version">Version of the Manifest to export</param>
        /// <param name="ExportObjects">If true all the Objects will be exported from Webstore and 
        /// placed in the same directory as the exported manifest</param>
        /// <param name="ExportGeneratedObjects">If true all the Webstore generated objects will be exported
        /// from Webstore and place in a sub directory of where the exported manifest is</param>
        /// <returns>FileInfo object pointing to the exported Manifest</returns>
        public FileInfo ExportManifest(string manifestName, string version, bool ExportObjects, bool ExportGeneratedObjects )
        {
            WmoCommandManifest wmomanifest = new WmoCommandManifest();
            Temp temp = new Temp(manifestName + "-" + version);
            string manifestFileName = temp.GetTempFileName("xml");

            wmomanifest.OutXmlPath = manifestFileName;
            wmomanifest.DoExportSource = ExportObjects;
            wmomanifest.DoExportGeneratedObjects = ExportGeneratedObjects;
            wmomanifest.ManifestName = manifestName;
            if (version != null)
                wmomanifest.ExportManifestVersion = version;

            wmomanifest.Export();

            return (new FileInfo(manifestFileName));
        }

        public FileInfo ExportManifest(string manifestName, bool ExportObjects, bool ExportGeneratedObjects )
        {           
            return ExportManifest(manifestName, null, ExportObjects, ExportGeneratedObjects);
        }
    
        public FileInfo ExportDeployment(string deploymentName)
        {
            if(!IsDeploymentImported(deploymentName))
            {
                return null;
            }

            Temp temp = new Temp("ExportedDeployments");
            string deploymentFileName = temp.GetTempFileName(deploymentName, "xml");

            WmoCommandDeployment wmoDeployment = new WmoCommandDeployment();
            wmoDeployment.DeploymentName = deploymentName;
            wmoDeployment.OutXmlPath = deploymentFileName;

            wmoDeployment.Export();

            return (new FileInfo(deploymentFileName));
        }

        /// <summary>
        /// Exports the named deployment status xml from Webstore config DB
        /// </summary>
        /// <param name="deployment">Name of the deployment to export</param>
        /// <param name="outXmlPath">path for export</param>
        /// <param name="isVerbose">true or false for verbose</param>
        /// <returns>FileInfo object pointing to the exported xml file</returns>
        public FileInfo ExportDeploymentStatus(string deploymentName, string outXmlPath, bool isVerbose)
        {
            WmoCommandDeployment wmodeployment = new WmoCommandDeployment();

            wmodeployment.OutXmlPath        = outXmlPath;
            wmodeployment.DeploymentName    = deploymentName;
            wmodeployment.IsVerbose         = isVerbose;

            wmodeployment.Status();

            return (new FileInfo(outXmlPath));
        }
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\wstrunner\core\Manifest.cs ===
/*******************************************************************
 *    FILE:         Manifest.cs
 *
 *    DESCRIPTION:  
 *
 *    OWNER:        gamagev
 *
 *    HISTORY:      04/08/2004      gamagev    Created
 *
 *    Copyright <cp> 2004 Microsoft Corporation.  All Rights Reserved.
 ********************************************************************
 */
using System;
using System.Xml;
using Microsoft.Webstore.Common;

namespace xonline.tools.wstrunner.core
{
    /// <summary>
    /// Summary description for Manifest.
    /// </summary>
    public class Manifest: ICloneable
    {
        private readonly IManifest _manifest;
        private readonly IOracle _oracle;
        private XmlDocument _manifestXml;
        private XmlNamespaceManager _nsManager;
        private readonly Log log = Log.GetInstance();
        private string _name;
        private string _version;
        private string _path;
        private readonly bool _isChanged = false;

        private Manifest(IManifest manifest, IOracle oracle)
        {
            _manifest = manifest;
            _oracle = oracle;
        }

        public Manifest(IManifest manifest, IOracle oracle, string path)
        {
            XmlNode node;
            _manifestXml = new XmlDocument();

            _manifest = manifest;
            _oracle = oracle;
            _path = path;

            _manifestXml.Load(_path);
            _nsManager = new XmlNamespaceManager(_manifestXml.NameTable);
            _nsManager.AddNamespace("wst", Globals.kWebstoreManifestXmlNamespace);

            node = _manifestXml.SelectSingleNode("//wst:Webstore/wst:Manifest", _nsManager);
            _name = node.Attributes["Name"].Value.Trim();

            node = _manifestXml.SelectSingleNode("//wst:Webstore/wst:Manifest/wst:Version", _nsManager);
            _version = node.InnerText.Trim();
        }

        public object Clone()
        {
            //clone everything but the tag list. We already did the tag
            // replacement so we dont need them any more.

            Manifest manifest = new Manifest(_manifest, _oracle);

            manifest._manifestXml = _manifestXml;
            manifest._nsManager = _nsManager;

            manifest._name = _name;
            manifest._version = _version;
            manifest._path = _path;
            
            return manifest;
        }
        
        public string Name{ get { return _name; } }

        public string Version{ get { return _version; } }
        
        public string Path{ get { return _path; } }

        public bool IsChanged{ get { return _isChanged; }}

        /// <summary>
        /// Imports current manifest into webstore
        /// </summary>
        public void Import()
        {
            if (_oracle.IsManifestImported(_name, _version))
            {
                log.WriteLine("Manifest {0} already imported with version {1}", _name, _version);
            }
            else
            {                
                log.WriteLine("Importing manifest {0} version {1} ", _name, _version);
                
                _manifest.InXmlPath = _path;

                try
                {
                    _manifest.Import();

                    // update the global list with the newer version
                    _oracle.AddManifestToHashTable(_name, _version);
                }
                catch (Exception e)
                {
                    log.WriteLine("Manifest import failed.  " + e.Message);
                    throw;
                }
                
                log.WriteLine("Done!");
            }
        }

        /// <summary>
        /// Purges the manifest with the current name from webstore
        /// </summary>
        public void Purge()
        {
            log.WriteLine("Purging manifest '{0}'",_name);

            _manifest.ManifestName = _name;
            _manifest.ManifestVersion = _version;
            _manifest.Purge();
        }

        public WstSecondaryType SecondaryType
        {
            get 
            {                
                XmlNode secondaryNode = _manifestXml.SelectSingleNode("//wst:Webstore/wst:Manifest/wst:Availability/wst:SqlSecondary/wst:SqlSecondaryType", _nsManager);
                
                return (WstSecondaryType)Enum.Parse(typeof(WstSecondaryType), secondaryNode.InnerText, true);
            }

        }

        public string NeedsReplicationColumn
        {
            get 
            {
                if (SecondaryType == WstSecondaryType.MultiMaster)
                {
                    XmlNode replColumnNode = _manifestXml.SelectSingleNode("//wst:Webstore/wst:Manifest/wst:Availability/wst:SqlSecondary/wst:Multimaster/wst:NeedsReplicationColumn", _nsManager);
                
                    if (replColumnNode != null)
                        return replColumnNode.InnerText;
                }
                
                return null;
            }
        }

        public WstPartitionType PartitionType
        {
            get 
            {
                XmlNode partitonTypeNode = _manifestXml.SelectSingleNode("//wst:Webstore/wst:Manifest/wst:ScaleOut/wst:PartitionType", _nsManager);
            
                return (WstPartitionType)Enum.Parse(typeof(WstPartitionType), partitonTypeNode.InnerText, true);
            }
        }
        
        public int DataPartitionCount
        {
            get 
            {
                //logical partitons only apply to "Fixed" partitioning type
                if (PartitionType != WstPartitionType.Fixed)
                    throw new ArgumentException("PartitionType is not \"Fixed\" and does not have a DataPartitionCount");

                XmlNode logicalPartitionCountNode = _manifestXml.SelectSingleNode("//wst:Webstore/wst:Manifest/wst:ScaleOut/wst:FixedPartitioning/wst:LogicalPartitionCount", _nsManager);
                
                return Convert.ToInt32(logicalPartitionCountNode.InnerText);
            }

            set
            {
                if (PartitionType != WstPartitionType.Fixed)
                    throw new ArgumentException("Can not set DataPartitionCount for non-fixed parition type");

                XmlNode logicalPartitionCountNode = _manifestXml.SelectSingleNode("//wst:Webstore/wst:Manifest/wst:ScaleOut/wst:FixedPartitioning/wst:LogicalPartitionCount", _nsManager);
                
                logicalPartitionCountNode.InnerText = value.ToString();
            
                Uri uri = new Uri(_manifestXml.BaseURI);

                _manifestXml.Save(uri.AbsolutePath);
            }
        }

        public string[] Jobs
        {
            get
            {
                XmlNodeList jobNodes = _manifestXml.SelectNodes("//wst:Webstore/wst:Manifest/wst:SqlObjects/wst:Jobs/wst:Job", _nsManager);

                string[] jobNames = new string[jobNodes.Count];

                for(int currentJob = 0; currentJob < jobNodes.Count; ++currentJob)
                {
                    XmlElement jobElement = (XmlElement) jobNodes[currentJob];

                    jobNames[currentJob] = jobElement.GetAttribute("Name"); 
                }

                return jobNames;
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\wstrunner\core\WmoDeployment.cs ===
/*******************************************************************
 *    FILE:         WmoDeployment.cs
 *
 *    DESCRIPTION:  IDeployment wrapper for WmoCommandDeployment class.
 *
 *    OWNER:        darrenan
 *
 *    HISTORY:      10-22-2007   - Created 
 *
 *    Copyright <cp> 2007 Microsoft Corporation.  All Rights Reserved.
 *******************************************************************/

using System;
using Microsoft.Webstore.Common;
using Microsoft.Webstore.Management.Wmo;

namespace xonline.tools.wstrunner.core
{
    public class WmoDeploymentFactory : IDeploymentFactory
    {
        public BaseDeployment CreateInstance()
        {
            return WmoDeployment.CreateInstance();
        }
    }
    
    public abstract class BaseDeployment : IDeployment
    {
        public abstract string InXmlPath { get; set; }
        public abstract string DeploymentName { get; set; }
        public abstract bool IsForce { get; set; }
        public abstract bool IsRollingUpgrade { get; set; }
        public abstract bool IsReplTearDown { get; set; }
        public abstract string NewManifestVersion { get; set; }
        public abstract string OutXmlPath { get; set; }
        public abstract bool IsVerbose { get; set; }
        public abstract void Import();
        public abstract void Setup();
        public abstract void Upgrade();
        public abstract void UpdateVersion();
        public abstract void Drop();
        public abstract void Status();
    }

    /// <summary>
    /// Wrap the WmoCommandDeployment class in a pass-through interface layer 
    /// for the purpose of mocking this in unit tests.
    /// </summary>
    public class WmoDeployment : BaseDeployment
    {
        private readonly WmoCommandDeployment wmoDeployment = new WmoCommandDeployment();
        private readonly Log log = Log.GetInstance();

        public static BaseDeployment CreateInstance()
        {
            return new WmoDeployment();
        }

        private WmoDeployment()
        {
            wmoDeployment.WmoStatusEvent += StatusEventHandler;
        }

        //  Properties
        public override string InXmlPath
        {
            get { return wmoDeployment.InXmlPath; }
            set { wmoDeployment.InXmlPath = value; }
        }

        public override string DeploymentName
        {
            get { return wmoDeployment.DeploymentName; }
            set { wmoDeployment.DeploymentName = value; }
        }

        public override bool IsForce
        {
            get { return wmoDeployment.IsForce; }
            set { wmoDeployment.IsForce = value; }
        }

        public override bool IsRollingUpgrade
        {
            get { return wmoDeployment.IsRollingUpgrade; }
            set { wmoDeployment.IsRollingUpgrade = value; }
        }

        public override bool IsReplTearDown
        {
            get { return wmoDeployment.IsReplTearDown; }
            set { wmoDeployment.IsReplTearDown = value; }
        }

        public override string NewManifestVersion
        {
            get { return wmoDeployment.NewManifestVersion; }
            set { wmoDeployment.NewManifestVersion = value; }
        }

        public override string OutXmlPath
        {
            get { return wmoDeployment.OutXmlPath; }
            set { wmoDeployment.OutXmlPath = value; }
        }

        public override bool IsVerbose
        {
            get { return wmoDeployment.IsVerbose; }
            set { wmoDeployment.IsVerbose = value; }
        }

        //  Methods

        public void StatusEventHandler(Object sender, WmoStatusEventArgs eventArgs)
        {
            log.WriteLine(string.Format("{0}", eventArgs));
        }

        // IDeployment

        public override void Import()
        {
            wmoDeployment.Import();
        }

        public override void Setup()
        {
            wmoDeployment.Setup();
        }

        public override void Upgrade()
        {
            wmoDeployment.Upgrade();
        }

        public override void UpdateVersion()
        {
            wmoDeployment.UpdateVersion();
        }

        public override void Drop()
        {
            wmoDeployment.Drop();
        }

        public override void Status()
        {
            wmoDeployment.Status();
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\wstrunner\core\obj\i386\_asmid.inc ===
ASSEMBLY_IDENTITY_KEY_FORM=x86__core_0_none_12.4.56.0_none_e91db01a1ac36ce1
ASSEMBLY_IDENTITY_XP_KEY_FORM=x86__core_0_no-public-key_12.4.56.0_x-ww_c45deb65
ASSEMBLY_IDENTITY_CULTURE=
ASSEMBLY_IDENTITY_NAME=_core_0
ASSEMBLY_IDENTITY_PROCESSOR_ARCHITECTURE=x86
ASSEMBLY_IDENTITY_PUBLIC_KEY=
ASSEMBLY_IDENTITY_PUBLIC_KEY_TOKEN=
ASSEMBLY_IDENTITY_TYPE=
ASSEMBLY_IDENTITY_TYPE_NAME=
ASSEMBLY_IDENTITY_VERSION=12.4.56.0
XP_KEY_FORM=x86__core_0_no-public-key_12.4.56.0_x-ww_c45deb65
XP_MANIFEST_DIRECTORY=manifests
XP_MANIFEST_NAME=x86__core_0_no-public-key_12.4.56.0_x-ww_c45deb65.manifest
XP_MANIFEST_PATH=manifests\x86__core_0_no-public-key_12.4.56.0_x-ww_c45deb65.manifest
XP_CATALOG_DIRECTORY=manifests
XP_CATALOG_NAME=x86__core_0_no-public-key_12.4.56.0_x-ww_c45deb65.cat
XP_CATALOG_PATH=manifests\x86__core_0_no-public-key_12.4.56.0_x-ww_c45deb65.cat
XP_PAYLOAD_PATH=x86__core_0_no-public-key_12.4.56.0_x-ww_c45deb65
_DELAY_SIGN=0
!if [set _ASMIDTOATTRIBS_TLBIMP=]
!endif
CODESIGN_TESTKEY=
_TLBIMP_FLAGS=$(_TLBIMP_FLAGS)  /asmversion:12.4.56.0
_ASSEMBLY_IDENTITY=_core_0,processorArchitecture=x86,version=12.4.56.0,publicKeyToken=neutral
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\wstrunner\core\WmoFailSafeSet.cs ===
/*******************************************************************
 *    FILE:         WmoFailSafeSet.cs
 *
 *    DESCRIPTION:  IFailSafeSet wrapper for WmoCommandFailSafeSet class.
 *
 *    OWNER:        darrenan
 *
 *    HISTORY:      7-18-2008   - Created 
 *
 *    Copyright <cp> 2008 Microsoft Corporation.  All Rights Reserved.
 *******************************************************************/

using System;
using Microsoft.Webstore.Common;
using Microsoft.Webstore.Management.Wmo;

namespace xonline.tools.wstrunner.core
{
    public class WmoFailSafeSetFactory : IFailSafeSetFactory
    {
        public BaseFailSafeSet CreateInstance()
        {
            return WmoFailSafeSet.CreateInstance();
        }
    }
    
    public abstract class BaseFailSafeSet : IFailSafeSet
    {
        #region IFailSafeSet Members

        public abstract string DeploymentName { get; set; }
        public abstract int SQLFSSNum { get; set; }

        public abstract void Demote();
        public abstract void Offline();
        public abstract void DropRepl();

        #endregion
    }

    /// <summary>
    /// Wrap the WmoCommandDatabase class in a pass-through interface layer 
    /// for the purpose of mocking this in unit tests.
    /// </summary>
    public class WmoFailSafeSet : BaseFailSafeSet
    {
        private readonly WmoCommandFailSafeSet wmoFailSafeSet = new WmoCommandFailSafeSet();
        private string deploymentName;
        private int sqlFSSNum;
        private readonly Log log = Log.GetInstance();

        public static WmoFailSafeSet CreateInstance()
        {
            return new WmoFailSafeSet();
        }

        private WmoFailSafeSet()
        {
            wmoFailSafeSet.WmoStatusEvent += StatusEventHandler;
        }

        //  Properties

        //  Methods

        public void StatusEventHandler(Object sender, WmoStatusEventArgs eventArgs)
        {
            log.WriteLine(string.Format("{0}", eventArgs));
        }

        // IDatabase

        public override string DeploymentName
        {
            get
            {
                return deploymentName;
            }
            set
            {
                deploymentName = value;
            }
        }

        public override int SQLFSSNum
        {
            get
            {
                return sqlFSSNum;
            }
            set
            {
                sqlFSSNum = value;
            }
        }

        public override void Demote()
        {
            wmoFailSafeSet.DeploymentName = deploymentName;
            wmoFailSafeSet.SQLFSSNum = sqlFSSNum;
            wmoFailSafeSet.Demote();
        }

        public override void Offline()
        {
            wmoFailSafeSet.DeploymentName = deploymentName;
            wmoFailSafeSet.SQLFSSNum = sqlFSSNum;
            wmoFailSafeSet.Offline();
        }

        public override void DropRepl()
        {
            wmoFailSafeSet.DeploymentName = deploymentName;
            wmoFailSafeSet.SQLFSSNum = sqlFSSNum;
            wmoFailSafeSet.DropRepl();
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\wstrunner\core\WstRunnerFactory.cs ===
namespace xonline.tools.wstrunner.core
{
    public class WstRunnerFactory : IWstRunnerFactory
    {
        private IOracleFactory oracleFactory = new WebstoreOracleFactory();
        private IManifestFactory manifestFactory = new WmoManifestFactory();
        private IDeploymentFactory deploymentFactory = new WmoDeploymentFactory();
        private IDatabaseTemplateFactory databaseTemplateFactory = new WmoDatabaseTemplateFactory();
        private IFailSafeSetFactory failSafeSetFactory = new WmoFailSafeSetFactory();

        public IOracleFactory OracleFactory
        {
            set { oracleFactory = value; }
        }

        public IManifestFactory ManifestFactory
        {
            set { manifestFactory = value; }
        }

        public IDeploymentFactory DeploymentFactory
        {
            set { deploymentFactory = value; }
        }

        public IDatabaseTemplateFactory DatabaseTemplateFactory
        {
            set { databaseTemplateFactory = value; }
        }

        public IFailSafeSetFactory FailSafeSetFactory
        {
            set { failSafeSetFactory = value; }
        }

        public IWstRunner CreateInstance(
            string workingPath,
            string manifestFile,
            string deploymentFile)
        {
            WstRunner runner = WstRunner.CreateInstance(workingPath, manifestFile, deploymentFile);
            runner.OracleFactory = oracleFactory;
            runner.ManifestFactory = manifestFactory;
            runner.DeploymentFactory = deploymentFactory;
            runner.DatabaseTemplateFactory = databaseTemplateFactory;
            runner.FailSafeSetFactory = failSafeSetFactory;

            return runner;
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\wstrunner\core\WmoManifest.cs ===
/*******************************************************************
 *    FILE:         WmoManifest.cs
 *
 *    DESCRIPTION:  IManifest wrapper for WmoCommandManifest class.
 *
 *    OWNER:        darrenan
 *
 *    HISTORY:      10-22-2007   - Created 
 *
 *    Copyright <cp> 2007 Microsoft Corporation.  All Rights Reserved.
 *******************************************************************/

using System;
using Microsoft.Webstore.Common;
using Microsoft.Webstore.Management.Wmo;

namespace xonline.tools.wstrunner.core
{
    public class WmoManifestFactory : IManifestFactory
    {
        public BaseManifest CreateInstance()
        {
            return WmoManifest.CreateInstance();
        }
    }

    public abstract class BaseManifest : IManifest
    {
        public abstract string InXmlPath { get; set;}
        public abstract string ManifestName { get; set;}
        public abstract string ManifestVersion { get; set;}
        public abstract void Import();
        public abstract void Purge();
    }

    /// <summary>
    /// Wrap the WmoCommandManifest class in a pass-through interface layer for the purpose
    /// of mocking this in unit tests.
    /// </summary>
    public class WmoManifest : BaseManifest
    {
        private readonly WmoCommandManifest wmoManifest = new WmoCommandManifest();
        private readonly Log log = Log.GetInstance();

        public static BaseManifest CreateInstance()
        {
            return new WmoManifest();
        }

        private WmoManifest()
        {
            wmoManifest.WmoStatusEvent += StatusEventHandler;
        }

        // Properties
        public override string InXmlPath
        {
            get { return wmoManifest.InXmlPath; }
            set { wmoManifest.InXmlPath = value; }
        }

        public override string ManifestName
        {
            get { return wmoManifest.ManifestName; }
            set { wmoManifest.ManifestName = value; }
        }

        public override string ManifestVersion
        {
            get { return wmoManifest.ManifestVersion; }
            set { wmoManifest.ManifestVersion = value; }
        }

        // Methods
        public override void Import()
        {
            wmoManifest.Import();
        }

        public override void Purge()
        {
            wmoManifest.Purge();
        }

        public void StatusEventHandler(Object sender, WmoStatusEventArgs eventArgs)
        {
            log.WriteLine(string.Format("{0}", eventArgs));
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\wstrunner\core\objd\i386\_asmid.inc ===
ASSEMBLY_IDENTITY_KEY_FORM=x86__core_0_none_12.4.56.0_none_e91db01a1ac36ce1
ASSEMBLY_IDENTITY_XP_KEY_FORM=x86__core_0_no-public-key_12.4.56.0_x-ww_c45deb65
ASSEMBLY_IDENTITY_CULTURE=
ASSEMBLY_IDENTITY_NAME=_core_0
ASSEMBLY_IDENTITY_PROCESSOR_ARCHITECTURE=x86
ASSEMBLY_IDENTITY_PUBLIC_KEY=
ASSEMBLY_IDENTITY_PUBLIC_KEY_TOKEN=
ASSEMBLY_IDENTITY_TYPE=
ASSEMBLY_IDENTITY_TYPE_NAME=
ASSEMBLY_IDENTITY_VERSION=12.4.56.0
XP_KEY_FORM=x86__core_0_no-public-key_12.4.56.0_x-ww_c45deb65
XP_MANIFEST_DIRECTORY=manifests
XP_MANIFEST_NAME=x86__core_0_no-public-key_12.4.56.0_x-ww_c45deb65.manifest
XP_MANIFEST_PATH=manifests\x86__core_0_no-public-key_12.4.56.0_x-ww_c45deb65.manifest
XP_CATALOG_DIRECTORY=manifests
XP_CATALOG_NAME=x86__core_0_no-public-key_12.4.56.0_x-ww_c45deb65.cat
XP_CATALOG_PATH=manifests\x86__core_0_no-public-key_12.4.56.0_x-ww_c45deb65.cat
XP_PAYLOAD_PATH=x86__core_0_no-public-key_12.4.56.0_x-ww_c45deb65
_DELAY_SIGN=0
!if [set _ASMIDTOATTRIBS_TLBIMP=]
!endif
CODESIGN_TESTKEY=
_TLBIMP_FLAGS=$(_TLBIMP_FLAGS)  /asmversion:12.4.56.0
_ASSEMBLY_IDENTITY=_core_0,processorArchitecture=x86,version=12.4.56.0,publicKeyToken=neutral
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\wstrunner\installer\makefile.inc ===
!include $(INETROOT)\build\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\wstrunner\core\WstRunnerConfig.cs ===
﻿using System;
using System.IO;
using System.Collections.Generic;
using System.Text;

namespace xonline.tools.wstrunner.core
{
    public class WstRunnerConfig
    {
        public class WSTVersion
        {
            public int major                = 0;
            public int minor                = 0;
            public int build                = 0;
            public int dot                  = 0;
            public string strVersion        = null;
        };

        //install
        public string jobType               = null;
        public string buildRoot             = null;
        public string webRootDir            = null;
        public string installDir            = null;
        public string environment           = null;
        public string databaseName          = null;
        public string upgradePath           = null;
        public string deployEnabled         = null;
        public string npdbServer            = null;
        public string npdbDatabase          = null;
        public string logRootDir            = null;
        public string userAccount           = null;
        public string adminAccount          = null;
        public string dataFilesDir          = null;
        public string logFilesDir           = null;
        public string dataServerList        = null;
        public uint   partitionCount        = 0;
        public uint   failSafeSetsPerServer = 1;
        public string accountRoleMap        = null;
        public string skipInterfaceConfig   = null;
        public string interfaceName         = null;
        public string manifestPath          = null;
        public WstRunner.SetupAction setAction = WstRunner.SetupAction.None;
        public bool isRollingUpgrade        = false;
        public bool replTearDown            = true;

        //install internal
        public string srcDir                    = null;
        public WSTVersion manifestVersion       = null;
        public WSTVersion failSafeVersion       = null;
        public bool failSafeSetDifferent        = false;
        public int fssNumber                    = 0;
        public WSTVersion installVersion        = null;
        public string deployVersion             = null;
        public string srcDirProdbaseDDL         = null;
        public string dstDirDDL                 = null;
        public string srcDirProdbaseDML         = null;
        public string dstDirDML                 = null;
        public string srcDirProdbaseOther       = null;
        public string dstDirOther               = null;
        public string dataDir                   = null;
        public string envDir                    = null;
        public string srcFile                   = null;
        public string dstFile                   = null;
        public FileInfo deploymentFile          = null;

        //uninstall internal
        public string dstDir                = null;
        public string computerName          = null;

        //ProdRestorePrep internal
        public string bakFile               = null;
        public string prodPath              = null;
        public string upgradeInstallDir     = null;

        //DisableAndStopJob internal
        public string sqlJobName            = null;

        public string deploymentFilename = null;
        public bool isUpgrade            = false;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\wstrunner\installer\obj\i386\_generated.cs ===
[assembly:System.Runtime.InteropServices.ComVisible(false)]
[assembly:System.Reflection.AssemblyVersion("12.4.56.0")]
[assembly:System.Reflection.AssemblyProduct("Microsoft(R) Xbox(TM)")]
[assembly:System.Reflection.AssemblyCopyright("Copyright (c) Microsoft Corporation. All rights reserved.")]
[assembly:System.Reflection.AssemblyCompany("Microsoft Corporation")]
[assembly:System.Reflection.AssemblyFileVersion("12.4.56.0")]
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\wstrunner\installer\obj\i386\_asmid.inc ===
ASSEMBLY_IDENTITY_KEY_FORM=msil_xonline.tools.wstrunner.installer_none_12.4.56.0_none_7d150d71c1faaff7
ASSEMBLY_IDENTITY_XP_KEY_FORM=msil_xonline.tools.wstrunner.installer_no-public-key_12.4.56.0_x-ww_418bed4f
ASSEMBLY_IDENTITY_CULTURE=
ASSEMBLY_IDENTITY_NAME=xonline.tools.wstrunner.installer
ASSEMBLY_IDENTITY_PROCESSOR_ARCHITECTURE=msil
ASSEMBLY_IDENTITY_PUBLIC_KEY=
ASSEMBLY_IDENTITY_PUBLIC_KEY_TOKEN=
ASSEMBLY_IDENTITY_TYPE=
ASSEMBLY_IDENTITY_TYPE_NAME=
ASSEMBLY_IDENTITY_VERSION=12.4.56.0
XP_KEY_FORM=msil_xonline.tools.wstrunner.installer_no-public-key_12.4.56.0_x-ww_418bed4f
XP_MANIFEST_DIRECTORY=manifests
XP_MANIFEST_NAME=msil_xonline.tools.wstrunner.installer_no-public-key_12.4.56.0_x-ww_418bed4f.manifest
XP_MANIFEST_PATH=manifests\msil_xonline.tools.wstrunner.installer_no-public-key_12.4.56.0_x-ww_418bed4f.manifest
XP_CATALOG_DIRECTORY=manifests
XP_CATALOG_NAME=msil_xonline.tools.wstrunner.installer_no-public-key_12.4.56.0_x-ww_418bed4f.cat
XP_CATALOG_PATH=manifests\msil_xonline.tools.wstrunner.installer_no-public-key_12.4.56.0_x-ww_418bed4f.cat
XP_PAYLOAD_PATH=msil_xonline.tools.wstrunner.installer_no-public-key_12.4.56.0_x-ww_418bed4f
_DELAY_SIGN=0
!if [set _ASMIDTOATTRIBS_TLBIMP=]
!endif
CODESIGN_TESTKEY=
_TLBIMP_FLAGS=$(_TLBIMP_FLAGS)  /asmversion:12.4.56.0
_ASSEMBLY_IDENTITY=xonline.tools.wstrunner.installer,processorArchitecture=msil,version=12.4.56.0,publicKeyToken=neutral
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\wstrunner\installer\objd\i386\_asmid.inc ===
ASSEMBLY_IDENTITY_KEY_FORM=msil_xonline.tools.wstrunner.installer_none_12.4.56.0_none_7d150d71c1faaff7
ASSEMBLY_IDENTITY_XP_KEY_FORM=msil_xonline.tools.wstrunner.installer_no-public-key_12.4.56.0_x-ww_418bed4f
ASSEMBLY_IDENTITY_CULTURE=
ASSEMBLY_IDENTITY_NAME=xonline.tools.wstrunner.installer
ASSEMBLY_IDENTITY_PROCESSOR_ARCHITECTURE=msil
ASSEMBLY_IDENTITY_PUBLIC_KEY=
ASSEMBLY_IDENTITY_PUBLIC_KEY_TOKEN=
ASSEMBLY_IDENTITY_TYPE=
ASSEMBLY_IDENTITY_TYPE_NAME=
ASSEMBLY_IDENTITY_VERSION=12.4.56.0
XP_KEY_FORM=msil_xonline.tools.wstrunner.installer_no-public-key_12.4.56.0_x-ww_418bed4f
XP_MANIFEST_DIRECTORY=manifests
XP_MANIFEST_NAME=msil_xonline.tools.wstrunner.installer_no-public-key_12.4.56.0_x-ww_418bed4f.manifest
XP_MANIFEST_PATH=manifests\msil_xonline.tools.wstrunner.installer_no-public-key_12.4.56.0_x-ww_418bed4f.manifest
XP_CATALOG_DIRECTORY=manifests
XP_CATALOG_NAME=msil_xonline.tools.wstrunner.installer_no-public-key_12.4.56.0_x-ww_418bed4f.cat
XP_CATALOG_PATH=manifests\msil_xonline.tools.wstrunner.installer_no-public-key_12.4.56.0_x-ww_418bed4f.cat
XP_PAYLOAD_PATH=msil_xonline.tools.wstrunner.installer_no-public-key_12.4.56.0_x-ww_418bed4f
_DELAY_SIGN=0
!if [set _ASMIDTOATTRIBS_TLBIMP=]
!endif
CODESIGN_TESTKEY=
_TLBIMP_FLAGS=$(_TLBIMP_FLAGS)  /asmversion:12.4.56.0
_ASSEMBLY_IDENTITY=xonline.tools.wstrunner.installer,processorArchitecture=msil,version=12.4.56.0,publicKeyToken=neutral
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\wstrunner\core\WstRunner.cs ===
/*******************************************************************
 *    FILE:         WstRunner.cs
 *
 *    DESCRIPTION:  Main WstRunner class.
 *
 *    OWNER:        darrenan
 *
 *    HISTORY:      10-22-2007   - Created 
 *
 *    Copyright <cp> 2007 Microsoft Corporation.  All Rights Reserved.
 *******************************************************************/

using Microsoft.SqlServer.Management.Smo;
using Microsoft.SqlServer.Management.Smo.Agent;
using System;
using System.Collections.Generic;
using System.IO;
using Microsoft.Webstore.MetaData;
using Microsoft.Webstore.WstClient;
using System.Threading;

namespace xonline.tools.wstrunner.core
{
    /// <summary>
    /// Provides the entry point for the WstRunner components.
    /// </summary>
    /// <remarks>
    ///  
    ///</remarks>
    public class WstRunner : IWstRunner
    {
        #region Members

        private readonly string _workingPath;
        private readonly string _manifestFile;
        private readonly string _deploymentFile;
        private readonly Log _log = Log.GetInstance();
        private IOracleFactory oracleFactory = new WebstoreOracleFactory();
        private IManifestFactory manifestFactory = new WmoManifestFactory();
        private IDeploymentFactory deploymentFactory = new WmoDeploymentFactory();
        private IDatabaseTemplateFactory databaseTemplateFactory = new WmoDatabaseTemplateFactory();
        private IFailSafeSetFactory failSafeSetFactory = new WmoFailSafeSetFactory();

        public enum SetupAction
        {
            None,
            Install,
            Upgrade
        } ;

        #endregion

        #region Constructors

        public static WstRunner CreateInstance(
            string workingPath,
            string manifestFile,
            string deploymentFile
            )
        {
            return new WstRunner(workingPath, manifestFile, deploymentFile);
        }

        /// <summary>
        /// Initializes a new instance of the WstRunner class.
        /// </summary>
        /// <param name="workingPath">
        /// The path to the directory that will be used as the base directory 
        /// for any relative paths to files defined in the manifest.  Passing 
        /// null or an empty string will result in an ArgumentNullException
        /// being thrown.  It is expected that this directory contains the
        /// manifest file and all .sql files that comprise this webstore
        /// application.  The webstore deployment file will be generated in
        /// this directory as well.
        /// </param>
        /// <param name="manifestFile">
        /// The name of the manifest file, sans path information.  This file
        /// must exist in workingPath, as must all files referenced by the
        /// manifest file.
        /// </param>
        /// <param name="deploymentFile">
        /// The name of the deployment file, sans path information.  This file
        /// must exist in workingPath.
        /// </param>
        /// <exception cref="ArgumentNullException">
        /// One of the arguments passed
        /// was null.
        /// </exception>
        private WstRunner(
            string workingPath,
            string manifestFile,
            string deploymentFile
            )
        {
            //
            //  Working path validation
            //

            if (string.IsNullOrEmpty(workingPath))
            {
                throw new ArgumentNullException("workingPath");
            }

            workingPath = workingPath.Trim();

            if (Path.GetExtension(workingPath) != String.Empty)
            {
                throw new ArgumentException("Filename passed in for working directory.", workingPath);
            }

            if (!Directory.Exists(workingPath))
            {
                throw new DirectoryNotFoundException("Directory not found: \"" + workingPath + "\"");
            }

            //
            //  Manifest file validation.
            //

            if (string.IsNullOrEmpty(manifestFile))
            {
                throw new ArgumentNullException("manifestFile");
            }

            if (Path.GetDirectoryName(manifestFile) != String.Empty)
            {
                throw new ArgumentException("The manifestFile parameter must not contain path information.", manifestFile);
            }

            if (!File.Exists(Path.Combine(workingPath, manifestFile)))
            {
                throw new FileNotFoundException("File not found: \"" + Path.Combine(workingPath, manifestFile));
            }

            //
            //  Deployment file validation
            //

            if (string.IsNullOrEmpty(deploymentFile))
            {
                throw new ArgumentNullException("deploymentFile");
            }

            if (Path.GetDirectoryName(deploymentFile) != String.Empty)
            {
                throw new ArgumentException("The deploymentFile parameter must not contain path information.", deploymentFile);
            }

            if (!File.Exists(Path.Combine(workingPath, deploymentFile)))
            {
                throw new FileNotFoundException("File not found: \"" + Path.Combine(workingPath, deploymentFile));
            }

            //
            //  Save values.
            //

            _workingPath = workingPath;
            _manifestFile = Path.Combine(workingPath, manifestFile);
            _deploymentFile = Path.Combine(workingPath, deploymentFile);
        }

        #endregion

        #region Properties

        /// <summary>
        /// The path to the directory that will be used as the base directory 
        /// for any relative paths to files defined in children steps.
        /// </summary>
        /// <remarks>
        /// Setting this property to null or an empty string will default this
        /// property to the current working directory.  If the path contains a
        /// file, the file name will be removed from the path and the directory
        /// containing the passed file will be used as the working path.       
        /// </remarks>
        /// <exception cref="ArgumentException">
        /// The WorkingPath was set to a value containing characters that are 
        /// not valid in a path specification
        /// </exception>
        /// <exception cref="FileNotFoundException">
        /// An attempt was made to set the WorkingPath to a non-existant 
        /// directory.
        /// </exception>
        public string WorkingPath
        {
            get { return _workingPath; }
        }

        public string ManifestFile
        {
            get { return _manifestFile; }
        }

        public string DeploymentFile
        {
            get { return _deploymentFile; }
        }
        public IManifestFactory ManifestFactory
        {
            set { manifestFactory = value; }
        }

        public IDeploymentFactory DeploymentFactory
        {
            set { deploymentFactory = value; }
        }

        public IFailSafeSetFactory FailSafeSetFactory
        {
            set { failSafeSetFactory = value; }
        }

        public IDatabaseTemplateFactory DatabaseTemplateFactory
        {
            set { databaseTemplateFactory = value; }
        }

        public IOracleFactory OracleFactory
        {
            set { oracleFactory = value; }
        }

        #endregion

        #region Methods

        private SetupAction GetSetupAction()
        {
            SetupAction action;

            BaseManifest wmoManifest = manifestFactory.CreateInstance();
            IOracle oracle = oracleFactory.CreateInstance();
            Manifest manifest = new Manifest(wmoManifest, oracle, _manifestFile);
            _log.WriteLine(string.Format("Loaded version {0} of manifest \"{1}\" from \"{2}\".", manifest.Version, manifest.Name, _manifestFile));

            if (oracle.IsManifestImported(manifest.Name, manifest.Version))
            {
                action = SetupAction.None;
            }
            else if (oracle.IsManifestImported(manifest.Name))
            {
                action = SetupAction.Upgrade;
            }
            else
            {
                action = SetupAction.Install;
            }

            return action;
        }

        /// <summary>
        /// This method will do an add or upgrade as appropriate, based on the
        /// manifest provided.
        /// </summary>
        public void Setup(SetupAction sAction, bool isRollingUpgrade, bool replTearDown)
        {
            switch (sAction)
            {
                case SetupAction.Install:
                    _log.WriteLine("Performing initial database installation.");
                    Add();
                    _log.WriteLine("Installation complete.");
                    break;

                case SetupAction.Upgrade:
                    _log.WriteLine("Detected existing database installation with lower version, proceeding with upgrade.");
                    Upgrade(isRollingUpgrade, replTearDown);
                    _log.WriteLine("Upgrade complete.");
                    break;

                case SetupAction.None:
                    _log.WriteLine("Detected existing database installation with current version, no action required.");
                    break;
            }
        }
        /// <summary>
        /// Repairs the primary first and then the secondary
        /// </summary>
        /// <returns></returns>
        protected void Repair(Database db,bool isForce)
        {
            
            WmoDatabase wmoDatabase = WmoDatabase.CreateInstance();
            wmoDatabase.Database = db.Name;
            wmoDatabase.Server = db.Server;
            wmoDatabase.Repair(isForce);
           
        }
        protected void Online(Database db)
        {
          
            WmoDatabase wmoDatabase = WmoDatabase.CreateInstance();
            wmoDatabase.Database = db.Name;
            wmoDatabase.Server = db.Server;
            wmoDatabase.MarkOnline();
         
        }
        /// <summary>
        /// Promotes the Database
        /// </summary>
        /// <param name="db"></param>
        protected void Promote(Database db)
        {
            WmoDatabase wmoDatabase = WmoDatabase.CreateInstance();
            wmoDatabase.Database = db.Name;
            wmoDatabase.Server = db.Server;
            wmoDatabase.Promote();
        }

        private List<Database> GetDeploymentDatabases(string dbIdentifier)
        {
            IOracle oracle = oracleFactory.CreateInstance();
            List<Database> databases;
            BaseDeployment wmoDeployment = deploymentFactory.CreateInstance();
            BaseDatabaseTemplate wmoDatabaseTemplate = databaseTemplateFactory.CreateInstance();
            Deployment deployment = new Deployment(wmoDeployment, wmoDatabaseTemplate, oracle, _deploymentFile);
            switch (dbIdentifier)
            {
                case "pri":
                    databases= deployment.PrimaryDatabases;
                    break;
               case "sec":
                    databases= deployment.SecondaryDatabases;
                    break;
                case "all":
                    databases= deployment.Databases;
                    break;
                default:
                    return null;
            }
            return databases;
        }

        private Database GetDeploymentDefaultPrimary()
        {
            IOracle oracle = oracleFactory.CreateInstance();
            BaseDeployment wmoDeployment = deploymentFactory.CreateInstance();
            BaseDatabaseTemplate wmoDatabaseTemplate = databaseTemplateFactory.CreateInstance();
            Deployment deployment = new Deployment(wmoDeployment, wmoDatabaseTemplate, oracle, _deploymentFile);
            return deployment.DefaultPrimary;
        }
        private List<Database> GetDeploymentPrimaryDatabases()
        {
            return GetDeploymentDatabases("pri");
        }
        private List<Database> GetDeploymentSecondaryDatabases()
        {
            return GetDeploymentDatabases("sec");
        }
        private List<Database> GetDeploymentAllDatabase()
        {
            return GetDeploymentDatabases("all");
        }
        public void RepairwithOnlinePromote()
        {
            
            Database defaultPrimary = GetDeploymentDefaultPrimary();
            if (defaultPrimary != null)
            {
                if (!defaultPrimary.Status.Equals("online"))
                {
                    Repair(defaultPrimary,true);
                    Online(defaultPrimary);
                    Promote(defaultPrimary);
                }
            }
            //sleep for webstore polling period
            WaitForPollingPeriod();
            if (GetDeploymentPrimaryDatabases().Count > 0)
            {
                List<Database> secondaryDatabases = GetDeploymentSecondaryDatabases();
                foreach (Database db in secondaryDatabases.ToArray())
                {
                    Repair(db,false);
                }
                secondaryDatabases = GetDeploymentSecondaryDatabases();
                foreach (Database db in secondaryDatabases.ToArray())
                {
                    Online(db);
                }
            }
        }
        protected void WaitForPollingPeriod()
        {
            // wait for polling period
            WebstoreEnvironmentSettings env = WebstoreMetaData.Instance.DefaultConfig.EnvironmentSettings;
            int sleepinterval = env.PollingIntervalService * 1000;
            Thread.Sleep(sleepinterval);
        }
        /// <summary>
        /// Marks the secondaries and the primaries as Needs repair
        /// </summary>
        public void MarkNeedsRepair()
        {
            List<Database> secondaryDatabases = GetDeploymentSecondaryDatabases();
            List<Database> primaryDatabases = GetDeploymentPrimaryDatabases();
            //Mark the Secondary as needs repair
            if (secondaryDatabases != null)
            {
                foreach (Database db in secondaryDatabases.ToArray())
                {
                    WmoDatabase wmoDatabase = WmoDatabase.CreateInstance();
                    wmoDatabase.Database = db.Name;
                    wmoDatabase.Server = db.Server;
                    wmoDatabase.NeedsRepair();
                }
            }
               if (primaryDatabases != null)
                {
                    //Mark the primary as needs repair
                    foreach (Database db in primaryDatabases.ToArray())
                    {
                        WmoDatabase wmoDatabase = WmoDatabase.CreateInstance();
                        wmoDatabase.Database = db.Name;
                        wmoDatabase.Server = db.Server;
                        wmoDatabase.NeedsRepair();
                    }
                }
        }
        /// <summary>
        /// 
        /// </summary>
        protected void Upgrade(bool isRollingUpgrade, bool replTearDown)
        {
            IOracle oracle = oracleFactory.CreateInstance();

            BaseManifest wmoManifest = manifestFactory.CreateInstance();
            Manifest manifest = new Manifest(wmoManifest, oracle, _manifestFile);
            string manifestVersion = manifest.Version;
            manifest.Import();

            BaseDeployment wmoDeployment = deploymentFactory.CreateInstance();
            BaseDatabaseTemplate wmoDatabaseTemplate = databaseTemplateFactory.CreateInstance();
            Deployment deployment = new Deployment(wmoDeployment, wmoDatabaseTemplate, oracle, _deploymentFile);

            if (oracle.GetVersionForDeployment(deployment.Name) != manifestVersion)
                deployment.UpdateVersion(manifestVersion);

            deployment.Upgrade(isRollingUpgrade, replTearDown, false);
        }
        /// <summary>
        /// Add a new webstore application.  This is a first-time install
        /// scenario.
        /// </summary>
        protected void Add()
        {
            IOracle oracle = oracleFactory.CreateInstance();

            BaseManifest wmoManifest = manifestFactory.CreateInstance();
            Manifest manifest = new Manifest(wmoManifest, oracle, _manifestFile);

            //  Import the manifest.
            manifest.Import();

            BaseDeployment wmoDeployment = deploymentFactory.CreateInstance();
            BaseDatabaseTemplate wmoDatabaseTemplate = databaseTemplateFactory.CreateInstance();
            Deployment deployment = new Deployment(wmoDeployment, wmoDatabaseTemplate, oracle, _deploymentFile);

            //  Create and import the deployment file.
            deployment.Import();

            //  Setup the deployment.
            deployment.Setup();
        }

        /// <summary>
        /// Remove a webstore application, and drop the underlying databases.
        /// </summary>
        /// <param name="removeDatabase"></param>
        public void Remove(bool removeDatabase)
        {
            if (!removeDatabase)
            {
                return;
            }

            IOracle oracle = oracleFactory.CreateInstance();

            BaseManifest wmoManifest = manifestFactory.CreateInstance();
            BaseDeployment wmoDeployment = deploymentFactory.CreateInstance();
            BaseDatabaseTemplate wmoDatabaseTemplate = databaseTemplateFactory.CreateInstance();
            List<Database> databasesToRemove = new List<Database>();

            //
            //  Try to get manifest and deployment files from Webstore config db.
            //  If they're not imported, just use the versions of the files that
            //  currently reside on the hard disk.
            //

            Manifest manifest = new Manifest(wmoManifest, oracle, _manifestFile);

            Deployment deployment = new Deployment(wmoDeployment, wmoDatabaseTemplate, oracle, _deploymentFile);
            if (oracle.IsDeploymentImported(deployment.Name))
            {
                deployment = new Deployment(
                    wmoDeployment,
                    wmoDatabaseTemplate,
                    oracle,
                    oracle.ExportDeployment(deployment.Name).FullName);
            }

            //
            //  Before we do any of the replication teardown stuff,
            //  build up the list of databases.
            //

            foreach (Database database in deployment.Databases)
            {
                databasesToRemove.Add(database);
            }

            //
            //  Now loop through the failsafe sets, performing
            //  the replication teardown operations.
            //

            if (oracle.IsDeploymentImported(deployment.Name))
            {
                BaseFailSafeSet failSafeSet = failSafeSetFactory.CreateInstance();
                using (WstConnection connection = new WstConnection(deployment.Name))
                {
                    connection.Open();

                    WebstoreSQLFssCollection collection = connection.SqlPartitions;
                    foreach (WebstoreSQLFss partition in collection)
                    {
                        //
                        //  Step 1.  Demote FSS.
                        //

                        failSafeSet.DeploymentName = deployment.Name;
                        failSafeSet.SQLFSSNum = partition.FssId;
                        failSafeSet.Demote();

                        //
                        //  Step 2.  Offline FSS.
                        //

                        failSafeSet.DeploymentName = deployment.Name;
                        failSafeSet.SQLFSSNum = partition.FssId;
                        failSafeSet.Offline();

                        //
                        //  Step 3.  Drop replication on FSS.
                        //

                        failSafeSet.DeploymentName = deployment.Name;
                        failSafeSet.SQLFSSNum = partition.FssId;
                        failSafeSet.DropRepl();
                    }
                }

                deployment.Drop();
            }

            //  Make sure we don't infinite loop trying to purge the same
            //  manifest over and over.
            string previousVersionSeen = "";
            while (oracle.IsManifestImported(manifest.Name))
            {
                if (oracle.ManifestVersions(manifest.Name)[0] == previousVersionSeen)
                {
                    _log.WriteLine(string.Format("Unable to purge all manifest versions for manifest {0}.",
                                                 manifest.Name));
                    break;
                }

                previousVersionSeen = oracle.ManifestVersions(manifest.Name)[0];
                Manifest manifestToPurge = new Manifest(
                    wmoManifest,
                    oracle,
                    oracle.ExportManifest(manifest.Name, previousVersionSeen,
                                          false, false).FullName);
                manifestToPurge.Purge();

                oracle.Refresh();
            }

            //
            //  Purge templates
            //

            wmoDatabaseTemplate.Purge();

            //
            //  Now remove the databases and any jobs from SQL
            //

            //  Get the list of jobs to remove from the manifest.

            string[] jobsToRemove = manifest.Jobs;

            //  Now loop through all the database servers, dropping
            //  databases and jobs.

            foreach (Database database in databasesToRemove)
            {
                Server s = new Server(database.Server);

                //  Drop all jobs specified by the manifest.

                JobServer jobServer = s.JobServer;
                if (jobServer != null)
                {
                    foreach (string jobName in jobsToRemove)
                    {
                        Job job = jobServer.Jobs[jobName];

                        if (job != null)
                        {
                            job.Drop();
                            _log.WriteLine(string.Format("Removed job \"{0}\" from {1}.", jobName,
                                                         database.Name));
                        }
                    }
                }

                //  Now drop the database itself.

                if (s.Databases.Contains(database.Name))
                {
                    s.Databases["master"].ExecuteNonQuery(
                        string.Format("ALTER DATABASE {0} SET SINGLE_USER with ROLLBACK IMMEDIATE",
                                      database.Name));
                    s.Databases[database.Name].Drop();
                    _log.WriteLine(string.Format("Dropped database {0}.", database.Name));
                }
            }
        }

        #endregion

    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\wstrunner\installer\objd\i386\_generated.cs ===
[assembly:System.Runtime.InteropServices.ComVisible(false)]
[assembly:System.Reflection.AssemblyVersion("12.4.56.0")]
[assembly:System.Reflection.AssemblyProduct("Microsoft(R) Xbox(TM)")]
[assembly:System.Reflection.AssemblyCopyright("Copyright (c) Microsoft Corporation. All rights reserved.")]
[assembly:System.Reflection.AssemblyCompany("Microsoft Corporation")]
[assembly:System.Reflection.AssemblyFileVersion("12.4.56.0")]
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\wstrunner\test\makefile.inc ===
!include $(INETROOT)\build\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\wstrunner\installer\WstRunnerInstaller.cs ===
/*******************************************************************
 *    FILE:         WstRunnerInstaller.cs
 *
 *    DESCRIPTION:  InstallUtil interface into WstRunner.  
 *
 *    OWNER:        darrenan
 *
 *    HISTORY:      11/8/2007   - Created 
 *
 *    Copyright <cp> 2008 Microsoft Corporation.  All Rights Reserved.
 *******************************************************************/

using Microsoft.Win32;
using System;
using System.IO;
using System.Collections;
using System.Diagnostics;
using System.ComponentModel;
using System.Configuration.Install;
using xonline.tools.wstrunner.core;

namespace xonline.tools.wstrunner.installer
{
	/// <summary>
	/// This class exposes the standard Installer interface for WstRunner.
	/// </summary>
	[RunInstaller(true)]
	public class WstRunnerInstaller : Installer
    {
        #region Members

        private EventLog _eventLog;
	    private static readonly Log _log = Log.GetInstance();
	    private IWstRunnerFactory _wstRunnerFactory = new WstRunnerFactory();
	    private IDeploymentFileFactory _deploymentFileFactory = new DeploymentFileFactory();

		/// <summary>
		/// Required designer variable.
		/// </summary>
		private readonly Container components = null;

        #endregion

        #region Constructors

        public WstRunnerInstaller()
		{
            Initialize();
			InitializeComponent();
		}

        #endregion

        #region Properties

	    public IWstRunnerFactory WstRunnerFactory
	    {
	        set { _wstRunnerFactory = value; }
	    }

	    public IDeploymentFileFactory DeploymentFactory
	    {
            set { _deploymentFileFactory = value; }
	    }

        #endregion

        /// <summary> 
		/// Clean up any resources being used.
		/// </summary>
		protected override void Dispose( bool disposing )
		{
			if( disposing )
			{
				if(components != null)
				{
					components.Dispose();
				}
			}
			base.Dispose( disposing );
		}

        /// <summary>
        /// Returns true if the DebugBreak registry value is set to a non-zero value
        /// under HKLM\Software\Microsoft\ESP\Deployment\WstRunner.
        /// </summary>
        /// <returns>True if DebugBreak is configured, false otherwise.</returns>

        private const string debugBreakRegKey = "Software\\Microsoft\\ESP\\Deployment\\WstRunner";
        private const string debugBreakValue = "DebugBreak";

        private static bool DebugBreak
        {
            get
            {
                RegistryKey wstRunnerRegKey = Registry.LocalMachine.OpenSubKey(debugBreakRegKey);

                if (wstRunnerRegKey == null)
                {
                    return false;
                }

                Object debugBreakObj = wstRunnerRegKey.GetValue(debugBreakValue);
                if (debugBreakObj == null)
                {
                    return false;
                }

                RegistryValueKind rvk = wstRunnerRegKey.GetValueKind("DebugBreak");
                if (rvk != RegistryValueKind.DWord)
                {
                    return false;
                }

                int debugBreak = (int) debugBreakObj;

                return debugBreak != 0;
            }
        }

        /// <summary>
        /// Main installation entry point.
        /// </summary>
        /// <param name="stateSaver"></param>
        public override void Install(IDictionary stateSaver)
        {
            if(DebugBreak)
            {
                Debugger.Break();
            }

            _log.WriteLine("Entering WstRunnerInstaller.Install().");

            base.Install (stateSaver);

            if (Context.Parameters["dataFilePath"] == null)
            {
                throw new NullReferenceException("The dataFilePath parameter must be specified. It should contain the path that will contain the database MDF file.");
            }

            if (!Directory.Exists(Context.Parameters["dataFilePath"]))
            {
                Directory.CreateDirectory(Context.Parameters["dataFilePath"]);
            }

            if (Context.Parameters["logFilePath"] == null)
            {
                throw new NullReferenceException("The logFilePath parameter must be specified. It should contain the path that will contain the database LDF file.");
            }

            if (!Directory.Exists(Context.Parameters["logFilePath"]))
            {
                Directory.CreateDirectory(Context.Parameters["logFilePath"]);
            }

            if(Context.Parameters["manifestXml"] == null)
            {
                throw new NullReferenceException("The manifestXml parameter must be specified. It should contain the path to the Webstore Manifest file.");
            }

            FileInfo wstManifestFile = new FileInfo(Context.Parameters["manifestXml"]);
            string message;
            if ((wstManifestFile == null) || (wstManifestFile.Length == 0))
            {
                throw new NullReferenceException("The manifestXml parameter must be specified. It should contain the path to the Webstore Manifest file.");
            }

            if(!wstManifestFile.Exists)
            {
                throw new FileNotFoundException("Manifest file does not exist.", wstManifestFile.FullName);
            }

            try
            {
                string deploymentXmlFileName = Context.Parameters["deploymentXml"];
                if(deploymentXmlFileName == null || deploymentXmlFileName.Trim().Length == 0)
                {
                    _log.WriteLine("/deploymentXml parameter not passed, using default file name \"deployment.xml\".");
                    deploymentXmlFileName = Path.Combine(
                        Path.GetDirectoryName(wstManifestFile.FullName),
                        "deployment.xml");
                }
                else
                {
                    _log.WriteLine(string.Format("/deploymentXml = \"{0}\".", deploymentXmlFileName));
                    deploymentXmlFileName = Path.Combine(
                        Path.GetDirectoryName(wstManifestFile.FullName),
                        deploymentXmlFileName);
                }

                FileInfo wstDeploymentFile = new FileInfo(deploymentXmlFileName);

                if (!wstDeploymentFile.Exists)
                {
                    _log.WriteLine(string.Format("Deployment file \"{0}\" does not exist, autogenerating.", deploymentXmlFileName));
                    wstDeploymentFile = _deploymentFileFactory.CreateDeployment(
                        wstManifestFile,
                        deploymentXmlFileName,
                        Context.Parameters["dataFilePath"],
                        Context.Parameters["logFilePath"],
                        Context.Parameters["configServerList"],
                        Context.Parameters["dataServerList"],
                        Context.Parameters.ContainsKey("failSafeSetsPerServer") ? UInt32.Parse(Context.Parameters["failSafeSetsPerServer"]) : 1,
                        Context.Parameters["accountRoleMap"],
                        UInt32.Parse(Context.Parameters["partitionCount"]),
                        Context.Parameters["databaseName"]);
                }
                else
                {
                    _log.WriteLine(string.Format("Using existing deployment file \"{0}\".", wstDeploymentFile));
                }

                message = String.Format("WstRunner started processing manifest '{0}' using deployment '{1}' at {2}", wstManifestFile, wstDeploymentFile, DateTime.Now);
                _eventLog.WriteEntry(message, EventLogEntryType.Information);
                _log.WriteLine(message);

                string workingPath;
                if(Directory.Exists(wstManifestFile.DirectoryName))
                {
                    workingPath = wstManifestFile.DirectoryName;
                }
                else
                {
                    workingPath = Environment.CurrentDirectory;
                }

                IWstRunner runner = _wstRunnerFactory.CreateInstance(
                    workingPath,
                    wstManifestFile.Name,
                    wstDeploymentFile.Name
                    );

                runner.Setup(WstRunner.SetupAction.Install, false, false);
            }
            catch (Exception ex)
            {
                _log.WriteLine("ERROR: Exception encountered executing WstRunner.");
                _log.WriteLine(ex.ToString());

                message = string.Format("Exception encountered executing WstRunner: \r\n{0}", ex);
                _eventLog.WriteEntry(message, EventLogEntryType.Error, 65000);
                throw;
            }

            message = String.Format("WstRunner processing of '{0}' completed at {1}", wstManifestFile, DateTime.Now);
            _eventLog.WriteEntry(message, EventLogEntryType.Information);
            _log.WriteLine(message);

            _log.WriteLine("Exiting WstRunnerInstaller.Install().");
        }

        // even though these overriddent methods appear to do nothing,
        // omiting them will leave temp files behind after the install.
        public override void Commit(IDictionary savedState)
        {
            if (DebugBreak)
            {
                Debugger.Break();
            }

            _log.WriteLine("Entering WstRunnerInstaller.Commit().");

            base.Commit(savedState);

            _log.WriteLine("Exiting WstRunnerInstaller.Commit().");
        }

        public override void Rollback(IDictionary savedState)
        {
            if (DebugBreak)
            {
                Debugger.Break();
            }

            _log.WriteLine("Entering WstRunnerInstaller.Rollback().");

            string message;
            FileInfo wstManifestFile;
            FileInfo wstDeploymentFile;

            try
            {
                base.Rollback(savedState);

                wstManifestFile = new FileInfo(Context.Parameters["manifestXml"]);

                if (wstManifestFile.Length == 0)
                {
                    throw new NullReferenceException("The manifestXml parameter must be specified. It should contain the path to the Webstore Manifest file.");
                }

                wstDeploymentFile = new FileInfo(
                    Path.Combine(Path.GetDirectoryName(Context.Parameters["manifestXml"]),
                                 "deployment.xml"));
                if (wstDeploymentFile.Length == 0)
                {
                    throw new NullReferenceException("The deploymentXml parameter must be specified. It should contain the path to the Webstore Deployment file.");
                }

                message = String.Format("WstRunner started processing manifest '{0}' using deployment '{1}' at {2}", wstManifestFile, wstDeploymentFile, DateTime.Now);
                _eventLog.WriteEntry(message, EventLogEntryType.Information);
                _log.WriteLine(message);

                string workingPath;
                if (Directory.Exists(wstManifestFile.DirectoryName))
                {
                    workingPath = wstManifestFile.DirectoryName;
                }
                else if (Directory.Exists(wstDeploymentFile.DirectoryName))
                {
                    workingPath = wstDeploymentFile.DirectoryName;
                }
                else
                {
                    workingPath = Environment.CurrentDirectory;
                }

                IWstRunner runner = _wstRunnerFactory.CreateInstance(
                    workingPath,
                    wstManifestFile.Name,
                    wstDeploymentFile.Name);

                runner.Remove(!Boolean.Parse(Context.Parameters["isUpgrade"]));

                wstDeploymentFile.Delete();
            }
            catch (Exception ex)
            {
                _log.WriteLine("ERROR: Exception encountered executing WstRunner.");
                _log.WriteLine(ex.ToString());

                message = string.Format("Exception encountered executing WstRunner: \r\n{0}", ex);
                _eventLog.WriteEntry(message, EventLogEntryType.Error, 65000);
                throw;
            }

            message = String.Format("WstRunner processing of '{0}' completed at {1}", wstManifestFile, DateTime.Now);
            _eventLog.WriteEntry(message, EventLogEntryType.Information);
            _log.WriteLine(message);

            _log.WriteLine("Exiting WstRunnerInstall.Rollback().");
        }

        public override void Uninstall(IDictionary stateSaver)
        {
            if (DebugBreak)
            {
                Debugger.Break();
            }

            _log.WriteLine("Entering WstRunnerInstaller.Uninstall().");

            string message;
            FileInfo wstManifestFile;
            FileInfo wstDeploymentFile;
            
            try
            {
                base.Uninstall(stateSaver);

                wstManifestFile = new FileInfo(Context.Parameters["manifestXml"]);

                if (wstManifestFile.Length == 0)
                {
                    throw new NullReferenceException("The manifestXml parameter must be specified. It should contain the path to the Webstore Manifest file.");
                }

                wstDeploymentFile = new FileInfo(
                    Path.Combine(Path.GetDirectoryName(Context.Parameters["manifestXml"]),
                                 "deployment.xml"));
                if (wstDeploymentFile.Length == 0)
                {
                    throw new NullReferenceException("The deploymentXml parameter must be specified. It should contain the path to the Webstore Deployment file.");
                }

                message = String.Format("WstRunner started processing manifest '{0}' using deployment '{1}' at {2}", wstManifestFile, wstDeploymentFile, DateTime.Now);
                _eventLog.WriteEntry(message, EventLogEntryType.Information);
                _log.WriteLine(message);

                string workingPath;
                if (Directory.Exists(wstManifestFile.DirectoryName))
                {
                    workingPath = wstManifestFile.DirectoryName;
                }
                else if (Directory.Exists(wstDeploymentFile.DirectoryName))
                {
                    workingPath = wstDeploymentFile.DirectoryName;
                }
                else
                {
                    workingPath = Environment.CurrentDirectory;
                }

                IWstRunner runner = _wstRunnerFactory.CreateInstance(
                    workingPath, 
                    wstManifestFile.Name, 
                    wstDeploymentFile.Name);

                runner.Remove(!Boolean.Parse(Context.Parameters["isUpgrade"]));

                wstDeploymentFile.Delete();
            }
            catch (Exception ex)
            {
                _log.WriteLine("ERROR: Exception encountered executing WstRunner.");
                _log.WriteLine(ex.ToString());

                message = string.Format("Exception encountered executing WstRunner: \r\n{0}", ex);
                _eventLog.WriteEntry(message, EventLogEntryType.Error, 65000);
                throw;
            }

            message = String.Format("WstRunner processing of '{0}' completed at {1}", wstManifestFile, DateTime.Now);
            _eventLog.WriteEntry(message, EventLogEntryType.Information);
            _log.WriteLine(message);

            _log.WriteLine("Existing WstRunnerInstaller.Uninstall().");
        }

        /// <summary>
        /// Event handler for WstRunner's event which writes the message to the install context's log.
        /// </summary>
        /// <param name="sender">The WstRunnerStep generating the event.</param>
        /// <param name="e">The MessageEventArgs sent by the event.</param>
        private void loggingEventHandler(object sender, LoggingEventArgs e)
        {
            if(e == null)
                return;

            //  Context.LogMessage adds a CR/LF, so we'll strip off any
            //  existing whitespace from the end of the message to be logged.
            Context.LogMessage(e.Message.TrimEnd());
        }

        private void Initialize()
        {
            //
            // _log
            //

		    _log.Verbosity = LogLevel.Verbose;
            _log.OnMessage += loggingEventHandler;

            // 
            // _eventLog
            // 
            _eventLog = new EventLog();
            _eventLog.Log = "Application";
            _eventLog.Source = "WstRunner";
        }

		#region Component Designer generated code
		/// <summary>
		/// Required method for Designer support - do not modify
		/// the contents of this method with the code editor.
		/// </summary>
		private void InitializeComponent()
		{
            ((System.ComponentModel.ISupportInitialize)(this._eventLog)).BeginInit();
            ((System.ComponentModel.ISupportInitialize)(this._eventLog)).EndInit();
        }
		#endregion
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\wstrunner\core\xonline.tools.wstrunner.core.Resources.Designer.cs ===
﻿//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//     Runtime Version:2.0.50727.1433
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------

namespace xonline.tools.wstrunner.core {
    using System;
    
    
    /// <summary>
    ///   A strongly-typed resource class, for looking up localized strings, etc.
    /// </summary>
    // This class was auto-generated by the StronglyTypedResourceBuilder
    // class via a tool like ResGen or Visual Studio.
    // To add or remove a member, edit your .ResX file then rerun ResGen
    // with the /str option, or rebuild your VS project.
    [global::System.CodeDom.Compiler.GeneratedCodeAttribute("System.Resources.Tools.StronglyTypedResourceBuilder", "2.0.0.0")]
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
    [global::System.Runtime.CompilerServices.CompilerGeneratedAttribute()]
    internal class Resources {
        
        private static global::System.Resources.ResourceManager resourceMan;
        
        private static global::System.Globalization.CultureInfo resourceCulture;
        
        [global::System.Diagnostics.CodeAnalysis.SuppressMessageAttribute("Microsoft.Performance", "CA1811:AvoidUncalledPrivateCode")]
        internal Resources() {
        }
        
        /// <summary>
        ///   Returns the cached ResourceManager instance used by this class.
        /// </summary>
        [global::System.ComponentModel.EditorBrowsableAttribute(global::System.ComponentModel.EditorBrowsableState.Advanced)]
        internal static global::System.Resources.ResourceManager ResourceManager {
            get {
                if (object.ReferenceEquals(resourceMan, null)) {
                    global::System.Resources.ResourceManager temp = new global::System.Resources.ResourceManager("xonline.tools.wstrunner.core.Resources", typeof(Resources).Assembly);
                    resourceMan = temp;
                }
                return resourceMan;
            }
        }
        
        /// <summary>
        ///   Overrides the current thread's CurrentUICulture property for all
        ///   resource lookups using this strongly typed resource class.
        /// </summary>
        [global::System.ComponentModel.EditorBrowsableAttribute(global::System.ComponentModel.EditorBrowsableState.Advanced)]
        internal static global::System.Globalization.CultureInfo Culture {
            get {
                return resourceCulture;
            }
            set {
                resourceCulture = value;
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to &lt;Account Name=&quot;#ACCOUNT_NAME#&quot; xmlns=&quot;urn:WebstoreDeploymentSchema.xsd&quot;&gt;
        ///    &lt;Role&gt;#ROLE_NAME#&lt;/Role&gt;
        ///&lt;/Account&gt;
        ///.
        /// </summary>
        internal static string account_template {
            get {
                return ResourceManager.GetString("account_template", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to &lt;Database Name=&quot;#DATABASE_NAME#&quot; DataServer=&quot;#SERVER_NAME#&quot; xmlns=&quot;urn:WebstoreDeploymentSchema.xsd&quot;&gt;
        ///    &lt;Status&gt;NotDeployed&lt;/Status&gt;
        ///    &lt;DefaultStatus&gt;Online&lt;/DefaultStatus&gt;
        ///&lt;/Database&gt;
        ///.
        /// </summary>
        internal static string database_template {
            get {
                return ResourceManager.GetString("database_template", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to &lt;DataPartition Number=&quot;#PARTITION_NUMBER#&quot; xmlns=&quot;urn:WebstoreDeploymentSchema.xsd&quot;&gt;
        ///    &lt;SqlFailSafeSetNumber&gt;#FSS_NUMBER#&lt;/SqlFailSafeSetNumber&gt;
        ///    &lt;Status&gt;ReadWrite&lt;/Status&gt;
        ///&lt;/DataPartition&gt;
        ///.
        /// </summary>
        internal static string datapartition_template {
            get {
                return ResourceManager.GetString("datapartition_template", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to &lt;Webstore xmlns=&quot;urn:WebstoreDeploymentSchema.xsd&quot;&gt;
        ///    &lt;DatabaseTemplates&gt;
        ///        &lt;DatabaseTemplate Name=&quot;#DISTRIBUTION_TEMPLATE_NAME#&quot;&gt;
        ///            &lt;Description/&gt;
        ///            &lt;IsDistributionOnly&gt;true&lt;/IsDistributionOnly&gt;
        ///            &lt;DataFileGroups&gt;
        ///                &lt;FileGroup Name=&quot;Primary&quot;&gt;
        ///                    &lt;LogicalFiles&gt;
        ///                        &lt;LogicalFile Name=&quot;DataFile&quot;&gt;
        ///                            &lt;Path&gt;#DATA_FILE_PATH#&lt;/Path&gt;
        ///                            &lt;Size&gt;10MB&lt;/Size&gt;
        ///             [rest of string was truncated]&quot;;.
        /// </summary>
        internal static string deployment_template {
            get {
                return ResourceManager.GetString("deployment_template", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to &lt;Server Name=&quot;#SERVER_NAME#&quot; ClusterName=&quot;DefaultCluster&quot; xmlns=&quot;urn:WebstoreDeploymentSchema.xsd&quot;&gt;
        ///    &lt;DataCenter Name=&quot;DefaultDataCenter&quot; /&gt;
        ///    &lt;DistributionDatabaseTemplate Name=&quot;#DISTRIBUTION_TEMPLATE_NAME#&quot; /&gt;
        ///    &lt;ServerRoles&gt;
        ///        &lt;ServerRole&gt;#SERVER_ROLE#&lt;/ServerRole&gt;
        ///    &lt;/ServerRoles&gt;
        ///&lt;/Server&gt;
        ///.
        /// </summary>
        internal static string server {
            get {
                return ResourceManager.GetString("server", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to &lt;SqlFailSafeSet Number=&quot;&quot; xmlns=&quot;urn:WebstoreDeploymentSchema.xsd&quot;&gt;
        ///    &lt;DatabaseTemplate Name=&quot;#DATABASE_TEMPLATE_NAME#&quot; /&gt;
        ///    &lt;Databases&gt;
        ///    &lt;/Databases&gt;
        ///    &lt;DefaultPrimaryDatabase Database=&quot;#DATABASE_NAME#&quot; DataServer=&quot;#PRIMARY_SERVER_NAME#&quot; /&gt;
        ///    &lt;PrimaryDatabase Database=&quot;#DATABASE_NAME#&quot; DataServer=&quot;#PRIMARY_SERVER_NAME#&quot; /&gt;
        ///&lt;/SqlFailSafeSet&gt;
        ///.
        /// </summary>
        internal static string sqlfailsafeset_template {
            get {
                return ResourceManager.GetString("sqlfailsafeset_template", resourceCulture);
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\wstrunner\test\WstRunnerCmdTestGroup.cs ===
/*******************************************************************
 *    FILE:         WstRunnerCmdTestGroup.cs
 *
 *    DESCRIPTION:  Unit tests for the xonline.tools.wstrunner.core.WstRunnerCmd 
 *                  class.
 *
 *    OWNER:        darrenan
 *
 *    HISTORY:      4-17-2008   - Created 
 *
 *    Copyright <cp> 2008 Microsoft Corporation.  All Rights Reserved.
 *******************************************************************/

using ServerTestFramework;
using ServerTestFramework.Core.Utilities;
using System;
using System.Collections.Generic;
using System.IO;
using System.Reflection;
using xonline.tools.wstrunner.console;
using xonline.tools.wstrunner.core;

namespace xonline.tools.wstrunner.test
{
    [TestGroup, DVT, Owner("chlange"), TestCasePriority(1), TestFrequency("Regression")]
    class WstRunnerCmdTestGroup : TestNode
    {
        #region Install Tests

        [TestCase]
        class ParseCommandLinePositive : TestBase
        {
            protected override void Execute()
            {
                TestWstRunnerFactory wstRunnerFactory = new TestWstRunnerFactory();
                TestDeploymentFileFactory deploymentFactory = new TestDeploymentFileFactory();
                WstRunnerCmd cmd = new WstRunnerCmd();
                cmd.WstRunnerFactory = wstRunnerFactory;
                cmd.DeploymentFactory = deploymentFactory;

                Dictionary<string,string> properties = new Dictionary<string,string>();

                properties.Add(
                    "dataFilePath",
                    Path.Combine(Path.GetDirectoryName(Assembly.GetExecutingAssembly().Location), "SqlDir"));
                properties.Add(
                    "logFilePath",
                    Path.Combine(Path.GetDirectoryName(Assembly.GetExecutingAssembly().Location), "LogDir"));
                properties.Add("configServerList", "test1");
                properties.Add("dataServerList", "test1");
                properties.Add("failSafeSetsPerServer", "2");
                properties.Add("accountRoleMap", "test1\\steve=ClientLib");
                properties.Add("partitionCount", "129");
                properties.Add("databaseName", "testdb");
                properties.Add("isUpgrade", "false");

                int argCount = (properties.Count * 2) + 2;
                string [] args = new string[argCount];

                int currentIndex = 0;

                args[currentIndex++] = "/M";
                args[currentIndex++] = Path.Combine(Path.GetDirectoryName(Assembly.GetExecutingAssembly().Location), "manifest1.xml");
                
                foreach(KeyValuePair<string,string> entry in properties)
                {
                    args[currentIndex++] = "/V";
                    args[currentIndex++] = entry.Key + "=" + entry.Value;
                }

                ValueCheck.IsTrue(cmd.ParseCommandLine(args), "ParseCommandLine");

                ValueCheck.Test(
                    "ManifestFileName",
                    Path.Combine(Path.GetDirectoryName(Assembly.GetExecutingAssembly().Location), "manifest1.xml"),
                    cmd.ManifestFileName);
                ValueCheck.TestNull(
                    "DeploymentFileName",
                    cmd.DeploymentFileName
                    );
                ValueCheck.Test(
                    "PropertyCount",
                    9,
                    cmd.Properties.Count);
                foreach(KeyValuePair<string,string> entry in properties)
                {
                    ValueCheck.Test(
                        entry.Key, 
                        entry.Value, 
                        cmd.Properties[entry.Key]);
                }

                ResultCode = TEST_RESULTS.PASSED;
            }
        }

        [TestCase]
        class AutoGenDeploymentNameOmitted : TestBase
        {

            protected override void Execute()
            {
                string deploymentXmlFileName =
                    Path.Combine(Path.GetDirectoryName(Assembly.GetExecutingAssembly().Location), "deployment.xml");
                
                TestWstRunnerFactory wstRunnerFactory = new TestWstRunnerFactory();
                wstRunnerFactory.RunnerMock.AddExpectation("Setup");
                
                WstRunnerCmd cmd = new WstRunnerCmd();
                cmd.WstRunnerFactory = wstRunnerFactory;

                TestManifestFactory manifestFactory = new TestManifestFactory();
                TestOracleFactory oracleFactory = new TestOracleFactory();
                DeploymentFileFactory.ManifestFactory = manifestFactory;
                DeploymentFileFactory.OracleFactory = oracleFactory;

                if (File.Exists(deploymentXmlFileName))
                {
                    File.Delete(deploymentXmlFileName);
                }

                string[] args =
                {
                    "/setup",
                    "/M", Path.Combine(Path.GetDirectoryName(Assembly.GetExecutingAssembly().Location), "manifest1.xml"),
                    "/V", "dataFilePath=" + Path.Combine(Path.GetDirectoryName(Assembly.GetExecutingAssembly().Location), "SqlDir"),
                    "/V", "logFilePath=" + Path.Combine(Path.GetDirectoryName(Assembly.GetExecutingAssembly().Location), "LogDir"),
                    "/V", "configServerList=test1",
                    "/V", "dataServerList=test1",
                    "/V", "failSafeSetsPerServer=2",
                    "/V", "accountRoleMap=test1\\steve=ClientLib",
                    "/V", "partitionCount=129",
                    "/V", "databaseName=testdb",
                    "/V", "isUpgrade=false"
                };

                ValueCheck.IsTrue(cmd.ParseCommandLine(args), "ParseCommandLine");
                ValueCheck.Test("RunIt", 0, cmd.RunIt());

                wstRunnerFactory.RunnerMock.Verify();

                if (!File.Exists(deploymentXmlFileName))
                {
                    ResultCode = TEST_RESULTS.FAILED;
                }
                else
                {
                    ResultCode = TEST_RESULTS.PASSED;
                }
            }
        }

        [TestCase]
        class AutoGenDeploymentNameProvided : TestBase
        {

            protected override void Execute()
            {
                string deploymentXmlFileName =
                    Path.Combine(Path.GetDirectoryName(Assembly.GetExecutingAssembly().Location),
                                 "deploymentAutoGen.xml");

                TestWstRunnerFactory wstRunnerFactory = new TestWstRunnerFactory();
                wstRunnerFactory.RunnerMock.AddExpectation("Setup");

                WstRunnerCmd cmd = new WstRunnerCmd();
                cmd.WstRunnerFactory = wstRunnerFactory;

                TestManifestFactory manifestFactory = new TestManifestFactory();
                DeploymentFileFactory.ManifestFactory = manifestFactory;

                if (File.Exists(deploymentXmlFileName))
                {
                    File.Delete(deploymentXmlFileName);
                }

                string[] args =
                    {
                        "/setup",
                        "/M", Path.Combine(Path.GetDirectoryName(Assembly.GetExecutingAssembly().Location), "manifest1.xml"),
                        "/D", deploymentXmlFileName,
                        "/V", "dataFilePath=" + Path.Combine(Path.GetDirectoryName(Assembly.GetExecutingAssembly().Location), "SqlDir"),
                        "/V", "logFilePath=" + Path.Combine(Path.GetDirectoryName(Assembly.GetExecutingAssembly().Location), "LogDir"),
                        "/V", "configServerList=test1",
                        "/V", "dataServerList=test1",
                        "/V", "failSafeSetsPerServer=2",
                        "/V", "accountRoleMap=test1\\steve=ClientLib",
                        "/V", "partitionCount=129",
                        "/V", "databaseName=testdb",
                        "/V", "isUpgrade=false"
                    };

                ValueCheck.IsTrue(cmd.ParseCommandLine(args), "ParseCommandLine");
                ValueCheck.Test("RunIt", 0, cmd.RunIt());

                wstRunnerFactory.RunnerMock.Verify();

                if (!File.Exists(deploymentXmlFileName))
                {
                    ResultCode = TEST_RESULTS.FAILED;
                }
                else
                {
                    ResultCode = TEST_RESULTS.PASSED;
                }
            }
        }

        [TestCase]
        class AutoGenDeploymentNameProvidedNoPPS : TestBase
        {

            protected override void Execute()
            {
                string deploymentXmlFileName =
                    Path.Combine(Path.GetDirectoryName(Assembly.GetExecutingAssembly().Location),
                                 "deploymentAutoGen.xml");

                TestWstRunnerFactory wstRunnerFactory = new TestWstRunnerFactory();
                wstRunnerFactory.RunnerMock.AddExpectation("Setup");

                WstRunnerCmd cmd = new WstRunnerCmd();
                cmd.WstRunnerFactory = wstRunnerFactory;

                TestManifestFactory manifestFactory = new TestManifestFactory();
                DeploymentFileFactory.ManifestFactory = manifestFactory;

                if (File.Exists(deploymentXmlFileName))
                {
                    File.Delete(deploymentXmlFileName);
                }

                string[] args =
                    {
                        "/setup",
                        "/M", Path.Combine(Path.GetDirectoryName(Assembly.GetExecutingAssembly().Location), "manifest1.xml"),
                        "/D", deploymentXmlFileName,
                        "/V", "dataFilePath=" + Path.Combine(Path.GetDirectoryName(Assembly.GetExecutingAssembly().Location), "SqlDir"),
                        "/V", "logFilePath=" + Path.Combine(Path.GetDirectoryName(Assembly.GetExecutingAssembly().Location), "LogDir"),
                        "/V", "configServerList=test1",
                        "/V", "dataServerList=test1",
                        "/V", "accountRoleMap=test1\\steve=ClientLib",
                        "/V", "partitionCount=129",
                        "/V", "databaseName=testdb",
                        "/V", "isUpgrade=false"
                    };

                ValueCheck.IsTrue(cmd.ParseCommandLine(args), "ParseCommandLine");
                ValueCheck.Test("RunIt", 0, cmd.RunIt());

                wstRunnerFactory.RunnerMock.Verify();

                if (!File.Exists(deploymentXmlFileName))
                {
                    ResultCode = TEST_RESULTS.FAILED;
                }
                else
                {
                    ResultCode = TEST_RESULTS.PASSED;
                }
            }
        }

        [TestCase]
        class DeploymentFileExists : TestBase
        {
            protected override void Execute()
            {
                string deploymentXmlFileName =
                    Path.Combine(Path.GetDirectoryName(Assembly.GetExecutingAssembly().Location), "deployment1.xml");
                FileInfo deploymentFileInfo = new FileInfo(deploymentXmlFileName);
                DateTime lastWriteTimeBefore = deploymentFileInfo.LastWriteTimeUtc;

                TestWstRunnerFactory wstRunnerFactory = new TestWstRunnerFactory();
                wstRunnerFactory.RunnerMock.AddExpectation("Setup");

                WstRunnerCmd cmd = new WstRunnerCmd();
                cmd.WstRunnerFactory = wstRunnerFactory;

                TestManifestFactory manifestFactory = new TestManifestFactory();
                DeploymentFileFactory.ManifestFactory = manifestFactory;

                string[] args =
                    {
                        "/setup",
                        "/M", Path.Combine(Path.GetDirectoryName(Assembly.GetExecutingAssembly().Location), "manifest1.xml"),
                        "/D", deploymentXmlFileName,
                        "/V", "dataFilePath=" + Path.Combine(Path.GetDirectoryName(Assembly.GetExecutingAssembly().Location), "SqlDir"),
                        "/V", "logFilePath=" +  Path.Combine(Path.GetDirectoryName(Assembly.GetExecutingAssembly().Location), "LogDir"),
                        "/V", "configServerList=test1",
                        "/V", "dataServerList=test1",
                        "/V", "failSafeSetsPerServer=2",
                        "/V", "accountRoleMap=test1\\steve=ClientLib",
                        "/V", "partitionCount=129",
                        "/V", "databaseName=testdb",
                        "/V", "isUpgrade=false"
                    };

                ValueCheck.IsTrue(cmd.ParseCommandLine(args), "ParseCommandLine");
                ValueCheck.Test("RunIt", 0, cmd.RunIt());

                wstRunnerFactory.RunnerMock.Verify();

                if (deploymentFileInfo.LastWriteTimeUtc != lastWriteTimeBefore)
                {
                    ResultCode = TEST_RESULTS.FAILED;
                }
                else
                {
                    ResultCode = TEST_RESULTS.PASSED;
                }
            }
        }

        [TestCase]
        class DropPositive : TestBase
        {
            protected override void Execute()
            {
                TestWstRunnerFactory wstRunnerFactory = new TestWstRunnerFactory();
                Object[] removeArgs = {true};
                wstRunnerFactory.RunnerMock.AddExpectation("Remove", removeArgs);

                WstRunnerCmd cmd = new WstRunnerCmd();
                cmd.WstRunnerFactory = wstRunnerFactory;

                string[] args =
                    {
                        "/drop",
                        "/M", Path.Combine(Path.GetDirectoryName(Assembly.GetExecutingAssembly().Location), "manifest1.xml"),
                        "/D", Path.Combine(Path.GetDirectoryName(Assembly.GetExecutingAssembly().Location), "deployment1.xml")
                    };

                ValueCheck.IsTrue(cmd.ParseCommandLine(args), "ParseCommandLine");
                ValueCheck.Test("RunIt", 0, cmd.RunIt());
                
                ResultCode = TEST_RESULTS.PASSED;
            }
        }
        [TestCase]
        class NeedsRepairPositive : TestBase
        {
            protected override void Execute()
            {
                TestWstRunnerFactory wstRunnerFactory = new TestWstRunnerFactory();
                wstRunnerFactory.RunnerMock.AddExpectation("MarkNeedsRepair");

                WstRunnerCmd cmd = new WstRunnerCmd();
                cmd.WstRunnerFactory = wstRunnerFactory;

                string[] args =
                    {
                        "/markneedsrepair",
                        "/M", Path.Combine(Path.GetDirectoryName(Assembly.GetExecutingAssembly().Location), "manifest1.xml"),
                        "/D", Path.Combine(Path.GetDirectoryName(Assembly.GetExecutingAssembly().Location), "deployment1.xml")
                    };

                ValueCheck.IsTrue(cmd.ParseCommandLine(args), "ParseCommandLine");
                ValueCheck.Test("RunIt", 0, cmd.RunIt());

                ResultCode = TEST_RESULTS.PASSED;
            }
        }
        [TestCase]
        class RepairPositive : TestBase
        {
            protected override void Execute()
            {
                TestWstRunnerFactory wstRunnerFactory = new TestWstRunnerFactory();
                wstRunnerFactory.RunnerMock.AddExpectation("RepairwithOnlinePromote");

                WstRunnerCmd cmd = new WstRunnerCmd();
                cmd.WstRunnerFactory = wstRunnerFactory;

                string[] args =
                    {
                        "/repair",
                        "/M", Path.Combine(Path.GetDirectoryName(Assembly.GetExecutingAssembly().Location), "manifest1.xml"),
                        "/D", Path.Combine(Path.GetDirectoryName(Assembly.GetExecutingAssembly().Location), "deployment1.xml")
                    };

                ValueCheck.IsTrue(cmd.ParseCommandLine(args), "ParseCommandLine");
                ValueCheck.Test("RunIt", 0, cmd.RunIt());

                ResultCode = TEST_RESULTS.PASSED;
            }
        }

        #endregion
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\wstrunner\test\TestFactories.cs ===
/*******************************************************************
 *    FILE:         TestFactories.cs
 *
 *    DESCRIPTION:  Test Factory classes.
 *
 *    OWNER:        darrenan
 *
 *    HISTORY:      4-17-2008   - Created 
 *
 *    Copyright <cp> 2008 Microsoft Corporation.  All Rights Reserved.
 *******************************************************************/

using System;
using Microsoft.VisualStudio.TestTools.MockObjects;
using System.IO;
using xonline.tools.wstrunner.core;

namespace xonline.tools.wstrunner.test
{
    /// <summary>
    /// This class provides a mock IManifest instance to the caller.
    /// NOTE:  For any given instance of TestManifestFactory, CreateInstance
    /// will always return the same instance interface, it doesn't create a new
    /// one on every call.
    /// </summary>
    class TestManifestFactory : IManifestFactory
    {
        private SequenceMock<BaseManifest> [] _runnerMock;
        private readonly int instanceCount;
        private int nextInstance = 0;

        public SequenceMock<BaseManifest>[] RunnerMock
        {
            get { return _runnerMock; }
        }

        private void Initialize()
        {
            _runnerMock = new SequenceMock<BaseManifest>[instanceCount];
            for(int currentInstance = 0; currentInstance < instanceCount; ++currentInstance)
            {
                _runnerMock[currentInstance] = new SequenceMock<BaseManifest>();
            }
        }
        public TestManifestFactory()
        {
            instanceCount = 1;
            Initialize();
        }

        public TestManifestFactory(int numInstances)
        {
            instanceCount = numInstances;
            Initialize();
        }

        public BaseManifest CreateInstance()
        {
            if(nextInstance >= _runnerMock.Length)
            {
                throw new ApplicationException("Too many IManifest instances created.");
            }

            return _runnerMock[nextInstance++].Instance;
        }
    }

    /// <summary>
    /// This class provides a mock IManifest instance to the caller.
    /// NOTE:  For any given instance of TestDeploymentFactory, CreateInstance
    /// will always return the same instance interface, it doesn't create a new
    /// one on every call.
    /// </summary>
    class TestDeploymentFactory : IDeploymentFactory
    {
        public SequenceMock<BaseDeployment> _runnerMock = new SequenceMock<BaseDeployment>();

        public SequenceMock<BaseDeployment> RunnerMock
        {
            get { return _runnerMock; }
        }

        public BaseDeployment CreateInstance()
        {
            return _runnerMock.Instance;
        }
    }

    /// <summary>
    /// This class provides a mock IWstRunner instance to the caller.
    /// NOTE:  For any given instance of TestWstRunnerFactory, CreateInstance
    /// will always return the same instance interface, it doesn't create a new
    /// one on every call.
    /// </summary>
    class TestWstRunnerFactory : IWstRunnerFactory
    {
        private readonly SequenceMock<IWstRunner> _runnerMock = new SequenceMock<IWstRunner>();

        public SequenceMock<IWstRunner> RunnerMock
        {
            get
            {
                return _runnerMock;
            }
        }

        public IWstRunner CreateInstance(string workingPath, string manifestFile, string deploymentFile)
        {
            return _runnerMock.Instance;
        }
    }

    /// <summary>
    /// This class provides a mock IWstRunner instance to the caller.
    /// NOTE:  For any given instance of TestWstRunnerFactory, CreateInstance
    /// will always return the same instance interface, it doesn't create a new
    /// one on every call.
    /// </summary>
    class TestFailSafeSetFactory : IFailSafeSetFactory
    {
        private readonly SequenceMock<BaseFailSafeSet> _runnerMock = new SequenceMock<BaseFailSafeSet>();

        public SequenceMock<BaseFailSafeSet> RunnerMock
        {
            get
            {
                return _runnerMock;
            }
        }

        public BaseFailSafeSet CreateInstance()
        {
            return _runnerMock.Instance;
        }
    }

    /// <summary>
    /// This class provides a mock IWstRunner instance to the caller.
    /// NOTE:  For any given instance of TestWstRunnerFactory, CreateInstance
    /// will always return the same instance interface, it doesn't create a new
    /// one on every call.
    /// </summary>
    class TestDatabaseTemplateFactory : IDatabaseTemplateFactory
    {
        private readonly SequenceMock<BaseDatabaseTemplate> _runnerMock = new SequenceMock<BaseDatabaseTemplate>();

        public SequenceMock<BaseDatabaseTemplate> RunnerMock
        {
            get
            {
                return _runnerMock;
            }
        }

        public BaseDatabaseTemplate CreateInstance()
        {
            return _runnerMock.Instance;
        }
    }

    class TestDeploymentFileFactory : IDeploymentFileFactory
    {
        public FileInfo CreateDeployment(
            FileInfo manifestXml, 
            string deploymentXmlFileName, 
            string dataFilePath,
            string logFilePath, 
            string configServerList, 
            string dataServerList,
            uint failSafeSetsPerServer,
            string accountRoleMap, 
            uint partitionCount, 
            string databaseName)
        {
            return new FileInfo(deploymentXmlFileName);
        }
    }

}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\wstrunner\test\obj\i386\_generated.cs ===
[assembly:System.Runtime.InteropServices.ComVisible(false)]
[assembly:System.Reflection.AssemblyVersion("12.4.56.0")]
[assembly:System.Reflection.AssemblyProduct("Microsoft(R) Xbox(TM)")]
[assembly:System.Reflection.AssemblyCopyright("Copyright (c) Microsoft Corporation. All rights reserved.")]
[assembly:System.Reflection.AssemblyCompany("Microsoft Corporation")]
[assembly:System.Reflection.AssemblyFileVersion("12.4.56.0")]
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\wstrunner\test\WstRunnerSuite.cs ===
using ServerTestFramework;

namespace xonline.tools.wstrunner.test
{
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\wstrunner\test\WstRunnerInstallerTestGroup.cs ===
/*******************************************************************
 *    FILE:         WstRunnerInstallerTestGroup.cs
 *
 *    DESCRIPTION:  Unit tests for the xonline.tools.wstrunner.core.WstRunnerInstaller 
 *                  class.
 *
 *    OWNER:        darrenan
 *
 *    HISTORY:      3-21-2008   - Created 
 *
 *    Copyright <cp> 2008 Microsoft Corporation.  All Rights Reserved.
 *******************************************************************/

using Microsoft.VisualStudio.TestTools.MockObjects;
using ServerTestFramework;
using System;
using System.Collections;
using System.Configuration.Install;
using System.IO;
using System.Reflection;
using xonline.tools.wstrunner.core;
using xonline.tools.wstrunner.installer;

namespace xonline.tools.wstrunner.test
{
    [TestGroup, DVT, Owner("chlange"), TestCasePriority(1), TestFrequency("Regression")]
    class WstRunnerInstallerTestGroup : TestNode
    {
        #region Install Tests

        [TestCase]
        class AutoGenDeploymentNameOmitted : TestBase
        {

            protected override void Execute()
            {
                string deploymentXmlFileName =
                    Path.Combine(Path.GetDirectoryName(Assembly.GetExecutingAssembly().Location), "deployment.xml");
                TestWstRunnerFactory wstRunnerFactory = new TestWstRunnerFactory();

                wstRunnerFactory.RunnerMock.AddExpectation("Setup");

                Hashtable parameters = new Hashtable();

                if (File.Exists(deploymentXmlFileName))
                {
                    File.Delete(deploymentXmlFileName);
                }

                TestManifestFactory manifestFactory = new TestManifestFactory();
                TestOracleFactory oracleFactory = new TestOracleFactory();
                DeploymentFileFactory.ManifestFactory = manifestFactory;
                DeploymentFileFactory.OracleFactory = oracleFactory;

                InstallContext context = new InstallContext();
                context.Parameters["manifestXml"] = Path.Combine(Path.GetDirectoryName(Assembly.GetExecutingAssembly().Location), "manifest1.xml");
                context.Parameters["dataFilePath"] = Path.Combine(Path.GetDirectoryName(Assembly.GetExecutingAssembly().Location), "SqlDir");
                context.Parameters["logFilePath"] = Path.Combine(Path.GetDirectoryName(Assembly.GetExecutingAssembly().Location), "LogDir");
                context.Parameters["configServerList"] = "test1";
                context.Parameters["dataServerList"] = "test1";
                context.Parameters["failSafeSetsPerServer"] = "2";
                context.Parameters["accountRoleMap"] = "test1\\steve=ClientLib";
                context.Parameters["partitionCount"] = "129";
                context.Parameters["databaseName"] = "testdb";
                context.Parameters["isUpgrade"] = "false";

                WstRunnerInstaller installer = new WstRunnerInstaller();
                installer.WstRunnerFactory = wstRunnerFactory;
                installer.Context = context;
                installer.Install(parameters);

                wstRunnerFactory.RunnerMock.Verify();

                if (!File.Exists(deploymentXmlFileName))
                {
                    ResultCode = TEST_RESULTS.FAILED;
                }
                else
                {
                    ResultCode = TEST_RESULTS.PASSED;
                }
            }
        }

        [TestCase]
        class AutoGenDeploymentNameProvided : TestBase
        {

            protected override void Execute()
            {
                string deploymentXmlFileName =
                    Path.Combine(Path.GetDirectoryName(Assembly.GetExecutingAssembly().Location), "deploymentAutoGen.xml");
                TestWstRunnerFactory wstRunnerFactory = new TestWstRunnerFactory();

                wstRunnerFactory.RunnerMock.AddExpectation("Setup");

                TestManifestFactory manifestFactory = new TestManifestFactory();
                TestOracleFactory oracleFactory = new TestOracleFactory();
                DeploymentFileFactory.ManifestFactory = manifestFactory;
                DeploymentFileFactory.OracleFactory = oracleFactory;

                Hashtable parameters = new Hashtable();

                if (File.Exists(deploymentXmlFileName))
                {
                    File.Delete(deploymentXmlFileName);
                }

                InstallContext context = new InstallContext();
                context.Parameters["manifestXml"] = Path.Combine(Path.GetDirectoryName(Assembly.GetExecutingAssembly().Location), "manifest1.xml");
                context.Parameters["deploymentXml"] = deploymentXmlFileName;
                context.Parameters["dataFilePath"] = Path.Combine(Path.GetDirectoryName(Assembly.GetExecutingAssembly().Location), "SqlDir");
                context.Parameters["logFilePath"] = Path.Combine(Path.GetDirectoryName(Assembly.GetExecutingAssembly().Location), "LogDir");
                context.Parameters["configServerList"] = "test1";
                context.Parameters["dataServerList"] = "test1";
                context.Parameters["failSafeSetsPerServer"] = "2";
                context.Parameters["accountRoleMap"] = "test1\\steve=ClientLib";
                context.Parameters["partitionCount"] = "129";
                context.Parameters["databaseName"] = "testdb";
                context.Parameters["isUpgrade"] = "false";

                WstRunnerInstaller installer = new WstRunnerInstaller();
                installer.WstRunnerFactory = wstRunnerFactory;
                installer.Context = context;
                installer.Install(parameters);

                wstRunnerFactory.RunnerMock.Verify();

                if (!File.Exists(deploymentXmlFileName))
                {
                    ResultCode = TEST_RESULTS.FAILED;
                }
                else
                {
                    ResultCode = TEST_RESULTS.PASSED;
                }
            }
        }

        [TestCase]
        class DeploymentFileExists : TestBase
        {

            protected override void Execute()
            {
                string deploymentXmlFileName =
                    Path.Combine(Path.GetDirectoryName(Assembly.GetExecutingAssembly().Location), "deployment1.xml");
                FileInfo deploymentFileInfo = new FileInfo(deploymentXmlFileName);
                DateTime lastWriteTimeBefore = deploymentFileInfo.LastWriteTimeUtc;
                TestWstRunnerFactory wstRunnerFactory = new TestWstRunnerFactory();

                wstRunnerFactory.RunnerMock.AddExpectation("Setup");

                Hashtable parameters = new Hashtable();

                InstallContext context = new InstallContext();
                context.Parameters["manifestXml"] = Path.Combine(Path.GetDirectoryName(Assembly.GetExecutingAssembly().Location), "manifest1.xml");
                context.Parameters["deploymentXml"] = deploymentXmlFileName;
                context.Parameters["dataFilePath"] = Path.Combine(Path.GetDirectoryName(Assembly.GetExecutingAssembly().Location), "SqlDir");
                context.Parameters["logFilePath"] = Path.Combine(Path.GetDirectoryName(Assembly.GetExecutingAssembly().Location), "LogDir");
                context.Parameters["configServerList"] = "test1";
                context.Parameters["dataServerList"] = "test1";
                context.Parameters["failSafeSetsPerServer"] = "2";
                context.Parameters["accountRoleMap"] = "test1\\steve=ClientLib";
                context.Parameters["partitionCount"] = "129";
                context.Parameters["databaseName"] = "testdb";
                context.Parameters["isUpgrade"] = "false";

                WstRunnerInstaller installer = new WstRunnerInstaller();
                installer.WstRunnerFactory = wstRunnerFactory;
                installer.Context = context;
                installer.Install(parameters);

                wstRunnerFactory.RunnerMock.Verify();

                if (deploymentFileInfo.LastWriteTimeUtc != lastWriteTimeBefore)
                {
                    ResultCode = TEST_RESULTS.FAILED;
                }
                else
                {
                    ResultCode = TEST_RESULTS.PASSED;
                }
            }
        }

        #endregion
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\wstrunner\test\objd\i386\_generated.cs ===
[assembly:System.Runtime.InteropServices.ComVisible(false)]
[assembly:System.Reflection.AssemblyVersion("12.4.56.0")]
[assembly:System.Reflection.AssemblyProduct("Microsoft(R) Xbox(TM)")]
[assembly:System.Reflection.AssemblyCopyright("Copyright (c) Microsoft Corporation. All rights reserved.")]
[assembly:System.Reflection.AssemblyCompany("Microsoft Corporation")]
[assembly:System.Reflection.AssemblyFileVersion("12.4.56.0")]
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\wstrunner\test\WstRunnerTestGroup.cs ===
/*******************************************************************
 *    FILE:         WstRunnerTestGroup.cs
 *
 *    DESCRIPTION:  Unit tests for the 
 *                  xonline.tools.wstrunner.core.WstRunner class.
 *
 *    OWNER:        darrenan
 *
 *    HISTORY:      10-22-2007   - Created 
 *
 *    Copyright <cp> 2007 Microsoft Corporation.  All Rights Reserved.
 *******************************************************************/

using Microsoft.VisualStudio.TestTools.MockObjects;
using ServerTestFramework;
using System.IO;
using System.Reflection;
using xonline.tools.wstrunner.core;

namespace xonline.tools.wstrunner.test
{
    public class TestOracleFactory : IOracleFactory
    {
        private readonly SequenceMock<IOracle> _runnerMock = new SequenceMock<IOracle>();

        public SequenceMock<IOracle> RunnerMock
        {
            get { return _runnerMock; }
        }

        public IOracle CreateInstance()
        {
            return _runnerMock.Instance;
        }

        public IOracle CreateInstanceWithoutRefresh()
        {
            return _runnerMock.Instance;
        }
    }

    [TestGroup, DVT, Owner("chlange"), TestCasePriority(1), TestFrequency("Regression")]
    public class WstRunnerTestGroup : TestNode
    {
        #region Constructor Tests
        [TestCase]
        public class ConstructorPositiveTest : TestBase
        {
            protected override void Execute()
            {
                IWstRunner wstRunner = WstRunner.CreateInstance(
                    Path.GetDirectoryName(Assembly.GetExecutingAssembly().Location),
                    "manifest1.xml",
                    "deployment1.xml");

                ResultCode = TEST_RESULTS.PASSED;
            }
        }

        #endregion

        #region Application Add Tests
        [TestCase]
        public class AddApplicationPositive : TestBase
        {
            protected override void Execute()
            {
                TestManifestFactory manifestFactory = new TestManifestFactory(2);
                object[] man_inXmlPathArgs = { Path.Combine(Path.GetDirectoryName(Assembly.GetExecutingAssembly().Location), "manifest1.xml") };
                manifestFactory.RunnerMock[1].AddExpectation("set_InXmlPath", man_inXmlPathArgs);
                manifestFactory.RunnerMock[1].AddExpectation("Import");

                TestOracleFactory oracleFactory = new TestOracleFactory();

                object[] isManifestImportedArgs1 = {"TestDB", "7.0.0001.0"};
                object[] isManifestImportedArgs2 = {"TestDB"};
                object[] addManifestToHashTableArgs = {"TestDB", "7.0.0001.0"};

                oracleFactory.RunnerMock.AddExpectation("IsManifestImported", isManifestImportedArgs1, false);
                oracleFactory.RunnerMock.AddExpectation("IsManifestImported", isManifestImportedArgs2, false);
                oracleFactory.RunnerMock.AddExpectation("IsManifestImported", isManifestImportedArgs1, false);
                oracleFactory.RunnerMock.AddExpectation("AddManifestToHashTable", addManifestToHashTableArgs);

                TestDeploymentFactory deploymentFactory = new TestDeploymentFactory();

                object [] dep_inXmlPathArgs = {Path.Combine(Path.GetDirectoryName(Assembly.GetExecutingAssembly().Location), "deployment1.xml")};
                object[] dep_setDeploymentNameArgs = {"TestDB"};
                deploymentFactory.RunnerMock.AddExpectation("set_InXmlPath", dep_inXmlPathArgs);
                deploymentFactory.RunnerMock.AddExpectation("Import");
                deploymentFactory.RunnerMock.AddExpectation("set_DeploymentName", dep_setDeploymentNameArgs);
                deploymentFactory.RunnerMock.AddExpectation("Setup");

                TestDatabaseTemplateFactory databaseTemplateFactory = new TestDatabaseTemplateFactory();

                WstRunnerFactory wstRunnerFactory = new WstRunnerFactory();
                wstRunnerFactory.OracleFactory = oracleFactory;
                wstRunnerFactory.ManifestFactory = manifestFactory;
                wstRunnerFactory.DeploymentFactory = deploymentFactory;
                wstRunnerFactory.DatabaseTemplateFactory = databaseTemplateFactory;

                IWstRunner wstRunner = wstRunnerFactory.CreateInstance(
                    Path.GetDirectoryName(Assembly.GetExecutingAssembly().Location),
                    "manifest1.xml",
                    "deployment1.xml");

                wstRunner.Setup(WstRunner.SetupAction.Install, false, false);

                ResultCode = TEST_RESULTS.PASSED;
            }
        }
        #endregion

        #region Application Upgrade Tests
        #endregion

        #region Application Uninstall Tests
        [TestCase]
        public class RemoveApplicationPositive : TestBase
        {
            protected override void Execute()
            {
                TestOracleFactory oracleFactory = new TestOracleFactory();
                object[] dep_isDeploymentImportedArgs = { "TestDB" };
                object[] man_isDeploymentImportedArgs = { "TestDB" };
                oracleFactory.RunnerMock.AddExpectation("IsDeploymentImported", dep_isDeploymentImportedArgs, false);
                oracleFactory.RunnerMock.AddExpectation("IsDeploymentImported", dep_isDeploymentImportedArgs, false);
                oracleFactory.RunnerMock.AddExpectation("IsDeploymentImported", dep_isDeploymentImportedArgs, false);
                oracleFactory.RunnerMock.AddExpectation("IsManifestImported", man_isDeploymentImportedArgs, false);

                TestManifestFactory manifestFactory = new TestManifestFactory();

                TestDeploymentFactory deploymentFactory = new TestDeploymentFactory();

                TestDatabaseTemplateFactory databaseTemplateFactory = new TestDatabaseTemplateFactory();

                TestFailSafeSetFactory failSafeSetFactory = new TestFailSafeSetFactory();
                failSafeSetFactory.RunnerMock.AddExpectation("set_DeploymentName", new object[] { "TestDB" });
                failSafeSetFactory.RunnerMock.AddExpectation("set_SQLFSSNum", new object[] { 0 });
                failSafeSetFactory.RunnerMock.AddExpectation("Demote");

                failSafeSetFactory.RunnerMock.AddExpectation("set_DeploymentName", new object[] { "TestDB" });
                failSafeSetFactory.RunnerMock.AddExpectation("set_SQLFSSNum", new object[] { 0 });
                failSafeSetFactory.RunnerMock.AddExpectation("Offline");

                failSafeSetFactory.RunnerMock.AddExpectation("set_DeploymentName", new object[] { "TestDB" });
                failSafeSetFactory.RunnerMock.AddExpectation("set_SQLFSSNum", new object[] { 0 });
                failSafeSetFactory.RunnerMock.AddExpectation("DropRepl");

                WstRunnerFactory wstRunnerFactory = new WstRunnerFactory();
                wstRunnerFactory.OracleFactory = oracleFactory;
                wstRunnerFactory.ManifestFactory = manifestFactory;
                wstRunnerFactory.DeploymentFactory = deploymentFactory;
                wstRunnerFactory.DatabaseTemplateFactory = databaseTemplateFactory;
                wstRunnerFactory.FailSafeSetFactory = failSafeSetFactory;

                IWstRunner wstRunner = wstRunnerFactory.CreateInstance(
                    Path.GetDirectoryName(Assembly.GetExecutingAssembly().Location),
                    "manifest1.xml",
                    "deployment1.xml");

                wstRunner.Remove(true);

                ResultCode = TEST_RESULTS.PASSED;
            }
        }
        #endregion

    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\wstrunner\test\objd\i386\_asmid.inc ===
ASSEMBLY_IDENTITY_KEY_FORM=msil_xonline.tools.wstrunner.test_none_12.4.56.0_none_6329eed30b602b21
ASSEMBLY_IDENTITY_XP_KEY_FORM=msil_xonline.tools.wstrunner.test_no-public-key_12.4.56.0_x-ww_15a5f4f1
ASSEMBLY_IDENTITY_CULTURE=
ASSEMBLY_IDENTITY_NAME=xonline.tools.wstrunner.test
ASSEMBLY_IDENTITY_PROCESSOR_ARCHITECTURE=msil
ASSEMBLY_IDENTITY_PUBLIC_KEY=
ASSEMBLY_IDENTITY_PUBLIC_KEY_TOKEN=
ASSEMBLY_IDENTITY_TYPE=
ASSEMBLY_IDENTITY_TYPE_NAME=
ASSEMBLY_IDENTITY_VERSION=12.4.56.0
XP_KEY_FORM=msil_xonline.tools.wstrunner.test_no-public-key_12.4.56.0_x-ww_15a5f4f1
XP_MANIFEST_DIRECTORY=manifests
XP_MANIFEST_NAME=msil_xonline.tools.wstrunner.test_no-public-key_12.4.56.0_x-ww_15a5f4f1.manifest
XP_MANIFEST_PATH=manifests\msil_xonline.tools.wstrunner.test_no-public-key_12.4.56.0_x-ww_15a5f4f1.manifest
XP_CATALOG_DIRECTORY=manifests
XP_CATALOG_NAME=msil_xonline.tools.wstrunner.test_no-public-key_12.4.56.0_x-ww_15a5f4f1.cat
XP_CATALOG_PATH=manifests\msil_xonline.tools.wstrunner.test_no-public-key_12.4.56.0_x-ww_15a5f4f1.cat
XP_PAYLOAD_PATH=msil_xonline.tools.wstrunner.test_no-public-key_12.4.56.0_x-ww_15a5f4f1
_DELAY_SIGN=0
!if [set _ASMIDTOATTRIBS_TLBIMP=]
!endif
CODESIGN_TESTKEY=
_TLBIMP_FLAGS=$(_TLBIMP_FLAGS)  /asmversion:12.4.56.0
_ASSEMBLY_IDENTITY=xonline.tools.wstrunner.test,processorArchitecture=msil,version=12.4.56.0,publicKeyToken=neutral
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\wstrunner\test\obj\i386\_asmid.inc ===
ASSEMBLY_IDENTITY_KEY_FORM=msil_xonline.tools.wstrunner.test_none_12.4.56.0_none_6329eed30b602b21
ASSEMBLY_IDENTITY_XP_KEY_FORM=msil_xonline.tools.wstrunner.test_no-public-key_12.4.56.0_x-ww_15a5f4f1
ASSEMBLY_IDENTITY_CULTURE=
ASSEMBLY_IDENTITY_NAME=xonline.tools.wstrunner.test
ASSEMBLY_IDENTITY_PROCESSOR_ARCHITECTURE=msil
ASSEMBLY_IDENTITY_PUBLIC_KEY=
ASSEMBLY_IDENTITY_PUBLIC_KEY_TOKEN=
ASSEMBLY_IDENTITY_TYPE=
ASSEMBLY_IDENTITY_TYPE_NAME=
ASSEMBLY_IDENTITY_VERSION=12.4.56.0
XP_KEY_FORM=msil_xonline.tools.wstrunner.test_no-public-key_12.4.56.0_x-ww_15a5f4f1
XP_MANIFEST_DIRECTORY=manifests
XP_MANIFEST_NAME=msil_xonline.tools.wstrunner.test_no-public-key_12.4.56.0_x-ww_15a5f4f1.manifest
XP_MANIFEST_PATH=manifests\msil_xonline.tools.wstrunner.test_no-public-key_12.4.56.0_x-ww_15a5f4f1.manifest
XP_CATALOG_DIRECTORY=manifests
XP_CATALOG_NAME=msil_xonline.tools.wstrunner.test_no-public-key_12.4.56.0_x-ww_15a5f4f1.cat
XP_CATALOG_PATH=manifests\msil_xonline.tools.wstrunner.test_no-public-key_12.4.56.0_x-ww_15a5f4f1.cat
XP_PAYLOAD_PATH=msil_xonline.tools.wstrunner.test_no-public-key_12.4.56.0_x-ww_15a5f4f1
_DELAY_SIGN=0
!if [set _ASMIDTOATTRIBS_TLBIMP=]
!endif
CODESIGN_TESTKEY=
_TLBIMP_FLAGS=$(_TLBIMP_FLAGS)  /asmversion:12.4.56.0
_ASSEMBLY_IDENTITY=xonline.tools.wstrunner.test,processorArchitecture=msil,version=12.4.56.0,publicKeyToken=neutral
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\wstrunner\testdb\prodbase\makefile.inc ===
!include $(INETROOT)\build\makefile.inc

SQLTARGET:
    -md %_NT386TREE%\msi\esp\database\WstRunnerTestDB
    -md %_NT386TREE%\msi\esp\database\WstRunnerTestDB\install
    for /f %i in ('dir /b *.sql *.xml') do type %i | perl -pe "s/\<\<BUILDNUMBER\>\>/%_BLDVERMAJOR%.%_BLDVERMINOR%.%_BLDNUMMAJOR%.%_BLDNUMMINOR%/" > %_NT386TREE%\msi\esp\database\WstRunnerTestDB\install\%i
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\wstrunner\test\DeploymentTestGroup.cs ===
/*******************************************************************
 *    FILE:         DeploymentTestGroup.cs
 *
 *    DESCRIPTION:  Unit tests for the xonline.tools.wstrunner.core.Deployment class
 *
 *    OWNER:        darrenan
 *
 *    HISTORY:      10-22-2007   - Created 
 *
 *    Copyright <cp> 2007 Microsoft Corporation.  All Rights Reserved.
 *******************************************************************/

using Microsoft.VisualStudio.TestTools.MockObjects;
using ServerTestFramework;
using ServerTestFramework.Core.Utilities;
using System.Collections.Generic;
using System.IO;
using System.Reflection;
using System.Xml;
using xonline.tools.wstrunner.core;

namespace xonline.tools.wstrunner.test
{
    [TestGroup, DVT, Owner("chlange"), TestCasePriority(1), TestFrequency("Regression")]
    class DeploymentTestGroup : TestNode
    {
        #region Constructor Tests
        [TestCase]
        public class DeploymentConstructorPositiveTest : TestBase
        {
            protected override void Execute()
            {
                SequenceMock<IDeployment> deploymentMock = new SequenceMock<IDeployment>();
                SequenceMock<IDatabaseTemplate> databaseTemplateMock = new SequenceMock<IDatabaseTemplate>();
                SequenceMock<IOracle> oracleMock = new SequenceMock<IOracle>();

                string currentAssemblyPath = Assembly.GetExecutingAssembly().Location;
                string deploymentDir = Path.GetDirectoryName(currentAssemblyPath);
                string deploymentFile = Path.Combine(deploymentDir, "deployment1.xml");
              
                Deployment deployment = new Deployment(
                    deploymentMock.Instance,
                    databaseTemplateMock.Instance,
                    oracleMock.Instance,
                    deploymentFile);

                ValueCheck.Test("DataPartitionCount", 4, deployment.DataPartionCount);
                ValueCheck.Test("PublisherName", "", deployment.PublisherName);

                ResultCode = TEST_RESULTS.PASSED;
            }
        }
        #endregion

        #region Import Tests
        [TestCase]
        class DeploymentImportPositiveTest : TestBase
        {
            override protected void Execute()
            {
                string currentAssemblyPath = Assembly.GetExecutingAssembly().Location;
                string deploymentDir = Path.GetDirectoryName(currentAssemblyPath);
                string deploymentFile = Path.Combine(deploymentDir, "deployment1.xml");

                SequenceMock<IDeployment> deploymentMock = new SequenceMock<IDeployment>();
                SequenceMock<IDatabaseTemplate> databaseTemplateMock = new SequenceMock<IDatabaseTemplate>();
                SequenceMock<IOracle> oracleMock = new SequenceMock<IOracle>();

                deploymentMock.AddExpectation(
                    "set_InXmlPath", 
                    new object [] { MockConstraint.IsEqual(deploymentFile, true)});
                deploymentMock.AddExpectation("Import");

                Deployment deployment = new Deployment(
                    deploymentMock.Instance,
                    databaseTemplateMock.Instance,
                    oracleMock.Instance,
                    deploymentFile);

                deployment.Import();

                deploymentMock.Verify();

                ResultCode = TEST_RESULTS.PASSED;
            }
        }
        #endregion

        #region Drop Tests
        [TestCase]
        class DeploymentDropPositiveTest : TestBase
        {
            protected override void Execute()
            {
                string currentAssemblyPath = Assembly.GetExecutingAssembly().Location;
                string deploymentDir = Path.GetDirectoryName(currentAssemblyPath);
                string deploymentFile = Path.Combine(deploymentDir, "deployment1.xml");
                string deploymentName = "TestDB";

                SequenceMock<IDeployment> deploymentMock = new SequenceMock<IDeployment>();
                SequenceMock<IDatabaseTemplate> databaseTemplateMock = new SequenceMock<IDatabaseTemplate>();
                SequenceMock<IOracle> oracleMock = new SequenceMock<IOracle>();

                deploymentMock.AddExpectation(
                    "set_IsForce",
                    new object[] { MockConstraint.IsEqual(true) });
                deploymentMock.AddExpectation(
                    "set_DeploymentName",
                    new object[] { MockConstraint.IsEqual(deploymentName, true) });
                deploymentMock.AddExpectation("Drop");
                databaseTemplateMock.AddExpectation("Purge");

                Deployment deployment = new Deployment(
                    deploymentMock.Instance,
                    databaseTemplateMock.Instance,
                    oracleMock.Instance,
                    deploymentFile);

                deployment.Drop();

                deploymentMock.Verify();

                ResultCode = TEST_RESULTS.PASSED;
            }

        }
        #endregion

        #region Setup Tests
        #endregion

        #region Generate Deployment Tests

        [TestCase]
        class DeploymentGeneratePositiveTest2Fss : TestBase
        {
            private readonly string manifestName = @"manifest";
            private readonly string manifestVersion = @"7.0.0.0";
            private readonly string dataFilePath = @"c:\mssql\data";
            private readonly string logFilePath = @"d:\mssql\data";
            private readonly uint partitionCount = 420;
            private readonly string databaseName = @"database";
            private readonly List<string> configServers;
            private readonly List<string> appServers;
            private readonly uint failSafeSetsPerServer;
            private readonly List<ApplicationAccount> accounts;

            public DeploymentGeneratePositiveTest2Fss()
            {
                configServers = new List<string>();
                configServers.Add("configServer1");
                configServers.Add("configServer2");

                appServers = new List<string>();
                appServers.Add("s1");
                appServers.Add("configServer2");
                appServers.Add("s3");

                failSafeSetsPerServer = 2;

                accounts = new List<ApplicationAccount>();
                accounts.Add(new ApplicationAccount(@"test\acct0", "ClientLib", "deployment"));
                accounts.Add(new ApplicationAccount(@"test\acct1", "AdminLib", "deployment"));
            }

            protected override void Execute()
            {
                XmlNode workingNode;
                XmlNode scopeNode;

                XmlDocument deploymentDoc = DeploymentFileFactory.GetDeployment(
                    manifestName,
                    manifestVersion,
                    dataFilePath,
                    logFilePath,
                    configServers,
                    appServers,
                    failSafeSetsPerServer,
                    accounts,
                    partitionCount,
                    databaseName);
                ValueCheck.TestNotNull("deploymentDoc is not null", deploymentDoc);

                XmlNamespaceManager manager = new XmlNamespaceManager(deploymentDoc.NameTable);
                manager.AddNamespace("ws", "urn:WebstoreDeploymentSchema.xsd");

                // Distribution Database Template

                scopeNode = deploymentDoc.SelectSingleNode("//ws:DatabaseTemplates/ws:DatabaseTemplate[@Name=\"" + databaseName + "DistributionDatabaseTemplate\"]", manager);
                ValueCheck.TestNotNull("Distribution Database Template", scopeNode);

                workingNode = scopeNode.SelectSingleNode("ws:DataFileGroups/ws:FileGroup[@Name=\"Primary\"]/ws:LogicalFiles/ws:LogicalFile[@Name=\"modeldist\"]/ws:Path/text()", manager);
                ValueCheck.TestNotNull("Data File Path", workingNode);
                ValueCheck.Test("Data File Path not set correctly", Path.Combine(dataFilePath, databaseName + "Data"), workingNode.Value);

                workingNode = scopeNode.SelectSingleNode("ws:LogFile/ws:LogicalFile[@Name=\"modeldist_log\"]/ws:Path/text()", manager);
                ValueCheck.TestNotNull("Log File Path", workingNode);
                ValueCheck.Test("Log File Path not set correctly", Path.Combine(logFilePath, databaseName + "Data"), workingNode.Value);

                // Database Template

                scopeNode = deploymentDoc.SelectSingleNode("//ws:DatabaseTemplates/ws:DatabaseTemplate[@Name=\"" + databaseName + "DatabaseTemplate\"]", manager);
                ValueCheck.TestNotNull("Database Template", scopeNode);

                workingNode = scopeNode.SelectSingleNode("ws:DataFileGroups/ws:FileGroup[@Name=\"Primary\"]/ws:LogicalFiles/ws:LogicalFile[@Name=\"DataFile\"]/ws:Path/text()", manager);
                ValueCheck.TestNotNull("Data File Path", workingNode);
                ValueCheck.Test("Data File Path not set correctly", Path.Combine(dataFilePath, databaseName + "Data"), workingNode.Value);

                workingNode = scopeNode.SelectSingleNode("ws:LogFile/ws:LogicalFile[@Name=\"LogFile\"]/ws:Path/text()", manager);
                ValueCheck.TestNotNull("Log File Path", workingNode);
                ValueCheck.Test("Log File Path not set correctly", Path.Combine(logFilePath, databaseName + "Data"), workingNode.Value);

                workingNode = scopeNode.SelectSingleNode("ws:Stripes/ws:Stripe/ws:Directory/text()", manager);
                ValueCheck.TestNotNull("Directory for sqlxfer share", workingNode);
                ValueCheck.Test("Directory for sqlxfer$ share is incorrect", Path.Combine(dataFilePath, "BAK"), workingNode.Value);

                // Config Server(s)

                scopeNode = deploymentDoc.SelectSingleNode("//ws:Servers", manager);
                ValueCheck.TestNotNull("Servers Element", scopeNode);
                ValueCheck.Test("Servers Count", appServers.Count, scopeNode.ChildNodes.Count);

                foreach (string server in appServers)
                {
                    workingNode = scopeNode.SelectSingleNode("ws:Server[@Name=\"" + server + "\"]", manager);
                    ValueCheck.TestNotNull(string.Format("Config server \"{0}\"", server), workingNode);

                    workingNode = scopeNode.SelectSingleNode("ws:Server[@Name=\"" + server + "\"]/ws:DistributionDatabaseTemplate[@Name=\"" + databaseName + "DistributionDatabaseTemplate\"]", manager);
                    ValueCheck.TestNotNull(string.Format("Distribution database template not correctly set for \"{0}\".", server), workingNode);

                    workingNode = scopeNode.SelectSingleNode("ws:Server[@Name=\"" + server + "\"]/ws:ServerRoles/ws:ServerRole/text()", manager);
                    ValueCheck.TestNotNull(string.Format("Distribution database template not correctly set for \"{0}\".", server), workingNode);

                    string expectedRole = "WstAppServerRole";
                    foreach (string configServer in configServers)
                    {
                        if (configServer == server)
                        {
                            expectedRole = "WstConfigServerRole";
                        }
                    }
                    ValueCheck.Test("Server Role Assigned To Server", expectedRole, workingNode.Value);
                }

                // Deployment Details

                scopeNode = deploymentDoc.SelectSingleNode("//ws:Deployment", manager);
                ValueCheck.TestNotNull("Deployment Element", scopeNode);
                ValueCheck.Test("Deployment Name", databaseName, ((XmlElement)scopeNode).GetAttribute("Name"));

                workingNode = scopeNode.SelectSingleNode("ws:UseManifest/ws:ManifestName/text()", manager);
                ValueCheck.Test("Manifest Name", manifestName, workingNode.Value);

                workingNode = scopeNode.SelectSingleNode("ws:UseManifest/ws:ManifestVersion/text()", manager);
                ValueCheck.Test("Manifest Version", manifestVersion, workingNode.Value);

                // Accounts

                scopeNode = deploymentDoc.SelectSingleNode("//ws:Deployment/ws:DeploymentDefaults/ws:Accounts", manager);
                ValueCheck.TestNotNull("Accounts Element", scopeNode);
                ValueCheck.Test("Accounts Count", accounts.Count, scopeNode.ChildNodes.Count);

                foreach (ApplicationAccount account in accounts)
                {
                    workingNode = scopeNode.SelectSingleNode("ws:Account[@Name=\"" + account.Name + "\"]", manager);
                    ValueCheck.TestNotNull(string.Format("Account \"{0}\"", account.Name), workingNode);

                    workingNode = workingNode.SelectSingleNode("ws:Role/text()", manager);
                    ValueCheck.Test("Account Role Name", account.Role, workingNode.Value);
                }

                // SQL Fail Safe Sets

                scopeNode = deploymentDoc.SelectSingleNode("//ws:Deployment/ws:SqlFailSafeSets", manager);
                ValueCheck.TestNotNull("SqlFailSafeSets Element", scopeNode);
                ValueCheck.Test("SqlFailSafeSets Count", appServers.Count * failSafeSetsPerServer, scopeNode.ChildNodes.Count);

                int currentFailSafeSet = 0;

                for (int currentAppServer = 0; currentAppServer < appServers.Count; ++currentAppServer)
                {
                    for (uint perServerFailSafeSet = 0; perServerFailSafeSet < failSafeSetsPerServer; ++perServerFailSafeSet)
                    {
                        string currentDatabaseName = (failSafeSetsPerServer == 1) ? databaseName : string.Format("{0}{1}", databaseName, currentFailSafeSet.ToString("000"));

                        workingNode = scopeNode.SelectSingleNode("ws:SqlFailSafeSet[@Number=\"" + currentFailSafeSet + "\"]", manager);
                        ValueCheck.TestNotNull("SqlFailSafeSet " + currentFailSafeSet, workingNode);

                        workingNode = scopeNode.SelectSingleNode("ws:SqlFailSafeSet[@Number=\"" + currentFailSafeSet + "\"]/ws:DatabaseTemplate[@Name=\"" + databaseName + "DatabaseTemplate\"]", manager);
                        ValueCheck.TestNotNull("SqlFailSafeSet " + currentFailSafeSet + " Database Template", workingNode);

                        workingNode = scopeNode.SelectSingleNode("ws:SqlFailSafeSet[@Number=\"" + currentFailSafeSet + "\"]/ws:Databases/ws:Database[@Name=\"" + currentDatabaseName + "\"][@DataServer=\"" + appServers[currentAppServer] + "\"]", manager);
                        ValueCheck.TestNotNull("SqlFailSafeSet " + currentFailSafeSet + " Database", workingNode);

                        if (appServers.Count > 1)
                        {
                            workingNode = scopeNode.SelectSingleNode("ws:SqlFailSafeSet[@Number=\"" + currentFailSafeSet + "\"]/ws:Databases/ws:Database[@Name=\"" + currentDatabaseName + "Replica\"][@DataServer=\"" + appServers[(currentAppServer + 1) % appServers.Count] + "\"]", manager);
                            ValueCheck.TestNotNull("SqlFailSafeSet " + currentFailSafeSet + " Replica Database", workingNode);
                        }

                        workingNode = scopeNode.SelectSingleNode("ws:SqlFailSafeSet[@Number=\"" + currentFailSafeSet + "\"]/ws:DefaultPrimaryDatabase[@Database=\"" + currentDatabaseName + "\"][@DataServer=\"" + appServers[currentAppServer] + "\"]", manager);
                        ValueCheck.TestNotNull("SqlFailSafeSet " + currentFailSafeSet + " Default Primary Database", workingNode);

                        workingNode = scopeNode.SelectSingleNode("ws:SqlFailSafeSet[@Number=\"" + currentFailSafeSet + "\"]/ws:PrimaryDatabase[@Database=\"" + currentDatabaseName + "\"][@DataServer=\"" + appServers[currentAppServer] + "\"]", manager);
                        ValueCheck.TestNotNull("SqlFailSafeSet " + currentFailSafeSet + " Primary Database", workingNode);

                        ++currentFailSafeSet;
                    }
                }

                // Data Partitions
                scopeNode = deploymentDoc.SelectSingleNode("//ws:Deployment/ws:DataPartitions", manager);
                ValueCheck.TestNotNull("DataPartitions Element", scopeNode);
                ValueCheck.Test("DataPartitions Count", partitionCount, scopeNode.ChildNodes.Count);

                int partitionsPerSet = ((int)partitionCount / (appServers.Count * (int)failSafeSetsPerServer));
                for (int currentPartition = 0; currentPartition < partitionCount; ++currentPartition)
                {
                    int fssNumber = currentPartition / partitionsPerSet;

                    workingNode = scopeNode.SelectSingleNode("ws:DataPartition[@Number=\"" + currentPartition + "\"]", manager);
                    ValueCheck.TestNotNull("DataPartition " + currentPartition, workingNode);

                    workingNode = workingNode.SelectSingleNode("ws:SqlFailSafeSetNumber/text()", manager);
                    ValueCheck.Test("DataPartition " + currentPartition + " FSS Number", fssNumber.ToString(), workingNode.Value);
                }

                ResultCode = TEST_RESULTS.PASSED;
            }
        }


        [TestCase]
        class DeploymentGeneratePositiveTest1Fss : TestBase
        {
            private readonly string manifestName = @"manifest";
            private readonly string manifestVersion = @"7.0.0.0";
            private readonly string dataFilePath = @"c:\mssql\data";
            private readonly string logFilePath = @"d:\mssql\data";
            private readonly uint partitionCount = 420;
            private readonly string databaseName = @"database";
            private readonly List<string> configServers;
            private readonly List<string> appServers;
            private readonly uint failSafeSetsPerServer;
            private readonly List<ApplicationAccount> accounts;

            public DeploymentGeneratePositiveTest1Fss()
            {
                configServers = new List<string>();
                configServers.Add("configServer1");
                configServers.Add("configServer2");

                appServers = new List<string>();
                appServers.Add("s1");
                appServers.Add("configServer2");
                appServers.Add("s3");

                failSafeSetsPerServer = 1;

                accounts = new List<ApplicationAccount>();
                accounts.Add(new ApplicationAccount(@"test\acct0", "ClientLib", "deployment"));
                accounts.Add(new ApplicationAccount(@"test\acct1", "AdminLib", "deployment"));
            }

            protected override void Execute()
            {
                XmlNode workingNode;
                XmlNode scopeNode;

                XmlDocument deploymentDoc = DeploymentFileFactory.GetDeployment(
                    manifestName,
                    manifestVersion,
                    dataFilePath,
                    logFilePath,
                    configServers,
                    appServers,
                    failSafeSetsPerServer,
                    accounts,
                    partitionCount,
                    databaseName);
                ValueCheck.TestNotNull("deploymentDoc is not null", deploymentDoc);

                XmlNamespaceManager manager = new XmlNamespaceManager(deploymentDoc.NameTable);
                manager.AddNamespace("ws", "urn:WebstoreDeploymentSchema.xsd");

                // Distribution Database Template

                scopeNode = deploymentDoc.SelectSingleNode("//ws:DatabaseTemplates/ws:DatabaseTemplate[@Name=\"" + databaseName + "DistributionDatabaseTemplate\"]", manager);
                ValueCheck.TestNotNull("Distribution Database Template", scopeNode);

                workingNode = scopeNode.SelectSingleNode("ws:DataFileGroups/ws:FileGroup[@Name=\"Primary\"]/ws:LogicalFiles/ws:LogicalFile[@Name=\"modeldist\"]/ws:Path/text()", manager);
                ValueCheck.TestNotNull("Data File Path", workingNode);
                ValueCheck.Test("Data File Path not set correctly", Path.Combine(dataFilePath, databaseName + "Data"), workingNode.Value);

                workingNode = scopeNode.SelectSingleNode("ws:LogFile/ws:LogicalFile[@Name=\"modeldist_log\"]/ws:Path/text()", manager);
                ValueCheck.TestNotNull("Log File Path", workingNode);
                ValueCheck.Test("Log File Path not set correctly", Path.Combine(logFilePath, databaseName + "Data"), workingNode.Value);

                // Database Template

                scopeNode = deploymentDoc.SelectSingleNode("//ws:DatabaseTemplates/ws:DatabaseTemplate[@Name=\"" + databaseName + "DatabaseTemplate\"]", manager);
                ValueCheck.TestNotNull("Database Template", scopeNode);

                workingNode = scopeNode.SelectSingleNode("ws:DataFileGroups/ws:FileGroup[@Name=\"Primary\"]/ws:LogicalFiles/ws:LogicalFile[@Name=\"DataFile\"]/ws:Path/text()", manager);
                ValueCheck.TestNotNull("Data File Path", workingNode);
                ValueCheck.Test("Data File Path not set correctly", Path.Combine(dataFilePath, databaseName + "Data"), workingNode.Value);

                workingNode = scopeNode.SelectSingleNode("ws:LogFile/ws:LogicalFile[@Name=\"LogFile\"]/ws:Path/text()", manager);
                ValueCheck.TestNotNull("Log File Path", workingNode);
                ValueCheck.Test("Log File Path not set correctly", Path.Combine(logFilePath, databaseName + "Data"), workingNode.Value);

                workingNode = scopeNode.SelectSingleNode("ws:Stripes/ws:Stripe/ws:Directory/text()", manager);
                ValueCheck.TestNotNull("Directory for sqlxfer share", workingNode);
                ValueCheck.Test("Directory for sqlxfer$ share is incorrect", Path.Combine(dataFilePath, "BAK"), workingNode.Value);

                // Config Server(s)

                scopeNode = deploymentDoc.SelectSingleNode("//ws:Servers", manager);
                ValueCheck.TestNotNull("Servers Element", scopeNode);
                ValueCheck.Test("Servers Count", appServers.Count, scopeNode.ChildNodes.Count);

                foreach (string server in appServers)
                {
                    workingNode = scopeNode.SelectSingleNode("ws:Server[@Name=\"" + server + "\"]", manager);
                    ValueCheck.TestNotNull(string.Format("Config server \"{0}\"", server), workingNode);

                    workingNode = scopeNode.SelectSingleNode("ws:Server[@Name=\"" + server + "\"]/ws:DistributionDatabaseTemplate[@Name=\"" + databaseName + "DistributionDatabaseTemplate\"]", manager);
                    ValueCheck.TestNotNull(string.Format("Distribution database template not correctly set for \"{0}\".", server), workingNode);

                    workingNode = scopeNode.SelectSingleNode("ws:Server[@Name=\"" + server + "\"]/ws:ServerRoles/ws:ServerRole/text()", manager);
                    ValueCheck.TestNotNull(string.Format("Distribution database template not correctly set for \"{0}\".", server), workingNode);

                    string expectedRole = "WstAppServerRole";
                    foreach (string configServer in configServers)
                    {
                        if (configServer == server)
                        {
                            expectedRole = "WstConfigServerRole";
                        }
                    }
                    ValueCheck.Test("Server Role Assigned To Server", expectedRole, workingNode.Value);
                }

                // Deployment Details

                scopeNode = deploymentDoc.SelectSingleNode("//ws:Deployment", manager);
                ValueCheck.TestNotNull("Deployment Element", scopeNode);
                ValueCheck.Test("Deployment Name", databaseName, ((XmlElement)scopeNode).GetAttribute("Name"));

                workingNode = scopeNode.SelectSingleNode("ws:UseManifest/ws:ManifestName/text()", manager);
                ValueCheck.Test("Manifest Name", manifestName, workingNode.Value);

                workingNode = scopeNode.SelectSingleNode("ws:UseManifest/ws:ManifestVersion/text()", manager);
                ValueCheck.Test("Manifest Version", manifestVersion, workingNode.Value);

                // Accounts

                scopeNode = deploymentDoc.SelectSingleNode("//ws:Deployment/ws:DeploymentDefaults/ws:Accounts", manager);
                ValueCheck.TestNotNull("Accounts Element", scopeNode);
                ValueCheck.Test("Accounts Count", accounts.Count, scopeNode.ChildNodes.Count);

                foreach (ApplicationAccount account in accounts)
                {
                    workingNode = scopeNode.SelectSingleNode("ws:Account[@Name=\"" + account.Name + "\"]", manager);
                    ValueCheck.TestNotNull(string.Format("Account \"{0}\"", account.Name), workingNode);

                    workingNode = workingNode.SelectSingleNode("ws:Role/text()", manager);
                    ValueCheck.Test("Account Role Name", account.Role, workingNode.Value);
                }

                // SQL Fail Safe Sets

                scopeNode = deploymentDoc.SelectSingleNode("//ws:Deployment/ws:SqlFailSafeSets", manager);
                ValueCheck.TestNotNull("SqlFailSafeSets Element", scopeNode);
                ValueCheck.Test("SqlFailSafeSets Count", appServers.Count * failSafeSetsPerServer, scopeNode.ChildNodes.Count);

                int currentFailSafeSet = 0;

                for (int currentAppServer = 0; currentAppServer < appServers.Count; ++currentAppServer)
                {
                    for (uint perServerFailSafeSet = 0; perServerFailSafeSet < failSafeSetsPerServer; ++perServerFailSafeSet)
                    {
                        string currentDatabaseName = (failSafeSetsPerServer == 1) ? databaseName : string.Format("{0}{1}", databaseName, currentFailSafeSet.ToString("000"));

                        workingNode = scopeNode.SelectSingleNode("ws:SqlFailSafeSet[@Number=\"" + currentFailSafeSet + "\"]", manager);
                        ValueCheck.TestNotNull("SqlFailSafeSet " + currentFailSafeSet, workingNode);

                        workingNode = scopeNode.SelectSingleNode("ws:SqlFailSafeSet[@Number=\"" + currentFailSafeSet + "\"]/ws:DatabaseTemplate[@Name=\"" + databaseName + "DatabaseTemplate\"]", manager);
                        ValueCheck.TestNotNull("SqlFailSafeSet " + currentFailSafeSet + " Database Template", workingNode);

                        workingNode = scopeNode.SelectSingleNode("ws:SqlFailSafeSet[@Number=\"" + currentFailSafeSet + "\"]/ws:Databases/ws:Database[@Name=\"" + currentDatabaseName + "\"][@DataServer=\"" + appServers[currentAppServer] + "\"]", manager);
                        ValueCheck.TestNotNull("SqlFailSafeSet " + currentFailSafeSet + " Database", workingNode);

                        if (appServers.Count > 1)
                        {
                            workingNode = scopeNode.SelectSingleNode("ws:SqlFailSafeSet[@Number=\"" + currentFailSafeSet + "\"]/ws:Databases/ws:Database[@Name=\"" + currentDatabaseName + "Replica\"][@DataServer=\"" + appServers[(currentAppServer + 1) % appServers.Count] + "\"]", manager);
                            ValueCheck.TestNotNull("SqlFailSafeSet " + currentFailSafeSet + " Replica Database", workingNode);
                        }

                        workingNode = scopeNode.SelectSingleNode("ws:SqlFailSafeSet[@Number=\"" + currentFailSafeSet + "\"]/ws:DefaultPrimaryDatabase[@Database=\"" + currentDatabaseName + "\"][@DataServer=\"" + appServers[currentAppServer] + "\"]", manager);
                        ValueCheck.TestNotNull("SqlFailSafeSet " + currentFailSafeSet + " Default Primary Database", workingNode);

                        workingNode = scopeNode.SelectSingleNode("ws:SqlFailSafeSet[@Number=\"" + currentFailSafeSet + "\"]/ws:PrimaryDatabase[@Database=\"" + currentDatabaseName + "\"][@DataServer=\"" + appServers[currentAppServer] + "\"]", manager);
                        ValueCheck.TestNotNull("SqlFailSafeSet " + currentFailSafeSet + " Primary Database", workingNode);

                        ++currentFailSafeSet;
                    }
                }

                // Data Partitions
                scopeNode = deploymentDoc.SelectSingleNode("//ws:Deployment/ws:DataPartitions", manager);
                ValueCheck.TestNotNull("DataPartitions Element", scopeNode);
                ValueCheck.Test("DataPartitions Count", partitionCount, scopeNode.ChildNodes.Count);

                int partitionsPerSet = ((int)partitionCount / (appServers.Count * (int)failSafeSetsPerServer));
                for (int currentPartition = 0; currentPartition < partitionCount; ++currentPartition)
                {
                    int fssNumber = currentPartition / partitionsPerSet;

                    workingNode = scopeNode.SelectSingleNode("ws:DataPartition[@Number=\"" + currentPartition + "\"]", manager);
                    ValueCheck.TestNotNull("DataPartition " + currentPartition, workingNode);

                    workingNode = workingNode.SelectSingleNode("ws:SqlFailSafeSetNumber/text()", manager);
                    ValueCheck.Test("DataPartition " + currentPartition + " FSS Number", fssNumber.ToString(), workingNode.Value);
                }

                ResultCode = TEST_RESULTS.PASSED;
            }
        }

        #endregion
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\wstrunner\testdb\prodbase\obj\i386\_asmid.inc ===
ASSEMBLY_IDENTITY_KEY_FORM=x86__prodbase_4_none_12.4.56.0_none_456c6b380e2df316
ASSEMBLY_IDENTITY_XP_KEY_FORM=x86__prodbase_4_no-public-key_12.4.56.0_x-ww_d5392792
ASSEMBLY_IDENTITY_CULTURE=
ASSEMBLY_IDENTITY_NAME=_prodbase_4
ASSEMBLY_IDENTITY_PROCESSOR_ARCHITECTURE=x86
ASSEMBLY_IDENTITY_PUBLIC_KEY=
ASSEMBLY_IDENTITY_PUBLIC_KEY_TOKEN=
ASSEMBLY_IDENTITY_TYPE=
ASSEMBLY_IDENTITY_TYPE_NAME=
ASSEMBLY_IDENTITY_VERSION=12.4.56.0
XP_KEY_FORM=x86__prodbase_4_no-public-key_12.4.56.0_x-ww_d5392792
XP_MANIFEST_DIRECTORY=manifests
XP_MANIFEST_NAME=x86__prodbase_4_no-public-key_12.4.56.0_x-ww_d5392792.manifest
XP_MANIFEST_PATH=manifests\x86__prodbase_4_no-public-key_12.4.56.0_x-ww_d5392792.manifest
XP_CATALOG_DIRECTORY=manifests
XP_CATALOG_NAME=x86__prodbase_4_no-public-key_12.4.56.0_x-ww_d5392792.cat
XP_CATALOG_PATH=manifests\x86__prodbase_4_no-public-key_12.4.56.0_x-ww_d5392792.cat
XP_PAYLOAD_PATH=x86__prodbase_4_no-public-key_12.4.56.0_x-ww_d5392792
_DELAY_SIGN=0
!if [set _ASMIDTOATTRIBS_TLBIMP=]
!endif
CODESIGN_TESTKEY=
_TLBIMP_FLAGS=$(_TLBIMP_FLAGS)  /asmversion:12.4.56.0
_ASSEMBLY_IDENTITY=_prodbase_4,processorArchitecture=x86,version=12.4.56.0,publicKeyToken=neutral
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\wstrunner\testdb\prodbase\objd\i386\_asmid.inc ===
ASSEMBLY_IDENTITY_KEY_FORM=x86__prodbase_4_none_12.4.56.0_none_456c6b380e2df316
ASSEMBLY_IDENTITY_XP_KEY_FORM=x86__prodbase_4_no-public-key_12.4.56.0_x-ww_d5392792
ASSEMBLY_IDENTITY_CULTURE=
ASSEMBLY_IDENTITY_NAME=_prodbase_4
ASSEMBLY_IDENTITY_PROCESSOR_ARCHITECTURE=x86
ASSEMBLY_IDENTITY_PUBLIC_KEY=
ASSEMBLY_IDENTITY_PUBLIC_KEY_TOKEN=
ASSEMBLY_IDENTITY_TYPE=
ASSEMBLY_IDENTITY_TYPE_NAME=
ASSEMBLY_IDENTITY_VERSION=12.4.56.0
XP_KEY_FORM=x86__prodbase_4_no-public-key_12.4.56.0_x-ww_d5392792
XP_MANIFEST_DIRECTORY=manifests
XP_MANIFEST_NAME=x86__prodbase_4_no-public-key_12.4.56.0_x-ww_d5392792.manifest
XP_MANIFEST_PATH=manifests\x86__prodbase_4_no-public-key_12.4.56.0_x-ww_d5392792.manifest
XP_CATALOG_DIRECTORY=manifests
XP_CATALOG_NAME=x86__prodbase_4_no-public-key_12.4.56.0_x-ww_d5392792.cat
XP_CATALOG_PATH=manifests\x86__prodbase_4_no-public-key_12.4.56.0_x-ww_d5392792.cat
XP_PAYLOAD_PATH=x86__prodbase_4_no-public-key_12.4.56.0_x-ww_d5392792
_DELAY_SIGN=0
!if [set _ASMIDTOATTRIBS_TLBIMP=]
!endif
CODESIGN_TESTKEY=
_TLBIMP_FLAGS=$(_TLBIMP_FLAGS)  /asmversion:12.4.56.0
_ASSEMBLY_IDENTITY=_prodbase_4,processorArchitecture=x86,version=12.4.56.0,publicKeyToken=neutral
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\wstrunner\testdb\upgrade\makefile.inc ===
!include $(INETROOT)\build\makefile.inc

SQLTARGET:
    -md %_NT386TREE%\msi\esp\database\WstRunnerTestDB
    -md %_NT386TREE%\msi\esp\database\WstRunnerTestDB\upgrade
    for /f %i in ('dir /b *.sql *.xml') do type %i | perl -pe "s/\<\<BUILDNUMBER\>\>/%_BLDVERMAJOR%.%_BLDVERMINOR%.%_BLDNUMMAJOR%.%_BLDNUMMINOR%/" > %_NT386TREE%\msi\esp\database\WstRunnerTestDB\upgrade\%i
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\wstrunner\testdb\upgrade\obj\i386\_asmid.inc ===
ASSEMBLY_IDENTITY_KEY_FORM=x86__upgrade_4_none_12.4.56.0_none_d800e2831c422dc8
ASSEMBLY_IDENTITY_XP_KEY_FORM=x86__upgrade_4_no-public-key_12.4.56.0_x-ww_f643cb68
ASSEMBLY_IDENTITY_CULTURE=
ASSEMBLY_IDENTITY_NAME=_upgrade_4
ASSEMBLY_IDENTITY_PROCESSOR_ARCHITECTURE=x86
ASSEMBLY_IDENTITY_PUBLIC_KEY=
ASSEMBLY_IDENTITY_PUBLIC_KEY_TOKEN=
ASSEMBLY_IDENTITY_TYPE=
ASSEMBLY_IDENTITY_TYPE_NAME=
ASSEMBLY_IDENTITY_VERSION=12.4.56.0
XP_KEY_FORM=x86__upgrade_4_no-public-key_12.4.56.0_x-ww_f643cb68
XP_MANIFEST_DIRECTORY=manifests
XP_MANIFEST_NAME=x86__upgrade_4_no-public-key_12.4.56.0_x-ww_f643cb68.manifest
XP_MANIFEST_PATH=manifests\x86__upgrade_4_no-public-key_12.4.56.0_x-ww_f643cb68.manifest
XP_CATALOG_DIRECTORY=manifests
XP_CATALOG_NAME=x86__upgrade_4_no-public-key_12.4.56.0_x-ww_f643cb68.cat
XP_CATALOG_PATH=manifests\x86__upgrade_4_no-public-key_12.4.56.0_x-ww_f643cb68.cat
XP_PAYLOAD_PATH=x86__upgrade_4_no-public-key_12.4.56.0_x-ww_f643cb68
_DELAY_SIGN=0
!if [set _ASMIDTOATTRIBS_TLBIMP=]
!endif
CODESIGN_TESTKEY=
_TLBIMP_FLAGS=$(_TLBIMP_FLAGS)  /asmversion:12.4.56.0
_ASSEMBLY_IDENTITY=_upgrade_4,processorArchitecture=x86,version=12.4.56.0,publicKeyToken=neutral
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\wstrunner\testdb\upgrade\objd\i386\_asmid.inc ===
ASSEMBLY_IDENTITY_KEY_FORM=x86__upgrade_4_none_12.4.56.0_none_d800e2831c422dc8
ASSEMBLY_IDENTITY_XP_KEY_FORM=x86__upgrade_4_no-public-key_12.4.56.0_x-ww_f643cb68
ASSEMBLY_IDENTITY_CULTURE=
ASSEMBLY_IDENTITY_NAME=_upgrade_4
ASSEMBLY_IDENTITY_PROCESSOR_ARCHITECTURE=x86
ASSEMBLY_IDENTITY_PUBLIC_KEY=
ASSEMBLY_IDENTITY_PUBLIC_KEY_TOKEN=
ASSEMBLY_IDENTITY_TYPE=
ASSEMBLY_IDENTITY_TYPE_NAME=
ASSEMBLY_IDENTITY_VERSION=12.4.56.0
XP_KEY_FORM=x86__upgrade_4_no-public-key_12.4.56.0_x-ww_f643cb68
XP_MANIFEST_DIRECTORY=manifests
XP_MANIFEST_NAME=x86__upgrade_4_no-public-key_12.4.56.0_x-ww_f643cb68.manifest
XP_MANIFEST_PATH=manifests\x86__upgrade_4_no-public-key_12.4.56.0_x-ww_f643cb68.manifest
XP_CATALOG_DIRECTORY=manifests
XP_CATALOG_NAME=x86__upgrade_4_no-public-key_12.4.56.0_x-ww_f643cb68.cat
XP_CATALOG_PATH=manifests\x86__upgrade_4_no-public-key_12.4.56.0_x-ww_f643cb68.cat
XP_PAYLOAD_PATH=x86__upgrade_4_no-public-key_12.4.56.0_x-ww_f643cb68
_DELAY_SIGN=0
!if [set _ASMIDTOATTRIBS_TLBIMP=]
!endif
CODESIGN_TESTKEY=
_TLBIMP_FLAGS=$(_TLBIMP_FLAGS)  /asmversion:12.4.56.0
_ASSEMBLY_IDENTITY=_upgrade_4,processorArchitecture=x86,version=12.4.56.0,publicKeyToken=neutral
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\XAppAdmin\LiveMachineClass.cs ===
using System;
using System.Collections;
using System.Collections.Generic;
using System.Text;
using System.Data;
using System.Data.SqlClient;
using Microsoft.Webstore.WstClient;
using Microsoft.Webstore.MetaData;

namespace XappAdmin
{
    public class LiveMachine : LiveObject
    {
        long machinespuid;
        string machinesgamertag = string.Empty;    // gamertag as stored in t_machines

        // CONSTRUCTOR
                public LiveMachine(WstConnection wstc)
        {
            wstcon = wstc;
            partcount = WebstoreMetaData.Instance.DefaultConfig.Deployments[WstLib.deploymentGuid("UODB")].Partitions.Count;
        }
        
        public LiveMachine(WstConnection wstc, string inpgt)
        {
            wstcon = wstc;
            partcount = WebstoreMetaData.Instance.DefaultConfig.Deployments[WstLib.deploymentGuid("UODB")].Partitions.Count;
            Gamertag = inpgt;   // this populates the PUID automatically
        }
        
        public LiveMachine(WstConnection wstc, long inppuid)
        {
            wstcon = wstc;
            partcount = WebstoreMetaData.Instance.DefaultConfig.Deployments[WstLib.deploymentGuid("UODB")].Partitions.Count;
            PUID = inppuid;
        }

        // PROPERTIES
        public string Gamertag
        {
            // NOTE: Gamertag is from t_user_names, and represents the consoleID (e.g. 'XE.012345678901')
            // The corresponding value from t_machines is MachinesSerialNum.
            get
            {
                return namesgamertag;
            }
            set
            {
                enteredgamertag = value.ToString();
                getGamertagAndPuidFromGamertag(enteredgamertag);
                if (namespuid != -1)
                {
                    getGamertagAndPuidFromPuid(namespuid);
                }
            }
        }

        public long PUID
        {
            // NOTE: PUID is from t_machines.
            // The corresponding value from t_user_names is NamesPUID, inherited from LiveObjectClass.
            get
            {
                return machinespuid;
            }
            set
            {
                enteredpuid = value;
                getGamertagAndPuidFromPuid(enteredpuid);
                if (puidexistsinmachines)
                {
                    getGamertagAndPuidFromGamertag(machinesgamertag);
                }
            }
        }

        public string MachinesSerialNum
        {
            get
            {
                return machinesgamertag;
            }
        }

        protected void getGamertagAndPuidFromGamertag(string inpgt)
        {
            namesgamertag = string.Empty;
            namespuid = -1;
            WstCommand gtcmd = wstcon.CreateCommand();
            namesbucket = WstHash.GetHash(inpgt.ToLower(), partcount);
            gtcmd.Partition = namesbucket;
            gtcmd.WstFailoverMode = WstFailoverMode.PrimaryThenSecondary;
            WstDataReader rdr = getResultsFromUsernames(gtcmd, inpgt);
            if (rdr != null)
            {
                namespartition = gtcmd.LastPartitionExecuted;
                WebstoreDatabase db = gtcmd.Database;
                namesserver = db.ServerName;
                namesdatabase = db.Name;
                if (rdr.HasRows)
                {
                    namesgamertag = WstLib.getStringFromReader(rdr);
                    namespuid = WstLib.getLongFromReader(rdr, 1);
                    puidinhex = "0x" + namespuid.ToString("X");
                }
                // clean up so the WstCommand object can be reused
                if (!rdr.IsClosed)
                    rdr.Close();
            }
        }

        protected void getGamertagAndPuidFromPuid(long inppd)
        {
            puidexistsinmachines = false;
            machinesgamertag = string.Empty;
            machinespuid = -1;
            WstCommand puidcmd = wstcon.CreateCommand();
            puidbucket = WstHash.GetHash(inppd, partcount);
            puidcmd.Partition = puidbucket;
            puidcmd.WstFailoverMode = WstFailoverMode.PrimaryThenSecondary;
            WstDataReader rdr = getResultsFromMachines(puidcmd, inppd);
            if (rdr != null)
            {
                puidpartition = puidcmd.LastPartitionExecuted;
                WebstoreDatabase db = puidcmd.Database;
                puidserver = db.ServerName;
                puiddatabase = db.Name;
                if (rdr.HasRows)
                {
                    puidexistsinmachines = true;
                    machinesgamertag = WstLib.getStringFromReader(rdr);
                    machinespuid = inppd;
                }
                else
                {
                    // look for the thing in t_users
                    rdr.Close();
                    puidcmd.Parameters.Clear();
                    puidexistsinusers = userExists(puidcmd, namespuid);
                }
                if (!rdr.IsClosed)
                    rdr.Close();
            }
        }

        protected WstDataReader getResultsFromMachines(WstCommand wstcmd, long inppd)
        {
            string cmd;
            cmd = "SELECT vc_serial_num, dt_reset_date";
            cmd += " FROM dbo.t_machines WITH (NOLOCK)";
            cmd += " WHERE bi_machine_puid = " + inppd.ToString();
            WstDataReader puidrdr = WstLib.getReaderFromWst(wstcmd, cmd);
            return puidrdr;
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\XAppAdmin\LiveObjectClass.cs ===
using System;
using System.Collections.Generic;
using System.Text;
using System.Data;
using System.Data.SqlClient;
using Microsoft.Webstore.WstClient;

namespace XappAdmin
{
    public class LiveObject
    {
        protected int partcount;          // number of partitions in the Webstore deployment
        protected string enteredgamertag = string.Empty;  // gamertag as entered from outside object
        protected long enteredpuid = -1;                  // PUID as entered from outside object
        protected int namesbucket;         // gamertag logical partition
        protected string namesgamertag;
        protected long namespuid = -1;    // puid as stored in t_user_names
        protected int namespartition = -1;     // gamertag physical partition
        protected string namesserver;          // server on which the gamertag exists in t_user_names
        protected string namesdatabase;        // db on which the gamertag exists in t_user_names
        protected int puidbucket;         // puid logical partition
        protected int puidpartition = -1;     // puid physical partition
        protected string puidserver;          // server on which the puid exists in t_users
        protected string puiddatabase;        // db on which the puid exists in t_users
        protected string puidinhex = string.Empty;
        protected bool puidexistsinusers;
        protected bool puidexistsinmachines;
        protected WstConnection wstcon;
        protected WstConnection npdbcon;

        public string EnteredGamertag
        {
            get
            {
                return enteredgamertag;
            }
        }

        public long EnteredPUID
        {
            get
            {
                return enteredpuid;
            }
        }

        public int NamesBucket
        {
            get
            {
                return namesbucket;
            }
        }

        public int NamesPartition
        {
            get
            {
                return namespartition;
            }
        }

        public string NamesServer
        {
            get
            {
                return namesserver;
            }
        }

        public string NamesDatabase
        {
            get
            {
                return namesdatabase;
            }
        }

        public long NamesPUID
        {
            get
            {
                return namespuid;
            }
        }
        
        public int PUIDBucket
        {
            get
            {
                return puidbucket;
            }
        }

        public bool PUIDExistsInMachines
        {
            get
            {
                return puidexistsinmachines;
            }
        }

        public string PUIDInHex
        {
            get
            {
                return puidinhex;
            }
        }
        public int PUIDPartition
        {
            get
            {
                return puidpartition;
            }
        }

        public string PUIDServer
        {
            get
            {
                return puidserver;
            }
        }

        public string PUIDDatabase
        {
            get
            {
                return puiddatabase;
            }
        }

        public string getMachineSerialFromPuid(Int64 machinepuid)
        {
            string serialnum = string.Empty;
            WstConnection con = ParsedArgs.connectToWST("UODB");
            WstCommand mccmd = con.CreateCommand();
            int machinebucket = WstHash.GetHash(machinepuid, partcount);
            mccmd.Partition = machinebucket;
            mccmd.PartitionType = WstPartitionType.Logical;
            mccmd.WstFailoverMode = WstFailoverMode.PrimaryThenSecondary;
            mccmd.CommandText = "p_xbos_get_console_id_for_machine_id";
            mccmd.CommandType = CommandType.StoredProcedure;
            SqlParameter retprm = mccmd.Parameters.Add("@RETURN_VALUE", SqlDbType.Int);
            retprm.Direction = ParameterDirection.ReturnValue;
            SqlParameter puidprm = mccmd.Parameters.Add("@bi_machine_id", SqlDbType.BigInt);
            puidprm.Value = machinepuid;
            SqlParameter nameprm = mccmd.Parameters.Add("@vc_console_id", SqlDbType.NVarChar);
            nameprm.Direction = ParameterDirection.Output;
            nameprm.Size = 15;
            WstDataReader rdr = WstLib.getReaderFromWst(mccmd);
            if (rdr != null)
            {
                serialnum = nameprm.Value.ToString();
                if (serialnum.Length > 2)
                {
                    if (serialnum.Substring(0, 3) != "XE." && serialnum.Substring(0, 3) != "PC.")
                        // prefix XE. is Xbox 360; prefix PC. is - well - PC.  No prefix is Xbox 1 ("SN." in t_user_names)
                        serialnum = string.Format("SN.{0}", serialnum);
                }
            }
            rdr.Close();
            mccmd.Dispose();
            return serialnum;
        }

        protected WstDataReader getResultsFromUsernames(WstCommand wstcmd, string inpgt)
        {
            string cmd;
            cmd = "SELECT vc_gamertag, bi_user_puid";
            cmd += " FROM dbo.t_user_names WITH (NOLOCK)";
            cmd += " WHERE vc_gamertag = '" + inpgt + "'";
            WstDataReader puidrdr = WstLib.getReaderFromWst(wstcmd, cmd);
            return puidrdr;
        }

        // Inputs : wstcmd     : WstCommand object with logical partition property already set.
        //          machinePUID: bi_machine_puid value to test existence on
        // Returns: boolean indicating whether the machine was found via the wstcmd object.
        protected static bool machineExists(WstCommand wstcmd, long machinePUID)
        {
            bool retval = false;
            wstcmd.CommandType = CommandType.StoredProcedure;
            wstcmd.CommandText = "p_xmacs_get_machine_account";
            wstcmd.CommandTimeout = 60;
            SqlParameter retprm = wstcmd.Parameters.Add("@RETURN_VALUE", SqlDbType.Int);
            retprm.Direction = ParameterDirection.ReturnValue;
            SqlParameter macprm = wstcmd.Parameters.Add("@bi_machine_puid", SqlDbType.BigInt);
            macprm.Value = machinePUID;
            WstDataReader rdr = WstLib.getReaderFromWst(wstcmd);
            if (rdr != null)
            {
                if (!rdr.IsClosed)
                {
                    if (rdr.HasRows)
                    {
                        retval = true;
                    }
                    rdr.Close();
                }
            }
            return retval;
        }

        // Inputs : wstcmd     : WstCommand object with logical partition property already set.
        //          userPUID: bi_machine_puid value to test existence on
        // Returns: boolean indicating whether the machine was found via the wstcmd object.
        protected static bool userExists(WstCommand wstcmd, long userPUID)
        {
            bool retval = false;
            wstcmd.CommandType = CommandType.StoredProcedure;
            wstcmd.CommandText = "p_pres_get_user_name";
            wstcmd.CommandTimeout = 60;
            SqlParameter retprm = wstcmd.Parameters.Add("@RETURN_VALUE", SqlDbType.Int);
            retprm.Direction = ParameterDirection.ReturnValue;
            SqlParameter macprm = wstcmd.Parameters.Add("@bi_user_puid", SqlDbType.BigInt);
            macprm.Value = userPUID;
            WstDataReader rdr = WstLib.getReaderFromWst(wstcmd);
            if (rdr != null)
            {
                if (!rdr.IsClosed)
                {
                    if (rdr.HasRows)
                    {
                        retval = true;
                    }
                    rdr.Close();
                }
            }
            return retval;
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\XAppAdmin\exe\obj\i386\_generated.cs ===
[assembly:System.Runtime.InteropServices.ComVisible(false)]
[assembly:System.Reflection.AssemblyVersion("12.4.56.0")]
[assembly:System.Reflection.AssemblyProduct("DEPOT")]
[assembly:System.Reflection.AssemblyCopyright("")]
[assembly:System.Reflection.AssemblyCompany("")]
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\XAppAdmin\LiveUserClass.cs ===
using System;
using System.Collections;
using System.Collections.Generic;
using System.Data;
using System.Data.SqlClient;
using System.Xml;

using Microsoft.Webstore.WstClient;
using Microsoft.Webstore.MetaData;

using xonline.common.billing;
using xonline.common.config;
using xonline.common.service;
using xonline.common.sql;
using xonline.common.sql.webstore;
using xonline.common.sql.sqlclient;
using xonline.common.user;

/// <summary>
/// Stores information about Live Users, such as gamertag, PUID, # of friends, etc.
/// Requires Open WstConnection to be passed
/// </summary
namespace XappAdmin
{
    public class LiveUser : LiveObject
    {
        string usersgamertag = string.Empty;    // gamertag as stored in t_users
        string changefromgamertag = string.Empty;  // gamertag as it existed prior to the most recent change
        string changetogamertag = string.Empty;    // destination gamertag of the most recent change
        ArrayList consoles = new ArrayList();
        ArrayList licenses = new ArrayList();
        string consolestr = string.Empty;
        string licensestr = string.Empty;
        DateTime changedate = DateTime.MinValue;
        bool changechecked = false;
        bool changewaspurchased = false;
        bool waschanged = false;
        protected long enteredwlid = -1;    // wlid as entered via a set of the WLID property
        protected long passportpuid = -1;   // puid as stored in t_user_passport_puids
        protected int wlidbucket;           // wlid logical partition
        protected int wlidpartition = -1;   // gamertag physical partition
        protected int presencebucket = -1;  // hash bucket to map PUID to presence server
        protected string presenceserver = string.Empty;  // presence server on which this user's presence data reside
        protected bool wlidexistsinusers = false;
        long userspuid = -1;    // puid as stored in t_users
        long userswlid = -1;    // wlid as stored in t_users
        int friendslength = -1; // length of friends as recorded in t_users
        int numoffriends = -1;  // number of friends listed in t_xprof_friends_lists
        int lockoutlistlength = -1;
        int numoflockouts = -1;
        bool gtexistsinuser_keys; // true if and only if GT exists in t_user_keys AND t_xenon_user_keys

        // CONSTRUCTOR
        public LiveUser(WstConnection wstc)
        {
            wstcon = wstc;
            partcount = WebstoreMetaData.Instance.DefaultConfig.Deployments[WstLib.deploymentGuid("UODB")].Partitions.Count;
        }

        public LiveUser(WstConnection wstc, string inpgt)
        {
            wstcon = wstc;
            partcount = WebstoreMetaData.Instance.DefaultConfig.Deployments[WstLib.deploymentGuid("UODB")].Partitions.Count;
            Gamertag = inpgt;   // this populates the PUID automatically
        }
        public LiveUser(WstConnection wstc, long inppuid)
        {
            wstcon = wstc;
            partcount = WebstoreMetaData.Instance.DefaultConfig.Deployments[WstLib.deploymentGuid("UODB")].Partitions.Count;
            PUID = inppuid;
        }
        public LiveUser(WstConnection wstc, long inppuid, bool isWLID)
        {
            wstcon = wstc;
            partcount = WebstoreMetaData.Instance.DefaultConfig.Deployments[WstLib.deploymentGuid("UODB")].Partitions.Count;
            if (isWLID)
            {
                WLID = inppuid;
            }
            else
            {
                PUID = inppuid;
            }
        }


        // PROPERTIES
        public string ChangeFromGamertag
        {
            // the gamertag FROM which the current PUID was changed most recently in t_user_gamertag_history
            get
            {
                if (!changechecked)
                {
                    getGamertagChange();
                }
                return changefromgamertag;
            }
        }

        public string ChangeToGamertag
        {
            // the gamertag TO which the current PUID was changed most recently in t_user_gamertag_history
            get
            {
                if (!changechecked)
                {
                    getGamertagChange();
                }
                return changetogamertag;
            }
        }

        public DateTime ChangeDate
        {
            // the date of the most recent gamertag change, if any
            get
            {
                if (!changechecked)
                {
                    getGamertagChange();
                }
                return changedate;
            }
        }

        public bool ChangeWasPurchased
        {
            // whether or not the most recent gamertag change was purchased
            get
            {
                return changewaspurchased;
            }
        }

        public ArrayList Consoles
        {
            get
            {
                if (consoles.Count == 0)
                {
                    getConsoles();
                }
                return consoles;
            }
        }

        public string ConsoleString
        {
            get
            {
                if (consolestr == string.Empty)
                {
                    getConsoles();
                }
                return consolestr;
            }
        }

        public long EnteredWLID
        {
            get
            {
                return enteredwlid;
            }
        }

        public int FriendsLength
        {
            get
            {
                if (friendslength == -1)
                {
                    if (userspuid == -1)
                    {
                        // if we don't have PUID location and confirmation, get all user data, including location and PUID
                        getGamertagAndPuidFromGamertag(enteredgamertag);
                    }
                    else
                    {
                        // if we already have PUID location, get the t_users data using the already available location and PUID
                        getUsersDataFromPuid(userspuid);
                    }
                }
                return friendslength;
            }
        }

        public string Gamertag
        {
            // NOTE: Gamertag is from t_user_names.
            // The corresponding value from t_users is UsersGamertag.
            get
            {
                if (namesgamertag == string.Empty)
                {
                    getGamertagFromPUID();
                }
                return namesgamertag;
            }
            set
            {
                enteredgamertag = value.ToString().TrimEnd();
                // get user PUID and location in t_users
                getGamertagAndPuidFromGamertag(enteredgamertag);
                if (NamesPUID != -1)
                {
                    getUsersDataFromPuid(namespuid);
                    getGamertagFromPUID();
                }
            }
        }

        public ArrayList Licenses
        {
            get
            {
                if (licenses.Count == 0)
                {
                    getLicenses();
                }
                return licenses;
            }
        }

        public string LicenseString
        {
            get
            {
                if (licensestr == string.Empty)
                {
                    getLicenses();
                }
                return licensestr;
            }
        }

        public bool GTExistsInUser_Keys
        {
            get
            {
                gtexistsinuser_keys = findGamertagInUserkeys(namesgamertag);
                return gtexistsinuser_keys;
            }
        }

        public int LockoutListLength
        {
            get
            {
                return lockoutlistlength;
            }
        }

        public int NumOfFriends
        {
            get
            {
                if (numoffriends == -1)
                {
                    numoffriends = getNumFromFriendLists();
                }
                return numoffriends;
            }
        }

        public int NumOfLockouts
        {
            get
            {
                if (numoflockouts == -1)
                {
                    numoflockouts = getNumFromLockoutLists();
                }
                return numoflockouts;
            }
        }

        public long PUID
        {
            // NOTE: PUID is from t_users.
            // The corresponding value from t_user_names is NamesPUID, inherited from LiveObjectClass.
            get
            {
                if (!puidexistsinusers)
                    getUsersDataFromPuid(enteredpuid);
                return userspuid;
            }
            set
            {
                enteredpuid = value;
                getUsersDataFromPuid(enteredpuid);
                getGamertagFromPUID();
            }
        }

        public bool PUIDExistsInUsers
        {
            get
            {
                if (!puidexistsinusers)
                    getUsersDataFromPuid(enteredpuid);
                return puidexistsinusers;
            }
        }

        public string UsersGamertag
        {
            get
            {
                return usersgamertag;
            }
        }

        public long UsersWLID
        {
            get
            {
                return userswlid;
            }
        }

        public long WLID
        {
            // NOTE: WLID is from t_user_passport_puids
            // the corresponding value from t_users is UsersWLID
            get
            {
                if (userswlid == -1)
                {
                    if (enteredwlid != -1)
                    {
                        getPuidFromWlid(enteredwlid);
                        getUsersDataFromPuid(passportpuid);
                        getGamertagFromPUID();
                    }
                }
                return userswlid;
            }
            set
            {
                // we need this!
                enteredwlid = value;
                getPuidFromWlid(enteredwlid);
                getUsersDataFromPuid(passportpuid);
                getGamertagFromPUID();
            }
        }

        public int WLIDPartition
        {
            get
            {
                return wlidpartition;
            }
        }

        // PUBLIC METHODS
        public bool deleteNameData()
        {
            bool success = false;
            if (namesgamertag == string.Empty)
            {
                Console.WriteLine("Gamertag not found in t_user_names.");
            }
            else
            {
                Console.WriteLine("Deleting gamertag rows.");
                WstCommand oldnamecmd = new WstCommand();
                oldnamecmd.Connection = wstcon;
                oldnamecmd.PartitionType = WstPartitionType.Logical;
                oldnamecmd.Partition = namesbucket;
                success = false;
                string cmd;
                cmd = "DELETE FROM dbo.t_user_keys WHERE vc_gamertag = '" + namesgamertag + "'";
                XappAdmin.executeNonQueryAtWst(oldnamecmd, cmd);
                cmd = "DELETE FROM dbo.t_xenon_user_keys WHERE vc_gamertag = '" + namesgamertag + "'";
                XappAdmin.executeNonQueryAtWst(oldnamecmd, cmd);
                // update t_user_names, so that Xcache doesn't know that a PUID delete took place
                cmd = "UPDATE dbo.t_user_names SET bi_user_puid = 0, dt_change_datetime=GETDATE() WHERE vc_gamertag = '" + namesgamertag + "'"; // new code
                if (XappAdmin.executeNonQueryAtWst(oldnamecmd, cmd))                                                                            // new code
                {
                    cmd = "DELETE FROM dbo.t_user_names WHERE vc_gamertag = '" + namesgamertag + "'";
                    success = XappAdmin.executeNonQueryAtWst(oldnamecmd, cmd);
                }
                oldnamecmd.Dispose();
            }
            return success;
        }

        public void getGamertagChange()
        {
            changechecked = true;
            // query to get the most recent time a gamertag change was successfully purchased
            WstCommand puidcmd = new WstCommand();
            puidcmd.Connection = wstcon;
            puidcmd.Partition = puidbucket;
            puidcmd.WstFailoverMode = WstFailoverMode.PrimaryThenSecondary;
            string cmd = "SELECT TOP 1 *";
            cmd += " FROM dbo.t_user_gamertag_history WITH (NOLOCK)";
            cmd += " WHERE bi_user_puid = " + userspuid.ToString();
            cmd += " AND vc_old_gamertag IS NOT NULL";
            cmd += " ORDER BY dt_gamertag_changed DESC";
            WstDataReader rdr = WstLib.getReaderFromWst(puidcmd, cmd);
            if (rdr != null)
            {
                if (rdr.HasRows)
                {
                    do
                    {
                        while (rdr.Read())
                        {
                            waschanged = true;
                            changefromgamertag = rdr.IsDBNull(1) ? "" : rdr.GetString(1);
                            changetogamertag = rdr.IsDBNull(2) ? "" : rdr.GetString(2);
                            changedate = rdr.GetDateTime(4);
                            if (Convert.ToString(rdr.GetByte(3)) == "1")
                            {
                                changewaspurchased = true;
                            }
                            else
                            {
                                changewaspurchased = false;
                            }
                        }
                    } while (rdr.NextResult());
                }
            }
            WstLib.disposeReader(rdr);
            puidcmd.Dispose();
        }

        public string gamertagChangePurchase()
        {
            string purchaseinfo = string.Empty;
            if (!changechecked)
            {
                getGamertagChange();
            }
            if (waschanged)
            {
                string msg;
                msg = "Gamertag '" + changefromgamertag + "' was changed to '";
                msg += changetogamertag + "' at " + Environment.NewLine;
                msg += changedate.ToString() + ". This gamertag change was";
                if (!changewaspurchased)
                {
                    msg += " NOT";
                }
                msg += " purchased.";
                purchaseinfo = msg;
            }
            else
            {
                purchaseinfo = "No record exists of this gamertag ever having been changed.";
            }
            return purchaseinfo;
        }

        public void Refresh()
        {
            // refresh all values from inputs to defaults
            changechecked = false;
            numoffriends = -1;
            numoflockouts = -1;
            friendslength = -1;
            lockoutlistlength = -1;
            // repopulate core values if possible
            getGamertagAndPuidFromGamertag(enteredgamertag);
            if (namespuid != -1)
            {
                getGamertagFromPUID();
            }
        }

        public void SynchGamertagInUsers()
        {
            XappAdmin.sendOut("Updating gamertag in t_users.");
            WstCommand wstcmd = new WstCommand();
            wstcmd.Connection = wstcon;
            wstcmd.Partition = puidbucket;
            wstcmd.CommandText = "p_pres_update_name_self";
            wstcmd.CommandType = CommandType.StoredProcedure;
            wstcmd.WstFailoverMode = WstFailoverMode.PrimaryOnly;
            SqlParameter retprm = wstcmd.Parameters.Add("@RETURN_VALUE", SqlDbType.Int);
            retprm.Direction = ParameterDirection.ReturnValue;
            SqlParameter puidprm = wstcmd.Parameters.Add("@bi_user_puid", SqlDbType.BigInt);
            puidprm.Value = userspuid;
            SqlParameter nameprm = wstcmd.Parameters.Add("@vc_gamertag", SqlDbType.VarChar);
            nameprm.Value = namesgamertag;
            XappAdmin.executeNonQueryAtWst(wstcmd);
            if (retprm.Value.ToString() == "0")
            {
                XappAdmin.sendOut("Stored procedure 'p_pres_update_name_self' executed successfully.{0}", Environment.NewLine);
            }
            else
            {
                XappAdmin.sendOut("Failed to execute stored procedure 'p_pres_update_name_self'.");
                XappAdmin.sendOut("@bi_user_puid: {0}  @vc_gamertag: {1}", userspuid.ToString(), namesgamertag);
                XappAdmin.sendOut("Run against partition {0}", wstcmd.LastPartitionExecuted.ToString());
                XappAdmin.sendOut("Stored procedure returned error " + retprm.Value.ToString());
            }
            wstcmd.Dispose();
        }

        public void SynchLengths()
        {
            if (FriendsLength != NumOfFriends)
            {
                XappAdmin.sendOut("{1}Updating t_users to show {0} friends.", NumOfFriends.ToString(), Environment.NewLine);
                updateFriendsLengthInUsers();
            }
            if (LockoutListLength != NumOfLockouts)
            {
                XappAdmin.sendOut("{1}Updating t_users to show {0} lockouts.", NumOfLockouts.ToString(), Environment.NewLine);
                updateLockoutLengthInUsers();
            }
        }

        // PROTECTED METHODS

        // returns boolean indicating whether the gamertag was found
        protected bool findGamertagInUserkeys(string gamertag)
        {
            bool found = false;
            WstCommand wstcmd = new WstCommand();
            wstcmd.WstFailoverMode = WstFailoverMode.PrimaryThenSecondary;
            wstcmd.Connection = wstcon;
            wstcmd.Partition = namesbucket;
            string cmd = "SELECT 1 FROM dbo.t_user_keys uk";
            cmd += " INNER JOIN dbo.t_xenon_user_keys xuk";
            cmd += " ON uk.vc_gamertag = xuk.vc_gamertag";
            cmd += " WHERE uk.vc_gamertag = '" + gamertag + "'";
            WstDataReader tagrdr = WstLib.getReaderFromWst(wstcmd, cmd);
            if (tagrdr != null)
            {
                if (!tagrdr.IsClosed)
                {
                    found = tagrdr.HasRows;
                }
            }
            WstLib.disposeReader(tagrdr);
            wstcmd.Dispose();
            return found;
        }

        private void getConsoles()
        {
            string cmd =
                "SELECT DISTINCT bi_machine_puid, MAX(dt_purchased) AS dt_licensed" +
                    " FROM dbo.t_user_offer_instance_purchases WITH (NOLOCK)" +
                    " WHERE bi_user_puid = @bi_user_puid AND bi_machine_puid <> 0" +
                    " GROUP BY bi_machine_puid ORDER BY 2 DESC";

            List<ulong> machineList = new List<ulong>();

            // find all consoles associated with user in t_user_offer_instance_purchases and t_user_video_licenses_console
            using (WSClient ws = new WSClient(ConfigUtil.GetUserCommerceWebstoreApp(), CmdType.WRITETHENREAD_COMMANDTYPE))
            {
                ws.PartitionType = WstPartitionType.Logical;
                ws.SetHashVal(userspuid);
                ws.CommandSql = cmd;

                ws.AddParameter("@bi_user_puid", userspuid);

                using (WstDataReader rdr = ws.Execute())
                {
                    while (rdr.Read())
                    {
                        ulong machinePuid = (ulong) rdr.GetInt64(0);

                        if (!machineList.Contains(machinePuid))
                        {
                            machineList.Add(machinePuid);
                        }
                    }
                }

                cmd = " SELECT bi_machine_puid " +
                        " FROM dbo.t_users WITH (NOLOCK)" +
                        " WHERE bi_user_puid = @bi_user_puid";

                // now find console associated with user in t_users
                using (WSClient ws2 = new WSClient(ConfigUtil.UodbWebstoreApp, CmdType.WRITETHENREAD_COMMANDTYPE))
                {
                    ws2.PartitionType = WstPartitionType.Logical;
                    ws2.SetHashVal(userspuid);
                    ws2.CommandSql = cmd;

                    ws2.AddParameter("@bi_user_puid", userspuid);

                    using (WstDataReader rdr = ws2.Execute())
                    {
                        while (rdr.Read())
                        {
                            ulong machinePuid = (ulong)rdr.GetInt64(0);

                            if (!machineList.Contains(machinePuid))
                            {
                                machineList.Add(machinePuid);
                            }
                        }
                    }
                }

                string machinePuidText = string.Empty;

                for (int i=0; i < machineList.Count; i++)
                {
                    string serialNumber = (machineList[i] == 0) ? "Not Available" : getMachineSerialFromPuid((long)machineList[i]);

                    machinePuidText += string.Format("{0}{1}", (i==0 ? "" : ","), serialNumber);
                }

                consolestr = machinePuidText;
            }
        }

        protected void getGamertagAndPuidFromGamertag(string gamertag)
        {
            namesgamertag = string.Empty;
            namespuid = -1;
            using (WSClient ws = new WSClient(ConfigUtil.UodbWebstoreApp, CmdType.WRITETHENREAD_COMMANDTYPE))
            {
                ws.SetHashVal(gamertag);
                using (WstDataReader rdr = getResultsFromUsernames(ws.Command, gamertag))
                {
                    namespartition = ws.Command.LastPartitionExecuted;
                    WebstoreDatabase db = ws.Command.Database;
                    namesserver = db.ServerName;
                    namesdatabase = db.Name;
                    if (rdr.HasRows)
                    {
                        namesgamertag = WstLib.getStringFromReader(rdr);
                        namespuid = WstLib.getLongFromReader(rdr, 1);
                        puidinhex = "0x" + NamesPUID.ToString("X");
                    }
                }
            }

            if (namesgamertag == string.Empty)
            {
                Console.WriteLine("Gamertag '{0}' not found.  Searching history.{1}", enteredgamertag, Environment.NewLine);
                searchForGamertag(enteredgamertag);
            }
        }

        protected void getGamertagFromPUID()
        {
            // get t_user_names info without searching for the gamertag if it doesn't exist.
            namesgamertag = string.Empty;
            string querygamertag = string.Empty;
            namespuid = -1;
            WstCommand gtcmd = wstcon.CreateCommand();
            if (enteredgamertag == string.Empty)
            {
                namesbucket = WstHash.GetHash(usersgamertag.ToLower(), partcount);
            }
            else
            {
                namesbucket = WstHash.GetHash(enteredgamertag.ToLower(), partcount);
            }
            gtcmd.Partition = namesbucket;
            gtcmd.WstFailoverMode = WstFailoverMode.PrimaryThenSecondary;
            if (enteredgamertag == string.Empty)
            {
                querygamertag = usersgamertag;
            }
            else
            {
                querygamertag = enteredgamertag;
            }
            WstDataReader usernamesrdr = getResultsFromUsernames(gtcmd, querygamertag);
            if (usernamesrdr != null)
            {
                namespartition = gtcmd.LastPartitionExecuted;
                WebstoreDatabase db = gtcmd.Database;
                namesserver = db.ServerName;
                namesdatabase = db.Name;
                if (usernamesrdr.HasRows)
                {
                    namesgamertag = WstLib.getStringFromReader(usernamesrdr);
                    namespuid = WstLib.getLongFromReader(usernamesrdr, 1);
                    puidinhex = "0x" + NamesPUID.ToString("X");
                }
            }
            WstLib.disposeReader(usernamesrdr);
            gtcmd.Dispose();
        }

        protected void getLicenses()
        {
            HResult hr = HResult.S_OK;

            string cmd =
                "SELECT bi_machine_puid, dt_purchased, uid_offer_id, uid_offer_instance_id, i_offer_media_type_id, i_store_id " +
                "FROM dbo.t_user_offer_instance_purchases WITH (NOLOCK) " +
                "WHERE bi_user_puid = @bi_user_puid " +
                "ORDER BY dt_purchased";

            List<PurchaseInfo> purchaseHistory = new List<PurchaseInfo>();

            using (WSClient ws = new WSClient(ConfigUtil.GetUserCommerceWebstoreApp(), CmdType.WRITETHENREAD_COMMANDTYPE))
            {
                ws.PartitionType = WstPartitionType.Logical;
                ws.SetHashVal(userspuid);
                ws.CommandSql = cmd;

                ws.AddParameter("@bi_user_puid", userspuid);

                using (WstDataReader rdr = ws.Execute())
                {
                    while (rdr.Read())
                    {
                        PurchaseInfo pi = new PurchaseInfo();
                        pi.machinePuid = (ulong) rdr.GetInt64(0);
                        pi.datePurchased = rdr.GetDateTime(1);
                        pi.offerId = rdr.GetGuid(2);
                        pi.offerInstanceId = rdr.GetGuid(3);
                        pi.mediaTypeId = rdr.GetInt32(4);
                        pi.storeId = rdr.GetInt32(5);

                        purchaseHistory.Add(pi);
                    }
                }
            }

            User u = new User();
            u.Load((ulong)userspuid);

            string locale = Culture.CultureToCode(u.CultureId);

            // find offer names from the catalog
            GetOfferTitleInfo(locale, purchaseHistory);

            List<string> licenseList = new List<string>();
            foreach (PurchaseInfo pi in purchaseHistory)
            {
                if ( pi == null ) continue;

                string serialNumber = (pi.machinePuid == 0) ? "Not Available" : getMachineSerialFromPuid((long)pi.machinePuid);

                string listItem = string.Format("{0}\t{1}\t{2}\t{3}", usersgamertag, serialNumber, pi.datePurchased.ToString(), pi.offerId.ToString());

                if ( !string.IsNullOrEmpty(pi.offerTitle) )
                {
                    listItem += "\t(" + pi.offerTitle + ")";
                }

                licenseList.Add(listItem);
            }

            foreach (string license in licenseList)
            {
                if (string.IsNullOrEmpty(license))
                    continue;

                licensestr += Environment.NewLine + license;
            }
        }

        protected  int getNumFromFriendLists()
        {
            int fl = -1;
            string cmd = "SELECT COUNT(*) FROM dbo.t_xprof_friend_lists WITH (NOLOCK) WHERE bi_user_puid = " + userspuid;
            WstCommand flcmd = wstcon.CreateCommand();
            flcmd.CommandTimeout = 60;
            flcmd.Partition = puidbucket;
            flcmd.WstFailoverMode = WstFailoverMode.PrimaryThenSecondary;
            WstDataReader flrdr = WstLib.getReaderFromWst(flcmd, cmd, "00:00:00.005"); // built-in delay of 5 ms
            if (flrdr != null)
            {
                fl = WstLib.getIntFromReader(flrdr);
            }
            WstLib.disposeReader(flrdr);
            flcmd.Dispose();
            return fl;
        }

        protected int getNumFromLockoutLists()
        {
            int ll = -1;
            string cmd = "SELECT COUNT(*) FROM dbo.t_xprof_lockout_lists WITH (NOLOCK) WHERE bi_user_puid = " + userspuid;
            WstCommand llcmd = wstcon.CreateCommand();
            llcmd.CommandTimeout = 60;
            llcmd.Partition = puidbucket;
            llcmd.WstFailoverMode = WstFailoverMode.PrimaryThenSecondary;
            WstDataReader llrdr = WstLib.getReaderFromWst(llcmd, cmd, "00:00:00.005"); // built-in delay of 5 ms
            if (llrdr != null)
            {
                ll = WstLib.getIntFromReader(llrdr);
            }
            WstLib.disposeReader(llrdr);
            llcmd.Dispose();
            return ll;
        }

        protected void getPuidFromWlid(long wlid)
        {
            WstCommand wlcmd = wstcon.CreateCommand();
            wlcmd.PartitionType = WstPartitionType.Logical;
            wlidbucket = WstHash.GetHash(wlid, partcount);
            wlcmd.Partition = wlidbucket;
            wlcmd.WstFailoverMode = WstFailoverMode.PrimaryThenSecondary;
            string cmd = "SELECT bi_user_puid FROM dbo.t_user_passport_puids WITH (NOLOCK) WHERE bi_user_passport_puid = " + wlid.ToString();
            WstDataReader wlidrdr = WstLib.getReaderFromWst(wlcmd, cmd);
            passportpuid = WstLib.getLongFromReader(wlidrdr, 0);
            WstLib.disposeReader(wlidrdr);
        }

        protected WstDataReader getResultsFromUsers(WstCommand wstcmd, long inppd)
        {
            string cmd;
            cmd = "SELECT vc_gamertag, bi_user_puid, i_friend_list_len, i_lockout_list_len, bi_user_passport_puid";
            cmd += " FROM dbo.t_users WITH (NOLOCK)";
            cmd += " WHERE bi_user_puid = " + inppd.ToString();
            WstDataReader puidrdr = WstLib.getReaderFromWst(wstcmd, cmd);
            return puidrdr;
        }

        protected void getUsersDataFromPuid(long inppd)
        {
            puidexistsinusers = false;
            usersgamertag = string.Empty;
            userspuid = -1;
            WstCommand puidcmd = wstcon.CreateCommand();
            puidbucket = WstHash.GetHash(inppd, partcount);
            puidcmd.Partition = puidbucket;
            puidcmd.WstFailoverMode = WstFailoverMode.PrimaryThenSecondary;
            WstDataReader rdr = getResultsFromUsers(puidcmd, inppd);
            if (rdr != null)
            {
                puidpartition = puidcmd.LastPartitionExecuted;
                WebstoreDatabase db = puidcmd.Database;
                puidserver = db.ServerName;
                puiddatabase = db.Name;
                if (rdr.HasRows)
                {
                    puidexistsinusers = true;
                    usersgamertag = WstLib.getStringFromReader(rdr);
                    userspuid = WstLib.getLongFromReader(rdr, 1);
                    friendslength = WstLib.getIntFromReader(rdr, 2);
                    lockoutlistlength = WstLib.getIntFromReader(rdr, 3);
                    userswlid = WstLib.getLongFromReader(rdr, 4);
                }
                else
                {
                    // look for the thing in t_machines
                    WstLib.disposeReader(rdr);
                    puidcmd.Parameters.Clear();
                    puidexistsinmachines = machineExists(puidcmd, namespuid);
                }
            }
            WstLib.disposeReader(rdr);
            puidcmd.Dispose();
        }

        private bool searchForGamertag(string gttofind)
        {
            // if gamertag isn't available at its hash location in t_user_names,
            // this function can look for it in t_user_gamertag_history
            bool success = false;
            Int64 userpuid = -1;
            int countfound = 0;
            WstCommand cmd = new WstCommand();
            cmd.Connection = ParsedArgs.connectToWST("UODB");
            cmd.PartitionType = WstPartitionType.Physical;
            string cmdtext = "SELECT DISTINCT bi_user_puid";
            cmdtext += " FROM dbo.t_user_gamertag_history WITH (NOLOCK)";
            cmdtext += " WHERE vc_old_gamertag = '" + gttofind + "'";
            cmd.CommandText = cmdtext;

            foreach (int physicalParititon in WSClient.GetPhysicalPartitions(ConfigUtil.UodbWebstoreApp))
            {
                cmd.Partition = physicalParititon;
                WstDataReader rdr = WstLib.getReaderFromWst(cmd);
                if (rdr != null)
                {
                    if (rdr.HasRows)
                    {
                        do
                        {
                            while (rdr.Read())
                            {
                                Console.WriteLine("Found on FSS {0}.", physicalParititon.ToString());
                                userpuid = WstLib.getLongFromReader(rdr);
                                Console.WriteLine("Corresponding PUID is {0}", userpuid);
                                countfound++; // counts the number of PUIDs we have found
                                success = true;
                            }
                        } while (rdr.NextResult());
                    }
                }
                WstLib.disposeReader(rdr);
            }
            cmd.Dispose();
            // if we have more than one, returning a valid PUID would imply
            // that we know which one is the correct one.  we don't.  so we
            // test to ensure we found only one before setting this.PUID to it
            if (countfound > 0)
            {
                if (countfound == 1)        // if we found ONLY one
                {
                    this.PUID = userpuid;   // return a valid object for that one.
                }
                else
                {
                    Console.WriteLine("Too many PUIDs found in history.  Aborting search with no conclusive PUID.");
                }
            }
            return success;
        }

        private void updateFriendsLengthInUsers()
        {
            // update t_users to set the i_friend_list_len value to the actual number of rows in t_xprof_friend_lists
            numoffriends = getNumFromFriendLists();
            WstCommand wstcmd = new WstCommand();
            wstcmd.Connection = wstcon;
            wstcmd.Partition = puidbucket;
            wstcmd.WstFailoverMode = WstFailoverMode.PrimaryThenSecondary;
            string cmd = "UPDATE dbo.t_users SET i_friend_list_len = ";
            cmd += numoffriends.ToString();
            // the version should also be incremented, as a means of telling Xcache that the data have changed
            cmd += ", i_friend_list_ver = i_friend_list_ver + 1, dt_change_datetime = GETDATE()";
            cmd += " WHERE bi_user_puid = " + userspuid;
            XappAdmin.executeNonQueryAtWst(wstcmd, cmd);
        }

        private void updateLockoutLengthInUsers()
        {
            // update t_users to set the i_lockout_list_len value to the actual number of rows in t_xprof_lockout_lists
            numoflockouts = getNumFromLockoutLists();
            WstCommand wstcmd = new WstCommand();
            wstcmd.Connection = wstcon;
            wstcmd.Partition = puidbucket;
            wstcmd.WstFailoverMode = WstFailoverMode.PrimaryThenSecondary;
            string cmd = "UPDATE dbo.t_users SET i_lockout_list_len = ";
            cmd += numoflockouts.ToString();
            // the version should also be incremented, as a means of telling Xcache that the data have changed
            cmd += ", i_lockout_list_ver = i_lockout_list_ver + 1, dt_change_datetime = GETDATE()";
            cmd += " WHERE bi_user_puid = " + userspuid;
            XappAdmin.executeNonQueryAtWst(wstcmd, cmd);
            wstcmd.Dispose();
        }

        protected static void GetOfferTitleInfo(string locale, List<PurchaseInfo> purchaseHistory)
        {
            HResult hr = HResult.S_OK;

            string otherIdsXml = "";
            int numXboxItems = 0;
            foreach (PurchaseInfo pi in purchaseHistory)
            {
                if ( pi.storeId == 1 )
                {
                    otherIdsXml +=
                        string.Format("<a offerId=\"{0}\" sortIndex=\"{1}\" offerInstanceId=\"{2}\" purchasedDate=\"{3}\" ppvLicensedOnMachine=\"{4}\" ppvLicenseAcknowledged=\"{5}\" />",
                            pi.offerId.ToString(),
                            ++numXboxItems,
                            pi.offerInstanceId.ToString(),
                            pi.datePurchased.ToString(),
                            1,  //TODO: fix this
                            1); //TODO: fix this
                }
            }

            using (SqlClient c = new SqlClient(Interface.fecatalogdbxbox, true))
            {
                c.StoredProc = "dbo.OfferPurchaseHistory";
                c.AddParameter(ParameterDirection.ReturnValue, "@hr", hr);
                c.AddParameter("@locale", locale);
                c.AddParameter("@legalLocale", locale);
                c.AddParameter("@store", 1); // Xbox store
                c.AddParameter("@pageSize", purchaseHistory.Count);
                c.AddParameter("@detailView", 1);
                c.AddParameter("@offerIds", string.Empty);
                c.AddParameter("@mediaTypeIds", string.Empty);
                c.AddParameter("@orderBy", 0);
                c.AddParameter("@orderDirection", 1);
                c.AddParameter("@otherIds", otherIdsXml);
                c.AddParameter("@totalItems", numXboxItems);
                c.AddParameter("@numItems", numXboxItems);
                c.AddParameter("@methodName", "PurchaseHistory");
                c.AddParameter("@editorialPrivilege", 1);

                string feedXml = null;
                using (SqlDataReader rdr = c.Execute())
                {
                    while ( rdr.Read() )
                    {
                        feedXml = rdr.GetString(0);
                    }
                }

                hr = (uint) c.GetIntParameter("@hr");
                if ( HResult.Succeeded(hr) && !string.IsNullOrEmpty(feedXml) )
                {
                    // merge feed with PurchaseInfo

                    XmlDocument xml = new XmlDocument();
                    xml.LoadXml(feedXml);

                    XmlNamespaceManager nsm = new XmlNamespaceManager(xml.NameTable);
                    nsm.AddNamespace("def", "http://www.w3.org/2005/Atom");
                    nsm.AddNamespace("live", "http://www.live.com/marketplace");

                    foreach (PurchaseInfo pi in purchaseHistory)
                    {
                        string xpathExpr = string.Format("/def:feed/def:entry/def:id[text()=\"urn:uuid:{0}\"]/../def:title", pi.offerId.ToString().ToUpper());

                        XmlNode node = xml.SelectSingleNode(xpathExpr, nsm);
                        if ( node != null && !string.IsNullOrEmpty(node.InnerText) )
                        {
                            pi.offerTitle = node.InnerText.Trim();
                        }
                    }
                }
            }
        }


        public class PurchaseInfo
        {
            public ulong machinePuid;
            public DateTime datePurchased;
            public Guid offerId;
            public Guid offerInstanceId;
            public int mediaTypeId;
            public int storeId;
            public string offerTitle;
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\XAppAdmin\exe\objd\i386\_generated.cs ===
[assembly:System.Runtime.InteropServices.ComVisible(false)]
[assembly:System.Reflection.AssemblyVersion("12.4.56.0")]
[assembly:System.Reflection.AssemblyProduct("DEPOT")]
[assembly:System.Reflection.AssemblyCopyright("")]
[assembly:System.Reflection.AssemblyCompany("")]
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\XAppAdmin\ParsedArgsClass.cs ===
using System;
using System.Data;
using System.Data.SqlClient;
using System.IO;
using System.Collections;
using Microsoft.Webstore.WstClient;
using Microsoft.Webstore.MetaData;

namespace XappAdmin
{
	/// <summary>
	/// stores arguments passed to the program from the command prompt
	/// </summary>
	public class ParsedArgs
	{
        WstConnection conn;
        WstConnection npdb;
        string action;
        Guid depguid = Guid.Empty;
        int partcount = -1;
		string additional = string.Empty;
        ArrayList columns = new ArrayList();
        ArrayList gamertags = new ArrayList();
        ArrayList PUIDs = new ArrayList();
        ArrayList WLIDs = new ArrayList();
        string gamertag = string.Empty;
        int inpindex = 0;
        string deployment = String.Empty;
        string server = string.Empty;
		string role = string.Empty;
		string filename = string.Empty;
        string logname = string.Empty;
		string query = string.Empty;
        string selecttable = string.Empty;
        string modifier = string.Empty;
        string update = string.Empty;
        bool outputversion = false;
		int timeout;
		long puidvalue = -1;    // individual instance of an entered PUID
        long wlidvalue = -1;    // individual instance of an entered WLID
        bool quiet = false;
        bool wstConnEntered = false;
        bool debug = false;  // marked true if this is a debug build.
        bool firstrow = true;
        string pretable = string.Empty;   // for SELECT, determines the set of columns to select
        bool fromdone = false;  // for SELECT, marks when the set of columns to be selected is finished
        bool wheredone = false; // for SELECT and UPDATE, marks where the predicate begins
        StreamReader sr = null;
        StreamWriter sw = null;
        int numofusers = 0;
        public string Modifier
        {
            get
            {
                return modifier;
            }
        }
        public Guid DepGUID
        {
            get
            {
                return depguid;
            }
        }
        public int LogicalPartitions
        {
            get
            {
                return partcount;
            }
        }
		public WstConnection WstConnect
		{
			get
			{
				return conn;
			}
		}
        public WstConnection NPDBConnect
        {
            get
            {
                return npdb;
            }
        }
		public bool Debug
		{
			get
			{
				return debug;
			}

		}
        public bool FirstRow
        {
            get
            {
                return firstrow;
            }
            set
            {
                firstrow = value;
            }
        }
		public int Timeout
		{
			set
			{
				try
				{
					timeout = value;
				}
				catch(InvalidCastException e)
				{
					Console.WriteLine("Invalid data type for timeout: {0}.  Using default of 30.  (Error {1})", value, e);
					timeout = 30;
				}

			}
			get
			{
				return timeout;
			}
		}
		public string Action
		{
			get
			{
				return action;
			}
		}
		public string Additional
		{
			get
			{
				return additional;
			}
		}
        public ArrayList Columns
        {
            get
            {
                return columns;
            }
        }
		public string File
		{
			get
			{
				return filename;
			}
		}
        public string Gamertag
        {
            get
            {
                return gamertag;
            }
        }
		public WstConnection NPDB
		{
			get
			{
				return npdb;
			}
		}
        public bool OutputVersion
        {
            get
            {
                return outputversion;
            }
        }
        public long PUID
        {
            get
            {
                return puidvalue;
            }
        }
        public bool Quiet
        {
            get
            {
                return quiet;
            }
        }
		public string Role
		{
			get
			{
				return role;
			}
		}
        public string PreTable
        {
            get
            {
                return pretable;
            }
        }
        public string SelectTable
        {
            get
            {
                return selecttable;
            }
        }
        public string Update
        {
            get
            {
                return update;
            }
        }
        public long WLID
        {
            get
            {
                return wlidvalue;
            }
        }
        public System.IO.StreamReader TextStream
		{
			get
			{
				return sr;
			}
		}
        public System.IO.StreamWriter LogStream
        {
            get
            {
                return sw;
            }
        }
        public string WstQuery
		{
			get
			{
				return query;
			}
		}
        public ParsedArgs(string[] args)
        {
            action = "None";
            timeout = 30;
            query = "";
            string inp;
            int i = 0;
            string o;
            string[] o_split;
            for (i = 0; i < args.Length; i++)
            {
                o = args[i].ToUpper();
                o_split = o.Split('.');
                if (o_split.Length >= 2)
                    o = o_split[1];
                switch (o)
                {
                    case ("/A"):
                        if (!PromptForValue(args, i))
                        {
                            inp = args[i + 1].ToString();
                            if (inp.Length > 3 && (inp.Substring(inp.Length - 4).ToLower() == ".txt" || inp.Substring(inp.Length - 4).ToLower() == ".sql"))
                            {
                                inp = "/A " + getStringFromFile(inp, " ");
                                args = inp.Split(' ');
                                i = -2;
                            }
                            else
                            {
                                arg = args[i + 1];
                                int colon = arg.IndexOf(':');
                                if (colon > -1)
                                {
                                    modifier = arg.Substring(colon + 1);
                                }
                                arg = arg.ToUpper();
                                if (arg.Length > 3)
                                {
                                    action = arg.Substring(0, 4);
                                }
                                else
                                {
                                    Console.WriteLine("Action must exceed three characters in length.");
                                }
                            }
                        }
                        i++;
                        break;
                    case ("/C"):
                        if (!PromptForValue(args, i))
                        {
                            inp = args[i + 1].ToString();
                            string[] Cs = inp.Split(new Char[] { ',' });
                            foreach (string C in Cs)
                            {
                                columns.Add(C);
                            }
                        }
                        i++;
                        break;
                    case ("/D"):
                        if (!PromptForValue(args, i))
                        {
                            deployment = args[i + 1];
                            conn = connectToWST(deployment);
                            if (conn.SqlPartitions.Count > 0)
                            {
                                setWstValues(deployment);
                            }
                        }
                        i++;
                        break;
                    case ("/F"):
                        if (!PromptForValue(args, i))
                        {
                            filename = args[i + 1];
                            if (System.IO.File.Exists(filename))
                            {
                                sr = System.IO.File.OpenText(filename);
                            }
                            else
                            {
                                Console.WriteLine("No file {0} exists.", filename);
                            }
                        }
                        i++;
                        break;
                    case ("/G"):
                        if (!PromptForValue(args, i))
                        {
                            inp = args[i + 1].ToString();
                            if (inp.Length > 3 && inp.Substring(inp.Length - 4, 4).ToLower() == ".txt")
                            {
                                try
                                {
                                    sr = System.IO.File.OpenText(inp);
                                }
                                catch (SystemException e)
                                {
                                    Console.WriteLine("Error attempting to open file {0} for read:", inp);
                                    Console.WriteLine(e.Message);
                                }
                                if (sr != null)
                                {
                                    string line = string.Empty;
                                    while ((line = sr.ReadLine()) != null)
                                    {
                                        if ( XappAdmin.IsValidGamertag(line) )
                                        {
                                            gamertags.Add(line);
                                        }
                                        else
                                        {
                                            Console.Error.WriteLine("Invalid gamertag: '{0}', skipping...", line);
                                        }
                                    }
                                    sr.Close();
                                }
                            }
                            else
                            {
                                string[] gs = inp.Split(new Char[] { ',' });
                                foreach (string g in gs)
                                {
                                    if ( XappAdmin.IsValidGamertag(g) )
                                    {
                                        gamertags.Add(g);
                                    }
                                    else
                                    {
                                        Console.Error.WriteLine("Invalid gamertag: '{0}', skipping...", g);
                                    }
                                }
                            }
                        }
                        i++;
                        break;
                    case ("/L"):
                        if (!PromptForValue(args, i))
                        {
                            logname = args[i + 1];
                            string backupname = logname + ".bak";
                            if (System.IO.File.Exists(logname))
                            {
                                if (System.IO.File.Exists(backupname))
                                {
                                    System.IO.File.Delete(backupname);
                                }
                                System.IO.File.Move(logname, backupname);
                            }
                            try
                            {
                                sw = System.IO.File.CreateText(logname);
                            }
                            catch (SystemException e)
                            {
                                Console.WriteLine("Error attempting to create log file {0}", logname);
                                Console.WriteLine(e.Message);
                            }
                        }
                        i++;
                        break;
                    case ("/P"):
                        if (!PromptForValue(args, i))
                        {
                            inp = args[i + 1].ToString();
                            if (inp.Length > 3 && inp.Substring(inp.Length - 4, 4).ToLower() == ".txt")
                            {
                                try
                                {
                                    sr = System.IO.File.OpenText(inp);
                                }
                                catch (SystemException e)
                                {
                                    Console.WriteLine("Error attempting to open file {0} for read:", inp);
                                    Console.WriteLine(e.Message);
                                }
                                if (sr != null)
                                {
                                    string line = string.Empty;
                                    while ((line = sr.ReadLine()) != null)
                                    {
                                        string[] Ps = line.Split(new Char[] { ' ', '\t' });
                                        PUIDs.Add(Ps[0]);
                                    }
                                    sr.Close();
                                }
                            }
                            else
                            {
                                PUIDs.Add(getInt64FromString(inp));
                            }
                        }
                        i++;
                        break;
                    case ("/Q"):
                        quiet = true;
                        break;
                    case ("/R"):
                        if (!PromptForValue(args, i))
                        {
                            role = args[i + 1].Substring(0, 3).ToUpper();
                        }
                        i++;
                        break;
                    case ("/T"):
                        if (!PromptForValue(args, i))
                        {
                            try
                            {
                                timeout = Convert.ToInt32(args[i + 1]);
                            }
                            catch (SystemException e)
                            {
                                Console.WriteLine("Error parsing timeout value:\n{0}", e.Message);
                            }
                        }
                        i++;
                        break;
                    case ("/U"):
                        if (!PromptForValue(args, i))
                            update = args[i + 1];
                        i++;
                        break;
                    case ("/V"):
                        outputversion = true;
                        break;
                    case ("/W"):
                        if (!PromptForValue(args, i))
                        {
                            inp = args[i + 1].ToString();
                            if (inp.Length > 3 && inp.Substring(inp.Length - 4, 4).ToLower() == ".txt")
                            {
                                try
                                {
                                    sr = System.IO.File.OpenText(inp);
                                }
                                catch (SystemException e)
                                {
                                    Console.WriteLine("Error attempting to open file {0} for read:", inp);
                                    Console.WriteLine(e.Message);
                                }
                                if (sr != null)
                                {
                                    string line = string.Empty;
                                    while ((line = sr.ReadLine()) != null)
                                    {
                                        string[] Ps = line.Split(new Char[] { ' ', '\t' });
                                        WLIDs.Add(Ps[0]);
                                    }
                                    sr.Close();
                                }
                            }
                            else
                            {
                                WLIDs.Add(getInt64FromString(inp));
                            }
                        }
                        i++;
                        break;
                    case ("/?"):
                        action = "USAG";
                        break;
                    case ("AND"):
                        if (args.Length > i + 1)
                        {
                            inp = args[i + 1];
                            string[] inp_split = inp.Split('.');
                            if (inp_split.Length > 1)
                                inp = inp_split[1];
                            if (inp.Length > 10)
                            {
                                // breaks for things like bi_user_puid should go in here
                            }
                            if (wheredone)
                            {
                                addToAdditional("AND");
                            }
                        }
                        else
                        {
                            Console.WriteLine("AND included with no addition to the predicate.");
                            action = "None";
                        }
                        break;
                    case ("BI_MACHINE_PUID"):
                        if (fromdone)
                        {
                            if (args.Length > i + 1)
                            {
                                if (args[i + 1] == "=")
                                {
                                    PUIDs.Add(getInt64FromString(args[i + 2]));
                                    i = i + 2;
                                }
                                else
                                {
                                    Console.WriteLine("Unsupported operator \"{0}\" found after bi_machine_puid.", args[i + 1]);
                                    action = "None";
                                }
                            }
                            else
                            {
                                addToAdditional(args[i]);
                            }
                        }
                        else
                        {
                            addToAdditional(args[i]);
                        }
                        break;
                    case ("BI_USER_PASSPORT_PUID"):
                        if (fromdone)
                        {
                            if (args.Length > i + 1)
                            {
                                if (args[i + 1] == "=")
                                {
                                    WLIDs.Add(getInt64FromString(args[i + 2]));
                                    i = i + 2;
                                }
                                else
                                {
                                    Console.WriteLine("Unsupported operator \"{0}\" found after bi_user_passport_puid.", args[i + 1]);
                                    action = "None";
                                }
                            }
                            else
                            {
                                addToAdditional(args[i]);
                            }
                        }
                        else
                        {
                            addToAdditional(args[i]);
                        }
                        break;
                    case ("BI_USER_PUID"):
                        if (fromdone)
                        {
                            if (args.Length > i + 1)
                            {
                                if (args[i + 1] == "=")
                                {
                                    PUIDs.Add(getInt64FromString(args[i + 2]));
                                    i = i + 2;
                                }
                                else
                                {
                                    Console.WriteLine("Unsupported operator \"{0}\" found after bi_user_puid.", args[i + 1]);
                                    action = "None";
                                }
                            }
                            else
                            {
                                addToAdditional(args[i]);
                            }
                        }
                        else
                        {
                            addToAdditional(args[i]);
                        }
                        break;
                    case ("FROM"):
                        fromdone = true;
                        break;
                    case ("ORDER"):
                        if (i > 1 && args[i - 1] == "AND")
                        {
                            additional = additional.Substring(0, additional.Length - 3);
                        }
                        addToAdditional(args[i]);
                        break;
                    case ("SET"):
                        if (!PromptForValue(args, i))
                            update = args[i + 1];
                        i++;
                        fromdone = true;
                        break;
                    case ("VC_GAMERTAG") :
                        string tempgt = string.Empty; // used as temporary gamertag storage prior to adding to array of gamertags
                        if (fromdone)
                        {
                            if (args.Length > i + 1)
                            {
                                switch (args[i + 1].ToUpper())
                                {
                                    case "=":
                                        if (args.Length > i + 2)
                                        {
                                            i = i + 2;
                                            tempgt = getGamertagFromArray(args, ref i);
                                            gamertags.Add(tempgt);
                                        }
                                        break;
                                    case "IN":
                                        if (args.Length > i + 2)
                                        {
                                            if (args[i + 2].Length > 0)
                                                // verify the beginning open parenthesis
                                                if (args[i + 2].Substring(0, 1) != "(")
                                                {
                                                    XappAdmin.sendOut("Incorrect syntax: no '(' after IN term.");
                                                    action = "None";
                                                }
                                            // parse arguments to add gamertags until we see the close parenthesis
                                            i = i + 2;
                                            string[] INValues = getINValuesFromArray(args, ref i);
                                            for (int j = 0; j < INValues.Length; j++)
                                            {
                                                tempgt = getGamertagFromArray(INValues, ref j);
                                                gamertags.Add(tempgt);
                                            }
                                        }
                                        break;
                                    default:
                                        Console.WriteLine("Unsupported operator \"{0}\" found after vc_gamertag.", args[i + 1]);
                                        action = "None";
                                        break;
                                }
                            }
                            else
                            {
                                addToAdditional(args[i]);
                            }
                        }
                        else
                        {
                            addToAdditional(args[i]);
                        }
                        break;
                    case ("WHERE"):
                        wheredone = true;
                        if (args.Length <= i + 1)
                        {
                            Console.WriteLine("WHERE included with no predicate.");
                            action = "None";
                        }
                        break;
                    case ("WITH"):
                        break;  // skip this entirely - hints are not allowed
                    case ("(NOLOCK)"):
                        break;  // skip this entirely - nolock is implied
                    default:
                        arg = args[i];
                        int equals = arg.IndexOf('=');
                        if (equals > -1)
                        {
                            string[] equalsplit = arg.Split('=');
                            switch (equalsplit[0].ToLower())
                            {
                                case "vc_gamertag":
                                    gamertags.Add(equalsplit[1].Replace("'", ""));
                                    break;
                                case "bi_machine_puid":
                                    PUIDs.Add(getInt64FromString(equalsplit[1]));
                                    break;
                                case "bi_user_puid":
                                    PUIDs.Add(getInt64FromString(equalsplit[1]));
                                    break;
                                case "bi_user_passport_puid":
                                    WLIDs.Add(getInt64FromString(equalsplit[1]));
                                    break;
                                default:
                                    addToAdditional(args[i]);
                                    break;
                            }
                        }
                        else
                        {
                            addToAdditional(args[i]);
                        }
                        break;
                }
            }
            if (gamertags.Count > 0)
            {
                gamertag = gamertags[inpindex].ToString().Trim();
                numofusers = gamertags.Count;
            }
            if (PUIDs.Count > 0)
            {
                puidvalue = getInt64FromString(PUIDs[inpindex].ToString());
                numofusers = PUIDs.Count;
            }
            if (WLIDs.Count > 0)
            {
                wlidvalue = getInt64FromString(WLIDs[inpindex].ToString());
                numofusers = WLIDs.Count;
            }
            if (columns.Count == 0)
            {
                string[] Cs = { "1", "2", "3", "4", "5", "6", "7", "8", "9", "10", "11", "12", "13", "14", "15", "16", "17", "18", "19", "21", "22", "23" };
                foreach (string C in Cs)
                {
                    columns.Add(C);
                }
            }
            switch (action)
            {
                case ("DELE"):
                    if (numofusers == 0)
                    {
                        Console.WriteLine("Must include hashing value (/G or /P) for Delete action.");
                        action = "None";
                    }
                    if ((puidvalue > -1) & (gamertags.Count != 0))
                    {
                        Console.WriteLine("Both gamertag and PUID entered for hashing value.  Please review usage and try again.");
                        action = "None";
                    }
                    if (modifier == string.Empty)
                    {
                        Console.WriteLine("Must include table from which to delete as action modifier for Delete action.");
                        action = "None";
                    }
                    setWstValues("UODB");
                    break;
                case ("GTDE"):
                    setWstValues("UODB");
                    break;
                case ("FLAT"):
                    if (numofusers == 0)
                    {
                        Console.WriteLine("Gamertag value (/G) or PUID value (/P) must be entered for flat view action.");
                        action = "None";
                    }
                    setWstValues("UODB");
                    if (modifier == string.Empty)
                        modifier = "USER";
                    break;
                case ("HASH"):
                    if (numofusers == 0 && additional == string.Empty)
                    {
                        Console.WriteLine("Must include gamertag or PUID for Hash action.");
                        action = "None";
                    }
                    if (!wstConnEntered)
                    {
                        Console.WriteLine("Must include valid, available Webstore deployment (/D) for Hash action.");
                        action = "None";
                    }
                    break;
                case ("LENG"):
                    if (gamertags.Count == 0)
                    {
                        Console.WriteLine("Gamertag value (/G) must be entered for length synch action");
                        action = "None";
                    }
                    setWstValues("UODB");
                    break;
                case ("RUNS"):
                    if (modifier == string.Empty)
                    {
                        Console.WriteLine("Must include stored procedure to run as modifier for RunSP action.");
                        action = "None";
                    }
                    if (numofusers == 0)
                    {
                        Console.WriteLine("Must include hashing value (/G or /P) for RunSP action.");
                        action = "None";
                    }
                    if ((puidvalue > -1) & (gamertags.Count != 0))
                    {
                        Console.WriteLine("Both gamertag and PUID entered for hashing value.  Please review usage and try again.");
                        action = "None";
                    }
                    setWstValues("UODB");
                    break;
                case ("SELE"):
                    if (numofusers == 0)
                    {
                        Console.WriteLine("Must include hashing value (/G, /P, or /W) for Select action.");
                        action = "None";
                    }
                    if ((puidvalue > -1) & (gamertags.Count != 0))
                    {
                        Console.WriteLine("Both gamertag and PUID entered for hashing value.  Please review usage and try again.");
                        action = "None";
                    }
                    if (selecttable == string.Empty)
                    {
                        Console.WriteLine("Must include table from which to select for SELECT action.");
                        action = "None";
                    }
                    setWstValues("UODB");
                    // trailing "AND" suggests it's at the wrong end of the additional information
                    if (additional.Length > 4 && additional.Substring(additional.Length - 3) == "AND")
                        additional = "AND " + additional.Substring(0, additional.Length - 3);
                    break;
                case ("SYNC"):
                    if (gamertags.Count == 0)
                    {
                        Console.WriteLine("Gamertag value (/G) must be entered for synch user action");
                        action = "None";
                    }
                    setWstValues("UODB");
                    break;
                case ("UPDA"):
                    if (numofusers == 0)
                    {
                        Console.WriteLine("Must include hashing value (/G or /P) for Update action.");
                        action = "None";
                    }
                    if ((puidvalue > -1) & (gamertags.Count != 0))
                    {
                        Console.WriteLine("Both gamertag and PUID entered for hashing value.  Please review usage and try again.");
                        action = "None";
                    }
                    if (update == string.Empty)
                    {
                        XappAdmin.sendOut("Must include update value (/U or SET) to use Update action.");
                        action = "None";
                    }
                    else
                    {
                        // since '^' is only used for escape in the app, we replace it with a space
                        update = update.Replace('^', ' ');
                    }
                    setWstValues("UODB");
                    // trailing "AND" suggests it's at the wrong end of the additional information
                    if (additional.Length > 4 && additional.Substring(additional.Length - 3) == "AND")
                        additional = "AND " + additional.Substring(0, additional.Length - 3);
                    break;
                case ("USAG"):
                    break;
                case ("VIEW"):
                    if (numofusers == 0)
                    {
                        XappAdmin.sendOut("Gamertag value (/G) or PUID value (/P) must be entered for view user action.");
                        action = "None";
                    }
                    setWstValues("UODB");
                    if (modifier == string.Empty)
                        modifier = "USER";
                    break;
                default:
                    if (outputversion)
                    {
                        action = "VERS";
                    }
                    else
                    {
                        Console.WriteLine("Invalid action: {0}", action);
                        action = "None";
                    }
                    break;
            }
        }

        private void addToAdditional(string strToAdd)
        {
            if (action == "SELE")
            {
                if (fromdone)
                {
                    if (wheredone)
                    {
                        additional = addStringToExisting(strToAdd, additional);
                    }
                    else
                    {
                        selecttable = addStringToExisting(strToAdd, selecttable);
                    }
                }
                else
                {
                    pretable = addStringToExisting(strToAdd, pretable);
                }
            }
            else if (action == "UPDA")
            {
                if (!wheredone)
                {
                    update = addStringToExisting(strToAdd, update);
                }
                if (!fromdone)
                {
                    pretable = addStringToExisting(strToAdd, pretable);
                }
            }
            else
            {
                // add strToAdd to Additional
                additional = addStringToExisting(strToAdd, additional);
            }
        }

        public bool Next()
        {
            bool newValAvailable = false;
            inpindex++;
            if (gamertags.Count > 0)
            {
                if (inpindex < gamertags.Count)
                {
                    gamertag = gamertags[inpindex].ToString().Trim();
                    newValAvailable = true;
                }
            }
            if (PUIDs.Count > 0)
            {
                if (inpindex < PUIDs.Count)
                {
                    puidvalue = getInt64FromString(PUIDs[inpindex].ToString());
                    newValAvailable = true;
                }
            }
            return newValAvailable;
        }

        private string addStringToExisting(string toadd, string existing)
        {
            string returnstring = string.Empty;
            if (existing == string.Empty)
            {
                returnstring = toadd;
            }
            else
            {
                returnstring = existing + " " + toadd;
            }
            return returnstring;
        }

        private string[] getINValuesFromArray(string[] sarray, ref int j)
        {
            ArrayList retvals = new ArrayList();
            bool endparen = false;
            // get rid of leading open parenthesis
            if (sarray[j].Length > 0)
                if (sarray[j].Substring(0, 1) == "(")
                    if (sarray[j].Length > 1)
                    {
                        sarray[j] = sarray[j].Substring(1);
                    }
                    else
                    {
                        sarray[j] = string.Empty;
                    }
            for (i = j; i < sarray.Length; i++)
            {
                if (sarray[i] != string.Empty)
                {
                    if (sarray[i].IndexOf(')') > -1)
                    {
                        // if we see an end-parenthesis
                        // add the last thing before it and exit
                        string[] parensplit = sarray[i].Split(')');
                        sarray[i] = parensplit[0];
                        endparen = true;
                    }
                    string[] commasplit = sarray[i].Split(',');
                    foreach (string split in commasplit)
                    {
                        retvals.Add(split);
                    }
                }
                if (endparen)
                    break;
            }
            j = i;
            string[] returnvalues = (string[]) retvals.ToArray(typeof(string));
            return returnvalues;
        }

        protected string getGamertagFromArray(string[] sourcearray, ref int arrayindex)
        {
            string gamertag = string.Empty;
            int i = arrayindex;
            int j = -1;
            if (sourcearray[i].Length == 0)
            {
                if (sourcearray.Length > i)
                {
                    i++;
                }
                else
                {
                    return string.Empty;
                }
            }
            if (sourcearray[i].Substring(0, 1) == "'")
            {
                for (j = i; j < sourcearray.Length; j++)
                {
                    gamertag = addStringToExisting(sourcearray[j], gamertag);
                    if (sourcearray[j].Substring(sourcearray[j].Length - 1, 1) == "'")
                        break;
                }
                gamertag = gamertag.Replace("'", "");
                arrayindex = j; // reset the array index so that the calling function can continue parsing the array from where this leaves off
            }
            else
            {
                gamertag = sourcearray[arrayindex].Replace("'", "");
                arrayindex++;   // increment the array index so the calling function continues on from here
            }
            return gamertag;
        }

        internal static string getStringFromFile(string filestr, string delimiter)
        {
            StreamReader sr = null;
            string totalstring = string.Empty;
            string inp = string.Empty;
            if (System.IO.File.Exists(filestr))
            {
                try
                {
                    sr = System.IO.File.OpenText(filestr);
                }
                catch (SystemException e)
                {
                    XappAdmin.outputError(e, string.Format("Error attempting to open input file {0}", filestr));
                }
                while (!sr.EndOfStream)
                {
                    inp = sr.ReadLine();
                    totalstring = string.Format("{0}{1}{2}", totalstring, inp, delimiter);
                }
            }
            return totalstring;
        }

        protected void setWstValues(string deploy)
        {
            conn = connectToWST(deploy);
            npdb = connectToWST("npdb");
            if (conn.SqlPartitions.Count > 0)
            {
                wstConnEntered = true;
                depguid = WstLib.deploymentGuid(deploy);
                partcount = WebstoreMetaData.Instance.DefaultConfig.Deployments[depguid].Partitions.Count;
            }
        }

        internal static WstConnection connectToWST(string strDeployment)
		{
            WstConnection con = null;
            // declare and open a connection to the deployment
			try
			{
                con = new WstConnection(strDeployment);
                con.Open();
			}
			catch (WstException ex)
			{
				Console.WriteLine("Error attempting to connect to Webstore deployment " + strDeployment);
				Console.WriteLine(ex.Message);
			}
			return con;
		}

        protected long getInt64FromString(string inpval)
        {
            long outval = -1;
            if (inpval.Length > 1)
            {
                if (inpval.Substring(0, 2).ToLower() == "0x")
                {
                    // convert hex to decimal
                    try
                    {
                        outval = Convert.ToInt64(inpval, 16);
                    }
                    catch (SystemException e)
                    {
                        Console.WriteLine(e.Message);
                        Console.WriteLine("Puid parameter (/P) needs to be a valid bigint value.");
                    }
                }
                else
                {
                    try
                    {
                        outval = Convert.ToInt64(inpval);
                    }
                    catch (SystemException e)
                    {
                        Console.WriteLine(e.Message);
                        Console.WriteLine("Puid parameter (/P) needs to be a valid bigint value.");
                    }
                }
            }
            return outval;
        }

		protected bool PromptForValue(string[] PValues, int intIndex)
		{
			if ((intIndex + 2) > PValues.Length)
			{
				Console.WriteLine(String.Concat("No value for switch ", PValues[intIndex].ToUpper()));
				return true;
			} 
			else 
			{
				return false;
			}
		}
		protected string arg;
		public int i;
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\XAppAdmin\WstLib.cs ===
using System;
using System.Collections.Generic;
using System.Data;
using System.Data.SqlClient;
using System.Text;
using Microsoft.Webstore.MetaData;
using Microsoft.Webstore.WstClient;

namespace XappAdmin
{
    class WstLib
    {
        internal static void handleReadError(SystemException e, WstDataReader rdr)
        {
            if (e.Message == "Invalid attempt to read when no data is present.")
            {
                // if we're not on a valid record, then read a record.
                rdr.Read();
            }
            else
            {
                // otherwise, just print the error.
                Console.WriteLine("message: {0}", e.Message);
            }
        }

        internal static Guid deploymentGuid(string deployment)
        {
            Guid retval = Guid.Empty;
            WebstoreConfig cfg = WebstoreMetaData.Instance.DefaultConfig;
            foreach (WebstoreDeployment dep in cfg.Deployments)
            {
                if (dep.Name.ToUpper() == deployment.ToUpper())
                {
                    retval = dep.Uid;
                }
            }
            return retval;
        }

        internal static void disposeReader(WstDataReader rdr)
        {
            if (rdr != null)
            {
                if (!rdr.IsClosed)
                {
                    rdr.Close();
                }
            }
        }

        public static string getBinaryFromReader(WstDataReader wstr, int rdrColumn)
        {
            string retval = string.Empty;
            // used to translate System.Byte[] value into byte array
            byte[] binaryData = (byte[])wstr.GetValue(rdrColumn);
            retval = ToHexString(binaryData); // used to translate byte array into string
            return retval;
        }

        public static DateTime getDateTimeFromReader(WstDataReader wstr, int rdrColumn)
        {
            DateTime retval = new DateTime();
            if (wstr == null)
            {
                Console.WriteLine("WstDataReader is null.");
            }
            else
            {
                if (wstr.HasRows)
                {
                    try
                    {
                        // if we're already on a valid record, return the requested value
                        retval = wstr.GetDateTime(rdrColumn);
                    }
                    catch (SystemException e)
                    {
                        // otherwise read once and then return the requested value
                        handleReadError(e, wstr);
                        retval = wstr.GetDateTime(rdrColumn);
                    }
                }
            }
            return retval;
        }

        public static int getIntFromReader(WstDataReader wstr)
        {
            int retval = -1;
            if (wstr.HasRows)
            {
                try
                {
                    // if we're already on a valid record, return the requested value
                    retval = wstr.GetInt32(0);
                }
                catch (SystemException e)
                {
                    // otherwise read once and then return the requested value
                    handleReadError(e, wstr);
                    retval = wstr.GetInt32(0);
                }
            }
            return retval;
        }

        public static int getIntFromReader(WstDataReader wstr, int cell)
        {
            int retval = -1;
            if (wstr.HasRows)
            {
                try
                {
                    // if we're already on a valid record, return the requested value
                    retval = wstr.GetInt32(cell);
                }
                catch (SystemException e)
                {
                    // otherwise read once and then return the requested value
                    handleReadError(e, wstr);
                    retval = wstr.GetInt32(cell);
                }
            }
            return retval;
        }

        public static long getLongFromReader(WstDataReader wstr)
        {
            long retval = getLongFromReader(wstr, 0);
            return retval;
        }

        public static long getLongFromReader(WstDataReader wstr, int cell)
        {
            long retval = -1;
            if (wstr.HasRows)
            {
                try
                {
                    // if we're already on a valid record, return the requested value
                    retval = wstr.GetInt64(cell);
                }
                catch (SystemException e)
                {
                    // otherwise read once and then return the requested value
                    handleReadError(e, wstr);
                    retval = wstr.GetInt64(cell);
                }
            }
            return retval;
        }

        internal static WstDataReader getReaderFromWst(WstCommand wstc)
        {
            WstDataReader getRdr = null;
            try
            {
                getRdr = wstc.ExecuteReader();
            }
            catch (WstException e)
            {
                Console.WriteLine("Webstore error executing query against connection string {0}, partition {1}:", wstc.Connection.ConnectionString, wstc.Partition);
                Console.WriteLine(e.Message);
            }
            catch (SqlException e)
            {
                Console.WriteLine("SQL Server error executing query \"{0}\" against connection string {1}, partition {2}:", wstc.CommandText, wstc.Connection.ConnectionString, wstc.Partition);
                Console.WriteLine(e.Message);
            }
            return getRdr;
        }

        internal static WstDataReader getReaderFromWst(WstCommand wstc, string cmdText)
        {
            WstDataReader getRdr = null;
            wstc.CommandText = cmdText;
            wstc.CommandType = CommandType.Text;
            try
            {
                getRdr = wstc.ExecuteReader();
            }
            catch (WstException e)
            {
                Console.WriteLine("Webstore error executing query against connection string {0}, partition {1}:", wstc.Connection.ConnectionString, wstc.Partition);
                Console.WriteLine(e.Message);
            }
            catch (SqlException e)
            {
                Console.WriteLine("SQL Server error executing query \"{0}\" against connection string {1}, partition {2}:", wstc.CommandText, wstc.Connection.ConnectionString, wstc.Partition);
                Console.WriteLine(e.Message);
            }
            return getRdr;
        }

        internal static WstDataReader getReaderFromWst(WstCommand wstc, string cmdText, string delay)
        {
            WstDataReader getRdr = null;
            cmdText += " WAITFOR DELAY '" + delay.ToString() + "'";
            wstc.CommandText = cmdText;
            wstc.CommandType = CommandType.Text;
            try
            {
                getRdr = wstc.ExecuteReader();
            }
            catch (WstException e)
            {
                Console.WriteLine("Webstore error executing query against connection string {0}, partition {1}:", wstc.Connection.ConnectionString, wstc.Partition);
                Console.WriteLine(e.Message);
            }
            catch (SqlException e)
            {
                Console.WriteLine("SQL Server error executing query \"{0}\" against connection string {1}, partition {2}:", wstc.CommandText, wstc.Connection.ConnectionString, wstc.Partition);
                Console.WriteLine(e.Message);
            }
            return getRdr;
        }

        public static string getStringFromReader(WstDataReader wstr)
        {
            string retval = getStringFromReader(wstr, 0);
            return retval;
        }

        public static string getStringFromReader(WstDataReader wstr, int rdrColumn)
        {
            string retval = string.Empty;
            if (wstr == null)
            {
                Console.WriteLine("WstDataReader is null.");
            }
            else
            {
                if (wstr.HasRows)
                {
                    try
                    {
                        // if we're already on a valid record, return the requested value
                        retval = wstr.GetString(rdrColumn);
                    }
                    catch (SystemException e)
                    {
                        // otherwise read once and then return the requested value
                        handleReadError(e, wstr);
                        retval = wstr.GetString(rdrColumn);
                    }
                }
            }
            return retval;
        }

        static char[] hexDigits = {
            '0', '1', '2', '3', '4', '5', '6', '7', 
            '8', '9', 'A', 'B', 'C', 'D', 'E', 'F'};

        internal static string ToHexString(byte[] bytes)
        {
            // turn a byte array into the equivalent character string
            char[] chars = new char[bytes.Length * 2];
            for (int i = 0; i < bytes.Length; i++)
            {
                int b = bytes[i];
                chars[i * 2] = hexDigits[b >> 4];
                chars[i * 2 + 1] = hexDigits[b & 0xF];
            }
            string charstr = new string(chars);
            charstr = string.Format("0x{0}", charstr);
            return charstr;
        }
        internal static bool verifyReader(WstDataReader rdr)
        {
            bool isready = verifyReader(rdr, true);
            return isready;
        }

        internal static bool verifyReader(WstDataReader rdr, bool outputstatus)
        {
            bool isready = false;
            if (rdr == null)
            {
                if (outputstatus)
                    Console.WriteLine("WstDataReader is null.");
            }
            else
            {
                if (rdr.IsClosed)
                {
                    if (outputstatus)
                        Console.WriteLine("WstDataReader is closed.");
                }
                else
                {
                    if (rdr.HasRows)
                    {
                        isready = true;
                    }
                    else
                    {
                        if (outputstatus)
                            Console.WriteLine("Query returned no rows.");
                    }
                }
            }
            return isready;
        }

    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\XblCfg\App\actionEtx.cs ===
// -----------------------------------------------------------------------
//
// Implements the -etx commands for XblCfg.exe
//
// -----------------------------------------------------------------------

using System;
using System.Collections.Generic;
using System.Data;
using System.IO;
using System.Security.Principal;
using System.Xml.Linq;

using xonline.common.service;
using xonline.common.tools.console;
using xonline.common.user;
using xonline.common.core.etx;
using xonline.common.sql.sqlclient;
using xonline.common.config;
using xonline.common.utilities2;
using System.Linq;

namespace xonline.tools.xblcfg
{
    public class ActionEtx
    {
        #region General Support Methods

        private static void PrintReport(List<Producer> newProducers, List<Producer> modifiedProducers, Dictionary<KeyValuePair<Blob, Blob>, Event> newEvents, Dictionary<KeyValuePair<Blob, Blob>, Event> modifiedEvents)
        {
            XblCfgConsole.Out("------------------------------- NEW PRODUCERS ---------------------------------");
            XblCfgConsole.Out("");

            foreach (Producer producer in newProducers)
            {
                XblCfgConsole.Out("  PRODUCER: {0}", producer.Symbol);
                XblCfgConsole.Out("    Fingerprint: {0}", producer.Fingerprint);
                XblCfgConsole.Out("    Description: {0}", producer.Description);

                PrintEventReport("New Events", producer.Events, true);

                XblCfgConsole.Out("");
            }

            XblCfgConsole.Out("----------------------------- MODIFIED PRODUCERS ------------------------------");
            XblCfgConsole.Out("");

            foreach (Producer producer in modifiedProducers)
            {
                XblCfgConsole.Out("  PRODUCER: {0}", producer.Symbol);
                XblCfgConsole.Out("    Fingerprint: {0}", producer.Fingerprint);
                XblCfgConsole.Out("    Description: {0}", producer.Description);

                PrintEventReport("New Events", newEvents.Where(item => item.Key.Key == producer.Fingerprint).Select(item => item.Value), true);
                PrintEventReport("Modified Events", modifiedEvents.Where(item => item.Key.Key == producer.Fingerprint).Select(item => item.Value), true);

                XblCfgConsole.Out("");
            }
        }

        private static void PrintEventReport(string name, IEnumerable<Event> events, bool shorthand)
        {
            foreach (Event ev in events)
            {
                XblCfgConsole.Out("    {0} ({1})", name, events.Count());
                XblCfgConsole.Out("      Event: {0}, {1}", ev.Symbol, ev.Ordinal);
                XblCfgConsole.Out("        Fingerprint: {0}", ev.Fingerprint);
                XblCfgConsole.Out("        LogStringId: {0}", ev.LogStringId);

                if (shorthand == false)
                {
                    XblCfgConsole.Out("        Category: {0}", ev.Category);
                    XblCfgConsole.Out("        Description: {0}", ev.Description);
                    XblCfgConsole.Out("        OmnitureArea: {0}", ev.OmnitureArea);
                    XblCfgConsole.Out("        DataFields: {0}", ev.DataFields.Count);

                    foreach (DataField df in ev.DataFields.OrderBy(item => item.Ordinal))
                    {
                        XblCfgConsole.Out("          DataField: {0}, {1}", df.Name, df.Ordinal);
                        XblCfgConsole.Out("            AutoValue: {0}, {1}", df.AutoValue, df.AutoValueCreator);
                        XblCfgConsole.Out("            InType: {0}", df.InType);
                        XblCfgConsole.Out("            OutType: {0}", df.OutType);
                        XblCfgConsole.Out("            OmnitureVar: {0}", df.OmnitureVar);
                    }
                }
                
                XblCfgConsole.Out("");
            }
        }

        #endregion

        internal void Process(NamedArgParser args)
        {
            if (args["help"] != null || args["h"] != null || args["?"] != null)
            {
                PrintUsageBlob();
            }
            else if (args["ingestRelease"] != null)
            {
                ProcessIngestRelease(args);
            }
            else if (args["diff"] != null)
            {
                ProcessDiff(args);
            }
            else if (args["listProducers"] != null)
            {
                ProcessListProducers(args);
            }
            else if (args["getProducers"] != null)
            {
                ProcessGetProducers(args);
            }
            else if (args["getEvents"] != null)
            {
                ProcessGetEvents(args);
            }
            else
            {
                PrintUsageBlob();
                throw new XblCfgBadArgumentException("One or more required actions was not set for -etx: ");
            }
        }

        internal void ProcessIngestRelease(NamedArgParser args)
        {
            string release;
            string path;
            List<Producer> newProducers;
            List<Producer> modifiedProducers;
            Dictionary<KeyValuePair<Blob, Blob>, Event> newEvents;
            Dictionary<KeyValuePair<Blob, Blob>, Event> modifiedEvents;
            EtxManifest world;
            DateTime dt1, dt2;

            release = args["release"];
            path = args["path"];

            newProducers = new List<Producer>();
            modifiedProducers = new List<Producer>();
            newEvents = new Dictionary<KeyValuePair<Blob, Blob>, Event>();
            modifiedEvents = new Dictionary<KeyValuePair<Blob, Blob>, Event>();

            if (string.IsNullOrEmpty(release)) // parameter required
            {
                PrintUsageBlob();
                throw new XblCfgBadArgumentException("-ingestRelease requires the -release parameter");
            }
            else if (string.IsNullOrEmpty(path)) // parameter required
            {
                PrintUsageBlob();
                throw new XblCfgBadArgumentException("-ingestRelease requires the -path parameter");
            }

            // connect to npdb and upload validated etx manifests
            using (SqlClient client = new SqlClient(Interface.npdb)) 
            {
                // perform operations under a transaction so that we can rollback on error
                client.Command.Transaction = client.Command.Connection.BeginTransaction(IsolationLevel.ReadCommitted);

                try
                {
                    XblCfgConsole.Out("Downloading entire Etx Manifest from npdb...");
                    world = EtxLoader.NPDB.GetManifest(client, ProducerFetchMode.Normalized, out dt1, out dt2);

                    ReleaseAction(
                        path,
                        manifest =>
                        {
                            XblCfgConsole.Out("    Validating Manifest...");
                            ValidateEachProducer(newProducers, modifiedProducers, newEvents, modifiedEvents, client, manifest);

                            XblCfgConsole.Out("    Manifest Merge...");
                            world.Merge(manifest);

                            XblCfgConsole.Out("    Uploading...");
                            EtxLoader.NPDB.UploadManifest(client, manifest);
                        });
                }
                catch
                {
                    XblCfgConsole.Out("Rolling back changes due to failure(s).");
                    client.Command.Transaction.Rollback();
                    throw;
                }

                XblCfgConsole.Out("Execution completed successfully, changes committed to npdb.");

                client.Command.Transaction.Commit();
            }

            XblCfgConsole.Out("===============================================================================");
            XblCfgConsole.Out("                                CHANGE REPORT");
            XblCfgConsole.Out("===============================================================================");
            XblCfgConsole.Out("  Total Producer Post Merge: {0}", world.Producers.Count);

            PrintReport(newProducers, modifiedProducers, newEvents, modifiedEvents);
        }

        #region Ingestion Support Methods

        private static void ValidateEachProducer(List<Producer> newProducers, List<Producer> modifiedProducers, Dictionary<KeyValuePair<Blob, Blob>, Event> newEvents, Dictionary<KeyValuePair<Blob, Blob>, Event> modifiedEvents, SqlClient client, EtxManifest manifest)
        {
            // validate each producer in the manifest
            
            foreach (Producer producer in manifest.Producers)
            {
                try
                {
                    List<Producer> producerVersions;

                    XblCfgConsole.Out("      Validating Producer {0}...", producer.Symbol);
                    producerVersions = EtxLoader.NPDB.GetProducerVersionsBySymbol(client, producer.Symbol, ProducerFetchMode.Normalized).ToList();

                    if (null != producerVersions.FirstOrDefault(p => p.Fingerprint == producer.Fingerprint))
                    {
                        // matching fingerprint found, producer already exists

                        XblCfgConsole.Out("        PASSED: Existing Producer, Skipping Upload.");
                        continue;
                    }
                    else
                    {
                        // no matching fingerprint, dealing with a new version of an existing producer symbol

                        // iterate through events 
                        foreach (Event ev in producer.Events)
                        {
                            List<Event> eventVersions;

                            XblCfgConsole.Out("        Validating Event {0},{1},{2}...", ev.Symbol, ev.LogStringId, ev.Fingerprint);

                            try
                            {
                                eventVersions = EtxLoader.NPDB.GetEventVersionsByLogStringId(client, ev.LogStringId).ToList();

                                if (null != eventVersions.FirstOrDefault(e => e.Fingerprint == ev.Fingerprint))
                                {
                                    // matching fingerprint found, event already exists

                                    XblCfgConsole.Out("          PASSED: Existing Event");
                                    continue;
                                }
                                else
                                {
                                    // no matching fingerprint found, older version of event exists

                                    XblCfgConsole.Out("          PASSED: Modified Event");
                                    modifiedEvents.Add(new KeyValuePair<Blob, Blob>(producer.Fingerprint, ev.Fingerprint), ev);
                                }
                            }
                            catch (ArgumentException)
                            {
                                // no events found - api throughs an exception

                                newEvents.Add(new KeyValuePair<Blob, Blob>(producer.Fingerprint, ev.Fingerprint), ev);
                            }
                        }

                        XblCfgConsole.Out("        PASSED: Modified Producer.");
                        modifiedProducers.Add(producer);
                    }
                }
                catch (ArgumentException)
                {
                    XblCfgConsole.Out("        PASSED: New Producer.");
                    newProducers.Add(producer);
                }
            }
        }
        
        #endregion

        private void ReleaseAction(string directoryOrFile, Action<EtxManifest> manifestAction)
        {
            if (File.Exists(directoryOrFile))
            {
                EtxManifest manifest;

                XblCfgConsole.Out("  File {0}", directoryOrFile);

                // load the file as xml
                XblCfgConsole.Out("    Loading...");
                manifest = new EtxManifest(XElement.Load(directoryOrFile));

                // perform the action
                manifestAction(manifest);
            }
            else
            {
                XblCfgConsole.Out("Reading all .xml files from '{0}' and its subdirectores...", directoryOrFile);

                // read all .xml files in the directory and subdirectories
                foreach (string file in Directory.GetFiles(directoryOrFile, "*.xml", SearchOption.AllDirectories))
                {
                    EtxManifest manifest;

                    XblCfgConsole.Out("  File {0}", file);

                    // load the file as xml
                    XblCfgConsole.Out("    Loading...");
                    manifest = new EtxManifest(XElement.Load(file));

                    // perform the action
                    manifestAction(manifest);
                }
            }
        }

        private EtxManifest LoadRelease(string path)
        {
            EtxManifest result;

            result = new EtxManifest();

            ReleaseAction(
                path,
                manifest =>
                {
                    XblCfgConsole.Out("    Merging Manifest...");
                    result.Merge(manifest);
                });

            return result;
        }

        internal void ProcessDiff(NamedArgParser args)
        {
            List<Producer> newProducers;
            List<Producer> modifiedProducers;
            Dictionary<KeyValuePair<Blob, Blob>, Event> newEvents;
            Dictionary<KeyValuePair<Blob, Blob>, Event> modifiedEvents;
            EtxManifest newManifest;
            EtxManifest oldManifest;
            string newRelease;
            string oldRelease;
            string newPath;
            string oldPath;

            newRelease = args["newRelease"];
            oldRelease = args["oldRelease"];
            newPath = args["newPath"];
            oldPath = args["oldPath"];

            newProducers = new List<Producer>();
            modifiedProducers = new List<Producer>();
            newEvents = new Dictionary<KeyValuePair<Blob, Blob>, Event>();
            modifiedEvents = new Dictionary<KeyValuePair<Blob, Blob>, Event>();

            if (string.IsNullOrEmpty(newRelease)) // parameter required
            {
                PrintUsageBlob();
                throw new XblCfgBadArgumentException("-diff requires the -newRelease parameter");
            }
            else if (string.IsNullOrEmpty(oldRelease)) // parameter required
            {
                PrintUsageBlob();
                throw new XblCfgBadArgumentException("-diff requires the -oldRelease parameter");
            }
            else if (string.IsNullOrEmpty(newPath)) // parameter required
            {
                PrintUsageBlob();
                throw new XblCfgBadArgumentException("-diff requires the -newPath parameter");
            }
            else if (string.IsNullOrEmpty(oldPath)) // parameter required
            {
                PrintUsageBlob();
                throw new XblCfgBadArgumentException("-diff requires the -oldPath parameter");
            }

            newManifest = LoadRelease(newPath);
            oldManifest = LoadRelease(oldPath);

            // new producers are producers which have symbols which have not yet been used
            newProducers.AddRange(
                newManifest.Producers
                .Where(np => null == oldManifest.Producers.FirstOrDefault(op => op.Symbol == np.Symbol)));

            // modified producers are producers which have unique fingerprints and share symbol names with old producers
            foreach (Producer np in newManifest.Producers)
            {
                if (false == oldManifest.Producers.Fingerprints.ContainsKey(np.Fingerprint))
                {
                    List<string> newSymbols;
                    List<string> modSymbols;

                    newSymbols = np.Events.Symbols.Select(s => s).ToList();
                    modSymbols = new List<string>(newSymbols);

                    foreach (Producer op in oldManifest.Producers.Where(p => p.Symbol == np.Symbol))
                    {
                        // save some effort
                        if (newSymbols.Count == 0 && modSymbols.Count == 0)
                        {
                            break;
                        }

                        foreach (Event ev in op.Events)
                        {
                            if (np.Events.Fingerprints.ContainsKey(ev.Fingerprint))
                            {
                                // symbol neither new nor modified
                                newSymbols.Remove(ev.Symbol);
                                modSymbols.Remove(ev.Symbol);
                            }
                            else
                            {
                                newSymbols.Remove(ev.Symbol);
                            }
                        }
                    }

                    // symbols that are new are certainly not modified
                    modSymbols.RemoveAll(s => newSymbols.Contains(s));

                    newSymbols
                        .ConvertAll(s => np.Events.Symbols[s])
                        .ForEach(ev => newEvents.Add(new KeyValuePair<Blob, Blob>(np.Fingerprint, ev.Fingerprint), ev));

                    modSymbols
                        .ConvertAll(s => np.Events.Symbols[s])
                        .ForEach(ev => modifiedEvents.Add(new KeyValuePair<Blob, Blob>(np.Fingerprint, ev.Fingerprint), ev));
                }
            }

            XblCfgConsole.Out("===============================================================================");
            XblCfgConsole.Out("                                 DIFF REPORT");
            XblCfgConsole.Out("===============================================================================");
            XblCfgConsole.Out("  Old Release Producer Count: {0}", oldManifest.Producers.Count);
            XblCfgConsole.Out("  New Release Producer Count: {0}", newManifest.Producers.Count);

            PrintReport(newProducers, modifiedProducers, newEvents, modifiedEvents);
        }

        internal void ProcessListProducers(NamedArgParser args)
        {
            EtxManifest manifest;
            DateTime dt1, dt2;

            XblCfgConsole.Out("Downloading ETX Manifest...");
            manifest = EtxLoader.NPDB.GetManifest(ProducerFetchMode.Normalized, out dt1, out dt2);

            XblCfgConsole.Out("===============================================================================");
            XblCfgConsole.Out("                                 LIST REPORT");
            XblCfgConsole.Out("===============================================================================");
            XblCfgConsole.Out("  Producer Count: {0}", manifest.Producers.Count);
            XblCfgConsole.Out("");

            foreach (Producer producer in manifest.Producers)
            {
                XblCfgConsole.Out("  PRODUCER: {0}", producer.Symbol);
                XblCfgConsole.Out("    Fingerprint: {0}", producer.Fingerprint);
                XblCfgConsole.Out("    Description: {0}", producer.Description);
                XblCfgConsole.Out("    Events: {0}", producer.Events.Count);
                XblCfgConsole.Out("");
            }
        }

        internal void ProcessGetProducers(NamedArgParser args)
        {
            string fingerprint;
            string symbol;

            fingerprint = args["fingerprint"];
            symbol = args["symbol"];

            if (string.IsNullOrEmpty(fingerprint) && string.IsNullOrEmpty(symbol))
            {
                PrintUsageBlob();
                throw new XblCfgBadArgumentException("-getProducers requires either the -fingerprint or -symbol parameter");
            }
            else if (!string.IsNullOrEmpty(fingerprint) && !string.IsNullOrEmpty(symbol))
            {
                PrintUsageBlob();
                throw new XblCfgBadArgumentException("-getProducers it is invalid to specifed both the -fingerprint and -symbol parameter.");
            }
            else if (!string.IsNullOrEmpty(fingerprint))
            {
                Blob producerFingerprint;
                Producer producer;

                try
                {
                    producerFingerprint = Blob.Parse(fingerprint);
                }
                catch
                {
                    PrintUsageBlob();
                    throw new XblCfgBadArgumentException(string.Format("-getProducers the specified fingerprint is not valid hex: {0}", fingerprint));
                }

                try
                {
                    XblCfgConsole.Out("Downloading ETX Producer By Fingerprint {0}...", fingerprint);

                    producer = EtxLoader.NPDB.GetProducer(producerFingerprint, ProducerFetchMode.Normalized);

                    XblCfgConsole.Out("  PRODUCER: {0}", producer.Symbol);
                    XblCfgConsole.Out("    Fingerprint: {0}", producer.Fingerprint);
                    XblCfgConsole.Out("    Description: {0}", producer.Description);

                    PrintEventReport("Events", producer.Events, false);

                    XblCfgConsole.Out("");
                }
                catch (ArgumentException)
                {
                    XblCfgConsole.Out("No producer found with fingerprint: {0}", fingerprint);
                }
            }
            else
            {
                IEnumerable<Producer> producers;

                try
                {
                    XblCfgConsole.Out("Downloading ETX Producers By Symbol {0}...", symbol);

                    producers = EtxLoader.NPDB.GetProducerVersionsBySymbol(symbol, ProducerFetchMode.Normalized);

                    XblCfgConsole.Out("Found {0} Producer Versions", producers.Count());

                    foreach (Producer producer in producers)
                    {
                        XblCfgConsole.Out("  PRODUCER: {0}", producer.Symbol);
                        XblCfgConsole.Out("    Fingerprint: {0}", producer.Fingerprint);
                        XblCfgConsole.Out("    Description: {0}", producer.Description);

                        PrintEventReport("Events", producer.Events, false);

                        XblCfgConsole.Out("");
                    }
                }
                catch (ArgumentException)
                {
                    XblCfgConsole.Out("No producers found with symbol: {0}", symbol);
                }
            }
        }

        internal void ProcessGetEvents(NamedArgParser args)
        {
            string fingerprint;
            string symbol;


            fingerprint = args["fingerprint"];
            symbol = args["symbol"];

            if (string.IsNullOrEmpty(fingerprint) && string.IsNullOrEmpty(symbol))
            {
                PrintUsageBlob();
                throw new XblCfgBadArgumentException("-getEvents requires either the -fingerprint or -symbol parameter");
            }
            else if (!string.IsNullOrEmpty(fingerprint) && !string.IsNullOrEmpty(symbol))
            {
                PrintUsageBlob();
                throw new XblCfgBadArgumentException("-getEvents it is invalid to specifed both the -fingerprint and -symbol parameter.");
            }
            else if (!string.IsNullOrEmpty(fingerprint))
            {
                Blob eventFingerprint;
                Event ev;

                try
                {
                    eventFingerprint = Blob.Parse(fingerprint);
                }
                catch
                {
                    PrintUsageBlob();
                    throw new XblCfgBadArgumentException(string.Format("-getEvents the specified fingerprint is not valid hex: {0}", fingerprint));
                }

                try
                {
                    XblCfgConsole.Out("Downloading ETX Event By Fingerprint {0}...", fingerprint);

                    ev = EtxLoader.NPDB.GetEvent(eventFingerprint);

                    PrintEventReport("Event", new Event[] { ev }, false);

                    XblCfgConsole.Out("");
                }
                catch (ArgumentException)
                {
                    XblCfgConsole.Out("No event found with fingerprint: {0}", fingerprint);
                }
            }
            else
            {
                IEnumerable<Event> events;

                try
                {
                    XblCfgConsole.Out("Downloading ETX Event By Symbol {0}...", symbol);

                    events = EtxLoader.NPDB.GetEventVersionsBySymbol(symbol);

                    XblCfgConsole.Out("Found {0} Event Versions", events.Count());

                    PrintEventReport("Events", events, false);

                    XblCfgConsole.Out("");
                }
                catch (ArgumentException)
                {
                    XblCfgConsole.Out("No event found with symbol: {0}", symbol);
                }
            }
        }

        #region Help Text
        
        internal void PrintUsageBlob()
        {
            string help = @"
xblcfg.exe -etx [options...]

Notes:
    -etx is used to modify client etx manifests stored in the database.  You can ingest etx producers, and list producers and events.

Options:
    -ingestRelease -release:<releaseVersion> -path:<path>
        Ingests one or more ETX Manifests located in the release directory.
        Example: xblcfg -etx -ingestRelease -release:11111 -path:c:\dir\

    -diff -oldRelease:<releaseVersion> -newRelease:<releaseVersion> 
        [-oldPath:<dpath>] [-newPath:<dpath>]
        Calculates the difference between two sets of ETX Manifests stored
        in their respective release directories.
        Example: xblcfg -etx -diff -oldRelease:11111 -newRelease:11112
            -oldPath:c:\dir\11111\ -newPath:c:\dir\11112\

    -listProducers
        Creates an abbreviated list of ETX Producers.
        Example: xblcfg -etx -listProducers

    -getProducers (-fingerprint:<hex> | -symbol:<name>)
        Gets the full producer definition(s).  When the fingerprint is
        specified a single producer defintion matching that fingerprint
        will be displayed. When the symbol is specified, all producer
        versions associated with the specified symbol will be displayed.
        Example: xblcfg -etx -getProducers -symbol:NuiApp

    -getEvents (-fingerprint:<hex> | -logStringId:<name>)
        Gets the full event definitions(s).  When the fingerprint is specified
        a single event definition matching that fingerprint will be displayed.  
        When the logStringId is specified, all event versions using the
        specified logStringId will be displayed.
        Example: xblcfg -etx -getEvents -logStringId:ID

Input Formats:
    <hex> - hex formated number.  0x prefix optional.
        Example: 0xFEEDBADBEEF2BABE

    <releaseVersion> - release number.
        Example: 11034

    <path> - directory or file path path.  Trailing \ optional.
        Example: \\EtxMachine\EtxShare\Releases\11034\

    <name> - a name.
        Example: LOGONFAILURE

Input Notes:
    SPACES - if you input contains spaces, make sure to wrap the entire
        parameter in quotes.
        Example: " + "\"-symbol:SPACING OUT\"";

            XblCfgConsole.Out(help);
        }

        #endregion
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\XblCfg\App\actionDevkit.cs ===
// --------------------------------------------------------------------------------------
// Copyright (c) Microsoft Corporation.  All rights reserved
//
// actionHive.cs
//
// XblCfg
//
// Process the hive command
// --------------------------------------------------------------------------------------

using System;
using System.Collections;
using System.Collections.Generic;
using System.Data;
using System.Data.SqlClient;
using System.Diagnostics;
using System.Globalization;
using System.IO;
using System.Net;
using System.Reflection;
using System.Security.Cryptography;
using System.Text;
using System.Text.RegularExpressions;
using System.Xml;
using System.Xml.XPath;

using Microsoft.Webstore.WstClient;

using xonline.common.config;
using xonline.common.diagnostics;
using xonline.common.service;
using xonline.common.sql.webstore;
using xonline.common.tools.console;
using xonline.common.tools;

namespace xonline.tools.xblcfg
{
    public class ActionDevkit
    {
        public const int CONSOLE_ID_SIZE = 12;
        public const string CONSOLE_NAME_PREFIX = "XE.";
        public const int EXCEPTION_LIST_MAX_ENTRIES = 256;
        public const int EXCEPTION_LIST_MAX_SIZE = 3700;

        // Copy of the loaded console list
        private List<String> ConsoleList = new List<string>();
        private List<String> BadConsoleList = new List<string>();

        private void AddConsole(string consoleId)
        {
            bool saveRequired = false;

            try
            {
                // Load the console list into memory from the server
                if (LoadConsoleList() == false)
                {
                    saveRequired = true;
                }

                // Only allow uppercase consoleids
                consoleId = consoleId.ToUpper();

                // Make sure that we have a valid consoleid
                if (ValidateConsoleId(consoleId) == false)
                {
                    throw new XblCfgBadArgumentException(
                        String.Format(
                            "-consoleid:{0} is not a valid ConsoleId",
                            consoleId
                            ));
                }

                // Make sure that we don't have a duplicate
                if (ConsoleList.Contains(consoleId) == true)
                {
                    throw new XblCfgBadArgumentException(
                        String.Format(
                            "-consoleid:{0} already exists in the Exemption List",
                            consoleId
                            ));
                }

                // Remember the console
                ConsoleList.Add(consoleId);
                saveRequired = true;
            }
            finally
            {
                if (saveRequired == true)
                {
                    // Save the console list back to the server
                    SaveConsoleList();
                }
            }
        }

        private bool LoadConsoleList()
        {
            List<String> consoleList = new List<string>();
            List<String> badConsoleList = new List<string>();
            string fullList;

            // Grad the full console list from the database
            fullList = DevkitManager.List;

            // Walk each element and validate it
            foreach (string console in fullList.Split(new Char[] {';', ','}))
            {
                // Don't allow for a blank/null string
                if (string.IsNullOrEmpty(console))
                {
                    continue;
                }

                // Only use console ids in uppercase notation
                string consoleId = console.ToUpper();

                // Make sure that we a valid console id
                if (ValidateConsoleId(consoleId) == false)
                {
                    if (badConsoleList.Contains(consoleId) == false)
                    {
                        badConsoleList.Add(consoleId);
                    }
                    continue;
                }

                // Make sure that we don't have a duplicate
                if (consoleList.Contains(consoleId) == true)
                {
                    if (badConsoleList.Contains(consoleId) == false)
                    {
                        badConsoleList.Add(consoleId);
                    }
                    continue;
                }

                // Remember this console
                consoleList.Add(consoleId);
            }

            // Remember the current lists
            ConsoleList = consoleList;
            BadConsoleList = badConsoleList;
            return (badConsoleList.Count == 0);
        }

        private void RemoveConsole(string consoleId)
        {
            bool saveRequired = false;

            try
            {
                // Load the console list from the server
                if (LoadConsoleList() == false)
                {
                    saveRequired = true;
                }

                // Only allow uppercase consoleids
                consoleId = consoleId.ToUpper();

                //
                // Do a sanity check that we don't already consider this console
                // as bad and thus removed during the load process
                //
                if (BadConsoleList.Contains(consoleId) == true)
                {
                    //
                    // Do not attempt to reset the machine account. This row
                    // is highly unlikely to exist in UODB
                    //
                    saveRequired = true;
                    return;
                }

                // Make sure that the console is currently in the list
                if (ConsoleList.Contains(consoleId) == false)
                {
                    throw new XblCfgBadArgumentException(
                        String.Format(
                            "-consoleid:{0} does not exists in the Exemption List",
                            consoleId
                            ));
                }

                //
                // Determine if we have a row in UODB for this machine or not.
                // If we do, then we have to reset the associated machine keys
                // for it since we don't want the console to be able to connect
                // using its currently valid keys.
                //
                ulong machinePuid;
                if (MachineManager.TryLookupMachinePuid(consoleId, out machinePuid) == true)
                {
                    MachineManager.ResetConsole(consoleId);
                }

                // Remove the console from the list
                ConsoleList.Remove(consoleId);
                saveRequired = true;
            }
            finally
            {
                if (saveRequired == true)
                {
                    // Save the console list back to the server
                    SaveConsoleList();
                }
            }
        }

        private void SaveConsoleList()
        {
            // See if there are bad consoles that won't get saved back out
            if (BadConsoleList.Count != 0)
            {
                Console.WriteLine("The following bad elements have been removed from the list:");

                int i = 0;
                foreach (string console in BadConsoleList)
                {
                    i++;
                    if (ValidateConsoleId(console) == false)
                    {
                        Console.WriteLine("{0, -3} \"{1}\" (Invalid Xbox 360 ConsoleId)", i, console);
                    }
                    else
                    {
                        Console.WriteLine("{0, -3} \"{1}\" (Duplicate)", i, console);
                    }
                }
            }

            // Walk each element and add it to string. Anything that
            // is in the list has to be valid by the way that we added
            // it or loaded it
            string list = string.Join(";", ConsoleList.ToArray());

            // Sanity checks
            if (list.Length >= EXCEPTION_LIST_MAX_SIZE)
            {
                throw new InvalidDataException(
                    String.Format(
                    "Exception List Length {0} Exceeds Maximum Length {1}",
                    list.Length,
                    EXCEPTION_LIST_MAX_SIZE
                    ) );
            }
            if (ConsoleList.Count >= EXCEPTION_LIST_MAX_ENTRIES)
            {
                throw new InvalidDataException(
                    String.Format(
                    "Exception List Entries {0} Exceed Maximum Entries {1}",
                    ConsoleList.Count,
                    EXCEPTION_LIST_MAX_ENTRIES
                    ));
            }

            // Save the setting
            DevkitManager.List = list;
        }

        private bool ValidateConsoleId(string consoleId)
        {
            uint actualChecksum = 0;
            uint reportedChecksum = 0;
            uint digit = 0;
            int stringIdx = 0;
            ulong ulConsoleId = 0;
            
            // Verify that consoleid starts with the correct string
            if (consoleId.StartsWith(CONSOLE_NAME_PREFIX) == false)
            {
                return false;
            }
            consoleId = consoleId.Substring(CONSOLE_NAME_PREFIX.Length);

            // verify the string length
            if (consoleId.Length != CONSOLE_ID_SIZE)
            {
                return false;
            }

            try
            {
                ulConsoleId = ulong.Parse(consoleId.Substring(0, consoleId.Length - 1));
            }
            catch (FormatException)
            {
                return false;
            }

            if (ulConsoleId == 0 || ulConsoleId > 0x0FFFFFFFFF)
            {
                // console ids cannot be 0 or > 0x0FFFFFFFFF
                return false;
            }

            // get the reported checksum
            reportedChecksum = uint.Parse(consoleId[consoleId.Length - 1].ToString());

            // From XMACSProvider.cpp:
            // The console id is made of 11 significant digits + 1 checksum digit
            // For example: XE.123456789016 
            // Where 6 is the checksum of 12345678901
            // Calculate checksum now. At the same time calculate binary form of the 
            // console id         
            for (stringIdx = 0; stringIdx < consoleId.Length - 1; stringIdx++)
            {
                // ensure the character is a digit.
                if (!char.IsDigit(consoleId, stringIdx))
                {
                    return false;
                }

                digit = uint.Parse(consoleId[stringIdx].ToString());
                actualChecksum += digit;

            }
            actualChecksum = actualChecksum % 10;

            // verify the checksum
            if (reportedChecksum != actualChecksum)
            {
                return false;
            }
            return true;
        }

        public void Process(NamedArgParser args)
        {
            if(args["help"] != null || args["h"] != null || args["?"] != null)
            {
                PrintUsageBlob();
                return;
            }
            if(args["add"] != null)
            {
                ProcessAddDevkit(args);
            }
            else if(args["remove"] != null)
            {
                ProcessRemoveDevkit(args);
            }
            else if (args["list"] != null)
            {
                ProcessListDevkit(args);
            }
            else
            {
                PrintUsageBlob();
                throw new XblCfgBadArgumentException("One or more required actions was not set -add -remove -list");
            }
        }

        private static void PrintUsageBlob()
        {
//       1         2         3         4         5         6         7         8
//34567890123456789012345678901234567890123456789012345678901234567890123456789012345678
            string helpText = @" 
xblcfg.exe -devkit [options...]

Notes:
    -devkit is used to add, delete, or list a devkit to 
        npdb.dbo.t_settings.kdcsvc_xmacs_ExceptionList

    This may be used to grant or remove access to a devkit to connect to 
    current environment. 

    This command only affects environments where devkits are not
    permitted to connect.

    Using this command without permission may result in severe penalties, up 
    to and including termination.

Options:

    -add -consoleid:<vc_consoleid>

        Adds a console to the ExceptionList, effectively granting it access
        to the current environment.

        [consoleid]......ConsoleId in XE.0123456789012 format
               
    -remove -consoleid:<vc_consoleid>

        Removes a console from the ExceptionList, effectively preventing it
        from accessing the current environment.

        [consoleid]......ConsoleId in XE.0123456789012 format

    -list

        Display the list of currently exempted console
    
    ::Examples:: 
      [-add]
        Add Console ID 029877733949 to the list of allowed consoles
            xblcfg.exe -devkit -add -consoleid:XE.029877733949

      [-remove]
        Remove Console ID 029877733949 from the list of allowed consoles
            xblcfg.exe -devkit -remove -consoleid:XE.029877733949

      [-list]
        List the currently excluded consoles
            xblcfg.exe -devkit -list

";

            XblCfgConsole.Out(helpText);
        }

        private void ProcessListDevkit(NamedArgParser args)
        {
            LoadConsoleList();

            if (ConsoleList.Count == 0)
            {
                Console.WriteLine("No machines in the Exemption List");
                return;
            }

            Console.WriteLine("The Exemption List contains the following machines:");
            int i = 0;
            foreach (string console in ConsoleList)
            {
                i++;
                Console.WriteLine("{0, -3} {1}", i, console);
            }

            if (BadConsoleList.Count == 0)
            {
                return;
            }

            Console.WriteLine("\n\nThe Exemption List contains the following invalid machines:");
            i = 0;
            foreach (string console in BadConsoleList)
            {
                i++;
                if (ValidateConsoleId(console) == false)
                {
                    Console.WriteLine("{0, -3} \"{1}\" (Invalid Xbox 360 ConsoleId)", i, console);
                }
                else
                {
                    Console.WriteLine("{0, -3} \"{1}\" (Duplicate)", i, console);
                }
            }
            Console.WriteLine("The above machines will get automatically purged on any ADD or REMOVE operation.");
        }

        private void ProcessAddDevkit(NamedArgParser args)
        {
            if (String.IsNullOrEmpty(args["consoleid"]) == true)
            {
                PrintUsageBlob();
                throw new XblCfgBadArgumentException("Missing -consoleid:<id> to xblcfg.exe -devkit -add");
            }
            
            AddConsole(args["consoleid"]);
            Console.WriteLine(
                "Console {0} successfully added to the Exemption List",
                args["consoleid"]
                );
        }

        private void ProcessRemoveDevkit(NamedArgParser args)
        {
            if (String.IsNullOrEmpty(args["consoleid"]) == true)
            {
                PrintUsageBlob();
                throw new XblCfgBadArgumentException("Missing -consoleid:<id> to xblcfg.exe -devkit -remove");
            }

            RemoveConsole(args["consoleid"]);
            Console.WriteLine(
                "Console {0} successfully removed from the Exemption List",
                args["consoleid"]
                );
        }

    } // class ActionDevkit
} // namespace xonline.tools.xblcfg
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\XblCfg\App\actionBlob.cs ===
// --------------------------------------------------------------------------------------
// Copyright (c) Microsoft Corporation.  All rights reserved
//
// pconfig.cs
//
// XblCfg
//
// Process the Config command
// --------------------------------------------------------------------------------------

using System;
using System.Collections;
using System.Collections.Generic;
using System.Data;
using System.Data.SqlClient;
using System.Diagnostics;
using System.Globalization;
using System.IO;
using System.Net;
using System.Reflection;
using System.Security.Cryptography;
using System.Text.RegularExpressions;
using System.Xml;
using System.Xml.XPath;

using Microsoft.Webstore.WstClient;

using xonline.common.config;
using xonline.common.diagnostics;
using xonline.common.service;
using xonline.common.sql.webstore;
using xonline.common.tools.console;
using xonline.common.tools;

namespace xonline.tools.xblcfg
{
    public class ActionBlob
    {
        public void Process(NamedArgParser args)
        {
            if(args["help"] != null || args["h"] != null || args["?"] != null)
            {
                PrintUsageBlob();
                return;
            }

            if(args["add"] != null)
            {
                ProcessBlobAdd(args);
            }
            else if(args["delete"] != null)
            {
                ProcessBlobDelete(args);
            }
            else if(args["get"] != null)
            {
                ProcessBlobGet(args);
            }
            else
            {
                PrintUsageBlob();
                throw new XblCfgBadArgumentException("Missing -add, -delete or -get arguments");
            }
        }

        private static void PrintUsageBlob()
        {
//       1         2         3         4         5         6         7         8
//34567890123456789012345678901234567890123456789012345678901234567890123456789012345678
            string helpText = @" 
xblcfg.exe -blob [options...]

Notes:
    -blob is used to add/delete/get a config blob from npdb..t_config_blobs

Options:

    -add -name:<blob-name> -file:<file-name>

        adds or updates a blob. blob-name is the name of the config blob as 
        stored in t_config_blobs and referenced by applications. file-name is 
        the name of the file to store in the blob.

    -delete -name:<blob-name>

        delete a blob from the database.

    -get -name:<blob-name> -file:<file-name>

        retrieves a blob from the database and stores it in file-name.

Examples:

xblcfg -blob -add -name:xbos_wmdrm_whitelist -file:whitelist.xml
xblcfg -blob -delete -name:xbos_wmdrm_whitelist
xblcfg -blob -get -name:xbos_wmdrm_whitelist -file:whitelist_from_db.xml
";

            XblCfgConsole.Out(helpText);
        }

        private void ProcessBlobAdd(NamedArgParser args)
        {
            string blobName = args["name"];
            string fileName = args["file"];

            if(blobName == null)
            {
                throw new XblCfgBadArgumentException("Missing -name argument");
            }

            if(fileName == null)
            {
                throw new XblCfgBadArgumentException("Missing -file argument");
            }
            
            // Read the file specified in -name

            byte[] blob = null;

            using(FileStream file = new FileStream(fileName, FileMode.Open))
            {
                blob = new byte[file.Length];

                int read = file.Read(blob, 0, blob.Length);

                Assert.AreEqual(read, blob.Length);
            }

            // Write blob to database

            XblCfgConsole.Out(
                "Writting config blob '{0}' to npdb..t_config_blobs (size = {1} bytes)",
                blobName, blob.Length.ToString());

            Npdb npdb = new Npdb();
            npdb.ConfigBlobSet(blobName, blob);
        }

        private void ProcessBlobDelete(NamedArgParser args)
        {
            string blobName = args["name"];
            
            if(blobName == null)
            {
                throw new XblCfgBadArgumentException("Missing -name argument");
            }

            // delete blob from database

            XblCfgConsole.Out(
                "Deleting config blob '{0}' from npdb..t_config_blobs",
                blobName);

            Npdb npdb = new Npdb();
            if(npdb.ConfigBlobDelete(blobName))
            {
                XblCfgConsole.Out("Done.");
            }
            else
            {
                XblCfgConsole.Out("Blob not found.");
            }
        }
        
        private void ProcessBlobGet(NamedArgParser args)
        {
            string blobName = args["name"];
            string fileName = args["file"];

            if(blobName == null)
            {
                throw new XblCfgBadArgumentException("Missing -name argument");
            }

            if(fileName == null)
            {
                throw new XblCfgBadArgumentException("Missing -file argument");
            }
            
            // Read blob from database

            XblCfgConsole.Out(
                "Reading config blob '{0}' from npdb..t_config_blobs",
                blobName);

            byte[] blob = null;

            Npdb npdb = new Npdb();
            if(!npdb.ConfigBlobGet(blobName, out blob))
            {
                XblCfgConsole.Out("Blob not found.");
                return;
            }

            // Write blob to file

            using(FileStream file = new FileStream(fileName, FileMode.CreateNew))
            {
                file.Write(blob, 0, blob.Length);
            }

            XblCfgConsole.Out(
                "Wrote {0} bytes to {1}",
                blob.Length.ToString(), fileName);
        }

    } // class ActionBlob
} // namespace xonline.tools.xblcfg
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\XblCfg\App\actionMultiSetting.cs ===
// --------------------------------------------------------------------------------------
// Copyright (c) Microsoft Corporation.  All rights reserved
//
// actionMultiSetting.cs
//
// XblCfg
//
// Process the multisetoverrides command
// --------------------------------------------------------------------------------------

using System;
using System.Collections;
using System.Collections.Generic;
using System.Data;
using System.Data.SqlClient;
using System.Diagnostics;
using System.Globalization;
using System.IO;
using System.Net;
using System.Reflection;
using System.Security.Cryptography;
using System.Text.RegularExpressions;
using System.Xml;
using System.Xml.XPath;

using Microsoft.Webstore.WstClient;

using xonline.common.config;
using xonline.common.diagnostics;
using xonline.common.service;
using xonline.common.sql.webstore;
using xonline.common.tools.console;
using xonline.common.tools;

namespace xonline.tools.xblcfg
{
    public class ActionMultiSetting
    {
        public static int NumExpectedArgs_Add = 6;
        public static int NumExpectedArgs_Delete = 5;
        public static int NumExpectedArgs_DeleteAll = 1;
        public static int NumExpectedArgs_List = 1;

        public void Process(NamedArgParser args)
        {
            if(args["help"] != null || args["h"] != null || args["?"] != null)
            {
                PrintUsageBlob();
                return;
            }
            if(args["add"] != null)
            {
                ProcessMultiSetting(args);
            }
            else if(args["delete"] != null)
            {
                ProcessMultiSetting(args);
            }
            else if(args["deleteAll"] != null)
            {
                ProcessMultiSetting(args);
            }
            else if (args["list"] != null)
            {
                ProcessMultiSetting(args);
            }
            else if (args["file"] != null)
            {
                ProcessFile(args);
            }
            else
            {
                PrintUsageBlob();
                throw new XblCfgBadArgumentException("One or more required actions was not set -add -delete -deleteall -list -file");
            }
        }

        private static void PrintUsageBlob()
        {
//       1         2         3         4         5         6         7         8
//34567890123456789012345678901234567890123456789012345678901234567890123456789012345678
            string helpText = @" 
xblcfg.exe -multisetoverrides [options...]

Notes:
    -multisetoverrides is used to add/delete/update settings in npdb.t_multisetting_overrides

Options:

    -add -env:<vc_environment> [-component:<vc_component> -site:<i_site_id> -server:<ti_server>] -multisetting:<vc_multisetting> -value:<vc_value>

        Adds or Updates a Multisetting Override config setting. Each field corresponds to a field in npdb.t_multisetting_overrides 

        [env]............Environment.
        [component]......Component type setting applies to.
                                - Set to ALL to target all components.
        [site]...........Site Id that setting applies to.
                                - Set to -1 to target all sites.
        [server].........Server that setting applies to.
                                - Set to ALL to target all servers.
        [multisetting]...Multisetting name.
        [value]..........Multisetting value.

               
    -delete -env:<vc_environment> [-component:<vc_component> -site:<i_site_id> -server:<ti_server>] -multisetting:<vc_multisetting>

        Delete a multisetting from the database.

        [env]............Environment.
        [component]......Component type setting applies to.
                                - Default is ALL, which deletes only multisettings configured for all environments.
        [site]...........Site Id that setting applies to.
                                - Default is -1.
        [server].........Server that setting applies to.
                                - Default is ALL, which deletes only multisettings configured for all servers.
        [multisetting]...Multisetting name.

    -deleteAll -multisetting:<vc_setting>
        
        Deletes all references of the specified multisetting in the database
    
        [multisetting]....Multisetting name.

    -list -env:<vc_environment>

        Dumps out the current settings for the environment specified.
    
        [env]....Environment.

    -file:<file_name>
    
        Takes in a text file that contains commands to run in order.
        Each line in the file should be a new command, and follow the same
        formatting as the above commands -action <args>

    ::Examples:: 
      [-add]
        Set kdcsvc_xkdc_sgSite1Ips=65.52.254.45 and 65.52.254.46.
            xblcfg.exe -multisetoverrides -add:""Testnet ALL -1 ALL kdcsvc_xkdc_sgSite1Ips 65.52.254.45""
            xblcfg.exe -multisetoverrides -add:""Testnet ALL -1 ALL kdcsvc_xkdc_sgSite1Ips 65.52.254.46""
        Set kdcsvc_xkdc_sgSite1Ips=65.52.254.45 and 65.52.254.46.
            xblcfg.exe -multisetoverrides -add -env:testnet -component:ALL -site:-1 -server:ALL -multisetting:kdcsvc_xkdc_sgSite1Ips -value:65.52.254.45
            xblcfg.exe -multisetoverrides -add -env:testnet -component:ALL -site:-1 -server:ALL -multisetting:kdcsvc_xkdc_sgSite1Ips -value:65.52.254.46
      [-delete]
        Delete the setting kdcsvc_xkdc_sgSite1Ips in Testnet
            xblcfg.exe -multisetoverrides -delete:""Testnet ALL -1 ALL kdcsvc_xkdc_sgSite1Ips ""
        Delete the setting kdcsvc_xkdc_sgSite1Ips in Testnet
            xblcfg.exe -multisetoverrides -delete -env:testnet -component:ALL -site:-1 -server:ALL -multisetting:kdcsvc_xkdc_sgSite1Ips
      [-deleteAll]
        Delete all kdcsvc_xkdc_sgSite1Ips for all environments.
            xblcfg.exe -multisetoverrides -deleteAll:kdcsvc_xkdc_sgSite1Ips
        Delete all kdcsvc_xkdc_sgSite1Ips for all environment and all builds.
            xblcfg.exe -multisetoverrides -deleteAll -multisetting:kdcsvc_xkdc_sgSite1Ips
      [-list]
        Lists the settings for the specified environment
            xblcfg.exe -multisetoverrides -list:Testnet
        Lists the setting for the specified environment
            xblcfg.exe -multisetoverrides -list -env:Testnet
      [-file]
        Use all the commands defined in Test.txt
            xblcfg.exe -multisetoverrides -file:Test.txt


";

            XblCfgConsole.Out(helpText);
        }

        private void ListMultiSetting(NamedArgParser args)
        {
            string environment = args["env"];
            if (environment == null)
            {
                environment = args["list"];
            }

            XblCfgConsole.Out("ListMultiSettings for vc_environment: {0}\n\n", environment);

            Npdb npdb = new Npdb();
            npdb.MultiSettingList(environment);
        }
        private void ProcessFile(NamedArgParser args)
        {
            string file = args["file"];
            if (file == "")
            {
                throw new XblCfgBadArgumentException("You must specify a file to use.");
            }
            else
            {
                FileStream fs = new FileStream(file, FileMode.Open);
                StreamReader sr = new StreamReader(fs);

                string line = "";
                while((line = sr.ReadLine()) != null)
                {
                    //line = line.Replace("\"","");
                    string[] lineArgs = line.Split(new char[] {'-'}, StringSplitOptions.RemoveEmptyEntries);
                    for (int i = 0; i < lineArgs.Length; i++)
                    {
                        lineArgs[i] = string.Format("-" + lineArgs[i].Trim());
                    }
                    

                    NamedArgParser argParser = new NamedArgParser();
                    argParser.Parse(lineArgs);
                    ProcessMultiSetting(argParser);
                }
            }

        }
        private void ProcessMultiSetting(NamedArgParser args)
        {
            //<vc_environment> <vc_client_config> <si_build> <si_qfe> <ti_beta_machine> <vc_setting> <vc_value>
            string environment      = args["env"];
            string component        = args["component"];
            string site             = args["site"];
            string server           = args["server"];
            string multisetting     = args["multisetting"];
            string value            = args["value"];

            //
            // If the user only gave an add, everything should be included as the argument
            //
            if (args.Count <= 2)
            {
                if (args["add"] != null)
                {
                    UpdateMultiSetting(args["add"]);
                }
                else if (args["delete"] != null)
                {
                    DeleteMultiSetting(args["delete"]);
                }
                else if (args["deleteAll"] != null)
                {
                    DeleteMultiSettingAll(args);
                }
                else if (args["list"] != null)
                {
                    ListMultiSetting(args);
                }
                else
                {
                    PrintUsageBlob();
                    throw new XblCfgBadArgumentException("One or more required actions was not set -add -delete -deleteall -list -file");
                }
            }
            else if (args["add"] != null)
            {
                if (environment != null &&
                        multisetting != null &&
                        value != null)
                {
                    UpdateMultiSetting(string.Format("{0} {1} {2} {3} {4} {5}", environment, component, site, server, multisetting, value));
                }
                else
                {
                    PrintUsageBlob();
                    throw new XblCfgBadArgumentException("One or more required values were not set.");
                }
            }
            else if (args["delete"] != null)
            {
                if (environment != null &&
                            multisetting != null)
                {
                    DeleteMultiSetting(string.Format("{0} {1} {2} {3} {4}", environment, component, site, server, multisetting));
                }
                else
                {
                    PrintUsageBlob();
                    throw new XblCfgBadArgumentException("One or more required values were not set.");
                }
            }
            else if (args["deleteAll"] != null)
            {
                DeleteMultiSettingAll(args);
            }
            else if (args["list"] != null)
            {
                ListMultiSetting(args);
            }
            else
            {
                PrintUsageBlob();
            }
        }

        /// UpdateMultiSetting:
        /// Parse parameters for UpdateMultiSetting and invoke method
        ///
        /// Parameters:
        ///    row - -env -component -site - server -multisetting -value
        ///
        /// Returns n/a
        private void UpdateMultiSetting(string row)
        {
            XblCfgConsole.Out("UpdateMultiSetting: {0}\r\n", row);

            //
            // Break the string passed in into seperate arguments
            //
            string[] rowArgs = row.Split(' ');
            if (rowArgs.Length != NumExpectedArgs_Add)
            {
                PrintUsageBlob();
                XblCfgConsole.Out("Number of items passed to -add was invalid. Expecting {0}, got {1}", NumExpectedArgs_Add, rowArgs.Length);
                return;
            }

            //
            // Pull out the values
            //
            string environment  = rowArgs[0];
            string component    = rowArgs[1];
            string site         = rowArgs[2];
            string server       = rowArgs[3];
            string multisetting = rowArgs[4];
            string value        = rowArgs[5];
            
            if (ValidateCoupledOptionalParameters(component, site, server))
            {
                //
                // Update or add the setting
                // 
                Npdb npdb = new Npdb();
                if (AllCoupledOptionalParametersMissing(component, site, server))
                {
                    npdb.MultiSettingAdd(environment, "ALL", "-1", "ALL", multisetting, value);
                }
                else
                {
                    npdb.MultiSettingAdd(environment, component, site, server, multisetting, value);
                }
            }
            else
            {
                throw new XblCfgBadArgumentException("Component, Site, and Server all need to be set or not set.");
            }
        }

        /// DeleteMultiSetting:
        /// Parse parameters for DeleteMultiSetting and invoke method
        ///
        /// Parameters:
        ///    row - -env -component -site - server -multisetting
        ///
        /// Returns n/a
        private void DeleteMultiSetting(string row)
        {
            XblCfgConsole.Out("DeleteMultiSetting: {0}\r\n", row);

            //
            // Break the string passed in into seperate arguments
            //
            string[] rowArgs = row.Split(' ');
            if (rowArgs.Length != NumExpectedArgs_Delete)
            {
                PrintUsageBlob();
                XblCfgConsole.Out("Number of items passed to -delete was invalid. Expecting {0}, got {1}", NumExpectedArgs_Delete, rowArgs.Length);
                return;
            }

            //
            // Pull out the values
            //
            string environment = rowArgs[0];
            string component = rowArgs[1];
            string site = rowArgs[2];
            string server = rowArgs[3];
            string multisetting = rowArgs[4];

            if (ValidateCoupledOptionalParameters(component, site, server))
            {
                //
                // Update or add the setting
                // 
                Npdb npdb = new Npdb();
                if (AllCoupledOptionalParametersMissing(component, site, server))
                {
                    npdb.MultiSettingDelete(environment, "ALL", "-1", "ALL", multisetting);
                }
                else
                {
                    npdb.MultiSettingDelete(environment, component, site, server, multisetting);
                }
            }
            else
            {
                throw new XblCfgBadArgumentException("Component, Site, and Server all need to be set or not set.");
            }
        }


        /// DeleteMultiSettingAll: 
        /// Parse parameters for DeleteMultiSettingAll and invoke method
        ///
        /// Parameters:
        ///    args - -multisetting:xxx value
        ///
        /// Returns n/a
        private void DeleteMultiSettingAll(NamedArgParser args)
        {
            string multisetting = args["multisetting"];
            if (multisetting == null)
            {
                multisetting = args["deleteall"];
            }

            XblCfgConsole.Out("DeleteMultiSettingAll for vc_multisetting: {0}\r\n", multisetting);

            Npdb npdb = new Npdb();
            npdb.MultiSettingDeleteAll(multisetting);
        }

        // Validate that the required params are defined together
        // Either build, qfe, and beta need to be not set
        // of all three must be set.
        //
        private static bool ValidateCoupledOptionalParameters(string component, string site, string server)
        {
            return AllCoupledOptionalParametersPresent(component, site, server)
                || AllCoupledOptionalParametersMissing(component, site, server);
        }

        private static bool AllCoupledOptionalParametersPresent(string component, string site, string server)
        {
            return !String.IsNullOrEmpty(component) && !String.IsNullOrEmpty(site) && !String.IsNullOrEmpty(server);
        }

        private static bool AllCoupledOptionalParametersMissing(string component, string site, string server)
        {
            return String.IsNullOrEmpty(component) && String.IsNullOrEmpty(site) && String.IsNullOrEmpty(server);
        }

    } // class ActionMultiSetting
} // namespace xonline.tools.xblcfg
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\XblCfg\App\actionHive.cs ===
// --------------------------------------------------------------------------------------
// Copyright (c) Microsoft Corporation.  All rights reserved
//
// actionHive.cs
//
// XblCfg
//
// Process the hive command
// --------------------------------------------------------------------------------------

using System;
using System.Collections;
using System.Collections.Generic;
using System.Data;
using System.Data.SqlClient;
using System.Diagnostics;
using System.Globalization;
using System.IO;
using System.Net;
using System.Reflection;
using System.Security.Cryptography;
using System.Text;
using System.Text.RegularExpressions;
using System.Xml;
using System.Xml.XPath;

using Microsoft.Webstore.WstClient;

using xonline.common.config;
using xonline.common.diagnostics;
using xonline.common.service;
using xonline.common.sql.webstore;
using xonline.common.tools.console;
using xonline.common.tools;

namespace xonline.tools.xblcfg
{
    public class ActionHive
    {
        public static int NumExpectedArgs_Delete = 6;
        public static int NumExpectedArgs_DeleteAll = 1;
        public static int NumExpectedArgs_List = 1;

        public void Process(NamedArgParser args)
        {
            if(args["help"] != null || args["h"] != null || args["?"] != null)
            {
                PrintUsageBlob();
                return;
            }
            if(args["add"] != null)
            {
                ProcessHive(args);
            }
            else if(args["delete"] != null)
            {
                ProcessHive(args);
            }
            else if(args["deleteAll"] != null)
            {
                ProcessHive(args);
            }
            else if (args["list"] != null)
            {
                ProcessHive(args);
            }
            else if (args["file"] != null)
            {
                ProcessFile(args);
            }
            else
            {
                PrintUsageBlob();
                throw new XblCfgBadArgumentException("One or more required actions was not set -add -delete -deleteall -list -file");
            }
        }

        private static void PrintUsageBlob()
        {
//       1         2         3         4         5         6         7         8
//34567890123456789012345678901234567890123456789012345678901234567890123456789012345678
            string helpText = @" 
xblcfg.exe -hive [options...]

Notes:
    -hive is used to add/delete/update a live registry settings in npdb.t_live_registry_settings

Options:

    -add -env:<vc_environment> -client:<vc_client_config> -build:<si_build> -qfe:<si_qfe> -beta:<guid_beta_group_id> -setting:<vc_setting> -value:<vc_value>

        Adds or Updates a Hive config setting. Each field corresponds to a row in npdb.t_live_registry_settings 

        [env]............Environment.
        [client].........Client type to return the setting for.
        [build]..........Build number that setting applies to.
                                - Set to NULL to target all builds.
        [qfe]............QFE number that setting applies to.
                                - Set to NULL to target all builds.
        [beta]...........Beta group that the setting applies to.
                                - Set to {00000000-0000-0000-0000-000000000000} to target all consoles
                                - Set to beta group guid in t_beta_groups to target a beta.
        [setting]........Setting name.
        [value]..........Setting value.

        ::Note::
            1. If beta is set, build and qfe must not be NULL.
            2. build and qfe must always be set together. 
               
    -delete -env:<vc_environment> -client:<vc_client_config> -build:<si_build> -qfe:<si_qfe> -beta:<guid_beta_group_id> -setting:<vc_setting>

        Delete a setting from the database.

        [env]............Environment.
        [client].........Client type to return the setting for.
        [build]..........Build number that setting applies to.
                                - Set to NULL to target all builds.
        [qfe]............QFE number that setting applies to.
                                - Set to NULL to target all builds.
        [beta]...........Beta group that the setting applies to.
                                - Set to {00000000-0000-0000-0000-000000000000} to target all consoles
                                - Set to beta group guid in t_beta_groups to target a beta.
        [setting]........Setting name.

    -deleteAll -setting:<vc_setting>
        
        Deletes all references of the specified setting in the database
    
        [setting]........Setting name.

    -list -env:<vc_environment>

        Dumps out the current settings for the environment specified.
    
        [env]....Environment.

    -file:<file_name>
    
        Takes in a text file that contains commands to run in order.
        Each line in the file should be a new command, and follow the same
        formatting as the above commands -action <args>

    ::Examples:: 
      [-add]
        Set FakeTestSetting=1000 for xenon users running 6690.0 who are not beta users.
            xblcfg.exe -hive -add -env:testnet -client:xenon -build:6690 -qfe:0 -beta:{00000000-0000-0000-0000-000000000000} -setting:FakeTestSetting -value:1000
        Set FakeTestSetting=1000 for xenon users running any build.
            xblcfg.exe -hive -add -client:Testnet -client:xenon -build:NULL -qfe:NULL -beta:{00000000-0000-0000-0000-000000000000} -setting:FakeTestSetting -value:1000
        Set FakeTestSetting=1000 for xenon users running any build.
            xblcfg.exe -hive -add -env:testnet -client:xenon -build:NULL -qfe:NULL -beta:{00000000-0000-0000-0000-000000000000}  -setting:FakeTestSetting -value:1000
      [-delete]
        Delete the setting FakeTestSetting in Testnet for build 6690.0
            xblcfg.exe -hive -delete -env:testnet -client:xenon -build:6690 -qfe:0 -beta:{00000000-0000-0000-0000-000000000000} -setting:FakeTestSetting
        Delete the setting FakeTestSetting in Testnet for build 6690.0
            xblcfg.exe -hive -delete -env:testnet -client:xenon -build:NULL -qfe:NULL -beta:{00000000-0000-0000-0000-000000000000} -setting:FakeTestSetting
      [-deleteAll]
        Delete all FakeTestSetting for all environment and all builds.
            xblcfg.exe -hive -deleteAll:FakeTestSetting
        Delete all FakeTestSetting for all environment and all builds.
            xblcfg.exe -hive -deleteAll setting:FakeTestSetting
      [-list]
        Lists the setting for the specified environment
            xblcfg.exe -hive -list:Testnet
        Lists the setting for the specified environment
            xblcfg.exe -hive -list -env:Testnet
      [-file]
        Use all the commands defined in Test.txt
            xblcfg.exe -hive -file:Test.txt


";

            XblCfgConsole.Out(helpText);
        }

        private void ListHive(NamedArgParser args)
        {
            string environment = args["env"];
            if (environment == null)
            {
                environment = args["list"];
            }

            XblCfgConsole.Out("ListHiveSettings: {0}", environment);

            Npdb npdb = new Npdb();
            npdb.HiveList(environment);
        }
        private void ProcessFile(NamedArgParser args)
        {
            string file = args["file"];
            if (file == "")
            {
                throw new XblCfgBadArgumentException("You must specify a file to use.");
            }
            else
            {
                FileStream fs = new FileStream(file, FileMode.Open);
                StreamReader sr = new StreamReader(fs);

                string line = "";
                while((line = sr.ReadLine()) != null)
                {
                    //line = line.Replace("\"","");

                    // This is pretty hacky, but so be it. We split on the '-' symbol, and that works for everything except for the beta flag,
                    // which has '-'s in it, since it's a guid. So we first go ahead and split the string, then, if we find the beta flag,
                    // we fudge it a little and adjust our index.
                    string[] lineArgsOrig = line.Split(new char[] {'-'}, StringSplitOptions.RemoveEmptyEntries);
                    List<string> lineArgsTrimmed = new List<string>(lineArgsOrig.Length);
                    for (int i = 0; i < lineArgsOrig.Length; i++)
                    {
                        if (lineArgsOrig[i].StartsWith("beta"))
                        {
                            StringBuilder sb = new StringBuilder(5);
                            for (int idxBeta = 0; idxBeta < 5; ++idxBeta)
                            {
                                sb.AppendFormat("-{0}", lineArgsOrig[i + idxBeta].Trim());
                            }
                            lineArgsTrimmed.Add(sb.ToString());
                            i += 4;
                        }
                        else
                        {
                            lineArgsTrimmed.Add(String.Format("-{0}", lineArgsOrig[i].Trim()));
                        }
                    }

                    NamedArgParser argParser = new NamedArgParser();
                    argParser.Parse(lineArgsTrimmed.ToArray());
                    ProcessHive(argParser);
                }
            }

        }
        private void ProcessHive(NamedArgParser args)
        {
            //<vc_environment> <vc_client_config> <si_build> <si_qfe> <guid_beta_group_id> <vc_setting> <vc_value>
            string environment      = args["env"];
            string clientConfig     = args["client"];
            string build            = args["build"];
            string qfe              = args["qfe"];
            string beta             = args["beta"];
            string setting          = args["setting"];
            string value            = args["value"];

            if (args.Count <= 2)
            {
                if (args["deleteAll"] != null)
                {
                    DeleteHiveSettingAll(args);
                }
                else if (args["list"] != null)
                {
                    ListHive(args);
                }
                else
                {
                    PrintUsageBlob();
                    throw new XblCfgBadArgumentException("One or more required actions was not set -add -delete -deleteall -list -file");
                }
            }
            else if (args["add"] != null)
            {
                if (environment != null &&
                        clientConfig != null &&
                        build != null &&
                        qfe != null &&
                        beta != null &&
                        setting != null &&
                        value != null)
                {
                    UpdateHiveSetting(environment, clientConfig, build, qfe, beta, setting, value);
                }
                else
                {
                    PrintUsageBlob();
                    throw new XblCfgBadArgumentException("One or more required values were not set.");
                }
            }
            else if (args["delete"] != null)
            {
                if (environment != null &&
                            clientConfig != null &&
                            build != null &&
                            qfe != null &&
                            beta != null &&
                            setting != null)
                {
                    DeleteHiveSetting(environment, clientConfig, build, qfe, beta, setting);
                }
                else
                {
                    PrintUsageBlob();
                    throw new XblCfgBadArgumentException("One or more required values were not set.");
                }
            }
            else if (args["deleteAll"] != null)
            {
                DeleteHiveSettingAll(args);
            }
            else if (args["list"] != null)
            {
                ListHive(args);
            }
            else
            {
                PrintUsageBlob();
            }
        }

        private void UpdateHiveSetting(string environment, string clientConfig, string build, string qfe, string beta, string setting, string value)
        {
            XblCfgConsole.Out("UpdateHiveSetting: {0} {1} {2} {3} {4} {5}", environment, clientConfig, build, qfe, beta, setting);

            //
            // Validate that the required params are defined together
            // Either build, qfe, and beta need to be not set
            // of all three must be set.
            //
            if ((build == null && qfe == null && beta == null) ||
                (build != null && qfe != null && beta != null))
            {
                //
                // Update or add the setting
                // 
                Npdb npdb = new Npdb();
                if (build == null && qfe == null && beta == null)
                {
                    npdb.HiveAdd(environment, clientConfig, "NULL", "NULL", Guid.Empty, setting, value);
                }
                else
                {
                    Guid betaGroupGuid;

                    try
                    {
                        betaGroupGuid = new Guid(beta);
                    }
                    catch
                    {
                        throw new XblCfgBadArgumentException("Beta argument is not a properly formatted guid.");
                    }

                    npdb.HiveAdd(environment, clientConfig, build, qfe, betaGroupGuid, setting, value);
                }
            }
            else
            {
                throw new XblCfgBadArgumentException("Build, QFE, and beta all need to be set or not set.");
            }
        }

        private void DeleteHiveSetting(string environment, string clientConfig, string build, string qfe, string beta, string setting)
        {
            XblCfgConsole.Out("DeleteHiveSetting: {0} {1} {2} {3} {4} {5}", environment, clientConfig, build, qfe, beta, setting);

            //
            // Validate that the required params are defined together
            // Either build, qfe, and beta need to be not set
            // of all three must be set.
            //
            if ((build == null && qfe == null && beta == null) ||
                (build != null && qfe != null && beta != null))
            {
                //
                // Update or add the setting
                // 
                Npdb npdb = new Npdb();
                if (build == null && qfe == null && beta == null)
                {
                    npdb.HiveDelete(environment, clientConfig, "NULL", "NULL", Guid.Empty, setting);
                }
                else
                {
                    Guid betaGroupGuid;

                    try
                    {
                        betaGroupGuid = new Guid(beta);
                    }
                    catch
                    {
                        throw new XblCfgBadArgumentException("Beta argument is not a properly formatted guid.");
                    }

                    npdb.HiveDelete(environment, clientConfig, build, qfe, betaGroupGuid, setting);
                }
            }
            else
            {
                throw new XblCfgBadArgumentException("Build, QFE, and beta all need to be set or not set.");
            }
        }


        private void DeleteHiveSettingAll(NamedArgParser args)
        {
            string setting = args["setting"];
            if (setting == null)
            {
                setting = args["deleteall"];
            }

            XblCfgConsole.Out("DeleteHiveSettingAll: {0}", setting);

            Npdb npdb = new Npdb();
            npdb.HiveDeleteAll(setting);
        }

    } // class ActionHive
} // namespace xonline.tools.xblcfg
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\XblCfg\App\actionGroups.cs ===
// -----------------------------------------------------------------------
//
// Implements the -groups command for XblCfg.exe
//
// -----------------------------------------------------------------------

using System;
using System.Collections.Generic;
using System.IO;
using System.Security.Principal;
using System.Globalization;

using xonline.common.service;
using xonline.common.tools.console;
using xonline.common.user;
using xonline.common.utilities;

namespace xonline.tools.xblcfg
{
    public class ActionGroups
    {
        internal void Process(NamedArgParser args)
        {
            if (args["help"] != null || args["h"] != null || args["?"] != null)
            {
                PrintUsageBlob();
                return;
            }
            else if (args["list"] != null)
            {
                ProcessList(args);
            }
            else if (args["machinelookup"] != null)
            {
                ProcessMachineLookup(args);
            }
            else if (args["create"] != null)
            {
                ProcessCreate(args);
            }
            else if (args["add"] != null)
            {
                ProcessAdd(args);
            }
            else if (args["remove"] != null)
            {
                ProcessRemove(args);
            }
            else
            {
                PrintUsageBlob();
                throw new XblCfgBadArgumentException("One or more required actions was not set for -groups: ");
            }
        }

        /// <summary>
        /// Attempts to convert the given string (either CID or PUID) to a Puid array
        /// <summary>
        bool TryConvertStringToPuids(string line, out Puid[] machinePuids)
        {
            UInt64 value = 0;
            bool ret = false;
            machinePuids = null;
            if (line == null)
            {
                return false;
            }
            //
            // If this is a Console id call MachineManager to get the list of Puids
            //
            if (line.Length > 2 && line[2] == '.')
            {
                return MachineManager.TryLookupMachinePuids(line, out machinePuids);
            }
            else if (line.ToLower().StartsWith("0x", true, CultureInfo.CurrentCulture))
            {
                //
                // Hex Specifier assume this is base 16
                //
                try
                {
                    value = Convert.ToUInt64(line.Substring(2), 16);
                    ret = true;
                }
                catch
                {
                }
            }
            else
            {
                //
                // First attempt to convert the string as base 10 if that fails
                // then attempt to convert as base 16.
                //
                try
                {
                    value = (UInt64)Convert.ToInt64(line, 10);
                    ret = true;
                }
                catch (System.FormatException)
                {
                    try
                    {
                        value = Convert.ToUInt64(line, 16);
                        ret = true;
                    }
                    catch
                    {
                    }
                }
                catch
                {
                }
            }
            if (ret == true)
            {
                machinePuids = new Puid[1];
                machinePuids[0] = value;
            }
            return ret;
        }

        private void ProcessAdd(NamedArgParser args)
        {
            string groupIdString = args["groupId"];
            string fileName = args["file"];
            Guid groupId = Guid.Empty;
            BetaGroup group;
            if (String.IsNullOrEmpty(groupIdString) || String.IsNullOrEmpty(fileName))
            {
                PrintUsageBlob();
                throw new XblCfgBadArgumentException(String.Format("-{0} requires -groupId and -file", "add"));
            }
            else if (groupIdString != null && !TryParseGuid(groupIdString, ref groupId))
            {
                PrintUsageBlob();
                throw new XblCfgBadArgumentException(String.Format("group \"{0}\" is not a properly formatted guid", groupIdString));
            }
            else if (!BetaGroupManager.TryGetBetaGroup(groupId, out group))
            {
                PrintUsageBlob();
                throw new XblCfgBadArgumentException(String.Format("group {0:B} does not exist", groupId));
            }
            else if (fileName != null && !File.Exists(fileName))
            {
                PrintUsageBlob();
                throw new XblCfgBadArgumentException(String.Format("cannot open file \"{0}\"", fileName));
            }
            else
            {
                StreamReader reader = new StreamReader(fileName);
                Guid existingGuid = Guid.Empty;
                while (!reader.EndOfStream)
                {
                    string line = reader.ReadLine();
                    Puid[] machinePuids = null;

                    if (TryConvertStringToPuids(line, out machinePuids))
                    {
                        foreach (Puid machinePuid in machinePuids)
                        {
                            string consoleIdString = line;
                            //
                            // Xbox1 CIDs do not contain the SN. in the DB but they are displayed with SN.
                            // bug bug: I'm not even sure why there is any Xbox1 code in here.
                            //
                            if (!consoleIdString.ToUpper().StartsWith("SN."))
                            {
                                try
                                {
                                    consoleIdString = ConsoleIdUtil.GetXbox360ConsoleIdStringFromMachineId(machinePuid);
                                }
                                catch
                                {
                                }
                            }
                            if (BetaGroupManager.TryGetBetaGroupForMachine(machinePuid, out existingGuid))
                            {
                                XblCfgConsole.Out("console {0} ({1}) already in group {2:B}", consoleIdString, machinePuid.ToString(), existingGuid);
                            }
                            else
                            {
                                XblCfgConsole.Out("adding Console {0} ({1}) to group {2:B}", consoleIdString, machinePuid.ToString(), groupId);
                                BetaGroupManager.AddRemoveMachineGroup(machinePuid, groupId, true);
                            }
                        }
                    }
                    else
                    {
                        XblCfgConsole.Out("console {0} does not exist", line);
                    }
                }
            }
        }

        private void ProcessRemove(NamedArgParser args)
        {
            string groupIdString = args["groupId"];
            string fileName = args["file"];
            Guid groupId = Guid.Empty;
            BetaGroup group;
            if (String.IsNullOrEmpty(groupIdString) || String.IsNullOrEmpty(fileName))
            {
                PrintUsageBlob();
                throw new XblCfgBadArgumentException(String.Format("-{0} requires -groupId and -file", "remove"));
            }
            else if (groupIdString != null && !TryParseGuid(groupIdString, ref groupId))
            {
                PrintUsageBlob();
                throw new XblCfgBadArgumentException(String.Format("group \"{0}\" is not a properly formatted guid", groupIdString));
            }
            else if (!BetaGroupManager.TryGetBetaGroup(groupId, out group))
            {
                PrintUsageBlob();
                throw new XblCfgBadArgumentException(String.Format("group {0:B} does not exist", groupId));
            }
            else if (fileName != null && !File.Exists(fileName))
            {
                PrintUsageBlob();
                throw new XblCfgBadArgumentException(String.Format("cannot open file \"{0}\"", fileName));
            }
            else
            {
                StreamReader reader = new StreamReader(fileName);
                Guid existingGuid = Guid.Empty;
                while (!reader.EndOfStream)
                {
                    string line = reader.ReadLine();
                    Puid[] machinePuids = null;

                    if (TryConvertStringToPuids(line, out machinePuids))
                    {
                        foreach (Puid machinePuid in machinePuids)
                        {
                            string consoleIdString = line;
                            if (!consoleIdString.ToUpper().StartsWith("SN."))
                            {
                                try
                                {
                                    consoleIdString = ConsoleIdUtil.GetXbox360ConsoleIdStringFromMachineId(machinePuid);
                                }
                                catch
                                {
                                }
                            }
                            XblCfgConsole.Out("Removing Console {0} ({1}) from group {2:B}", consoleIdString, machinePuid.ToString(), groupId);
                            BetaGroupManager.AddRemoveMachineGroup(machinePuid, groupId, false);
                        }
                    }
                    else
                    {
                        XblCfgConsole.Out("Console {0} does not exist", line);
                    }

                }
            }
        }

        private void ProcessCreate(NamedArgParser args)
        {
            string friendlyName = args["friendlyname"];
            if (String.IsNullOrEmpty(friendlyName))
            {
                PrintUsageBlob();
                throw new XblCfgBadArgumentException("-create requires a friendly name");
            }
            else
            {
                string groupIdString = args["groupId"];
                Guid groupId = Guid.NewGuid();
                if (groupIdString != null && groupIdString == String.Empty)
                {
                    PrintUsageBlob();
                    throw new XblCfgBadArgumentException("-groupId requires a guid");
                }
                else if (groupIdString != null && !TryParseGuid(groupIdString, ref groupId))
                {
                    PrintUsageBlob();
                    throw new XblCfgBadArgumentException(String.Format("group \"{0}\" is not a properly formatted guid", groupIdString));
                }
                else if (friendlyName.Length > BetaGroupManager.MAX_FRIENDLY_NAME_LENGTH)
                {
                    throw new XblCfgBadArgumentException(String.Format("friendly name {0} too long", friendlyName));
                }
                else
                {
                    IEnumerable<BetaGroup> betaGroups = BetaGroupManager.GetAllBetaGroups();

                    foreach (BetaGroup betaGroup in betaGroups)
                    {
                        if (betaGroup.Id == groupId)
                        {
                            throw new XblCfgBadArgumentException(String.Format("groupId {0:B} already exists", groupId));
                        }
                        else if (betaGroup.Name == friendlyName)
                        {
                            throw new XblCfgBadArgumentException(String.Format("friendly name {0} already exists", friendlyName));
                        }
                    }

                    BetaGroupManager.CreateGroup(groupId, friendlyName, WindowsIdentity.GetCurrent().Name);
                    XblCfgConsole.Out("Created group \"{0}\" with id {1:B}.", friendlyName, groupId);
                }
            }
        }

        private void ProcessMachineLookup(NamedArgParser args)
        {
            string machine = args["machinelookup"];
            Puid[] machinePuids = new Puid[0];
            Guid groupId = Guid.Empty;
            Machine machineVerify = new Machine();

            if (String.IsNullOrEmpty(machine))
            {
                PrintUsageBlob();
                throw new XblCfgBadArgumentException("-machineLookup requires a machine to lookup");
            }
            else if (!TryConvertStringToPuids(machine, out machinePuids))
            {
                throw new XblCfgBadArgumentException(String.Format("console {0} does not exist", machine));
            }
            else
            {
                bool found = false;

                foreach (Puid machinePuid in machinePuids)
                {
                    if (BetaGroupManager.TryGetBetaGroupForMachine(machinePuid, out groupId))
                    {
                        found = true;
                        if (!machine.ToUpper().StartsWith("SN."))
                        {
                            try
                            {
                                machine = ConsoleIdUtil.GetXbox360ConsoleIdStringFromMachineId(machinePuid);
                            }
                            catch
                            {
                            }
                        }
                        XblCfgConsole.Out("Console {0} ({1}) is in group {2:B}", machine, machinePuid, groupId);
                    }
                }

                if (found == false)
                {
                    XblCfgConsole.Out("Console {0} is not in a group", machine);
                }
            }
        }

        private bool TryParseGuid(string s, ref Guid guid)
        {
            guid = Guid.Empty;
            try
            {
                guid = new Guid(s);
            }
            catch (Exception e)
            {
                if (e is FormatException || e is OverflowException)
                {
                    return false;
                }
                else
                {
                    throw;
                }
            }
            return true;
        }

        private void ProcessList(NamedArgParser args)
        {
            string groupId = args["groupId"];
            BetaGroup group = null;
            if (groupId == null)
            {
                ListAllGroups();
            }
            else if (groupId == String.Empty)
            {
                PrintUsageBlob();
                throw new XblCfgBadArgumentException("-group requires a groupId");
            }
            else if (!BetaGroupManager.TryGetBetaGroup(new Guid(groupId), out group))
            {
                PrintUsageBlob();
                throw new XblCfgBadArgumentException(String.Format("group {0} does not exist", groupId));
            }
            else
            {
                bool showPuid = false;
                if (args["puid"] != null)
                {
                    showPuid = true;
                }
                ListGroup(group, showPuid);
            }
        }

        private void ListAllGroups()
        {
            foreach (BetaGroup group in BetaGroupManager.GetAllBetaGroups())
            {
                XblCfgConsole.Out("{0:B} \"{1}\"", group.Id, group.Name);
            }
        }

        private void ListGroup(BetaGroup group, bool showPuid)
        {
            PrintGroupHeader(group);
            ListGroupMachines(group, showPuid);
        }

        private void PrintGroupHeader(BetaGroup group)
        {
            XblCfgConsole.Out("Group {0:B}:", group.Id);
            XblCfgConsole.Out("\tFriendly Name:\t{0}", group.Name);
            XblCfgConsole.Out("\tCreated By:\t{0}", group.CreatedBy);
            XblCfgConsole.Out("\tCreated Time:\t{0}", group.Created);
            XblCfgConsole.Out("\n");
        }

        private void ListGroupMachines(BetaGroup group, bool showPuid)
        {
            foreach (ulong machineId in BetaGroupManager.GetMachinesForBetaGroup(group.Id))
            {
                string consoleId;
                MachineManager.TryLookupConsoleId(machineId, out consoleId);
                if (showPuid)
                {
                    XblCfgConsole.Out("{0}, 0x{1:X016}, {2}", consoleId, machineId, (long)machineId);
                }
                else
                {
                    XblCfgConsole.Out("{0}", consoleId);
                }
            }
        }

        private void PrintUsageBlob()
        {
            string helpText = @" 
xblcfg.exe -groups.hidden [options...]

Notes:
    This functionality is deprecated. Yellow Door is the supported way to do this. 

    -groups.hidden is used to modify beta groups. You can create and delete groups, as well as add and remove machines from existing groups.

Options:
    -list -groupId:<group id> [-puid]
        Lists group members for specified group. Optional -puid shows machine PUID with console ID

    -machineLookup:<console id>
        Looks up group membership for a specified machine.

    -create -friendlyName:<friendly name in quotes> [-groupId:<group id>]
        Creates a new group with the friendly name passed in. If you pass in a group id, we will use that,
        otherwise we will generate one.

    -add -groupId:<group id> -file:<file name>
        Adds all the console ids or machine PUIDs in the file to the given group id.

    -remove -groupId:<group id> -file:<file name>
        Removes all the console ids or machine PUIDs in the file from the given group id.
";
            XblCfgConsole.Out(helpText);
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\XblCfg\App\exe\obj\i386\_generated.cs ===
[assembly:System.Runtime.InteropServices.ComVisible(false)]
[assembly:System.Reflection.AssemblyVersion("12.4.56.0")]
[assembly:System.Reflection.AssemblyProduct("DEPOT")]
[assembly:System.Reflection.AssemblyCopyright("")]
[assembly:System.Reflection.AssemblyCompany("")]
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\XblCfg\App\actionServer.cs ===
// --------------------------------------------------------------------------------------
// Copyright (c) Microsoft Corporation.  All rights reserved
//
// actionServer.cs
//
// XblCfg
//
// Process the Config command
// --------------------------------------------------------------------------------------

using System;
using System.Collections;
using System.Collections.Generic;
using System.Diagnostics;
using System.Net;
using System.Net.NetworkInformation;
using System.Net.Sockets;
using System.Text;

using xonline.common.config;
//using xonline.common.diagnostics;
//using xonline.common.service;
using xonline.common.tools.console;
using xonline.common.tools;

namespace xonline.tools.xblcfg
{
    public class ActionServer
    {
        public void Process(NamedArgParser args)
        {
            if(args["help"] != null || args["h"] != null || args["?"] != null)
            {
                PrintUsageBlob();
                return;
            }

            // set the npdb server if it exists
            if (args["npdbServer"] != null)
            {
                Config.NpdbServer = args["npdbServer"];
            }
            if (args["npdbDatabase"] != null)
            {
                Config.NpdbDatabase = args["npdbDatabase"];
            }

            if (args["add"] != null)
            {
                ProcessServerAdd(args);
            }
            else if(args["addsg"] != null)
            {
                ProcessSGServerAdd(args);
            }
            else if(args["delete"] != null)
            {
                ProcessServerDelete(args);
            }
            else
            {
                PrintUsageBlob();
                throw new XblCfgBadArgumentException("Missing -add or -delete arguments");
            }
        }

        private static void PrintUsageBlob()
        {
//       1         2         3         4         5         6         7         8
//34567890123456789012345678901234567890123456789012345678901234567890123456789012345678
            string helpText = @" 
xblcfg.exe -server [options...]

Notes:
    -server is used to add/delete a server config from t_servers and
            t_server_nics

Options:

    -add [-npdbServer:<server>] [-npdbDatabase:<database>] [-site:<site_id>] [-xblob]

    Adds a server and a nic to npdb.  Attempts to find and add both internet and
    datacenter nic to the tables.  If -xblob is specified, will force addition
    of both internet and datacenter network interfaces

    -addsg [-npdbServer:<server>] [-npdbDatabase:<database>] [-site:<site_id>]
      -nic:<nic_role> -ip:<ip_address> -netmask:<ip_netmask> -gateway:<ip_gateway>
      [-mac:<mac_address>]
      -sgipbegin:<pool_starting_ip> -sgipend:<pool_ending_ip>
      -sgportbegin:<pool_starting_port> -sgportend:<pool_ending_port>

    Adds a server and a nic with sg specific details.  If not explicitly specified,
    the code will perform an autodiscovery of the mac address based on network addresses
    that are not bound to a particular network address.  Multiple calls can be made to
    add all of the nics for the sgsvc interface.

    -addsg [-npdbServer:<server>] [-npdbDatabase:<database>] [-site:<site_id>] -xblob

    Adds the configuration for the SG in an xblob configuration.  Assumes that there
    is one network adapter, and that will be used for both internet and datacenter
    nic configuration

    -delete [-npdbServer:<npdb>] [-npdbDatabase:<database>] [-nic:<nic_role>] [-sg]

    delete a server and associated nics from the database. If there are
    interfaces still bound to this server, the data will be left untouched.
    If -sg is spcified, the sg specific nic roles will be removed.

    Optionally can specify a single nic role to delete instead of the whole server.

Examples:

";

            XblCfgConsole.Out(helpText);
        }

        private void ProcessServerAdd(NamedArgParser args)
        {
            string serverName = Environment.MachineName;

            int siteId = 1;
            if (args["site"] != null && !Int32.TryParse(args["site"], out siteId))
            {
                throw new XblCfgBadArgumentException("Invalid -site argument");
            }

            XblCfgConsole.Out("Attempting to register '{0}' and associated network interfaces to npdb\n", serverName);
            // Attempt to find the MAC address from the list registered on the server

            NetworkInterface[] networks = GetNetworkInterfaces();

            // Add the middle_tier IP configuration
            IPAddress dmzIP = FindDatacenterIP();
            NetworkInterface dmzNet = FindDatacenterAddress(networks, dmzIP);

            IPAddress gateway;
            IPAddress netmask;
            GetNetmaskAndGatewayForIP(dmzNet, dmzIP, out netmask, out gateway);

            Npdb npdb = new Npdb();

            // Add the datacenter configuration
            npdb.AddServer(serverName, siteId, "middle_tier", dmzIP, netmask, gateway, dmzNet.GetPhysicalAddress(),
                null, null, 0, 0);

            // See if there is a secondary nic that should be bound to the internet side
            NetworkInterface net = FindInternetAddress(networks, dmzIP);

            // No secondary nic, but this is an xblob, so fake the internet nic to be the same as the datacenter nic
            if (net == null && args["xblob"] != null)
            {
                net = dmzNet;
            }

            if (net != null)
            {
                IPAddress intIP = FindNetworkIPAddress(net);
                GetNetmaskAndGatewayForIP(net, intIP, out netmask, out gateway);

                npdb.AddServer(serverName, siteId, "internet_tier", intIP, netmask, gateway, net.GetPhysicalAddress(),
                    null, null, 0, 0);
            }
            else
            {
                XblCfgConsole.Out("Only one TCP/IP bound network interface discovered, skipping configuration of 'internet_tier' nic role.\n");
            }
        }

        private void ProcessSGServerAdd(NamedArgParser args)
        {
            string serverName = Environment.MachineName;

            int siteId = 1;
            if (args["site"] != null && !Int32.TryParse(args["site"], out siteId))
            {
                throw new XblCfgBadArgumentException("Invalid -site argument");
            }

            IPAddress ip;
            IPAddress netmask;
            IPAddress gateway;

            Npdb npdb = new Npdb();
            if (args["xblob"] != null)
            {
                NetworkInterface[] networks = GetNetworkInterfaces();

                if (networks.Length > 1)
                {
                    throw new XblCfgBadArgumentException("Too many networks discovered for xblob configuration.");
                }

                ip = FindDatacenterIP();

                // The code now is going to assume that the SG IP Pool range is 192.168.X.Y, where X.Y is the IP suffix of the main
                // address.
                byte[] ipBytes = ip.GetAddressBytes();
                ipBytes[0] = 192;
                ipBytes[1] = 168;
                IPAddress ipPool = new IPAddress(ipBytes);
                GetNetmaskAndGatewayForIP(networks[0], ip, out netmask, out gateway);

                npdb.AddServer(serverName, siteId, "internet_tier_sg1", ip, netmask, gateway, networks[0].GetPhysicalAddress(),
                    null, null, 0, 0);

                IPAddress zero = new IPAddress(0);
                npdb.AddServer(serverName, siteId, "middle_tier_sg", zero, zero, null, networks[0].GetPhysicalAddress(),
                    ipPool, ipPool, 1, 65534);
                return;
            }

            string nicRole = args["nic"];
            if (nicRole == null)
            {
                throw new XblCfgBadArgumentException("Missing -nic argument");
            }

            XblCfgConsole.Out("Attempting to register network interface '{0}' for server '{1}' to npdb\n", nicRole, serverName);

            if (args["ip"] == null || !IPAddress.TryParse(args["ip"], out ip))
            {
                throw new XblCfgBadArgumentException("Missing or Invalid -ip argument");
            }

            if (args["netmask"] == null || !IPAddress.TryParse(args["netmask"], out netmask))
            {
                throw new XblCfgBadArgumentException("Missing or Invalid -netmask argument");
            }

            if (args["gateway"] == null || !IPAddress.TryParse(args["gateway"], out gateway))
            {
                throw new XblCfgBadArgumentException("Missing or Invalid -gateway argument");
            }

            IPAddress sgPoolStartIP = null, sgPoolEndIP = null;
            ushort sgPoolStartPort = 0, sgPoolEndPort = 0;

            if (nicRole == "middle_tier_sg")
            {
                if (args["sgipbegin"] == null || !IPAddress.TryParse(args["sgipbegin"], out sgPoolStartIP) ||
                    args["sgipend"] == null || !IPAddress.TryParse(args["sgipend"], out sgPoolEndIP) ||
                    args["sgportbegin"] == null || !UInt16.TryParse(args["sgportbegin"], out sgPoolStartPort) ||
                    args["sgportend"] == null || !UInt16.TryParse(args["sgportend"], out sgPoolEndPort))
                {
                    throw new XblCfgBadArgumentException("Missing or invalid SG pool info");
                }
            }

            PhysicalAddress mac = PhysicalAddress.None;
            if (!String.IsNullOrEmpty(args["mac"]))
            {
                try
                {
                    mac = PhysicalAddress.Parse(args["mac"]);
                }
                catch (FormatException)
                {
                    throw new XblCfgBadArgumentException("Invalid MAC address");
                }

                AddressInfo[] addrs = GetMacAddresses();
                if (!Array.Exists(addrs, delegate(AddressInfo a) { return a.mac == mac; }))
                {
                    throw new XblCfgBadArgumentException("Configured mac address does not match any address found on computer.  Found addresses: "+ 
                        GetMacListString(addrs));
                }
            }
            else
            {
                // Attempt to find the MAC address from the list registered on the server

                // Step 1: Find all of the ethernet adapters that are registered with TCP/IP
                NetworkInterface[] networks = GetNetworkInterfaces();

                // Step 2: Get the list of NICs on the machine that do not map to an IP
                AddressInfo[] addresses = GetUnboundAddresses();

                IPAddress dmzIP = FindDatacenterIP();
                // Depending on the role, get the appropriate mac address.
                if (nicRole.StartsWith("internet_tier", StringComparison.InvariantCultureIgnoreCase))
                {
                    // For the internet-facing nics, the mapping will tend to point to the server which
                    // doesn't have anything bound to it.
                    if (addresses.Length == 1)
                    {
                        mac = addresses[0].mac;
                    }
                    else if (addresses.Length == 0)
                    {
                        // This may be a condensed environment where there are two IPs, and no dedicated SG NIC.  Find the
                        // internet IP and use that to determine the relevant mac address.
                        NetworkInterface n = FindInternetAddress(networks, dmzIP);
                        mac = n != null ? n.GetPhysicalAddress() : networks[0].GetPhysicalAddress();
                    }
                    else
                    {
                        XblCfgConsole.Out("Multiple unbound NICs found, attempting to resolve correct mac to use.\n");
                        // There are multiple network adapters still, assuming teaming is in play, try to find the
                        // mac that has multiple transports assigned to it.  The solitary nic would remain as the
                        // secondary.

                        AddressInfo[] addrs = Array.FindAll(addresses,
                                                            delegate(AddressInfo a)
                                                            {
                                                                return a.transportNames.Count > 1;
                                                            });
                        NetworkInterface n;

                        if (addrs.Length == 1)
                        {
                            XblCfgConsole.Out("Found same MAC on multiple unbound NICs, assuming this the active team NIC:\n" + addrs[0].ToString());
                            // Found a single unbound NIC that appears multiple times, call it as the internet nic
                            mac = addrs[0].mac;
                        }
                        else if (addrs.Length == 0 && (n = FindInternetAddress(networks, dmzIP)) != null)
                        {
                            // No unbound team nic, then bind to internet TCP/IP NIC
                            XblCfgConsole.Out("Unable to find unbound team interface, binding to internet TCP/IP network interface");
                            mac = n.GetPhysicalAddress();
                        }
                        else
                        {
                            throw new XblCfgBadArgumentException("Unable to find suitable internet mac address to use.");
                        }
                    }
                }
                else // nicRole.StartsWith("middle_tier")
                {
                    XblCfgConsole.Out("Using npdb network interface for datacenter configuration.\n");
                    // Bind to the same NIC as the datacenter tier IP
                    NetworkInterface n = FindDatacenterAddress(networks, dmzIP);
                    mac = n.GetPhysicalAddress();
                }
            }

            npdb.AddServer(serverName, siteId, nicRole, ip, netmask, gateway, mac,
                sgPoolStartIP, sgPoolEndIP, sgPoolStartPort, sgPoolEndPort);
        }

        private void ProcessServerDelete(NamedArgParser args)
        {
            string serverName = Environment.MachineName;
            Npdb npdb = new Npdb();

            string nicRole = args["nic"];
            string sg = args["sg"];
            if (sg != null)
            {
                // Need to delete both the internet tier and middle tier nics
                if (!npdb.DeleteServer(serverName, "internet_tier_sg1"))
                {
                    return;
                }
                nicRole = "middle_tier_sg";
            }

            if (npdb.DeleteServer(serverName, nicRole))
            {
                XblCfgConsole.Out("Unregistration successful.");
            }
        }
        
        // TODO: comment on returning TCP/IP bound network interfaces
        private static NetworkInterface[] GetNetworkInterfaces()
        {
            NetworkInterface[] nets = Array.FindAll(NetworkInterface.GetAllNetworkInterfaces(),
                delegate(NetworkInterface n)
                {
                    return n.NetworkInterfaceType != NetworkInterfaceType.Loopback && // No 127.0.0.1
                        n.NetworkInterfaceType != NetworkInterfaceType.Tunnel &&      // we don't use tunnel connections
                        n.OperationalStatus == OperationalStatus.Up &&                // Needs to be online
                        (n.GetIPProperties().GetIPv4Properties() != null) &&          // Don't care about IPv6 only
                        !n.GetIPProperties().GetIPv4Properties().IsAutomaticPrivateAddressingActive; // No 169.254.X.X
                });

            if (nets.Length > 0)
            {
                XblCfgConsole.Out("Active TCP/IP network interfaces discovered:");
                foreach (NetworkInterface n in nets)
                {
                    XblCfgConsole.Out("MAC {0}:", n.GetPhysicalAddress());
                    XblCfgConsole.Out("InterfaceType {0}:", n.NetworkInterfaceType);
                    foreach (UnicastIPAddressInformation ip in n.GetIPProperties().UnicastAddresses)
                    {
                        XblCfgConsole.Out("\tIP: {0}", ip.Address);
                    }
                }
                XblCfgConsole.Out("");
            }
            return nets;
        }

        class AddressInfo
        {
            public List<string> connectionNames = new List<string>();
            public PhysicalAddress mac;
            public List<string> transportNames = new List<string>();

            internal AddressInfo(PhysicalAddress mac)
            {
                this.mac = mac;
            }

            public override string ToString()
            {
                StringBuilder sb = new StringBuilder();
                sb.AppendFormat("MAC {0}:", mac);
                foreach (string s in connectionNames)
                {
                    sb.AppendFormat("\n\tConnection: {0}", s);
                }

                return sb.ToString();
            }
        }

        private static void GetNetmaskAndGatewayForIP(NetworkInterface n, IPAddress ip, out IPAddress netmask, out IPAddress gateway)
        {
            gateway = n.GetIPProperties().GatewayAddresses.Count > 0 ? n.GetIPProperties().GatewayAddresses[0].Address : null;

            netmask = null;
            foreach (UnicastIPAddressInformation info in n.GetIPProperties().UnicastAddresses)
            {
                if (ip.Equals(info.Address))
                {
                    netmask = info.IPv4Mask;
                    break;
                }
            }
        }

        private static string GetMacListString(AddressInfo[] addrs)
        {
            return String.Join(", ", Array.ConvertAll<AddressInfo, string>(addrs, delegate(AddressInfo a) { return a.mac.ToString(); }));
        }

        private static AddressInfo[] GetUnboundAddresses()
        {
            AddressInfo[] addrs = Array.FindAll(
                                    GetMacAddresses(),
                                    delegate(AddressInfo a)
                                    {
                                        return !a.transportNames.Exists(delegate(string s) {return s != "N/A";});
                                    });

            if (addrs != null && addrs.Length > 0)
            {
                XblCfgConsole.Out("Active unbound network interface discovered:");
                foreach (AddressInfo a in addrs)
                {
                    XblCfgConsole.Out(a.ToString());
                }
                XblCfgConsole.Out("");
            }
            else
            {
                XblCfgConsole.Out("All active NICs found on machine are bound to TCP/IP. No isolated network interfaces available for RAWNIC binding.\n");
            }
            return addrs;
        }

        private static AddressInfo[] GetMacAddresses()
        {
            List<AddressInfo> NicInfos = new List<AddressInfo>();

            ProcessStartInfo pso = new ProcessStartInfo();

            pso.FileName = "getmac.exe";
            pso.Arguments = "/FO CSV /V /NH";
            pso.UseShellExecute = false;
            pso.RedirectStandardOutput = true;

            Process p = new Process();

            p.StartInfo = pso;
            p.OutputDataReceived +=
                new DataReceivedEventHandler(
                    delegate(object sender, DataReceivedEventArgs e)
                    {
                        if (e.Data == null) return;
                        string[] items = Array.ConvertAll(e.Data.Split(','), new Converter<string, string>(UnQuote));

                        // the MAC address can actually not have a real value at all, as it is disabled, ignore that case.
                        if (String.Equals(items[2], "Disabled", StringComparison.InvariantCultureIgnoreCase)) return;

                        PhysicalAddress mac = PhysicalAddress.Parse(items[2]);

                        AddressInfo a = NicInfos.Find((delegate(AddressInfo info) { return mac.Equals(info.mac); }));
                        if (a == null)
                        {
                            a = new AddressInfo(mac);
                            NicInfos.Add(a);
                        }

                        a.connectionNames.Add(items[0]);
                        a.transportNames.Add(items[3]);
                    });
            p.Start();
            p.BeginOutputReadLine();
            p.WaitForExit();

            return NicInfos.ToArray();
        }

        private static string UnQuote(string s)
        {
            if (s.StartsWith("\"") && s.EndsWith("\""))
                return s.Substring(1, s.Length - 2);
            return s;
        }


        private static NetworkInterface FindDatacenterAddress(NetworkInterface[] networks, IPAddress addr)
        {
            if (networks.Length == 1)
            {
                return networks[0];
            }
            else
            {
                foreach (NetworkInterface network in networks)
                {
                    foreach (UnicastIPAddressInformation ip in network.GetIPProperties().UnicastAddresses)
                    {
                        if (addr.Equals(ip.Address))
                        {
                            return network;
                        }
                    }
                }

                // Shouldn't get here, so return null and let hilarity ensue.
                return null;
            }
        }

        // Finds the internet address by virtue of it not being the IP returned in the datacenter query.
        private static NetworkInterface FindInternetAddress(NetworkInterface[] networks, IPAddress addr)
        {
            if (networks.Length > 2)
            {
                throw new XblCfgBadArgumentException(String.Format("Unable to determine internet nic, {0} TCP/IP bound nics available", networks.Length - 1));
            }

            foreach (NetworkInterface network in networks)
            {
                bool foundIP = false;
                foreach (UnicastIPAddressInformation ip in network.GetIPProperties().UnicastAddresses)
                {
                    if (foundIP = addr.Equals(ip.Address))
                    {
                        // If a match exists, then this is the wrong IP
                        break;
                    }
                }

                // The first IP that doesn't match the datacenter IP counts as the internet IP.
                if (!foundIP)
                {
                    return network;
                }
            }

            return null;
        }

        private static IPAddress FindNetworkIPAddress(NetworkInterface n)
        {
            foreach (UnicastIPAddressInformation info in n.GetIPProperties().UnicastAddresses)
            {
                if (info.Address.AddressFamily == AddressFamily.InterNetwork)
                {
                    return info.Address;
                }
            }

            return null;
        }
        // Cheap query.  An easy way to determine which interface is the datacenter interface is to see which is used to connect to
        // npdb, then look at the socket.  If there is a cleaner way, I have not been able to find it, and would welcome another way to
        // ping the interfaces to see who would be able to successfully route to npdb.
        private static IPAddress FindDatacenterIP()
        {
            Socket s = new Socket(AddressFamily.InterNetwork, SocketType.Stream, ProtocolType.Tcp);
            try
            {
                s.Connect(Config.NpdbServer, 1433);

                if (s.Connected)
                {
                    IPAddress addr = ((IPEndPoint)(s.LocalEndPoint)).Address;
                    XblCfgConsole.Out("Local IPAddress used to connect to npdb: {0}\n", addr);
                    
                    return addr;
                }
            }
            catch (SocketException e)
            {
                throw new XblCfgBadArgumentException("Unable to connect to npdb server '" + Config.NpdbServer + "' to determine datacenter nic, InnerException:\n" + e.ToString());
            }
            finally
            {
                if (s.Connected)
                {
                    s.Shutdown(SocketShutdown.Both);
                }
            }
            throw new XblCfgBadArgumentException("Unable to connect to npdb server '" + Config.NpdbServer + "' to determine datacenter nic.");
        }
    } // class ActionServer
} // namespace xonline.tools.xblcfg
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\XblCfg\App\exe\objd\i386\_generated.cs ===
[assembly:System.Runtime.InteropServices.ComVisible(false)]
[assembly:System.Reflection.AssemblyVersion("12.4.56.0")]
[assembly:System.Reflection.AssemblyProduct("DEPOT")]
[assembly:System.Reflection.AssemblyCopyright("")]
[assembly:System.Reflection.AssemblyCompany("")]
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\XblCfg\App\xblcfg.cs ===
// --------------------------------------------------------------------------------------
// Copyright (c) Microsoft Corporation.  All rights reserved
//
// xblcfg.cs
//
// xblcfg
//
// main file
// --------------------------------------------------------------------------------------

using System;
using System.Collections;
using System.Collections.Generic;
using System.Data;
using System.Data.SqlClient;
using System.Diagnostics;
using System.Globalization;
using System.IO;
using System.Net;
using System.Reflection;
using System.Security.Cryptography;
using System.Text.RegularExpressions;
using System.Xml;
using System.Xml.XPath;

using Microsoft.Webstore.WstClient;

using xonline.common.config;
using xonline.common.diagnostics;
using xonline.common.service;
using xonline.common.sql.webstore;
using xonline.common.tools.console;
using xonline.common.tools;

namespace xonline.tools.xblcfg
{
    public class XblCfg
    {
        static int Main(string[] rawargs)
        {
            int ret = 0;
            try
            {
                NamedArgParser args = new NamedArgParser();
                args.Parse(rawargs);
                // The first parameter matters. The rest can be in any order.
                if (rawargs.Length < 1)
                {
                    PrintUsage();
                    return 0;
                }

                // Remove leading / or -
                string command = rawargs[0].ToLower().Substring(1);
                if (command == "blob")
                {
                    (new ActionBlob()).Process(args);
                }
                else if (command == "script")
                {
                    (new ActionScript()).Process(args);
                }
                else if (command == "hive")
                {
                    (new ActionHive()).Process(args);
                }
                else if (command == "server")
                {
                    (new ActionServer()).Process(args);
                }
                else if (command == "vinterface")
                {
                    (new ActionVirtualInterface()).Process(args);
                }
                else if (command == "multisetoverrides")
                {
                    (new ActionMultiSetting()).Process(args);
                }
                else if (command == "groups")
                {
                    // Group management in xblcfg is deprecated, so tell the user to use Yellow Door
                    PrintUsageForGroups();
                }
                else if (command == "groups.hidden")
                {
                    // Group management in xblcfg is deprecated, but we are keeping this as a
                    // hidden feature in case something comes up and this functionality is
                    // really needed in this tool.
                    (new ActionGroups()).Process(args);
                }
                else if (command == "etx")
                {
                    (new ActionEtx()).Process(args);
                }
                else if (command == "devkit")
                {
                    (new ActionDevkit()).Process(args);
                }
                else
                {
                    PrintUsage();
                }
            }
            catch (XblCfgBadArgumentException e)
            {
                XblCfgConsole.Out("Usage error:");
                XblCfgConsole.Out(e.Message);
                ret = -1;
            }
            catch (Exception e)
            {
                XblCfgConsole.Out("Internal error:");
                XblCfgConsole.Out(e.ToString());
                ret = -1;
            }

            return ret;
        }

        private static void PrintUsage()
        {
//       1         2         3         4         5         6         7         8
//34567890123456789012345678901234567890123456789012345678901234567890123456789012345678
            string helpText = @" 
Xbox Live Common Config Tool

    Add and remove settings in npdb. And more.

Usage: 
    xblcfg.exe [command] [command options...]

Notes:
    All parameters may be given in any order. Any option surrounded by 
    brackets is optional. 

Commands (additional help is available for each):

    -blob

        Add and remove settings in t_config_blobs

    -devkit

        Add and remove devkits from kdsvc_xmacs_ExceptionList

    -etx

        Manage etx manifest storage

    -hive

        Add and remove hive settings from t_live_registry_settings

    -multisetoverrides

        Add and remove multi settings from t_multisetting_overrides

    -script

        Add and remove script in t_sg_scripts

    -server

        Add and remove server information in t_servers/t_server_nics

    -vinterface

        Add and remove virtual interface to ip mapping information in t_site_virtual_interface_ips
";

            Console.WriteLine(helpText);

        }

        private static void PrintUsageForGroups()
        {
            string helpText = @"Group management in XBLCFG is deprecated. Please use Yellow Door instead.";

            Console.WriteLine(helpText);

        }
    }

    public class XblCfgBadArgumentException : Exception
    {
        public XblCfgBadArgumentException(string message) :
            base(message)
        {
        }
    }

    public class XblCfgConsole
    {
        public static void Out(string fmt, params object[] prms)
        {
            Console.WriteLine(string.Format(fmt, prms));
        }

        public static void Out(string line)
        {
            Console.WriteLine(line);
        }

        public static void OutPairs(int indent, params object[] values)
        {
            int pad = 35-indent;

            for(int i=0; i < values.Length; i+=2)
            {
                Console.Write(String.Empty.PadRight(indent) +
                              values[i].ToString().PadRight(pad) + " : ");

                if(i + 1 < values.Length)
                {
                    Console.Write(values[i+1] + "\n");
                }
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\XblCfg\App\actionScript.cs ===
// --------------------------------------------------------------------------------------
// Copyright (c) Microsoft Corporation.  All rights reserved
//
// pconfig.cs
//
// XblCfg
//
// Process the Config command
// --------------------------------------------------------------------------------------

using System;
using System.Collections;
using System.Collections.Generic;
using System.Data;
using System.Data.SqlClient;
using System.Diagnostics;
using System.Globalization;
using System.IO;
using System.Net;
using System.Reflection;
using System.Security.Cryptography;
using System.Text.RegularExpressions;
using System.Xml;
using System.Xml.XPath;

using Microsoft.Webstore.WstClient;

using xonline.common.config;
using xonline.common.diagnostics;
using xonline.common.service;
using xonline.common.sql.webstore;
using xonline.common.tools.console;
using xonline.common.tools;

namespace xonline.tools.xblcfg
{
    public class ActionScript
    {
        public class XblCfgScriptException : Exception
        {
            public XblCfgScriptException(string message) :
                base(message)
            {
            }
        }

        public void Process(NamedArgParser args)
        {
            if (args["help"] != null || args["h"] != null || args["?"] != null)
            {
                PrintUsage();
                return;
            }

            if (args["add"] != null)
            {
                ProcessAdd(args);
            }
            else if (args["delete"] != null)
            {
                ProcessDelete(args);
            }
            else if (args["deleteScriptFiles"] != null)
            {
                ProcessDeleteScriptFiles(args);
            }
            else if (args["get"] != null)
            {
                ProcessGet(args);
            }
            else if (args["test"] != null)
            {
                ProcessDeleteScriptFiles(args);
            }
            else
            {
                PrintUsage();
            }
        }

        private static void PrintUsage()
        {
            //       1         2         3         4         5         6         7         8
            //34567890123456789012345678901234567890123456789012345678901234567890123456789012345678
            string helpText = @" 
xblcfg.exe -script [options...]

Notes:
    -script is used to add/delete/get a challenge from an environment

Options:

    -add 
        Adds or updates a script in t_sg_scripts, unless -servers is specified
        then the challenge will be deployed directly to those servers and not in
        t_sg_scripts. This option requires the following additional options:

        -name:<script-name> 
            script-name is a unique identifier for this script

        -scriptfile:<lua-file-name> 
            lua-file-name is the name of the LUA file to prop to the database.
    
        [-servers:<sg-server-names>]
            sg-server-names is the list of servers to deploy the script to
            ';' delimited. If this argument is passed, the script will not
            go into t_sg_scripts, it will be deployed directly to the servers
            sgcfg folder. If this argument is not passed, it is assumed ALL was 
            expected, and the setting will go into npdb. 
        
        [Challenge Only]
            [-xex:<xex-file-name]
                xex-file-name is the binary xex to deploy to the XTOU servers.
        
            [-xexpath:<xex-folder-name>]
                xex-folder-name is the location on the XTOU servers, which the binary 
                xex will be placed.     

            [-binaryfile:<binary-file-name>]
                binary-file-name is the file to upload into the im_blob field, which 
                is used as the binary blob to send to the client. Normally this is 
                embedded within the LUA script.
            
            [-kickenabled:0|1] 
                Sets challenge override to prevent kicking. Default is 0, which 
                disables the challenge from ever kicking the client.
                **If -servers is defined, this setting is ignored.**

            [-timeoutenabled:0|1]
                Sets challenge override to prevent timing out. Default is 0, which 
                disables ever kicking the client due to timing out.
                **If -servers is defined, this setting is ignored.**

    -delete 
        Deletes a script from the database.

        -name:<script-name>
            script-name is a unique identifier for this script

    -deleteScriptFiles 
        Deletes a file or folder from each server running the provided interface.
        
        -interface:<server-interface>
            The server type to remove the files from.

        -path:<file-path>
            file-path is the path on the server that the file you would like 
            to delete is located in. If no file is specified, the folder itself
            will be removed.        

        -scriptfile:<file-name>
            file-name is the name of the file to remove.

    -get
        Lists all active scripts.

Examples:
    Add a simple script or sync challenge to npdb.t_sg_scripts:
        xblcfg -script -add -name:xenon1 -scriptfile:sg_chal_xenon80.lua -kickenabled:1

    Add an async challenge to npdb.t_sg_scripts:
        xblcfg -script -add -name:104 -scriptfile:sg_chal_104_xenon.lua -xex:D:\xosc.xex -xexpath:C3V1

    Add a script/challenge to a single server or set of servers:
        xblcfg -script -add -scriptfile:sg_chal_104_xenon.lua -xex:D:\xosc.xex -xexpath:C3V1 -servers:XESECUINH001
         
    Delete a file that has previously been deployed from all sgsvc machines.
        xblcfg -script -deletescriptfiles -interface:sgsvc -path:d$\webroot\sgcfg\ -scriptfile:sg_chal_104_xenon.lua
    
    Delete a folder and contents that has previously been deployed from all xtou machines.
        xblcfg -script -deletescriptfiles -interface:xtou -path:d$\webroot\xtou\xedl\chalresp\C3V1\ -scriptfile:xosc.xex
    
    Delete a script from npdb.t_sg_scripts:
        xblcfg -script -delete -name:xenon1

    Get a list of scripts from npdb.t_sg_scripts:
        xblcfg -script -get

";

            XblCfgConsole.Out(helpText);
        }

        private void ProcessAdd(NamedArgParser args)
        {
            string scriptName = args["name"];
            string scriptFileName = args["scriptfile"];
            string servers = args["servers"];
            string[] serverList = null;
            string xex = args["xex"];
            string xexPath = args["xexpath"];
            string binaryFileName = args["binaryfile"];
            byte[] binaryBlob = null;
            uint kickEnabled = 0;
            uint timeoutEnabled = 0;
            string scriptText = null;

            // Verify required parameters were provided
            if (serverList == null && scriptName == null)
            {
                throw new XblCfgBadArgumentException("Missing -name argument");
            }

            if (scriptFileName == null)
            {
                throw new XblCfgBadArgumentException("Missing -scriptfile argument");
            }

            if (!File.Exists(scriptFileName))
            {
                throw new XblCfgBadArgumentException("Script file '" + scriptFileName + "' does not exist");
            }
            scriptText = File.ReadAllText(scriptFileName);

            // Handle optional parameters
            if (servers != null)
            {
                serverList = servers.Split(';');
                if (serverList.Length == 1 && serverList[0] == "")
                {
                    throw new XblCfgBadArgumentException("Servers must contain at least one server.");
                }
            }

            if (xex != null)
            {
                if (!File.Exists(xex))
                {
                    throw new XblCfgBadArgumentException("Xex file '" + xex + "' does not exist");
                }

                if (xexPath == null)
                {
                    throw new XblCfgBadArgumentException("Missing -xexpath argument");
                }

            }

            if (binaryFileName != null)
            {
                if (!File.Exists(binaryFileName))
                {
                    throw new XblCfgBadArgumentException("Binary file '" + binaryFileName + "' does not exist");
                }
                binaryBlob = File.ReadAllBytes(binaryFileName);
            }

            if (args["kickenabled"] != null)
            {
                kickEnabled = args.ParseUInt("kickenabled");
                if (kickEnabled != 0)
                {
                    kickEnabled = 1;
                }
            }

            if (args["timeoutenabled"] != null)
            {
                timeoutEnabled = args.ParseUInt("timeoutenabled");
                if (timeoutEnabled != 0)
                {
                    timeoutEnabled = 1;
                }
            }

            if ((args["noblock"] != null) || (PrintAddOverview(scriptName, scriptFileName, serverList, xex, xexPath, binaryFileName, kickEnabled, timeoutEnabled)))
            {
                //
                // Deploy xex files to all XTOU servers
                //
                Npdb npdb = new Npdb();
                if (xex != null)
                {
                    string[] XTOUservers = npdb.GetServersByInterface("XTOU");
                    XblCfgConsole.Out("\nDeploying Data Files to XTOU servers");

                    string targetDir = "d$\\webroot\\xtou\\xedl\\chalresp";
                    if (Config.Environment.ToLower() == "xblob")
                    {
                        targetDir = "c$\\esp\\webroot\\xtou\\xedl\\chalresp";
                    }
                    DeployDataFiles(XTOUservers, targetDir, xexPath, xex);
                }

                //
                // Deploy Script to t_sg_scripts if no servers are specified
                // else deploy to each server sgcfg folder specified in serverList.
                //
                if (serverList != null)
                {
                    XblCfgConsole.Out("\nDeploying script Files to sgcfg servers");

                    string targetDir = "d$\\webroot";
                    if (Config.Environment.ToLower() == "xblob")
                    {
                        targetDir = "c$\\esp\\webroot\\sgsvc";
                    }
                    DeployDataFiles(serverList, targetDir, "sgcfg", scriptFileName);
                }
                else
                {
                    npdb.ChalSet(scriptName, scriptText, binaryBlob, kickEnabled, timeoutEnabled);
                }

                ReloadSGs();
            }
            else
            {
                XblCfgConsole.Out("\nDeployment canceled by user.");
                return;
            }
        }

        private void ProcessDelete(NamedArgParser args)
        {
            string sciptName = args["name"];

            if (sciptName == null)
            {
                throw new XblCfgBadArgumentException("Missing -name argument");
            }

            // Delete script from database
            XblCfgConsole.Out(
                "Deleting challenge '{0}' from npdb.t_sg_scripts",
                sciptName);

            Npdb npdb = new Npdb();
            if (npdb.ScriptDelete(sciptName))
            {
                ReloadSGs();

                XblCfgConsole.Out("Done.");
            }
            else
            {
                XblCfgConsole.Out("Script not found.");
            }
        }

        private void ProcessDeleteScriptFiles(NamedArgParser args)
        {
            string serverInterface = args["interface"];
            string scriptFile = args["scriptfile"];
            string scriptPath = args["scriptpath"];
            string[] servers = null;

            if (scriptPath == null)
            {
                throw new XblCfgBadArgumentException("Missing -scriptpath argument");
            }

            Npdb npdb = new Npdb();
            servers = npdb.GetServersByInterface(serverInterface);
            if ((args["noblock"] != null) || (PrintDeleteOverview(servers, scriptPath, scriptFile)))
            {
                DeleteDataFiles(servers, scriptPath, scriptFile);
            }
        }

        private void ProcessGet(NamedArgParser args)
        {
            // Read all challenges in database

            string outputText;

            Npdb npdb = new Npdb();
            if (!npdb.ScriptGetAll(out outputText))
            {
                XblCfgConsole.Out("Error listing challenges in t_sg_scripts.");
                return;
            }

            XblCfgConsole.Out(outputText);
        }
        private bool PrintDeleteOverview(string[] serverList, string path, string fileName)
        {
            XblCfgConsole.Out("[Delete Overview]");
            bool wroteHeading = false;

            if (fileName != null)
            {
                foreach (string server in serverList)
                {
                    if (File.Exists("\\\\" + server + path + fileName))
                    {
                        if (wroteHeading == false)
                        {
                            XblCfgConsole.Out("\t[Files]");
                            wroteHeading = true;

                        }
                        XblCfgConsole.Out("\t\tDelete [ \\\\" + server + path + fileName + " ]");
                    }
                }
            }
            else
            {
                foreach (string server in serverList)
                {
                    if (Directory.Exists("\\\\" + server + path))
                    {
                        if (wroteHeading == false)
                        {
                            XblCfgConsole.Out("\t[Directory]");
                            wroteHeading = true;

                        }
                        XblCfgConsole.Out("\t\tDelete [ \\\\" + server + path + " ] and all files contained.");
                    }
                }
            }

            if (wroteHeading == false)
            {
                XblCfgConsole.Out("\tNothing to delete found.");
            }
            else
            {
                Console.Write("\nWould you like to continue? (Y/N): ");
                string deploy = Console.ReadLine().ToLower();
                if (deploy == "y" || deploy == "yes")
                {
                    return true;
                }
            }
            return false;
        }

        private bool PrintAddOverview(string scriptName,
                                    string scriptFileName,
                                    string[] serverList,
                                    string xexName,
                                    string xexFolderName,
                                    string binaryFileName,
                                    uint kickEnabled,
                                    uint timeoutEnabled)
        {
            XblCfgConsole.Out("\n[Deployment Overview]");
            XblCfgConsole.Out("     Script name: \t{0}", scriptName);
            XblCfgConsole.Out("     Script file: \t{0}", scriptFileName);
            XblCfgConsole.Out("     Xex name:   \t{0}", xexName == null ? "<none>" : xexName);
            XblCfgConsole.Out("     Xex folder: \t{0}", xexFolderName == null ? "<none>" : xexFolderName);
            XblCfgConsole.Out("     Binary file: \t{0}", binaryFileName == null ? "<none>" : binaryFileName);
            XblCfgConsole.Out("     KickEnabled: \t{0}", kickEnabled == UInt32.MaxValue ? "<none>" : kickEnabled.ToString());
            XblCfgConsole.Out("     TimeoutEnabled: \t{0}", timeoutEnabled == UInt32.MaxValue ? "<none>" : timeoutEnabled.ToString());
            if (serverList != null)
            {
                XblCfgConsole.Out("     [Servers]");
                foreach (string s in serverList)
                {
                    XblCfgConsole.Out("         {0}", s);
                }
            }
            else
            {
                XblCfgConsole.Out("     Servers: \t\tAll");
            }

            Console.Write("\nWould you like to continue? (Y/N): ");
            string doContinue = Console.ReadLine().ToLower();
            if (doContinue == "y" || doContinue == "yes")
            {
                return true;
            }
            return false;
        }


        private void DeployDataFiles(string[] serverList, string targetPathBase, string targetPathFolder, string fileNamePath)
        {
            string fileName = fileNamePath.Substring(fileNamePath.LastIndexOf('\\'));

            if (serverList.Length == 0)
            {
                throw new XblCfgScriptException(String.Format("No servers were found to deploy data files to."));
            }

            foreach (string server in serverList)
            {
                DeployFile(server, fileNamePath, fileName, "\\" + targetPathBase + "\\" + targetPathFolder);
            }
        }

        public void DeployFile(string _server, string _sourceFileName, string _destinationFileName, string _path)
        {
            XblCfgConsole.Out("\tAttempting to deploy file [ " + _sourceFileName + " ] to [ \\\\" + _server + _path + _destinationFileName + " ]");
            Directory.CreateDirectory("\\\\" + _server + _path);
            try
            {
                File.Copy(_sourceFileName, "\\\\" + _server + _path + _destinationFileName, true);
            }
            catch (Exception e)
            {
                XblCfgConsole.Out("\tDeployment to [ " + _server + " ] failed: " + e.Message);
            }
        }

        private void DeleteDataFiles(string[] serverList, string path, string fileName)
        {
            foreach (string server in serverList)
            {
                DeleteFile(server, path, fileName);
            }
        }

        private void DeleteFile(string _server, string _path, string _fileName)
        {
            string fullPath = _server + _path + "\\";
            if (_fileName != null)
            {
                if (File.Exists("\\\\" + fullPath + _fileName))
                {
                    XblCfgConsole.Out("\tDeleting file [ \\\\" + fullPath + _fileName + " ]");
                    File.Delete("\\\\" + fullPath + _fileName);
                }
                else
                {
                    XblCfgConsole.Out("\tFile [ \\\\" + fullPath + _fileName + " ] could not be found.");
                }
            }
            else
            {
                if (Directory.Exists("\\\\" + fullPath))
                {
                    XblCfgConsole.Out("\tDeleting directory [ \\\\" + fullPath + " ]");
                    Directory.Delete("\\\\" + fullPath, true);
                }
                else
                {
                    XblCfgConsole.Out("\tDirectory [ \\\\" + fullPath + " ] could not be found.");
                }
            }
        }


        public void ReloadSGs()
        {
            XblCfgConsole.Out("\nReloading all SGs");
            string filename = "xmgmtc.exe";
            string arguments = "-i sgsvc -r \"e :sg reload_config\""; 
            Process sgReload = new Process();
            try
            {
                sgReload.StartInfo.FileName = filename;
                sgReload.StartInfo.Arguments = arguments;
                sgReload.StartInfo.UseShellExecute = false;
                sgReload.StartInfo.RedirectStandardOutput = true;
                sgReload.Start();

                StreamReader sr = sgReload.StandardOutput;
                string currentLine = null;
                while ((currentLine = sr.ReadLine()) != null)
                {
                    XblCfgConsole.Out("\t" + currentLine);
                }
            }
            catch (Exception e)
            {
                XblCfgConsole.Out("Error executing \"{0} {1}\":\n{2}\n", filename, arguments, e.ToString());
            }
            finally
            {
                sgReload.Close();
            }
        }
    } // class ActionChal
} // namespace xonline.tools.xblcfg
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\XAppAdmin\XAppAdmin.cs ===
using System;
using System.Collections;
using System.Data;
using System.Data.SqlClient;
using System.Diagnostics;
using System.Globalization;
using System.IO;
using System.Reflection;
using System.Text;
using System.Text.RegularExpressions;
using System.Windows.Forms;

using Microsoft.Webstore.WstClient;
using Microsoft.Webstore.MetaData;

namespace XappAdmin
{
    /// Xbox Live Administration tool
    /// Miscellaneous admin needs related to ideosyncrasies in the Xbox Live database applications
    /// are covered by this tool.
    class XappAdmin
    {
        /// <summary>
        /// Program to address administration issues specific to Xbox Live applications ("Xapps").
        /// </summary>

        static StreamWriter wr = null;

        [STAThread]
        static int Main(string[] args)
        {
            DateTime start = new DateTime();
            start = DateTime.Now;
            bool blnSuccess = false;
            Console.WriteLine();
            if (args.Length == 0)
            {
                Usage();
                return 1;
            }
            ParsedArgs ar = new ParsedArgs(args);
            if (ar.Action == "None")
            {
                Console.WriteLine("{0}Operation Failed", Environment.NewLine);
                return 1;
            }
            else
            {
                LogObj = ar.LogStream;
                if (ar.OutputVersion)
                {
                    Assembly asm = Assembly.GetExecutingAssembly();
                    string output = asm.FullName;
                    string[] outputs = output.Split(',');
                    sendOut("{0}{1}", outputs[0], outputs[1]);
                }
                blnSuccess = runAction(ar);
                Console.WriteLine();
                if (blnSuccess == false)
                {
                    Console.WriteLine("Operation Failed");
                    return 1;
                }
                else
                {
                    DateTime end = new DateTime();
                    end = DateTime.Now;
                    TimeSpan duration = end.Subtract(start);
                    string durstring = duration.ToString();
                    if (durstring.Length > 12)
                    {
                        durstring = durstring.Substring(0, 12);
                    }
                    Console.WriteLine("XappAdmin time elapsed: {0}", durstring);
                    Console.WriteLine();
                    Console.WriteLine("Operation Successful");
                }
            }

            return 0;
        }

        // PROPERTIES
        public static StreamWriter LogObj
        {
            get
            {
                if (wr != null)
                {
                    return wr;
                }
                else
                {
                    return null;
                }
            }
            set
            {
                wr = value;
            }
        }

        // METHODS
        public static bool IsValidGamertag(string name)
        {
            if (string.IsNullOrEmpty(name) || name.Length > xonline.common.service.XOn.XONLINE_NAME_MAX_SIZE)
            {
                return false;
            }

            // ^(\w(\s\w|\w)+)$
            if ( !Regex.IsMatch(name, "^([a-z]([a-z0-9]| [a-z0-9])*)$", RegexOptions.IgnoreCase) )
            {
                return false;
            }

            if (Regex.IsMatch(name, "  "))
            {
                return false;
            }

            if (name[0] == ' ' || name[name.Length - 1] == ' ')
            {
                return false;
            }

            return true;
        }

        static string addParamToMsg(string msg, ParsedArgs arg)
        {
            if (arg.Gamertag != string.Empty)
            {
                msg = string.Format("{0} Gamertag: {1}", msg, arg.Gamertag);
            }
            else
            {
                if (arg.PUID != -1)
                {
                    msg = string.Format("{0} PUID: {1}", msg, arg.PUID);
                }
                else
                {
                    if (arg.WLID != -1)
                    {
                        msg = string.Format("{0} WLID: {1}", msg, arg.WLID);
                    }
                }
            }
            if (arg.Additional != string.Empty)
                msg = string.Format("{0} {1}", msg, arg.Additional);
            return msg;
        }

        static string addToString(string toWhichToAdd, string toBeAdded, string delimiter)
        {
            string retstr;
            if (toWhichToAdd == string.Empty)
            {
                retstr = toBeAdded;
            }
            else
            {
                retstr = toWhichToAdd + delimiter + toBeAdded;
            }
            return retstr;
        }

        static bool checkForDelete(LiveUser keepUser, LiveUser deleteUser)
        {
            bool success = false;
            // verify that the UsersGamertag is good, then delete the current gamertag
            if (keepUser.NamesPUID != -1)            // exists in t_user_names
            {
                if (keepUser.GTExistsInUser_Keys)    // exists in t_user_keys and t_xenon_user_keys
                {
                    if (keepUser.ChangeToGamertag != deleteUser.Gamertag)
                    {
                        if (keepUser.PUID == deleteUser.PUID)
                        {
                            if (deleteUser.UsersGamertag.ToUpper() != deleteUser.Gamertag.ToUpper())
                            {
                                sendOut("Gamertag '{0}' is the correct one.  Deleting '{1}'.", deleteUser.UsersGamertag, deleteUser.Gamertag);
                                deleteUser.deleteNameData();
                                success = true;
                            }
                            else
                            {
                                // the upper case GTs are identical, but the lower-case ones are not
                                sendOut("Gamertag '{0}' is the same as '{1}' except for case.", deleteUser.UsersGamertag, deleteUser.Gamertag);
                            }
                        }
                        else
                        {
                            sendOut("Found a discrepancy in the user PUIDs.");
                            sendOut("PUID for '{0}' is {1}.", deleteUser.Gamertag, deleteUser.PUID.ToString());
                            sendOut("PUID for '{0}' is {1}.", keepUser.Gamertag, keepUser.PUID.ToString());
                        }
                    }
                    else
                    {
                        sendOut("Can't delete '{0}' as the user has tried to change TO this gamertag.", deleteUser.Gamertag);
                    }
                }
                else
                {
                    sendOut("User '{0}' missing from t_user_keys or t_xenon_user_keys.", deleteUser.UsersGamertag);
                }
            }
            else
            {
                sendOut("User '{0}' missing from t_user_names.", deleteUser.UsersGamertag);
            }
            return success;
        }

        private static bool confirmAction(string action)
        {
            bool response = false;
            string msg = "This will " + action;
            msg += "  Are you sure you want to do this?";
            DialogResult result = MessageBox.Show(msg, "Confirm action", MessageBoxButtons.YesNo, MessageBoxIcon.Exclamation, MessageBoxDefaultButton.Button2);
            if (result == DialogResult.Yes)
            {
                response = true;
            }
            else
            {
                sendOut("Action terminated due to user input.");
            }
            return response;
        }

        static bool deleteFromWebstoreDB(ParsedArgs ar)
        {
            bool success = false;
            if (selectFromWebstoreDB(ar))
            {
                string fieldName = "bi_user_puid";
                string predicate = string.Empty;
                string actiontobetaken = string.Empty;
                LiveUser user = getLiveUser(ar);
                if (user.PUIDExistsInUsers)
                {
                    Console.WriteLine("PUID from t_users    : {0}", user.PUID);
                    // output what we're about to do
                    actiontobetaken = string.Format("Action: Delete row from {0} where gamertag is '{1}'", ar.Modifier, user.Gamertag);
                    if (ar.Additional != string.Empty)
                    {
                        // include additions to the predicate
                        actiontobetaken = string.Format("{0}\r\n        {1}", actiontobetaken, ar.Additional);
                    }
                    else
                    {
                        actiontobetaken = string.Format("{0}\r\n", actiontobetaken);
                    }
                    // create a predicate composed of the user PUID information plus any parameters defined by Additional Information
                    predicate = string.Format(" WHERE {0} = {1}", fieldName, user.PUID);
                    if (ar.Additional != string.Empty)
                    {
                        predicate += ar.Additional;
                    }
                    // construct the delete statement using the assembled predicate
                    string cmdtxt = "DELETE " + ar.Modifier;
                    cmdtxt += predicate;
                    WstCommand cmd = new WstCommand();
                    cmd.Connection = ar.WstConnect;
                    cmd.Partition = user.PUIDPartition;
                    cmd.PartitionType = WstPartitionType.Physical;
                    success = executeNonQueryAtWst(cmd, cmdtxt);
                }
                else
                {
                    LiveMachine mach = getLiveMachine(ar);
                    if (mach.PUIDExistsInMachines)
                    {
                        sendOut("PUID from t_machines : {0}", mach.PUID.ToString());
                        sendOut("Action: Delete from {0} for console ID '{1}'{2}", ar.Modifier, mach.Gamertag, Environment.NewLine);
                        string cmdtxt = "DELETE " + ar.Modifier;
                        cmdtxt += string.Format(" WHERE {0} = {1}", fieldName, user.PUID);
                        sendOut(cmdtxt);
                    }
                    else
                    {
                        sendOut("PUID not found in t_users or t_machines.  Aborting Delete.");
                    }
                }
            }
            return success;
        }

        private static bool deleteGTFromUserNames(ParsedArgs ar)
        {
            bool success = false;
            LiveUser user = getLiveUser(ar);
            if (user.NamesPUID == -1)
            {
                viewUserName(ar);
            }
            else
            {
                string msg = "Action: Delete t_user_names data.";
                msg = addParamToMsg(msg, ar);
                sendOut(msg);
                if (confirmAction("delete t_user_names data for gamertag '" + user.Gamertag + "'"))
                    success = user.deleteNameData();
            }
            return success;
        }

        public static bool executeNonQueryAtWst(WstCommand wstc, string cmdText)
        {
            bool success = false;
            wstc.CommandText = cmdText;
            wstc.CommandType = CommandType.Text;
            string actiontaken = string.Empty;
            try
            {
                int rowsaffected = wstc.ExecuteNonQuery();
                WebstoreDatabase db = wstc.Database;
                sendOut("Executed against server {0}, database {1}.", db.ServerName, db.Name);
                sendOut("{0} rows affected.", rowsaffected.ToString());
                if (rowsaffected > 0)
                {
                    success = true;
                    actiontaken = string.Format("Executed query '{0}' against database '{1}'.", cmdText, db.Name);
                    XappAdmin.logEvent(db.ServerName, actiontaken);
                }
            }
            catch (SystemException e)
            {
                XappAdmin.outputError(e, "executing query '" + cmdText + "' against connection string " + wstc.Connection.ConnectionString);
            }
            return success;
        }

        public static bool executeNonQueryAtWst(WstCommand wstc)
        {
            bool success = false;
            try
            {
                int rowsaffected = wstc.ExecuteNonQuery();
                WebstoreDatabase db = wstc.Database;
                sendOut("Executed against server {0}, database {1}.", db.ServerName, db.Name);
                if (wstc.CommandType == CommandType.Text)
                {
                    Console.WriteLine("{0} rows affected.", rowsaffected);
                }
                if (rowsaffected > 0)
                {
                    success = true;
                }
            }
            catch (SystemException e)
            {
                outputError(e, string.Format("Executing query or procedure '{0}' against connection string {1}:", wstc.CommandText, wstc.Connection.ConnectionString));
            }
            return success;
        }

        public static bool executeSPAtWst(WstCommand wstc)
        {
            bool success = false;
            try
            {
                wstc.ExecuteNonQuery();
                WebstoreDatabase db = wstc.Database;
                sendOut("Executed against server {0}, database {1}.", db.ServerName, db.Name);
                success = true;
            }
            catch (SystemException e)
            {
                outputError(e, string.Format("Error executing query or procedure '{0}' against connection string {1}:", wstc.CommandText, wstc.Connection.ConnectionString));
            }
            return success;
        }

        // Returns: boolean indicating whether the gamertag was found
        //          in any of the three tables hashed on gamertag
        static bool findNameInAny(WstCommand wstcmd, string gamertag)
        {
            bool found = false;
            string cmd = "SELECT 1 FROM dbo.t_user_names";
            cmd += " WHERE vc_gamertag = '" + gamertag + "'";
            cmd += " UNION SELECT 1 FROM dbo.t_user_keys";
            cmd += " WHERE vc_gamertag = '" + gamertag + "'";
            cmd += " UNION SELECT 1 FROM dbo.t_xenon_user_keys";
            cmd += " WHERE vc_gamertag = '" + gamertag + "'";
            WstDataReader findrdr = WstLib.getReaderFromWst(wstcmd, cmd);
            if (!findrdr.IsClosed)
            {
                found = findrdr.HasRows;
            }
            findrdr.Close();
            return found;
        }

        private static string getFieldNameByTable(string tablename, string possiblealias)
        {
            string returnval = string.Empty;
            string tablealias = string.Empty;
            switch (possiblealias.ToLower())
            {
                case "inner":
                case "outer":
                case "join" :
                case "left" :
                case "right":
                case "on"   :
                    tablealias = tablename;
                    break;
                default:
                    tablealias = possiblealias;
                    break;
            }
            switch (tablename.ToLower())
            {
                case "t_achievements":
                    returnval = string.Format("{0}.bi_puid", tablealias);
                    break;
                case "t_machines":
                    returnval = string.Format("{0}.bi_machine_puid", tablealias);
                    break;
                case "t_subscriptions":
                    returnval = string.Format("{0}.bi_primary_puid", tablealias);
                    break;
                case "t_user_keys":
                    returnval = string.Format("{0}.vc_gamertag", tablealias);
                    break;
                case "t_user_names":
                    returnval = string.Format("{0}.vc_gamertag", tablealias);
                    break;
                case "t_user_passport_puids":
                    returnval = string.Format("{0}.bi_user_passport_puid", tablealias);
                    break;
                case "t_xenon_user_keys":
                    returnval = string.Format("{0}.vc_gamertag", tablealias);
                    break;
                default:
                    returnval = string.Format("{0}.bi_user_puid", tablealias);
                    break;
            }
            return returnval;
        }

        private static string getFieldNameByTable(string tablename)
        {
            string returnval = string.Empty;
            string tablealias = tablename;
            switch (tablename.ToLower())
            {
                case "t_achievements":
                    returnval = string.Format("{0}.bi_puid", tablealias);
                    break;
                case "t_machines":
                    returnval = string.Format("{0}.bi_machine_puid", tablealias);
                    break;
                case "t_subscriptions":
                    returnval = string.Format("{0}.bi_primary_puid", tablealias);
                    break;
                case "t_user_keys":
                    returnval = string.Format("{0}.vc_gamertag", tablealias);
                    break;
                case "t_user_names":
                    returnval = string.Format("{0}.vc_gamertag", tablealias);
                    break;
                case "t_user_passport_puids":
                    returnval = string.Format("{0}.bi_user_passport_puid", tablealias);
                    break;
                case "t_xenon_user_keys":
                    returnval = string.Format("{0}.vc_gamertag", tablealias);
                    break;
                default:
                    returnval = string.Format("{0}.bi_user_puid", tablealias);
                    break;
            }
            return returnval;
        }

        private static LiveMachine getLiveMachine(ParsedArgs ar)
        {
            LiveMachine mach = new LiveMachine(ar.WstConnect);
            if (ar.Gamertag == string.Empty)
            {
                mach.PUID = ar.PUID;
            }
            else
            {
                mach.Gamertag = ar.Gamertag;
            }
            return mach;
        }

        private static LiveUser getLiveUser(ParsedArgs a)
        {
            LiveUser user = new LiveUser(a.WstConnect);
            if (a.Gamertag == string.Empty)
            {
                if (a.WLID == -1)
                {
                    user.PUID = a.PUID;
                }
                else
                {
                    user.WLID = a.WLID;
                }
            }
            else
            {
                user.Gamertag = a.Gamertag;
            }
            return user;
        }

        // Returns: machine ID of the user from t_users, if found; otherwise String.Empty
        static long getMachineIDFromUsers(WstCommand wstcmd, long userpuid)
        {
            long machineid = -1;
            string cmd = "SELECT bi_machine_puid";
            cmd += " FROM dbo.t_users";
            cmd += " WHERE bi_user_puid = '" + userpuid.ToString() + "'";
            wstcmd.CommandType = CommandType.Text;
            wstcmd.CommandText = cmd;
            WstDataReader rdr = WstLib.getReaderFromWst(wstcmd);
            if (rdr.HasRows)
            {
                do
                {
                    while (rdr.Read())
                    {
                        machineid = rdr.GetInt64(0);
                        Console.WriteLine("MachineID in t_users : {0}", machineid.ToString());
                    }
                } while (rdr.NextResult());
            }
            else
            {
                Console.WriteLine("Could not find row in t_users for puid {0} with partition {1}.", userpuid.ToString(), wstcmd.LastPartitionExecuted.ToString());
            }
            rdr.Close();
            return machineid;
        }

        internal static int getPartitionFromTable(string tablename, LiveUser userobj)
        {
            int partition = -1;
            switch (tablename.ToLower())
            {
                case "t_user_names":
                    partition = userobj.NamesPartition;
                    break;
                case "t_user_keys":
                    partition = userobj.NamesPartition;
                    break;
                case "t_user_passport_puids":
                    partition = userobj.WLIDPartition;
                    break;
                case "t_xenon_user_keys":
                    partition = userobj.NamesPartition;
                    break;
                default:
                    partition = userobj.PUIDPartition;
                    break;
            }
            return partition;
        }

        internal static int getPartitionFromTable(string tablename, LiveMachine userobj)
        {
            int partition = -1;
            switch (tablename.ToLower())
            {
                case "t_user_names":
                    partition = userobj.NamesPartition;
                    break;
                case "t_user_keys":
                    partition = userobj.NamesPartition;
                    break;
                default:
                    partition = userobj.PUIDPartition;
                    break;
            }
            return partition;
        }

        private static string getValueByTable(string tablename, LiveUser user, LiveMachine machine)
        {
            string returnval = string.Empty;
            switch (tablename.ToLower())
            {
                case "t_user_names":
                    returnval = string.Format("'{0}'", user.Gamertag);
                    break;
                case "t_user_keys":
                    returnval = string.Format("'{0}'", user.Gamertag);
                    break;
                case "t_user_passport_puids":
                    returnval = user.WLID.ToString();
                    break;
                case "t_xenon_user_keys":
                    returnval = string.Format("'{0}'", user.Gamertag);
                    break;
                case "t_machines":
                    // we pass a machine just in case the table warrants a machine PUID instead of a user PUID
                    returnval = machine.PUID.ToString();
                    break;
                default:
                    returnval = user.PUID.ToString();
                    break;
            }
            return returnval;
        }


        private static bool initStoredProc(WstCommand cmd, string procName, string procParams, LiveUser user)
        {
            bool success = false;
            cmd.CommandType = CommandType.StoredProcedure;
            cmd.CommandText = procName;
            if (procParams == string.Empty)
            {
                Console.WriteLine("No parameters entered for stored procedure '{0}'.", procName);
            }
            else
            {
                string[] spparams = splitParams(procParams);
                SqlParameter retparm = cmd.Parameters.Add("@RETURN_VALUE", SqlDbType.Int);
                retparm.Direction = ParameterDirection.ReturnValue;
                foreach (string param in spparams)
                {
                    string[] parmelements = param.Split('=');
                    if (parmelements.Length > 1)
                    {
                        try
                        {
                            // determine which parameters to expect by stored procedure.
                            switch (procName.ToLower())
                            {
                                case "p_stats_gamerscore_update":
                                    switch (parmelements[0])
                                    {
                                        case "@i_title_id":
                                            SqlParameter prm1 = cmd.Parameters.Add("@i_title_id", SqlDbType.Int);
                                            prm1.Value = Convert.ToInt32(parmelements[1]);
                                            break;
                                        case "@i_gamerscore":
                                            SqlParameter prm2 = cmd.Parameters.Add("@i_gamerscore", SqlDbType.Int);
                                            prm2.Value = Convert.ToInt32(parmelements[1]);
                                            break;
                                        case "@i_achievements":
                                            SqlParameter prm3 = cmd.Parameters.Add("@i_achievements", SqlDbType.Int);
                                            prm3.Value = Convert.ToInt32(parmelements[1]);
                                            break;
                                        default:
                                            break;
                                    }
                                    break;
                                default:
                                    break;
                            }
                        }
                        catch (SystemException e)
                        {
                            outputError(e, string.Format("Error entering value {0} for parameter {1}:", parmelements[1], parmelements[0]));
                        }
                    }
                    else
                    {
                        Console.WriteLine("No parameter value for parameter {0}.", parmelements[0]);
                    }
                }
            }
            // now that we have the entered parameters, add additional ones as necessary
            switch (procName.ToLower())
            {
                case "p_stats_gamerscore_update":
                    if (cmd.Parameters.Count == 4)
                    {
                        SqlParameter prm4 = cmd.Parameters.Add("@bi_user_puid", SqlDbType.BigInt);
                        prm4.Value = user.PUID;
                        SqlParameter prm5 = cmd.Parameters.Add("@si_hash_bucket", SqlDbType.SmallInt);
                        prm5.Value = user.PUIDPartition;
                        success = true;
                    }
                    break;
                default:
                    break;
            }
            return success;
        }

        /*******************************************************************
        Purpose: Log SQLAdmin action to command prompt and Windows Event Log
        Inputs : target     : server on which event is to be logged
        *******************************************************************/
        public static void logEvent(string target, string sEvent)
        {
            // log an Information event in the application event log
            string sSource;
            sSource = "XappAdmin";
            sEvent += "\r\nXappAdmin user: " + Environment.UserDomainName;
            sEvent += "\\" + Environment.UserName;
            sEvent += "\r\nXappAdmin client: " + Environment.MachineName;
            try
            {
                EventLog writeLog = new EventLog();
                writeLog.Log = "Application";
                writeLog.MachineName = target;
                writeLog.Source = sSource;
                writeLog.WriteEntry(sEvent);
            }
            catch (SystemException e)
            {
                // no work here - the event logging will fail silently and I'll document this in the GAST docs
                Console.WriteLine(e.Message);
            }
        }

        static bool runAction(ParsedArgs arg)
        {
            bool blnSuccess = false;
            string msg = string.Empty;
            if (arg.Debug)
            {
                Console.WriteLine("runAction begins");
                Console.WriteLine("Action is " + arg.Action);
            }
            switch (arg.Action)
            {
                case "VIEW":
                    msg = "Action: View Webstore data.";
                    break;
                case "SELE":
                    msg = string.Format("Action: SELECT {0} from Webstore table {1}.", arg.PreTable, arg.SelectTable);
                    break;
            }
            if (arg.Action == "VIEW" || arg.Action == "SELE")
            {
                msg = addParamToMsg(msg, arg);
                Console.WriteLine(msg);
            }
            do
            {
                switch (arg.Action)
                {
                    case "DELE":
                        blnSuccess = deleteFromWebstoreDB(arg);
                        break;
                    case "FLAT":
                        blnSuccess = viewObjectFlat(arg);
                        break;
                    case "GTDE":
                        blnSuccess = deleteGTFromUserNames(arg);
                        break;
                    case "HASH":
                        blnSuccess = viewHashData(arg);
                        break;
                    case "LENG":
                        blnSuccess = synchUser(arg);
                        break;
                    case "RUNS": // run stored procedure
                        blnSuccess = runStoredProc(arg);
                        break;
                    case "SELE":
                        if (blnSuccess == false) // one successful run in a list of GTs yields success for the operation as a whole
                        {
                            blnSuccess = selectFromWebstoreDB(arg);
                        }
                        else
                        {
                            selectFromWebstoreDB(arg);
                        }
                        break;
                    case "SYNC":
                        blnSuccess = synchUser(arg);
                        break;
                    case "UPDA":
                        if (arg.LogicalPartitions == -1)
                        {
                            return false;
                        }
                        else
                        {
                            blnSuccess = updateWebstoreDB(arg);
                        }
                        break;
                    case "USAG": // output usage
                        blnSuccess = Usage();
                        break;
                    case "VERS":
                        blnSuccess = true;
                        break;
                    case "VIEW":
                        blnSuccess = viewObject(arg);
                        break;
                    default:
                        Console.WriteLine("Unhandled action passed to runAction.");
                        break;
                }
            } while (arg.Next());
            if (arg.LogStream != null)
            {
                arg.LogStream.Flush();
                arg.LogStream.Close();
                arg.LogStream.Dispose();
            }
            return blnSuccess;
        }

        private static bool runStoredProc(ParsedArgs ar)
        {
            bool success = false;
            LiveUser user = getLiveUser(ar);
            string spName = ar.Modifier;
            if (user.PUIDExistsInUsers)
            {
                Console.WriteLine("PUID from t_users    : {0}", user.PUID);
                Console.WriteLine("Action: Run stored proc '{0}' for gamertag '{1}'.{2}", spName, user.Gamertag, Environment.NewLine);
                WstCommand cmd = new WstCommand();
                cmd.Connection = ar.WstConnect;
                cmd.Partition = user.PUIDBucket;
                cmd.PartitionType = WstPartitionType.Logical;
                if (initStoredProc(cmd, spName, ar.Additional, user))
                {
                    if (executeSPAtWst(cmd))
                    {
                        if (cmd.Parameters[0].ToString() == "0")
                        {
                            Console.WriteLine("Stored procedure executed successfully.");
                            success = true;
                        }
                        else
                        {
                            Console.WriteLine("Stored procedure returned code {0}.", cmd.Parameters[0].ToString());
                        }
                    }
                }
            }
            else
            {
                Console.WriteLine("Could not find PUID for user {0}.", ar.Gamertag);
            }
            return success;
        }

        static bool selectFromWebstoreDB(ParsedArgs ar)
        {
            bool success = false;
            string userid = string.Empty;
            string fieldName = string.Empty;
            string cmdtxt = string.Empty;
            string outtxt = string.Empty;
            byte[] b = new byte[1000];
            LiveUser user = getLiveUser(ar);
            LiveMachine machine = getLiveMachine(ar);
            bool includegamertag = true;
            // if the "SUPPRESSGAMERTAG" modifier (can be shortened to as little as "SUPP")
            // is included then don't include the gamertag
            if (ar.Modifier.Length > 3 && ar.Modifier.Substring(0, 4).ToUpper() == "SUPP")
                includegamertag = false;
            if (user.PUIDExistsInUsers || machine.PUIDExistsInMachines)
            {
                // query using the select list from the ParsedArgs properties
                cmdtxt = string.Format("SELECT {0}", ar.PreTable);
                cmdtxt += string.Format(" FROM {0} WHERE ", ar.SelectTable);
                string[] selecttables = ar.SelectTable.Split(' ');
                if (selecttables.Length > 1)
                {
                    fieldName = getFieldNameByTable(selecttables[0], selecttables[1]);
                }
                else
                {
                    fieldName = getFieldNameByTable(selecttables[0]);
                }
                cmdtxt += string.Format("{0} = {1}{2}", fieldName, getValueByTable(selecttables[0], user, machine), " ");
                if (ar.Additional != string.Empty)
                {
                    cmdtxt += ar.Additional;
                }
                WstCommand cmd = new WstCommand();
                cmd.Connection = ParsedArgs.connectToWST("uodb");
                if (user.PUIDExistsInUsers)
                {
                    cmd.Partition = getPartitionFromTable(ar.SelectTable, user);
                }
                else
                {
                    cmd.Partition = getPartitionFromTable(ar.SelectTable, machine);
                }
                cmd.CommandTimeout = 120;
                cmd.PartitionType = WstPartitionType.Physical;
                WstDataReader rdr = WstLib.getReaderFromWst(cmd, cmdtxt);
                if (user.PUIDExistsInUsers)
                {
                    if (ar.PUID == -1)
                    {
                        userid = user.Gamertag;
                    }
                    else
                    {
                        userid = user.PUID.ToString();
                    }
                }
                else
                {
                    if (ar.PUID == -1)
                    {
                        userid = machine.Gamertag;
                    }
                    else
                    {
                        userid = machine.PUID.ToString();
                    }
                }
                if (WstLib.verifyReader(rdr))
                {
                    try
                    {
                        if (ar.FirstRow)
                        {
                            if (includegamertag)
                            {
                                for (int i = 0; i < rdr.FieldCount; i++)
                                {
                                    // if "vc_gamertag" is in the select list, don't include the gamertag separately
                                    if (rdr.GetName(i).ToString() == "vc_gamertag")
                                        includegamertag = false;
                                }
                            }
                            // return column headings
                            if (includegamertag)
                            {
                                outtxt = string.Format("{0}\t{1}", "gamertag", rdr.GetName(0).ToString());
                            }
                            else
                            {
                                outtxt = rdr.GetName(0).ToString();
                            }
                            for (int i = 1; i < rdr.FieldCount; i++)
                            {
                                outtxt = String.Format("{0}\t{1}", outtxt, rdr.GetName(i).ToString());
                            }
                            sendOut(outtxt);
                            ar.FirstRow = false;
                        }
                        // return actual data from query
                        while (rdr.Read())
                        {
                            if (!includegamertag)
                            {
                                // suppress the gamertag output if the modifier says to
                                if (rdr.GetValue(0).ToString() == "System.Byte[]")
                                {
                                    outtxt = WstLib.getBinaryFromReader(rdr, 0);
                                }
                                else
                                {
                                    outtxt = string.Format(rdr.GetValue(0).ToString());
                                }
                            }
                            else
                            {
                                if (user.PUIDExistsInUsers)
                                {
                                    // include the gamertag output with each row by default
                                    if (rdr.GetValue(0).ToString() == "System.Byte[]")
                                    {
                                        outtxt = string.Format("{0}\t{1}", user.Gamertag, WstLib.getBinaryFromReader(rdr, 0));
                                    }
                                    else
                                    {
                                        outtxt = string.Format("{0}\t{1}", user.Gamertag, rdr.GetValue(0).ToString());
                                    }
                                }
                                else
                                {                                        // include the gamertag output with each row by default
                                    if (rdr.GetValue(0).ToString() == "System.Byte[]")
                                    {
                                        outtxt = string.Format("{0}\t{1}", machine.MachinesSerialNum, WstLib.getBinaryFromReader(rdr, 0));
                                    }
                                    else
                                    {
                                        outtxt = string.Format("{0}\t{1}", machine.MachinesSerialNum, rdr.GetValue(0).ToString());
                                    }
                                }
                            }
                            for (int j = 1; j < rdr.FieldCount; j++)
                            {
                                if (rdr.GetValue(j).ToString() == "System.Byte[]")
                                {
                                    outtxt = string.Format("{0}\t{1}", outtxt, WstLib.getBinaryFromReader(rdr, j));
                                }
                                else
                                {
                                    outtxt = String.Format("{0}\t{1}", outtxt, rdr.GetValue(j).ToString());
                                }
                            }
                            sendOut(outtxt);
                            success = true;
                        }
                    }
                    catch (SystemException e)
                    {
                        Console.WriteLine("Error returning results from:");
                        Console.WriteLine(cmdtxt);
                        Console.WriteLine(e.Message);
                        Console.WriteLine("Server  : {0}", user.PUIDServer);
                        Console.WriteLine("Database: {0}", user.PUIDDatabase);
                    }
                }
                WstLib.disposeReader(rdr);
            }
            else
            {
                Console.WriteLine("PUID not found in t_users or t_machines.");
            }
            return success;
        }

        internal static void sendOut()
        {
            sendOut("");
        }

        internal static void sendOut(string msg)
        {
            Console.WriteLine(msg);
            if (LogObj != null)
                LogObj.WriteLine(msg);
        }

        internal static void sendOut(string msg, string param1)
        {
            sendOut(string.Format(msg, param1));
        }

        internal static void sendOut(string msg, string param1, string param2)
        {
            sendOut(string.Format(msg, param1, param2));
        }

        internal static void sendOut(string msg, string param1, string param2, string param3)
        {
            sendOut(string.Format(msg, param1, param2, param3));
        }

        internal static void sendOut(string msg, string param1, string param2, string param3, string param4)
        {
            sendOut(string.Format(msg, param1, param2, param3, param4));
        }

        internal static void sendOut(string msg, string param1, string param2, string param3, string param4, string param5)
        {
            sendOut(string.Format(msg, param1, param2, param3, param4, param5));
        }

        private static string[] splitParams(string procParams)
        {
            string[] retparams = procParams.Split(' ');
            if (procParams == string.Empty)
            {
                Console.WriteLine("No stored procedure parameters provided.");
            }
            return retparams;
        }

        static bool synchUser(ParsedArgs ar)
        {
            sendOut("Action: Synchronize user data.{0}", Environment.NewLine);
            sendOut("Entered Gamertag (GT): {0}", ar.Gamertag);
            LiveUser user = new LiveUser(ar.WstConnect, ar.Gamertag);
            string msg = string.Empty;
            bool success = false;
            int partcount = ar.LogicalPartitions;
            DateTime dateOfPurchase = new DateTime(1, 1, 1, 0, 0, 0, 0);
            DateTime nullDate = new DateTime(1, 1, 1, 0, 0, 0, 0);
            if (user.Gamertag != string.Empty)
            {
                sendOut("GT from t_user_names : {0}", user.Gamertag);
                sendOut("Gamertag Partition   : {0}", user.NamesPartition.ToString());
            }
            if (user.PUID == -1) // if the user's puid doesn't exist in t_users
            {
                if (user.NamesPUID != -1)
                {
                    sendOut("PUID {0} not found in t_users.", user.NamesPUID.ToString());
                    sendOut("Re-run synchuser with the old gamertag to verify login capability.");
                }
                else
                {
                    sendOut("PUID not found in t_users.", user.NamesPUID.ToString());
                    sendOut("Re-run synchuser with the old gamertag to verify login capability.");
                }
            }
            else
            {
                if (user.Gamertag.ToUpper() == user.UsersGamertag.ToUpper())
                {
                    // the two are equal. nothing to see here! move along!
                    sendOut("{0}Gamertags are equal in t_users and t_user_names.  No GT change action taken.", Environment.NewLine);
                    success = true;
                }
                else
                {
                    // we found the gamertag in t_user_names
                    Console.WriteLine("User PUID            : {0}", user.PUID);
                    // look for new name in t_user_keys and t_xenon_user_keys
                    if (!user.GTExistsInUser_Keys)
                    {
                        sendOut("{1}Gamertag '{0}' from t_user_names is missing from t_user_keys or t_xenon_user_keys.", user.Gamertag, Environment.NewLine);
                        sendOut("Comparing '{0}' from t_users.{1}", user.UsersGamertag, Environment.NewLine);
                        // if the UsersGamertag user is sound, delete this user
                        LiveUser t_usersUser = new LiveUser(ar.WstConnect);
                        t_usersUser.Gamertag = user.UsersGamertag;
                        if (t_usersUser.PUIDExistsInMachines)
                        {
                            sendOut("'{0}' is a machine account.", user.UsersGamertag);
                            if (user.Gamertag.Length > 0)
                            {
                                sendOut("Synching to '{0}' is the best available option.{1}", user.Gamertag, Environment.NewLine);
                                user.SynchGamertagInUsers();
                                user.Refresh();
                            }
                        }
                        else
                        {
                            if (t_usersUser.NamesPUID == -1)
                            {
                                sendOut("User '{0}' doesn't exist in t_user_names.", user.UsersGamertag);
                                if (user.Gamertag.Length > 0)
                                {
                                    sendOut("Synching to '{0}' as the best available option.{1}", user.Gamertag, Environment.NewLine);
                                    user.SynchGamertagInUsers();
                                    user.Refresh();
                                }
                                else
                                {
                                    if (user.ChangeToGamertag != string.Empty)
                                    {
                                        msg = string.Format("*** Re-run synch for gamertag '{0}'. ***", user.ChangeToGamertag);
                                        sendOut("{0}", string.Empty.PadLeft(msg.Length, '*'));
                                        sendOut(msg);
                                        sendOut("{0}", string.Empty.PadLeft(msg.Length, '*'));
                                    }
                                    else
                                    {
                                        sendOut("Run XappAdmin view against PUID {0} to troubleshoot.", user.PUID.ToString());
                                    }
                                }
                            }
                            else
                            {
                                success = checkForDelete(t_usersUser, user);
                            }
                        }
                    }
                    else
                    {
                        // change the partition based on the hash of PUID, rather than gamertag
                        WstCommand puidcmd = ar.WstConnect.CreateCommand();
                        Console.WriteLine("PUID Partition       : {0}", user.PUIDPartition);
                        if (user.UsersGamertag != string.Empty)
                        {
                            // we found the puid in t_users!
                            Console.WriteLine("GT in t_users        : {0}", user.UsersGamertag);
                            // if the two aren't equal, we'll want to know what the UsersGamertag user looks like
                            LiveUser t_usersUser = new LiveUser(ar.WstConnect);
                            t_usersUser.Gamertag = user.UsersGamertag;
                            WstCommand oldnamecmd = ar.WstConnect.CreateCommand();
                            oldnamecmd.PartitionType = WstPartitionType.Logical;
                            oldnamecmd.Partition = WstHash.GetHash(user.UsersGamertag.ToLower(), ar.LogicalPartitions);
                            if (findNameInAny(oldnamecmd, user.UsersGamertag))
                            {
                                sendOut("Old GT partition     : {0}", oldnamecmd.LastPartitionExecuted.ToString());
                                // we found the old gamertag.
                                sendOut("{0}'{1}' found in t_user_names, t_user_keys, or t_xenon_user_keys.{0}", Environment.NewLine, user.UsersGamertag);
                                if (user.ChangeToGamertag == user.Gamertag)
                                {
                                    // if the user's GT did indeed change to the GT in t_user_names, we still need to synch.
                                    sendOut("Deleting data for {0}, per gamertag change history.", user.UsersGamertag);
                                    t_usersUser.deleteNameData();
                                    user.SynchGamertagInUsers();
                                    user.Refresh();
                                }
                                else
                                {
                                    if (t_usersUser.PUIDExistsInMachines)
                                    {
                                        sendOut("Synching because '{1}' is a machine account.", user.Gamertag, user.UsersGamertag);
                                        user.SynchGamertagInUsers();
                                        user.Refresh();
                                    }
                                    else
                                    {
                                        if (ar.Modifier == "OVERRIDE")
                                        {
                                            sendOut("Updating anyway due to user OVERRIDE input.");
                                            user.SynchGamertagInUsers();
                                            // now that we updated successfully, verify that the "old" value has changed
                                            user.Refresh();
                                        }
                                        else
                                        {
                                            success = checkForDelete(t_usersUser, user);
                                        }
                                    }
                                }
                            }
                            else
                            {
                                Console.WriteLine("Old GT partition     : {0}", oldnamecmd.LastPartitionExecuted);
                                sendOut("{0}'{1}' not found in t_user_names, t_user_keys, or t_xenon_user_keys.", Environment.NewLine, user.UsersGamertag);
                                user.SynchGamertagInUsers();
                                // now that we updated successfully, verify that the "old" value has changed
                                user.Refresh();
                            }
                        }
                    }
                    Console.WriteLine("GT in t_users        : {0}", user.UsersGamertag);
                    if (user.Gamertag == user.UsersGamertag)
                    {
                        sendOut("{0}Update succeeded -- verified by query.{0}", Environment.NewLine);
                        success = true;
                    }
                    // verify that the user purchased a gamertag change at some point
                    sendOut(user.gamertagChangePurchase());
                }
                if (user.FriendsLength != user.NumOfFriends)
                {
                    sendOut("t_users.i_friend_list_len doesn't match row count in t_xprof_friend_lists!");
                    sendOut("t_users friend count : {0}", user.FriendsLength.ToString());
                    sendOut("t_xprof_friend_lists : {0}", user.NumOfFriends.ToString());
                }
                if (user.LockoutListLength != user.NumOfLockouts)
                {
                    sendOut("t_users.i_lockout_list_len doesn't match row count in t_xprof_lockout_lists!");
                    sendOut("t_users lockout count: {0}", user.LockoutListLength.ToString());
                    sendOut("t_xprof_lockout_lists: {0}", user.NumOfLockouts.ToString());
                }
                if ((user.FriendsLength != user.NumOfFriends) || (user.LockoutListLength != user.NumOfLockouts))
                {
                    user.SynchLengths();
                    user.Refresh();
                }
                else
                {
                    sendOut("{0}User lengths are already in synch.  No length action taken.{0}", Environment.NewLine);
                    Console.WriteLine("Number of friends    : {0}", user.FriendsLength);
                    Console.WriteLine("Number of lockouts   : {0}", user.LockoutListLength);
                }
                if ((user.FriendsLength == user.NumOfFriends) & (user.LockoutListLength == user.NumOfLockouts))
                {
                    success = true;
                }
                else
                {
                    if (user.FriendsLength != user.NumOfFriends)
                    {
                        sendOut("t_users.i_friend_list_len doesn't match row count in t_xprof_friend_lists!");
                        sendOut("t_users friend count : {0}", user.FriendsLength.ToString());
                        sendOut("t_xprof_friend_lists : {0}", user.NumOfFriends.ToString());
                    }
                    if (user.LockoutListLength != user.NumOfLockouts)
                    {
                        sendOut("t_users.i_lockout_list_len doesn't match row count in t_xprof_lockout_lists!");
                        sendOut("t_users lockout count: {0}", user.LockoutListLength.ToString());
                        sendOut("t_xprof_lockout_lists: {0}", user.NumOfLockouts.ToString());
                    }
                }
            }
            sendOut();
            return success;
        }

        static bool updateWebstoreDB(ParsedArgs ar)
        {
            bool success = false;
            string fieldName = "bi_user_puid";
            LiveUser user = getLiveUser(ar);
            if (user.PUIDExistsInUsers)
            {
                Console.WriteLine("PUID from t_users    : {0}", user.PUID);
                sendOut("Action: Update {0}, set {1}, for gamertag '{2}'", ar.PreTable, ar.Update, user.Gamertag);
                if (ar.Additional != string.Empty)
                {
                    sendOut("        {0}", ar.Additional);
                }
                else
                {
                    sendOut();
                }
                string cmdtxt = string.Format("UPDATE {0}", ar.PreTable);
                cmdtxt += " SET " + ar.Update;
                if (cmdtxt.ToLower().IndexOf("dt_change_datetime") == -1)
                    // add dt_change_datetime if it's not already there to prevent firing the trigger
                    cmdtxt += ", dt_Change_Datetime = getdate()";
                cmdtxt += string.Format(" WHERE {0} = {1}", fieldName, user.PUID);
                if (ar.Additional != string.Empty)
                {
                    cmdtxt += ar.Additional;
                }
                WstCommand cmd = new WstCommand();
                cmd.Connection = ar.WstConnect;
                cmd.Partition = getPartitionFromTable(ar.PreTable, user);
                cmd.PartitionType = WstPartitionType.Physical;
                success = executeNonQueryAtWst(cmd, cmdtxt);
            }
            else
            {
                LiveMachine mach = getLiveMachine(ar);
                if (mach.PUIDExistsInMachines)
                {
                    Console.WriteLine("PUID from t_machines : {0}", mach.PUID);
                    Console.WriteLine("Action: Update {0}, set {1}, for console ID '{2}'{3}", ar.Modifier, ar.Update, mach.Gamertag, Environment.NewLine);
                    string cmdtxt = "UPDATE " + ar.Modifier;
                    cmdtxt += " SET " + ar.Update;
                    cmdtxt += ", dt_Change_Datetime = getdate()";
                    cmdtxt += string.Format(" WHERE {0} = {1}", fieldName, user.PUID);
                    Console.WriteLine(cmdtxt);
                }
                else
                {
                    Console.WriteLine("PUID not found in t_users or t_machines.  Aborting Update.");
                }
            }
            return success;
        }

        private static void validateOneUserLength(WstConnection wst, string gt, StreamWriter log)
        {
            LiveUser user = new LiveUser(wst);
            user.Gamertag = gt;
            // only continue if we found the gamertag in t_user_names
            if (user.NamesPUID != -1)
            {
                if (user.PUIDExistsInUsers)
                {
                    if (user.NumOfLockouts != user.LockoutListLength)
                    {
                        user.Refresh();  // one refresh ensures it wasn't just a fluke of timing.
                        if (user.NumOfLockouts != user.LockoutListLength)
                        {
                            sendOut(user.Gamertag);
                        }
                    }
                }
            }
        }

        private static bool viewHashData(ParsedArgs ar)
        {
            bool success = false;
            string partition = string.Empty;
            string thisval = string.Empty;
            string server = string.Empty;
            string database = string.Empty;
            WstCommand myCmd = ar.WstConnect.CreateCommand();
            if (ar.PUID != -1)
            {
                myCmd.Partition = WstHash.GetHash(ar.PUID, ar.LogicalPartitions);
                thisval = string.Format("PUID {0}", ar.PUID.ToString());
                partition = myCmd.Partition.ToString().PadLeft(3);
            }
            else if (ar.Gamertag != String.Empty)
            {
                myCmd.Partition = WstHash.GetHash(ar.Gamertag.ToLower(), ar.LogicalPartitions);
                thisval = string.Format("Gamertag '{0}'", ar.Gamertag);
                partition = myCmd.Partition.ToString().PadLeft(3);
            }
            myCmd.CommandText = "SELECT @@SERVERNAME, DB_NAME(db_id())";
            myCmd.CommandType = CommandType.Text;
            myCmd.WstFailoverMode = WstFailoverMode.PrimaryThenSecondary;
            WstDataReader serverrecord = WstLib.getReaderFromWst(myCmd);
            server = WstLib.getStringFromReader(serverrecord);
            database = WstLib.getStringFromReader(serverrecord, 1);
            sendOut("{0} hashes to bucket {1} on FSS {2}, DB: {3}.{4}", thisval, partition, myCmd.LastPartitionExecuted.ToString().PadLeft(3), server, database);
            WstLib.disposeReader(serverrecord);
            success = true;
            return success;
        }

        private static bool viewMachine(ParsedArgs arg)
        {
            bool success = false;
            LiveMachine mach = getLiveMachine(arg);
            if (arg.Columns.IndexOf("1") != -1)
            {
                if (arg.Gamertag == string.Empty)
                {
                    Console.WriteLine("{1}Entered PUID         (1): {0}", mach.EnteredPUID, Environment.NewLine);
                }
                else
                {
                    Console.WriteLine("{1}Entered consoleID    (1): {0}", mach.EnteredGamertag, Environment.NewLine);
                }
            }
            if (arg.Columns.IndexOf("2") != -1)
                Console.WriteLine("Gamertag hash bucket (2): {0}", mach.NamesBucket);
            if (arg.Columns.IndexOf("3") != -1)
                Console.WriteLine("Gamertag partition   (3): {0}", mach.NamesPartition);
            if (arg.Columns.IndexOf("4") != -1)
                Console.WriteLine("Gamertag server      (4): {0}", mach.NamesServer);
            if (arg.Columns.IndexOf("5") != -1)
                Console.WriteLine("Gamertag database    (5): {0}", mach.NamesDatabase);
            // only continue if we found the gamertag in t_user_names
            if (mach.NamesPUID == -1)
            {
                Console.WriteLine("Could not find t_user_names row at the above location");
            }
            else
            {
                if (arg.Columns.IndexOf("6") != -1)
                    Console.WriteLine("GT from t_user_names (6): {0}", mach.Gamertag);
                if (arg.Columns.IndexOf("8") != -1)
                    Console.WriteLine("PUID in t_machines   (8): {0}", mach.PUID);
                if (arg.Columns.IndexOf("9") != -1)
                    Console.WriteLine("PUID in t_user_names (9): {0}", mach.NamesPUID);
                if (arg.Columns.IndexOf("10") != -1)
                    Console.WriteLine("PUID in hex         (10): {0}", mach.PUIDInHex);
                if (arg.Columns.IndexOf("11") != -1)
                    Console.WriteLine("PUID hash bucket    (11): {0}", mach.PUIDBucket);
                if (arg.Columns.IndexOf("12") != -1)
                    Console.WriteLine("PUID partition      (12): {0}", mach.PUIDPartition);
                if (arg.Columns.IndexOf("13") != -1)
                    Console.WriteLine("PUID server         (13): {0}", mach.PUIDServer);
                if (arg.Columns.IndexOf("14") != -1)
                    Console.WriteLine("PUID database       (14): {0}", mach.PUIDDatabase);
                // look for new name in t_users and t_machines
                if (!mach.PUIDExistsInMachines)
                {
                    string outstr = "PUID doesn't exist in t_machines";
                    Console.WriteLine(outstr);
                }
                else
                {
                    if (!mach.PUIDExistsInMachines)
                    {
                        Console.WriteLine("Could not find row in t_machines for puid {0} on partition {1}", mach.NamesPUID, mach.PUIDPartition);
                    }
                }
                success = true;
            }
            return success;
        }

        private static bool viewObjectFlat(ParsedArgs arg)
        {
            bool success = false;
            switch (arg.Modifier.Substring(0, 4).ToUpper())
            {
                case "MACH":
                    success = viewMachineFlat(arg);
                    break;
                case "USER":
                    success = viewUserFlat(arg);
                    break;
                default:
                    LiveUser us = getLiveUser(arg);
                    if (us.PUIDExistsInUsers)
                    {
                        success = viewUserFlat(arg);
                    }
                    else
                    {
                        if (us.PUIDExistsInMachines)
                        {
                            success = viewMachineFlat(arg);
                        }
                    }
                    break;
            }
            return success;
        }

        private static bool viewObject(ParsedArgs arg)
        {
            bool success = false;
            if (arg.Modifier.Length > 3)
            {
                switch (arg.Modifier.Substring(0, 4).ToUpper())
                {
                    case "MACH":
                        success = viewMachine(arg);
                        break;
                    case "USER":
                        sendOut("");
                        success = viewUserName(arg);
                        break;
                }
            }
            else
            {
                LiveUser us = getLiveUser(arg);
                if (us.PUIDExistsInUsers)
                {
                    success = viewUserName(arg);
                }
                else
                {
                    if (us.PUIDExistsInMachines)
                    {
                        success = viewMachine(arg);
                    }
                }
            }
            if (arg.Debug)
                Console.WriteLine("viewObject success: {0}", success.ToString());
            return success;
        }

        static bool viewUserName(ParsedArgs ar)
        {
            bool success = false;
            LiveUser user = getLiveUser(ar);
            if (ar.Columns.IndexOf("1") != -1)
            {
                if (ar.Gamertag == string.Empty)
                {
                    if (ar.WLID == -1)
                    {
                        sendOut("Entered PUID         (1): {0}", user.EnteredPUID.ToString(), Environment.NewLine);
                    }
                    else
                    {
                        sendOut("Entered WLID         (1): {0}", user.EnteredWLID.ToString(), Environment.NewLine);
                    }
                }
                else
                {
                    sendOut("Entered gamertag     (1): {0}", user.EnteredGamertag, Environment.NewLine);
                }
            }
            if (user.PUIDExistsInMachines)
            {
                LiveMachine machine = getLiveMachine(ar);
                if (ar.Columns.IndexOf("2") != -1)
                    sendOut("ConsoleID hash bucket(2): {0}", user.NamesBucket.ToString());
                if (ar.Columns.IndexOf("3") != -1)
                    sendOut("ConsoleID partition  (3): {0}", user.NamesPartition.ToString());
                if (ar.Columns.IndexOf("4") != -1)
                    sendOut("ConsoleID server     (4): {0}", user.NamesServer);
                if (ar.Columns.IndexOf("5") != -1)
                    sendOut("ConsoleID database   (5): {0}", user.NamesDatabase);
                // only continue if we found the consoleid in t_user_names
                if (machine.NamesPUID == -1)
                {
                    if (ar.Gamertag == string.Empty)
                    {
                        sendOut("Could not find t_user_names row for console with PUID '{0}'.", user.EnteredPUID.ToString());
                    }
                    else
                    {
                        sendOut("Could not find t_user_names row for console '{0}'.", user.EnteredGamertag);
                    }
                }
                else
                {
                    if (ar.Columns.IndexOf("6") != -1)
                        sendOut("CID from t_user_names(6): {0}", machine.Gamertag);
                    if (ar.Columns.IndexOf("8") != -1)
                        sendOut("PUID in t_machines   (8): {0}", machine.PUID.ToString());
                    if (ar.Columns.IndexOf("9") != -1)
                        sendOut("PUID in t_user_names (9): {0}", machine.NamesPUID.ToString());
                    if (ar.Columns.IndexOf("10") != -1)
                        sendOut("PUID in hex         (10): {0}", machine.PUIDInHex);
                    if (ar.Columns.IndexOf("11") != -1)
                        sendOut("PUID hash bucket    (11): {0}", machine.PUIDBucket.ToString());
                    if (ar.Columns.IndexOf("12") != -1)
                        sendOut("PUID partition      (12): {0}", machine.PUIDPartition.ToString());
                    if (ar.Columns.IndexOf("13") != -1)
                        sendOut("PUID server         (13): {0}", machine.PUIDServer);
                    if (ar.Columns.IndexOf("14") != -1)
                        sendOut("PUID database       (14): {0}", machine.PUIDDatabase);
                    if (machine.Gamertag != string.Empty)
                    {
                        // we found the puid in t_machines!
                        if (machine.Gamertag.ToLower() != machine.MachinesSerialNum.ToLower())
                        {
                            sendOut("t_machines gamertag does not match that in t_user_names!");
                            // if the gamertage in t_users doesn't match that in t_user_names
                            // find out of the gamertag in t_users also exists in t_user_names
                            WstCommand oldnamecmd = ar.WstConnect.CreateCommand();
                            oldnamecmd.Partition = WstHash.GetHash(user.UsersGamertag.ToLower(), ar.LogicalPartitions);
                            findNameInAny(oldnamecmd, user.Gamertag);
                            sendOut("Serial in t_machines(15): {0}", machine.MachinesSerialNum);
                            oldnamecmd.Dispose();
                        }
                        else
                        {
                            if (ar.Columns.IndexOf("15") != -1)
                                sendOut("Serial in t_machines(15): {0}", machine.MachinesSerialNum);
                        }
                        success = true;
                    }
                }
            }
            else
            {
                if (ar.Columns.IndexOf("2") != -1)
                    sendOut("Gamertag hash bucket (2): {0}", user.NamesBucket.ToString());
                if (ar.Columns.IndexOf("3") != -1)
                    sendOut("Gamertag partition   (3): {0}", user.NamesPartition.ToString());
                if (ar.Columns.IndexOf("4") != -1)
                    sendOut("Gamertag server      (4): {0}", user.NamesServer);
                if (ar.Columns.IndexOf("5") != -1)
                    sendOut("Gamertag database    (5): {0}", user.NamesDatabase);
                // only continue if we found the gamertag in t_user_names
                if (user.NamesPUID == -1)
                {
                    if (ar.Gamertag == string.Empty)
                    {
                        sendOut("Could not find t_user_names row for user '{0}'.", user.EnteredPUID.ToString());
                    }
                    else
                    {
                        sendOut("Could not find t_user_names row for user '{0}'.", user.EnteredGamertag);
                    }
                    sendOut("Location information above represents where the data SHOULD have been.");
                }
                else
                {
                    if (ar.Columns.IndexOf("6") != -1)
                        sendOut("GT from t_user_names (6): {0}", user.Gamertag);
                    if (ar.Columns.IndexOf("7") != -1)
                        sendOut("GT keys present      (7): {0}", user.GTExistsInUser_Keys.ToString());
                }
                if (user.PUID != -1)
                {
                    if (ar.Columns.IndexOf("8") != -1)
                        sendOut("PUID in t_users      (8): {0}", user.PUID.ToString());
                }
                if (user.NamesPUID != -1)
                {
                    if (ar.Columns.IndexOf("9") != -1)
                        sendOut("PUID in t_user_names (9): {0}", user.NamesPUID.ToString());
                    if (ar.Columns.IndexOf("10") != -1)
                        sendOut("PUID in hex         (10): {0}", user.PUIDInHex);
                }
                if (user.PUID != -1)
                {
                    if (ar.Columns.IndexOf("11") != -1)
                        sendOut("PUID hash bucket    (11): {0}", user.PUIDBucket.ToString());
                    if (ar.Columns.IndexOf("12") != -1)
                        sendOut("PUID partition      (12): {0}", user.PUIDPartition.ToString());
                    if (ar.Columns.IndexOf("13") != -1)
                        sendOut("PUID server         (13): {0}", user.PUIDServer);
                    if (ar.Columns.IndexOf("14") != -1)
                        sendOut("PUID database       (14): {0}", user.PUIDDatabase);
                }
                if (user.PUID == -1)
                {
                    Console.WriteLine("No single, valid PUID found.");
                }
                else
                {
                    // look for new name in t_users and t_machines
                    if (!user.PUIDExistsInUsers)
                    {
                        string outstr = "PUID doesn't exist in t_users";
                        if (user.PUIDExistsInMachines)
                        {
                            outstr += "; it exists in t_machines instead.";
                        }
                        else
                        {
                            outstr += " or in t_machines.";
                        }
                        sendOut(outstr);
                    }
                    else
                    {
                        if (user.Gamertag != string.Empty)
                        {
                            // we found the puid in t_users!
                            if (user.Gamertag.ToLower() != user.UsersGamertag.ToLower())
                            {
                                sendOut("t_users gamertag does not match that in t_user_names!");
                                // if the gamertage in t_users doesn't match that in t_user_names
                                // find out of the gamertag in t_users also exists in t_user_names
                                WstCommand oldnamecmd = ar.WstConnect.CreateCommand();
                                oldnamecmd.Partition = WstHash.GetHash(user.UsersGamertag.ToLower(), ar.LogicalPartitions);
                                findNameInAny(oldnamecmd, user.Gamertag);
                                sendOut("Gamertag in t_users (15): {0}", user.UsersGamertag);
                                oldnamecmd.Dispose();
                            }
                            else
                            {
                                if (ar.Columns.IndexOf("15") != -1)
                                    sendOut("Gamertag in t_users (15): {0}", user.UsersGamertag);
                            }
                        }
                        else
                        {
                            if (ar.Columns.IndexOf("15") != -1)
                                sendOut("Gamertag in t_users (15): {0}", user.UsersGamertag);
                        }
                        if (user.FriendsLength != user.NumOfFriends)
                        {
                            sendOut("t_users.i_friend_list_len doesn't match row count in t_xprof_friend_lists!");
                            sendOut("t_users friend count    : {0}", user.FriendsLength.ToString());
                            sendOut("t_xprof_friend_lists    : {0}", user.NumOfFriends.ToString());
                        }
                        else
                        {
                            if (ar.Columns.IndexOf("16") != -1)
                                sendOut("Number of friends   (16): {0}", user.FriendsLength.ToString());
                        }
                        if (user.LockoutListLength != user.NumOfLockouts)
                        {
                            sendOut("t_users.i_lockout_list_len doesn't match row count in t_xprof_lockout_lists!");
                            sendOut("t_users lockout count   : {0}", user.LockoutListLength.ToString());
                            sendOut("t_xprof_lockout_lists   : {0}", user.NumOfLockouts.ToString());
                        }
                        else
                        {
                            if (ar.Columns.IndexOf("17") != -1)
                                sendOut("Number of lockouts  (17): {0}", user.LockoutListLength.ToString());
                        }
                        if (ar.Columns.IndexOf("18") != -1)
                            sendOut("Consoles            (18): {0}", user.ConsoleString);
                        if (ar.Columns.IndexOf("19") != -1)
                            sendOut("Windows Live ID     (19): {0}", user.WLID.ToString());
                        if (ar.Columns.IndexOf("20") != -1)
                            sendOut(user.LicenseString);
                        if (ar.Columns.IndexOf("21") != -1)
                            sendOut(user.gamertagChangePurchase());
                        success = true;
                    }
                }
            }
            if (ar.Debug)
                Console.WriteLine("viewUser success: {0}", success.ToString());
            return success;
        }

        static bool viewMachineFlat(ParsedArgs ar)
        {
            bool success = false;
            string delim = "\t";
            LiveMachine mach = getLiveMachine(ar);
            string outputline = string.Empty;
            if (ar.Columns.IndexOf("1") != -1)
            {
                if (mach.EnteredGamertag == string.Empty)
                {
                    outputline = addToString(outputline, mach.EnteredPUID.ToString(), delim);
                }
                else
                {
                    outputline = addToString(outputline, mach.EnteredGamertag, delim);
                }
            }
            if (ar.Columns.IndexOf("2") != -1)
                outputline = addToString(outputline, mach.NamesBucket.ToString(), delim);
            if (ar.Columns.IndexOf("3") != -1)
                outputline = addToString(outputline, mach.NamesPartition.ToString(), delim);
            if (ar.Columns.IndexOf("4") != -1)
                outputline = addToString(outputline, mach.NamesServer, delim);
            if (ar.Columns.IndexOf("5") != -1)
                outputline = addToString(outputline, mach.NamesDatabase, delim);
            if (ar.Columns.IndexOf("6") != -1)
                outputline = addToString(outputline, mach.Gamertag, delim);
            if (ar.Columns.IndexOf("8") != -1)
                outputline = addToString(outputline, mach.PUID.ToString(), delim);
            if (ar.Columns.IndexOf("9") != -1)
                outputline = addToString(outputline, mach.NamesPUID.ToString(), delim);
            if (ar.Columns.IndexOf("10") != -1)
                outputline = addToString(outputline, mach.PUIDInHex, delim);
            if (ar.Columns.IndexOf("11") != -1)
                outputline = addToString(outputline, mach.PUIDBucket.ToString(), delim);
            if (ar.Columns.IndexOf("12") != -1)
                outputline = addToString(outputline, mach.PUIDPartition.ToString(), delim);
            if (ar.Columns.IndexOf("13") != -1)
                outputline = addToString(outputline, mach.PUIDServer, delim);
            if (ar.Columns.IndexOf("14") != -1)
                outputline = addToString(outputline, mach.PUIDDatabase, delim);
            sendOut(outputline);
            success = true;
            return success;
        }

        static bool viewUserFlat(ParsedArgs ar)
        {
            bool success = false;
            string delim = "\t";
            LiveUser user = getLiveUser(ar);
            string outputline = string.Empty;
            if (ar.Columns.IndexOf("1") != -1)
            {
                if (user.EnteredGamertag == string.Empty)
                {
                    outputline = addToString(outputline, user.EnteredPUID.ToString(), delim);
                }
                else
                {
                    outputline = addToString(outputline, user.EnteredGamertag, delim);
                }
            }
            if (ar.Columns.IndexOf("2") != -1)
                outputline = addToString(outputline, user.NamesBucket.ToString(), delim);
            if (ar.Columns.IndexOf("3") != -1)
                outputline = addToString(outputline, user.NamesPartition.ToString(), delim);
            if (ar.Columns.IndexOf("4") != -1)
                outputline = addToString(outputline, user.NamesServer, delim);
            if (ar.Columns.IndexOf("5") != -1)
                outputline = addToString(outputline, user.NamesDatabase, delim);
            if (ar.Columns.IndexOf("6") != -1)
                outputline = addToString(outputline, user.Gamertag, delim);
            if (ar.Columns.IndexOf("7") != -1)
                outputline = addToString(outputline, user.GTExistsInUser_Keys.ToString(), delim);
            if (ar.Columns.IndexOf("8") != -1)
                outputline = addToString(outputline, user.PUID.ToString(), delim);
            if (ar.Columns.IndexOf("9") != -1)
                outputline = addToString(outputline, user.NamesPUID.ToString(), delim);
            if (ar.Columns.IndexOf("10") != -1)
                outputline = addToString(outputline, user.PUIDInHex, delim);
            if (ar.Columns.IndexOf("11") != -1)
                outputline = addToString(outputline, user.PUIDBucket.ToString(), delim);
            if (ar.Columns.IndexOf("12") != -1)
                outputline = addToString(outputline, user.PUIDPartition.ToString(), delim);
            if (ar.Columns.IndexOf("13") != -1)
                outputline = addToString(outputline, user.PUIDServer, delim);
            if (ar.Columns.IndexOf("14") != -1)
                outputline = addToString(outputline, user.PUIDDatabase, delim);
            if (ar.Columns.IndexOf("15") != -1)
                outputline = addToString(outputline, user.UsersGamertag, delim);
            if (ar.Columns.IndexOf("16") != -1)
                outputline = addToString(outputline, user.FriendsLength.ToString(), delim);
            if (ar.Columns.IndexOf("17") != -1)
                outputline = addToString(outputline, user.LockoutListLength.ToString(), delim);
            if (ar.Columns.IndexOf("18") != -1)
                outputline = addToString(outputline, user.ConsoleString, delim);
            if (ar.Columns.IndexOf("19") != -1)
                outputline = addToString(outputline, user.WLID.ToString(), delim);
            sendOut(outputline);
            success = true;
            return success;
        }

        static bool Usage()
        {
            Console.WriteLine("Usage:");
            Console.WriteLine("xappadmin /A action /L logfile [/S tablename /D deployment|/G gamertag]");
            Console.WriteLine();
            Console.WriteLine("/A: Action to be performed.  The following actions are supported:");
            Console.WriteLine(" Delete (deletes individual table rows related to a single gamertag)");
            Console.WriteLine(" FlatView (same as view, with results returned one row per gamertag)");
            Console.WriteLine(" LengthSynch (synchs t_user lengths with corresponding row counts)");
            Console.WriteLine(" Select (gets values from a table)");
            Console.WriteLine(" Synch (fix all known referential integrity issues for user)");
            Console.WriteLine(" Update (updates row in partition based on hashing of gamertag or PUID)");
            Console.WriteLine(" View (view user data by gamertag or puid)");
            Console.WriteLine("/C: Columns to include in output, in comma-delimited numeric format");
            Console.WriteLine("    Use view action to determine ID numbers for each datum");
            Console.WriteLine("/D: Webstore deployment to update");
            Console.WriteLine("/G: Gamertag against which to operate - NOTE: use quotes if there are spaces");
            Console.WriteLine("    Supports multiple gamertags, comma-delimited");
            Console.WriteLine("    Also supports a text file path, with the gamertags listed one per line");
            Console.WriteLine("/L: For supported actions, the path to the log file to which output is sent");
            Console.WriteLine("/P: PUID against which to operate (not valid when /G is present)");
            Console.WriteLine("/T: Integer timeout for operation.  Defaults to 30 seconds");
            Console.WriteLine("/V: Verbose mode");
            Console.WriteLine("/W: WLID bigint value against which to operate (not valid with /G or /P)");
            Console.WriteLine();
            Console.WriteLine("Examples:");
            Console.WriteLine("To view information on user with gamertag of 'mat kous' in UODB:");
            Console.WriteLine("xappadmin /a view /g \"mat kous\"");
            Console.WriteLine();
            Console.WriteLine("To view a single line output of gamertag and console for a text file of GTs:");
            Console.WriteLine("xappadmin /a flat /c 6,18 /g gamertags.txt");
            Console.WriteLine();
            Console.WriteLine("To synch all t_users data for gamertag of 'makous' in UODB:");
            Console.WriteLine("xappadmin /a synch /g makous");
            Console.WriteLine();
            Console.WriteLine("To update t_users for gamertag 'makous', setting dt_last_activity to now:");
            Console.WriteLine("xappadmin /a update:t_users /u dt_last_activity=getdate() /g makous");
            return true;
        }

        internal static void outputError(SystemException e, string whatWeWereDoing)
        {
            Console.WriteLine("Error {0}:", whatWeWereDoing);
            Console.WriteLine(e.Message);
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\XblCfg\Test\ActionDevkit.cs ===
using System.Collections.Generic;

using ServerTestFramework;
using ServerTestFramework.Utilities;
using ServerTestFramework.Database;

using xonline.common.config;

namespace XblConfigTest
{
    //NOTE: These tests that there are no setting overrides for the console exception list for the current environment.
    [TestGroup]
    public class Devkit: TestNode
    {
        string originalSavedExceptionList=null;

        public override void PreRun()
        {
            //store off the current exception list before we start, then wipe it out so the tests have a clean slate
            Global.RO.Debug("Saving the current exception list...");
            originalSavedExceptionList=(string)StaticNpdb.ExecuteScalar("select vc_value from t_settings where vc_setting='"+Setting.kdcsvc_xmacs_consoleExceptionList+"'");
            ClearExceptionList();
        }

        public override void PostRun()
        {
            //restore the exception list to what it was before we started
            if (originalSavedExceptionList!=null)
            {
                Global.RO.Debug("Restoring the exception list...");
                SetCurrentExceptionList(originalSavedExceptionList);
            }
            else
            {
                Global.RO.Debug("Original exception list was empty, nothing to restore.");
            }
        }

        // -- helpers

        public static void ClearExceptionList()
        {
            Global.RO.Debug("Clearing the exception list.");
            StaticNpdb.ExecuteNonQuery("update t_settings set vc_value='' where vc_setting='"+Setting.kdcsvc_xmacs_consoleExceptionList+"'");
        }

        public static void VerifyNoErrors(string s)
        {
            if (s.ToLower().Contains("error") || s.ToLower().Contains("exception"))
            {
                throw new UnexpectedTestResultException("Output contains an error or exception.");
            }
        }

        public static string[] GetCurrentExceptionList()
        {
            return GetCurrentExceptionList(true);
        }

        public static string[] GetCurrentExceptionList(bool returnBlanks)
        {
            string db=(string)StaticNpdb.ExecuteScalar("select vc_value from t_settings where vc_setting='"+Setting.kdcsvc_xmacs_consoleExceptionList+"'");
            Global.RO.Debug("Console exception list in DB:\n"+db);
            return ParseExceptionListString(db, returnBlanks);
        }

        public static string []ParseExceptionListString(string listString, bool returnBlanks)
        {
            if (listString==null || listString.Length==0)
            {
                return new string[0];
            }

            if (returnBlanks)
            {
                return listString.Split(new char[]{';',','});
            }
            else
            {
                return listString.Split(new char[]{';',','}, System.StringSplitOptions.RemoveEmptyEntries);
            }
        }

        public static void SetCurrentExceptionList(string listString)
        {
            Global.RO.Debug("Setting exception list to:\n"+listString);
            StaticNpdb.ExecuteNonQuery("update t_settings set vc_value="+QueryGenerator.EvaluateObject(listString)+" where vc_setting='"+Setting.kdcsvc_xmacs_consoleExceptionList+"'");
        }

        public static void SetCurrentExceptionList(string []entries)
        {
            string s=string.Join(";", entries);
            SetCurrentExceptionList(s);
        }

        public static void VerifyListOutput(string output, string []expectedList)
        {
            if (output.Contains("No machines in the Exemption List"))
            {
                ValueCheck.Test("Number of machines expected to be output", expectedList.Length, 0);
                return;
            }

            string expectedStartString="The Exemption List contains the following machines:";
            if (!output.StartsWith(expectedStartString))
            {
                throw new UnexpectedTestResultException("Output does not start with the expected string: "+expectedStartString);
            }

            //the remaining lines are of the form: EntryNumber    ConsoleId
            List<string> listedConsoleIDs=new List<string>();
            string []lines=output.Replace("\r","").Split(new char[]{'\n'});
            for (int l=1; l<lines.Length; ++l)
            {
                string line=lines[l];

                if (line.Length==0) //empty line means end of list
                {
                    break;
                }

                string []lineParts=line.Split(new char[]{' '}, System.StringSplitOptions.RemoveEmptyEntries);
                if (lineParts.Length!=2)
                {
                    throw new UnexpectedTestResultException("Line "+l+" is not of the expected format of a number followed by a whitespace followed by a console ID.");
                }

                if (lineParts[0]!=l.ToString())
                {
                    throw new UnexpectedTestResultException("Number of line "+l+" was expected to be "+l+" but was "+lineParts[0]);
                }

                if (lineParts[1].Length==0)
                {
                    throw new UnexpectedTestResultException("Line "+l+" contains an empty console ID.");
                }

                listedConsoleIDs.Add(lineParts[1]);
            }

            //verify that the list in the output matches the expected list
            ValueCheck.TestAllUnordered("List in output", expectedList, listedConsoleIDs);
        }

        public static void VerifyListInvalidMachinesOutput(string output, string []expectedList)
        {
            string expectedStartString="The Exemption List contains the following invalid machines:";

            if (!output.Contains(expectedStartString))
            {
                ValueCheck.Test("Number of machines expected to be output", expectedList.Length, 0);
                return;
            }

            //the remaining lines are of the form: EntryNumber    ConsoleId
            bool listStarted=false;
            List<string> listedConsoleIDs=new List<string>();
            string []lines=output.Replace("\r","").Split(new char[]{'\n'});
            for (int l=1; l<lines.Length; ++l)
            {
                string line=lines[l];

                if (line.Length==0)
                {
                    continue;
                }

                if (line=="The above machines will get automatically purged on any ADD or REMOVE operation.") //empty line or special string means end of list
                {
                    break;
                }

                if (!listStarted)
                {
                    if (line.Contains(expectedStartString))
                    {
                        listStarted=true;
                    }

                    continue;
                }

                string []lineParts=line.Split(new char[]{'\"'}, System.StringSplitOptions.RemoveEmptyEntries);
                if (lineParts.Length<2)
                {
                    throw new UnexpectedTestResultException("Line "+l+" is not of the expected format of a number followed by a whitespace followed by a console ID.");
                }

                int expectedLineNumber=listedConsoleIDs.Count+1;
                if (lineParts[0].Trim()!=expectedLineNumber.ToString())
                {
                    throw new UnexpectedTestResultException("Number of line "+l+" was expected to be "+expectedLineNumber+" but was "+lineParts[0]);
                }

                if (lineParts[1].Length==0)
                {
                    throw new UnexpectedTestResultException("Line "+l+" contains an empty console ID.");
                }

                listedConsoleIDs.Add(lineParts[1].ToUpper());
            }

            //verify that the list in the output matches the expected list
            ValueCheck.TestAllUnordered("Invalid list in output", expectedList, listedConsoleIDs);
        }

        public static void VerifyInvalidEntriesRemovedOutput(string output, string []expectedList)
        {
            string expectedHeaderString="The following bad elements have been removed from the list:";
            if (!output.Contains(expectedHeaderString))
            {
                throw new UnexpectedTestResultException("Output does not contain the expected string: "+expectedHeaderString);
            }

            //there are now lines are of the form: EntryNumber    ConsoleId, potentially followed by some other text
            bool listStarted=false;
            List<string> listedConsoleIDs=new List<string>();
            string []lines=output.Replace("\r","").Split(new char[]{'\n'});
            for (int l=0; l<lines.Length; ++l)
            {
                string line=lines[l];

                if (!listStarted)
                {
                    if (line.Contains(expectedHeaderString))
                    {
                        listStarted=true;
                    }

                    continue;
                }

                if (l==lines.Length-1 && line.Length==0) //allow the last line to be completely empty
                {
                    break;
                }

                string []lineParts=line.Split(new char[]{'\"'}, System.StringSplitOptions.RemoveEmptyEntries);
                if (lineParts.Length!=3)
                {
                    break;
                }

                if (lineParts[0].Trim()!=l.ToString())
                {
                    break;
                }

                if (lineParts[1].Length==0)
                {
                    throw new UnexpectedTestResultException("Line "+l+" contains an empty console ID.");
                }

                listedConsoleIDs.Add(lineParts[1].ToUpper());
            }

            //verify that the list in the output matches the expected list
            ValueCheck.TestAllUnordered("Invalid entries removed in output", expectedList, listedConsoleIDs);
        }

        public static void VerifyConsoleIdInvalidInOutput(string output, string cid)
        {
            if (!output.ToLower().Contains("-consoleid:"+cid.ToLower().Replace("\"","")+" is not a valid consoleid"))
            {
                throw new UnexpectedTestResultException("Expected console to be reported as invalid: "+cid);
            }
        }

        public static void VerifyConsoleAlreadyInListInOutput(string output, string cid)
        {
            if (!output.ToLower().Contains("-consoleid:"+cid.ToLower().Replace("\"","")+" already exists in the exemption list"))
            {
                throw new UnexpectedTestResultException("Expected console to be reported as already in the list: "+cid);
            }
        }

        public static void VerifySuccessfulAddInOutput(string output, string cid)
        {
            if (!output.ToLower().Contains("console "+cid.ToLower()+" successfully added to the exemption list"))
            {
                throw new UnexpectedTestResultException("Expected console to be reported as successfully added to the list: "+cid);
            }
        }

        public static void VerifySuccessfulRemoveInOutput(string output, string cid)
        {
            if (!output.ToLower().Contains("console "+cid.ToLower()+" successfully removed from the exemption list"))
            {
                throw new UnexpectedTestResultException("Expected console to be reported as successfully removed from the list: "+cid);
            }
        }

        public static void VerifyNotInListInOutput(string output, string cid)
        {
            if (!output.ToLower().Contains("-consoleid:"+cid.ToLower()+" does not exists in the exemption list"))
            {
                throw new UnexpectedTestResultException("Expected console to be reported as not in the list: "+cid);
            }
        }

        // -- tests

        [TestCase, Description("If the -devkit command exists, then the help will not list available commands, but available options.")]
        public void CommandHelp()
        {
            string output=CfgUtil.RunXblConfig("-devkit").ToLower();

            if (output.Contains("commands (additional help is available for each)"))
            {
                throw new UnexpectedTestResultException("Commands help present, meaning that the devkit command may not be implemented.");
            }

            if (!output.Contains("this may be used to grant or remove access to a devkit"))
            {
                throw new UnexpectedTestResultException("Devkit help not present, meaning that the devkit command may not be implemented.");
            }
        }

        [TestGroup, Description("Tests for the -devkit -add command")]
        public class Add: TestNode
        {
            [TestCase, Description("Simple mainline case of adding a machine to the list")]
            [CompoundCase("ListIsEmpty", 0)]
            [CompoundCase("ListHasOne",  1)]
            [CompoundCase("ListHasTwo",  2)]
            public void Mainline(TestNode me)
            {
                int existingEntriesInList=(int)me.MyValues[0];

                //clear the exception list and set it to what we want
                ClearExceptionList();

                List<string> otherCids=new List<string>();
                for (int i=0; i<existingEntriesInList; ++i)
                {
                    otherCids.Add(MachineEditor.GenerateRandomConsoleID(MachineType.Xbox360));
                }
                SetCurrentExceptionList(otherCids.ToArray());

                //run the tool and verify there were no errors
                string cid=MachineEditor.GenerateRandomConsoleID(MachineType.Xbox360);
                string output=CfgUtil.RunXblConfig("-devkit -add -consoleid:"+cid);
                VerifyNoErrors(output);
                VerifySuccessfulAddInOutput(output, cid);

                //verify that the exception list contains what it should
                List<string> expectedCids=new List<string>();
                expectedCids.AddRange(otherCids);
                expectedCids.Add(cid);

                string []listInDb=GetCurrentExceptionList();
                ValueCheck.TestAllUnordered("Exception list in db", expectedCids, listInDb);
            }

            [TestCase, Description("Simple mainline case only specify the console id in lower case")]
            public void LowerCase()
            {
                ClearExceptionList();

                //run the tool and verify there were no errors
                string cid=MachineEditor.GenerateRandomConsoleID(MachineType.Xbox360);
                string output=CfgUtil.RunXblConfig("-devkit -add -consoleid:"+cid.ToLower());
                VerifyNoErrors(output);
                VerifySuccessfulAddInOutput(output, cid);

                //verify that the exception list contains what it should
                string []listInDb=GetCurrentExceptionList();
                ValueCheck.TestAllUnordered("Exception list in db", new string[]{cid}, listInDb);
            }

            [TestCase, Description("Verify that adding a real machine to the list doesn't muck with its key.")]
            public void VerifyMachineKey()
            {
                //create the machine
                MachineEditor machine=MachineEditor.CreateNew(MachineType.Xbox360);
                byte []origMachineKey=machine.GetEncryptedKey();

                //run the tool
                string output=CfgUtil.RunXblConfig("-devkit -add -consoleid:"+machine.ConsoleId);
                VerifyNoErrors(output);

                //verify the key did not change
                byte []newMachineKey=machine.GetEncryptedKey();
                ValueCheck.Test("Machine Key", origMachineKey, newMachineKey);
            }

            [TestCase, Description("If the list in the DB is comma separated, it should still work right")]
            public void ListInDbIsCommaSeparated()
            {
                //clear the exception list and set it to what we want
                string existingCid0=MachineEditor.GenerateRandomConsoleID(MachineType.Xbox360);
                string existingCid1=MachineEditor.GenerateRandomConsoleID(MachineType.Xbox360);

                ClearExceptionList();
                SetCurrentExceptionList(existingCid0+","+existingCid1);

                //run the tool
                string cid=MachineEditor.GenerateRandomConsoleID(MachineType.Xbox360);
                string output=CfgUtil.RunXblConfig("-devkit -add -consoleid:"+cid);
                VerifyNoErrors(output);
                VerifySuccessfulAddInOutput(output, cid);

                //verify that the exception list contains what it should
                string []listInDb=GetCurrentExceptionList();
                ValueCheck.TestAllUnordered("Exception list in db", new string[]{existingCid0, existingCid1, cid}, listInDb);
            }

            [TestCase, Description("DB has two consecutive seperators in it.")]
            public void ListInDbHasConsecutiveSeperators()
            {
                //clear the exception list and set it to what we want
                string existingCid0=MachineEditor.GenerateRandomConsoleID(MachineType.Xbox360);
                string existingCid1=MachineEditor.GenerateRandomConsoleID(MachineType.Xbox360);

                ClearExceptionList();
                SetCurrentExceptionList(existingCid0+";;"+existingCid1);

                //run the tool
                string cid=MachineEditor.GenerateRandomConsoleID(MachineType.Xbox360);
                string output=CfgUtil.RunXblConfig("-devkit -add -consoleid:"+cid);
                VerifyNoErrors(output);
                VerifySuccessfulAddInOutput(output, cid);

                //verify that the exception list contains what it should
                string []listInDb=GetCurrentExceptionList();
                ValueCheck.TestAllUnordered("Exception list in db", new string[]{existingCid0, existingCid1, cid}, listInDb);
            }

            [TestCase, Description("Machine being added is already in the list")]
            [CompoundCase("ListHasOneOther",  2)]
            [CompoundCase("ListHasOnlyThis",  1)]
            public void AlreadyInList(TestNode me)
            {
                int entriesInList=(int)me.MyValues[0];

                //clear the exception list and set it to what we want
                ClearExceptionList();
                List<string> cids=new List<string>();
                for (int i=0; i<entriesInList; ++i)
                {
                    cids.Add(MachineEditor.GenerateRandomConsoleID(MachineType.Xbox360));
                }
                SetCurrentExceptionList(cids.ToArray());

                //run the tool
                string output=CfgUtil.RunXblConfig("-devkit -add -consoleid:"+cids[0]);

                //verify
                VerifyConsoleAlreadyInListInOutput(output, cids[0]);

                string []listInDb=GetCurrentExceptionList();
                ValueCheck.TestAllUnordered("Exception list in db", cids, listInDb);
            }

            [TestCase, Description("Verify the behaviour around the list being full when we try to add."), TestCasePriority(2)]
            public void ListIsFull()
            {
                //The db can hold 3700 characters.  All entries except the last consume 16 characters, and the last consumes 15.  This means 231 valid machines can be stored.
                //Start with 230 in the list.
                ClearExceptionList();
                List<string> cids=new List<string>();
                for (int i=0; i<230; ++i)
                {
                    cids.Add(MachineEditor.GenerateRandomConsoleID(MachineType.Xbox360));
                }
                SetCurrentExceptionList(cids.ToArray());

                //Try to add one, putting us up to 231, this should work.
                string cid=MachineEditor.GenerateRandomConsoleID(MachineType.Xbox360);
                cids.Add(cid);
                string output=CfgUtil.RunXblConfig("-devkit -add -consoleid:"+cid);

                VerifyNoErrors(output);
                string []listInDb=GetCurrentExceptionList();
                ValueCheck.TestAllUnordered("Exception list in db", cids, listInDb);

                //Try to add one more, this should fail.
                cid=MachineEditor.GenerateRandomConsoleID(MachineType.Xbox360);
                output=CfgUtil.RunXblConfig("-devkit -add -consoleid:"+cid);

                if (!output.Contains("Exception List Length 3711 Exceeds Maximum Length 3700"))
                {
                    throw new UnexpectedTestResultException("Expected an error saying the list was too long.");
                }

                listInDb=GetCurrentExceptionList();
                ValueCheck.TestAllUnordered("Exception list in db", cids, listInDb);
            }

            [TestCase, Ignore("This is a NamedArgParser problem in common code, affects all tools."), Description("Specify multiple -consoleid parameters"), TestCasePriority(2)]
            public void SpecifyMultipleConsoles()
            {
                ClearExceptionList();
                string cid0=MachineEditor.GenerateRandomConsoleID(MachineType.Xbox360);
                string cid1=MachineEditor.GenerateRandomConsoleID(MachineType.Xbox360);

                //run the tool
                string cid=MachineEditor.GenerateRandomConsoleID(MachineType.Xbox360);
                string output=CfgUtil.RunXblConfig("-devkit -add -consoleid:"+cid0+" -consoleid:"+cid1);

                //verify
                if (!output.Contains("Usage error:"))
                {
                    throw new UnexpectedTestResultException("Expected a usage error.");
                }

                string []listInDb=GetCurrentExceptionList();
                ValueCheck.Test("Number of entries in the exception list", 0, listInDb.Length);
            }

            [TestCase, Description("Attempt to add machines from a platform not supported by this feature"), TestCasePriority(2)]
            [CompoundCase("Xbox1", MachineType.Xbox1)]
            [CompoundCase("PC", MachineType.PC)]
            public void UnsupportedPlatforms(TestNode me)
            {
                MachineType mtype=(MachineType)me.MyValues[0];

                ClearExceptionList();

                //run the tool
                string cid=MachineEditor.GenerateRandomConsoleID(mtype);
                string output=CfgUtil.RunXblConfig("-devkit -add -consoleid:"+cid);

                //verify
                VerifyConsoleIdInvalidInOutput(output, cid);
                string []listInDb=GetCurrentExceptionList();
                ValueCheck.Test("Number of entries in the exception list", 0, listInDb.Length);
            }

            [TestCase, Description("Attempt to add invalid console IDs to the list"), TestCasePriority(2)]
            [CompoundCase("TooShort",           "XE.23478901240")]
            [CompoundCase("TooLong",            "XE.1123478901242")]
            [CompoundCase("BadChecksum",        "XE.123478901247")]
            [CompoundCase("XeNoNumbers",        "XE.")]
            [CompoundCase("XeLetters",          "XE.this00is0bad")]
            [CompoundCase("Letters",            "huh0this0is0bad")]
            [CompoundCase("Numbers",            "123407080901241")]
            [CompoundCase("SpaceInName",        "\"XE.12347 8901241\"")]
            [CompoundCase("CommaSeparated",     "XE.123478901241,XE.223478901242")]
            [CompoundCase("SemicolonSeparated", "XE.123478901241;XE.223478901242")]
            public void InvalidConsoleIds(TestNode me)
            {
                string badName=(string)me.MyValues[0];

                ClearExceptionList();

                //run the tool
                string output=CfgUtil.RunXblConfig("-devkit -add -consoleid:"+badName);

                //verify
                VerifyConsoleIdInvalidInOutput(output, badName);
                string []listInDb=GetCurrentExceptionList();
                ValueCheck.Test("Number of entries in the exception list", 0, listInDb.Length);
            }

            [TestCase, Description("No paramaters beyond -devkit -add")]
            public void NoParameters()
            {
                string output=CfgUtil.RunXblConfig("-devkit -add");
                if (!output.Contains("Usage error:") || !output.Contains("Missing -consoleid"))
                {
                    throw new UnexpectedTestResultException("Expected a usage error for missing -consoleid");
                }
            }

            [TestCase, Description("Specify -consoleid but no actual value for the parameter"), TestCasePriority(3)]
            public void ConsoleIdEmpty()
            {
                string output=CfgUtil.RunXblConfig("-devkit -add -consoleid:");
                if (!output.Contains("Usage error:") || !output.Contains("Missing -consoleid"))
                {
                    throw new UnexpectedTestResultException("Expected a usage error for missing -consoleid");
                }
            }
        }; //class Add


        [TestGroup, Description("Tests for the -devkit -remove command")]
        public class Remove: TestNode
        {
            [TestCase, Description("Removes a console ID from a list when the list already has elements in it.")]
            [CompoundCase("ListHasOne",   1)]
            [CompoundCase("ListHasTwo",   2)]
            [CompoundCase("ListHasThree", 3)]
            public void Mainline(TestNode me)
            {
                int existingEntriesInList=(int)me.MyValues[0];

                //clear the exception list and set it to what we want
                ClearExceptionList();

                List<string> cids=new List<string>();
                for (int i=0; i<existingEntriesInList; ++i)
                {
                    cids.Add(MachineEditor.GenerateRandomConsoleID(MachineType.Xbox360));
                }
                SetCurrentExceptionList(cids.ToArray());

                //run the tool and verify there were no errors
                string output=CfgUtil.RunXblConfig("-devkit -remove -consoleid:"+cids[cids.Count-1]);
                VerifyNoErrors(output);
                VerifySuccessfulRemoveInOutput(output, cids[cids.Count-1]);

                //verify that the exception list contains what it should
                List<string> expectedCids=new List<string>();
                expectedCids.AddRange(cids);
                expectedCids.RemoveAt(cids.Count-1);

                string []listInDb=GetCurrentExceptionList();
                ValueCheck.TestAllUnordered("Exception list in db", expectedCids, listInDb);
            }

            [TestCase, Description("Simple mainline case only specify the console id in lower case")]
            public void LowerCase()
            {
                string cid=MachineEditor.GenerateRandomConsoleID(MachineType.Xbox360);
                ClearExceptionList();
                SetCurrentExceptionList(new string[]{cid});

                //run the tool and verify there were no errors
                string output=CfgUtil.RunXblConfig("-devkit -remove -consoleid:"+cid.ToLower());
                VerifyNoErrors(output);
                VerifySuccessfulRemoveInOutput(output, cid);

                //verify that the exception list contains what it should
                string []listInDb=GetCurrentExceptionList();
                ValueCheck.TestAllUnordered("Exception list in db", new string[]{}, listInDb);
            }

            [TestCase, Description("Verify that removing a real machine from the list DOES reset its key.")]
            public void VerifyMachineKey()
            {
                //create the machine and put it in the list
                MachineEditor machine=MachineEditor.CreateNew(MachineType.Xbox360);
                byte []origMachineKey=machine.GetEncryptedKey();
                System.DateTime origMachineResetDate=machine.ResetDate;
                Global.RO.Debug("Machine reset date: "+origMachineResetDate);

                ClearExceptionList();
                SetCurrentExceptionList(new string[]{machine.ConsoleId});

                //run the tool
                string output=CfgUtil.RunXblConfig("-devkit -remove -consoleid:"+machine.ConsoleId);
                VerifyNoErrors(output);

                //verify the key DID change
                byte []newMachineKey=machine.GetEncryptedKey();
                System.DateTime newMachineResetDate=machine.ResetDate;
                Global.RO.Debug("Machine reset date: "+newMachineResetDate);

                if (origMachineResetDate==newMachineResetDate)
                {
                    throw new UnexpectedTestResultException("Machine reset date was NOT updated.  Existing TGT will not be revoked.");
                }

                ValueCheck.Test("Machine key length", origMachineKey.Length, newMachineKey.Length);
                for (int i=0; i<newMachineKey.Length; ++i)
                {
                    if (newMachineKey[i]!=origMachineKey[i])
                    {
                        return; //success
                    }
                }

                throw new UnexpectedTestResultException("MachineKey was NOT reset");
            }

            [TestCase, Description("Attempt to remove a console not in the list.")]
            public void NotInList()
            {
                //clear the exception list and set it to what we want
                ClearExceptionList();

                string cidExisting=MachineEditor.GenerateRandomConsoleID(MachineType.Xbox360);
                SetCurrentExceptionList(new string[]{cidExisting});

                //run the tool
                string cidNotInList=MachineEditor.GenerateRandomConsoleID(MachineType.Xbox360);
                string output=CfgUtil.RunXblConfig("-devkit -remove -consoleid:"+cidNotInList);

                //verify
                VerifyNotInListInOutput(output, cidNotInList);

                string []listInDb=GetCurrentExceptionList();
                ValueCheck.TestAllUnordered("Exception list in db", new string[]{cidExisting}, listInDb);
            }

            [TestCase, Description("Attempt to remove a console when the list is empty.")]
            public void ListIsEmpty()
            {
                 //clear the exception list and set it to what we want
                ClearExceptionList();

                //run the tool
                string cid=MachineEditor.GenerateRandomConsoleID(MachineType.Xbox360);
                string output=CfgUtil.RunXblConfig("-devkit -remove -consoleid:"+cid);

                //verify
                VerifyNotInListInOutput(output, cid);

                string []listInDb=GetCurrentExceptionList();
                ValueCheck.TestAllUnordered("Exception list in db", new string[]{}, listInDb);
            }

            [TestCase, Description("The exception list has an invalid entry in it.  Note that xblcfg write operations will remove ALL invalid entries."), TestCasePriority(2)]
            //                               initial list                                                           remove this        expect this in the exemption list                   expected invalid removed list    usage error
            [CompoundCase("RemoveValid",     new string[]{"XE.123478901230", "woops", "XE.123478901241", "XE.ACK"}, "XE.123478901241", new string[]{"XE.123478901230"},                    new string[]{"WOOPS", "XE.ACK"}, false)]
            [CompoundCase("RemoveInvalid",   new string[]{"XE.123478901230", "woops", "XE.123478901241", "XE.ACK"}, "woops",           new string[]{"XE.123478901230", "XE.123478901241"}, new string[]{"WOOPS", "XE.ACK"}, false)]
            [CompoundCase("RemoveAll",       new string[]{"woops", "XE.123478901241"},                              "XE.123478901241", new string[0],                                      new string[]{"WOOPS"},           false)]
            [CompoundCase("AllInvalid",      new string[]{"woops", "wtf"},                                          "wtf",             new string[0],                                      new string[]{"WOOPS", "WTF"},    false)]
            [CompoundCase("RemoveNotInList", new string[]{"woops", "XE.123478901241"},                              "XE.typo",         new string[]{"XE.123478901241"},                    new string[]{"WOOPS"},           true)]
            public void InvalidRemoval(TestNode me)
            {
                string []initialList=(string[])me.MyValues[0];
                string removeCid=(string)me.MyValues[1];
                string []expectedExceptionList=(string[])me.MyValues[2];
                string []expectedInvalidRemovedList=(string[])me.MyValues[3];
                bool expectUsageError=(bool)me.MyValues[4];

                ClearExceptionList();
                SetCurrentExceptionList(initialList);

                //run the tool
                string output=CfgUtil.RunXblConfig("-devkit -remove -consoleid:"+removeCid);

                //verify output
                if (!expectUsageError)
                {
                    VerifyNoErrors(output);
                }
                else
                {
                    if (!output.Contains("Usage error"))
                    {
                        throw new UnexpectedTestResultException("Expected a usage error.");
                    }
                }

                VerifyInvalidEntriesRemovedOutput(output, expectedInvalidRemovedList);

                //verify db value
                string []listInDb=GetCurrentExceptionList();
                ValueCheck.TestAllUnordered("Exception list in db", expectedExceptionList, listInDb);
            }

            [TestCase, Description("No paramaters beyond -devkit -remove")]
            public void NoParameters()
            {
                string output=CfgUtil.RunXblConfig("-devkit -remove");
                if (!output.Contains("Usage error:") || !output.Contains("Missing -consoleid"))
                {
                    throw new UnexpectedTestResultException("Expected a usage error for missing -consoleid");
                }
            }

            [TestCase, Description("Specify -consoleid but no actual value for the parameter"), TestCasePriority(3)]
            public void ConsoleIdEmpty()
            {
                string output=CfgUtil.RunXblConfig("-devkit -remove -consoleid:");
                if (!output.Contains("Usage error:") || !output.Contains("Missing -consoleid"))
                {
                    throw new UnexpectedTestResultException("Expected a usage error for missing -consoleid");
                }
            }
        }; //class Remove


        [TestGroup, Description("Tests for the -devkit -list command")]
        public class List: TestNode
        {
            [TestCase, Description("Run -devkit -list with a list of 0, 1, and 2 consoles.")]
            [CompoundCase("ListHasNone", 0)]
            [CompoundCase("ListHasOne",  1)]
            [CompoundCase("ListHasTwo",  2)]
            public void Mainline(TestNode me)
            {
                int existingEntriesInList=(int)me.MyValues[0];

                //clear the exception list and set it to what we want
                ClearExceptionList();

                List<string> cids=new List<string>();
                for (int i=0; i<existingEntriesInList; ++i)
                {
                    cids.Add(MachineEditor.GenerateRandomConsoleID(MachineType.Xbox360));
                }
                SetCurrentExceptionList(cids.ToArray());

                //run the tool and verify there were no errors
                string output=CfgUtil.RunXblConfig("-devkit -list");
                VerifyNoErrors(output);

                //verify that the output contains the correct list
                string []listInDb=GetCurrentExceptionList();
                ValueCheck.TestAllUnordered("Exception list in db", cids, listInDb);
                VerifyListOutput(output, listInDb);
            }

            [TestCase, Description("Verify that list a real machine doesn't muck with its key.")]
            public void VerifyMachineKey()
            {
                //create the machine and add them to the list
                MachineEditor machine=MachineEditor.CreateNew(MachineType.Xbox360);
                byte []origMachineKey=machine.GetEncryptedKey();

                ClearExceptionList();
                SetCurrentExceptionList(new string[]{machine.ConsoleId});

                //run the tool
                string output=CfgUtil.RunXblConfig("-devkit -list");
                VerifyNoErrors(output);

                //verify the key did not change
                byte []newMachineKey=machine.GetEncryptedKey();
                ValueCheck.Test("Machine Key", origMachineKey, newMachineKey);
            }

            [TestCase, Description("The list in the db is the max possible size"), TestCasePriority(2)]
            public void ListIsFull()
            {
                //The db can hold 3700 characters.  All entries except the last consume 16 characters, and the last consumes 15.  This means 231 valid machines can be stored.
                ClearExceptionList();
                List<string> cids=new List<string>();
                for (int i=0; i<231; ++i)
                {
                    cids.Add(MachineEditor.GenerateRandomConsoleID(MachineType.Xbox360));
                }
                SetCurrentExceptionList(cids.ToArray());

                //run the tool and verify there were no errors
                string output=CfgUtil.RunXblConfig("-devkit -list");
                VerifyNoErrors(output);

                //verify that the output contains the correct list
                string []listInDb=GetCurrentExceptionList();
                ValueCheck.TestAllUnordered("Exception list in db", cids, listInDb);
                VerifyListOutput(output, listInDb);
            }

            [TestCase, Description("If the list in the DB is comma separated, it should still work right")]
            public void ListInDbIsCommaSeparated()
            {
                //clear the exception list and set it to what we want
                string existingCid0=MachineEditor.GenerateRandomConsoleID(MachineType.Xbox360);
                string existingCid1=MachineEditor.GenerateRandomConsoleID(MachineType.Xbox360);

                ClearExceptionList();
                SetCurrentExceptionList(existingCid0+","+existingCid1);

                //run the tool
                string output=CfgUtil.RunXblConfig("-devkit -list");
                VerifyNoErrors(output);

                //verify that the exception list contains what it should
                string []listInDb=GetCurrentExceptionList();
                ValueCheck.TestAllUnordered("Exception list in db", new string[]{existingCid0, existingCid1}, listInDb);
                VerifyListOutput(output, listInDb);
            }

            [TestCase, Description("DB has two consecutive seperators in it.")]
            public void ListInDbHasConsecutiveSeperators()
            {
                //clear the exception list and set it to what we want
                string existingCid0=MachineEditor.GenerateRandomConsoleID(MachineType.Xbox360);
                string existingCid1=MachineEditor.GenerateRandomConsoleID(MachineType.Xbox360);

                ClearExceptionList();
                SetCurrentExceptionList(existingCid0+";;"+existingCid1);

                //run the tool
                string output=CfgUtil.RunXblConfig("-devkit -list");
                VerifyNoErrors(output);

                //verify that the exception list contains what it should
                string []listInDb=GetCurrentExceptionList(false);
                ValueCheck.TestAllUnordered("Exception list in db", new string[]{existingCid0, existingCid1}, listInDb);
                VerifyListOutput(output, listInDb);
            }

            [TestCase, Description("List has invalid console IDs in it"), TestCasePriority(2)]
            [CompoundCase("TooShort",           "XE.23478901240")]
            [CompoundCase("TooLong",            "XE.1123478901242")]
            [CompoundCase("SpaceBefore",        " XE.123478901241")]
            [CompoundCase("SpaceAfter",         "XE.123478901241 ")]
            [CompoundCase("SpaceInMiddle",      "XE.12347 8901241")]
            [CompoundCase("BadChecksum",        "XE.123478901247")]
            [CompoundCase("XeNoNumbers",        "XE.")]
            [CompoundCase("XeLetters",          "XE.this00is0bad")]
            [CompoundCase("Letters",            "huh0this0is0bad")]
            [CompoundCase("Numbers",            "123407080901241")]
            public void InvalidConsoleIds(TestNode me)
            {
                string badName=(string)me.MyValues[0];
                string goodCid0=MachineEditor.GenerateRandomConsoleID(MachineType.Xbox360);
                string goodCid1=MachineEditor.GenerateRandomConsoleID(MachineType.Xbox360);

                ClearExceptionList();
                SetCurrentExceptionList(new string[]{goodCid0, badName, goodCid1});

                //run the tool
                string output=CfgUtil.RunXblConfig("-devkit -list");
                VerifyNoErrors(output);

                //verify
                string []listInDb=GetCurrentExceptionList();
                ValueCheck.TestAllUnordered("Exception list in db", new string[]{goodCid0, badName, goodCid1}, listInDb);
                VerifyListOutput(output, new string[]{goodCid0, goodCid1});
                VerifyListInvalidMachinesOutput(output, new string[]{badName.ToUpper()});
            }
        }; //class List
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\XblCfg\App\actionVInterface.cs ===
﻿// --------------------------------------------------------------------------------------
// Copyright (c) Microsoft Corporation.  All rights reserved
//
// actionInterface.cs
//
// XblCfg
//
// Process the Config command
// --------------------------------------------------------------------------------------

using System;
using System.Collections;
using System.Collections.Generic;
using System.Diagnostics;
using System.Net;
using System.Net.NetworkInformation;
using System.Net.Sockets;
using System.Text;

using xonline.common.config;
//using xonline.common.diagnostics;
//using xonline.common.service;
using xonline.common.tools.console;
using xonline.common.tools;

namespace xonline.tools.xblcfg
{    
    public class ActionVirtualInterface
    {
        public class XblCfgVirtualInterfaceException : Exception
        {
            public XblCfgVirtualInterfaceException(string message) :
                base(message)
            {
            }
        }

        public void Process(NamedArgParser args)
        {
            if(args["help"] != null || args["h"] != null || args["?"] != null)
            {
                PrintUsageBlob();
                return;
            }

            // set the npdb info if it exists
            if (args["npdbServer"] != null)
            {
                Config.NpdbServer = args["npdbServer"];
            }
            if (args["npdbDatabase"] != null)
            {
                Config.NpdbDatabase = args["npdbDatabase"];
            }

            if (args["add"] != null)
            {
                ProcessVirtualInterfaceAdd(args);
            }
            else
            {
                PrintUsageBlob();
                throw new XblCfgBadArgumentException("Missing -add arguments");
            }
        }

        private static void PrintUsageBlob()
        {
//       1         2         3         4         5         6         7         8
//34567890123456789012345678901234567890123456789012345678901234567890123456789012345678
            string helpText = @" 
xblcfg.exe -vinterface [options...]

Notes:
    -vinterface is used to add a virtual interface to ip mapping in
        t_site_virtual_interface_ips in NPDB and
        t_sites in UODB

Options:
    
    -add:<virtual_interface_name> [-vip:<vip>]
            [-npdbServer:<npdb_server>] [-npdbDatabase:<npdb_database>] [-overwrite]

    Adds the vip specified to the virtual interfaces separated by semi-colon (;).
    Adding specific or all site ids for a virtual interface is specified by :
    e.g. sgsvc:all for all sites or sgsvc:9999 for just site 9999
    If site id is not specified, it is defaulted to 1

    If vip is not provide, will attempt to find out the IP of this server
    from t_server_nics by associating with the nic role defined in t_interfaces.

    If there is already a vip entry for this virtual interface, this action will not
    overwrite the value unless the -overwrite flag is specified    

Examples:

xblcfg.exe -vinterface -add:sgsvc

xblcfg.exe -vinterface -add:sgsvc:all;xbanc -vip:65.56.74.81 -overwrite

xblcfg.exe -vinterface -add:fbserver;sgsvc:1;sgsvc:9999;xbanc -vip:65.56.74.81 -overwrite

";

            XblCfgConsole.Out(helpText);
        }

        private void ProcessVirtualInterfaceAdd(NamedArgParser args)
        {
            // Parameters from console
            string virtualInterfaceInput = args["add"];
            string vip = args["vip"];
            string overwriteArg = args["overwrite"];
            string siteIdArg = args["site"];

            bool overwriteExistingValue = (overwriteArg != null);
            
            if (vip != null && vip.Equals(""))
            {
                throw new XblCfgBadArgumentException("Vip can not be specified but empty.");
            }
            
            // Fail out if it's production and a vip is not provided.
            // It doesn't make sense to detect a certain server to be the VIP in production.
            if (Config.EnvironmentType.ToLower().Equals("production") && String.IsNullOrEmpty(vip))
            {
                throw new XblCfgBadArgumentException("Production environment must be configured using a vip");
            }
            
            Npdb npdb = new Npdb();

            string[] virtualInterfaces = virtualInterfaceInput.Split(';');

            foreach (string virtualInterfaceValuePair in virtualInterfaces)
            {
                XblCfgConsole.Out("\nConfiguring virtual interface {0}...", virtualInterfaceValuePair);

                string virtualInterface = null;
                List<int> siteIds = new List<int>();                

                // If siteid is specified for this virtual interface, we need to handle it
                if (virtualInterfaceValuePair.Contains(":"))
                {
                    string[] virtualInterfaceValues = virtualInterfaceValuePair.Split(':');
                    virtualInterface = virtualInterfaceValues[0];

                    // If it's virtualInterface:all, query for all sites so we can add this to all sites
                    if (virtualInterfaceValues[1].Equals("all", StringComparison.CurrentCultureIgnoreCase))
                    {
                        siteIds.AddRange(npdb.GetAllSiteIds());
                    }
                    else
                    {
                        // else just add it for virtualInterface:siteId
                        siteIds.Add(Convert.ToInt32(virtualInterfaceValues[1]));
                    }                    
                }
                else
                {
                    // else just do the default site 1
                    virtualInterface = virtualInterfaceValuePair;
                    siteIds.Add(1);
                }
                                
                XblCfgConsole.Out("Virtual interface {0} for all sites: {1}",
                    virtualInterface,
                    String.Join(", ", Array.ConvertAll<int, string>(siteIds.ToArray(), new Converter<int, string>(Convert.ToString))));

                string ip = vip;
                if (String.IsNullOrEmpty(ip))
                {
                    // Find out which nic role this interface should use
                    string nicRole = npdb.GetNicRoleByVirtualInterface(virtualInterface);

                    if (String.IsNullOrEmpty(nicRole))
                    {
                        XblCfgConsole.Out("Unable to obtain nic role for virtual interface: {0} from server.", virtualInterface);
                        XblCfgConsole.Out("Please ensure the virtual interface is defined in t_virtual_interfaces.");
                        throw new XblCfgVirtualInterfaceException(String.Format("No nic role defined for interface: {0}", virtualInterface));
                    }
                    else
                    {
                        XblCfgConsole.Out("Obtained nic role: {0} for virtual interface {1}.", nicRole, virtualInterface);

                        // Find out server nic IP using Environment.MachineName and nic role         
                        ip = npdb.GetIpByServerNicRole(Environment.MachineName, nicRole);
                    }
                }

                // We still don't have an ip, we can't add the interface
                if (String.IsNullOrEmpty(ip))
                {
                    XblCfgConsole.Out("Vip not provided and failed to obtain IP for server: {0}", Environment.MachineName);
                    XblCfgConsole.Out("\nFailed to add virtual interface vip.");
                    throw new XblCfgVirtualInterfaceException(String.Format("Vip not provided and failed to obtain IP for server: {0}", Environment.MachineName));
                }
                else
                {
                    foreach (int siteId in siteIds)
                    {
                        // Add/Update virtual interface ip
                        npdb.AddVirtualInterfaceIp(siteId, virtualInterface, ip, overwriteExistingValue);
                    }
                }
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\XblCfg\App\database.cs ===
// --------------------------------------------------------------------------------------
// Copyright (c) Microsoft Corporation.  All rights reserved
//
// database.cs
//
// XblCfg
//
// Database stuff
// --------------------------------------------------------------------------------------

using System;
using System.Collections;
using System.Collections.Generic;
using System.Data;
using System.Data.SqlClient;
using System.Diagnostics;
using System.Globalization;
using System.IO;
using System.Net;
using System.Net.NetworkInformation;
using System.Reflection;
using System.Security.Cryptography;
using System.Text;
using System.Text.RegularExpressions;
using System.Xml;
using System.Xml.XPath;

using Microsoft.Webstore.WstClient;

using xonline.common.config;
using xonline.common.diagnostics;
using xonline.common.machine;
using xonline.common.service;
using xonline.common.sql.webstore;
using xonline.common.tools.console;
using xonline.common.tools;
using xonline.common.utilities;

using xonline.server.xmachine.fd.soap;

namespace xonline.tools.xblcfg
{
    public class Npdb
    {
        public Npdb()
        {
            // Get the connection string for the webdb interface from Config
            _npdbConnectionString = Config.NpdbConnectionString;
        }

        public void ConfigBlobSet(string configBlobName, byte[] blob)
        {
            using (SqlConnection sql = new SqlConnection(_npdbConnectionString))
            {
                sql.Open();

                SqlCommand cmd = new SqlCommand("dbo.p_config_blob_set");
                cmd.Connection = sql;
                cmd.CommandType = CommandType.StoredProcedure;

                cmd.Parameters.Add("@vc_config_blob_name", SqlDbType.NVarChar).Value = configBlobName;
                cmd.Parameters.Add("@im_value", SqlDbType.Image).Value = blob;

                cmd.ExecuteNonQuery();
            }
        }

        public bool ConfigBlobGet(string configBlobName, out byte[] blob)
        {
            using (SqlConnection sql = new SqlConnection(_npdbConnectionString))
            {
                sql.Open();

                SqlCommand cmd = new SqlCommand("dbo.p_config_blob_get");
                cmd.Connection = sql;
                cmd.CommandType = CommandType.StoredProcedure;

                cmd.Parameters.Add("@vc_config_blob_name", SqlDbType.NVarChar).Value = configBlobName;

                using (SqlDataReader reader = cmd.ExecuteReader())
                {
                    if (!reader.Read())
                    {
                        // config blob not found
                        blob = null;
                        return false;
                    }

                    blob = reader.GetSqlBinary(0).Value;
                }
            }

            return true;
        }

        public bool ConfigBlobDelete(string configBlobName)
        {
            using (SqlConnection sql = new SqlConnection(_npdbConnectionString))
            {
                sql.Open();

                SqlCommand cmd = new SqlCommand();
                cmd.Connection = sql;
                cmd.CommandType = CommandType.Text;
                cmd.CommandText =
                    "delete dbo.t_config_blobs \n" +
                    "where vc_config_blob_name = @vc_config_blob_name";

                cmd.Parameters.Add("@vc_config_blob_name", SqlDbType.NVarChar).Value = configBlobName;

                int rows = cmd.ExecuteNonQuery();

                return rows > 0;
            }
        }

        public void ScriptSet(string scriptName, string scriptText)
        {
            ScriptSet(scriptName, scriptText, null, 0, 0);
        }
        public void ScriptSet(string scriptName, string scriptText, byte[] binaryBlob, uint kickEnabled, uint timeoutEnabled)
        {
            using (SqlConnection sql = new SqlConnection(_npdbConnectionString))
            {
                sql.Open();

                SqlCommand cmd = new SqlCommand("dbo.p_sg_script_set");
                cmd.Connection = sql;
                cmd.CommandType = CommandType.StoredProcedure;

                cmd.Parameters.Add("@vc_script_name", SqlDbType.VarChar).Value = scriptName;
                cmd.Parameters.Add("@ti_enabled", SqlDbType.TinyInt).Value = 1;
                cmd.Parameters.Add("@txt_script", SqlDbType.Text).Value = scriptText;
                cmd.Parameters.Add("@im_blob", SqlDbType.Image).Value = binaryBlob;
                cmd.Parameters.Add("@ti_chal_kick_enabled", SqlDbType.TinyInt).Value = kickEnabled;
                cmd.Parameters.Add("@ti_chal_timeout_enabled", SqlDbType.TinyInt).Value = timeoutEnabled;

                cmd.ExecuteNonQuery();
            }
        }

        public void ChalSet(string chalName, string scriptText, byte[] blobBytes, UInt32 kickenabled, UInt32 timeoutenabled)
        {
            using (SqlConnection sql = new SqlConnection(_npdbConnectionString))
            {
                sql.Open();

                SqlCommand cmd = new SqlCommand("dbo.p_sg_script_set");
                cmd.Connection = sql;
                cmd.CommandType = CommandType.StoredProcedure;

                cmd.Parameters.Add("@vc_script_name", SqlDbType.VarChar).Value = chalName;
                cmd.Parameters.Add("@ti_enabled", SqlDbType.TinyInt).Value = 1;
                cmd.Parameters.Add("@txt_script", SqlDbType.Text).Value = scriptText;
                cmd.Parameters.Add("@im_blob", SqlDbType.Image).Value = blobBytes;
                if (kickenabled != UInt32.MaxValue)
                {
                    cmd.Parameters.Add("@ti_chal_kick_enabled", SqlDbType.TinyInt).Value = kickenabled;
                }
                if (timeoutenabled != UInt32.MaxValue)
                {
                    cmd.Parameters.Add("@ti_chal_timeout_enabled", SqlDbType.TinyInt).Value = timeoutenabled;
                }

                cmd.ExecuteNonQuery();
            }
        }

        public bool ScriptGetAll(out string outputText)
        {
            StringBuilder sb = new StringBuilder();
            sb.Append("         Script Name   Enabled\n");
            sb.Append("====================   =======\n");

            using (SqlConnection sql = new SqlConnection(_npdbConnectionString))
            {
                sql.Open();

                SqlCommand cmd = new SqlCommand("dbo.p_sg_script_list");
                cmd.Connection = sql;
                cmd.CommandType = CommandType.StoredProcedure;

                using (SqlDataReader reader = cmd.ExecuteReader())
                {
                    while (reader.Read())
                    {
                        string name = reader.GetString(0);
                        string enabled = reader.GetByte(1).ToString();
                        sb.Append(name.PadLeft(20) + "   " + enabled.PadLeft(7) + "\n");
                    }
                }
            }

            outputText = sb.ToString();
            return true;
        }

        public bool ScriptDelete(string scriptName)
        {
            using (SqlConnection sql = new SqlConnection(_npdbConnectionString))
            {
                sql.Open();

                SqlCommand cmd = new SqlCommand();
                cmd.Connection = sql;
                cmd.CommandType = CommandType.Text;
                cmd.CommandText =
                    "delete dbo.t_sg_scripts\n" +
                    "where vc_script_name = @vc_script_name";

                cmd.Parameters.Add("@vc_script_name", SqlDbType.NVarChar).Value = scriptName;

                int rows = cmd.ExecuteNonQuery();

                return rows > 0;
            }
        }

        public void HiveAdd(string environment, string clientConfig, string build, string qfe, Guid beta, string setting, string value)
        {
            using (SqlConnection sql = new SqlConnection(_npdbConnectionString))
            {
                sql.Open();

                SqlCommand cmd = new SqlCommand("dbo.p_live_registry_set_setting");
                cmd.Connection = sql;
                cmd.CommandType = CommandType.StoredProcedure;

                cmd.Parameters.Add("@vc_environment", SqlDbType.NVarChar).Value = environment;
                cmd.Parameters.Add("@vc_client_config", SqlDbType.NVarChar).Value = clientConfig;
                cmd.Parameters.Add("@si_build", SqlDbType.SmallInt).Value = (build.ToLower() == "null") ? null : build;
                cmd.Parameters.Add("@si_qfe", SqlDbType.SmallInt).Value = (qfe.ToLower() == "null") ? null : qfe;
                cmd.Parameters.Add("@guid_beta_group_id", SqlDbType.UniqueIdentifier).Value = beta;
                cmd.Parameters.Add("@vc_setting", SqlDbType.NVarChar).Value = setting;
                cmd.Parameters.Add("@vc_value", SqlDbType.NVarChar).Value = value;

                cmd.ExecuteNonQuery();
            }
        }

        public void HiveDelete(string environment, string clientConfig, string build, string qfe, Guid beta, string setting)
        {
            using (SqlConnection sql = new SqlConnection(_npdbConnectionString))
            {
                sql.Open();

                SqlCommand cmd = new SqlCommand();
                cmd.Connection = sql;
                cmd.CommandType = CommandType.Text;

                if ((build.ToLower() == "null") && (qfe.ToLower() == "null"))
                {
                    cmd.CommandText =
                        "delete dbo.t_live_registry_settings \n" +
                        "where vc_environment = @vc_environment\n" +
                        "and vc_client_config = @vc_client_config\n" +
                        "and si_build is NULL\n" +
                        "and si_qfe is NULL\n" +
                        "and guid_beta_group_id = @guid_beta_group_id\n" +
                        "and vc_setting = @vc_setting";
                }
                else
                {
                    cmd.CommandText =
                        "delete dbo.t_live_registry_settings \n" +
                        "where vc_environment = @vc_environment\n" +
                        "and vc_client_config = @vc_client_config\n" +
                        "and si_build = @si_build\n" +
                        "and si_qfe = @si_qfe\n" +
                        "and guid_beta_group_id = @guid_beta_group_id\n" +
                        "and vc_setting = @vc_setting";
                }
                cmd.Parameters.Add("@vc_environment", SqlDbType.NVarChar).Value = environment;
                cmd.Parameters.Add("@vc_client_config", SqlDbType.NVarChar).Value = clientConfig;
                cmd.Parameters.Add("@si_build", SqlDbType.SmallInt).Value = (build.ToLower() == "null") ? "0" : build;
                cmd.Parameters.Add("@si_qfe", SqlDbType.SmallInt).Value = (qfe.ToLower() == "null") ? "0" : qfe;
                cmd.Parameters.Add("@guid_beta_group_id", SqlDbType.UniqueIdentifier).Value = beta;
                cmd.Parameters.Add("@vc_setting", SqlDbType.NVarChar).Value = setting;

                cmd.ExecuteNonQuery();
            }
        }

        public void HiveDeleteAll(string setting)
        {
            using (SqlConnection sql = new SqlConnection(_npdbConnectionString))
            {
                sql.Open();

                SqlCommand cmd = new SqlCommand();
                cmd.Connection = sql;
                cmd.CommandType = CommandType.Text;

                cmd.CommandText =
                    "delete dbo.t_live_registry_settings \n" +
                    "where vc_setting = @vc_setting";

                cmd.Parameters.Add("@vc_setting", SqlDbType.NVarChar).Value = setting;

                cmd.ExecuteNonQuery();
            }
        }

        public void HiveList(string environment)
        {
            using (SqlConnection sql = new SqlConnection(_npdbConnectionString))
            {
                sql.Open();

                SqlCommand cmd = new SqlCommand("dbo.p_live_registry_get_all_settings");
                cmd.Connection = sql;
                cmd.CommandType = CommandType.StoredProcedure;

                cmd.Parameters.Add("@vc_environment", SqlDbType.NVarChar).Value = environment;

                using (SqlDataReader reader = cmd.ExecuteReader())
                {
                    string columnHeader = string.Format("{0, -16} {1, -9} {2, -7} {3, -38} {4, -45} {5}",
                                                                "vc_client_config",
                                                                "si_build",
                                                                "si_qfe",
                                                                "guid_beta_group_id",
                                                                "vc_setting",
                                                                "vc_value");

                    string columnDivider = string.Format("{0, -16} {1, -9} {2, -7} {3, -38} {4, -45} {5}",
                                                                "----------------",
                                                                "--------",
                                                                "------",
                                                                "---------------",
                                                                "---------",
                                                                "--------");
                    XblCfgConsole.Out(columnHeader);
                    XblCfgConsole.Out(columnDivider);

                    while (reader.Read())
                    {
                        string outputRow = string.Format("{0, -16} {1, -9} {2, -7} {3, -38} {4, -45} {5}", reader["vc_client_config"],
                                                                        reader.IsDBNull(reader.GetOrdinal("si_build")) ? "NULL" : Convert.ToString(reader["si_build"]),
                                                                        reader.IsDBNull(reader.GetOrdinal("si_qfe")) ? "NULL" : Convert.ToString(reader["si_qfe"]),
                                                                        Convert.ToString(reader["guid_beta_group_id"]),
                                                                        reader["vc_setting"],
                                                                        reader["vc_value"]);

                        XblCfgConsole.Out(outputRow);
                    }
                }
            }
        }

        public string DevkitListGet()
        {
            string list = "";

            using (SqlConnection sql = new SqlConnection(_npdbConnectionString))
            {
                sql.Open();

                SqlCommand cmd = new SqlCommand("dbo.p_config_get_setting");
                cmd.Connection = sql;
                cmd.CommandType = CommandType.StoredProcedure;

                cmd.Parameters.Add("@vc_setting", SqlDbType.NVarChar).Value = Setting.kdcsvc_xmacs_consoleExceptionList;

                using (SqlDataReader reader = cmd.ExecuteReader())
                {
                    while (reader.Read())
                    {
                        if (reader.IsDBNull(reader.GetOrdinal("vc_value")) != true)
                        {
                            list += reader["vc_value"];
                        }
                    }
                }
            }
            return list;
        }

        public void DevkitListSet(string list)
        {
            using (SqlConnection sql = new SqlConnection(_npdbConnectionString))
            {
                sql.Open();

                SqlCommand cmd = new SqlCommand("dbo.p_config_add_setting");
                cmd.Connection = sql;
                cmd.CommandType = CommandType.StoredProcedure;

                cmd.Parameters.Add("@setting", SqlDbType.NVarChar).Value = Setting.kdcsvc_xmacs_consoleExceptionList;
                cmd.Parameters.Add("@value", SqlDbType.NVarChar).Value = list;
                cmd.Parameters.Add("@overwriteExistingValue", SqlDbType.Bit).Value = 1;

                cmd.ExecuteNonQuery();
            }
        }

        /// MultiSettingAdd: 
        /// Add a given multisetting to t_multisetting_overrides
        /// Uses MultiSettingInfoMessage to capture results of commandtext print.
        ///
        /// Parameters:
        ///    environment - vc_environment of Live Server environment
        ///    component - vc_component of Live Server component
        ///    site - i_site_id of Live Server site id
        ///    server - vc_server of Live Server server
        ///    multisetting - vc_multisetting to add
        ///    value - vc_value for the multisetting
        ///
        /// Returns n/a
        public void MultiSettingAdd(string environment, string component, string site, string server, string multisetting, string value)
        {
            using (SqlConnection sql = new SqlConnection(_npdbConnectionString))
            {
                sql.InfoMessage += new SqlInfoMessageEventHandler(MultiSettingInfoMessage);
                sql.Open();

                SqlCommand cmd = new SqlCommand("dbo.p_config_add_multisetting_override");
                cmd.Connection = sql;
                cmd.CommandType = CommandType.StoredProcedure;

                cmd.Parameters.Add("@multisetting", SqlDbType.NVarChar).Value = multisetting;
                cmd.Parameters.Add("@value", SqlDbType.NVarChar).Value = value;
                if ("ALL" != environment)
                    cmd.Parameters.Add("@environment", SqlDbType.NVarChar).Value = environment;
                if ("ALL" != component)
                    cmd.Parameters.Add("@component", SqlDbType.NVarChar).Value = component;
                if ("-1" != site)
                    cmd.Parameters.Add("@site_id", SqlDbType.Int).Value = site;
                if ("ALL" != server)
                    cmd.Parameters.Add("@server", SqlDbType.NVarChar).Value = server;

                cmd.ExecuteNonQuery();
            }
        }

        /// MultiSettingDelete: 
        /// Delete a given multisetting from t_multisetting_overrides (for a given environment)
        /// Uses MultiSettingInfoMessage to capture results of commandtext print.
        ///
        /// Parameters:
        ///    environment - vc_environment of Live Server environment
        ///    component - vc_component of Live Server component
        ///    site - i_site_id of Live Server site id
        ///    server - vc_server of Live Server server
        ///    multisetting - vc_multisetting to delete
        ///
        /// Returns n/a
        public void MultiSettingDelete(string environment, string component, string site, string server, string multisetting)
        {
            using (SqlConnection sql = new SqlConnection(_npdbConnectionString))
            {
                sql.InfoMessage += new SqlInfoMessageEventHandler(MultiSettingInfoMessage);
                sql.Open();

                SqlCommand cmd = new SqlCommand();
                cmd.Connection = sql;
                cmd.CommandType = CommandType.Text;

                cmd.CommandText = "print 'Deleting Multisetting Override with parameters: @multisetting = ' + @vc_multisetting + ' @environment = ' + @vc_environment + ' @component = ' + @vc_component + ' @siteId = ' + cast(@i_site_id as varchar) + ' @server = ' + @vc_server\n";
                cmd.CommandText += "delete dbo.t_multisetting_overrides " +
                                    "where vc_environment = @vc_environment " +
                                    "and vc_component = @vc_component " +
                                    "and i_site_id = @i_site_id " +
                                    "and vc_server = @vc_server " +
                                    "and vc_multisetting = @vc_multisetting\n";
                cmd.CommandText += "print cast(@@rowcount as varchar) + ' Rows deleted.'";

                cmd.Parameters.Add("@vc_environment", SqlDbType.NVarChar).Value = environment;
                cmd.Parameters.Add("@vc_component", SqlDbType.NVarChar).Value = component;
                cmd.Parameters.Add("@i_site_id", SqlDbType.Int).Value = site;
                cmd.Parameters.Add("@vc_server", SqlDbType.NVarChar).Value = server;
                cmd.Parameters.Add("@vc_multisetting", SqlDbType.NVarChar).Value = multisetting;

                cmd.ExecuteNonQuery();
            }
        }

        /// MultiSettingDeleteAll: 
        /// Delete a given multisetting from t_multisetting_overrides (for all environments, components, servers, etc.)
        ///
        /// Parameters:
        ///    multisetting - vc_multisetting to delete
        ///
        /// Returns n/a
        public void MultiSettingDeleteAll(string multisetting)
        {
            using (SqlConnection sql = new SqlConnection(_npdbConnectionString))
            {
                sql.InfoMessage += new SqlInfoMessageEventHandler(MultiSettingInfoMessage);
                sql.Open();

                SqlCommand cmd = new SqlCommand();
                cmd.Connection = sql;
                cmd.CommandType = CommandType.Text;

                cmd.CommandText =
                    "delete dbo.t_multisetting_overrides " +
                    "where vc_multisetting = @vc_multisetting \n";
                cmd.CommandText += "print cast(@@rowcount as varchar) + ' Rows deleted.'";

                cmd.Parameters.Add("@vc_multisetting", SqlDbType.NVarChar).Value = multisetting;

                cmd.ExecuteNonQuery();
            }
        }

        /// MultiSettingInfoMessage: SqlInfoMessageEventHandler Delegate
        /// Use the SqlInfoMessageEventArgs to output useful messages to the command line
        ///
        /// Parameters:
        ///    sender - The source of the event. 
        ///    e - A SqlInfoMessageEventArgs object that contains the event data.
        ///
        /// Returns n/a
        public void MultiSettingInfoMessage(Object sender, SqlInfoMessageEventArgs e)
        {
            XblCfgConsole.Out(e.Message);
        }

        /// MultiSettingList: 
        /// List the contents of npdb.t_multisetting_overrides for the given environment
        ///
        /// Parameters:
        ///    environment - Live Server environment 
        ///
        /// Returns n/a
        public void MultiSettingList(string environment)
        {
            using (SqlConnection sql = new SqlConnection(_npdbConnectionString))
            {
                sql.Open();

                SqlCommand cmd = new SqlCommand("dbo.p_config_get_all_multisetting_overrides");
                cmd.Connection = sql;
                cmd.CommandType = CommandType.StoredProcedure;

                cmd.Parameters.Add("@vc_environment", SqlDbType.NVarChar).Value = environment;

                using (SqlDataReader reader = cmd.ExecuteReader())
                {
                    string columnHeader = string.Format("{0, -16} {1, -9} {2, -16} {3, -16} {4, -16}",
                                                                "vc_component",
                                                                "i_site_id",
                                                                "vc_server",
                                                                "vc_multisetting",
                                                                "vc_value");

                    string columnDivider = string.Format("{0, -16} {1, -9} {2, -16} {3, -16} {4, -16}",
                                                                "------------",
                                                                "---------",
                                                                "---------",
                                                                "---------------",
                                                                "--------");
                    XblCfgConsole.Out(columnHeader);
                    XblCfgConsole.Out(columnDivider);

                    while (reader.Read())
                    {
                        string component = reader.GetString(0);
                        string site_id = reader.IsDBNull(1) ? "NULL" : Convert.ToString(reader.GetInt32(1));
                        string server = reader.GetString(2);
                        string multisetting = reader.GetString(3);
                        string value = reader.GetString(4);

                        while (0 < component.Length + site_id.Length + server.Length + multisetting.Length)
                        {
                            string outputRow = string.Format("{0, -16} {1, -9} {2, -16} {3, -16} {4, -16}",
                                                                    (16 < component.Length) ? component.Substring(0, 16) : component,
                                                                    (16 < site_id.Length) ? site_id.Substring(0, 16) : site_id,
                                                                    (16 < server.Length) ? server.Substring(0, 16) : server,
                                                                    (16 < multisetting.Length) ? multisetting.Substring(0, 16) : multisetting,
                                                                    (16 < value.Length) ? value.Substring(0, 16) : value);
                            XblCfgConsole.Out(outputRow);

                            component = (16 < component.Length) ? component.Substring(16) : "";
                            site_id = (16 < site_id.Length) ? site_id.Substring(16) : "";
                            server = (16 < server.Length) ? server.Substring(16) : "";
                            multisetting = (16 < multisetting.Length) ? multisetting.Substring(16) : "";
                            value = (16 < value.Length) ? value.Substring(16) : "";
                        }
                        if (0 < value.Length)
                        {
                            XblCfgConsole.Out(value);
                        }
                    }
                }
            }
        }

        public void AddServer(string serverName, int siteId, string nicRole, IPAddress ip, IPAddress netmask, IPAddress gateway,
            PhysicalAddress mac, IPAddress sgStartIP, IPAddress sgEndIP, int sgStartPort, int sgEndPort)
        {
            XblCfgConsole.Out(
                "Adding '{0}' configuration for '{1}'\n IP:{2}\n Mask:{3}\n Gateway:{4}\n MAC:{5}",
                nicRole, serverName, ip, netmask, gateway, mac);

            if (sgStartIP != null)
            {
                XblCfgConsole.Out(
                    " SG Pool Begin IP:{0}\n SG Pool End IP:{1}\n SG Pool Begin Port:{2}\n SG Pool End Port:{3}\n",
                    sgStartIP, sgEndIP, sgStartPort, sgEndPort);
            }
            else
            {
                XblCfgConsole.Out("");
            }

            using (SqlConnection sql = new SqlConnection(_npdbConnectionString))
            {
                sql.Open();

                SqlCommand cmd = new SqlCommand("dbo.p_config_add_server");
                cmd.Connection = sql;
                cmd.CommandType = CommandType.StoredProcedure;

                cmd.Parameters.Add("@environment", SqlDbType.NVarChar).Value = Config.Environment;
                cmd.Parameters.Add("@server", SqlDbType.NVarChar).Value = serverName;
                cmd.Parameters.Add("@servertype", SqlDbType.NVarChar).Value = "unused";
                cmd.Parameters.Add("@siteId", SqlDbType.Int).Value = siteId;
                cmd.Parameters.Add("@serverState", SqlDbType.NVarChar).Value = "online";
                cmd.Parameters.Add("@serverId", SqlDbType.Int).Value = 1;
                cmd.Parameters.Add("@overwriteExistingValue", SqlDbType.Bit).Value = true;

                cmd.ExecuteNonQuery();

                cmd = new SqlCommand("dbo.p_config_add_server_nic");
                cmd.Connection = sql;
                cmd.CommandType = CommandType.StoredProcedure;

                cmd.Parameters.Add("@environment", SqlDbType.NVarChar).Value = Config.Environment;
                cmd.Parameters.Add("@server", SqlDbType.NVarChar).Value = serverName;
                cmd.Parameters.Add("@nicRole", SqlDbType.NVarChar).Value = nicRole;
                cmd.Parameters.Add("@ip", SqlDbType.NVarChar).Value = ip.ToString();
                cmd.Parameters.Add("@ipNetmask", SqlDbType.NVarChar).Value = netmask.ToString();
                cmd.Parameters.Add("@ipDefaultGateway", SqlDbType.NVarChar).Value = gateway != null ? gateway.ToString() : null;
                cmd.Parameters.Add("@mac", SqlDbType.NVarChar).Value = mac != null ? mac.ToString() : null;
                cmd.Parameters.Add("@sgIpBegin", SqlDbType.NVarChar).Value = sgStartIP != null ? sgStartIP.ToString() : null;
                cmd.Parameters.Add("@sgIpEnd", SqlDbType.NVarChar).Value = sgEndIP != null ? sgEndIP.ToString() : null;
                cmd.Parameters.Add("@sgPortBegin", SqlDbType.Int).Value = sgStartIP != null ? (object)sgStartPort : null;
                cmd.Parameters.Add("@sgPortEnd", SqlDbType.Int).Value = sgEndIP != null ? (object)sgEndPort : null;
                cmd.Parameters.Add("@wiretapIp", SqlDbType.NVarChar).Value = null;
                cmd.Parameters.Add("@b_disabled", SqlDbType.Bit).Value = null;
                cmd.Parameters.Add("@overwriteExistingValue", SqlDbType.Bit).Value = true;

                cmd.ExecuteNonQuery();
            }
        }

        public bool DeleteServer(string serverName, string nicRole)
        {
            if (String.IsNullOrEmpty(nicRole))
            {
                XblCfgConsole.Out("Attempting to unregister server '{0}' from npdb\n", serverName);
            }
            else
            {
                XblCfgConsole.Out("Attempting to unregister '{1}' nic role from server '{0}' in npdb\n", serverName, nicRole);
            }

            bool deleteSucceded = true;
            using (SqlConnection sql = new SqlConnection(_npdbConnectionString))
            {
                try
                {
                    sql.Open();

                    SqlCommand cmd;

                    if (String.IsNullOrEmpty(nicRole))
                    {
                        cmd = new SqlCommand("dbo.p_config_delete_server");
                        cmd.CommandType = CommandType.StoredProcedure;
                    }
                    else
                    {
                        cmd = new SqlCommand("delete from t_server_nics where vc_server = @server and vc_environment = @environment and vc_nic_role = @nic");
                        cmd.Parameters.Add("@nic", SqlDbType.NVarChar).Value = nicRole;
                    }
                    cmd.Connection = sql;

                    cmd.Parameters.Add("@environment", SqlDbType.NVarChar).Value = Config.Environment;
                    cmd.Parameters.Add("@server", SqlDbType.NVarChar).Value = serverName;

                    using (SqlDataReader reader = cmd.ExecuteReader())
                    {
                        // If there are no rows, then the delete succeeded
                        deleteSucceded = !reader.HasRows;
                        if (!deleteSucceded)
                        {
                            XblCfgConsole.Out("Cannot delete server, conflicting rows in the following tables:");
                            while (reader.Read())
                            {
                                int count = reader.GetInt32(reader.GetOrdinal("count"));
                                XblCfgConsole.Out("  Server: {0} ({1} row{2})", reader["table"], reader["count"], count > 1 ? "s" : String.Empty);
                            }
                        }
                        reader.Close();
                    }
                }
                catch (SqlException e)
                {
                    XblCfgConsole.Out("Unable to connect to execute delete command, skipping the delete operation.\n\nDetails:\n{0}", e.Message);
                    return false;
                }
            }
            return deleteSucceded;
        }

        public string[] GetServersByInterface(string _interface)
        {
            using (SqlConnection sql = new SqlConnection(_npdbConnectionString))
            {
                List<string> servers = new List<string>();
                try
                {
                    sql.Open();

                    SqlCommand cmd = sql.CreateCommand();

                    cmd.CommandText = "p_config_get_server_list_by_interface";
                    cmd.CommandType = CommandType.StoredProcedure;

                    cmd.Parameters.Add("@vc_environment", SqlDbType.VarChar).Value = Config.Environment;
                    cmd.Parameters.Add("@vc_interface", SqlDbType.VarChar).Value = _interface;

                    using (SqlDataReader reader = cmd.ExecuteReader())
                    {
                        while (reader.Read())
                        {
                            servers.Add(reader.GetString(reader.GetOrdinal("vc_server")));
                        }
                    }
                }
                catch (SqlException e)
                {
                    XblCfgConsole.Out("Unable to connect to gather server info.\n\nDetails:\n{0}", e.Message);
                    return null;
                }
                return servers.ToArray();
            }
        }

        public string GetNicRoleByVirtualInterface(string virtualInterface)
        {
            using (SqlConnection connection = new SqlConnection(_npdbConnectionString))
            {
                try
                {
                    connection.Open();

                    SqlCommand cmd = new SqlCommand("p_config_get_interface_by_virtual_interface");
                    cmd.Connection = connection;
                    cmd.CommandType = CommandType.StoredProcedure;

                    cmd.Parameters.Add("@vc_virtual_interface", SqlDbType.NVarChar).Value = virtualInterface;

                    using (SqlDataReader reader = cmd.ExecuteReader())
                    {
                        if (reader.Read())
                        {
                            return (string)reader["vc_nic_role"];
                        }
                        else
                        {
                            return null;
                        }
                    }
                }
                catch (SqlException e)
                {
                    XblCfgConsole.Out("Unable to obtain nic role for virtual interface: {0} from server.\n\nDetails:\n{1}", virtualInterface, e.Message);
                    return null;
                }
            }
        }

        public string GetIpByServerNicRole(string serverName, string nicRole)
        {
            using (SqlConnection connection = new SqlConnection(_npdbConnectionString))
            {
                try
                {
                    connection.Open();

                    SqlCommand cmd = new SqlCommand("p_config_get_server_nic");
                    cmd.Connection = connection;
                    cmd.CommandType = CommandType.StoredProcedure;

                    cmd.Parameters.Add("@vc_environment", SqlDbType.NVarChar).Value = Config.Environment;
                    cmd.Parameters.Add("@vc_server", SqlDbType.NVarChar).Value = serverName;
                    cmd.Parameters.Add("@vc_nic_role", SqlDbType.NVarChar).Value = nicRole;

                    using (SqlDataReader reader = cmd.ExecuteReader())
                    {
                        if (reader.Read())
                        {
                            return (string)reader["vc_ip"];
                        }
                        else
                        {
                            return null;
                        }
                    }
                }
                catch (SqlException e)
                {
                    XblCfgConsole.Out("Unable to gather server nic info for server: {0} nic role:{1}.\n\nDetails:\n{2}", serverName, nicRole, e.Message);
                    return null;
                }
            }
        }

        public void AddVirtualInterfaceIp(int siteId, string virtualInterface, string vip, bool overwriteExistingValue)
        {
            XblCfgConsole.Out("Adding ip {0} to virtual interface {1} for site {2}", vip, virtualInterface, siteId);
            if (overwriteExistingValue)
            {
                XblCfgConsole.Out("Overwriting existing value if the virtual interface is already defined.");
            }

            using (SqlConnection connection = new SqlConnection(_npdbConnectionString))
            {
                connection.Open();

                SqlCommand cmd = new SqlCommand("p_config_add_site_virtual_interface_ip");
                cmd.Connection = connection;
                cmd.CommandType = CommandType.StoredProcedure;

                cmd.Parameters.Add("@environment", SqlDbType.NVarChar).Value = Config.Environment;
                cmd.Parameters.Add("@siteId", SqlDbType.Int).Value = siteId;
                cmd.Parameters.Add("@virtualInterface", SqlDbType.NVarChar).Value = virtualInterface;
                cmd.Parameters.Add("@ip", SqlDbType.NVarChar).Value = vip;
                cmd.Parameters.Add("@overwriteExistingValue", SqlDbType.Bit).Value = overwriteExistingValue;

                int rowsAffected = cmd.ExecuteNonQuery();

                if (rowsAffected <= 0)
                {
                    if (overwriteExistingValue)
                    {
                        XblCfgConsole.Out("Unable to add {0} to virtual interface {1} for site {2}. No changes made.", vip, virtualInterface, siteId, rowsAffected);
                    }
                    else
                    {
                        XblCfgConsole.Out("{0} NOT added to virtual interface {1} for site {2}, use the -overwrite flag if updating existing value.", vip, virtualInterface, siteId);
                    }
                }
                else
                {
                    XblCfgConsole.Out("{0} added to virtual interface {1} for site {2} successfully.", vip, virtualInterface, siteId);
                }
            }
        }

        public int[] GetAllSiteIds()
        {
            using (SqlConnection connection = new SqlConnection(_npdbConnectionString))
            {
                try
                {
                    connection.Open();

                    SqlCommand cmd = new SqlCommand("p_sites_get_all");
                    cmd.Connection = connection;
                    cmd.CommandType = CommandType.StoredProcedure;

                    cmd.Parameters.Add("@vc_environment", SqlDbType.NVarChar).Value = Config.Environment;

                    List<int> siteIds = new List<int>();

                    using (SqlDataReader reader = cmd.ExecuteReader())
                    {
                        while (reader.Read())
                        {
                            siteIds.Add((int)reader["i_site_id"]);
                        }
                    }

                    return siteIds.ToArray();
                }
                catch (SqlException e)
                {
                    XblCfgConsole.Out("Unable to gather all site ids.\n\nDetails:\n{0}", e.Message);
                    return null;
                }
            }
        }

        protected string _npdbConnectionString;
    }

    public class BetaGroup
    {
        public Guid Id { get { return _id; } }
        public string Name { get { return _name; } }
        public string CreatedBy { get { return _createdBy; } }
        public DateTime Created { get { return _created; } }

        public BetaGroup(Guid id, string name, string createdBy, DateTime created)
        {
            _id = id;
            _name = name;
            _createdBy = createdBy;
            _created = created;
        }

        public BetaGroup(WstDataReader reader)
        {
            _id = (Guid)reader["uid_group_id"];
            _name = (string)reader["vc_group_name"];
            _createdBy = (string)reader["vc_created_by"];
            _created = (DateTime)reader["dt_created"];
        }

        private readonly Guid _id;
        private readonly string _name;
        private readonly string _createdBy;
        private readonly DateTime _created;
    }

    public static class BetaGroupManager
    {
        public const int MAX_FRIENDLY_NAME_LENGTH = 100;

        public static bool TryGetBetaGroup(Guid groupId, out BetaGroup group)
        {
            group = null;

            using (WSClient ws = new WSClient(ConfigUtil.UodbWebstoreApp, CmdType.WRITETHENREAD_COMMANDTYPE))
            {
                ws.SetHashVal(groupId);
                ws.StoredProc = "p_beta_group_query";
                ws.AddParameter(ParamType.INPUT, "@uid_group_id", groupId);

                using (WstDataReader reader = ws.Execute())
                {
                    if (!reader.Read())
                    {
                        return false;
                    }
                    else
                    {
                        group = new BetaGroup(reader);
                        return true;
                    }
                }
            }
        }

        public static IEnumerable<BetaGroup> GetAllBetaGroups()
        {
            using (WSClient ws = new WSClient(ConfigUtil.UodbWebstoreApp, CmdType.WRITETHENREAD_COMMANDTYPE))
            {

                for (int partition = 0; partition < ws.PhysicalPartitions; ++partition)
                {
                    ws.ClearParameters();
                    ws.PhysicalPartition = partition;
                    ws.StoredProc = "p_beta_group_list";

                    using (WstDataReader reader = ws.Execute())
                    {
                        while (reader.Read())
                        {
                            yield return new BetaGroup(reader);
                        }
                    }
                }
            }
        }

        public static bool BetaGroupExists(Guid groupId)
        {
            BetaGroup group = null;
            return TryGetBetaGroup(groupId, out group);
        }

        public static IEnumerable<ulong> GetMachinesForBetaGroup(Guid groupId)
        {
            using (WSClient ws = new WSClient(ConfigUtil.UodbWebstoreApp, CmdType.WRITETHENREAD_COMMANDTYPE))
            {
                for (int partition = 0; partition < ws.PhysicalPartitions; ++partition)
                {
                    ws.ClearParameters();
                    ws.PhysicalPartition = partition;
                    ws.StoredProc = "p_beta_group_group_get_machines";
                    ws.AddParameter(ParamType.INPUT, "@uid_group_id", groupId);

                    using (WstDataReader reader = ws.Execute())
                    {
                        while (reader.Read())
                        {
                            yield return (ulong)(long)reader["bi_machine_puid"];
                        }
                    }
                }
            }
        }

        public static bool TryGetBetaGroupForMachine(ulong machinePuid, out Guid betaId)
        {
            betaId = Guid.Empty;

            using (WSClient ws = new WSClient(ConfigUtil.UodbWebstoreApp, CmdType.WRITETHENREAD_COMMANDTYPE))
            {
                ws.SetHashVal(machinePuid);
                ws.StoredProc = "p_beta_group_machine_get_groups";
                ws.AddParameter(ParamType.INPUT, "@bi_machine_puid", machinePuid);

                using (WstDataReader reader = ws.Execute())
                {
                    // This can only possibly be one or zero things, because of the contrainst on t_machine_beta_group
                    if (!reader.Read())
                    {
                        return false;
                    }
                    else
                    {
                        betaId = (Guid)reader["uid_group_id"];
                        return true;
                    }
                }
            }
        }

        public static void CreateGroup(Guid betaId, string friendlyName, string createdBy)
        {
            using (WSClient ws = new WSClient(ConfigUtil.UodbWebstoreApp, CmdType.WRITEONLY_COMMANDTYPE))
            {
                ws.SetHashVal(betaId);
                ws.StoredProc = "p_beta_group_create";
                ws.AddParameter(ParamType.INPUT, "@uid_group_id", betaId);
                ws.AddParameter(ParamType.INPUT, "@vc_group_name", friendlyName);
                ws.AddParameter(ParamType.INPUT, "@vc_created_by", createdBy);
                ws.AddParameter(ParamType.INPUT, "@si_hash_bucket", ws.Partition);

                using (WstDataReader reader = ws.Execute())
                {
                    // Don't use the results at all--we just want to create the group.
                }
            }
        }

        public static void AddRemoveMachineGroup(ulong machinePuid, Guid betaId, bool add)
        {
            using (WSClient ws = new WSClient(ConfigUtil.UodbWebstoreApp, CmdType.WRITEONLY_COMMANDTYPE))
            {
                ws.SetHashVal(machinePuid);
                ws.StoredProc = add ? "p_beta_group_machine_add": "p_beta_group_machine_remove";
                ws.AddParameter(ParamType.INPUT, "@bi_machine_puid", machinePuid);
                ws.AddParameter(ParamType.INPUT, "@uid_group_id", betaId);
                if (add)
                {
                    ws.AddParameter(ParamType.INPUT, "@si_hash_bucket", ws.Partition);
                }

                ws.ExecuteNonQuery();
            }
        }
    }

    public static class MachineManager
    {
        public static bool MachineExists(ulong machinePuid)
        {
            string consoleId;
            return TryLookupConsoleId(machinePuid, out consoleId);
        }

        public static bool TryLookupConsoleId(ulong machinePuid, out string consoleId)
        {
            try
            {
                consoleId = ConsoleIdUtil.GetXbox360ConsoleIdStringFromMachineId( machinePuid );
            }
            catch (Exception)
            {
                consoleId = String.Empty;
            }
            return (consoleId != String.Empty);
        }

        public static bool TryLookupMachinePuid(string consoleId, out ulong machinePuid)
        {
            //
            // This code will have to be updated at some point in order to receive a hint
            // so that it multiple machine puids are returned/possible from the consoleid
            // then this code could select the correct one.
            // 
            try
            {
                machinePuid = MachinePuidUtil.GetMachineIdFromConsoleId( consoleId );
            }
            catch (Exception)
            {
                machinePuid = 0;
            }
            return (machinePuid != 0);
        }

        public static bool TryLookupMachinePuids(string consoleId, out Puid[] machinePuids)
        {
            try
            {
                machinePuids = MachinePuidUtil.GetMachineIdsFromConsoleId( consoleId );
            }
            catch (Exception)
            {
                machinePuids = null;
            }
            return (machinePuids != null);
        }

        public static bool ResetConsole(string consoleId)
        {
            ConsoleIdResult[] result = null;

            try
            {
                XMachineSoapClient connection = new XMachineSoapClient();

                String[] resetConsoleIds = new String[1];
                resetConsoleIds[0] = consoleId;

                result = connection.ResetMachinePasswordByConsoleIds( resetConsoleIds );
            }
            catch (Exception)
            {
                result = null;
            }

            return (result != null && result.Length == 1 && ( (HResult) result[0].Result).IsSuccess());
        }
    }

    public static class DevkitManager
    {
        private static string _List = null;
        public static string List
        {
            get
            {
                if (_List != null)
                {
                    return _List;
                }

                Npdb npdb = new Npdb();
                _List = npdb.DevkitListGet();
                return _List;
            }

            set
            {
                _List = value;

                Npdb npdb = new Npdb();
                npdb.DevkitListSet(value);
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\XblCfg\Test\ActionMultiSetting.cs ===
using ServerTestFramework;
using ServerTestFramework.Utilities;
using ServerTestFramework.Database;
using ServerTestFramework.LiveService;

using System.Collections.Generic;
using System.Data.SqlClient;
using System.Data;
using System.Net;
using System;

namespace XblConfigTest
{
    //Util
    public class MultiSettingUtil
    {
        public static void VerifyOutputHasNoErrors(string output)
        {
            string lowerOutput=output.ToLower();
            if (lowerOutput.Contains("usage error")) throw new UnexpectedTestResultException("Output contains an usage error.");
            if (lowerOutput.Contains("internal error")) throw new UnexpectedTestResultException("Output contains an internal error.");
            if (lowerOutput.Contains("exception")) throw new UnexpectedTestResultException("Output contains an exception.");
            //TODO: anything else we can check here?
        }

        //cleans out all entries for our test multisetting from npdb
        public static void CleanTestSetting()
        {
            using (Npdb npdb=new Npdb())
            {
                npdb.ConnectToServer();
                npdb.IssueCommand("delete from t_multisetting_overrides where vc_multisetting='"+MultiSetting.TestSettingName+"'");
            }
        }

        //Adds a new entry directly to npdb for our test setting for our environment
        public static void AddTestSettingOverride(string component, int site, string server, string value)
        {
            Global.RO.Debug("Directly adding setting("+MultiSetting.TestSettingName+") for ("+component+" "+site+" "+server+") value: "+value);

            component=component.Replace("'","''");
            server=server.Replace("'","''");
            value=value.Replace("'","''");

            using (Npdb npdb=new Npdb())
            {
                npdb.ConnectToServer();
                npdb.IssueCommand("insert into t_multisetting_overrides"+
                                  "(vc_environment,             vc_component,    i_site_id, vc_server,    vc_multisetting,                    vc_value) values "+
                                  "('"+Global.XEnv.GetEnv()+"', '"+component+"', "+site+",  '"+server+"', '"+MultiSetting.TestSettingName+"', '"+value+"')");
            }
        }

        //does a query on NPDB and verifies that the returned value is equal to count
        public static void VerifyQueryCount(string query, int count)
        {
            using (Npdb npdb=new Npdb())
            {
                npdb.ConnectToServer();
                object ret=npdb.ExecuteScalar(query);
                int retInt=(int)ret;
                ValueCheck.Test("Value returned by: "+query+"\n", count, retInt);
            }
        }
    }; //class MultiSettingUtil

    //Tests
    [TestGroup]
    public class MultiSetting: TestNode
    {
        public const string TestSettingName="test_xblcfg_multisettingTest";

        //base that always does a Clean in the PreRun
        public class TestNode_PreRunCleanup: TestNode
        {
            public override void PreRun()
            {
                MultiSettingUtil.CleanTestSetting();
            }
        };

        public override void PreRun()
        {
            //create a new multisetting type for use by the test if needed
            using (Npdb npdb=new Npdb())
            {
                npdb.ConnectToServer();
                npdb.IssueCommand("if ((select count(0) from t_multisetting_names where vc_multisetting='"+TestSettingName+"')=0) begin insert into t_multisetting_names (vc_multisetting) values ('"+TestSettingName+"') end");
            }

            //cleanup
            MultiSettingUtil.CleanTestSetting();
        }

        //
        [TestCase, Description("We should see help text in the output.")]
        public void NoArgs()
        {
            string output=CfgUtil.RunXblConfig("-multisetoverrides");

            //verify the high level options are present in the output text
            string lowerOutput=output.ToLower();
            if (!lowerOutput.Contains("-add")) throw new UnexpectedTestResultException("-add help text not present.");
            if (!lowerOutput.Contains("-delete")) throw new UnexpectedTestResultException("-delete help text not present.");
            if (!lowerOutput.Contains("-deleteall")) throw new UnexpectedTestResultException("-deleteall help text not present.");
            if (!lowerOutput.Contains("-list")) throw new UnexpectedTestResultException("-list help text not present.");
            if (!lowerOutput.Contains("-file")) throw new UnexpectedTestResultException("-file help text not present.");
        }

        //Tests for the ADD option
        [TestGroup, Description("Tests for the -add options")]
        public class Add: TestNode
        {
            [TestCase, Description("Runs -add with the minimal set of parameters possible.")]
            public class MinimalParameters: TestNode_PreRunCleanup
            {
                public override void Run()
                {
                    string output=CfgUtil.RunXblConfig("-multisetoverrides -add -env:"+Global.XEnv.GetEnv()+" -multisetting:"+TestSettingName+" -value:testminimal");
                    MultiSettingUtil.VerifyOutputHasNoErrors(output);
                    MultiSettingUtil.VerifyQueryCount("select count(0) from t_multisetting_overrides where vc_environment='"+Global.XEnv.GetEnv()+"' and vc_component='ALL' and i_site_id=-1 and vc_server='ALL' and vc_multisetting='"+TestSettingName+"' and vc_value='testminimal'", 1);
                }
            };

            [TestCase, Description("Runs -add specifying every possible parameter")]
            public class UseAllParameters: TestNode_PreRunCleanup
            {
                public override void Run()
                {
                    //get the name of a kdc
                    string kdcServerName=Global.XEnv.GetServerListByInterface("kdcsvc")[0];

                    //
                    string output=CfgUtil.RunXblConfig("-multisetoverrides -add -env:"+Global.XEnv.GetEnv()+" -component:kdcsvc -site:9999 -server:"+kdcServerName+" -multisetting:"+TestSettingName+" -value:testall");
                    MultiSettingUtil.VerifyOutputHasNoErrors(output);
                    MultiSettingUtil.VerifyQueryCount("select count(0) from t_multisetting_overrides where vc_environment='"+Global.XEnv.GetEnv()+"' and vc_component='kdcsvc' and i_site_id=9999 and vc_server='"+kdcServerName+"' and vc_multisetting='"+TestSettingName+"' and vc_value='testall'", 1);
                }
            };

            [TestCase, Description("Runs -add with a setting name that doesn't exist.")]
            public class NonexistantSettingName: TestNode_PreRunCleanup
            {
                public override void Run()
                {
                    string output=CfgUtil.RunXblConfig("-multisetoverrides -add -env:"+Global.XEnv.GetEnv()+" -multisetting:"+TestSettingName+"_fake -value:testminimal");

                    if (!output.ToLower().Contains("the insert statement conflicted with the foreign key constraint"))
                    {
                        throw new UnexpectedTestResultException("Expected output to contain a foreign key violation error.");
                    }

                    MultiSettingUtil.VerifyQueryCount("select count(0) from t_multisetting_overrides where vc_environment='"+Global.XEnv.GetEnv()+"' and vc_component='ALL' and i_site_id=-1 and vc_server='ALL' and vc_multisetting='"+TestSettingName+"_fake' and vc_value='testminimal'", 0);
                }
            };
        }; //class Add

        //Tests for the LIST option
        [TestGroup, Description("Tests for the -list options")]
        public class List: TestNode
        {
            [TestCase, Description("Runs -list for a valid setting that has no overiddes.")]
            public class NoEntry: TestNode_PreRunCleanup
            {
                public override void Run()
                {
                    string output=CfgUtil.RunXblConfig("-multisetoverrides -list -env:"+Global.XEnv.GetEnv());
                    MultiSettingUtil.VerifyOutputHasNoErrors(output);

                    //the output gets broken up over multiple lines... so check for a the first line that would be our setting.
                    if (output.Contains(TestSettingName.Substring(0, 16)))
                    {
                        throw new UnexpectedTestResultException("Did not expected -list to contain our test setting: "+TestSettingName);
                    }
                }
            };

            [TestCase, Description("Runs -list for a valid setting that has one overidde.")]
            public class OneEntry: TestNode_PreRunCleanup
            {
                public override void Run()
                {
                    //poke an entry into the db
                    MultiSettingUtil.AddTestSettingOverride("ALL", -1, "ALL", "testone");

                    //run
                    string output=CfgUtil.RunXblConfig("-multisetoverrides -list -env:"+Global.XEnv.GetEnv());
                    MultiSettingUtil.VerifyOutputHasNoErrors(output);

                    //step through all lines and verify that there is exactly one entry for this
                    int countFound=0;
                    int countsUnexplained=0;
                    string []lines=output.Split(new char[]{'\n'});
                    foreach (string line in lines)
                    {
                        //split each line into space-deliminated parts that reperesent the different override settings
                        string []parts=line.Split(new char[]{' '}, StringSplitOptions.RemoveEmptyEntries);
                        if(parts.Length>=5)
                        {
                            if (parts[0]=="ALL" && parts[1]=="-1" && parts[2]=="ALL" && parts[3]==TestSettingName.Substring(0, 16) && parts[4]=="testone")
                                ++countFound;
                            else if (parts[3]==TestSettingName.Substring(0, 16))
                                ++countsUnexplained;
                        }
                    }

                    ValueCheck.Test("Count of correct entries for "+TestSettingName, 1, countFound);
                    ValueCheck.Test("Count of unexplained entries for "+TestSettingName, 0, countsUnexplained);
                }
            };

            [TestCase, Description("Runs -list for a valid setting that has 6 mixed overiddes.")]
            public class MixedEntries: TestNode_PreRunCleanup
            {
                public override void Run()
                {
                    //get the name of a kdc
                    string kdcServerName=Global.XEnv.GetServerListByInterface("kdcsvc")[0];

                    //poke entries into the db
                    MultiSettingUtil.AddTestSettingOverride("ALL", -1, "ALL", "testsix1");
                    MultiSettingUtil.AddTestSettingOverride("ALL", -1, "ALL", "testsix1"); //dupe of first
                    MultiSettingUtil.AddTestSettingOverride("kdcsvc", -1, "ALL", "testsix3");
                    MultiSettingUtil.AddTestSettingOverride("ALL", 9999, "ALL", "testsix4");
                    MultiSettingUtil.AddTestSettingOverride("ALL", -1, kdcServerName, "testsix5");
                    MultiSettingUtil.AddTestSettingOverride("kdcsvc", 1, kdcServerName, "testsix6");

                    //run
                    string output=CfgUtil.RunXblConfig("-multisetoverrides -list -env:"+Global.XEnv.GetEnv());
                    MultiSettingUtil.VerifyOutputHasNoErrors(output);

                    //step through all lines and verify that there is exactly one entry for this
                    int []counts=new int[6];
                    int countsUnexplained=0;
                    string []lines=output.Split(new char[]{'\n'});
                    foreach (string line in lines)
                    {
                        //split each line into space-deliminated parts that reperesent the different override settings
                        string []parts=line.Split(new char[]{' '}, StringSplitOptions.RemoveEmptyEntries);
                        if(parts.Length>=5)
                        {
                            if (parts[0]=="ALL" && parts[1]=="-1" && parts[2]=="ALL" && parts[3]==TestSettingName.Substring(0, 16) && parts[4]=="testsix1")
                                ++counts[0];
                            else if (parts[0]=="kdcsvc" && parts[1]=="-1" && parts[2]=="ALL" && parts[3]==TestSettingName.Substring(0, 16) && parts[4]=="testsix3")
                                ++counts[2];
                            else if (parts[0]=="ALL" && parts[1]=="9999" && parts[2]=="ALL" && parts[3]==TestSettingName.Substring(0, 16) && parts[4]=="testsix4")
                                ++counts[3];
                            else if (parts[0]=="ALL" && parts[1]=="-1" && parts[2]==kdcServerName && parts[3]==TestSettingName.Substring(0, 16) && parts[4]=="testsix5")
                                ++counts[4];
                            else if (parts[0]=="kdcsvc" && parts[1]=="1" && parts[2]==kdcServerName && parts[3]==TestSettingName.Substring(0, 16) && parts[4]=="testsix6")
                                ++counts[5];
                            else if (parts[3]==TestSettingName.Substring(0, 16))
                                ++countsUnexplained;
                        }
                    }

                    ValueCheck.Test("Count of entries for "+TestSettingName+" value testsix1", 2, counts[0]);
                    ValueCheck.Test("Count of entries for "+TestSettingName+" value testsix2", 0, counts[1]);
                    ValueCheck.Test("Count of entries for "+TestSettingName+" value testsix3", 1, counts[2]);
                    ValueCheck.Test("Count of entries for "+TestSettingName+" value testsix4", 1, counts[3]);
                    ValueCheck.Test("Count of entries for "+TestSettingName+" value testsix5", 1, counts[4]);
                    ValueCheck.Test("Count of entries for "+TestSettingName+" value testsix6", 1, counts[5]);
                    ValueCheck.Test("Count of unexplained entries for "+TestSettingName, 0, countsUnexplained);
                }
            };

            [TestCase, Description("Runs -list for a valid setting that has 250 overiddes.")]
            public class ManyEntries: TestNode_PreRunCleanup
            {
                public override void Run()
                {
                    //poke an entry into the db
                    for (int i=0; i<250; ++i)
                    {
                        MultiSettingUtil.AddTestSettingOverride("ALL", -1, "ALL", "testlots");
                    }

                    //run
                    string output=CfgUtil.RunXblConfig("-multisetoverrides -list -env:"+Global.XEnv.GetEnv());
                    MultiSettingUtil.VerifyOutputHasNoErrors(output);

                    //step through all lines and verify that there is exactly one entry for this
                    int countFound=0;
                    int countsUnexplained=0;
                    string []lines=output.Split(new char[]{'\n'});
                    foreach (string line in lines)
                    {
                        //split each line into space-deliminated parts that reperesent the different override settings
                        string []parts=line.Split(new char[]{' '}, StringSplitOptions.RemoveEmptyEntries);
                        if(parts.Length>=5)
                        {
                            if (parts[0]=="ALL" && parts[1]=="-1" && parts[2]=="ALL" && parts[3]==TestSettingName.Substring(0, 16) && parts[4]=="testlots")
                                ++countFound;
                            else if (parts[3]==TestSettingName.Substring(0, 16))
                                ++countsUnexplained;
                        }
                    }

                    ValueCheck.Test("Count of correct entries for "+TestSettingName, 250, countFound);
                    ValueCheck.Test("Count of unexplained entries for "+TestSettingName, 0, countsUnexplained);
                }
            };

            [TestCase, Description("Runs -list for a valid setting that has one overidde, where the value has some odd characters.")]
            public class StrangeCharacters: TestNode_PreRunCleanup
            {
                public override void Run()
                {
                    //poke an entry into the db
                    string strangeChars="\"'\\/`?#$&*}=|{";
                    MultiSettingUtil.AddTestSettingOverride("ALL", -1, "ALL", strangeChars);

                    //run
                    string output=CfgUtil.RunXblConfig("-multisetoverrides -list -env:"+Global.XEnv.GetEnv());
                    MultiSettingUtil.VerifyOutputHasNoErrors(output);

                    //step through all lines and verify that there is exactly one entry for this
                    int countFound=0;
                    int countsUnexplained=0;
                    string []lines=output.Split(new char[]{'\n'});
                    foreach (string line in lines)
                    {
                        //split each line into space-deliminated parts that reperesent the different override settings
                        string []parts=line.Split(new char[]{' '}, StringSplitOptions.RemoveEmptyEntries);
                        if(parts.Length>=5)
                        {
                            if (parts[0]=="ALL" && parts[1]=="-1" && parts[2]=="ALL" && parts[3]==TestSettingName.Substring(0, 16) && parts[4]==strangeChars)
                                ++countFound;
                            else if (parts[3]==TestSettingName.Substring(0, 16))
                                ++countsUnexplained;
                        }
                    }

                    ValueCheck.Test("Count of correct entries for "+TestSettingName, 1, countFound);
                    ValueCheck.Test("Count of unexplained entries for "+TestSettingName, 0, countsUnexplained);
                }
            };

        }; //class List

        //Tests for the DELETEALL option
        [TestGroup, Description("Tests for the -deleteAll options")]
        public class DeleteAll: TestNode
        {
            [TestCase, Description("Runs -delete for the test setting.")]
            public class TestSetting: TestNode_PreRunCleanup
            {
                public override void Run()
                {
                    //poke some entries into the db
                    MultiSettingUtil.AddTestSettingOverride("kdcsvc", -1, "ALL", "delone");
                    MultiSettingUtil.AddTestSettingOverride("ALL", -1, "ALL", "deltwo");
                    MultiSettingUtil.AddTestSettingOverride("ALL", -1, "ALL", "deltwo");

                    //run
                    string output=CfgUtil.RunXblConfig("-multisetoverrides -deleteall -multisetting:"+TestSettingName);
                    MultiSettingUtil.VerifyOutputHasNoErrors(output);

                    //check db
                    MultiSettingUtil.VerifyQueryCount("select count(0) from t_multisetting_overrides where vc_multisetting='"+TestSettingName+"'", 0);
                }
            };
        }; //class DeleteAll

        //Tests for the DELETE option
        [TestGroup, Description("Tests for the -delete options")]
        public class Delete: TestNode
        {
            [TestCase, Description("Runs -delete for a valid setting that has no entries.")]
            public class NoEntry: TestNode_PreRunCleanup
            {
                public override void Run()
                {
                    string output=CfgUtil.RunXblConfig("-multisetoverrides -delete -env:"+Global.XEnv.GetEnv()+" -multisetting:"+TestSettingName);
                    MultiSettingUtil.VerifyOutputHasNoErrors(output);
                }
            };

            [TestCase, Description("Runs -delete for a valid setting that has one entry.")]
            public class OneEntrySimple: TestNode_PreRunCleanup
            {
                public override void Run()
                {
                    //poke an entry into the db
                    MultiSettingUtil.AddTestSettingOverride("ALL", -1, "ALL", "testone");

                    //run
                    string output=CfgUtil.RunXblConfig("-multisetoverrides -delete -env:"+Global.XEnv.GetEnv()+" -multisetting:"+TestSettingName);
                    MultiSettingUtil.VerifyOutputHasNoErrors(output);

                    //check db
                    MultiSettingUtil.VerifyQueryCount("select count(0) from t_multisetting_overrides where vc_multisetting='"+TestSettingName+"'", 0);
                }
            };

            [TestCase, Description("Runs -delete for a valid setting that has one entry.")]
            public class OneEntrySpecific: TestNode_PreRunCleanup
            {
                public override void Run()
                {
                    //poke an entry into the db
                    MultiSettingUtil.AddTestSettingOverride("ALL", -1, "ALL", "testone");

                    //run
                    string output=CfgUtil.RunXblConfig("-multisetoverrides -delete -env:"+Global.XEnv.GetEnv()+" -component:ALL -site:-1 -server:ALL -multisetting:"+TestSettingName);
                    MultiSettingUtil.VerifyOutputHasNoErrors(output);

                    //check db
                    MultiSettingUtil.VerifyQueryCount("select count(0) from t_multisetting_overrides where vc_multisetting='"+TestSettingName+"'", 0);
                }
            };

            [TestCase, Description("Runs -delete for a valid setting that has several entries.")]
            public class MultipleEntriesRemoveDefault: TestNode_PreRunCleanup
            {
                public override void Run()
                {
                    //get the name of a kdc
                    string kdcServerName=Global.XEnv.GetServerListByInterface("kdcsvc")[0];

                    //poke an entry into the db
                    MultiSettingUtil.AddTestSettingOverride("ALL", -1, "ALL", "testmul0");
                    MultiSettingUtil.AddTestSettingOverride("kdcsvc",  -1, "ALL", "testmul1");
                    MultiSettingUtil.AddTestSettingOverride("kdcsvc", 1, "ALL", "testmul2");
                    MultiSettingUtil.AddTestSettingOverride("ALL", -1, kdcServerName, "testmul3");

                    //run
                    string output=CfgUtil.RunXblConfig("-multisetoverrides -delete -env:"+Global.XEnv.GetEnv()+" -multisetting:"+TestSettingName);
                    MultiSettingUtil.VerifyOutputHasNoErrors(output);

                    //check db
                    MultiSettingUtil.VerifyQueryCount("select count(0) from t_multisetting_overrides where vc_multisetting='"+TestSettingName+"' and vc_value='testmul0'", 0);
                    MultiSettingUtil.VerifyQueryCount("select count(0) from t_multisetting_overrides where vc_multisetting='"+TestSettingName+"' and vc_value='testmul1'", 1);
                    MultiSettingUtil.VerifyQueryCount("select count(0) from t_multisetting_overrides where vc_multisetting='"+TestSettingName+"' and vc_value='testmul2'", 1);
                    MultiSettingUtil.VerifyQueryCount("select count(0) from t_multisetting_overrides where vc_multisetting='"+TestSettingName+"' and vc_value='testmul3'", 1);
                }
            };

            [TestCase, Description("Runs -delete for a valid setting that has several entries.")]
            public class MultipleEntriesRemoveComponent: TestNode_PreRunCleanup
            {
                public override void Run()
                {
                    //get the name of a kdc
                    string kdcServerName=Global.XEnv.GetServerListByInterface("kdcsvc")[0];

                    //poke an entry into the db
                    MultiSettingUtil.AddTestSettingOverride("ALL", -1, "ALL", "testmul0");
                    MultiSettingUtil.AddTestSettingOverride("kdcsvc",  -1, "ALL", "testmul1a");
                    MultiSettingUtil.AddTestSettingOverride("kdcsvc",  -1, "ALL", "testmul1a");
                    MultiSettingUtil.AddTestSettingOverride("kdcsvc",  -1, kdcServerName, "testmul1b");
                    MultiSettingUtil.AddTestSettingOverride("kdcsvc",  1, "ALL", "testmul1c");
                    MultiSettingUtil.AddTestSettingOverride("sgsvc", 1, "ALL", "testmul2");
                    MultiSettingUtil.AddTestSettingOverride("ALL", -1, kdcServerName, "testmul3");

                    //run
                    string output=CfgUtil.RunXblConfig("-multisetoverrides -delete -env:"+Global.XEnv.GetEnv()+" -component:kdcsvc -site:-1 -server:ALL -multisetting:"+TestSettingName);
                    MultiSettingUtil.VerifyOutputHasNoErrors(output);

                    //check db
                    MultiSettingUtil.VerifyQueryCount("select count(0) from t_multisetting_overrides where vc_multisetting='"+TestSettingName+"' and vc_value='testmul0'", 1);
                    MultiSettingUtil.VerifyQueryCount("select count(0) from t_multisetting_overrides where vc_multisetting='"+TestSettingName+"' and vc_value='testmul1a'", 0);
                    MultiSettingUtil.VerifyQueryCount("select count(0) from t_multisetting_overrides where vc_multisetting='"+TestSettingName+"' and vc_value='testmul1b'", 1);
                    MultiSettingUtil.VerifyQueryCount("select count(0) from t_multisetting_overrides where vc_multisetting='"+TestSettingName+"' and vc_value='testmul1c'", 1);
                    MultiSettingUtil.VerifyQueryCount("select count(0) from t_multisetting_overrides where vc_multisetting='"+TestSettingName+"' and vc_value='testmul2'", 1);
                    MultiSettingUtil.VerifyQueryCount("select count(0) from t_multisetting_overrides where vc_multisetting='"+TestSettingName+"' and vc_value='testmul3'", 1);
                }
            };

            [TestCase, Description("Runs -delete for a valid setting that has several entries.")]
            public class MultipleEntriesRemoveSite: TestNode_PreRunCleanup
            {
                public override void Run()
                {
                    //get the name of a kdc
                    string kdcServerName=Global.XEnv.GetServerListByInterface("kdcsvc")[0];

                    //poke an entry into the db
                    MultiSettingUtil.AddTestSettingOverride("ALL", -1, "ALL", "testmul0");
                    MultiSettingUtil.AddTestSettingOverride("ALL", 9999, "ALL", "testmul1");
                    MultiSettingUtil.AddTestSettingOverride("kdcsvc", 1, "ALL", "testmul2a");
                    MultiSettingUtil.AddTestSettingOverride("ALL", 1, "ALL", "testmul2b");
                    MultiSettingUtil.AddTestSettingOverride("ALL", 1, kdcServerName, "testmul2c");
                    MultiSettingUtil.AddTestSettingOverride("ALL", -1, kdcServerName, "testmul3");

                    //run
                    string output=CfgUtil.RunXblConfig("-multisetoverrides -delete -env:"+Global.XEnv.GetEnv()+" -component:ALL -site:1 -server:ALL -multisetting:"+TestSettingName);
                    MultiSettingUtil.VerifyOutputHasNoErrors(output);

                    //check db
                    MultiSettingUtil.VerifyQueryCount("select count(0) from t_multisetting_overrides where vc_multisetting='"+TestSettingName+"' and vc_value='testmul0'", 1);
                    MultiSettingUtil.VerifyQueryCount("select count(0) from t_multisetting_overrides where vc_multisetting='"+TestSettingName+"' and vc_value='testmul1'", 1);
                    MultiSettingUtil.VerifyQueryCount("select count(0) from t_multisetting_overrides where vc_multisetting='"+TestSettingName+"' and vc_value='testmul2a'", 1);
                    MultiSettingUtil.VerifyQueryCount("select count(0) from t_multisetting_overrides where vc_multisetting='"+TestSettingName+"' and vc_value='testmul2b'", 0);
                    MultiSettingUtil.VerifyQueryCount("select count(0) from t_multisetting_overrides where vc_multisetting='"+TestSettingName+"' and vc_value='testmul2c'", 1);
                    MultiSettingUtil.VerifyQueryCount("select count(0) from t_multisetting_overrides where vc_multisetting='"+TestSettingName+"' and vc_value='testmul3'", 1);
                }
            };

            [TestCase, Description("Runs -delete for a valid setting that has several entries.")]
            public class MultipleEntriesRemoveServer: TestNode_PreRunCleanup
            {
                public override void Run()
                {
                    //get the name of a kdc
                    string kdcServerName=Global.XEnv.GetServerListByInterface("kdcsvc")[0];

                    //poke an entry into the db
                    MultiSettingUtil.AddTestSettingOverride("ALL", -1, "ALL", "testmul0");
                    MultiSettingUtil.AddTestSettingOverride("ALL", -1, kdcServerName, "testmul1a");
                    MultiSettingUtil.AddTestSettingOverride("ALL", 1, kdcServerName, "testmul1b");
                    MultiSettingUtil.AddTestSettingOverride("kdcsvc", -1, kdcServerName, "testmul1c");

                    //run
                    string output=CfgUtil.RunXblConfig("-multisetoverrides -delete -env:"+Global.XEnv.GetEnv()+" -component:ALL -site:-1 -server:"+kdcServerName+" -multisetting:"+TestSettingName);
                    MultiSettingUtil.VerifyOutputHasNoErrors(output);

                    //check db
                    MultiSettingUtil.VerifyQueryCount("select count(0) from t_multisetting_overrides where vc_multisetting='"+TestSettingName+"' and vc_value='testmul0'", 1);
                    MultiSettingUtil.VerifyQueryCount("select count(0) from t_multisetting_overrides where vc_multisetting='"+TestSettingName+"' and vc_value='testmul1a'", 0);
                    MultiSettingUtil.VerifyQueryCount("select count(0) from t_multisetting_overrides where vc_multisetting='"+TestSettingName+"' and vc_value='testmul1b'", 1);
                    MultiSettingUtil.VerifyQueryCount("select count(0) from t_multisetting_overrides where vc_multisetting='"+TestSettingName+"' and vc_value='testmul1c'", 1);
                }
            };
        }; //class Delete

        //Tests for the FILE option
        [TestGroup, Description("Tests for the -file option")]
        public class File: TestNode
        {
            [TestCase, Description("Runs several adds and a delete from a file.")]
            public class Mixed: TestNode_PreRunCleanup
            {
                public override void Run()
                {
                    const string fileName="temp\\multisetoverrides_file_mixed.txt";
                    System.IO.Directory.CreateDirectory("temp");
                    System.IO.File.WriteAllText(fileName, 
                                                "-add -env:"+Global.XEnv.GetEnv()+" -component:kdcsvc -site:1 -server:ALL -multisetting:"+TestSettingName+" -value:testvalue1\n"+
                                                "-add -env:"+Global.XEnv.GetEnv()+" -component:kdcsvc -site:-1 -server:ALL -multisetting:"+TestSettingName+" -value:testvalue2\n"+
                                                "-add -env:"+Global.XEnv.GetEnv()+" -component:ALL -site:1 -server:ALL -multisetting:"+TestSettingName+" -value:testvalue3\n"+
                                                "-delete -env:"+Global.XEnv.GetEnv()+" -component:kdcsvc -site:-1 -server:ALL -multisetting:"+TestSettingName);

                    string output=CfgUtil.RunXblConfig("-multisetoverrides -file:"+fileName);
                    MultiSettingUtil.VerifyOutputHasNoErrors(output);

                    MultiSettingUtil.VerifyQueryCount("select count(0) from t_multisetting_overrides where vc_environment='"+Global.XEnv.GetEnv()+"' and vc_component='kdcsvc' and i_site_id=1 and vc_server='ALL' and vc_multisetting='"+TestSettingName+"' and vc_value='testvalue1'", 1);
                    MultiSettingUtil.VerifyQueryCount("select count(0) from t_multisetting_overrides where vc_environment='"+Global.XEnv.GetEnv()+"' and vc_component='ALL' and i_site_id=1 and vc_server='ALL' and vc_multisetting='"+TestSettingName+"' and vc_value='testvalue3'", 1);
                    MultiSettingUtil.VerifyQueryCount("select count(0) from t_multisetting_overrides where vc_environment='"+Global.XEnv.GetEnv()+"' and vc_multisetting='"+TestSettingName+"'", 2);
                }
            };
        }
    }; //class Script
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\XblCfg\Test\ActionHive.cs ===
using ServerTestFramework;
using ServerTestFramework.Utilities;
using ServerTestFramework.Database;
using ServerTestFramework.LiveService;

using System.Collections.Generic;
using System.Data.SqlClient;
using System.Data;
using System.Net;
using System;

namespace XblConfigTest
{
    //Util
    public class HiveUtil
    {
        public static void VerifyOutputHasNoErrors(string output)
        {
            string lowerOutput=output.ToLower();
            if (lowerOutput.Contains("usage error")) throw new UnexpectedTestResultException("Output contains an usage error.");
            if (lowerOutput.Contains("internal error")) throw new UnexpectedTestResultException("Output contains an internal error.");
            if (lowerOutput.Contains("was invalid")) throw new UnexpectedTestResultException("Output contains 'was invalid'.");

            //unfortunately there are now livehive settings called EtxException* which break the simple "string contains exception case", so add something more specialized here to avoid that
            if (lowerOutput.Contains(".exception") || (lowerOutput.Contains("exception") && !lowerOutput.Contains("etxexception")))
            {
                throw new UnexpectedTestResultException("Output contains an exception.");
            }

            //TODO: anything else we can check here?
        }

        //cleans out all entries for our test build
        public static void CleanTestSettings()
        {
            StaticNpdb.ExecuteNonQuery("delete from t_live_registry_settings where vc_client_config='"+Hive.TestClientConfig+"'");
        }

        //add setting to livehive
        public static void AddTestSetting(short? build, short? qfe, Guid beta, string setting, string value)
        {
            StaticNpdb.ExecuteNonQuery("insert into t_live_registry_settings (vc_environment, vc_client_config, si_build, si_qfe, guid_beta_group_id, vc_setting, vc_value) values ("+QueryGenerator.EvaluateObject(Global.XEnv.GetEnv())+", "+QueryGenerator.EvaluateObject(Hive.TestClientConfig)+", "+QueryGenerator.EvaluateObject(build)+", "+QueryGenerator.EvaluateObject(qfe)+", "+QueryGenerator.EvaluateObject(beta)+", "+QueryGenerator.EvaluateObject(setting)+", "+QueryGenerator.EvaluateObject(value)+")");
        }

        //does a query and verifies that the returned value is equal to count
        public static void VerifyQueryCount(string query, int count)
        {
            object ret=StaticNpdb.ExecuteScalar(query);
            int retCount=(int)ret;
            ValueCheck.Test("Value returned by: "+query+"\n", count, retCount);
        }

    }; //class HiveUtil

    //Tests
    [TestGroup]
    public class Hive: TestNode
    {
        public const string TestClientConfig="test_xblcfg";

        //base that always does a Clean in the PreRun
        public class TestNode_PreRunCleanup: TestNode
        {
            public override void PreRun()
            {
                HiveUtil.CleanTestSettings();
            }
        };

        //
        [TestCase, Description("We should see help text in the output.")]
        public void NoArgs()
        {
            string output=CfgUtil.RunXblConfig("-hive");

            //verify the high level options are present in the output text
            string lowerOutput=output.ToLower();
            if (!lowerOutput.Contains("-add")) throw new UnexpectedTestResultException("-add help text not present.");
            if (!lowerOutput.Contains("-delete")) throw new UnexpectedTestResultException("-delete help text not present.");
            if (!lowerOutput.Contains("-deleteall")) throw new UnexpectedTestResultException("-deleteall help text not present.");
            if (!lowerOutput.Contains("-list")) throw new UnexpectedTestResultException("-list help text not present.");
            if (!lowerOutput.Contains("-file")) throw new UnexpectedTestResultException("-file help text not present.");
        }

        //tests for the ADD option
        [TestGroup, Description("Tests for the -add options")]
        public class Add: TestNode
        {
            [TestCase, Description("Runs -add with the minimal set of parameters possible.")]
            public class MinimalParameters: TestNode_PreRunCleanup
            {
                public override void Run()
                {
                    string output=CfgUtil.RunXblConfig("-hive -add -env:"+Global.XEnv.GetEnv()+" -client:"+TestClientConfig+" -build:null -qfe:null -beta:{00000000-0000-0000-0000-000000000000} -setting:testing -value:123");
                    HiveUtil.VerifyOutputHasNoErrors(output);
                    HiveUtil.VerifyQueryCount("select count(0) from t_live_registry_settings where vc_environment='"+Global.XEnv.GetEnv()+"' and vc_client_config='"+TestClientConfig+"' and si_build is null and si_qfe is null and guid_beta_group_id='{00000000-0000-0000-0000-000000000000}' and vc_setting='testing' and vc_value='123'", 1);
                }
            };

            //This isn't currently relevent since all parameters are required
            /*[TestCase, Description("Runs -add specifying every possible parameter")]
            public class UseAllParameters: TestNode_PreRunCleanup
            */

            [TestCase, Description("Runs -add twice for the same with different values, and the second time should replace the first one")]
            public class ReplaceSetting: TestNode_PreRunCleanup
            {
                public override void Run()
                {
                    string output=CfgUtil.RunXblConfig("-hive -add -env:"+Global.XEnv.GetEnv()+" -client:"+TestClientConfig+" -build:null -qfe:null -beta:{00000000-0000-0000-0000-000000000000} -setting:testing -value:123");
                    HiveUtil.VerifyOutputHasNoErrors(output);

                    output=CfgUtil.RunXblConfig("-hive -add -env:"+Global.XEnv.GetEnv()+" -client:"+TestClientConfig+" -build:null -qfe:null -beta:{00000000-0000-0000-0000-000000000000} -setting:testing -value:456");
                    HiveUtil.VerifyOutputHasNoErrors(output);

                    HiveUtil.VerifyQueryCount("select count(0) from t_live_registry_settings where vc_environment='"+Global.XEnv.GetEnv()+"' and vc_client_config='"+TestClientConfig+"' and si_build is null and si_qfe is null and guid_beta_group_id='{00000000-0000-0000-0000-000000000000}' and vc_setting='testing' and vc_value='456'", 1);
                }
            };

            [TestCase, Description("Runs -add to add a value with some unusual characters in it")]
            public class StrangeValues: TestNode_PreRunCleanup
            {
                public override void Run()
                {
                    // This is kind of weird. Command-line programs don't take '"' directly. You need to escape them, for the command-line, as '\"'.
                    // This means that what we actually pass to xblcfg -hive isn't what we expect to get back:
                    string strangeValue         = "`1'~!@#$%^&*(){}+=/?_-\\\"<>,\\:;|.";
                    string strangeValueExpected = "`1'~!@#$%^&*(){}+=/?_-\"<>,\\:;|.";

                    string output=CfgUtil.RunXblConfig("-hive -add -env:"+Global.XEnv.GetEnv()+" -client:"+TestClientConfig+" -build:null -qfe:null -beta:{00000000-0000-0000-0000-000000000000} -setting:testing -value:"+strangeValue);
                    HiveUtil.VerifyOutputHasNoErrors(output);

                    ValueCheck.Test("value of setting", strangeValueExpected, StaticNpdb.ExecuteScalar("select vc_value from t_live_registry_settings where vc_client_config='" + TestClientConfig + "'"));
                }
            };

            [TestCase, Description("Runs -add to add a value inside a quoted string")]
            public class QuotedString: TestNode_PreRunCleanup
            {
                public override void Run()
                {
                    string value="This is a test.";
                    string output=CfgUtil.RunXblConfig("-hive -add -env:"+Global.XEnv.GetEnv()+" -client:"+TestClientConfig+" -build:null -qfe:null -beta:{00000000-0000-0000-0000-000000000000} -setting:testing -value:\""+value+"\"");
                    HiveUtil.VerifyOutputHasNoErrors(output);

                    ValueCheck.Test("value of setting", value, StaticNpdb.ExecuteScalar("select vc_value from t_live_registry_settings where vc_client_config='"+TestClientConfig+"'"));
                }
            };

            [TestCase, Description("Runs -add twice, and the second time would violate a constraint")]
            public class ViolateConstraint: TestNode_PreRunCleanup
            {
                public override void Run()
                {
                    string output=CfgUtil.RunXblConfig("-hive -add -env:"+Global.XEnv.GetEnv()+" -client:"+TestClientConfig+" -build:null -qfe:1 -beta:{00000000-0000-0000-0000-000000000000} -setting:testing -value:123");

                    if (!output.Contains("Internal error"))
                    {
                        throw new UnexpectedTestResultException("Expected an internal error");
                    }
                }
            };
        };

        //Tests for the LIST option
        [TestGroup, Description("Tests for the -list options")]
        public class List: TestNode
        {
            [TestCase, Description("Runs -list for a valid setting that has no overiddes.")]
            public class NoEntry: TestNode_PreRunCleanup
            {
                public override void Run()
                {
                    string output=CfgUtil.RunXblConfig("-hive -list -env:"+Global.XEnv.GetEnv());
                    HiveUtil.VerifyOutputHasNoErrors(output);

                    if (output.Contains(TestClientConfig))
                    {
                        throw new UnexpectedTestResultException("Did not expected -list to contain anything for our client type: "+TestClientConfig);
                    }
                }
            };

            [TestCase, Description("Runs -list to check a single valid setting.")]
            public class OneEntry: TestNode_PreRunCleanup
            {
                public override void Run()
                {
                    //poke an entry into the db
                    HiveUtil.AddTestSetting(null, null, new Guid("{00000000-0000-0000-0000-000000000000}"), "settingname", "settingvalue");

                    //run
                    string output=CfgUtil.RunXblConfig("-hive -list -env:"+Global.XEnv.GetEnv());
                    HiveUtil.VerifyOutputHasNoErrors(output);

                    //step through all lines and verify that there is exactly one entry for this
                    int countFound=0;
                    int countsUnexplained=0;
                    int countsMalformed=0;
                    string []lines=output.Replace("\r", "").Split(new char[]{'\n'});
                    foreach (string line in lines)
                    {
                        if (line.Contains(TestClientConfig))
                        {
                            //split each line into space-deliminated parts
                            string []parts=line.Split(new char[]{' '}, StringSplitOptions.RemoveEmptyEntries);
                            if (parts.Length==6)
                            {
                                if (parts[0]==TestClientConfig && parts[1]=="NULL" && parts[2]=="NULL" && parts[3]=="00000000-0000-0000-0000-000000000000" && parts[4]=="settingname" && parts[5]=="settingvalue")
                                    ++countFound;
                                else
                                    ++countsUnexplained;
                            }
                            else
                                ++countsMalformed;
                        }
                    }

                    ValueCheck.Test("Count of unexplained entries for "+TestClientConfig, 0, countsUnexplained);
                    ValueCheck.Test("Count of malformed entries for "+TestClientConfig, 0, countsMalformed);
                    ValueCheck.Test("Count of correct entries for "+TestClientConfig, 1, countFound);
                }
            };

            [TestCase, Description("Runs -list to check a set of valid settings.")]
            public class MultipleEntries: TestNode_PreRunCleanup
            {
                public override void Run()
                {
                    //add entries
                    HiveUtil.AddTestSetting(null, null, new Guid("{00000000-0000-0000-0000-000000000000}"), "setting0", "value0");
                    HiveUtil.AddTestSetting(1,    1,    new Guid("{00000000-0000-0000-0000-000000000000}"), "setting1", "value1");
                    HiveUtil.AddTestSetting(1,    1,    new Guid("{10000000-0000-0000-0000-000000000001}"), "setting2", "value2");

                    //run
                    string output=CfgUtil.RunXblConfig("-hive -list -env:"+Global.XEnv.GetEnv());
                    HiveUtil.VerifyOutputHasNoErrors(output);

                    //step through all lines and verify that there is exactly one entry for this
                    int []counts=new int[3];
                    int countsUnexplained=0;
                    int countsMalformed=0;
                    string []lines=output.Split(new char[]{'\n'});
                    foreach (string line in lines)
                    {
                        if (line.Contains(TestClientConfig))
                        {
                            //split each line into space-deliminated parts
                            string []parts=line.Split(new char[]{' '}, StringSplitOptions.RemoveEmptyEntries);
                            if(parts.Length==6)
                            {
                                if (parts[0]==TestClientConfig && parts[1]=="NULL" && parts[2]=="NULL" && parts[3]=="00000000-0000-0000-0000-000000000000" && parts[4]=="setting0")
                                    ++counts[0];
                                else if (parts[0]==TestClientConfig && parts[1]=="1" && parts[2]=="1" && parts[3]=="00000000-0000-0000-0000-000000000000" && parts[4]=="setting1")
                                    ++counts[1];
                                else if (parts[0]==TestClientConfig && parts[1]=="1" && parts[2]=="1" && parts[3]=="10000000-0000-0000-0000-000000000001" && parts[4]=="setting2")
                                    ++counts[2];
                                else
                                    ++countsUnexplained;
                            }
                            else
                                ++countsMalformed;
                        }
                    }

                    ValueCheck.Test("Count of unexplained entries for "+TestClientConfig, 0, countsUnexplained);
                    ValueCheck.Test("Count of malformed entries for "+TestClientConfig, 0, countsMalformed);
                    ValueCheck.Test("Count of entries for "+TestClientConfig+" value setting0", 1, counts[0]);
                    ValueCheck.Test("Count of entries for "+TestClientConfig+" value setting1", 1, counts[1]);
                    ValueCheck.Test("Count of entries for "+TestClientConfig+" value setting2", 1, counts[2]);
                }
            };

            [TestCase, Description("Runs -list to check a single setting whose value has a bunch of strange characters.")]
            public class StrangeValues: TestNode_PreRunCleanup
            {
                public override void Run()
                {
                    //poke an entry into the db
                    string strangeValue="`1'~ !@#$%^&*(){}+=/?_-\"<>,\\:;\t|.";
                    HiveUtil.AddTestSetting(null, null, new Guid("{00000000-0000-0000-0000-000000000000}"), "settingname", strangeValue);

                    //run
                    string output=CfgUtil.RunXblConfig("-hive -list -env:"+Global.XEnv.GetEnv());
                    HiveUtil.VerifyOutputHasNoErrors(output);

                    //step through all lines and verify that there is exactly one entry for this
                    int countFound=0;
                    int countsUnexplained=0;
                    int countsMalformed=0;
                    string []lines=output.Replace("\r", "").Split(new char[]{'\n'});
                    foreach (string line in lines)
                    {
                        if (line.Contains(TestClientConfig))
                        {
                            //split each line into space-deliminated parts
                            string []parts=line.Split(new char[]{' '}, StringSplitOptions.RemoveEmptyEntries);
                            if (parts.Length==7)
                            {
                                if (parts[0]==TestClientConfig && parts[1]=="NULL" && parts[2]=="NULL" && parts[3]=="00000000-0000-0000-0000-000000000000" && parts[4]=="settingname" && parts[5]=="`1'~" && parts[6]=="!@#$%^&*(){}+=/?_-\"<>,\\:;\t|.")
                                    ++countFound;
                                else
                                    ++countsUnexplained;
                            }
                            else
                                ++countsMalformed;
                        }
                    }

                    ValueCheck.Test("Count of unexplained entries for "+TestClientConfig, 0, countsUnexplained);
                    ValueCheck.Test("Count of malformed entries for "+TestClientConfig, 0, countsMalformed);
                    ValueCheck.Test("Count of correct entries for "+TestClientConfig, 1, countFound);
                }
            };

            [TestCase, Description("Runs -list for a valid setting that has 250 entries.")]
            public class ManyEntries: TestNode_PreRunCleanup
            {
                public override void Run()
                {
                    //poke an entry into the db
                    for (int i=0; i<250; ++i)
                    {
                        HiveUtil.AddTestSetting(null, null, new Guid("{00000000-0000-0000-0000-000000000000}"), "settingname"+i, "settingvalue");
                    }

                    //run
                    string output=CfgUtil.RunXblConfig("-hive -list -env:"+Global.XEnv.GetEnv());
                    HiveUtil.VerifyOutputHasNoErrors(output);

                    //step through all lines and verify that there is exactly one entry for this
                    int countFound=0;
                    int countsUnexplained=0;
                    int countsMalformed=0;
                    string []lines=output.Replace("\r", "").Split(new char[]{'\n'});
                    foreach (string line in lines)
                    {
                        if (line.Contains(TestClientConfig))
                        {
                            //split each line into space-deliminated parts
                            string []parts=line.Split(new char[]{' '}, StringSplitOptions.RemoveEmptyEntries);
                            if (parts.Length==6)
                            {
                                if (parts[0]==TestClientConfig && parts[1]=="NULL" && parts[2]=="NULL" && parts[3]=="00000000-0000-0000-0000-000000000000" && parts[4].StartsWith("settingname") && parts[5]=="settingvalue")
                                    ++countFound;
                                else
                                    ++countsUnexplained;
                            }
                            else
                                ++countsMalformed;
                        }
                    }

                    ValueCheck.Test("Count of unexplained entries for "+TestClientConfig, 0, countsUnexplained);
                    ValueCheck.Test("Count of malformed entries for "+TestClientConfig, 0, countsMalformed);
                    ValueCheck.Test("Count of correct entries for "+TestClientConfig, 250, countFound);
                }
            };
        }; //class List

        //Tests for the DELETEALL option
        [TestGroup, Ignore, Description("Tests for the -deleteall option")]
        public class DeleteAll: TestNode
        {
            [TestCase, Description("Runs -deleteall when several settings exist")]
            public class SeveralExist: TestNode_PreRunCleanup
            {
                public override void Run()
                {
                    //add some settings
                    HiveUtil.AddTestSetting(null, null, new Guid("{00000000-0000-0000-0000-000000000000}"), "settingname0", "settingvalue");
                    HiveUtil.AddTestSetting(1,    1,    new Guid("{10000000-0000-0000-0000-000000000001}"), "settingname0", "settingvalue");
                    HiveUtil.AddTestSetting(1,    1,    new Guid("{10000000-0000-0000-0000-000000000001}"), "settingname1", "settingvalue");

                    //run
                    string output=CfgUtil.RunXblConfig("-hive -deleteall -env:"+Global.XEnv.GetEnv()+" -client:"+TestClientConfig+" -setting:settingname0");
                    HiveUtil.VerifyOutputHasNoErrors(output);

                    //TODO: make this right once we decide on deleteall behaviour
                    //HiveUtil.VerifyQueryCount("select count(0) from t_live_registry_settings where vc_environment='"+Global.XEnv.GetEnv()+"' and vc_client_config='"+TestClientConfig+"' and si_build is null and si_qfe is null and guid_beta_group_id='{00000000-0000-0000-0000-000000000000}' and vc_setting='testing' and vc_value='123'", 1);
                }
            };
        }; // class DeleteAll

        //Tests for the DELETE option
        [TestGroup, Description("Tests for the -delete option")]
        public class Delete: TestNode
        {
            [TestCase, Description("Runs -delete when several settings exist")]
            public class OneOfSeveral: TestNode_PreRunCleanup
            {
                public override void Run()
                {
                    //add some settings
                    HiveUtil.AddTestSetting(null, null, new Guid("{00000000-0000-0000-0000-000000000000}"), "settingname0", "settingvalue");
                    HiveUtil.AddTestSetting(1,    1,    new Guid("{10000000-0000-0000-0000-000000000001}"), "settingname0", "settingvalue");
                    HiveUtil.AddTestSetting(1,    1,    new Guid("{10000000-0000-0000-0000-000000000001}"), "settingname1", "settingvalue");

                    //run
                    string output=CfgUtil.RunXblConfig("-hive -delete -env:"+Global.XEnv.GetEnv()+" -client:"+TestClientConfig+" -build:1 -qfe:1 -beta:{10000000-0000-0000-0000-000000000001} -setting:settingname0");
                    HiveUtil.VerifyOutputHasNoErrors(output);

                    HiveUtil.VerifyQueryCount("select count(0) from t_live_registry_settings where vc_environment='"+Global.XEnv.GetEnv()+"' and vc_client_config='"+TestClientConfig+"' and si_build is null and si_qfe is null and guid_beta_group_id='{00000000-0000-0000-0000-000000000000}' and vc_setting='settingname0'", 1);
                    HiveUtil.VerifyQueryCount("select count(0) from t_live_registry_settings where vc_environment='"+Global.XEnv.GetEnv()+"' and vc_client_config='"+TestClientConfig+"' and si_build=1 and si_qfe=1 and guid_beta_group_id='{10000000-0000-0000-0000-000000000001}' and vc_setting='settingname1'", 1);
                }
            };

            [TestCase(50176), Description("Runs -delete when no settings exist")]
            public class DoesNotExist: TestNode_PreRunCleanup
            {
                public override void Run()
                {
                    string output=CfgUtil.RunXblConfig("-hive -delete -env:"+Global.XEnv.GetEnv()+" -client:"+TestClientConfig+" -build:1 -qfe:1 -beta:{10000000-0000-0000-0000-000000000001} -setting:settingname0");

                    try
                    {
                        HiveUtil.VerifyOutputHasNoErrors(output);
                    }
                    catch (System.Exception e)
                    {
                        Global.RO.Debug("Got expected expection: "+e);
                        return;
                    }

                    throw new UnexpectedTestResultException("Expected an error.");
                }
            };
        }; //class Delete

        //Tests for the FILE option
        [TestGroup, Description("Tests for the -file option")]
        public class File: TestNode
        {
            [TestCase, Description("Runs several adds and a delete from a file.")]
            public class Mixed: TestNode_PreRunCleanup
            {
                public override void Run()
                {
                    const string fileName="temp\\hive_file_mixed.txt";
                    System.IO.Directory.CreateDirectory("temp");
                    System.IO.File.WriteAllText(fileName, 
                                                "-add -env:"+Global.XEnv.GetEnv()+" -client:"+TestClientConfig+" -build:null -qfe:null -beta:{00000000-0000-0000-0000-000000000000} -setting:testing -value:123\n"+
                                                "-add -env:"+Global.XEnv.GetEnv()+" -client:"+TestClientConfig+" -build:6 -qfe:6 -beta:{00000000-0000-0000-0000-000000000000} -setting:testing -value:456\n"+
                                                "-add -env:"+Global.XEnv.GetEnv()+" -client:"+TestClientConfig+" -build:7 -qfe:7 -beta:{10000000-0000-0000-0000-000000000001} -setting:testing -value:456\n"+
                                                "-delete -env:"+Global.XEnv.GetEnv()+" -client:"+TestClientConfig+" -build:6 -qfe:6 -beta:{00000000-0000-0000-0000-000000000000} -setting:testing");

                    string output=CfgUtil.RunXblConfig("-hive -file:"+fileName);
                    HiveUtil.VerifyOutputHasNoErrors(output);

                    HiveUtil.VerifyQueryCount("select count(0) from t_live_registry_settings where vc_environment='"+Global.XEnv.GetEnv()+"' and vc_client_config='"+TestClientConfig+"' and si_build is null and si_qfe is null and guid_beta_group_id='{00000000-0000-0000-0000-000000000000}' and vc_setting='testing' and vc_value='123'", 1);
                    HiveUtil.VerifyQueryCount("select count(0) from t_live_registry_settings where vc_environment='"+Global.XEnv.GetEnv()+"' and vc_client_config='"+TestClientConfig+"' and si_build=7 and si_qfe=7 and guid_beta_group_id='{10000000-0000-0000-0000-000000000001}' and vc_setting='testing' and vc_value='456'", 1);
                    HiveUtil.VerifyQueryCount("select count(0) from t_live_registry_settings where vc_environment='"+Global.XEnv.GetEnv()+"' and vc_client_config='"+TestClientConfig+"'", 2);
                }
            };
        }
    }; //class Hive
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\XblCfg\Test\obj\i386\_generated.cs ===
[assembly:System.Runtime.InteropServices.ComVisible(false)]
[assembly:System.Reflection.AssemblyVersion("12.4.56.0")]
[assembly:System.Reflection.AssemblyProduct("Microsoft(R) Xbox(TM)")]
[assembly:System.Reflection.AssemblyCopyright("Copyright (c) Microsoft Corporation. All rights reserved.")]
[assembly:System.Reflection.AssemblyCompany("Microsoft Corporation")]
[assembly:System.Reflection.AssemblyFileVersion("12.4.56.0")]
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\XblCfg\Test\ActionScript.cs ===
using ServerTestFramework;
using ServerTestFramework.Utilities;
using ServerTestFramework.Database;
using ServerTestFramework.LiveService;
using ServerTestFramework.LiveService.Auth;

using System.Collections.Generic;
using System.Data.SqlClient;
using System.Data;
using System.Net;
using System;

namespace XblConfigTest
{
    //Utilities for the script option tests
    public class ScriptUtil
    {
        public const string NPDB_SCRIPT_PREFIX="xblConfigTest_";
        private const string SIMPLE_CHALLENGE_TEMPLATE="ChallengeDeclare(0x{0}, \"XblConfigTest 0x{0}\",false,false)\n__Binary = Buffer.new('1982')";

        //Gets the path (such as d$\webroot\sgsvc) of where challenges should be placed on SGs in the current environment
        public static string GetSgChallengePath(string machineNameOrIp)
        {
            if (machineNameOrIp!=null)
            {
                if (!machineNameOrIp.StartsWith("\\"))
                {
                    machineNameOrIp="\\\\"+machineNameOrIp;
                }

                if (!machineNameOrIp.EndsWith("\\"))
                {
                    machineNameOrIp+="\\";
                }
            }

            //we currently have no way to know whether we're installed on an xblob or real environment, so base this off of the environment name for now
            if (Global.XEnv.GetEnv().ToLower().Contains("blob"))
            {
                return machineNameOrIp+"C$\\ESP\\Webroot\\sgsvc\\sgcfg\\";
            }
            else
            {
                return machineNameOrIp+"d$\\webroot\\sgcfg\\";
            }
        }

        //Gets the path (such as d$\webroot\sgsvc) of where challenges should be placed on xtou in the current environment
        public static string GetXtouChallengePath(string machineNameOrIp)
        {
            if (machineNameOrIp!=null)
            {
                if (!machineNameOrIp.StartsWith("\\"))
                {
                    machineNameOrIp="\\\\"+machineNameOrIp;
                }

                if (!machineNameOrIp.EndsWith("\\"))
                {
                    machineNameOrIp+="\\";
                }
            }

            //we currently have no way to know whether we're installed on an xblob or real environment, so base this off of the environment name for now
            if (Global.XEnv.GetEnv().ToLower().Contains("blob"))
            {
                return machineNameOrIp+"C$\\ESP\\Webroot\\xtou\\xedl\\chalresp\\";
            }
            else
            {
                return machineNameOrIp+"d$\\webroot\\xtou\\xedl\\chalresp\\";
            }
        }

        //
        public static string GetNpdbScriptNameFromNumber(int number)
        {
            string hexNum=string.Format("{0:X}", number);
            return NPDB_SCRIPT_PREFIX+hexNum;
        }

        //Creates a new simple challenge file for a given challenge number, optionally adding body to the challenge file.  Returns the name of the temp file created
        public static string CreateLuaChallengeFile(int number, string body)
        {
            string hexNum=string.Format("{0:X}", number);
            string fileText=string.Format(SIMPLE_CHALLENGE_TEMPLATE, hexNum);
            fileText+="\n"+body;
            return CfgUtil.WriteTempFile("xblconfigtest_script_"+hexNum+".lua", fileText);
        }

        //Creates a new simple challenge file for a given challenge number, optionally adding body to the challenge file.  Returns the name of the temp file created
        public static string CreateBlobChallengeFile(int number, byte []bytes)
        {
            string hexNum=string.Format("{0:X}", number);
            return CfgUtil.WriteTempFile("xblconfigtest_script_"+hexNum+".blob", bytes);
        }

        public static string CreateXexFile(int number)
        {
            string hexNum=string.Format("{0:X}", number);
            return CfgUtil.WriteTempFile("xblconfigtest_xex_"+hexNum+".xex", "This is not an executable, it is a test file.\n"+hexNum);
        }

        public static void ReloadSGs()
        {
            SgServerInfo.ReloadConfiguration();
        }

        //verifies that a specific generated challenge number is present in t_sg_scripts, optionally verifies properties of what was loaded
        public static void VerifyNpdbChallenge(int number, Nullable<bool> isEnabled, string scriptText, byte []scriptBlob, Nullable<bool> isKicking, Nullable<bool> isTimeoutEnabled)
        {
            string scriptName=ScriptUtil.GetNpdbScriptNameFromNumber(number);
            using (Npdb npdb=new Npdb())
            {
                //run query and verify it exists
                npdb.ConnectToServer();
                SqlDataReader reader;
                npdb.ReadData("select ti_enabled, txt_script, im_blob, ti_chal_kick_enabled, ti_chal_timeout_enabled from t_sg_scripts where vc_script_name='"+scriptName+"'", out reader);
                if (!reader.Read())
                {
                    throw new UnexpectedTestResultException("There is no script in npdb t_sg_scripts named "+scriptName);
                }

                //verify fields
                if (isEnabled!=null)
                {
                    bool dbData=0!=(byte)reader[0];
                    ValueCheck.Test("ti_enabled in t_sg_scripts for "+scriptName, (bool)isEnabled, dbData);
                }

                if (scriptText!=null)
                {
                    string dbData=(string)reader[1];
                    ValueCheck.Test("txt_script in t_sg_scripts for "+scriptName, scriptText, dbData);
                }

                if (scriptBlob!=null)
                {
                    byte []dbData=(byte[])reader[2];
                    ValueCheck.TestAll("im_blob in t_sg_scripts for "+scriptName, scriptBlob, dbData);
                }

                if (isKicking!=null)
                {
                    bool dbData=0!=(byte)reader[3];
                    ValueCheck.Test("ti_chal_kick_enabled in t_sg_scripts for "+scriptName, (bool)isKicking, dbData);
                }

                if (isTimeoutEnabled!=null)
                {
                    bool dbData=0!=(byte)reader[4];
                    ValueCheck.Test("ti_chal_timeout_enabled in t_sg_scripts for "+scriptName, (bool)isTimeoutEnabled, dbData);
                }
            }
        }

        //verifies that a specific generated challenge number is not present in t_sg_scripts
        public static void VerifyNpdbChallengeNotLoaded(int number)
        {
            string scriptName=GetNpdbScriptNameFromNumber(number);
            using (Npdb npdb=new Npdb())
            {
                npdb.ConnectToServer();
                int count=(int)npdb.ExecuteScalar("select count(*) from t_sg_scripts where vc_script_name='"+scriptName+"'");
                if (count!=0)
                {
                    throw new UnexpectedTestResultException("Script "+scriptName+" is unexpectedly present in npdb t_sg_scripts.");
                }
            }
        }

        //verifies that a specifically generated challenge number is loaded on all online SGs, according to xmgmt
        public static void VerifySGLuaChallengeIsLoaded(int number)
        {
            IPEndPoint []sgIps=ManagementListener.GetXmgmtEndPoints("sgsvc");
            foreach (IPEndPoint sgIp in sgIps)
            {
                //run the command on the SG
                string result;
                bool success=ManagementConsole.Execute(sgIp, "e :sg list_challenges", out result);
                Global.RO.Debug("list_challenges:\n"+result);
                if (!success)
                {
                    throw new UnexpectedTestResultException("Failed to run xmgmt command on SG "+sgIp);
                }

                //verify the challenge is present in the output
                string expectString="xblconfigtest 0x"+string.Format("{0:X}", number);
                string lowerResult=result.ToLower();
                if (!lowerResult.Contains(expectString.ToLower()))
                {
                    throw new UnexpectedTestResultException("SG "+sgIp+" list_challenges xmgmt command did not contain \""+expectString+"\"");
                }
            }
        }

        //verifies that a specifically generated challenge number is not loaded on any online SGs, according to xmgmt
        public static void VerifySGLuaChallengeNotLoaded(int number)
        {
            IPEndPoint []sgIps=ManagementListener.GetXmgmtEndPoints("sgsvc");
            foreach (IPEndPoint sgIp in sgIps)
            {
                //run the command on the SG
                string result;
                bool success=ManagementConsole.Execute(sgIp, "e :sg list_challenges", out result);
                Global.RO.Debug("list_challenges:\n"+result);
                if (!success)
                {
                    throw new UnexpectedTestResultException("Failed to run xmgmt command on SG "+sgIp);
                }

                //verify the challenge is present in the output
                string expectString="xblconfigtest 0x"+string.Format("{0:X}", number);
                string lowerResult=result.ToLower();
                if (lowerResult.Contains(expectString.ToLower()))
                {
                    throw new UnexpectedTestResultException("SG "+sgIp+" list_challenges xmgmt command unexpectedly contained \""+expectString+"\"");
                }
            }
        }

        //verifies that the output contains no error messages
        public static void VerifyOutputHasNoErrors(string output)
        {
            string lowerOutput=output.ToLower();
            if (lowerOutput.Contains("exception"))
            {
                throw new UnexpectedTestResultException("Output contains an exception.");
            }

            if (lowerOutput.Contains("usage error"))
            {
                throw new UnexpectedTestResultException("Output contains a usage error.");
            }

            //TODO: anything else we can check here?
        }
    }; //class ScriptUtil

    //Tests
    [TestGroup]
    public class Script: TestNode
    {
        private void CleanupEverything()
        {
            //remove any existing xblConfig test files from npdb
            Global.RO.Debug("Removing xmlconfigtest challenges from npdb...");
            using (Npdb npdb=new Npdb())
            {
                npdb.ConnectToServer();
                npdb.IssueCommand("delete from t_sg_scripts where vc_script_name like '"+ScriptUtil.NPDB_SCRIPT_PREFIX+"%'");
            }

            //remove any existing xblConfig test files from SGs
            Global.RO.Debug("Removing xblconfigtest challenges from all SGs...");
            IPEndPoint []sgIps=ManagementListener.GetXmgmtEndPoints("sgsvc"); //xmgmt should be the internal IP that we can access
            foreach (IPEndPoint sgIp in sgIps)
            {
                string sgCfgPath=ScriptUtil.GetSgChallengePath(sgIp.Address.ToString());
                string []fileList=System.IO.Directory.GetFiles(sgCfgPath);
                foreach (string file in fileList)
                {
                    string lowerFile=file.ToLower();
                    if (lowerFile.StartsWith("xblconfigtest_script_") && lowerFile.EndsWith(".lua"))
                    {
                        System.IO.File.Delete(sgCfgPath+file);
                    }
                }
            }

            //remove any existing XblConfig test files from xtou
            Global.RO.Debug("Removing xblconfigtest challenges from all Xtou servers...");
            IPEndPoint []xtouIps=ManagementListener.GetXmgmtEndPoints("xtou"); //xmgmt should be the internal IP that we can access
            foreach (IPEndPoint xtouIp in xtouIps)
            {
                string xtouChalPath=ScriptUtil.GetXtouChallengePath(xtouIp.Address.ToString());
                xtouChalPath+="xblconfigtest";
                try
                {
                    if (System.IO.Directory.Exists(xtouChalPath))
                    {
                        System.IO.Directory.Delete(xtouChalPath, true);
                    }
                }
                catch (System.Exception exc)
                {
                    Global.RO.Warn(exc.ToString());
                }
            }

            //reload SGs
            ScriptUtil.ReloadSGs();
        }

        /*
        Note: to manually register commonconfig, run this:
        C:\WINNT\Microsoft.NET\Framework\v2.0.50727\regasm /codebase XblConfig.dll
        */

        // --

        public override void PreRun()
        {
            CleanupEverything();

            //register commonconfig.  This is needed if xmgmtc (used by xblcfg -script) has to look up server interfaces.
            Global.RO.Debug("Registering XblConfig.dll...");
            System.Runtime.InteropServices.RegistrationServices managedReg=new System.Runtime.InteropServices.RegistrationServices();
            System.Reflection.Assembly commonconfigAssembly=System.Reflection.Assembly.LoadFile(System.Environment.CurrentDirectory+"\\XblConfig.dll");
            if (!managedReg.RegisterAssembly(commonconfigAssembly, System.Runtime.InteropServices.AssemblyRegistrationFlags.SetCodeBase))
            {
                throw new System.Exception("XblConfig.dll regasm register failed.");
            }

            //verify that xmgmtc is in the path, as xblcfg -script requires this to work right
            Global.RO.Debug("Verifying that xmgmtc is in the path and can be run...");
            System.Diagnostics.Process.Start("xmgmtc.exe", "-r l");
        }

        public override void PostRun()
        {
            CleanupEverything();

            //unregister commonconfig
            Global.RO.Debug("Unregistering XblConfig.dll...");
            System.Runtime.InteropServices.RegistrationServices managedReg=new System.Runtime.InteropServices.RegistrationServices();
            System.Reflection.Assembly commonconfigAssembly=System.Reflection.Assembly.LoadFile(System.Environment.CurrentDirectory+"\\XblConfig.dll");
            managedReg.UnregisterAssembly(commonconfigAssembly);
        }

        // --

        //
        [TestCase, Description("We should see help text in the output.")]
        public void NoArgs()
        {
            string output=CfgUtil.RunXblConfig("-script");
            ScriptUtil.VerifyOutputHasNoErrors(output);

            //verify the high level options are present in the output text
            string lowerOutput=output.ToLower();
            if (!lowerOutput.Contains("-add")) throw new UnexpectedTestResultException("-add help text not present.");
            if (!lowerOutput.Contains("-delete")) throw new UnexpectedTestResultException("-delete help text not present.");
            if (!lowerOutput.Contains("-deletescriptfiles")) throw new UnexpectedTestResultException("-deletescriptfiles help text not present.");
            if (!lowerOutput.Contains("-get")) throw new UnexpectedTestResultException("-get help text not present.");
        }

        //Tests for the ADD option
        [TestGroup, Description("Tests for the -add options")]
        public class Add: TestNode
        {
            [TestGroup, Description("Tests for -add placing challenge scripts into npdb")]
            public class NpdbScript: TestNode
            {
                [TestCase, Description("Runs the tool to deploy a challenge to NPDB without additional parameters")]
                public class Simple: TestNode
                {
                    public override void Run()
                    {
                        int chalNum=0x7f80;
                        string chalName=ScriptUtil.GetNpdbScriptNameFromNumber(chalNum);

                        string luaFile=ScriptUtil.CreateLuaChallengeFile(chalNum, null);
                        string output=CfgUtil.RunXblConfig("-script -noblock -add -name:"+chalName+" -scriptfile:"+luaFile);
                        ScriptUtil.VerifyOutputHasNoErrors(output);

                        System.Threading.Thread.Sleep(5000); //XblCfg doesn't wait on the sg reload to happen, so we will
                        ScriptUtil.VerifyNpdbChallenge(chalNum, true, System.IO.File.ReadAllText(luaFile), null, false, false);
                        ScriptUtil.VerifySGLuaChallengeIsLoaded(chalNum);
                    }
                };

                [TestCase, Description("Runs the tool to deploy a challenge to NPDB also specifying a binary blob")]
                public class WithBinaryFile: TestNode
                {
                    public override void Run()
                    {
                        int chalNum=0x7f81;
                        string chalName=ScriptUtil.GetNpdbScriptNameFromNumber(chalNum);

                        string luaFile=ScriptUtil.CreateLuaChallengeFile(chalNum, null);
                        byte []blob=new byte[256];
                        for (int i=0; i<256; ++i)
                        {
                            blob[i]=(byte)i;
                        }
                        string blobFile=ScriptUtil.CreateBlobChallengeFile(chalNum, blob);

                        string output=CfgUtil.RunXblConfig("-script -noblock -add -name:"+chalName+" -scriptfile:"+luaFile+" -binaryfile:"+blobFile);
                        ScriptUtil.VerifyOutputHasNoErrors(output);

                        System.Threading.Thread.Sleep(5000); //XblCfg doesn't wait on the sg reload to happen, so we will
                        ScriptUtil.VerifyNpdbChallenge(chalNum, true, System.IO.File.ReadAllText(luaFile), blob, false, false);
                        ScriptUtil.VerifySGLuaChallengeIsLoaded(chalNum);
                    }
                };

                [TestCase, Description("Runs the tool to deploy a challenge to NPDB also specifying to kick")]
                public class WithKick: TestNode
                {
                    public override void Run()
                    {
                        int chalNum=0x7f82;
                        string chalName=ScriptUtil.GetNpdbScriptNameFromNumber(chalNum);

                        string luaFile=ScriptUtil.CreateLuaChallengeFile(chalNum, null);

                        string output=CfgUtil.RunXblConfig("-script -noblock -add -name:"+chalName+" -scriptfile:"+luaFile+" -kickenabled:1");
                        ScriptUtil.VerifyOutputHasNoErrors(output);

                        System.Threading.Thread.Sleep(5000); //XblCfg doesn't wait on the sg reload to happen, so we will
                        ScriptUtil.VerifyNpdbChallenge(chalNum, true, System.IO.File.ReadAllText(luaFile), null, true, false);
                        ScriptUtil.VerifySGLuaChallengeIsLoaded(chalNum);
                    }
                };

                [TestCase, Description("Runs the tool to deploy a challenge to NPDB also specifying to timeout")]
                public class WithTimeout: TestNode
                {
                    public override void Run()
                    {
                        int chalNum=0x7f83;
                        string chalName=ScriptUtil.GetNpdbScriptNameFromNumber(chalNum);

                        string luaFile=ScriptUtil.CreateLuaChallengeFile(chalNum, null);

                        string output=CfgUtil.RunXblConfig("-script -noblock -add -name:"+chalName+" -scriptfile:"+luaFile+" -timeoutenabled:1");
                        ScriptUtil.VerifyOutputHasNoErrors(output);

                        System.Threading.Thread.Sleep(5000); //XblCfg doesn't wait on the sg reload to happen, so we will
                        ScriptUtil.VerifyNpdbChallenge(chalNum, true, System.IO.File.ReadAllText(luaFile), null, false, true);
                        ScriptUtil.VerifySGLuaChallengeIsLoaded(chalNum);
                    }
                };
            }

            [TestCase, Description("Runs the tool to deploy a challenge directly to all SGs' disks")]
            public class SimpleSgScript: TestNode
            {
                public override void Run()
                {
                    int chalNum=0x7f01;
                    string chalName=ScriptUtil.GetNpdbScriptNameFromNumber(chalNum);

                    //build a string for all SGs
                    IPEndPoint []sgIps=ManagementListener.GetXmgmtEndPoints("sgsvc"); //xmgmt should be the internal IP that we can access
                    string sgIpsString="";
                    foreach (IPEndPoint sgIp in sgIps)
                    {
                        string ip=sgIp.Address.ToString();
                        if (sgIpsString.Length>0) sgIpsString+=";";
                        sgIpsString+=ip;
                    }

                    //run
                    string luaFile=ScriptUtil.CreateLuaChallengeFile(chalNum, null);
                    string output=CfgUtil.RunXblConfig("-script -noblock -add -name:"+chalName+" -scriptfile:"+luaFile+" -servers:"+sgIpsString);
                    ScriptUtil.VerifyOutputHasNoErrors(output);

                    System.Threading.Thread.Sleep(5000); //XblCfg doesn't wait on the sg reload to happen, so we will
                    ScriptUtil.VerifyNpdbChallengeNotLoaded(chalNum);
                    ScriptUtil.VerifySGLuaChallengeIsLoaded(chalNum);
                }
            };

            [TestCase]
            public void SimpleXex()
            {
                int chalNum=0x7f02;
                string chalName=ScriptUtil.GetNpdbScriptNameFromNumber(chalNum);

                string xexFile=ScriptUtil.CreateXexFile(chalNum);
                string xexFileNoPath=xexFile.Substring(xexFile.LastIndexOf("\\")+1);
                string luaFile=ScriptUtil.CreateLuaChallengeFile(chalNum, null);
                string output=CfgUtil.RunXblConfig("-script -noblock -add -xex:"+xexFile+" -name:"+chalName+" -scriptfile:"+luaFile+" -xexpath:xblconfigtest");
                ScriptUtil.VerifyOutputHasNoErrors(output);

                //check all xtou servers for the file now
                IPEndPoint []xtouIps=ManagementListener.GetXmgmtEndPoints("xtou"); //xmgmt should be the internal IP that we can access
                foreach (IPEndPoint xtouIp in xtouIps)
                {
                    string xtouChalPath=ScriptUtil.GetXtouChallengePath(xtouIp.Address.ToString());
                    xtouChalPath+="xblconfigtest\\";
                    string xtouChalFullFilename=xtouChalPath+xexFileNoPath;
                    if (!System.IO.File.Exists(xtouChalFullFilename))
                    {
                        throw new UnexpectedTestResultException(xtouChalFullFilename+" does not exist, but it should have been created by XblCfg.");
                    }
                }
            }
        }; //class Add

        //Tests for the DELETE option
        [TestGroup, Description("Tests for the -delete options")]
        public class Delete: TestNode
        {
            [TestCase]
            public class NpdbScriptName: TestNode
            {
                int chalNum=0x7f03;
                string chalName;

                public override void PreRun()
                {
                    chalName=ScriptUtil.GetNpdbScriptNameFromNumber(chalNum);
                    string luaFile=ScriptUtil.CreateLuaChallengeFile(chalNum, null);

                    //put script into npdb directly and reload the SGs
                    NpdbUtility npdb;
                    npdb=new NpdbUtility();
                    npdb.ConnectToServer();
                    npdb.PropSgScript(chalName, System.IO.File.ReadAllText(luaFile), null);
                    ScriptUtil.ReloadSGs();

                    //verify it shows up in all SGs list_challenges
                    ScriptUtil.VerifySGLuaChallengeIsLoaded(chalNum);
                }

                public override void Run()
                {
                    //run delete command for the challenge
                    string output=CfgUtil.RunXblConfig("-script -noblock -delete -name:"+chalName);
                    ScriptUtil.VerifyOutputHasNoErrors(output);

                    //verify it no longer shows up in any SGs list_challenges
                    System.Threading.Thread.Sleep(5000); //XblCfg doesn't wait on the sg reload to happen, so we will
                    ScriptUtil.VerifySGLuaChallengeNotLoaded(chalNum);
                }
            }
        }
    }; //class Script
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\XblCfg\Test\obj\i386\_asmid.inc ===
ASSEMBLY_IDENTITY_KEY_FORM=msil_xblconfigtest_none_12.4.56.0_none_642e5da0c0ee7319
ASSEMBLY_IDENTITY_XP_KEY_FORM=msil_xblconfigtest_no-public-key_12.4.56.0_x-ww_077cc8d9
ASSEMBLY_IDENTITY_CULTURE=
ASSEMBLY_IDENTITY_NAME=xblconfigtest
ASSEMBLY_IDENTITY_PROCESSOR_ARCHITECTURE=msil
ASSEMBLY_IDENTITY_PUBLIC_KEY=
ASSEMBLY_IDENTITY_PUBLIC_KEY_TOKEN=
ASSEMBLY_IDENTITY_TYPE=
ASSEMBLY_IDENTITY_TYPE_NAME=
ASSEMBLY_IDENTITY_VERSION=12.4.56.0
XP_KEY_FORM=msil_xblconfigtest_no-public-key_12.4.56.0_x-ww_077cc8d9
XP_MANIFEST_DIRECTORY=manifests
XP_MANIFEST_NAME=msil_xblconfigtest_no-public-key_12.4.56.0_x-ww_077cc8d9.manifest
XP_MANIFEST_PATH=manifests\msil_xblconfigtest_no-public-key_12.4.56.0_x-ww_077cc8d9.manifest
XP_CATALOG_DIRECTORY=manifests
XP_CATALOG_NAME=msil_xblconfigtest_no-public-key_12.4.56.0_x-ww_077cc8d9.cat
XP_CATALOG_PATH=manifests\msil_xblconfigtest_no-public-key_12.4.56.0_x-ww_077cc8d9.cat
XP_PAYLOAD_PATH=msil_xblconfigtest_no-public-key_12.4.56.0_x-ww_077cc8d9
_DELAY_SIGN=0
!if [set _ASMIDTOATTRIBS_TLBIMP=]
!endif
CODESIGN_TESTKEY=
_TLBIMP_FLAGS=$(_TLBIMP_FLAGS)  /asmversion:12.4.56.0
_ASSEMBLY_IDENTITY=xblconfigtest,processorArchitecture=msil,version=12.4.56.0,publicKeyToken=neutral
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\XblCfg\Test\Suite.cs ===
using ServerTestFramework;

[assembly:RootNode(typeof(XblConfigTest.XblConfigTest))]

namespace XblConfigTest
{
    [Owner("LukeL"), TestFrequency("Daily"), TestCasePriority(1)]
    public class XblConfigTest: TestNode
    {
    };
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\XblCfg\Test\General.cs ===
using ServerTestFramework;
using ServerTestFramework.Utilities;

namespace XblConfigTest
{
    //Tests
    [TestGroup]
    public class General: TestNode
    {
        //
        [TestCase, Description("We should see help text in the output.")]
        public void NoArgs()
        {
            string output=CfgUtil.RunXblConfig("");

            //verify the high level options are present in the output text
            string lowerOutput=output.ToLower();
            if (!lowerOutput.Contains("-hive"))              throw new UnexpectedTestResultException("-hive option is not present in the help text");
            if (!lowerOutput.Contains("-multisetoverrides")) throw new UnexpectedTestResultException("-multisetoverrides option is not present in the help text");
            if (!lowerOutput.Contains("-script"))            throw new UnexpectedTestResultException("-script option is not present in the help text");
        }
    }; //class General
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\XblCfg\Test\objd\i386\_generated.cs ===
[assembly:System.Runtime.InteropServices.ComVisible(false)]
[assembly:System.Reflection.AssemblyVersion("12.4.56.0")]
[assembly:System.Reflection.AssemblyProduct("Microsoft(R) Xbox(TM)")]
[assembly:System.Reflection.AssemblyCopyright("Copyright (c) Microsoft Corporation. All rights reserved.")]
[assembly:System.Reflection.AssemblyCompany("Microsoft Corporation")]
[assembly:System.Reflection.AssemblyFileVersion("12.4.56.0")]
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\XblCfg\Test\Util.cs ===
using ServerTestFramework;
using ServerTestFramework.Utilities;
using ServerTestFramework.Database;
using System.IO;
using System.Text;

using xonline.common.config;

namespace XblConfigTest
{
    public static class CfgUtil
    {
        //runs xblcfg tool with specific arguments, and returns the commandline output
        public static string RunXblConfig(string args)
        {
            return RunXblConfig(args, 300);
        }
        public static string RunXblConfig(string args, uint timeoutInS)
        {
            //run it, capturing the output
            ProcessWrapper pr=new ProcessWrapper("xblcfg","xblcfg.exe");

            if (!(Global.CurrentEnvironment.NpdbIp==null || Global.CurrentEnvironment.NpdbIp.Length==0))
            {
                pr.SetEnvironmentVariable("XBL_CONFIG_SERVER", Global.CurrentEnvironment.NpdbIp);
            }

            if (!(Global.CurrentEnvironment.NpdbName==null || Global.CurrentEnvironment.NpdbName.Length==0))
            {
                pr.SetEnvironmentVariable("XBL_CONFIG_DATABASE", Global.CurrentEnvironment.NpdbName);
            }

            pr.ExecutionTimeout=(int)timeoutInS;
            pr.EchoOutput=true;
            pr.Run(args);

            //
            return pr.Output;
        }

        //writes a string out to a temporary stf file in text mode
        //returns a relative path to the filename that was created
        public static string WriteTempFile(string fname, string data)
        {
            Directory.CreateDirectory("tmp\\xblconfigtest\\");

            string fullName="tmp\\xblconfigtest\\" + fname;

            FileStream f=new FileStream(fullName, FileMode.Create, FileAccess.Write);
            StreamWriter fwriter=new StreamWriter(f);
            fwriter.Write(data);
            fwriter.Close();
            f.Close();

            return fullName;
        }

        //writes a string out to a temporary stf file in binary mode
        //returns a relative path to the filename that was created
        public static string WriteTempFile(string fname, byte []data)
        {
            Directory.CreateDirectory("tmp\\xblconfigtest\\");

            string fullName="tmp\\xblconfigtest\\" + fname;

            FileStream f=new FileStream(fullName, FileMode.Create, FileAccess.Write);
            BinaryWriter fwriter=new BinaryWriter(f);
            fwriter.Write(data);
            fwriter.Close();
            f.Close();

            return fullName;
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\XblCfg\Test\objd\i386\_asmid.inc ===
ASSEMBLY_IDENTITY_KEY_FORM=msil_xblconfigtest_none_12.4.56.0_none_642e5da0c0ee7319
ASSEMBLY_IDENTITY_XP_KEY_FORM=msil_xblconfigtest_no-public-key_12.4.56.0_x-ww_077cc8d9
ASSEMBLY_IDENTITY_CULTURE=
ASSEMBLY_IDENTITY_NAME=xblconfigtest
ASSEMBLY_IDENTITY_PROCESSOR_ARCHITECTURE=msil
ASSEMBLY_IDENTITY_PUBLIC_KEY=
ASSEMBLY_IDENTITY_PUBLIC_KEY_TOKEN=
ASSEMBLY_IDENTITY_TYPE=
ASSEMBLY_IDENTITY_TYPE_NAME=
ASSEMBLY_IDENTITY_VERSION=12.4.56.0
XP_KEY_FORM=msil_xblconfigtest_no-public-key_12.4.56.0_x-ww_077cc8d9
XP_MANIFEST_DIRECTORY=manifests
XP_MANIFEST_NAME=msil_xblconfigtest_no-public-key_12.4.56.0_x-ww_077cc8d9.manifest
XP_MANIFEST_PATH=manifests\msil_xblconfigtest_no-public-key_12.4.56.0_x-ww_077cc8d9.manifest
XP_CATALOG_DIRECTORY=manifests
XP_CATALOG_NAME=msil_xblconfigtest_no-public-key_12.4.56.0_x-ww_077cc8d9.cat
XP_CATALOG_PATH=manifests\msil_xblconfigtest_no-public-key_12.4.56.0_x-ww_077cc8d9.cat
XP_PAYLOAD_PATH=msil_xblconfigtest_no-public-key_12.4.56.0_x-ww_077cc8d9
_DELAY_SIGN=0
!if [set _ASMIDTOATTRIBS_TLBIMP=]
!endif
CODESIGN_TESTKEY=
_TLBIMP_FLAGS=$(_TLBIMP_FLAGS)  /asmversion:12.4.56.0
_ASSEMBLY_IDENTITY=xblconfigtest,processorArchitecture=msil,version=12.4.56.0,publicKeyToken=neutral
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\XblCfg\Test\ActionGroups.cs ===
using System;
using System.Collections.Generic;
using System.IO;
using System.Security.Principal;
using System.Text;

using ServerTestFramework;
using ServerTestFramework.Utilities;
using ServerTestFramework.Database;

using Microsoft.Webstore.WstClient;

using xonline.common.sql.webstore;
using xonline.common.config;

namespace XblConfigTest
{
    [TestGroup]
    public class Groups : TestNode
    {
        private class StringValidation
        {
            public string Contains;
            public string ExceptionText;
            public StringValidation(string contains, string exceptionText)
            {
                Contains = contains;
                ExceptionText = exceptionText;
            }
        };

        private static void ValidateOutputContains(string output, IEnumerable<StringValidation> svs)
        {
            foreach (StringValidation sv in svs)
            {
                if (!output.ToLower().Contains(sv.Contains.ToLower()))
                {
                    string exceptionText = String.Format("{0}: expected [{1}] within [{2}]",
                            sv.ExceptionText,
                            sv.Contains,
                            output);

                    throw new UnexpectedTestResultException(exceptionText);
                }
            }
        }

        private static IEnumerable<StringValidation> MakeSvs(params string[] strings)
        {
            // Must come in sets of two.
            if (strings.Length % 2 != 0)
            {
                throw new ArgumentException("MakeSvs takes strings in pairs: <text to check for>, <exception text>", "strings");
            }

            for (int idx = 0; idx < strings.Length; idx += 2)
            {
                yield return new StringValidation(strings[idx], strings[idx+1]);
            }
        }

        private static void WriteFileString(string s, string fileName)
        {
            using (FileStream fs = new FileStream(fileName, FileMode.Create))
            {
                using (StreamWriter writer = new StreamWriter(fs))
                {
                    writer.Write(s);
                }
            }
        }

        [TestGroup, Description("Basic tests of the -groups.hidden functionality--like does it exist at all.")]
        public class Basic : TestNode
        {
            [TestCase, Description("If the -groups.hidden command exists, then the help will not list available commands, but available options.")]
            public class GroupsCommandExists : TestNode
            {
                public override void Run()
                {
                    string output = CfgUtil.RunXblConfig("-groups.hidden").ToLower();

                    // Verify that the "commands" section of help is not present, since that indicates that the command exists.
                    if (output.Contains("commands (additional help is available for each)"))
                    {
                        throw new UnexpectedTestResultException("Commands help present, meaning that groups command is not implemented.");
                    }
                }
            }

            [TestCase, Description("We should get some amount of help for the -groups.hidden command")]
            public class GroupsCommandHasHelp : TestNode
            {
                public override void Run()
                {
                    string output = CfgUtil.RunXblConfig("-groups.hidden").ToLower();

                    // Verify that the output has the various help sections we should have.
                    IEnumerable<StringValidation> svs = MakeSvs(
                        "xblcfg.exe -groups.hidden [options...]", "Basic usage not present for -groups.hidden command",
                        "notes:", "Notes section (which briefly explains the command) not present for -groups.hidden command",
                        "options:", "Options section not present for -groups.hidden command",
                        "-list", "-list help text not present for -groups.hidden command",
                        "-machinelookup", "-machineLookup help text not present for the -groups.hidden command",
                        "-create", "-create help text not present for the -groups.hidden command",
                        "-add", "-add help text not present for the -groups.hidden command",
                        "-remove", "remove help text not present for the -groups.hidden command");

                    ValidateOutputContains(output, svs);
                }
            }
        } //class Basic

        [TestGroup, Description("Tests the -list option of the -groups.hidden command.")]
        public class List : TestNode
        {
            private static string FormatListCommand(Guid groupId)
            {
                return String.Format("-groups.hidden -list -groupId:{0:B}", groupId);
            }

            private static string[] GetMachinesFromOutput(string output)
            {
                string []parts=output.Replace("\r","").Split(new char[]{'\n'});
                System.Collections.Generic.List<string> machines=new System.Collections.Generic.List<string>();
                for (int i=4; i<parts.Length; ++i) //skip the header
                {
                    string cid=parts[i].Trim();
                    if (cid.Length>0)
                    {
                        if (!cid.Contains(", "))
                        {
                            if (cid.Length != 15)
                            {
                                if (!(cid.Length == 12 && cid[2] != '.'))
                                {
                                    throw new UnexpectedTestResultException("Invalid console ID found: " + cid);
                                }
                            }
                        }
                        machines.Add(cid);
                    }
                }

                return machines.ToArray();
            }

            private static void VerifyExactList(string []machinesExpect, string []machinesGot)
            {
                System.Collections.Generic.LinkedList<string> extraMachines=new System.Collections.Generic.LinkedList<string>();
                foreach (string mg in machinesGot)
                {
                    extraMachines.AddLast(mg.ToLower());
                }

                foreach (string mExpect in machinesExpect)
                {
                    if (System.Array.IndexOf(machinesGot, mExpect.ToLower())==-1)
                    {
                        throw new UnexpectedTestResultException(string.Format("List was expected to contain machine {0} but it did not.", mExpect));
                    }

                    extraMachines.Remove(mExpect.ToLower());
                }

                if (extraMachines.Count>0)
                {
                    string extrasList="";
                    foreach (string e in extraMachines)
                    {
                        extrasList+=string.Format("{0}\n", e);
                    }
                    throw new UnexpectedTestResultException("List contains extra machines:\n"+extrasList);
                }
            }

            //
            [TestCase(BugDatabase="Xbox360 Console Software", BugID=124365), Description("Calls -list with no group.  It should list all groups along with their friendly name.")]
            public class ListWithNoGroup: TestNode
            {
                struct ListEntry
                {
                    public System.Guid Guid;
                    public string      Name;

                    public ListEntry(System.Guid g, string n)
                    {
                        Guid=g;
                        Name=n;
                    }

                    public bool Equals(ListEntry o)
                    {
                        return o.Guid==Guid && o.Name==Name;
                    }

                    public override string ToString()
                    {
                        return "{"+Guid+"} "+Name;
                    }
                }

                private static System.Collections.Generic.List<ListEntry> GetListFromDB()
                {
                    System.Collections.Generic.List<ListEntry> list=new System.Collections.Generic.List<ListEntry>();

                    using (WSClient ws=new WSClient(ConfigUtil.UodbWebstoreApp, CmdType.WRITETHENREAD_COMMANDTYPE))
                    {
                        for (int p=0; p<ws.PhysicalPartitions; ++p)
                        {
                            ws.PhysicalPartition=p;
                            ws.CommandSql="select uid_group_id, vc_group_name from t_beta_group";

                            using (WstDataReader reader=ws.Execute())
                            {
                                while (reader.Read())
                                {
                                    System.Guid g=(System.Guid)reader[0];
                                    string n=(string)reader[1];
                                    ListEntry le=new ListEntry(g, n);
                                    list.Add(le);
                                }
                            }
                        }
                    }

                    return list;
                }

                private static System.Collections.Generic.List<ListEntry> ParseOutputList(string output)
                {
                    System.Collections.Generic.List<ListEntry> list=new System.Collections.Generic.List<ListEntry>();

                    // Pre-calculate the length of a guid
                    int guidLen = Guid.Empty.ToString("B").Length;

                    string []lines=output.Replace("\r","").Split(new char[]{'\n'});
                    foreach (string line in lines)
                    {
                        // This tool has some empty lines at the end of the output. Ignore them.
                        if (line.Trim().Length == 0)
                        {
                            continue;
                        }

                        // Format is {guid} "name". Since the name could pretty much be anything (including, in theory, quotations), 
                        // to verify the format, we can basically do this:
                        // First 38 characters are a guid
                        // Next character is a space
                        // Next character and the last character are '"'
                        // Characters in between are the name.

                        // First, the length must be guidLen + 1 (space) +2 (quotes)
                        ValueCheck.TestGreaterThan(String.Format("Length of line: {0}", line.Length), guidLen + 3, line.Length);

                        Guid guid = new Guid(line.Substring(0, guidLen));
                        string name = line.Substring(guidLen + 2);
                        name = name.Substring(0, name.Length - 1);
                        list.Add(new ListEntry(guid, name));
                    }

                    return list;
                }

                private static void VerifyListsMatch(System.Collections.Generic.List<ListEntry> listExpect, System.Collections.Generic.List<ListEntry> listGot)
                {
                    System.Collections.Generic.LinkedList<ListEntry> extras=new System.Collections.Generic.LinkedList<ListEntry>();
                    foreach (ListEntry le in listGot)
                    {
                        extras.AddLast(le);
                    }

                    foreach (ListEntry mExpect in listExpect)
                    {
                        if (!listGot.Contains(mExpect))
                        {
                            throw new UnexpectedTestResultException(string.Format("List was expected to contain group: {0}", mExpect));
                        }

                        extras.Remove(mExpect);
                    }

                    if (extras.Count>0)
                    {
                        string extrasList="";
                        foreach (ListEntry le in extras)
                        {
                            extrasList+=le.ToString()+"\n";
                        }
                        throw new UnexpectedTestResultException("List contains extra entries:\n"+extrasList);
                    }
                }

                public override void PreRun()
                {
                    //make sure at least a couple groups exist
                    BetaGroupEditor.CreateNew();
                    BetaGroupEditor.CreateNew();
                }

                public override void Run()
                {
                    string output = CfgUtil.RunXblConfig("-groups.hidden -list");

                    if (output.Contains("Usage error:"))
                    {
                        throw new UnexpectedTestResultException("Output contains a usage error.");
                    }

                    System.Collections.Generic.List<ListEntry> listFromOutput=ParseOutputList(output);
                    System.Collections.Generic.List<ListEntry> listFromDB=GetListFromDB();

                    VerifyListsMatch(listFromDB, listFromOutput);
                }
            }

            [TestCase, Description("Attempts to list a non-existant group.")]
            public class ListNonExistantGroup : TestNode
            {
                private readonly Guid _groupId = new Guid("{10000000-0000-0000-0000-1000deadbeef}");

                public override void Run()
                {
                    string output = CfgUtil.RunXblConfig(FormatListCommand(_groupId)).ToLower();

                    // Verify that the output contains the right error string.
                    IEnumerable<StringValidation> svs = MakeSvs(
                    String.Format("group {0:B} does not exist", _groupId), "-list did not produce an error when passed a group that doesn't exist.");

                    ValidateOutputContains(output, svs);
                }
            }

            [TestCase, Description("Creates a group and makes sure that group is listed."), TestCasePriority(2)]
            public class ListEmptyGroup : TestNode
            {
                private readonly Guid _groupId = new Guid("{10000000-0000-0000-0000-1000deadbeef}");
                private const string _friendlyName = "ListEmptyGroup_FriendlyName";
                private const string _createdBy = "ListEmptyGroup_CreatedBy";
                private readonly DateTime _created = new DateTime(1776, 7, 4);
                public override void PreRun()
                {
                    BetaGroupEditor bge = BetaGroupEditor.CreateOrUseExistingId(_groupId);
                    bge.Name = _friendlyName;
                    bge.Creator = _createdBy;
                    bge.Created = _created;
                }

                public override void Run()
                {
                    string output = CfgUtil.RunXblConfig(FormatListCommand(_groupId)).ToLower();

                    // Verify that the group is listed (with no actual machines)
                    IEnumerable<StringValidation> svs = MakeSvs(
                        String.Format("group {0:B}:", _groupId), "-list output does not contain the basic group header information",
                        String.Format("\tfriendly name:\t{0}", _friendlyName.ToLower()), "-list output does not contain the group's friendly name, or the friendly name is not correct",
                        String.Format("\tcreated by:\t{0}", _createdBy.ToLower()), "-list output does not contain the group's creator, or the creator is not correct",
                        String.Format("\tcreated time:\t{0}", _created.ToString().ToLower()), "-list output does not contain the group's creation date, or the creation date is not correct");

                    ValidateOutputContains(output, svs);

                    // Since this is an empty group, we need to make sure that there's nothing else 
                    if (!output.Trim().EndsWith(String.Format("\tcreated time:\t{0}", _created.ToString().ToLower())))
                    {
                        throw new UnexpectedTestResultException("Empty group has output after the created time.");
                    }
                }

                public override void PostRun()
                {
                    BetaGroupEditor.NukeGroup(_groupId);
                }
            }

            [TestCase, Description("Creates a group with one machine and makes sure that machine is listed.")]
            [CompoundCase("Normal", false)]
            [CompoundCase("-PUID", true)]
            public class ListGroupOfOne : TestNode
            {
                private readonly Guid _groupId = new Guid("{10000000-0000-0000-0000-1000deadbeef}");
                private const string _consoleId = "XE.377700000026";
                private MachineEditor _machine;

                public override void PreRun()
                {
                    _machine = MachineEditor.CreateOrUseExistingName(_consoleId);
                    BetaGroupEditor bge = BetaGroupEditor.CreateOrUseExistingId(_groupId);
                    bge.RemoveAllMachines();
                    bge.AddMachine(_machine.Id);
                }

                public override void Run()
                {
                    string output;
                    IEnumerable<StringValidation> svs;

                    if ((bool)MyValues[0] == false)
                    {
                        output = CfgUtil.RunXblConfig(FormatListCommand(_groupId)).ToLower();

                        // Verify that the group is listed (with no actual machines)
                        svs = MakeSvs(
                            String.Format("group {0:B}:", _groupId), "-list output does not contain the basic group header information",
                            String.Format("{0}", _machine.ConsoleId), "-list output does not contain the machine we inserted");
                    }
                    else
                    {
                        output = CfgUtil.RunXblConfig(FormatListCommand(_groupId) + " -puid").ToLower();

                        // Verify that the group is listed (with no actual machines)
                        svs = MakeSvs(
                            String.Format("group {0:B}:", _groupId), "-list output does not contain the basic group header information",
                            String.Format("{0}, 0x{1:X16}, {2}", _machine.ConsoleId, _machine.Id, (long)_machine.Id), String.Format("-list -PUID output does not contain: {0}, 0x{1:X16}, {2}", _machine.ConsoleId, _machine.Id, (long)_machine.Id));
                    }
                    ValidateOutputContains(output, svs);
                }

                public override void PostRun()
                {
                    _machine.CompletelyRemoveMachine();
                    BetaGroupEditor.NukeGroup(_groupId);
                }
            }

            [TestCase, Description("Creates a group with multiple machines and makes sure those machines are listed.")]
            [CompoundCase("Normal", false)]
            [CompoundCase("-PUID", true)]
            public class ListGroupOfMany : TestNode
            {
                private readonly Guid _groupId = new Guid("{10000000-0000-0000-0000-1000deadbeef}");
                private readonly string[] _consoleIds = new string[] { "XE.377700000026", "XE.377700000004", "XE.377700000015" };
                private MachineEditor[] _machines;

                public override void PreRun()
                {
                    _machines = new MachineEditor[_consoleIds.Length];
                    for (int idx = 0; idx < _machines.Length; ++idx)
                    {
                        _machines[idx] = MachineEditor.CreateOrUseExistingName(_consoleIds[idx]);
                    }
                    BetaGroupEditor bge = BetaGroupEditor.CreateOrUseExistingId(_groupId);
                    bge.RemoveAllMachines();
                    foreach (MachineEditor machine in _machines)
                    {
                        bge.AddMachine(machine.Id);
                    }
                }

                private string[] GetMachineIdValidationStrings()
                {
                    List<string> strings = new List<string>(_machines.Length * 2);

                    foreach (MachineEditor machine in _machines)
                    {
                        if ((bool)MyValues[0] == false)
                        {
                            strings.Add(String.Format("{0}", machine.ConsoleId));
                            strings.Add(String.Format("-list output does not contain: {0}", machine.ConsoleId));
                        }
                        else
                        {
                            strings.Add(String.Format("{0}, 0x{1:X16}, {2}", machine.ConsoleId, machine.Id, (long)machine.Id));
                            strings.Add(String.Format("-list -puid output does not contain: {0}, 0x{1:X16}, {2}", machine.ConsoleId, machine.Id, (long)machine.Id));

                        }
                    }

                    return strings.ToArray();
                }

                public override void Run()
                {
                    string output;
                    if ((bool)MyValues[0] == false)
                    {
                        output = CfgUtil.RunXblConfig(FormatListCommand(_groupId)).ToLower();
                    }
                    else
                    {
                        output = CfgUtil.RunXblConfig(FormatListCommand(_groupId) + " -puid").ToLower();
                    }

                    // Verify that the group is listed (with no actual machines)
                    // Note that we assume other tests have made sure the basic header stuff is there.

                    IEnumerable<StringValidation> svs = MakeSvs(
                        GetMachineIdValidationStrings());

                    ValidateOutputContains(output, svs);
                }

                public override void PostRun()
                {
                    foreach (MachineEditor machine in _machines)
                    {
                        machine.CompletelyRemoveMachine();
                    }
                    BetaGroupEditor.NukeGroup(_groupId);
                }
            }

            [TestCase, Description("Mixture of machines from different flatforms"), TestCasePriority(2)]
            [CompoundCase("Normal", false)]
            [CompoundCase("-PUID", true)]
            public class MixedPlatforms : TestNode
            {
                System.Collections.Generic.List<string> consoles;
                BetaGroupEditor bge;

                public override void PreRun()
                {
                    //create machines
                    consoles=new System.Collections.Generic.List<string>();
                    System.Collections.Generic.List<ulong> puids=new System.Collections.Generic.List<ulong>();
                    for (uint i=0; i<33; ++i)
                    {
                        MachineEditor meXb1=MachineEditor.CreateNew(MachineType.Xbox1);
                        MachineEditor meXb360 = MachineEditor.CreateNew(MachineType.Xbox360);
                        MachineEditor mePC = MachineEditor.CreateNew(MachineType.PC);
                        if ((bool)MyValues[0] == false)
                        {
                            consoles.Add(meXb1.ConsoleId);
                            consoles.Add(meXb360.ConsoleId);
                            consoles.Add(mePC.ConsoleId);
                        }
                        else
                        {
                            consoles.Add(String.Format("{0}, 0x{1:X16}, {2}", meXb1.ConsoleId, meXb1.Id, (long) meXb1.Id));
                            consoles.Add(String.Format("{0}, 0x{1:X16}, {2}", meXb360.ConsoleId, meXb360.Id, (long)meXb360.Id));
                            consoles.Add(String.Format("{0}, 0x{1:X16}, {2}", mePC.ConsoleId, mePC.Id, (long)mePC.Id));
                        }
                        puids.Add(meXb1.Id);
                        puids.Add(meXb360.Id);
                        puids.Add(mePC.Id);

                    }

                    //create group
                    bge=BetaGroupEditor.CreateNew();
                    bge.Name="XblCfg Test Group "+bge.Id;
                    foreach (ulong m in puids)
                    {
                        bge.AddMachine(m);
                    }
                }

                public override void Run()
                {
                    string output;
                    string[] outputConsoles;

                    if ((bool)MyValues[0] == false)
                    {
                        output = CfgUtil.RunXblConfig(FormatListCommand(bge.Id)).ToLower();
                    }
                    else
                    {
                        output = CfgUtil.RunXblConfig(FormatListCommand(bge.Id) + " -puid").ToLower();
                    }
                    //verify that only the exact machines that should be in the output are there
                    outputConsoles = GetMachinesFromOutput(output);
                    VerifyExactList(consoles.ToArray(), outputConsoles);
                }
            }
        } //class List

        [TestGroup, Description("Tests the -machineLookup option of the -groups.hidden command.")]
        public class MachineLookup : TestNode
        {
            private static string FormatMachineLookupCommand(string consoleId)
            {
                return String.Format("-groups.hidden -machineLookup:{0}", consoleId);
            }

            [TestCase, Description("Tests -machineLookup with no machine passed to it (which should mean help text).")]
            public class NoMachine : TestNode
            {
                public override void Run()
                {
                    string output = CfgUtil.RunXblConfig("-groups.hidden -machineLookup").ToLower();

                    IEnumerable<StringValidation> svs = MakeSvs(
                        "-machinelookup requires a machine to lookup", "-machineLookup with no machine did not produce appropriate error text.");

                    ValidateOutputContains(output, svs);
                }
            }

            [TestCase, Description("Test -machineLookup with a goofy string"), TestCasePriority(2)]
            public class MachineInvalidString : TestNode
            {
                public override void Run()
                {
                    string badMachine = "NotANumber";
                    string output = CfgUtil.RunXblConfig(String.Format("-groups.hidden -machineLookup:{0}", badMachine));

                    IEnumerable<StringValidation> svs = MakeSvs(
                        String.Format("{0} is not a valid console ID", badMachine.ToLower()), "-machineLookup with a random string didn't show the proper error");
                }
            }

            [TestCase, Description("Test -machineLookup with a bad console id checksum"), TestCasePriority(2)]
            public class MachineInvalidConsoleIdChecksum : TestNode
            {
                public override void Run()
                {
                    string badMachine = "XE.123443211234"; //last digit would have to be 6 to be correct
                    string output = CfgUtil.RunXblConfig(String.Format("-groups.hidden -machineLookup:{0}", badMachine));

                    IEnumerable<StringValidation> svs = MakeSvs(
                        String.Format("{0} is not a valid console ID", badMachine.ToLower()), "-machineLookup with a random string didn't show the proper error");
                }
            }

            [TestCase, Description("Tests -machineLookup with a machine that doesn't exist but is a valid id")]
            public class MachineDoesNotExist : TestNode
            {
                public override void Run()
                {
                    string badMachine = "XE.174845729434";
                    string output = CfgUtil.RunXblConfig(String.Format("-groups.hidden -machineLookup:{0}", badMachine)).ToLower();

                    IEnumerable<StringValidation> svs = MakeSvs(
                        String.Format("console {0} does not exist", badMachine), "-machineLookup with a non-existant machine didn't show the proper error");

                    ValidateOutputContains(output, svs);
                }
            }

            [TestCase, Description("Tests -machineLookup with a valid machine that isn't part of a group")]
            public class MachineValidNoGroup : TestNode
            {
                private const string _consoleId = "XE.377700000026";
                private MachineEditor _machine;

                public override void PreRun()
                {
                    _machine = MachineEditor.CreateOrUseExistingName(_consoleId);
                }

                public override void Run()
                {
                    string output = CfgUtil.RunXblConfig(FormatMachineLookupCommand(_machine.ConsoleId)).ToLower();

                    IEnumerable<StringValidation> svs = MakeSvs(
                        String.Format("console {0} is not in a group", _machine.ConsoleId), "-machineLookup with a machine that isn't in a group did not return the proper text");

                    ValidateOutputContains(output, svs);
                }

                public override void PostRun()
                {
                    _machine.CompletelyRemoveMachine();
                }
            }

            [TestCase, Description("Machine that is in a valid group.")]
            [CompoundCase("Xenon", MachineType.Xbox360)]
            [CompoundCase("Xbox1", MachineType.Xbox1)]
            [CompoundCase("PC", MachineType.PC)]
            public class MachineInOneGroup: TestNode
            {
                System.Guid guid=new System.Guid("{d05ca700-a5ed-f00d-0000-bad00000beef}");
                string console;
                ulong puid;

                public override void PreRun()
                {
                    MachineEditor me=MachineEditor.CreateNew((MachineType)MyValues[0]);
                    console=me.GetDecoratedConsoleId();
                    puid=me.Id;

                    BetaGroupEditor bge=BetaGroupEditor.CreateOrUseExistingId(guid);
                    bge.Name="XblCfg Test "+guid;
                    bge.RemoveAllMachines();
                    bge.AddMachine(me.Id);
                }

                public override void Run()
                {
                    string output=CfgUtil.RunXblConfig(FormatMachineLookupCommand(console)).ToLower();

                    string expectedOutput=string.Format("Console {0} (0x{1:X16})", console, puid)+" is in group {"+guid+"}";
                    if (!output.Contains(expectedOutput.ToLower()))
                    {
                        throw new UnexpectedTestResultException("Expected output to contain: "+expectedOutput);
                    }
                }
            }

            [TestCase, Description("Both machines in a group share a console id")]
            public void DuplicateConsolesInSameGroup()
            {
                //create group and machines
                BetaGroupEditor bge=BetaGroupEditor.CreateNew();
                bge.Name="XblCfg Test "+bge.Id;

                MachineEditor mach0=MachineEditor.CreateNew();
                MachineEditor mach1=MachineEditor.CreateDuplicateXbox360(mach0.ConsoleId);

                bge.AddMachine(mach0.Id);
                bge.AddMachine(mach1.Id);

                //call the tool
                string output=CfgUtil.RunXblConfig(FormatMachineLookupCommand(mach0.ConsoleId)).ToLower();

                string expectedOutput=string.Format("Console {0} (0x{1:X16})", mach0.ConsoleId, mach0.Id)+" is in group {"+bge.Id+"}";
                if (!output.Contains(expectedOutput.ToLower()))
                {
                    throw new UnexpectedTestResultException("Expected output to contain: "+expectedOutput);
                }
            }

            [TestCase, Description("Both machines in different groups share a console id")]
            public void DuplicateConsolesInDifferentGroups()
            {
                //create group and machines
                BetaGroupEditor bge0=BetaGroupEditor.CreateNew();
                bge0.Name="XblCfg Test "+bge0.Id;
                BetaGroupEditor bge1=BetaGroupEditor.CreateNew();
                bge1.Name="XblCfg Test "+bge1.Id;

                MachineEditor mach0=MachineEditor.CreateNew();
                MachineEditor mach1=MachineEditor.CreateDuplicateXbox360(mach0.ConsoleId);

                bge0.AddMachine(mach0.Id);
                bge1.AddMachine(mach1.Id);

                //call the tool
                string output=CfgUtil.RunXblConfig(FormatMachineLookupCommand(mach0.ConsoleId)).ToLower();

                string expectedOutput=string.Format("Console {0} (0x{1:X16})", mach0.ConsoleId, mach0.Id)+" is in group {"+bge0.Id+"}";
                if (!output.Contains(expectedOutput.ToLower()))
                {
                    throw new UnexpectedTestResultException("Expected output to contain: "+expectedOutput);
                }

                expectedOutput=string.Format("Console {0} (0x{1:X16})", mach1.ConsoleId, mach1.Id)+" is in group {"+bge1.Id+"}";
                if (!output.Contains(expectedOutput.ToLower()))
                {
                    throw new UnexpectedTestResultException("Expected output to contain: "+expectedOutput);
                }
            }
        } //class MachineLookup

        [TestGroup, Description("Tests the -create option of the -groups.hidden command.")]
        public class Create : TestNode
        {
            [TestCase, Description("Tests -create without a friendly name.")]
            public class NoFriendlyName : TestNode
            {
                public override void Run()
                {
                    string output = CfgUtil.RunXblConfig("-groups.hidden -create").ToLower();

                    IEnumerable<StringValidation> svs = MakeSvs(
                        "-create requires a friendly name", "-create with no friendly name didn't show the correct help text.");

                    ValidateOutputContains(output, svs);
                }
            }

            [TestCase, Description("Tests the -create option with a friendly name and no group id.")]
            public class FriendlyNameNoGroupId : TestNode
            {
                private const string _friendlyName = "friendlynamenogroupid_friendlyname";
                private Guid _betaId;

                public override void Run()
                {
                    string output = CfgUtil.RunXblConfig(String.Format("-groups.hidden -create -friendlyName:\"{0}\"", _friendlyName)).ToLower();

                    // Validate the output of the command.
                    string successSentinal = String.Format("created group \"{0}\" with id ", _friendlyName);
                    IEnumerable<StringValidation> svs = MakeSvs(
                        successSentinal, "-groups.hidden -create failed");
                    ValidateOutputContains(output, svs);

                    // Validate that the group actually exists. To do this, we must first figure out the group
                    // id that was just created.
                    string[] sections = output.Split('{', '}');
                    if (sections.Length != 3)
                    {
                        throw new UnexpectedTestResultException("Unexpected output from -create doesn't work with our group id parsing code.");
                    }
                    _betaId = new Guid(sections[1]);

                    BetaGroupEditor bge = BetaGroupEditor.FromId(_betaId);
                    if (!bge.Exists)
                    {
                        throw new UnexpectedTestResultException(String.Format("Output of xblcfg says it created guid {0:B}, but we can't find it.", _betaId));
                    }
                    if (bge.Creator != WindowsIdentity.GetCurrent().Name)
                    {
                        throw new UnexpectedTestResultException("Created group doesn't have the current windows id as the creator.");
                    }
                    if (bge.Name != _friendlyName)
                    {
                        throw new UnexpectedTestResultException("Created group doesn't have the friendly name we gave it.");
                    }
                }

                public override void PostRun()
                {
                    BetaGroupEditor.NukeGroup(_betaId);
                }
            }

            [TestCase, Description("Tests the -create option with groupId specified, but empty."), TestCasePriority(3)]
            public class FriendlyNameEmptyGroupId : TestNode
            {
                private const string _friendlyName = "friendlynameemptygroupid_friendlyname";

                public override void Run()
                {
                    string output = CfgUtil.RunXblConfig(String.Format("-groups.hidden -create -friendlyName:\"{0}\" -groupId:", _friendlyName)).ToLower();

                    IEnumerable<StringValidation> svs = MakeSvs(
                        "-groupid requires a guid", "-create with -groupId (but no group) didn't give the correct help text");

                    ValidateOutputContains(output, svs);
                }
            }

            [TestCase, Description("Tests the -create option with groupId specified, but incorrectly formatted."), TestCasePriority(2)]
            public class FriendlyNameBadGroupId : TestNode
            {
                private const string _friendlyName = "friendlynamebadgroupid_friendlyname";
                private const string _badGuid = "notaguid";

                public override void Run()
                {
                    string output = CfgUtil.RunXblConfig(String.Format("-groups.hidden -create -friendlyName:\"{0}\" -groupId:{{{1}}}", _friendlyName, _badGuid)).ToLower();

                    IEnumerable<StringValidation> svs = MakeSvs(
                        String.Format("group \"{{{0}}}\" is not a properly formatted guid", _badGuid), "-groupId with invalid guid does not give the correct help text");

                    ValidateOutputContains(output, svs);
                }
            }

            [TestCase, Description("Tests the -create option with a friendly name and no group id.")]
            public class FriendlyNameGroupId : TestNode
            {
                private const string _friendlyName = "friendlynamenogroupid_friendlyname";
                private readonly Guid _betaId = new Guid("{10000000-0000-0000-0000-1000deadbeef}");

                public override void Run()
                {
                    string output = CfgUtil.RunXblConfig(String.Format("-groups.hidden -create -friendlyName:\"{0}\" -groupId:{1:B}", _friendlyName, _betaId)).ToLower();

                    // Validate the output of the command.
                    string successSentinal = String.Format("created group \"{0}\" with id {1:B}", _friendlyName, _betaId);
                    IEnumerable<StringValidation> svs = MakeSvs(
                        successSentinal, "-groups.hidden -create failed");
                    ValidateOutputContains(output, svs);

                    BetaGroupEditor bge = BetaGroupEditor.FromId(_betaId);
                    if (!bge.Exists)
                    {
                        throw new UnexpectedTestResultException(String.Format("Output of xblcfg says it created guid {0:B}, but we can't find it.", _betaId));
                    }
                    if (bge.Creator != WindowsIdentity.GetCurrent().Name)
                    {
                        throw new UnexpectedTestResultException("Created group doesn't have the current windows id as the creator.");
                    }
                    if (bge.Name != _friendlyName)
                    {
                        throw new UnexpectedTestResultException("Created group doesn't have the friendly name we gave it.");
                    }
                }

                public override void PostRun()
                {
                    BetaGroupEditor.NukeGroup(_betaId);
                }
            }

            [TestCase(BugDatabase="Xbox360 Console Software", BugID=124366), Description("Tests the -create option with a friendly name that is too long."), TestCasePriority(3)]
            public class FriendlyNameIsTooLong: TestNode
            {
                private readonly Guid _betaId = new Guid("{10066600-fa70-f00d-0000-c0debaadbeef}");

                public override void PreRun()
                {
                    BetaGroupEditor bge=BetaGroupEditor.FromId(_betaId);
                    if (bge.Exists)
                    {
                        BetaGroupEditor.NukeGroup(_betaId);
                    }
                }

                public override void Run()
                {
                    string tooLongName="";
                    for (int i=0; i<101; ++i)
                    {
                        tooLongName+="x";
                    }

                    string output = CfgUtil.RunXblConfig(String.Format("-groups.hidden -create -friendlyName:\"{0}\" -groupId:{1:B}", tooLongName, _betaId)).ToLower();

                    IEnumerable<StringValidation> svs = MakeSvs(
                        String.Format("friendly name {0} too long", tooLongName), "-create with friendly name that's too long didn't show the correct help text.");
                    ValidateOutputContains(output, svs);

                    BetaGroupEditor bge=BetaGroupEditor.FromId(_betaId);
                    if (bge.Exists)
                    {
                        throw new UnexpectedTestResultException("Did not expect beta group to actually get created.");
                    }
                }

                public override void PostRun()
                {
                    BetaGroupEditor.NukeGroup(_betaId);
                }
            }

            [TestCase(BugDatabase="Xbox360 Console Software", BugID=124368), Description("Try to create a group with a name that already exists."), TestCasePriority(2)]
            public class FriendlyNameAlreadyExists: TestNode
            {
                private readonly Guid _betaId = new Guid("{20066602-fa70-f00d-0000-c0debaadbeef}");
                private const string _friendlyName="XblConfigTestNameExists";

                public override void PreRun()
                {
                    BetaGroupEditor bge=BetaGroupEditor.CreateOrUseExistingId(_betaId);
                    bge.Name=_friendlyName;
                }

                public override void Run()
                {
                    string output = CfgUtil.RunXblConfig(String.Format("-groups.hidden -create -friendlyName:\"{0}\"", _friendlyName)).ToLower();

                    IEnumerable<StringValidation> svs = MakeSvs(
                        String.Format("friendly name {0} already exists", _friendlyName.ToLower()), "-create with a friendly name that already exists didn't show the correct help text.");
                    ValidateOutputContains(output, svs);
                }
            }

            [TestCase(BugDatabase="Xbox360 Console Software", BugID=124367), Description("Try to create a group with a name that already exists."), TestCasePriority(2)]
            public class GuidAlreadyExists: TestNode
            {
                private readonly Guid _betaId = new Guid("{30066603-fa70-f00d-0000-c0debaadbeef}");
                private const string _friendlyName="XblConfigTestGuidExists";

                public override void PreRun()
                {
                    BetaGroupEditor bge=BetaGroupEditor.CreateOrUseExistingId(_betaId);
                    bge.Name=_friendlyName+" different name";
                }

                public override void Run()
                {
                    string output = CfgUtil.RunXblConfig(String.Format("-groups.hidden -create -friendlyName:\"{0}\" -groupId:{1:B}", _friendlyName, _betaId)).ToLower();

                    IEnumerable<StringValidation> svs = MakeSvs(
                        String.Format("groupid {0:b} already exists", _betaId), "-create with existing guid didn't show the correct help text.");
                    ValidateOutputContains(output, svs);
                }
            }
        } //class Create

        [TestGroup, Description("Tests the -add option of the -groups.hidden command.")]
        public class Add : TestNode
        {
            [TestCase, Description("-add with no options.")]
            public class AddNoOptions : TestNode
            {
                public override void Run()
                {
                    string output = CfgUtil.RunXblConfig("-groups.hidden -add").ToLower();

                    IEnumerable<StringValidation> svs = MakeSvs(
                        "-add requires -groupid and -file", "-add with no options did not return the correct help text.");

                    ValidateOutputContains(output, svs);
                }
            }

            [TestCase, Description("-add with an invalid group id")]
            public class AddInvalidGroupId : TestNode
            {
                private const string _badGuid = "notaguid";
                private const string _goodFile = "couldBeAFile";

                public override void Run()
                {
                    string output = CfgUtil.RunXblConfig(String.Format("-groups.hidden -add -groupid:{0} -file:{1}", _badGuid, _goodFile)).ToLower();

                    IEnumerable<StringValidation> svs = MakeSvs(
                        String.Format("group \"{0}\" is not a properly formatted guid", _badGuid), "-groupId with invalid guid does not give the correct help text");

                    ValidateOutputContains(output, svs);
                }
            }

            [TestCase, Description("-add with a non-existant file")]
            public class AddInvalidFileName : TestNode
            {
                private readonly Guid _groupId = new Guid("{10000000-0000-0000-0000-1000deadbeef}");
                private const string _fileNotFound = "addinvalidfilename_filename";

                public override void PreRun()
                {
                    BetaGroupEditor bge = BetaGroupEditor.CreateOrUseExistingId(_groupId);
                }

                public override void Run()
                {
                    string output = CfgUtil.RunXblConfig(String.Format("-groups.hidden -add -groupid:{0:B} -file:\"{1}\"", _groupId, _fileNotFound)).ToLower();

                    IEnumerable<StringValidation> svs = MakeSvs(
                        String.Format("cannot open file \"{0}\"", _fileNotFound), "-add with a non-existant file didn't show the correct help text.");

                    ValidateOutputContains(output, svs);
                }

                public override void PostRun()
                {
                    BetaGroupEditor.NukeGroup(_groupId);
                }
            }

            [TestCase, Description("-add with valid guid that isn't a group")]
            public class AddNonExistantGroup : TestNode
            {
                private readonly Guid _groupId = new Guid("{10000000-0000-0000-0000-1000deadbeef}");
                private const string _fileName = "couldbeafile";

                public override void Run()
                {
                    string output = CfgUtil.RunXblConfig(String.Format("-groups.hidden -add -groupId:{0:B} -file:\"{1}\"", _groupId, _fileName)).ToLower();

                    // Verify that the output contains the right error string.
                    IEnumerable<StringValidation> svs = MakeSvs(
                    String.Format("group {0:B} does not exist", _groupId), "-add did not produce an error when passed a group that doesn't exist.");

                    ValidateOutputContains(output, svs);
                }
            }

            [TestCase, Description("-add with valid file, which has a single valid console id in it")]
            [CompoundCase("ByConsoleId", 0)]
            [CompoundCase("ByHexPuid", 1)]
            [CompoundCase("byDecimalPuid", 2)]
            public class AddOneMachineFile : TestNode
            {
                private readonly Guid _groupId = new Guid("{10000000-0000-0000-0000-1000deadbeef}");
                private const string _consoleId = "XE.377700000026";
                private MachineEditor _machine;
                private string _fileName = Path.GetTempFileName();
                private BetaGroupEditor _bge;

                public override void PreRun()
                {
                    _machine = MachineEditor.CreateOrUseExistingName(_consoleId);
                    _bge = BetaGroupEditor.CreateOrUseExistingId(_groupId);
                    _bge.RemoveAllMachines();
                    switch ((int)MyValues[0])
                    {
                        case (0):
                            WriteFileString(String.Format("{0}\n", _machine.ConsoleId), _fileName);
                            break;
                        case (1):
                            WriteFileString(String.Format("0x{0:X16}\n", _machine.Id), _fileName);
                            break;
                        case (2):
                            WriteFileString(String.Format("{0}\n", (long)_machine.Id), _fileName);
                            break;
                    }

                }

                public override void Run()
                {
                    string output = CfgUtil.RunXblConfig(String.Format("-groups.hidden -add -groupId:{0:B} -file:\"{1}\"", _groupId, _fileName)).ToLower();

                    IEnumerable<StringValidation> svs = MakeSvs(
                        String.Format("adding console {0} (0x{1:X16}) to group {2:B}", _machine.ConsoleId, _machine.Id, _groupId), "-groups.hidden -add didn't list the added machines");

                    ValidateOutputContains(output, svs);

                    string[] consoles = _bge.GetAllConsoles();
                    if (consoles.Length != 1)
                    {
                        throw new UnexpectedTestResultException("Should only have one console in this group.");
                    }

                    if (consoles[0] != _machine.ConsoleId)
                    {
                        throw new UnexpectedTestResultException(String.Format("console {0} not added to group.", _machine.ConsoleId));
                    }
                }

                public override void PostRun()
                {
                    _machine.CompletelyRemoveMachine();
                    BetaGroupEditor.NukeGroup(_groupId);
                }
            }

            [TestCase, Description("-add with valid file, which has a single valid console id in it that is shared by two machines")]
            public void AddDuplicateConsoleFile()
            {
                //create group and machines
                BetaGroupEditor bge=BetaGroupEditor.CreateNew();
                bge.Name="XblCfg Test "+bge.Id;

                MachineEditor mach0=MachineEditor.CreateNew();
                MachineEditor mach1=MachineEditor.CreateDuplicateXbox360(mach0.ConsoleId);

                //write to file
                string fileName=Path.GetTempFileName();
                WriteFileString(String.Format("{0}\n", mach0.ConsoleId), fileName);

                //call the tool and verify
                string output=CfgUtil.RunXblConfig(String.Format("-groups.hidden -add -groupId:{0:B} -file:\"{1}\"", bge.Id, fileName)).ToLower();

                string expectedOutput = String.Format("adding console {0} (0x{1:X16}) to group {2:B}", mach0.ConsoleId, mach0.Id, bge.Id);
                if (!output.Contains(expectedOutput.ToLower()))
                {
                    throw new UnexpectedTestResultException("Expected output to contain: "+expectedOutput);
                }

                ValueCheck.Test("Number of consoles in beta group after -add", 2, bge.GetAllConsoles().Length);
            }

            [TestCase, Description("-add with valid file, which has a multiple valid console ids in it")]
            public class AddManyMachineFile : TestNode
            {
                private readonly Guid _groupId = new Guid("{10000000-0000-0000-0000-1000deadbeef}");
                private readonly string[] _consoleIds = new string[] { "XE.377700000026", "XE.377700000004", "XE.377700000015" };
                private MachineEditor[] _machines;
                private string _fileName = Path.GetTempFileName();
                private BetaGroupEditor _bge;

                public override void PreRun()
                {
                    _machines = Array.ConvertAll<string, MachineEditor>(_consoleIds, delegate(string consoleId) { return MachineEditor.CreateOrUseExistingName(consoleId); });
                    _bge = BetaGroupEditor.CreateOrUseExistingId(_groupId);
                    _bge.RemoveAllMachines();

                    StringBuilder sb = new StringBuilder();
                    foreach (MachineEditor machine in _machines)
                    {
                        sb.AppendFormat("{0}\n", machine.ConsoleId);
                    }
                    WriteFileString(sb.ToString(), _fileName);
                }

                private string[] GetMachineIdValidationStrings()
                {
                    List<string> strings = new List<string>(_machines.Length * 2);

                    foreach (MachineEditor machine in _machines)
                    {
                        strings.Add(String.Format("adding console {0} (0x{1:X16}) to group {2:B}", machine.ConsoleId, machine.Id, _groupId));
                        strings.Add(String.Format("-list output does not contain the machine {0} we inserted", machine.ConsoleId));
                    }

                    return strings.ToArray();
                }

                public override void Run()
                {
                    string output = CfgUtil.RunXblConfig(String.Format("-groups.hidden -add -groupId:{0:B} -file:\"{1}\"", _groupId, _fileName)).ToLower();

                    IEnumerable<StringValidation> svs = MakeSvs(GetMachineIdValidationStrings());

                    ValidateOutputContains(output, svs);

                    string[] consoles = _bge.GetAllConsoles();
                    if (consoles.Length != _machines.Length)
                    {
                        throw new UnexpectedTestResultException(String.Format("Should exactly {0} machine in this group.", _machines.Length));
                    }

                    foreach (MachineEditor machine in _machines)
                    {
                        if (!Array.Exists(consoles, delegate(string cid) { return machine.ConsoleId == cid; }))
                        {
                            throw new UnexpectedTestResultException(String.Format("console {0} not added to group.", machine.ConsoleId));
                        }
                    }
                }

                public override void PostRun()
                {
                    foreach (MachineEditor machine in _machines)
                    {
                        machine.CompletelyRemoveMachine();
                    }
                    BetaGroupEditor.NukeGroup(_groupId);
                }
            }

            [TestCase(BugDatabase="Xbox360 Console Software", BugID=124369), Description("-add with valid file, which has a single valid console id that is not an existing machine in it"), TestCasePriority(2)]
            [CompoundCase("DoesNotExist", "XE.174845729434", "console XE.174845729434 does not exist")] //valid id, just doesn't exist
            [CompoundCase("InvalidValue", "woops",           "console woops does not exist")]        //totally bad id
            [CompoundCase("BadChecksum",  "XE.123443211234", "console XE.123443211234 does not exist")] //valid format, bad checksum
            public class AddBadConsoleFile: TestNode
            {
                private readonly Guid _groupId = new Guid("{10000000-0000-0000-0000-1000deadbeef}");

                private string _fileName = Path.GetTempFileName();
                private BetaGroupEditor _bge;

                public override void PreRun()
                {
                    _bge = BetaGroupEditor.CreateOrUseExistingId(_groupId);
                    _bge.RemoveAllMachines();

                    string consoleId=(string)MyValues[0];
                    WriteFileString(String.Format("{0}\n", consoleId), _fileName);
                }

                public override void Run()
                {
                    string consoleId=(string)MyValues[0];
                    string errorString=(string)MyValues[1];

                    string output = CfgUtil.RunXblConfig(String.Format("-groups.hidden -add -groupId:{0:B} -file:\"{1}\"", _groupId, _fileName)).ToLower();

                    string expectString=errorString;
                    if (!output.ToLower().Contains(expectString.ToLower()))
                    {
                        throw new UnexpectedTestResultException("Expected output to contain: "+expectString);
                    }

                    ulong[] machines = _bge.GetAllMachines();
                    if (machines.Length != 0)
                    {
                        throw new UnexpectedTestResultException("Expected no machines in this group.");
                    }
                }

                public override void PostRun()
                {
                    BetaGroupEditor.NukeGroup(_groupId);
                }
            }

            [TestCase(BugDatabase="Xbox360 Console Software", BugID=124369), Description("-add with valid file, which has a multiple valid console ids in it along with a valid machine that does not exist and one that's malformed"), TestCasePriority(2)]
            public class AddMixedGoodAndNonExistingAndBadMachinesFile : TestNode
            {
                private readonly Guid _groupId = new Guid("{10000000-0000-0000-0000-1000deadbeef}");
                private MachineEditor[] _machines;
                private string _fileName = Path.GetTempFileName();
                private BetaGroupEditor _bge;

                public override void PreRun()
                {
                    _machines=new MachineEditor[3];
                    _machines[0]=MachineEditor.CreateNew(MachineType.Xbox360);
                    _machines[1]=MachineEditor.CreateNew(MachineType.Xbox1);
                    _machines[2]=MachineEditor.CreateNew(MachineType.PC);

                    _bge = BetaGroupEditor.CreateOrUseExistingId(_groupId);
                    _bge.RemoveAllMachines();

                    StringBuilder sb = new StringBuilder();
                    sb.AppendFormat("{0}\n", _machines[0].ConsoleId);
                    sb.AppendFormat("XE.123443211234\n");
                    sb.AppendFormat("{0}\n", _machines[1].GetDecoratedConsoleId());
                    sb.AppendFormat("BadEntry\n");
                    sb.AppendFormat("{0}\n", _machines[2].ConsoleId);
                    WriteFileString(sb.ToString(), _fileName);
                }

                private string[] GetMachineIdValidationStrings()
                {
                    List<string> strings = new List<string>(_machines.Length * 2);

                    foreach (MachineEditor machine in _machines)
                    {
                        strings.Add(String.Format("adding console {0} (0x{1:X16}) to group {2:B}", machine.GetDecoratedConsoleId(), machine.Id, _groupId));
                        strings.Add(String.Format("-add output does not contain: adding console {0} (0x{1:X16}) to group {2:B}", machine.GetDecoratedConsoleId(), machine.Id, _groupId));
                    }

                    return strings.ToArray();
                }

                public override void Run()
                {
                    string output = CfgUtil.RunXblConfig(String.Format("-groups.hidden -add -groupId:{0:B} -file:\"{1}\"", _groupId, _fileName)).ToLower();

                    //make sure the good ones got there
                    IEnumerable<StringValidation> svs = MakeSvs(GetMachineIdValidationStrings());

                    ValidateOutputContains(output, svs);

                    string[] consoles = _bge.GetAllConsoles();
                    if (consoles.Length != _machines.Length)
                    {
                        throw new UnexpectedTestResultException(String.Format("Should exactly {0} consoles in this group.", _machines.Length));
                    }

                    foreach (MachineEditor machine in _machines)
                    {
                        if (!Array.Exists(consoles, delegate(string cid) { return machine.ConsoleId == cid; }))
                        {
                            throw new UnexpectedTestResultException(String.Format("console {0} not added to group.", machine.ConsoleId));
                        }
                    }

                    //verify errors for bad ones
                    {
                        string expectString="console XE.123443211234 does not exist";
                        if (!output.ToLower().Contains(expectString.ToLower()))
                        {
                            throw new UnexpectedTestResultException("Expected output to contain: "+expectString);
                        }
                    }

                    {
                        string expectString="BadEntry does not exist";
                        if (!output.ToLower().Contains(expectString.ToLower()))
                        {
                            throw new UnexpectedTestResultException("Expected output to contain: "+expectString);
                        }
                    }
                }

                public override void PostRun()
                {
                    BetaGroupEditor.NukeGroup(_groupId);
                }
            }

            [TestCase, Description("-add with valid file, which has a multiple valid console ids, one of which is already in the group")]
            public class AddAlreadyInSameGroupMachinesFile : TestNode
            {
                private readonly Guid _groupId = new Guid("{10000000-0000-0000-0000-1000deadbeef}");
                private MachineEditor[] _machines;
                private string _fileName = Path.GetTempFileName();
                private BetaGroupEditor _bge;

                public override void PreRun()
                {
                    _machines=new MachineEditor[3];
                    _machines[0]=MachineEditor.CreateNew(MachineType.Xbox360);
                    _machines[1]=MachineEditor.CreateNew(MachineType.Xbox360);
                    _machines[2]=MachineEditor.CreateNew(MachineType.Xbox360);

                    _bge = BetaGroupEditor.CreateOrUseExistingId(_groupId);
                    _bge.RemoveAllMachines();
                    _bge.AddMachine(_machines[1].Id);

                    StringBuilder sb = new StringBuilder();
                    sb.AppendFormat("{0}\n", _machines[0].ConsoleId);
                    sb.AppendFormat("{0}\n", _machines[1].ConsoleId);
                    sb.AppendFormat("{0}", _machines[2].ConsoleId);
                    WriteFileString(sb.ToString(), _fileName);
                }

                private string[] GetMachineIdValidationStrings()
                {
                    List<string> strings = new List<string>(_machines.Length * 2);

                    foreach (MachineEditor machine in _machines)
                    {
                        if (machine.Id != _machines[1].Id)
                        {
                            strings.Add(String.Format("adding console {0} (0x{1:X16}) to group {2:B}", machine.ConsoleId, machine.Id, _groupId));
                            strings.Add(String.Format("-add output does not contain the console {0} we inserted", machine.ConsoleId));
                        }
                    }

                    return strings.ToArray();
                }

                public override void Run()
                {
                    string output = CfgUtil.RunXblConfig(String.Format("-groups.hidden -add -groupId:{0:B} -file:\"{1}\"", _groupId, _fileName)).ToLower();

                    //make sure the good ones got there
                    IEnumerable<StringValidation> svs = MakeSvs(GetMachineIdValidationStrings());

                    ValidateOutputContains(output, svs);

                    string[] consoles = _bge.GetAllConsoles();
                    if (consoles.Length != _machines.Length)
                    {
                        throw new UnexpectedTestResultException(String.Format("Should be exactly {0} consoles in this group.", _machines.Length));
                    }

                    foreach (MachineEditor machine in _machines)
                    {
                        if (!Array.Exists(consoles, delegate(string cid) { return machine.ConsoleId == cid; }))
                        {
                            throw new UnexpectedTestResultException(String.Format("console {0} not added to group.", machine.ConsoleId));
                        }
                    }
                }

                public override void PostRun()
                {
                    BetaGroupEditor.NukeGroup(_groupId);
                }
            }

            [TestCase, Description("-add with valid file, which has a multiple valid console ids, one of which is already in the group")]
            public class AddAlreadyInDifferentGroupMachinesFile : TestNode
            {
                private readonly Guid _groupId = new Guid("{10000000-0000-0000-0000-1000deadbeef}");
                private readonly Guid _groupIdOther = new Guid("{10000000-0000-0000-ffff-1000deadbeef}");
                private MachineEditor[] _machines;
                private string _fileName = Path.GetTempFileName();
                private BetaGroupEditor _bge;
                private BetaGroupEditor _bgeOther;

                public override void PreRun()
                {
                    _machines=new MachineEditor[3];
                    _machines[0]=MachineEditor.CreateNew(MachineType.Xbox360);
                    _machines[1]=MachineEditor.CreateNew(MachineType.Xbox360);
                    _machines[2]=MachineEditor.CreateNew(MachineType.Xbox360);

                    _bge = BetaGroupEditor.CreateOrUseExistingId(_groupId);
                    _bge.RemoveAllMachines();

                    _bgeOther = BetaGroupEditor.CreateOrUseExistingId(_groupIdOther);
                    _bgeOther.RemoveAllMachines();
                    _bgeOther.AddMachine(_machines[1].Id);

                    StringBuilder sb = new StringBuilder();
                    sb.AppendFormat("{0}\n", _machines[0].ConsoleId);
                    sb.AppendFormat("{0}\n", _machines[1].ConsoleId);
                    sb.AppendFormat("{0}", _machines[2].ConsoleId);
                    WriteFileString(sb.ToString(), _fileName);
                }

                private string[] GetMachineIdValidationStrings()
                {
                    List<string> strings = new List<string>(_machines.Length * 2+2);

                    foreach (MachineEditor machine in _machines)
                    {
                        if (machine.Id != _machines[1].Id)
                        {
                            strings.Add(String.Format("adding console {0} (0x{1:X16}) to group {2:B}", machine.ConsoleId, machine.Id, _groupId));
                            strings.Add(String.Format("-add output does not contain the machine {0} we inserted", machine.ConsoleId));
                        }
                    }

                    return strings.ToArray();
                }

                public override void Run()
                {
                    string output = CfgUtil.RunXblConfig(String.Format("-groups.hidden -add -groupId:{0:B} -file:\"{1}\"", _groupId, _fileName)).ToLower();

                    //make sure the good ones got there
                    IEnumerable<StringValidation> svs = MakeSvs(GetMachineIdValidationStrings());

                    ValidateOutputContains(output, svs);

                    //check the group being added to
                    string []consoles = _bge.GetAllConsoles();
                    if (consoles.Length != _machines.Length-1)
                    {
                        throw new UnexpectedTestResultException(String.Format("Should exactly {0} consoles in the group being added to.", _machines.Length-1));
                    }

                    foreach (MachineEditor machine in _machines)
                    {
                        if (machine.Id != _machines[1].Id)
                        {
                            if (!Array.Exists(consoles, delegate(string cid) { return machine.ConsoleId == cid; }))
                            {
                                throw new UnexpectedTestResultException(String.Format("console {0} (0x{1:X16}) already in group {2:B}", machine.ConsoleId, machine.Id, _groupId));
                            }
                        }
                    }

                    //check the other group
                    string []consolesOther = _bgeOther.GetAllConsoles();
                    ValueCheck.Test("Should exactly 1 machine in the other group.", 1, consolesOther.Length);
                    ValueCheck.Test("Console in other group", _machines[1].ConsoleId, consolesOther[0]);

                    //verify output
                    string expectedError = string.Format("console {0} (0x{1:X16}) already in group {2:B}", _machines[1].ConsoleId, _machines[1].Id, _bgeOther.Id);
                    if (!output.ToLower().Contains(expectedError.ToLower()))
                    {
                        throw new UnexpectedTestResultException("Expected output to contain: "+expectedError);
                    }
                }

                public override void PostRun()
                {
                    BetaGroupEditor.NukeGroup(_groupId);
                    BetaGroupEditor.NukeGroup(_groupIdOther);
                }
            }

        } //class Add

        [TestGroup, Description("Tests the -remove option of the -groups.hidden command.")]
        public class Remove : TestNode
        {
            [TestCase, Description("-remove with no options.")]
            public class RemoveNoOptions : TestNode
            {
                public override void Run()
                {
                    string output = CfgUtil.RunXblConfig("-groups.hidden -remove").ToLower();

                    IEnumerable<StringValidation> svs = MakeSvs(
                        "-remove requires -groupid and -file", "-remove with no options did not return the correct help text.");

                    ValidateOutputContains(output, svs);
                }
            }

            [TestCase, Description("-remove with an invalid group id")]
            public class RemoveInvalidGroupId : TestNode
            {
                private const string _badGuid = "notaguid";
                private const string _goodFile = "couldBeAFile";

                public override void Run()
                {
                    string output = CfgUtil.RunXblConfig(String.Format("-groups.hidden -remove -groupid:{0} -file:\"{1}\"", _badGuid, _goodFile)).ToLower();

                    IEnumerable<StringValidation> svs = MakeSvs(
                        String.Format("group \"{0}\" is not a properly formatted guid", _badGuid), "-groupId with invalid guid does not give the correct help text");

                    ValidateOutputContains(output, svs);
                }
            }

            [TestCase, Description("-remove with a non-existant file")]
            public class RemoveInvalidFileName : TestNode
            {
                private readonly Guid _groupId = new Guid("{10000000-0000-0000-0000-1000deadbeef}");
                private const string _fileNotFound = "addinvalidfilename_filename";

                public override void PreRun()
                {
                    BetaGroupEditor bge = BetaGroupEditor.CreateOrUseExistingId(_groupId);
                }

                public override void Run()
                {
                    string output = CfgUtil.RunXblConfig(String.Format("-groups.hidden -remove -groupid:{0:B} -file:\"{1}\"", _groupId, _fileNotFound)).ToLower();

                    IEnumerable<StringValidation> svs = MakeSvs(
                        String.Format("cannot open file \"{0}\"", _fileNotFound), "-remove with a non-existant file didn't show the correct help text.");

                    ValidateOutputContains(output, svs);
                }

                public override void PostRun()
                {
                    BetaGroupEditor.NukeGroup(_groupId);
                }
            }

            [TestCase, Description("-remove with valid guid that isn't a group")]
            public class RemoveNonExistantGroup : TestNode
            {
                private readonly Guid _groupId = new Guid("{10000000-0000-0000-0000-1000deadbeef}");
                private const string _fileName = "couldbeafile";

                public override void Run()
                {
                    string output = CfgUtil.RunXblConfig(String.Format("-groups.hidden -remove -groupId:{0:B} -file:\"{1}\"", _groupId, _fileName)).ToLower();

                    // Verify that the output contains the right error string.
                    IEnumerable<StringValidation> svs = MakeSvs(
                    String.Format("group {0:B} does not exist", _groupId), "-remove did not produce an error when passed a group that doesn't exist.");

                    ValidateOutputContains(output, svs);
                }
            }

            [TestCase, Description("-remove with valid file, which has a single valid console id in it")]
            [CompoundCase("ByConsoleId", 0)]
            [CompoundCase("ByHexPuid", 1)]
            [CompoundCase("byDecimalPuid", 2)]
            public class RemoveOneMachineFile : TestNode
            {
                private readonly Guid _groupId = new Guid("{10000000-0000-0000-0000-1000deadbeef}");
                private const string _consoleId = "XE.377700000026";
                private MachineEditor _machine;
                private string _fileName = Path.GetTempFileName();
                private BetaGroupEditor _bge;

                public override void PreRun()
                {
                    _machine = MachineEditor.CreateOrUseExistingName(_consoleId);
                    _bge = BetaGroupEditor.CreateOrUseExistingId(_groupId);
                    _bge.RemoveAllMachines();
                    _bge.AddMachine(_machine.Id);

                    switch ((int)MyValues[0])
                    {
                        case (0):
                            WriteFileString(String.Format("{0}\n", _machine.ConsoleId), _fileName);
                            break;
                        case (1):
                            WriteFileString(String.Format("0x{0:X16}\n", _machine.Id), _fileName);
                            break;
                        case (2):
                            WriteFileString(String.Format("{0}\n", (long)_machine.Id), _fileName);
                            break;
                    }
                }

                public override void Run()
                {
                    string output = CfgUtil.RunXblConfig(String.Format("-groups.hidden -remove -groupId:{0:B} -file:\"{1}\"", _groupId, _fileName)).ToLower();

                    IEnumerable<StringValidation> svs = MakeSvs(
                        String.Format("removing console {0} (0x{1:X16}) from group {2:B}", _machine.ConsoleId, _machine.Id, _groupId), "-groups.hidden -remove didn't list the removed consoles");

                    ValidateOutputContains(output, svs);

                    ulong[] machines = _bge.GetAllMachines();
                    if (machines.Length != 0)
                    {
                        throw new UnexpectedTestResultException("This group should have no consoles at all now.");
                    }
                }

                public override void PostRun()
                {
                    _machine.CompletelyRemoveMachine();
                    BetaGroupEditor.NukeGroup(_groupId);
                }
            }

            [TestCase, Description("-remove with valid file, which has a single valid console id in it that is shared by two machines")]
            public void RemoveDuplicateConsoleFile()
            {
                //create group and machines
                BetaGroupEditor bge=BetaGroupEditor.CreateNew();
                bge.Name="XblCfg Test "+bge.Id;

                MachineEditor mach0=MachineEditor.CreateNew();
                MachineEditor mach1=MachineEditor.CreateDuplicateXbox360(mach0.ConsoleId);

                bge.AddMachine(mach0.Id);
                bge.AddMachine(mach1.Id);

                //write to file
                string fileName=Path.GetTempFileName();
                WriteFileString(String.Format("{0}\n", mach0.ConsoleId), fileName);

                //call the tool and verify
                string output=CfgUtil.RunXblConfig(String.Format("-groups.hidden -remove -groupId:{0:B} -file:\"{1}\"", bge.Id, fileName)).ToLower();
                IEnumerable<StringValidation> svs=MakeSvs(String.Format("removing console {0} (0x{1:X16}) from group {2:B}", mach0.ConsoleId, mach0.Id, bge.Id), "-groups.hidden -remove didn't list the removed consoles");

                ValidateOutputContains(output, svs);

                ulong[] machines=bge.GetAllMachines();
                if (machines.Length!=0)
                {
                    throw new UnexpectedTestResultException("This group should have no consoles at all now.");
                }
            }

            [TestCase, Description("-remove with valid file, which has a multiple valid console id in it")]
            public class RemoveManyMachineFile : TestNode
            {
                private readonly Guid _groupId = new Guid("{10000000-0000-0000-0000-1000deadbeef}");
                private readonly string[] _consoleIds = new string[] { "XE.377700000026", "XE.377700000004", "XE.377700000015" };
                private MachineEditor[] _machines;
                private string _fileName = Path.GetTempFileName();
                private BetaGroupEditor _bge;

                public override void PreRun()
                {
                    _machines = Array.ConvertAll<string, MachineEditor>(_consoleIds, delegate(string consoleId) { return MachineEditor.CreateOrUseExistingName(consoleId); });
                    _bge = BetaGroupEditor.CreateOrUseExistingId(_groupId);
                    _bge.RemoveAllMachines();

                    StringBuilder sb = new StringBuilder();
                    foreach (MachineEditor machine in _machines)
                    {
                        sb.AppendFormat("{0}\n", machine.ConsoleId);
                        _bge.AddMachine(machine.Id);
                    }
                    WriteFileString(sb.ToString(), _fileName);
                }

                private string[] GetMachineIdValidationStrings()
                {
                    List<string> strings = new List<string>(_machines.Length * 2);

                    foreach (MachineEditor machine in _machines)
                    {
                        strings.Add(String.Format("removing console {0} (0x{1:X16}) from group {2:B}", machine.ConsoleId, machine.Id, _groupId));
                        strings.Add(String.Format("-list output does not contain the console {0} we removed", machine.ConsoleId));
                    }

                    return strings.ToArray();
                }

                public override void Run()
                {
                    string output = CfgUtil.RunXblConfig(String.Format("-groups.hidden -remove -groupId:{0:B} -file:\"{1}\"", _groupId, _fileName)).ToLower();

                    IEnumerable<StringValidation> svs = MakeSvs(GetMachineIdValidationStrings());

                    ValidateOutputContains(output, svs);

                    ulong[] machines = _bge.GetAllMachines();
                    if (machines.Length != 0)
                    {
                        throw new UnexpectedTestResultException("This group should have no consoles at all now.");
                    }
                }

                public override void PostRun()
                {
                    foreach (MachineEditor machine in _machines)
                    {
                        machine.CompletelyRemoveMachine();
                    }
                    BetaGroupEditor.NukeGroup(_groupId);
                }
            }

            [TestCase, Description("-remove with valid file, which 1 machine in it.  the group has 3 machines total")]
            public class RemoveSomeMachineFile : TestNode
            {
                private readonly Guid _groupId = new Guid("{10000000-0000-0000-0000-1000deadbeef}");
                private MachineEditor []_machines;
                private string _fileName = Path.GetTempFileName();
                private BetaGroupEditor _bge;

                public override void PreRun()
                {
                    _machines=new MachineEditor[3];
                    _machines[0]=MachineEditor.CreateNew(MachineType.Xbox360);
                    _machines[1]=MachineEditor.CreateNew(MachineType.Xbox360);
                    _machines[2]=MachineEditor.CreateNew(MachineType.Xbox360);

                    _bge = BetaGroupEditor.CreateOrUseExistingId(_groupId);
                    _bge.RemoveAllMachines();
                    _bge.AddMachine(_machines[0].Id);
                    _bge.AddMachine(_machines[1].Id);
                    _bge.AddMachine(_machines[2].Id);

                    StringBuilder sb = new StringBuilder();
                    sb.AppendFormat("{0}\n", _machines[1].ConsoleId);
                    WriteFileString(sb.ToString(), _fileName);
                }

                public override void Run()
                {
                    string output = CfgUtil.RunXblConfig(String.Format("-groups.hidden -remove -groupId:{0:B} -file:\"{1}\"", _groupId, _fileName)).ToLower();

                    IEnumerable<StringValidation> svs = MakeSvs(
                        String.Format("removing console {0} (0x{1:X16}) from group {2:B}", _machines[1].ConsoleId, _machines[1].Id, _groupId), "-groups.hidden -remove didn't list the removed machines");

                    ValidateOutputContains(output, svs);

                    string []consoles = _bge.GetAllConsoles();
                    if (consoles.Length != 2)
                    {
                        throw new UnexpectedTestResultException("This group should have 2 consoles now but has "+consoles.Length+".");
                    }

                    if (System.Array.IndexOf(consoles, _machines[0].ConsoleId)==-1)
                    {
                        throw new UnexpectedTestResultException(string.Format("Console {0} was expected to be in the group.", _machines[0].ConsoleId));
                    }

                    if (System.Array.IndexOf(consoles, _machines[1].ConsoleId)!=-1)
                    {
                        throw new UnexpectedTestResultException(string.Format("Console {0} was NOT expected to be in the group.", _machines[1].ConsoleId));
                    }

                    if (System.Array.IndexOf(consoles, _machines[2].ConsoleId)==-1)
                    {
                        throw new UnexpectedTestResultException(string.Format("Console {0} was expected to be in the group.", _machines[2].ConsoleId));
                    }
                }

                public override void PostRun()
                {
                    BetaGroupEditor.NukeGroup(_groupId);
                }
            }

            [TestCase, Description("-remove with valid file, which 1 machine in it.  that group doesn't have that machine in it though."), TestCasePriority(2)]
            public class RemoveMachineNotInGroupMachineFile : TestNode
            {
                private readonly Guid _groupId = new Guid("{10000000-0000-0000-0000-1000deadbeef}");
                private MachineEditor []_machines;
                private string _fileName = Path.GetTempFileName();
                private BetaGroupEditor _bge;

                public override void PreRun()
                {
                    _machines=new MachineEditor[3];
                    _machines[0]=MachineEditor.CreateNew(MachineType.Xbox360);

                    _bge = BetaGroupEditor.CreateOrUseExistingId(_groupId);
                    _bge.RemoveAllMachines();

                    StringBuilder sb = new StringBuilder();
                    sb.AppendFormat("{0}\n", _machines[0].ConsoleId);
                    WriteFileString(sb.ToString(), _fileName);
                }

                public override void Run()
                {
                    string output = CfgUtil.RunXblConfig(String.Format("-groups.hidden -remove -groupId:{0:B} -file:\"{1}\"", _groupId, _fileName)).ToLower();

                    IEnumerable<StringValidation> svs = MakeSvs(
                        String.Format("removing console {0} (0x{1:X16}) from group {2:B}", _machines[0].ConsoleId, _machines[0].Id, _groupId), "-groups.hidden -remove didn't list the removed machines");

                    ValidateOutputContains(output, svs);

                    ulong []machines = _bge.GetAllMachines();
                    if (machines.Length != 0)
                    {
                        throw new UnexpectedTestResultException("This group should have no consoles in it.");
                    }
                }

                public override void PostRun()
                {
                    BetaGroupEditor.NukeGroup(_groupId);
                }
            }

            [TestCase(BugDatabase="Xbox360 Console Software", BugID=124370), Description("-remove with valid file, which has 4 machines in it (1 a bad id, one non-existant machine).  the group has 3 machines total"), TestCasePriority(2)]
            public class RemoveMixedGoodAndBadEntriesMachineFile : TestNode
            {
                private readonly Guid _groupId = new Guid("{10000000-0000-0000-0000-1000deadbeef}");
                private MachineEditor []_machines;
                private string _fileName = Path.GetTempFileName();
                private BetaGroupEditor _bge;

                public override void PreRun()
                {
                    _machines=new MachineEditor[3];
                    _machines[0]=MachineEditor.CreateNew(MachineType.Xbox360);
                    _machines[1]=MachineEditor.CreateNew(MachineType.Xbox360);
                    _machines[2]=MachineEditor.CreateNew(MachineType.Xbox360);

                    _bge = BetaGroupEditor.CreateOrUseExistingId(_groupId);
                    _bge.RemoveAllMachines();
                    _bge.AddMachine(_machines[0].Id);
                    _bge.AddMachine(_machines[1].Id);
                    _bge.AddMachine(_machines[2].Id);

                    StringBuilder sb = new StringBuilder();
                    sb.AppendFormat("{0}\n", _machines[0].ConsoleId);
                    sb.AppendFormat("XE.123443211234\n");
                    sb.AppendFormat("BadEntry\n");
                    sb.AppendFormat("{0}\n", _machines[2].ConsoleId);
                    WriteFileString(sb.ToString(), _fileName);
                }

                public override void Run()
                {
                    string output = CfgUtil.RunXblConfig(String.Format("-groups.hidden -remove -groupId:{0:B} -file:\"{1}\"", _groupId, _fileName)).ToLower();

                    IEnumerable<StringValidation> svs = MakeSvs(
                        String.Format("removing console {0} (0x{1:X16}) from group {2:B}", _machines[0].ConsoleId, _machines[0].Id, _groupId), "-groups.hidden -remove didn't list the removed consoles",
                        String.Format("removing console {0} (0x{1:X16}) from group {2:B}", _machines[0].ConsoleId, _machines[0].Id, _groupId), "-groups.hidden -remove didn't list the removed consoles");

                    ValidateOutputContains(output, svs);

                    string []consoles = _bge.GetAllConsoles();
                    if (consoles.Length != 1)
                    {
                        throw new UnexpectedTestResultException("This group should have 1 console now.");
                    }

                    if (System.Array.IndexOf(consoles, _machines[1].ConsoleId)==-1)
                    {
                        throw new UnexpectedTestResultException(string.Format("Console {0} was expected to be in the group.", _machines[1].ConsoleId));
                    }

                    //verify errors for bad ones
                    {
                        string expectString="console XE.123443211234 does not exist";
                        if (!output.Contains(expectString.ToLower()))
                        {
                            throw new UnexpectedTestResultException("Expected output to contain: "+expectString);
                        }
                    }

                    {
                        string expectString="console BadEntry does not exist";
                        if (!output.Contains(expectString.ToLower()))
                        {
                            throw new UnexpectedTestResultException("Expected output to contain: "+expectString);
                        }
                    }
                }

                public override void PostRun()
                {
                    BetaGroupEditor.NukeGroup(_groupId);
                }
            }
        } //class Remove
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\XblEventPerfReporting\makefile.inc ===
RobocopyScripts : 
    -robocopy . $(_NT386TREE)\msi\esp\XblEventPerfReporting /X /A-:R /E /R:0 /NP /NJH /NJS /XO /XX /XF build.log build.err build.wrn buildd.log buildd.err buildd.wrn sources makefile makefile.inc *.sln *.rptproj /XD obj objd
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\XBLMaestro\XBLMaestro_FD\XBLMaestro_FD-PostImage\makefile.inc ===
!include $(INETROOT)\build\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\XblEventPerfReporting\obj\i386\_asmid.inc ===
ASSEMBLY_IDENTITY_KEY_FORM=x86_eventperfreporting_none_12.4.56.0_none_1349fe88daabef7f
ASSEMBLY_IDENTITY_XP_KEY_FORM=x86_eventperfreporting_no-public-key_12.4.56.0_x-ww_ee66ce21
ASSEMBLY_IDENTITY_CULTURE=
ASSEMBLY_IDENTITY_NAME=eventperfreporting
ASSEMBLY_IDENTITY_PROCESSOR_ARCHITECTURE=x86
ASSEMBLY_IDENTITY_PUBLIC_KEY=
ASSEMBLY_IDENTITY_PUBLIC_KEY_TOKEN=
ASSEMBLY_IDENTITY_TYPE=
ASSEMBLY_IDENTITY_TYPE_NAME=
ASSEMBLY_IDENTITY_VERSION=12.4.56.0
XP_KEY_FORM=x86_eventperfreporting_no-public-key_12.4.56.0_x-ww_ee66ce21
XP_MANIFEST_DIRECTORY=manifests
XP_MANIFEST_NAME=x86_eventperfreporting_no-public-key_12.4.56.0_x-ww_ee66ce21.manifest
XP_MANIFEST_PATH=manifests\x86_eventperfreporting_no-public-key_12.4.56.0_x-ww_ee66ce21.manifest
XP_CATALOG_DIRECTORY=manifests
XP_CATALOG_NAME=x86_eventperfreporting_no-public-key_12.4.56.0_x-ww_ee66ce21.cat
XP_CATALOG_PATH=manifests\x86_eventperfreporting_no-public-key_12.4.56.0_x-ww_ee66ce21.cat
XP_PAYLOAD_PATH=x86_eventperfreporting_no-public-key_12.4.56.0_x-ww_ee66ce21
_DELAY_SIGN=0
!if [set _ASMIDTOATTRIBS_TLBIMP=]
!endif
CODESIGN_TESTKEY=
_TLBIMP_FLAGS=$(_TLBIMP_FLAGS)  /asmversion:12.4.56.0
_ASSEMBLY_IDENTITY=eventperfreporting,processorArchitecture=x86,version=12.4.56.0,publicKeyToken=neutral
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\XBLMaestro\XBLMaestro_FD\XBLMaestro_FD-PostImage\obj\i386\_generated.cs ===
[assembly:System.Runtime.InteropServices.ComVisible(false)]
[assembly:System.Reflection.AssemblyVersion("12.4.56.0")]
[assembly:System.Reflection.AssemblyProduct("Microsoft(R) Xbox(TM)")]
[assembly:System.Reflection.AssemblyCopyright("Copyright (c) Microsoft Corporation. All rights reserved.")]
[assembly:System.Reflection.AssemblyCompany("Microsoft Corporation")]
[assembly:System.Reflection.AssemblyFileVersion("12.4.56.0")]
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\XblEventPerfReporting\objd\i386\_asmid.inc ===
ASSEMBLY_IDENTITY_KEY_FORM=x86_eventperfreporting_none_12.4.56.0_none_1349fe88daabef7f
ASSEMBLY_IDENTITY_XP_KEY_FORM=x86_eventperfreporting_no-public-key_12.4.56.0_x-ww_ee66ce21
ASSEMBLY_IDENTITY_CULTURE=
ASSEMBLY_IDENTITY_NAME=eventperfreporting
ASSEMBLY_IDENTITY_PROCESSOR_ARCHITECTURE=x86
ASSEMBLY_IDENTITY_PUBLIC_KEY=
ASSEMBLY_IDENTITY_PUBLIC_KEY_TOKEN=
ASSEMBLY_IDENTITY_TYPE=
ASSEMBLY_IDENTITY_TYPE_NAME=
ASSEMBLY_IDENTITY_VERSION=12.4.56.0
XP_KEY_FORM=x86_eventperfreporting_no-public-key_12.4.56.0_x-ww_ee66ce21
XP_MANIFEST_DIRECTORY=manifests
XP_MANIFEST_NAME=x86_eventperfreporting_no-public-key_12.4.56.0_x-ww_ee66ce21.manifest
XP_MANIFEST_PATH=manifests\x86_eventperfreporting_no-public-key_12.4.56.0_x-ww_ee66ce21.manifest
XP_CATALOG_DIRECTORY=manifests
XP_CATALOG_NAME=x86_eventperfreporting_no-public-key_12.4.56.0_x-ww_ee66ce21.cat
XP_CATALOG_PATH=manifests\x86_eventperfreporting_no-public-key_12.4.56.0_x-ww_ee66ce21.cat
XP_PAYLOAD_PATH=x86_eventperfreporting_no-public-key_12.4.56.0_x-ww_ee66ce21
_DELAY_SIGN=0
!if [set _ASMIDTOATTRIBS_TLBIMP=]
!endif
CODESIGN_TESTKEY=
_TLBIMP_FLAGS=$(_TLBIMP_FLAGS)  /asmversion:12.4.56.0
_ASSEMBLY_IDENTITY=eventperfreporting,processorArchitecture=x86,version=12.4.56.0,publicKeyToken=neutral
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\XBLMaestro\XBLMaestro_FD\XBLMaestro_FD-PostImage\objd\i386\_generated.cs ===
[assembly:System.Runtime.InteropServices.ComVisible(false)]
[assembly:System.Reflection.AssemblyVersion("12.4.56.0")]
[assembly:System.Reflection.AssemblyProduct("Microsoft(R) Xbox(TM)")]
[assembly:System.Reflection.AssemblyCopyright("Copyright (c) Microsoft Corporation. All rights reserved.")]
[assembly:System.Reflection.AssemblyCompany("Microsoft Corporation")]
[assembly:System.Reflection.AssemblyFileVersion("12.4.56.0")]
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\XBLMaestro\XBLMaestro_FD\XBLMaestro_FD-PostImage\obj\i386\_asmid.inc ===
ASSEMBLY_IDENTITY_KEY_FORM=msil_xblmaestro_fd-postimage_none_12.4.56.0_none_5f84e5ddf1ffd547
ASSEMBLY_IDENTITY_XP_KEY_FORM=msil_xblmaestro_fd-postimage_no-public-key_12.4.56.0_x-ww_e4594901
ASSEMBLY_IDENTITY_CULTURE=
ASSEMBLY_IDENTITY_NAME=xblmaestro_fd-postimage
ASSEMBLY_IDENTITY_PROCESSOR_ARCHITECTURE=msil
ASSEMBLY_IDENTITY_PUBLIC_KEY=
ASSEMBLY_IDENTITY_PUBLIC_KEY_TOKEN=
ASSEMBLY_IDENTITY_TYPE=
ASSEMBLY_IDENTITY_TYPE_NAME=
ASSEMBLY_IDENTITY_VERSION=12.4.56.0
XP_KEY_FORM=msil_xblmaestro_fd-postimage_no-public-key_12.4.56.0_x-ww_e4594901
XP_MANIFEST_DIRECTORY=manifests
XP_MANIFEST_NAME=msil_xblmaestro_fd-postimage_no-public-key_12.4.56.0_x-ww_e4594901.manifest
XP_MANIFEST_PATH=manifests\msil_xblmaestro_fd-postimage_no-public-key_12.4.56.0_x-ww_e4594901.manifest
XP_CATALOG_DIRECTORY=manifests
XP_CATALOG_NAME=msil_xblmaestro_fd-postimage_no-public-key_12.4.56.0_x-ww_e4594901.cat
XP_CATALOG_PATH=manifests\msil_xblmaestro_fd-postimage_no-public-key_12.4.56.0_x-ww_e4594901.cat
XP_PAYLOAD_PATH=msil_xblmaestro_fd-postimage_no-public-key_12.4.56.0_x-ww_e4594901
_DELAY_SIGN=0
!if [set _ASMIDTOATTRIBS_TLBIMP=]
!endif
CODESIGN_TESTKEY=
_TLBIMP_FLAGS=$(_TLBIMP_FLAGS)  /asmversion:12.4.56.0
_ASSEMBLY_IDENTITY=xblmaestro_fd-postimage,processorArchitecture=msil,version=12.4.56.0,publicKeyToken=neutral
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\XBLMaestro\XBLMaestro_FD\XBLMaestro_FD-PreImage\makefile.inc ===
!include $(INETROOT)\build\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\XBLMaestro\XBLMaestro_FD\XBLMaestro_FD-PostImage\objd\i386\_asmid.inc ===
ASSEMBLY_IDENTITY_KEY_FORM=msil_xblmaestro_fd-postimage_none_12.4.56.0_none_5f84e5ddf1ffd547
ASSEMBLY_IDENTITY_XP_KEY_FORM=msil_xblmaestro_fd-postimage_no-public-key_12.4.56.0_x-ww_e4594901
ASSEMBLY_IDENTITY_CULTURE=
ASSEMBLY_IDENTITY_NAME=xblmaestro_fd-postimage
ASSEMBLY_IDENTITY_PROCESSOR_ARCHITECTURE=msil
ASSEMBLY_IDENTITY_PUBLIC_KEY=
ASSEMBLY_IDENTITY_PUBLIC_KEY_TOKEN=
ASSEMBLY_IDENTITY_TYPE=
ASSEMBLY_IDENTITY_TYPE_NAME=
ASSEMBLY_IDENTITY_VERSION=12.4.56.0
XP_KEY_FORM=msil_xblmaestro_fd-postimage_no-public-key_12.4.56.0_x-ww_e4594901
XP_MANIFEST_DIRECTORY=manifests
XP_MANIFEST_NAME=msil_xblmaestro_fd-postimage_no-public-key_12.4.56.0_x-ww_e4594901.manifest
XP_MANIFEST_PATH=manifests\msil_xblmaestro_fd-postimage_no-public-key_12.4.56.0_x-ww_e4594901.manifest
XP_CATALOG_DIRECTORY=manifests
XP_CATALOG_NAME=msil_xblmaestro_fd-postimage_no-public-key_12.4.56.0_x-ww_e4594901.cat
XP_CATALOG_PATH=manifests\msil_xblmaestro_fd-postimage_no-public-key_12.4.56.0_x-ww_e4594901.cat
XP_PAYLOAD_PATH=msil_xblmaestro_fd-postimage_no-public-key_12.4.56.0_x-ww_e4594901
_DELAY_SIGN=0
!if [set _ASMIDTOATTRIBS_TLBIMP=]
!endif
CODESIGN_TESTKEY=
_TLBIMP_FLAGS=$(_TLBIMP_FLAGS)  /asmversion:12.4.56.0
_ASSEMBLY_IDENTITY=xblmaestro_fd-postimage,processorArchitecture=msil,version=12.4.56.0,publicKeyToken=neutral
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\XBLMaestro\XBLMaestro_FD\XBLMaestro_FD-PreImage\obj\i386\_generated.cs ===
[assembly:System.Runtime.InteropServices.ComVisible(false)]
[assembly:System.Reflection.AssemblyVersion("12.4.56.0")]
[assembly:System.Reflection.AssemblyProduct("Microsoft(R) Xbox(TM)")]
[assembly:System.Reflection.AssemblyCopyright("Copyright (c) Microsoft Corporation. All rights reserved.")]
[assembly:System.Reflection.AssemblyCompany("Microsoft Corporation")]
[assembly:System.Reflection.AssemblyFileVersion("12.4.56.0")]
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\XBLMaestro\XBLMaestro_FD\XBLMaestro_FD-PreImage\objd\i386\_generated.cs ===
[assembly:System.Runtime.InteropServices.ComVisible(false)]
[assembly:System.Reflection.AssemblyVersion("12.4.56.0")]
[assembly:System.Reflection.AssemblyProduct("Microsoft(R) Xbox(TM)")]
[assembly:System.Reflection.AssemblyCopyright("Copyright (c) Microsoft Corporation. All rights reserved.")]
[assembly:System.Reflection.AssemblyCompany("Microsoft Corporation")]
[assembly:System.Reflection.AssemblyFileVersion("12.4.56.0")]
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\XBLMaestro\XBLMaestro_FD\XBLMaestro_FD-PreImage\obj\i386\_asmid.inc ===
ASSEMBLY_IDENTITY_KEY_FORM=msil_xblmaestro_fd-preimage_none_12.4.56.0_none_3c694116b3331324
ASSEMBLY_IDENTITY_XP_KEY_FORM=msil_xblmaestro_fd-preimage_no-public-key_12.4.56.0_x-ww_a0e99b78
ASSEMBLY_IDENTITY_CULTURE=
ASSEMBLY_IDENTITY_NAME=xblmaestro_fd-preimage
ASSEMBLY_IDENTITY_PROCESSOR_ARCHITECTURE=msil
ASSEMBLY_IDENTITY_PUBLIC_KEY=
ASSEMBLY_IDENTITY_PUBLIC_KEY_TOKEN=
ASSEMBLY_IDENTITY_TYPE=
ASSEMBLY_IDENTITY_TYPE_NAME=
ASSEMBLY_IDENTITY_VERSION=12.4.56.0
XP_KEY_FORM=msil_xblmaestro_fd-preimage_no-public-key_12.4.56.0_x-ww_a0e99b78
XP_MANIFEST_DIRECTORY=manifests
XP_MANIFEST_NAME=msil_xblmaestro_fd-preimage_no-public-key_12.4.56.0_x-ww_a0e99b78.manifest
XP_MANIFEST_PATH=manifests\msil_xblmaestro_fd-preimage_no-public-key_12.4.56.0_x-ww_a0e99b78.manifest
XP_CATALOG_DIRECTORY=manifests
XP_CATALOG_NAME=msil_xblmaestro_fd-preimage_no-public-key_12.4.56.0_x-ww_a0e99b78.cat
XP_CATALOG_PATH=manifests\msil_xblmaestro_fd-preimage_no-public-key_12.4.56.0_x-ww_a0e99b78.cat
XP_PAYLOAD_PATH=msil_xblmaestro_fd-preimage_no-public-key_12.4.56.0_x-ww_a0e99b78
_DELAY_SIGN=0
!if [set _ASMIDTOATTRIBS_TLBIMP=]
!endif
CODESIGN_TESTKEY=
_TLBIMP_FLAGS=$(_TLBIMP_FLAGS)  /asmversion:12.4.56.0
_ASSEMBLY_IDENTITY=xblmaestro_fd-preimage,processorArchitecture=msil,version=12.4.56.0,publicKeyToken=neutral
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\XBLMaestro\XBLMaestro_FD\XBLMaestro_FD-PreImage\objd\i386\_asmid.inc ===
ASSEMBLY_IDENTITY_KEY_FORM=msil_xblmaestro_fd-preimage_none_12.4.56.0_none_3c694116b3331324
ASSEMBLY_IDENTITY_XP_KEY_FORM=msil_xblmaestro_fd-preimage_no-public-key_12.4.56.0_x-ww_a0e99b78
ASSEMBLY_IDENTITY_CULTURE=
ASSEMBLY_IDENTITY_NAME=xblmaestro_fd-preimage
ASSEMBLY_IDENTITY_PROCESSOR_ARCHITECTURE=msil
ASSEMBLY_IDENTITY_PUBLIC_KEY=
ASSEMBLY_IDENTITY_PUBLIC_KEY_TOKEN=
ASSEMBLY_IDENTITY_TYPE=
ASSEMBLY_IDENTITY_TYPE_NAME=
ASSEMBLY_IDENTITY_VERSION=12.4.56.0
XP_KEY_FORM=msil_xblmaestro_fd-preimage_no-public-key_12.4.56.0_x-ww_a0e99b78
XP_MANIFEST_DIRECTORY=manifests
XP_MANIFEST_NAME=msil_xblmaestro_fd-preimage_no-public-key_12.4.56.0_x-ww_a0e99b78.manifest
XP_MANIFEST_PATH=manifests\msil_xblmaestro_fd-preimage_no-public-key_12.4.56.0_x-ww_a0e99b78.manifest
XP_CATALOG_DIRECTORY=manifests
XP_CATALOG_NAME=msil_xblmaestro_fd-preimage_no-public-key_12.4.56.0_x-ww_a0e99b78.cat
XP_CATALOG_PATH=manifests\msil_xblmaestro_fd-preimage_no-public-key_12.4.56.0_x-ww_a0e99b78.cat
XP_PAYLOAD_PATH=msil_xblmaestro_fd-preimage_no-public-key_12.4.56.0_x-ww_a0e99b78
_DELAY_SIGN=0
!if [set _ASMIDTOATTRIBS_TLBIMP=]
!endif
CODESIGN_TESTKEY=
_TLBIMP_FLAGS=$(_TLBIMP_FLAGS)  /asmversion:12.4.56.0
_ASSEMBLY_IDENTITY=xblmaestro_fd-preimage,processorArchitecture=msil,version=12.4.56.0,publicKeyToken=neutral
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\XBLMaestro\XBLMaestro_FD\XBLMaestro_FD-PostImage\Program.cs ===
﻿using System;
using System.Collections.Generic;
using System.Text;
using System.IO;
using System.Net;
using System.Diagnostics;
using System.Data.SqlClient;

namespace XBLMaestro_FD_PostImage
{
    class Program
    {
        private static String workingDir = @"C:\XBLMaestro\"; // !!! Hard-coded System-drive? !!!
        private static String logFile = workingDir + @"XBLMaestro_PostImage.log";
        private static String webroot = @"C:\ESP\Webroot\";
        private static String databaseMachine = "COMPNETDB";
        private static String environment = "compactnet";

        static void Main(string[] args)
        {
            try
            {
                String oldMachineName = "";
                String oldIPAddress = "";
                // Clear log file
                if (File.Exists(logFile))
                {
                    File.Delete(logFile);
                }

                // - Read Old Machine Name -
                if (!File.Exists(workingDir + "machinename.txt"))
                {
                    writeLine("ERROR: Could not read old machine name; machinename.txt does not exist");
                    return;
                }
                TextReader textRead = new StreamReader(workingDir + "machinename.txt");
                oldMachineName = textRead.ReadLine();
                oldIPAddress = textRead.ReadLine();
                textRead.Close();
                writeLine("Read Old Machine Name: " + oldMachineName);

                // Retrieve IP Address
                String hostName = Dns.GetHostName();
                writeLine("Getting IP Address for '" + hostName + "'");
                IPHostEntry ipEntry = Dns.GetHostEntry(hostName);
                IPAddress[] addr = ipEntry.AddressList;
                writeLine("IP Address '" + addr[0].ToString() + "' retrieved");
                // - Update NPDB in SQL -
                writeLine("Updating NPDB Entries...");
                updateNPDB(oldMachineName, oldIPAddress, addr[0].ToString());
                // - Update MetaBase.xml -
                writeLine("Updating IIS MetaBase file with the new IP address references");
                runProcess("iisreset", "/stop");
                replaceStringInFile(@"C:\WINDOWS\system32\inetsrv\MetaBase.xml", oldIPAddress, addr[0].ToString());
                runProcess("iisreset", "/start");

                // - re-store MasterKey -
                // !!! Needs to be runas authenticated !!!
                writeLine("Re-storing MasterKey...");
                runProcess(webroot + @"xbltools\xkeymgr", "storemk \\" + System.Environment.MachineName + @"\secure$\MasterKeyV1.prv");

                // - PropCert certificates back -
                // Remove Old Certificates
                runProcess(webroot + @"xbltools\PropCert.exe", @"/user:uodb.user /store:LocalMachine\My /remove cert.int-net.xboxlive.com");
                runProcess(webroot + @"xbltools\PropCert.exe", @"/user:uodb.user /store:LocalMachine\My /remove cert.ppe-ups");
                runProcess(webroot + @"xbltools\PropCert.exe", @"/user:uodb.user /store:LocalMachine\My /remove cert.spgclient");
                runProcess(webroot + @"xbltools\PropCert.exe", @"/user:uodb.user /store:LocalMachine\My /remove cert.XblIptvTestCA");
                runProcess(webroot + @"xbltools\PropCert.exe", @"/user:uodb.user /store:LocalMachine\My /remove idsapi.xuacs");
                runProcess(webroot + @"xbltools\PropCert.exe", @"/user:uodb.user /store:LocalMachine\My /remove rps.activeauth");
                // Add Certificates
                runProcess(webroot + @"xbltools\PropCert.exe", @"/user:uodb.user /store:LocalMachine\My cert.int-net.xboxlive.com");
                runProcess(webroot + @"xbltools\PropCert.exe", @"/user:uodb.user /store:LocalMachine\My cert.ppe-ups");
                runProcess(webroot + @"xbltools\PropCert.exe", @"/user:uodb.user /store:LocalMachine\My cert.spgclient");
                runProcess(webroot + @"xbltools\PropCert.exe", @"/user:uodb.user /store:LocalMachine\My cert.XblIptvTestCA");
                runProcess(webroot + @"xbltools\PropCert.exe", @"/user:uodb.user /store:LocalMachine\My idsapi.xuacs");
                runProcess(webroot + @"xbltools\PropCert.exe", @"/user:uodb.user /store:LocalMachine\My rps.activeauth");
            }
            catch (Exception ex)
            {
                // Quit without restarting if there was an error
                writeLine("Error during PostImage: " + ex.Message);
            }
        }

        private static string NpdbConnectionString
        {
            get
            {
                return "Data Source=" + databaseMachine + ";Initial Catalog=npdb;Trusted_Connection=yes";
            }
        }

        #region SQL Functions

        /// <summary>
        /// Updates entries in NPDB
        /// </summary>
        /// <param name="oldServerName">Old Server Name</param>
        private static void updateNPDB(String oldServer, String oldIP, String newIP)
        {
            String newServer = System.Environment.MachineName;

            writeLine("Connecting with Connection String: " + NpdbConnectionString);
            try
            {
                using (SqlConnection cxn = new SqlConnection(NpdbConnectionString))
                {
                    cxn.Open();

                    SqlCommand sqlCommand = cxn.CreateCommand();
                    runSqlCommand(sqlCommand, "USE [NPDB]");

                    // - Add new ServerName to t_servers -
                    // !!! i_server_id no longer exists !!!
                    writeLine("Adding '" + newServer + "' to t_servers");
                    runSqlCommand(sqlCommand, "INSERT INTO [t_servers] ([vc_environment], [vc_server], [i_site_id], [vc_server_state], [i_server_id]) VALUES ('{0}', '{1}', 1, 'online', 199001)", environment, newServer);

                    // - Update t_interface_buckets -
                    writeLine("Updating t_interface_buckets");
                    runSqlCommand(sqlCommand, "UPDATE [t_interface_buckets] SET [vc_server] = '{0}', [vc_next_server] = '{0}' WHERE [vc_server] = '{1}'", newServer, oldServer);

                    // - Update t_server_interfaces -
                    writeLine("Updating t_server_interfaces");
                    runSqlCommand(sqlCommand, "UPDATE [t_server_interfaces] SET [vc_server] = '{0}' WHERE [vc_server] = '{1}'", newServer, oldServer);

                    // - Update t_server_nics -
                    writeLine("Updating t_server_nics");
                    runSqlCommand(sqlCommand, "UPDATE [t_server_nics] SET [vc_server] = '{0}' WHERE [vc_server] = '{1}'", newServer, oldServer);

                    //// - Delete old ServerName from t_servers -
                    //writeLine("Deleting '" + oldServer + "' from t_servers");
                    //sqlCommand.CommandText = "DELETE FROM [t_servers] WHERE [vc_server] = '" + oldServer + "'";
                    //sqlCommand.ExecuteNonQuery();

                    // - Update t_server_nics -
                    writeLine("Updating t_server_nics");
                    runSqlCommand(sqlCommand, "UPDATE [t_server_nics] SET [vc_ip] = '{0}' WHERE [vc_ip] = '{1}'", newIP, oldIP);
                    // Not used in FD
                    //sqlCommand.CommandText = "UPDATE [t_server_nics] SET [vc_sg_ip_begin] = '" + addr[0].ToString() + "' WHERE [vc_sg_ip_begin] = '" + oldIP + "'";
                    //sqlCommand.ExecuteNonQuery();
                    //sqlCommand.CommandText = "UPDATE [t_server_nics] SET [vc_sg_ip_end] = '" + addr[0].ToString() + "' WHERE [vc_sg_ip_end] = '" + oldIP + "'";
                    //sqlCommand.ExecuteNonQuery();

                    // - Update t_site_virtual_interface_ips -
                    writeLine("Updating t_site_virtual_interface_ips");
                    // [Note: This would need to be done per virtual interface later]
                    runSqlCommand(sqlCommand, "UPDATE [t_site_virtual_interface_ips] SET [vc_ip] = '{0}' WHERE [vc_ip] = '{1}'", newIP, oldIP);

                    // - Update t_site_virtual_interface_overrides -
                    // !!! Redmond domain hard-coded !!!
                    writeLine("Updating t_site_virtual_interface_overrides");
                    runSqlCommand(sqlCommand, "UPDATE [t_site_virtual_interface_overrides] SET [vc_info1] = '{0}.redmond.corp.microsoft.com' WHERE [vc_info1] = '{1}.redmond.corp.microsoft.com'", newServer, oldServer);

                    // - Add new ServerName to t_servers_backup -
                    writeLine("Adding '" + newServer + "' to t_servers_backup");
                    runSqlCommand(sqlCommand, "INSERT INTO [t_servers_backup] ([vc_environment], [vc_server], [vc_server_type], [i_site_id], [vc_server_state], [i_server_id]) VALUES ('{0}', '{1}', 'alliis', 1, 'online', 199001)", environment, newServer);

                    // - Update t_setting_overrides -
                    writeLine("Updating t_setting_overrides");
                    runSqlCommand(sqlCommand, "UPDATE [t_setting_overrides] SET [vc_value] = '\\\\{0}\\secure$' WHERE [vc_setting] = 'setup_secureUNC'", newServer);

                    writeLine("NPDB Successfully Updated!");
                    cxn.Close();
                }
            }
            catch (Exception ex)
            {
                writeLine("NPDB Update Failed: " + ex.Message);
                throw ex;
            }
        }

        /// <summary>
        /// Runs a SQL Command and writes out to debug
        /// </summary>
        /// <param name="sqlCommand">SQL Command Object</param>
        /// <param name="command">Command String</param>
        /// <param name="args">Command String Parameters</param>
        private static void runSqlCommand(SqlCommand sqlCommand, String command, params Object[] args)
        {
            runSqlCommand(sqlCommand, String.Format(command, args));
        }

        /// <summary>
        /// Runs a SQL Command and writes out to debug
        /// </summary>
        /// <param name="sqlCommand">SQL Command Object</param>
        /// <param name="command">Command String</param>
        private static void runSqlCommand(SqlCommand sqlCommand, String command)
        {
            sqlCommand.CommandText = command;
            writeLine("\t" + command);
            sqlCommand.ExecuteNonQuery();
        }

        #endregion

        #region Utility Functions

        /// <summary>
        /// Writes to screen and logs to file
        /// </summary>
        /// <param name="output">Output String</param>
        private static void writeLine(String output)
        {
            Console.WriteLine(output);
            using (StreamWriter log = File.AppendText(logFile))
            {
                log.WriteLine(DateTime.Now + ":\t" + output);
            }
        }

        /// <summary>
        /// Replaces a string in a file with a new string
        /// </summary>
        /// <param name="filename">Filename</param>
        /// <param name="oldString">Old String Value</param>
        /// <param name="newString">New String Value</param>
        private static void replaceStringInFile(String filename, String oldString, String newString)
        {
            StreamReader streamReader = File.OpenText(filename);
            String contents = "";

            try
            {
                // Read the file into a string (Assumed to be small, text files)
                contents = streamReader.ReadToEnd();
            }
            finally
            {
                streamReader.Close();
            }

            // Overwrite the file
            StreamWriter streamWriter = File.CreateText(filename);

            try
            {
                streamWriter.Write(contents.Replace(oldString, newString));
            }
            finally
            {
                streamWriter.Close();
            }
        }

        /// <summary>
        /// Runs a process and waits for it to finish
        /// </summary>
        /// <param name="processName">Name of the process to run</param>
        /// <param name="processArguments">Arguments to pass to the process</param>
        private static void runProcess(String processName, String processArguments)
        {
            ProcessStartInfo proc = new ProcessStartInfo();
            proc.FileName = processName;
            proc.RedirectStandardInput = false;
            proc.RedirectStandardOutput = true;
            proc.Arguments = processArguments;

            proc.UseShellExecute = false; /*do not show console for the process - a must*/

            using (Process p = Process.Start(proc))
            {
                while (!p.StandardOutput.EndOfStream)
                {
                    String result = p.StandardOutput.ReadLine();
                    writeLine(result);
                }
                p.WaitForExit();
            }
        }

        #endregion
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\XBLMaestro\XBLMaestro_FD\XBLMaestro_FD-PostImage\Properties\AssemblyInfo.cs ===
﻿using System.Reflection;
using System.Runtime.CompilerServices;
using System.Runtime.InteropServices;

// General Information about an assembly is controlled through the following 
// set of attributes. Change these attribute values to modify the information
// associated with an assembly.
[assembly: AssemblyTitle("XBLMaestro_FD-PostImage")]
[assembly: AssemblyDescription("")]
[assembly: AssemblyConfiguration("")]
[assembly: AssemblyCompany("Microsoft")]
[assembly: AssemblyProduct("XBLMaestro_FD-PostImage")]
[assembly: AssemblyCopyright("Copyright © Microsoft 2008")]
[assembly: AssemblyTrademark("")]
[assembly: AssemblyCulture("")]

// Setting ComVisible to false makes the types in this assembly not visible 
// to COM components.  If you need to access a type in this assembly from 
// COM, set the ComVisible attribute to true on that type.
[assembly: ComVisible(false)]

// The following GUID is for the ID of the typelib if this project is exposed to COM
[assembly: Guid("ad9f0a3b-12db-426b-852c-e25981645374")]

// Version information for an assembly consists of the following four values:
//
//      Major Version
//      Minor Version 
//      Build Number
//      Revision
//
// You can specify all the values or you can default the Build and Revision Numbers 
// by using the '*' as shown below:
// [assembly: AssemblyVersion("1.0.*")]
[assembly: AssemblyVersion("1.0.0.0")]
[assembly: AssemblyFileVersion("1.0.0.0")]
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\xblobnuke\makefile.inc ===
!include $(INETROOT)\build\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\xblobnuke\IComponent.cs ===
using System;
using System.Collections.Generic;
using System.Text;

namespace WipeBlob
{
    public abstract class IComponent : IComparable
    {
        abstract public String Name { get; }

        abstract public void Uninstall(Boolean isForce);

        public override string ToString()
        {
            return Name;
        }

        public int CompareTo(object obj)
        {
            IComponent other = obj as IComponent;

            if (other == null)
                return -1;

            return Name.CompareTo(other.Name);
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\XBLMaestro\XBLMaestro_FD\XBLMaestro_FD-PreImage\Program.cs ===
﻿using System;
using System.Collections.Generic;
using System.Text;
using System.Xml;
using System.Xml.XPath;
using System.Diagnostics;
using System.IO;
using System.Net;

namespace XBLMaestro_FD_PreImage
{
    class Program
    {
        private static String workingDir = @"C:\XBLMaestro\"; // !!! Hard-coded System-drive? !!!
        private static String logFile = workingDir + @"XBLMaestro_PreImage.log";

        static void Main(string[] args)
        {
            // Clear log file
            if (File.Exists(logFile))
            {
                File.Delete(logFile);
            }

            // - Save Current Machine Name & IP -
            writeLine("Storing Current Machine Name: " + System.Environment.MachineName);
            TextWriter textWrite = new StreamWriter(workingDir + "machinename.txt");
            textWrite.WriteLine(System.Environment.MachineName);
            // Retrieve IP Address
            String hostName = Dns.GetHostName();
            IPHostEntry ipEntry = Dns.GetHostEntry(hostName);
            IPAddress[] addr = ipEntry.AddressList;
            writeLine("Storing IP Address '" + addr[0].ToString() + "'");
            textWrite.WriteLine(addr[0].ToString());
            textWrite.Close();
        }

        #region Utility Functions

        /// <summary>
        /// Writes to screen and logs to file
        /// </summary>
        /// <param name="output">Output String</param>
        private static void writeLine(String output)
        {
            Console.WriteLine(output);
            using (StreamWriter log = File.AppendText(logFile))
            {
                log.WriteLine(DateTime.Now + ":\t" + output);
            }
        }

        /// <summary>
        /// Runs a process and waits for it to finish
        /// </summary>
        /// <param name="processName">Name of the process to run</param>
        /// <param name="processArguments">Arguments to pass to the process</param>
        private static void runProcess(String processName, String processArguments)
        {
            ProcessStartInfo proc = new ProcessStartInfo();
            proc.FileName = processName;
            proc.RedirectStandardInput = false;
            proc.RedirectStandardOutput = true;
            proc.Arguments = processArguments;

            proc.UseShellExecute = false; /*do not show console for the process - a must*/

            using (Process p = Process.Start(proc))
            {
                while (!p.StandardOutput.EndOfStream)
                {
                    String result = p.StandardOutput.ReadLine();
                    writeLine(result);
                }
                p.WaitForExit();
            }
        }

        #endregion
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\xblobnuke\Program.cs ===
using System;
using System.Collections.Generic;
using System.Text;
using System.Windows.Forms;

namespace WipeBlob
{
    class Program
    {
        static void Main(string[] args)
        {
            Win32.FreeConsole();
            Win32.AllocConsole();

            Win32.RECT _consoleRect;
            IntPtr consoleWindow = Win32.GetConsoleWindow();
            Win32.GetWindowRect(consoleWindow, out _consoleRect);

            UninstallForm ui = new UninstallForm();
            DialogResult result = ui.ShowDialog();

            Win32.SetWindowPos(consoleWindow, IntPtr.Zero, _consoleRect.Left, _consoleRect.Top,
                _consoleRect.Right - _consoleRect.Left, _consoleRect.Bottom - _consoleRect.Top, 0x0200);

            if (result != DialogResult.OK)
                return;

            foreach (IComponent component in InstalledComponents.Uninstall)
            {
                component.Uninstall(true);
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\xblobnuke\UninstallForm.cs ===
using System;
using System.Collections.Generic;
using System.ComponentModel;
using System.Data;
using System.Drawing;
using System.Text;
using System.Windows.Forms;

namespace WipeBlob
{
    public partial class UninstallForm : Form
    {
        public UninstallForm()
        {
            InitializeComponent();
        }

        private void MoveConsoleWindow()
        {
            Win32.RECT consoleRect;
            
            IntPtr consoleWindow = Win32.GetConsoleWindow();
            Win32.GetWindowRect(consoleWindow, out consoleRect);
            Win32.SetWindowPos(consoleWindow, Handle, Left + Width, Top, consoleRect.Right - consoleRect.Left, Height, 0x0200);
            Win32.GetWindowRect(consoleWindow, out consoleRect);
            Height = consoleRect.Bottom - consoleRect.Top;
            if( !Focused )
                Focus();
        }

        private void UninstallForm_Load(object sender, EventArgs e)
        {
            WstDatabaseListBox.Sorted = true;
            MsiComponentsListBox.Sorted = true;
            
            foreach (IComponent component in InstalledComponents.Installed)
            {
                if (component is WebstoreComponent)
                {
                    WstDatabaseListBox.Items.Add(component);
                }
                if (component is MsiComponent)
                {
                    MsiComponentsListBox.Items.Add(component);
                }
                MoveConsoleWindow();
            }

            foreach (IComponent component in InstalledComponents.Uninstall)
            {
                if (component is WebstoreComponent)
                {
                    WstDatabaseListBox.SelectedItems.Add(component);
                }
                if (component is MsiComponent)
                {
                    MsiComponentsListBox.SelectedItems.Add(component);
                }
            }

        }

        private void Remove_Click(object sender, EventArgs e)
        {
            InstalledComponents.Uninstall.Clear();
            foreach (IComponent component in WstDatabaseListBox.SelectedItems)
            {
                InstalledComponents.Uninstall.Add(component);
            }
            foreach (IComponent component in MsiComponentsListBox.SelectedItems)
            {
                InstalledComponents.Uninstall.Add(component);
            }            
       }

        private void UninstallForm_Move(object sender, EventArgs e)
        {
            MoveConsoleWindow();
        }

        private void UninstallForm_Resize(object sender, EventArgs e)
        {
            MoveConsoleWindow();
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\xblobnuke\InstalledComponents.cs ===
using System;
using System.Collections.Generic;
using System.Text;

namespace WipeBlob
{
    class InstalledComponents : List<IComponent>
    {
        private static InstalledComponents _installedComponents;
        private static InstalledComponents _uninstallList;

        public static InstalledComponents Installed { get { return _installedComponents; } }
        public static InstalledComponents Uninstall { get { return _uninstallList; } }

        static InstalledComponents()
        {
            _installedComponents = new InstalledComponents();
            _uninstallList = new InstalledComponents();

            foreach (IComponent component in WebstoreComponent.GetInstalledComponents())
            {
                _installedComponents.Add(component);
                _uninstallList.Add(component);
            }

            foreach (IComponent component in MsiComponent.GetInstalledComponents())
            {
                _installedComponents.Add(component);
                if (component.Name.ToLower().StartsWith("_xbl "))
                {
                    _uninstallList.Add(component);
                }
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\XBLMaestro\XBLMaestro_FD\XBLMaestro_FD-PreImage\Properties\AssemblyInfo.cs ===
﻿using System.Reflection;
using System.Runtime.CompilerServices;
using System.Runtime.InteropServices;

// General Information about an assembly is controlled through the following 
// set of attributes. Change these attribute values to modify the information
// associated with an assembly.
[assembly: AssemblyTitle("XBLMaestro_FD-PreImage")]
[assembly: AssemblyDescription("")]
[assembly: AssemblyConfiguration("")]
[assembly: AssemblyCompany("Microsoft")]
[assembly: AssemblyProduct("XBLMaestro_FD-PreImage")]
[assembly: AssemblyCopyright("Copyright © Microsoft 2008")]
[assembly: AssemblyTrademark("")]
[assembly: AssemblyCulture("")]

// Setting ComVisible to false makes the types in this assembly not visible 
// to COM components.  If you need to access a type in this assembly from 
// COM, set the ComVisible attribute to true on that type.
[assembly: ComVisible(false)]

// The following GUID is for the ID of the typelib if this project is exposed to COM
[assembly: Guid("125a6608-ee1f-4b51-b495-a39442f9ff21")]

// Version information for an assembly consists of the following four values:
//
//      Major Version
//      Minor Version 
//      Build Number
//      Revision
//
// You can specify all the values or you can default the Build and Revision Numbers 
// by using the '*' as shown below:
// [assembly: AssemblyVersion("1.0.*")]
[assembly: AssemblyVersion("1.0.0.0")]
[assembly: AssemblyFileVersion("1.0.0.0")]
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\xblobnuke\UninstallForm.Designer.cs ===
namespace WipeBlob
{
    partial class UninstallForm
    {
        /// <summary>
        /// Required designer variable.
        /// </summary>
        private System.ComponentModel.IContainer components = null;

        /// <summary>
        /// Clean up any resources being used.
        /// </summary>
        /// <param name="disposing">true if managed resources should be disposed; otherwise, false.</param>
        protected override void Dispose(bool disposing)
        {
            if (disposing && (components != null))
            {
                components.Dispose();
            }
            base.Dispose(disposing);
        }

        #region Windows Form Designer generated code

        /// <summary>
        /// Required method for Designer support - do not modify
        /// the contents of this method with the code editor.
        /// </summary>
        private void InitializeComponent()
        {
            this.button1 = new System.Windows.Forms.Button();
            this.button2 = new System.Windows.Forms.Button();
            this.WstPanel = new System.Windows.Forms.Panel();
            this.WstDatabaseListBox = new System.Windows.Forms.ListBox();
            this.MsiPanel = new System.Windows.Forms.Panel();
            this.MsiComponentsListBox = new System.Windows.Forms.ListBox();
            this.RemovePanel = new System.Windows.Forms.Panel();
            this.Cancel = new System.Windows.Forms.Button();
            this.Remove = new System.Windows.Forms.Button();
            this.WstPanel.SuspendLayout();
            this.MsiPanel.SuspendLayout();
            this.RemovePanel.SuspendLayout();
            this.SuspendLayout();
            // 
            // button1
            // 
            this.button1.Dock = System.Windows.Forms.DockStyle.Top;
            this.button1.Location = new System.Drawing.Point(0, 0);
            this.button1.Name = "button1";
            this.button1.Size = new System.Drawing.Size(292, 23);
            this.button1.TabIndex = 0;
            this.button1.Text = "WST Databases";
            this.button1.UseVisualStyleBackColor = true;
            // 
            // button2
            // 
            this.button2.Dock = System.Windows.Forms.DockStyle.Top;
            this.button2.Location = new System.Drawing.Point(0, 0);
            this.button2.Name = "button2";
            this.button2.Size = new System.Drawing.Size(292, 23);
            this.button2.TabIndex = 0;
            this.button2.Text = "MSI Components";
            this.button2.UseVisualStyleBackColor = true;
            // 
            // WstPanel
            // 
            this.WstPanel.Controls.Add(this.WstDatabaseListBox);
            this.WstPanel.Controls.Add(this.button1);
            this.WstPanel.Dock = System.Windows.Forms.DockStyle.Top;
            this.WstPanel.Location = new System.Drawing.Point(0, 0);
            this.WstPanel.Name = "WstPanel";
            this.WstPanel.Size = new System.Drawing.Size(292, 146);
            this.WstPanel.TabIndex = 0;
            // 
            // WstDatabaseListBox
            // 
            this.WstDatabaseListBox.Dock = System.Windows.Forms.DockStyle.Fill;
            this.WstDatabaseListBox.FormattingEnabled = true;
            this.WstDatabaseListBox.IntegralHeight = false;
            this.WstDatabaseListBox.Location = new System.Drawing.Point(0, 23);
            this.WstDatabaseListBox.Name = "WstDatabaseListBox";
            this.WstDatabaseListBox.SelectionMode = System.Windows.Forms.SelectionMode.MultiExtended;
            this.WstDatabaseListBox.Size = new System.Drawing.Size(292, 123);
            this.WstDatabaseListBox.Sorted = true;
            this.WstDatabaseListBox.TabIndex = 1;
            // 
            // MsiPanel
            // 
            this.MsiPanel.Controls.Add(this.MsiComponentsListBox);
            this.MsiPanel.Controls.Add(this.button2);
            this.MsiPanel.Dock = System.Windows.Forms.DockStyle.Fill;
            this.MsiPanel.Location = new System.Drawing.Point(0, 146);
            this.MsiPanel.Name = "MsiPanel";
            this.MsiPanel.Size = new System.Drawing.Size(292, 316);
            this.MsiPanel.TabIndex = 1;
            // 
            // MsiComponentsListBox
            // 
            this.MsiComponentsListBox.Dock = System.Windows.Forms.DockStyle.Fill;
            this.MsiComponentsListBox.FormattingEnabled = true;
            this.MsiComponentsListBox.IntegralHeight = false;
            this.MsiComponentsListBox.Location = new System.Drawing.Point(0, 23);
            this.MsiComponentsListBox.Name = "MsiComponentsListBox";
            this.MsiComponentsListBox.SelectionMode = System.Windows.Forms.SelectionMode.MultiExtended;
            this.MsiComponentsListBox.Size = new System.Drawing.Size(292, 293);
            this.MsiComponentsListBox.Sorted = true;
            this.MsiComponentsListBox.TabIndex = 1;
            // 
            // RemovePanel
            // 
            this.RemovePanel.Controls.Add(this.Cancel);
            this.RemovePanel.Controls.Add(this.Remove);
            this.RemovePanel.Dock = System.Windows.Forms.DockStyle.Bottom;
            this.RemovePanel.Location = new System.Drawing.Point(0, 462);
            this.RemovePanel.Name = "RemovePanel";
            this.RemovePanel.Size = new System.Drawing.Size(292, 53);
            this.RemovePanel.TabIndex = 2;
            // 
            // Cancel
            // 
            this.Cancel.DialogResult = System.Windows.Forms.DialogResult.Cancel;
            this.Cancel.Location = new System.Drawing.Point(124, 15);
            this.Cancel.Name = "Cancel";
            this.Cancel.Size = new System.Drawing.Size(75, 23);
            this.Cancel.TabIndex = 1;
            this.Cancel.Text = "&Cancel";
            this.Cancel.UseVisualStyleBackColor = true;
            // 
            // Remove
            // 
            this.Remove.DialogResult = System.Windows.Forms.DialogResult.OK;
            this.Remove.Location = new System.Drawing.Point(205, 15);
            this.Remove.Name = "Remove";
            this.Remove.Size = new System.Drawing.Size(75, 23);
            this.Remove.TabIndex = 0;
            this.Remove.Text = "Remove";
            this.Remove.UseVisualStyleBackColor = true;
            this.Remove.Click += new System.EventHandler(this.Remove_Click);
            // 
            // UninstallForm
            // 
            this.AcceptButton = this.Remove;
            this.AutoScaleDimensions = new System.Drawing.SizeF(6F, 13F);
            this.AutoScaleMode = System.Windows.Forms.AutoScaleMode.Font;
            this.CancelButton = this.Cancel;
            this.ClientSize = new System.Drawing.Size(292, 515);
            this.Controls.Add(this.MsiPanel);
            this.Controls.Add(this.WstPanel);
            this.Controls.Add(this.RemovePanel);
            this.Name = "UninstallForm";
            this.Text = "ComponentsForm";
            this.Resize += new System.EventHandler(this.UninstallForm_Resize);
            this.Move += new System.EventHandler(this.UninstallForm_Move);
            this.Load += new System.EventHandler(this.UninstallForm_Load);
            this.WstPanel.ResumeLayout(false);
            this.MsiPanel.ResumeLayout(false);
            this.RemovePanel.ResumeLayout(false);
            this.ResumeLayout(false);

        }

        #endregion

        private System.Windows.Forms.Panel WstPanel;
        private System.Windows.Forms.ListBox WstDatabaseListBox;
        private System.Windows.Forms.Panel MsiPanel;
        private System.Windows.Forms.ListBox MsiComponentsListBox;
        private System.Windows.Forms.Panel RemovePanel;
        private System.Windows.Forms.Button Remove;
        private System.Windows.Forms.Button Cancel;
        private System.Windows.Forms.Button button1;
        private System.Windows.Forms.Button button2;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\xblobnuke\MsiComponent.cs ===
using System;
using System.Collections.Generic;
using System.Text;
using Microsoft.Win32;
using System.IO;
using System.Diagnostics;

namespace WipeBlob
{
    public class InstalledPackage
    {
        private String _guid;
        public String Guid { get { return _guid; } }

        private String _keyPath;
        public String KeyPath { get { return _keyPath; } }

        private String _subKeyName;
        public String SubKeyName { get { return _subKeyName; } }

        private String _displayName;
        public String DisplayName { get { return _displayName; } }

        private String _uninstallString;
        public String UninstallString { get { return _uninstallString; } }

        public InstalledPackage(RegistryKey uninstallSubKey)
        {
            _keyPath = uninstallSubKey.Name;
            _subKeyName = Path.GetFileName(uninstallSubKey.Name);
            _guid = _subKeyName.Substring(0, 38);
            _displayName = uninstallSubKey.GetValue("DisplayName") as String;
            if (_displayName == null || _displayName == "")
                _displayName = uninstallSubKey.GetValue("QuietDisplayName") as String;
            if (_displayName == null)
                _displayName = "";
            _uninstallString = uninstallSubKey.GetValue("UninstallString") as String;
        }

        public void Uninstall(bool isForce)
        {
            if (!_uninstallString.ToLower().StartsWith("msiexec"))
            {
                return;
            }

            Console.WriteLine("Uninstall {0}", _displayName);

            Process msiexecProcess = new Process();
            msiexecProcess.StartInfo = new ProcessStartInfo("msiexec.exe", "/passive /X" + _guid);
            msiexecProcess.StartInfo.CreateNoWindow = true;
            msiexecProcess.StartInfo.UseShellExecute = false;

            msiexecProcess.Start();
            msiexecProcess.WaitForExit();

            Console.WriteLine("Zapping {0}", _displayName);

            Process msizapProcess = new Process();
            msizapProcess.StartInfo = new ProcessStartInfo("msizap.exe", "TW! \"" + _guid + "\"");
            //msizapProcess.StartInfo.CreateNoWindow = true;
            msizapProcess.StartInfo.UseShellExecute = false;

            msizapProcess.Start();
            msizapProcess.WaitForExit();
        }
    }

    public class MsiComponent : IComponent
    {
        private string _name;
        private List<InstalledPackage> _packages;

        public MsiComponent(String name)
        {
            _name = name;
            _packages = new List<InstalledPackage>();
        }

        public void AddPackage(InstalledPackage package)
        {
            _packages.Add(package);
        }

        public override string Name
        {
            get { return _name; }
        }

        public override void Uninstall(bool isForce)
        {
            foreach (InstalledPackage package in _packages)
            {
                package.Uninstall(isForce);
            }
        }

        public static MsiComponent[] GetInstalledComponents()
        {
            return GetInstalledComponents("localhost");
        }

        public static MsiComponent[] GetInstalledComponents(String server)
        {
            RegistryKey localMachineKey = RegistryKey.OpenRemoteBaseKey(RegistryHive.LocalMachine, server);
            RegistryKey uninstallKey = localMachineKey.OpenSubKey(@"SOFTWARE\Microsoft\Windows\CurrentVersion\Uninstall");
            Dictionary<String, MsiComponent> _installedComponents;
            List<MsiComponent> _components;

            _installedComponents = new Dictionary<string, MsiComponent>();
            _components = new List<MsiComponent>();

            foreach (string subKeyName in uninstallKey.GetSubKeyNames())
            {
                if (subKeyName[0] != '{')
                    continue;

                using (RegistryKey uninstallSubKey = uninstallKey.OpenSubKey(subKeyName))
                {
                    InstalledPackage package = new InstalledPackage(uninstallSubKey);

                    if(!_installedComponents.ContainsKey(package.DisplayName))
                    {
                        _installedComponents[package.DisplayName] = new MsiComponent(package.DisplayName);
                        _components.Add(_installedComponents[package.DisplayName]);
                    }
                    _installedComponents[package.DisplayName].AddPackage(package);
                }
            }

            return _components.ToArray();
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\xblobnuke\obj\i386\_generated.cs ===
[assembly:System.Runtime.InteropServices.ComVisible(false)]
[assembly:System.Reflection.AssemblyVersion("12.4.56.0")]
[assembly:System.Reflection.AssemblyProduct("Microsoft(R) Xbox(TM)")]
[assembly:System.Reflection.AssemblyCopyright("Copyright (c) Microsoft Corporation. All rights reserved.")]
[assembly:System.Reflection.AssemblyCompany("Microsoft Corporation")]
[assembly:System.Reflection.AssemblyFileVersion("12.4.56.0")]
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\xblobnuke\objd\i386\_generated.cs ===
[assembly:System.Runtime.InteropServices.ComVisible(false)]
[assembly:System.Reflection.AssemblyVersion("12.4.56.0")]
[assembly:System.Reflection.AssemblyProduct("Microsoft(R) Xbox(TM)")]
[assembly:System.Reflection.AssemblyCopyright("Copyright (c) Microsoft Corporation. All rights reserved.")]
[assembly:System.Reflection.AssemblyCompany("Microsoft Corporation")]
[assembly:System.Reflection.AssemblyFileVersion("12.4.56.0")]
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\xboxcom\toolLib\AssemblyInfo.cs ===
using System.Reflection;
using System.Runtime.CompilerServices;

//
// General Information about an assembly is controlled through the following 
// set of attributes. Change these attribute values to modify the information
// associated with an assembly.
//
[assembly: AssemblyTitle("")]
[assembly: AssemblyDescription("")]
[assembly: AssemblyConfiguration("")]
[assembly: AssemblyCompany("")]
[assembly: AssemblyProduct("")]
[assembly: AssemblyCopyright("")]
[assembly: AssemblyTrademark("")]
[assembly: AssemblyCulture("")]		

//
// Version information for an assembly consists of the following four values:
//
//      Major Version
//      Minor Version 
//      Build Number
//      Revision
//
// You can specify all the values or you can default the Revision and Build Numbers 
// by using the '*' as shown below:

[assembly: AssemblyVersion("1.0.*")]

//
// In order to sign your assembly you must specify a key to use. Refer to the 
// Microsoft .NET Framework documentation for more information on assembly signing.
//
// Use the attributes below to control which key is used for signing. 
//
// Notes: 
//   (*) If no key is specified, the assembly is not signed.
//   (*) KeyName refers to a key that has been installed in the Crypto Service
//       Provider (CSP) on your machine. KeyFile refers to a file which contains
//       a key.
//   (*) If the KeyFile and the KeyName values are both specified, the 
//       following processing occurs:
//       (1) If the KeyName can be found in the CSP, that key is used.
//       (2) If the KeyName does not exist and the KeyFile does exist, the key 
//           in the KeyFile is installed into the CSP and used.
//   (*) In order to create a KeyFile, you can use the sn.exe (Strong Name) utility.
//       When specifying the KeyFile, the location of the KeyFile should be
//       relative to the project output directory which is
//       %Project Directory%\obj\<configuration>. For example, if your KeyFile is
//       located in the project directory, you would specify the AssemblyKeyFile 
//       attribute as [assembly: AssemblyKeyFile("..\\..\\mykey.snk")]
//   (*) Delay Signing is an advanced option - see the Microsoft .NET Framework
//       documentation for more information on this.
//
[assembly: AssemblyDelaySign(false)]
[assembly: AssemblyKeyFile("")]
[assembly: AssemblyKeyName("")]
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\xblobnuke\Win32.cs ===
using System;
using System.Collections.Generic;
using System.Text;
using System.Runtime.InteropServices;

namespace WipeBlob
{
    public static class Win32
    {
        [DllImport("kernel32.dll")]
        public static extern IntPtr GetConsoleWindow();

        [DllImport("user32.dll", SetLastError = true)]
        public static extern bool SetWindowPos(IntPtr hwnd, IntPtr hwnd2, int x, int y, int cx, int cy, int uFlags);

        [StructLayout(LayoutKind.Sequential)]
        public struct RECT
        {
            public int Left;
            public int Top;
            public int Right;
            public int Bottom;
        }

        [DllImport("user32.dll")]
        [return: MarshalAs(UnmanagedType.Bool)]
        public static extern bool GetWindowRect(IntPtr hWnd, out RECT lpRect);

        [DllImport("kernel32.dll", SetLastError = true, ExactSpelling = true)]
        public static extern bool AllocConsole();

        [DllImport("kernel32.dll", SetLastError = true, ExactSpelling = true)]
        public static extern bool FreeConsole();
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\xblobnuke\obj\i386\_asmid.inc ===
ASSEMBLY_IDENTITY_KEY_FORM=msil_xblobnuke_none_12.4.56.0_none_44f94c818e4a933f
ASSEMBLY_IDENTITY_XP_KEY_FORM=msil_xblobnuke_no-public-key_12.4.56.0_x-ww_b6ceb099
ASSEMBLY_IDENTITY_CULTURE=
ASSEMBLY_IDENTITY_NAME=xblobnuke
ASSEMBLY_IDENTITY_PROCESSOR_ARCHITECTURE=msil
ASSEMBLY_IDENTITY_PUBLIC_KEY=
ASSEMBLY_IDENTITY_PUBLIC_KEY_TOKEN=
ASSEMBLY_IDENTITY_TYPE=
ASSEMBLY_IDENTITY_TYPE_NAME=
ASSEMBLY_IDENTITY_VERSION=12.4.56.0
XP_KEY_FORM=msil_xblobnuke_no-public-key_12.4.56.0_x-ww_b6ceb099
XP_MANIFEST_DIRECTORY=manifests
XP_MANIFEST_NAME=msil_xblobnuke_no-public-key_12.4.56.0_x-ww_b6ceb099.manifest
XP_MANIFEST_PATH=manifests\msil_xblobnuke_no-public-key_12.4.56.0_x-ww_b6ceb099.manifest
XP_CATALOG_DIRECTORY=manifests
XP_CATALOG_NAME=msil_xblobnuke_no-public-key_12.4.56.0_x-ww_b6ceb099.cat
XP_CATALOG_PATH=manifests\msil_xblobnuke_no-public-key_12.4.56.0_x-ww_b6ceb099.cat
XP_PAYLOAD_PATH=msil_xblobnuke_no-public-key_12.4.56.0_x-ww_b6ceb099
_DELAY_SIGN=0
!if [set _ASMIDTOATTRIBS_TLBIMP=]
!endif
CODESIGN_TESTKEY=
_TLBIMP_FLAGS=$(_TLBIMP_FLAGS)  /asmversion:12.4.56.0
_ASSEMBLY_IDENTITY=xblobnuke,processorArchitecture=msil,version=12.4.56.0,publicKeyToken=neutral
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\xblobnuke\objd\i386\_asmid.inc ===
ASSEMBLY_IDENTITY_KEY_FORM=msil_xblobnuke_none_12.4.56.0_none_44f94c818e4a933f
ASSEMBLY_IDENTITY_XP_KEY_FORM=msil_xblobnuke_no-public-key_12.4.56.0_x-ww_b6ceb099
ASSEMBLY_IDENTITY_CULTURE=
ASSEMBLY_IDENTITY_NAME=xblobnuke
ASSEMBLY_IDENTITY_PROCESSOR_ARCHITECTURE=msil
ASSEMBLY_IDENTITY_PUBLIC_KEY=
ASSEMBLY_IDENTITY_PUBLIC_KEY_TOKEN=
ASSEMBLY_IDENTITY_TYPE=
ASSEMBLY_IDENTITY_TYPE_NAME=
ASSEMBLY_IDENTITY_VERSION=12.4.56.0
XP_KEY_FORM=msil_xblobnuke_no-public-key_12.4.56.0_x-ww_b6ceb099
XP_MANIFEST_DIRECTORY=manifests
XP_MANIFEST_NAME=msil_xblobnuke_no-public-key_12.4.56.0_x-ww_b6ceb099.manifest
XP_MANIFEST_PATH=manifests\msil_xblobnuke_no-public-key_12.4.56.0_x-ww_b6ceb099.manifest
XP_CATALOG_DIRECTORY=manifests
XP_CATALOG_NAME=msil_xblobnuke_no-public-key_12.4.56.0_x-ww_b6ceb099.cat
XP_CATALOG_PATH=manifests\msil_xblobnuke_no-public-key_12.4.56.0_x-ww_b6ceb099.cat
XP_PAYLOAD_PATH=msil_xblobnuke_no-public-key_12.4.56.0_x-ww_b6ceb099
_DELAY_SIGN=0
!if [set _ASMIDTOATTRIBS_TLBIMP=]
!endif
CODESIGN_TESTKEY=
_TLBIMP_FLAGS=$(_TLBIMP_FLAGS)  /asmversion:12.4.56.0
_ASSEMBLY_IDENTITY=xblobnuke,processorArchitecture=msil,version=12.4.56.0,publicKeyToken=neutral
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\xblobnuke\WebstoreComponent.cs ===
using System;
using System.Collections.Generic;
using System.Text;
using Microsoft.Webstore.MetaData;
using Microsoft.Webstore.Management.Wmo;
using Microsoft.SqlServer.Management.Smo;

namespace WipeBlob
{
    class WebstoreComponent : IComponent
    {
        private string deploymentName;

        public WebstoreComponent(string name)
        {
            deploymentName = name;
        }

        public override string Name
        {
            get { return deploymentName; }
        }

        public override void Uninstall(bool isForce)
        {
            List<String> purgeList = new List<String>();
            WebstoreDeployment deployment = WebstoreMetaData.Instance.DefaultConfig.Deployments[deploymentName];

            foreach (WebstoreSQLFss fss in deployment.SQLFailSafeSets)
            {
                foreach (WebstoreDatabase database in fss.Databases)
                {
                    purgeList.Add(database.Name + "@" + database.ServerName);
                }
            }

            WmoCommandDeployment wmoDeployment = new WmoCommandDeployment();

            Console.WriteLine("Removing deployment: " + deploymentName);
            wmoDeployment.DeploymentName = deploymentName;
            wmoDeployment.IsForce = isForce;
            wmoDeployment.IsReplTearDown = true;
            wmoDeployment.IsRollingUpgrade = false;
            wmoDeployment.Drop();

            Console.WriteLine("Purging manifest");
            WmoCommandManifest wmoManifest = new WmoCommandManifest();
            wmoManifest.Purge();

            Console.WriteLine("Purging template");
            WmoCommandDatabaseTemplate wmoTemplate = new WmoCommandDatabaseTemplate();
            wmoTemplate.Purge();

            Console.WriteLine("Dropping databases");
            foreach (String database in purgeList)
            {
                String[] dbInfo = database.Split('@');
                Server s = new Server(dbInfo[1]);

                if (s.Databases.Contains(dbInfo[0]))
                {
                    s.Databases["master"].ExecuteNonQuery(
                        string.Format("ALTER DATABASE {0} SET SINGLE_USER with ROLLBACK IMMEDIATE",
                                      dbInfo[0]));
                    s.Databases[dbInfo[0]].Drop();
                }
            }
        }

        public static WebstoreComponent[] GetInstalledComponents()
        {
            WmoCommandDeployment wmoDeployment = new WmoCommandDeployment();
            WebstoreConfig defaultConfig = WebstoreMetaData.Instance.DefaultConfig;
            List<WebstoreComponent> deployments = new List<WebstoreComponent>();

            foreach (WebstoreDeployment deployment in defaultConfig.Deployments)
            {
                if (deployment.Name != "WstConfig")
                {
                    deployments.Add(new WebstoreComponent(deployment.Name));
                }
            }
            return deployments.ToArray();
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\xboxcom\toolLib\Dirlist.cs ===
using System;
using System.Collections;

namespace xonline.tools.xboxcom.toollib
{
	public class DirectoryEnumerator : IEnumerator
	{
		protected string _startPath;
		protected Stack _dirStack = null;
		protected string[] _currentFilenames = null;
		protected int _currentFileIndex = 0;

		public DirectoryEnumerator(string path)
		{
			_startPath = path;
			char lastCh = _startPath[_startPath.Length-1];
			if (lastCh!='/' && lastCh!='\\')
			{
				_startPath = _startPath+"/";
			}

			Reset();
		}

		public void Reset()
		{
			_currentFilenames = null;
			_currentFileIndex = 0;
			_dirStack = new Stack();
			_dirStack.Push(_startPath);
		}

		public Object Current
		{
			get
			{
				return _currentFilenames[_currentFileIndex].Substring(_startPath.Length);
			}
		}

		public bool MoveNext()
		{
			if (_currentFilenames!=null && _currentFileIndex+1 < _currentFilenames.GetLength(0))
			{
				_currentFileIndex++;
				return true;
			}

			do 
			{
				if (_dirStack.Count==0)
				{
					return false;
				}

				string path = (string)_dirStack.Pop();

				string[] dirList = System.IO.Directory.GetDirectories(path);
				for (int i=dirList.Length; --i>=0; )
				{
					_dirStack.Push(dirList[i]);
				}

				_currentFilenames = System.IO.Directory.GetFiles(path);
				_currentFileIndex = 0;

			} while (_currentFilenames.GetLength(0)==0);

			return true;
		}
	}

	public class DirectoryListing : IEnumerable
	{
		private DirectoryEnumerator _dirWalker = null;

		public DirectoryListing(string path)
		{
			_dirWalker = new DirectoryEnumerator(path);
		}

		public IEnumerator GetEnumerator()
		{
			return _dirWalker;
		}
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\xboxcom\XmlToCms\console\makefile.inc ===
!include $(INETROOT)\build\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\xboxcom\toolLib\htmlUtl.cs ===
using System;
using System.Xml;
using System.Collections;


namespace xonline.tools.xboxcom.toollib
{

    public class HtmlUtl
    {
        /// <summary>
        ///     Escape/Unescape text for body of a CDATA element.
        ///     
        ///     "]]" is the only thing banned in a CDATA section because
        ///     it means the end of the CDATA. This happens when the text
        ///     itself is Html and has CDATA elements. Escaping means
        ///     replacing ']' with '' (unicode char 0x00BB, or {0xC2 0xBB}
        ///     in utf8 encoded files).
        /// </summary>
        
        private static readonly char CdataEsc = '\uF001';
        private static readonly char CdataCloseEsc = '\u00BB';
        private static readonly char CdataClose = ']';


        /// <summary>
        /// EscapeXmlForCData: convert ] => \u00BB,
        ///   and in the extremely unlikely event when source had
        ///   \u00BB in its text, they are converted to \uFF01\u00BB
        ///   Meanwhile, existing \uFF01 also has to be escaped to
        ///   \uF001\uF001.
        /// </summary>
        /// <param name="xmlSrc"></param>
        /// <returns></returns>
        public static string EscapeXmlForCData(string xmlSrc)
        {
            char[] src = xmlSrc.ToCharArray();
            System.IO.StringWriter writer = new System.IO.StringWriter();

            for (int i=0; i<src.Length; i++)
            {
                char ch = src[i];
                if (ch==CdataClose)
                {
                    ch=CdataCloseEsc;
                }
                else if (ch==CdataEsc || ch==CdataCloseEsc)
                {
                    writer.Write( CdataEsc );
                }

                writer.Write(ch);
            }

            return writer.GetStringBuilder().ToString();
        }


        /// <summary>
        /// UnescapeCDataToXml: convert
        ///     \uF0BB => \
        ///     \uF001\u00BB => \u00BB
        ///     \uF001\uF001 => \uF001
        /// </summary>
        /// <param name="cdata"></param>
        /// <returns></returns>
        public static string UnescapeCDataToXml(string cdata)
        {
            char[] src = cdata.ToCharArray();
            System.IO.StringWriter writer = new System.IO.StringWriter();

            for (int i=0; i<src.Length; i++)
            {
                if (src[i]==CdataEsc)
                {
                    i++;
                    writer.Write( src[i] );
                }
                else if (src[i]==CdataCloseEsc)
                {
                    writer.Write( CdataClose );
                }
                else
                {
                    writer.Write( src[i] );
                }
            }

            return writer.GetStringBuilder().ToString();
        }


        /// <summary>
        ///     Format source Html text into uniform format - Each tag on its own line.
        ///     Useful when preparing a document for windiff.
        /// </summary>
        /// <param name="html">the source Html text</param>
        /// <returns>the formatted Html text</returns>
        public static string HtmlSingleLine(string html)
        {
            System.IO.StringWriter dest = new System.IO.StringWriter();
            System.IO.StringReader src = new System.IO.StringReader(html);

            char ch = ' ';
            char lastCh;
            int intCh;
            bool newLine=true;

            while (-1!=(intCh=src.Read()))
            {
                lastCh = ch;
                ch = (char)intCh;
                if (ch<=' ')
                {
                    ch=' ';
                    if (lastCh==' ') continue;
                }

                if (ch=='<' && !newLine)
                {
                    newLine=true;
                    dest.WriteLine();
                }

                dest.Write(ch);
                newLine=false;
                
                if (ch=='>' && !newLine)
                {
                    newLine=true;
                    dest.WriteLine();
                    ch=' ';
                }
            }

            return dest.GetStringBuilder().ToString();
        }

        /* obsolete Html cleanup code
         * 
        enum ParseState 
        {
            PS_Text,
            PS_TagName,
            PS_TagAttr,
            PS_AttrValueEndOnSpace,
            PS_AttrValueEndOnDQ,
            PS_AttrValueEndOnSQ
        }

        class TagDef
        {
            public bool block;
            public bool close;
            public string name;
            public string comment;
            public int count;

            public TagDef(int block0, int close0, string name0, string comment0)
            {
                block=(block0!=0);
                close=(close0!=0);
                name=name0.ToLower();
                comment=comment0;
                count=0;
            }
        }

        public static bool allowAddRemoveTags = true;

        private static TagDef[] tagTable = new TagDef
            [] {
                   new TagDef(0, 0, "A",     "anchor"),
                   new TagDef(0, 0, "ABBR",  "abbreviated form (e.g., WWW, HTTP, etc.)"),
                   new TagDef(0, 0, "ACRONYM",  ""),
                   new TagDef(1, 0, "ADDRESS",   "information on author"),
                   new TagDef(0, 1, "AREA",  "client-side image map area"),
                   new TagDef(0, 0, "B",     "bold text style"),
                   new TagDef(0, 1, "BASE",  "document base URI"),
                   new TagDef(0, 0, "BDO",   "I18N BiDi over-ride"),
                   new TagDef(0, 0, "BIG",   "large text style"),
                   new TagDef(1, 0, "BLOCKQUOTE",    "long quotation"),
                   new TagDef(0, 0, "BODY",  "document body"),
                   new TagDef(0, 1, "BR",    "forced line break"),
                   new TagDef(0, 0, "BUTTON",    "push button"),
                   new TagDef(0, 0, "CAPTION",   "table caption"),
                   new TagDef(0, 0, "CITE",  "citation"),
                   new TagDef(0, 0, "CODE",  "computer code fragment"),
                   new TagDef(0, 1, "COL",   "table column"),
                   new TagDef(0, 0, "COLGROUP",  "table column group"),
                   new TagDef(2, 0, "DD",    "definition description"),
                   new TagDef(0, 0, "DEL",   "deleted text"),
                   new TagDef(0, 0, "DFN",   "instance definition"),
                   new TagDef(0, 0, "DIV",   "generic language/style container"),
                   new TagDef(1, 0, "DL",    "definition list"),
                   new TagDef(2, 0, "DT",    "definition term"),
                   new TagDef(0, 0, "EM",    "emphasis"),
                   new TagDef(1, 0, "FIELDSET",  "form control group"),
                   new TagDef(0, 0, "FONT",  "local change to font"),
                   new TagDef(1, 0, "FORM",  "interactive form"),
                   new TagDef(0, 1, "FRAME",     "subwindow"),
                   new TagDef(2, 0, "FRAMESET",  "window subdivision"),
                   new TagDef(1, 0, "H1",    "heading"),
                   new TagDef(1, 0, "H2",    "heading"),
                   new TagDef(1, 0, "H3",    "heading"),
                   new TagDef(1, 0, "H4",    "heading"),
                   new TagDef(1, 0, "H5",    "heading"),
                   new TagDef(1, 0, "H6",    "heading"),
                   new TagDef(0, 0, "HEAD",  "document head"),
                   new TagDef(1, 1, "HR",    "horizontal rule"),
                   new TagDef(0, 0, "HTML",  "document root element"),
                   new TagDef(0, 0, "I",     "italic text style"),
                   new TagDef(0, 0, "IFRAME",    "inline subwindow"),
                   new TagDef(0, 1, "IMG",   "Embedded image"),
                   new TagDef(0, 1, "INPUT",     "form control"),
                   new TagDef(0, 0, "INS",   "inserted text"),
                   new TagDef(0, 0, "KBD",   "text to be entered by the user"),
                   new TagDef(0, 0, "LABEL",     "form field label text"),
                   new TagDef(0, 0, "LEGEND",    "fieldset legend"),
                   new TagDef(2, 0, "LI",    "list item"),
                   new TagDef(0, 1, "LINK",  "a media-independent link"),
                   new TagDef(0, 0, "MAP",   "client-side image map"),
                   new TagDef(0, 1, "META",  "generic metainformation"),
                   new TagDef(1, 0, "NOFRAMES",  "alternate content container for non frame-based rendering"),
                   new TagDef(1, 0, "NOSCRIPT",  "alternate content container for non script-based rendering"),
                   new TagDef(0, 0, "OBJECT",    "generic embedded object"),
                   new TagDef(1, 0, "OL",    "ordered list"),
                   new TagDef(0, 0, "OPTGROUP",  "option group"),
                   new TagDef(0, 0, "OPTION",    "selectable choice"),
                   new TagDef(1, 0, "P",     "paragraph"),
                   new TagDef(0, 1, "PARAM",     "named property value"),
                   new TagDef(1, 0, "PRE",   "preformatted text"),
                   new TagDef(0, 0, "Q",     "short inline quotation"),
                   new TagDef(0, 0, "SAMP",  "sample program output, scripts, etc."),
                   new TagDef(0, 0, "SCRIPT",    "script statements"),
                   new TagDef(0, 0, "SELECT",    "option selector"),
                   new TagDef(0, 0, "SMALL",     "small text style"),
                   new TagDef(0, 0, "SPAN",  "generic language/style container"),
                   new TagDef(0, 0, "STRONG",    "strong emphasis"),
                   new TagDef(0, 0, "STYLE",     "style info"),
                   new TagDef(0, 0, "SUB",   "subscript"),
                   new TagDef(0, 0, "SUP",   "superscript"),
                   new TagDef(1, 0, "TABLE",    ""),
                   new TagDef(2, 0, "TBODY",     "table body"),
                   new TagDef(2, 0, "TD",    "table data cell"),
                   new TagDef(0, 0, "TEXTAREA",  "multi-line text field"),
                   new TagDef(2, 0, "TFOOT",     "table footer"),
                   new TagDef(2, 0, "TH",    "table header cell"),
                   new TagDef(2, 0, "THEAD",     "table header"),
                   new TagDef(0, 0, "TITLE",     "document title"),
                   new TagDef(2, 0, "TR",    "table row"),
                   new TagDef(0, 0, "TT",    "teletype or monospaced text style"),
                   new TagDef(1, 0, "UL",    "underlined text style"),
                   new TagDef(0, 0, "U",     "unordered list"),
                   new TagDef(0, 0, "VAR",   "instance of a variable or program argument")
               };

        private static TagDef LookupTag(string tag)
        {
            for (int i=0; i<tagTable.Length; i++)
            {
                if (tagTable[i].name == tag) return tagTable[i];
            }
            return new TagDef(0, 0, tag, "unknown");
        }

        public static string XhtmlFromHtml(string html)
        {
            System.IO.StringWriter xhtml = new System.IO.StringWriter();
            System.IO.StringReader src = new System.IO.StringReader(html);
            ParseState state=ParseState.PS_Text;
            char[] tagName = new char[50];
            int iTag = 0;
            bool closingTag = false;
            bool emptyNodeByModel = false;
            string [] nestingTags = new string[50];
            int iNestingLevel = 0;

            char ch=' ';
            char lastCh;
            int intCh;
            while (-1!=(intCh=src.Read()))
            {
                lastCh = ch;
                ch = (char)intCh;

                switch (state)
                {
                    case ParseState.PS_Text:
                        if (ch=='<') 
                        {
                            // entering a tag
                            state = ParseState.PS_TagName;
                            iTag = 0;

                            lastCh = ch;
                            ch = (char)src.Read();
                            if (ch=='/')
                            {
                                closingTag = true;
                                break;
                            }
                            else
                            {
                                closingTag = false;
                                goto case ParseState.PS_TagName;
                            }
                        }
                        else
                        {
                            xhtml.Write(ch);
                            break;
                        }

                    case ParseState.PS_TagName:
                        if (char.IsLetterOrDigit(ch) || ch=='?' || ch==':')
                        {
                            ch = char.ToLower(ch);
                            tagName[iTag++] = ch;
                            break;
                        }
                        else
                        {
                            // end of a tag name
                            string tag = new string(tagName, 0, iTag);
                            iTag = 0;
                            TagDef def = LookupTag(tag);
                            def.count++;

                            if (closingTag)
                            {
                                if (ch!='>') 
                                {
                                    // not expecting attributes in closing tag
                                    throw new System.ApplicationException();
                                }

                                bool skipClosingTag = false;

                                if (iNestingLevel==0)
                                {
                                    skipClosingTag = true;;
                                }
                                else if (nestingTags[iNestingLevel-1] != tag)
                                {
                                    skipClosingTag = true;;
                                }

                                if (!skipClosingTag)
                                {
                                    xhtml.Write("</" + tag + ">");
                                    iNestingLevel--;
                                }
                                else if (!allowAddRemoveTags)
                                {
                                    xhtml.Write("</" + tag + ">");
                                }
                                else
                                {
                                    Console.WriteLine("- unmatched closing tag </{0}>!!", tag);
                                }

                                state = ParseState.PS_Text;
                                break;
                            }
                            else
                            {
                                if (def.block && allowAddRemoveTags)
                                {
                                    while (iNestingLevel>0)
                                    {
                                        string lastTag = nestingTags[iNestingLevel-1];
                                        TagDef defLast = LookupTag(lastTag);

                                        // close li tag upon block elements
                                        if (lastTag=="li")
                                        {
                                            goto CloseATag;
                                        }

                                        // only allow li elements inside ul element
                                        if (lastTag=="ul")
                                        {
                                            if (tag!="li")
                                            {
                                                goto CloseATag;
                                            }
                                        }

                                        // close previous p tag upon block elements
                                        int i;
                                        for (i=iNestingLevel; --i>=0;)
                                        {
                                            if (nestingTags[i]=="p") goto CloseATag;
                                        }

                                        // passed all checks
                                        break;

                                    CloseATag:
                                        // need to close previous tag
                                        xhtml.Write("</" + lastTag + ">");
                                        Console.WriteLine("+ missing closing tag </{0}>", lastTag);
                                        iNestingLevel--;
                                    }
                                }

                                xhtml.Write("<" + tag);
                                nestingTags[iNestingLevel++] = tag;

                                if (def.close)
                                {
                                    emptyNodeByModel = true;
                                }
                                else
                                {
                                    emptyNodeByModel = false;
                                }

                                state = ParseState.PS_TagAttr;
                                goto case ParseState.PS_TagAttr;
                            }
                        }

                    case ParseState.PS_TagAttr:
                        if (ch=='=')
                        {
                            // entering attribute value

                            xhtml.Write(ch);
                            xhtml.Write('"');
                            lastCh = ch;
                            do 
                            {
                                ch = (char)src.Read();
                            } while (ch==' ');

                            if (ch=='"')
                            {
                                state = ParseState.PS_AttrValueEndOnDQ;
                            }
                            else if (ch=='\'')
                            {
                                state = ParseState.PS_AttrValueEndOnSQ;
                            }
                            else
                            {
                                xhtml.Write(ch);
                                state = ParseState.PS_AttrValueEndOnSpace;
                            }
                        }
                        else if (ch=='>')
                        {
                            // leaving tag

                            if (emptyNodeByModel && lastCh!='/')
                            {
                                if (lastCh>' ')
                                {
                                    xhtml.Write(' ');
                                }

                                xhtml.Write('/');
                                lastCh = '/';
                            }

                            if (lastCh=='/')
                            {
                                iNestingLevel--;
                            }

                            xhtml.Write(ch);

                            state = ParseState.PS_Text;
                        }
                        else
                        {
                            ch = char.ToLower(ch);
                            xhtml.Write(ch);
                        }
                        break;

                    case ParseState.PS_AttrValueEndOnDQ:
                        if (ch=='"')
                        {
                            xhtml.Write('"');
                            state = ParseState.PS_TagAttr;
                        }
                        else
                        {
                            xhtml.Write(ch);
                        }
                        break;

                    case ParseState.PS_AttrValueEndOnSQ:
                        if (ch=='\'')
                        {
                            xhtml.Write('"');
                            state = ParseState.PS_TagAttr;
                        }
                        else
                        {
                            xhtml.Write(ch);
                        }
                        break;

                    case ParseState.PS_AttrValueEndOnSpace:
                        if (ch<=' ')  // white space, tab, LF, CR, or other control char
                        {
                            xhtml.Write('"');
                            xhtml.Write(' ');
                            state = ParseState.PS_TagAttr;
                        }
                        else
                        {
                            xhtml.Write(ch);
                        }
                        break;
                }
            }

            while (iNestingLevel>0 && allowAddRemoveTags)
            {
                string tag = nestingTags[--iNestingLevel];
                xhtml.Write("</" + tag + ">");
                Console.WriteLine("+ missing closing tag </{0}> at eof", tag);
            }

            return xhtml.GetStringBuilder().ToString();
        }
        */
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\xboxcom\toolLib\CommandLineOptions.cs ===
using System;
using System.Collections;

namespace xonline.tools.xboxcom.toollib
{
    /// <summary>
    ///		command-line options parser
    ///		see SimpleIoOptions for sample implementation
    /// </summary>
    public abstract class CmdOptions
    {
        /// <summary>
        ///		ParseCommandLine
        /// </summary>
        /// <param name="commandLine">the args from Main</param>
        public void ParseCommandLine(string[] commandLine)
        {
            for (int i=0; i<commandLine.Length; i++)
            {
                string keyword = commandLine[i];
                string val = null;

                if (keyword[0]=='/' || keyword[0]=='-')
                {
                    keyword = keyword.Substring(1);

					if (i+1==commandLine.Length) 
					{
						val = null;
					}
					else if (commandLine[i+1][0]=='-' || commandLine[i+1][0]=='/')
					{
						val = null;
					}
					else
                    {
						i++;
                        val = commandLine[i];
                    }
                }
                else
                {
                    val = keyword;
                    keyword = "";
                }

                ProcessOption(keyword, val);
            }

            OnEndOfCommandLine();
        }

        protected void SetStringOptionValue(ref string var, string val, string def)
        {
            if (var!=null)
            {
				PrintHelp();
				throw new DuplicateOptionsException();
            }
            if (val==null)
            {
                if (def==null)
                {
					PrintHelp();
					throw new MissingValueException();
                }
                val = def;
            }
            var = val;
        }

        //
        // functions to be implemented by subclasses
        //

		protected virtual void ProcessOption(string name, string val)
		{
			if (name=="?")
			{
				PrintHelp();
				throw new EndProcessException();
			}
			else
			{
				PrintHelp();
				throw new BadOptionsException();
			}
		}

        protected abstract void OnEndOfCommandLine();
        protected abstract void PrintHelp();


		public class EndProcessException : System.Exception
		{
		}

		public class BadOptionsException : System.Exception
		{
		}

		public class DuplicateOptionsException : BadOptionsException
		{
		}

		public class MissingValueException : BadOptionsException
		{
		}

		public class MissingOptionsException: BadOptionsException
		{
		}
	}


    /// <summary>
    ///		simple command line option parser that supports -i and -o switches.
    ///		uses stdin/stdout if either switch is missing.
    ///		parse command line in constructor. then use input, output properties
    ///		to access the IO data stream. use inputPath, outputPath to access
    ///		the path to the files.
    /// </summary>
    public class SimpleIoCmdOptions : CmdOptions
    {
        /// <summary>
        ///		constructor
        /// </summary>
        /// <param name="args">the args from Main</param>
        /// <param name="ioEncoding">the encoding for input/output files</param>
        public SimpleIoCmdOptions(string[] args, System.Text.Encoding ioEncoding)
        {
            _inputEncoding = ioEncoding;
            _outputEncoding = ioEncoding;
            ParseCommandLine(args);
        }

        //
        // option value: input stream
        //
        protected System.IO.TextReader _inputStream = null;
        public System.IO.TextReader input
        {
            get 
            {
                return _inputStream;
            }
        }

        //
        // option value: input path (or stdin)
        //
        protected string _inputPath = null;
        public string inputPath
        {
            get 
            {
                return _inputPath;
            }
        }

        //
        // option value: output stream
        //
        protected System.IO.TextWriter _outputStream = null;
        public System.IO.TextWriter output
        {
            get 
            {
                return _outputStream;
            }
        }

        //
        // option value: output file path (or stdout)
        //
        protected string _outputPath = null;
        public string outputPath
        {
            get
            {
                return _outputPath;
            }
        }


        //
        // help text
        //
        protected override void PrintHelp()
        {
            Console.Write("usage: {0}", System.Reflection.Assembly.GetEntryAssembly().GetName().Name);

            Console.Write(" -i infile");
            Console.Write(" -o outfile");

            Console.WriteLine();
        }


        //
        // handle option name/value pairs
        //
        protected override void ProcessOption(string name, string val)
        {
            switch (name)
            {
                case "":
                    // nameless option default to input file
                    goto case "i";

                case "i":
                    SetStringOptionValue( ref _inputPath, val, null );
                    break;

                case "o":
                    SetStringOptionValue( ref _outputPath, val, null );
                    break;

                default:
					base.ProcessOption(name, val);
                    break;
            }
        }


        protected override void OnEndOfCommandLine()
        {
            if (_inputPath==null) 
            {
                _inputStream = Console.In;
                _inputPath = "stdin";
            }
            else
            {
                _inputStream = new System.IO.StreamReader(_inputPath, _inputEncoding);
            }

            if (_outputPath==null) 
            {
                _outputStream = Console.Out;
                _outputPath = "stdout";
            }
            else
            {
                _outputStream = new System.IO.StreamWriter(_outputPath, false, _outputEncoding);
            }
        }


        //
        // text file encoding
        //
        protected System.Text.Encoding _inputEncoding;
        protected System.Text.Encoding _outputEncoding;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\xboxcom\XmlToCms\winform\makefile.inc ===
!include $(INETROOT)\build\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\xboxcomData\XboxComDataDump\AssemblyInfo.cs ===
using System.Reflection;
using System.Runtime.CompilerServices;

//
// General Information about an assembly is controlled through the following 
// set of attributes. Change these attribute values to modify the information
// associated with an assembly.
//
[assembly: AssemblyTitle("")]
[assembly: AssemblyDescription("")]
[assembly: AssemblyConfiguration("")]
[assembly: AssemblyCompany("")]
[assembly: AssemblyProduct("")]
[assembly: AssemblyCopyright("")]
[assembly: AssemblyTrademark("")]
[assembly: AssemblyCulture("")]		

//
// Version information for an assembly consists of the following four values:
//
//      Major Version
//      Minor Version 
//      Build Number
//      Revision
//
// You can specify all the values or you can default the Revision and Build Numbers 
// by using the '*' as shown below:

[assembly: AssemblyVersion("1.0.*")]

//
// In order to sign your assembly you must specify a key to use. Refer to the 
// Microsoft .NET Framework documentation for more information on assembly signing.
//
// Use the attributes below to control which key is used for signing. 
//
// Notes: 
//   (*) If no key is specified, the assembly is not signed.
//   (*) KeyName refers to a key that has been installed in the Crypto Service
//       Provider (CSP) on your machine. KeyFile refers to a file which contains
//       a key.
//   (*) If the KeyFile and the KeyName values are both specified, the 
//       following processing occurs:
//       (1) If the KeyName can be found in the CSP, that key is used.
//       (2) If the KeyName does not exist and the KeyFile does exist, the key 
//           in the KeyFile is installed into the CSP and used.
//   (*) In order to create a KeyFile, you can use the sn.exe (Strong Name) utility.
//       When specifying the KeyFile, the location of the KeyFile should be
//       relative to the project output directory which is
//       %Project Directory%\obj\<configuration>. For example, if your KeyFile is
//       located in the project directory, you would specify the AssemblyKeyFile 
//       attribute as [assembly: AssemblyKeyFile("..\\..\\mykey.snk")]
//   (*) Delay Signing is an advanced option - see the Microsoft .NET Framework
//       documentation for more information on this.
//
[assembly: AssemblyDelaySign(false)]
[assembly: AssemblyKeyFile("")]
[assembly: AssemblyKeyName("")]
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\xboxcom\toolLib\TLog.cs ===
using System;
using System.IO;
using System.Text;

namespace xonline.tools.xboxcom.toollib
{
    /// <summary>
    ///     Timed Logging
    /// </summary>
    public class TLog
    {
        /// <summary>
        ///     write a new line to the log
        /// </summary>
        /// <param name="format"></param>
        /// <param name="args"></param>
        public static void Write(string format, params object[] args)
        {
            WriteTo(Console.Out, format, args);
        }

        public static void ReportError(string format, params object[] args)
        {
            WriteTo(Console.Error, errorPrefix + format, args);
        }

        private static void WriteTo(TextWriter con, string format, params object[] args)
        {
            //
            // assemble format and arguments
            //
            StringBuilder sb = new StringBuilder();
            sb.AppendFormat("{0:hh:mm:ss} ", DateTime.Now);
            sb.AppendFormat(format, args);
            sb.Append("\r\n");
            string message = sb.ToString();

            Console.Out.WriteLine(message);

            //
            // inform hooks
            //
            if (_hooks!=null)
            {
                if (!_hooks(message))
                {
                    // don't send it to log file as indicated by hooks
                    return;
                }
            }

            //
            // write to log file
            //

            if (!Directory.Exists(logRoot))
            {
                Directory.CreateDirectory(logRoot);
            }

            if (_logFile==null)
            {
                string exeName = System.Reflection.Assembly.GetEntryAssembly().GetName().Name;
                string logName = logRoot + exeName + ".log";
                _logFile = new StreamWriter(logName, true);
                _logFile.WriteLine("=====");
                _logFile.WriteLine("new log started {0}", DateTime.Now);
            }

            _logFile.Write(message);
            _logFile.Flush();
        }

        private static StreamWriter _logFile = null;

        public delegate bool LogHook(string logLine);

        private static LogHook _hooks = null;
        public static LogHook Hooks 
        {
            get { return _hooks; }
            set { _hooks = value; }
        }

        const string logRoot = @"c:\tlog\";
        const string errorPrefix = "[error]";
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\xboxcom\XmlToCms\ImportPosting.cs ===
using System;
using System.IO;
using System.Xml;
using System.Collections;
using Microsoft.ContentManagement.Publishing;
using Microsoft.ContentManagement.Publishing.Extensions.Placeholders;

using xonline.tools.xboxcom.toollib;

namespace xonline.tools.xboxcom.XmlToCms
{
    /// <summary>
    ///     Tool for importing CMS postings
    /// </summary>
    public class PostingImporter
    {
        // count number of commits since last CMS context reset
        int commitCount=0;
        // reset CMS app context every 200 commit
        const int CommitLimit=200;

        private bool _cancel = false;
        public void Cancel()
        {
            _cancel = true;
        }

        static string[] _referencedTemplates = new string []
            {
                "FlexPageFragement"
            };
        private bool IsReferencedPosting(string templateName)
        {
            foreach (string t in _referencedTemplates)
            {
                if (t==templateName) return true;
            }
            return false;
        }

        bool _overwrite = false;
        bool _approve = false;

        /// <summary>
        /// The main entry point for the application.
        /// </summary>
        public void ImportDir(string rootDir, bool overwrite, bool approve)
        {
            _overwrite = overwrite;
            _approve = approve;

            string listingFilePath = Path.Combine(rootDir, "listing.txt");
            if (File.Exists(listingFilePath))
            {
                TLog.Write("found listing.txt, importing files from the file list");

                ListingReader listing = new ListingReader(listingFilePath);
                ImportCollection(listing, rootDir);
            }
            else
            {
                TLog.Write("listing.txt not found, importing all files in the directory");

                DirectoryListing dirlist = new DirectoryListing(rootDir);
                ImportCollection(dirlist, rootDir);
            }
        }
		
        Hashtable _guidMappingTable;

        private void ImportCollection(IEnumerable collection, string rootDir)
        {
            _guidMappingTable = new Hashtable();
            _guidMappingTable.Add(Guid.Empty.ToString(), Guid.Empty.ToString());
            _guidUpdateSuccess = 0;
            _guidUpdateFail = 0;
			
            CmsApplicationContext context = null;

            foreach (string relPath in collection)
            {
                if (_cancel) 
                {
                    TLog.Write("cancelled");
                    return;
                }

                string path = Path.Combine(rootDir, relPath);

                StreamReader reader = new StreamReader(path, System.Text.Encoding.UTF8);
                string src = reader.ReadToEnd();
                reader.Close();

                if (context == null)
                {
                    context = new CmsApplicationContext();
                    context.AuthenticateAsCurrentUser(PublishingMode.Update);
                }

                string guid = Import(src, context, path);

                if (commitCount>CommitLimit)
                {
                    TLog.Write("commit count={0}, recycling CMS app context", commitCount);
                    context.Dispose();
                    context = null;
                    System.GC.Collect();
                    commitCount = 0;
                }
            }

            TLog.Write("{0} unknown GUIDs, {1} GUIDs updated successfully",
                _guidUpdateFail,
                _guidUpdateSuccess);
        }

        /// <summary>
        ///     import a posting from exported Xml format
        /// </summary>
        /// <param name="xmlAsString"></param>
        /// <param name="cms"></param>
        /// <param name="srcLocation"></param>
        public string Import(
                string xmlAsString,
                CmsContext cms,
                string srcLocation
                )
        {
            XmlDocument xmlDoc = new XmlDocument();
            xmlDoc.LoadXml(xmlAsString);

            // get destination path of the posting
            string templatePath = xmlDoc.SelectSingleNode("/Posting/Template").Attributes["path"].Value;
            // get the template path of the posting, which must exist already
            string postingPath = xmlDoc.SelectSingleNode("/Posting").Attributes["path"].Value;
            string oldGuid = xmlDoc.SelectSingleNode("/Posting").Attributes["guid"].Value;
            // remove {} around the guid
            oldGuid = oldGuid.Substring(1,36);
            
            // get the list of placeholders in the posting
            XmlNodeList placeholderNodes = xmlDoc.SelectNodes("/Posting/Placeholder");

            if (placeholderNodes.Count==0)
            {
                TLog.Write("ignore empty postings {0}", srcLocation);
                return null;
            }

            TLog.Write("importing {0}...", srcLocation);

            string relTemplatePath = templatePath.Replace("/Template/", "");
            string relPostingPath = postingPath.Replace("/Channels/", "");

            //
            // only import known templates
            //
            switch (relTemplatePath)
            {
                case "Flexpage":
                    break;

                case "Skin":
                    break;

                case "FlexPageFragment":
                    break;

                default:
                    TLog.ReportError("unknown template: {0}", templatePath);
                    return null;
            }

            // acquite template object
            Template template = (Template)cms.RootTemplateGallery.GetByRelativePath(relTemplatePath);

            // acquire channel object
            string postingFolderPath = Path.GetDirectoryName(relPostingPath).Replace('\\','/');
            string postingName = Path.GetFileName(relPostingPath);
            Channel channel = CreateChannelPath(postingFolderPath, cms);

            Posting posting = null;

            // see if the posting exists
            try
            {
                posting = channel.Postings[postingName];
            }
            catch
            {
            }

            if (posting!=null)
            {
                if (_overwrite)
                {
                    //
                    // delete if it has a different template
                    //
                    if (posting.Template.Path != template.Path)
                    {
                        posting.Delete();
                        posting = null;
                    }
                }
                else
                {
                    TLog.Write("aborted, existing posting preserved.");
                    return null;
                }
            }

            //
            // create the posting if not existing
            //
            if (posting==null)
            {
                posting = channel.CreatePosting(template);

                posting.Name = postingName;
                posting.DisplayName = posting.Name;
            }
            else
            {
                string existingGuid = posting.Guid;
			
                // remove {} around the guid
                existingGuid = existingGuid.Substring(1,36);

                _guidMappingTable[oldGuid.ToUpper()] = existingGuid.ToUpper();
            }

            //
            // load up placeholder definitions
            //
            for (int i=0; i<placeholderNodes.Count; i++)
            {
                string placeholderText = placeholderNodes[i].InnerText;
                placeholderText = HtmlUtl.UnescapeCDataToXml(placeholderText);
                placeholderText = UpdateGuid(placeholderText);

                XmlPlaceholder placeholder = (XmlPlaceholder)posting.Placeholders[i];
                placeholder.XmlAsString = placeholderText;
            }
            
            if (_approve)
            {
                posting.Approve();
            }
            else
            {
                posting.ReleaseOwnership(true);
            }
			
            // save changes
            cms.CommitAll();
            commitCount++;

            TLog.Write("done.");

            string newGuid = posting.Guid;
			newGuid = newGuid.Substring(1,36);
			
            _guidMappingTable[oldGuid.ToUpper()] = newGuid.ToUpper();

            return posting.Guid;
        }

        private int _guidUpdateSuccess;
        private int _guidUpdateFail;

        private string UpdateGuid(string placeholderText)
        {
            string[] attrHeads = new string[] {
                                                  " postingGuid=\"",
                                                  "\"/NR/exeres/",
                                                  "\"/NR/rdonlyres/"
                                              };
            const int guidLength = 36;

            int headIndex = -1;
            int p0=placeholderText.Length;

            for (int i=0; i<attrHeads.Length; i++)
            {
                int p = placeholderText.IndexOf(attrHeads[i], 0, p0);
                if (p<0)
                {
                    continue;
                }

                if (p<p0)
                {
                    headIndex = i;
                    p0=p;
                }
            }

            if (headIndex == -1) 
            {
                return placeholderText;
            }

            bool mustUpdate = true;
            if (attrHeads[headIndex].IndexOf("rdonlyres")>=0)
            {
                // rdonlyres may point to resource gallery item, their guid
                // won't change in that case.
                mustUpdate = false;
            }

            int p1 = p0 + attrHeads[headIndex].Length;
            int p2 = p1 + guidLength;

            string guidOld = placeholderText.Substring(p1, guidLength).ToUpper();
            string guidNew = _guidMappingTable[guidOld] as string;
            if (guidNew==null)
            {
                if (mustUpdate)
                {
                    TLog.ReportError("guid {0} not found in mapping table", guidOld);
                    guidNew = guidOld;
                    _guidUpdateFail++;
                }
                else
                {
                    guidNew = guidOld;
                }
            }
            else
            {
                _guidUpdateSuccess++;
            }

            return placeholderText.Substring(0, p1)
                + guidNew
                + UpdateGuid(placeholderText.Substring(p2));
        }

        /// <summary>
        ///     create channels leading to a specified path
        /// </summary>
        /// <param name="path"></param>
        /// <param name="cms"></param>
        /// <returns></returns>
        private Channel CreateChannelPath(string path, CmsContext cms)
        {
            Channel channel = (Channel)cms.RootChannel;

            foreach (string comp in path.Split('/'))
            {
                Channel channel1 = channel.Channels[comp];
                if (channel1 == null)
                {
                    channel1 = channel.CreateChannel();
                    channel1.Name = comp;
                    cms.CommitAll();
                }

                channel = channel1;
            }

            return channel;
        }

    }

    class ListingEnumerator : IEnumerator
    {
        private string _filePath = null;
        private StreamReader _stream = null;
        private string _line = null;

        public Object Current
        {
            get
            {
                return _line;
            }
        }

        public ListingEnumerator(string path)
        {
            _filePath = path;
            Reset();
        }

        public void Reset()
        {
            _stream = new StreamReader(_filePath);
            _line = null;
        }

        public bool MoveNext()
        {
            do 
            {
                _line = _stream.ReadLine();
                if (_line==null) return false;
            }
            while (_line.Length==0 || _line[0]=='[');

            return true;
        }
    }

    class ListingReader : IEnumerable
    {
        string _filePath = null;

        public ListingReader(string path)
        {
            _filePath = path;
        }

        public IEnumerator GetEnumerator()
        {
            return new ListingEnumerator(_filePath);
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\xboxcom\XmlToCms\ConsoleMain.cs ===
using System;
using System.IO;

namespace xonline.tools.xboxcom.XmlToCms
{
    /// <summary>
    ///     console version of CMS posting importer tool
    /// </summary>
    public class ConsoleMain
    {
        [STAThread]
        static void Main(string[] args)
        {
            if (args.Length!=1)
            {
                Console.WriteLine("usage: XmlToCms root-folder");
                return;
            }

            (new PostingImporter()).ImportDir(args[0], false, false);
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\xboxcomData\productdb\makefile.inc ===
!include $(INETROOT)\build\makefile.inc

SQLTARGET:
    -md %_NT386TREE%\tools\xboxcom\productdb
    copy *.bat               $(_NT386TREE)\tools\xboxcom\productdb
    copy *.dat               $(_NT386TREE)\tools\xboxcom\productdb
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\xboxcomData\XboxComDataDump\Data\Culture.cs ===
using System;
using System.Xml;

namespace xonline.tools.xboxcomData.XboxComDataDump.Data
{
	/// <summary>
	/// Summary description for Culture.
	/// </summary>
	public class Culture
	{
		private String m_szName;

		public Culture()
		{
			//
			// TODO: Add constructor logic here
			//
		}

		public String Name
		{
			set
			{
				this.m_szName = value;
			}
			get
			{
				return this.m_szName;
			}
		}

		public System.Xml.XmlNode XML(XmlDocument objXML)
		{
			System.Xml.XmlNode nodeCulture = objXML.CreateNode(System.Xml.XmlNodeType.Element, "culture", "");
			System.Xml.XmlAttribute attribCulture = objXML.CreateAttribute("code");
			attribCulture.Value = this.Name;

			nodeCulture.Attributes.Append(attribCulture);

			return nodeCulture;
		}
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\xboxcomData\XboxComDataDump\Data\Cultures.cs ===
using System;
using System.Collections;
using System.Xml;

namespace xonline.tools.xboxcomData.XboxComDataDump.Data
{
	/// <summary>
	/// Summary description for Cultures.
	/// </summary>
	public class Cultures
	{
		private ArrayList m_arrCultures = new ArrayList();

		public Cultures(System.Data.SqlClient.SqlConnection objConn)
		{
			System.Data.SqlClient.SqlCommand objCommand = new System.Data.SqlClient.SqlCommand();
			objCommand.Connection = objConn;

			objCommand.CommandText = "select CategoryName from [xbox_catalogproducts] where DefinitionName = 'CultureCategory' and parentOID != -1";

			System.Data.SqlClient.SqlDataReader objRs = objCommand.ExecuteReader();

			while (objRs.Read())
			{
				Culture culture = new Culture();
				culture.Name = objRs.GetString(0);

				this.m_arrCultures.Add(culture);
			}

			objRs.Close();
		}

		public System.Xml.XmlNode XML(XmlDocument objXML)
		{
			// create <cultures> sub-node
			XmlNode nodeCultures = objXML.CreateNode(System.Xml.XmlNodeType.Element, "cultures", "");

			// append all cultures
			System.Collections.IEnumerator myEnum = this.m_arrCultures.GetEnumerator();
			XmlNode nodeCulture;

			while (myEnum.MoveNext())
			{
				nodeCulture = ((Culture)myEnum.Current).XML(objXML);
				nodeCultures.AppendChild(nodeCulture);
			}

			return nodeCultures;
		}

		public Culture[] CultureList
		{
			get
			{
				Culture[] rgCultures = new Culture[this.m_arrCultures.Count];
				int i = 0;
				System.Collections.IEnumerator myEnum = this.m_arrCultures.GetEnumerator();

				while (myEnum.MoveNext())
				{
					rgCultures[i] = (Culture)(myEnum.Current);
					i++;
				}

				return rgCultures;
			}
		}
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\xboxcomData\XboxComDataDump\Data\Genre.cs ===
using System;
using System.Collections;
using System.Xml;

namespace xonline.tools.xboxcomData.XboxComDataDump.Data
{
	/// <summary>
	/// Summary description for Genre.
	/// </summary>
	public class Genre
	{
		private String m_szName;
		private int m_iGenreId;

		private ArrayList m_arrLocalized = new ArrayList();

		public Genre()
		{
			//
			// TODO: Add constructor logic here
			//
		}

		public String Name
		{
			set
			{
				this.m_szName = value;
			}
			get
			{
				return this.m_szName;
			}
		}

		public int GenreId
		{
			set
			{
				this.m_iGenreId = value;
			}

			get
			{
				return this.m_iGenreId;
			}
		}

//		public void AddLocalizedValue(String szCulture, String szValue)
//		{
//			Localized lcl = new Localized();
//			lcl.Culture = szCulture;
//			lcl.Value = szValue;
//
//			this.m_arrLocalized.Add(lcl);
//		}
//
//		public void UpdateLocalizedValue(String szCulture, String szValue)
//		{
//			System.Collections.IEnumerator myEnum = this.m_arrLocalized.GetEnumerator();
//			Localized lcl;
//
//			while (myEnum.MoveNext())
//			{
//				lcl = (Localized)(myEnum.Current);
//				if (lcl.Culture.ToLower().Equals(szCulture.ToLower()))
//				{
//					lcl.Value = szValue;
//					return;
//				}
//			}
//		}

		public System.Xml.XmlNode XML(XmlDocument objXML)
		{
			System.Xml.XmlNode nodeGenre = objXML.CreateNode(System.Xml.XmlNodeType.Element, "genre", "");
			System.Xml.XmlAttribute attribGenre = objXML.CreateAttribute("name");
			attribGenre.Value = this.Name;

			nodeGenre.Attributes.Append(attribGenre);

			System.Xml.XmlAttribute attribGenreId = objXML.CreateAttribute("id");
			attribGenreId.Value = this.GenreId.ToString();
			nodeGenre.Attributes.Append(attribGenreId);

//			System.Xml.XmlNode nodeLocalized = objXML.CreateNode(System.Xml.XmlNodeType.Element, "localized", "");
//
//			System.Collections.IEnumerator myEnum = this.m_arrLocalized.GetEnumerator();
//
//			while (myEnum.MoveNext())
//			{
//				Localized lcl = (Localized)myEnum.Current;
//				nodeLocalized.AppendChild(lcl.XML(objXML));
//			}
//
//			nodeGenre.AppendChild(nodeLocalized);

			return nodeGenre;
		}
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\xboxcomData\XboxComDataDump\Data\Genres.cs ===
using System;
using System.Collections;
using System.Xml;

namespace xonline.tools.xboxcomData.XboxComDataDump.Data
{
	/// <summary>
	/// Summary description for Genres.
	/// </summary>
	public class Genres
	{

		private ArrayList m_arrGenres = new ArrayList();

		public Genres(System.Data.SqlClient.SqlConnection objConn, Culture[] rgCultures)
		{
			System.Data.SqlClient.SqlCommand objCommand = new System.Data.SqlClient.SqlCommand();
			objCommand.Connection = objConn;

			objCommand.CommandText = "select CategoryName, oid from [xbox_catalogproducts] where DefinitionName = 'GenreCategory' and CategoryName != 'Genres'";

			System.Data.SqlClient.SqlDataReader objRs = objCommand.ExecuteReader();

			while (objRs.Read())
			{
				Genre genre = new Genre();
				genre.Name = objRs.GetString(objRs.GetOrdinal("CategoryName"));
				genre.GenreId = objRs.GetInt32(objRs.GetOrdinal("oid"));

				this.m_arrGenres.Add(genre);
			}

			objRs.Close();

//			// now step through all the cultures and get the appropriate genre translation
//			for (int i = 0; i < rgCultures.Length; i++)
//			{
//				objCommand.CommandText = "select [#catalog_lang_oid] as oid, DisplayName from [xbox_" + rgCultures[i].Name + "_catalog] where [#catalog_lang_oid] in (select oid from [xbox_catalogproducts] where DefinitionName = 'GenreCategory' and CategoryName != 'Genres')";
//
//				objRs = objCommand.ExecuteReader();
//				while (objRs.Read())
//				{
//					int iOid = objRs.GetInt32(objRs.GetOrdinal("oid"));
//
//					System.Collections.IEnumerator myEnum = this.m_arrGenres.GetEnumerator();
//
//					while (myEnum.MoveNext())
//					{
//						Genre genre = (Genre)myEnum.Current;
//						if (genre.GenreId == iOid)
//						{
//							genre.AddLocalizedValue(rgCultures[i].Name, objRs.GetString(objRs.GetOrdinal("DisplayName")));
//						}
//					}
//				}
//
//				objRs.Close();
//			}
		}

		public System.Xml.XmlNode XML(XmlDocument objXML)
		{
			// create <genres> sub-node
			XmlNode nodeGenres = objXML.CreateNode(System.Xml.XmlNodeType.Element, "genres", "");

 			// append all genres
			System.Collections.IEnumerator myEnum = this.m_arrGenres.GetEnumerator();
			XmlNode nodeGenre;

			while (myEnum.MoveNext())
			{
				nodeGenre = ((Genre)myEnum.Current).XML(objXML);
				nodeGenres.AppendChild(nodeGenre);
			}

			return nodeGenres;
		}

		public Genre[] GenreList
		{
			get
			{
				Genre[] rgGenres = new Genre[this.m_arrGenres.Count];
				int i = 0;
				System.Collections.IEnumerator myEnum = this.m_arrGenres.GetEnumerator();

				while (myEnum.MoveNext())
				{
					rgGenres[i] = (Genre)(myEnum.Current);
					i++;
				}

				return rgGenres;
			}
		}
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\xboxcom\XmlToCms\MainForm.cs ===
using System;
using System.Drawing;
using System.Collections;
using System.ComponentModel;
using System.Windows.Forms;
using System.Data;
using System.Threading;
using System.IO;

using xonline.tools.xboxcom.toollib;

namespace xonline.tools.xboxcom.XmlToCms
{
    /// <summary>
    ///     windowed version of CMS posting importer
    /// </summary>
    public class MainForm : System.Windows.Forms.Form
    {
        private System.Windows.Forms.FolderBrowserDialog folderBrowserDialog1;
        private System.Windows.Forms.Button button1;
        private System.Windows.Forms.Button button2;
        private System.Windows.Forms.RichTextBox richTextBox1;
        private System.Windows.Forms.Panel panel2;
        private System.Windows.Forms.Panel panel1;
        private System.Windows.Forms.Button BrowseOutputDirectoryButton;
        private System.Windows.Forms.TextBox OutputDirectoryTextbox;
        private System.Windows.Forms.Label label1;
        private System.Windows.Forms.Label label3;
        private System.Windows.Forms.CheckBox checkBoxOverwrite;
        private System.Windows.Forms.CheckBox checkBoxApprove;
        private PostingImporter _importer;
        /// <summary>
        /// Required designer variable.
        /// </summary>
        private System.ComponentModel.Container components = null;

        public MainForm()
        {
            //
            // Required for Windows Form Designer support
            //
            InitializeComponent();

            //
            // set focus control
            //
            this.ActiveControl = OutputDirectoryTextbox;

            //
            // set default button
            //
            this.AcceptButton = button1;

            //
            // display the startup pane
            //
            this.Height = 400;
            panel1.Show();
            panel2.Hide();
        }

        /// <summary>
        /// Clean up any resources being used.
        /// </summary>
        protected override void Dispose( bool disposing )
        {
            if( disposing )
            {
                if (components != null) 
                {
                    components.Dispose();
                }
            }
            base.Dispose( disposing );
        }

        #region Windows Form Designer generated code
        /// <summary>
        /// Required method for Designer support - do not modify
        /// the contents of this method with the code editor.
        /// </summary>
        private void InitializeComponent()
        {
            this.folderBrowserDialog1 = new System.Windows.Forms.FolderBrowserDialog();
            this.button1 = new System.Windows.Forms.Button();
            this.button2 = new System.Windows.Forms.Button();
            this.panel2 = new System.Windows.Forms.Panel();
            this.richTextBox1 = new System.Windows.Forms.RichTextBox();
            this.panel1 = new System.Windows.Forms.Panel();
            this.checkBoxApprove = new System.Windows.Forms.CheckBox();
            this.checkBoxOverwrite = new System.Windows.Forms.CheckBox();
            this.BrowseOutputDirectoryButton = new System.Windows.Forms.Button();
            this.OutputDirectoryTextbox = new System.Windows.Forms.TextBox();
            this.label1 = new System.Windows.Forms.Label();
            this.label3 = new System.Windows.Forms.Label();
            this.panel2.SuspendLayout();
            this.panel1.SuspendLayout();
            this.SuspendLayout();
            // 
            // button1
            // 
            this.button1.Location = new System.Drawing.Point(184, 312);
            this.button1.Name = "button1";
            this.button1.Size = new System.Drawing.Size(90, 26);
            this.button1.TabIndex = 8;
            this.button1.Text = "Start";
            this.button1.Click += new System.EventHandler(this.button1_Click);
            // 
            // button2
            // 
            this.button2.Location = new System.Drawing.Point(312, 312);
            this.button2.Name = "button2";
            this.button2.Size = new System.Drawing.Size(90, 26);
            this.button2.TabIndex = 16;
            this.button2.Text = "Cancel";
            this.button2.Click += new System.EventHandler(this.button2_Click);
            // 
            // panel2
            // 
            this.panel2.Controls.Add(this.richTextBox1);
            this.panel2.Location = new System.Drawing.Point(0, 376);
            this.panel2.Name = "panel2";
            this.panel2.Size = new System.Drawing.Size(600, 300);
            this.panel2.TabIndex = 17;
            // 
            // richTextBox1
            // 
            this.richTextBox1.Location = new System.Drawing.Point(0, 0);
            this.richTextBox1.Name = "richTextBox1";
            this.richTextBox1.Size = new System.Drawing.Size(592, 296);
            this.richTextBox1.TabIndex = 20;
            this.richTextBox1.Text = "";
            // 
            // panel1
            // 
            this.panel1.Controls.Add(this.checkBoxApprove);
            this.panel1.Controls.Add(this.checkBoxOverwrite);
            this.panel1.Controls.Add(this.BrowseOutputDirectoryButton);
            this.panel1.Controls.Add(this.OutputDirectoryTextbox);
            this.panel1.Controls.Add(this.label1);
            this.panel1.Controls.Add(this.label3);
            this.panel1.Location = new System.Drawing.Point(0, 0);
            this.panel1.Name = "panel1";
            this.panel1.Size = new System.Drawing.Size(600, 300);
            this.panel1.TabIndex = 18;
            // 
            // checkBoxApprove
            // 
            this.checkBoxApprove.Location = new System.Drawing.Point(72, 120);
            this.checkBoxApprove.Name = "checkBoxApprove";
            this.checkBoxApprove.Size = new System.Drawing.Size(136, 24);
            this.checkBoxApprove.TabIndex = 21;
            this.checkBoxApprove.Text = "Approve posting";
            // 
            // checkBoxOverwrite
            // 
            this.checkBoxOverwrite.Location = new System.Drawing.Point(72, 88);
            this.checkBoxOverwrite.Name = "checkBoxOverwrite";
            this.checkBoxOverwrite.Size = new System.Drawing.Size(136, 24);
            this.checkBoxOverwrite.TabIndex = 20;
            this.checkBoxOverwrite.Text = "Overwrite existing";
            // 
            // BrowseOutputDirectoryButton
            // 
            this.BrowseOutputDirectoryButton.Location = new System.Drawing.Point(432, 184);
            this.BrowseOutputDirectoryButton.Name = "BrowseOutputDirectoryButton";
            this.BrowseOutputDirectoryButton.Size = new System.Drawing.Size(90, 27);
            this.BrowseOutputDirectoryButton.TabIndex = 18;
            this.BrowseOutputDirectoryButton.Text = "Browse...";
            this.BrowseOutputDirectoryButton.Click += new System.EventHandler(this.BrowseOutputDirectoryButton_Click);
            // 
            // OutputDirectoryTextbox
            // 
            this.OutputDirectoryTextbox.Location = new System.Drawing.Point(144, 186);
            this.OutputDirectoryTextbox.Name = "OutputDirectoryTextbox";
            this.OutputDirectoryTextbox.Size = new System.Drawing.Size(264, 22);
            this.OutputDirectoryTextbox.TabIndex = 17;
            this.OutputDirectoryTextbox.Text = "c:\\cmscontent";
            // 
            // label1
            // 
            this.label1.Location = new System.Drawing.Point(40, 188);
            this.label1.Name = "label1";
            this.label1.Size = new System.Drawing.Size(117, 18);
            this.label1.TabIndex = 16;
            this.label1.Text = "Input Directory:";
            // 
            // label3
            // 
            this.label3.Location = new System.Drawing.Point(32, 8);
            this.label3.Name = "label3";
            this.label3.Size = new System.Drawing.Size(504, 56);
            this.label3.TabIndex = 19;
            this.label3.Text = "This application imports posting into CMS database from Xml files as generated by" +
                " CmsToXml. Each file in the directory maps to one posting in CMS. The directory " +
                "is processed recursively.";
            // 
            // MainForm
            // 
            this.AutoScaleBaseSize = new System.Drawing.Size(6, 15);
            this.ClientSize = new System.Drawing.Size(608, 720);
            this.Controls.Add(this.panel1);
            this.Controls.Add(this.panel2);
            this.Controls.Add(this.button2);
            this.Controls.Add(this.button1);
            this.Name = "MainForm";
            this.Text = "CMS Importing Tool";
            this.Closing += new System.ComponentModel.CancelEventHandler(this.MainForm_Closing);
            this.SizeChanged += new System.EventHandler(this.MainForm_SizeChanged);
            this.panel2.ResumeLayout(false);
            this.panel1.ResumeLayout(false);
            this.ResumeLayout(false);

        }
        #endregion

        /// <summary>
        /// The main entry point for the application.
        /// </summary>
        [STAThread]
        static void Main() 
        {
            Application.Run(new MainForm());
        }

        private void BrowseOutputDirectoryButton_Click(object sender, System.EventArgs e)
        {
            folderBrowserDialog1.SelectedPath = OutputDirectoryTextbox.Text;
            
            if (folderBrowserDialog1.ShowDialog() == DialogResult.OK)
            {
                OutputDirectoryTextbox.Text = folderBrowserDialog1.SelectedPath;
            }
        }

        Thread _bkThread = null;

        private void button1_Click(object sender, System.EventArgs e)
        {
            // start button only fire once
            button1.Enabled = false;

            //
            // switch to working pane from startup pane
            //
            panel1.Hide();
            panel2.Location = new Point(0,0);
            panel2.Show();

            // set new focus
            this.ActiveControl = richTextBox1;

            _importer = new PostingImporter();

            //
            // kick off import task on separate thread
            //
            _bkThread = new Thread(new ThreadStart(BackgroundThread));
            _bkThread.Start();
        }

        private void button2_Click(object sender, System.EventArgs e)
        {
            // try to close the window, which may not always pass verification
            this.Close();
        }

        private void MainForm_SizeChanged(object sender, System.EventArgs e)
        {
            //
            // resize and reposition controls in response to window size changes.
            // currently we only adjust horizontally
            //
            int w = this.Size.Width;
            panel1.Width = w-12;
            OutputDirectoryTextbox.Width = w - 300;
            BrowseOutputDirectoryButton.Left = w - 150;
            panel2.Width = w-12;
            richTextBox1.Width = w-12;
        }

        /// <summary>
        ///     the background worker for importing postings
        /// </summary>
        private void BackgroundThread()
        {
            string root = OutputDirectoryTextbox.Text;

            try 
            {
                // grab log messages so we can show it on screen
                TLog.Hooks += new TLog.LogHook(OnNewLogEntry);

                bool overwrite = checkBoxOverwrite.Checked;
                bool approve = checkBoxApprove.Checked;

                // call the importer
                _importer.ImportDir(root, overwrite, approve);

                TLog.Write("{0} errors", _errorCount);
            }
            catch (Exception e)
            {
                TLog.Write(e.ToString());
            }
            finally
            {
                // clear thread handle so the main window can close
                _bkThread = null;

                // rename the cancel button and reenable it
                button2.Text = "Close";
                button2.Enabled = true;
            }
        }

        private int _errorCount = 0;
        private bool _replaceLastLine = false;
        private bool OnNewLogEntry(string logLine)
        {
            if (_replaceLastLine)
            {
                richTextBox1.Undo();
            }

            if (logLine.IndexOf("[error]")!=-1)
            {
                richTextBox1.SelectionColor = Color.FromArgb(255,0,0);
                _errorCount++;
            }
            else
            {
                richTextBox1.SelectionColor = Color.FromArgb(0,0,0);
            }

            richTextBox1.AppendText(logLine);
            richTextBox1.ScrollToCaret();

            if (logLine[1+logLine.IndexOf(' ')]=='>')
            {
                _replaceLastLine = true;
            }
            else
            {
                _replaceLastLine = false;
            }

            return true;
        }

        private void MainForm_Closing(object sender, System.ComponentModel.CancelEventArgs e)
        {
            if (_bkThread!=null)
            {
                // can't quit if background thread is alive
                e.Cancel = true;

                // signal cancel to background thread
                _importer.Cancel();

                // visual feedback that we're trying to cancel.
                // however, user can still try to "close" the window.
                button2.Enabled = false;

                TLog.Write("cancelling");
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\xboxcomData\XboxComDataDump\Data\Localized.cs ===
using System;
using System.Xml;

namespace xonline.tools.xboxcomData.XboxComDataDump.Data
{
	/// <summary>
	/// Summary description for Localized.
	/// </summary>
	public class Localized
	{
		private string m_szCulture = "";
		private string m_szValue = "";

		public String Culture
		{
			get
			{
				return this.m_szCulture;
			}

			set
			{
				this.m_szCulture = value;
			}
		}

		public String Value
		{
			get
			{
				return this.m_szValue;
			}

			set
			{
				this.m_szValue = value;
			}
		}

		public System.Xml.XmlNode XML(XmlDocument objXML)
		{
			System.Xml.XmlNode nodeCulture = objXML.CreateElement("culture");

			System.Xml.XmlAttribute attribValue = objXML.CreateAttribute("code");
			attribValue.Value = this.m_szCulture;
			nodeCulture.Attributes.Append(attribValue);

			System.Xml.XmlNode nodeValue = objXML.CreateNode(System.Xml.XmlNodeType.Text, "", "");
			nodeValue.Value = this.m_szValue;
			nodeCulture.AppendChild(nodeValue);

			return nodeCulture;
		}
		public Localized()
		{
			//
			// TODO: Add constructor logic here
			//
		}
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\xboxcomData\XboxComDataRestore\AssemblyInfo.cs ===
using System.Reflection;
using System.Runtime.CompilerServices;

//
// General Information about an assembly is controlled through the following 
// set of attributes. Change these attribute values to modify the information
// associated with an assembly.
//
[assembly: AssemblyTitle("")]
[assembly: AssemblyDescription("")]
[assembly: AssemblyConfiguration("")]
[assembly: AssemblyCompany("")]
[assembly: AssemblyProduct("")]
[assembly: AssemblyCopyright("")]
[assembly: AssemblyTrademark("")]
[assembly: AssemblyCulture("")]		

//
// Version information for an assembly consists of the following four values:
//
//      Major Version
//      Minor Version 
//      Build Number
//      Revision
//
// You can specify all the values or you can default the Revision and Build Numbers 
// by using the '*' as shown below:

[assembly: AssemblyVersion("1.0.*")]

//
// In order to sign your assembly you must specify a key to use. Refer to the 
// Microsoft .NET Framework documentation for more information on assembly signing.
//
// Use the attributes below to control which key is used for signing. 
//
// Notes: 
//   (*) If no key is specified, the assembly is not signed.
//   (*) KeyName refers to a key that has been installed in the Crypto Service
//       Provider (CSP) on your machine. KeyFile refers to a file which contains
//       a key.
//   (*) If the KeyFile and the KeyName values are both specified, the 
//       following processing occurs:
//       (1) If the KeyName can be found in the CSP, that key is used.
//       (2) If the KeyName does not exist and the KeyFile does exist, the key 
//           in the KeyFile is installed into the CSP and used.
//   (*) In order to create a KeyFile, you can use the sn.exe (Strong Name) utility.
//       When specifying the KeyFile, the location of the KeyFile should be
//       relative to the project output directory which is
//       %Project Directory%\obj\<configuration>. For example, if your KeyFile is
//       located in the project directory, you would specify the AssemblyKeyFile 
//       attribute as [assembly: AssemblyKeyFile("..\\..\\mykey.snk")]
//   (*) Delay Signing is an advanced option - see the Microsoft .NET Framework
//       documentation for more information on this.
//
[assembly: AssemblyDelaySign(false)]
[assembly: AssemblyKeyFile("")]
[assembly: AssemblyKeyName("")]
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\xboxcomData\XboxComDataDump\XboxComDataDump.cs ===
using System;
using System.Drawing;
using System.Collections;
using System.ComponentModel;
using System.Windows.Forms;
using System.Data;

namespace xonline.tools.xboxcomData.XboxComDataDump
{
	/// <summary>
	/// Summary description for Form1.
	/// </summary>
	public class XboxComDataDump : System.Windows.Forms.Form
	{
		private System.Data.SqlClient.SqlConnection sqlConnection1;
		private System.Windows.Forms.SaveFileDialog saveFileDialog1;
		private System.Windows.Forms.Button button2;
		private System.Windows.Forms.Label label5;
		private System.Windows.Forms.TextBox txtOutputFile;
		private System.Windows.Forms.Button button1;
		private System.Windows.Forms.Label label2;
		private System.Windows.Forms.Label label1;
		private System.Windows.Forms.TextBox txtDatabaseServer;
		private System.Windows.Forms.Label label6;
		private System.Windows.Forms.TextBox txtCommerceDatabase;
		private System.Windows.Forms.TextBox m_txtMediaDatabase;
		/// <summary>
		/// Required designer variable.
		/// </summary>
		private System.ComponentModel.Container components = null;

		public XboxComDataDump()
		{
			//
			// Required for Windows Form Designer support
			//
			InitializeComponent();

			//
			// TODO: Add any constructor code after InitializeComponent call
			//
		}

		/// <summary>
		/// Clean up any resources being used.
		/// </summary>
		protected override void Dispose( bool disposing )
		{
			if( disposing )
			{
				if (components != null) 
				{
					components.Dispose();
				}
			}
			base.Dispose( disposing );
		}

		#region Windows Form Designer generated code
		/// <summary>
		/// Required method for Designer support - do not modify
		/// the contents of this method with the code editor.
		/// </summary>
		private void InitializeComponent()
		{
			this.sqlConnection1 = new System.Data.SqlClient.SqlConnection();
			this.saveFileDialog1 = new System.Windows.Forms.SaveFileDialog();
			this.button2 = new System.Windows.Forms.Button();
			this.label5 = new System.Windows.Forms.Label();
			this.txtOutputFile = new System.Windows.Forms.TextBox();
			this.button1 = new System.Windows.Forms.Button();
			this.label2 = new System.Windows.Forms.Label();
			this.label1 = new System.Windows.Forms.Label();
			this.txtCommerceDatabase = new System.Windows.Forms.TextBox();
			this.txtDatabaseServer = new System.Windows.Forms.TextBox();
			this.m_txtMediaDatabase = new System.Windows.Forms.TextBox();
			this.label6 = new System.Windows.Forms.Label();
			this.SuspendLayout();
			// 
			// saveFileDialog1
			// 
			this.saveFileDialog1.Filter = "XML files|*.xml";
			// 
			// button2
			// 
			this.button2.Location = new System.Drawing.Point(264, 128);
			this.button2.Name = "button2";
			this.button2.Size = new System.Drawing.Size(24, 16);
			this.button2.TabIndex = 22;
			this.button2.Text = "..";
			this.button2.Click += new System.EventHandler(this.button2_Click);
			// 
			// label5
			// 
			this.label5.Location = new System.Drawing.Point(0, 128);
			this.label5.Name = "label5";
			this.label5.Size = new System.Drawing.Size(80, 16);
			this.label5.TabIndex = 21;
			this.label5.Text = "Save To:";
			// 
			// txtOutputFile
			// 
			this.txtOutputFile.Location = new System.Drawing.Point(96, 128);
			this.txtOutputFile.Name = "txtOutputFile";
			this.txtOutputFile.Size = new System.Drawing.Size(160, 20);
			this.txtOutputFile.TabIndex = 20;
			this.txtOutputFile.Text = "C:\\output.xml";
			// 
			// button1
			// 
			this.button1.Location = new System.Drawing.Point(72, 176);
			this.button1.Name = "button1";
			this.button1.Size = new System.Drawing.Size(136, 32);
			this.button1.TabIndex = 12;
			this.button1.Text = "Dump";
			this.button1.Click += new System.EventHandler(this.button1_Click);
			// 
			// label2
			// 
			this.label2.Location = new System.Drawing.Point(0, 56);
			this.label2.Name = "label2";
			this.label2.Size = new System.Drawing.Size(96, 28);
			this.label2.TabIndex = 17;
			this.label2.Text = "Commerce Database:";
			// 
			// label1
			// 
			this.label1.Location = new System.Drawing.Point(2, 36);
			this.label1.Name = "label1";
			this.label1.Size = new System.Drawing.Size(96, 16);
			this.label1.TabIndex = 15;
			this.label1.Text = "Database Server:";
			// 
			// txtCommerceDatabase
			// 
			this.txtCommerceDatabase.Location = new System.Drawing.Point(98, 60);
			this.txtCommerceDatabase.Name = "txtCommerceDatabase";
			this.txtCommerceDatabase.Size = new System.Drawing.Size(160, 20);
			this.txtCommerceDatabase.TabIndex = 14;
			this.txtCommerceDatabase.Text = "xboxnet_commerce";
			// 
			// txtDatabaseServer
			// 
			this.txtDatabaseServer.Location = new System.Drawing.Point(98, 28);
			this.txtDatabaseServer.Name = "txtDatabaseServer";
			this.txtDatabaseServer.Size = new System.Drawing.Size(160, 20);
			this.txtDatabaseServer.TabIndex = 13;
			this.txtDatabaseServer.Text = "kurtisc-02";
			// 
			// m_txtMediaDatabase
			// 
			this.m_txtMediaDatabase.Location = new System.Drawing.Point(96, 96);
			this.m_txtMediaDatabase.Name = "m_txtMediaDatabase";
			this.m_txtMediaDatabase.Size = new System.Drawing.Size(160, 20);
			this.m_txtMediaDatabase.TabIndex = 23;
			this.m_txtMediaDatabase.Text = "MediaManager";
			// 
			// label6
			// 
			this.label6.Location = new System.Drawing.Point(0, 104);
			this.label6.Name = "label6";
			this.label6.Size = new System.Drawing.Size(96, 16);
			this.label6.TabIndex = 24;
			this.label6.Text = "Media Database:";
			// 
			// XboxComDataDump
			// 
			this.AutoScaleBaseSize = new System.Drawing.Size(5, 13);
			this.ClientSize = new System.Drawing.Size(292, 221);
			this.Controls.Add(this.label6);
			this.Controls.Add(this.m_txtMediaDatabase);
			this.Controls.Add(this.button2);
			this.Controls.Add(this.label5);
			this.Controls.Add(this.txtOutputFile);
			this.Controls.Add(this.button1);
			this.Controls.Add(this.label2);
			this.Controls.Add(this.label1);
			this.Controls.Add(this.txtCommerceDatabase);
			this.Controls.Add(this.txtDatabaseServer);
			this.Name = "XboxComDataDump";
			this.Text = "XboxComDataDump Tool";
			this.ResumeLayout(false);

		}
		#endregion

		/// <summary>
		/// The main entry point for the application.
		/// </summary>
		[STAThread]
		static void Main() 
		{
			Application.Run(new XboxComDataDump());
		}

		private void button1_Click(object sender, System.EventArgs e)
		{
			try
			{
				this.sqlConnection1.ConnectionString =  
					"Server=" + this.txtDatabaseServer.Text + ";" +
					"Database=" + this.txtCommerceDatabase.Text + ";" +
					"Integrated Security=SSPI;";

				this.sqlConnection1.Open();

				// do some work
				Data.ProductList productList = new Data.ProductList();
				productList.Load(this.sqlConnection1);

				productList.XML.Save(this.txtOutputFile.Text);

				System.Windows.Forms.MessageBox.Show("Data has been dumped.", "Done!");
			}
			catch (Exception ex)
			{
				System.Windows.Forms.MessageBox.Show(ex.Message, "SQL Connection Error");
			}
			finally
			{
				// close connection
				this.sqlConnection1.Close();
			}
		}

		private void button2_Click(object sender, System.EventArgs e)
		{
			this.saveFileDialog1.ShowDialog();
			this.txtOutputFile.Text = this.saveFileDialog1.FileName;
		}
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\xboxcomData\XboxComDataDump\Data\LocalizedProduct.cs ===
using System;
using System.Xml;
using System.Collections;

namespace xonline.tools.xboxcomData.XboxComDataDump.Data
{
	/// <summary>
	/// Summary description for LocalizedProduct.
	/// </summary>
	public class LocalizedProduct
	{
		private bool m_bActive = false;
		private int m_iProductCatalogId;
		private string m_szCulture;
		private string m_szTitle;
		private string m_szLinkToURL;
		private double m_dListPrice;
		private double m_dOriginalPrice;
		private string m_szSoftGenre;
		private string m_szSoftSubGenre;
		private string m_szPublisher;
		private string m_szPublisherURL;
		private string m_szReleaseDate;
		private DateTime m_dtReleaseDateSortable;
		private bool m_bPlatinum = false;
		private string m_szRating;
		private string m_szRatingDescription;

		private bool m_bCoOp;
		private bool m_bCustomSoundtracks;
		private bool m_bDolby51;
		private bool m_bHDTV;
		private bool m_bHighlight;
		private bool m_bLiveContent;
		private bool m_bLiveContentDownload;
		private bool m_bLiveFriends;
		private bool m_bLiveKeyboard;
		private bool m_bLiveMultiplayer;
		private bool m_bLiveScoreboard;
		private bool m_bLiveStats;
		private bool m_bLiveVoice;
		private bool m_bMemoryUnit;
		private bool m_bMultiplayerVs;
		private string m_szPlayers;
		private bool m_bSystemLink;
		private bool m_bXboxCompatible;
		private bool m_bXboxLicensed;
		private string m_szGenre;
		private int m_iGenre;
		private string m_szSubGenre;
		private int m_iSubGenre;
		private string m_szManufacturer;
		private string m_szManufacturerURL;
		private string m_szDeveloper;
		private string m_szDeveloperURL;

		#region  Properties for resolving data
		public string SoftGenre
		{
			get
			{
				return (this.m_szSoftGenre == null ? "" : this.m_szSoftGenre);
			}
		}

		public string SoftSubGenre
		{
			get
			{
				return (this.m_szSoftSubGenre == null ? "" : this.m_szSoftSubGenre);
			}
		}

		public String Title
		{
			get
			{
				return this.m_szTitle;
			}
		}

		public String Culture
		{
			get
			{
				return this.m_szCulture;
			}
		}

		public bool Active
		{
			get
			{
				return this.m_bActive;
			}
		}
		#endregion


		public LocalizedProduct(System.Data.SqlClient.SqlConnection objConn, int iProductCatalogId, Culture objCulture, Genre[] rgGenres)
		{
			//
			// TODO: Add constructor logic here
			//
			this.m_iProductCatalogId = iProductCatalogId;
			this.m_szCulture = objCulture.Name;

			System.Data.SqlClient.SqlCommand objCommand = new System.Data.SqlClient.SqlCommand();
			objCommand.Connection = objConn;

			objCommand.CommandText = "select * from [xbox_" + this.m_szCulture + "_catalog] cat, xbox_catalogproducts where cat.[#catalog_lang_oid] = xbox_catalogproducts.oid and xbox_catalogproducts.culture = '" + this.m_szCulture + "' and productid = " + this.m_iProductCatalogId;

			System.Data.SqlClient.SqlDataReader objRs = objCommand.ExecuteReader();

			if (objRs.Read())
			{
				this.m_bActive = true;
				this.m_szTitle = objRs.IsDBNull(objRs.GetOrdinal("Title")) ? "Unknown title" : objRs.GetString(objRs.GetOrdinal("title"));
				this.m_szLinkToURL = objRs.IsDBNull(objRs.GetOrdinal("LinkToURL")) ? "" : objRs.GetString(objRs.GetOrdinal("LinkToURL"));
				this.m_szDeveloper = objRs.IsDBNull(objRs.GetOrdinal("Developer")) ? "" : objRs.GetString(objRs.GetOrdinal("Developer"));
				this.m_szDeveloperURL = objRs.IsDBNull(objRs.GetOrdinal("DeveloperURL")) ? "" : objRs.GetString(objRs.GetOrdinal("DeveloperURL"));
				this.m_szPublisher = objRs.IsDBNull(objRs.GetOrdinal("Publisher")) ? "" : objRs.GetString(objRs.GetOrdinal("Publisher"));
				this.m_szPublisherURL = objRs.IsDBNull(objRs.GetOrdinal("PublisherURL")) ? "" : objRs.GetString(objRs.GetOrdinal("PublisherURL"));
				this.m_szManufacturer = objRs.IsDBNull(objRs.GetOrdinal("Manufacturer")) ? "" : objRs.GetString(objRs.GetOrdinal("Manufacturer"));
				this.m_szManufacturerURL = objRs.IsDBNull(objRs.GetOrdinal("ManufacturerURL")) ? "" : objRs.GetString(objRs.GetOrdinal("ManufacturerURL"));
				this.m_dListPrice = objRs.IsDBNull(objRs.GetOrdinal("cy_list_price")) ? 0 : objRs.GetSqlMoney(objRs.GetOrdinal("cy_list_price")).ToDouble();
				this.m_dOriginalPrice = objRs.IsDBNull(objRs.GetOrdinal("OriginalPrice")) ? 0 : objRs.GetSqlMoney(objRs.GetOrdinal("OriginalPrice")).ToDouble();
				this.m_szSoftGenre = objRs.IsDBNull(objRs.GetOrdinal("Genre")) ? "" : objRs.GetString(objRs.GetOrdinal("Genre"));
				this.m_szSoftSubGenre = objRs.IsDBNull(objRs.GetOrdinal("SubGenre")) ? "" : objRs.GetString(objRs.GetOrdinal("SubGenre"));
				this.m_bPlatinum = objRs.IsDBNull(objRs.GetOrdinal("PlatinumHits")) ? false : objRs.GetString(objRs.GetOrdinal("PlatinumHits")).ToLower() == "yes";
				this.m_szReleaseDate = objRs.IsDBNull(objRs.GetOrdinal("ReleaseDate")) ? "" : objRs.GetString(objRs.GetOrdinal("ReleaseDate"));
				this.m_dtReleaseDateSortable = objRs.IsDBNull(objRs.GetOrdinal("ReleaseDateSortable")) ? new DateTime(1, 1, 1) : objRs.GetDateTime(objRs.GetOrdinal("ReleaseDateSortable"));
				this.m_szRating = objRs.IsDBNull(objRs.GetOrdinal("Rating")) ? "" : objRs.GetString(objRs.GetOrdinal("Rating"));
				this.m_szRatingDescription = objRs.IsDBNull(objRs.GetOrdinal("RatingsContentDescriptor")) ? "" : objRs.GetString(objRs.GetOrdinal("RatingsContentDescriptor"));
				this.m_bCoOp = objRs.IsDBNull(objRs.GetOrdinal("Co-OpPlay")) ? false : objRs.GetString(objRs.GetOrdinal("Co-OpPlay")).ToLower().Equals("yes");
				this.m_bCustomSoundtracks = objRs.IsDBNull(objRs.GetOrdinal("CustomSoundtracks")) ? false : objRs.GetString(objRs.GetOrdinal("CustomSoundtracks")).ToLower().Equals("yes");
				this.m_bDolby51 = objRs.IsDBNull(objRs.GetOrdinal("Dolby51")) ? false : objRs.GetString(objRs.GetOrdinal("Dolby51")).ToLower().Equals("yes");
				this.m_bHDTV = objRs.IsDBNull(objRs.GetOrdinal("HDTV")) ? false : objRs.GetString(objRs.GetOrdinal("HDTV")).ToLower().Equals("yes");
				this.m_bHighlight = objRs.IsDBNull(objRs.GetOrdinal("Highlight")) ? false : objRs.GetString(objRs.GetOrdinal("Highlight")).ToLower().Equals("yes");
				this.m_bLiveContent = objRs.IsDBNull(objRs.GetOrdinal("Live-Content")) ? false : objRs.GetString(objRs.GetOrdinal("Live-Content")).ToLower().Equals("yes");
				this.m_bLiveContentDownload = objRs.IsDBNull(objRs.GetOrdinal("LiveContentDownload")) ? false : objRs.GetString(objRs.GetOrdinal("LiveContentDownload")).ToLower().Equals("yes");
				this.m_bLiveFriends = objRs.IsDBNull(objRs.GetOrdinal("Live-Friendslist")) ? false : objRs.GetString(objRs.GetOrdinal("Live-Friendslist")).ToLower().Equals("yes");
				this.m_bLiveKeyboard = objRs.IsDBNull(objRs.GetOrdinal("Live-Keyboard")) ? false : objRs.GetString(objRs.GetOrdinal("Live-Keyboard")).ToLower().Equals("yes");
				this.m_bLiveMultiplayer = objRs.IsDBNull(objRs.GetOrdinal("Live-Multiplayer")) ? false : objRs.GetString(objRs.GetOrdinal("Live-Multiplayer")).ToLower().Equals("yes");
				this.m_bLiveScoreboard = objRs.IsDBNull(objRs.GetOrdinal("Live-Scoreboard")) ? false : objRs.GetString(objRs.GetOrdinal("Live-Scoreboard")).ToLower().Equals("yes");
				this.m_bLiveStats = objRs.IsDBNull(objRs.GetOrdinal("Live-Stats")) ? false : objRs.GetString(objRs.GetOrdinal("Live-Stats")).ToLower().Equals("yes");
				this.m_bLiveVoice = objRs.IsDBNull(objRs.GetOrdinal("Live-Voice")) ? false : objRs.GetString(objRs.GetOrdinal("Live-Voice")).ToLower().Equals("yes");
				this.m_bMemoryUnit = objRs.IsDBNull(objRs.GetOrdinal("MemoryUnit")) ? false : objRs.GetString(objRs.GetOrdinal("MemoryUnit")).ToLower().Equals("yes");
				this.m_bMultiplayerVs = objRs.IsDBNull(objRs.GetOrdinal("Multiplayer-vs")) ? false : objRs.GetString(objRs.GetOrdinal("Multiplayer-vs")).ToLower().Equals("yes");
				this.m_szPlayers = objRs.IsDBNull(objRs.GetOrdinal("Players")) ? "1" : objRs.GetString(objRs.GetOrdinal("Players"));
				this.m_bSystemLink = objRs.IsDBNull(objRs.GetOrdinal("SystemLink")) ? false : objRs.GetString(objRs.GetOrdinal("SystemLink")).ToLower().Equals("yes");
				this.m_bXboxCompatible = objRs.IsDBNull(objRs.GetOrdinal("XboxCompatible")) ? false : objRs.GetString(objRs.GetOrdinal("XboxCompatible")).ToLower().Equals("yes");
				this.m_bXboxLicensed = objRs.IsDBNull(objRs.GetOrdinal("XboxLicensed")) ? false : objRs.GetString(objRs.GetOrdinal("XboxLicensed")).ToLower().Equals("yes");

				// determine the genre/subgenre this product should be.
				// Loop through all the localized product information and see if we can get a match
				for (int i = 0; i < rgGenres.Length; i++)
				{
					if (this.SoftGenre.ToLower().Equals(rgGenres[i].Name.ToLower()))
					{
						this.m_szGenre = rgGenres[i].Name;
						this.m_iGenre = rgGenres[i].GenreId;
					}

					if (this.SoftSubGenre.ToLower().Equals(rgGenres[i].Name.ToLower()))
					{
						this.m_szSubGenre = rgGenres[i].Name;
						this.m_iSubGenre = rgGenres[i].GenreId;
					}
				}
			}
			else
			{
				this.m_bActive = false;
			}

			objRs.Close();
		}

		public System.Xml.XmlNode XML(XmlDocument objXML)
		{
			System.Xml.XmlNode nodeCulture = objXML.CreateElement("culture");

			System.Xml.XmlAttribute attribValue = objXML.CreateAttribute("code");
			attribValue.Value = this.m_szCulture;
			nodeCulture.Attributes.Append(attribValue);

			XmlAttribute attrib = objXML.CreateAttribute("active");
			attrib.Value = (this.m_bActive ? "true" : "false");
			nodeCulture.Attributes.Append(attrib);

			XmlNode nodeElement = objXML.CreateElement("title");
			XmlNode nodeText = objXML.CreateTextNode("");
			nodeText.Value = this.m_szTitle;
			nodeElement.AppendChild(nodeText);
			nodeCulture.AppendChild(nodeElement);

			nodeElement = objXML.CreateElement("linktourl");
			nodeText = objXML.CreateTextNode("");
			nodeText.Value = this.m_szLinkToURL;
			nodeElement.AppendChild(nodeText);
			nodeCulture.AppendChild(nodeElement);

			nodeElement = objXML.CreateElement("developer");
			nodeText = objXML.CreateTextNode("");
			nodeText.Value = this.m_szDeveloper;
			nodeElement.AppendChild(nodeText);
			nodeCulture.AppendChild(nodeElement);

			nodeElement = objXML.CreateElement("developerurl");
			nodeText = objXML.CreateTextNode("");
			nodeText.Value = this.m_szDeveloperURL;
			nodeElement.AppendChild(nodeText);
			nodeCulture.AppendChild(nodeElement);

			nodeElement = objXML.CreateElement("publisher");
			nodeText = objXML.CreateTextNode("");
			nodeText.Value = this.m_szPublisher;
			nodeElement.AppendChild(nodeText);
			nodeCulture.AppendChild(nodeElement);

			nodeElement = objXML.CreateElement("publisherurl");
			nodeText = objXML.CreateTextNode("");
			nodeText.Value = this.m_szPublisherURL;
			nodeElement.AppendChild(nodeText);
			nodeCulture.AppendChild(nodeElement);

			nodeElement = objXML.CreateElement("manufacturer");
			nodeText = objXML.CreateTextNode("");
			nodeText.Value = this.m_szManufacturer;
			nodeElement.AppendChild(nodeText);
			nodeCulture.AppendChild(nodeElement);

			nodeElement = objXML.CreateElement("manufacturerurl");
			nodeText = objXML.CreateTextNode("");
			nodeText.Value = this.m_szManufacturerURL;
			nodeElement.AppendChild(nodeText);
			nodeCulture.AppendChild(nodeElement);

			attrib = objXML.CreateAttribute("listprice");
			attrib.Value = this.m_dListPrice.ToString();
			nodeCulture.Attributes.Append(attrib);

			attrib = objXML.CreateAttribute("originalprice");
			attrib.Value = this.m_dOriginalPrice.ToString();
			nodeCulture.Attributes.Append(attrib);

			attrib = objXML.CreateAttribute("platinum");
			attrib.Value = this.m_bPlatinum.ToString();
			nodeCulture.Attributes.Append(attrib);

			nodeElement = objXML.CreateElement("rating");
			nodeText = objXML.CreateTextNode("");
			nodeText.Value = this.m_szRating;
			nodeElement.AppendChild(nodeText);
			nodeCulture.AppendChild(nodeElement);

			nodeElement = objXML.CreateElement("ratingdescription");
			nodeText = objXML.CreateTextNode("");
			nodeText.Value = this.m_szRatingDescription;
			nodeElement.AppendChild(nodeText);
			nodeCulture.AppendChild(nodeElement);

			nodeElement = objXML.CreateElement("releasedate");
			nodeText = objXML.CreateTextNode("");
			nodeText.Value = this.m_szReleaseDate;
			nodeElement.AppendChild(nodeText);
			nodeCulture.AppendChild(nodeElement);

			attrib = objXML.CreateAttribute("releasedatesortable");
			attrib.Value = this.m_dtReleaseDateSortable.Ticks.ToString();
			nodeCulture.Attributes.Append(attrib);

			attrib = objXML.CreateAttribute("genre");
			attrib.Value = this.m_szGenre;
			nodeCulture.Attributes.Append(attrib);

			attrib = objXML.CreateAttribute("genreid");
			attrib.Value = this.m_iGenre.ToString();
			nodeCulture.Attributes.Append(attrib);

			attrib = objXML.CreateAttribute("subgenre");
			attrib.Value = this.m_szSubGenre;
			nodeCulture.Attributes.Append(attrib);

			attrib = objXML.CreateAttribute("subgenreid");
			attrib.Value = this.m_iSubGenre.ToString();
			nodeCulture.Attributes.Append(attrib);

			attrib = objXML.CreateAttribute("genretext");
			if (this.m_szSoftGenre != null && this.m_szSoftGenre.Length > 0)
			{
				attrib.Value = this.m_szSoftGenre;
			}
			else if (this.m_szSoftSubGenre != null)
			{
				attrib.Value = this.m_szSoftSubGenre;
			}
			else
			{
				attrib.Value = "";
			}
			nodeCulture.Attributes.Append(attrib);

			attrib = objXML.CreateAttribute("coop");
			attrib.Value = (this.m_bCoOp ? "true" : "false");
			nodeCulture.Attributes.Append(attrib);

			attrib = objXML.CreateAttribute("customsoundtracks");
			attrib.Value = (this.m_bCustomSoundtracks ? "true" : "false");
			nodeCulture.Attributes.Append(attrib);
			
			attrib = objXML.CreateAttribute("dolby51");
			attrib.Value = (this.m_bDolby51 ? "true" : "false");
			nodeCulture.Attributes.Append(attrib);
			
			attrib = objXML.CreateAttribute("hdtv");
			attrib.Value = (this.m_bHDTV ? "true" : "false");
			nodeCulture.Attributes.Append(attrib);

			attrib = objXML.CreateAttribute("highlight");
			attrib.Value = (this.m_bHighlight ? "true" : "false");
			nodeCulture.Attributes.Append(attrib);

			attrib = objXML.CreateAttribute("livecontent");
			attrib.Value = (this.m_bLiveContent ? "true" : "false");
			nodeCulture.Attributes.Append(attrib);

			attrib = objXML.CreateAttribute("livecontentdownload");
			attrib.Value = (this.m_bLiveContentDownload ? "true" : "false");
			nodeCulture.Attributes.Append(attrib);

			attrib = objXML.CreateAttribute("livefriends");
			attrib.Value = (this.m_bLiveFriends ? "true" : "false");
			nodeCulture.Attributes.Append(attrib);

			attrib = objXML.CreateAttribute("livekeyboard");
			attrib.Value = (this.m_bLiveKeyboard ? "true" : "false");
			nodeCulture.Attributes.Append(attrib);

			attrib = objXML.CreateAttribute("livemultiplayer");
			attrib.Value = (this.m_bLiveMultiplayer ? "true" : "false");
			nodeCulture.Attributes.Append(attrib);

			attrib = objXML.CreateAttribute("livescoreboard");
			attrib.Value = (this.m_bLiveScoreboard ? "true" : "false");
			nodeCulture.Attributes.Append(attrib);

			attrib = objXML.CreateAttribute("livestats");
			attrib.Value = (this.m_bLiveStats ? "true" : "false");
			nodeCulture.Attributes.Append(attrib);

			attrib = objXML.CreateAttribute("livevoice");
			attrib.Value = (this.m_bLiveVoice ? "true" : "false");
			nodeCulture.Attributes.Append(attrib);

			attrib = objXML.CreateAttribute("memoryunit");
			attrib.Value = (this.m_bMemoryUnit ? "true" : "false");
			nodeCulture.Attributes.Append(attrib);

			attrib = objXML.CreateAttribute("multiplayervs");
			attrib.Value = (this.m_bMultiplayerVs ? "true" : "false");
			nodeCulture.Attributes.Append(attrib);

			attrib = objXML.CreateAttribute("players");
			attrib.Value = this.m_szPlayers;
			nodeCulture.Attributes.Append(attrib);

			attrib = objXML.CreateAttribute("systemlink");
			attrib.Value = (this.m_bSystemLink ? "true" : "false");
			nodeCulture.Attributes.Append(attrib);

			attrib = objXML.CreateAttribute("xboxcompatible");
			attrib.Value = (this.m_bXboxCompatible ? "true" : "false");
			nodeCulture.Attributes.Append(attrib);
			
			attrib = objXML.CreateAttribute("xboxlicensed");
			attrib.Value = (this.m_bXboxLicensed ? "true" : "false");
			nodeCulture.Attributes.Append(attrib);

			return nodeCulture;
		}
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\xboxcomData\XboxComDataDump\Data\ProductList.cs ===
using System;
using System.Collections;
using System.Data;
using System.Xml;

namespace xonline.tools.xboxcomData.XboxComDataDump.Data
{
	/// <summary>
	/// Summary description for ProductList.
	/// </summary>
	public class ProductList
	{
		private Cultures m_Cultures;
		private Genres m_Genres;
		private ProductTypes m_ProductTypes;
		private Products m_Products;

		public ProductList()
		{
			//
			// TODO: Add constructor logic here
			//
		}

		#region Data Load
		public void Load(System.Data.SqlClient.SqlConnection objConn)
		{
			m_Cultures = new Cultures(objConn);
			m_Genres = new Genres(objConn, m_Cultures.CultureList);
			m_ProductTypes = new ProductTypes(objConn);
			m_Products = new Products(objConn, m_Cultures.CultureList, m_Genres.GenreList);
		}

		#endregion

		#region Data Save

		private System.Xml.XmlNode CreateMetaData(System.Xml.XmlDocument objXML)
		{
			XmlNode nodeMetaData = objXML.CreateNode(System.Xml.XmlNodeType.Element, "metadata", "");

			nodeMetaData.AppendChild(this.m_Cultures.XML(objXML));

			nodeMetaData.AppendChild(this.m_Genres.XML(objXML));

			nodeMetaData.AppendChild(this.m_ProductTypes.XML(objXML));

			return nodeMetaData;
		}

		public System.Xml.XmlDocument XML
		{
			get
			{
				System.Xml.XmlDocument objXML = new XmlDocument();

				// create <productcatalog>
				XmlNode nodeProductCatalog = objXML.CreateNode(System.Xml.XmlNodeType.Element, "productcatalog", "");
				objXML.AppendChild(nodeProductCatalog);

				nodeProductCatalog.AppendChild(this.CreateMetaData(objXML));

				nodeProductCatalog.AppendChild(this.m_Products.XML(objXML));

				return objXML;
			}
		}
		#endregion
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\xboxcomData\XboxComDataDump\Data\Product.cs ===
using System;
using System.Collections;
using System.Xml;

namespace xonline.tools.xboxcomData.XboxComDataDump.Data
{
	/// <summary>
	/// Summary description for Product.
	/// </summary>
	public class Product
	{
		private string m_szProductType;
		private string m_szProductName = "";
		private int m_iProductCatalogId;

		private ArrayList m_arrLocalizedProducts = new ArrayList();
		#region Properties
		public string ProductType
		{
			set
			{
				this.m_szProductType = value;
			}

			get
			{
				return this.m_szProductType;
			}
		}

		public int ProductCatalogId
		{
			set
			{
				this.m_iProductCatalogId = value;
			}

			get
			{
				return this.m_iProductCatalogId;
			}
		}

		#endregion

		public Product()
		{
			//
			// TODO: Add constructor logic here
			//
		}

		public void LoadData(System.Data.SqlClient.SqlConnection objConn, Culture[] rgCultures, Genre[] rgGenres)
		{
			System.Data.SqlClient.SqlCommand objCommand = new System.Data.SqlClient.SqlCommand();
			objCommand.Connection = objConn;

			objCommand.CommandText = "select * from xbox_catalogproducts where productid = " + this.m_iProductCatalogId + " and culture is null";

			System.Data.SqlClient.SqlDataReader objRs = objCommand.ExecuteReader();

			while (objRs.Read())
			{
				this.m_szProductType = objRs.GetString(objRs.GetOrdinal("DefinitionName"));
			}

			objRs.Close();

			LocalizedProduct lclp;

			for (int i = 0; i < rgCultures.Length; i++)
			{
				lclp = new LocalizedProduct(objConn, this.m_iProductCatalogId, rgCultures[i], rgGenres);

				this.m_arrLocalizedProducts.Add(lclp);
			}

			System.Collections.IEnumerator myEnum;

			// get the product name.  Preference is English, then japanese, then whatever we can find
			myEnum = this.m_arrLocalizedProducts.GetEnumerator();

			while (myEnum.MoveNext())
			{
				lclp = (LocalizedProduct)(myEnum.Current);
					
				if (lclp.Culture.ToLower().Equals("en-us") && lclp.Active)
				{
					this.m_szProductName = lclp.Title;
				}
			}

			// if english wasn't found, then default to japanese
			if (this.m_szProductName.Equals(""))
			{
				myEnum = this.m_arrLocalizedProducts.GetEnumerator();

				while (myEnum.MoveNext())
				{
					lclp = (LocalizedProduct)(myEnum.Current);
					
					if (lclp.Culture.ToLower().Equals("ja-kp") && lclp.Active)
					{
						this.m_szProductName = lclp.Title;
					}
				}
			}

			// if japanese wasn't found, just find the first active culture
			if (this.m_szProductName.Equals(""))
			{
				myEnum = this.m_arrLocalizedProducts.GetEnumerator();

				while (myEnum.MoveNext())
				{
					lclp = (LocalizedProduct)(myEnum.Current);
					
					if (lclp.Active)
					{
						this.m_szProductName = lclp.Title;
					}
				}
			}

			// if no title is found, the product name will be Product (ID)
			if (this.m_szProductName.Equals(""))
			{
				this.m_szProductName = "Product #" + this.m_iProductCatalogId.ToString();
			}
		}

		public System.Xml.XmlNode XML(XmlDocument objXML)
		{
			// create <product> sub-node
			XmlNode nodeProduct = objXML.CreateNode(System.Xml.XmlNodeType.Element, "product", "");

			System.Xml.XmlAttribute attribProductCatalogId = objXML.CreateAttribute("productcatalogid");
			attribProductCatalogId.Value = this.m_iProductCatalogId.ToString();

			nodeProduct.Attributes.Append(attribProductCatalogId);

			System.Xml.XmlAttribute attribProductType = objXML.CreateAttribute("producttype");
			attribProductType.Value = this.m_szProductType;

			nodeProduct.Attributes.Append(attribProductType);

			XmlNode nodeTitle = objXML.CreateElement("title");
			XmlNode nodeTitleText = objXML.CreateTextNode(this.m_szProductName);
			nodeTitle.AppendChild(nodeTitleText);
			nodeProduct.AppendChild(nodeTitle);
			
			XmlNode nodeLocalizedContent = objXML.CreateElement("localizedcontent");

			System.Collections.IEnumerator myEnum = this.m_arrLocalizedProducts.GetEnumerator();

			while (myEnum.MoveNext())
			{
				LocalizedProduct lclp = (LocalizedProduct)myEnum.Current;
				nodeLocalizedContent.AppendChild(lclp.XML(objXML));
			}

			nodeProduct.AppendChild(nodeLocalizedContent);

			return nodeProduct;
		}
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\xboxcomData\XboxComDataDump\Data\ProductType.cs ===
using System;
using System.Collections;
using System.Xml;

namespace xonline.tools.xboxcomData.XboxComDataDump.Data
{
	/// <summary>
	/// Summary description for ProductType.
	/// </summary>
	public class ProductType
	{
		private String m_szName;

		public ProductType()
		{
			//
			// TODO: Add constructor logic here
			//
		}

		public String Name
		{
			set
			{
				this.m_szName = value;
			}
			get
			{
				return this.m_szName;
			}
		}

		public System.Xml.XmlNode XML(XmlDocument objXML)
		{
			System.Xml.XmlNode nodeProductType = objXML.CreateNode(System.Xml.XmlNodeType.Element, "producttype", "");
			System.Xml.XmlAttribute attribProductType = objXML.CreateAttribute("name");
			attribProductType.Value = this.Name;

			nodeProductType.Attributes.Append(attribProductType);

			return nodeProductType;
		}
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\xboxcomData\XboxComDataDump\Data\Products.cs ===
using System;
using System.Collections;
using System.Xml;

namespace xonline.tools.xboxcomData.XboxComDataDump.Data
{
	/// <summary>
	/// Summary description for Products.
	/// </summary>
	public class Products
	{
		private ArrayList m_arrProducts = new ArrayList();

		public Products(System.Data.SqlClient.SqlConnection objConn, Culture[] rgCultures, Genre[] rgGenres)
		{
			System.Data.SqlClient.SqlCommand objCommand = new System.Data.SqlClient.SqlCommand();
			objCommand.Connection = objConn;

			objCommand.CommandText = "select distinct cast(productid as int) as productid from xbox_catalogproducts where DefinitionName = 'Game' or DefinitionName = 'Hardware' order by cast (productid as int)";

			System.Data.SqlClient.SqlDataReader objRs = objCommand.ExecuteReader();

			while (objRs.Read())
			{
				Product product = new Product();
				product.ProductCatalogId = objRs.GetInt32(objRs.GetOrdinal("productid"));

				this.m_arrProducts.Add(product);
			}

			objRs.Close();

			System.Collections.IEnumerator myEnum = this.m_arrProducts.GetEnumerator();

			while (myEnum.MoveNext())
			{
				Product product = (Product)myEnum.Current;

				product.LoadData(objConn, rgCultures, rgGenres);
			}
		}

		public System.Xml.XmlNode XML(XmlDocument objXML)
		{
			// create <products> sub-node
			XmlNode nodeProducts = objXML.CreateNode(System.Xml.XmlNodeType.Element, "products", "");

			// append all products
			System.Collections.IEnumerator myEnum = this.m_arrProducts.GetEnumerator();
			XmlNode nodeProduct;

			while (myEnum.MoveNext())
			{
				nodeProduct = ((Product)myEnum.Current).XML(objXML);
				nodeProducts.AppendChild(nodeProduct);
			}

			return nodeProducts;
		}
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\xboxcomData\XboxComDataDump\Data\ProductTypes.cs ===
using System;
using System.Collections;
using System.Xml;

namespace xonline.tools.xboxcomData.XboxComDataDump.Data
{
	/// <summary>
	/// Summary description for ProductTypes.
	/// </summary>
	public class ProductTypes
	{
		private ArrayList m_arrProductTypes = new ArrayList();

		public ProductTypes(System.Data.SqlClient.SqlConnection objConn)
		{
			System.Data.SqlClient.SqlCommand objCommand = new System.Data.SqlClient.SqlCommand();
			objCommand.Connection = objConn;

			objCommand.CommandText = "select distinct producttype from [xbox_catalogproducts] where producttype is not NULL";

			System.Data.SqlClient.SqlDataReader objRs = objCommand.ExecuteReader();

			while (objRs.Read())
			{
				ProductType productType = new ProductType();
				productType.Name = objRs.GetString(0);

				this.m_arrProductTypes.Add(productType);
			}

			objRs.Close();
		}

		public System.Xml.XmlNode XML(XmlDocument objXML)
		{
			// create <producttypes> sub-node
			XmlNode nodeProductTypes = objXML.CreateNode(System.Xml.XmlNodeType.Element, "producttypes", "");

			// append all products
			System.Collections.IEnumerator myEnum = this.m_arrProductTypes.GetEnumerator();
			XmlNode nodeProductType;

			while (myEnum.MoveNext())
			{
				nodeProductType = ((ProductType)myEnum.Current).XML(objXML);
				nodeProductTypes.AppendChild(nodeProductType);
			}

			return nodeProductTypes;
		}
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\xboxcomData\XboxComDataRestore\components\Culture.cs ===
using System;
using System.Globalization;

namespace xonline.tools.xboxcomData.XboxComDataRestore.components
{
	/// <summary>
	/// Summary description for Culture.
	/// </summary>
	public class Culture
	{
		private string m_szCode;
		private string m_szCultureName;
		private int m_iCultureId;
		private Rating[] m_rgRatings;

		public Culture(string szCode, System.Data.SqlClient.SqlConnection objConn)
		{
			this.m_szCode = szCode;

			CultureInfo ci = new CultureInfo(szCode);
			this.m_szCultureName = ci.EnglishName;
			this.m_iCultureId = ci.LCID;

			this.LoadRatings(objConn);
		}

		public string Code
		{
			get
			{
				return this.m_szCode;
			}
		}

		public int Id
		{
			get
			{
				return this.m_iCultureId;
			}
		}

		public string Name
		{
			get
			{
				return this.m_szCultureName;
			}
		}

		private void LoadRatings(System.Data.SqlClient.SqlConnection objConn)
		{
			System.Data.SqlClient.SqlCommand objCmd = objConn.CreateCommand();
			System.Data.SqlClient.SqlDataReader objRs = null;

			Rating rating;
			System.Collections.ArrayList arrRatings = new System.Collections.ArrayList();
			int iRatingId;
			string szRating;

			try
			{
				objCmd.CommandText = "p_pcat_GetRatingList";
				objCmd.CommandType = System.Data.CommandType.StoredProcedure;

				System.Data.SqlClient.SqlParameter objParam;

				objParam = new System.Data.SqlClient.SqlParameter();
				objParam.ParameterName = "@cultureId";
				objParam.SqlDbType = System.Data.SqlDbType.Int;
				objParam.Value = this.m_iCultureId;
				objCmd.Parameters.Add(objParam);

				objRs = objCmd.ExecuteReader();		

				while(objRs.Read())
				{
					iRatingId = objRs.GetInt32(objRs.GetOrdinal("RatingId"));
					szRating = objRs.GetString(objRs.GetOrdinal("Description"));

					rating = new Rating(iRatingId, szRating);

					arrRatings.Add(rating);
				}

				this.m_rgRatings = new Rating[arrRatings.Count];

				System.Collections.IEnumerator myEnum = arrRatings.GetEnumerator();

				int i = 0;
				while (myEnum.MoveNext())
				{
					rating = (Rating)myEnum.Current;
					this.m_rgRatings[i++] = rating;
				}
			}
			catch (Exception ex)
			{
				throw new Exception("Error saving culture information. " + ex.Message);
			}
			finally
			{
				objRs.Close();
			}
		}

		public int GetRatingId(string szRating)
		{
			int iReturn = 0;
			
			// a ton of hacks to fix unnormalized ratings
			if (szRating.Length == 0)
			{
				return iReturn;
			}

			if ((szRating == "Rating Pending to Mature" || szRating == "Pending to Mature") && this.m_iCultureId == 1033)
			{
				szRating = "None";
			}
			else if ((szRating == "mature" || szRating == "Matuer") && this.m_iCultureId == 1033)
			{
				szRating = "Mature";
			}
			else if (szRating == "G 8+" && this.m_iCultureId == 3081)
			{
				szRating = "G8+";
			}
			else if (szRating == "G 8+" && this.m_iCultureId == 5129)
			{
				szRating = "G8+";
			}
			else if ((szRating == "MA15+" || szRating == "MA 15+") && this.m_iCultureId == 3081)
			{
				szRating = "M15+";
			}
			else if (szRating == "Not Yet Rated" && this.m_iCultureId == 3081)
			{
				szRating = "None";
			}
			else if (szRating == "TBC" && this.m_iCultureId == 3081)
			{
				szRating = "None";
			}
			else if ((szRating == "R16" || szRating == "NZ - R16") && this.m_iCultureId == 5129)
			{
				szRating = "M15+";
			}
			else if (szRating == "R18" && this.m_iCultureId == 5129)
			{
				szRating = "M15+";
			}
			else if (szRating == "MA15+" && this.m_iCultureId == 5129)
			{
				szRating = "M15+";
			}
			else if ((szRating == "Not Yet Rated" || szRating == "Yet To Be Rated") && this.m_iCultureId == 5129)
			{
				szRating = "None";
			}
			else if (szRating == "TBC" && this.m_iCultureId == 5129)
			{
				szRating = "None";
			}
			else if (szRating == "Adolescents" && this.m_iCultureId == 3084)
			{
				szRating = "Teen";
			}
			else if ((szRating == "Jeunes adultes" || szRating == "Adultes Jeunesse" || szRating == "Jeunes Adultes") && this.m_iCultureId == 3084)
			{
				szRating = "Teen";
			}
			else if (szRating == "Aún no disponible" && this.m_iCultureId == 3082)
			{
				szRating = "None";
			}
			else if (szRating == "ADOLESCENTS" && this.m_iCultureId == 3084)
			{
				szRating = "Teen";
			}
			else if (szRating == "Bald erhältlich" && (this.m_iCultureId == 1031 || this.m_iCultureId == 3079 || this.m_iCultureId == 2055))
			{
				szRating = "None";
			}
			else if (szRating == "3+" && this.m_iCultureId == 1031)
			{
				szRating = "6 years";
			}
			else if (szRating == "Tous" && this.m_iCultureId == 3084)
			{
				szRating = "Everyone";
			}
			else if (szRating == "CLASSEMENT À VENIR" && this.m_iCultureId == 3084)
			{
				szRating = "None";
			}
			else if ((szRating == "Tout public" || szRating == "tout public") && this.m_iCultureId == 1036)
			{
				szRating = "3+";
			}
			else if (szRating == "Todos los públicos" && this.m_iCultureId == 3082)
			{
				szRating = "3+";
			}
			else if (szRating == "NR MENORES DE 13" && this.m_iCultureId == 3082)
			{
				szRating = "12+";
			}
			else if (szRating == "NR MENORES DE 16" && this.m_iCultureId == 3082)
			{
				szRating = "16+";
			}
			else if (szRating == "NR MENORES DE 18" && this.m_iCultureId == 3082)
			{
				szRating = "18+";
			}
			else if (szRating == "--" && this.m_iCultureId == 1041)
			{
				szRating = "None";
			}
			else if ((szRating == "Bientôt disponible" || szRating == "Bientôt Disponible") && (this.m_iCultureId == 2060 || this.m_iCultureId == 1036 || this.m_iCultureId == 3084))
			{
				szRating = "None";
			}
			else if (szRating == "Nog niet beschikbaar" && (this.m_iCultureId == 2067 || this.m_iCultureId == 1043))
			{
				szRating = "None";
			}
			else if (szRating == "Endnu ikke vurderet" && this.m_iCultureId == 1030)
			{
				szRating = "None";
			}
			else if (szRating == "Ei vielä vahvistettu" && this.m_iCultureId == 1035)
			{
				szRating = "None";
			}
			else if (szRating == "Δεν είναι ακόμα διαθέσιμο" && this.m_iCultureId == 1032)
			{
				szRating = "None";
			}
			else if (szRating == "Not available yet" && this.m_iCultureId == 6153)
			{
				szRating = "None";
			}
			else if (szRating == "Non ancora disponibile" && this.m_iCultureId == 1040)
			{
				szRating = "None";
			}
			else if (szRating == "Under vurdering" && this.m_iCultureId == 1044)
			{
				szRating = "None";
			}
			else if (szRating == "Ainda não disponíve" && this.m_iCultureId == 2070)
			{
				szRating = "None";
			}
			else if (szRating == "Inte tillgängligt ännu" && this.m_iCultureId == 1053)
			{
				szRating = "None";
			}
			else if (szRating == "Not available yet" && this.m_iCultureId == 2057)
			{
				szRating = "None";
			}
			else if (szRating == "Not yet available" && this.m_iCultureId == 6153)
			{
				szRating = "None";
			}
			else if (szRating == "全年齢対象" && this.m_iCultureId == 1041)
			{
				szRating = "All";
			}
			else if ((szRating == "12才以上対象" || szRating == "12歳以上対象" || szRating == "12 才以上対象") && this.m_iCultureId == 1041)
			{
				szRating = "12+";
			}
			else if ((szRating == "15才以上対象" || szRating == "15 才以上対象" || szRating == "15歳以上対象") && this.m_iCultureId == 1041)
			{
				szRating = "15+";
			}
			else if ((szRating == "18才以上対象" || szRating == "18歳以上以上" || szRating == "18歳以上推奨" || szRating == "18歳以上対象") && this.m_iCultureId == 1041)
			{
				szRating = "18+";
			}
			else if (szRating == "12+" && this.m_iCultureId == 1031)
			{
				szRating = "12";
			}
			else if (szRating == "15+" && this.m_iCultureId == 2057)
			{
				szRating = "16+";
			}
			else if (szRating == "Geeignet ohne Altersbeschränkung" && this.m_iCultureId == 1031)
			{
				szRating = "Released without age restriction";
			}
			else if (szRating == "16+" && this.m_iCultureId == 1031)
			{
				szRating = "16 years";
			}
			else if (this.m_iCultureId == 2058) // if this is mexico..  for now just ignore.  do they use esrb?
			{
				return 0;
			}
			else if (szRating == "Aventure" && this.m_iCultureId == 3084) // typo, genre in rating
			{
				return 0;
			}
			else if (this.m_iCultureId == 2070) // for some reason, portugese doesn't seem to match
			{
				return 0;
			}

			// iterate through ratings and try to resolve
			for (int i = 0; i < this.m_rgRatings.Length; i++)
			{
				if (this.m_rgRatings[i].Name.IndexOf(szRating) >= 0)
				{
					return this.m_rgRatings[i].Id;
				}
			}

			return iReturn;
		}

		public void Save(System.Data.SqlClient.SqlConnection objConn)
		{
			System.Data.SqlClient.SqlCommand objCmd = objConn.CreateCommand();
//			System.Data.SqlClient.SqlDataReader objRs = null;
			
			try
			{
//				objCmd.CommandText = "p_pcat_AddCulture";
//				objCmd.CommandType = System.Data.CommandType.StoredProcedure;
//
//				System.Data.SqlClient.SqlParameter objParam;
//
//				objParam = new System.Data.SqlClient.SqlParameter();
//				objParam.ParameterName = "@cultureId";
//				objParam.SqlDbType = System.Data.SqlDbType.Int;
//				objParam.Value = this.m_iCultureId;
//				objCmd.Parameters.Add(objParam);
//
//				objParam = new System.Data.SqlClient.SqlParameter();
//				objParam.ParameterName = "@cultureName";
//				objParam.SqlDbType = System.Data.SqlDbType.NVarChar;
//				objParam.Size = this.m_szCultureName.Length;
//				objParam.Value = this.m_szCultureName;
//				objCmd.Parameters.Add(objParam);
//
//				objParam = new System.Data.SqlClient.SqlParameter();
//				objParam.ParameterName = "@cultureCode";
//				objParam.SqlDbType = System.Data.SqlDbType.NVarChar;
//				objParam.Size = this.m_szCode.Length;
//				objParam.Value = this.m_szCode;
//				objCmd.Parameters.Add(objParam);
//
//				objRs = objCmd.ExecuteReader();		
//
//				objRs.Read();

//				this.m_iCultureId = objRs.GetInt32(objRs.GetOrdinal("CultureId"));
			}
			catch (Exception ex)
			{
				throw new Exception("Error saving culture information. " + ex.Message);
			}
			finally
			{
//				objRs.Close();
			}
		}
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\xboxcomData\XboxComDataRestore\components\Genre.cs ===
using System;

namespace xonline.tools.xboxcomData.XboxComDataRestore.components
{
	/// <summary>
	/// Summary description for Genre.
	/// </summary>
	public class Genre
	{
		private string m_szName;
		private int m_iGenreId;

		public Genre(string szName)
		{
			this.m_szName = szName;
		}

		public string Name
		{
			get
			{
				return this.m_szName;
			}
		}

		public int Id
		{
			get
			{
				return this.m_iGenreId;
			}
		}

		public void Save(System.Data.SqlClient.SqlConnection objConn)
		{
			System.Data.SqlClient.SqlCommand objCmd = objConn.CreateCommand();
			System.Data.SqlClient.SqlDataReader objRs = null;
			
			try
			{
				objCmd.CommandText = "p_pcat_LookupGenreId";
				objCmd.CommandType = System.Data.CommandType.StoredProcedure;

				System.Data.SqlClient.SqlParameter objParam;
				objParam = new System.Data.SqlClient.SqlParameter();
				objParam.ParameterName = "@genreName";
				objParam.SqlDbType = System.Data.SqlDbType.NVarChar;
				objParam.Size = this.m_szName.Length;
				objParam.Value = this.m_szName;
				objCmd.Parameters.Add(objParam);

				objRs = objCmd.ExecuteReader();		

				objRs.Read();

				this.m_iGenreId = objRs.GetInt32(objRs.GetOrdinal("GenreId"));
			}
			catch (Exception ex)
			{
				throw new Exception("Error saving genre information. " + ex.Message);
			}
			finally
			{
				objRs.Close();
			}
		}
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\xboxcomData\XboxComDataRestore\XboxComDataRestore.cs ===
using System;
using System.Drawing;
using System.Collections;
using System.ComponentModel;
using System.Windows.Forms;
using System.Data;
using xonline.tools.xboxcomData.XboxComDataRestore.components;
using xonline.server.xboxcom.lib.logic.ProductCatalog.authoring;

namespace xonline.tools.xboxcomData.XboxComDataRestore
{
	/// <summary>
	/// Summary description for Form1.
	/// </summary>
	public class XboxComDataRestore : System.Windows.Forms.Form
	{
		private System.Data.SqlClient.SqlConnection sqlConnection1;
		private System.Windows.Forms.OpenFileDialog openFileDialog1;
		private System.Windows.Forms.Button button2;
		private System.Windows.Forms.Button button1;
		private System.Windows.Forms.TextBox m_txtFilename;
		private System.Windows.Forms.Label label5;
		private System.Windows.Forms.TextBox m_txtDatabase;
		private System.Windows.Forms.Label label2;
		private System.Windows.Forms.TextBox m_txtDatabaseServer;
		private System.Windows.Forms.Label label1;
        private System.Windows.Forms.Button button3;
        private System.Windows.Forms.TextBox m_txtMappingFilename;
        private System.Windows.Forms.Label label3;
		/// <summary>
		/// Required designer variable.
		/// </summary>
		private System.ComponentModel.Container components = null;

		public XboxComDataRestore()
		{
			//
			// Required for Windows Form Designer support
			//
			InitializeComponent();

			//
			// TODO: Add any constructor code after InitializeComponent call
			//
		}

		/// <summary>
		/// Clean up any resources being used.
		/// </summary>
		protected override void Dispose( bool disposing )
		{
			if( disposing )
			{
				if (components != null) 
				{
					components.Dispose();
				}
			}
			base.Dispose( disposing );
		}

		#region Windows Form Designer generated code
		/// <summary>
		/// Required method for Designer support - do not modify
		/// the contents of this method with the code editor.
		/// </summary>
		private void InitializeComponent()
		{
            this.sqlConnection1 = new System.Data.SqlClient.SqlConnection();
            this.openFileDialog1 = new System.Windows.Forms.OpenFileDialog();
            this.button2 = new System.Windows.Forms.Button();
            this.button1 = new System.Windows.Forms.Button();
            this.m_txtFilename = new System.Windows.Forms.TextBox();
            this.label5 = new System.Windows.Forms.Label();
            this.m_txtDatabase = new System.Windows.Forms.TextBox();
            this.label2 = new System.Windows.Forms.Label();
            this.m_txtDatabaseServer = new System.Windows.Forms.TextBox();
            this.label1 = new System.Windows.Forms.Label();
            this.button3 = new System.Windows.Forms.Button();
            this.m_txtMappingFilename = new System.Windows.Forms.TextBox();
            this.label3 = new System.Windows.Forms.Label();
            this.SuspendLayout();
            // 
            // button2
            // 
            this.button2.Location = new System.Drawing.Point(136, 160);
            this.button2.Name = "button2";
            this.button2.Size = new System.Drawing.Size(96, 32);
            this.button2.TabIndex = 23;
            this.button2.Text = "Restore";
            this.button2.Click += new System.EventHandler(this.button2_Click);
            // 
            // button1
            // 
            this.button1.Location = new System.Drawing.Point(312, 96);
            this.button1.Name = "button1";
            this.button1.Size = new System.Drawing.Size(24, 16);
            this.button1.TabIndex = 22;
            this.button1.Text = "..";
            this.button1.Click += new System.EventHandler(this.button1_Click);
            // 
            // m_txtFilename
            // 
            this.m_txtFilename.Location = new System.Drawing.Point(112, 96);
            this.m_txtFilename.Name = "m_txtFilename";
            this.m_txtFilename.Size = new System.Drawing.Size(192, 20);
            this.m_txtFilename.TabIndex = 21;
            this.m_txtFilename.Text = "c:\\output.xml";
            // 
            // label5
            // 
            this.label5.Location = new System.Drawing.Point(72, 96);
            this.label5.Name = "label5";
            this.label5.Size = new System.Drawing.Size(32, 16);
            this.label5.TabIndex = 20;
            this.label5.Text = "File:";
            // 
            // m_txtDatabase
            // 
            this.m_txtDatabase.Location = new System.Drawing.Point(112, 60);
            this.m_txtDatabase.Name = "m_txtDatabase";
            this.m_txtDatabase.Size = new System.Drawing.Size(192, 20);
            this.m_txtDatabase.TabIndex = 15;
            this.m_txtDatabase.Text = "productdb";
            // 
            // label2
            // 
            this.label2.Location = new System.Drawing.Point(40, 60);
            this.label2.Name = "label2";
            this.label2.Size = new System.Drawing.Size(56, 16);
            this.label2.TabIndex = 14;
            this.label2.Text = "Database:";
            // 
            // m_txtDatabaseServer
            // 
            this.m_txtDatabaseServer.Location = new System.Drawing.Point(112, 28);
            this.m_txtDatabaseServer.Name = "m_txtDatabaseServer";
            this.m_txtDatabaseServer.Size = new System.Drawing.Size(192, 20);
            this.m_txtDatabaseServer.TabIndex = 13;
            this.m_txtDatabaseServer.Text = "localhost";
            // 
            // label1
            // 
            this.label1.Location = new System.Drawing.Point(8, 28);
            this.label1.Name = "label1";
            this.label1.Size = new System.Drawing.Size(104, 16);
            this.label1.TabIndex = 12;
            this.label1.Text = "Database Server:";
            // 
            // button3
            // 
            this.button3.Location = new System.Drawing.Point(312, 128);
            this.button3.Name = "button3";
            this.button3.Size = new System.Drawing.Size(24, 16);
            this.button3.TabIndex = 26;
            this.button3.Text = "..";
            this.button3.Click += new System.EventHandler(this.button3_Click);
            // 
            // m_txtMappingFilename
            // 
            this.m_txtMappingFilename.Location = new System.Drawing.Point(112, 128);
            this.m_txtMappingFilename.Name = "m_txtMappingFilename";
            this.m_txtMappingFilename.Size = new System.Drawing.Size(192, 20);
            this.m_txtMappingFilename.TabIndex = 25;
            this.m_txtMappingFilename.Text = "c:\\mapping.xml";
            // 
            // label3
            // 
            this.label3.Location = new System.Drawing.Point(8, 128);
            this.label3.Name = "label3";
            this.label3.Size = new System.Drawing.Size(104, 16);
            this.label3.TabIndex = 24;
            this.label3.Text = "Save mapping File:";
            // 
            // XboxComDataRestore
            // 
            this.AutoScaleBaseSize = new System.Drawing.Size(5, 13);
            this.ClientSize = new System.Drawing.Size(352, 213);
            this.Controls.Add(this.button3);
            this.Controls.Add(this.m_txtMappingFilename);
            this.Controls.Add(this.label3);
            this.Controls.Add(this.button2);
            this.Controls.Add(this.button1);
            this.Controls.Add(this.m_txtFilename);
            this.Controls.Add(this.m_txtDatabase);
            this.Controls.Add(this.m_txtDatabaseServer);
            this.Controls.Add(this.label5);
            this.Controls.Add(this.label2);
            this.Controls.Add(this.label1);
            this.Name = "XboxComDataRestore";
            this.Text = "XboxComDataRestore Tool";
            this.ResumeLayout(false);

        }
		#endregion

		/// <summary>
		/// The main entry point for the application.
		/// </summary>
		[STAThread]
		static void Main() 
		{
			Application.Run(new XboxComDataRestore());
		}

		private void button1_Click(object sender, System.EventArgs e)
		{
			this.openFileDialog1.ShowDialog();

			this.m_txtFilename.Text = this.openFileDialog1.FileName;
		}

		private void button2_Click(object sender, System.EventArgs e)
		{
			try
			{
				this.sqlConnection1.ConnectionString =  
						"Server=" + this.m_txtDatabaseServer.Text + ";" +
						"Database=" + this.m_txtDatabase.Text + ";" +
						"Integrated Security=SSPI;";
				this.sqlConnection1.Open();

				ProductCatalog pc = new ProductCatalog(this.m_txtFilename.Text, this.sqlConnection1);

				pc.Save(this.m_txtMappingFilename.Text, this.sqlConnection1);

				System.Windows.Forms.MessageBox.Show("Data has been restored.", "Done!");
			}
			catch (Exception ex)
			{
				System.Windows.Forms.MessageBox.Show(ex.Message, "SQL Connection Error");
			}
			finally
			{
				// close connection
				this.sqlConnection1.Close();
			}
		}

        private void button3_Click(object sender, System.EventArgs e)
        {
            this.openFileDialog1.ShowDialog();

            this.m_txtMappingFilename.Text = this.openFileDialog1.FileName;
        }
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\xboxcomData\XboxComDataRestore\components\Metadata.cs ===
using System;
using System.Collections;
using System.Xml;

namespace xonline.tools.xboxcomData.XboxComDataRestore.components
{
	/// <summary>
	/// Summary description for Metadata.
	/// </summary>
	public class Metadata
	{
		private ProductType[] m_rgProductTypes;
		private Genre[] m_rgGenres;
		private Culture[] m_rgCultures;

		public Metadata(XmlNode nodeMetadata, System.Data.SqlClient.SqlConnection objConn)
		{
			XmlNode nodeCultures;
			XmlNode nodeGenres;
			XmlNode nodeProductTypes;

			try
			{
				nodeCultures = nodeMetadata.SelectSingleNode("cultures");
				nodeGenres = nodeMetadata.SelectSingleNode("genres");
				nodeProductTypes = nodeMetadata.SelectSingleNode("producttypes");

				// parse through cultures
				this.m_rgCultures = new Culture[nodeCultures.ChildNodes.Count];
				for (int i = 0; i < nodeCultures.ChildNodes.Count; i++)
				{
					this.m_rgCultures[i] = new Culture(nodeCultures.ChildNodes.Item(i).Attributes.GetNamedItem("code").Value, objConn);
				}

				this.m_rgGenres = new Genre[nodeGenres.ChildNodes.Count];
				for (int i = 0; i < nodeGenres.ChildNodes.Count; i++)
				{
					this.m_rgGenres[i] = new Genre(nodeGenres.ChildNodes.Item(i).Attributes.GetNamedItem("name").Value);
				}

				this.m_rgProductTypes = new ProductType[nodeProductTypes.ChildNodes.Count];
				for (int i = 0; i < nodeProductTypes.ChildNodes.Count; i++)
				{
					this.m_rgProductTypes[i] = new ProductType(nodeProductTypes.ChildNodes.Item(i).Attributes.GetNamedItem("name").Value);
				}
			}
			catch (Exception ex)
			{
				throw new Exception("Error parsing metadata. " + ex.Message);
			}
			finally
			{

			}
		}

		public void Save(System.Data.SqlClient.SqlConnection objConn)
		{
//			System.IO.StreamWriter sOutput = new System.IO.FileInfo("C:\\cultures.txt").CreateText();
//			sOutput.WriteLine("<cultures>");
			for (int i = 0; i < this.m_rgCultures.Length; i++)
			{
				// assume that all cultures are in the database now
//				this.m_rgCultures[i].Save(objConn);
//				sOutput.WriteLine("  <culture cultureid=\""+ this.m_rgCultures[i].Id.ToString() + "\" name=\"" + this.m_rgCultures[i].Name + "\" code=\"" + this.m_rgCultures[i].Code + "\"/>");
//				sOutput.WriteLine("exec [dbo].[p_pcat_AddCulture] @cultureId=" + this.m_rgCultures[i].Id.ToString() + ", @cultureName=N'" + this.m_rgCultures[i].Name +"', @cultureCode=N'" + this.m_rgCultures[i].Code + "'");
			}

//			sOutput.WriteLine("</cultures>");
//			sOutput.Close();

			for (int i = 0; i < this.m_rgGenres.Length; i++)
			{
				this.m_rgGenres[i].Save(objConn);
			}

			for (int i = 0; i < this.m_rgProductTypes.Length; i++)
			{
				this.m_rgProductTypes[i].Save(objConn);
			}
		}

		public int GetRatingId(int iCultureId, string szRating)
		{
			for (int i = 0; i < this.m_rgCultures.Length; i++)
			{
				if (this.m_rgCultures[i].Id == iCultureId)
				{
					return this.m_rgCultures[i].GetRatingId(szRating);
				}
			}

			return 0;
		}

		public int GetProductTypeId(string szProductTypeName)
		{
			for (int i = 0; i < this.m_rgProductTypes.Length; i++)
			{
				if (this.m_rgProductTypes[i].Name.ToLower().Equals(szProductTypeName.ToLower()))
				{
					return this.m_rgProductTypes[i].Id;
				}
			}

			throw new Exception("Product type not found");
		}

		public int GetCultureId(string szCultureCode)
		{
			for (int i = 0; i < this.m_rgCultures.Length; i++)
			{
				if (this.m_rgCultures[i].Code.ToLower().Equals(szCultureCode.ToLower()))
				{
					return this.m_rgCultures[i].Id;
				}
			}

			throw new Exception("Culture not found");
		}

		public string GetCultureNameById(int iCultureId)
		{
			for (int i = 0; i < this.m_rgCultures.Length; i++)
			{
				if (this.m_rgCultures[i].Id == iCultureId)
				{
					return this.m_rgCultures[i].Name;
				}
			}

			throw new Exception("Culture not found");
		}

		public int GetGenreId(string szGenreName)
		{
			for (int i = 0; i < this.m_rgGenres.Length; i++)
			{
				if (this.m_rgGenres[i].Name.ToLower().Equals(szGenreName.ToLower()))
				{
					return this.m_rgGenres[i].Id;
				}
			}

			throw new Exception("Genre not found");
		}
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\xboxcomData\XboxComDataRestore\components\ProductList.cs ===
using System;
using System.Xml;

namespace xonline.tools.xboxcomData.XboxComDataRestore.components
{
    /// <summary>
    /// Summary description for ProductList.
    /// </summary>
    public class ProductList
    {
        private Product[] m_rgProducts;

        public ProductList(XmlNode nodeProducts, Metadata metadata)
        {
            this.m_rgProducts = new Product[nodeProducts.ChildNodes.Count];

            for (int i = 0; i < nodeProducts.ChildNodes.Count; i++)
            {
                this.m_rgProducts[i] = new Product(nodeProducts.ChildNodes.Item(i), metadata);
            }
        }

        public void Save(System.Data.SqlClient.SqlConnection objConn, Metadata metadata, string szMappingFilename)
        {
            XmlDocument xmlMapping = new XmlDocument();
            XmlNode nodeRoot = xmlMapping.CreateElement("mappings");
            xmlMapping.AppendChild(nodeRoot);

            for (int i = 0; i < this.m_rgProducts.Length; i++)
            {
                this.m_rgProducts[i].Save(objConn, metadata);

                if (this.m_rgProducts[i].NewProductId > 0)
                {
                    XmlNode nodeMapping = xmlMapping.CreateElement("mapping");
                    nodeRoot.AppendChild(nodeMapping);

                    XmlAttribute attrib = xmlMapping.CreateAttribute("oldproductid");
                    attrib.Value = this.m_rgProducts[i].OldProductId.ToString();
                    nodeMapping.Attributes.Append(attrib);

                    attrib = xmlMapping.CreateAttribute("newproductid");
                    attrib.Value = this.m_rgProducts[i].NewProductId.ToString();
                    nodeMapping.Attributes.Append(attrib);
                }
            }

            xmlMapping.Save(szMappingFilename);
        }

    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\xboxcomData\XboxComDataRestore\components\ProductType.cs ===
using System;

namespace xonline.tools.xboxcomData.XboxComDataRestore.components
{
	/// <summary>
	/// Summary description for ProductType.
	/// </summary>
	public class ProductType
	{
		private string m_szName;
		private int m_iProductTypeId;

		public ProductType(string szName)
		{
			this.m_szName = szName;
		}

		public string Name
		{
			get
			{
				return this.m_szName;
			}
		}

		public int Id
		{
			get
			{
				return this.m_iProductTypeId;
			}
		}

		public void Save(System.Data.SqlClient.SqlConnection objConn)
		{
			System.Data.SqlClient.SqlCommand objCmd = objConn.CreateCommand();
			System.Data.SqlClient.SqlDataReader objRs = null;
			
			try
			{
				objCmd.CommandText = "p_pcat_AddProductType";
				objCmd.CommandType = System.Data.CommandType.StoredProcedure;

				System.Data.SqlClient.SqlParameter objParam;
				objParam = new System.Data.SqlClient.SqlParameter();
				objParam.ParameterName = "@productTypeName";
				objParam.SqlDbType = System.Data.SqlDbType.NVarChar;
				objParam.Size = this.m_szName.Length;
				objParam.Value = this.m_szName;
				objCmd.Parameters.Add(objParam);

				objRs = objCmd.ExecuteReader();		

				objRs.Read();

				this.m_iProductTypeId = objRs.GetInt32(objRs.GetOrdinal("ProductTypeId"));
			}
			catch (Exception ex)
			{
				throw new Exception("Error saving product type information. " + ex.Message);
			}
			finally
			{
				objRs.Close();
			}
		}
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\xboxcomData\XboxComDataRestore\components\ProductCatalog.cs ===
using System;
using System.Collections;
using System.Xml;

namespace xonline.tools.xboxcomData.XboxComDataRestore.components
{
	/// <summary>
	/// Summary description for ProductCatalog.
	/// </summary>
	public class ProductCatalog
	{
		private Metadata m_Metadata;
		private ProductList m_Products;

		public ProductCatalog(String szFilename, System.Data.SqlClient.SqlConnection objConn)
		{
			System.Xml.XmlDocument objXML = new XmlDocument();
			try
			{
				objXML.Load(szFilename);
			}
			catch (Exception ex)
			{
				throw new Exception("Error loading the file. " + ex.Message);
			}

			XmlNode nodeProductCatalog;

			try
			{
				nodeProductCatalog = objXML.SelectSingleNode("//productcatalog");
				if (nodeProductCatalog == null)
					throw new Exception("Error locating product catalog node");
			}
			finally
			{

			}

			XmlNode nodeMetadata;

			try
			{
				nodeMetadata = nodeProductCatalog.SelectSingleNode("metadata");
				if (nodeMetadata == null)
					throw new Exception("Error locating metadata");

				this.m_Metadata = new Metadata(nodeMetadata, objConn);
			}
			finally
			{

			}

			XmlNode nodeProducts;

			try
			{
				nodeProducts = nodeProductCatalog.SelectSingleNode("products");
				if (nodeProducts == null)
					throw new Exception("Error locating product list");

				this.m_Products = new ProductList(nodeProducts, this.m_Metadata);
			}
			finally
			{

			}
		}

		public void Save(string szMappingFilename, System.Data.SqlClient.SqlConnection objConn)
		{
			this.m_Metadata.Save(objConn);
			this.m_Products.Save(objConn, this.m_Metadata, szMappingFilename);
		}
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\xboxcomData\XboxComDataRestore\components\ProductCulture.cs ===
using System;
using System.Xml;

namespace xonline.tools.xboxcomData.XboxComDataRestore.components
{
	/// <summary>
	/// Summary description for ProductCulture.
	/// </summary>
	public class ProductCulture
	{
		private string m_szCultureCode;
		private int m_iCultureCode;
		private bool m_bActive;
		private double m_dListPrice;
		private double m_dOriginalPrice;
		private string m_szTitle;
		private string m_szLinkToURL;
		private string m_szDeveloper = "";
		private string m_szDeveloperURL = "";
		private string m_szPublisher;
		private string m_szPublisherURL;
		private string m_szManufacturer;
		private string m_szManufacturerURL;
		private bool m_bPlatinum;
		private string m_szRating;
		private string m_szRatingDescription;
		private string m_szReleaseDate;
		private DateTime m_dtReleaseDateSortable;
		private string m_szGenre;
		private string m_szSubGenre;
		private string m_szGenreText;
		private bool m_bCoop = false;
		private bool m_bCustomSoundtracks = false;
		private bool m_bDolby51 = false;
		private bool m_bHDTV = false;
		private bool m_bLiveContent = false;
		private bool m_bLiveContentDownload = false;
		private bool m_bLiveFriends = false;
		private bool m_bLiveKeyboard = false;
		private bool m_bLiveMultiplayer = false;
		private bool m_bLiveScoreboard = false;
		private bool m_bLiveStats = false;
		private bool m_bLiveVoice = false;
		private bool m_bMemoryUnit = false;
		private bool m_bMultiplayerVersus = false;
		private string m_szPlayers = "";
		private bool m_bSystemLink = false;

		public ProductCulture(XmlNode nodeProductCulture, Metadata metadata)
		{
			XmlNode nodeTemp;

			try
			{
				this.m_szCultureCode = nodeProductCulture.Attributes.GetNamedItem("code").Value;
				this.m_iCultureCode = metadata.GetCultureId(this.m_szCultureCode);
				this.m_bActive = nodeProductCulture.Attributes.GetNamedItem("active").Value.ToLower().Equals("true");
				this.m_dListPrice = Convert.ToDouble(nodeProductCulture.Attributes.GetNamedItem("listprice").Value);
				this.m_dOriginalPrice = Convert.ToDouble(nodeProductCulture.Attributes.GetNamedItem("originalprice").Value);
				nodeTemp = nodeProductCulture.SelectSingleNode("title");
				this.m_szTitle = (nodeTemp.ChildNodes.Count > 0) ? nodeTemp.FirstChild.Value : "";

				nodeTemp = nodeProductCulture.SelectSingleNode("developer");
				this.m_szDeveloper = (nodeTemp.ChildNodes.Count > 0) ? nodeTemp.FirstChild.Value : "";
				
				nodeTemp = nodeProductCulture.SelectSingleNode("developerurl");
				this.m_szDeveloperURL = (nodeTemp.ChildNodes.Count > 0) ? nodeTemp.FirstChild.Value : "";

				nodeTemp = nodeProductCulture.SelectSingleNode("publisher");
				this.m_szPublisher = (nodeTemp.ChildNodes.Count > 0) ? nodeTemp.FirstChild.Value : "";
				
				nodeTemp = nodeProductCulture.SelectSingleNode("publisherurl");
				this.m_szPublisherURL = (nodeTemp.ChildNodes.Count > 0) ? nodeTemp.FirstChild.Value : "";

				nodeTemp = nodeProductCulture.SelectSingleNode("manufacturer");
				this.m_szManufacturer = (nodeTemp.ChildNodes.Count > 0) ? nodeTemp.FirstChild.Value : "";
				
				nodeTemp = nodeProductCulture.SelectSingleNode("manufacturerurl");
				this.m_szManufacturerURL = (nodeTemp.ChildNodes.Count > 0) ? nodeTemp.FirstChild.Value : "";

				nodeTemp = nodeProductCulture.SelectSingleNode("linktourl");
				this.m_szLinkToURL = (nodeTemp.ChildNodes.Count > 0) ? nodeTemp.FirstChild.Value : "";

				this.m_bPlatinum = nodeProductCulture.Attributes.GetNamedItem("platinum").Value.ToLower().Equals("true");

				nodeTemp = nodeProductCulture.SelectSingleNode("rating");
				this.m_szRating = (nodeTemp.ChildNodes.Count > 0) ? nodeTemp.FirstChild.Value : "";

				nodeTemp = nodeProductCulture.SelectSingleNode("ratingdescription");
				this.m_szRatingDescription = (nodeTemp.ChildNodes.Count > 0) ? nodeTemp.FirstChild.Value : "";

				nodeTemp = nodeProductCulture.SelectSingleNode("releasedate");
				this.m_szReleaseDate = (nodeTemp.ChildNodes.Count > 0) ? nodeTemp.FirstChild.Value : "";

				this.m_dtReleaseDateSortable = new DateTime(Convert.ToInt64(nodeProductCulture.Attributes.GetNamedItem("releasedatesortable").Value));

				this.m_szGenre = nodeProductCulture.Attributes.GetNamedItem("genre").Value;
				this.m_szSubGenre = nodeProductCulture.Attributes.GetNamedItem("subgenre").Value;
				this.m_szGenreText = nodeProductCulture.Attributes.GetNamedItem("genretext").Value;
				this.m_bCoop = nodeProductCulture.Attributes.GetNamedItem("coop").Value.ToLower().Equals("true");
				this.m_bCustomSoundtracks = nodeProductCulture.Attributes.GetNamedItem("customsoundtracks").Value.ToLower().Equals("true");
				this.m_bDolby51 = nodeProductCulture.Attributes.GetNamedItem("dolby51").Value.ToLower().Equals("true");
				this.m_bHDTV = nodeProductCulture.Attributes.GetNamedItem("hdtv").Value.ToLower().Equals("true");
				this.m_bLiveContent = nodeProductCulture.Attributes.GetNamedItem("livecontent").Value.ToLower().Equals("true");
				this.m_bLiveContentDownload = nodeProductCulture.Attributes.GetNamedItem("livecontentdownload").Value.ToLower().Equals("true");
				this.m_bLiveFriends = nodeProductCulture.Attributes.GetNamedItem("livefriends").Value.ToLower().Equals("true");
				this.m_bLiveKeyboard = nodeProductCulture.Attributes.GetNamedItem("livekeyboard").Value.ToLower().Equals("true");
				this.m_bLiveMultiplayer = nodeProductCulture.Attributes.GetNamedItem("livemultiplayer").Value.ToLower().Equals("true");
				this.m_bLiveScoreboard = nodeProductCulture.Attributes.GetNamedItem("livescoreboard").Value.ToLower().Equals("true");
				this.m_bLiveStats = nodeProductCulture.Attributes.GetNamedItem("livestats").Value.ToLower().Equals("true");
				this.m_bLiveVoice = nodeProductCulture.Attributes.GetNamedItem("livevoice").Value.ToLower().Equals("true");
				this.m_bMemoryUnit = nodeProductCulture.Attributes.GetNamedItem("memoryunit").Value.ToLower().Equals("true");
				this.m_bMultiplayerVersus = nodeProductCulture.Attributes.GetNamedItem("multiplayervs").Value.ToLower().Equals("true");
				this.m_szPlayers = nodeProductCulture.Attributes.GetNamedItem("players").Value;
				this.m_bSystemLink = nodeProductCulture.Attributes.GetNamedItem("systemlink").Value.ToLower().Equals("true");

			}
			catch (Exception ex)
			{
				throw new Exception("Error loading product data. " + ex.Message);
			}
			finally
			{

			}
		}

		#region Properties
		public int CultureId
		{
			get
			{
				return this.m_iCultureCode;
			}
		}

		public bool Active
		{
			get
			{
				return this.m_bActive;
			}
		}

		public double ListPrice
		{
			get
			{
				return this.m_dListPrice;
			}
		}

		public double OriginalPrice
		{
			get
			{
				return this.m_dOriginalPrice;
			}
		}

		public string Title
		{
			get
			{
				return this.m_szTitle;
			}
		}

		public string LinkToURL
		{
			get
			{
				return this.m_szLinkToURL;
			}
		}

		public string Developer
		{
			get
			{
				return this.m_szDeveloper;
			}
		}

		public string DeveloperURL
		{
			get
			{
				return this.m_szDeveloperURL;
			}
		}

		public string Publisher
		{
			get
			{
				return this.m_szPublisher;
			}
		}

		public string PublisherURL
		{
			get
			{
				return this.m_szPublisherURL;
			}
		}

		public string Manufacturer
		{
			get
			{
				return this.m_szManufacturer;
			}
		}

		public string ManufacturerURL
		{
			get
			{
				return this.m_szManufacturerURL;
			}
		}

		public bool Platinum
		{
			get
			{
				return this.m_bPlatinum;
			}
		}

		public string Rating
		{
			get
			{
				return this.m_szRating;
			}
		}
		public string RatingDescription
		{
			get
			{
				return this.m_szRatingDescription;
			}
		}

		public string ReleaseDate
		{
			get
			{
				return this.m_szReleaseDate;
			}
		}

		public DateTime ReleaseDateSortable
		{
			get
			{
				return this.m_dtReleaseDateSortable;
			}
		}

		public bool CoOp
		{
			get
			{
				return this.m_bCoop;
			}
		}

		public bool CustomSoundtrack
		{
			get
			{
				return this.m_bCustomSoundtracks;
			}
		}

		public bool Dolby51
		{
			get
			{
				return this.m_bDolby51;
			}
		}

		public bool LiveContent
		{
			get
			{
				return this.m_bLiveContent;
			}
		}

		public bool LiveContentDownload
		{
			get
			{
				return this.m_bLiveContentDownload;
			}
		}

		public bool LiveMultiplayer
		{
			get
			{
				return this.m_bLiveMultiplayer;
			}
		}

		public bool LiveScoreboard
		{
			get
			{
				return this.m_bLiveScoreboard;
			}
		}

		public bool LiveStats
		{
			get
			{
				return this.m_bLiveStats;
			}
		}

		public bool LiveVoice
		{
			get
			{
				return this.m_bLiveVoice;
			}
		}

		public bool MemoryUnit
		{
			get
			{
				return this.m_bMemoryUnit;
			}
		}

		public bool MultiplayerVersus
		{
			get
			{
				return this.m_bMultiplayerVersus;
			}
		}

		public bool LiveKeyboard
		{
			get
			{
				return this.m_bLiveKeyboard;
			}
		}

		public bool LiveFriends
		{
			get
			{
				return this.m_bLiveFriends;
			}
		}

		public bool SystemLink
		{
			get
			{
				return this.m_bSystemLink;
			}
		}

		public string Players
		{
			get
			{
				return this.m_szPlayers;
			}
		}

		public bool HDTVMode
		{
			get
			{
				return this.m_bHDTV;
			}
		}

		public string GenreName
		{
			get
			{
				return this.m_szGenre;
			}
		}

		public string SubGenreName
		{
			get
			{
				return this.m_szSubGenre;
			}
		}

		public string GenreText
		{
			get
			{
				return this.m_szGenreText;
			}
		}
		#endregion
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\xereports\BannerPathHashTool\obj\i386\_generated.cs ===
[assembly:System.Runtime.InteropServices.ComVisible(false)]
[assembly:System.Reflection.AssemblyVersion("12.4.56.0")]
[assembly:System.Reflection.AssemblyProduct("Microsoft(R) Xbox(TM)")]
[assembly:System.Reflection.AssemblyCopyright("Copyright (c) Microsoft Corporation. All rights reserved.")]
[assembly:System.Reflection.AssemblyCompany("Microsoft Corporation")]
[assembly:System.Reflection.AssemblyFileVersion("12.4.56.0")]
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\xboxcomData\XboxComDataRestore\components\Rating.cs ===
using System;

namespace xonline.tools.xboxcomData.XboxComDataRestore.components
{
	/// <summary>
	/// Summary description for Rating.
	/// </summary>
	public class Rating
	{
		private int m_iRatingId;
		private string m_szName;

		public Rating(int iRatingId, string szRatingName)
		{
			this.m_iRatingId = iRatingId;
			this.m_szName = szRatingName;
		}

		public string Name
		{
			get
			{
				return this.m_szName;
			}
		}

		public int Id
		{
			get
			{
				return this.m_iRatingId;
			}
		}
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\xboxcomData\XboxComDataRestore\components\Product.cs ===
﻿using System;
using System.Xml;
using xonline.server.xboxcom.lib.logic.ProductCatalog.authoring;

namespace xonline.tools.xboxcomData.XboxComDataRestore.components
{
    /// <summary>
    /// Summary description for Product.
    /// </summary>
    public class Product
    {
        private string m_szTitle = "";
        private string m_szProductType;
        private int m_iProductType;
        private int m_iProductCatalogId;
        private int m_iProductId = -1;

        private ProductCulture[] m_rgContent;

        public int OldProductId
        {
            get
            {
                return this.m_iProductCatalogId;
            }
        }

        public int NewProductId
        {
            get
            {
                return this.m_iProductId;
            }
        }

        public Product(XmlNode nodeProduct, Metadata metadata)
        {
            try
            {
                this.m_szTitle = nodeProduct.SelectSingleNode("title").FirstChild.Value;
                this.m_szProductType = nodeProduct.Attributes.GetNamedItem("producttype").Value;
                this.m_iProductCatalogId = Convert.ToInt32(nodeProduct.Attributes.GetNamedItem("productcatalogid").Value);

                // load all the culture stuff
                XmlNode nodeLocalizedContent = nodeProduct.SelectSingleNode("localizedcontent");
                this.m_rgContent = new ProductCulture[nodeLocalizedContent.ChildNodes.Count];

                for (int i = 0; i < nodeLocalizedContent.ChildNodes.Count; i++)
                {
                    this.m_rgContent[i] = new ProductCulture(nodeLocalizedContent.ChildNodes[i], metadata);
                }
            }
            catch (Exception ex)
            {
                throw new Exception("Error loading product data. " + ex.Message);
            }
            finally
            {

            }
        }

        public void Save(System.Data.SqlClient.SqlConnection objConn, Metadata metadata)
        {
            // resolve product type
            this.m_iProductType = metadata.GetProductTypeId(this.m_szProductType);

            xonline.server.xboxcom.lib.logic.ProductCatalog.authoring.Product prod =
                new xonline.server.xboxcom.lib.logic.ProductCatalog.authoring.Product(this.m_szTitle, this.m_iProductType, objConn);

            prod.GeneralData.ProductCatalogId = this.m_iProductCatalogId;
            prod.KeyWords = "TODO IMPORT";

            prod.Save("Data Restore", objConn);

            ProductContentData pcd;

            int iUSCultureIdIndex = -1;

            // find the index for english in case we need to do some defaulting
            for (int i = 0; i < this.m_rgContent.Length; i++)
            {
                if (this.m_rgContent[i].CultureId == 1033)
                {
                    iUSCultureIdIndex = i;
                }
            }

            for (int i = 0; i < this.m_rgContent.Length; i++)
            {
                if (this.m_rgContent[i].Active)
                {
                    prod.AddProductProfile(this.m_rgContent[i].CultureId, metadata.GetCultureNameById(this.m_rgContent[i].CultureId));

                    ProductProfile pp = prod.GetProductProfileByCultureId(this.m_rgContent[i].CultureId);

                    pp.Active = true;
                    pp.FeatureData.CoOp = this.m_rgContent[i].CoOp;
                    pp.FeatureData.CustomSoundtrack = this.m_rgContent[i].CustomSoundtrack;
                    pp.FeatureData.Dolby51 = this.m_rgContent[i].Dolby51;
                    pp.FeatureData.LiveAware = this.m_rgContent[i].LiveContent || this.m_rgContent[i].LiveContentDownload || this.m_rgContent[i].LiveFriends || this.m_rgContent[i].LiveKeyboard
                        || this.m_rgContent[i].LiveMultiplayer || this.m_rgContent[i].LiveScoreboard || this.m_rgContent[i].LiveStats || this.m_rgContent[i].LiveVoice;
                    pp.FeatureData.LiveDownloads = this.m_rgContent[i].LiveContent || this.m_rgContent[i].LiveContentDownload;
                    pp.FeatureData.Peripherals = this.m_rgContent[i].LiveKeyboard;
                    pp.FeatureData.LiveMultiplayer = this.m_rgContent[i].LiveMultiplayer;
                    pp.FeatureData.LiveScoreboard = this.m_rgContent[i].LiveScoreboard;
                    pp.FeatureData.LiveStats = this.m_rgContent[i].LiveStats;
                    pp.FeatureData.LiveVoice = this.m_rgContent[i].LiveVoice;
                    pp.FeatureData.MemoryUnit = this.m_rgContent[i].MemoryUnit;
                    pp.FeatureData.MultiplayerVersus = this.m_rgContent[i].MultiplayerVersus;
                    pp.FeatureData.SystemLink = this.m_rgContent[i].SystemLink;
                    pp.FeatureData.XboxSupport = true;        
            
                    pp.FeatureData.HDTVMode = this.m_rgContent[i].HDTVMode ? 1 : 0;

                    string szPlayers = "";
                    int iPlayers = 1;
        
                    szPlayers = this.m_rgContent[i].Players;
        
                    // replace special chars
                    szPlayers = szPlayers.Replace("人～", "");
                    szPlayers = szPlayers.Replace("人", "");
                    szPlayers = szPlayers.Replace("1(最大4)", "1-4");
                    szPlayers = szPlayers.Replace("Many", "32");
                    szPlayers = szPlayers.Replace("～", "-");
                    szPlayers = szPlayers.Replace("名", "");
                    szPlayers = szPlayers.Replace(" （Xbox Live、システムリンクプレイ対応時：最大4）", "-4");
                    szPlayers = szPlayers.Replace("(ネットワーク時最大8)", "-8");
                    szPlayers = szPlayers.Replace("（ライブ対応）", "");
        
                    // if there is a - in the players field, parse it out and get the second half
                    if (szPlayers.IndexOf("-") >= 0)
                    {
                        string[] rgszPlayers = szPlayers.Split('-');
                        szPlayers = rgszPlayers[rgszPlayers.Length - 1];
                    }
        
                    if (szPlayers.Trim().Length == 0)
                        szPlayers = "1";
                    
                    // convert the players to a number
                    try
                    {
                        iPlayers = Convert.ToInt32(szPlayers);
                    }
                    catch
                    {
//                        System.Windows.Forms.MessageBox.Show("There was a problem determining the number of players for " + this.m_szTitle);
                        iPlayers = 1;
                    }

                    if (iPlayers > 4)
                    {
                        pp.FeatureData.PlayersOffline = 4;
                    }
                    else
                    {
                        pp.FeatureData.PlayersOffline = iPlayers;
                    }

                    if (iPlayers > 1)
                    {
                        if (this.m_rgContent[i].SystemLink)
                        {
                            pp.FeatureData.PlayersSystemLink = iPlayers;
                        }
                        else
                        {
                            pp.FeatureData.PlayersSystemLink = 0;
                        }

                        if (this.m_rgContent[i].LiveMultiplayer)
                        {
                            pp.FeatureData.PlayersLive = iPlayers;
                        }
                        else
                        {
                            pp.FeatureData.PlayersLive = 0;
                        }
                    }
                    else
                    {
                        pp.FeatureData.PlayersLive = 0;
                        pp.FeatureData.PlayersSystemLink = 0;
                    }

                    pcd = pp.ContentData;

                    int iGenreId;
                    int iSubGenreId;

                    try
                    {
                        iGenreId = metadata.GetGenreId(this.m_rgContent[i].GenreName);
                    }
                    catch
                    {
                        iGenreId = 0;
                    }
        
                    try
                    {
                        iSubGenreId = metadata.GetGenreId(this.m_rgContent[i].SubGenreName);
                    }
                    catch
                    {
                        iSubGenreId = 0;
                    }

                    if (iGenreId != 0)
                    {
                        pcd.GenreId = iGenreId;
                    }
                    else
                    {
                        if (iSubGenreId != 0)
                        {
                            pcd.GenreId = iSubGenreId;
                        }
                    }

                    if (pp.ContentData.GenreId == 0 || pp.ContentData.GenreId == 1)
                    {
                        try
                        {
                            // look up US genre id if possible
                            if (iUSCultureIdIndex >= 0)
                            {
                                try
                                {
                                    iGenreId = metadata.GetGenreId(this.m_rgContent[iUSCultureIdIndex].GenreName);
                                }
                                catch
                                {
                                    iGenreId = 0;
                                }
        
                                try
                                {
                                    iSubGenreId = metadata.GetGenreId(this.m_rgContent[iUSCultureIdIndex].SubGenreName);
                                }
                                catch
                                {
                                    iSubGenreId = 0;
                                }

                                if (iGenreId != 0)
                                {
                                    pcd.GenreId = iGenreId;
                                }
                                else
                                {
                                    if (iSubGenreId != 0)
                                    {
                                        pcd.GenreId = iSubGenreId;
                                    }
                                }
                            }
                        }
                        catch
                        {

                        }
                    }

                    if (pp.ContentData.GenreId == 1 || pp.ContentData.GenreId == 0)
                    {
                        pcd.GenreText = this.m_rgContent[i].GenreText;
                    }

                    pcd.Platinum = this.m_rgContent[i].Platinum;
                    pcd.Price = this.m_rgContent[i].ListPrice;
                    pcd.ProductURL = ""; //this.m_rgContent[i].LinkToURL;
                    pcd.Title = this.m_rgContent[i].Title;
                    pcd.Developer = this.m_rgContent[i].Developer;
                    pcd.DeveloperURL = this.m_rgContent[i].DeveloperURL;
                    pcd.Publisher = this.m_rgContent[i].Publisher;
                    pcd.PublisherURL = this.m_rgContent[i].PublisherURL;
                    pcd.Manufacturer = this.m_rgContent[i].Manufacturer;
                    pcd.ManufacturerURL = this.m_rgContent[i].ManufacturerURL;
                    pcd.ReleaseDate = this.m_rgContent[i].ReleaseDate;
                    pcd.ReleaseDateMonth = this.m_rgContent[i].ReleaseDateSortable.Month;
                    pcd.ReleaseDateDay = this.m_rgContent[i].ReleaseDateSortable.Day;
                    pcd.ReleaseDateYear = this.m_rgContent[i].ReleaseDateSortable.Year;
                    pcd.RatingId = metadata.GetRatingId(this.m_rgContent[i].CultureId, this.m_rgContent[i].Rating);
                    pcd.RatingDescription = this.m_rgContent[i].RatingDescription;
                }
            }

            prod.Save("Data Restore", objConn);

            this.m_iProductId = prod.Id;
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\xereports\BannerPathHashTool\makefile.inc ===
!include $(INETROOT)\build\makefile.inc

!if !defined(PASS0ONLY)
$(O)\Sha1.XmlSerializers.dll : $(O)\Sha1.dll
    echo Build_Status Generating $(O)\Sha1.XmlSerializers.dll from $(O)\Sha1.dll
     sgen.exe /a:$(O)\Sha1.dll 
    if not exist $(O)\Sha1.XmlSerializers.dll echo NMAKE : T1013: 'SGEN' Unable to locate $(O)\Sha1.XmlSerializers.dll

    -1 robocopy $(O) $(_NT386TREE)\xdb\reportingdb Sha1.XmlSerializers.dll /R:0 /NP /NJS /NJH

!endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\xereports\BannerPathHashTool\objd\i386\_generated.cs ===
[assembly:System.Runtime.InteropServices.ComVisible(false)]
[assembly:System.Reflection.AssemblyVersion("12.4.56.0")]
[assembly:System.Reflection.AssemblyProduct("Microsoft(R) Xbox(TM)")]
[assembly:System.Reflection.AssemblyCopyright("Copyright (c) Microsoft Corporation. All rights reserved.")]
[assembly:System.Reflection.AssemblyCompany("Microsoft Corporation")]
[assembly:System.Reflection.AssemblyFileVersion("12.4.56.0")]
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\xereports\BannerPathHashTool\obj\i386\_asmid.inc ===
ASSEMBLY_IDENTITY_KEY_FORM=msil_sha1_none_12.4.56.0_none_b4e41ab3192e57d0
ASSEMBLY_IDENTITY_XP_KEY_FORM=msil_sha1_no-public-key_12.4.56.0_x-ww_a57dee28
ASSEMBLY_IDENTITY_CULTURE=
ASSEMBLY_IDENTITY_NAME=sha1
ASSEMBLY_IDENTITY_PROCESSOR_ARCHITECTURE=msil
ASSEMBLY_IDENTITY_PUBLIC_KEY=
ASSEMBLY_IDENTITY_PUBLIC_KEY_TOKEN=
ASSEMBLY_IDENTITY_TYPE=
ASSEMBLY_IDENTITY_TYPE_NAME=
ASSEMBLY_IDENTITY_VERSION=12.4.56.0
XP_KEY_FORM=msil_sha1_no-public-key_12.4.56.0_x-ww_a57dee28
XP_MANIFEST_DIRECTORY=manifests
XP_MANIFEST_NAME=msil_sha1_no-public-key_12.4.56.0_x-ww_a57dee28.manifest
XP_MANIFEST_PATH=manifests\msil_sha1_no-public-key_12.4.56.0_x-ww_a57dee28.manifest
XP_CATALOG_DIRECTORY=manifests
XP_CATALOG_NAME=msil_sha1_no-public-key_12.4.56.0_x-ww_a57dee28.cat
XP_CATALOG_PATH=manifests\msil_sha1_no-public-key_12.4.56.0_x-ww_a57dee28.cat
XP_PAYLOAD_PATH=msil_sha1_no-public-key_12.4.56.0_x-ww_a57dee28
_DELAY_SIGN=0
!if [set _ASMIDTOATTRIBS_TLBIMP=]
!endif
CODESIGN_TESTKEY=
_TLBIMP_FLAGS=$(_TLBIMP_FLAGS)  /asmversion:12.4.56.0
_ASSEMBLY_IDENTITY=sha1,processorArchitecture=msil,version=12.4.56.0,publicKeyToken=neutral
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\xereports\BannerPathHashTool\Sha1.cs ===
using System;
using System.Security.Cryptography;
using Microsoft.SqlServer.Server;
using System.Text;

public class HashUtils
{
    public enum HashOutputFormat { Hexadecimal, BigInt };

    [Microsoft.SqlServer.Server.SqlProcedure]
    public static int CalculateHash(string path, out string hash)
    {
        return CalculateHashReal(path, out hash, HashOutputFormat.Hexadecimal);
    }

    //josszy -- To have this act as a function as per spec, needed to return
    //instead of handling the return value as a passed-in value
    [Microsoft.SqlServer.Server.SqlFunction]
    public static string CalculateHashBigInt(string path)
    {
        string hash = String.Empty;
        CalculateHashReal(path, out hash, HashOutputFormat.BigInt);
        return hash;
    }

    public static int CalculateHashReal(string path, out string hash, HashOutputFormat fmt)
    {
        try
        {
            byte[] res = new SHA1CryptoServiceProvider().ComputeHash(Encoding.ASCII.GetBytes(path));
            ulong sha1 = BitConverter.ToUInt64(res, 0);
            // convert from little-endian to big-endian
            sha1 = (sha1 >> 56) |
                ((sha1 << 40) & 0x00FF000000000000) |
                ((sha1 << 24) & 0x0000FF0000000000) |
                ((sha1 << 8) & 0x000000FF00000000) |
                ((sha1 >> 8) & 0x00000000FF000000) |
                ((sha1 >> 24) & 0x0000000000FF0000) |
                ((sha1 >> 40) & 0x000000000000FF00) |
                (sha1 << 56);

            hash = string.Empty;
            switch (fmt)
            {
                case HashOutputFormat.Hexadecimal:
                    {
                        hash = sha1.ToString("x8");
                        break;
                    }
                case HashOutputFormat.BigInt:
                    {
                        hash = ((Int64)sha1).ToString();
                        break;
                    }
            }
            return 0;
        }
        catch
        {
            hash = string.Empty;
            return -1; // exception in computing hash
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\xereports\BannerPathHashTool\objd\i386\_asmid.inc ===
ASSEMBLY_IDENTITY_KEY_FORM=msil_sha1_none_12.4.56.0_none_b4e41ab3192e57d0
ASSEMBLY_IDENTITY_XP_KEY_FORM=msil_sha1_no-public-key_12.4.56.0_x-ww_a57dee28
ASSEMBLY_IDENTITY_CULTURE=
ASSEMBLY_IDENTITY_NAME=sha1
ASSEMBLY_IDENTITY_PROCESSOR_ARCHITECTURE=msil
ASSEMBLY_IDENTITY_PUBLIC_KEY=
ASSEMBLY_IDENTITY_PUBLIC_KEY_TOKEN=
ASSEMBLY_IDENTITY_TYPE=
ASSEMBLY_IDENTITY_TYPE_NAME=
ASSEMBLY_IDENTITY_VERSION=12.4.56.0
XP_KEY_FORM=msil_sha1_no-public-key_12.4.56.0_x-ww_a57dee28
XP_MANIFEST_DIRECTORY=manifests
XP_MANIFEST_NAME=msil_sha1_no-public-key_12.4.56.0_x-ww_a57dee28.manifest
XP_MANIFEST_PATH=manifests\msil_sha1_no-public-key_12.4.56.0_x-ww_a57dee28.manifest
XP_CATALOG_DIRECTORY=manifests
XP_CATALOG_NAME=msil_sha1_no-public-key_12.4.56.0_x-ww_a57dee28.cat
XP_CATALOG_PATH=manifests\msil_sha1_no-public-key_12.4.56.0_x-ww_a57dee28.cat
XP_PAYLOAD_PATH=msil_sha1_no-public-key_12.4.56.0_x-ww_a57dee28
_DELAY_SIGN=0
!if [set _ASMIDTOATTRIBS_TLBIMP=]
!endif
CODESIGN_TESTKEY=
_TLBIMP_FLAGS=$(_TLBIMP_FLAGS)  /asmversion:12.4.56.0
_ASSEMBLY_IDENTITY=sha1,processorArchitecture=msil,version=12.4.56.0,publicKeyToken=neutral
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\xereports\CorpScripts\obj\i386\_asmid.inc ===
ASSEMBLY_IDENTITY_KEY_FORM=x86__corpscripts_2_none_12.4.56.0_none_d77156ea7540c078
ASSEMBLY_IDENTITY_XP_KEY_FORM=x86__corpscripts_2_no-public-key_12.4.56.0_x-ww_ec310948
ASSEMBLY_IDENTITY_CULTURE=
ASSEMBLY_IDENTITY_NAME=_corpscripts_2
ASSEMBLY_IDENTITY_PROCESSOR_ARCHITECTURE=x86
ASSEMBLY_IDENTITY_PUBLIC_KEY=
ASSEMBLY_IDENTITY_PUBLIC_KEY_TOKEN=
ASSEMBLY_IDENTITY_TYPE=
ASSEMBLY_IDENTITY_TYPE_NAME=
ASSEMBLY_IDENTITY_VERSION=12.4.56.0
XP_KEY_FORM=x86__corpscripts_2_no-public-key_12.4.56.0_x-ww_ec310948
XP_MANIFEST_DIRECTORY=manifests
XP_MANIFEST_NAME=x86__corpscripts_2_no-public-key_12.4.56.0_x-ww_ec310948.manifest
XP_MANIFEST_PATH=manifests\x86__corpscripts_2_no-public-key_12.4.56.0_x-ww_ec310948.manifest
XP_CATALOG_DIRECTORY=manifests
XP_CATALOG_NAME=x86__corpscripts_2_no-public-key_12.4.56.0_x-ww_ec310948.cat
XP_CATALOG_PATH=manifests\x86__corpscripts_2_no-public-key_12.4.56.0_x-ww_ec310948.cat
XP_PAYLOAD_PATH=x86__corpscripts_2_no-public-key_12.4.56.0_x-ww_ec310948
_DELAY_SIGN=0
!if [set _ASMIDTOATTRIBS_TLBIMP=]
!endif
CODESIGN_TESTKEY=
_TLBIMP_FLAGS=$(_TLBIMP_FLAGS)  /asmversion:12.4.56.0
_ASSEMBLY_IDENTITY=_corpscripts_2,processorArchitecture=x86,version=12.4.56.0,publicKeyToken=neutral
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\xereports\CorpScripts\objd\i386\_asmid.inc ===
ASSEMBLY_IDENTITY_KEY_FORM=x86__corpscripts_2_none_12.4.56.0_none_d77156ea7540c078
ASSEMBLY_IDENTITY_XP_KEY_FORM=x86__corpscripts_2_no-public-key_12.4.56.0_x-ww_ec310948
ASSEMBLY_IDENTITY_CULTURE=
ASSEMBLY_IDENTITY_NAME=_corpscripts_2
ASSEMBLY_IDENTITY_PROCESSOR_ARCHITECTURE=x86
ASSEMBLY_IDENTITY_PUBLIC_KEY=
ASSEMBLY_IDENTITY_PUBLIC_KEY_TOKEN=
ASSEMBLY_IDENTITY_TYPE=
ASSEMBLY_IDENTITY_TYPE_NAME=
ASSEMBLY_IDENTITY_VERSION=12.4.56.0
XP_KEY_FORM=x86__corpscripts_2_no-public-key_12.4.56.0_x-ww_ec310948
XP_MANIFEST_DIRECTORY=manifests
XP_MANIFEST_NAME=x86__corpscripts_2_no-public-key_12.4.56.0_x-ww_ec310948.manifest
XP_MANIFEST_PATH=manifests\x86__corpscripts_2_no-public-key_12.4.56.0_x-ww_ec310948.manifest
XP_CATALOG_DIRECTORY=manifests
XP_CATALOG_NAME=x86__corpscripts_2_no-public-key_12.4.56.0_x-ww_ec310948.cat
XP_CATALOG_PATH=manifests\x86__corpscripts_2_no-public-key_12.4.56.0_x-ww_ec310948.cat
XP_PAYLOAD_PATH=x86__corpscripts_2_no-public-key_12.4.56.0_x-ww_ec310948
_DELAY_SIGN=0
!if [set _ASMIDTOATTRIBS_TLBIMP=]
!endif
CODESIGN_TESTKEY=
_TLBIMP_FLAGS=$(_TLBIMP_FLAGS)  /asmversion:12.4.56.0
_ASSEMBLY_IDENTITY=_corpscripts_2,processorArchitecture=x86,version=12.4.56.0,publicKeyToken=neutral
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\xereports\CorpScripts\makefile.inc ===
CorpScriptsCopy : makefile.inc
    -md %_NT386TREE%\tools\xereports\Datafeeds\CIQ\CorpScripts
    -robocopy . %_NT386TREE%\tools\xereports\Datafeeds\CIQ\CorpScripts CIQDownload.js /R:0 /NP /NJH /NJS /A-:R
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\xereports\DTS\ReportingDTS\core\makefile.inc ===
!include $(INETROOT)\build\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\xereports\DTS\ReportingDTS\installer\makefile.inc ===
!include $(INETROOT)\build\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\xereports\DTS\ReportingDTS\console\makefile.inc ===
!include $(INETROOT)\build\makefile.inc

CopyFiles : makefile.inc
    -md %_NT386TREE%\tools\xereports
   xcopy /y $(XONEXTPATH)\DTS\Microsoft.SQLServer.DTSPkg80.dll %_NT386TREE%\tools\xereports
   xcopy /y $(XONEXTPATH)\DTS\Microsoft.SQLServer.DTSPkg80.CustTask.dll %_NT386TREE%\tools\xereports
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\xereports\DTS\ReportingDTS\console\ReportDTSConsole.cs ===
using System;
using System.IO;
using System.Xml;
using xonline.tools.reporting.dts.core;

namespace xonline.tools.reporting.dts.console
{
    class ReportDTSConsole
    {
        [STAThread]
        static void Main( string[] rgszArgs )
        {
            ReportingDTS pReportDTS;
            XmlDocument xmlDoc;
            XmlNodeList xmlList;

            bool fDelete = false;
            bool fUseWrapper = false;
            string szFile = string.Empty;

            if( 1 == rgszArgs.Length )
            {
                szFile = rgszArgs[ 0 ];
            }
            else if( 2 <= rgszArgs.Length )
            {
                foreach( string szArg in rgszArgs )
                {
                    if( szArg[ 0 ] == '-' )
                    {
                        if( szArg.ToLower( ) == "-d" )
                        {
                            fDelete = true;
                        }
                        else if( szArg.ToLower( ) == "-f" )
                        {
                            fUseWrapper = true;
                        }
                        else
                        {
                            Usage( );
                            goto lDone;
                        }
                    }
                    else
                    {
                        szFile = szArg;
                    }
                }
            }
            else
            {
                Usage( );
                goto lDone;
            }

            if( fUseWrapper )
            {
                try
                {
                    xmlDoc = new XmlDocument( );
                    xmlDoc.Load( szFile );
                
                    xmlList = xmlDoc.DocumentElement.SelectNodes( "Package/@File" );
                    foreach( XmlNode xnT in xmlList )
                    {
                        pReportDTS = new ReportingDTS( );
                        pReportDTS.Execute( Path.Combine( Path.GetDirectoryName( Path.GetFullPath( szFile ) ), xnT.InnerText ), false );
                    }
                }
                catch( Exception exc )
                {
                    Console.WriteLine( exc.ToString( ) );
                }
            }
            else
            {
                pReportDTS = new ReportingDTS( );
                try
                {
                    pReportDTS.Execute( szFile, fDelete );
                }
                catch( Exception exc )
                {
                    Console.WriteLine( exc.ToString( ) );
                }
            }

        lDone:

            return;
        }

        static void Usage( )
        {
            Console.WriteLine( "Usage: ReportDTS.exe [options] <DTS XML File or DTS XML Wrapper File>" );
            Console.WriteLine( "     -d Delete the DTS package(s)" );
            Console.WriteLine( "     -f Specify a DTS XML Wrapper file that points to multiple DTS XML files" );
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\xereports\GenerateSSIS\AppStructs.cs ===
#region Using directives

using System;
using System.Collections.Generic;
using System.Text;

#endregion

namespace GenerateDTS
{
    public class AppStructs
    {
        public AppStructs()
        {

        }
        public struct ConnectionStruct
        {
            public int ID;
            public string ConnectionName;
            public string dataSource;
            public string connectionString;
            public string catalog;

        }


        public struct TableColumnStruct
        {
            public int ordinal;
            public string columnName;
            public string columnType;
            public bool isPrimaryKey;
        }


        public struct GenerateObjectStruct
        {
            public string packageName;
            public int sourceObjectID;
            public string sourceObjectTypeName;
            public string sourceObjectName;
            public int HistorydestObjectID;
            public string HistorydestinationObjectName;
            public int WorkdestObjectID;
            public string WorkdestinationObjectName;
            public string DeltaDestinationObjectName;
            public string etlStage;
            public string srcSearchArgColName;
            public string destCriterionColName;
            public bool isSourceIncremental;
            public string customTransformExecSQLSPName;
            public string DatabaseName;
            public string TemplateName;
            public string SqlQuery;
            public string DestinationConnectionName;
            public string SourceConnectionName;
            public int DestinationObjectTypeId;
        }



        public struct PackageInformation
        {
            public int id;
            public string name;
            public string fileName;
            public string PackageType;
            public int parentPkgID;
            public int prevPrecPkgID;

        }

        public struct SPParamStruct
        {
            public string paramName;
            public int paramOrder;
            public string paramType;
            public int paramLength;
            public string paramSetFunctionName;
        }

        public struct PackageTask
        {
            public int TaskID;
            public string TaskName;
            public string TaskTypeName;
            public string PreceedingTaskID;
        }

        public enum ValidationStage
        {
            PostExtract,
            PostTransform
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\xereports\DTS\ReportingDTS\installer\ReportDTSInstaller.cs ===
using System;
using System.Collections;
using System.ComponentModel;
using System.Configuration.Install;
using System.Diagnostics;
using System.IO;
using System.Xml;
using xonline.tools.reporting.dts.core;

namespace xonline.tools.reporting.dts.installer
{
    [RunInstaller(true)]
    public class ReportDTSInstaller : System.Configuration.Install.Installer
    {
        private EventLog _eventLog;
    
        public ReportDTSInstaller( )
        {
            _eventLog = new EventLog( );
            _eventLog.Log = "Application";
            _eventLog.Source = "ReportDTSInstaller";
        }
        
        public override void Install(IDictionary stateSaver)
        {
            base.Install (stateSaver);

            ReportingDTS pReportDTS;
            string szXmlFile;
            XmlDocument xmlDoc;
            XmlNodeList xmlList;

            szXmlFile = Context.Parameters[ "ReportDTSFile" ];

            try
            {
                xmlDoc = new XmlDocument( );
                xmlDoc.Load( szXmlFile );

                xmlList = xmlDoc.DocumentElement.SelectNodes( "Package/@File" );
                foreach( XmlNode xnT in xmlList )
                {
                    pReportDTS = new ReportingDTS( );
                    pReportDTS.Execute( Path.Combine( Path.GetDirectoryName( Path.GetFullPath( szXmlFile ) ), xnT.InnerText ), false );
                }
            }
            catch( Exception exc )
            {
                Context.LogMessage( "ERROR: Exception encountered executing ReportDTS. - " + exc.Message );
                Context.LogMessage( exc.ToString( ) );
                _eventLog.WriteEntry( "ERROR: Exception encountered executing ReportDTS: \r\n" + exc.ToString( ), EventLogEntryType.Error, 65000 );
                throw;
            }
        }
    
        // even though these overriddent methods appear to do nothing,
        // omiting them will leave temp files behind after the install.
        public override void Commit(IDictionary savedState)
        {
            base.Commit (savedState);
        }

        public override void Rollback(IDictionary savedState)
        {
            base.Rollback (savedState);
        }

        public override void Uninstall(IDictionary savedState)
        {
            base.Uninstall (savedState);

            ReportingDTS pReportDTS;
            string szXmlFile;
            XmlDocument xmlDoc;
            XmlNodeList xmlList;
            
            szXmlFile = Context.Parameters[ "ReportDTSFile" ];
            
            try
            {
                xmlDoc = new XmlDocument( );
                xmlDoc.Load( szXmlFile );
            
                xmlList = xmlDoc.DocumentElement.SelectNodes( "Package/@File" );
                foreach( XmlNode xnT in xmlList )
                {
                    pReportDTS = new ReportingDTS( );
                    pReportDTS.Execute( Path.Combine( Path.GetDirectoryName( Path.GetFullPath( szXmlFile ) ), xnT.InnerText ), true );
                }
            }
            catch( Exception exc )
            {
                Context.LogMessage( "ERROR: Exception encountered executing ReportDTS. - " + exc.Message );
                Context.LogMessage( exc.ToString( ) );
                _eventLog.WriteEntry( "ERROR: Exception encountered executing ReportDTS: \r\n" + exc.ToString( ), EventLogEntryType.Error, 65000 );
                throw;
            }
        }
    }    
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\xereports\GenerateSSIS\DataConversionTask.cs ===
using System;
using System.Collections.Generic;
using System.Collections;
using System.Text;
using GenerateDTS.Common;
using Microsoft.SqlServer.Dts.Pipeline.Wrapper;
using dtr = Microsoft.SqlServer.Dts.Runtime.Wrapper;
using Microsoft.SqlServer.Dts.Runtime;
using Microsoft.SqlServer.Dts.Tasks.ExecuteSQLTask;
//using TxDataConvert;

namespace GenerateDTS
{
    class DataConversionTask
    {
        public void PopulateTask(string DataFlowTaskName, Package pkg, string DataConvertTaskName,string OutputColName)
        {
            try
            {

                IDTSComponentMetaData90  objDataConvert = null;
                MainPipe dataFlow = null;
                Executable exe = pkg.Executables[DataFlowTaskName];
                TaskHost th2 = exe as TaskHost;
                dataFlow = th2.InnerObject as MainPipe;



                foreach (IDTSComponentMetaData90 comp in dataFlow.ComponentMetaDataCollection)
                {
                    if (comp.Name == DataConvertTaskName)
                    {
                        objDataConvert = comp;
                    }
                }

                CManagedComponentWrapper instance = objDataConvert.Instantiate();
                IDTSOutput90 output = objDataConvert.OutputCollection[0];
                //int lineageID = output.OutputColumnCollection[0].ExternalMetadataColumnID;
                //output.OutputColumnCollection.RemoveAll();
                IDTSOutputColumn90 outputCol = output.OutputColumnCollection[0]; //output.OutputColumnCollection.New();
                outputCol.Name = OutputColName;
                //outputCol.ExternalMetadataColumnID = lineageID;


                //IDTSOutput90 output = objDataConvert.OutputCollection[0];
                //IDTSVirtualInput90 vInput = input.GetVirtualInput();
                //foreach (IDTSVirtualInputColumn90 vColumn in vInput.VirtualInputColumnCollection)
                //{
                //    IDTSInputColumn90 vCol = instance.SetUsageType(input.ID, vInput, vColumn.LineageID, DTSUsageType.UT_READONLY);
                //    instance.MapOutputColumn(  .MapInputColumn(input.ID, vCol.ID, input.ExternalMetadataColumnCollection[vColumn.Name].ID);

                //}

            }
            catch (Exception ex)
            {

                throw ex;
            }

        }

    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\xereports\GenerateSSIS\DerivedColTask.cs ===
using System;
using System.Text;
using GenerateDTS.Common;
using Microsoft.SqlServer.Dts.Pipeline.Wrapper;
using dtr = Microsoft.SqlServer.Dts.Runtime.Wrapper;
using Microsoft.SqlServer.Dts.Runtime;
using Microsoft.SqlServer.Dts.Tasks.ExecuteSQLTask;
using System.Collections;


namespace GenerateDTS
{
    class DerivedColTask
    {
        public void modifyDerivedColTask(Package pkg, string DataFlowTaskName, string DerivedColTaskName, string KeyColName, string ColumnName, string UserExpression)
        {

            IDTSComponentMetaData90 DerivedColTask = null;
            MainPipe dataFlow;
            Executable exe;

            try
            {
                exe = pkg.Executables[DataFlowTaskName];
                TaskHost th2 = exe as TaskHost;
                dataFlow = th2.InnerObject as MainPipe; // getting the datatflow task

                // getting the lookup task which belongs to the dataflow task
                foreach (IDTSComponentMetaData90 comp in dataFlow.ComponentMetaDataCollection)
                    if (comp.Name.ToLower() == DerivedColTaskName.ToLower())
                        DerivedColTask = comp;

                CManagedComponentWrapper instanceSplit = DerivedColTask.Instantiate();

                //Initialize the connection
                instanceSplit.AcquireConnections(null);
                instanceSplit.ReinitializeMetaData();
                instanceSplit.ReleaseConnections();


                IDTSInput90 input = DerivedColTask.InputCollection[0];
                IDTSVirtualInput90 vInput = input.GetVirtualInput();
                IDTSInputColumn90 vKeyCol = null;
                IDTSInputColumn90 vCol = null;

                // Set the col mapping aginst the lookup.
                foreach (IDTSVirtualInputColumn90 vColumn in vInput.VirtualInputColumnCollection)
                {
                    if (vColumn.Name == KeyColName)
                    {
                        vKeyCol = instanceSplit.SetUsageType(input.ID, vInput, vColumn.LineageID, DTSUsageType.UT_READWRITE);
                    }
                    if (vColumn.Name == ColumnName)
                    {
                        vCol = instanceSplit.SetUsageType(input.ID, vInput, vColumn.LineageID, DTSUsageType.UT_READONLY);
                    }
                }

                for (int i = 0; i < input.InputColumnCollection.Count; i++)
                {
                    IDTSInputColumn90 col = input.InputColumnCollection[i];
                    if (col.Name.ToLower() == KeyColName.ToLower())
                    {
                        col.CustomPropertyCollection["Expression"].Value =@"#" + UserExpression.Replace(vCol.Name, vCol.LineageID.ToString());
                        col.CustomPropertyCollection["FriendlyExpression"].Value = UserExpression;
                    }
                }

            }
            catch (Exception ex)
            {
                Console.WriteLine(ex.Message);
                throw ex;
            }
        }

    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\xereports\GenerateSSIS\DataFlowTask.cs ===
using System;
using System.Collections.Generic;
using System.Text;
using System.Collections;
using System.Data;
using System.Data.SqlClient;
using Microsoft.ApplicationBlocks.Data;
using GenerateDTS.Common;
using Microsoft.SqlServer.Dts.Pipeline.Wrapper;
using dtr = Microsoft.SqlServer.Dts.Runtime.Wrapper;
using Microsoft.SqlServer.Dts.Runtime;

namespace GenerateDTS
{

    class DataFlowTask
    {
        private string _spObjectTypeName = string.Empty;

        public DataFlowTask()
        {
            _spObjectTypeName = Global.GetAppParamValue("SPObjectTypeName");
        }

        public bool retriveObjectColumnInfo(AppStructs.GenerateObjectStruct objStruct, ref ArrayList _tblColumnStructList)
        {
            if (_tblColumnStructList == null)
            {
                _tblColumnStructList = new ArrayList();
            }

            string commandText = "metadata.p_GetPackageObjectColumn";
            SqlDataReader reader = null;

            try
            {
                // get column names for the tables
                SqlParameter[] parameters = new SqlParameter[1];
                parameters[0] = new SqlParameter("@ObjectID", System.Data.SqlDbType.Int);
                //if (objStruct.sourceObjectTypeName == _spObjectTypeName)
                //{
                //    parameters[0].Value = objStruct.HistorydestinationObjectName;
                //}
                //else
                //{
                //    if (objStruct.etlStage == "Extract")
                //        parameters[0].Value = objStruct.WorkdestObjectID;
                //    else if (objStruct.etlStage == "Transform")
                //        parameters[0].Value = objStruct.sourceObjectID;
                //    else if (objStruct.etlStage == "Load")
                //        parameters[0].Value = objStruct.sourceObjectID;

                //}

                if (objStruct.etlStage == "Extract")
                    parameters[0].Value = objStruct.WorkdestObjectID;
                else if (objStruct.etlStage == "Transform")
                    parameters[0].Value = objStruct.sourceObjectID;
                else if (objStruct.etlStage == "Load")
                    parameters[0].Value = objStruct.sourceObjectID;

                reader = SqlHelper.ExecuteReader(Global.MetadataConnString,CommandType.StoredProcedure, commandText, parameters);
            }
            catch (Exception ex)
            {
                Console.WriteLine(ex.Message);
                return false;
            }

            if (!reader.HasRows)
            {
                Console.WriteLine("Object " + objStruct.sourceObjectName
                    + " does not have columns defined in ObjectColumn table. ");
                reader.Close();
                return false;
            }


            int i = 0, j = 0;

            while (reader.Read())
            {
                AppStructs.TableColumnStruct colStruct = new AppStructs.TableColumnStruct();

                colStruct.ordinal = ++j;

                try
                {
                    i = reader.GetOrdinal("vc_ColumnName");
                    colStruct.columnName = (string)reader.GetValue(i);

                    i = reader.GetOrdinal("vc_ColumnType");
                    colStruct.columnType = (string)reader.GetValue(i);

                    /*i = reader.GetOrdinal("ColumnLength");
                    if (!reader.IsDBNull(i))
                    {
                        colStruct.columnLength = (int)reader.GetValue(i);
                    }

                    i = reader.GetOrdinal("ColumnPrec");
                    if (!reader.IsDBNull(i))
                    {
                        try
                        {
                            colStruct.columnPrecision = Convert.ToInt32(reader.GetValue(i));
                        }
                        catch (Exception ex)
                        {
                            ex.ToString();
                            colStruct.columnPrecision = 0;
                        }
                    }
                    else
                    {
                        colStruct.columnPrecision = 0;
                    }

                    i = reader.GetOrdinal("IsTransferred");
                    colStruct.isTransferred = Convert.ToBoolean(reader.GetValue(i));
                    */
                    i = reader.GetOrdinal("IsPrimaryKey");
                    colStruct.isPrimaryKey  = Convert.ToBoolean(reader.GetValue(i));


                }
                catch (Exception ex)
                {
                    Console.WriteLine(ex.StackTrace);
                    return false;
                }

                _tblColumnStructList.Add(colStruct);

            }
            reader.Close();

            return true;
        }

        public void ModifyOledbSourceAdapter(Package pkg, string TaskName, string SourceAdapterName, string ConnName, Common.OledbSourceAccessMode AccessMode, string AccessValue)
        {

            IDTSComponentMetaData90 oledbSource;
            MainPipe dataFlow;
            Executable exe;

            try
            {
                exe = pkg.Executables[TaskName];
            }
            catch (Exception ex)
            {
                Console.WriteLine(ex.Message);
                throw ex;
            }

            TaskHost th2 = exe as TaskHost;
            dataFlow = th2.InnerObject as MainPipe;

            oledbSource = null;

            foreach (IDTSComponentMetaData90 comp in dataFlow.ComponentMetaDataCollection)
            {
                if (comp.Name == SourceAdapterName)
                {
                    oledbSource = comp;

                }

            }
            if (oledbSource.RuntimeConnectionCollection.Count > 0)
            {
                oledbSource.RuntimeConnectionCollection[0].ConnectionManager = DtsConvert.ToConnectionManager90(pkg.Connections[ConnName]);
                oledbSource.RuntimeConnectionCollection[0].ConnectionManagerID = pkg.Connections[ConnName].ID;
            }

            CManagedComponentWrapper instanceSource = oledbSource.Instantiate();

            if (AccessMode == Common.OledbSourceAccessMode.TableORView)
            {
                //table
                instanceSource.SetComponentProperty("AccessMode", 0);
                instanceSource.SetComponentProperty("OpenRowset", AccessValue);
            }
            else if (AccessMode == Common.OledbSourceAccessMode.SqlCommand)
            {
                instanceSource.SetComponentProperty("AccessMode", 2);
                string DummyValue = AccessValue.Remove(0, AccessValue.IndexOf("from"));
                instanceSource.SetComponentProperty("SqlCommand", "SELECT '' AS DummyColumn " + DummyValue);
                instanceSource.AcquireConnections(null);
                instanceSource.ReinitializeMetaData();
                instanceSource.ReleaseConnections();
                instanceSource.SetComponentProperty("SqlCommand", AccessValue);
            }
            else if (AccessMode == Common.OledbSourceAccessMode.SqlCommandFromVariable)
            {
                instanceSource.SetComponentProperty("AccessMode", 3);
                instanceSource.SetComponentProperty("SqlCommandVariable", "g_StoredProc");
            }
            //Acquire Connections and reinitialize the component
            try
            {
                instanceSource.AcquireConnections(null);
                instanceSource.ReinitializeMetaData();
                instanceSource.ReleaseConnections();
            }
            catch (Exception ex)
            {
                Console.WriteLine("An error occured when trying to initialize OLEDB Source for AccessValue= " + AccessValue
                                   + "\n Error= " + ex.ToString());
            }

        }

        public void ModifyOledbDestinationAdapter(Package pkg, string TaskName, string DestinationAdapterName, string ConnName, Common.OledbDestinationAccessMode AccessMode, string AccessValue)
        {
            IDTSComponentMetaData90 oledbDestination=null;
            MainPipe dataFlow=null;
            Executable exe = pkg.Executables[TaskName];
            TaskHost th2 = exe as TaskHost;
            dataFlow = th2.InnerObject as MainPipe;



            foreach (IDTSComponentMetaData90 comp in dataFlow.ComponentMetaDataCollection)
            {
                if (comp.Name == DestinationAdapterName)
                {
                    oledbDestination = comp;

                }
            }

            if (oledbDestination.RuntimeConnectionCollection.Count > 0)
            {
                oledbDestination.RuntimeConnectionCollection[0].ConnectionManager = DtsConvert.ToConnectionManager90(pkg.Connections[ConnName]);
                oledbDestination.RuntimeConnectionCollection[0].ConnectionManagerID = pkg.Connections[ConnName].ID;
            }

            CManagedComponentWrapper instanceDest = oledbDestination.Instantiate();

            // Currently we are not using the AccessMode option and directly setting the value.
            instanceDest.SetComponentProperty("OpenRowset", AccessValue);

            //Acquire Connections and reinitialize the component
            try
            {
                instanceDest.AcquireConnections(null);
                instanceDest.ReinitializeMetaData();
                instanceDest.ReleaseConnections();
            }
            catch (Exception ex)
            {
                Console.WriteLine("An error occured when trying to initialize OLEDB Source for AccessValue= " + AccessValue
                                   + "\n Error= " + ex.ToString());
            }

            // Map the input columns with external columns to the Oledbdestination
            IDTSInput90 input = oledbDestination.InputCollection[0];
            IDTSVirtualInput90 vInput = input.GetVirtualInput();
            foreach (IDTSVirtualInputColumn90 vColumn in vInput.VirtualInputColumnCollection)
            {
                if (!vColumn.Name.EndsWith("_Lookup"))
                {
                    //&& !vColumn.Name.EndsWith("RowCreatedDateID")
                    IDTSInputColumn90 vCol = instanceDest.SetUsageType(input.ID, vInput, vColumn.LineageID, DTSUsageType.UT_READONLY);
                    try
                    {
                        //for()
                        instanceDest.MapInputColumn(input.ID, vCol.ID, input.ExternalMetadataColumnCollection[vColumn.Name].ID);


                    }
                    catch (Exception)
                    {
                        //Console.WriteLine(ex.Message);
                    }
                }

            }

            try
            {
                instanceDest.AcquireConnections(null);
                instanceDest.ReinitializeMetaData();
                instanceDest.ReleaseConnections();
            }
            catch { }


        }

        public string GetSQLStatementForObject(AppStructs.GenerateObjectStruct objStruct, ArrayList _tblColumnStructList)
        {
                StringBuilder sqlSB = new StringBuilder();
                bool firstTime = true;
                sqlSB.Append("select");
                sqlSB.Append("\r\n");

                IEnumerator listEnumerator = _tblColumnStructList.GetEnumerator();

                while (listEnumerator.MoveNext())
                {
                    AppStructs.TableColumnStruct colStruct = (AppStructs.TableColumnStruct)listEnumerator.Current;

                    if (firstTime)
                    {
                        sqlSB.Append("       " + "[" + colStruct.columnName + "]");
                        firstTime = false;
                    }
                    else
                    {
                        sqlSB.Append("       ," + "[" + colStruct.columnName + "]");
                    }
                    sqlSB.Append("\r\n");
                }

                sqlSB.Append("from " + "[" + objStruct.sourceObjectName + "]");
                sqlSB.Append("\r\n");

                return sqlSB.ToString();
        }

        public void ModifyFlatFileSourceAdapter(Package pkg, string TaskName, string SourceAdapterName, string ConnName)
        {

            IDTSComponentMetaData90 oledbSource;
            MainPipe dataFlow;
            Executable exe;
            string constring=string.Empty;

            try
            {
                exe = pkg.Executables[TaskName];
            }
            catch (Exception ex)
            {
                Console.WriteLine(ex.Message);
                throw ex;
            }

            TaskHost th2 = exe as TaskHost;
            dataFlow = th2.InnerObject as MainPipe;

            oledbSource = null;

            foreach (IDTSComponentMetaData90 comp in dataFlow.ComponentMetaDataCollection)
            {
                if (comp.Name == SourceAdapterName)
                {
                    oledbSource = comp;

                }

            }

            if (oledbSource.RuntimeConnectionCollection.Count > 0)
            {
                oledbSource.RuntimeConnectionCollection[0].ConnectionManager = DtsConvert.ToConnectionManager90(pkg.Connections[ConnName]);
                oledbSource.RuntimeConnectionCollection[0].ConnectionManagerID = pkg.Connections[ConnName].ID;
            }

            CManagedComponentWrapper instanceSource = oledbSource.Instantiate();
            constring = oledbSource.RuntimeConnectionCollection[0].ConnectionManager.ConnectionString;

            //Acquire Connections and reinitialize the component
            try
            {
                instanceSource.AcquireConnections(null);
                instanceSource.ReinitializeMetaData();
                instanceSource.ReleaseConnections();
            }
            catch (Exception ex)
            {
                Console.WriteLine("An error occured when trying to initialize Flat File Source for AccessValue= " + constring
                                   + "\n Error= " + ex.ToString());
            }

        }

        public void ModifyOledbDestinationAdapter_XML(Package pkg, string TaskName, string DestinationAdapterName, string ConnName, Common.OledbDestinationAccessMode AccessMode, string AccessValue)
        {
            IDTSComponentMetaData90 oledbDestination = null;
            MainPipe dataFlow = null;
            Executable exe = pkg.Executables[TaskName];
            TaskHost th2 = exe as TaskHost;
            dataFlow = th2.InnerObject as MainPipe;



            foreach (IDTSComponentMetaData90 comp in dataFlow.ComponentMetaDataCollection)
            {
                if (comp.Name == DestinationAdapterName)
                {
                    oledbDestination = comp;

                }
            }

            if (oledbDestination.RuntimeConnectionCollection.Count > 0)
            {
                oledbDestination.RuntimeConnectionCollection[0].ConnectionManager = DtsConvert.ToConnectionManager90(pkg.Connections[ConnName]);
                oledbDestination.RuntimeConnectionCollection[0].ConnectionManagerID = pkg.Connections[ConnName].ID;
            }

            CManagedComponentWrapper instanceDest = oledbDestination.Instantiate();

            // Currently we are not using the AccessMode option and directly setting the value.
            instanceDest.SetComponentProperty("OpenRowset", AccessValue);

            //Acquire Connections and reinitialize the component
            try
            {
                instanceDest.AcquireConnections(null);
                instanceDest.ReinitializeMetaData();
                instanceDest.ReleaseConnections();
            }
            catch (Exception ex)
            {
                Console.WriteLine("An error occured when trying to initialize OLEDB Source for AccessValue= " + AccessValue
                                   + "\n Error= " + ex.ToString());
            }

            // Map the input columns with external columns to the Oledbdestination
            IDTSInput90 input = oledbDestination.InputCollection[0];
            IDTSVirtualInput90 vInput = input.GetVirtualInput();
            int icnt = 0;
            foreach (IDTSVirtualInputColumn90 vColumn in vInput.VirtualInputColumnCollection)
            {
                if(icnt==1)
                {
                IDTSInputColumn90 vCol = instanceDest.SetUsageType(input.ID, vInput, vColumn.LineageID, DTSUsageType.UT_READONLY);
                try
                {
                    instanceDest.MapInputColumn(input.ID, vCol.ID, input.ExternalMetadataColumnCollection[vColumn.Name].ID);
                }
                catch { }
                }
                icnt++;


            }

        }

        public void ModifyOledbCommand(Package pkg, string TaskName, string DestinationAdapterName, string ConnName, Common.OledbDestinationAccessMode AccessMode, string AccessValue,ArrayList ColOrder)
        {
            IDTSComponentMetaData90 oledbDestination = null;
            MainPipe dataFlow = null;
            Executable exe = pkg.Executables[TaskName];
            TaskHost th2 = exe as TaskHost;
            dataFlow = th2.InnerObject as MainPipe;



            foreach (IDTSComponentMetaData90 comp in dataFlow.ComponentMetaDataCollection)
            {
                if (comp.Name == DestinationAdapterName)
                {
                    oledbDestination = comp;
                }
            }

            if (oledbDestination.RuntimeConnectionCollection.Count > 0)
            {
                oledbDestination.RuntimeConnectionCollection[0].ConnectionManager = DtsConvert.ToConnectionManager90(pkg.Connections[ConnName]);
                oledbDestination.RuntimeConnectionCollection[0].ConnectionManagerID = pkg.Connections[ConnName].ID;
            }

            CManagedComponentWrapper instanceDest = oledbDestination.Instantiate();

            // Currently we are not using the AccessMode option and directly setting the value.
            instanceDest.SetComponentProperty("SqlCommand", AccessValue);

            //Acquire Connections and reinitialize the component
            try
            {
                instanceDest.AcquireConnections(null);
                instanceDest.ReinitializeMetaData();
                instanceDest.ReleaseConnections();
            }
            catch (Exception ex)
            {
                Console.WriteLine("An error occured when trying to initialize OLEDB Source for AccessValue= " + AccessValue
                                   + "\n Error= " + ex.ToString());
            }

            // Map the input columns with external columns to the Oledbdestination
            IDTSInput90 input = oledbDestination.InputCollection[0];
            IDTSVirtualInput90 vInput = input.GetVirtualInput();

            foreach (IDTSVirtualInputColumn90 vColumn in vInput.VirtualInputColumnCollection)
            {
                IDTSInputColumn90 vCol = instanceDest.SetUsageType(input.ID, vInput, vColumn.LineageID, DTSUsageType.UT_READONLY);
                for (int i = 0; i < ColOrder.Count ; i++)
                {
                    if (((string)ColOrder[i]).ToLower() == vCol.Name.ToLower())
                    {
                        instanceDest.MapInputColumn(input.ID, vCol.ID, input.ExternalMetadataColumnCollection["Param_" + i.ToString()].ID);
                        break;
                    }
                }

            }

        }


    }

}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\xereports\GenerateSSIS\DTSExtractPackage.cs ===
using System;
using System.Collections.Generic;
using System.Text;
using System.Collections;
using System.Data;
using System.Data.SqlClient;
using Microsoft.ApplicationBlocks.Data;
using GenerateDTS.Common;
using Microsoft.SqlServer.Dts.Pipeline.Wrapper;
using dtr = Microsoft.SqlServer.Dts.Runtime.Wrapper;
using Microsoft.SqlServer.Dts.Runtime;
using Microsoft.SqlServer.Dts.Tasks.ExecuteSQLTask;

namespace GenerateDTS
{

    class DTSExtractPackage: DTSTemplatePackage
    {
        public DTSExtractPackage():base()
        { }


        public override bool Build(ArrayList objStructList)
        {

            AppStructs.GenerateObjectStruct objStruct = (AppStructs.GenerateObjectStruct)objStructList[0];

            try
            {
                // Load the package from the available template
                if (!LoadPackage(objStruct.TemplateName))
                {
                    return false;
                }

                // Modify Connection Properties
                if (!ModifyConnections(objStruct, Common.ConnectionType.OLEDB))
                {
                    return false;
                }

                if (!ModifyPackage(objStruct))
                {
                    return false;
                }

                // Saves the package in the targer server
                if (!SavePackage(objStruct.packageName))
                {
                    return false;
                }

                return true;
            }
            catch (Exception)
            {
                return false;
            }
        }

        public override bool ModifyConnections(AppStructs.GenerateObjectStruct objStruct, Common.ConnectionType ConType)
        {

            string serverName = string.Empty;
            string dbName = string.Empty;
            string destServerName = string.Empty;
            string destDBName = string.Empty;
            string DeltaDestServerName = string.Empty;
            string DeltaDestDBName = string.Empty;

            string resStrHistoryConnName = Global.GetAppParamValue("ConnectionETLExtractHistory");
            string resStrDeltaConnName = Global.GetAppParamValue("ConnectionETLExtract");

            try
            {
                if (!GetConnectionInfo(objStruct.SourceConnectionName, ref serverName, ref dbName))
                    return false;
            }
            catch (Exception ex)
            {
                Console.WriteLine(ex.Message);
                Console.WriteLine("Failed when extracting return data for " + objStruct.SourceConnectionName);
                return false;
            }
            try
            {
                if (!GetConnectionInfo(resStrHistoryConnName, ref destServerName, ref destDBName))
                    return false;

            }
            catch (Exception ex)
            {
                Console.WriteLine(ex.Message);
                Console.WriteLine("Failed when extracting return data for " + resStrHistoryConnName);
                return false;
            }
            try
            {
                if (!GetConnectionInfo(resStrDeltaConnName, ref DeltaDestServerName, ref DeltaDestDBName))
                    return false;

            }
            catch (Exception ex)
            {
                Console.WriteLine(ex.Message);
                Console.WriteLine("Failed when extracting return data for " + resStrDeltaConnName);
                return false;
            }


            string resStrSourceConnName = Global.GetAppParamValue("ConnectionExternalSource");


            foreach (ConnectionManager conn in pkg.Connections)
            {
                if (conn.Name == resStrSourceConnName)
                {
                    conn.ConnectionString = Global.getConnectionString(serverName, dbName, GenerateDTS.Common.ConnectionType.OLEDB);
                    conn.Name = objStruct.SourceConnectionName;
                }
                else if (conn.Name == resStrHistoryConnName)
                {
                    conn.ConnectionString = Global.getConnectionString(destServerName, destDBName, GenerateDTS.Common.ConnectionType.OLEDB);
                }
                else if (conn.Name == resStrDeltaConnName)
                {
                    conn.ConnectionString = Global.getConnectionString(DeltaDestServerName, DeltaDestDBName, GenerateDTS.Common.ConnectionType.OLEDB);
                }
            }


            return true;
        }

        public override bool ModifyPackage(GenerateDTS.AppStructs.GenerateObjectStruct objStruct)
        {

            try
            {
                objStruct.etlStage = "Extract";

                 ModifyConfiguration(objStruct);
                // Modify existing sql task in template
                ModifySQLTask(objStruct);
                // Create data pump in template
                ModifyDataflowTask(objStruct);
                // Modify the global variables

                ModifyGlobalVariables(objStruct);
                // Modify the global variables
                ModifyErrorHandler(objStruct);
            }
            catch (Exception)
            {}

            return true;
        }

        public void ModifyConfiguration(GenerateDTS.AppStructs.GenerateObjectStruct objStruct)
        {

            string commandText = "metadata.p_GetParentPackage";
            SqlParameter[] PackageParameters = new SqlParameter[1];
            SqlDataReader PReader = null;

            PackageParameters[0] = new SqlParameter("@PackageName", System.Data.SqlDbType.NVarChar);
            PackageParameters[0].Value = objStruct.packageName;

            PReader = SqlHelper.ExecuteReader(Global.MetadataConnString, CommandType.StoredProcedure, commandText, PackageParameters);

            if (!PReader.HasRows)
            {
                Console.WriteLine(objStruct.packageName + " does not have parent package");
                PReader.Close();
                return;
            }

            PReader.Read();
            string strParentPackageName = PReader.GetString(0);

            foreach (Configuration con in pkg.Configurations)
            {
                if (con.Name == "PackageSpecificConfigurations")
                {
                    pkg.Configurations["PackageSpecificConfigurations"].ConfigurationString = "\"Metadata\";\"[metadata].[Configurations]\";\"" + strParentPackageName + "Configurations\";";
                }
                else if (con.Name == "CommonConfigurations")
                {
                    pkg.Configurations["CommonConfigurations"].ConfigurationString = "\"Metadata\";\"[metadata].[Configurations]\";\"" + "CommonConfigurations\";";
                }
            }

            if (Global.GetAppParamValue("ReCreateConfigurationValues").ToString().ToLower() != "true")
            {
                return;
            }


            commandText = "metadata.p_InsertConfigurationValues";

            SqlDataReader reader = null;
            SqlParameter[] parameters = new SqlParameter[4];

            foreach (ConnectionManager Conn in pkg.Connections)
            {
                if (Conn.Name != Global.GetAppParamValue("MetadataConnection")
                    && Conn.Name != Global.GetAppParamValue("AuditConnection")
                    && Conn.Name != Global.GetAppParamValue("ConnectionETLExtract")
                    && Conn.Name != Global.GetAppParamValue("ConnectionETLExtractHistory")
                    && Conn.Name != Global.GetAppParamValue("ConnectionETLTransform")
                    && Conn.Name != Global.GetAppParamValue("MasterNonLeafExtractConnectionName")
                    && Conn.Name != Global.GetAppParamValue("MasterNonLeafTransformConnectionName"))
                {

                    parameters[0] = new SqlParameter("@ConfigurationFilter", System.Data.SqlDbType.NVarChar);
                    parameters[0].Value = strParentPackageName + "Configurations";

                    parameters[1] = new SqlParameter("@ConfiguredValue", System.Data.SqlDbType.NVarChar);
                    string strConn = Conn.ConnectionString.Replace("Data Source=", "");
                    parameters[1].Value = strConn.Substring(0, strConn.IndexOf(";"));

                    parameters[2] = new SqlParameter("@PackagePath", System.Data.SqlDbType.NVarChar);
                    parameters[2].Value = @"\Package.Connections[" + Conn.Name + @"].Properties[ServerName]";

                    parameters[3] = new SqlParameter("@ConfiguredValueType", System.Data.SqlDbType.NVarChar);
                    parameters[3].Value = "String";

                    reader = SqlHelper.ExecuteReader(Global.MetadataConnString, CommandType.StoredProcedure, commandText, parameters);

                    parameters[1] = new SqlParameter("@ConfiguredValue", System.Data.SqlDbType.NVarChar);
                    strConn = strConn.Remove(0, strConn.IndexOf(";") + 1).Replace("Initial Catalog=", "");
                    parameters[1].Value = strConn.Substring(0, strConn.IndexOf(";"));

                    parameters[2] = new SqlParameter("@PackagePath", System.Data.SqlDbType.NVarChar);
                    parameters[2].Value = @"\Package.Connections[" + Conn.Name + @"].Properties[InitialCatalog]";

                    reader = SqlHelper.ExecuteReader(Global.MetadataConnString, CommandType.StoredProcedure, commandText, parameters);

                    reader = null;
                }
                else if (Conn.Name == Global.GetAppParamValue("MetadataConnection")
                    || Conn.Name == Global.GetAppParamValue("AuditConnection")
                    || Conn.Name == Global.GetAppParamValue("ConnectionETLExtract")
                    || Conn.Name == Global.GetAppParamValue("ConnectionETLExtractHistory")
                    || Conn.Name == Global.GetAppParamValue("ConnectionETLTransform")
                    || Conn.Name == Global.GetAppParamValue("MasterNonLeafExtractConnectionName")
                    || Conn.Name == Global.GetAppParamValue("MasterNonLeafTransformConnectionName"))
                {
                    parameters[0] = new SqlParameter("@ConfigurationFilter", System.Data.SqlDbType.NVarChar);
                    parameters[0].Value = "CommonConfigurations";

                    parameters[1] = new SqlParameter("@ConfiguredValue", System.Data.SqlDbType.NVarChar);
                    string strConn = Conn.ConnectionString.Replace("Data Source=", "");
                    parameters[1].Value = strConn.Substring(0, strConn.IndexOf(";"));

                    parameters[2] = new SqlParameter("@PackagePath", System.Data.SqlDbType.NVarChar);
                    parameters[2].Value = @"\Package.Connections[" + Conn.Name + @"].Properties[ServerName]";

                    parameters[3] = new SqlParameter("@ConfiguredValueType", System.Data.SqlDbType.NVarChar);
                    parameters[3].Value = "String";

                    reader = SqlHelper.ExecuteReader(Global.MetadataConnString, CommandType.StoredProcedure, commandText, parameters);

                }
            }

            parameters[0] = new SqlParameter("@ConfigurationFilter", System.Data.SqlDbType.NVarChar);
            parameters[0].Value = strParentPackageName + "Configurations";

            parameters[1] = new SqlParameter("@ConfiguredValue", System.Data.SqlDbType.NVarChar);
            parameters[1].Value = @"c:\" + strParentPackageName + "Checkpoint.txt";

            parameters[2] = new SqlParameter("@PackagePath", System.Data.SqlDbType.NVarChar);
            parameters[2].Value = @"\Package.Properties[CheckpointFileName]";

            parameters[3] = new SqlParameter("@ConfiguredValueType", System.Data.SqlDbType.NVarChar);
            parameters[3].Value = "String";

            reader = SqlHelper.ExecuteReader(Global.MetadataConnString, CommandType.StoredProcedure, commandText, parameters);



        }

        public  bool ModifySQLTask(GenerateDTS.AppStructs.GenerateObjectStruct objStruct)
        {
            try
            {
                if (objStruct.isSourceIncremental)
                {
                    string resStrUpdtAudit = Global.GetAppParamValue("DTSExtract.SQLTask.ExtractWithTimeStampUpdateAudit");

                    string resStrDelDuplicatesHistory = Global.GetAppParamValue("DTSExtract.SQLTask.ExtractWithTimeStampDeleteDuplicatesHistory");
                    string resStrTruncateWorkTable = Global.GetAppParamValue("DTSExtract.SQLTask.ExtractWithTimeStampTruncateWorkTable");
                    string resStrDelDuplicatesDelta = Global.GetAppParamValue("DTSExtract.SQLTask.ExtractWithTimeStampDeleteDuplicatesDelta");
                    string resStrExecuteValidationtask = Global.GetAppParamValue("DTSExtract.SQLTask.ExtractWithTimeStampExecuteValidationtask");

                    string[,] Pat_Sub = new string[2, 2];
                    SqlTask objSqlTask = new SqlTask();

                    Pat_Sub[0, 0] = "[HistoryTableName]";
                    Pat_Sub[0, 1] = objStruct.HistorydestinationObjectName;
                    objSqlTask.PopulateTask(resStrUpdtAudit, pkg, Pat_Sub);


                    Pat_Sub[0, 0] = "[HistoryTableName]";
                    Pat_Sub[0, 1] = "[" + objStruct.HistorydestinationObjectName + "]";
                    Pat_Sub[1, 0] = "[DateColumn]";
                    Pat_Sub[1, 1] = "[" + objStruct.destCriterionColName + "]";
                    objSqlTask.PopulateTask(resStrDelDuplicatesHistory, pkg, Pat_Sub);

                    Pat_Sub[0, 0] = "[WorkTableName]";
                    Pat_Sub[0, 1] = "[" + objStruct.WorkdestinationObjectName + "]";
                    objSqlTask.PopulateTask(resStrTruncateWorkTable, pkg, Pat_Sub);

                    Pat_Sub[0, 0] = "[DeltaTableName]";
                    Pat_Sub[0, 1] = "[" + objStruct.DeltaDestinationObjectName + "]";
                    Pat_Sub[1, 0] = "[DateColumn]";
                    Pat_Sub[1, 1] = "[" + objStruct.destCriterionColName + "]";
                    objSqlTask.PopulateTask(resStrDelDuplicatesDelta, pkg, Pat_Sub);

                    Pat_Sub[0, 0] = "[DeltaTableName]";
                    Pat_Sub[0, 1] = "" + objStruct.DeltaDestinationObjectName + "";
                    objSqlTask.PopulateTask(resStrExecuteValidationtask, pkg, Pat_Sub);

                }
                else
                {

                    string resStrTruncateHistory = Global.GetAppParamValue("DTSExtract.SQLTask.ExtractWithOutTimeStampTruncateHistory");
                    string resStrTruncateWorkTable = Global.GetAppParamValue("DTSExtract.SQLTask.ExtractWithOutTimeStampTruncateWorkTable");
                    string resStrTruncateDelta = Global.GetAppParamValue("DTSExtract.SQLTask.ExtractWithOutTimeStampTruncateDelta");
                    string resStrExecuteValidationtask = Global.GetAppParamValue("DTSExtract.SQLTask.ExtractWithOutTimeStampExecuteValidationtask");

                    SqlTask objSqlTask = new SqlTask();

                    string[,] Pat_Sub = new string[1, 2];

                    Pat_Sub[0, 0] = "[HistoryTableName]";
                    Pat_Sub[0, 1] = "[" + objStruct.HistorydestinationObjectName + "]";
                    objSqlTask.PopulateTask(resStrTruncateHistory, pkg, Pat_Sub);

                    Pat_Sub[0, 0] = "[WorkTableName]";
                    Pat_Sub[0, 1] = "[" + objStruct.WorkdestinationObjectName + "]";
                    objSqlTask.PopulateTask(resStrTruncateWorkTable, pkg, Pat_Sub);

                    Pat_Sub[0, 0] = "[DeltaTableName]";
                    Pat_Sub[0, 1] = "[" + objStruct.DeltaDestinationObjectName + "]";
                    objSqlTask.PopulateTask(resStrTruncateDelta, pkg, Pat_Sub);

                    Pat_Sub[0, 0] = "[DeltaTableName]";
                    Pat_Sub[0, 1] = "" + objStruct.DeltaDestinationObjectName + "";
                    objSqlTask.PopulateTask(resStrExecuteValidationtask, pkg, Pat_Sub);

                }

                return true;
            }
            catch (Exception)
            {
                Console.WriteLine("Failed to modify the SqlTask for Package: " + objStruct.packageName);
                return false;
            }


        }

        public  bool ModifyDataflowTask(GenerateDTS.AppStructs.GenerateObjectStruct objStruct)
        {

            try
            {
                ArrayList _tblColumnStructList = null;
                string _spObjectTypeName = string.Empty;
                DataFlowTask objDataFlowTask = new DataFlowTask();
                string sqlQry = "";
                string TaskName = "";
                string SourceAdapterName = "";
                string HistoryDestinationAdapterName = "";
                string WorkDestinationAdapterName = "";
                string SourceConnectionName = "";
                string HistoryDestinationConnectionName = "";
                string WorkDestinationConnectionName = "";


                if (!objDataFlowTask.retriveObjectColumnInfo(objStruct, ref _tblColumnStructList))
                {
                    return false;
                }

                // Read the task level values and connection names
                if (objStruct.isSourceIncremental)
                {

                    TaskName = Global.GetAppParamValue("DTSExtract.DataFlowTask.ExtractWithTimeStampDataFlowTask");
                    SourceAdapterName = Global.GetAppParamValue("DTSExtract.DataFlowTask.ExtractWithTimeStampSourceAdapter");
                    HistoryDestinationAdapterName = Global.GetAppParamValue("DTSExtract.DataFlowTask.ExtractWithTimeStampDestinationAdapterHistory");
                    WorkDestinationAdapterName = Global.GetAppParamValue("DTSExtract.DataFlowTask.ExtractWithTimeStampDestinationAdapterWork");
                }
                else
                {
                    TaskName = Global.GetAppParamValue("DTSExtract.DataFlowTask.ExtractWithOutTimeStampDataFlowTask");
                    SourceAdapterName = Global.GetAppParamValue("DTSExtract.DataFlowTask.ExtractWithOutTimeStampSourceAdapter");
                    HistoryDestinationAdapterName = Global.GetAppParamValue("DTSExtract.DataFlowTask.ExtractWithOutTimeStampDestinationAdapterHistory");
                    WorkDestinationAdapterName = Global.GetAppParamValue("DTSExtract.DataFlowTask.ExtractWithOutTimeStampDestinationAdapterWork");
                }

                SourceConnectionName = objStruct.SourceConnectionName;
                HistoryDestinationConnectionName = Global.GetAppParamValue("ConnectionETLExtractHistory");
                WorkDestinationConnectionName = Global.GetAppParamValue("ConnectionETLExtract");

                string sqlWhere = " ";
                // Invoke the source Adapter with proper object/ sql sattement
                if (objStruct.isSourceIncremental)
                {
                    sqlWhere += " where " + "[" + objStruct.destCriterionColName + "]" + " > ?";
                }

                    if (objStruct.sourceObjectTypeName == Global.GetAppParamValue("SPObjectTypeName"))
                    {
                        sqlQry = "";
                        SqlParameter[] parameters = new SqlParameter[3];
                        parameters[0] = new SqlParameter("@ObjectName", System.Data.SqlDbType.VarChar, 256);
                        parameters[0].Value = objStruct.sourceObjectName;

                        parameters[1] = new SqlParameter("@ExtractObjectName", System.Data.SqlDbType.VarChar, 256);
                        parameters[1].Value = objStruct.DeltaDestinationObjectName;

                        parameters[2] = new SqlParameter("@SProc", System.Data.SqlDbType.VarChar, 8000);
                        parameters[2].Direction=ParameterDirection.Output;

                        SqlHelper.ExecuteNonQuery(Global.MetadataConnString, CommandType.StoredProcedure, "GetStoredProcWithParamValues", parameters);

                        pkg.Variables["g_StoredProc"].Value = parameters[2].Value;

                        objDataFlowTask.ModifyOledbSourceAdapter(pkg, TaskName, SourceAdapterName, SourceConnectionName, OledbSourceAccessMode.SqlCommandFromVariable,"g_StoredProc" );
                    }
                    else
                    {
                        //chk for custom qry but dont build the query
                        sqlQry = objStruct.SqlQuery;

                        if (sqlQry ==null || sqlQry == string.Empty)
                        {
                            sqlQry = objDataFlowTask.GetSQLStatementForObject(objStruct, _tblColumnStructList);
                            if (sqlQry == null || sqlQry == string.Empty)
                                objDataFlowTask.ModifyOledbSourceAdapter(pkg, TaskName, SourceAdapterName, SourceConnectionName,
                                    OledbSourceAccessMode.TableORView, objStruct.sourceObjectName);
                            else
                            {
                                sqlQry += sqlWhere;
                                objDataFlowTask.ModifyOledbSourceAdapter(pkg, TaskName, SourceAdapterName, SourceConnectionName,
                                    OledbSourceAccessMode.SqlCommand, sqlQry);
                            }
                        }
                        else
                        {
                            objDataFlowTask.ModifyOledbSourceAdapter(pkg, TaskName, SourceAdapterName, SourceConnectionName,
                                OledbSourceAccessMode.SqlCommand, sqlQry);
                        }
                    }


                //Invoke the destination Adapter
                    objDataFlowTask.ModifyOledbDestinationAdapter(pkg, TaskName, HistoryDestinationAdapterName, HistoryDestinationConnectionName, OledbDestinationAccessMode.TableORViewFastLoad, objStruct.HistorydestinationObjectName);
                    objDataFlowTask.ModifyOledbDestinationAdapter(pkg, TaskName, WorkDestinationAdapterName, WorkDestinationConnectionName, OledbDestinationAccessMode.TableORViewFastLoad, objStruct.WorkdestinationObjectName);

                return true;
            }
            catch (Exception)
            {
                Console.WriteLine("Error in setting the dataflow task for package " + objStruct.packageName);
                return false;
            }
        }


    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\xereports\GenerateSSIS\GenerateMain.cs ===
#region Using directives

using System;
using System.Collections.Generic;
using System.Text;


#endregion

namespace GenerateDTS
{
    class GenerateMain
    {
        static void Main(string[] args)
        {
            try
            {
                GenerateMain progMain = new GenerateMain();
                if (!progMain.generateLeafPackage())
                {
                    Console.WriteLine("Could not generate Leaf packages");
                    return;
                }
                if (!progMain.generateMasterPackage())
                {
                    Console.WriteLine("Could not generate Master packages");
                    return;
                }
            }
            catch (System.Exception ex)
            {
                Console.WriteLine(ex.Message);
            }
            finally
            {

                Console.WriteLine("\nPackage generation process complete. Press any key to exit...");
                Console.Read();
            }
        }
        public bool generateLeafPackage()
        {
            GenerateMgr mgr = new GenerateMgr();
            //return true;
            return mgr.generateLeafPackage();
        }

        public bool generateMasterPackage()
        {
            GenerateMgr mgr = new GenerateMgr();
            //return true;
            return mgr.generateMasterPackage();

        }

    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\xereports\GenerateSSIS\DTSTemplatePackage.cs ===
using System;
using System.Collections;
using System.IO;
using System.Data;
using System.Data.SqlClient;
using Microsoft.SqlServer.Dts.Pipeline.Wrapper;
using Microsoft.SqlServer.Dts.Runtime;
using Microsoft.SqlServer.Dts.Tasks.ExecuteSQLTask;
using GenerateDTS.Common;
using Microsoft.ApplicationBlocks.Data;


namespace GenerateDTS
{
    /// <summary>
    /// Summary description for DTSTemplatePackage.
    /// </summary>
    public abstract class DTSTemplatePackage: IPackage
    {
        protected Package pkg;
        Application app;

        public DTSTemplatePackage()
        {
                pkg = new Package();
                app = new Application();
        }

        public virtual bool Build(ArrayList objStructList)
        {
            return true;
        }

        public bool LoadPackage(string TemplatePkgName)
        {
            string strFilePath = String.Empty;
            try
            {
                strFilePath = Global.GetAppParamValue("TemplatePackageFilePath").Trim();

                if (strFilePath.EndsWith(@"\") == true)
                    strFilePath += TemplatePkgName; //+ @".dtsx";
                else
                    strFilePath += @"\" + TemplatePkgName; // +@".dtsx";

                pkg = app.LoadPackage(strFilePath, null);

            }
            catch (Exception ex)
            {
                Console.WriteLine("Error when loading " + strFilePath);
                Console.WriteLine(ex.Message);
                return false;
            }
            return true;
        }

        public virtual bool ModifyConnections(AppStructs.GenerateObjectStruct objPkgDetails, Common.ConnectionType ConType)
        {
            return true;
        }

        public bool GetConnectionInfo(string ConnectionName, ref string ServerName, ref string DBName)
        {
            string commandText = "metadata.p_GetConnectionInfo";
            SqlDataReader reader = null;
            try
            {
                SqlParameter[] parameters = new SqlParameter[1];
                parameters[0] = new SqlParameter("@ConnectionName", System.Data.SqlDbType.NVarChar);
                parameters[0].Value = ConnectionName;
                reader = SqlHelper.ExecuteReader(Global.MetadataConnString, CommandType.StoredProcedure, commandText, parameters);
            }
            catch (Exception ex)
            {
                Console.WriteLine(ex.Message);
                return false;
            }

            if (!reader.HasRows)
            {
                Console.WriteLine("No connection data for " + ConnectionName);
                reader.Close();
                return false;
            }

            if (reader.Read())
            {
                try
                {
                    ServerName = (string)reader.GetValue(0);
                    DBName = (string)reader.GetValue(1);
                }
                catch (Exception ex)
                {
                    Console.WriteLine(ex.Message);
                    Console.WriteLine("Failed when extracting return data for " + ConnectionName);
                    return false;
                }
            }

            reader.Close();
            reader = null;
            return true;
        }

        public virtual bool ModifyPackage(GenerateDTS.AppStructs.GenerateObjectStruct objStruct)
        {
            return true;
        }

        public bool ModifyErrorHandler(GenerateDTS.AppStructs.GenerateObjectStruct objStruct)
        {
            DtsEventHandler ehPreExecute = (DtsEventHandler)pkg.EventHandlers["OnError"];
            Executables ehExecs = ehPreExecute.Executables;
            Executable ehExec = ehExecs[0];
            TaskHost taskHost = (TaskHost)ehExec;
            if (taskHost.InnerObject is Microsoft.SqlServer.Dts.Tasks.ExecuteSQLTask.ExecuteSQLTask)
            {
                IDTSExecuteSQL sqlTask = (IDTSExecuteSQL)taskHost.InnerObject;
                if (taskHost.Name == Global.GetAppParamValue("ErrorHandlerTaskName"))
                {
                    string tableName = string.Empty;

                    if (objStruct.etlStage == "Transform")
                    {
                        tableName = "[TransformTableName]";
                    }
                    else if (objStruct.etlStage == "Extract")
                    {
                        tableName = "[ExtractTableName]";
                    }
                    sqlTask.SqlStatementSource = sqlTask.SqlStatementSource.Replace(tableName, objStruct.HistorydestinationObjectName);
                    //sqlTask.SqlStatementSource = sqlTask.SqlStatementSource.Replace("[SourceName]", objStruct.destSource);
                }
            }
            return true;
        }

        public bool ModifyGlobalVariables(AppStructs.GenerateObjectStruct objStruct)
        {
            try
            {

                if (objStruct.etlStage == "Extract" || objStruct.TemplateName.ToLower() == "TransformSCDTemplate.dtsx".ToLower())
                {
                    pkg.Variables["g_Destination_ObjectName"].Value = objStruct.DeltaDestinationObjectName;
                    //pkg.Variables["g_Destination_ServerName"].Value = objStruct.destSource;

                    if (objStruct.etlStage == "Extract")
                    {
                        pkg.Variables["g_Source_ObjectName"].Value = objStruct.sourceObjectName;
                        pkg.Variables["g_SPObjectTypeName"].Value = Global.GetAppParamValue("SPObjectTypeName");
                        pkg.Variables["g_Source_ObjectType"].Value = objStruct.sourceObjectTypeName;

                        pkg.Variables["g_WorkTableName"].Value = objStruct.WorkdestinationObjectName;
                        if (pkg.Variables.Contains("g_Destination_ObjectTypeID")) pkg.Variables["g_Destination_ObjectTypeID"].Value = objStruct.DestinationObjectTypeId;

                    }
                }
                else if (objStruct.etlStage == "Transform")
                {
                    pkg.Variables["g_TransformationProc"].Value = objStruct.sourceObjectName;
                    pkg.Variables["g_Destination_ObjectName"].Value = objStruct.HistorydestinationObjectName;
                }

                return true;
            }
            catch (Exception ex)
            {

                Console.WriteLine("Missing global variable. Error: " + ex.Message);
                return false;
            }
        }

        public bool SavePackage(string packageName)
        {
            string newDTSFileDir = Global.GetAppParamValue("NewDTSPackageFileDir");
            try
            {
                pkg.Name = packageName;
                if (Global.GetAppParamValue("DeployToFile").ToLower()  == "true")
                {
                    app.SaveToXml(newDTSFileDir + packageName + ".dtsx", pkg, null);
                }
                app.SaveToSqlServer(pkg, null, Global.GetAppParamValue("DTSDeployTargetServer"), "", "");
                Console.WriteLine("Generated package: " + packageName + ".dtsx");
            }
            catch (Exception ex)
            {
                Console.WriteLine(ex.Message);
                return false;
            }

            return true;
        }

    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\xereports\GenerateSSIS\DTSTransformPackage.cs ===
using System;
using System.Collections.Generic;
using System.Text;
using System.Collections;
using System.Data;
using System.Data.SqlClient;
using Microsoft.ApplicationBlocks.Data;
using GenerateDTS.Common;
using Microsoft.SqlServer.Dts.Pipeline.Wrapper;
using dtr = Microsoft.SqlServer.Dts.Runtime.Wrapper;
using Microsoft.SqlServer.Dts.Runtime;
using Microsoft.SqlServer.Dts.Tasks.ExecuteSQLTask;

namespace GenerateDTS
{
    class DTSTransformPackage: DTSTemplatePackage
    {
        public DTSTransformPackage(): base()
        {}

        public override bool Build(ArrayList objStructList)
        {
            AppStructs.GenerateObjectStruct objStruct = (AppStructs.GenerateObjectStruct)objStructList[0];

            try
            {
                // Load the package from the available template
                if (!LoadPackage(objStruct.TemplateName))
                {
                    return false;
                }



                // Modify Connection Properties
                if (!ModifyConnections(objStruct, Common.ConnectionType.OLEDB))
                {
                    return false;
                }

                if (!ModifyPackage(objStruct))
                {
                    return false;
                }

                // Saves the package in the targer server
                if (!SavePackage(objStruct.packageName))
                {
                    return false;
                }

                return true;
            }
            catch (Exception)
            {
                return false;
            }
        }

        public override bool ModifyConnections(AppStructs.GenerateObjectStruct objStruct, Common.ConnectionType ConType)
        {

            string serverName = string.Empty;
            string dbName = string.Empty;
            string destServerName = string.Empty;
            string destDBName = string.Empty;

            try
            {
                if (!GetConnectionInfo(objStruct.DestinationConnectionName, ref destServerName, ref destDBName))
                    return false;

                try
                {
                    destDBName = Global.GetAppParamValue("DTSTransform.DBName");
                }
                catch (Exception)
                {
                    destDBName = "Transform";
                }



            }
            catch (Exception ex)
            {
                Console.WriteLine(ex.Message);
                Console.WriteLine("Failed when extracting return data for " + objStruct.DestinationConnectionName);
                return false;
            }

            string resStrConsolidatorConnName = Global.GetAppParamValue("ConnectionETLTransform");


            foreach (ConnectionManager conn in pkg.Connections)
            {
                if (conn.Name == resStrConsolidatorConnName)
                {
                    conn.ConnectionString = Global.getConnectionString(destServerName, destDBName, GenerateDTS.Common.ConnectionType.ADONET);
                }
            }


            return true;
        }

        public override bool ModifyPackage(GenerateDTS.AppStructs.GenerateObjectStruct objStruct)
        {
            objStruct.etlStage = "Transform";

            ModifyConfiguration(objStruct);

            // Modify existing sql task in template
            ModifySQLTask(objStruct);
            // Modify the global variables
            ModifyGlobalVariables(objStruct);
            // Modify the global variables
            ModifyErrorHandler(objStruct);

            return true;
        }

        public void ModifyConfiguration(GenerateDTS.AppStructs.GenerateObjectStruct objStruct)
        {

            string commandText = "metadata.p_GetParentPackage";
            SqlParameter[] PackageParameters = new SqlParameter[1];
            SqlDataReader PReader = null;

            PackageParameters[0] = new SqlParameter("@PackageName", System.Data.SqlDbType.NVarChar);
            PackageParameters[0].Value = objStruct.packageName;

            PReader = SqlHelper.ExecuteReader(Global.MetadataConnString, CommandType.StoredProcedure, commandText, PackageParameters);

            if (!PReader.HasRows)
            {
                Console.WriteLine(objStruct.packageName + " does not have parent package");
                PReader.Close();
                return;
            }

            PReader.Read();
            string strParentPackageName = PReader.GetString(0);

            foreach (Configuration con in pkg.Configurations)
            {
                if (con.Name == "PackageSpecificConfigurations")
                {
                    pkg.Configurations["PackageSpecificConfigurations"].ConfigurationString = "\"Metadata\";\"[dbo].[Configurations]\";\"" + strParentPackageName + "Configurations\";";
                }
                else if (con.Name == "CommonConfigurations")
                {
                    pkg.Configurations["CommonConfigurations"].ConfigurationString = "\"Metadata\";\"[dbo].[Configurations]\";\"" + "CommonConfigurations\";";
                }
            }

            if (Global.GetAppParamValue("ReCreateConfigurationValues").ToString().ToLower() != "true")
            {
                return;
            }

            commandText = "metadata.p_InsertConfigurationValues";

            SqlDataReader reader = null;
            SqlParameter[] parameters = new SqlParameter[4];

            foreach (ConnectionManager Conn in pkg.Connections)
            {
                if (Conn.Name != Global.GetAppParamValue("MetadataConnection")
                    && Conn.Name != Global.GetAppParamValue("AuditConnection")
                    && Conn.Name != Global.GetAppParamValue("ConnectionETLExtract")
                    && Conn.Name != Global.GetAppParamValue("ConnectionETLExtractHistory")
                    && Conn.Name != Global.GetAppParamValue("ConnectionETLTransform")
                    && Conn.Name != Global.GetAppParamValue("MasterNonLeafExtractConnectionName")
                    && Conn.Name != Global.GetAppParamValue("MasterNonLeafTransformConnectionName"))
                {

                    parameters[0] = new SqlParameter("@ConfigurationFilter", System.Data.SqlDbType.NVarChar);
                    parameters[0].Value = strParentPackageName + "Configurations";

                    parameters[1] = new SqlParameter("@ConfiguredValue", System.Data.SqlDbType.NVarChar);
                    string strConn = Conn.ConnectionString.Replace("Data Source=", "");
                    parameters[1].Value = strConn.Substring(0, strConn.IndexOf(";"));

                    parameters[2] = new SqlParameter("@PackagePath", System.Data.SqlDbType.NVarChar);
                    parameters[2].Value = @"\Package.Connections[" + Conn.Name + @"].Properties[ServerName]";

                    parameters[3] = new SqlParameter("@ConfiguredValueType", System.Data.SqlDbType.NVarChar);
                    parameters[3].Value = "String";

                    reader = SqlHelper.ExecuteReader(Global.MetadataConnString, CommandType.StoredProcedure, commandText, parameters);

                    reader = null;
                }
                else if (Conn.Name == Global.GetAppParamValue("MetadataConnection")
                    || Conn.Name == Global.GetAppParamValue("AuditConnection")
                    || Conn.Name == Global.GetAppParamValue("ConnectionETLExtract")
                    || Conn.Name == Global.GetAppParamValue("ConnectionETLExtractHistory")
                    || Conn.Name == Global.GetAppParamValue("ConnectionETLTransform")
                    || Conn.Name == Global.GetAppParamValue("MasterNonLeafExtractConnectionName")
                    || Conn.Name == Global.GetAppParamValue("MasterNonLeafTransformConnectionName"))
                {
                    parameters[0] = new SqlParameter("@ConfigurationFilter", System.Data.SqlDbType.NVarChar);
                    parameters[0].Value = "CommonConfigurations";

                    parameters[1] = new SqlParameter("@ConfiguredValue", System.Data.SqlDbType.NVarChar);
                    string strConn = Conn.ConnectionString.Replace("Data Source=", "");
                    parameters[1].Value = strConn.Substring(0, strConn.IndexOf(";"));

                    parameters[2] = new SqlParameter("@PackagePath", System.Data.SqlDbType.NVarChar);
                    parameters[2].Value = @"\Package.Connections[" + Conn.Name + @"].Properties[ServerName]";

                    parameters[3] = new SqlParameter("@ConfiguredValueType", System.Data.SqlDbType.NVarChar);
                    parameters[3].Value = "String";

                    reader = SqlHelper.ExecuteReader(Global.MetadataConnString, CommandType.StoredProcedure, commandText, parameters);

                }
            }

            parameters[0] = new SqlParameter("@ConfigurationFilter", System.Data.SqlDbType.NVarChar);
            parameters[0].Value = strParentPackageName + "Configurations";

            parameters[1] = new SqlParameter("@ConfiguredValue", System.Data.SqlDbType.NVarChar);
            parameters[1].Value = @"c:\" + strParentPackageName + "Checkpoint.txt";

            parameters[2] = new SqlParameter("@PackagePath", System.Data.SqlDbType.NVarChar);
            parameters[2].Value = @"\Package.Properties[CheckpointFileName]";

            parameters[3] = new SqlParameter("@ConfiguredValueType", System.Data.SqlDbType.NVarChar);
            parameters[3].Value = "String";

            reader = SqlHelper.ExecuteReader(Global.MetadataConnString, CommandType.StoredProcedure, commandText, parameters);


        }

        public bool ModifySQLTask(GenerateDTS.AppStructs.GenerateObjectStruct objStruct)
        {
            try
            {
                string resStrTransform = Global.GetAppParamValue("DTSTransform.SQLTask.TransformSqlTask");
                string resStrValidation = Global.GetAppParamValue("DTSTransform.SQLTask.TransformValidationTask");

                string[,] Pat_Sub = new string[2, 2];
                SqlTask objSqlTask = new SqlTask();

                Pat_Sub[0, 0] = "[TransformProcedure]";
                Pat_Sub[0, 1] = "p_Transform" + objStruct.HistorydestinationObjectName;
                objSqlTask.PopulateTask(resStrTransform, pkg, Pat_Sub);

                Pat_Sub[0, 0] = "[ValidationProcedure]";
                Pat_Sub[0, 1] = "p_Validate" + objStruct.HistorydestinationObjectName;
                objSqlTask.PopulateTask(resStrValidation, pkg, Pat_Sub);

                return true;

            }
            catch (Exception)
            {
                Console.WriteLine("Failed to modify the SqlTask for Package: " + objStruct.packageName);
                return false;
            }
        }

    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\xereports\GenerateSSIS\IPackage.cs ===
using GenerateDTS;
using GenerateDTS.Common;
using System.Collections;

public interface IPackage
{
    bool LoadPackage (string TemplatePkgName);
    bool ModifyConnections(AppStructs.GenerateObjectStruct objPkgDetails, GenerateDTS.Common.ConnectionType ConType);
    bool ModifyPackage (AppStructs.GenerateObjectStruct objPkgDetails);
    bool ModifyErrorHandler(GenerateDTS.AppStructs.GenerateObjectStruct objStruct);
    bool SavePackage (string PackageName);
    bool Build(ArrayList objStructList);
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\xereports\GenerateSSIS\DTSMasterPackage.cs ===
using System;
using System.Collections.Generic;
using System.Text;
using System.Collections;
using System.Data;
using System.Data.SqlClient;
using Microsoft.ApplicationBlocks.Data;
using GenerateDTS.Common;
using Microsoft.SqlServer.Dts.Pipeline.Wrapper;
using dtr = Microsoft.SqlServer.Dts.Runtime.Wrapper;
using Microsoft.SqlServer.Dts.Runtime;
using Microsoft.SqlServer.Dts.Tasks.ExecuteSQLTask;
using Microsoft.SqlServer.Dts.Tasks.ExecutePackageTask;


namespace GenerateDTS
{
    /// <summary>
    /// Summary description for DTSMasterPackage.
    /// </summary>
    public class DTSMasterPackage
    {
        string masterETLPackageName = string.Empty;
        Application app;

        public DTSMasterPackage()
        {
            //masterETLPackageName = Global.GetAppParamValue("MasterETLPackageName");
            app = new Application();
        }

        public bool buildMaster()
        {

            bool execStatus = true;
            // first try to get the master package name
            string commandText = "metadata.p_GetParentPackage";
            SqlDataReader reader = null;

            SqlParameter[] Params = new SqlParameter[1];

            Params[0] = new SqlParameter("@ReturnVariableInfo", System.Data.SqlDbType.Bit);
            Params[0].Value = true;

            try
            {
                reader = SqlHelper.ExecuteReader(Global.MetadataConnString, CommandType.StoredProcedure, commandText, Params);
            }
            catch (Exception ex)
            {
                Console.WriteLine(ex.Message);
                throw ex;
            }

            if (!reader.HasRows)
            {
                Console.WriteLine("Master package name is not found");
                reader.Close();
                execStatus = false;
            }


            if (execStatus != false)
            {
                while (reader.Read())
                {
                    AppStructs.PackageInformation masterPkgInfo = new AppStructs.PackageInformation();

                    masterPkgInfo.name = reader.GetString(0);
                    masterPkgInfo.fileName = reader.GetString(0);
                    masterPkgInfo.id = reader.GetInt32(1);

                    Package pkg = traversePackageStructure(masterPkgInfo);

                    if (pkg == null) continue;
                    pkg.Variables[reader.GetString(reader.GetOrdinal("VariableName"))].Value = reader.GetString(reader.GetOrdinal("VariableValue"));
                    savePackage(pkg, masterPkgInfo.name);
                }

                reader.Close();
                execStatus = true;

            }
            return execStatus;
        }

        private ArrayList getPackageChild(AppStructs.PackageInformation parentPkgInfo)
        {
            string commandText = "metadata.p_GetChildPackages";
            ArrayList childPkgInfoList = null;
            SqlDataReader reader = null;

            try
            {
                SqlParameter[] parameters = new SqlParameter[1];
                parameters[0] = new SqlParameter("@PackageName", System.Data.SqlDbType.NVarChar);
                parameters[0].Value = parentPkgInfo.name;
                reader = SqlHelper.ExecuteReader(Global.MetadataConnString, CommandType.StoredProcedure, commandText, parameters);
            }
            catch (Exception ex)
            {
                Console.WriteLine(ex.Message);
                throw ex;
            }

            childPkgInfoList = new ArrayList();

            if (!reader.HasRows)
            {
                reader.Close();
                return childPkgInfoList;
            }


            while (reader.Read())
            {
                AppStructs.PackageInformation childPkgInfo = new AppStructs.PackageInformation();
                childPkgInfo.id = reader.GetInt32(0);
                childPkgInfo.name = reader.GetString(1);
                childPkgInfo.PackageType = reader.GetString(2);
                //childPkgInfo.fileName = reader.GetString(1);
                //childPkgInfo.prevPrecPkgID = reader.GetInt32(2);,
                childPkgInfoList.Add(childPkgInfo);
            }
            reader.Close();

            return childPkgInfoList;
        }

        private Package traversePackageStructure(AppStructs.PackageInformation pkgInfo)
        {
            // check if package should have children
            ArrayList childPkgInfoList = getPackageChild(pkgInfo);

            if (childPkgInfoList.Count == 0)
            {
                // if reaching the leaf, return
                return null;
            }

            // aray list for child package
            ArrayList modChildPkgInfoList = new ArrayList();

            // create package object for the ones that has children
            Package pkg = loadPackage(pkgInfo);
            if (pkg == null)
            {
                return null;
            }

            IEnumerator connEnumerator = pkg.Connections.GetEnumerator();
            //string sDataSource = Global.GetAppParamValue("MetadataServer");
            //string sCatalog = Global.GetAppParamValue("MetadataCatalog");
            string resStrMasterExtractNonLeafConn = Global.GetAppParamValue("MasterNonLeafExtractConnectionName");
            string resStrMasterTransformNonLeafConn = Global.GetAppParamValue("MasterNonLeafTransformConnectionName");


            foreach (ConnectionManager conn in pkg.Connections)
            {
                if (conn.Name == resStrMasterExtractNonLeafConn)
                {
                    pkg.Connections[resStrMasterExtractNonLeafConn].ConnectionString = pkg.Connections[resStrMasterExtractNonLeafConn].ConnectionString.Replace("[ServerName]", Global.GetAppParamValue("ExtractPackageConn"));
                }
                else if (conn.Name == resStrMasterTransformNonLeafConn)
                {
                    pkg.Connections[resStrMasterTransformNonLeafConn].ConnectionString = pkg.Connections[resStrMasterTransformNonLeafConn].ConnectionString.Replace("[ServerName]", Global.GetAppParamValue("TransformPackageConn"));
                }
            }

            IEnumerator childListEnum = childPkgInfoList.GetEnumerator();

            // store child package info
            while (childListEnum.MoveNext())
            {
                traversePackageStructure((AppStructs.PackageInformation)childListEnum.Current);

                // now start processing each node
                AppStructs.PackageInformation currentPkgInfo = (AppStructs.PackageInformation)childListEnum.Current;

                if (pkgInfo.name != masterETLPackageName)
                {
                    // add the package
                    if (!addChildPackage(pkg, ref currentPkgInfo))
                    {
                        return pkg;
                    }

                    modChildPkgInfoList.Add(currentPkgInfo);
                }

            }

            pkg.Name = pkgInfo.name;

            if (Global.GetAppParamValue("ReCreateConfigurationValues").ToString().ToLower() == "true")
            {
                ReCreateConfigurationValues(pkg);
            }
            foreach (Configuration con in pkg.Configurations)
            {
                if (con.Name == "PackageSpecificConfigurations")
                {
                    pkg.Configurations["PackageSpecificConfigurations"].ConfigurationString = "\"Metadata\";\"[dbo].[Configurations]\";\"" + pkg.Name + "Configurations\";";
                }
                else if (con.Name == "CommonConfigurations")
                {
                    pkg.Configurations["CommonConfigurations"].ConfigurationString = "\"Metadata\";\"[dbo].[Configurations]\";\"CommonConfigurations\";";
                }
            }

            // now iterate the package to create precedence
            if (createChildPackagePrecedence(pkg, modChildPkgInfoList))
            {
                //                    savePackage(pkg, pkgInfo.name);
            }

            return pkg;

        }

        public void ReCreateConfigurationValues(Package pkg)
        {
            // Set the configuration settings

            string commandText = "metadata.p_InsertConfigurationValues";

            SqlDataReader reader = null;
            SqlParameter[] parameters = new SqlParameter[4];
            foreach (ConnectionManager Conn in pkg.Connections)
            {


                if (Conn.Name != Global.GetAppParamValue("MetadataConnection")
                    && Conn.Name != Global.GetAppParamValue("AuditConnection")
                    && Conn.Name != Global.GetAppParamValue("ConnectionETLExtract")
                    && Conn.Name != Global.GetAppParamValue("ConnectionETLExtractHistory")
                    && Conn.Name != Global.GetAppParamValue("ConnectionETLTransform")
                    && Conn.Name != Global.GetAppParamValue("MasterNonLeafExtractConnectionName")
                    && Conn.Name != Global.GetAppParamValue("MasterNonLeafTransformConnectionName"))
                {
                    parameters[0] = new SqlParameter("@ConfigurationFilter", System.Data.SqlDbType.NVarChar);
                    parameters[0].Value = pkg.Name + "Configurations";

                    parameters[1] = new SqlParameter("@ConfiguredValue", System.Data.SqlDbType.NVarChar);
                    string strConn = Conn.ConnectionString.Replace("Data Source=", "");
                    parameters[1].Value = strConn.Substring(0, strConn.IndexOf(";"));

                    parameters[2] = new SqlParameter("@PackagePath", System.Data.SqlDbType.NVarChar);
                    parameters[2].Value = @"\Package.Connections[" + Conn.Name + @"].Properties[ServerName]";

                    parameters[3] = new SqlParameter("@ConfiguredValueType", System.Data.SqlDbType.NVarChar);
                    parameters[3].Value = "String";

                    reader = SqlHelper.ExecuteReader(Global.MetadataConnString, CommandType.StoredProcedure, commandText, parameters);

                    reader = null;
                }
                else if (Conn.Name == Global.GetAppParamValue("MetadataConnection")
                    || Conn.Name == Global.GetAppParamValue("AuditConnection")
                    || Conn.Name == Global.GetAppParamValue("ConnectionETLExtract")
                    || Conn.Name == Global.GetAppParamValue("ConnectionETLExtractHistory")
                    || Conn.Name == Global.GetAppParamValue("ConnectionETLTransform")
                    || Conn.Name == Global.GetAppParamValue("MasterNonLeafExtractConnectionName")
                    || Conn.Name == Global.GetAppParamValue("MasterNonLeafTransformConnectionName"))
                {
                    parameters[0] = new SqlParameter("@ConfigurationFilter", System.Data.SqlDbType.NVarChar);
                    parameters[0].Value = "CommonConfigurations";

                    parameters[1] = new SqlParameter("@ConfiguredValue", System.Data.SqlDbType.NVarChar);
                    string strConn = Conn.ConnectionString.Replace("Data Source=", "");
                    parameters[1].Value = strConn.Substring(0, strConn.IndexOf(";"));

                    parameters[2] = new SqlParameter("@PackagePath", System.Data.SqlDbType.NVarChar);
                    parameters[2].Value = @"\Package.Connections[" + Conn.Name + @"].Properties[ServerName]";

                    parameters[3] = new SqlParameter("@ConfiguredValueType", System.Data.SqlDbType.NVarChar);
                    parameters[3].Value = "String";

                    reader = SqlHelper.ExecuteReader(Global.MetadataConnString, CommandType.StoredProcedure, commandText, parameters);

                }
            }

            parameters[0] = new SqlParameter("@ConfigurationFilter", System.Data.SqlDbType.NVarChar);
            parameters[0].Value = pkg.Name + "Configurations";

            parameters[1] = new SqlParameter("@ConfiguredValue", System.Data.SqlDbType.NVarChar);
            parameters[1].Value = @"c:\" + pkg.Name + "Checkpoint.txt";

            parameters[2] = new SqlParameter("@PackagePath", System.Data.SqlDbType.NVarChar);
            parameters[2].Value = @"\Package.Properties[CheckpointFileName]";

            parameters[3] = new SqlParameter("@ConfiguredValueType", System.Data.SqlDbType.NVarChar);
            parameters[3].Value = "String";

            reader = SqlHelper.ExecuteReader(Global.MetadataConnString, CommandType.StoredProcedure, commandText, parameters);


        }


        public Package loadPackage(AppStructs.PackageInformation pkgInfo)
        {
            string strFilePath = String.Empty;
            string TemplatePkgName = String.Empty;
            Package pkg = null;
            try
            {
                if (pkgInfo.name == masterETLPackageName)
                {
                    TemplatePkgName = Global.GetAppParamValue("ETLMasterTemplatePackageName");
                }
                else
                {
                    TemplatePkgName = Global.GetAppParamValue("MasterTemplateNonLeafPackageName");
                }

                strFilePath = Global.GetAppParamValue("TemplatePackageFilePath").Trim();

                if (strFilePath.EndsWith(@"\") == true)
                    strFilePath += TemplatePkgName; //+ @".dtsx";
                else
                    strFilePath += @"\" + TemplatePkgName; // +@".dtsx";

                pkg = app.LoadPackage(strFilePath, null);
            }
            catch (Exception ex)
            {
                Console.WriteLine("Error when loading " + strFilePath);
                Console.WriteLine(ex.Message);

            }
            return pkg;
        }

        private bool addChildPackage(Package pkg, ref  AppStructs.PackageInformation pkgInfo)
        {
            try
            {
                string resStrMasterExtractNonLeafConn = Global.GetAppParamValue("MasterNonLeafExtractConnectionName");
                string resStrMasterTransformNonLeafConn = Global.GetAppParamValue("MasterNonLeafTransformConnectionName");


                TaskHost execPkghost = (TaskHost)pkg.Executables.Add("STOCK:ExecutePackageTask");
                execPkghost.FailPackageOnFailure = true;

                IDTSExecutePackage90 task = (IDTSExecutePackage90)execPkghost.InnerObject;
                execPkghost.Name = "Execute " + pkgInfo.name + " Task";

                    if (pkgInfo.PackageType == "Extract")
                        task.Connection = resStrMasterExtractNonLeafConn;//pkg.Connections[0].Name;
                    else if(pkgInfo.PackageType == "Transform")
                        task.Connection = resStrMasterTransformNonLeafConn;

                task.ExecuteOutOfProcess = true;
                task.PackageID = pkgInfo.id.ToString();
                task.PackageName = @"\/" + pkgInfo.name;
            }
            catch (Exception ex)
            {
                Console.WriteLine("Fail when adding package for package id: " + pkgInfo.id);
                Console.WriteLine(ex.Message);
                return false;
            }

            return true;
        }

        private bool createChildPackagePrecedence(Package pkg, ArrayList childPkgInfoList)
        {
            bool precedenceStatus = true;
            IEnumerator listEnumerator = childPkgInfoList.GetEnumerator();
            ExecutableEnumerator exe = pkg.Executables.GetEnumerator();

            while (listEnumerator.MoveNext())
            {
                GenerateDTS.AppStructs.PackageInformation pkgInfo = (GenerateDTS.AppStructs.PackageInformation)listEnumerator.Current;
                if (pkgInfo.PackageType == "Extract")
                {
                    PrecedenceConstraint pcTransformTask1 = pkg.PrecedenceConstraints.Add(pkg.Executables["Audit - Start Package"], pkg.Executables["Execute " + pkgInfo.name + " Task"]);
                    PrecedenceConstraint pcTransformTask2 = pkg.PrecedenceConstraints.Add(pkg.Executables["Execute " + pkgInfo.name + " Task"], pkg.Executables["Check Transform Dependencies"]);

                    pcTransformTask1.EvalOp = DTSPrecedenceEvalOp.Constraint;
                    pcTransformTask1.Value = DTSExecResult.Success;
                    pcTransformTask2.EvalOp = DTSPrecedenceEvalOp.Constraint;
                    pcTransformTask2.Value = DTSExecResult.Success;

                }
                else if (pkgInfo.PackageType == "Transform")
                {
                    PrecedenceConstraint pcTransformTask1 = pkg.PrecedenceConstraints.Add(pkg.Executables["Check Transform Dependencies"], pkg.Executables["Execute " + pkgInfo.name + " Task"]);
                    PrecedenceConstraint pcTransformTask2 = pkg.PrecedenceConstraints.Add(pkg.Executables["Execute " + pkgInfo.name + " Task"], pkg.Executables["Audit Complete after Transform"]);

                    pcTransformTask1.EvalOp = DTSPrecedenceEvalOp.Expression;
                    pcTransformTask1.Expression = "@g_ProceedWithTransform==1";
                    pcTransformTask2.EvalOp = DTSPrecedenceEvalOp.Constraint;
                    pcTransformTask2.Value = DTSExecResult.Success;
                }

                //pkg.PrecedenceConstraints.Add(pkg.Executables["Audit - Start Package"], pkgInfo.name);

                /*if (pkgInfo.prevPrecPkgID > 0)
                {
                    bool precedenceFound = false;
                    IEnumerator searchEnumerator = childPkgInfoList.GetEnumerator();
                    while (searchEnumerator.MoveNext())
                    {
                        AppStructs.PackageInformation searchPkgInfo = (AppStructs.PackageInformation)searchEnumerator.Current;
                        if (searchPkgInfo.id == pkgInfo.prevPrecPkgID)
                        {
                            precedenceFound = true;
                            string nextTaskName = "Execute " + pkgInfo.name + " Task";
                            string prevTaskName = "Execute " + searchPkgInfo.name + " Task";
                            pkg.PrecedenceConstraints.Add(pkg.Executables[prevTaskName], pkg.Executables[nextTaskName]);
                        }
                    }
                    if (!precedenceFound)
                    {
                        Console.WriteLine("Error when creating predence for package: " + pkgInfo.name);
                        Console.WriteLine("Precedence package not found with ID " + pkgInfo.prevPrecPkgID);
                        precedenceStatus = false;
                        break;

                    }
                }*/

            }

            return precedenceStatus;
        }

        private bool savePackage(Package pkg, string packageName)
        {
            string newDTSFileDir = Global.GetAppParamValue("NewDTSPackageFileDir");
            try
            {
                if (Global.GetAppParamValue("DeployToFile").ToLower() == "true")
                {
                    app.SaveToXml(newDTSFileDir + packageName + ".dtsx", pkg, null);
                }
                app.SaveToSqlServer(pkg, null, Global.GetAppParamValue("DTSDeployTargetServer"), "", "");
                Console.WriteLine("Generated package: " + packageName + ".dtsx");
            }
            catch (Exception ex)
            {
                Console.WriteLine(ex.Message);
                return false;
            }

            return true;
        }


    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\xereports\GenerateSSIS\GenerateMgr.cs ===
#region Using directives

using System;
using System.Collections.Generic;
using System.Text;
using System.Collections;
using GenerateDTS.Common;
using System.Data;
using System.Data.SqlClient;
using Microsoft.ApplicationBlocks.Data;

#endregion

namespace GenerateDTS
{
    public class GenerateMgr
    {
        public GenerateMgr()
        { }

        /// <summary>
        /// Delegates the responsibility of Leaf Package Generation
        /// </summary>
        /// <param name="">None</param>
        /// <returns>Success Or Failure </returns>
        public bool generateLeafPackage()
        {
            try
            {
                bool runStatus = true;
                IPackage pkg = null;
                ArrayList pkgNameList = new ArrayList();
                ArrayList tempList = new ArrayList();

                pkgNameList = getPackageNamesToModify(Global.GetAppParamValue("ETLExtract"));

                tempList= getPackageNamesToModify(Global.GetAppParamValue("ETLTransform"));


                try
                {
                    if (pkgNameList == null) pkgNameList = new ArrayList();
                    if (tempList != null)
                    pkgNameList.AddRange(tempList);

                }
                catch (Exception)
                {}

                IEnumerator listEnum = pkgNameList.GetEnumerator();

                if (pkgNameList == null)
                {
                    Console.WriteLine("No leaf package names exists");
                    return false;
                }
                while (listEnum.MoveNext())
                {
                    string pkgName = string.Empty;

                    if (Global.GetAppParamValue("SinglePackage") != string.Empty)
                    {
                        pkgName = Global.GetAppParamValue("SinglePackage");
                        if (pkgName.ToLower()  == ((string)listEnum.Current).ToLower() )
                        {
                            ArrayList objStructList = getPackageDetailObject(pkgName);

                            if (objStructList == null)
                            {
                                continue;
                            }
                            AppStructs.GenerateObjectStruct objStruct = (AppStructs.GenerateObjectStruct)objStructList[0];
                            Type type = Type.GetType(Global.GetAppParamValue(objStruct.TemplateName));
                            pkg = (IPackage)Activator.CreateInstance(type);
                            pkg.Build(objStructList);
                            break;
                        }
                    }
                    else
                    {
                        pkgName = (string)listEnum.Current;
                        ArrayList objStructList = getPackageDetailObject(pkgName);
                        if (objStructList == null)
                        {
                            continue;
                        }
                        AppStructs.GenerateObjectStruct objStruct = (AppStructs.GenerateObjectStruct)objStructList[0];
                        Type type = Type.GetType(Global.GetAppParamValue(objStruct.TemplateName));
                        pkg = (IPackage)Activator.CreateInstance(type);
                        pkg.Build(objStructList);
                    }

                }
                return runStatus;
            }
            catch (Exception ex)
            {
                Console.WriteLine("Error in generation of leaf package. ErrorMsg =" + ex.Message);
                return false;
            }
         }

        private ArrayList getPackageNamesToModify(string processName)
        {
            string commandText = "metadata.p_GetLeafPackagesByProcess";
            SqlDataReader reader = null;
            ArrayList pkgNameList = null;


            try
            {
                SqlParameter[] parameters = new SqlParameter[1];
                parameters[0] = new SqlParameter("@ProcessName", System.Data.SqlDbType.NVarChar);
                parameters[0].Value = processName;
                reader = SqlHelper.ExecuteReader(Global.MetadataConnString, CommandType.StoredProcedure, commandText, parameters);
            }
            catch (Exception ex)
            {
                Console.WriteLine(ex.Message);
                throw;
            }

            if (!reader.HasRows)
            {
                Console.WriteLine(processName + " does not have packages to process");
                reader.Close();
                return null;
            }

            pkgNameList = new ArrayList();
            while (reader.Read())
            {
                pkgNameList.Add(reader.GetString(0));
            }
            reader.Close();
            reader = null;
            return pkgNameList;
        }

        private ArrayList getPackageDetailObject(string pkgName)
        {
            string commandText = "metadata.p_GetPackageObject";
            SqlDataReader reader = null;
            ArrayList generateObjList = null;

            try
            {
                SqlParameter[] parameters = new SqlParameter[1];
                parameters[0] = new SqlParameter("@PackageName", System.Data.SqlDbType.NVarChar);
                parameters[0].Value = pkgName;
                reader = SqlHelper.ExecuteReader(Global.MetadataConnString, CommandType.StoredProcedure, commandText, parameters);
            }
            catch (Exception ex)
            {
                Console.WriteLine(ex.Message);
                throw;
            }


            if (reader == null)
            {
                Console.WriteLine("Package " + pkgName + " does not have package object");
                if (reader != null)
                {
                    reader.Close();
                }
                return null;
            }
            else if (!reader.HasRows)
            {
                Console.WriteLine("Package " + pkgName + " does not have package object");
                if (reader != null)
                {
                    reader.Close();
                }
                return null;
            }


            generateObjList = new ArrayList();
            AppStructs.GenerateObjectStruct objStruct = new AppStructs.GenerateObjectStruct();
            while (reader.Read())
            {
                if (reader.GetString(10) == Global.GetAppParamValue("ConnectionETLExtract"))
                {
                    objStruct.WorkdestObjectID = reader.GetInt32(3);
                    objStruct.WorkdestinationObjectName = reader.GetString(4).Replace("Extract","Work");
                    objStruct.DeltaDestinationObjectName = reader.GetString(4);
                    objStruct.destCriterionColName = reader.GetString(6);
                    objStruct.DestinationObjectTypeId = reader.GetInt32(12);
                }
                else
                {
                    objStruct.packageName = pkgName;
                    objStruct.sourceObjectID = reader.GetInt32(0);
                    objStruct.sourceObjectName = reader.GetString(1);
                    objStruct.sourceObjectTypeName = reader.GetString(2);
                    objStruct.HistorydestObjectID = reader.GetInt32(3);
                    objStruct.HistorydestinationObjectName = reader.GetString(4);
                    objStruct.srcSearchArgColName = reader.GetString(5);
                    objStruct.isSourceIncremental = reader.GetBoolean(7);
                    objStruct.DatabaseName = @"metadata";
                    objStruct.TemplateName = reader.GetString(8);
                    if (reader.GetValue(9).GetType() != Type.GetType("System.DBNull"))
                        objStruct.SqlQuery = reader.GetString(9);
                    objStruct.DestinationConnectionName = reader.GetString(10);
                    objStruct.SourceConnectionName = reader.GetString(11);
                    objStruct.DestinationObjectTypeId = reader.GetInt32(12);
                }
            }
            generateObjList.Add(objStruct);
            reader.Close();
            reader = null;
            return generateObjList;

        }
        public bool generateMasterPackage()
        {
            DTSMasterPackage package = new DTSMasterPackage();
            return package.buildMaster();
        }

    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\xereports\ManualData\makefile.inc ===
!include $(INETROOT)\build\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\xereports\GenerateSSIS\makefile.inc ===
!include $(INETROOT)\build\makefile.inc

CopyFiles : makefile.inc
    -md %_NT386TREE%\tools\xereports
    -robocopy $(XONEXTPATH)\Reporting %_NT386TREE%\tools\xereports\GenerateSSIS GotDotNet.ApplicationBlocks.Data.dll Microsoft.ApplicationBlocks.Data.dll Microsoft.SqlServer.DTSPipelineWrap.dll Microsoft.SQLServer.DTSRuntimeWrap.dll Microsoft.SqlServer.ExecPackageTaskWrap.dll Microsoft.SqlServer.ExecProcTask.dll Microsoft.SQLServer.ManagedDTS.dll /R:0 /NP /NJH /NJS /A-:R
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\xereports\DTS\ReportingDTS\core\ReportDTS.cs ===
using Microsoft.SQLServer.DTSPkg80;
using Microsoft.SQLServer.DTSPkg80.CustTask;
using System;
using System.Collections;
using System.Data;
using System.Data.SqlClient;
using System.IO;
using System.Net;
using System.Reflection;
using System.Text;
using System.Text.RegularExpressions;
using System.Xml;
using System.Xml.Schema;
using xonline.common.config;

namespace xonline.tools.reporting.dts.core
{
    class InterfaceInfoWithServername
    {
        private string _serverName = null;
        private IInterfaceInfo _interfaceInfo = null;

        public string ServerName
        {
            get { return _serverName; }
            set { _serverName = value; }
        }

        public IInterfaceInfo InterfaceInfo
        {
            get { return _interfaceInfo; }
            set { _interfaceInfo = value; }
        }
    }

    class PackageDTS
    {
        private Package2 _packageDTS = new Package2Class( );
        private ArrayList _rgConnections = new ArrayList( );
        private ArrayList _rgTransformSteps = new ArrayList( );
        private int _iConnID = 1;

        public ReplicationRoleType ReplicationRole = ReplicationRoleType.Primary;
        public string SourceServerName = null;
        public string TargetServerName = null;
        public string SourceDatabaseName = null;

        //
        // This string is how we query the database to retrieve column information for a table
        //
        private const string _strSchemaQuery = "SELECT column_name, is_nullable, data_type, character_maximum_length, numeric_precision, numeric_scale FROM INFORMATION_SCHEMA.COLUMNS WHERE TABLE_NAME = '{0}'";

        //
        // This regex allows us to parse the following table references:
        //      [owner].[table]
        // where the square brackets are optional, and owner is optional
        //
        private static Regex _regOwnerAndTable = new Regex( "(\\[?(?<owner>\\w*)\\]?\\.)?\\[?(?<table>\\w*)\\]?", RegexOptions.IgnoreCase | RegexOptions.ECMAScript | RegexOptions.Compiled );

        //
        // This is how our datatypes map out
        //
        private class DBType
        {
            public DBType( string szT, int iD, int iF, bool fSize, bool fPrec, bool fScale )
            {
                szType = szT;
                iDataType = iD;
                iFlags = iF;
                fLookupSize = fSize;
                fLookupPrecision = fPrec;
                fLookupScale = fScale;
            }

            public string szType;
            public int iDataType;
            public int iFlags;
            public bool fLookupSize;
            public bool fLookupPrecision;
            public bool fLookupScale;
        }
        
        private static DBType[] _rgDBTypes =
        {
            new DBType( "smallint", 2, 24, false, false, false ),
            new DBType( "int", 3, 24, false, false, false ),
            new DBType( "real", 4, 24, false, false, false ),
            new DBType( "float", 5, 24, false, false, false ),
            new DBType( "money", 6, 24, false, false, false ),
            new DBType( "smallmoney", 6, 24, false, false, false ),
            new DBType( "bit", 11, 24, false, false, false ),
            new DBType( "sql_variant", 12, 24, false, false, false ),
            new DBType( "tinyint", 17, 24, false, false, false ),
            new DBType( "bigint", 20, 24, false, false, false ),
            new DBType( "uniqueidentifier", 72, 24, false, false, false ),
            new DBType( "binary", 128, 8, true, false, false ),
            new DBType( "image", 128, 136, false, false, false ),
            new DBType( "timestamp", 128, 528, false, false, false ),
            new DBType( "varbinary", 128, 8, true, false, false ),
            new DBType( "char", 129, 24, true, false, false ),
            new DBType( "text", 129, 136, false, false, false ),
            new DBType( "varchar", 129, 8, true, false, false ),
            new DBType( "nchar", 130, 24, true, false, false ),
            new DBType( "ntext", 130, 136, false, false, false ),
            new DBType( "nvarchar", 130, 8, true, false, false ),
            new DBType( "decimal", 131, 24, false, true, true ),
            new DBType( "numeric", 131, 24, false, true, true ),
            new DBType( "datetime", 135, 24, false, false, false ),
            new DBType( "smalldatetime", 135, 24, false, false, false )
        };
        

        private enum Destination
        {
            SourceDestination = 1,
            TargetDestination = 2
        }

        public enum ReplicationRoleType
        {
            Primary = 0,
            Replica = 1
        }
        
        //
        // These are the valid attributes for the Job node, along with defaults
        //
        private static string[,] _rgJobAttributes = 
            {
                { "Name", "Agent Job" },
                { "Category", "[Uncategorized (Local)]" },
                { "DeleteLevel", "None" },
                { "Description", "No description available." },
                { "EmailLevel", "None" },
                { "OperatorToEmail", "(unknown)" },
                { "Enabled", "true" },
                { "EventlogLevel", "Failure" },
                { "NetSendLevel", "None" },
                { "OperatorToNetSend", "(unknown)" },
                { "Owner", "sa" },
                { "PageLevel", "None" },
                { "OperatorToPage", "(unknown)" },
                { "StartStepID", "1" }
            };

        //
        // These are the valid attributes for a job step, along with defaults
        //
        private static string[,] _rgJobStepAttributes = 
            {
                { "Name", "DTS Package" },
                { "StepID", "1" },
                { "SubSystem", "CmdExec" },
                { "CmdExecSuccessCode", "0" },
                { "OnFailAction", "QuitWithFailure" },
                { "OnFailStep", "0" },
                { "OnSuccessAction", "QuitWithSuccess" },
                { "OnSuccessStep", "0" },
                { "OutputFileName", "" },
                { "RetryAttempts", "0" },
                { "RetryInterval", "1" },
                { "Server", "" }
            };

        //
        // These are the tokens that we can replace
        //
        private static string[,] _rgTokens = 
            {
                { "%%SOURCESERVERNAME%%", "SourceServerName" },
                { "%%TARGETSERVERNAME%%", "TargetServerName" },
                { "%%REPLICATIONROLE%%", "ReplicationRole" },
                { "%%SOURCEDATABASE%%", "SourceDatabaseName" }
            };

        //
        // Helper class for when we have to set up a manual transform from XML (specifying source and destination columns and types).
        //
        class ColumnAndType
        {
            public ColumnAndType( )
            {
                iSize = 0;
                iPrecision = 0;
                iNumericScale = 0;
            }
            
            public ColumnAndType( string szC, int iD, int iS, int iF, int iP, int iN, bool fNull )
            {
                szColumn = szC;
                iDataType = iD;
                iSize = iS;
                iFlags = iF;
                iPrecision = iP;
                iNumericScale = iN;
                fNullable = fNull;
            }
        
            public override bool Equals(object obj)
            {
                ColumnAndType cT = obj as ColumnAndType;
                if( null != cT )
                {
                    if( ( cT.szColumn.ToLower( ) == this.szColumn.ToLower( ) ) &&
                        ( cT.iDataType == this.iDataType ) &&
                        ( cT.iSize == this.iSize ) )
                    {
                        return true;
                    }
                }
                return false;
            }
        
            public override int GetHashCode()
            {
                return base.GetHashCode ();
            }
        
            public string szColumn;
            public int iDataType;
            public int iSize;
            public int iFlags;
            public int iPrecision;
            public int iNumericScale;
            public bool fNullable;
        };
        
        //
        // Helper class to keep track of all the connections we may have flying all over the place.
        //
        class DatabaseInfo
        {
            public string szDatabase;
            public string szDatabasePrefix;
            public string szInterface;
            public Destination destType;
            public int iConnID;
        
            public DatabaseInfo( )
            {
                szDatabase = string.Empty;
                szDatabasePrefix = string.Empty;
                szInterface = string.Empty;
                destType = Destination.SourceDestination;
                iConnID = 0;
            }
        }

        public void DeletePackage( XmlElement xDomElement, IInterfaceInfo iiHost )
        {
            //
            // Check our needed parameters, silently fail
            //
            if( null == SourceServerName || null == TargetServerName || null == SourceDatabaseName )
            {
                return;
            }
            
            //
            // Delete the package from the server
            //
            try
            {
                _packageDTS.RemoveFromSQLServer( iiHost.IPAddress.ToString( ),
                    null, null, DTSSQLServerStorageFlags.DTSSQLStgFlag_UseTrustedConnection, null, null,
                    _ReplaceTokens( xDomElement.SelectSingleNode( "Properties/@Name" ).InnerText ) );
            }
            catch {}
        }

        public void CreatePackage( XmlElement xDomElement, IInterfaceInfo iiSource, IInterfaceInfo iiTarget, IInterfaceInfo iiHost )
        {
            XmlNode xNode;
            object pVarPersistStgOfHost = null;

            //
            // Check our needed parameters
            //
            if( null == SourceServerName || null == TargetServerName || null == SourceDatabaseName )
            {
                throw new ArgumentNullException( "SourceServerName, TargetServerName, and SourceDatabaseName need to be defined." );
            }

            //
            // Set up the main package settings
            //
            xNode = xDomElement.SelectSingleNode( "Properties" );
            _PackageSettings( xNode, iiHost );

            //
            // Create the connections - target first since we 
            // will only have one target, but possibly several sources
            //
            _CreateConnection( Destination.TargetDestination, iiTarget );
            _CreateConnection( Destination.SourceDestination, iiSource );

            //
            // Set up the dynamic properties which will initialize the package
            //
            xNode = xDomElement.SelectSingleNode( "DynamicProperties" );
            if( null != xNode )
            {
                _CreateDynamicProperties( xNode );
            }

            //
            // Create the step/task to execute any SQL before the transform
            //
            xNode = xDomElement.SelectSingleNode( "PreStep" );
            if( null != xNode )
            {
                _CreateSQLStepAndTask( xNode );
            }
        
            //
            // Create all the transformation tasks and steps
            //
            foreach( XmlNode xNodeT in xDomElement.SelectNodes( "Transforms/Transform" ) )
            {
                _CreateTransformStepAndTask( xNodeT, iiSource );
            }
        
            //
            // Create the step/task to execute any SQL before the transform
            //
            xNode = xDomElement.SelectSingleNode( "PostStep" );
            if( null != xNode )
            {
                _CreateSQLStepAndTask( xNode );
            }
        
            //
            // Create all of our precedence steps
            //

            //
            // If we have a prestep, we do:
            //      Dynamic Properties -> PreStep -> Transforms
            // otherwise, we do:
            //      Dynamic Properties -> Transforms
            // First, all transforms happen after the prestep succeeds
            xNode = xDomElement.SelectSingleNode( "PreStep" );
            XmlNode xNodeDynProp = xDomElement.SelectSingleNode( "DynamicProperties" );
            if( null != xNode )
            {
                Step2 step;
                step = ( Step2 ) _packageDTS.Steps.Item( xNode.Attributes.GetNamedItem( "Name" ).InnerText );

                //
                // Dynamic Properties -> Prestep
                //
                PrecedenceConstraint precConst;

                if( null != xNodeDynProp )
                {
                    precConst = step.PrecedenceConstraints.New( "Package Setup" );
                    precConst.StepName = "Package Setup";
                    precConst.PrecedenceBasis = DTSStepPrecedenceBasis.DTSStepPrecedenceBasis_ExecResult;
                    precConst.Value = 0;
                    step.PrecedenceConstraints.Add( precConst );
                }
                
                //
                // Prestep -> Transforms
                //
                foreach( Step2 stepT in _rgTransformSteps )
                {
                    precConst = stepT.PrecedenceConstraints.New( xNode.Attributes.GetNamedItem( "Name" ).InnerText );
                    precConst.StepName = xNode.Attributes.GetNamedItem( "Name" ).InnerText;
                    precConst.PrecedenceBasis = DTSStepPrecedenceBasis.DTSStepPrecedenceBasis_ExecResult;
                    precConst.Value = 0;
                    stepT.PrecedenceConstraints.Add( precConst );
                }
            }
            else if( null != xNodeDynProp )
            {
                //
                // Dynamic Properties -> Transforms
                //
                foreach( Step2 stepT in _rgTransformSteps )
                {
                    PrecedenceConstraint precConst;

                    precConst = stepT.PrecedenceConstraints.New( "Package Setup" );
                    precConst.StepName = "Package Setup";
                    precConst.PrecedenceBasis = DTSStepPrecedenceBasis.DTSStepPrecedenceBasis_ExecResult;
                    precConst.Value = 0;
                    stepT.PrecedenceConstraints.Add( precConst );
                }
            }
        
            // Second, post step happens after all transforms succeed
            xNode = xDomElement.SelectSingleNode( "PostStep" );
            if( null != xNode )
            {
                Step2 step;
                step = ( Step2 ) _packageDTS.Steps.Item( xNode.Attributes.GetNamedItem( "Name" ).InnerText );
        
                foreach( Step2 stepT in _rgTransformSteps )
                {
                    PrecedenceConstraint precConst;
                    precConst = step.PrecedenceConstraints.New( stepT.Name );
                    precConst.StepName = stepT.Name;
                    precConst.PrecedenceBasis = DTSStepPrecedenceBasis.DTSStepPrecedenceBasis_ExecResult;
                    precConst.Value = 0;
                    step.PrecedenceConstraints.Add( precConst );
                }
            }
        
            //
            // Finally, save the package to the server after removing any existing packages of the same name
            //
            try
            {
                _packageDTS.RemoveFromSQLServer( iiHost.IPAddress.ToString( ),
                    null, null, DTSSQLServerStorageFlags.DTSSQLStgFlag_UseTrustedConnection, null, null,
                    _packageDTS.Name );
            }
            catch {}

            _packageDTS.SaveToSQLServer( iiHost.IPAddress.ToString( ),
                null, null, DTSSQLServerStorageFlags.DTSSQLStgFlag_UseTrustedConnection, null, null,
                null, ref pVarPersistStgOfHost, true );

            //
            // Now, create the AgentAdmin XML file, if applicable, for adding a scheduled task.
            //
            xNode = xDomElement.SelectSingleNode( "ScheduledTask" );
            if( null != xNode )
            {
                _CreateSQLAgentJob( xNode, xDomElement.SelectSingleNode( "Properties/@Name" ).InnerText, iiSource, iiTarget );
            }
        }

        //
        // Set up the package properties:
        //      Log to NT events on completion
        //      Use a trusted connection
        //      Log steps to SQL
        //      Fail the package on unable to log to SQL
        //
        private void _PackageSettings( XmlNode xNode, IInterfaceInfo iiHost )
        {
            _packageDTS.Name = _ReplaceTokens( xNode.Attributes.GetNamedItem( "Name" ).InnerText );
            _packageDTS.WriteCompletionStatusToNTEventLog = true;
            _packageDTS.LogToSQLServer = true;
            _packageDTS.LogServerName = iiHost.IPAddress.ToString( );
            _packageDTS.LogServerFlags = DTSSQLServerStorageFlags.DTSSQLStgFlag_UseTrustedConnection;
            _packageDTS.FailPackageOnLogFailure = true;
            _packageDTS.FailOnError = true;
            _packageDTS.ExplicitGlobalVariables = false;
            _packageDTS.PackageType = DTSPackageType.DTSPkgType_Default;
            _packageDTS.PackagePriorityClass = DTSPackagePriorityClass.DTSPriorityClass_Normal;
            _packageDTS.MaxConcurrentSteps = 4;
        }

        private void _CreateConnection( Destination dst, IInterfaceInfo iiConnection )
        {
            Connection2 conn;
            DatabaseInfo dbInfo;
        
            dbInfo = new DatabaseInfo( );
            dbInfo.destType = dst;
            dbInfo.iConnID = _iConnID;
            dbInfo.szInterface = iiConnection.Interface.ToString( );
            if( Destination.SourceDestination == dst )
            {
                dbInfo.szDatabase = SourceDatabaseName;
            }
            else
            {
                dbInfo.szDatabase = iiConnection.DBName;
            }

            conn = ( Connection2 ) _packageDTS.Connections.New( "SQLOLEDB" );
            conn.Name = dbInfo.szDatabase;
            conn.ID = _iConnID++;
            conn.Reusable = true;
            conn.ConnectImmediate = true;
            conn.ConnectionTimeout = 60;
            conn.UseTrustedConnection = true;
            conn.UseDSL = false;
            conn.DataSource = iiConnection.IPAddress.ToString( );
            conn.Catalog = dbInfo.szDatabase;
    
            _packageDTS.Connections.Add( ( Connection ) conn );
                    
            //
            // We only need to add one instance of DatabaseInfo even when we have multiple 
            // databases associated because we can determine the connectionID of each member
            // database (which is all we really care about) - also, it makes it easy to determine
            // how to map from UODB -> UODB_01, UODB_02 etc.
            //
            _rgConnections.Add( dbInfo );
        }

        private void _CreateDynamicProperties( XmlNode xNode )
        {
            Step2 step;
            Task task;
            DynamicPropertiesTask taskDynProps;

            step = ( Step2 ) _packageDTS.Steps.New( );
            step.Name = "Package Setup";
            step.Description = "Dynamic properties to initialize the package";
            step.ExecutionStatus = DTSStepExecStatus.DTSStepExecStat_Completed;
            step.TaskName = "Package Setup";
            step.RollbackFailure = false;
            step.ScriptLanguage = "VBScript";
            step.AddGlobalVariables = false;
            step.CloseConnection = false;
            step.ExecuteInMainThread = false;
            step.IsPackageDSORowset = false;
            step.JoinTransactionIfPresent = false;
            step.DisableStep = false;
            step.FailPackageOnError = true;
            
            _packageDTS.Steps.Add( step );
            
            task = _packageDTS.Tasks.New( "DTSDynamicPropertiesTask" );
            task.Name = "Package Setup";
            taskDynProps = ( DynamicPropertiesTask ) task.CustomTask;
            taskDynProps.Name = "Package Setup";
            taskDynProps.Description = "Dynamic properties to initialize the package";

            if( null != xNode )
            {
                XmlNodeList xNList = xNode.SelectNodes( "DynamicProperty" );
                foreach( XmlNode xNT in xNList )
                {
                    DynamicPropertiesTaskAssignment taskAssign;
                    DynamicPropertiesTaskAssignments assigns;

                    DatabaseInfo dbInfo;
                    
                    dbInfo = _GetConnection( xNT.Attributes.GetNamedItem( "Interface" ).InnerText );

                    assigns = taskDynProps.Assignments( );
                    
                    taskAssign = assigns.New( );
                    taskAssign.SourceType = 1;
                    taskAssign.SourceQueryConnectionID = dbInfo.iConnID;
                    taskAssign.SourceQuerySQL = ( xNT.ChildNodes[ 0 ] is XmlCDataSection ) ? _ReplaceTokens( ( ( XmlCDataSection ) xNT.ChildNodes.Item( 0 ) ).Value ) : "";
                    taskAssign.DestinationPropertyID = string.Format( "'Tasks';'Transform for {0}';'Properties';'SourceSQLStatement'", xNT.Attributes.GetNamedItem( "Transform" ).InnerText );

                    taskDynProps.Assignments( ).Add( taskAssign );
                }
            }
        
            _packageDTS.Tasks.Add( task );
        }
        
        private void _CreateSQLStepAndTask( XmlNode xNode )
        {
            Step2 step;
            Task task;
            ExecuteSQLTask2 taskSQL;
        
            DatabaseInfo dbInfo;
        
            dbInfo = _GetTargetConnection( );
        
            step = ( Step2 ) _packageDTS.Steps.New( );
            step.Name = xNode.Attributes.GetNamedItem( "Name" ).InnerText;
            step.Description = xNode.Attributes.GetNamedItem( "Description" ).InnerText;
            step.ExecutionStatus = DTSStepExecStatus.DTSStepExecStat_Completed;
            step.TaskName = xNode.Attributes.GetNamedItem( "Name" ).InnerText;
            step.RollbackFailure = false;
            step.ScriptLanguage = "VBScript";
            step.AddGlobalVariables = false;
            step.CloseConnection = false;
            step.ExecuteInMainThread = false;
            step.IsPackageDSORowset = false;
            step.JoinTransactionIfPresent = false;
            step.DisableStep = false;
            step.FailPackageOnError = true;
        
            _packageDTS.Steps.Add( step );
        
            //
            // We always assume that all operations are going to be done on the target database - after all,
            // we're only trying to get data from A to B, so no data needs to be changed on A.
            //
        
            task = _packageDTS.Tasks.New( "DTSExecuteSQLTask" );
            task.Name = xNode.Attributes.GetNamedItem( "Name" ).InnerText;
            taskSQL = ( ExecuteSQLTask2 ) task.CustomTask;
            taskSQL.Name = xNode.Attributes.GetNamedItem( "Name" ).InnerText;
            taskSQL.Description = xNode.Attributes.GetNamedItem( "Description" ).InnerText;
            taskSQL.SQLStatement = ( xNode.ChildNodes[ 0 ] is XmlCDataSection ) ? _ReplaceTokens( ( ( XmlCDataSection ) xNode.ChildNodes.Item( 0 ) ).Value ) : "";
            taskSQL.ConnectionID = dbInfo.iConnID;
            taskSQL.CommandTimeout = 0;
            taskSQL.OutputAsRecordset = false;
        
            _packageDTS.Tasks.Add( task );
        }
        
        private void _CreateTransformStepAndTask( XmlNode xNode, IInterfaceInfo iiSource )
        {
            Step2 step;
            Task task;
            DataPumpTask2 taskPump;
        
            string szStepTaskName;
            string szDescription;
            string szSourceDB;
            string szSourceTable;
            string szDestinationTable;
        
            DatabaseInfo dbInfoSource;
            DatabaseInfo dbInfoTarget;
        
            ArrayList rgSourceColumns = null;
            ArrayList rgTargetColumns = null;
            
            //
            // Determine which connections to use. We know we will always use a single target connection.
            //
        
            dbInfoTarget = _GetTargetConnection( );
            szDestinationTable = xNode.Attributes.GetNamedItem( "DestinationTable" ).InnerText;
        
            //
            // Determine what the source database is
            //
            dbInfoSource = _GetConnection( iiSource.Interface.ToString( ) );
        
            szStepTaskName = string.Format( "Transform for {0}", xNode.Attributes.GetNamedItem( "Name" ).InnerText );
            szSourceDB = dbInfoSource.szDatabase;
            szSourceTable = xNode.Attributes.GetNamedItem( "SourceTable" ).InnerText;
            szDescription = string.Format( "Transform for {0}", xNode.Attributes.GetNamedItem( "Name" ).InnerText );
    
            step = ( Step2 ) _packageDTS.Steps.New( );
            step.Name = szStepTaskName;
            step.Description = szDescription;
            step.ExecutionStatus = DTSStepExecStatus.DTSStepExecStat_Completed;
            step.TaskName = szStepTaskName;
            step.RollbackFailure = false;
            step.ScriptLanguage = "VBScript";
            step.AddGlobalVariables = false;
            step.CloseConnection = false;
            step.ExecuteInMainThread = false;
            step.IsPackageDSORowset = false;
            step.JoinTransactionIfPresent = false;
            step.DisableStep = false;
            step.FailPackageOnError = true;
    
            _packageDTS.Steps.Add( step );
    
            task = _packageDTS.Tasks.New( "DTSDataPumpTask" );
            task.Name = szStepTaskName;
            taskPump = ( DataPumpTask2 ) task.CustomTask;
            taskPump.Name = szStepTaskName;
            taskPump.Description = szDescription;
            taskPump.SourceConnectionID = dbInfoSource.iConnID;
            switch( xNode.Attributes.GetNamedItem( "SourceType" ).InnerText )
            {
                case "Query":
                {
                    XmlNode xNT = xNode.SelectSingleNode( "Query" ).ChildNodes[ 0 ];
                    taskPump.SourceSQLStatement = ( xNT is XmlCDataSection ) ? _ReplaceTokens( ( ( XmlCDataSection ) xNT ).Value ) : "";
                }
                    break;
                case "Table":
                    taskPump.SourceObjectName = szSourceTable;
                    break;
                default:
                    throw new ArgumentException( "Invalid source type for the transformation", "SourceType" );
            }
            taskPump.DestinationConnectionID = dbInfoTarget.iConnID;
            taskPump.DestinationObjectName = szDestinationTable;
            taskPump.ProgressRowCount = 10000;
            taskPump.MaximumErrorCount = 0;
            taskPump.FetchBufferSize = 1;
            taskPump.UseFastLoad = true;
            taskPump.InsertCommitSize = 0;
            taskPump.ExceptionFileColumnDelimiter = "|";
            taskPump.ExceptionFileRowDelimiter = "\r\n";
            taskPump.AllowIdentityInserts = false;
            taskPump.FirstRow = "0";
            taskPump.LastRow = "0";
            taskPump.FastLoadOptions = DTSFastLoadOptions.DTSFastLoad_KeepNulls | DTSFastLoadOptions.DTSFastLoad_TableLock;
            taskPump.ExceptionFileOptions = DTSExceptionFileOptions.DTSExcepFile_SingleFile70;
            taskPump.DataPumpOptions = 0;
    
            //
            // First, retrieve the schema information for the source and target tables (we only retrieve from the source
            // if it's a table)
            //
            if( "Table" == xNode.Attributes.GetNamedItem( "SourceType" ).InnerText )
            {
                _RetrieveSchemaInformation( szSourceDB, szSourceTable, Destination.SourceDestination, out rgSourceColumns );
            }
            _RetrieveSchemaInformation( dbInfoTarget.szDatabase, szDestinationTable, Destination.TargetDestination, out rgTargetColumns );

            //
            // Time to do fun stuff with column transformations.
            // If our source is a table then
            // we will attempt to automatically map all columns of the same name, datatype, size.
            //
            if( ( "Table" == xNode.Attributes.GetNamedItem( "SourceType" ).InnerText ) &&
                ( 0 == xNode.SelectNodes( "Columns/Column" ).Count ) )
            {
                _AutoColumnTransform( rgSourceColumns, rgTargetColumns, taskPump );
            }
            else
            {
                _ManualColumnTransform( xNode.SelectNodes( "Columns/Column" ), rgSourceColumns, rgTargetColumns, taskPump );
            }
    
            _packageDTS.Tasks.Add( task );
            _rgTransformSteps.Add( step );
        }

        private void _AutoColumnTransform( ArrayList rgSourceColumns, ArrayList rgTargetColumns, DataPumpTask2 taskPump )
        {
            Transformation2 transform;
            Column column;
        
            //
            // For each column in the source, try to find the same name/datatype/size in 
            // the target. If we find it, create a transformation.
            //
            int iIndex;
            foreach( ColumnAndType cT in rgSourceColumns )
            {
                iIndex = rgTargetColumns.IndexOf( cT );
                if( iIndex != -1 )
                {
                    ColumnAndType cTT = rgTargetColumns[ iIndex ] as ColumnAndType;
        
                    transform = ( Transformation2 ) taskPump.Transformations.New( "DTS.DataPumpTransformCopy" );
                    transform.Name = cT.szColumn;
                    transform.TransformFlags = 63;
                    transform.ForceSourceBlobsBuffered = 0;
                    transform.ForceBlobsInMemory = false;
                    transform.InMemoryBlobSize = 1048576;
                    transform.TransformPhases = 4;
        
                    column = transform.SourceColumns.New( cT.szColumn, 1 );
                    column.Name = cT.szColumn;
                    column.Ordinal = 1;
                    column.DataType = cT.iDataType;
                    column.Precision = cT.iPrecision;
                    column.NumericScale = cT.iNumericScale;
                    column.Nullable = cT.fNullable;
                    column.Flags = cT.iFlags;
                    column.Size = cT.iSize;
                    transform.SourceColumns.Add( column );
        
                    column = transform.DestinationColumns.New( cTT.szColumn, 1 );
                    column.Name = cTT.szColumn;
                    column.Ordinal = 1;
                    column.DataType = cTT.iDataType;
                    column.Precision = cTT.iPrecision;
                    column.NumericScale = cTT.iNumericScale;
                    column.Nullable = cTT.fNullable;
                    column.Flags = cTT.iFlags;
                    column.Size = cT.iSize;
                    transform.DestinationColumns.Add( column );
        
                    taskPump.Transformations.Add( ( Transformation ) transform );
                }
            }

            if( 0 == taskPump.Transformations.Count )
            {
                throw new Exception( "Please manually specify column transformations, as the given source and target tables have no columns in common." );
            }
        }
        
        private void _ManualColumnTransform( XmlNodeList xNList, ArrayList rgSourceColumns, ArrayList rgTargetColumns, DataPumpTask2 taskPump )
        {
            Transformation2 transform;
            Column column;
            XmlNode xNSource;
            XmlNode xNTarget;
            ColumnAndType cT;
        
            foreach( XmlNode xNT in xNList )
            {
                //
                // Read in source column information
                //
                xNSource = xNT.SelectSingleNode( "SourceColumn" );

                transform = ( Transformation2 ) taskPump.Transformations.New( "DTS.DataPumpTransformCopy" );
                transform.Name = xNSource.Attributes.GetNamedItem( "Name" ).InnerText;
                transform.TransformFlags = 63;
                transform.ForceSourceBlobsBuffered = 0;
                transform.ForceBlobsInMemory = false;
                transform.InMemoryBlobSize = 1048576;
                transform.TransformPhases = 4;

                cT = _PopulateColumnAndType( xNSource );
                //
                // Verify the column exists in the source if we're not a query
                //
                if( null != rgSourceColumns )
                {
                    int iIndex = rgSourceColumns.IndexOf( cT );

                    if( -1 == iIndex )
                    {
                        throw new ArgumentOutOfRangeException( "Unable to find the column " + cT.szColumn + " in the source table" );
                    }
                }
                
                column = transform.SourceColumns.New( cT.szColumn, 1 );
                column.Name = cT.szColumn;
                column.Ordinal = 1;
                column.DataType = cT.iDataType;
                column.Precision = cT.iPrecision;
                column.NumericScale = cT.iNumericScale;
                column.Nullable = cT.fNullable;
                column.Flags = cT.iFlags;
                column.Size = cT.iSize;
                transform.SourceColumns.Add( column );
        
                //
                // If no TargetColumn node exists, assume that the target has the exact same
                // parameters as the source.
                //
                xNTarget = xNT.SelectSingleNode( "TargetColumn" );
                if( null == xNTarget )
                {
                    xNTarget = xNSource;
                }
        
                cT = _PopulateColumnAndType( xNTarget );

                //
                // Verify the column exists in the target
                //
                do
                {
                    int iIndex = rgTargetColumns.IndexOf( cT );
                
                    if( -1 == iIndex )
                    {
                        throw new ArgumentOutOfRangeException( "Unable to find the column " + cT.szColumn + " in the target table" );
                    }
                } while( false );
                
                column = transform.DestinationColumns.New( cT.szColumn, 1 );
                column.Name = cT.szColumn;
                column.Ordinal = 1;
                column.DataType = cT.iDataType;
                column.Precision = cT.iPrecision;
                column.NumericScale = cT.iNumericScale;
                column.Nullable = cT.fNullable;
                column.Flags = cT.iFlags;
                column.Size = cT.iSize;
                transform.DestinationColumns.Add( column );
        
                taskPump.Transformations.Add( ( Transformation ) transform );
            }
        }
        
        private void _RetrieveSchemaInformation( string szDatabase, string szSource, Destination destType, out ArrayList rgColumnAndTypes )
        {
            string szTable;
            Match match;
        
            if( null != ( match = _regOwnerAndTable.Match( szSource ) ) )
            {
                szTable = match.Result("${table}");
            }
            else
            {
                throw new ArgumentOutOfRangeException( "Unknown table format" );
            }
        
            rgColumnAndTypes = new ArrayList( );

            //
            // Query the schema for the desired table
            //
            SqlConnection connSource = new SqlConnection( "Server=" + _packageDTS.Connections.Item( szDatabase ).DataSource + ";Integrated Security=true;Database=" + szDatabase );
            SqlCommand cmdSource = new SqlCommand( );
            SqlDataReader pReaderSrc;
        
            cmdSource.Connection = connSource;
            cmdSource.CommandText = string.Format( _strSchemaQuery, szTable );
            cmdSource.CommandType = CommandType.Text;

            try
            {
                connSource.Open( );
                pReaderSrc = cmdSource.ExecuteReader( );
            }
            catch( Exception exc )
            {
                throw new Exception( string.Format( "Schema retrieval failed on connection string: {0}. Query is: {1}. Exception is: {2}",
                    cmdSource.Connection.ConnectionString, cmdSource.CommandText, exc.ToString( ) ) );
            }

            if( !pReaderSrc.HasRows )
            {
                throw new ArgumentOutOfRangeException( string.Format( "Table {0} on DB {1} has 0 columns. It may not exist.", szTable, szDatabase ) );
            }
        
            //
            // Just stuff all the column information into the array passed to us
            //
            while( pReaderSrc.Read( ) )
            {
                int iSize = 0;
                int iPrecision = 0;
                int iScale = 0;
                
                string szColumn = pReaderSrc[ "column_name" ].ToString( );
                DBType dbType = _GetDBType( pReaderSrc[ "data_type" ].ToString( ) );
                int iFlags = dbType.iFlags;
                if( dbType.fLookupSize )
                {
                    iSize = int.Parse( pReaderSrc[ "character_maximum_length" ].ToString( ) );
                }
                if( dbType.fLookupPrecision )
                {
                    iPrecision = int.Parse( pReaderSrc[ "numeric_precision" ].ToString( ) ); 
                }
                if( dbType.fLookupScale )
                {
                    iScale = int.Parse( pReaderSrc[ "numeric_scale" ].ToString( ) ); 
                }
                bool fNullable = pReaderSrc[ "is_nullable" ].ToString( ).ToLower( ) == "yes";
                if( fNullable )
                {
                    iFlags |= 96;
                }
        
                ColumnAndType cT = new ColumnAndType( szColumn, dbType.iDataType, iSize, iFlags, iPrecision, iScale, fNullable );
                rgColumnAndTypes.Add( cT );
            }

            connSource.Close( );
        }
        
        private DatabaseInfo _GetTargetConnection( )
        {
            foreach( DatabaseInfo dbInfo in _rgConnections )
            {
                if( Destination.TargetDestination == dbInfo.destType )
                {
                    return dbInfo;
                }
            }
        
            return null;
        }
        
        private DatabaseInfo _GetConnection( string szInterface )
        {
            foreach( DatabaseInfo dbInfo in _rgConnections )
            {
                if( szInterface.ToLower( ) == dbInfo.szInterface.ToLower( ) )
                {
                    return dbInfo;
                }
            }
        
            return null;
        }
        
        private void _CreateSQLAgentJob( XmlNode xNode, string szPackageName, IInterfaceInfo iiSource, IInterfaceInfo iiTarget )
        {
            XmlDocument xmlAgent;
            XmlNodeList xNList;
            XmlNode xJob, xJobSteps, xJobStep, xJobSchedule;
            XmlCDataSection xCData;
            XmlAttribute xAttr;
            XmlNode xNodeT;

            string szJob;
        
            xmlAgent = new XmlDocument( );
        
            //
            // Create and fill up the Job node
            //
            xJob = xmlAgent.CreateElement( "Job" );
        
            for( int i = 0; i < ( _rgJobAttributes.Length / 2 ); i++ )
            {
                xAttr = xmlAgent.CreateAttribute( _rgJobAttributes[ i, 0] );
                xNodeT = xNode.SelectSingleNode( "TaskProperties/@" + _rgJobAttributes[ i, 0 ] );
                if( null != xNodeT )
                {
                    xAttr.Value = _ReplaceTokens( xNodeT.InnerText );
                }
                else
                {
                    xAttr.Value = _rgJobAttributes[ i, 1 ];
                }
                xJob.Attributes.Append( xAttr );
            }
        
            //
            // Add the job steps.
            // If we see no job steps, then our task will be simple - just the DTS package.
            // Otherwise, we will set up whatever is in JobSteps/JobStep but replacing any package
            // named DTSPackage with our step
            //
            xJobSteps = xmlAgent.CreateElement( "JobSteps" );
        
            xNList = xNode.SelectNodes( "JobSteps/JobStep" );
            if( 0 == xNList.Count )
            {
                xJobStep = xmlAgent.CreateElement( "JobStep" );
                for( int i = 0; i < ( _rgJobStepAttributes.Length / 2 ); i++ )
                {
                    xAttr = xmlAgent.CreateAttribute( _rgJobStepAttributes[ i, 0] );
                    xAttr.Value = _rgJobStepAttributes[ i, 1 ];
                    xJobStep.Attributes.Append( xAttr );
                }
        
                xCData = xmlAgent.CreateCDataSection( "DTSRun /S \"(local)\" /N \"" + szPackageName + "\" /W \"0\" /E" );
                xJobStep.AppendChild( xCData );
                xJobSteps.AppendChild( xJobStep );
            }
            else
            {
                foreach( XmlNode xNJobT in xNList )
                {
                    xNodeT = xmlAgent.ImportNode( xNJobT, true );
        
                    if( "DTSPackage" == xNodeT.Attributes.GetNamedItem( "Name" ).InnerText )
                    {
                        foreach( XmlNode xNC in xNJobT.ChildNodes )
                        {
                            if( typeof( XmlCDataSection ) == xNC.GetType( ) )
                            {
                                xNC.Value = "DTSRun /S \"(local)\" /N \"" + szPackageName + "\" /W \"0\" /E";
                            }
                        }
                    }
        
                    xJobSteps.AppendChild( xNodeT );
                }
            }
        
            xJob.AppendChild( xJobSteps );
        
            xJobSchedule = xNode.SelectSingleNode( "JobSchedules" );
            if( null != xJobSchedule )
            {
                xNodeT = xmlAgent.ImportNode( xJobSchedule, true );
                xJob.AppendChild( xNodeT );
            }
        
            xmlAgent.AppendChild( xJob );

            szJob = string.Format( "{0} on {1} to {2} on {3}.xml", iiSource.Interface, iiSource.IPAddress, iiTarget.Interface, iiTarget.IPAddress );
            xmlAgent.Save( szJob );
        }

        private string _ReplaceTokens( string szInput )
        {
            string szOutput = szInput;
            Type typeThis = GetType( );
            FieldInfo fiParam;

            for( int i = 0; i < ( _rgTokens.Length / 2 ); i++ )
            {
                if( szOutput.IndexOf( _rgTokens[ i, 0 ] ) >= 0 )
                {
                    fiParam = typeThis.GetField( _rgTokens[ i, 1 ] );
                    szOutput = szOutput.Replace( _rgTokens[ i, 0 ], fiParam.GetValue( this ).ToString( ) );
                }
            }

            return( szOutput );
        }

        private DBType _GetDBType( string szType )
        {
            foreach( DBType dT in _rgDBTypes )
            {
                if( szType.Trim( ).ToLower( ) == dT.szType.Trim( ).ToLower( ) )
                {
                    return dT;
                }
            }

            throw new ArgumentOutOfRangeException( "The column type of " + szType + " is not supported" );
        }

        private ColumnAndType _PopulateColumnAndType( XmlNode xNode )
        {
            ColumnAndType cT = new ColumnAndType( );
            DBType dbType;
        
            dbType = _GetDBType( xNode.Attributes.GetNamedItem( "DataType" ).InnerText );
            cT.szColumn = xNode.Attributes.GetNamedItem( "Name" ).InnerText;
            cT.iDataType = dbType.iDataType;
            cT.iFlags = dbType.iFlags;
            if( dbType.fLookupSize )
            {
                if( null == xNode.Attributes.GetNamedItem( "Size" ) )
                {
                    throw new ArgumentNullException( "Datatype of " + dbType.szType + " requires the Size attribute on column " + cT.szColumn );
                }
                cT.iSize = int.Parse( xNode.Attributes.GetNamedItem( "Size" ).InnerText );
            }
            else
            {
                cT.iSize = 0;
            }
            if( dbType.fLookupPrecision )
            {
                if( null == xNode.Attributes.GetNamedItem( "Precision" ) )
                {
                    throw new ArgumentNullException( "Datatype of " + dbType.szType + " requires the Precision attribute on column " + cT.szColumn );
                }
                cT.iPrecision = int.Parse( xNode.Attributes.GetNamedItem( "Precision" ).InnerText );
            }
            else
            {
                cT.iPrecision = 0;
            }
            if( dbType.fLookupScale )
            {
                if( null == xNode.Attributes.GetNamedItem( "Scale" ) )
                {
                    throw new ArgumentNullException( "Datatype of " + dbType.szType + " requires the Scale attribute on column " + cT.szColumn );
                }
                cT.iNumericScale = int.Parse( xNode.Attributes.GetNamedItem( "Scale" ).InnerText );
            }
            else
            {
                cT.iNumericScale = 0;
            }
            cT.iFlags = dbType.iFlags;
            
            cT.fNullable = ( null != xNode.Attributes.GetNamedItem( "Nullable" ) ) ? ( bool.Parse( xNode.Attributes.GetNamedItem( "Nullable" ).InnerText ) ) : false;
            if( cT.fNullable )
            {
                cT.iFlags |= 96;
            }

            return cT;
        }
    }

    class ReportingDTS
    {
        private StringBuilder _strValidationError = new StringBuilder( );
        private bool _fPackageOnTarget = true;

        public void Execute( string szXmlFile, bool fDelete )
        {
            XmlDocument xDom;

            ArrayList rgSourceInterfaces = new ArrayList( );
            ArrayList rgTargetInterfaces = new ArrayList( );

            int iSource;
            int iTarget;

            xDom = new XmlDocument( );
            xDom.Load( szXmlFile );

            //
            // Validate against dtspackage.xsd (which is compiled into the assembly)
            //
            _Validate( xDom.OuterXml );

            //
            // Get our server information
            //
            _RetrieveServerInformation( xDom.DocumentElement, ref rgSourceInterfaces, ref rgTargetInterfaces );

            //
            // For each source/target combination, create a DTS package
            //
            try
            {
                for( iSource = 0; iSource < rgSourceInterfaces.Count; iSource++ )
                {
                    InterfaceInfoWithServername iiSource =  ( InterfaceInfoWithServername ) rgSourceInterfaces[ iSource ];
                    for( iTarget = 0; iTarget < rgTargetInterfaces.Count; iTarget++ )
                    {
                        InterfaceInfoWithServername  iiTarget = ( InterfaceInfoWithServername ) rgTargetInterfaces[ iTarget ];
                        PackageDTS      pkg = new PackageDTS( );
                        IInterfaceInfo  iiHost;

                        iiHost = ( _fPackageOnTarget ) ? iiTarget.InterfaceInfo : iiSource.InterfaceInfo;

                        pkg.SourceServerName = iiSource.ServerName;
                        pkg.TargetServerName = iiTarget.ServerName;
                        pkg.SourceDatabaseName = iiSource.InterfaceInfo.DBName;
                        if( fDelete )
                        {
                            pkg.DeletePackage( xDom.DocumentElement, iiHost );
                        }
                        else
                        {
                            pkg.CreatePackage( xDom.DocumentElement, iiSource.InterfaceInfo, iiTarget.InterfaceInfo, iiHost );
                        }

                        //
                        // For webstore databases, handle the replica's package (only if more than 1 server exists)
                        //
                        if( ( iiSource.InterfaceInfo.Protocol.ToLower( ) == "webstore" ) && ( rgSourceInterfaces.Count > 1 ) )
                        {
                            InterfaceInfoWithServername iiOriginal = ( InterfaceInfoWithServername ) rgSourceInterfaces[ ( iSource + rgSourceInterfaces.Count - 1 ) % rgSourceInterfaces.Count ];

                            pkg = new PackageDTS( );
                            pkg.SourceServerName = iiSource.ServerName;
                            pkg.TargetServerName = iiTarget.ServerName;
                            pkg.ReplicationRole = PackageDTS.ReplicationRoleType.Replica;
                            pkg.SourceDatabaseName = iiOriginal.InterfaceInfo.DBName + "Replicaof" + iiOriginal.ServerName;
                            if( fDelete )
                            {
                                pkg.DeletePackage( xDom.DocumentElement, iiHost );
                            }
                            else
                            {
                                pkg.CreatePackage( xDom.DocumentElement, iiSource.InterfaceInfo, iiTarget.InterfaceInfo, iiHost );
                            }
                        }
                    }
                }
            }
            catch
            {
                if( !fDelete )
                {
                    for( iSource = 0; iSource < rgSourceInterfaces.Count; iSource++ )
                    {
                        InterfaceInfoWithServername iiSource =  ( InterfaceInfoWithServername ) rgSourceInterfaces[ iSource ];
                        for( iTarget = 0; iTarget < rgTargetInterfaces.Count; iTarget++ )
                        {
                            InterfaceInfoWithServername  iiTarget = ( InterfaceInfoWithServername ) rgTargetInterfaces[ iTarget ];
                            PackageDTS      pkg = new PackageDTS( );
                            IInterfaceInfo  iiHost;

                            iiHost = ( _fPackageOnTarget ) ? iiTarget.InterfaceInfo : iiSource.InterfaceInfo;

                            pkg.SourceServerName = iiSource.ServerName;
                            pkg.TargetServerName = iiTarget.ServerName;
                            pkg.SourceDatabaseName = iiSource.InterfaceInfo.DBName;
                            pkg.DeletePackage( xDom.DocumentElement, iiHost );
     
                            //
                            // For webstore databases, delete the replica's package
                            //
                            if( ( iiSource.InterfaceInfo.Protocol.ToLower( ) == "webstore" ) && ( rgSourceInterfaces.Count > 1 ) )
                            {
                                InterfaceInfoWithServername iiOriginal = ( InterfaceInfoWithServername ) rgSourceInterfaces[ ( iSource + rgSourceInterfaces.Count - 1 ) % rgSourceInterfaces.Count ];

                                pkg = new PackageDTS( );
                                pkg.SourceServerName = iiSource.ServerName;
                                pkg.TargetServerName = iiTarget.ServerName;
                                pkg.ReplicationRole = PackageDTS.ReplicationRoleType.Replica;
                                pkg.SourceDatabaseName = iiOriginal.InterfaceInfo.DBName + "Replicaof" + iiOriginal.ServerName;
                                pkg.DeletePackage( xDom.DocumentElement, iiHost );
                             }
                        }
                    }
                }
                throw;
            }
        }

        private void _Validate( string szXml )
        {
            Assembly aThis;
            string[] rgszNames;
            Stream strXSD = null;
        
            XmlTextReader xTReader;
            XmlSchemaCollection xSchColl;
            XmlValidatingReader xValidate;
        
            //
            // Retrieve the XSD from the manifest
            //
            aThis = Assembly.GetExecutingAssembly( );
            rgszNames = aThis.GetManifestResourceNames( );
        
            foreach( string szT in rgszNames )
            {
                if( szT.EndsWith( "dtspackage.xsd" ) )
                {
                    strXSD = aThis.GetManifestResourceStream( szT );
                }
            }
        
            //
            // Serious error if we can't find the xsd
            //
            if( null == strXSD )
            {
                throw new BadImageFormatException( "Unable to find the XSD" );
            }
        
            //
            // Validate the xml document
            //
            xTReader = new XmlTextReader( strXSD );
            xSchColl = new XmlSchemaCollection( );
            xSchColl.Add( null, xTReader );
        
            xValidate = new XmlValidatingReader( szXml, XmlNodeType.Document, null );
            xValidate.Schemas.Add( xSchColl );
        
            xValidate.ValidationType = ValidationType.Schema;
            xValidate.ValidationEventHandler += new ValidationEventHandler( this._ValidationHandler );
        
            while( xValidate.Read( ) );
        
            xValidate.Close( );
        
            if( _strValidationError.Length != 0 )
            {
                throw new Exception( _strValidationError.ToString( ) );
            }
        }
        
        //
        // As we're validating, we will keep appending to a validation error string
        //
        private void _ValidationHandler( object sender, ValidationEventArgs args )
        {
            _strValidationError.Append( args.Message );
            _strValidationError.Append( "\r\n" );
        }

        //
        // Based on the XML values, go into ConfigDB and retrieve the server information
        //
        private void _RetrieveServerInformation( XmlNode xNode, ref ArrayList rgSourceInterfaces, ref ArrayList rgTargetInterfaces )
        {
            string iFace;
            string[] rgszServers;

            //
            // Check to make sure that the package host is either the source or
            // destination interface
            //
            if( xNode.SelectSingleNode( "Properties/@Interface" ).InnerText.ToLower( ) == 
                xNode.SelectSingleNode( "Destinations/Source/@Interface" ).InnerText.ToLower( ) )
            {
                _fPackageOnTarget = false;
            }
            else if( xNode.SelectSingleNode( "Properties/@Interface" ).InnerText.ToLower( ) == 
                xNode.SelectSingleNode( "Destinations/Target/@Interface" ).InnerText.ToLower( ) )
            {
                _fPackageOnTarget = true;
            }
            else
            {
                throw new Exception( "The package must reside on either the source or destination interface." );
            }

            //
            // Get all the source/target interfaces
            //
            try
            {
                iFace = xNode.SelectSingleNode( "Destinations/Source/@Interface" ).InnerText;
            }
            catch
            {
                throw new ArgumentOutOfRangeException( xNode.SelectSingleNode( "Destinations/Source/@Interface" ).InnerText + " is not a valid source interface." );
            }
            rgszServers = Config.GetServerListByInterface( iFace );
            if( rgszServers.Length == 0 )
            {
                throw new ArgumentOutOfRangeException( "Unable to find any servers with the interface " + iFace.ToString( ) );
            }
           
            foreach( string szServer in rgszServers )
            {
                InterfaceInfoWithServername iiDestination = new InterfaceInfoWithServername( );
                iiDestination.ServerName = szServer;
                iiDestination.InterfaceInfo = Config.GetInterface( szServer, iFace );
                rgSourceInterfaces.Add( iiDestination );
            }

            try
            {
                iFace = xNode.SelectSingleNode( "Destinations/Target/@Interface" ).InnerText;
            }
            catch
            {
                throw new ArgumentOutOfRangeException( xNode.SelectSingleNode( "Destinations/Target/@Interface" ).InnerText + " is not a valid target interface." );
            }
            rgszServers = Config.GetServerListByInterface( iFace );
            if( rgszServers.Length == 0 )
            {
                throw new ArgumentOutOfRangeException( "Unable to find any servers with the interface " + iFace.ToString( ) );
            }

            foreach( string szServer in rgszServers )
            {
                InterfaceInfoWithServername iiDestination = new InterfaceInfoWithServername( );
                iiDestination.ServerName = szServer;
                iiDestination.InterfaceInfo = Config.GetInterface( szServer, iFace );
                rgTargetInterfaces.Add( iiDestination );
            }

        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\xereports\GenerateSSIS\Global.cs ===
using System;
using System.Collections.Generic;
using System.Text;
using System.Configuration;
using System.Data;
using System.Data.SqlClient;
using Microsoft.ApplicationBlocks.Data;
using System.Collections;


namespace GenerateDTS.Common
{
    public enum DatabaseType
    {
        ProductionDatamart = 0,
        ProductionStage = 1,
        ConsolidatorGSADW = 2,
        ConsolidatorStage = 3,
        ConsolidatorSource = 4,
        Metadata = 5
    }


    public enum ConnectionType
    {
        OLEDB = 0,
        ADONET = 1,
        FlatFile = 2,
        File = 3,
        XML=4,
        XLS=5,
        ACCESS=6,
        SQLSERVER=7
    }

    public enum OledbSourceAccessMode
    {
        TableORView =0,
        TableORViewFromVariable=1,
        SqlCommand=2,
        SqlCommandFromVariable = 3,
        None=4
    }


    public enum OledbDestinationAccessMode
    {
        TableORView = 0,
        TableORViewFastLoad = 1,
        TableORViewvariable = 2,
        TableORViewvariableFastLoad = 3,
        SqlCommand = 4,
    }


    class Global
    {
        public static string GetAppParamValue(string paramName)
        {

            string paramValue=string.Empty  ;
            try
            {
                paramValue = ConfigurationManager.AppSettings[paramName].ToString();
                if (paramValue == null || paramValue == String.Empty)
                {
                    throw new Exception("Entry " + paramName + " does not exist or does not contain any value in ConfigFile");
                }

                return paramValue;
            }
            catch (Exception)
            {
                if (paramName != "SinglePackage")
                Console.WriteLine("Entry " + paramName + " does not exist or does not contain any value in ConfigFile");
                return paramValue;
                //throw new Exception("Entry " + paramName + " does not exist or does not contain any value in ConfigFile");
            }
        }

        public static string getConnectionString(string server, string database, ConnectionType connectionType)
        {
            string connString = string.Empty;
            if (connectionType == ConnectionType.OLEDB)
            {
                connString = ConfigurationManager.AppSettings["OLEDBConnString"];
                connString = connString.Replace("[DataSource]", server);
                connString = connString.Replace("[Catalog]", database);
            }
            else if (connectionType == ConnectionType.ADONET)
            {
                connString = ConfigurationManager.AppSettings["ADOConnString"];
                connString = connString.Replace("[DataSource]", server);
                connString = connString.Replace("[Catalog]", database);
            }

            return connString;
        }

        //public static string MetadataConnString
        //{
        //    string strConnString = ConfigurationManager.AppSettings["MetaDataConnectionString"];
        //    return strConnString;
        //}

        //public static string GetProductionConncetionString()
        //{
        //    string strConnString = ConfigurationManager.AppSettings["ProductionConncetionString"];
        //    return strConnString;
        //}


        public static string MetadataConnString
        {
            get { return GetConnString(DatabaseType.Metadata); }
        }

        private static string GetConnString(DatabaseType dbType)
        {
            string connString = string.Empty;
            string dbServer = string.Empty;
            string initCatalog = string.Empty;

            string configServerParamName = string.Empty;
            string configDBParamName = string.Empty;


            switch (dbType)
            {
                case DatabaseType.Metadata:
                    configServerParamName = "MetadataServer";
                    configDBParamName = "MetadataCatalog";
                    break;
            }



            dbServer = ConfigurationManager.AppSettings.Get(configServerParamName);

            if (dbServer == null || dbServer == String.Empty)
            {
                throw new Exception("Entry " + configServerParamName + " does not exist or does not contain any value in ConfigFile");
            }

            initCatalog = ConfigurationManager.AppSettings.Get(configDBParamName);
            if (initCatalog == null || initCatalog == String.Empty)
            {
                throw new Exception("Entry " + configDBParamName + " does not exist or does not contain any value in ConfigFile");
            }

            connString = ConfigurationManager.AppSettings.Get("GenericConString");
            connString = connString.Replace("[DataSource]", dbServer);
            connString = connString.Replace("[Catalog]", initCatalog);

            return connString;
        }

        public static System.Collections.ArrayList GetPackageTasks(string pkgName)
        {

            string commandText = "GetPackageTask";
            SqlDataReader reader = null;
            ArrayList PackageTasks = null;

            try
            {
                SqlParameter[] parameters = new SqlParameter[1];
                parameters[0] = new SqlParameter("@packagename", System.Data.SqlDbType.NVarChar);
                parameters[0].Value = pkgName;
                reader = SqlHelper.ExecuteReader(Global.MetadataConnString, CommandType.StoredProcedure, commandText, parameters);
            }
            catch (Exception ex)
            {
                Console.WriteLine(ex.Message);
                throw;
            }

            if (reader == null)
            {
                Console.WriteLine("Package " + pkgName + " does not have tasks entries");
                if (reader != null)
                {
                    reader.Close();
                }
                return null;
            }
            else if (!reader.HasRows)
            {
                Console.WriteLine("Package " + pkgName + " does not have tasks entries");
                if (reader != null)
                {
                    reader.Close();
                }
                return null;
            }

            PackageTasks = new ArrayList();
            while (reader.Read())
            {
                AppStructs.PackageTask objStruct;
                objStruct.TaskID = (int)reader.GetValue(0);
                objStruct.TaskName = (string)reader.GetValue(1);
                objStruct.TaskTypeName = (string)reader.GetValue(3);
                objStruct.PreceedingTaskID = "";
                PackageTasks.Add(objStruct);
            }
            reader.Close();
            reader = null;
            return PackageTasks;

        }

        public static System.Data.SqlClient.SqlDataReader GetPackageTaskColumns(int TaskID)
        {
            try
            {
                string commandText = "GetPackageTaskColumns";
                SqlParameter[] parameters = new SqlParameter[1];
                parameters[0] = new SqlParameter("@packageTaskId", System.Data.SqlDbType.NVarChar);
                parameters[0].Value = TaskID;
                System.Data.SqlClient.SqlDataReader reader = SqlHelper.ExecuteReader(Global.MetadataConnString, CommandType.StoredProcedure, commandText, parameters);
                return reader;
            }
            catch (Exception ex)
            {
                Console.WriteLine(ex.Message);
                throw;
            }

        }

    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\xereports\GenerateSSIS\LookUpTask.cs ===
using System;
using System.Collections.Generic;
using System.Collections;
using System.Text;
using GenerateDTS.Common;
using Microsoft.SqlServer.Dts.Pipeline.Wrapper;
using dtr = Microsoft.SqlServer.Dts.Runtime.Wrapper;
using Microsoft.SqlServer.Dts.Runtime;
using Microsoft.SqlServer.Dts.Tasks.ExecuteSQLTask;


namespace GenerateDTS
{
    class LookUpTask
    {
        public void modifyLookUpTask(Package pkg, string DataFlowTaskName, string LookUpTaskName, string ConnName, string LookUpTableName, string LookColumnName, string CopyFromReferenceColumn, string JoinToReferenceColumn)
        {

            IDTSComponentMetaData90 LookUP = null;
            MainPipe dataFlow;
            Executable exe;

            try
            {
                exe = pkg.Executables[DataFlowTaskName];
                TaskHost th2 = exe as TaskHost;
                dataFlow = th2.InnerObject as MainPipe; // getting the datatflow task

                // getting the lookup task which belongs to the dataflow task
                foreach (IDTSComponentMetaData90 comp in dataFlow.ComponentMetaDataCollection)
                    if (comp.Name == LookUpTaskName)
                        LookUP = comp;


                // set the conmnection
                if (LookUP.RuntimeConnectionCollection.Count > 0)
                {
                    LookUP.RuntimeConnectionCollection[0].ConnectionManager = DtsConvert.ToConnectionManager90(pkg.Connections[ConnName]);
                    LookUP.RuntimeConnectionCollection[0].ConnectionManagerID = pkg.Connections[ConnName].ID;
                }

                CManagedComponentWrapper instanceLookup = LookUP.Instantiate();

                //Initialize the connection
                instanceLookup.AcquireConnections(null);
                instanceLookup.ReinitializeMetaData();
                instanceLookup.ReleaseConnections();

                // Set the lookup table from where we need to lookup
                instanceLookup.SetComponentProperty("SqlCommand", "Select * from " + LookUpTableName);

                IDTSInput90 input = LookUP.InputCollection[0];
                IDTSVirtualInput90 vInput = input.GetVirtualInput();

                // Set the col mapping aginst the lookup.
                foreach (IDTSVirtualInputColumn90 vColumn in vInput.VirtualInputColumnCollection)
                {
                    if (vColumn.Name.ToLower() == LookColumnName.ToLower())
                    {
                        IDTSInputColumn90 vCol = instanceLookup.SetUsageType(input.ID, vInput, vColumn.LineageID, DTSUsageType.UT_READONLY);
                        vCol.CustomPropertyCollection["CopyFromReferenceColumn"].Value = CopyFromReferenceColumn;
                        vCol.CustomPropertyCollection["JoinToReferenceColumn"].Value = JoinToReferenceColumn;
                    }
                }

            }
            catch (Exception ex)
            {
                Console.WriteLine(ex.Message);
                throw ex;
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\xereports\OLAPAutoBuild\obj\i386\_generated.cs ===
[assembly:System.Runtime.InteropServices.ComVisible(false)]
[assembly:System.Reflection.AssemblyVersion("12.4.56.0")]
[assembly:System.Reflection.AssemblyProduct("DEPOT")]
[assembly:System.Reflection.AssemblyCopyright("")]
[assembly:System.Reflection.AssemblyCompany("")]
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\xereports\OLAPAutoBuild\objd\i386\_generated.cs ===
[assembly:System.Runtime.InteropServices.ComVisible(false)]
[assembly:System.Reflection.AssemblyVersion("12.4.56.0")]
[assembly:System.Reflection.AssemblyProduct("DEPOT")]
[assembly:System.Reflection.AssemblyCopyright("")]
[assembly:System.Reflection.AssemblyCompany("")]
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\xereports\ManualData\ManualData.cs ===
using System;
using System.Collections;
using System.Collections.Generic;
using System.Data;
using System.Data.SqlClient;
using System.IO;
using System.Text;

namespace ApplogToBCP
{
    class Program
    {
        static string[] s_rgszLogTypes = 
            {
            "CONTENTREF",
            "CREATEACCOUNT",
            "CREATELIVEACCOUNT",
            "CREATEXBOXCOMACCOUNT",
            "XeOfferPurchase",
            "XeContentReferral",
            "TITLESTART",
            "TITLEND",
            "SESSTART",
            "SESEND",
            "MIGRATEXBOX1USER",
            "MigrateXboxComUser",
            "LS-BAN_VW",
            "LSA-BAN_VW",
            "LS-BAN_CL",
            "LSA-BAN_CL",
            "LS-MP_P",
            "LSA-MP_P",
            "LS-FU",
            "LSA-FU",
            "ARGOLICENSE",
            "GeoFenceOfferPurchase",
            "GeoFenceContentReferral",
            "GeoFenceVideoPurchase",
            "GeoFenceVideoAcquireURL",
            "GeoFenceVideoAcquireLicense",
            "LS-DHW",
            "LICTRANSFER",
            "GENERICMSG",
            "PurchaseOffersReporting",
            "LICENSE_REQUEST"
            };

        enum eCustomDataTypes
        {
            guid = 19,
            binaryArray = 99,
        };

        public class FieldTransform
        {
            public int messageId;
            public int sourceFieldPosition;
            public int destFieldPosition;
            public System.TypeCode destFieldType;
            public System.Data.SqlDbType destDbType;
            public int isXeh;

            public FieldTransform(int messageId, int sourceFieldPosition, int destFieldPosition,
                System.TypeCode destFieldType, int isXeh, System.Data.SqlDbType destDbType)
            {
                this.messageId = messageId;
                this.sourceFieldPosition = sourceFieldPosition;
                this.destFieldPosition = destFieldPosition;
                this.destFieldType = destFieldType;
                this.isXeh = isXeh;
                this.destDbType = destDbType;
            }
        }

        public class Message
        {
            public int componentID;
            public string sourcePrefix;
            public int messageId;
            public string storedProcedureName;
            public int userPuidPosition;

            public Message(int messageId, int componentID, string sourcePrefix, string storedProcedureName, int userPuidPosition)
            {
                this.messageId = messageId;
                this.componentID = componentID;
                this.sourcePrefix = sourcePrefix;
                this.storedProcedureName = storedProcedureName;
                this.userPuidPosition = userPuidPosition;
            }
        }

        public class ByteConvert
        {
            //
            // turns a byte array into a hex string
            //
            public static string ToString(byte[] ba)
            {
                if (ba == null)
                {
                    return "0";
                }

                StringBuilder strb = new StringBuilder(ba.Length * 2);

                for (int i = 0; i < ba.Length; i++)
                {
                    strb.Append(ba[i].ToString("x2"));
                }

                return strb.ToString();
            }


            //
            // turns a byte array into a hex string reversed (for little endian stuff)
            //
            public static string ToReverseString(byte[] ba)
            {
                if (ba == null)
                {
                    return "0";
                }

                StringBuilder strb = new StringBuilder(ba.Length * 2);

                for (int i = ba.Length - 1; i >= 0; i--)
                {
                    strb.Append(ba[i].ToString("X2"));
                }

                return strb.ToString();
            }


            public static string[] ToFormattedStrings(byte[] ba)
            {
                StringBuilder hexBytes = new StringBuilder(50);
                StringBuilder strBytes = new StringBuilder(16);

                string[] lines = new string[ba.Length / 16 + (ba.Length % 16 == 0 ? 0 : 1)];

                for (int i = 0; i < lines.Length; i++)
                {
                    for (int j = 0; j < 16; j++)
                    {
                        int index = (i * 16) + j;
                        if (index < ba.Length)
                        {
                            byte b = ba[index];
                            hexBytes.Append(b.ToString("x2") + (j == 7 ? "-" : " "));
                            strBytes.Append(b >= 0x20 && b < 0x7f ? (char)b : '.');
                        }
                    }

                    lines[i] = hexBytes.ToString().PadRight(48) + strBytes.ToString().PadRight(17);
                    hexBytes.Length = 0;
                    strBytes.Length = 0;
                }

                return lines;
            }

            //
            // turns a hex string into a byte array
            //
            public static byte[] FromString(string str)
            {
                byte[] ba = new byte[str.Length / 2];
                for (int i = 0; i < ba.Length; i++)
                {
                    ba[i] = Convert.ToByte(str.Substring(i * 2, 2), 16);
                }
                return ba;
            }
        }

        static object messages;
        static object messageTransform;

        static void Main(string[] args)
        {
            string szInputDirectory;
            string szOutputDirectory;
            string szNPDBServer;
            Dictionary<string, StreamWriter> diBCPFile = new Dictionary<string, StreamWriter>();

            if (3 != args.Length)
            {
                Console.WriteLine("ApplogToBCP <npdbserver> <npdbdatabase> <inputdir> <outputdir>");
                return;
            }

            Console.WriteLine("THIS APPLICATION WILL DELETE ALL FILES IN THE OUTPUT DIRECTORY.");
            Console.WriteLine("PRESS ENTER (AND ONLY ENTER) TO CONTINUE.");
            ConsoleKeyInfo cki = Console.ReadKey();
            if (cki.Key != ConsoleKey.Enter)
            {
                return;
            }

            szNPDBServer = args[0];
            szNPDBDatabase = args[1];
            szInputDirectory = args[2];
            szOutputDirectory = args[3];

            LoadTransformConfig(szNPDBServer, szNPDBDatabase);

            string[] rgszDelFiles = Directory.GetFiles(szOutputDirectory);

            foreach (string szDelFile in rgszDelFiles)
            {
                File.Delete(szDelFile);
            }

            DateTime dtNow = DateTime.Now;
            foreach (string szLogType in s_rgszLogTypes)
            {
                string szBCPFileName = szOutputDirectory + @"\" + szLogType + "_" +
                    System.Environment.GetEnvironmentVariable("USERNAME") +
                    "_" + dtNow.ToString("yyyyMMddHHmm") + ".bcp";
                StreamWriter swBCPFile = File.CreateText(szBCPFileName);
                swBCPFile.AutoFlush = true;
                diBCPFile.Add(szLogType, swBCPFile);
            }

            string[] rgszLogFiles = Directory.GetFiles(szInputDirectory);

            foreach (string szLogFile in rgszLogFiles)
            {
                string szLine;
                StreamReader srLogFile = File.OpenText(szLogFile);

                Console.WriteLine("Parsing file: " + szLogFile);

                szLine = srLogFile.ReadLine();
                while (null != szLine)
                {
                    string[] rgszLogLine = szLine.Split('|');
                    if (rgszLogLine.Length >= 2 && diBCPFile.ContainsKey(rgszLogLine[1]))
                    {
                        FieldTransform[] rgTransform = GetTransform(rgszLogLine[1]);
                        string[] rgszValues = new string[rgTransform.Length];

                        for (int i = 0; i < rgszValues.Length; i++)
                        {
                            rgszValues[i] = ConvertField(rgszLogLine, rgTransform[i]);
                        }

                        diBCPFile[rgszLogLine[1]].WriteLine(string.Join("|", rgszValues));
                    }

                    szLine = srLogFile.ReadLine();
                }

                srLogFile.Close();
            }

            foreach (StreamWriter swBCPFile in diBCPFile.Values)
            {
                swBCPFile.Close();
            }
        }

        static void LoadTransformConfig(string szNPDBServer, string szNPDBDatabase)
        {
            Hashtable tempMessages = new Hashtable();
            Hashtable tempMessageTransform = new Hashtable();

            using (SqlConnection npdbConnection = new SqlConnection("Data Source=" + szNPDBServer + ";Integrated Security=SSPI;Initial Catalog=" + szNPDBDatabase))
            {
                SqlCommand cmd = npdbConnection.CreateCommand();

                cmd = npdbConnection.CreateCommand();
                cmd.CommandText = "p_get_messages";
                cmd.CommandType = CommandType.StoredProcedure;
                cmd.Connection.Open();
                SqlDataReader reader = cmd.ExecuteReader();

                while (reader.Read())
                {
                    Message msg = new Message((int)(short)reader["si_message_id"], (int)(short)reader["si_component_id"],
                    (string)reader["vc_source_prefix"], (string)reader["vc_action_sproc_name"], (int)(byte)reader["ti_dest_user_puid_position"]);

                    tempMessages.Add(msg.sourcePrefix, msg);
                }

                // now for every message load its transform
                IDictionaryEnumerator myEnumerator = tempMessages.GetEnumerator();
                while (myEnumerator.MoveNext())
                {
                    Message msg = (Message)myEnumerator.Value;
                    FieldTransform[] flds = new FieldTransform[255];
                    reader.Close();

                    cmd.CommandText = "p_get_transform";
                    cmd.CommandType = CommandType.StoredProcedure;
                    cmd.Parameters.Clear();
                    cmd.Parameters.Add("@si_message_id", SqlDbType.SmallInt).Value = msg.messageId;

                    reader = cmd.ExecuteReader();
                    int i = 0;
                    for (; i < flds.Length && reader.Read(); i++)
                    {
                        flds[i] = new FieldTransform(msg.messageId, (int)(byte)reader["ti_source_field_position"],
                                    (int)(byte)reader["ti_dest_field_position"], (System.TypeCode)(byte)reader["ti_dest_field_type"],
                                    (int)(byte)reader["ti_is_hex_format"],
                                    (System.Data.SqlDbType)(byte)reader["ti_dest_sql_db_type"]);
                    }

                    FieldTransform[] realFlds = new FieldTransform[i];
                    for (i = 0; i < realFlds.Length; i++)
                    {
                        realFlds[i] = flds[i];
                    }

                    tempMessageTransform.Add(msg.messageId, realFlds);
                }
            }

            messages = tempMessages;
            messageTransform = tempMessageTransform;
        }

        static FieldTransform[] GetTransform(string sourcePrefix)
        {
            FieldTransform[] transform = null;
            Hashtable msgs = (Hashtable)messages;
            Hashtable msgTransf = (Hashtable)messageTransform;

            Message message = (Message)msgs[sourcePrefix];

            transform = (FieldTransform[])msgTransf[message.messageId];

            return transform;
        }

        static string ConvertField(string[] elements, FieldTransform transform)
        {
            //Do not attempt to transform an empty element. Nor try to transform an element not in the source string.
            if (elements.Length <= transform.sourceFieldPosition ||
                elements[transform.sourceFieldPosition] == string.Empty)
            {
                return null;
            }

            object value = new object();

            if ((int)transform.destFieldType == (int)eCustomDataTypes.binaryArray)
            {
                byte[] rgbData = new byte[elements[transform.sourceFieldPosition].Length];
                rgbData = ByteConvert.FromString(elements[transform.sourceFieldPosition]);
                return ByteConvert.ToString(rgbData);
            }

            if ((int)transform.destFieldType == (int)eCustomDataTypes.guid)
            {
                return new Guid(elements[transform.sourceFieldPosition]).ToString();
            }

            int numberStyle = transform.isXeh == 1 ? 16 : 10;

            switch (transform.destFieldType)
            {
                case TypeCode.Boolean:
                    value = Convert.ToBoolean(elements[transform.sourceFieldPosition]);
                    break;
                case TypeCode.Byte:
                    value = elements[transform.sourceFieldPosition] == "" ? (byte)0 : Convert.ToByte(elements[transform.sourceFieldPosition], numberStyle);
                    break;
                case TypeCode.Char:
                    value = Convert.ToChar(elements[transform.sourceFieldPosition]);
                    break;
                case TypeCode.DateTime:
                    DateTime dtVal = Convert.ToDateTime(elements[transform.sourceFieldPosition]);
                    return dtVal.ToString("o");
                case TypeCode.Decimal:
                    value = elements[transform.sourceFieldPosition] == "" ? 0 : Convert.ToDecimal(elements[transform.sourceFieldPosition]);
                    break;
                case TypeCode.Double:
                    value = elements[transform.sourceFieldPosition] == "" ? 0 : Convert.ToDouble(elements[transform.sourceFieldPosition]);
                    break;
                case TypeCode.Int16:
                    value = elements[transform.sourceFieldPosition] == "" ? (Int16)0 : Convert.ToInt16(elements[transform.sourceFieldPosition], numberStyle);
                    break;
                case TypeCode.Int32:
                    value = elements[transform.sourceFieldPosition] == "" ? 0 : Convert.ToInt32(elements[transform.sourceFieldPosition], numberStyle);
                    break;
                case TypeCode.Int64:
                    value = elements[transform.sourceFieldPosition] == "" ? 0 : Convert.ToInt64(elements[transform.sourceFieldPosition], numberStyle);
                    break;
                case TypeCode.SByte:
                    value = elements[transform.sourceFieldPosition] == "" ? (sbyte)0 : Convert.ToSByte(elements[transform.sourceFieldPosition], numberStyle);
                    break;
                case TypeCode.Single:
                    value = Convert.ToSingle(elements[transform.sourceFieldPosition]);
                    break;
                case TypeCode.String:
                    value = elements[transform.sourceFieldPosition];
                    break;
                case TypeCode.UInt16:
                    value = elements[transform.sourceFieldPosition] == "" ? (UInt16)0 : Convert.ToUInt16(elements[transform.sourceFieldPosition], numberStyle);
                    break;
                case TypeCode.UInt32:
                    value = elements[transform.sourceFieldPosition] == "" ? 0 : Convert.ToUInt32(elements[transform.sourceFieldPosition], numberStyle);
                    break;
                case TypeCode.UInt64:
                    value = elements[transform.sourceFieldPosition] == "" ? 0 : Convert.ToUInt64(elements[transform.sourceFieldPosition], numberStyle);
                    break;
                default:
                    throw new Exception("Inknown data type in message , transform type = " + transform.destFieldType);
            }
            return value.ToString();
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\xereports\GenerateSSIS\SqlTask.cs ===
using System;
using System.Collections.Generic;
using System.Collections;
using System.Text;
using GenerateDTS.Common;
using Microsoft.SqlServer.Dts.Pipeline.Wrapper;
using dtr = Microsoft.SqlServer.Dts.Runtime.Wrapper;
using Microsoft.SqlServer.Dts.Runtime;
using Microsoft.SqlServer.Dts.Tasks.ExecuteSQLTask;


namespace GenerateDTS
{
    class SqlTask
    {

        public void PopulateTask(string TaskName,Package pkg,string [,]Pat_Sub)
        {
            try
            {
                Executables pExecs = pkg.Executables;
                foreach (Executable pExec in pExecs)
                {
                    TaskHost taskHost = (TaskHost)pExec;
                    if (taskHost.InnerObject is Microsoft.SqlServer.Dts.Tasks.ExecuteSQLTask.ExecuteSQLTask)
                    {

                        TaskHost execSqlTaskhost = (TaskHost)pExec;
                        IDTSExecuteSQL execSqlTask = (IDTSExecuteSQL)execSqlTaskhost.InnerObject;

                        if (execSqlTaskhost.Name.Equals(TaskName))
                        {
                            for (int iRow = 0; iRow <= Pat_Sub.GetUpperBound(0); iRow++)
                            {
                                if (Pat_Sub[iRow, 0] != null )
                                    execSqlTask.SqlStatementSource = execSqlTask.SqlStatementSource.Replace(Pat_Sub[iRow, 0], Pat_Sub[iRow, 1]);
                            }
                        }

                    }

                }
            }
            catch (Exception ex)
            {

                throw ex;
            }

        }


    }


}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\xereports\OLAPAutoBuild\OLAPAutoBuild.cs ===
using System;
using System.Collections.Generic;
using System.Text;
using System.IO;
using Microsoft.AnalysisServices;
using System.Collections;
using System.Collections.Specialized;
using System.Xml;
using System.Diagnostics;
using System.Data;
using System.Data.SqlClient;
using System.Threading;
using System.Net.Mail;

using xonline.common.mgmt;
using xonline.common.service;

[assembly: XomAreaDefinition(XomAreaName.log)]


// OLAPAutoBuild tool allows building OLAP objects like dimensions and cubes programmatically
// One of the input parameters is xml file that defines objects to build
// The tool must use .Net framework that is not part of CoreXT build environment yet. 
// When the build environment is updated the tool should be incorporated into the daily build.
// Classes like Tracer and NTEvent logger should be substituted by the xmgmt infrastructure.
namespace OLAPAutoBuild
{
    class OLAPAutoBuild
    {
        static int Main(string[] args)
        {
            int hresult = 0;
            BuildProcessor builder = new BuildProcessor();
            try
            {
                Config.Init(args);
                builder.Init();
                if (true == Config.outputXmlaMeasureModeSet)
                {
                builder.OutputXMLA(Config.destXmlaMeasureFilename, false);
              Xom.NtEvent( XEvent.Id.REPORTING_OLAPAUTOBUILD_INFO , "OLAPAutoBuild XMLA for measure group generation is completed");  
                }
                if (true == Config.outputXmlaDimensionModeSet)
                {
                builder.OutputXMLA(Config.destXmlaDimensionFilename, true);
              Xom.NtEvent( XEvent.Id.REPORTING_OLAPAUTOBUILD_INFO , "OLAPAutoBuild XMLA for dimension generation is completed");    
                }
                if (false == Config.outputXmlaMeasureModeSet && false == Config.outputXmlaDimensionModeSet)
                {
                builder.Process();
              Xom.NtEvent( XEvent.Id.REPORTING_OLAPAUTOBUILD_INFO , "OLAPAutoBuild processing is completed");
                }
            }
            catch (Exception e)
            {
                string message = "OLAPBuild failed. Exception thrown: " + e.ToString();
                Xom.Log(XomAreaName.log, message);

              Xom.NtEvent( XEvent.Id.REPORTING_OLAPAUTOBUILD_ERROR, "OLAPAutoBuild failed: "  + e.Message + ", Stack: " + e.StackTrace);
                hresult = -2147467259; // E_FAIL
            }
            finally
            {
                builder.Cleanup();
                Config.Cleanup();
            }
            return hresult;
        }
    }

    public class AutoBuildException: ApplicationException
    {
        public AutoBuildException ()
            :base() {}

        public AutoBuildException (string message)
            :base(message) 
        {        
            Xom.Log(XomAreaName.log, message);
        }

        public AutoBuildException (string message, Exception inner)
            :base(message, inner) 
        {
            Xom.Log(XomAreaName.log, message + "Inner exception: " + inner.ToString());
        }

        public AutoBuildException(string message, XEvent.Id eventId)
            : base(message)
        {
            switch ( eventId)
                {
                case XEvent.Id.REPORTING_OLAPAUTOBUILD_ERROR:
                  Xom.NtEvent( XEvent.Id.REPORTING_OLAPAUTOBUILD_ERROR , message );
                break;

                default:
                  Xom.NtEvent( XEvent.Id.REPORTING_OLAPAUTOBUILD_INFO , message );
                break;
                }
        } 
    }

    class Config
    {
        static public DateTime fromDate = DateTime.MinValue;
        static public DateTime toDate = DateTime.MaxValue;
        static public string xmlFileName = null;
        static public bool verboseLog = true;
        static public XmlDocument olapConfigXml = null;
        static public StringDictionary args = null;
        static public int waitForRdbMin = 0;
        static public string destXmlaMeasureFilename = null;
        static public string destXmlaDimensionFilename = null;
        static public bool outputXmlaMeasureModeSet = false;
        static public bool outputXmlaDimensionModeSet = false;
        static public string fileURI = @"file:\";

        static public string componentName = "OLAPAutoBuild";

        static public void Init(string[] input)
        {
            XomLoggingControl.Init();

            ParseInput(input);
            
            string message = "Running OLAPAutoBuild with the following parameters: \nfrom = " + fromDate.ToString() + ", to = " + toDate.ToString() +
                       ", xmlFile = " + xmlFileName + ", verbose = " + (verboseLog == true ? "TRUE" : "FALSE") + ", waitForRdbMin = " + waitForRdbMin.ToString() + ", destination XMLA measuregroup output = " + destXmlaMeasureFilename + ", destination XMLA dimension output = " + destXmlaDimensionFilename;
          Xom.NtEvent( XEvent.Id.REPORTING_OLAPAUTOBUILD_INFO, message);
            Xom.Log(XomAreaName.log, message);
        }
        static public void Cleanup()
        {
        }
        static private void ParseInput(string[] input)
        {
            args = new StringDictionary();
            foreach (string inputVal in input)
            {
                string[] values = inputVal.Split(':');
                if (values.Length == 2 && values[0].StartsWith("/"))
                {
                    args.Add(values[0].Substring(1).ToLower(), values[1].ToLower());
                } 
            }
            fromDate = args["from"] == null ? DateTime.Today.AddDays(-1) : DateTime.Parse(args["from"]);
            toDate = args["to"] == null ? fromDate.AddDays(1) : DateTime.Parse(args["to"]);
            if (fromDate >= toDate)
            {
                throw new ApplicationException("Invalid data range");
            }
            if (args["xml"] == null)
            {
                Usage();
                throw new ApplicationException("Invalid input. xml switch is not found");
            }
            xmlFileName = args["xml"];
            try
            {
                xmlFileName = Path.GetDirectoryName(System.Reflection.Assembly.GetExecutingAssembly().GetName().CodeBase)+ Path.DirectorySeparatorChar + xmlFileName; 
                olapConfigXml = new XmlDocument();
                XmlTextReader reader = new XmlTextReader(xmlFileName);
                reader.WhitespaceHandling = WhitespaceHandling.All;
                olapConfigXml.Load(reader);
            }
            catch (Exception e)
            {
                throw new ApplicationException("Unable to load xml config file. File name: " + xmlFileName + " Exception thrown: " + e.ToString());
            }
            
            destXmlaMeasureFilename = args["measurexmlapath"];
            if (destXmlaMeasureFilename != null)
            {
                try
                {
                     destXmlaMeasureFilename = Path.GetDirectoryName(System.Reflection.Assembly.GetExecutingAssembly().GetName().CodeBase)+ Path.DirectorySeparatorChar + destXmlaMeasureFilename; 
                     if (destXmlaMeasureFilename.StartsWith(fileURI))
                     {
                         destXmlaMeasureFilename = destXmlaMeasureFilename.Substring(fileURI.Length);
                     }
                }
                catch (Exception e)
                {
                    throw new ApplicationException("Unable to set XMLA output file name. File name: " + destXmlaMeasureFilename + " Exception thrown: " + e.ToString());
                }
            }    
            destXmlaDimensionFilename = args["dimensionxmlapath"];
            if (destXmlaDimensionFilename != null)
            {
                try
                {
                     destXmlaDimensionFilename = Path.GetDirectoryName(System.Reflection.Assembly.GetExecutingAssembly().GetName().CodeBase)+ Path.DirectorySeparatorChar + destXmlaDimensionFilename; 
                     if (destXmlaDimensionFilename.StartsWith(fileURI))
                     {
                         destXmlaDimensionFilename = destXmlaDimensionFilename.Substring(fileURI.Length);
                     }
                }
                catch (Exception e)
                {
                    throw new ApplicationException("Unable to set XMLA output file name. File name: " + destXmlaDimensionFilename + " Exception thrown: " + e.ToString());
                }
            }  
                       
            outputXmlaMeasureModeSet = (destXmlaMeasureFilename != null);   
            outputXmlaDimensionModeSet = (destXmlaDimensionFilename != null);
            if (args["verbose"] != null && args["verbose"] == "yes")
            {
                verboseLog = true;
            }

            if (args["waitForRdbMin"] !=  null)
            {
                waitForRdbMin = Int32.Parse(args["waitForRdbMin"]);
                waitForRdbMin = waitForRdbMin >= 1200? 1200 : waitForRdbMin; // do not wait more than 20 hours 
            }
        }
 
        static void Usage()
        {
            string usage = "OLAPAutoBuild tool allows to build OLAP cubes automatically.\nTo run specify the following format\nOLAPAutoBuild.exe /from:<date> /to:<date> /xml:<olapconfig> /verbose:<yes/no> \n/waitForRdbMin:<interval in minutes to wait for reportingdb processing, default is 0>. \n/measurexmlapath:<name for xmla file to be generated to make measure groups.> /dimensionxmlapath:<name for xmla file to be generated to make dimensions groups.> \nWARNING: THE CUBE WILL NOT BE PROCESSED IF EITHER OR BOTH OF THE XMLA GENERATING FLAGS ARE SET";
            Xom.Log(XomAreaName.log, usage);
            Console.WriteLine(usage);
        }

    }
    
    class BuildProcessor
    {
        public void Init()
        {
            // establish connection to the OLAP db
            Connect();
            command.Init(maxBatchParallel);
            dimensionCommand.Init(maxBatchParallel);
            // parse config xml
            ParseConfigXml();
        }

        public void Cleanup()
        {
            // cleanup connection to the olap db
            SetSessionTraceOff(olapServer);
            olapServer.Disconnect();
            string logLine = "Disconnected from database " + olapDbName + " on server " + olapServerMachineName;
            Xom.Log(XomAreaName.log, logLine);
        }

        public void OutputXMLA(string destPath, bool outputDimension)
        {
            try
            {
                System.IO.StreamWriter sr = new StreamWriter(destPath);
                if (true == outputDimension)
                {
                sr.WriteLine(dimensionCommand.GetXmlaCommand());
                }
                else
                {
                sr.WriteLine(command.GetXmlaCommand());
                }
                sr.Close();
            }
            catch(Exception cantWriteException)
            {
                throw new AutoBuildException("Unable to write command to file: " + destPath + ", with error:" + cantWriteException.Message, XEvent.Id.REPORTING_OLAPAUTOBUILD_ERROR);
            }
        }
        
        public void Process()
        {
            if (IsReadyForProcessing())
            {
                MarkProcessingStarted();

                // XE 114392 - use XMLA to process dimensions and not .Process()
                /*
                foreach (OlapObject obj in dimensions)
                {
                    obj.Process();
                }
                */
                
                ExecuteXMLA(dimensionCommand.GetXmlaCommand());
                //ProcessCube();
                ExecuteXMLA(command.GetXmlaCommand());
                
                MarkProcessingComplete(true);

                try
                {
                    SendCompletionMail();
                }
                catch
                {
                    string logLine = "The cube has been processed. However, we failed to send completion mail." ;
                    Xom.Log(XomAreaName.log, logLine);
                }
            }
            else
            {
                string message = "The cube has not been processed. Relational database does not contain all data required cube processing. Time range for the processing from " + Config.fromDate + " to: " + Config.toDate;
                throw new AutoBuildException(message, XEvent.Id.REPORTING_OLAPAUTOBUILD_ERROR);
            }
        }

        public void ExecuteXMLA(string cmd)
        {
            string logLine = "Sending the following xmla command to the server:\n" + cmd;
            Xom.Log(XomAreaName.log, logLine);  

            XmlaResultCollection resColl = olapServer.Execute(cmd);
            int errorCount = 0;
            int warningCount = 0;
            foreach (XmlaResult res in resColl)
            {
                foreach (XmlaMessage msg in res.Messages)
                {
                    if (msg is XmlaError)
                    {
                        errorCount++;
                      Xom.NtEvent( XEvent.Id.REPORTING_OLAPAUTOBUILD_ERROR,  "Processing failed. Error message returned: " + msg.Description);                         
                    }
                    else if (msg is XmlaWarning)
                    {
                        warningCount++;
                        logLine = "Warning during the processing: " + msg.Description;
                        Xom.Log(XomAreaName.log, logLine);
                    }
                }
            }
            if (errorCount > 0)
            {
                MarkProcessingComplete(false);
                throw new AutoBuildException("Processing failed. Number of errors found: " + errorCount, XEvent.Id.REPORTING_OLAPAUTOBUILD_ERROR);
            }

        }

        public BuildProcessor()
        {
            olapServer = new Server();
            olapDb = new Database();
            //dimensions = new ArrayList();
            partitions = new ArrayList();
            command = new XmlaCommand();
            dimensionCommand = new XmlaCommand();
        }
        private void Connect()
        {
            string logLine;
            try
            {
                olapServerMachineName = ReadXmlNode("OLAPServer/@machineName");
                olapDbName = ReadXmlNode("OLAPServer/@databaseName");
                if (olapServerMachineName == null || olapDbName == null)
                {
                    throw new ApplicationException("Cannot determine OLAP server name or and OLAP database name. Check supplied xml");
                }

                olapServer.Connect(olapServerMachineName);
                olapDb = olapServer.Databases.FindByName(olapDbName);
                if (olapDb == null)
                {
                    throw new AutoBuildException("Unable to connect to OLAP database " + olapDbName + " on " + olapServerMachineName, XEvent.Id.REPORTING_OLAPAUTOBUILD_ERROR);
                }

                
                // build connection string
                for (int i = 0; i < olapDb.DataSources.Count; i++)
                {
                // need to find reportingdb to verify whether processing can commence

                    if( (olapDb.DataSources[i].Name.ToLower()) != "reportingdb" )
                    {
                        continue;
                    }

                    string[] connectionParams = olapDb.DataSources[i].ConnectionString.Split(';');
                    StringBuilder bldr = new StringBuilder();
                    foreach (string conn in connectionParams)
                    {                    
                        if (conn.StartsWith("Data Source"))
                        {
                            bldr.Append(conn);
                        }
                        else if (conn.StartsWith("Integrated Security"))
                        {
                            bldr.Append(conn);
                        }
                        else if (conn.StartsWith("Initial Catalog"))
                        {
                            bldr.Append(conn);
                        }
                        bldr.Append(";");
                    }
                    reportingDbConnectionString = bldr.ToString();
                    logLine = "Reportingdb connection string: " + reportingDbConnectionString;
                    Xom.Log(XomAreaName.log, logLine);

                }
                if(reportingDbConnectionString == null)
                {
                    throw new ApplicationException("Unable to build reportingdb connection string. Check supplied xml");
                }
                
                SetSessionTraceOn(olapServer);
                logLine = "Connection established with database " + olapDbName + " on server " + olapServerMachineName;
                Xom.Log(XomAreaName.log, logLine);


                maxBatchParallel = ReadXmlNode("OLAPServer/@MaxParallel");
            }
            catch
            {
                throw new AutoBuildException("Unable to establish connection with server: " + olapServerMachineName + " database: " + olapDbName, XEvent.Id.REPORTING_OLAPAUTOBUILD_ERROR);
            }
        }
        
        private bool IsReadyForProcessing()
        {

            int sleepIntervalMin = 10;
            int iMaxWait = Config.waitForRdbMin/sleepIntervalMin; 
            string logLine;
            
            DateTime dt = new DateTime();
            for (int i = 0; i <= iMaxWait; i++)
            {
                using (SqlConnection reportingDBConnection = new SqlConnection(reportingDbConnectionString))
                {
                    reportingDBConnection.Open();

                    SqlCommand cmd = reportingDBConnection.CreateCommand();
                    // read all messages
                    cmd.CommandText = "p_get_processing_time";
                    cmd.CommandType = CommandType.StoredProcedure;
                    cmd.Parameters.Add("@vc_ssas_db_name", SqlDbType.VarChar).Value = olapDbName;

                    SqlDataReader reader = cmd.ExecuteReader();
                    if(reader.Read())
                    {
                        dt = (DateTime) reader["dt_data_ready"];
                    }
                }
                if (dt >= Config.toDate.AddDays(-1))
                {
                    return true;
                }

                if (i == iMaxWait)
                {
                    logLine = "Waiting time for reportingDB expired. Fail to start processing for date range: " + Config.fromDate + " - " + Config.toDate +
                    " because reportingDb returns date: " + dt + "\n Retrying in " + sleepIntervalMin + " min. ";
                    Xom.Log(XomAreaName.log, logLine);
                    break;
                }
                logLine = "Waiting for reportingDB. Cannot start processing for date range: " + Config.fromDate + " - " + Config.toDate +
                    " because reportingDb returns date: " + dt + "\n Retrying in " + sleepIntervalMin + " min. ";
                Xom.Log(XomAreaName.log, logLine);
                Thread.Sleep(sleepIntervalMin*60*1000);

            }
            return false;
        }

        private void MarkProcessingStarted()
        {
            using (SqlConnection reportingDBConnection = new SqlConnection(reportingDbConnectionString))
            {
                reportingDBConnection.Open();
            
                SqlCommand cmd = reportingDBConnection.CreateCommand();
                // read all messages
                cmd.CommandText = "p_daily_processing_olap_start";
                cmd.CommandType = CommandType.StoredProcedure;
                cmd.Parameters.Add("@vc_cube", SqlDbType.VarChar).Value = olapDbName;
                cmd.Parameters.Add("@dt_current_day", SqlDbType.DateTime ).Value = Config.toDate.AddDays(-1);
                SqlDataReader reader = cmd.ExecuteReader();
            }
        }

        private void MarkProcessingComplete(bool successVal)
        {
            using (SqlConnection reportingDBConnection = new SqlConnection(reportingDbConnectionString))
            {
                reportingDBConnection.Open();
            
                SqlCommand cmd = reportingDBConnection.CreateCommand();
                // read all messages
                cmd.CommandText = "p_daily_processing_olap_complete";
                cmd.CommandType = CommandType.StoredProcedure;
                cmd.Parameters.Add("@vc_cube", SqlDbType.VarChar).Value = olapDbName;
                cmd.Parameters.Add("@dt_current_day", SqlDbType.DateTime ).Value = Config.toDate.AddDays(-1);
                if (false == successVal)
                {
                   cmd.Parameters.Add("@i_success_val", SqlDbType.Int ).Value = 0; 
                }
                SqlDataReader reader = cmd.ExecuteReader();
            }
        }

        private void SendCompletionMail()
        {
            XmlNode node = Config.olapConfigXml.DocumentElement.SelectSingleNode("MailConfig");

            if (null != node && null != node.SelectSingleNode("SMTPHost"))
            {
                SmtpClient smtpClient = new SmtpClient(node.SelectSingleNode("SMTPHost").InnerXml);

                string addrFrom = node.SelectSingleNode("FromAddress").InnerXml;
                string addrFromName = node.SelectSingleNode("FromName").InnerXml;
                string addrTo = node.SelectSingleNode("ToAddress").InnerXml;
                string subject = node.SelectSingleNode("Subject").InnerXml;
                string body = node.SelectSingleNode("Body").InnerXml;

                string logLine = "Sending completion mail.";
                Xom.Log(XomAreaName.log, logLine);

                MailAddress from = new MailAddress(addrFrom, addrFromName);
                MailAddress to = new MailAddress(addrTo);
                MailMessage msg = new MailMessage(from, to);
                msg.Subject = string.Format(subject, Config.toDate.AddDays(-1).ToShortDateString());
                msg.Body = body;

                smtpClient.Send(msg);
            }
        }
     
        private string ReadXmlNode(string name)
        {
            if (Config.olapConfigXml == null)
            {
                return null;
            }
            XmlNode node = Config.olapConfigXml.DocumentElement;
            return node.SelectSingleNode(name) == null ? null : node.SelectSingleNode(name).InnerXml;
        }

        private void ParseConfigXml()
        {
            bool buildAllDimensions = true;

            XmlNode node = Config.olapConfigXml.DocumentElement;           
            foreach (XmlNode xNode in node.SelectNodes("Process"))
            {
                // read processing type for the current object
                if (xNode.SelectSingleNode("Type") == null)
                {
                    throw new AutoBuildException("Failed to find ProcessType node" + ", database: " + olapDb.Name + " Check xml configuration file", XEvent.Id.REPORTING_OLAPAUTOBUILD_ERROR);
                }
                string processType = xNode.SelectSingleNode("Type").InnerText;
                /*
                ProcessType type;
                switch (processType.ToLower())
                {
#if SUPPORT_PROCESSADD
                    case "processadd":
                        type = ProcessType.ProcessAdd;
                        break;
#endif
                    case "processfull":
                        type = ProcessType.ProcessFull;
                        break;
                    case "processupdate":
                        type = ProcessType.ProcessUpdate;
                        break;
                    default:
                        throw new AutoBuildException("Invalid process type: " + processType  + " in the database: " + olapDb.Name + " Check xml configuration file");                        
                }
                */
                XmlNodeList cubeNames = xNode.SelectNodes("Object/CubeName");
                if (cubeNames.Count > 1)
                {
                    throw new AutoBuildException("Multiple cube names specified in the Process node. Check xml configuration file");
                }
                XmlNodeList mgNames = xNode.SelectNodes("Object/MeasureGroupName");
                if (cubeNames.Count == 0 && mgNames.Count > 0)
                {
                    throw new AutoBuildException("CubeName is missing for building MeasureGroups. Check xml configuration file");
                }

                // if CubeName is present, then find all measure groups to build
                if (xNode.SelectSingleNode("Object/CubeName") != null)
                {
                    string cubeName = null;
                    Cube cube = new Cube();
                    cubeName = xNode.SelectSingleNode("Object/CubeName").InnerXml;
                    cube = olapDb.Cubes.FindByName(cubeName);
                    if (cube == null)
                    {
                        throw new AutoBuildException("Failed to find cube: " + cubeName + " in the database: " + olapDb.Name + " Check xml configuration file", XEvent.Id.REPORTING_OLAPAUTOBUILD_ERROR);
                    }

                    // if no measures specified, build all measures
                    XmlNodeList mgList = xNode.SelectNodes("Object/MeasureGroupName");
                    if (mgList != null && mgList.Count > 0)
                    {
                        foreach (XmlNode xmlMg in mgList)
                        {
                            string mgName = xmlMg.InnerText;
                            MeasureGroup mg = cube.MeasureGroups.FindByName(mgName);
                            if (mg == null)
                            {
                                throw new AutoBuildException("Measure: " + mgName
                                    + " is not found in cube " + cubeName + " in the database: " + olapDb.Name + " Check xml configuration file", XEvent.Id.REPORTING_OLAPAUTOBUILD_ERROR);
                            }

                            ArrayList curPartitions = OLAPHelper.FindPartition(mg, Config.fromDate, Config.toDate);
                            foreach (Partition partition in curPartitions)
                            {
                                command.AddMeasureProcessNode(olapDb.ID, cube.ID, mg.ID, partition.ID, "ProcessFull");
                            }
                        }
                    }
                    else
                    {
                        foreach (MeasureGroup mg in cube.MeasureGroups)
                        {
                            ArrayList curPartitions = OLAPHelper.FindPartition(mg, Config.fromDate, Config.toDate);
                            foreach (Partition partition in curPartitions)
                            {
                                command.AddMeasureProcessNode(olapDb.ID, cube.ID, mg.ID, partition.ID, "ProcessFull");
                            }
                        }

                    }
                    command.CompleteCommand();   
                }
                // if DimensionName is present, then rebuild only specified dimension, default build all dimensions with ProcessUpdate type
                else 
                {
                    XmlNodeList dimList = xNode.SelectNodes("Object/DimensionName");
                    if (dimList != null)
                    {
                        buildAllDimensions = false;
                        foreach (XmlNode dimName in dimList)
                        {
                            Dimension dim = olapDb.Dimensions.FindByName(dimName.InnerText);
                            if (dim == null)
                            {
                                throw new AutoBuildException("Invalid dimension name: " + dimName.InnerText + " in the database: " + olapDb.Name + " Check xml configuration file", XEvent.Id.REPORTING_OLAPAUTOBUILD_ERROR);
                            }
                            dimensionCommand.AddDimensionProcessNode(olapDb.ID,processType,dim.ID);                            
                            //OlapObject obj = new OlapObject(type, dim);
                            //dimensions.Add(obj);
                        }
                        dimensionCommand.CompleteCommand();   
                    }
                    else
                    {
                        throw new AutoBuildException("Invalid object is found. It is not a dimension or measure group. Check xml configuration file", XEvent.Id.REPORTING_OLAPAUTOBUILD_ERROR);
                    }
                }
            }
            // if not specified, rebuild all dimensions
            if (buildAllDimensions == true)
            {
                // fill in container of objects to build
                foreach (Dimension dimension in olapDb.Dimensions)
                {
                    dimensionCommand.AddDimensionProcessNode(olapDb.ID,"ProcessUpdate",dimension.ID);
                    //OlapObject obj = new OlapObject(ProcessType.ProcessUpdate, dimension);
                    //dimensions.Add(obj);
                }
                dimensionCommand.CompleteCommand();   
            }
        }
#if SUPPORT_PROCESSADD
        private void FindPartitions(MeasureGroup mg, ProcessType type)
        {
            ArrayList curPartitions = OLAPHelper.FindPartition(mg, Config.fromDate, Config.toDate);
            // no incremental is allowed if time range spans between more than one partition

            if (type == ProcessType.ProcessAdd && curPartitions.Count > 0) 
            {
                Partition part = (Partition)curPartitions[0];
                // incremental updates possible for processed partitions only
                if (curPartitions.Count == 1 && part.State == AnalysisState.Processed)
                {                    
                    QueryBinding qb = (QueryBinding)part.Source;
                    qb.QueryDefinition += " and i_date >= " + OLAPHelper.Getidate(Config.fromDate) + " and i_date < " + OLAPHelper.Getidate(Config.toDate) ;
                    OlapObject obj = new OlapObject(type, part, qb);
                    partitions.Add(obj);
                    return;
                }
                else
                {
                    string logLine;
                    if (curPartitions.Count != 1)
                    {
                        logLine = "Time spans across multiple partitions. Cannot apply incremental build. Forcing full build. Measure group: " + mg.Name + " from: " + Config.fromDate + " to: " + Config.toDate;
                        Xom.Log(XomAreaName.log, logLine);
                    }
                    else if (part.State != AnalysisState.Processed)
                    {
                        logLine = "Partition: " + part.Name + " is not processed. Cannot apply incremental build. Performing full build"
                        Xom.Log(XomAreaName.log, logLine);
                    }
                    type = ProcessType.ProcessFull;
                }
            }
            
            foreach (Partition part in curPartitions)
            {
                OlapObject obj = new OlapObject(type, part);
                partitions.Add(obj);
            }
        }
#endif


        private void SetSessionTraceOn(Server svr)
        {
            if (svr.Connected && Config.verboseLog == true)
            {
                svr.SessionTrace.OnEvent
                        += new TraceEventHandler(DefaultTrace_OnEvent);
                svr.SessionTrace.Stopped
                    += new TraceStoppedEventHandler(DefaultTrace_Stopped);
                svr.SessionTrace.Start();
            }
        }
        private void SetSessionTraceOff(Server svr)
        {
            if (svr.Connected && Config.verboseLog == true)
            {
                svr.SessionTrace.Stop();
            }
        }

        private void DefaultTrace_OnEvent(object sender, TraceEventArgs e)
        {
            //skip empty lines
            if (e == null || e != null && e.TextData == null ) //e.TextData.Length == 0)
            {
                return;
            }
            string logLine = string.Format("SSAS({0}/{1}): {2}", e.ObjectID, e.JobID, e.TextData);
            Xom.Log(XomAreaName.log, logLine);
        }

        static void DefaultTrace_Stopped(ITrace sender, TraceStoppedEventArgs e)
        {
            switch (e.StopCause)
            {
                case TraceStopCause.StoppedByUser:
                case TraceStopCause.Finished:
                    break;

                case TraceStopCause.StoppedByException:
                    string logLine = "Processing failed: " + e.Exception.Message;
                    Xom.Log(XomAreaName.log, logLine);   
                  Xom.NtEvent( XEvent.Id.REPORTING_OLAPAUTOBUILD_ERROR, "Processing failed : " + e.Exception );
                    break;
            }
        }


        private Server olapServer;
        private Database olapDb;
        // dimension should be processed before cubes' parititions
        //private ArrayList dimensions;
        private ArrayList partitions;
        private XmlaCommand command;
        private XmlaCommand dimensionCommand;
        private string reportingDbConnectionString;
        private string olapServerMachineName;
        private string olapDbName;
        private string maxBatchParallel;
    }

    class XmlaCommand
    {
        public XmlaCommand()
        {
            ms = new MemoryStream();
            xmlaCommand = new XmlTextWriter(ms, null);
        }
        public void Init(string maxBatchParallel)
        {
            xmlaCommand.Formatting = Formatting.Indented;
            xmlaCommand.Indentation = 4;
            xmlaCommand.Namespaces = true;
            xmlaCommand.WriteStartElement("", "Batch", "http://schemas.microsoft.com/analysisservices/2003/engine");
            xmlaCommand.WriteStartElement("Parallel");
            if (maxBatchParallel != null)
            {
                xmlaCommand.WriteAttributeString("MaxParallel", maxBatchParallel);
            }
        }

        public void AddDimensionProcessNode(string databaseId, string processType, string dimensionId)
        {
            xmlaCommand.WriteStartElement("Process");
            xmlaCommand.WriteStartElement("Object");

            xmlaCommand.WriteStartElement("DatabaseID");
            xmlaCommand.WriteString(databaseId);
            xmlaCommand.WriteEndElement();
            
            xmlaCommand.WriteStartElement("DimensionID");
            xmlaCommand.WriteString(dimensionId);
            xmlaCommand.WriteEndElement();
            
            xmlaCommand.WriteEndElement(); // object

            xmlaCommand.WriteStartElement("Type");
            xmlaCommand.WriteString(processType);
            xmlaCommand.WriteEndElement();

            xmlaCommand.WriteStartElement("WriteBackTableCreation");
            xmlaCommand.WriteString("UseExisting");
            xmlaCommand.WriteEndElement();

            xmlaCommand.WriteEndElement(); // process
        }
        public void AddMeasureProcessNode(string databaseId, string cubeId, string measureId, string partitionId, string processType)
        {
            xmlaCommand.WriteStartElement("Process");
            xmlaCommand.WriteStartElement("Object");

            xmlaCommand.WriteStartElement("DatabaseID");
            xmlaCommand.WriteString(databaseId);
            xmlaCommand.WriteEndElement();

            xmlaCommand.WriteStartElement("CubeID");
            xmlaCommand.WriteString(cubeId);
            xmlaCommand.WriteEndElement();

            xmlaCommand.WriteStartElement("MeasureGroupID");
            xmlaCommand.WriteString(measureId);
            xmlaCommand.WriteEndElement();

            xmlaCommand.WriteStartElement("PartitionID");
            xmlaCommand.WriteString(partitionId);
            xmlaCommand.WriteEndElement();
            
            xmlaCommand.WriteEndElement(); // object

            xmlaCommand.WriteStartElement("Type");
            xmlaCommand.WriteString(processType);
            xmlaCommand.WriteEndElement();

            xmlaCommand.WriteStartElement("WriteBackTableCreation");
            xmlaCommand.WriteString("UseExisting");
            xmlaCommand.WriteEndElement();

            xmlaCommand.WriteEndElement(); // process
        }

        public void CompleteCommand()
        {
            xmlaCommand.WriteEndElement(); // Parallel 
            xmlaCommand.WriteEndElement();  // batch                              
            xmlaCommand.Flush();
        }

        public string GetXmlaCommand()
        {
            ms.Position = 0;
            StreamReader sr = new StreamReader(ms);
            return sr.ReadToEnd();
        }
        
        
        private XmlTextWriter xmlaCommand;
        private MemoryStream ms;
    }
    class OlapObject
    {
        public void Process()
        {
            // verify that the ProcessType is compatible with the object state and call .Process
            string logLine = "Starting processing for : " + processObj.Name + ". Processing type is " + processType;
            Xom.Log(XomAreaName.log, logLine);
            if (qb != null)
            {
                if (processType != ProcessType.ProcessAdd || processObj.GetType() != typeof(Partition) )
                {
                    throw new AutoBuildException("Invalid processType: " + processType + " for object: " + processObj.Name, XEvent.Id.REPORTING_OLAPAUTOBUILD_ERROR);
                }
                try
                {
                    processObj.Process(processType, qb);
                }
                catch (Exception e)
                {
                    logLine = "Unable to perform incremental build. Exception thrown: " + e.ToString() + " trying full build. Partition: " + processObj.Name;
                    Xom.Log(XomAreaName.log, logLine);
                    processObj.Process(ProcessType.ProcessFull);
                }
            }
            else
            {
                processObj.Process(processType);
            }
            logLine = "Completed processing for : " + processObj.Name;
            Xom.Log(XomAreaName.log, logLine);
        }

        public OlapObject(ProcessType processType, ProcessableMajorObject processObj)
        {
            this.processType = processType;
            this.processObj = processObj;
        }

        public OlapObject(ProcessType processType, ProcessableMajorObject processObj, QueryBinding qb)
        {
            this.processType = processType;
            this.processObj = processObj;
            this.qb = qb;
        }

        private ProcessType processType;
        private ProcessableMajorObject processObj;
        private QueryBinding qb;
    }

    class OLAPHelper
    {
        static public int Getidate(DateTime date)
        {
            return (int)date.Year * 10000 + (int)date.Month * 100 + (int)date.Day;
        }
        
        //For the percentage partition, we need to run the previous month as well
        public static String PERCENTAGE_PARTITION_PREFIX = "PPC_";
        static public ArrayList FindPartition(MeasureGroup mes, DateTime from, DateTime to)
        {
            ArrayList partitions = new ArrayList();
            ArrayList suffixesMon = new ArrayList();
            ArrayList suffixesQ = new ArrayList();
            ArrayList suffixesWeekly = new ArrayList();
            ArrayList suffixesSemiMonthly = new ArrayList();
            ArrayList suffixesPrevMon = new ArrayList();
            
            DateTime oneMonthBack = from.AddMonths(-1);
            StringBuilder previousMonth = new StringBuilder();
            previousMonth.Append(oneMonthBack.Year);
            previousMonth.Append("_");
            previousMonth.Append(string.Format("{0:D2}", oneMonthBack.Month));
            suffixesPrevMon.Add(previousMonth);
            
            DateTime toDate = to.AddDays(-1);

            for(int year = from.Year; year <= toDate.Year; year++)
            {
                StringBuilder curSuffixMon = new StringBuilder();
                curSuffixMon.Append(year);
                curSuffixMon.Append("_");

                StringBuilder curSuffixQ = new StringBuilder();
                curSuffixQ.Append(year);
                curSuffixQ.Append("_");
                
                StringBuilder curSuffixWk = new StringBuilder();
                curSuffixWk.Append(year);
                curSuffixWk.Append("_");

                for (int month = 1; month <= 12; month++)
                {
                    if (year == from.Year && month < from.Month)
                    {
                        continue;
                    }
                    if (year == toDate.Year && month > toDate.Month)
                    {
                        break;
                    }
                    StringBuilder curSuffix = new StringBuilder(curSuffixMon.ToString());
                    curSuffix.Append(string.Format("{0:D2}", month));
                    suffixesMon.Add(curSuffix);
                    
                    StringBuilder cursuffixWeekly = null;
                    StringBuilder curSuffixSemiMonthly = null;
                    //add the semimonthly suffixes
                    for (int i =0; i< 2; i++)
                    {
                        if (year == from.Year && month == from.Month && from.Day > 14)
                        {
                            curSuffixSemiMonthly = new StringBuilder(curSuffix.ToString());
                            curSuffixSemiMonthly.Append("_15");
                            suffixesSemiMonthly.Add (curSuffixSemiMonthly);
                            break;
                        }
                        
                        if (year == toDate.Year && month == toDate.Month && toDate.Day <14)
                        {
                            curSuffixSemiMonthly = new StringBuilder(curSuffix.ToString());
                            curSuffixSemiMonthly.Append("_01");
                            if (!suffixesSemiMonthly.Contains(curSuffixSemiMonthly))
                            {
                                suffixesSemiMonthly.Add (curSuffixSemiMonthly);
                            }
                            break;
                        }
                        
                        curSuffixSemiMonthly = new StringBuilder(curSuffix.ToString());
                        curSuffixSemiMonthly.Append(string.Format("_{0:D2}", 1+14*i));
                        suffixesSemiMonthly.Add (curSuffixSemiMonthly);
                    }
                    //add the weekly suffixes. They are of the form
                    // {prefix}_YYYY_MM_{1,8,15,22}_{8,15,22,<last day of month>}
                    int DaysInCurrMonth = System.DateTime.DaysInMonth(year, month);
                    for (int i =0; i< 4; i++)
                    {
                        int firstDate = 1+(7*i);
                        //end of period is either (i+1) * 7 or the last day of the month, see partitioncreationtool.cs
                        int secondDate = i != 3? 1 + ((i+1)* 7):DaysInCurrMonth;
                        //Logic: Unless we are at the first or last month, make the 4 weekly partitions.
                        //First month edge case: Create all partitions where the end date is >= the day (skip if <)
                        if (year == from.Year && month == from.Month && from.Day > secondDate)
                        {
                            continue;
                        }
                        //Last month edge case: Create partitions where the start date is <= the day (skip if >) 
                        if (year == toDate.Year && month == toDate.Month && toDate.Day < firstDate)
                        {
                            continue;
                        }
                                              
                        cursuffixWeekly = new StringBuilder(curSuffix.ToString());
                        cursuffixWeekly.Append(string.Format("_{0:D2}_{1:D2}", firstDate,secondDate));                        
                        suffixesWeekly.Add (cursuffixWeekly);                                                                   
                    }
                        
                }

                for (int quater = 1; quater <= 4; quater++)
                {
                    if (year == from.Year && quater < (from.Month-1)/3 + 1)
                    {
                        continue;
                    }
                    if (year == toDate.Year && quater > (toDate.Month-1) /3 + 1)
                    {
                        break;
                    }
                    
                    StringBuilder curSuffix = new StringBuilder(curSuffixQ.ToString());
                    curSuffix.Append("q"+quater);
                    suffixesQ.Add(curSuffix);
                }

                }
            
            foreach (Partition part in mes.Partitions)
            {
                foreach (StringBuilder suffixMon in suffixesMon)
                {
                    if (part.Name.ToLower().EndsWith(suffixMon.ToString().ToLower()))
                    {
                        partitions.Add(part);
                    }
                }
                foreach (StringBuilder suffixQ in suffixesQ)
                if (part.Name.ToLower().EndsWith(suffixQ.ToString().ToLower()))
                {
                    partitions.Add(part);
                }

                foreach (StringBuilder suffixBiW in suffixesSemiMonthly)
                if (part.Name.ToLower().EndsWith(suffixBiW.ToString().ToLower()))
                {
                    partitions.Add(part);
                }
                
                foreach (StringBuilder suffixWky in suffixesWeekly)
                {
                if (part.Name.ToLower().EndsWith(suffixWky.ToString().ToLower()))
                {                                        
                    partitions.Add(part);
                }
                }     
                if (part.Name.ToLower().StartsWith(PERCENTAGE_PARTITION_PREFIX))
                {
                    foreach (StringBuilder suffixPrMon in suffixesPrevMon)
                    {
                        if (part.Name.ToLower().EndsWith(suffixPrMon.ToString().ToLower()))
                        {                                        
                        partitions.Add(part);
                        }
                    }     
                }        
            }
 
            return partitions;
        }
        
        static public Dimension FindDimension(string name)
        {
            return null;
        }
    }

}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\xereports\GenerateSSIS\SplitTask.cs ===
using System;
using System.Text;
using GenerateDTS.Common;
using Microsoft.SqlServer.Dts.Pipeline.Wrapper;
using dtr = Microsoft.SqlServer.Dts.Runtime.Wrapper;
using Microsoft.SqlServer.Dts.Runtime;
using Microsoft.SqlServer.Dts.Tasks.ExecuteSQLTask;
using System.Collections;


namespace GenerateDTS
{
    class SplitTask
    {
        public void modifySplitTask(Package pkg, string DataFlowTaskName, string SplitTaskName,string KeyColName,string OutPutPathName,ArrayList ColumnName,string UserExpression )
        {

            IDTSComponentMetaData90 Split = null;
            MainPipe dataFlow;
            Executable exe;

            try
            {
                exe = pkg.Executables[DataFlowTaskName];
                TaskHost th2 = exe as TaskHost;
                dataFlow = th2.InnerObject as MainPipe; // getting the datatflow task

                // getting the lookup task which belongs to the dataflow task
                foreach (IDTSComponentMetaData90 comp in dataFlow.ComponentMetaDataCollection)
                    if (comp.Name.ToLower() == SplitTaskName.ToLower())
                        Split = comp;

                CManagedComponentWrapper instanceSplit = Split.Instantiate();

                //Initialize the connection
                instanceSplit.AcquireConnections(null);
                instanceSplit.ReinitializeMetaData();
                instanceSplit.ReleaseConnections();


                IDTSInput90 input = Split.InputCollection[0];
                IDTSVirtualInput90 vInput = input.GetVirtualInput();
                IDTSInputColumn90 vCol = null;

                // Set the col mapping aginst the lookup.
                foreach (IDTSVirtualInputColumn90 vColumn in vInput.VirtualInputColumnCollection)
                {
                    if (ColumnName.Contains(vColumn.Name))
                    {
                        vCol = instanceSplit.SetUsageType(input.ID, vInput, vColumn.LineageID, DTSUsageType.UT_READONLY);
                        // Set the output for insert and update
                        IDTSOutput90 output = Split.OutputCollection[OutPutPathName];
                        output.CustomPropertyCollection["Expression"].Value = UserExpression.Replace(vColumn.Name, vCol.LineageID.ToString());
                        output.CustomPropertyCollection["FriendlyExpression"].Value = UserExpression;

                        //output = Split.OutputCollection["Insert"];
                        //output.CustomPropertyCollection["Expression"].Value = @"ISNULL(" + vCol.LineageID.ToString() + ")";
                        //output.CustomPropertyCollection["FriendlyExpression"].Value = @"ISNULL(WorkflowStateId)";
                    }
                }

            }
            catch (Exception ex)
            {
                Console.WriteLine(ex.Message);
                throw ex;
            }
        }

    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\xereports\OLAPPartitionTool\makefile.inc ===
!include $(INETROOT)\build\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\xereports\OLAPPartitionTool\obj\i386\_generated.cs ===
[assembly:System.Runtime.InteropServices.ComVisible(false)]
[assembly:System.Reflection.AssemblyVersion("12.4.56.0")]
[assembly:System.Reflection.AssemblyProduct("Microsoft(R) Xbox(TM)")]
[assembly:System.Reflection.AssemblyCopyright("Copyright (c) Microsoft Corporation. All rights reserved.")]
[assembly:System.Reflection.AssemblyCompany("Microsoft Corporation")]
[assembly:System.Reflection.AssemblyFileVersion("12.4.56.0")]
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\xereports\OLAPPartitionTool\objd\i386\_generated.cs ===
[assembly:System.Runtime.InteropServices.ComVisible(false)]
[assembly:System.Reflection.AssemblyVersion("12.4.56.0")]
[assembly:System.Reflection.AssemblyProduct("Microsoft(R) Xbox(TM)")]
[assembly:System.Reflection.AssemblyCopyright("Copyright (c) Microsoft Corporation. All rights reserved.")]
[assembly:System.Reflection.AssemblyCompany("Microsoft Corporation")]
[assembly:System.Reflection.AssemblyFileVersion("12.4.56.0")]
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\xereports\PartitionCreationTool\obj\i386\_generated.cs ===
[assembly:System.Runtime.InteropServices.ComVisible(false)]
[assembly:System.Reflection.AssemblyVersion("12.4.56.0")]
[assembly:System.Reflection.AssemblyProduct("DEPOT")]
[assembly:System.Reflection.AssemblyCopyright("")]
[assembly:System.Reflection.AssemblyCompany("")]
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\xereports\OLAPPartitionTool\obj\i386\_asmid.inc ===
ASSEMBLY_IDENTITY_KEY_FORM=msil_olappartitiontool_none_12.4.56.0_none_646e976c3fa428cf
ASSEMBLY_IDENTITY_XP_KEY_FORM=msil_olappartitiontool_no-public-key_12.4.56.0_x-ww_49724339
ASSEMBLY_IDENTITY_CULTURE=
ASSEMBLY_IDENTITY_NAME=olappartitiontool
ASSEMBLY_IDENTITY_PROCESSOR_ARCHITECTURE=msil
ASSEMBLY_IDENTITY_PUBLIC_KEY=
ASSEMBLY_IDENTITY_PUBLIC_KEY_TOKEN=
ASSEMBLY_IDENTITY_TYPE=
ASSEMBLY_IDENTITY_TYPE_NAME=
ASSEMBLY_IDENTITY_VERSION=12.4.56.0
XP_KEY_FORM=msil_olappartitiontool_no-public-key_12.4.56.0_x-ww_49724339
XP_MANIFEST_DIRECTORY=manifests
XP_MANIFEST_NAME=msil_olappartitiontool_no-public-key_12.4.56.0_x-ww_49724339.manifest
XP_MANIFEST_PATH=manifests\msil_olappartitiontool_no-public-key_12.4.56.0_x-ww_49724339.manifest
XP_CATALOG_DIRECTORY=manifests
XP_CATALOG_NAME=msil_olappartitiontool_no-public-key_12.4.56.0_x-ww_49724339.cat
XP_CATALOG_PATH=manifests\msil_olappartitiontool_no-public-key_12.4.56.0_x-ww_49724339.cat
XP_PAYLOAD_PATH=msil_olappartitiontool_no-public-key_12.4.56.0_x-ww_49724339
_DELAY_SIGN=0
!if [set _ASMIDTOATTRIBS_TLBIMP=]
!endif
CODESIGN_TESTKEY=
_TLBIMP_FLAGS=$(_TLBIMP_FLAGS)  /asmversion:12.4.56.0
_ASSEMBLY_IDENTITY=olappartitiontool,processorArchitecture=msil,version=12.4.56.0,publicKeyToken=neutral
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\xereports\PartitionCreationTool\objd\i386\_generated.cs ===
[assembly:System.Runtime.InteropServices.ComVisible(false)]
[assembly:System.Reflection.AssemblyVersion("12.4.56.0")]
[assembly:System.Reflection.AssemblyProduct("DEPOT")]
[assembly:System.Reflection.AssemblyCopyright("")]
[assembly:System.Reflection.AssemblyCompany("")]
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\xereports\OLAPPartitionTool\Program.cs ===
using System;
using System.Collections.Generic;
using System.Text;
using Microsoft.AnalysisServices;

namespace OLAPPartitionTool
{
    class Idate
    {        
        static public int GetIdate(DateTime date)
        {            
            return (int)date.Year * 10000 + (int)date.Month * 100 + (int)date.Day;
        }
        static public int AddMonthIdate(DateTime date)
        {
            DateTime nextMonth = date.AddMonths(1);
            return GetIdate(nextMonth);
        }
        static public int AddQuaterIdate(DateTime date)
        {
            DateTime nextQuater = date.AddMonths(3);
            return GetIdate(nextQuater);
        }
        static public DateTime GetDate(int idate)
        {
            int day = idate % 100;
            int month = ((idate - day)/100) % 100;
            int year = (idate - month * 100 - day) / 10000;
            return new DateTime(year, month, day);
        }

        static public int AddSemiMonthIdate(DateTime date)
        {
            DateTime dt = date;
            switch (dt.Day)
            {
                case 1: 
                    dt= dt.AddDays(14);
                    break;
                case 15:
                    dt = dt.AddDays(DateTime.DaysInMonth(dt.Year, dt.Month)-15+1); //first of the next month
                    break;
                default:
                    throw new Exception("Invalid day for semi monthly partitions");
            }
                return GetIdate(dt);
        }
        
        static public string GetSuffix(DateTime date, string partSize)
        {
            switch (partSize.ToLower())
            {
                case "mm":
                    if (date.Month < 10)
                        return "_" + (int)date.Year + "_" + "0" + (int)date.Month;
                    else return "_" + (int)date.Year + "_" + (int)date.Month;
                case "qq":
                    int q;
                    switch (date.Month)
                    {
                        case 1:
                            q = 1;
                            break;
                        case 4:
                            q = 2;
                            break;
                        case 7:
                            q = 3;
                            break;
                        case 10:
                            q = 4;
                            break;
                        default:
                            throw new Exception("Invalid quater parameter");
                    }
                    return "_" + (int)date.Year + "_Q" + q;                  

                case "w2":
                {
                    StringBuilder curSuffix = new StringBuilder();
                    curSuffix.Append(string.Format("_{0:D4}", date.Year));
                    curSuffix.Append(string.Format("_{0:D2}", date.Month));
                    curSuffix.Append(string.Format("_{0:D2}", date.Day));

                    return curSuffix.ToString();
                }
              default:
                    throw new Exception("Unknown partition size");
            }
        }
    }
    class Program
    {
        static void Main(string[] args)
        {
            if (args.Length != 8)
            {
                Usage();
                return;
            }

            string dbName =  args[0];
            string cubeName = args[1];
            string measureGroup = args[2];
            DateTime fromDate = DateTime.Parse(args[3]);            
            int numOfPart = Convert.ToInt16(args[4]);
            string partSize = args[5];
            string queryTemplate = args[6];
            string partPrefix = args[7];

            Console.WriteLine("OLAPPartitionTool input:\nOlapDbName = {0}\nCubeName = {1}\nmeasureGroup = {2}\nfromDate = {3}", dbName, cubeName, measureGroup, fromDate);
            Console.WriteLine("numberOfPartitions = {0}\npartitionSize = {1}\nqueryTemplate = {2}", numOfPart, partSize, queryTemplate);
            Console.WriteLine("partitionNamePrefix = {0}", partPrefix);
     
            using (Server svr = new Server())
            {
                svr.Connect("localhost");
                Database db = svr.Databases.FindByName(dbName);

                Cube cb = db.Cubes.GetByName(cubeName);
                MeasureGroup mg = cb.MeasureGroups.GetByName(measureGroup);

                int iToDate;
                int iFromDate = Idate.GetIdate(fromDate);
                for (int i = 0; i< numOfPart; i++)
                {                    
                    switch (partSize)
                    {
                        case "mm":
                            iToDate = Idate.AddMonthIdate(fromDate);
                            break;
                        case "qq":
                            iToDate = Idate.AddQuaterIdate(fromDate);
                            break;
                        case "w2":
                            iToDate = Idate.AddSemiMonthIdate(fromDate);
                            break;
                        default:
                            throw new Exception("Unknown partition size");
                    }
                    string suffix = Idate.GetSuffix(fromDate, partSize);
                    string query = queryTemplate + " WHERE i_date>=" + iFromDate + " AND i_date<" + iToDate;
                    
                    string partName = partPrefix + suffix;
                    if (mg.Partitions.FindByName(partName)!=null )
                    {
                        mg.Partitions.Remove(partName);
                    }
                    Partition part = mg.Partitions.Add(partName);
                    part.StorageMode = StorageMode.Molap;                    
                    part.Source = new QueryBinding(cb.DataSource.ID, query);
                    Console.WriteLine("Adding partition: {0} to measure group {1}", partName, mg.Name);
                    fromDate = Idate.GetDate(iToDate);
                    iFromDate = iToDate;
                }
                cb.Update(UpdateOptions.ExpandFull);
            }
        }
        static public void Usage()
        {
            Console.WriteLine("OLAPPartitionTool adds new partitions to a specified cube\n\n");
            Console.WriteLine("Usage: OLAPPartitionTool <OLAPDBName> <CubeName> <MeasureGroup> <FromDate> <PartitionsNumber> <PartSize = qq, mm> <ViewName> <PartitionPrefix>");
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\xereports\OLAPPartitionTool\objd\i386\_asmid.inc ===
ASSEMBLY_IDENTITY_KEY_FORM=msil_olappartitiontool_none_12.4.56.0_none_646e976c3fa428cf
ASSEMBLY_IDENTITY_XP_KEY_FORM=msil_olappartitiontool_no-public-key_12.4.56.0_x-ww_49724339
ASSEMBLY_IDENTITY_CULTURE=
ASSEMBLY_IDENTITY_NAME=olappartitiontool
ASSEMBLY_IDENTITY_PROCESSOR_ARCHITECTURE=msil
ASSEMBLY_IDENTITY_PUBLIC_KEY=
ASSEMBLY_IDENTITY_PUBLIC_KEY_TOKEN=
ASSEMBLY_IDENTITY_TYPE=
ASSEMBLY_IDENTITY_TYPE_NAME=
ASSEMBLY_IDENTITY_VERSION=12.4.56.0
XP_KEY_FORM=msil_olappartitiontool_no-public-key_12.4.56.0_x-ww_49724339
XP_MANIFEST_DIRECTORY=manifests
XP_MANIFEST_NAME=msil_olappartitiontool_no-public-key_12.4.56.0_x-ww_49724339.manifest
XP_MANIFEST_PATH=manifests\msil_olappartitiontool_no-public-key_12.4.56.0_x-ww_49724339.manifest
XP_CATALOG_DIRECTORY=manifests
XP_CATALOG_NAME=msil_olappartitiontool_no-public-key_12.4.56.0_x-ww_49724339.cat
XP_CATALOG_PATH=manifests\msil_olappartitiontool_no-public-key_12.4.56.0_x-ww_49724339.cat
XP_PAYLOAD_PATH=msil_olappartitiontool_no-public-key_12.4.56.0_x-ww_49724339
_DELAY_SIGN=0
!if [set _ASMIDTOATTRIBS_TLBIMP=]
!endif
CODESIGN_TESTKEY=
_TLBIMP_FLAGS=$(_TLBIMP_FLAGS)  /asmversion:12.4.56.0
_ASSEMBLY_IDENTITY=olappartitiontool,processorArchitecture=msil,version=12.4.56.0,publicKeyToken=neutral
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\xereports\ProdScripts\makefile.inc ===
ProdScriptsCopy : makefile.inc
    -md %_NT386TREE%\tools\xereports\Datafeeds\CIQ\ProdScripts
    -robocopy . %_NT386TREE%\tools\xereports\Datafeeds\CIQ\ProdScripts CIQ.wsf /R:0 /NP /NJH /NJS /A-:R
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\xereports\ProdScripts\objd\i386\_asmid.inc ===
ASSEMBLY_IDENTITY_KEY_FORM=x86__prodscripts_3_none_12.4.56.0_none_9302dc7351ae6e1a
ASSEMBLY_IDENTITY_XP_KEY_FORM=x86__prodscripts_3_no-public-key_12.4.56.0_x-ww_5b700d1c
ASSEMBLY_IDENTITY_CULTURE=
ASSEMBLY_IDENTITY_NAME=_prodscripts_3
ASSEMBLY_IDENTITY_PROCESSOR_ARCHITECTURE=x86
ASSEMBLY_IDENTITY_PUBLIC_KEY=
ASSEMBLY_IDENTITY_PUBLIC_KEY_TOKEN=
ASSEMBLY_IDENTITY_TYPE=
ASSEMBLY_IDENTITY_TYPE_NAME=
ASSEMBLY_IDENTITY_VERSION=12.4.56.0
XP_KEY_FORM=x86__prodscripts_3_no-public-key_12.4.56.0_x-ww_5b700d1c
XP_MANIFEST_DIRECTORY=manifests
XP_MANIFEST_NAME=x86__prodscripts_3_no-public-key_12.4.56.0_x-ww_5b700d1c.manifest
XP_MANIFEST_PATH=manifests\x86__prodscripts_3_no-public-key_12.4.56.0_x-ww_5b700d1c.manifest
XP_CATALOG_DIRECTORY=manifests
XP_CATALOG_NAME=x86__prodscripts_3_no-public-key_12.4.56.0_x-ww_5b700d1c.cat
XP_CATALOG_PATH=manifests\x86__prodscripts_3_no-public-key_12.4.56.0_x-ww_5b700d1c.cat
XP_PAYLOAD_PATH=x86__prodscripts_3_no-public-key_12.4.56.0_x-ww_5b700d1c
_DELAY_SIGN=0
!if [set _ASMIDTOATTRIBS_TLBIMP=]
!endif
CODESIGN_TESTKEY=
_TLBIMP_FLAGS=$(_TLBIMP_FLAGS)  /asmversion:12.4.56.0
_ASSEMBLY_IDENTITY=_prodscripts_3,processorArchitecture=x86,version=12.4.56.0,publicKeyToken=neutral
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\xereports\ProdScripts\obj\i386\_asmid.inc ===
ASSEMBLY_IDENTITY_KEY_FORM=x86__prodscripts_3_none_12.4.56.0_none_9302dc7351ae6e1a
ASSEMBLY_IDENTITY_XP_KEY_FORM=x86__prodscripts_3_no-public-key_12.4.56.0_x-ww_5b700d1c
ASSEMBLY_IDENTITY_CULTURE=
ASSEMBLY_IDENTITY_NAME=_prodscripts_3
ASSEMBLY_IDENTITY_PROCESSOR_ARCHITECTURE=x86
ASSEMBLY_IDENTITY_PUBLIC_KEY=
ASSEMBLY_IDENTITY_PUBLIC_KEY_TOKEN=
ASSEMBLY_IDENTITY_TYPE=
ASSEMBLY_IDENTITY_TYPE_NAME=
ASSEMBLY_IDENTITY_VERSION=12.4.56.0
XP_KEY_FORM=x86__prodscripts_3_no-public-key_12.4.56.0_x-ww_5b700d1c
XP_MANIFEST_DIRECTORY=manifests
XP_MANIFEST_NAME=x86__prodscripts_3_no-public-key_12.4.56.0_x-ww_5b700d1c.manifest
XP_MANIFEST_PATH=manifests\x86__prodscripts_3_no-public-key_12.4.56.0_x-ww_5b700d1c.manifest
XP_CATALOG_DIRECTORY=manifests
XP_CATALOG_NAME=x86__prodscripts_3_no-public-key_12.4.56.0_x-ww_5b700d1c.cat
XP_CATALOG_PATH=manifests\x86__prodscripts_3_no-public-key_12.4.56.0_x-ww_5b700d1c.cat
XP_PAYLOAD_PATH=x86__prodscripts_3_no-public-key_12.4.56.0_x-ww_5b700d1c
_DELAY_SIGN=0
!if [set _ASMIDTOATTRIBS_TLBIMP=]
!endif
CODESIGN_TESTKEY=
_TLBIMP_FLAGS=$(_TLBIMP_FLAGS)  /asmversion:12.4.56.0
_ASSEMBLY_IDENTITY=_prodscripts_3,processorArchitecture=x86,version=12.4.56.0,publicKeyToken=neutral
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\xereports\ReplicationSetup\obj\i386\_generated.cs ===
[assembly:System.Runtime.InteropServices.ComVisible(false)]
[assembly:System.Reflection.AssemblyVersion("12.4.56.0")]
[assembly:System.Reflection.AssemblyProduct("DEPOT")]
[assembly:System.Reflection.AssemblyCopyright("")]
[assembly:System.Reflection.AssemblyCompany("")]
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\xereports\ReplicationSetup\objd\i386\_generated.cs ===
[assembly:System.Runtime.InteropServices.ComVisible(false)]
[assembly:System.Reflection.AssemblyVersion("12.4.56.0")]
[assembly:System.Reflection.AssemblyProduct("DEPOT")]
[assembly:System.Reflection.AssemblyCopyright("")]
[assembly:System.Reflection.AssemblyCompany("")]
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\xereports\PartitionCreationTool\PartitionCreationTool.cs ===
using System;
using System.Collections;
using System.Data;
using System.Data.SqlClient;
using System.IO;
using System.Threading;
using System.Xml;
using System.Net;
using System.Net.Sockets;
using System.Collections.Generic;
using Microsoft.SqlServer.Management.Common;
using Microsoft.SqlServer.Management.Smo;
using System.Text.RegularExpressions;
using Microsoft.AnalysisServices;

using xonline.common.config;
using xonline.common.mgmt;
using xonline.common.service;

namespace xonline.tools.reporting.ssas.partitioncreation
{
    //This tool automatically creates OLAP partitions for the next 3 (or another number passed in) months.
    //See Xenon 68228, and the associated design doc, for a description of the design of the system.

    public enum OperatingModes
    {
        CLEANFUTURE,
        CREATEMONTHS,
        ARCHIVAL,
        VALIDATE,
        ENUMERATE
    }
    class PartitionCreationToolApplication
    {

        //By default, this tool will generate 3 months' worth of partitions
        public static uint NumMonthsToGenerate = 3;
        public const string MonthlyUnit = "monthly";
        public const string semimonthlyUnit = "semimonthly";
        public const string QuarterlyUnit = "quarterly";
        public const string WeeklyUnit = "weekly";
        public const int CREATE_NEW_PARTITIONS_SUCCESS = 1;
        public const int FILLTABLE_SUCCESS = 2;
        public const int CLEAN_FUTURE_PARTITIONS_SUCCESS = 3;
        public const int ARCHIVE_OLD_PARTITIONS_SUCCESS = 4;
        public const int VALIDATION_SUCCESS = 5;
        public const int TIMEOUT_TOKEN_OFFSET = 2;
        public const int TIMEOUT_PARAMETER_OFFSET = 3;
        public const int STARTDATE_AND_TIMEOUT_TOKEN_OFFSET = 4;
        public const int STARTDATE_AND_TIMEOUT_PARAMETER_OFFSET = 5;


        //So long as we have parameters, we need to do some work for each command line option. XE-83939
        //OlapRealTime is not in Interface (ConfigItemClasses.cs)
        //public static string[] OlapDatabases = { Interface.olapGameUsage, Interface.olapCruxUsage, Interface.olapAchievements, "OlapRealtime" };
        public static string[] OlapDatabases = { "OlapRdb", "OlapCruxUsage", "OlapAchievements", "OlapRealtime", "OlapCdbCruxUsage", "VideoCube" };

        public static string USAGE_STRING = "Usage: PartitionCreationTool (archival | cleanfuture | filltable | months <n> | months <n> ( timeout <o> | startdate <p> | timeout <o> startdate <p>)) | validate)";

        public static int Main(string[] args)
        {

            //First, handle any command line parameters.
            if (args.Length > 0)
            {
                //An instance of the worker class.
                PartitionCreationToolLibrary LocalTool;
                //See whether we are giving a number of months, or a request to fill the partition table.
                switch (args[0])
                {
                    case "cleanfuture":
                        //Delete all partitions in the future (for testing)
                        try
                        {
                            LogInfo("Starting to delete all future partitions. This is for testing.");
                            LocalTool = new PartitionCreationToolLibrary(NumMonthsToGenerate);
                            //The next few functions need to be run for each olap cube (XE-83939)
                            foreach (string currentDatabase in OlapDatabases)
                            {
                                //LocalTool.init(false, true, currentDatabase);
                                LocalTool.init(OperatingModes.CLEANFUTURE, currentDatabase);
                                //XE-83942
                                LocalTool.DeleteFuturePartitionTableEntries();
                            }
                            LogInfo("Deletion successful.");
                            return CLEAN_FUTURE_PARTITIONS_SUCCESS;
                        }
                        catch (Exception ex)
                        {
                            LogError("Error in deleting future partitions: " + ex.Message);
                            return -1 * CLEAN_FUTURE_PARTITIONS_SUCCESS;
                        }

                    case "months":
                        int ConnectionTimeout = PartitionCreationToolLibrary.DEFAULT_TIMEOUT;
                        System.DateTime StartDate = DateTime.Now.AddDays(1);
                        //Attempt to parse the input time (number of months) as an unsigned integer.
                        try
                        {
                            NumMonthsToGenerate = uint.Parse(args[1]);
                        }
                        catch (Exception ex)
                        {
                            //Log that an incorrect parameter was passed in.
                            LogError("An incorrect number of months was passed in: " + ex.Message);
                            return -1;
                        }

                        //We allow <timeout n> and <startdate o> and <timeout n startdate o> and <startdate o timeout n> as per usage string
                        if (4 == args.Length || 6 == args.Length)
                        {
                            if (args[TIMEOUT_TOKEN_OFFSET] == "timeout" || ( 6 == args.Length && args[STARTDATE_AND_TIMEOUT_TOKEN_OFFSET] == "timeout"))
                            {
                                bool TimeoutArgsCorrect = false;
                                int timeoutParameterLocation = (args[TIMEOUT_TOKEN_OFFSET] == "timeout") ? TIMEOUT_PARAMETER_OFFSET : STARTDATE_AND_TIMEOUT_PARAMETER_OFFSET;
                                TimeoutArgsCorrect = Int32.TryParse(args[timeoutParameterLocation], out ConnectionTimeout);
                                TimeoutArgsCorrect = TimeoutArgsCorrect && (ConnectionTimeout > 0);

                                if (false == TimeoutArgsCorrect)
                                {
                                    LogError(USAGE_STRING);
                                    return -1;
                                }
                            }
                            //If we have a startdate, use that if formatted correctly.
                            if (args[TIMEOUT_TOKEN_OFFSET] == "startdate" || ( 6 == args.Length && args[STARTDATE_AND_TIMEOUT_TOKEN_OFFSET] == "startdate"))
                            {
                                bool StartDateArgsCorrect = false;
                                int startdateParameterLocation = (args[TIMEOUT_TOKEN_OFFSET] == "startdate") ? TIMEOUT_PARAMETER_OFFSET : STARTDATE_AND_TIMEOUT_PARAMETER_OFFSET;
                                StartDateArgsCorrect = System.DateTime.TryParse(args[startdateParameterLocation], out StartDate);

                                if (false == StartDateArgsCorrect)
                                {
                                    LogError(USAGE_STRING);
                                    return -1;
                                }
                            }
                            //Otherwise, we have junk input. Print the usage string and begone.
                            if (args[TIMEOUT_TOKEN_OFFSET] != "startdate" && ( 6 != args.Length || args[STARTDATE_AND_TIMEOUT_TOKEN_OFFSET] != "startdate")
                               && args[TIMEOUT_TOKEN_OFFSET] != "timeout" && ( 6 != args.Length || args[STARTDATE_AND_TIMEOUT_TOKEN_OFFSET] != "timeout"))
                            {
                                LogError(USAGE_STRING);
                                return -1;
                            }
                        }
                        //Only 2, 4, or 6 arguments is acceptable.
                        else if (2 != args.Length)
                        {
                            System.Console.WriteLine(USAGE_STRING);
                            return -1;
                        }

                        ///     //Now that we know how many months to make, create the worker object.
                        ///    LocalTool = new PartitionCreationToolLibrary(NumMonthsToGenerate);
                        //The false parameter to init indicates that we are not to generate the table of partitions.
                        LogInfo("Starting the generation of monthly partitions.");
                        foreach (string currentDatabase in OlapDatabases)
                        {
                            LocalTool = new PartitionCreationToolLibrary(NumMonthsToGenerate, ConnectionTimeout, StartDate);
                            LocalTool.init(OperatingModes.CREATEMONTHS, currentDatabase);
                            //LocalTool.init(false, true, currentDatabase);
                      //      LocalTool.DeleteFuturePartitionTableEntries();
                            LocalTool.GenerateParitionNames();

                            try
                            {
                                LocalTool.GenerateFuturePartitions(currentDatabase);
                            }
                            catch (Exception ex)
                            {
                                LogError("Error in creating new partitions (generating partitions): " + ex.Message);
                                return -1 * CREATE_NEW_PARTITIONS_SUCCESS;
                            }
                        }
                        LogInfo("Generation of montly partitions successful.");
                        return CREATE_NEW_PARTITIONS_SUCCESS;


                    case "filltable":
                        //Here, we are going to fill the table t_measuregroup_partition_regexes.
                        try
                        {
                            LogInfo("Starting the filling of the table t_measuregroup_partition_regexes.");
                            LocalTool = new PartitionCreationToolLibrary();
                            LocalTool.GenerateTable();
                            LogInfo("Table generation successful.");
                            return FILLTABLE_SUCCESS;
                        }
                        catch (Exception ex)
                        {
                            LogError("Error in filling the table t_measuregroup_partition_regexes: " + ex.Message);
                            return -1 * FILLTABLE_SUCCESS;
                        }
                    case "archival":
                        //Here, we are going to check all partitions, and if there are ones in the past, change them to point to
                        //reportarchivedb if that is the prudent thing to do.
                        try
                        {
                            LogInfo("Beginning the archival of past partitions from reportingdb->reportarchivedb if necessary.");
                            LocalTool = new PartitionCreationToolLibrary();
                            foreach (string currentDatabase in OlapDatabases)
                            {
                                //LocalTool.init(false, false, currentDatabase);
                                LocalTool.init(OperatingModes.ARCHIVAL, currentDatabase);
                            }
                            LogInfo("Archival process completed successfully");
                            return ARCHIVE_OLD_PARTITIONS_SUCCESS;
                        }
                        catch (Exception ex)
                        {
                            LogError("Error in archiving past partitions: " + ex.Message);
                            return -1 * ARCHIVE_OLD_PARTITIONS_SUCCESS;
                        }

                    case "validate":
                        //Here, we are going to compare the partition name with the partition periods
                        try
                        {
                            LogInfo("Beginning the validation of partition periods against the partition names.");
                            LocalTool = new PartitionCreationToolLibrary();
                            foreach (string currentDatabase in OlapDatabases)
                            {
                               LocalTool.init(OperatingModes.VALIDATE, currentDatabase);
                            }
                            LogInfo("Validation complete.");
                            return VALIDATION_SUCCESS;
                        }
                        catch (Exception ex)
                        {
                            LogError("Error in validating the partitions: " + ex.Message);
                            return -1 * VALIDATION_SUCCESS;
                        }
                    default:
                        System.Console.WriteLine(USAGE_STRING);
                        return -1;

                }

            }
            //If we do not have one of the required arguments, error out.
            else
            {
                System.Console.WriteLine(USAGE_STRING);
                return -1;
            }
        }

        public static void LogError(string LogMessage)
        {
          Xom.NtEvent(XEvent.Id.PARTITION_TOOL_ERROR, LogMessage);
            System.Console.WriteLine(LogMessage);
            System.Environment.Exit(-1);
        }

        //This logs an informational, non-error, message.
        public static void LogInfo(string LogMessage)
        {
          Xom.NtEvent(XEvent.Id.PARTITION_TOOL_INFO, LogMessage);
            System.Console.WriteLine(LogMessage);
        }
    }//end class

    //This class is used for executing the body of the logic to execute the steps needed to create partitions.
    public class PartitionCreationToolLibrary
    {
        //const strings for determining how to parse and create partition names.
        public const string MonthlyPartitionRegex = @".+_(\d{4,4})_(\d{2,2})";
        public const string QuarterlyPartitionRegex = @".+_(\d{4,4})_[qQ]([1234])";
        public const string semimonthlyPartitionRegex = @".+_(\d{4,4})_(\d{2,2})_(\d{2,2})";
        public const string weeklyPartitionRegex = @".+_(\d{4,4})_(\d{2,2})_(\d{2,2})_(\d{2,2})";
        public const string DateValidationRegex = @"(.*)((>=)|(>)).*((\d){8}).*<.*((\d){8})(.*)";
        public const string FunctionDateValidationRegex = @".*\(.*((\d){8}).*((\d){8}).*\)";

        public const string MonthlyNamingPattern = "<prefix>_<year>_<month>";
        //XE-84326 -- change quarterly to capital Q
        public const string QuarterlyNamingPattern = "<prefix>_<year>_Q<value>";
        public const string semimonthlyNamingPattern = "<prefix>_<year>_<month>_<day>";
        public const string WeeklyNamingPattern = "<prefix>_<year>_<month>_<value>_<day>";


        public const string MonthlyUnit = "monthly";
        public const string semimonthlyUnit = "semimonthly";
        public const string QuarterlyUnit = "quarterly";
        public const string WeeklyUnit = "weekly";

        //SQL query timeouts
        public const int DEFAULT_TIMEOUT = 1800;    //30 minutes
        public int LongQueryTimeout;

        public uint LocalNumberOfMonths;
        public DateTime RelativeStartingDate;

        //These three members handle the caching of connection informaiton.
        //Once we run GetDataAdapter once, the information will be cached for reuse.
        IInterfaceInfo iiTarget;
        string[] rgszServers;

        //These objects let us interface with SSAS.
        private Microsoft.AnalysisServices.Server olapServer;
        private Microsoft.AnalysisServices.Database olapDb;

        //The collections store objects created during the enumeration and processing of partitions
        public List<UniqueMeasureGroupKey> PartitionsToCreate;
        public List<UniqueMeasureGroupKey> UniqueMeasureGroupList;

        //This protects a critical function from being called out of order.
        private bool NameGenerationComplete;

        //This constructor is used for the table generation, and will not generate any partitions directly.
        public PartitionCreationToolLibrary()
        {
            LocalNumberOfMonths = 0;
            NameGenerationComplete = false;
            LongQueryTimeout = DEFAULT_TIMEOUT;
            RelativeStartingDate = DateTime.Now.AddDays(1);
        }
        //This constructor is used when deleting future partitions (for testing only)
        public PartitionCreationToolLibrary(uint NumberOfMonths)
        {
            LocalNumberOfMonths = NumberOfMonths;
            PartitionsToCreate = new List<UniqueMeasureGroupKey>();
            NameGenerationComplete = false;
            LongQueryTimeout = DEFAULT_TIMEOUT;
        }
        //This constructor is used when creating partitions.
        public PartitionCreationToolLibrary(uint NumberOfMonths, int CustomQueryTimeout, DateTime StartDate)
        {
            LocalNumberOfMonths = NumberOfMonths;
            PartitionsToCreate = new List<UniqueMeasureGroupKey>();
            NameGenerationComplete = false;
            LongQueryTimeout = CustomQueryTimeout;
            RelativeStartingDate = StartDate;
        }
        public static void LogError(string LogMessage)
        {
          Xom.NtEvent(XEvent.Id.PARTITION_TOOL_ERROR, LogMessage);
            System.Console.WriteLine(LogMessage);
            System.Environment.Exit(-1);
        }

        //For non-error, informational messages
        public static void LogMessage(string LogMessage)
        {
          Xom.NtEvent(XEvent.Id.PARTITION_TOOL_LOG_NON_ERROR, LogMessage);
            System.Console.WriteLine(LogMessage);
        }

        //This is an inner class, representing a unique measure group/partition element
        public class UniqueMeasureGroupKey
        {
            //These are the elements of the measure group key.
            public string SSAS_DBname;
            public string VC_Cubename;
            public string VC_MeasureGroup;
            public string PartitionName;
            public DateTime PartitionTimeStart;
            public DateTime PartitionTimeEnd;

            //to hold a unique measure group, with no partition information
            public UniqueMeasureGroupKey(string DbName, string CubeName, string MeasureGroup)
            {
                SSAS_DBname = DbName;
                VC_Cubename = CubeName;
                VC_MeasureGroup = MeasureGroup;
                //The below 2 params are not used in this mode, and are just defaulted for safety's sake.
                PartitionName = "";
                PartitionTimeStart = System.DateTime.Now;
                PartitionTimeEnd = System.DateTime.Now;
            }
            //To hold partition names referencing db/cube/measure
            public UniqueMeasureGroupKey(string DbName, string CubeName, string MeasureGroup, string Partition, DateTime TimeStart, DateTime TimeEnd)
            {
                SSAS_DBname = DbName;
                VC_Cubename = CubeName;
                VC_MeasureGroup = MeasureGroup;
                PartitionName = Partition;
                PartitionTimeStart = TimeStart;
                PartitionTimeEnd = TimeEnd;
            }

            //For copying the object
            public UniqueMeasureGroupKey(UniqueMeasureGroupKey inputKey)
            {
                SSAS_DBname = inputKey.SSAS_DBname;
                VC_Cubename = inputKey.VC_Cubename;
                VC_MeasureGroup = inputKey.VC_MeasureGroup;
                PartitionName = inputKey.PartitionName;
                PartitionTimeStart = inputKey.PartitionTimeStart;
                PartitionTimeEnd = inputKey.PartitionTimeEnd;
            }
        }
        //This is a utility, as this date format is used in other database tables.
        public int GetIntegerFromDateTime(DateTime inputTime)
        {
            int RetVal = inputTime.Year * 10000;
            RetVal += (inputTime.Month * 100);
            RetVal += inputTime.Day;
            return RetVal;
        }

        //and to do the inverse
        public DateTime GetDateTimeFromInt(int inputInt)
        {
            int year = inputInt / 10000;
            inputInt -= (year * 10000);
            int month = inputInt / 100;
            inputInt -= (month * 100);
            return new DateTime(year, month, inputInt);
        }

        //There are two steps to filling in t_measuregroup_partition_regexes:
        //1) empty the table (via the sproc p_modify_t_measuregroup_partition_regexes)
        //2) fill the table (the function init, with 'true' parameter, does this)
        public void GenerateTable()
        {
            Dictionary<string, object> SprocParameters = new Dictionary<string, object>();
            SprocParameters.Add("clear_table", 1);
            SqlDataReader blankTable = GetDataAdapter("p_modify_t_measuregroup_partition_regexes", SprocParameters, "reportingdb", DEFAULT_TIMEOUT);
            blankTable.Close();
            //Now, we need to enumerate all combinations of vc_dbname/vc_cubename/vc_measuregroup, and fill in the table.
            foreach (string currentDatabase in PartitionCreationToolApplication.OlapDatabases)
            {
                //init(true, true, currentDatabase);
                init(OperatingModes.ENUMERATE, currentDatabase);
            }
        }

        //This helper function converts a partition time unit to a naming pattern.
        public string GetNamingPatternFromPartitionUnit(string PartitionUnit)
        {
            string RetVal = "";
            switch (PartitionUnit)
            {
                case MonthlyUnit:
                    RetVal = MonthlyNamingPattern;
                    break;
                case semimonthlyUnit:
                    RetVal = semimonthlyNamingPattern;
                    break;
                case QuarterlyUnit:
                    RetVal = QuarterlyNamingPattern;
                    break;
                case WeeklyUnit:
                    RetVal = WeeklyNamingPattern;
                    break;
                default:
                    //This is an error and should not happen
                    string ErrMsg = "Error: Partition unit not recognized: " + PartitionUnit;
                    LogError(ErrMsg);
                    throw (new Exception(ErrMsg));
            }
            return RetVal;
        }

        //This function uses a regex to analyze the partition name, and turn it into a frequency unit.
        public string GetFrequencyUnitFromPartitionName(string InputPartitionName)
        {
            Regex MonthlyRegex = new Regex(MonthlyPartitionRegex);
            Regex QuarterlyRegex = new Regex(QuarterlyPartitionRegex);
            Regex semimonthlyRegex = new Regex(semimonthlyPartitionRegex);
            Regex weeklyRegex = new Regex(weeklyPartitionRegex);

            if (weeklyRegex.Matches(InputPartitionName).Count > 0)
            {
                return WeeklyUnit;
            }
            //must check semimonthly before monthly as it is a subset of monthly.
            //if you check monthly first, it will match semimonthly partitions.
            else if (semimonthlyRegex.Matches(InputPartitionName).Count > 0)
            {
                return semimonthlyUnit;
            }

            else if (QuarterlyRegex.Matches(InputPartitionName).Count > 0)
            {
                return QuarterlyUnit;
            }
            else if (MonthlyRegex.Matches(InputPartitionName).Count > 0)
            {
                return MonthlyUnit;
            }
            else
            //It's not a partition that grows. Return an empty string.
            {
                return "";
            }
        }

        //This utility function turns a partition name to a datetime object.
        public DateTime GetDateFromPartitionName(string InputPartitionName)
        {
            string FrequencyUnit = GetFrequencyUnitFromPartitionName(InputPartitionName);
            DateTime RetVal;
            switch (FrequencyUnit)
            {
                case MonthlyUnit:
                    Regex ParseMonth = new Regex(MonthlyPartitionRegex);
                    MatchCollection ParseMonthMatches = ParseMonth.Matches(InputPartitionName);
                    int year = Int32.Parse(ParseMonthMatches[0].Groups[1].Value);
                    int month = Int32.Parse(ParseMonthMatches[0].Groups[2].Value);
                    //hardcode the day to be 1st of the month as it's monthly.
                    RetVal = new DateTime(year, month, 01);
                    break;
                case semimonthlyUnit:
                    Regex ParseBiMonth = new Regex(semimonthlyPartitionRegex);
                    MatchCollection ParseBiMonthMatches = ParseBiMonth.Matches(InputPartitionName);
                    year = Int32.Parse(ParseBiMonthMatches[0].Groups[1].Value);
                    month = Int32.Parse(ParseBiMonthMatches[0].Groups[2].Value);
                    int day = Int32.Parse(ParseBiMonthMatches[0].Groups[3].Value);
                    RetVal = new DateTime(year, month, day);
                    break;
                case QuarterlyUnit:
                    Regex ParseQuarter = new Regex(QuarterlyPartitionRegex);
                    MatchCollection ParseQuarterlyatches = ParseQuarter.Matches(InputPartitionName);
                    year = Int32.Parse(ParseQuarterlyatches[0].Groups[1].Value);
                    month = Int32.Parse(ParseQuarterlyatches[0].Groups[2].Value);
                    //for quarterly, set this to the first month of the new. (Q1 starts 1/1, q2 4/1, q3 7/1, q4 10/1)
                    //Algorithim for quarter# to month: month = ((Quarter-1)* 3) + 1
                    month -= 1;
                    month *= 3;
                    month += 1;
                    //hardcode the day to be 1st of the month as it's quarterly.
                    RetVal = new DateTime(year, month, 1);
                    break;
                    //weekly units return the beginning of the period (the first day in the name)
                case WeeklyUnit:
                    Regex ParseWeekly = new Regex(weeklyPartitionRegex);
                    MatchCollection ParseWeeklyMatches = ParseWeekly.Matches(InputPartitionName);
                    year = Int32.Parse(ParseWeeklyMatches[0].Groups[1].Value);
                    month = Int32.Parse(ParseWeeklyMatches[0].Groups[2].Value);
                    day = Int32.Parse(ParseWeeklyMatches[0].Groups[3].Value);
                    RetVal = new DateTime(year, month, day);
                    break;
                default:
                    //XE83939 -- need to support a non growing partition, TitleAchievementInfo (NonGrowingPartitionName)
                    //In the case, treat it as a past partition, so it does not get deleted.
                    RetVal = new DateTime(2000, 01, 01);
                    break;

            }
            return RetVal;
        }
        //A query that makes a partition has a start and end date. These two functions get the start and end dates from the query.
        public string GetStartDateFromQuery(string InputQueryText)
        {
            //The regex DateValidationRegex gives us the date ranges for the query. Group 5 is the start date.
            Regex ParsePeriod = new Regex(DateValidationRegex);
            MatchCollection ParseDateMatches = ParsePeriod.Matches(InputQueryText);
            if(ParseDateMatches.Count > 0)
            {
                return ParseDateMatches[0].Groups[5].Value.Trim();
            }
            else
            {
                Regex ParseFuncPeriod = new Regex(FunctionDateValidationRegex);
                ParseDateMatches = ParseFuncPeriod.Matches(InputQueryText);
                return ParseDateMatches[0].Groups[1].Value.Trim();
            }
        }
        public string GetEndDateFromQuery(string InputQueryText)
        {
            //The regex DateValidationRegex gives us the date ranges for the query. Group 7 is the end date.
            Regex ParsePeriod = new Regex(DateValidationRegex);
            MatchCollection ParseDateMatches = ParsePeriod.Matches(InputQueryText);
            if(ParseDateMatches.Count > 0)
            {
                return ParseDateMatches[0].Groups[7].Value.Trim();
            }
            else
            {
                Regex ParseFuncPeriod = new Regex(FunctionDateValidationRegex);
                ParseDateMatches = ParseFuncPeriod.Matches(InputQueryText);
                return ParseDateMatches[0].Groups[3].Value.Trim();
            }
        }

        //Using a regex, this function gets the prefix from a partition name.
        public string DeterminePartitionPrefix(string InputPartitionName)
        {
            string PrefixRegex = @"(.*)_\d\d\d\d.*";
            Regex PrefixFinder = new Regex(PrefixRegex);
            MatchCollection RegexResults = PrefixFinder.Matches(InputPartitionName);
            //This may be confusing with the hardcoded offsets. Results[0] = the first result (and the only possible one).
            //Groups[1] = the second match group. (The first being the entire string)
            return RegexResults[0].Groups[1].Value.Trim();
        }

        public string GetBaseTableFromQuery(string InputQueryString)
        {
            string BaseTableRegex = @".*FROM(.*)WHERE.*";
            string BaseFuncRegex = @".*FROM(.*)\(.*";
            Regex BaseTableFinder = new Regex(BaseTableRegex, RegexOptions.IgnoreCase | RegexOptions.Singleline);
            MatchCollection RegexResults = BaseTableFinder.Matches(InputQueryString);
            if(RegexResults.Count > 0)
            {
                return RegexResults[0].Groups[1].Value.Trim();
            }
            else
            {
                Regex BaseFuncFinder = new Regex(BaseFuncRegex, RegexOptions.IgnoreCase | RegexOptions.Singleline);
                RegexResults = BaseFuncFinder.Matches(InputQueryString);
                return RegexResults[0].Groups[1].Value.Trim();
            }
        }

        //Init, based on the parameter, either enumerates the partitions to a table, or makes new partitions.
        //Why have the same function do both? In both cases, we have to drill down into each measure group in the DB.
        //Since that is a good bit of work, I consolidated the abilities here, rather than duplicate the code for 2 functions.
        //public void init(bool GeneratingTableData, bool DeletingFuturePartitions, string DatabaseName)
        public void init (OperatingModes operationMode, string DatabaseName)
        {
            bool GeneratingTableData = (operationMode == OperatingModes.ENUMERATE);
            bool DeletingFuturePartitions = (operationMode == OperatingModes.CLEANFUTURE || operationMode == OperatingModes.CREATEMONTHS || operationMode == OperatingModes.ENUMERATE);
            bool ValidatingTableData = (operationMode == OperatingModes.VALIDATE);
            try
            {
            //Find the location of all combinations of SSAS DB name, the cube name, and measure group
           string InterfaceName = Interface.olapGameUsage;
            IInterfaceInfo Face = Config.GetInterface((Config.GetServerListByInterface(Interface.olapGameUsage))[0], InterfaceName);

           olapServer = new Microsoft.AnalysisServices.Server();
           olapServer.Connect(Face.IPAddressString);

            olapDb = olapServer.Databases.FindByName(DatabaseName);
            UniqueMeasureGroupList = new List<PartitionCreationToolLibrary.UniqueMeasureGroupKey>();

            //Now, we have a connection. Enumerate cubes.
            //Why can't we use foreach? Because we want to be able to alter partitions, which you can't
            //if you're enumerating the cubes with a foreach.
            for (int j = 0; j < olapDb.Cubes.Count; j++)
            {
                Cube CurrentCube = olapDb.Cubes[j];
                //Enumerate measure groups
                foreach (MeasureGroup CurrentMeasure in CurrentCube.MeasureGroups)
                {
                    //For each measure group, set dbname/cubename/measure group so we can uniquely identify what
                    //we are working with
                    //Do this by adding each combination to the collection UniqueMeasureGroup list for later processing.
                    ///     UniqueMeasureGroupList.Add(new UniqueMeasureGroupKey(Face.DBName, CurrentCube.Name, CurrentMeasure.Name));
                    UniqueMeasureGroupKey KeyToAdd = new UniqueMeasureGroupKey(DatabaseName, CurrentCube.Name, CurrentMeasure.Name);
                    UniqueMeasureGroupList.Add(KeyToAdd);
                    //then, work with each partition. If it's a partition in the past, we need to check to see if we need
                    //to change its data source to reportarchivedb by running its query against reportingdb and reportarchivedb.
                    //If and only if reportingdb has no records, and reportarchivedb does, and it's in the past, change its data source.
                    for (int i = 0; i < CurrentMeasure.Partitions.Count; i++)
                    {
                        Partition CurrentPartition = CurrentMeasure.Partitions[i];
                        //since we are deleting the partition if blank and in the future, we can't use foreach
                        //If GeneratingTableData is true, we are just enumerating
                        if (true == GeneratingTableData)
                        {
                            //Ensure that the partition should be created -- not all partitions should be added
                            if ("" == GetFrequencyUnitFromPartitionName(CurrentPartition.Name))
                            {
                                continue;
                            }
                            //Now, we need to enumerate all combinations of vc_dbname/vc_cubename/vc_measuregroup, and fill them in.
                            //vc_frequency_unit is calculated.
                            //vc_partition_prefix can be found pretty easy (search for first regex match of [(.*)_\d\d\d\d.*]. This fits
                            //all existing partitioning schemes, but if it doesn't later, the user can change the prefix in the table
                            //as it's merely cosmetic.
                            //vc_query_def will be pulled from the existing group's query.
                            //i_startdate is pulled from the query's starting date.
                            //1_enddate is pulled from the query's ending date.
                            //vc_query_base_table is pulled from the existing query (as they are all "Select ... from <base_table>...")
                            try
                            {
                                Dictionary<string, object> SprocParameters = new Dictionary<string, object>();
                                //SprocParameters.Add("vc_ssas_dbname", Face.DBName);
                                SprocParameters.Add("vc_ssas_dbname", DatabaseName);
                                SprocParameters.Add("vc_cubename", CurrentCube.Name);
                                SprocParameters.Add("vc_measuregroup", CurrentMeasure.Name);
                                SprocParameters.Add("vc_frequency_unit", GetFrequencyUnitFromPartitionName(CurrentPartition.Name));
                                SprocParameters.Add("vc_partition_prefix", DeterminePartitionPrefix(CurrentPartition.Name));
                                string QueryDefinition = ((Microsoft.AnalysisServices.QueryBinding)(CurrentPartition.Source)).QueryDefinition;
                                SprocParameters.Add("vc_query_def", (QueryDefinition));
                                SprocParameters.Add("i_startdate", GetStartDateFromQuery(QueryDefinition));
                                SprocParameters.Add("i_enddate", GetEndDateFromQuery(QueryDefinition));
                                SprocParameters.Add("vc_query_base_table", GetBaseTableFromQuery(QueryDefinition));
                                SqlDataReader blankTable = GetDataAdapter("p_modify_t_measuregroup_partition_regexes", SprocParameters, "reportingdb", DEFAULT_TIMEOUT);
                            }
                            catch (Exception ex)
                            {
                                LogError("Error in writing partitions to the database: " + ex.Message);
                                return;
                            }
                        }
                        //In this case, we are validating that the partition information seems reasonable.
                        else if (true == ValidatingTableData)
                        {
                            //Ensure that the partition should be scanned.
                            if ("" == GetFrequencyUnitFromPartitionName(CurrentPartition.Name))
                            {
                                continue;
                            }
                            string currentObjectName = "";
                            string QueryDefinition = "";
                            string frequencyUnit = "";
                            try
                            {
                               currentObjectName = DatabaseName + "-" + CurrentCube.Name + "-" + CurrentMeasure.Name;
                               QueryDefinition = ((Microsoft.AnalysisServices.QueryBinding)(CurrentPartition.Source)).QueryDefinition;
                               //The regex DateValidationRegex gives us the date ranges for the query.
                               //Get the two date range values and make sure that date 1 is less than date 2.
                               Regex ParsePeriod = new Regex(DateValidationRegex);
                               MatchCollection ParseDateMatches = ParsePeriod.Matches(QueryDefinition);
                               int date1 = Int32.Parse(ParseDateMatches[0].Groups[5].Value);
                               int date2 = Int32.Parse(ParseDateMatches[0].Groups[7].Value);
                               if (!(date1 < date2))
                               {
                                LogMessage("Error: Partition: " + currentObjectName + " with query:\r\n" + QueryDefinition + "\r\nhas failed validation because the start date was not before the end date.");
                               }
                               //Check the frequency unit against the dates in the query
                               frequencyUnit = GetFrequencyUnitFromPartitionName(CurrentPartition.Name);
                               DateTime startDate = GetDateTimeFromInt(date1);
                               DateTime endDate = GetDateTimeFromInt(date2);
                               switch (frequencyUnit)
                               {
                                   case MonthlyUnit:
                                       if (startDate.AddMonths(1) != endDate)
                                       {
                                           LogMessage("Error in validation. The monthly partition: " + currentObjectName + " with query:\r\n" + QueryDefinition + "\r\nhas failed validation because the dates are not a month apart.");
                                       }
                                       break;
                                   case QuarterlyUnit:
                                       if (startDate.AddMonths(3) != endDate)
                                       {
                                           LogMessage("Error in validation. The quarterly partition: " + currentObjectName + " with query:\r\n" + QueryDefinition + "\r\nhas failed validation because the dates are not 3 months apart.");
                                       }
                                       break;
                                   case semimonthlyUnit:
                                       if (startDate.Day == 15)
                                       {
                                           int DaysInCurrMonth = System.DateTime.DaysInMonth(startDate.Year, startDate.Month);
                                           startDate = startDate.AddDays((DaysInCurrMonth - startDate.Day) + 1);
                                       }
                                       else
                                       {
                                           startDate = startDate.AddDays(15 - startDate.Day);
                                       }
                                       if (startDate != endDate)
                                       {
                                           LogMessage("Error in validation. The semimonthlyUnit partition: " + currentObjectName + " with query:\r\n" + QueryDefinition + "\r\nhas failed validation because the dates are not a semimonthlyUnit apart.");
                                       }
                                       break;
                                   case WeeklyUnit:
                                       AdvanceWeeklyPartition(ref startDate);
                                       //Depending on if it's the end of the month, the dates might be 1 date higher than a advanced period apart.
                                       if ((startDate != endDate) && (startDate.AddDays(1) != endDate))
                                       {
                                           LogMessage("Error in validation. The weekly partition: " + currentObjectName + " with query:\r\n" + QueryDefinition + "\r\nhas failed validation because the dates are not a partiton-tool week apart.");
                                       }
                                       break;
                                   default:
                                       break;
                               }
                            }
                            catch (Exception ex)
                            {
                                LogError("Error in scanning partitions to be validated for object: " + currentObjectName + "\r\nwith query:" + QueryDefinition + "\r\nand error: " + ex.Message);
                                return;
                            }
                        }
                        else          //In this case, we are making new partitions.
                        {
                            bool needReenableProactive = false;
                            System.Console.WriteLine("Progress update: On partition" + CurrentPartition.Name);
                            string CurrentPartitionName = CurrentPartition.Name;
                            if (null != CurrentPartition.ProactiveCaching && true == CurrentPartition.ProactiveCaching.Enabled)
                            {
                                CurrentPartition.ProactiveCaching.Enabled = false;
                                CurrentPartition.Update();
                                needReenableProactive = true;
                            }
                            //Not all queries use Microsoft.AnalysisServices.QueryBinding. For those that do not, continue. (non fatal error)
                            string QueryDefinition;
                            try
                            {
                                QueryDefinition = ((Microsoft.AnalysisServices.QueryBinding)(CurrentPartition.Source)).QueryDefinition;
                            }
                            catch (Exception)
                            {
                                ReEnableProactive(needReenableProactive, CurrentPartition);
                                continue;
                            }
                            //See if it's in the past
                            bool isInPast = DeterminePartitionInPast(CurrentPartitionName, RelativeStartingDate);
                            if (true == isInPast)
                            {
                                //Here, we will need to change the source to archivedb.But only if there are rows in archivedb, and not in reportingdb.
                                //This is done by calling p_partitioning_determine_data_exists on both reportingdb and reportarchivedb, which says "Does this query have any results?"
                                //First, though, make sure that the source isn't already reportarchivedb, or that it's a realtime based source
                                if ("ReportArchiveDB" == ((Microsoft.AnalysisServices.QueryBinding)(CurrentPartition.Source)).DataSourceID ||
                                    "ReportRealtimeDB" == ((Microsoft.AnalysisServices.QueryBinding)(CurrentPartition.Source)).DataSourceID )
                                {
                                    ReEnableProactive(needReenableProactive, CurrentPartition);
                                    continue;
                                }
                                Dictionary<string, object> SprocParameters = new Dictionary<string, object>();
                                SprocParameters.Add("vc_querytext", ((Microsoft.AnalysisServices.QueryBinding)(CurrentPartition.Source)).QueryDefinition);
                                //Use a longer timeout for this query as it can take a long time to run. The longer time is acceptable.
                                SqlDataReader ReportingResults = GetDataAdapter("p_partitioning_determine_data_exists", SprocParameters, "ReportingDB", LongQueryTimeout);
                                if (false == ReportingResults.Read())
                                {
                                    //Try to run the sproc p_partitioning_determine_data_exists. If it fails, that's ok (not all tables in reportingdb exist in reportarchivedb)
                                    SqlDataReader ReportArchiveResults;
                                    try
                                    {
                                        ReportArchiveResults = GetDataAdapter("p_partitioning_determine_data_exists", SprocParameters, "ReportArchiveDB", LongQueryTimeout);
                                    }
                                    //If there is an exception, then we don't need to change the data source.
                                    catch (Exception)
                                    {
                                        ReEnableProactive(needReenableProactive, CurrentPartition);
                                        continue;
                                    }
                                    if (ReportArchiveResults.Read())
                                    {
                                        //This will actually change the data source from ReportingDB to ReportArchiveDB
                                        try
                                        {
                                            ((Microsoft.AnalysisServices.QueryBinding)(CurrentPartition.Source)).DataSourceID = "ReportArchiveDB";
                                            CurrentPartition.Process();
                                            CurrentPartition.Update();
                                        }
                                        catch (Exception ex)
                                        {
                                            ReEnableProactive(needReenableProactive, CurrentPartition);
                                            LogError("Error: Could not alter partition " + CurrentPartition.Name + " to ArchiveDB. Perhaps ReportArchiveDB is not defined in the cube? Message: " + ex.Message);
                                        }
                                    }
                                }
                            }
                            else
                            {
                                //Only delete future partitions if we are instructed to. Some modes of operation just enumerate, and don't delete.
                                if (true == DeletingFuturePartitions)
                                {
                                    //Do not delete partitions we did not create.
                                    //Check to see if the partition name frequency unit is "". If so, we should not add
                                    //an entry to the database.
                                    if ("" == GetFrequencyUnitFromPartitionName(CurrentPartition.Name))
                                    {
                                        ReEnableProactive(needReenableProactive, CurrentPartition);
                                        continue;
                                    }
                                    try
                                    {
                                        //Future partitions should not have data.
                                        //If they do, though, log it, but don't error.
                                        if (0 != CurrentPartition.EstimatedRows)
                                        {
                                            LogMessage("Partition: " + CurrentPartition.Name + " has rows, and is in the future. It was not deleted.");
                                        }
                                        else
                                        {
                                            CurrentPartition.Drop();
                                            CurrentMeasure.Update();
                                            //We have to go back one partition since we just dropped one.
                                            i--;
                                            continue;
                                        }
                                    }
                                    catch (Exception ex)
                                    {
                                        ReEnableProactive(needReenableProactive, CurrentPartition);
                                        LogError(ex.Message);
                                    }
                                }
                                ReEnableProactive(needReenableProactive, CurrentPartition);
                               }    //end else (is in past)
                        }

                    }
                }


            }
        }
        catch (Exception ex)
        {
            LogMessage("Error in initialization for database " + DatabaseName + ". Most likely this database is not installed. Error:" + ex.Message);
        }
        }

        public void ReEnableProactive(bool needReenableProactive, Partition CurrentPartition)
        {
            if (true == needReenableProactive)
            {
                System.Console.WriteLine("HACKHACK: Reenabling partition cache");
                CurrentPartition.ProactiveCaching.Enabled = true;
                CurrentPartition.Update();
            }
        }
        //Delete all future partition table entries. This is run
        //after we delete the future partitions from the OLAP DB.
        public void DeleteFuturePartitionTableEntries()
        {
            DateTime currentDate = System.DateTime.Now.AddDays(1);
            int startDate = GetIntegerFromDateTime(currentDate);
            Dictionary<string, object> SprocParameters = new Dictionary<string, object>();
            SprocParameters.Add("i_startdate", startDate);
            GetDataAdapter("p_delete_future_partition_information", SprocParameters, "ReportingDB", DEFAULT_TIMEOUT);
        }

        //taken from ReportSSAS.cs
        private IInterfaceInfo GetServerInterface(string faceName)
        {
            string[] rgszServers = Config.GetServerListByInterface(faceName);
            IPHostEntry iphostentry = Dns.GetHostEntry(Dns.GetHostName());
            IInterfaceInfo face = null;
            IInterfaceInfo curFace = null;

            for (int i = 0; i < rgszServers.Length; i++)
            {
                curFace = Config.GetInterface(rgszServers[i], faceName);
                foreach (IPAddress ipaddress in iphostentry.AddressList)
                {
                    if (curFace.IPAddress.Equals(ipaddress))
                    {
                        face = curFace;
                        break;
                    }
                }
                if (face != null)
                {
                    break;
                }
            }
            return face;
        }


        //We can only use stored procedures, so the command type is not taken as a parameter.
        //Change later if necessary
        public SqlDataReader GetDataAdapter(string StoredProcName, Dictionary<string, object> ProcedureParameters, string DataSource, int queryTimeout)
        {
              //Figure out on what server we have the configuration data
                //Check the data source -- will be a different server for the config data in a multiserver environment
                //rgszServers = Config.GetServerListByInterface("reportingdb");
                rgszServers = Config.GetServerListByInterface(DataSource);
            //Why are we refreshing iitarget, and not caching? Because, based on the DataSource parameter
            //the iiTarget value will change per-run.
            iiTarget = Config.GetInterface(rgszServers[0], DataSource);
            SqlConnection pConn = new SqlConnection(iiTarget.SqlConnectionString);
            SqlCommand pCmd = new SqlCommand();
            pCmd.Connection = pConn;
            pCmd.CommandType = CommandType.StoredProcedure;
            pCmd.CommandText = StoredProcName;
            foreach (string QueryParameter in ProcedureParameters.Keys)
            {
                SqlParameter SqlPassParam = new SqlParameter(QueryParameter, ProcedureParameters[QueryParameter]);
                pCmd.Parameters.Add(SqlPassParam);
            }
            pCmd.CommandTimeout = queryTimeout;
            pConn.Open();
            try
            {
                SqlDataReader sr = pCmd.ExecuteReader();
                return sr;
            }
            catch (Exception ex)
            {
                string ErrorText = "Error: Problem with running stored procedure: " + StoredProcName + " message: " + ex.Message + " with source:" + DataSource;
                throw new Exception(ErrorText);
            }

        }

        //This function takes the name of a partition and figures out if that name is in the past.
        public bool DeterminePartitionInPast(string PartitionName, DateTime startingDate)
        {
            //Only use the greater of tomorrow's date or the passed in date.
            //Why? We NEVER want to delete partitions already created
            //but we don't want to delete partitions in the future before our new starting date.
            System.DateTime tomorrowsDate = DateTime.Now.AddDays(1);
            tomorrowsDate = startingDate > tomorrowsDate ? startingDate : tomorrowsDate;
            System.DateTime PartitionDate = GetDateFromPartitionName(PartitionName);
            if (PartitionDate < tomorrowsDate)
            {
                return true;
            }
            else
            {
                return false;
            }
        }

        //Get the DataReader to provide the frequency unit and/or partition prefix for a given date time
        public SqlDataReader GetPartitionUnitInformation(UniqueMeasureGroupKey currentGroupKey, System.DateTime MonthsToMake)
        {
            Dictionary<string, object> SprocParams = new Dictionary<string, object>();
            SprocParams.Add("vc_ssas_dbname", currentGroupKey.SSAS_DBname);
            SprocParams.Add("vc_cubename", currentGroupKey.VC_Cubename);
            SprocParams.Add("vc_measuregroup", currentGroupKey.VC_MeasureGroup);
            SprocParams.Add("i_startdate", GetIntegerFromDateTime(MonthsToMake));
            SqlDataReader sr = GetDataAdapter("p_get_partition_name", SprocParams, "reportingdb", DEFAULT_TIMEOUT);
            bool HasValue = sr.Read();
            //If we don't have any matches, we have something that needs to be logged as information.
            if (false == HasValue)
            {
                LogMessage("Note: No entry in t_measuregroup_partition_regexes for DB/Cube/Measuregroup:" +
                    currentGroupKey.SSAS_DBname + "/" + currentGroupKey.VC_Cubename +
                    "/" + currentGroupKey.VC_MeasureGroup + ". This means that the partition was not created, and is normal if the partition is not date-dependant.");
                return null;
            }
            //The sproc returns <frequency unit> and <partition prefix>
            return sr;
        }

        //The algorithm to advance a weekly partition is somewhat messy, so it's encapsulated here.
        //FirstAdvance handles the case where we are always going to the next period.
        public void AdvanceWeeklyPartition(ref System.DateTime MonthsToMake)
        {
            //Set the day to the first of the new period, unless we are the first of the month.
            //Weekly periods:
            //Day 1 - Day 7, Day 8-Day 14, Day 15-Day 21, Day 21 - End of Month
            //This means that the last period is > than one week (except in Feb. of non leap years),
            //but it's otherwise impossible
            //to handle switching between weekly and bimonthly and monthly periods
            //without an insane algorithim
                int DaysInCurrMonth = System.DateTime.DaysInMonth(MonthsToMake.Year, MonthsToMake.Month);
                //If the day is after the 21st, go to the 1st of the next month
                if (MonthsToMake.Day > 20)
                {
                    MonthsToMake = MonthsToMake.AddDays((DaysInCurrMonth - MonthsToMake.Day) + 1);
                }
                //If 14-20, set to the 21st.
                else if (MonthsToMake.Day > 14)
                {
                    MonthsToMake = MonthsToMake.AddDays(21 - MonthsToMake.Day);
                }
                //If 7-13, set to the 14th.
                else if (MonthsToMake.Day > 6)
                {
                    MonthsToMake = MonthsToMake.AddDays(14 - MonthsToMake.Day);
                }
                //If 1-6, set to the 7th.
                else
                {
                    MonthsToMake = MonthsToMake.AddDays(7 - MonthsToMake.Day);
                }
           // }
        }
        //Make the names of partitions to be created.
        public void GenerateParitionNames()
        {
            foreach (UniqueMeasureGroupKey currentGroupKey in UniqueMeasureGroupList)
            {
                string FrequencyUnit = "";
                string NamingPattern = "";
                string PartitionPrefix = "";

                //The partition name is formed with a combination of
                //t_measuregroup_partition_regexes.vc_partition_prefix with vc_naming_pattern (same table)
                //and is recovered from the stored procedure p_get_partition_name
                try
                {
                    //XE-84482 -- changing to check the partition name every month for changes.
                    //System.DateTime MonthsToMake = System.DateTime.Now;
                    System.DateTime MonthsToMake = RelativeStartingDate;

                    int DaysInCurrMonth = 0;
                    //XE 85952 -- We need to advance to the beginning of the next <frequency unit> and then
                    //check the partition unit from the sproc again. But only for monthly, semimonthly, and weekly.
                    //Why? Unlike monthly/semimonthly, quarterly only sometimes creates partitions.
                    SqlDataReader partInfo = GetPartitionUnitInformation(currentGroupKey, MonthsToMake);
                    //If we get a null back, go to the next element.
                    if (null == partInfo)
                    {
                        continue;
                    }
                    FrequencyUnit = partInfo.GetString(0);
                    switch (FrequencyUnit)
                    {
                        case MonthlyUnit:
                            //Advance to the beginning of next month.
                            DaysInCurrMonth = System.DateTime.DaysInMonth(MonthsToMake.Year, MonthsToMake.Month);
                            MonthsToMake = MonthsToMake.AddDays((DaysInCurrMonth - MonthsToMake.Day) + 1);
                            break;
                        case semimonthlyUnit:
                            if (MonthsToMake.Day > 15)
                            {
                                //Set to the first day  next month
                                DaysInCurrMonth = System.DateTime.DaysInMonth(MonthsToMake.Year, MonthsToMake.Month);
                                MonthsToMake = MonthsToMake.AddDays((DaysInCurrMonth - MonthsToMake.Day) + 1);
                            }
                            else
                            {
                                //Set to the 15th.
                                MonthsToMake = MonthsToMake.AddDays(15 - MonthsToMake.Day);
                            }
                            break;
                        case QuarterlyUnit:
                                        //Advance to the beginning of next month.
                            DaysInCurrMonth = System.DateTime.DaysInMonth(MonthsToMake.Year, MonthsToMake.Month);
                            MonthsToMake = MonthsToMake.AddDays((DaysInCurrMonth - MonthsToMake.Day) + 1);
                            break;
                        case WeeklyUnit:
                            AdvanceWeeklyPartition(ref MonthsToMake);
                            break;

                    }
                    //Now, figure out what the new frequency unit is, in case it changed. (XE 85952)
                    for (int i = 0; i < LocalNumberOfMonths; i++)
                    {
                        partInfo = GetPartitionUnitInformation(currentGroupKey, MonthsToMake);
                        FrequencyUnit = partInfo.GetString(0);
                        NamingPattern = GetNamingPatternFromPartitionUnit(FrequencyUnit);
                        PartitionPrefix = partInfo.GetString(1);
                        DaysInCurrMonth = 0;

                        switch (FrequencyUnit)
                        {
                            case WeeklyUnit:
                                string MeasureName;
                                DateTime startDate;
                                DaysInCurrMonth = System.DateTime.DaysInMonth(MonthsToMake.Year, MonthsToMake.Month);
                                bool firstRun = true;
                                while ((true == firstRun) || (1 != MonthsToMake.Day))
                                {
                                    firstRun = false;
                                    //For weekly, we use the "Value" token to show the start of the weekly partition
                                    string WeekBeginning = MonthsToMake.Day.ToString();
                                    if (WeekBeginning.Length == 1)
                                    {
                                        WeekBeginning = "0" + WeekBeginning;
                                    }


                                    startDate = MonthsToMake;
                                    currentGroupKey.PartitionTimeStart = startDate;
                                    //Each partition is a week long, except the one starting the 21st -- that one
                                    //is the size of the rest of the month.
                                    if (MonthsToMake.Day == 22)
                                    {
                                        MonthsToMake = MonthsToMake.AddDays(DaysInCurrMonth - MonthsToMake.Day);
                                        MeasureName = ExpandNamingPattern(NamingPattern, PartitionPrefix, MonthsToMake, WeekBeginning);

                                        MonthsToMake = MonthsToMake.AddDays(1);
                                    }
                                    else
                                    {
                                        MonthsToMake = MonthsToMake.AddDays(7);
                                        MeasureName = ExpandNamingPattern(NamingPattern, PartitionPrefix, MonthsToMake, WeekBeginning);

                                    }
                                    currentGroupKey.PartitionName = MeasureName;
                                    currentGroupKey.PartitionTimeEnd = MonthsToMake;
                                    PartitionsToCreate.Add(new UniqueMeasureGroupKey(currentGroupKey));
                                  //  AdvanceWeeklyPartition(ref MonthsToMake);
                                }
                            break;
                            case MonthlyUnit:
                                //Set the day to the first of the new period, unless we are the first of the month.
                                if (1 != MonthsToMake.Day)
                                {
                                    DaysInCurrMonth = System.DateTime.DaysInMonth(MonthsToMake.Year, MonthsToMake.Month);
                                    MonthsToMake = MonthsToMake.AddDays((DaysInCurrMonth - MonthsToMake.Day) + 1);
                                }
                                //For monthly, we have no need of the "Value" token.
                                MeasureName = ExpandNamingPattern(NamingPattern, PartitionPrefix, MonthsToMake, "");
                                currentGroupKey.PartitionName = MeasureName;
                                startDate = MonthsToMake;
                                currentGroupKey.PartitionTimeStart = startDate;
                                MonthsToMake = MonthsToMake.AddMonths(1);
                                currentGroupKey.PartitionTimeEnd = MonthsToMake;
                                PartitionsToCreate.Add(new UniqueMeasureGroupKey(currentGroupKey));
                                break;
                            case semimonthlyUnit:

                                //Set the day to the first of the new period (Either 1st or 15th)
                                if (MonthsToMake.Day > 15)
                                {
                                    //Set to the first day  next month
                                    DaysInCurrMonth = System.DateTime.DaysInMonth(MonthsToMake.Year, MonthsToMake.Month);
                                    MonthsToMake = MonthsToMake.AddDays((DaysInCurrMonth - MonthsToMake.Day) + 1);
                                }
                                //If we are on the first, no need to advance
                                else if (MonthsToMake.Day != 1)
                                {
                                    //Set to the 15th.
                                    MonthsToMake = MonthsToMake.AddDays(15 - MonthsToMake.Day);
                                }
                                //For semimonthly, we have no need of the "Value" token.
                                MeasureName = ExpandNamingPattern(NamingPattern, PartitionPrefix, MonthsToMake, "");
                                currentGroupKey.PartitionName = MeasureName;
                                startDate = MonthsToMake;
                                currentGroupKey.PartitionTimeStart = startDate;
                                //Now, add a second period. We will only create it, though, if it will be from the 15th->end of month
                                //(You could be creating just a partition from the 15th to the end of the month, in which case we need to NOT create a second partition).
                                //Set the day to the first of the new period (Either 1st or 15th)
                                if (MonthsToMake.Day == 15)
                                {
                                    //Set to the first day  next month
                                    DaysInCurrMonth = System.DateTime.DaysInMonth(MonthsToMake.Year, MonthsToMake.Month);
                                    MonthsToMake = MonthsToMake.AddDays((DaysInCurrMonth - MonthsToMake.Day) + 1);
                                }

                                else
                                {
                                    //Set to the 15th.
                                    MonthsToMake = MonthsToMake.AddDays(15 - MonthsToMake.Day);
                                }
                                currentGroupKey.PartitionTimeEnd = MonthsToMake;
                                PartitionsToCreate.Add(new UniqueMeasureGroupKey(currentGroupKey));
                                if (MonthsToMake.Day == 15)
                                {
                                    MeasureName = ExpandNamingPattern(NamingPattern, PartitionPrefix, MonthsToMake, "");
                                    currentGroupKey.PartitionName = MeasureName;
                                    startDate = MonthsToMake;
                                    currentGroupKey.PartitionTimeStart = startDate;

                                    //Set the end day to the 1st of the next month.
                                    DaysInCurrMonth = System.DateTime.DaysInMonth(MonthsToMake.Year, MonthsToMake.Month);
                                    MonthsToMake = MonthsToMake.AddDays((DaysInCurrMonth - MonthsToMake.Day) + 1);
                                    currentGroupKey.PartitionTimeEnd = MonthsToMake;
                                    PartitionsToCreate.Add(new UniqueMeasureGroupKey(currentGroupKey));
                                }
                                break;
                            case QuarterlyUnit:
                                //Algorithim: If month 0, or the # of months evenly divides 4, it's a new quarter. NO!
                                //We specify number of months, and need to determine how many quarters to make.
                                if (MonthsToMake.Month == 1 || MonthsToMake.Month == 4 || MonthsToMake.Month == 7 || MonthsToMake.Month == 10)
                                {
                                    //For quarterly, we use the quarter data as "value". Quarter is (month + 2)/3, rounded down
                                    string QuarterName = ((MonthsToMake.Month + 2) / 3).ToString();
                                    //GeneratedNames.Add(ExpandNamingPattern(NamingPattern, PartitionPrefix, MonthsToMake, QuarterName));
                                    MeasureName = ExpandNamingPattern(NamingPattern, PartitionPrefix, MonthsToMake, QuarterName);
                                    currentGroupKey.PartitionName = MeasureName;
                                    //Dates for quarters are hard-coded to avoid any algorithmic errors.
                                    switch (MonthsToMake.Month)        //Use month name not quarter as we need start date, instead of end date
                                    {
                                        case 1:
                                            currentGroupKey.PartitionTimeStart = new DateTime(MonthsToMake.Year, 1, 1);
                                            currentGroupKey.PartitionTimeEnd = new DateTime(MonthsToMake.Year, 4, 1);
                                            break;
                                        case 4:
                                            currentGroupKey.PartitionTimeStart = new DateTime(MonthsToMake.Year, 4, 1);
                                            currentGroupKey.PartitionTimeEnd = new DateTime(MonthsToMake.Year, 7, 1);
                                            break;
                                        case 7:
                                            currentGroupKey.PartitionTimeStart = new DateTime(MonthsToMake.Year, 7, 1);
                                            currentGroupKey.PartitionTimeEnd = new DateTime(MonthsToMake.Year, 10, 1);
                                            break;
                                        case 10:
                                            currentGroupKey.PartitionTimeStart = new DateTime(MonthsToMake.Year, 10, 1);
                                            currentGroupKey.PartitionTimeEnd = new DateTime((MonthsToMake.Year + 1), 1, 1);
                                            break;

                                    }
                                    PartitionsToCreate.Add(new UniqueMeasureGroupKey(currentGroupKey));
                                }
                                //Set to the first day  next month
                                DaysInCurrMonth = System.DateTime.DaysInMonth(MonthsToMake.Year, MonthsToMake.Month);
                                MonthsToMake = MonthsToMake.AddDays((DaysInCurrMonth - MonthsToMake.Day) + 1);

                                break;
                            default:
                                LogError("Error: Unknown partition frequency unit encountered in GenerateParitionNames:" + FrequencyUnit);
                                break;
                        }
                    }
                }
                catch (Exception ex)
                {
                    LogError("Error making partition names: " + ex.Message);
                    return;
                }
            }
            NameGenerationComplete = true;
        }

        //This function actually makes the new partitions.
        public void GenerateFuturePartitions(string DatabaseName)
        {
            //Ensure, through NameGenerationComplete, that we ran GenerateParitionNames
            //to figure out what partitions to create.
            if (false == NameGenerationComplete)
            {
                string ErrMsg = "Error: Name generation not complete. Generation cannot continue.";
                LogError(ErrMsg);
                return;
            }
            foreach (UniqueMeasureGroupKey currentKey in PartitionsToCreate)
            {
                //Find the cube we want. We have to reference it by finding the name because
                //you can't do a bracket operator on name, only "ID" (not the same as name)
                olapDb = olapServer.Databases.FindByName(DatabaseName);
                foreach (Cube currentCube in olapDb.Cubes)
                {
                    if (currentCube.Name == currentKey.VC_Cubename)
                    {
                        //Copy an old partition, and change its name and source.
                        string currentMeasureGroupId = "";
                        foreach (MeasureGroup curMeasure in currentCube.MeasureGroups)
                        {
                            if (curMeasure.Name == currentKey.VC_MeasureGroup)
                            {
                                currentMeasureGroupId = curMeasure.ID;
                                break;
                            }
                        }
                        Partition NewPartition = currentCube.MeasureGroups[currentMeasureGroupId].Partitions[0].Clone();
                        System.Console.WriteLine("Progress update: On Measuregroup: " + currentCube.Name + "/" + currentKey.VC_MeasureGroup);
                        NewPartition.Name = currentKey.PartitionName;
                        NewPartition.ID = currentCube.MeasureGroups[currentMeasureGroupId].Name + "_" + NewPartition.Name;
                        //Handle the case where we found a partition with no date -- this is acceptable, just don't create any future ones from it.
                        try
                        {
                            string newQuery = GetNewPartitionQuery(currentKey);
                            if ("" == newQuery)
                            {
                                continue;
                            }
                            else
                            {
                                ((Microsoft.AnalysisServices.QueryBinding)(NewPartition.Source)).QueryDefinition = newQuery;
                            }
                        }
                        catch (Exception ex)
                        {
                            LogError(ex.Message);
                        }

                        //If this is a proactive caching partition, we need to update our polling and processing queries
                        if (null != NewPartition.ProactiveCaching &&
                            true == NewPartition.ProactiveCaching.Enabled)
                        {



                            ProactiveCachingIncrementalProcessingBinding pBinding = null;

                            try
                            {
                                NewPartition.ProactiveCaching.Enabled = false;
                                pBinding = NewPartition.ProactiveCaching.Source
                                   as ProactiveCachingIncrementalProcessingBinding;
                                if (null != pBinding)
                                {
                                    string szNewProcessingQuery = GetNewPartitionProcessingQuery(
                                        pBinding.IncrementalProcessingNotifications[0].ProcessingQuery, currentKey);

                                    pBinding.IncrementalProcessingNotifications[0].ProcessingQuery = szNewProcessingQuery;
                                    NewPartition.ProactiveCaching.Enabled = true;
                                }

                            }
                            catch (Exception ex)
                            {
                                LogError(ex.Message);
                            }
                        }


                        string theError = "";
                        bool CanAdd = currentCube.MeasureGroups[currentMeasureGroupId].Partitions.CanAdd(NewPartition, out theError);
                        try
                        {
                            int result = currentCube.MeasureGroups[currentMeasureGroupId].Partitions.Add(NewPartition);
                            currentCube.MeasureGroups[currentMeasureGroupId].Partitions[result].Update();
                        }
                        catch (Exception ex)
                        {
                            string ErrMsg = "Error adding new partition: " + NewPartition.Name + ", error " + ex.Message;
                            //If we are working in the past using the startDate parameter, this is informational and not fatal.
                            //Why take a day away from DateTime.Now? We passed the relative starting date at function call time and some time has elapsed
                            //so we want to be sure that we are close to the date of running the application to determine that we are in the present.
                            if (DateTime.Now.AddDays(-1) < RelativeStartingDate)
                            {
                                LogError(ErrMsg);
                            }
                            else
                            {
                                LogMessage("Non-Fatal Error due to running in Past: " + ErrMsg);
                            }
                        }
                        try
                        {

                            //Now, add a new entry into t_measuregroup_partition_regexes for this new partition:
                            Dictionary<string, object> SprocParameters = new Dictionary<string, object>();
                            SprocParameters.Add("vc_ssas_dbname", currentKey.SSAS_DBname);
                            SprocParameters.Add("vc_cubename", currentCube.Name);
                            SprocParameters.Add("vc_measuregroup", currentCube.MeasureGroups[currentMeasureGroupId].Name);
                            SprocParameters.Add("vc_frequency_unit", GetFrequencyUnitFromPartitionName(NewPartition.Name));
                            SprocParameters.Add("vc_partition_prefix", DeterminePartitionPrefix(NewPartition.Name));
                            string QueryDefinition = ((Microsoft.AnalysisServices.QueryBinding)(NewPartition.Source)).QueryDefinition;
                            SprocParameters.Add("vc_query_def", (QueryDefinition));
                            SprocParameters.Add("i_startdate", GetStartDateFromQuery(QueryDefinition));
                            SprocParameters.Add("i_enddate", GetEndDateFromQuery(QueryDefinition));
                            SprocParameters.Add("vc_query_base_table", GetBaseTableFromQuery(QueryDefinition));
                            SqlDataReader blankTable = GetDataAdapter("p_modify_t_measuregroup_partition_regexes", SprocParameters, "reportingdb", DEFAULT_TIMEOUT);
                            blankTable.Read();

                        }
                        catch (Exception ex)
                        {
                            string ErrMsg = "Error adding new partition to database: " + NewPartition.Name + ", error " + ex.Message;
                            LogError(ErrMsg);
                        }
                        break;
                    }
                }
            }


        }

        //This function gets us the new query for a partition to be created.
        public string GetNewPartitionQuery(UniqueMeasureGroupKey PartitionKey)
        {
            //Using the sproc p_get_latest_partition_query, we can find out the latest query for a given db/cube/measuregroup
            Dictionary<string, object> SprocParameters = new Dictionary<string, object>();
            SprocParameters.Add("vc_ssas_dbname", PartitionKey.SSAS_DBname);
            SprocParameters.Add("vc_cubename", PartitionKey.VC_Cubename);
            SprocParameters.Add("vc_measuregroup", PartitionKey.VC_MeasureGroup);
            SqlDataReader LatestPartition = GetDataAdapter("p_get_latest_partition_query", SprocParameters, "ReportingDB", DEFAULT_TIMEOUT);
            //This proc returns only one value -- the latest query. We need to then change the dates
            bool AnyResults = LatestPartition.Read();
            if (false == AnyResults)
            {
                string ErrMes = "Error in GetNewPartitionQuery. No results for Latest Partition Query.";
                LogError(ErrMes);
                throw (new Exception(ErrMes));
            }
            string currentQuery = LatestPartition.GetString(0);
            int NewEndDate = GetIntegerFromDateTime(PartitionKey.PartitionTimeEnd);
            int NewStartDate = GetIntegerFromDateTime(PartitionKey.PartitionTimeStart);
            string OrigStartDate = GetStartDateFromQuery(currentQuery);
            string OrigEndDate = GetEndDateFromQuery(currentQuery);
            string RetVal = currentQuery;
            //Note: change the end date first, becuase otherwise you will not create the date range correctly.
            //example: 1/1-2/1 becomes 2/1-3/1, but if you change start first it becomes 3/1-3/1
            //However, if the new end date = the original start date, this will work incorrectly.
            //In that case, replace the original start date first.
            if (OrigStartDate.ToString().Equals(NewEndDate.ToString()))
            {
                RetVal = RetVal.Replace(OrigStartDate, NewStartDate.ToString());
                RetVal = RetVal.Replace(OrigEndDate, NewEndDate.ToString());
            }
            else
            {
                RetVal = RetVal.Replace(OrigEndDate, NewEndDate.ToString());
                RetVal = RetVal.Replace(OrigStartDate, NewStartDate.ToString());
            }

            return RetVal;
        }

        //This function gets us the new polling query.
        public string GetNewPartitionPollingQuery(string OldPollingQuery, UniqueMeasureGroupKey PartitionKey)
        {
            int NewEndDate = GetIntegerFromDateTime(PartitionKey.PartitionTimeEnd);
            int NewStartDate = GetIntegerFromDateTime(PartitionKey.PartitionTimeStart);
            string OrigStartDate = GetStartDateFromQuery(OldPollingQuery);
            string OrigEndDate = GetEndDateFromQuery(OldPollingQuery);
            string RetVal = OldPollingQuery;
            //Note: change the end date first, becuase otherwise you will not create the date range correctly.
            //example: 1/1-2/1 becomes 2/1-3/1, but if you change start first it becomes 3/1-3/1
            RetVal = RetVal.Replace(OrigEndDate, NewEndDate.ToString());
            RetVal = RetVal.Replace(OrigStartDate, NewStartDate.ToString());

            return RetVal;
        }

        //This function gets us the new incremental processing query.
        public string GetNewPartitionProcessingQuery(string OldProcessingQuery, UniqueMeasureGroupKey PartitionKey)
        {
            int NewEndDate = GetIntegerFromDateTime(PartitionKey.PartitionTimeEnd);
            int NewStartDate = GetIntegerFromDateTime(PartitionKey.PartitionTimeStart);
            string OrigStartDate = GetStartDateFromQuery(OldProcessingQuery);
            string OrigEndDate = GetEndDateFromQuery(OldProcessingQuery);
            string RetVal = OldProcessingQuery;
            //Note: change the end date first, becuase otherwise you will not create the date range correctly.
            //example: 1/1-2/1 becomes 2/1-3/1, but if you change start first it becomes 3/1-3/1
            RetVal = RetVal.Replace(OrigEndDate, NewEndDate.ToString());
            RetVal = RetVal.Replace(OrigStartDate, NewStartDate.ToString());

            return RetVal;
        }

        //Turn a naming pattern into a real name.
        public static string ExpandNamingPattern(string Pattern, string Prefix, DateTime PatternDate, string Value)
        {
            Pattern = Pattern.Replace("<prefix>", Prefix);
            Pattern = Pattern.Replace("<year>", PatternDate.Year.ToString());
            Pattern = Pattern.Replace("<value>", Value);
            //Add a preceding 0 to days less than 10 to keep them 2 digit.
            string ReplaceDay = PatternDate.Day.ToString();
            if (PatternDate.Day < 10)
            {
                ReplaceDay = "0" + ReplaceDay;
            }
            Pattern = Pattern.Replace("<day>", ReplaceDay);
            //Add a preceding 0 to months less than 10 to keep them 2 digit.
            string ReplaceMonth = PatternDate.Month.ToString();
            if (PatternDate.Month < 10)
            {
                ReplaceMonth = "0" + ReplaceMonth;
            }
            Pattern = Pattern.Replace("<month>", ReplaceMonth);
            return Pattern;
        }


    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\xereports\Reports\makefile.inc ===
RdlCopy : makefile.inc
    -md %_NT386TREE%\tools\xereports\rosetta
    for /f %i in ('dir /b *.rdl') do type %i | perl -pe "s/\<\<BUILDNUMBER\>\>/%_BLDVERMAJOR%.%_BLDVERMINOR%.%_BLDNUMMAJOR%.%_BLDNUMMINOR%/" > %_NT386TREE%\tools\xereports\rosetta\%i
    for /f %i in ('dir /b *.rss') do type %i | perl -pe "s/\<\<BUILDNUMBER\>\>/%_BLDVERMAJOR%.%_BLDVERMINOR%.%_BLDNUMMAJOR%.%_BLDNUMMINOR%/" > %_NT386TREE%\tools\xereports\rosetta\%i
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\xereports\RosettaInstall\console\obj\i386\_generated.cs ===
[assembly:System.Runtime.InteropServices.ComVisible(false)]
[assembly:System.Reflection.AssemblyVersion("12.4.56.0")]
[assembly:System.Reflection.AssemblyProduct("DEPOT")]
[assembly:System.Reflection.AssemblyCopyright("")]
[assembly:System.Reflection.AssemblyCompany("")]
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\xereports\Reports\obj\i386\_asmid.inc ===
ASSEMBLY_IDENTITY_KEY_FORM=x86__reports_1_none_12.4.56.0_none_e40695e2cad59888
ASSEMBLY_IDENTITY_XP_KEY_FORM=x86__reports_1_no-public-key_12.4.56.0_x-ww_f7849108
ASSEMBLY_IDENTITY_CULTURE=
ASSEMBLY_IDENTITY_NAME=_reports_1
ASSEMBLY_IDENTITY_PROCESSOR_ARCHITECTURE=x86
ASSEMBLY_IDENTITY_PUBLIC_KEY=
ASSEMBLY_IDENTITY_PUBLIC_KEY_TOKEN=
ASSEMBLY_IDENTITY_TYPE=
ASSEMBLY_IDENTITY_TYPE_NAME=
ASSEMBLY_IDENTITY_VERSION=12.4.56.0
XP_KEY_FORM=x86__reports_1_no-public-key_12.4.56.0_x-ww_f7849108
XP_MANIFEST_DIRECTORY=manifests
XP_MANIFEST_NAME=x86__reports_1_no-public-key_12.4.56.0_x-ww_f7849108.manifest
XP_MANIFEST_PATH=manifests\x86__reports_1_no-public-key_12.4.56.0_x-ww_f7849108.manifest
XP_CATALOG_DIRECTORY=manifests
XP_CATALOG_NAME=x86__reports_1_no-public-key_12.4.56.0_x-ww_f7849108.cat
XP_CATALOG_PATH=manifests\x86__reports_1_no-public-key_12.4.56.0_x-ww_f7849108.cat
XP_PAYLOAD_PATH=x86__reports_1_no-public-key_12.4.56.0_x-ww_f7849108
_DELAY_SIGN=0
!if [set _ASMIDTOATTRIBS_TLBIMP=]
!endif
CODESIGN_TESTKEY=
_TLBIMP_FLAGS=$(_TLBIMP_FLAGS)  /asmversion:12.4.56.0
_ASSEMBLY_IDENTITY=_reports_1,processorArchitecture=x86,version=12.4.56.0,publicKeyToken=neutral
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\xereports\RosettaInstall\console\objd\i386\_generated.cs ===
[assembly:System.Runtime.InteropServices.ComVisible(false)]
[assembly:System.Reflection.AssemblyVersion("12.4.56.0")]
[assembly:System.Reflection.AssemblyProduct("DEPOT")]
[assembly:System.Reflection.AssemblyCopyright("")]
[assembly:System.Reflection.AssemblyCompany("")]
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\xereports\Reports\objd\i386\_asmid.inc ===
ASSEMBLY_IDENTITY_KEY_FORM=x86__reports_1_none_12.4.56.0_none_e40695e2cad59888
ASSEMBLY_IDENTITY_XP_KEY_FORM=x86__reports_1_no-public-key_12.4.56.0_x-ww_f7849108
ASSEMBLY_IDENTITY_CULTURE=
ASSEMBLY_IDENTITY_NAME=_reports_1
ASSEMBLY_IDENTITY_PROCESSOR_ARCHITECTURE=x86
ASSEMBLY_IDENTITY_PUBLIC_KEY=
ASSEMBLY_IDENTITY_PUBLIC_KEY_TOKEN=
ASSEMBLY_IDENTITY_TYPE=
ASSEMBLY_IDENTITY_TYPE_NAME=
ASSEMBLY_IDENTITY_VERSION=12.4.56.0
XP_KEY_FORM=x86__reports_1_no-public-key_12.4.56.0_x-ww_f7849108
XP_MANIFEST_DIRECTORY=manifests
XP_MANIFEST_NAME=x86__reports_1_no-public-key_12.4.56.0_x-ww_f7849108.manifest
XP_MANIFEST_PATH=manifests\x86__reports_1_no-public-key_12.4.56.0_x-ww_f7849108.manifest
XP_CATALOG_DIRECTORY=manifests
XP_CATALOG_NAME=x86__reports_1_no-public-key_12.4.56.0_x-ww_f7849108.cat
XP_CATALOG_PATH=manifests\x86__reports_1_no-public-key_12.4.56.0_x-ww_f7849108.cat
XP_PAYLOAD_PATH=x86__reports_1_no-public-key_12.4.56.0_x-ww_f7849108
_DELAY_SIGN=0
!if [set _ASMIDTOATTRIBS_TLBIMP=]
!endif
CODESIGN_TESTKEY=
_TLBIMP_FLAGS=$(_TLBIMP_FLAGS)  /asmversion:12.4.56.0
_ASSEMBLY_IDENTITY=_reports_1,processorArchitecture=x86,version=12.4.56.0,publicKeyToken=neutral
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\xereports\RosettaInstall\core\makefile.inc ===
!include $(INETROOT)\build\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\xereports\RosettaInstall\console\RosettaInstallConsole.cs ===
using System;
using xonline.tools.reporting.rosetta.core;

namespace xonline.tools.reporting.rosetta.console
{
    class RosettaInstallConsole
    {
        [STAThread]
        static void Main( string[] rgszArgs )
        {
            RosettaInstall pRosetta;

            pRosetta = new RosettaInstall( );
            pRosetta.OnMessage += new MessageEventHandler(_OnMessage);
            try
            {
                pRosetta.Execute( Environment.CurrentDirectory );
            }
            catch( Exception exc )
            {
                Console.WriteLine( exc.ToString( ) );
            }

            return;
        }

        static void Usage( )
        {
            Console.WriteLine( "Usage: RosettaInstall.exe" );
        }

        static void _OnMessage(object sender, MessageEventArgs e)
        {
            Console.WriteLine(e.Message);
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\xereports\ReplicationSetup\ReplicationSetup.cs ===
using System;
using System.Collections;
using System.Collections.Generic;
using System.Data;
using System.Data.SqlClient;
using System.Diagnostics;
using System.IO;
using System.Management;
using System.Net;
using System.Reflection;
using System.Threading;
using System.Xml;
using Microsoft.SqlServer.Management.Common;
using Microsoft.SqlServer.Management.Smo;
using Microsoft.SqlServer.Management.Smo.Agent;
using Microsoft.SqlServer.Replication;
using xonline.common.config;

namespace xonline.tools.reporting.replication
{
    class ReplicationSetup
    {
        static private bool s_fVerbose = false;

        private int m_iMaxRetention;
        private int m_iMaxHistory;
        private string m_szDistributionDb;
        private string m_szDataFilePath;
        private string m_szLogFilePath;
        private string m_szReplShare;
        private string m_szReplDirectory;
        private string m_szUsername;
        private string m_szPassword;
        private bool m_fUseSQLAgentLogin;
        private int m_iDataFileSize;
        private int m_iLogFileSize;
        private int m_iDataFileGrowth;
        private int m_iLogFileGrowth;
        private int[] m_rgProfileIds = { 1, 2, 4, 6, 11 };
        private Hashtable m_hashDistributionDB;
        private Hashtable m_hashRemoteDistributionMap;
        private int m_iErrors;
        private int m_iBcpBatchSize;
        private bool m_fCreateDirectories;

        #region Private Classes
        private class ArticleParams
        {
            public string szArticle = string.Empty;
            public string szTarget = string.Empty;
            public bool fNoDelete = false;
            public bool fKeepNCI = false;
        }

        private class DistributorInfo
        {
            public string szServer = string.Empty;
            public string szConnectionString = string.Empty;

            public override bool Equals(object obj)
            {
                DistributorInfo pInfo = obj as DistributorInfo;

                if (null != pInfo && (pInfo.szServer == this.szServer))
                {
                    return true;
                }

                return false;
            }

            public override int GetHashCode()
            {
                return base.GetHashCode();
            }
        }

        private class PublisherInfo
        {
            public string szPublisher = string.Empty;
            public string szDistributor = string.Empty;

            public override bool Equals(object obj)
            {
                PublisherInfo pInfo = obj as PublisherInfo;

                if (null != pInfo && (pInfo.szPublisher == this.szPublisher)
                    && (pInfo.szDistributor == this.szDistributor))
                {
                    return true;
                }

                return false;
            }

            public override int GetHashCode()
            {
                return base.GetHashCode();
            }
        }

        private class PublishedDatabaseInfo
        {
            public string szServer = string.Empty;
            public string szDatabase = string.Empty;

            public override bool Equals(object obj)
            {
                PublishedDatabaseInfo pInfo = obj as PublishedDatabaseInfo;

                if (null != pInfo && (pInfo.szServer == this.szServer) &&
                    (pInfo.szDatabase == this.szDatabase))
                {
                    return true;
                }

                return false;
            }

            public override int GetHashCode()
            {
                return base.GetHashCode();
            }
        }

        private class PublicationInfo
        {
            public string szServer = string.Empty;
            public string szDatabase = string.Empty;
            public string szPublication = string.Empty;
            public List<ArticleParams> rgArticles = new List<ArticleParams>();
            public PublicationType pubType = PublicationType.Transactional;

            public override bool Equals(object obj)
            {
                PublicationInfo pInfo = obj as PublicationInfo;

                if (null != pInfo && (pInfo.szServer == this.szServer) &&
                    (pInfo.szDatabase == this.szDatabase) &&
                    (pInfo.szPublication == this.szPublication))
                {
                    return true;
                }

                return false;
            }

            public override int GetHashCode()
            {
                return base.GetHashCode();
            }
        }

        private class SubscriptionInfo
        {
            public string szPubServer = string.Empty;
            public string szSubServer = string.Empty;
            public string szPublicationDb = string.Empty;
            public string szPublicationName = string.Empty;
            public string szSubscriberDb = string.Empty;

            public override bool Equals(object obj)
            {
                SubscriptionInfo pInfo = obj as SubscriptionInfo;

                if (null != pInfo && (pInfo.szPubServer == this.szPubServer) &&
                    (pInfo.szSubServer == this.szSubServer) &&
                    (pInfo.szPublicationDb == this.szPublicationDb) &&
                    (pInfo.szPublicationName == this.szPublicationName) &&
                    (pInfo.szSubscriberDb == this.szSubscriberDb))
                {
                    return true;
                }

                return false;
            }

            public override int GetHashCode()
            {
                return base.GetHashCode();
            }
        }

        private class SnapshotInfo
        {
            public string szPublication = string.Empty;
            public List<PublicationInfo> rgPublications = new List<PublicationInfo>();
        }

        private interface IPostStep
        {
            void Execute();
        }

        private class SqlPostStep : IPostStep
        {
            public string szConnectionString = string.Empty;
            public string szQuery = string.Empty;
            public int iTimeout = 300;

            public void Execute()
            {
                using (SqlConnection pConn = new SqlConnection(szConnectionString))
                {
                    string szShortQuery;

                    SqlCommand pCmd = new SqlCommand();
                    pCmd.Connection = pConn;
                    pCmd.CommandType = CommandType.Text;
                    pCmd.CommandText = szQuery;
                    pCmd.CommandTimeout = iTimeout;

                    szShortQuery = szQuery.Length > 50 ? szQuery.Substring(0, 50) : szQuery;

                    try
                    {
                        pConn.Open();

                        ReplicationSetup.LogVerbose(string.Format("Executing post-step command: \"{0}\".",
                            szShortQuery));

                        pCmd.ExecuteNonQuery();
                    }
                    catch (Exception e)
                    {
                        ReplicationSetup.LogException(
                            string.Format("Error trying to execute post-step command: \"{0}\" against connection: \"{1}\".",
                            szShortQuery, szConnectionString), e);
                        throw e;
                    }
                }
            }
        }

        private class DelayPostStep : IPostStep
        {
            public int iDelayMS = 0;

            public void Execute()
            {
                if (iDelayMS > 0)
                {
                    ReplicationSetup.LogVerbose(string.Format("Waiting {0}ms before executing next post step.", iDelayMS));
                    Thread.Sleep(iDelayMS);
                }
            }
        }

        private class StepCollection
        {
            public List<IPostStep> rgSteps = new List<IPostStep>();
            public string szSubscriber = string.Empty;
            public string szSubscriberDb = string.Empty;
            public string szPublication = string.Empty;
        }

        private class PublicationWait
        {
            public PublicationInfo pPublication;
            public AutoResetEvent hEvent;
        }
        #endregion

        static int Main(string[] args)
        {
            ReplicationSetup pSetup;
            int iRet;

            pSetup = new ReplicationSetup();
            if(pSetup.Init())
            {
                iRet = pSetup.Run(args);
            }
            else
            {
                iRet = -1;
            }

            return iRet;
        }

        public bool Init()
        {
            string[] rgszServers;

            m_hashDistributionDB = new Hashtable();
            m_hashRemoteDistributionMap = new Hashtable();

            //
            // Initialize various settings
            //
            CSetupSecureResolver setupResolver = new CSetupSecureResolver();

            // Verify that there is an interface for our replication target server
            rgszServers = Config.GetServerListByInterface(Interface.xblmetadb);
            if (0 == rgszServers.Length)
            {
                Log("Unable to find any servers with the xblmetadb interface.");
                return false;
            }
            IInterfaceInfo iiInfo = Config.GetInterface(rgszServers[0], Interface.xblmetadb);

            m_szUsername = iiInfo.Username;
            m_szPassword = setupResolver.UserSecret(iiInfo.Password);
            m_fUseSQLAgentLogin = true;
            m_fCreateDirectories = false;

            m_iMaxRetention = int.Parse(Config.GetSetting("reporting_DistributionMaxRetention"));
            m_iMaxHistory = int.Parse(Config.GetSetting("reporting_DistributionMaxHistoryRetention"));
            m_szDistributionDb = Config.GetSetting("reporting_DistributionDBName");
            m_szReplShare = Config.GetSetting("reporting_ReplicationShare");
            m_szReplDirectory = Config.GetSetting("reporting_ReplicationDirectory");
            m_szDataFilePath = Config.GetSetting("setup_sqldbroot");
            m_szLogFilePath = Config.GetSetting("setup_sqllogroot");
            m_iDataFileSize = int.Parse(Config.GetSetting("reporting_DistributionDataFileSize"));
            m_iLogFileSize = int.Parse(Config.GetSetting("reporting_DistributionLogFileSize"));
            m_iDataFileGrowth = int.Parse(Config.GetSetting("reporting_DistributionDataFileGrowth"));
            m_iLogFileGrowth = int.Parse(Config.GetSetting("reporting_DistributionLogFileGrowth"));
            m_iBcpBatchSize = int.Parse(Config.GetSetting("reporting_SnapshotBcpBatchSize"));

            m_iErrors = 0;

            return true;
        }

        public int Run(string[] args)
        {
            string szFile = string.Empty;
            XmlDocument xmlDoc;
            XmlNodeList xmlList;

            foreach(string szArg in args)
            {
                if ('-' == szArg[0])
                {
                    if ("-v" == szArg.ToLower())
                    {
                        s_fVerbose = true;
                    }
                    else if ("-p" == szArg.ToLower())
                    {
                        m_fUseSQLAgentLogin = false;
                    }
                    else if ("-c" == szArg.ToLower())
                    {
                        m_fCreateDirectories = true;
                    }
                    else
                    {
                        Usage();
                        return -1;
                    }
                }
                else if (string.Empty == szFile)
                {
                    szFile = szArg;
                }
                else
                {
                    //
                    // We already have the filename... this is an invalid arg
                    //
                    Usage();
                    return -1;
                }
            }

            if (string.Empty == szFile)
            {
                Usage();
                return -1;
            }

            LogVerbose("Starting Replication Setup v"+FileVersionInfo.GetVersionInfo(Assembly.GetExecutingAssembly().Location).FileVersion);
            xmlDoc = new XmlDocument();
            xmlDoc.Load(szFile);

            if (1 == xmlDoc.SelectNodes("/ReplicationTopology/DistributionMap").Count)
            {
                _MapRemoteDistributors(xmlDoc.SelectSingleNode("/ReplicationTopology/DistributionMap"));
            }

            if (0 == xmlDoc.SelectNodes("/ReplicationTopology/ReplicationGroup").Count ||
                0 == xmlDoc.SelectNodes("/ReplicationTopology/ReplicationGroup/Replication").Count)
            {
                Log("Unable to find any replication objects to create. Are you using a valid XML file?");
                return -1;
            }

            xmlList = xmlDoc.SelectNodes("/ReplicationTopology/ReplicationGroup");
            foreach (XmlNode xNode in xmlList)
            {
                _CreateReplicationGroup(xNode);
            }

            if (0 == m_iErrors)
            {
                return 0;
            }
            else
            {
                Log(string.Format("Encountered {0} fatal errors.", m_iErrors));
                return -1;
            }
        }

        static private void Usage()
        {
            Console.WriteLine("Usage: ReplicationSetup [-v] [-p] [-c] <xmlfile>");
            Console.WriteLine("   -v : Verbose output");
            Console.WriteLine("   -p : Jobs should use proxy accounts and not the SQL Server Agent account");
            Console.WriteLine("   -c : Create & set permissions on the replication directories,"+
                              "        instead of verifying.");
        }

        private void _MapRemoteDistributors(
            XmlNode xMap
            )
        {
            XmlNodeList xmlList;

            IInterfaceInfo iiDistributor;
            string[] rgszServers;

            xmlList = xMap.SelectNodes("Map");
            foreach (XmlNode xNode in xmlList)
            {
                rgszServers = Config.GetServerListByInterface(xNode.Attributes["PublisherInterface"].Value);
                if (0 == rgszServers.Length)
                {
                    Log(string.Format("Unable to find any servers with the {0} interface.",
                        xNode.Attributes["PublisherInterface"].Value));
                    Interlocked.Increment(ref m_iErrors);
                    return;
                }

                rgszServers = Config.GetServerListByInterface(xNode.Attributes["DistributorInterface"].Value);
                if (0 == rgszServers.Length)
                {
                    LogInfo(string.Format("Warning: Unable to find any servers with the {0} interface. The {1} publisher will not be mapped.",
                        xNode.Attributes["DistributorInterface"].Value, xNode.Attributes["PublisherInterface"].Value));
                    continue;
                }
                iiDistributor = Config.GetInterface(rgszServers[0], xNode.Attributes["DistributorInterface"].Value);

                foreach(string szServer in rgszServers)
                {
                    LogVerbose(string.Format("Mapping all publications on publisher {0} to remote distributor {1}.",
                        szServer, iiDistributor.ServerName));
                    m_hashRemoteDistributionMap[szServer] = iiDistributor;
                }
            }
        }

        private void _CreateReplicationGroup(
            XmlNode xGroupNode
            )
        {
            XmlNodeList xmlList;

            IInterfaceInfo iiTarget;
            IInterfaceInfo iiDistributor;
            List<IInterfaceInfo> rgiiSource;
            string[] rgszServers;

            DistributorInfo pDistributor;
            PublisherInfo pPublisher;
            PublishedDatabaseInfo pPublishedDB;
            PublicationInfo pPublication;
            SubscriptionInfo pSubscription;

            List<DistributorInfo> rgDistributors;
            List<PublisherInfo> rgPublishers;
            List<PublishedDatabaseInfo> rgPublishedDBs;
            List<PublicationInfo> rgPublications;
            List<SubscriptionInfo> rgSubscriptions;
            List<SnapshotInfo> rgSnapshots;
            List<PublicationInfo> rgPostStepPublications;
            List<StepCollection> rgPostSteps;

            rgDistributors = new List<DistributorInfo>();
            rgPublishers = new List<PublisherInfo>();
            rgPublishedDBs = new List<PublishedDatabaseInfo>();
            rgPublications = new List<PublicationInfo>();
            rgSubscriptions = new List<SubscriptionInfo>();
            rgSnapshots = new List<SnapshotInfo>();
            rgPostStepPublications = new List<PublicationInfo>();
            rgPostSteps = new List<StepCollection>();

            xmlList = xGroupNode.SelectNodes("Replication");

            LogInfo("Creating replication streams on:");
            LogInfo("===============================");

            foreach (XmlNode xNode in xmlList)
            {
                string szPublication = xNode.Attributes["Publication"].Value;
                bool fMultisource = (null != xNode.Attributes["Multisource"]) && bool.Parse(xNode.Attributes["Multisource"].Value);
                bool fPostSteps = (null != xNode.SelectSingleNode("PostSteps"));
                PublicationType pubType =  ((null != xNode.Attributes["PublicationType"]) &&
                    ("snapshot" == xNode.Attributes["PublicationType"].Value)) ? PublicationType.Snapshot : PublicationType.Transactional;
                StepCollection scSteps = new StepCollection();
                SnapshotInfo pSnapshot = new SnapshotInfo();

                XmlNodeList xmlArticleList = xNode.SelectNodes("Articles/Article");

                rgiiSource = new List<IInterfaceInfo>();

                if (0 == xmlArticleList.Count)
                {
                    Log(string.Format("There are 0 articles for replication for the {0} publication.",
                        szPublication));
                    Interlocked.Increment(ref m_iErrors);
                    return;
                }

                if (null != xNode.Attributes["TargetServer"])
                {
                    //
                    // Ensure that we have the correct attributes available
                    //
                    if (null == xNode.Attributes["TargetServer"] ||
                        null == xNode.Attributes["TargetDatabase"] ||
                        null == xNode.Attributes["SourceServer"] ||
                        null == xNode.Attributes["SourceDatabase"])
                    {
                        Log(string.Format("The node for publication {0} is malformed. It requires the TargetServer, " +
                            "TargetDatabase, SourceServer, and SourceDatabase attributes", szPublication));
                        Interlocked.Increment(ref m_iErrors);
                        return;
                    }

                    InterfaceInfo iTarget;

                    iTarget = new InterfaceInfo();
                    iTarget.ServerName = xNode.Attributes["TargetServer"].Value;
                    iTarget.Protocol = "sql";
                    IPHostEntry iphostentry = Dns.GetHostEntry(iTarget.ServerName);
                    iTarget.IPAddress = iphostentry.AddressList[0];
                    iTarget.DBName = xNode.Attributes["TargetDatabase"].Value;
                    iTarget.Timeout = 30000;

                    iiTarget = iTarget;

                    InterfaceInfo iiSource = new InterfaceInfo();
                    iiSource.ServerName = xNode.Attributes["SourceServer"].Value;
                    iiSource.Protocol = "sql";
                    iphostentry = Dns.GetHostEntry(iiSource.ServerName);
                    iiSource.IPAddress = iphostentry.AddressList[0];
                    iiSource.DBName = xNode.Attributes["SourceDatabase"].Value;
                    iiSource.Timeout = 30000;

                    rgiiSource.Add(iiSource);
                }
                else
                {
                    rgszServers = Config.GetServerListByInterface(xNode.Attributes["TargetInterface"].Value);
                    if (0 == rgszServers.Length)
                    {
                        Log(string.Format("Unable to find any servers with the {0} interface.",
                            xNode.Attributes["TargetInterface"].Value));
                        Interlocked.Increment(ref m_iErrors);
                        return;
                    }
                    iiTarget = Config.GetInterface(rgszServers[0], xNode.Attributes["TargetInterface"].Value);

                    rgszServers = Config.GetServerListByInterface(xNode.Attributes["SourceInterface"].Value);
                    if (0 == rgszServers.Length)
                    {
                        Log(string.Format("Unable to find any servers with the {0} interface.",
                            xNode.Attributes["SourceInterface"].Value));
                        Interlocked.Increment(ref m_iErrors);
                        return;
                    }

                    foreach(string szServer in rgszServers)
                    {
                        IInterfaceInfo iiSource = Config.GetInterface(szServer, xNode.Attributes["SourceInterface"].Value);
                        rgiiSource.Add(iiSource);
                    }

                    if (!fMultisource && rgiiSource.Count > 1)
                    {
                        //
                        // Basically, trim the array to one item so that we don't have to have duplicate
                        // logic for single / multi source setups
                        //
                        rgiiSource.RemoveRange(1, rgiiSource.Count - 1);
                    }
                }

                //
                // Build our post steps, if applicable
                //
                if (fPostSteps)
                {
                    XmlNode xNPS = xNode.SelectSingleNode("PostSteps");

                    scSteps.szSubscriber = iiTarget.ServerName;
                    scSteps.szSubscriberDb = iiTarget.DBName;
                    scSteps.szPublication = szPublication;

                    foreach (XmlNode xNPSC in xNPS.ChildNodes)
                    {
                        if ("SQL" == xNPSC.LocalName && xNPSC.ChildNodes[0] is XmlCDataSection)
                        {
                            SqlPostStep pSQLStep = new SqlPostStep();
                            int iTimeout;

                            pSQLStep.szConnectionString = iiTarget.SqlConnectionString;
                            pSQLStep.szQuery = ((XmlCDataSection)xNPSC.ChildNodes.Item(0)).Value;
                            if ((null != xNPSC.Attributes["Timeout"]) &&
                                (int.TryParse(xNPSC.Attributes["Timeout"].Value, out iTimeout)))
                            {
                                pSQLStep.iTimeout = iTimeout;
                            }

                            //
                            // If the query contains the SOURCEINTERFACE token, replace it with an
                            // XML fragment of the form:
                            // <server name="SeaXeFltrSQL001" /><server name="SeaXeFltrSQL002" />
                            //
                            if(pSQLStep.szQuery.Contains("#SOURCEINTERFACE#"))
                            {
                                string szServerXml = string.Empty;
                                foreach(IInterfaceInfo iiSource in rgiiSource)
                                {
                                    szServerXml += string.Format("<server name=\"{0}\" />", iiSource.ServerName);
                                }

                                pSQLStep.szQuery = pSQLStep.szQuery.Replace("#SOURCEINTERFACE#", szServerXml);
                            }

                            scSteps.rgSteps.Add(pSQLStep);
                        }
                        else if ("Delay" == xNPSC.LocalName)
                        {
                            DelayPostStep pDelay = new DelayPostStep();

                            pDelay.iDelayMS = int.Parse(xNPSC.Attributes["TimeMS"].Value);

                            scSteps.rgSteps.Add(pDelay);
                        }
                        else
                        {
                            LogInfo(string.Format("Unknown PostStep of type {0}", xNPSC.LocalName));
                        }
                    }
                }

                if (pubType != PublicationType.Snapshot)
                {
                    pSnapshot.szPublication = szPublication;
                }

                foreach (IInterfaceInfo iiSource in rgiiSource)
                {
                    LogInfo(string.Format("{0}:{1} to {2}:{3} for Publication:{4}", iiSource.ServerName,
                        iiSource.DBName, iiTarget.ServerName, iiTarget.DBName, szPublication));

                    iiDistributor = _GetMappedDistributionServer(iiSource.ServerName) ?? iiSource;

                    pDistributor = new DistributorInfo();
                    pDistributor.szServer = iiDistributor.ServerName;
                    pDistributor.szConnectionString = iiDistributor.SqlConnectionString;
                    if (!rgDistributors.Contains(pDistributor))
                    {
                        LogVerbose(string.Format("  Preparing {0} as a distributor", pDistributor.szServer));
                        rgDistributors.Add(pDistributor);
                    }

                    pPublisher = new PublisherInfo();
                    pPublisher.szPublisher = iiSource.ServerName;
                    pPublisher.szDistributor = pDistributor.szServer;
                    if (!rgPublishers.Contains(pPublisher))
                    {
                        LogVerbose(string.Format("  Preparing {0}:{1} as a publisher", pPublisher.szPublisher, pPublisher.szDistributor));
                        rgPublishers.Add(pPublisher);
                    }

                    pPublishedDB = new PublishedDatabaseInfo();
                    pPublishedDB.szServer = iiSource.ServerName;
                    pPublishedDB.szDatabase = iiSource.DBName;
                    if (!rgPublishedDBs.Contains(pPublishedDB))
                    {
                        LogVerbose(string.Format("  Preparing {0}:{1} as a published database", pPublishedDB.szServer, pPublishedDB.szDatabase));
                        rgPublishedDBs.Add(pPublishedDB);
                    }

                    pPublication = new PublicationInfo();
                    pPublication.szServer = iiSource.ServerName;
                    pPublication.szDatabase = iiSource.DBName;
                    pPublication.szPublication = szPublication;
                    pPublication.pubType = pubType;
                    if (!rgPublications.Contains(pPublication))
                    {
                        LogVerbose(string.Format("  Preparing {0}:{1}:{2} as a publication",
                            pPublication.szServer, pPublishedDB.szDatabase, pPublication.szPublication));

                        //
                        // Set up our articles for publication here
                        //
                        foreach (XmlNode xArticle in xmlArticleList)
                        {
                            bool fNoDelete = (null != xArticle.Attributes["Nodelete"]) && bool.Parse(xArticle.Attributes["Nodelete"].Value);
                            bool fKeepNCI = (null != xArticle.Attributes["KeepNCI"]) && bool.Parse(xArticle.Attributes["KeepNCI"].Value);
                            string szTarget = (null != xArticle.Attributes["Target"]) ? xArticle.Attributes["Target"].Value : xArticle.Attributes["Name"].Value;

                            ArticleParams pParams = new ArticleParams();
                            pParams.szArticle = xArticle.Attributes["Name"].Value;
                            pParams.szTarget = fMultisource ? szTarget + "_" + pPublication.szServer : szTarget;
                            pParams.fNoDelete = fNoDelete;

                            LogVerbose(string.Format("    Preparing article {0} on publication {1}",
                                pParams.szArticle, pPublication.szPublication));

                            pPublication.rgArticles.Add(pParams);
                        }

                        rgPublications.Add(pPublication);

                        //
                        // If we have post steps for this publication, track its status
                        // later on before post steps run.
                        //
                        if(fPostSteps)
                        {
                            rgPostStepPublications.Add(pPublication);
                        }
                    }

                    //
                    // If we are running post steps, take note of all publications we will have to wait on
                    //
                    if (!pSnapshot.rgPublications.Contains(pPublication))
                    {
                        LogVerbose(string.Format("    Preparing snapshot publication {0} on {1}",
                            pPublication.szPublication, pPublication.szServer));
                        pSnapshot.rgPublications.Add(pPublication);
                    }

                    pSubscription = new SubscriptionInfo();
                    pSubscription.szPubServer = iiSource.ServerName;
                    pSubscription.szSubServer = iiTarget.ServerName;
                    pSubscription.szPublicationDb = iiSource.DBName;
                    pSubscription.szPublicationName = szPublication;
                    pSubscription.szSubscriberDb = iiTarget.DBName;
                    if (!rgSubscriptions.Contains(pSubscription))
                    {
                        LogVerbose(string.Format("  Preparing {0}:{1}:{2}->{3}:{4} as a subscription",
                            pSubscription.szPubServer, pSubscription.szPublicationDb, pSubscription.szPublicationName,
                            pSubscription.szSubServer, pSubscription.szSubscriberDb));
                        rgSubscriptions.Add(pSubscription);
                    }
                }

                if (pubType != PublicationType.Snapshot)
                {
                    rgSnapshots.Add(pSnapshot);
                }

                if (fPostSteps)
                {
                    LogVerbose(string.Format("  Preparing poststeps on {0}.{1}",
                        scSteps.szSubscriber, scSteps.szSubscriberDb));
                    rgPostSteps.Add(scSteps);
                }
            }

            //
            // Either validate that our required directories and shares are present,
            // or try to create them, depending on what option is desired.
            //
            if (m_fCreateDirectories)
            {
                LogInfo(string.Empty);
                LogInfo("Setting up replication directories:");
                LogInfo("==================================");
                foreach (PublisherInfo pT in rgPublishers)
                {
                    LogInfo(string.Format("  Publisher: {0}", pT.szPublisher));
                    _CreateDirectories(pT.szPublisher, pT.szDistributor);
                }
            }
            else
            {
                LogInfo(string.Empty);
                LogInfo("Verifying replication directories:");
                LogInfo("=================================");
                foreach (PublisherInfo pT in rgPublishers)
                {
                    LogInfo(string.Format("  Publisher: {0}", pT.szPublisher));
                    if (!_VerifyDirectories(pT.szPublisher, pT.szDistributor))
                    {
                        return;
                    }
                }
            }

            LogInfo(string.Empty);
            LogInfo("Building distributors:");
            LogInfo("=====================");

            foreach (DistributorInfo pT in rgDistributors)
            {
                LogInfo(string.Format("  Distributor: {0}", pT.szServer));
                _SetupDistributor(pT.szServer);
                LogInfo(string.Format("  Updating agent profiles."));
                _UpdateAgentProfiles(pT.szConnectionString);
            }

            LogInfo(string.Empty);
            LogInfo("Building publishers:");
            LogInfo("===================");

            foreach (PublisherInfo pT in rgPublishers)
            {
                LogInfo(string.Format("  Publisher: {0}", pT.szPublisher));
                _SetupPublisher(pT.szPublisher, pT.szDistributor);
            }

            LogInfo(string.Empty);
            LogInfo("Enabling Databases for Publishing:");
            LogInfo("=================================");

            foreach (PublishedDatabaseInfo pT in rgPublishedDBs)
            {
                LogInfo(string.Format("  Enabling database: {0} on {1}", pT.szDatabase, pT.szServer));
                _SetupDBForPublishing(pT.szServer, pT.szDatabase);
            }

            LogInfo(string.Empty);
            LogInfo("Building publications:");
            LogInfo("=====================");

            foreach (PublicationInfo pT in rgPublications)
            {
                LogInfo(string.Format("  {3} Publication: {0} on {1}:{2}", pT.szPublication,
                    pT.szServer, pT.szDatabase, pT.pubType));
                _CreatePublication(pT.szServer, pT.szDatabase, pT.szPublication, pT.pubType);

                LogVerbose(string.Format("  Adding articles on {0}.", pT.szPublication));
                foreach (ArticleParams pTA in pT.rgArticles)
                {
                    LogVerbose(string.Format("    {0}", pTA.szArticle));
                    _AddArticle(pT.szServer, pT.szDatabase, pT.szPublication, pTA);
                }
            }

            LogInfo(string.Empty);
            LogInfo("Building subscriptions:");
            LogInfo("======================");

            foreach (SubscriptionInfo pT in rgSubscriptions)
            {
                LogInfo(string.Format("  Subscription on {0}:{1} from {2}:{3}:{4}",
                    pT.szSubServer, pT.szSubscriberDb, pT.szPubServer, pT.szPublicationDb,
                    pT.szPublicationName));
                _CreateSubscription(pT.szPubServer, pT.szSubServer, pT.szPublicationDb, pT.szPublicationName,
                    pT.szSubscriberDb);
            }

            LogInfo(string.Empty);
            LogInfo("Running snapshot agents:");
            LogInfo("=======================");

            foreach (SnapshotInfo pT in rgSnapshots)
            {
                LogInfo(string.Format("  Executing snapshot agent on {0}.", pT.szPublication));
                _RunSnapshotAgent(pT);
            }

            LogInfo(string.Empty);
            LogInfo("Checking replication status:");
            LogInfo("===========================");
            if(rgPostStepPublications.Count > 0)
            {
                _CheckReplicationStatus(rgPostStepPublications);
            }

            LogInfo(string.Empty);
            LogInfo("Executing Poststeps:");
            LogInfo("===================");

            foreach (StepCollection scT in rgPostSteps)
            {
                LogInfo(string.Format("  Poststeps {0}:{1} depending on Publication {2}",
                    scT.szSubscriber, scT.szSubscriberDb, scT.szPublication));
                _ExecutePostSteps(scT);
            }

            LogInfo(string.Empty);
            LogInfo("Disabling snapshot agent schedules for all publications:");
            LogInfo("=======================================================");
            foreach (PublicationInfo pT in rgPublications)
            {
                LogInfo(string.Format("  Snapshot agent on publication: {0}:{1} on {2}", pT.szDatabase,
                    pT.szPublication, pT.szServer));
                _DisableSnapshotAgentSchedule(pT.szServer, pT.szDatabase, pT.szPublication);
            }

            LogInfo(string.Empty);
            LogInfo("Updating logreader agent schedules:");
            LogInfo("==================================");
            foreach (PublishedDatabaseInfo pT in rgPublishedDBs)
            {
                LogInfo(string.Format("  Logreader(s) on published database: {0} on {1}", pT.szDatabase, pT.szServer));
                _UpdateLogreaderAgentSchedules(pT.szServer, pT.szDatabase);
            }
        }

        private bool _VerifyDirectories(
            string szPublisher,
            string szDistributor
            )
        {
            ServerConnection pConnDist;
            ServerConnection pConnPub;
            DistributionPublisher pPublisher;

            pConnDist = new ServerConnection(szDistributor);
            pConnPub = new ServerConnection(szPublisher);

            string szTrueName = pConnPub.TrueName;

            string szSQLServerAgentStartName;
            szSQLServerAgentStartName = _GetSQLServerAgentStartName(szTrueName);

            try
            {
                string szReplNetworkDirectory;
                string szReplDirectory;
                string szReplShare;

                pPublisher = new DistributionPublisher(pConnPub.TrueName, pConnDist);
                if (pPublisher.LoadProperties())
                {
                    szReplShare = pPublisher.WorkingDirectory;
                    if (szReplShare.EndsWith("\\"))
                    {
                        szReplShare = szReplShare.Substring(0, szReplShare.Length - 1);
                    }
                    szReplShare = szReplShare.Substring(szReplShare.LastIndexOf("\\") + 1);

                    szReplDirectory = _GetFileShareLocalPath(szTrueName, szReplShare);
                    szReplNetworkDirectory = @"\\" + szTrueName + @"\" + szReplDirectory.Replace(@":\", @"$\");
                }
                else
                {
                    szReplShare = m_szReplShare;
                    szReplDirectory = _GetFileShareLocalPath(szTrueName, szReplShare);
                    szReplNetworkDirectory = @"\\" + szTrueName + @"\" + m_szReplDirectory.Replace(@":\", @"$\");
                }

                if(string.IsNullOrEmpty(szReplDirectory))
                {
                    Log(string.Format("The replication directory does not exist on {0}", szPublisher));
                    return false;
                }

                if (!_VerifyNTFSPermissionsOnDirectory(szPublisher, szReplDirectory, m_szUsername))
                {
                    Log(string.Format("Unable to find the NTFS permissions for the user {2} on the directory {0} for the publisher {1}.",
                                      szReplDirectory, szPublisher, m_szUsername));
                    return false;
                }

                if (!_VerifySharePermissions(szPublisher, szReplShare, m_szUsername))
                {
                    Log(string.Format("Unable to find the share permissions for the user {2} on the share {0} for the publisher {1}.",
                                      szReplShare, szPublisher, m_szUsername));
                    return false;
                }

                if (!_VerifyNTFSPermissionsOnDirectory(szPublisher, szReplDirectory, @"BUILTIN\Administrators"))
                {
                    Log(string.Format("Unable to find the NTFS permissions for the user {2} on the directory {0} for the publisher {1}.",
                                      szReplDirectory, szPublisher, @"BUILTIN\Administrators"));
                    return false;
                }

                if (!_VerifySharePermissions(szPublisher, szReplShare, @"BUILTIN\Administrators"))
                {
                    Log(string.Format("Unable to find the share permissions for the user {2} on the share {0} for the publisher {1}.",
                                      szReplShare, szPublisher, @"BUILTIN\Administrators"));
                    return false;
                }

                if (m_fUseSQLAgentLogin)
                {
                    if (!_VerifyNTFSPermissionsOnDirectory(szPublisher, szReplDirectory, szSQLServerAgentStartName))
                    {
                        Log(string.Format("Unable to find the NTFS permissions for the user {2} on the directory {0} for the publisher {1}.",
                                          szReplDirectory, szPublisher, szSQLServerAgentStartName));
                        return false;
                    }

                    if (!_VerifySharePermissions(szPublisher, szReplShare, szSQLServerAgentStartName))
                    {
                        Log(string.Format("Unable to find the share permissions for the user {2} on the share {0} for the publisher {1}.",
                                          szReplShare, szPublisher, szSQLServerAgentStartName));
                        return false;
                    }
                }
            }
            catch (Exception e)
            {
                Log(string.Format("Unhandled exception verifying replication directories on the publisher {0}.",
                    szPublisher));
                Interlocked.Increment(ref m_iErrors);
                throw e;
            }
            finally
            {
                pConnPub.Disconnect();
            }

            return true;
        }

        private void _CreateDirectories(
            string szPublisher,
            string szDistributor
            )
        {
            ServerConnection pConnDist;
            ServerConnection pConnPub;
            DistributionPublisher pPublisher;

            pConnDist = new ServerConnection(szDistributor);
            pConnPub = new ServerConnection(szPublisher);

            string szTrueName = pConnPub.TrueName;

            string szSQLServerAgentStartName;
            szSQLServerAgentStartName = _GetSQLServerAgentStartName(szTrueName);

            try
            {
                pPublisher = new DistributionPublisher(pConnPub.TrueName, pConnDist);
                if (!pPublisher.LoadProperties())
                {
                    string szReplDirectory;

                    szReplDirectory = @"\\" + szTrueName + @"\" + m_szReplDirectory.Replace(@":\", @"$\");
                    if (!Directory.Exists(szReplDirectory))
                    {
                        try
                        {
                            Directory.CreateDirectory(szReplDirectory);
                        }
                        catch (Exception e)
                        {
                            LogException(string.Format("Error trying to create the replication directory {0}.",
                                szReplDirectory), e);
                            Interlocked.Increment(ref m_iErrors);
                            return;
                        }
                    }

                    _SetNTFSPermissionsOnDirectory(szTrueName, m_szReplDirectory, m_szUsername);
                    _SetNTFSPermissionsOnDirectory(szTrueName, m_szReplDirectory, "BUILTIN\\Administrators");
                    if (m_fUseSQLAgentLogin)
                    {
                        _SetNTFSPermissionsOnDirectory(szTrueName, m_szReplDirectory, szSQLServerAgentStartName);
                    }

                    if (!Directory.Exists(string.Format(@"\\{0}\{1}", szTrueName, m_szReplShare)))
                    {
                        try
                        {
                            _CreateFileShare(szTrueName, m_szReplDirectory, m_szReplShare);
                        }
                        catch (Exception e)
                        {
                            LogException(string.Format("Error trying to create the replication share {0} on {1} at {2}.",
                                m_szReplShare, szTrueName, m_szReplDirectory), e);
                            Interlocked.Increment(ref m_iErrors);
                            return;
                        }
                    }

                    _SetSharePermissions(szTrueName, m_szReplShare, m_szUsername);
                    _SetSharePermissions(szTrueName, m_szReplShare, "BUILTIN\\Administrators");
                    if (m_fUseSQLAgentLogin)
                    {
                        _SetSharePermissions(szTrueName, m_szReplShare, szSQLServerAgentStartName);
                    }
                }
                else
                {
                    string szReplShare = pPublisher.WorkingDirectory;
                    if (szReplShare.EndsWith("\\"))
                    {
                        szReplShare = szReplShare.Substring(0, szReplShare.Length - 1);
                    }
                    string szShareName = szReplShare.Substring(szReplShare.LastIndexOf("\\") + 1);
                    string szReplDirectory = _GetFileShareLocalPath(szTrueName, szShareName);

                    _SetNTFSPermissionsOnDirectory(szTrueName, szReplDirectory, m_szUsername);
                    _SetNTFSPermissionsOnDirectory(szTrueName, szReplDirectory, "BUILTIN\\Administrators");
                    if (m_fUseSQLAgentLogin)
                    {
                        _SetNTFSPermissionsOnDirectory(szTrueName, szReplDirectory, szSQLServerAgentStartName);
                    }

                    _SetSharePermissions(szTrueName, szShareName, m_szUsername);
                    _SetSharePermissions(szTrueName, szShareName, "BUILTIN\\Administrators");
                    if (m_fUseSQLAgentLogin)
                    {
                        _SetSharePermissions(szTrueName, szShareName, szSQLServerAgentStartName);
                    }
                }
            }
            catch (Exception e)
            {
                Log(string.Format("Unhandled exception creating replication directories on the publisher {0}.",
                    szPublisher));
                Interlocked.Increment(ref m_iErrors);
                throw e;
            }
            finally
            {
                pConnPub.Disconnect();
            }
        }

        private void _UpdateAgentProfiles(
            string szConnectionString
            )
        {
            int iProfileId = 0;
            bool fParamExists = false;

            foreach (int i in m_rgProfileIds)
            {
                using (SqlConnection pConn = new SqlConnection(szConnectionString))
                {
                    SqlCommand pCmd = new SqlCommand();
                    pCmd.Connection = pConn;
                    pCmd.CommandType = CommandType.StoredProcedure;
                    pCmd.CommandText = "sp_MSupdate_agenttype_default";

                    pCmd.Parameters.Add("@profile_id", SqlDbType.Int);
                    pCmd.Parameters["@profile_id"].Value = i;

                    pConn.Open();

                    try
                    {
                        pCmd.ExecuteNonQuery();
                    }
                    catch (Exception e)
                    {
                        LogException(string.Format("Error trying to update agent profile {0}.",
                            i), e);
                        Interlocked.Increment(ref m_iErrors);
                    }
                }
            }

            using (SqlConnection pConn = new SqlConnection(szConnectionString))
            {
                SqlCommand pCmd = new SqlCommand();
                pCmd.Connection = pConn;
                pCmd.CommandType = CommandType.StoredProcedure;
                pCmd.CommandText = "sp_help_agent_profile";

                pCmd.Parameters.Add("@agent_type", SqlDbType.Int);
                pCmd.Parameters["@agent_type"].Value = 3;
                pCmd.Parameters.Add("@profile_id", SqlDbType.Int);
                pCmd.Parameters["@profile_id"].Value = -1;

                pConn.Open();

                try
                {
                    SqlDataReader pReader = pCmd.ExecuteReader();

                    while (pReader.Read())
                    {
                        if ("SmallBCPBatchDist" == pReader["profile_name"].ToString())
                        {
                            iProfileId = int.Parse(pReader["profile_id"].ToString());
                            break;
                        }
                    }
                }
                catch (Exception e)
                {
                    LogException(string.Format("Error querying agent profile on the distributor."), e);
                    Interlocked.Increment(ref m_iErrors);
                }
            }

            if(0 == iProfileId)
            {
                using (SqlConnection pConn = new SqlConnection(szConnectionString))
                {
                    SqlCommand pCmd = new SqlCommand();
                    pCmd.Connection = pConn;
                    pCmd.CommandType = CommandType.StoredProcedure;
                    pCmd.CommandText = "sp_add_agent_profile";

                    pCmd.Parameters.Add("@profile_type", SqlDbType.Int);
                    pCmd.Parameters["@profile_type"].Value = 1;
                    pCmd.Parameters.Add("@profile_name", SqlDbType.NVarChar);
                    pCmd.Parameters["@profile_name"].Value = "SmallBCPBatchDist";
                    pCmd.Parameters.Add("@agent_type", SqlDbType.Int);
                    pCmd.Parameters["@agent_type"].Value = 3;
                    pCmd.Parameters.Add("description", SqlDbType.NVarChar);
                    pCmd.Parameters["description"].Value = "Distribution with smaller BCPBatch";
                    pCmd.Parameters.Add("@default", SqlDbType.Bit);
                    pCmd.Parameters["@default"].Value = 1;
                    pCmd.Parameters.Add("@profile_id", SqlDbType.Int);
                    pCmd.Parameters["@profile_id"].Direction = ParameterDirection.Output;

                    pConn.Open();

                    try
                    {
                        pCmd.ExecuteNonQuery();

                        iProfileId = Int32.Parse(pCmd.Parameters["@profile_id"].Value.ToString());
                    }
                    catch (Exception e)
                    {
                        LogException(string.Format("Error trying to create a new agent profile on the distributor."), e);
                        Interlocked.Increment(ref m_iErrors);
                    }
                }
            }

            using (SqlConnection pConn = new SqlConnection(szConnectionString))
            {
                SqlCommand pCmd = new SqlCommand();
                pCmd.Connection = pConn;
                pCmd.CommandType = CommandType.StoredProcedure;
                pCmd.CommandText = "sp_help_agent_parameter";

                pCmd.Parameters.Add("@profile_id", SqlDbType.Int);
                pCmd.Parameters["@profile_id"].Value = iProfileId;

                pConn.Open();

                try
                {
                    SqlDataReader pReader = pCmd.ExecuteReader();

                    while (pReader.Read())
                    {
                        if ("-BcpBatchSize" == pReader["parameter_name"].ToString())
                        {
                            fParamExists = true;
                            break;
                        }
                    }
                }
                catch (Exception e)
                {
                    LogException(string.Format("Error querying agent profile on the distributor."), e);
                    Interlocked.Increment(ref m_iErrors);
                }
            }

            if (fParamExists)
            {
                using (SqlConnection pConn = new SqlConnection(szConnectionString))
                {
                    SqlCommand pCmd = new SqlCommand();
                    pCmd.Connection = pConn;
                    pCmd.CommandType = CommandType.StoredProcedure;
                    pCmd.CommandText = "sp_change_agent_parameter";

                    pCmd.Parameters.Add("@profile_id", SqlDbType.Int);
                    pCmd.Parameters["@profile_id"].Value = iProfileId;
                    pCmd.Parameters.Add("@parameter_name ", SqlDbType.NVarChar);
                    pCmd.Parameters["@parameter_name "].Value = "-BcpBatchSize";
                    pCmd.Parameters.Add("@parameter_value", SqlDbType.NVarChar);
                    pCmd.Parameters["@parameter_value"].Value = m_iBcpBatchSize;

                    pConn.Open();

                    try
                    {
                        pCmd.ExecuteNonQuery();
                    }
                    catch (Exception e)
                    {
                        LogException(string.Format("Error trying to change the property <<BcpBatchSize>> on profile id <<{0}>>.",
                            iProfileId), e);
                        Interlocked.Increment(ref m_iErrors);
                    }
                }
            }
            else
            {
                using (SqlConnection pConn = new SqlConnection(szConnectionString))
                {
                    SqlCommand pCmd = new SqlCommand();
                    pCmd.Connection = pConn;
                    pCmd.CommandType = CommandType.StoredProcedure;
                    pCmd.CommandText = "sp_add_agent_parameter";

                    pCmd.Parameters.Add("@profile_id", SqlDbType.Int);
                    pCmd.Parameters["@profile_id"].Value = iProfileId;
                    pCmd.Parameters.Add("@parameter_name ", SqlDbType.NVarChar);
                    pCmd.Parameters["@parameter_name "].Value = "-BcpBatchSize";
                    pCmd.Parameters.Add("@parameter_value", SqlDbType.NVarChar);
                    pCmd.Parameters["@parameter_value"].Value = m_iBcpBatchSize;

                    pConn.Open();

                    try
                    {
                        pCmd.ExecuteNonQuery();
                    }
                    catch (Exception e)
                    {
                        LogException(string.Format("Error trying to add the property <<BcpBatchSize>> on profile id <<{0}>>.",
                            iProfileId), e);
                        Interlocked.Increment(ref m_iErrors);
                    }
                }
            }

            using (SqlConnection pConn = new SqlConnection(szConnectionString))
            {
                SqlCommand pCmd = new SqlCommand();
                pCmd.Connection = pConn;
                pCmd.CommandType = CommandType.StoredProcedure;
                pCmd.CommandText = "sp_MSupdate_agenttype_default";

                pCmd.Parameters.Add("@profile_id", SqlDbType.Int);
                pCmd.Parameters["@profile_id"].Value = iProfileId;

                pConn.Open();

                try
                {
                    pCmd.ExecuteNonQuery();
                }
                catch (Exception e)
                {
                    LogException(string.Format("Error trying to update agent profile {0}.",
                        iProfileId), e);
                    Interlocked.Increment(ref m_iErrors);
                }
            }
        }

        private void _SetupDistributor(
            string szServer
            )
        {
            Server pServer;
            Database pDatabase;
            ServerConnection pConn;
            ReplicationServer pDistributor;
            DistributionDatabase pDistributionDb;
            string szDistributionDb;

            pConn = new ServerConnection(szServer);

            string szTrueName = pConn.TrueName;
            pConn = new ServerConnection(szTrueName);

            //
            // Set the repl max text size option
            //
            pServer = new Server(pConn);
            try
            {
                pServer.Configuration.ReplicationMaxTextSize.ConfigValue = pServer.Configuration.ReplicationMaxTextSize.Maximum;
                pServer.Configuration.Alter();
            }
            catch( Exception e )
            {
                Log(string.Format("Error trying to set the repl max text size option. Exception was [[{0}]].",
                    e.Message));
            }

            try
            {
                //
                // Connect to the distributor
                //
                pConn.Connect();
                pDistributor = new ReplicationServer(pConn);

                //
                // Set up the distributor, if necessary
                //
                if (!pDistributor.IsDistributor)
                {
                    szDistributionDb = m_szDistributionDb;

                    //
                    // Define the distribution database
                    //
                    pDistributionDb = new DistributionDatabase(szDistributionDb, pConn);
                    pDistributionDb.MaxDistributionRetention = m_iMaxRetention;
                    pDistributionDb.HistoryRetention = m_iMaxHistory;
                    pDistributionDb.DataFolder = m_szDataFilePath;
                    pDistributionDb.DataFile = szDistributionDb + ".mdf";
                    pDistributionDb.DataFileSize = m_iDataFileSize;
                    pDistributionDb.LogFolder = m_szLogFilePath;
                    pDistributionDb.LogFile = szDistributionDb + "_Log.ldf";
                    pDistributionDb.LogFileSize = m_iLogFileSize;

                    //
                    // Install the distributor
                    //
                    try
                    {
                        pDistributor.InstallDistributor(m_szPassword, pDistributionDb);
                    }
                    catch (Exception e)
                    {
                        LogException(string.Format("Error trying to install the distributor on {0}.",
                            szServer), e);
                        Interlocked.Increment(ref m_iErrors);
                        return;
                    }

                    //
                    // Set the growth settings on the distribution database
                    //
                    pDatabase = pServer.Databases[szDistributionDb];
                    if (null == pDatabase)
                    {
                        Log(string.Format("Unable to find distribution database {0} on {1}.",
                            szDistributionDb, szServer));
                        Interlocked.Increment(ref m_iErrors);
                        return;
                    }
                    pDatabase.FileGroups[0].Files[0].GrowthType = FileGrowthType.KB;
                    pDatabase.FileGroups[0].Files[0].Growth = m_iDataFileGrowth;
                    pDatabase.LogFiles[0].GrowthType = FileGrowthType.KB;
                    pDatabase.LogFiles[0].Growth = m_iLogFileGrowth;
                    try
                    {
                        pDatabase.Alter();
                    }
                    catch (Exception e)
                    {
                        LogException(string.Format("Error trying to change the growth settings of the distribution database {0} " +
                            "on server {1}.",
                            m_szDistributionDb, szServer), e, false);
                    }
                }
                else
                {
                    LogInfo(string.Format("Warning: {0} is already set up as a distributor", szServer));

                    szDistributionDb = pDistributor.DistributionDatabases[0].Name;

                    //
                    // Save off the name of the distribution DB on this server so
                    // we can use it later if we need to check on replication status
                    // prior to running a post step
                    //
                    m_hashDistributionDB[szTrueName] = szDistributionDb;
                }

                if (!m_fUseSQLAgentLogin)
                {
                    _AddToDBOwner(szTrueName, szDistributionDb, m_szUsername);
                }
            }
            catch (Exception e)
            {
                LogException(string.Format("Unhandled exception setting up the distributor on {0}.",
                    szServer), e);
                Interlocked.Increment(ref m_iErrors);
            }
            finally
            {
                pConn.Disconnect();
            }
        }

        private void _SetupPublisher(
            string szPublisher,
            string szDistributor
            )
        {
            Server pServer;
            ServerConnection pConnDist;
            ServerConnection pConnPub;
            DistributionPublisher pPublisher;

            pConnDist = new ServerConnection(szDistributor);
            pConnPub = new ServerConnection(szPublisher);

            string szTrueName = pConnPub.TrueName;

            //
            // Set the repl max text size option
            //
            pServer = new Server(pConnPub);
            try
            {
                pServer.Configuration.ReplicationMaxTextSize.ConfigValue = pServer.Configuration.ReplicationMaxTextSize.Maximum;
                pServer.Configuration.Alter();
            }
            catch( Exception e )
            {
                Log(string.Format("Error trying to set the repl max text size option. Exception was [[{0}]].",
                    e.Message));
            }

            try
            {
                //
                // Set up the publisher
                //
                pPublisher = new DistributionPublisher(pConnPub.TrueName, pConnDist);
                if (!pPublisher.LoadProperties())
                {
                    pPublisher.DistributionDatabase = _GetDistributionDatabaseName(pConnDist.TrueName);
                    pPublisher.WorkingDirectory = string.Format(@"\\{0}\{1}", szTrueName, m_szReplShare);
                    pPublisher.PublisherSecurity.WindowsAuthentication = true;
                    try
                    {
                        pPublisher.Create();
                    }
                    catch (Exception e)
                    {
                        LogException(string.Format("Error trying to create the publisher on {0}.",
                            szPublisher), e);
                        Interlocked.Increment(ref m_iErrors);
                        return;
                    }

                    //
                    // Install the remote distribution database onto the local publisher
                    //
                    if (pConnDist.TrueName != pConnPub.TrueName)
                    {
                        ReplicationServer pReplPublisher;

                        pReplPublisher = new ReplicationServer(pConnPub);
                        try
                        {
                            pReplPublisher.InstallDistributor(pConnDist.TrueName, m_szPassword);
                        }
                        catch (Exception e)
                        {
                            LogException(string.Format("Error trying to install the distributor {0} on {1}.",
                                pConnDist.TrueName, pConnPub.TrueName), e);
                            Interlocked.Increment(ref m_iErrors);
                            return;
                        }
                    }
                }
                else
                {
                    LogInfo(string.Format("Warning: {0} is already set up as a publisher.",
                        szPublisher));
                }
            }
            catch (Exception e)
            {
                LogException(string.Format("Unhandled exception setting up the publisher on {0}.",
                    szPublisher), e);
                Interlocked.Increment(ref m_iErrors);
            }
            finally
            {
                pConnPub.Disconnect();
                pConnDist.Disconnect();
            }
        }

        private void _SetupDBForPublishing(
            string szServer,
            string szPublicationDb
            )
        {
            ServerConnection pConn;
            ReplicationServer pDistributor;
            ReplicationDatabase pPublicationDb;

            pConn = new ServerConnection(szServer);

            string szTrueName = pConn.TrueName;
            pConn = new ServerConnection(szTrueName);

            try
            {
                //
                // Connect to the distributor
                //
                pConn.Connect();
                pDistributor = new ReplicationServer(pConn);

                _AddToDBOwner(szTrueName, szPublicationDb, m_szUsername);

                pPublicationDb = new ReplicationDatabase(szPublicationDb, pConn);
                pPublicationDb.EnabledTransPublishing = true;
            }
            catch (Exception e)
            {
                LogException(string.Format("Error trying to enable database {0} on {1} for publishing.",
                    szPublicationDb, szServer), e, false);
            }
            finally
            {
                pConn.Disconnect();
            }
        }

        private void _CreatePublication(
            string szServer,
            string szPublicationDb,
            string szPublicationName,
            PublicationType pubType
            )
        {
            ServerConnection pConn;
            ReplicationDatabase pPublicationDb;
            TransPublication pPublication;

            pConn = new ServerConnection(szServer);

            string szTrueName = pConn.TrueName;
            pConn = new ServerConnection(szTrueName);

            try
            {
                //
                // Connect to the publisher
                //
                pConn.Connect();

                pPublicationDb = new ReplicationDatabase(szPublicationDb, pConn);
                if (!pPublicationDb.LoadProperties())
                {
                    Log(string.Format("Unable to find database {0} on {1}.", szPublicationDb, szServer));
                    Interlocked.Increment(ref m_iErrors);
                    return;
                }

                //
                // Enable the database for transactional publishing
                //
                if (!pPublicationDb.EnabledTransPublishing)
                {
                    pPublicationDb.EnabledTransPublishing = true;
                }

                //
                // Enable the log reader
                //
                if (!pPublicationDb.LogReaderAgentExists && (PublicationType.Transactional == pubType))
                {
                    if (!m_fUseSQLAgentLogin)
                    {
                        pPublicationDb.LogReaderAgentProcessSecurity.Login = m_szUsername;
                        pPublicationDb.LogReaderAgentProcessSecurity.Password = m_szPassword;

                        pPublicationDb.LogReaderAgentPublisherSecurity.WindowsAuthentication = true;
                    }

                    try
                    {
                        pPublicationDb.CreateLogReaderAgent();
                    }
                    catch (Exception e)
                    {
                        LogException(string.Format("Error trying to create the log reader agent on {0} for publication {1} of database " +
                            "{2}.",
                            szServer, szPublicationName, szPublicationDb), e);
                        Interlocked.Increment(ref m_iErrors);
                        return;
                    }
                }

                //
                // Enable the queue reader
                //
                if (!pPublicationDb.QueueReaderAgentExists && (PublicationType.Transactional == pubType))
                {
                    if (!m_fUseSQLAgentLogin)
                    {
                        pPublicationDb.QueueReaderAgentProcessSecurity.Login = m_szUsername;
                        pPublicationDb.QueueReaderAgentProcessSecurity.Password = m_szPassword;
                    }

                    try
                    {
                        pPublicationDb.CreateQueueReaderAgent();
                    }
                    catch (Exception e)
                    {
                        LogException(string.Format("Error trying to create the queue reader agent on {0} for publication {1} of database " +
                            "{2}.",
                            szServer, szPublicationName, szPublicationDb), e);
                        Interlocked.Increment(ref m_iErrors);
                        return;
                    }
                }

                //
                // Set up the publication
                //
                pPublication = new TransPublication();
                pPublication.ConnectionContext = pConn;
                pPublication.Name = szPublicationName;
                pPublication.Description = string.Format("{2} publication of database {0} from Publisher {1}.",
                    szPublicationDb, szServer, pubType.ToString());
                pPublication.DatabaseName = szPublicationDb;
                pPublication.Type = pubType;

                //
                // Activate the publication so subscriptions can be added
                //
                pPublication.Status = State.Active;

                //
                // Allow push/pull/independent distribution agents
                //
                pPublication.Attributes |= PublicationAttributes.AllowPull;
                pPublication.Attributes |= PublicationAttributes.AllowPush;
                pPublication.Attributes |= PublicationAttributes.IndependentAgent;

                //
                // Set up the snapshot agent auth information
                //
                if (!m_fUseSQLAgentLogin)
                {
                    pPublication.SnapshotGenerationAgentProcessSecurity.Login = m_szUsername;
                    pPublication.SnapshotGenerationAgentProcessSecurity.Password = m_szPassword;
                    pPublication.SnapshotGenerationAgentPublisherSecurity.WindowsAuthentication = true;
                }

                if (!pPublication.IsExistingObject)
                {
                    try
                    {
                        pPublication.Create();
                    }
                    catch (Exception e)
                    {
                        LogException(string.Format("Error trying to create publication {1} on {0} of database " +
                            "{2}.",
                            szServer, szPublicationName, szPublicationDb), e);
                        Interlocked.Increment(ref m_iErrors);
                        return;
                    }

                    try
                    {
                        pPublication.CreateSnapshotAgent();
                    }
                    catch (Exception e)
                    {
                        LogException(string.Format("Error trying to create the snapshot agent on {0} for publication {1} of database " +
                            "{2}.",
                            szServer, szPublicationName, szPublicationDb), e);
                        Interlocked.Increment(ref m_iErrors);
                        return;
                    }

                    //
                    // Grant access to other users
                    //
                    pPublication.GrantPublicationAccess(m_szUsername);
                }
                else
                {
                    Log(string.Format("Warning: {0} is already set up as a publication on {1}:{2}",
                        szPublicationName, szServer, szPublicationDb));
                }
            }
            catch (Exception e)
            {
                LogException(string.Format("Unhandled exception setting up the publication {0} on {1} of database {2}.",
                    szPublicationName, szServer, szPublicationDb), e);
                Interlocked.Increment(ref m_iErrors);
            }
            finally
            {
                pConn.Disconnect();
            }
        }

        private void _AddArticle(
            string szServer,
            string szPublicationDb,
            string szPublicationName,
            ArticleParams pParams
            )
        {
            ServerConnection pConn;
            TransArticle pArticle;

            pConn = new ServerConnection(szServer);

            string szTrueName = pConn.TrueName;
            pConn = new ServerConnection(szTrueName);

            try
            {
                //
                // Connect to the publisher
                //
                pConn.Connect();

                pArticle = new TransArticle();
                pArticle.ConnectionContext = pConn;
                pArticle.Name = pParams.szArticle;
                pArticle.DatabaseName = szPublicationDb;
                pArticle.PublicationName = szPublicationName;
                pArticle.Type = ArticleOptions.LogBased;
                pArticle.PreCreationMethod = PreCreationOption.Drop;

                if (!pArticle.IsExistingObject)
                {
                    pArticle.IdentityRangeManagementOption = IdentityRangeManagementOption.Manual;

                    pArticle.SchemaOption = CreationScriptOptions.ClusteredIndexes;
                    pArticle.SchemaOption |= CreationScriptOptions.Collation;
                    pArticle.SchemaOption |= CreationScriptOptions.DriDefaults;
                    pArticle.SchemaOption |= CreationScriptOptions.DriUniqueKeys;
                    pArticle.SchemaOption |= CreationScriptOptions.ExtendedProperties;
                    pArticle.SchemaOption |= CreationScriptOptions.Identity;
                    pArticle.SchemaOption |= CreationScriptOptions.KeepTimestamp;
                    pArticle.SchemaOption |= CreationScriptOptions.MarkReplicatedCheckConstraintsAsNotForReplication;
                    pArticle.SchemaOption |= CreationScriptOptions.MarkReplicatedForeignKeyConstraintsAsNotForReplication;
                    if (pParams.fKeepNCI)
                    {
                        pArticle.SchemaOption |= CreationScriptOptions.NonClusteredIndexes;
                    }
                    pArticle.SchemaOption |= CreationScriptOptions.PrimaryObject;
                    pArticle.SchemaOption |= CreationScriptOptions.Schema;

                    if (pParams.fNoDelete)
                    {
                        pArticle.SchemaOption |= CreationScriptOptions.CustomProcedures;
                        pArticle.InsertCommand = "CALL [sp_MSins_dbo" + pParams.szTarget + "]";
                        pArticle.UpdateCommand = "SCALL [sp_MSupd_dbo" + pParams.szTarget + "]";
                        pArticle.DeleteCommand = "NONE";
                    }

                    if (pParams.szArticle == pParams.szTarget)
                    {
                        pArticle.SchemaOption |= CreationScriptOptions.DriPrimaryKey;
                    }

                    pArticle.SourceObjectOwner = "dbo";
                    pArticle.SourceObjectName = pParams.szArticle;
                    pArticle.DestinationObjectOwner = "dbo";
                    pArticle.DestinationObjectName = pParams.szTarget;

                    pArticle.Create();
                }
                else
                {
                    LogInfo(string.Format("Warning: {0} is already set up as an article for publication {1}",
                        pParams.szArticle, szPublicationName));
                }
            }
            catch (Exception e)
            {
                LogException(string.Format("Unhandled exception setting up the article {0} on publication {1}.",
                    pParams.szArticle, szPublicationName), e);
                Interlocked.Increment(ref m_iErrors);
            }
            finally
            {
                pConn.Disconnect();
            }
        }

        private void _RunSnapshotAgent(
            SnapshotInfo pSnapshot
            )
        {
            AutoResetEvent[] rgEvents;

            if (0 >= pSnapshot.rgPublications.Count)
            {
                Log(string.Format("There are 0 publications defined for publication {0}.", pSnapshot.szPublication));
                Interlocked.Increment(ref m_iErrors);
                return;
            }

            //
            // Wait for all the subscriptions to be in a good state
            //
            rgEvents = new AutoResetEvent[pSnapshot.rgPublications.Count];
            for (int i = 0; i < rgEvents.Length; i++)
            {
                rgEvents[i] = new AutoResetEvent(false);
            }

            for (int i = 0; i < rgEvents.Length; i++)
            {
                PublicationWait pWait = new PublicationWait();
                pWait.pPublication = pSnapshot.rgPublications[i] as PublicationInfo;
                pWait.hEvent = rgEvents[i];

                ThreadPool.QueueUserWorkItem(new WaitCallback(_WaitOnSnapshotCreated), pWait);
            }

            WaitHandle.WaitAll(rgEvents);
        }

        private void _CheckReplicationStatus(
            List<PublicationInfo> rgPublications
            )
        {
            AutoResetEvent[] rgEvents;

            rgEvents = new AutoResetEvent[rgPublications.Count];
            for (int i = 0; i < rgEvents.Length; i++)
            {
                rgEvents[i] = new AutoResetEvent(false);
            }

            for (int i = 0; i < rgEvents.Length; i++)
            {
                PublicationWait pWait = new PublicationWait();
                pWait.pPublication = rgPublications[i] as PublicationInfo;
                pWait.hEvent = rgEvents[i];

                ThreadPool.QueueUserWorkItem(new WaitCallback(_WaitOnSubscriptionStatus), pWait);
            }

            WaitHandle.WaitAll(rgEvents);
        }

        private void _CreateSubscription(
            string szPublisher,
            string szSubscriber,
            string szPublicationDb,
            string szPublicationName,
            string szSubscriptionDb
            )
        {
            ServerConnection pPublisherConn;
            ServerConnection pSubscriberConn;
            TransPublication pPublication;
            TransSubscription pSubscription;

            pPublisherConn = new ServerConnection(szPublisher);
            pSubscriberConn = new ServerConnection(szSubscriber);

            string szTrueName = pPublisherConn.TrueName;
            pPublisherConn = new ServerConnection(szTrueName);

            szTrueName = pSubscriberConn.TrueName;
            pSubscriberConn = new ServerConnection(szTrueName);

            try
            {
                //
                // Connect to the publisher and subscriber
                //
                pPublisherConn.Connect();
                pSubscriberConn.Connect();

                //
                // Load our publication
                //
                pPublication = new TransPublication();
                pPublication.Name = szPublicationName;
                pPublication.DatabaseName = szPublicationDb;
                pPublication.ConnectionContext = pPublisherConn;

                if (pPublication.IsExistingObject)
                {
                    if ((pPublication.Attributes & PublicationAttributes.AllowPush) == 0)
                    {
                        pPublication.Attributes |= PublicationAttributes.AllowPush;
                    }

                    _AddToDBOwner(szTrueName, szSubscriptionDb, m_szUsername);

                    pSubscription = new TransSubscription();
                    pSubscription.ConnectionContext = pPublisherConn;
                    pSubscription.SubscriberName = szSubscriber;
                    pSubscription.PublicationName = szPublicationName;
                    pSubscription.DatabaseName = szPublicationDb;
                    pSubscription.SubscriptionDBName = szSubscriptionDb;

                    if (!m_fUseSQLAgentLogin)
                    {
                        pSubscription.SynchronizationAgentProcessSecurity.Login = m_szUsername;
                        pSubscription.SynchronizationAgentProcessSecurity.Password = m_szPassword;
                    }

                    pSubscription.CreateSyncAgentByDefault = true;

                    pSubscription.AgentSchedule.FrequencyType = ScheduleFrequencyType.Daily;
                    pSubscription.AgentSchedule.FrequencyInterval = 1;
                    pSubscription.AgentSchedule.FrequencySubDay = ScheduleFrequencySubDay.Minute;
                    pSubscription.AgentSchedule.FrequencySubDayInterval = 1;
                    pSubscription.AgentSchedule.FrequencyRelativeInterval = ScheduleRelativeIntervals.First;
                    pSubscription.AgentSchedule.FrequencyRecurrenceFactor = 0;
                    pSubscription.AgentSchedule.ActiveStartDate = 19900101;
                    pSubscription.AgentSchedule.ActiveStartTime = 0;

                    if (!pSubscription.LoadProperties())
                    {
                        try
                        {
                            pSubscription.Create();
                        }
                        catch (Exception e)
                        {
                            LogException(string.Format("Error trying to create the subscription on {0} of publication {1}.",
                                szSubscriber, szPublicationName), e);
                            Interlocked.Increment(ref m_iErrors);
                            return;
                        }
                    }
                    else
                    {
                        LogInfo(string.Format("Warning: {0} already has a subscription for publication {1}",
                            szSubscriber, szPublicationName));
                    }
                }
                else
                {
                    Log(string.Format("Unable to find publication {0} on {1}.", szPublicationName, szPublisher));
                    Interlocked.Increment(ref m_iErrors);
                    return;
                }
            }
            catch (Exception e)
            {
                LogException(string.Format("Unhandled exception setting up the subscription on {0} of publication {1}. ",
                    szSubscriber, szPublicationName), e);
                Interlocked.Increment(ref m_iErrors);
            }
            finally
            {
                pPublisherConn.Disconnect();
                pSubscriberConn.Disconnect();
            }
        }

        private void _ExecutePostSteps(StepCollection pStepCollection)
        {
            foreach (IPostStep iStep in pStepCollection.rgSteps)
            {
                try
                {
                    iStep.Execute();
                }
                catch
                {
                    Interlocked.Increment(ref m_iErrors);
                }
            }
        }

        private void _WaitOnSnapshotCreated(object oState)
        {
            string szOutputDir;

            ServerConnection pConn;
            PublicationWait pWait;
            SnapshotGenerationAgent pAgent;

            pWait = oState as PublicationWait;

            if (null != pWait)
            {
                try
                {
                    szOutputDir = string.Format(@"{0}\ReplicationSetup", Config.GetSetting("setup_logroot"));

                    if (!Directory.Exists(szOutputDir))
                    {
                        try
                        {
                            Directory.CreateDirectory(szOutputDir);
                        }
                        catch (Exception e)
                        {
                            LogException(string.Format("Error trying to create the snapshot log directory {0}.",
                                szOutputDir), e);
                            Interlocked.Increment(ref m_iErrors);
                            return;
                        }
                    }

                    pConn = new ServerConnection(pWait.pPublication.szServer);

                    string szTrueName = pConn.TrueName;

                    pAgent = new SnapshotGenerationAgent();
                    pAgent.Distributor = _GetMappedDistributionServerName(pWait.pPublication.szServer);
                    pAgent.DistributorSecurityMode = SecurityMode.Integrated;
                    pAgent.Publisher = szTrueName;
                    pAgent.PublisherSecurityMode = SecurityMode.Integrated;
                    pAgent.Publication = pWait.pPublication.szPublication;
                    pAgent.PublisherDatabase = pWait.pPublication.szDatabase;
                    pAgent.ReplicationType = ReplicationType.Transactional;
                    pAgent.Output = string.Format(@"{0}\{1}-{2}-{3}.txt", szOutputDir, pWait.pPublication.szServer,
                        pWait.pPublication.szDatabase, pWait.pPublication.szPublication );
                    pAgent.OutputVerboseLevel = s_fVerbose ? 2 : 1;

                    pAgent.GenerateSnapshot();
                }
                catch (ReplicationAgentContainerException race)
                {
                    foreach (Exception e in race.ExceptionCollection)
                    {
                        if (e is ReplicationAgentException)
                        {
                            LogException(string.Format("Replication exception running snapshot agent of publication {0} on server {1}.",
                                pWait.pPublication.szPublication, pWait.pPublication.szServer), e, false);
                        }
                        else
                        {
                            LogException(string.Format("Unhandled exception running snapshot agent of publication {0} on server {1}. ",
                                pWait.pPublication.szPublication, pWait.pPublication.szServer), e);
                            Interlocked.Increment(ref m_iErrors);
                        }
                    }
                }
                catch (Exception e)
                {
                    LogException(string.Format("Unhandled exception running snapshot agent of publication {0} on server {1}. ",
                        pWait.pPublication.szPublication, pWait.pPublication.szServer), e);
                    Interlocked.Increment(ref m_iErrors);
                }
                finally
                {
                    pWait.hEvent.Set();
                }
            }
        }

        private static string ReplicationStatusToString(int status)
        {
            switch (status)
            {
                case 1: return "Started";
                case 2: return "Succeeded";
                case 3: return "In progress";
                case 4: return "Idle";
                case 5: return "Retrying";
                case 6: return "Failed";
            }

            return "unknown: " + status;
        }

        private void _WaitOnSubscriptionStatus(object oState)
        {
            PublicationWait pWait;

            pWait = oState as PublicationWait;

            if (null != pWait)
            {
                try
                {
                    ServerConnection pConnDist;
                    ServerConnection pConnPub;
                    PublicationMonitor pMonitor;
                    DataSet dsStatus;
                    string szDistributionServer;
                    string szDistributionDb;

                    pConnPub = new ServerConnection(pWait.pPublication.szServer);
                    szDistributionServer = _GetMappedDistributionServerName(pWait.pPublication.szServer);
                    pConnDist = new ServerConnection(szDistributionServer);
                    szDistributionDb = _GetDistributionDatabaseName(szDistributionServer);

                    pMonitor = new PublicationMonitor(pWait.pPublication.szPublication, szDistributionDb,
                        pConnPub.TrueName, pWait.pPublication.szDatabase, pConnDist);

                    if (null == pMonitor)
                    {
                        LogInfo(string.Format("Unable to find a publication monitor on {0} for {1}:{2} with distribution DB {3}.",
                            pConnPub.TrueName, pWait.pPublication.szDatabase, pWait.pPublication.szPublication, szDistributionDb));
                        return;
                    }

                    while(true)
                    {
                        bool fReady = true;

                        dsStatus = pMonitor.EnumSubscriptions();

                        if ((null == dsStatus) ||
                            (null == dsStatus.Tables) ||
                            (null == dsStatus.Tables[0]))
                        {
                            LogInfo(string.Format("Unable to find the subscriptions for publication monitor on {0} for {1}:{2} with distribution DB {3}.",
                                pConnPub.TrueName, pWait.pPublication.szDatabase, pWait.pPublication.szPublication, szDistributionDb));
                            return;
                        }

                        foreach(DataRow dr in dsStatus.Tables[0].Rows)
                        {
                            LogVerbose(string.Format("Publication: {0}:{1} Subscription: {2}:{3} Status: {4}",
                  