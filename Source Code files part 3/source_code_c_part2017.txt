tAddr = &dwPrimaryServerAddr;
					break;
				case '2':
					pdwCurrentAddr = &dwSecondaryServerAddr;
					break;
				default:
					printf("Invalid parameter: %s", argv[nCurrentParam]);
					goto Usage;
				}

				if((nCurrentParam + 1) == argc)
				{
					printf("No address provided with %s parameter\n", argv[nCurrentParam]);
					goto Usage;
				}


				nCurrentStrLen = strlen(argv[nCurrentParam + 1]);
				if(nCurrentStrLen > (MAX_SERVER_ADDR - 1))
				{
					printf("Provided address was too long: %s\n", argv[nCurrentParam + 1]);
					goto Usage;
				}

				if((*pdwCurrentAddr = inet_addr(argv[nCurrentParam + 1])) == INADDR_NONE)
				{
					printf("Provided address was not valid: %s\n", argv[nCurrentParam + 1]);
					goto Usage;
				}

				++nCurrentParam;
				break;
			default:
				printf("Unknown parameter: %s\n", argv[nCurrentParam]);
				goto Usage;
			}
		}
		else
		{
			printf("Unknown parameter: %s\n", argv[nCurrentParam]);
			goto Usage;
		}
	}

	// Verify that ports and addresses were set
	if(!dwPrimaryServerAddr)
	{
		printf("No primary address was provided\n");
		goto Usage;
	}

	if(!dwSecondaryServerAddr)
	{
		printf("No secondary address was provided\n");
		goto Usage;
	}

	// Build destination socket addresses
	SockServ11.sin_addr.S_un.S_addr = SockServ12.sin_addr.S_un.S_addr = dwPrimaryServerAddr;
	SockServ21.sin_addr.S_un.S_addr = SockServ22.sin_addr.S_un.S_addr = dwSecondaryServerAddr;
	SockServ11.sin_port = SockServ21.sin_port = htons(PRIMARY_TEST_PORT);
	SockServ12.sin_port = SockServ22.sin_port = htons(SECONDARY_TEST_PORT);

	// Create the local socket
	ClientSock = socket(AF_INET, SOCK_DGRAM, 0);
	if(ClientSock == INVALID_SOCKET)
	{
		printf("Couldn't create socket\n");
		goto Exit;
	}

	// Set local socket to be non-blocking
	dwNonBlocking = TRUE;
	if(ioctlsocket(ClientSock, FIONBIO, &dwNonBlocking) == SOCKET_ERROR)
	{
		printf("Setting local socket to non-blocking failed with 0x%08x\n", WSAGetLastError());
		goto Exit;
	}

	// Bind to any address locally
	LocalAddr.sin_addr.S_un.S_addr = INADDR_ANY;
	LocalAddr.sin_port = htons(PRIMARY_TEST_PORT);
    if (bind(ClientSock, (const struct sockaddr *) &LocalAddr, sizeof(LocalAddr)) == SOCKET_ERROR)
    {
		printf("Binding local socket failed with 0x%08x\n", WSAGetLastError());
		goto Exit;
    }
	printf("Bound local socket\n");

	// Have each socket send a packet to the client
	OutgoingPing.dwMsgType = PING_MSG_TYPE;
	OutgoingPing.dwClientIP = INADDR_ANY;
	OutgoingPing.wClientPort = PRIMARY_TEST_PORT;
	nBytes = sendto(ClientSock, (const char *) &OutgoingPing, sizeof(OutgoingPing), 0, (struct sockaddr *) &SockServ11, sizeof(SockServ11));
	if(nBytes == SOCKET_ERROR)
	{
		printf("Writing socket failed with 0x%08x\n", WSAGetLastError());
		goto Exit;
	}

	FD_ZERO(&ReadableSockets);
	FD_SET(ClientSock, &ReadableSockets);
	
	// Wait for readability
	nNumReadable = select(0, &ReadableSockets, NULL, NULL, &time);
	if(nNumReadable == SOCKET_ERROR)
	{
		printf("Checking socket for readability failed with 0x%08x\n", WSAGetLastError());
		goto Exit;
	}

	if(!nNumReadable)
	{
		printf("No response was received from the server within 10 seconds\n");
		goto Exit;
	}

	// Read first packet
	nFromLen = sizeof(RecvAddr);
	nBytes = recvfrom(ClientSock, (char *) bBuffer, sizeof(bBuffer), 0, (struct sockaddr *) &RecvAddr, &nFromLen);
	if(nBytes == SOCKET_ERROR)
	{
		printf("Reading socket failed with 0x%08x\n", WSAGetLastError());
		goto Exit;
	}

	// Compare received address
	if((RecvAddr.sin_addr.S_un.S_addr != dwPrimaryServerAddr) ||
		(RecvAddr.sin_port != htons(PRIMARY_TEST_PORT)))
	{
		printf("Packet received from unexpected source: %s:%u\n", inet_ntoa(RecvAddr.sin_addr), RecvAddr.sin_port);
		goto Exit;
	}

	printf("Packet received from server: %s:%u\n", inet_ntoa(RecvAddr.sin_addr), ntohs(RecvAddr.sin_port));

	// Send remaining packets
	OutgoingPing.dwMsgType = PING_MSG_TYPE;
	OutgoingPing.dwClientIP = INADDR_ANY;
	OutgoingPing.wClientPort = PRIMARY_TEST_PORT;
	nBytes = sendto(ClientSock, (const char *) &OutgoingPing, sizeof(OutgoingPing), 0, (struct sockaddr *) &SockServ12, sizeof(SockServ12));
	if(nBytes == SOCKET_ERROR)
	{
		printf("Writing socket failed with 0x%08x\n", WSAGetLastError());
		goto Exit;
	}

	OutgoingPing.dwMsgType = PING_MSG_TYPE;
	OutgoingPing.dwClientIP = INADDR_ANY;
	OutgoingPing.wClientPort = PRIMARY_TEST_PORT;
	nBytes = sendto(ClientSock, (const char *) &OutgoingPing, sizeof(OutgoingPing), 0, (struct sockaddr *) &SockServ21, sizeof(SockServ21));
	if(nBytes == SOCKET_ERROR)
	{
		printf("Writing socket failed with 0x%08x\n", WSAGetLastError());
		goto Exit;
	}

	OutgoingPing.dwMsgType = PING_MSG_TYPE;
	OutgoingPing.dwClientIP = INADDR_ANY;
	OutgoingPing.wClientPort = PRIMARY_TEST_PORT;
	nBytes = sendto(ClientSock, (const char *) &OutgoingPing, sizeof(OutgoingPing), 0, (struct sockaddr *) &SockServ22, sizeof(SockServ22));
	if(nBytes == SOCKET_ERROR)
	{
		printf("Writing socket failed with 0x%08x\n", WSAGetLastError());
		goto Exit;
	}

	// Read remaining packets
	Sleep(5000);

	FD_ZERO(&ReadableSockets);
	FD_SET(ClientSock, &ReadableSockets);
	
	// Wait for readability
	nNumReadable = select(0, &ReadableSockets, NULL, NULL, &time);
	if(nNumReadable == SOCKET_ERROR)
	{
		printf("Checking socket for readability failed with 0x%08x\n", WSAGetLastError());
		goto Exit;
	}

	// Read all packets from the socket
	bPacketsReceived = 0;
	while(TRUE)
	{
		// Read first packet
		nBytes = recvfrom(ClientSock, (char *) bBuffer, sizeof(bBuffer), 0, (struct sockaddr *) &RecvAddr, &nFromLen);
		if(nBytes == SOCKET_ERROR)
		{
			nLastError = WSAGetLastError();
			if(nLastError == WSAEWOULDBLOCK)
				break;

			printf("Reading socket failed with 0x%08x\n", WSAGetLastError());
			goto Exit;
		}

		++bPacketsReceived;

		// Compare received address
		printf("Packet received from %s:%u\n", inet_ntoa(RecvAddr.sin_addr), ntohs(RecvAddr.sin_port));
	}


Exit:

	WSACleanup();

	return 0;

Usage:
	printf("Usage: natclient -a1 <IP1> -a2 <IP2>\n");
	goto Exit;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\nat\natinfo\client\StdAfx.cpp ===
// stdafx.cpp : source file that includes just the standard includes
//	natclient.pch will be the pre-compiled header
//	stdafx.obj will contain the pre-compiled type information

#include "stdafx.h"

// TODO: reference any additional headers you need in STDAFX.H
// and not in this file
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\nat\natinfo\client\StdAfx.h ===
// stdafx.h : include file for standard system include files,
//  or project specific include files that are used frequently, but
//      are changed infrequently
//

#if !defined(AFX_STDAFX_H__FC8D1768_298A_48E9_A17F_A3EAB8741019__INCLUDED_)
#define AFX_STDAFX_H__FC8D1768_298A_48E9_A17F_A3EAB8741019__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000


// TODO: reference additional headers your program requires here
#include <stdio.h>
#include <winsock.h>

//{{AFX_INSERT_LOCATION}}
// Microsoft Visual C++ will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_STDAFX_H__FC8D1768_298A_48E9_A17F_A3EAB8741019__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\nat\natinfo\server\natserv.cpp ===
// natserv.cpp : Defines the entry point for the console application.
//

#include "stdafx.h"

#define PRIMARY_TEST_PORT		1000
#define SECONDARY_TEST_PORT		1001
#define MAX_DGRAM_SIZE			1024
#define PING_MSG_TYPE			1
#define SUMMARY_MSG_TYPE		2

#define EXIT_IF_MAIN_THREAD_SIGNALS(pParams)	if(WaitForSingleObject(pParams->hStopThreadEvent,0) == WAIT_OBJECT_0) \
													goto Exit;

#pragma pack(push, 1)
typedef struct
{
	DWORD dwMsgType;
	DWORD dwClientIP;
	WORD  wClientPort;
} NATPING_MSG, *PNATPING_MSG;

typedef struct
{
	DWORD dwMsgType;
	DWORD dwReceivedPacketFlag;
} NATSUMMARY_MSG, *PNATSUMMARY_MSG;

#pragma pack(pop)

typedef struct
{
	IN_ADDR   LocalAddr1;
	IN_ADDR   LocalAddr2;
	HANDLE    hStopThreadEvent;
} THREAD_PARAMS, *PTHREAD_PARAMS;

BOOL GetLocalMachineAddresses(IN_ADDR *pLocalAddr1, IN_ADDR *pLocalAddr2)
{
	HOSTENT *pHost = NULL;
	DWORD dwNumIPs = 0;
	CHAR szHostName[20];

	if(gethostname(szHostName, 20) != 0)
	{
		printf("gethostname failed with 0x%08x\n", WSAGetLastError());
		return FALSE;
	}

	// Get the address information for the local machine
	pHost = gethostbyname(szHostName);
	if(!pHost)
	{
		printf("gethostbyname failed with 0x%08x\n", WSAGetLastError());
		return FALSE;
	}

	// Count the number of IP interfaces
	for(dwNumIPs = 0;pHost->h_addr_list[dwNumIPs];++dwNumIPs);

	printf("Found %u local IP address%s\n", dwNumIPs, (dwNumIPs != 1) ? "es" : "");
	
	for(dwNumIPs = 0;pHost->h_addr_list[dwNumIPs];++dwNumIPs)
	{
		printf("IP%u: %s\n", dwNumIPs + 1, inet_ntoa(*((IN_ADDR *) pHost->h_addr_list[dwNumIPs])));
	}

	// We need at least 2 of them
	if(dwNumIPs < 2)
		return FALSE;

	*pLocalAddr1 = *((IN_ADDR *) pHost->h_addr_list[0]);
	*pLocalAddr2 = *((IN_ADDR *) pHost->h_addr_list[1]);

	return TRUE;
}

DWORD WINAPI ListenerThread(LPVOID pParams)
{
	PTHREAD_PARAMS pThreadParams = (PTHREAD_PARAMS) pParams;
	NATPING_MSG OutgoingPing, *pIncomingPing = NULL;
	SOCKADDR_IN SockAddr, NatAddr11, NatAddr12, NatAddr21, NatAddr22, ClientAddr;
	TIMEVAL time = {1, 0};
	FD_SET ReadableSockets;
	SOCKET Sock11 = INVALID_SOCKET, Sock12 = INVALID_SOCKET, Sock21 = INVALID_SOCKET, Sock22 = INVALID_SOCKET;
	DWORD dwNonBlocking = TRUE;
	BYTE bBuffer[MAX_DGRAM_SIZE];
	INT nNumReadable = 0, nBytes = 0, nFromLen = 0;

	memset(bBuffer, 0, sizeof(bBuffer));

	memset(&NatAddr11, 0, sizeof(SockAddr));
	memset(&NatAddr12, 0, sizeof(SockAddr));
	memset(&NatAddr21, 0, sizeof(SockAddr));
	memset(&NatAddr22, 0, sizeof(SockAddr));
	memset(&ClientAddr, 0, sizeof(SockAddr));
    ClientAddr.sin_family = AF_INET;
	memset(&SockAddr, 0, sizeof(SockAddr));
    SockAddr.sin_family = AF_INET;

	// Create all four sockets
	Sock11 = socket(AF_INET, SOCK_DGRAM, 0);
	Sock12 = socket(AF_INET, SOCK_DGRAM, 0);
	Sock21 = socket(AF_INET, SOCK_DGRAM, 0);
	Sock22 = socket(AF_INET, SOCK_DGRAM, 0);

	if((Sock11 == INVALID_SOCKET) ||
		(Sock12 == INVALID_SOCKET) ||
		(Sock21 == INVALID_SOCKET) ||
		(Sock22 == INVALID_SOCKET))
	{
		printf("Couldn't allocate required sockets\n");
		goto Exit;
	}

	// Set all four sockets to be non-blocking
	dwNonBlocking = TRUE;
	if(ioctlsocket(Sock11, FIONBIO, &dwNonBlocking) == SOCKET_ERROR)
	{
		printf("Setting socket 1 to non-blocking failed with 0x%08x\n", WSAGetLastError());
		goto Exit;
	}

	dwNonBlocking = TRUE;
	if(ioctlsocket(Sock12, FIONBIO, &dwNonBlocking) == SOCKET_ERROR)
	{
		printf("Setting socket 2 to non-blocking failed with 0x%08x\n", WSAGetLastError());
		goto Exit;
	}

	dwNonBlocking = TRUE;
	if(ioctlsocket(Sock21, FIONBIO, &dwNonBlocking) == SOCKET_ERROR)
	{
		printf("Setting socket 3 to non-blocking failed with 0x%08x\n", WSAGetLastError());
		goto Exit;
	}

	dwNonBlocking = TRUE;
	if(ioctlsocket(Sock22, FIONBIO, &dwNonBlocking) == SOCKET_ERROR)
	{
		printf("Setting socket 4 to non-blocking failed with 0x%08x\n", WSAGetLastError());
		goto Exit;
	}

	// Bind all four sockets
    SockAddr.sin_port = htons(PRIMARY_TEST_PORT);
    SockAddr.sin_addr.S_un.S_addr = pThreadParams->LocalAddr1.S_un.S_addr;
    if (bind(Sock11, (const struct sockaddr *) &SockAddr, sizeof(SockAddr)) == SOCKET_ERROR)
    {
		printf("Binding socket 1 failed with 0x%08x\n", WSAGetLastError());
		goto Exit;
    }
	printf("Bound socket 1 to %s:%u\n", inet_ntoa(pThreadParams->LocalAddr1), PRIMARY_TEST_PORT);

    SockAddr.sin_port = htons(SECONDARY_TEST_PORT);
    SockAddr.sin_addr.S_un.S_addr = pThreadParams->LocalAddr1.S_un.S_addr;
    if (bind(Sock12, (const struct sockaddr *) &SockAddr, sizeof(SockAddr)) == SOCKET_ERROR)
    {
		printf("Binding socket 2 failed with 0x%08x\n", WSAGetLastError());
		goto Exit;
    }
	printf("Bound socket 2 to %s:%u\n", inet_ntoa(pThreadParams->LocalAddr1), SECONDARY_TEST_PORT);

    SockAddr.sin_port = htons(PRIMARY_TEST_PORT);
    SockAddr.sin_addr.S_un.S_addr = pThreadParams->LocalAddr2.S_un.S_addr;
    if (bind(Sock21, (const struct sockaddr *) &SockAddr, sizeof(SockAddr)) == SOCKET_ERROR)
    {
		printf("Binding socket 3 failed with 0x%08x\n", WSAGetLastError());
		goto Exit;
    }
	printf("Bound socket 3 to %s:%u\n", inet_ntoa(pThreadParams->LocalAddr2), PRIMARY_TEST_PORT);

    SockAddr.sin_port = htons(SECONDARY_TEST_PORT);
    SockAddr.sin_addr.S_un.S_addr = pThreadParams->LocalAddr2.S_un.S_addr;
    if (bind(Sock22, (const struct sockaddr *) &SockAddr, sizeof(SockAddr)) == SOCKET_ERROR)
    {
		printf("Binding socket 4 failed with 0x%08x\n", WSAGetLastError());
		goto Exit;
    }
	printf("Bound socket 4 to %s:%u\n", inet_ntoa(pThreadParams->LocalAddr2), SECONDARY_TEST_PORT);

	// Start main loop
	while(TRUE)
	{

		// Add all sockets to the set to be checked for readability
		FD_ZERO(&ReadableSockets);
		FD_SET(Sock11, &ReadableSockets);
		FD_SET(Sock12, &ReadableSockets);
		FD_SET(Sock21, &ReadableSockets);
		FD_SET(Sock22, &ReadableSockets);

		// Wait one second for readability
		nNumReadable = select(0, &ReadableSockets, NULL, NULL, &time);
		if(nNumReadable == SOCKET_ERROR)
		{
			printf("Checking sockets for readability failed with 0x%08x\n", WSAGetLastError());
			goto Exit;
		}

		EXIT_IF_MAIN_THREAD_SIGNALS(pThreadParams);

		if(nNumReadable == 0)
			continue;

		if(!FD_ISSET(Sock11, &ReadableSockets))
		{
			printf("Unexpected packets received on some sockets!");
			continue;
		}

		// Read first packet from socket 1
		nFromLen = sizeof(NatAddr11);
		nBytes = recvfrom(Sock11, (char *) bBuffer, sizeof(bBuffer), 0, (struct sockaddr *) &NatAddr11, &nFromLen);
		if(nBytes == SOCKET_ERROR)
		{
			printf("Reading socket 1 failed with 0x%08x\n", WSAGetLastError());
			goto Exit;
		}

		if(nBytes < sizeof(DWORD))
			continue;
		
		// If this is a ping, then record the address the client reported
		switch(*((DWORD *) bBuffer))
		{
		case PING_MSG_TYPE:
			pIncomingPing = (PNATPING_MSG) bBuffer;
			ClientAddr.sin_addr.S_un.S_addr = pIncomingPing->dwClientIP;
			ClientAddr.sin_port = pIncomingPing->wClientPort;
			break;
		default:
			continue;
		}

		// Have each socket send a packet to the client
		OutgoingPing.dwMsgType = PING_MSG_TYPE;
		OutgoingPing.dwClientIP = pThreadParams->LocalAddr1.S_un.S_addr;
		OutgoingPing.wClientPort = PRIMARY_TEST_PORT;
		nBytes = sendto(Sock11, (const char *) &OutgoingPing, sizeof(OutgoingPing), 0, (struct sockaddr *) &NatAddr11, sizeof(NatAddr11));
		if(nBytes == SOCKET_ERROR)
		{
			printf("Writing socket 1 failed with 0x%08x\n", WSAGetLastError());
			goto Exit;
		}

		printf("Socket 1 sent to %s:%u\n", inet_ntoa(NatAddr11.sin_addr), ntohs(NatAddr11.sin_port));

		EXIT_IF_MAIN_THREAD_SIGNALS(pThreadParams);

		OutgoingPing.dwClientIP = pThreadParams->LocalAddr1.S_un.S_addr;
		OutgoingPing.wClientPort = SECONDARY_TEST_PORT;
		nBytes = sendto(Sock12, (const char *) &OutgoingPing, sizeof(OutgoingPing), 0, (struct sockaddr *) &NatAddr11, sizeof(NatAddr11));
		if(nBytes == SOCKET_ERROR)
		{
			printf("Writing socket 2 failed with 0x%08x\n", WSAGetLastError());
			goto Exit;
		}

		printf("Socket 2 sent to %s:%u\n", inet_ntoa(NatAddr11.sin_addr), ntohs(NatAddr11.sin_port));

		EXIT_IF_MAIN_THREAD_SIGNALS(pThreadParams);

		OutgoingPing.dwClientIP = pThreadParams->LocalAddr2.S_un.S_addr;
		OutgoingPing.wClientPort = PRIMARY_TEST_PORT;
		nBytes = sendto(Sock21, (const char *) &OutgoingPing, sizeof(OutgoingPing), 0, (struct sockaddr *) &NatAddr11, sizeof(NatAddr11));
		if(nBytes == SOCKET_ERROR)
		{
			printf("Writing socket 3 failed with 0x%08x\n", WSAGetLastError());
			goto Exit;
		}

		printf("Socket 3 sent to %s:%u\n", inet_ntoa(NatAddr11.sin_addr), ntohs(NatAddr11.sin_port));

		EXIT_IF_MAIN_THREAD_SIGNALS(pThreadParams);

		OutgoingPing.dwClientIP = pThreadParams->LocalAddr2.S_un.S_addr;
		OutgoingPing.wClientPort = SECONDARY_TEST_PORT;
		nBytes = sendto(Sock22, (const char *) &OutgoingPing, sizeof(OutgoingPing), 0, (struct sockaddr *) &NatAddr11, sizeof(NatAddr11));
		if(nBytes == SOCKET_ERROR)
		{
			printf("Writing socket 4 failed with 0x%08x\n", WSAGetLastError());
			goto Exit;
		}

		printf("Socket 4 sent to %s:%u\n", inet_ntoa(NatAddr11.sin_addr), ntohs(NatAddr11.sin_port));

		EXIT_IF_MAIN_THREAD_SIGNALS(pThreadParams);

		Sleep(2000);

		EXIT_IF_MAIN_THREAD_SIGNALS(pThreadParams);

		// Add all sockets to the set to be checked for readability
		FD_ZERO(&ReadableSockets);
		FD_SET(Sock12, &ReadableSockets);
		FD_SET(Sock21, &ReadableSockets);
		FD_SET(Sock22, &ReadableSockets);

		// Wait one second for readability
		nNumReadable = select(0, &ReadableSockets, NULL, NULL, &time);
		if(nNumReadable == SOCKET_ERROR)
		{
			printf("Checking sockets for readability failed with 0x%08x\n", WSAGetLastError());
			goto Exit;
		}

		EXIT_IF_MAIN_THREAD_SIGNALS(pThreadParams);

		printf("%u sockets received data from client\n", nNumReadable + 1);
		printf("Socket 1 received packet from %s:%u\n", inet_ntoa(NatAddr11.sin_addr), ntohs(NatAddr11.sin_port));

		if(FD_ISSET(Sock12, &ReadableSockets))
		{
			// Read packet from socket 2
			nFromLen = sizeof(NatAddr12);
			nBytes = recvfrom(Sock12, (char *) bBuffer, sizeof(bBuffer), 0, (struct sockaddr *) &NatAddr12, &nFromLen);
			if(nBytes == SOCKET_ERROR)
			{
				printf("Reading socket 2 failed with 0x%08x\n", WSAGetLastError());
				goto Exit;
			}

			printf("Socket 2 received packet from %s:%u\n", inet_ntoa(NatAddr12.sin_addr), ntohs(NatAddr12.sin_port));
		}

		if(FD_ISSET(Sock21, &ReadableSockets))
		{
			// Read packet from socket 3
			nFromLen = sizeof(NatAddr21);
			nBytes = recvfrom(Sock21, (char *) bBuffer, sizeof(bBuffer), 0, (struct sockaddr *) &NatAddr21, &nFromLen);
			if(nBytes == SOCKET_ERROR)
			{
				printf("Reading socket 3 failed with 0x%08x\n", WSAGetLastError());
				goto Exit;
			}

			printf("Socket 3 received packet from %s:%u\n", inet_ntoa(NatAddr21.sin_addr), ntohs(NatAddr21.sin_port));
		}

		if(FD_ISSET(Sock22, &ReadableSockets))
		{
			// Read packet from socket 4
			nFromLen = sizeof(NatAddr22);
			nBytes = recvfrom(Sock22, (char *) bBuffer, sizeof(bBuffer), 0, (struct sockaddr *) &NatAddr22, &nFromLen);
			if(nBytes == SOCKET_ERROR)
			{
				printf("Reading socket 4 failed with 0x%08x\n", WSAGetLastError());
				goto Exit;
			}

			printf("Socket 4 received packet from %s:%u\n", inet_ntoa(NatAddr22.sin_addr), ntohs(NatAddr22.sin_port));
		}

		EXIT_IF_MAIN_THREAD_SIGNALS(pThreadParams);
	}
	// Loop exits when stop thread event is signalled

Exit:

	if(Sock11 != INVALID_SOCKET)
		closesocket(Sock11);

	if(Sock12 != INVALID_SOCKET)
		closesocket(Sock12);

	if(Sock21 != INVALID_SOCKET)
		closesocket(Sock21);

	if(Sock22 != INVALID_SOCKET)
		closesocket(Sock22);

	return 0;
}

int main(int argc, char* argv[])
{
	THREAD_PARAMS ThreadParams;
    WSADATA WSAData;
	HANDLE hThread = NULL;
	DWORD dwWaitResult = 0;
    WORD wVersionRequested = MAKEWORD(1,1);
	INT nChar = 0;
	
	// Initialize the winsock layer
    if(WSAStartup(wVersionRequested, &WSAData) != 0)
    {
		printf("WSAStartup() failed\n");
        return FALSE;
    }

	memset(&ThreadParams, 0, sizeof(ThreadParams));

	// Get local addresses
	if(!GetLocalMachineAddresses(&(ThreadParams.LocalAddr1), &(ThreadParams.LocalAddr2)))
	{
		printf("Couldn't retrieve local IP addresses\n");
		goto Exit;
	}

	printf("NatServ:  IP1: %s, IP2: %s\n", inet_ntoa(ThreadParams.LocalAddr1), inet_ntoa(ThreadParams.LocalAddr2));

	// Create event used to stop thread
	ThreadParams.hStopThreadEvent = CreateEvent(NULL, FALSE, FALSE, NULL);
	if(!ThreadParams.hStopThreadEvent)
	{
		printf("Couldn't create event\n");
		goto Exit;
	}

	// Spawn listener thread
	hThread = CreateThread(NULL, 0, ListenerThread, &ThreadParams, 0, NULL);
	if(!hThread)
	{
		printf("Couldn't create listener thread\n");
		goto Exit;
	}

	// Start main loop
	for(nChar = getchar(); ((nChar != 'q') && (nChar != 'Q')); nChar = getchar());

	// Signal listener thread to stop
	if(!SetEvent(ThreadParams.hStopThreadEvent))
	{
		printf("Couldn't signal event\n");
		goto Exit;
	}

	// Wait for listener thread to stop
	dwWaitResult = WaitForSingleObject(hThread, 10000);

Exit:

	if(ThreadParams.hStopThreadEvent)
	{
		CloseHandle(ThreadParams.hStopThreadEvent);
		ThreadParams.hStopThreadEvent = NULL;
	}

	if(hThread)
	{
		CloseHandle(hThread);
		hThread = NULL;
	}

	WSACleanup();

	return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\nat\natinfo\server\StdAfx.cpp ===
// stdafx.cpp : source file that includes just the standard includes
//	natserv.pch will be the pre-compiled header
//	stdafx.obj will contain the pre-compiled type information

#include "stdafx.h"

// TODO: reference any additional headers you need in STDAFX.H
// and not in this file
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\nat\natinfo\server\StdAfx.h ===
// stdafx.h : include file for standard system include files,
//  or project specific include files that are used frequently, but
//      are changed infrequently
//

#if !defined(AFX_STDAFX_H__11198272_50F1_4EBE_87D1_69D4D7C02EA3__INCLUDED_)
#define AFX_STDAFX_H__11198272_50F1_4EBE_87D1_69D4D7C02EA3__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000


// TODO: reference additional headers your program requires here
#include <stdio.h>
#include <winsock.h>

//{{AFX_INSERT_LOCATION}}
// Microsoft Visual C++ will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_STDAFX_H__11198272_50F1_4EBE_87D1_69D4D7C02EA3__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\nat\NatType\Client\Transactor.h ===
// Transactor.h : Define class to send request then receive reply  

#ifndef __NATTYPE_TRANSACTOR_H__
#define __NATTYPE_TRANSACTOR_H__

///////////////////////////////////////
// Transactor
//
class CTransactor
{
public:

	CTransactor( DWORD dwBaseIp, WORD wBasePort, bool bVerbose );

	bool Init();
	
	void SetReplyTo( DWORD  dwIp, WORD wPort ) 
	{
		m_dwReplyToIp  = dwIp;
		m_wReplyToPort = wPort;
	}

	bool RunTest( ERelate eToIp, ERelate eToPort, 
		          ERelate eReplyFromIp, ERelate eReplyFromPort,
				  bool& rGotReply, DWORD* pdwSrcIp, WORD* pwSrcPort );

	DWORD GetLocalIp()    const { return( m_LocalIp ); }
	WORD  GetLocalPort()  const { return( m_LocalPort ); }

private:

	bool m_bVerbose;
	
	CNonBlockingUDPSocket m_Socket;

	DWORD m_LocalIp;
	WORD  m_LocalPort;

	// Transaction ID 
	MachineID m_ClientID;
	int       m_SeqNum;

	// Send To 
	DWORD m_dwSrvIps[2];
	WORD  m_wSrvPorts[2];

	// Reply To
	DWORD  m_dwReplyToIp;
	WORD   m_wReplyToPort;

	bool Transact( const CSockAddress& ToAddress, 
		           const SRequestMsg& rReq, SReplyMsg& rReply,
				   bool& rGotReply ); 
};

#endif // __NATTYPE_TRANSACTOR_H__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\nat\NatType\Common\CmdLine.cpp ===
// CmdLine.cpp:  Implements general purpose cmd line parsing class that I plan to use later

#pragma warning( disable : 4786 )

#include <string.h>
#include "CmdLine.h"

///////////////////////////////////////////////////////////////////////////////
//	CCmdLine
///////////////////////////////////////////////////////////////////////////////

///////////////////////////////////////
// Ctor
//
CCmdLine::CCmdLine( int argc, char* argv[] )
{
	SCmdParam CurParam;
	char cSwitch = 0;
	for( int iParam = 1; iParam < argc; ++iParam )
	{
		if( NULL != strchr( "-/", argv[iParam][0] ) )
		{
			// Staring a new param
			CurParam = "";
			cSwitch  = argv[iParam][1]; 
			mParams[ cSwitch ].mSet = true; 
		}
		else
		{ 
			// Apend value
			if( ! mParams[ cSwitch ].mStr.empty() )
			{
				mParams[ cSwitch ].mStr.append( " " );
			}
			mParams[ cSwitch ].mStr.append( argv[iParam] );
		}
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\nat\NatType\Client\Transactor.cpp ===
// Transactor.cpp : Implement class to send request then receive reply

#include "..\common\NbUdpSocket.h"
#include "..\common\NatTypeData.h"
#include "..\common\GetMachineID.h"

#include "Transactor.h"

///////////////////////////////////////////////////////////////////////////////
//	CTransactor
///////////////////////////////////////////////////////////////////////////////

///////////////////////////////////////
// Ctor
//
CTransactor::CTransactor( DWORD dwBaseIp, WORD wBasePort, bool bVerbose )
	: m_bVerbose( bVerbose ), m_SeqNum( 0 ), m_dwReplyToIp( 0 ), m_wReplyToPort( 0 )
{
	m_dwSrvIps[kSame]  = dwBaseIp;
	m_wSrvPorts[kSame] = wBasePort;

	if( m_bVerbose ) 
	{
		printf( "\tPrimary server: %s:%u\n", inet_ntoa( *((in_addr*)&dwBaseIp) ), wBasePort );
	}
}

///////////////////////////////////////
// Init
//
bool CTransactor::Init()
{
	// Create the local socket
	if( ! m_Socket.Open() )
	{
		return( false );
	}
	if( m_bVerbose ) 
	{
		printf( "\tLocal socket open and set to non-blocking mode.\n" );
	}

	// Get local IP address
	TSockAddressList ClientAddrList;
	if( ! GetLocalMachineAddresses( ClientAddrList, 1 ) )
	{
		return( false );	            
	}
	m_LocalIp = ClientAddrList[0].GetIp();  
	if( m_bVerbose )
	{
		printf( "\tObtained local IP: %s\n", ClientAddrList[0].GetIpStr() );
	}

	// Bind to local address
	ClientAddrList[0].SetPort( kClientPort );
	if( ! m_Socket.Bind( ClientAddrList[0], kPortRetries ) )
	{
		return( false );
	}
	m_LocalPort = ClientAddrList[0].GetPort();
	if( m_bVerbose )
	{
		printf( "\tLocal Socket bound to port %u\n", m_LocalPort );
	}

	// Get Secondary Server Address
	MachineID midZero;
	memset( &midZero, 0, sizeof(MachineID) );
	SRequestMsg msgReqestSvrInfo( midZero, 0, 0, 0, 0, 0 );
	SReplyMsg   msgSrvInfoReply;
	bool bGotReply;
	if( ! Transact( CSockAddress( m_dwSrvIps[kSame], m_wSrvPorts[kSame] ), 
		            msgReqestSvrInfo, msgSrvInfoReply, bGotReply ) )
	{
		return( false );
	}
	if( ! bGotReply )
	{
		printf( "Geting Secondary server failed! No response.\n" );
		return( false );
	}
	m_dwSrvIps[kFamiliar]  = msgSrvInfoReply.m_SrcIp;
	m_wSrvPorts[kFamiliar] = msgSrvInfoReply.m_SrcPort;
	if( m_bVerbose )
	{
		printf( "\tSecondary server: %s:%u\n", 
				inet_ntoa( *((in_addr*)&m_dwSrvIps[kFamiliar]) ), m_wSrvPorts[kFamiliar] );
	}

	// Get unique machine ID
	if( ! GetMachineID( m_ClientID ) )
	{
		printf( "Geting Network Unique Machine ID failed!\n" );
		return( false );
	}

	return( true );
}

///////////////////////////////////////
// RunTest
//
bool CTransactor::RunTest( ERelate eToIp, ERelate eToPort, 
		                   ERelate eReplyFromIp, ERelate eReplyFromPort,
				           bool& rGotReply, DWORD* pdwSrcIp, WORD* pwSrcPort )
{
	// Set up request message
	SRequestMsg Req( m_ClientID, ++m_SeqNum,
					 eReplyFromIp, eReplyFromPort, m_dwReplyToIp, m_wReplyToPort ); 	

	// Set up destination address
	CSockAddress DestAddr( m_dwSrvIps[eToIp], m_wSrvPorts[eToPort] );

	if( m_bVerbose ) 
	{
		printf( "\tSending to %s:%u\n", DestAddr.GetIpStr(), DestAddr.GetPort() );
		printf( "\tWanting reply from [%d:%d]\n", eReplyFromIp, eReplyFromPort );
	}
				
	// Transact the test case
	SReplyMsg Reply;
	if( ! Transact( DestAddr, Req, Reply, rGotReply ) )
	{
		return( false );
	}
	
	if( (NULL != pdwSrcIp) && (NULL != pwSrcPort) ) 
	{
		*pdwSrcIp  = Reply.m_SrcIp;
		*pwSrcPort = Reply.m_SrcPort;
	}

	return( true );
}	

///////////////////////////////////////
// Transact
//
bool CTransactor::Transact
( 
	const CSockAddress&          ToAddress,
    const SRequestMsg&           rReq,
	SReplyMsg&                   rReply, 
	bool&                        rGotReply
) 
{
	rGotReply = false;

	// UDP means we'll try a few times before giving up
	for( int nRetries = kSendRetries; nRetries > 0; --nRetries )
	{
		// Send
		if( ! m_Socket.SendTo( ToAddress, (char*)&rReq, sizeof(SRequestMsg) ) )
		{
			return( false );
		}

		// Wait
		bool MsgWaiting;
		if( ! m_Socket.WaitForMsg( kRecvTimeOut, MsgWaiting ) )
		{
			return( false );
		}
		if( ! MsgWaiting )
		{
			continue;
		}

		// Recieve
		CSockAddress RecvSockAddr;
		if( ! m_Socket.RecvMsgFrom( RecvSockAddr, (char*)&rReply, sizeof(SReplyMsg) ) )
		{
			return( false );
		}
		++nRetries; // Reading something buys back a retry

		// Check
		if( rReq.m_TID == rReply.m_TID )
		{
			rGotReply = true;
			break;
		}
	}

	// Ran out of tries
	return( true );
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\nat\NatType\Client\NatType.cpp ===
// NatType.cpp : Implement client side of NAT type test

#include <windows.h>
#include <stdio.h>

#include "..\common\CmdLine.h"
#include "..\common\NbUdpSocket.h"
#include "..\common\NatTypeData.h"

#include "Transactor.h"

///////////////////////////////////////
// Usage
//
void Usage()
{
	printf( "\nUsage: NatType -a <ServerIP> [-p <ServerPort>] [-v]\n\n" );
    printf( "\t<ServerIP> : One of the 3 IP addresses of the server outside the NAT\n" );
    printf( "\t<ServerPort> : Port to use for intiial contact with above IP\n" );
	printf( "\t               (if default doesn't work)\n" );
	printf( "\t-v : Verbose output\n" );
}

///////////////////////////////////////
// PrintFinalResult
//
void PrintFinalResult( int iNatType )
{
	printf( "\nFINAL RESULT:\nNAT Type is %d\n", iNatType );

	switch( iNatType )
	{
	case 1: printf( "No NAT, no port assignment and no filtering.\n" );               break;
	case 2: printf( "Minimal port assignment and loose filtering.\n" );               break;
	case 3: printf( "Minimal port assignment and address-sensitive filtering.\n" );   break;
	case 4: printf( "Minimal port assignment and port-sensitive filtering.\n" );      break;
	case 5: printf( "Aggressive port assignment and loose filtering\n" );             break;
	case 6: printf( "Aggressive port assignment and address-sensitive filtering\n" ); break;
	case 7: printf( "Aggressive port assignment and port-sensitive filtering.\n" );   break;
	}
}

///////////////////////////////////////
// main
//
int main( int argc, char* argv[] )
{
	// Parse command line amd check args
	CCmdLine CmdLine( argc, argv );
	// ... Server IP
	DWORD dwSrvIp = inet_addr( CmdLine['a'].mStr.c_str() );
	if( (INADDR_NONE == dwSrvIp) || (0 == dwSrvIp) )
	{
		printf( "Server address not valid! \"%s\"\n", CmdLine['a'].mStr.c_str() );
		Usage();
		return( 1 );
	}
	// ... Server Port, may need to set if server can't bind the default.
	WORD wSrvPort = kServerPort[kSame];
	if( CmdLine['p'].mSet ) 
	{
		if( 0 == sscanf( CmdLine['p'].mStr.c_str(), "%hu", &wSrvPort ) )
		{
			printf( "Server port not valid! \"%s\"\n", CmdLine['p'] );
			Usage();
			return( 1 );
		}
	}
	// ... Verbose output flag
	bool Verbose = CmdLine['v'].mSet;
	// ... Usage flag
	if( CmdLine['?'].mSet )
	{
		Usage();
		return( 1 );
	}

	// Initialize the winsock layer
	CWinSockInit WinSock;
	if( ! WinSock.Startup( 1, 1 ) ) 
	{
		return( 1 );
	}
	if( Verbose ) printf( "\tWinsodk Initialized.\n" );

	// Create and init request transactor
	CTransactor Transactor( dwSrvIp, wSrvPort, Verbose );
	if( ! Transactor.Init() )
	{
		return( 1 );
	}

	// Prepare to run the tests
	int iNatType = 1;

	bool  bGotReply;
	DWORD dwSrcIp;
	WORD  wSrcPort;

	// Test 1
	// ------
	printf( "\nTest 1 - Is there a NAT?\n" );
	if( ! Transactor.RunTest( kSame, kSame, kSame, kSame, bGotReply, &dwSrcIp, &wSrcPort ) )
	{
		return( 1 );
	}
	if( !bGotReply )
	{
		printf( "Invalid Result. No response.\n" );
		return( 1 );
	}
	if( Verbose ) 
	{
		printf( "\tServer reported Src as %s:%u\n", 
			    inet_ntoa( *((in_addr*)&dwSrcIp) ), wSrcPort );
	}
	if( (dwSrcIp  == Transactor.GetLocalIp()) &&
		(wSrcPort == Transactor.GetLocalPort()) )
	{
		printf( "--- NO\n" );
		
		PrintFinalResult( iNatType );
		return( 0 );
	}
	printf( "--- YES\n" );
	DWORD dwNatIp = dwSrcIp;
	WORD  wNatPort = wSrcPort;
	Transactor.SetReplyTo( dwNatIp, wNatPort );

	// Assignment Cases
	printf( "\nIs Assignment Aggressive?\n"	);

	// Test 2
	// ------
	printf( "Test 2 - Dependent on destination IP?\n" );
	if( ! Transactor.RunTest( kFamiliar, kSame, kSame, kSame, bGotReply, &dwSrcIp, &wSrcPort ) )
	{
		return( 1 );
	}
	if( !bGotReply )
	{
		printf( "Invalid Result. No response.\n" );
		return( 1 );
	}
	if( Verbose ) 
	{
		printf( "\tServer reported Src as %s:%u\n", 
			    inet_ntoa( *((in_addr*)&dwSrcIp) ), wSrcPort );
	}
	bool bAggOnIp = ( (dwSrcIp != dwNatIp) || (wSrcPort != wNatPort) );
	printf( "--- %s\n", bAggOnIp ? "YES" : "NO" );

	// Test 3
	// ------
	printf( "Test 3 - Dependent on destination Port?\n" );
	if( ! Transactor.RunTest( kSame, kFamiliar, kSame, kSame, bGotReply, &dwSrcIp, &wSrcPort ) )
	{
		return( 1 );
	}
	if( !bGotReply )
	{
		printf( "Invalid Result. No response.\n" );
		return( 1 );
	}
	if( Verbose ) 
	{
		printf( "\tServer reported Src as %s:%u\n", 
			    inet_ntoa( *((in_addr*)&dwSrcIp) ), wSrcPort );
	}
	bool bAggOnPort = ( (dwSrcIp != dwNatIp) || (wSrcPort != wNatPort) );
	printf( "--- %s\n", bAggOnIp ? "YES" : "NO" );
	
	// Assignment Summary
	if( bAggOnIp )
	{
		iNatType = 5;
		if( bAggOnPort )
		{
			printf( "\nAssigment depends on either port or IP.\n" );
		}
		else 
		{
			printf( "\nAssigment depends on IP.\n" );
		}
	}
	else
	{
		if( bAggOnPort )
		{
			iNatType = 5;
			printf( "\nAssigment depends on port.\n" );
		}
		else 
		{
			iNatType = 2;
			printf( "\nAssigment is minimal\n" );
		}
	}
	
	// Port Filtering Cases
	printf( "\nIs filtering port sensitive?\n" );

	// Test 4
	// ------
	printf( "Test 4 - From base IP - familiar port?\n" );
	if( ! Transactor.RunTest( kSame, kSame, kSame, kFamiliar, bGotReply, NULL, NULL ) )
	{
		return( 1 );
	}
	bool bPortFilter = !bGotReply;
	printf( "--- %s\n", bPortFilter ? "YES" : "NO" );

	// Test 5
	// ------
	printf( "Test 5 - From base IP - unfamiliar port?\n" );
	if( ! Transactor.RunTest( kSame, kSame, kSame, kUnfamiliar, bGotReply, NULL, NULL ) )
	{
		return( 1 );
	}
	bool bPortFilter2 = !bGotReply;
	printf( "--- %s\n", bPortFilter2 ? "YES" : "NO" );

	// Port Filtering Summary
	if( bPortFilter || bPortFilter2 )
	{
		iNatType += 2;
		PrintFinalResult( iNatType );
		return( 0 );
	}

	// Address Filtering Cases
	printf( "\nIs filtering address sensitive?\n" );
	
	// Test 6
	// ------
	printf( "Test 6 - From familiar IP - familiar port?\n" );
	if( ! Transactor.RunTest( kSame, kSame, kFamiliar, kFamiliar, bGotReply, NULL, NULL ) )
	{
		return( 1 );
	}
	printf( "--- %s\n", !bGotReply ? "YES" : "NO" );
	bool bAddrFilter = !bGotReply;
	
	// Test 7
	// ------
	printf( "Test 7 - From familiar IP - base port?\n" );
	if( ! Transactor.RunTest( kSame, kSame, kFamiliar, kSame, bGotReply, NULL, NULL ) )
	{
		return( 1 );
	}
	printf( "--- %s\n", !bGotReply ? "YES" : "NO" );
	bAddrFilter |= !bGotReply;

	// Test 8
	// ------
	printf( "Test 8 - From familiar IP - unfamiliar port?\n" );
	if( ! Transactor.RunTest( kSame, kSame, kFamiliar, kUnfamiliar, bGotReply, NULL, NULL ) )
	{
		return( 1 );
	}
	printf( "--- %s\n", !bGotReply ? "YES" : "NO" );
	bAddrFilter |= !bGotReply;

	// Test 9
	// ------
	printf( "Test 9 - From unfamiliar IP - bse port?\n" );
	if( ! Transactor.RunTest( kSame, kSame, kUnfamiliar, kSame, bGotReply, NULL, NULL ) )
	{
		return( 1 );
	}
	printf( "--- %s\n", !bGotReply ? "YES" : "NO" );
	bAddrFilter |= !bGotReply;

	// Test 10
	// ------
	printf( "Test 10 - From unfamiliar IP - familar port?\n" );
	if( ! Transactor.RunTest( kSame, kSame, kUnfamiliar, kFamiliar, bGotReply, NULL, NULL ) )
	{
		return( 1 );
	}
	printf( "--- %s\n", !bGotReply ? "YES" : "NO" );
	bAddrFilter |= !bGotReply;

	// Test 11
	// ------
	printf( "Test 11 - From unfamiliar IP - unfamilar port?\n" );
	if( ! Transactor.RunTest( kSame, kSame, kUnfamiliar, kUnfamiliar, bGotReply, NULL, NULL ) )
	{
		return( 1 );
	}
	printf( "--- %s\n", !bGotReply ? "YES" : "NO" );
	bAddrFilter |= !bGotReply;

	// Address Filtering Summary
	if( bAddrFilter )
	{
		iNatType += 1;
	}

	PrintFinalResult( iNatType );
	return( 0 );
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\nat\NatType\Common\GetMachineID.h ===
// GetMachineID.cpp: Defines function and type to get unique machine ID

#ifndef _GETMACHINEID_H_
#define _GETMACHINEID_H_

typedef unsigned char MachineID[6];

bool GetMachineID( MachineID& rID );

#endif // _GETMACHINEID_H_
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\nat\NatType\Common\NbUdpSocket.cpp ===
// NbUdpSocket.cpp:  Implements general purpose non blocking UDP socket classes 
//                   and functions that could be useful later

#include <stdio.h>
#include "NbUdpSocket.h"


///////////////////////////////////////////////////////////////////////////////
//	CWinSockInit
///////////////////////////////////////////////////////////////////////////////

///////////////////////////////////////
//	Startup
//
bool CWinSockInit::Startup( BYTE Major, BYTE Minor )
{			 
	if( m_bReady )
	{
		// should assert
		return( false );
	}

    WORD wVersionRequested = MAKEWORD( Major, Minor );
    WSADATA WSAData;
	int rc = WSAStartup( wVersionRequested, &WSAData );
	if( rc != 0 )
    {
		printf( "WSAStartup() failed. Error: %d\n", rc );
    }
	m_bReady = ( rc == 0 );
	return( m_bReady );
}

///////////////////////////////////////
//	Dtor
//
CWinSockInit::~CWinSockInit()
{			 
	if( m_bReady )
	{
		WSACleanup();
	}
}

///////////////////////////////////////////////////////////////////////////////
//	CSockAddress
///////////////////////////////////////////////////////////////////////////////

///////////////////////////////////////
// Ctor, Ip as dotted string 
//
CSockAddress::CSockAddress( const char* pszIp, WORD wPort )
{
	if( (NULL != pszIp) && ('\0' != *pszIp) )
	{
		Init( inet_addr( pszIp ), wPort );
	}
	else 
	{
		Init( INADDR_ANY, wPort );
	}
}

///////////////////////////////////////
// Ctor, Ip as dword in network order
//
CSockAddress::CSockAddress( DWORD dwIp, WORD wPort )
{
	Init( dwIp, wPort );
}

///////////////////////////////////////
// Init
//
void CSockAddress::Init( DWORD dwIp, WORD wPort )
{
	memset( &m_Addr, 0, sizeof(SOCKADDR_IN) );

	m_Addr.sin_family      = AF_INET;
	m_Addr.sin_addr.s_addr = dwIp;
	m_Addr.sin_port        = htons( wPort );
}


///////////////////////////////////////////////////////////////////////////////
//	CNonBlockingUDPSocket
///////////////////////////////////////////////////////////////////////////////

///////////////////////////////////////
// Open 
//
bool CNonBlockingUDPSocket::Open()
{
	// Create socket
	m_hSock = socket( AF_INET, SOCK_DGRAM, 0 );
	if( m_hSock == INVALID_SOCKET )
	{
		printf( "Couldn't create socket! Error: %d\n", WSAGetLastError() );
		return( false );
	}

	// Set socket to be non-blocking
	DWORD dwNonBlocking = TRUE;
	if( ioctlsocket( m_hSock, FIONBIO, &dwNonBlocking ) == SOCKET_ERROR )
	{
		printf( "Couldn't set socket to non-blocking. Error: %d\n", WSAGetLastError() );
		return( false );
	}

	return( true );
}

///////////////////////////////////////
// Bind
//
bool CNonBlockingUDPSocket::Bind( CSockAddress& rAddr, WORD wPortRange )
{
	WORD wFirstPort = rAddr.GetPort();

	for( WORD wTry = 0; wTry < wPortRange; ++wTry )
	{
		if( SOCKET_ERROR == bind( m_hSock, rAddr.GetSockAddrPtr(), sizeof(SOCKADDR_IN) ) )
		{
			if( (WSAEADDRINUSE != WSAGetLastError())    && 
				(WSAEADDRNOTAVAIL != WSAGetLastError()) )
			{
				printf( "Binding socket failed! Error: %d\n", WSAGetLastError() );
				return( false );
			}
			rAddr.IncPort();
		}
		else
		{
			return( true );
		}
    }
	
	printf( "Binding socket on %s failed!\n", rAddr.GetIpStr() );
	if( wPortRange > 1 )
	{
		printf( "Ports %u through %u unavailaible.\n", wFirstPort, wFirstPort+wPortRange-1 );
	}
	else 
	{
		printf( "Port %u unavailaible.\n", wFirstPort );
	}

	return( false );
}

///////////////////////////////////////
// SendTo
//
// Handles unlikely case of an output buffer
//	shortage
//
bool CNonBlockingUDPSocket::SendTo( const CSockAddress& rDest, char* pBuf, int BufLen ) const
{	
	// Keep going until message is sent or a failure occurs
	while( true )
	{
		// printf( "Sending to: %s:%u\n", rDest.GetIpStr(), rDest.GetPort() );
		int nBytes = sendto( m_hSock, pBuf, BufLen, 0, rDest.GetSockAddrPtr(), sizeof(SOCKADDR_IN) );
		
		// Error!
		if(	nBytes == SOCKET_ERROR )
		{
			// Anything that's not a "would block" spells doom
			if( WSAEWOULDBLOCK != WSAGetLastError() )
			{
				printf( "Writing socket failed! Error = %d\n", WSAGetLastError() );
				return( false );
			}

			// Select a few times to see if writing becomes possible
			TIMEVAL WaitTime = { 0, kWriteRetry_uSec };
			FD_SET Writeable;
			FD_ZERO( &Writeable );
			FD_SET( m_hSock, &Writeable );	
			for( int iWait = 0; iWait < kWriteRetry_Count; ++iWait )
			{
				int NumWriteable = select( 0, NULL, &Writeable	, NULL, &WaitTime ); 
				if( 1 == NumWriteable)
				{
					break; // Out of loop
				}
					
				if( SOCKET_ERROR == NumWriteable )
				{
					printf( "Waiting for writable state on socket failed! Error = %d\n", WSAGetLastError() );
					return( false );
				}
			}
				
			// Check to see if waited long enough
			if( iWait >= kWriteRetry_Count )
			{
				printf( "Waiting for writable state on socket failed! Tried every %f second, %d tiems.\n", 
						float( WaitTime.tv_usec ) / 1000000, kWriteRetry_Count );
				return( false );
			}
		}
		// Incomplete Message sent
		else if( nBytes < BufLen )
		{
			printf( "Writing socket failed! Only sent %d of %d bytes in message.\n", nBytes, BufLen );
			return( false );
		}
		// Success!
		else
		{
			break; // Out of loop
		}
	}

	return( true );
}

///////////////////////////////////////
// WaitForMsg	
//
bool CNonBlockingUDPSocket::WaitForMsg( long Seconds, bool& rMsgArived ) const
{
	FD_SET Readable;
	FD_ZERO( &Readable );
	FD_SET( m_hSock, &Readable );

	TIMEVAL Wait = { Seconds, 0 };

	int nNumReadable = select( 0, &Readable, NULL, NULL, &Wait ); 
	if( nNumReadable == SOCKET_ERROR )
	{
		printf( "Select for readable socket failed! Error = %d\n", WSAGetLastError() );
	}

	rMsgArived = (nNumReadable > 0);
	return( nNumReadable != SOCKET_ERROR );
}

///////////////////////////////////////
// RecvMsgFrom
//
bool CNonBlockingUDPSocket::RecvMsgFrom( CSockAddress& rSrc, char* pBuf, int BufLen ) const
{

	int nFromLen = sizeof( SOCKADDR_IN );
	int nBytes = recvfrom( m_hSock, pBuf, BufLen, 0, rSrc.GetSockAddrPtr(), &nFromLen );
	if( nBytes == SOCKET_ERROR )
	{
		printf(	"Reading socket failed! Error = %d\n", WSAGetLastError() );
		return( false );
	}
	if( (sizeof( SOCKADDR_IN ) > nFromLen) || (BufLen > nBytes) )
	{
		printf(	"Reading socket failed! Incomplete Msg: &d of %d\n", nBytes, BufLen );
			return( false );
	}

	return( true );
}

///////////////////////////////////////
// RecvFrom
//
bool CNonBlockingUDPSocket::RecvFrom( CSockAddress& rSrc, char* pBuf, int BufLen, int& nRead ) const
{
	int nFromLen = sizeof( SOCKADDR_IN );
	nRead = recvfrom( m_hSock, pBuf, BufLen, 0, rSrc.GetSockAddrPtr(), &nFromLen );
	if( nRead == SOCKET_ERROR )
	{
		printf(	"Reading socket failed! Error = %d\n", WSAGetLastError() );
		return( false );
	}

	if( nFromLen < sizeof( SOCKADDR_IN ) )
	{
		printf( "Recieved incomplete source address\n" );
		return( false );
	}
	return( true );
}


///////////////////////////////////////////////////////////////////////////////
//	Functions
///////////////////////////////////////////////////////////////////////////////

///////////////////////////////////////
//	GetLocalMachineAddresses
//
bool GetLocalMachineAddresses( TSockAddressList& rList, int nCount )
{ 
   // Get host name or token
	char szHostName[ kHostNameLen ];
	if( gethostname( szHostName, kHostNameLen ) != 0 )
	{
		printf( "gethostname failed! Error = %d\n", WSAGetLastError() );
		return( false );
	}

   // Get list of host addresses
   HOSTENT* pHostEnt = gethostbyname( szHostName );
	if( NULL == pHostEnt )
	{
		printf( "gethostbyname failed! Error = %d\n", WSAGetLastError() );
		return( false );
	}

   // Load list with desired number of addresses
   rList.clear();
   for( int i = 0; i < nCount; ++i )
   {
#ifdef ONE_IP_SVR
      rList.push_back( CSockAddress( *((DWORD*)pHostEnt->h_addr_list[0]) ) );      
#else
      if( NULL == pHostEnt->h_addr_list[i] )
      {
         printf( "Only found %d local addresses, needed %d\n", i, nCount );
         return( false );
      }

      rList.push_back( CSockAddress( *((DWORD*)pHostEnt->h_addr_list[i]) ) );      
#endif
   }
   return( true );
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\nat\NatType\Common\GetMachineID.cpp ===
// GetMachineID.cpp: Implements function to get unique machine ID

#include <windows.h>
#include <stdio.h>

#include "GetMachineID.h"

bool GetMachineID( MachineID& rID )
{
	NCB Ncb;

	// Make sure there's at least one adapter
    LANA_ENUM  lenum;
    memset( &Ncb, 0, sizeof(Ncb) );
    Ncb.ncb_command = NCBENUM;
    Ncb.ncb_buffer  = (UCHAR *)&lenum;
    Ncb.ncb_length  = sizeof(lenum);
    UCHAR uRetCode = Netbios( &Ncb );
	if( (NRC_GOODRET != uRetCode) || (1 > lenum.length) )
	{
		printf( "LANA Eumation Failed!\n" );
		return( false );
	}

	// Reset adapter in preparation to get status
	memset( &Ncb, 0, sizeof(Ncb) );
	Ncb.ncb_command  = NCBRESET;
	Ncb.ncb_lana_num = lenum.lana[0];
	uRetCode = Netbios( &Ncb );
	if( NRC_GOODRET != uRetCode )
	{
		printf( "Adapter Reset Failed! Error = 0x%x\n", uRetCode );
		return( false );
	}

	// Get Adapter status 
	struct ASTAT
	{
		ADAPTER_STATUS adapt;
		NAME_BUFFER    NameBuff[30];
	
	} Adapter;

	memset( &Ncb, 0, sizeof (Ncb) );
	Ncb.ncb_command  = NCBASTAT;
	Ncb.ncb_lana_num = lenum.lana[0];
	strcpy( (char*)Ncb.ncb_callname,  "*               " );
	Ncb.ncb_buffer   = (unsigned char *) &Adapter;
	Ncb.ncb_length   = sizeof(Adapter);
	uRetCode = Netbios( &Ncb );
	if( NRC_GOODRET != uRetCode )
	{
		printf( "Getting Adapter Status Failed! Error = 0x%x\n", uRetCode );
		return( false );
	}

	// Store adapter address as machine ID
	memcpy( rID, Adapter.adapt.adapter_address, 6 );

	return( true );
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\nat\NatType\Common\CmdLine.h ===
// CmdLine.h:  Defines general purpose cmd line parsing class that I plan to use later

#ifndef _CMDLINEPARSER_H_
#define	_CMDLINEPARSER_H_

#pragma warning( disable : 4786 )

// Includes
#include <map>
#include <string>

// Forward declarations
class CCmdLine;

///////////////////////////////////////
//	CCmdParam
//
struct SCmdParam
{
public:

	SCmdParam( char* str = ""  )
		: mSet( false ), mStr( str ) {}

	bool        mSet;
	std::string mStr;
};


///////////////////////////////////////
//	CCmdLine
//
class CCmdLine
{
public:
	
	CCmdLine( int argc, char* argv[] );

	const SCmdParam& operator[]( char cSwitch )
	{
		return( mParams[ cSwitch ] );
	}
	
private:

	// Prevent copying, assignment, and default consturction
	CCmdLine();                                   // Not Implemented
	CCmdLine( const CCmdLine& );				  // Not Implemented
	const CCmdLine& operator=( const CCmdLine& ); // Not Implemented

	// Parsed parameter storage
	typedef std::map<char, SCmdParam> ParamList;
	ParamList mParams;
};

#endif // _CMDLINEPARSER_H_
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\nat\NatType\Common\NatTypeData.h ===
// NatType.h:  Defines data that's shared by client and Server

#ifndef _NATTYPECOMMON_H_
#define _NATTYPECOMMON_H_

#include <stdlib.h>

#include "GetMachineID.h"

// Port bindng contatns 
const WORD kServerPort[3] = { 20000, 21000, 22000 };
const WORD kClientPort    = 3074;

#ifdef ONE_IP_SVR
const WORD kPortRetries = 3;
#else
const WORD kPortRetries = 1;
#endif

// Index into IP and port arrays according to relationship with base case
typedef int ERelate;
const int kSame       = 0;
const int kFamiliar   = 1;
const int kUnfamiliar = 2;

// Transaction constants
const int kSendRetries  = 5;
const int kRecvTimeOut = 2;

// Tranaction ID
struct TransactionID
{
	MachineID m_Machine;
	WORD      m_Sequence;

	TransactionID() 
	: m_Sequence(0) 
	{	
		memset( &m_Machine, 0, sizeof(MachineID) ); 
	}
	
	TransactionID( const MachineID& id, WORD seq ) 
	: m_Sequence(seq) 
	{	
		memcpy( &m_Machine, &id, sizeof(MachineID) ); 
	}

	bool operator==( const TransactionID& that ) const
	{
		return( (m_Sequence == that.m_Sequence) && 
			    (0 == memcmp( &m_Machine, &that.m_Machine, sizeof(MachineID) )) );
	}

	bool IsNull() const 
	{
		return( *this == TransactionID() );
	}
};

// Reqest Messsage
struct SRequestMsg
{
	TransactionID m_TID;

	ERelate m_ReplyFromIP;
	ERelate m_ReplyFromPort;
	DWORD   m_ReplyToIp;
	WORD    m_ReplyToPort;

	SRequestMsg()
	{
		memset( this, 0, sizeof(this) );
	}

	SRequestMsg( const MachineID& mId, WORD wSeq,
				 ERelate eFromIp, ERelate eFromPort,
				 DWORD dwToIp, WORD wToPort )
	: m_TID( mId, wSeq ), 
	  m_ReplyFromIP( eFromIp ), m_ReplyFromPort( eFromPort ),
	  m_ReplyToIp( dwToIp ), m_ReplyToPort( wToPort )
	{}
};

// Reply Message
struct SReplyMsg
{
	TransactionID m_TID;

	DWORD m_SrcIp;
	WORD  m_SrcPort;

	SReplyMsg()
	{
		memset( this, 0, sizeof(this) );
	}

	SReplyMsg( TransactionID tID, DWORD dwSrcIp, WORD wSrcPort )
	: m_TID( tID ), m_SrcIp( dwSrcIp ), m_SrcPort( wSrcPort ) 
	{}
};

#endif // _NATTYPECOMMON_H_
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\PackageCheck\makefile.inc ===
!include $(INETROOT)\build\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\nat\NatType\Common\Utility.h ===
// Utility.h:  Really general purpose stuff to be used again later

class SafeWin32Handle
{
public:

	explicit SafeWin32Handle( HANDLE h ) : mHandle( h ) {}
	~SafeWin32Handle() { if( mHandle ) CloseHandle( mHandle ); }
	
	operator HANDLE() const { return( mHandle ); }

private:

	HANDLE mHandle;
};
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\nat\NatType\Common\NbUdpSocket.h ===
// NbUdpSocket.h:  Defines general purpose non blocking UDP socket classes 
//                 and functions that could be useful later

#ifndef _GENERALNBUDPSOCKET_H_
#define _GENERALNBUDPSOCKET_H_

#include <vector>
#include <Winsock.h>
#include <stdio.h>

///////////////////////////////////////
// Buffer size constants

const int kHostNameLen = 255;

///////////////////////////////////////
//	CWinSockInit
//
//	Wraps WSA Startup so matching 
//
class CWinSockInit
{
public:

	CWinSockInit() : m_bReady( false ) {}
	~CWinSockInit();

	bool Startup( BYTE Major, BYTE Minor );

private:
	
	// No copying or assignment allowed
	CWinSockInit( const CWinSockInit& );            // not implemented
	CWinSockInit& operator=( const CWinSockInit& ); // not implemented
	
	bool m_bReady;
};

///////////////////////////////////////
//	CSockAddress
//
//	Wraps SOCKADDR_IN struct for easier use	
//
class CSockAddress
{
public:

	CSockAddress( const char* pszIp, WORD wPort = 0 );        
	CSockAddress( DWORD dwIp = INADDR_ANY, WORD wPort = 0 );

	DWORD       GetIp() const       { return( m_Addr.sin_addr.s_addr ); }  
	const char* GetIpStr() const    { return( inet_ntoa( m_Addr.sin_addr ) ); }
	void        SetIp( DWORD dwIp ) { m_Addr.sin_addr.s_addr = dwIp; }

	WORD GetPort() const       { return( ntohs( m_Addr.sin_port ) ); }
	void SetPort( WORD wPort ) { m_Addr.sin_port = htons( wPort ); }

friend class CNonBlockingUDPSocket;
private:

	void Init( DWORD dwIp, WORD wPort );

	void IncPort()             { SetPort( GetPort() + 1 ); }

	SOCKADDR* GetSockAddrPtr() const { return( (SOCKADDR*)&m_Addr ); } 

	SOCKADDR_IN m_Addr;
};

typedef std::vector<CSockAddress> TSockAddressList;


///////////////////////////////////////
//	CNonBlockingUdpSocket
//
//	Non blocking UDP socket for easy general use
//
class CNonBlockingUDPSocket
{
public:

	CNonBlockingUDPSocket()
		: m_hSock( INVALID_SOCKET ) 
	{}
	
	~CNonBlockingUDPSocket() 
	{ 
		if( INVALID_SOCKET != m_hSock ) 
			closesocket( m_hSock ); 
	}
																	  
	bool Open();
	bool Bind( CSockAddress& rAddr, WORD wPortRange = 1 );
	bool SendTo( const CSockAddress& rDest, char* pBuf, int BufLen ) const;
	bool WaitForMsg( long Seconds, bool& rMsgArived ) const;
	bool RecvMsgFrom( CSockAddress& rSrc, char* pBuf, int BufLen ) const;
	bool RecvFrom( CSockAddress& rSrc, char* pBuf, int BufLen, int& nRead ) const;

	operator SOCKET() { return( m_hSock ); }

private:
	
	enum
	{
		kWriteRetry_uSec  = 100000,
		kWriteRetry_Count = 10
	};

	SOCKET m_hSock;
};

///////////////////////////////////////
//	Functions
//
bool GetLocalMachineAddresses( TSockAddressList& rList, int nCount );

#endif // _GENERALNBUDPSOCKET_H_
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\PackageCheck\obj\i386\_generated.cs ===
[assembly:System.Runtime.InteropServices.ComVisible(false)]
[assembly:System.Reflection.AssemblyVersion("12.4.56.0")]
[assembly:System.Reflection.AssemblyProduct("Microsoft(R) Xbox(TM)")]
[assembly:System.Reflection.AssemblyCopyright("Copyright (c) Microsoft Corporation. All rights reserved.")]
[assembly:System.Reflection.AssemblyCompany("Microsoft Corporation")]
[assembly:System.Reflection.AssemblyFileVersion("12.4.56.0")]
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\nat\NatType\Server\NatTypeSrv.cpp ===
// NatTypeSrv.cpp : Server side of NAT Classification test tool

#pragma warning( disable : 4786 )

#include <stdio.h>
#include <conio.h>

#include "..\common\CmdLine.h"
#include "..\common\NbUdpSocket.h"
#include "..\common\NatTypeData.h"

#include "Reflector.h"

///////////////////////////////////////
// Usage
//
void Usage()
{
	printf( "Usage: NatTypeSrv [-v]\n" );
	printf( "       -v : Verbose output\n" );
}

///////////////////////////////////////
// main
//
int main( int argc, char* argv[] )
{
	// Parse command line
	CCmdLine CmdLine( argc, argv );
	if( CmdLine['?'].mSet )
	{
		Usage();
		return( 1 );
	}
	bool Verbose = CmdLine['v'].mSet;

	// Initialize the winsock layer
	CWinSockInit WinSock;
	if( ! WinSock.Startup( 1, 1 ) ) 
	{
		return( 1 );
	}
	if( Verbose ) printf( "\tWinsodk Initialized.\n" );

	// Create and init request reflector
	CReflector Reflector;
	if( ! Reflector.Init( Verbose ) )
	{
		return( 1 );
	}

	// Display Client Cmd Line
	if( Reflector.GetBasePort() == kServerPort[kSame] )
	{
		printf( "On client Machine enter: NatType -a %s\n", 
			    Reflector.GetBaseIpStr() );
	}
	else 
	{
		printf( "On client Machine enter: NatType -a %s -p %hu\n", 
			    Reflector.GetBaseIpStr(), Reflector.GetBasePort() );
	}

	// Start processing request
	if( ! Reflector.Start() )
	{
		return( 1 );
	}
	
	// wait for quit key
	printf( "NAT Info Server Started. Press Q key to exit.\n\n" );
	for( int nChar = _getche(); ((nChar != 'q') && (nChar != 'Q')); nChar = _getche())
	{
		if( ! Reflector.IsActive() ) // has a built in delay
		{
			printf( "Processing terminated unexpectedly.\n" );
			break;
		}
	}

	// Signal listener thread to stop
	return( Reflector.Stop() );
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\nat\NatType\Server\Reflector.cpp ===
// Reflector.cpp : Implement class that responds to requests

#include "..\common\NbUdpSocket.h"
#include "..\common\NatTypeData.h"

#include "Reflector.h"

///////////////////////////////////////////////////////////////////////////////
//	CReflector
///////////////////////////////////////////////////////////////////////////////

///////////////////////////////////////
// Init
//
bool CReflector::Init( bool bVerbose )
{
	m_Verbose = bVerbose;

	// Get local IP addresses
	TSockAddressList ServerAddrList;
	if( ! GetLocalMachineAddresses( ServerAddrList, 3 ) )
	{
		return( false );	            
	}
	if( m_Verbose )
	{
		printf( "\tLocal IP addresses:\n");
		printf( "\t\t1: %s\n", ServerAddrList[0].GetIpStr() );
		printf( "\t\t2: %s\n", ServerAddrList[1].GetIpStr() );
		printf( "\t\t3: %s\n", ServerAddrList[2].GetIpStr() );
	}

	// Create the local sockets
	int iIP, iPort;
	for( iIP = 0; iIP < 3; ++iIP )
	{
		for( iPort = 0; iPort < 3; ++iPort )
		{
			if( ! m_Socket[iIP][iPort].Open() )
			{
				return( false );	            
			}
		}
	}
	if( m_Verbose ) printf( "\tLocal sockets open and set to non-blocking mode.\n" );

	// Bind to local addresses

	// TBD!!  Make this work as intended
	//        The bind will retry a range of ports until it gets one that's available.
	//        However the tests rely on the 3 port numbers being consistent accross all
	//        3 IP's.  To work around this for now kPortRetries has been set to 1.
	//        Need to figure out a way to let the server be flexible in the ports it uses
	//        yet remain consistent.
	
	if( m_Verbose ) printf( "\tLocal Socket bindings:\n" );
	for( iIP = 0; iIP < 3; ++iIP )
	{
		for( iPort = 0; iPort < 3; ++iPort )
		{
			ServerAddrList[iIP].SetPort( kServerPort[iPort] );

			if( ! m_Socket[iIP][iPort].Bind( ServerAddrList[iIP], kPortRetries ) )
			{
				return( false );	            
			}

			if( (iIP < 2) && (iPort < 2) )
			{
				m_RecvAddr[iIP][iPort] = ServerAddrList[iIP];	
			}

			if( m_Verbose ) 
			{	
				printf( "\t\tSocket[%i][%i] bound to: %s:%u\n", iIP, iPort,
					    ServerAddrList[iIP].GetIpStr(), ServerAddrList[iIP].GetPort() ); 
			}
		}
	}

	return( true );
}



///////////////////////////////////////
// Start
//
bool CReflector::Start()
{
	// Spawn proccessing thread
	m_hThread = CreateThread( NULL, 0, CReflector::ThreadFunc, this, 0, NULL );
	if( NULL == m_hThread )
	{
		printf( "Couldn't create thread! Error = %lu\n", GetLastError() );
		return( false );
	}
	return( true );
}

///////////////////////////////////////
// Stop
//
int CReflector::Stop()
{
	printf( "Stopping." );

	InterlockedIncrement( &m_lStopSignal );

	// Wait for listener thread to stop
	for( int iWait = 0; iWait < 10; ++iWait )
	{
		DWORD dwResult = WaitForSingleObject( m_hThread, 500 );
		if( dwResult == WAIT_OBJECT_0 )
		{
			break; // out of loop
		}
		else if( dwResult == WAIT_TIMEOUT )
		{
			printf("."); 
			continue;
		}
		else
		{
			printf( "\nCouldn't wait! Error = %lu\n", GetLastError() );
			return( 1 );
		}
	}

	if( iWait >= 10 )
	{
		printf( "\nWaited long enough.!\n" );
		return( 1 );
	}

	printf( "\n" );
	DWORD dwExitCode; 
	GetExitCodeThread( m_hThread, &dwExitCode );
	if( m_Verbose ) printf( "Thread Stopped. Exit code = %u\n", dwExitCode );
	return( int( dwExitCode ) );
}
	
///////////////////////////////////////
// IsActive
//
bool CReflector::IsActive()
{
	DWORD dwResult = WaitForSingleObject( m_hThread, 250 );
	return( dwResult != WAIT_OBJECT_0 );
}

///////////////////////////////////////
// ProcessingLoop
//
bool CReflector::ProcessingLoop()
{
	// Loop until signaled to stop
	while( m_lStopSignal == 0 )
	{
		// Prepare set of readable sockets
		FD_SET ReadableFdSet;
		FD_ZERO( &ReadableFdSet );
		for( int iIP = 0; iIP < 2; ++iIP )
		{
			for( int iPort = 0; iPort < 2; ++iPort )
			{
				FD_SET( m_Socket[iIP][iPort], &ReadableFdSet );
			}
		}
		
		// wait for something to read
		TIMEVAL Wait = { kRecvTimeOut, 0 };
		int iNumReady = select( 0, &ReadableFdSet, NULL, NULL, &Wait );
		if( SOCKET_ERROR == iNumReady )
		{
			printf( "Select for readable socket failed! Error = %d\n", WSAGetLastError() );
			return( 1 );
		}
		else if( 0 == iNumReady )
		{
			continue;
		}

		// Handle incoming messages
		for( iIP = 0; iIP < 2; ++iIP )
		{
			for( int iPort = 0; iPort < 2; ++iPort )
			{
				if( FD_ISSET( m_Socket[iIP][iPort], &ReadableFdSet ) )
				{
					// Read the reaquest
					SRequestMsg  Req;
					CSockAddress SrcSockAddr;
					if( ! m_Socket[iIP][iPort].RecvMsgFrom( SrcSockAddr, reinterpret_cast<char*>( &Req ), 
						                                    sizeof(SRequestMsg) ) )
					{
						if( m_Verbose ) printf( "Ignoring bad receive\n" );
						continue;  // Don't need to fail here, client might have just gone away
					}

					// Send the reply
					if( Req.m_TID.IsNull() )
					{
						// Special case: second server info requested
						
						SReplyMsg Reply( Req.m_TID, 
							             m_RecvAddr[kFamiliar][kFamiliar].GetIp(),
										 m_RecvAddr[kFamiliar][kFamiliar].GetPort() );

						m_Socket[kSame][kSame]
							.SendTo( CSockAddress( SrcSockAddr.GetIp(), SrcSockAddr.GetPort() ),
										           reinterpret_cast<char*>( &Reply ), sizeof( SReplyMsg ) );
						
						if( m_Verbose ) printf( "Responded to info request.\n" );
					}
					else
					{
						// Ordinary request

						SReplyMsg Reply( Req.m_TID, SrcSockAddr.GetIp(), SrcSockAddr.GetPort() );

						// If requested reply to address is blank use the source.
						DWORD ReplyToIp   = Req.m_ReplyToIp   ? Req.m_ReplyToIp   : SrcSockAddr.GetIp();
						WORD  ReplyToPort = Req.m_ReplyToPort ? Req.m_ReplyToPort : SrcSockAddr.GetPort();
					
						m_Socket[ Req.m_ReplyFromIP ][ Req.m_ReplyFromPort ]
							.SendTo( CSockAddress( ReplyToIp, ReplyToPort ),
								     reinterpret_cast<char*>( &Reply ), sizeof( SReplyMsg ) );

						if( m_Verbose ) printf( "Responded to ordinary request.\n" );
					}
				}
			}
		}
	}
	return( 0 );
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\PackageCheck\objd\i386\_generated.cs ===
[assembly:System.Runtime.InteropServices.ComVisible(false)]
[assembly:System.Reflection.AssemblyVersion("12.4.56.0")]
[assembly:System.Reflection.AssemblyProduct("Microsoft(R) Xbox(TM)")]
[assembly:System.Reflection.AssemblyCopyright("Copyright (c) Microsoft Corporation. All rights reserved.")]
[assembly:System.Reflection.AssemblyCompany("Microsoft Corporation")]
[assembly:System.Reflection.AssemblyFileVersion("12.4.56.0")]
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\PackageCheck\obj\i386\_asmid.inc ===
ASSEMBLY_IDENTITY_KEY_FORM=msil_packagecheck_none_12.4.56.0_none_24bf7feab2ec57e5
ASSEMBLY_IDENTITY_XP_KEY_FORM=msil_packagecheck_no-public-key_12.4.56.0_x-ww_176e2e45
ASSEMBLY_IDENTITY_CULTURE=
ASSEMBLY_IDENTITY_NAME=packagecheck
ASSEMBLY_IDENTITY_PROCESSOR_ARCHITECTURE=msil
ASSEMBLY_IDENTITY_PUBLIC_KEY=
ASSEMBLY_IDENTITY_PUBLIC_KEY_TOKEN=
ASSEMBLY_IDENTITY_TYPE=
ASSEMBLY_IDENTITY_TYPE_NAME=
ASSEMBLY_IDENTITY_VERSION=12.4.56.0
XP_KEY_FORM=msil_packagecheck_no-public-key_12.4.56.0_x-ww_176e2e45
XP_MANIFEST_DIRECTORY=manifests
XP_MANIFEST_NAME=msil_packagecheck_no-public-key_12.4.56.0_x-ww_176e2e45.manifest
XP_MANIFEST_PATH=manifests\msil_packagecheck_no-public-key_12.4.56.0_x-ww_176e2e45.manifest
XP_CATALOG_DIRECTORY=manifests
XP_CATALOG_NAME=msil_packagecheck_no-public-key_12.4.56.0_x-ww_176e2e45.cat
XP_CATALOG_PATH=manifests\msil_packagecheck_no-public-key_12.4.56.0_x-ww_176e2e45.cat
XP_PAYLOAD_PATH=msil_packagecheck_no-public-key_12.4.56.0_x-ww_176e2e45
_DELAY_SIGN=0
!if [set _ASMIDTOATTRIBS_TLBIMP=]
!endif
CODESIGN_TESTKEY=
_TLBIMP_FLAGS=$(_TLBIMP_FLAGS)  /asmversion:12.4.56.0
_ASSEMBLY_IDENTITY=packagecheck,processorArchitecture=msil,version=12.4.56.0,publicKeyToken=neutral
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\nat\NatType\Server\Reflector.h ===
// Reflector.h : Define class that responds to requests

#ifndef __NATTYPE_REFLECTOR_H__
#define __NATTYPE_REFLECTOR_H__

///////////////////////////////////////
// Reflector
//
class CReflector
{
public:

	CReflector()
	: m_hThread( NULL ), m_lStopSignal(0), m_Verbose(false) {} 

	~CReflector()
	{ 
		if( NULL != m_hThread ) 
		{
			CloseHandle( m_hThread );
		}
	}

	bool Init( bool bVerbose );

	bool Start();
	int  Stop();
	bool IsActive();

	const char* GetBaseIpStr() const { return m_RecvAddr[kSame][kSame].GetIpStr(); }
	WORD        GetBasePort() const  { return m_RecvAddr[kSame][kSame].GetPort();  }

private:

	HANDLE m_hThread;
	long   m_lStopSignal;
	
	bool m_Verbose;
	
	CNonBlockingUDPSocket m_Socket[3][3];   // Sockets sent with
	CSockAddress          m_RecvAddr[2][2]; // Address of sockets recieved with

	bool ProcessingLoop();

	static DWORD WINAPI ThreadFunc( LPVOID pParams )
	{
		return( reinterpret_cast<CReflector*>( pParams )->ProcessingLoop() ? TRUE : FALSE );
	}
};

#endif // __NATTYPE_REFLECTOR_H__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\PackageCheck\objd\i386\_asmid.inc ===
ASSEMBLY_IDENTITY_KEY_FORM=msil_packagecheck_none_12.4.56.0_none_24bf7feab2ec57e5
ASSEMBLY_IDENTITY_XP_KEY_FORM=msil_packagecheck_no-public-key_12.4.56.0_x-ww_176e2e45
ASSEMBLY_IDENTITY_CULTURE=
ASSEMBLY_IDENTITY_NAME=packagecheck
ASSEMBLY_IDENTITY_PROCESSOR_ARCHITECTURE=msil
ASSEMBLY_IDENTITY_PUBLIC_KEY=
ASSEMBLY_IDENTITY_PUBLIC_KEY_TOKEN=
ASSEMBLY_IDENTITY_TYPE=
ASSEMBLY_IDENTITY_TYPE_NAME=
ASSEMBLY_IDENTITY_VERSION=12.4.56.0
XP_KEY_FORM=msil_packagecheck_no-public-key_12.4.56.0_x-ww_176e2e45
XP_MANIFEST_DIRECTORY=manifests
XP_MANIFEST_NAME=msil_packagecheck_no-public-key_12.4.56.0_x-ww_176e2e45.manifest
XP_MANIFEST_PATH=manifests\msil_packagecheck_no-public-key_12.4.56.0_x-ww_176e2e45.manifest
XP_CATALOG_DIRECTORY=manifests
XP_CATALOG_NAME=msil_packagecheck_no-public-key_12.4.56.0_x-ww_176e2e45.cat
XP_CATALOG_PATH=manifests\msil_packagecheck_no-public-key_12.4.56.0_x-ww_176e2e45.cat
XP_PAYLOAD_PATH=msil_packagecheck_no-public-key_12.4.56.0_x-ww_176e2e45
_DELAY_SIGN=0
!if [set _ASMIDTOATTRIBS_TLBIMP=]
!endif
CODESIGN_TESTKEY=
_TLBIMP_FLAGS=$(_TLBIMP_FLAGS)  /asmversion:12.4.56.0
_ASSEMBLY_IDENTITY=packagecheck,processorArchitecture=msil,version=12.4.56.0,publicKeyToken=neutral
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\PackageCheck\PackageCheck.cs ===
using System;
using System.Data.SqlClient;
using System.Drawing;
using System.Collections;
using System.Collections.Specialized;
using System.IO;
using System.Net;
using System.Runtime.InteropServices;
using System.Text;
using System.Text.RegularExpressions;
using System.Threading;
using System.Windows.Forms;
using System.Xml;


namespace PackageCheck
{
    /// <summary>
    /// Summary description for PackageCheck.
    /// </summary>
    public class PackageCheck : Form
    {
        enum ENUM_QUERY
        {
            all = 0x0,
            content = 0x100,
            xboxcontent,
            xbox360content,
            autoupdate = 0x200
        }

        private static NamedArgParser  argParser;

        private static ENUM_QUERY      queryType = ENUM_QUERY.all;



        public class NamedArgParser : StringDictionary
        {
            private static char[]  _delimsVariable = { '/', '-' };
            private static char[]  _delimsValue = { ':', '=' };

            public NamedArgParser(string[] args)
            {
                for (int iArg = 0; iArg < args.Length; iArg++)
                {
                    string  arg = args[iArg];
                    string  stringVariable = null;
                    string  stringValue = null;

                    int     iDelim;

                    // find the variable delimeter
                    for (iDelim = 0; iDelim < _delimsVariable.Length; iDelim++)
                    {
                        if (arg[0] == _delimsVariable[iDelim])
                        {
                            break;
                        }
                    }

                    if (_delimsVariable.Length == iDelim)
                    {
                        continue;
                    }

                    // remove the variable delimeter
                    stringVariable = arg.Substring(1);

                    // find the value delimeter
                    int  iDelimValue = 0;

                    for (iDelim = 0; iDelim < _delimsValue.Length; iDelim++)
                    {
                        iDelimValue = stringVariable.IndexOf(_delimsValue[iDelim]);

                        if (0 < iDelimValue)
                        {
                            break;
                        }
                    }

                    if (-1 == iDelimValue)
                    {
                        base.Add(stringVariable, "");
                    }
                    else if (1 < iDelimValue)
                    {
                        stringValue = stringVariable.Substring(iDelimValue + 1).ToLower();
                        stringVariable = stringVariable.Substring(0, iDelimValue).ToLower();

                        base.Add(stringVariable, stringValue);
                    }
                }
            }				
        }



        [DllImport("user32")]
        static extern int PostMessage(IntPtr hWnd, int msg, int wParam, int lParam);
        const int WM_CLICK = 0x00F5;



        public class ContentInfoXbox
        {
            public UInt32  TitleId;
            public UInt64  OfferId;
            public UInt32  PackageSize;
            public string  PackageName;
            public string  XRL;
            public string  xrlIP;
            public string  xrlRealIP;

            public ContentInfoXbox(
                UInt32  TitleId,
                UInt64  OfferId,
                UInt32  PackageSize,
                string  PackageName,
                string  XRL,
                string  xrlIP
                )
            {
                this.TitleId = TitleId;
                this.OfferId = OfferId;
                this.PackageSize = PackageSize;
                this.PackageName = PackageName;
                this.XRL = XRL;
                this.xrlIP = xrlIP;
            }

            public ContentInfoXbox(
                ContentInfoXbox  contentInfoXbox,
                string           xrlRealIP
                )
            {
                this.TitleId = contentInfoXbox.TitleId;
                this.OfferId = contentInfoXbox.OfferId;
                this.PackageSize = contentInfoXbox.PackageSize;
                this.PackageName = contentInfoXbox.PackageName;
                this.XRL = contentInfoXbox.XRL;
                this.xrlIP = contentInfoXbox.xrlIP;
                this.xrlRealIP = xrlRealIP;
            }
        }



        public class ContentInfoXbox360
        {
            public UInt32  TitleId;
            public UInt64  OfferId;
            public byte[]  ContentId;
            public UInt32  PackageSize;
            public string  PackageName;
            public string  XRL;
            public string  xrlIP;
            public string  xrlRealIP;

            public ContentInfoXbox360(
                UInt32  TitleId,
                UInt64  OfferId,
                byte[]  ContentId,
                UInt32  PackageSize,
                string  PackageName,
                string  XRL,
                string  xrlIP
                )
            {
                this.TitleId = TitleId;
                this.OfferId = OfferId;
                this.ContentId = ContentId;
                this.PackageSize = PackageSize;
                this.PackageName = PackageName;
                this.XRL = XRL;
                this.xrlIP = xrlIP;
            }

            public ContentInfoXbox360(
                ContentInfoXbox360  contentInfoXbox360,
                string              xrlRealIP
                )
            {
                this.TitleId = contentInfoXbox360.TitleId;
                this.OfferId = contentInfoXbox360.OfferId;
                this.ContentId = contentInfoXbox360.ContentId;
                this.PackageSize = contentInfoXbox360.PackageSize;
                this.PackageName = contentInfoXbox360.PackageName;
                this.XRL = contentInfoXbox360.XRL;
                this.xrlIP = contentInfoXbox360.xrlIP;
                this.xrlRealIP = xrlRealIP;
            }
        }



        public class AutoUpdateInfo
        {
            public UInt32  TitleId;
            public UInt32  BaseVersion;
            public UInt32  UpdateVersion;
            public UInt32  PackageSize;
            public string  PackageName;
            public string  XRL;
            public string  xrlIP;
            public string  xrlRealIP;

            public AutoUpdateInfo(
                UInt32  TitleId,
                UInt32  BaseVersion,
                UInt32  UpdateVersion,
                UInt32  PackageSize,
                string  PackageName,
                string  XRL,
                string  xrlIP
                )
            {
                this.TitleId = TitleId;
                this.BaseVersion = BaseVersion;
                this.UpdateVersion = UpdateVersion;
                this.PackageSize = PackageSize;
                this.PackageName = PackageName;
                this.XRL = XRL;
                this.xrlIP = xrlIP;
            }

            public AutoUpdateInfo(
                AutoUpdateInfo  autoUpdateInfo,
                string          xrlRealIP
                )
            {
                this.TitleId = autoUpdateInfo.TitleId;
                this.BaseVersion = autoUpdateInfo.BaseVersion;
                this.UpdateVersion = autoUpdateInfo.UpdateVersion;
                this.PackageSize = autoUpdateInfo.PackageSize;
                this.PackageName = autoUpdateInfo.PackageName;
                this.XRL = autoUpdateInfo.XRL;
                this.xrlIP = autoUpdateInfo.xrlIP;
                this.xrlRealIP = xrlRealIP;
            }
        }



        private static int  VALUE_SQL_TIMEOUT = 600;
        private static int  lockThread = 0;



        private abstract class GroupBase
        {
            public static Hashtable                hashtableServersAvailable = new Hashtable();
            public static Hashtable                hashtableServersSelected = new Hashtable();

            public static ArrayList                arrayListXrlIPs = new ArrayList();
            public static SortedList               sortedListXrlIPMap = new SortedList();

            public static ArrayList                arrayListContentInfoXboxRaw = new ArrayList();
            public static ArrayList                arrayListContentInfoXbox360Raw = new ArrayList();
            public static ArrayList                arrayListAutoUpdateInfoRaw = new ArrayList();

            public static ArrayList                arrayListContentInfoXboxReal = new ArrayList();
            public static ArrayList                arrayListContentInfoXbox360Real = new ArrayList();
            public static ArrayList                arrayListAutoUpdateInfoReal = new ArrayList();

            public static ListBox                  controlServer;
            public static ListBox                  controlDatabase;
            public static TreeView                 controlXrlIPMap;

            public static string                   stringFileName;
            public static OpenFileDialog           configOpenDialog;
            public static SaveFileDialog           configSaveDialog;
            public static bool                     fUnattend;

            private static TimeSpan                timeSpanIncrement;
            private static TimeSpan                timeSpanCurrent;
            private static TimeSpan                timeSpanTotal;
            private static System.Threading.Timer  timerTimeCurrent;
            private static System.Threading.Timer  timerTimeTotal;
            private static Label                   labelTimeCurrent;
            private static Label                   labelTimeTotal;



            public Form                            parentForm;
            public GroupBox                        groupBoxMain;
            public Button                          buttonBack;
            public Button                          buttonNext;
            public GroupBase                       groupBack;
            public GroupBase                       groupNext;
            public Control                         controlFocus;



            public GroupBase()
            {
                groupBoxMain = new GroupBox();
                groupBoxMain.SuspendLayout();

                if (null == GroupBase.labelTimeCurrent)
                {
                    //
                    // labelTimeCurrent
                    //
                    labelTimeCurrent = new Label();
                    labelTimeCurrent.Location = new Point(184, 556);
                    labelTimeCurrent.Size = new Size(204, 16);
                    labelTimeCurrent.TabIndex = 96;
                    labelTimeCurrent.Text = "";
                    labelTimeCurrent.TextAlign = ContentAlignment.MiddleRight;

                    groupBoxMain.Controls.Add(labelTimeCurrent);
                }

                if (null == GroupBase.labelTimeTotal)
                {
                    //
                    // labelTimeTotal
                    //
                    labelTimeTotal = new Label();
                    labelTimeTotal.Location = new Point(396, 556);
                    labelTimeTotal.Size = new Size(204, 16);
                    labelTimeTotal.TabIndex = 97;
                    labelTimeTotal.Text = "";
                    labelTimeTotal.TextAlign = ContentAlignment.MiddleLeft;

                    groupBoxMain.Controls.Add(labelTimeTotal);
                }

                buttonBack = new Button();
                buttonNext = new Button();

                //
                // groupBoxMain
                //
                groupBoxMain.Location = new Point(8, 8);
                groupBoxMain.Size = new Size(784, 584);
                groupBoxMain.TabIndex = 0;
                groupBoxMain.TabStop = false;
                //
                // buttonBack
                //
                buttonBack.Location = new Point(608, 552);
                buttonBack.Size = new Size(80, 24);
                buttonBack.TabIndex = 98;
                buttonBack.Text = "&Back";
                buttonBack.Click += new System.EventHandler(buttonBack_Click);
                //
                // buttonNext
                //
                buttonNext.Location = new Point(696, 552);
                buttonNext.Size = new Size(80, 24);
                buttonNext.TabIndex = 99;
                buttonNext.Text = "&Next";
                buttonNext.Click += new System.EventHandler(buttonNext_Click);

                if (null == GroupBase.configSaveDialog)
                {
                    GroupBase.configSaveDialog = new SaveFileDialog();
                    GroupBase.configSaveDialog.AddExtension = true;
                    GroupBase.configSaveDialog.DefaultExt = "xml";
                    GroupBase.configSaveDialog.Filter = "Config files (*.xml)|*.xml|All files (*.*)|*.*";
                    GroupBase.configSaveDialog.FilterIndex = 1;
                    GroupBase.configSaveDialog.InitialDirectory = Directory.GetCurrentDirectory();
                    GroupBase.configSaveDialog.RestoreDirectory = true;
                }

                if (null == GroupBase.configOpenDialog)
                {
                    GroupBase.configOpenDialog = new OpenFileDialog();
                    GroupBase.configOpenDialog.AddExtension = true;
                    GroupBase.configOpenDialog.DefaultExt = "xml";
                    GroupBase.configOpenDialog.Filter = "Config files (*.xml)|*.xml|All files (*.*)|*.*";
                    GroupBase.configOpenDialog.FilterIndex = 1;
                    GroupBase.configOpenDialog.InitialDirectory = Directory.GetCurrentDirectory();
                    GroupBase.configOpenDialog.RestoreDirectory = true;
                }

                if (null != argParser["unattend"])
                {
                    fUnattend = true;
                }

                if (null == GroupBase.timerTimeTotal)
                {
                    TimeStart();
                }
            }

            public virtual void GroupActivate()
            {
            }

            public virtual void GroupDeactivate()
            {
            }

            public void SetGroupBack(GroupBase groupBack)
            {
                this.groupBack = groupBack;

                if (null == this.groupBack)
                {
                    groupBoxMain.Controls.Remove(buttonBack);
                }
                else
                {
                    groupBoxMain.Controls.Add(buttonBack);
                }
            }

            public void SetGroupNext(GroupBase groupNext)
            {
                this.groupNext = groupNext;

                if (null == this.groupNext)
                {
                    groupBoxMain.Controls.Remove(buttonNext);
                }
                else
                {
                    groupBoxMain.Controls.Add(buttonNext);
                }
            }

            public static void TimeCurrentStart()
            {
                lock (typeof(GroupBase))
                {
                    timeSpanCurrent = TimeSpan.Zero;
                    timerTimeCurrent.Change(0, 1000);
                }
            }

            public static void TimeCurrentStop()
            {
                lock (typeof(GroupBase))
                {
                    timerTimeCurrent.Change(0, Timeout.Infinite);
                }
            }

            public static void TimeCurrentResume()
            {
                lock (typeof(GroupBase))
                {
                    timerTimeCurrent.Change(0, 1000);
                }
            }

            public static void TimeCurrentReset()
            {
                lock (typeof(GroupBase))
                {
                    timeSpanCurrent = TimeSpan.Zero;
                    timerTimeCurrent.Change(0, Timeout.Infinite);
                }
            }

            public static void TimeStart()
            {
                lock (typeof(GroupBase))
                {
                    timeSpanIncrement = new TimeSpan(0, 0, 1);
                    timeSpanTotal = TimeSpan.Zero;
                    timerTimeCurrent = new System.Threading.Timer(new TimerCallback(TimeCallback), labelTimeCurrent, 0, Timeout.Infinite);
                    timerTimeTotal = new System.Threading.Timer(new TimerCallback(TimeCallback), labelTimeTotal, 0, 1000);
                }
            }

            public static void TimeStop()
            {
                lock (typeof(GroupBase))
                {
                    timerTimeCurrent.Dispose();
                    timerTimeTotal.Dispose();
                }
            }

            private static void TimeCallback(object labelTime)
            {
                lock (typeof(GroupBase))
                {
                    Label  _labelTime = (Label) labelTime;

                    if (_labelTime == labelTimeCurrent)
                    {
                        _labelTime.Text = "Current Time: " + timeSpanCurrent.ToString();
                        timeSpanCurrent += timeSpanIncrement;
                    }
                    else
                    {
                        _labelTime.Text = "Total Time: " + timeSpanTotal.ToString();
                        timeSpanTotal += timeSpanIncrement;
                    }
                }
            }

            public void buttonBack_Click(object sender, EventArgs e)
            {
                TimeCurrentReset();

                GroupDeactivate();

                parentForm.Controls.Remove(groupBoxMain);

                groupBack.groupBoxMain.Controls.Add(labelTimeCurrent);
                groupBack.groupBoxMain.Controls.Add(labelTimeTotal);

                parentForm.Controls.Add(groupBack.groupBoxMain);

                groupBack.controlFocus.Focus();
            }

            public void buttonNext_Click(object sender, EventArgs e)
            {
                TimeCurrentReset();

                GroupDeactivate();

                parentForm.Controls.Remove(groupBoxMain);

                groupNext.groupBoxMain.Controls.Add(labelTimeCurrent);
                groupNext.groupBoxMain.Controls.Add(labelTimeTotal);

                parentForm.Controls.Add(groupNext.groupBoxMain);

                groupNext.controlFocus.Focus();

                if (null == groupNext.groupBack)
                {
                    GroupBase  groupBase = this;

                    while (null != groupBase)
                    {
                        ArrayList  arrayListControls = new ArrayList(groupBase.groupBoxMain.Controls);

                        foreach (Control control in arrayListControls)
                        {
                            control.Dispose();
                        }

                        arrayListControls.Clear();

                        groupBase.groupBoxMain.Dispose();

                        groupBase = groupBase.groupBack;
                    }
                }

                groupNext.GroupActivate();
            }
        }



        private class GroupUsage : GroupBase
        {
            private RichTextBox  richTextBox;

            public GroupUsage(
                Form  parentForm
                )
            {
                this.parentForm = parentForm;

                richTextBox = new RichTextBox();
                controlFocus = richTextBox;

                //
                // groupBoxMain
                //
                groupBoxMain.Controls.Add(richTextBox);
                groupBoxMain.Text = "Usage";
                //
                // richTextBox
                //
                richTextBox.Font = new Font("Courier New", richTextBox.Font.Size);
                richTextBox.Location = new Point(8, 24);
                richTextBox.ReadOnly = true;
                richTextBox.Size = new Size(768, 514);
                richTextBox.TabIndex = 1;
                richTextBox.WordWrap = false;

                richTextBox.AppendText("Command Line: " + Environment.CommandLine + "\n");
                richTextBox.AppendText("\n");
                richTextBox.AppendText("PackageCheck /FILE:<file> [/UNATTEND]\n");
                richTextBox.AppendText("\n");
                richTextBox.AppendText("    /FILE:\n");
                richTextBox.AppendText("        <file>             Optional Configuration File\n");
                richTextBox.AppendText("    /UNATTEND              Unattended\n");
                richTextBox.AppendText("\n");
                richTextBox.AppendText("PackageCheck /TYPE:<type> [/FILE:<file> [/UNATTEND]\n");
                richTextBox.AppendText("\n");
                richTextBox.AppendText("    /TYPE:\n");
                richTextBox.AppendText("        content            Xbox and Xbox 360 Content Packages\n");
                richTextBox.AppendText("        xboxcontent        Xbox Content Packages\n");
                richTextBox.AppendText("        xbox360content     Xbox 360 Content Packages\n");
                richTextBox.AppendText("        autoupdate         AutoUpdate Packages\n");
                richTextBox.AppendText("    /FILE:\n");
                richTextBox.AppendText("        <file>             Optional Configuration File\n");
                richTextBox.AppendText("    /UNATTEND              Unattended\n");
                richTextBox.AppendText("\n");
                richTextBox.AppendText("PackageCheck /TYPE:<content type> [/TITLEID:<titleid>] [/OFFERID:<offerid>] [/FILE:<file> [/UNATTEND]]\n");
                richTextBox.AppendText("\n");
                richTextBox.AppendText("    /TYPE:\n");
                richTextBox.AppendText("        content            Xbox and Xbox 360 Content Packages\n");
                richTextBox.AppendText("        xboxcontent        Xbox Content Packages\n");
                richTextBox.AppendText("        xbox360content     Xbox 360 Content Packages\n");
                richTextBox.AppendText("    /TITLEID:\n");
                richTextBox.AppendText("        <titleid>          Optional Title Id (0x00000000 Format)\n");
                richTextBox.AppendText("    /OFFERID:\n");
                richTextBox.AppendText("        <offerid>          Optional Offer Id (0x0000000000000000 Format)\n");
                richTextBox.AppendText("    /FILE:\n");
                richTextBox.AppendText("        <file>             Optional Configuration File\n");
                richTextBox.AppendText("    /UNATTEND              Unattended\n");
                richTextBox.AppendText("\n");
                richTextBox.AppendText("PackageCheck /TYPE:<autoupdate type> /TITLEID:titleid [/BASEVERSION:baseversion] [/UPDATEVERSION:updateversion] [/FILE:<file> [/UNATTEND]]\n");
                richTextBox.AppendText("\n");
                richTextBox.AppendText("    /TYPE:\n");
                richTextBox.AppendText("        autoupdate         AutoUpdate Packages\n");
                richTextBox.AppendText("    /TITLEID:\n");
                richTextBox.AppendText("        <titleid>          Title Id (0x00000000 Format)\n");
                richTextBox.AppendText("    /BASEVERSION:\n");
                richTextBox.AppendText("        <baseversion>      Optional Base Version (0x Format)\n");
                richTextBox.AppendText("    /UPDATEVERSION:\n");
                richTextBox.AppendText("        <updateversion>    Optional Update Version (0x Format)\n");
                richTextBox.AppendText("    /FILE:\n");
                richTextBox.AppendText("        <file>             Optional Configuration File\n");
                richTextBox.AppendText("    /UNATTEND              Unattended\n");
                richTextBox.AppendText("\n");

                richTextBox.SelectionStart = 0;
                richTextBox.SelectionLength = 0;

                groupBoxMain.ResumeLayout(false);
            }
        }



        private class GroupWelcome : GroupBase
        {
            private Label   labelText;
            private Button  buttonOpen;

            public GroupWelcome(
                Form  parentForm
                )
            {
                this.parentForm = parentForm;

                labelText = new Label();
                buttonOpen = new Button();
                controlFocus = buttonOpen;

                //
                // groupBoxMain
                //
                groupBoxMain.Controls.Add(labelText);
                groupBoxMain.Controls.Add(buttonOpen);
                groupBoxMain.Text = "Welcome";
                //
                // labelText
                //
                labelText.Location = new Point(8, 26);
                labelText.Size = new Size(768, 514);
                labelText.TabIndex = 1;
                labelText.Text = "Welcome to PackageCheck: the Content and AutoUpdate Package verification tool.\n\nThis tool will verify the Content and AutoUpdate packages specified in UODB are available from the Download Servers.";
                labelText.TextAlign = ContentAlignment.TopLeft;
                //
                // buttonOpen
                //
                buttonOpen.Location = new Point(8, 552);
                buttonOpen.Size = new Size(80, 24);
                buttonOpen.TabIndex = 2;
                buttonOpen.Text = "&Open";
                buttonOpen.Click += new EventHandler(buttonOpen_Click);

                groupBoxMain.ResumeLayout(false);
            }

            public override void GroupActivate()
            {
                if (null != argParser["file"])
                {
                    configOpenDialog.FileName = argParser["file"];
                    stringFileName = configOpenDialog.FileName;

                    argParser.Remove("file");
                    PostMessage(buttonNext.Handle, WM_CLICK, 0, 0);
                }
            }

            private void buttonOpen_Click(object sender, EventArgs e)
            {
                configOpenDialog.InitialDirectory = configSaveDialog.InitialDirectory;

                if (DialogResult.OK != configOpenDialog.ShowDialog())
                {
                    stringFileName = null;

                    return;
                }

                stringFileName = configOpenDialog.FileName;

                buttonNext_Click(null, null);
            }
        }



        private class GroupServerName : GroupBase
        {
            private TextBox  textBoxServerName;
            private Button   buttonAdd;
            private Button   buttonRemove;
            private ListBox  listBoxServerName;
            private Label    labelStatus;

            public GroupServerName(
                Form  parentForm
                )
            {
                this.parentForm = parentForm;

                textBoxServerName = new TextBox();
                buttonAdd = new Button();
                buttonRemove = new Button();
                listBoxServerName = new ListBox();
                labelStatus = new Label();
                controlFocus = textBoxServerName;
                controlServer = listBoxServerName;

                //
                // groupBoxMain
                //
                groupBoxMain.Controls.Add(textBoxServerName);
                groupBoxMain.Controls.Add(buttonAdd);
                groupBoxMain.Controls.Add(buttonRemove);
                groupBoxMain.Controls.Add(listBoxServerName);
                groupBoxMain.Controls.Add(labelStatus);
                groupBoxMain.Text = "Specify UODB Servers";
                //
                // textBoxServerName
                //
                textBoxServerName.Location = new Point(8, 26);
                textBoxServerName.Size = new Size(336, 20);
                textBoxServerName.TabIndex = 1;
                textBoxServerName.Text = "";
                //
                // buttonAdd
                //
                buttonAdd.Location = new Point(352, 24);
                buttonAdd.Size = new Size(80, 24);
                buttonAdd.TabIndex = 2;
                buttonAdd.Text = "&Add";
                buttonAdd.Click += new System.EventHandler(buttonAdd_Click);
                //
                // buttonRemove
                //
                buttonRemove.Location = new Point(352, 56);
                buttonRemove.Size = new Size(80, 24);
                buttonRemove.TabIndex = 3;
                buttonRemove.Text = "&Remove";
                buttonRemove.Click += new System.EventHandler(buttonRemove_Click);
                //
                // listBoxServerName
                //
                listBoxServerName.HorizontalScrollbar = true;
                listBoxServerName.Location = new Point(440, 24);
                listBoxServerName.SelectionMode = SelectionMode.MultiExtended;
                listBoxServerName.Size = new Size(336, 514);
                listBoxServerName.Sorted = true;
                listBoxServerName.TabIndex = 4;
                listBoxServerName.DoubleClick += new System.EventHandler(buttonRemove_Click);
                //
                // labelStatus
                //
                labelStatus.Location = new Point(8, 56);
                labelStatus.Size = new Size(336, 482);
                labelStatus.TabIndex = 5;
                labelStatus.Text = "";

                groupBoxMain.ResumeLayout(false);
            }

            public override void GroupActivate()
            {
                labelStatus.Text = "";

                if (null != stringFileName)
                {
                    Thread  threadOpen = new Thread(new ThreadStart(ThreadOpen));
                    threadOpen.Start();
                    stringFileName = null;
                }
            }

            private void ThreadAdd()
            {
                Interlocked.Increment(ref lockThread);

                parentForm.Cursor = Cursors.WaitCursor;

                textBoxServerName.Enabled = false;
                textBoxServerName.ReadOnly = true;
                buttonAdd.Enabled = false;
                buttonRemove.Enabled = false;
                listBoxServerName.Enabled = false;
                buttonBack.Enabled = false;
                buttonNext.Enabled = false;

                string  serverName = ResolveServerName(textBoxServerName.Text);

                if (null == serverName)
                {
                    labelStatus.Text = "'" + textBoxServerName.Text + "' cannot be resolved to a valid server name.";
                    textBoxServerName.Text = "";
                    parentForm.Cursor = Cursors.Default;

                    goto ThreadCleanup;
                }

                if (true == listBoxServerName.Items.Contains(serverName))
                {
                    labelStatus.Text = "'" + textBoxServerName.Text + "' was resolved to '" + serverName + "'.";
                    textBoxServerName.Text = "";
                    parentForm.Cursor = Cursors.Default;

                    goto ThreadCleanup;
                }

                if (false == ConnectServer(serverName))
                {
                    textBoxServerName.Text = "";
                    parentForm.Cursor = Cursors.Default;

                    goto ThreadCleanup;
                }

                labelStatus.Text = "'" + textBoxServerName.Text + "' was resolved to '" + serverName + "'.";
                textBoxServerName.Text = "";
                listBoxServerName.Items.Add(serverName);

ThreadCleanup:
                textBoxServerName.Enabled = true;
                textBoxServerName.ReadOnly = false;
                buttonAdd.Enabled = true;
                buttonRemove.Enabled = true;
                listBoxServerName.Enabled = true;
                buttonBack.Enabled = true;
                buttonNext.Enabled = true;

                parentForm.Cursor = Cursors.Default;

                Interlocked.Decrement(ref lockThread);
            }

            private void ThreadOpen()
            {
                Interlocked.Increment(ref lockThread);

                TimeCurrentStart();

                parentForm.Cursor = Cursors.WaitCursor;

                textBoxServerName.Enabled = false;
                textBoxServerName.ReadOnly = true;
                buttonAdd.Enabled = false;
                buttonRemove.Enabled = false;
                listBoxServerName.Enabled = false;
                buttonBack.Enabled = false;
                buttonNext.Enabled = false;

                foreach (string serverName in hashtableServersAvailable.Keys)
                {
                    ArrayList  arrayListDatabases = (ArrayList) hashtableServersAvailable[serverName];

                    arrayListDatabases.Clear();
                }

                hashtableServersAvailable.Clear();

                foreach (string serverName in hashtableServersSelected.Keys)
                {
                    ArrayList  arrayListDatabases = (ArrayList) hashtableServersSelected[serverName];

                    arrayListDatabases.Clear();
                }

                hashtableServersSelected.Clear();

                labelStatus.Text = "Loading...";

                Stream       xmlStream;
                XmlDocument  xmlDocument;

                try
                {
                    xmlStream = configOpenDialog.OpenFile();
                    xmlDocument = new XmlDocument();
                    xmlDocument.Load(xmlStream);
                }
                catch (Exception e)
                {
                    labelStatus.Text = "Cannot Open File: " + e.Message;
                    fUnattend = false;
                    goto ThreadCleanup;
                }

                // get the servers
                controlServer.Items.Clear();

                XmlNodeList  nodeListServers = xmlDocument.SelectNodes("/PackageCheck/Servers/Server");

                foreach (XmlNode nodeServerName in nodeListServers)
                {
                    string  serverName = ResolveServerName(nodeServerName.Attributes.GetNamedItem("Name").Value);

                    if (null == serverName)
                    {
                        continue;
                    }

                    if (false == ConnectServer(serverName))
                    {
                        continue;
                    }

                    controlServer.Items.Add(serverName);
                }

                // get the databases
                controlDatabase.Items.Clear();

                XmlNodeList  nodeListDatabases = xmlDocument.SelectNodes("/PackageCheck/Databases/Database");

                foreach (XmlNode nodeDatabaseName in nodeListDatabases)
                {
                    string  databaseName = nodeDatabaseName.Attributes.GetNamedItem("Name").Value;

                    controlDatabase.Items.Add(databaseName);
                }

                // get the xrl ip map
                XmlNodeList  nodeListXrlIPMap = xmlDocument.SelectNodes("/PackageCheck/XrlIPMapping/XrlIPMap");

                foreach (XmlNode nodeXrlIPMap in nodeListXrlIPMap)
                {
                    string       xrlIP = nodeXrlIPMap.Attributes.GetNamedItem("XrlIP").Value;
                    TreeNode     parentNode = new TreeNode(xrlIP);

                    XmlNodeList  nodeListXrlRealIP = nodeXrlIPMap.SelectNodes("XrlRealIP");

                    foreach (XmlNode nodeXrlRealIP in nodeListXrlRealIP)
                    {
                        string    xrlRealIP = nodeXrlRealIP.InnerText;
                        TreeNode  childNode = new TreeNode(xrlRealIP);

                        parentNode.Nodes.Add(childNode);
                    }

                    controlXrlIPMap.Nodes.Add(parentNode);
                }

                xmlStream.Close();

                labelStatus.Text = "Done";

ThreadCleanup:
                textBoxServerName.Enabled = true;
                textBoxServerName.ReadOnly = false;
                buttonAdd.Enabled = true;
                buttonRemove.Enabled = true;
                listBoxServerName.Enabled = true;
                buttonBack.Enabled = true;
                buttonNext.Enabled = true;

                parentForm.Cursor = Cursors.Default;

                TimeCurrentStop();

                Interlocked.Decrement(ref lockThread);

                if (true == fUnattend)
                {
                    PostMessage(buttonNext.Handle, WM_CLICK, 0, 0);
                }
            }

            private string ResolveServerName(string serverName)
            {
                IPAddress  serverIP = null;
                string     serverResolved = null;

                labelStatus.Text = "Resolving '" + serverName + "'...";
                // Updated for 2.0 # JK 6/22/06
                // GetHostEntry takes IP or servername as a string and resolves it
/*                // try the server name first as a name then as an ip
                if (true == Regex.IsMatch(serverName, "\\A[a-zA-Z0-9-.]+\\z"))
                {
                    try
                    {
                        // convert to an ip
                        //IPHostEntry  hostInfo = Dns.GetHostByName(serverName);
                        serverIP = hostInfo.AddressList[0];
                    }
                    catch
                    {
                    }
                }
                else
                {
                    try
                    {
                        // convert to an ip
                        IPAddress    ipAddress = IPAddress.Parse(serverName);
                        IPHostEntry  hostInfo = Dns.GetHostByAddress(ipAddress);
                        serverIP = hostInfo.AddressList[0];
                    }
                    catch
                    {
                    }
                }
*/
                try
                {
                    IPHostEntry hostInfo = Dns.GetHostEntry(serverName);
                    serverIP = hostInfo.AddressList[0];
                }
                catch
                {
                }
                if ((null == serverIP) || ("0.0.0.0" == serverIP.ToString()))
                {
                    return null;
                }

                // convert back to name
                try
                {
                    // Updated for 2.0 # JK 6/22/06
                    //IPHostEntry  hostInfo = Dns.GetHostByAddress(serverIP);
                    IPHostEntry hostInfo = Dns.GetHostEntry(serverIP);
                    serverResolved = hostInfo.HostName.ToUpper();

                    if ("LOCALHOST" == serverResolved)
                    {
                        serverResolved = SystemInformation.ComputerName;
                    }
                }
                catch
                {
                    return null;
                }

                return serverResolved;
            }

            private bool ConnectServer(string serverName)
            {
                labelStatus.Text = "Querying " + serverName + "...";

                TimeCurrentStart();

                try
                {
                    ArrayList  arrayListDatabases = new ArrayList();

                    // connect to server and get databases
                    using (SqlConnection  sqlConnectionDatabase = new SqlConnection("Data Source=" + serverName + ";Initial Catalog=master;Integrated Security=SSPI"))
                    {
                        sqlConnectionDatabase.Open();

                        SqlCommand     sqlCommandDatabase = sqlConnectionDatabase.CreateCommand();
                        sqlCommandDatabase.CommandTimeout = VALUE_SQL_TIMEOUT;
                        sqlCommandDatabase.CommandText = "SELECT CATALOG_NAME FROM INFORMATION_SCHEMA.SCHEMATA";
                        SqlDataReader  sqlDataReaderDatabase = sqlCommandDatabase.ExecuteReader();

                        while (true == sqlDataReaderDatabase.Read())
                        {
                            string  databaseName = sqlDataReaderDatabase["CATALOG_NAME"].ToString().ToUpper();

                            using (SqlConnection sqlConnectionTable = new SqlConnection("Data Source=" + serverName + ";Initial Catalog=" + databaseName + ";Integrated Security=SSPI"))
                            {
                                sqlConnectionTable.Open();

                                SqlCommand     sqlCommandTable = sqlConnectionTable.CreateCommand();
                                sqlCommandTable.CommandTimeout = VALUE_SQL_TIMEOUT;
                                sqlCommandTable.CommandText = "SELECT TABLE_NAME FROM INFORMATION_SCHEMA.TABLES WHERE TABLE_TYPE='BASE TABLE' "
                                    + "AND TABLE_NAME='t_title_offers' "
                                    + "OR TABLE_NAME='t_offers' "
                                    + "OR TABLE_NAME='t_offer_locations' "
                                    + "OR TABLE_NAME='t_offer_content_details' "
                                    + "OR TABLE_NAME='t_content' "
                                    + "OR TABLE_NAME='t_content_locations' "
                                    + "OR TABLE_NAME='t_title_update_packages' "
                                    + "OR TABLE_NAME='t_title_update_locations'";
                                SqlDataReader  sqlDataReaderTable = sqlCommandTable.ExecuteReader();
                                int            iTableCount = 0;

                                while (true == sqlDataReaderTable.Read())
                                {
                                    iTableCount++;
                                }

                                if (8 == iTableCount)
                                {
                                    arrayListDatabases.Add(databaseName);
                                }
                            }
                        }
                    }

                    hashtableServersAvailable[serverName] = arrayListDatabases;

                    return true;
                }
                catch (Exception e)
                {
                    labelStatus.Text = "Cannot connect '" + serverName + "': " + e.Message;

                    return false;
                }
                finally
                {
                    TimeCurrentStop();
                }
            }

            private void buttonAdd_Click(object sender, EventArgs e)
            {
                Thread  threadAdd = new Thread(new ThreadStart(ThreadAdd));
                threadAdd.Start();
            }

            private void buttonRemove_Click(object sender, EventArgs e)
            {
                labelStatus.Text = "";

                // remove all selected server names from the list
                while (null != listBoxServerName.SelectedItem)
                {
                    ArrayList  arrayListDatabases;

                    arrayListDatabases = (ArrayList) hashtableServersAvailable[listBoxServerName.SelectedItem];
                    arrayListDatabases.Clear();

                    hashtableServersAvailable.Remove(listBoxServerName.SelectedItem);

                    listBoxServerName.Items.Remove(listBoxServerName.SelectedItem);
                }
            }
        }



        private class GroupDatabaseName : GroupBase
        {
            private ListBox  listBoxAvailable;
            private Button   buttonAdd;
            private Button   buttonRemove;
            private ListBox  listBoxSelected;

            public GroupDatabaseName(
                Form  parentForm
                )
            {
                this.parentForm = parentForm;

                listBoxAvailable = new ListBox();
                buttonAdd = new Button();
                buttonRemove = new Button();
                listBoxSelected = new ListBox();
                controlFocus = listBoxAvailable;
                controlDatabase = listBoxSelected;

                //
                // groupBoxMain
                //
                groupBoxMain.Controls.Add(listBoxAvailable);
                groupBoxMain.Controls.Add(buttonAdd);
                groupBoxMain.Controls.Add(buttonRemove);
                groupBoxMain.Controls.Add(listBoxSelected);
                groupBoxMain.Text = "Specify UODB Databases";
                //
                // listBoxAvailable
                //
                listBoxAvailable.HorizontalScrollbar = true;
                listBoxAvailable.Location = new Point(8, 24);
                listBoxAvailable.SelectionMode = SelectionMode.MultiExtended;
                listBoxAvailable.Size = new Size(336, 520);
                listBoxAvailable.Sorted = true;
                listBoxAvailable.TabIndex = 1;
                listBoxAvailable.DoubleClick += new System.EventHandler(buttonAdd_Click);
                //
                // buttonAdd
                //
                buttonAdd.Location = new Point(352, 24);
                buttonAdd.Size = new Size(80, 24);
                buttonAdd.TabIndex = 2;
                buttonAdd.Text = "&Add";
                buttonAdd.Click += new System.EventHandler(buttonAdd_Click);
                //
                // buttonRemove
                //
                buttonRemove.Location = new Point(352, 56);
                buttonRemove.Size = new Size(80, 24);
                buttonRemove.TabIndex = 3;
                buttonRemove.Text = "&Remove";
                buttonRemove.Click += new System.EventHandler(buttonRemove_Click);
                //
                // listBoxSelected
                //
                listBoxSelected.HorizontalScrollbar = true;
                listBoxSelected.Location = new Point(440, 24);
                listBoxSelected.SelectionMode = SelectionMode.MultiExtended;
                listBoxSelected.Size = new Size(336, 520);
                listBoxSelected.Sorted = true;
                listBoxSelected.TabIndex = 4;
                listBoxSelected.DoubleClick += new System.EventHandler(buttonRemove_Click);

                groupBoxMain.ResumeLayout(false);
            }

            public override void GroupActivate()
            {
                ArrayList  arrayListDatabases = new ArrayList();

                foreach (string serverName in hashtableServersAvailable.Keys)
                {
                    foreach (string databaseName in (ArrayList) hashtableServersAvailable[serverName])
                    {
                        if (false == arrayListDatabases.Contains(databaseName))
                        {
                            arrayListDatabases.Add(databaseName);
                        }
                    }
                }

                ArrayList  arrayListDatabasesAvailable = new ArrayList(listBoxAvailable.Items);
                ArrayList  arrayListDatabasesSelected = new ArrayList(listBoxSelected.Items);

                foreach (string databaseName in arrayListDatabasesAvailable)
                {
                    if (false == arrayListDatabases.Contains(databaseName))
                    {
                        listBoxAvailable.Items.Remove(databaseName);
                    }

                    if (true == arrayListDatabasesSelected.Contains(databaseName))
                    {
                        listBoxAvailable.Items.Remove(databaseName);
                    }
                }

                foreach (string databaseName in arrayListDatabasesSelected)
                {
                    if (false == arrayListDatabases.Contains(databaseName))
                    {
                        listBoxSelected.Items.Remove(databaseName);
                    }
                }

                arrayListDatabasesAvailable.Clear();
                arrayListDatabasesSelected.Clear();

                arrayListDatabasesAvailable = new ArrayList(listBoxAvailable.Items);
                arrayListDatabasesSelected = new ArrayList(listBoxSelected.Items);

                foreach (string databaseName in arrayListDatabases)
                {
                    if (true == arrayListDatabasesAvailable.Contains(databaseName))
                    {
                        continue;
                    }

                    if (true == arrayListDatabasesSelected.Contains(databaseName))
                    {
                        continue;
                    }

                    listBoxAvailable.Items.Add(databaseName);
                }

                arrayListDatabasesAvailable.Clear();
                arrayListDatabasesSelected.Clear();

                arrayListDatabases.Clear();

                if (true == fUnattend)
                {
                    PostMessage(buttonNext.Handle, WM_CLICK, 0, 0);
                }
            }

            public override void GroupDeactivate()
            {
                ArrayList  arrayListServers = new ArrayList(hashtableServersSelected.Keys);

                foreach (string serverName in arrayListServers)
                {
                    ArrayList  arrayListDatabases = (ArrayList) hashtableServersSelected[serverName];

                    arrayListDatabases.Clear();
                }

                hashtableServersSelected.Clear();



                foreach (string serverName in hashtableServersAvailable.Keys)
                {
                    ArrayList  arrayListDatabasesAvailable = (ArrayList) hashtableServersAvailable[serverName];
                    ArrayList  arrayListDatabasesSelected = new ArrayList();

                    foreach (string databaseName in arrayListDatabasesAvailable)
                    {
                        if (false == listBoxSelected.Items.Contains(databaseName))
                        {
                            continue;
                        }

                        arrayListDatabasesSelected.Add(databaseName);
                    }

                    if (0 < arrayListDatabasesSelected.Count)
                    {
                        hashtableServersSelected[serverName] = arrayListDatabasesSelected;
                    }
                }
            }

            private void buttonAdd_Click(object sender, EventArgs e)
            {
                while (null != listBoxAvailable.SelectedItem)
                {
                    listBoxSelected.Items.Add(listBoxAvailable.SelectedItem);
                    listBoxAvailable.Items.Remove(listBoxAvailable.SelectedItem);
                }
            }

            private void buttonRemove_Click(object sender, EventArgs e)
            {
                while (null != listBoxSelected.SelectedItem)
                {
                    listBoxAvailable.Items.Add(listBoxSelected.SelectedItem);
                    listBoxSelected.Items.Remove(listBoxSelected.SelectedItem);
                }
            }
        }



        private class GroupQuery : GroupBase
        {
            private RichTextBox  richTextBox;

            public GroupQuery(
                Form  parentForm
                )
            {
                this.parentForm = parentForm;

                richTextBox = new RichTextBox();
                controlFocus = richTextBox;

                //
                // groupBoxMain
                //
                groupBoxMain.Controls.Add(richTextBox);
                groupBoxMain.Text = "Querying Data";
                //
                // richTextBox
                //
                richTextBox.Font = new Font("Courier New", richTextBox.Font.Size);
                richTextBox.Location = new Point(8, 24);
                richTextBox.ReadOnly = true;
                richTextBox.Size = new Size(768, 514);
                richTextBox.TabIndex = 1;
                richTextBox.WordWrap = false;

                groupBoxMain.ResumeLayout(false);
            }

            public override void GroupActivate()
            {
                Thread  threadQueryData = new Thread(new ThreadStart(ThreadQueryData));
                threadQueryData.Start();
            }

            private void ThreadQueryData()
            {
                Interlocked.Increment(ref lockThread);

                parentForm.Cursor = Cursors.WaitCursor;

                buttonBack.Enabled = false;
                buttonNext.Enabled = false;

                TimeCurrentStart();

                richTextBox.Clear();

                arrayListXrlIPs.Clear();

                arrayListContentInfoXboxRaw.Clear();
                arrayListContentInfoXbox360Raw.Clear();
                arrayListAutoUpdateInfoRaw.Clear();



                try
                {
                    if ((ENUM_QUERY.all == queryType) || (ENUM_QUERY.content == queryType) || (ENUM_QUERY.xboxcontent == queryType))
                    {
                        richTextBox.AppendText("Querying Xbox Content Packages...\n");

                        foreach (string serverName in hashtableServersSelected.Keys)
                        {
                            ArrayList  arrayListDatabases = (ArrayList) hashtableServersSelected[serverName];

                            foreach (string databaseName in arrayListDatabases)
                            {
                                using (SqlConnection sqlConnection = new SqlConnection("Data Source=" + serverName + ";Initial Catalog=" + databaseName + ";Integrated Security=SSPI"))
                                {
                                    sqlConnection.Open();

                                    SqlCommand     sqlCommand = sqlConnection.CreateCommand();
                                    sqlCommand.CommandTimeout = VALUE_SQL_TIMEOUT;

                                    StringBuilder  sqlCommandText = new StringBuilder();
                                    StringBuilder  sqlWhere = null;

                                    sqlCommandText.Append("SELECT TTO.i_title_id, TTO.bi_offer_id, TOs.i_package_size, TOL.vc_XRL FROM t_title_offers AS TTO  "
                                        + "INNER JOIN t_offers AS TOs "
                                        + "ON TTO.bi_offer_id = TOs.bi_offer_id "
                                        + "INNER JOIN t_offer_locations AS TOL "
                                        + "ON TTO.bi_offer_id = TOL.bi_offer_id  ");

                                    if (null != argParser["titleid"])
                                    {
                                        sqlWhere = new StringBuilder();
                                        sqlWhere.Append("WHERE TTO.i_title_id = " + argParser["titleid"] + " ");
                                    }

                                    if (null != argParser["offerid"])
                                    {
                                        if (null == sqlWhere)
                                        {
                                            sqlWhere = new StringBuilder();
                                            sqlWhere.Append("WHERE TTO.bi_offer_id = " + argParser["offerid"] + " ");
                                        }
                                        else
                                        {
                                            sqlWhere.Append("AND TTO.bi_offer_id = " + argParser["offerid"] + " ");
                                        }
                                    }

                                    if (null != sqlWhere)
                                    {
                                        sqlCommandText.Append(sqlWhere.ToString());
                                    }

                                    sqlCommandText.Append("ORDER BY TTO.i_title_id, TTO.bi_offer_id, TOL.i_location_rank");

                                    sqlCommand.CommandText = sqlCommandText.ToString();

                                    SqlDataReader  sqlDataReader = sqlCommand.ExecuteReader();

                                    while (true == sqlDataReader.Read())
                                    {
                                        UInt32  TitleId;
                                        UInt64  OfferId;
                                        UInt32  PackageSize;
                                        string  XRL;

                                        TitleId = (UInt32) sqlDataReader.GetInt32(0);
                                        OfferId = (UInt64) sqlDataReader.GetInt64(1);
                                        PackageSize = (UInt32) sqlDataReader.GetInt32(2);
                                        XRL = sqlDataReader.GetString(3);

                                        string  PackageName = null;
                                        string  xrlIP = null;

                                        ParseXRLwoHTTP(XRL, TitleId, ref PackageName, ref xrlIP);

                                        if (null == xrlIP)
                                        {
                                            ParseXRLwHTTP(XRL, TitleId, ref PackageName, ref xrlIP);
                                        }

                                        if (null == xrlIP)
                                        {
                                            richTextBox.AppendText("\tTitleId: " + TitleId.ToString("x") + "\n");
                                            richTextBox.AppendText("\tOfferId: " + OfferId.ToString("x") + "\n");
                                            richTextBox.AppendText("\tXRL: " + XRL + "\n");

                                            richTextBox.SelectionColor = Color.Red;
                                            richTextBox.AppendText("\tXRL is not in expected format\n\n");
                                        }
                                        else
                                        {
                                            if (false == arrayListXrlIPs.Contains(xrlIP))
                                            {
                                                arrayListXrlIPs.Add(xrlIP);
                                            }

                                            arrayListContentInfoXboxRaw.Add(new ContentInfoXbox(TitleId, OfferId, PackageSize, PackageName, XRL, xrlIP));
                                        }
                                    }
                                }
                            }
                        }

                        richTextBox.AppendText("\n");
                    }



                    if ((ENUM_QUERY.all == queryType) || (ENUM_QUERY.content == queryType) || (ENUM_QUERY.xbox360content == queryType))
                    {
                        richTextBox.AppendText("Querying Xbox 360 Content Packages...\n");

                        foreach (string serverName in hashtableServersSelected.Keys)
                        {
                            ArrayList  arrayListDatabases = (ArrayList) hashtableServersSelected[serverName];

                            foreach (string databaseName in arrayListDatabases)
                            {
                                using (SqlConnection sqlConnection = new SqlConnection("Data Source=" + serverName + ";Initial Catalog=" + databaseName + ";Integrated Security=SSPI"))
                                {
                                    sqlConnection.Open();

                                    SqlCommand     sqlCommand = sqlConnection.CreateCommand();
                                    sqlCommand.CommandTimeout = VALUE_SQL_TIMEOUT;

                                    StringBuilder  sqlCommandText = new StringBuilder();
                                    StringBuilder  sqlWhere = null;

                                    sqlCommandText.Append("SELECT TTO.i_title_id, TTO.bi_offer_id, TOCD.b_content_id, TC.i_package_size, TCL.vc_XRL FROM t_title_offers AS TTO "
                                        + "INNER JOIN t_offer_content_details AS TOCD "
                                        + "ON TTO.bi_offer_id = TOCD.bi_offer_id "
                                        + "INNER JOIN t_content AS TC "
                                        + "ON TOCD.b_content_id = TC.b_content_id "
                                        + "INNER JOIN t_content_locations AS TCL "
                                        + "ON TOCD.b_content_id = TCL.b_content_id ");

                                    if (null != argParser["titleid"])
                                    {
                                        sqlWhere = new StringBuilder();
                                        sqlWhere.Append("WHERE TTO.i_title_id = " + argParser["titleid"] + " ");
                                    }

                                    if (null != argParser["offerid"])
                                    {
                                        if (null == sqlWhere)
                                        {
                                            sqlWhere = new StringBuilder();
                                            sqlWhere.Append("WHERE TTO.bi_offer_id = " + argParser["offerid"] + " ");
                                        }
                                        else
                                        {
                                            sqlWhere.Append("AND TTO.bi_offer_id = " + argParser["offerid"] + " ");
                                        }
                                    }

                                    if (null != sqlWhere)
                                    {
                                        sqlCommandText.Append(sqlWhere.ToString());
                                    }

                                    sqlCommandText.Append("ORDER BY TTO.i_title_id, TTO.bi_offer_id, TOCD.b_content_id, TCL.i_location_rank");

                                    sqlCommand.CommandText = sqlCommandText.ToString();

                                    SqlDataReader  sqlDataReader = sqlCommand.ExecuteReader();

                                    while (true == sqlDataReader.Read())
                                    {
                                        UInt32  TitleId;
                                        UInt64  OfferId;
                                        byte[]  ContentId;
                                        UInt32  PackageSize;
                                        string  XRL;

                                        TitleId = (UInt32) sqlDataReader.GetInt32(0);
                                        OfferId = (UInt64) sqlDataReader.GetInt64(1);
                                        ContentId = (byte[]) sqlDataReader.GetSqlBinary(2);
                                        PackageSize = (UInt32) sqlDataReader.GetInt32(3);
                                        XRL = sqlDataReader.GetString(4);

                                        string  PackageName = null;
                                        string  xrlIP = null;

                                        ParseXRLwoHTTP(XRL, TitleId, ref PackageName, ref xrlIP);

                                        if (null == xrlIP)
                                        {
                                            ParseXRLwHTTP(XRL, TitleId, ref PackageName, ref xrlIP);
                                        }

                                        if (null == xrlIP)
                                        {
                                            richTextBox.AppendText("\tTitleId: " + TitleId.ToString("x") + "\n");
                                            richTextBox.AppendText("\tOfferId: " + OfferId.ToString("x") + "\n");

                                            StringBuilder  contentId = new StringBuilder();

                                            for (int iIndex = 0; iIndex < ContentId.Length; iIndex++)
                                            {
                                                contentId.Append(ContentId[iIndex].ToString("x"));
                                            }

                                            richTextBox.AppendText("\tContentId: " + contentId.ToString() + "\n");
                                            richTextBox.AppendText("\tXRL: " + XRL + "\n");

                                            richTextBox.SelectionColor = Color.Red;
                                            richTextBox.AppendText("\tXRL is not in expected format\n\n");
                                        }
                                        else
                                        {
                                            if (false == arrayListXrlIPs.Contains(xrlIP))
                                            {
                                                arrayListXrlIPs.Add(xrlIP);
                                            }

                                            arrayListContentInfoXbox360Raw.Add(new ContentInfoXbox360(TitleId, OfferId, ContentId, PackageSize, PackageName, XRL, xrlIP));
                                        }
                                    }
                                }
                            }
                        }

                        richTextBox.AppendText("\n");
                    }



                    if ((ENUM_QUERY.all == queryType) || (ENUM_QUERY.autoupdate == queryType))
                    {
                        richTextBox.AppendText("Querying AutoUpdate Packages...\n");

                        foreach (string serverName in hashtableServersSelected.Keys)
                        {
                            ArrayList  arrayListDatabases = (ArrayList) hashtableServersSelected[serverName];

                            foreach (string databaseName in arrayListDatabases)
                            {
                                using (SqlConnection sqlConnection = new SqlConnection("Data Source=" + serverName + ";Initial Catalog=" + databaseName + ";Integrated Security=SSPI"))
                                {
                                    sqlConnection.Open();

                                    SqlCommand     sqlCommand = sqlConnection.CreateCommand();
                                    sqlCommand.CommandTimeout = VALUE_SQL_TIMEOUT;

                                    StringBuilder  sqlCommandText = new StringBuilder();
                                    StringBuilder  sqlWhere = null;

                                    sqlCommandText.Append("SELECT TTUP.i_title_id, TTUP.i_title_base_version, TTUP.i_title_update_version, TTUP.i_package_size, TTUL.vc_XRL FROM t_title_update_packages AS TTUP "
                                        + "INNER JOIN t_title_update_locations AS TTUL "
                                        + "ON TTUP.i_title_id = TTUL.i_title_id AND TTUP.i_title_base_version = TTUL.i_title_base_version AND TTUP.i_title_update_version = TTUL.i_title_update_version ");

                                    if (null != argParser["titleid"])
                                    {
                                        sqlWhere = new StringBuilder();
                                        sqlWhere.Append("WHERE TTUP.i_title_id = " + argParser["titleid"] + " ");

                                        if (null != argParser["baseversion"])
                                        {
                                            sqlWhere.Append("AND TTUP.i_title_base_version = " + argParser["baseversion"] + " ");
                                        }

                                        if (null != argParser["updateversion"])
                                        {
                                            sqlWhere.Append("AND TTUP.i_title_update_version = " + argParser["updateversion"] + " ");
                                        }
                                    }

                                    if (null != sqlWhere)
                                    {
                                        sqlCommandText.Append(sqlWhere.ToString());
                                    }

                                    sqlCommandText.Append("ORDER BY TTUP.i_title_id, TTUP.i_title_base_version, TTUP.i_title_update_version, TTUL.i_location_rank");

                                    sqlCommand.CommandText = sqlCommandText.ToString();

                                    SqlDataReader  sqlDataReader = sqlCommand.ExecuteReader();

                                    while (true == sqlDataReader.Read())
                                    {
                                        UInt32  TitleId;
                                        UInt32  BaseVersion;
                                        UInt32  UpdateVersion;
                                        UInt32  PackageSize;
                                        string  XRL;

                                        TitleId = (UInt32) sqlDataReader.GetInt32(0);
                                        BaseVersion = (UInt32) sqlDataReader.GetInt32(1);
                                        UpdateVersion = (UInt32) sqlDataReader.GetInt32(2);
                                        PackageSize = (UInt32) sqlDataReader.GetInt32(3);
                                        XRL = sqlDataReader.GetString(4);

                                        string  PackageName = null;
                                        string  xrlIP = null;

                                        ParseXRLwoHTTP(XRL, TitleId, ref PackageName, ref xrlIP);

                                        if (null == xrlIP)
                                        {
                                            ParseXRLwHTTP(XRL, TitleId, ref PackageName, ref xrlIP);
                                        }

                                        if (null == xrlIP)
                                        {
                                            richTextBox.AppendText("\tTitleId: " + TitleId.ToString("x") + "\n");
                                            richTextBox.AppendText("\tBaseVersion: " + BaseVersion.ToString("x")+ "\n");
                                            richTextBox.AppendText("\tUpdateVersion: " + UpdateVersion.ToString("x") + "\n");
                                            richTextBox.AppendText("\tXRL: " + XRL + "\n");

                                            richTextBox.SelectionColor = Color.Red;
                                            richTextBox.AppendText("\tXRL is not in expected format\n\n");
                                        }
                                        else
                                        {
                                            if (false == arrayListXrlIPs.Contains(xrlIP))
                                            {
                                                arrayListXrlIPs.Add(xrlIP);
                                            }

                                            arrayListAutoUpdateInfoRaw.Add(new AutoUpdateInfo(TitleId, BaseVersion, UpdateVersion, PackageSize, PackageName, XRL, xrlIP));
                                        }
                                    }
                                }
                            }
                        }

                        richTextBox.AppendText("\n");
                    }



                    buttonNext.Enabled = true;

                    richTextBox.SelectionColor = Color.Green;
                    richTextBox.AppendText("Done.\n");
                }
                catch (Exception e)
                {
                    richTextBox.SelectionColor = Color.Red;
                    richTextBox.AppendText("\tException: " + e.Message + "\n");
                    fUnattend = false;
                }
                finally
                {
                    TimeCurrentStop();

                    buttonBack.Enabled = true;

                    parentForm.Cursor = Cursors.Default;

                    Interlocked.Decrement(ref lockThread);

                    if (true == fUnattend)
                    {
                        PostMessage(buttonNext.Handle, WM_CLICK, 0, 0);
                    }
                }
            }

            private void ParseXRLwHTTP(
                string      XRL,
                UInt32      TitleId,
                ref string  PackageName,
                ref string  xrlIP
                )
            {
                string[]   splitXRL = XRL.Split('/');

                if (0 != String.Compare("http:", splitXRL[0]))
                {
                    goto FunctionExit;
                }

                if (0 != String.Compare("", splitXRL[1]))
                {
                    goto FunctionExit;
                }

                if (0 != String.Compare("content", splitXRL[3]))
                {
                    goto FunctionExit;
                }

                if (0 != String.Compare(TitleId.ToString("x"), splitXRL[4].ToLower()))
                {
                    goto FunctionExit;
                }

                PackageName = splitXRL[5];
                xrlIP = splitXRL[2];

FunctionExit:
                return;
            }

            private void ParseXRLwoHTTP(
                string      XRL,
                UInt32      TitleId,
                ref string  PackageName,
                ref string  xrlIP
                )
            {
                string[]   splitXRL = XRL.Split('/');

                if (0 != String.Compare("content", splitXRL[1]))
                {
                    goto FunctionExit;
                }

                if (0 != String.Compare(TitleId.ToString("x"), splitXRL[2].ToLower()))
                {
                    goto FunctionExit;
                }

                PackageName = splitXRL[3];
                xrlIP = splitXRL[0];

FunctionExit:
                return;
            }
        }



        private class GroupXrlIPMap : GroupBase
        {
            private TextBox   textBoxIPAddress;
            private Button    buttonAdd;
            private Button    buttonRemove;
            private TreeView  treeViewXrlIPMap;

            public GroupXrlIPMap(
                Form  parentForm
                )
            {
                this.parentForm = parentForm;

                textBoxIPAddress = new TextBox();
                buttonAdd = new Button();
                buttonRemove = new Button();
                treeViewXrlIPMap = new TreeView();
                controlFocus = textBoxIPAddress;
                controlXrlIPMap = treeViewXrlIPMap;

                //
                // groupBoxMain
                //
                groupBoxMain.Controls.Add(textBoxIPAddress);
                groupBoxMain.Controls.Add(buttonAdd);
                groupBoxMain.Controls.Add(buttonRemove);
                groupBoxMain.Controls.Add(treeViewXrlIPMap);
                groupBoxMain.Text = "Specify XRL IP Mapping";
                //
                // textBoxIPAddress
                //
                textBoxIPAddress.Location = new Point(8, 26);
                textBoxIPAddress.Size = new Size(336, 20);
                textBoxIPAddress.TabIndex = 1;
                textBoxIPAddress.Text = "";
                //
                // buttonAdd
                //
                buttonAdd.Location = new Point(352, 24);
                buttonAdd.Size = new Size(80, 24);
                buttonAdd.TabIndex = 2;
                buttonAdd.Text = "&Add";
                buttonAdd.Click += new System.EventHandler(buttonAdd_Click);
                //
                // buttonRemove
                //
                buttonRemove.Location = new Point(352, 56);
                buttonRemove.Size = new Size(80, 24);
                buttonRemove.TabIndex = 3;
                buttonRemove.Text = "&Remove";
                buttonRemove.Click += new System.EventHandler(buttonRemove_Click);
                //
                // treeViewXrlIPMap
                //
                treeViewXrlIPMap.HideSelection = false;
                treeViewXrlIPMap.Location = new Point(440, 24);
                treeViewXrlIPMap.Size = new Size(336, 514);
                treeViewXrlIPMap.Sorted = true;
                treeViewXrlIPMap.TabIndex = 4;
                treeViewXrlIPMap.DoubleClick += new System.EventHandler(buttonRemove_Click);

                groupBoxMain.ResumeLayout(false);
            }

            public override void GroupActivate()
            {
                SortedList  sortedListXrlIPs = new SortedList();

                foreach (TreeNode parentNode in treeViewXrlIPMap.Nodes)
                {
                    sortedListXrlIPs.Add(parentNode.Text, parentNode);
                }

                foreach (string xrlIP in sortedListXrlIPs.Keys)
                {
                    if (false == arrayListXrlIPs.Contains(xrlIP))
                    {
                        treeViewXrlIPMap.Nodes.Remove((TreeNode) sortedListXrlIPs[xrlIP]);
                    }
                }

                sortedListXrlIPs.Clear();

                foreach (TreeNode parentNode in treeViewXrlIPMap.Nodes)
                {
                    sortedListXrlIPs.Add(parentNode.Text, parentNode);
                }

                foreach (string xrlIP in arrayListXrlIPs)
                {
                    if (false == sortedListXrlIPs.Contains(xrlIP))
                    {
                        treeViewXrlIPMap.Nodes.Add(new TreeNode(xrlIP));
                    }
                }

                sortedListXrlIPs.Clear();

                if (true == fUnattend)
                {
                    PostMessage(buttonNext.Handle, WM_CLICK, 0, 0);
                }
            }

            public override void GroupDeactivate()
            {
                foreach (string xrlIP in sortedListXrlIPMap.Keys)
                {
                    ArrayList  arrayListXrlIPMap = (ArrayList) sortedListXrlIPMap[xrlIP];

                    arrayListXrlIPMap.Clear();
                }

                sortedListXrlIPMap.Clear();



                foreach (TreeNode parentNode in treeViewXrlIPMap.Nodes)
                {
                    ArrayList  arrayListXrlIPMap = new ArrayList();

                    foreach (TreeNode childNode in parentNode.Nodes)
                    {
                        arrayListXrlIPMap.Add(childNode.Text);
                    }

                    sortedListXrlIPMap[parentNode.Text] = arrayListXrlIPMap;
                }
            }

            private void buttonAdd_Click(object sender, EventArgs e)
            {
                if (null == treeViewXrlIPMap.SelectedNode)
                {
                    return;
                }

                string[]  ipAddressSplit = textBoxIPAddress.Text.Split(':');

                try
                {
                    IPAddress.Parse(ipAddressSplit[0]);

                    if ((1 != ipAddressSplit.Length) && (2 != ipAddressSplit.Length))
                    {
                        throw new Exception();
                    }

                    if (2 == ipAddressSplit.Length)
                    {
                        Convert.ToInt16(ipAddressSplit[1]);
                    }

                    TreeNode  childNode = new TreeNode(textBoxIPAddress.Text);
                    TreeNode  parentNode = treeViewXrlIPMap.SelectedNode;

                    if (null != parentNode.Parent)
                    {
                        parentNode = parentNode.Parent;
                    }

                    parentNode.Nodes.Add(childNode);
                }
                catch
                {
                }
            }

            private void buttonRemove_Click(object sender, EventArgs e)
            {
                if (null == treeViewXrlIPMap.SelectedNode)
                {
                    return;
                }

                TreeNode  treeNode = treeViewXrlIPMap.SelectedNode;

                if (null == treeNode.Parent)
                {
                    treeNode.Nodes.Clear();
                }
                else
                {
                    treeViewXrlIPMap.Nodes.Remove(treeNode);
                }
            }
        }



        private class GroupCheck : GroupBase
        {
            private RichTextBox     richTextBoxAll;
            private RichTextBox     richTextBoxErrors;
            private ListView        listViewSummary;
            private Button          buttonSave;

            public GroupCheck(
                Form  parentForm
                )
            {
                this.parentForm = parentForm;

                richTextBoxAll = new RichTextBox();
                richTextBoxErrors = new RichTextBox();
                listViewSummary = new ListView();
                buttonSave = new Button();
                controlFocus = richTextBoxAll;

                //
                // groupBoxMain
                //
                groupBoxMain.Controls.Add(richTextBoxAll);
                groupBoxMain.Controls.Add(richTextBoxErrors);
                groupBoxMain.Controls.Add(listViewSummary);
                groupBoxMain.Controls.Add(buttonSave);
                groupBoxMain.Text = "Checking XRLs";
                //
                // richTextBoxAll
                //
                richTextBoxAll.Font = new Font("Courier New", richTextBoxAll.Font.Size);
                richTextBoxAll.Location = new Point(8, 24);
                richTextBoxAll.ReadOnly = true;
                richTextBoxAll.Size = new Size(768, 207);
                richTextBoxAll.TabIndex = 1;
                richTextBoxAll.WordWrap = false;
                //
                // richTextBoxErrors
                //
                richTextBoxErrors.Font = new Font("Courier New", richTextBoxErrors.Font.Size);
                richTextBoxErrors.Location = new Point(8, 239);
                richTextBoxErrors.ReadOnly = true;
                richTextBoxErrors.Size = new Size(768, 207);
                richTextBoxErrors.TabIndex = 2;
                richTextBoxErrors.WordWrap = false;
                //
                // listViewSummary
                //
                listViewSummary.FullRowSelect = true;
                listViewSummary.HideSelection = false;
                listViewSummary.Location = new Point(8, 454);
                listViewSummary.Size = new Size(768, 84);
                listViewSummary.TabIndex = 3;
                listViewSummary.View = View.Details;

                listViewSummary.Columns.Add("Type", 126, HorizontalAlignment.Left);
                listViewSummary.Columns.Add("Packages", 72, HorizontalAlignment.Right);
                listViewSummary.Columns.Add("URLs", 72, HorizontalAlignment.Right);
                listViewSummary.Columns.Add("Errors", 72, HorizontalAlignment.Right);
                //
                // buttonSave
                //
                buttonSave.Location = new Point(8, 552);
                buttonSave.Size = new Size(80, 24);
                buttonSave.TabIndex = 4;
                buttonSave.Text = "&Save";
                buttonSave.Click += new EventHandler(buttonSave_Click);

                groupBoxMain.ResumeLayout(false);
            }

            public override void GroupActivate()
            {
                Thread  threadCheckXRLs = new Thread(new ThreadStart(ThreadCheckXRLs));
                threadCheckXRLs.Start();
                fUnattend = false;
            }

            private void ThreadCheckXRLs()
            {
                Interlocked.Increment(ref lockThread);

                parentForm.Cursor = Cursors.WaitCursor;

                buttonBack.Enabled = false;
                buttonNext.Enabled = false;

                TimeCurrentStart();

                richTextBoxAll.Clear();
                richTextBoxErrors.Clear();
                listViewSummary.Items.Clear();

                arrayListContentInfoXboxReal.Clear();
                arrayListContentInfoXbox360Real.Clear();
                arrayListAutoUpdateInfoReal.Clear();

                // Updated for 2.0 # JK 6/22/06
                //GlobalProxySelection.Select = WebProxy.GetDefaultProxy();
                //GlobalProxySelection.Select.Credentials = CredentialCache.DefaultCredentials;
                WebRequest.DefaultWebProxy.Credentials = CredentialCache.DefaultCredentials;

                int           iErrors;
                ListViewItem  lvi;



                if (0 < arrayListContentInfoXboxRaw.Count)
                {
                    richTextBoxAll.AppendText("Mapping Xbox Content Package IPs...\n");

                    foreach (ContentInfoXbox contentInfoXboxRaw in arrayListContentInfoXboxRaw)
                    {
                        ArrayList  arrayListIPMap = (ArrayList) sortedListXrlIPMap[contentInfoXboxRaw.xrlIP];

                        if (0 == arrayListIPMap.Count)
                        {
                            arrayListContentInfoXboxReal.Add(new ContentInfoXbox(contentInfoXboxRaw, contentInfoXboxRaw.xrlIP));
                        }

                        foreach (string xrlRealIP in arrayListIPMap)
                        {
                            arrayListContentInfoXboxReal.Add(new ContentInfoXbox(contentInfoXboxRaw, xrlRealIP));
                        }
                    }

                    richTextBoxAll.AppendText("\n");
                }



                if (0 < arrayListContentInfoXbox360Raw.Count)
                {
                    richTextBoxAll.AppendText("Mapping Xbox 360 Content Package IPs...\n");

                    foreach (ContentInfoXbox360 contentInfoXbox360Raw in arrayListContentInfoXbox360Raw)
                    {
                        ArrayList  arrayListIPMap = (ArrayList) sortedListXrlIPMap[contentInfoXbox360Raw.xrlIP];

                        if (0 == arrayListIPMap.Count)
                        {
                            arrayListContentInfoXbox360Real.Add(new ContentInfoXbox360(contentInfoXbox360Raw, contentInfoXbox360Raw.xrlIP));
                        }

                        foreach (string xrlRealIP in arrayListIPMap)
                        {
                            arrayListContentInfoXbox360Real.Add(new ContentInfoXbox360(contentInfoXbox360Raw, xrlRealIP));
                        }
                    }

                    richTextBoxAll.AppendText("\n");
                }



                if (0 < arrayListAutoUpdateInfoRaw.Count)
                {
                    richTextBoxAll.AppendText("Mapping AutoUpdate Package IPs...\n");

                    foreach (AutoUpdateInfo autoUpdateInfoRaw in arrayListAutoUpdateInfoRaw)
                    {
                        ArrayList  arrayListIPMap = (ArrayList) sortedListXrlIPMap[autoUpdateInfoRaw.xrlIP];

                        if (0 == arrayListIPMap.Count)
                        {
                            arrayListAutoUpdateInfoReal.Add(new AutoUpdateInfo(autoUpdateInfoRaw, autoUpdateInfoRaw.xrlIP));
                        }

                        foreach (string xrlRealIP in arrayListIPMap)
                        {
                            arrayListAutoUpdateInfoReal.Add(new AutoUpdateInfo(autoUpdateInfoRaw, xrlRealIP));
                        }
                    }

                    richTextBoxAll.AppendText("\n");
                }



                iErrors = 0;

                if (0 < arrayListContentInfoXboxReal.Count)
                {
                    richTextBoxAll.AppendText("Checking Xbox Content Packages...\n");
                    richTextBoxErrors.AppendText("Checking Xbox Content Packages...\n");

                    foreach (ContentInfoXbox contentInfoXboxReal in arrayListContentInfoXboxReal)
                    {
                        // build the url
                        string         url = "http://" + contentInfoXboxReal.xrlRealIP + "/content/" + contentInfoXboxReal.TitleId.ToString("x") + "/" + contentInfoXboxReal.PackageName;
                        StringBuilder  richText = new StringBuilder();

                        richText.Append("\tTitleId: " + contentInfoXboxReal.TitleId.ToString("x") + "\n");
                        richText.Append("\tOfferId: " + contentInfoXboxReal.OfferId.ToString("x") + "\n");
                        richText.Append("\tXRL: " + contentInfoXboxReal.XRL + "\n");
                        richText.Append("\tURL: " + url + "\n");

                        // build the request
                        HttpWebRequest   request = (HttpWebRequest) WebRequest.Create(url);
                        request.Credentials = CredentialCache.DefaultCredentials;

                        try
                        {
                            // get the response
                            HttpWebResponse  response = (HttpWebResponse) request.GetResponse();

                            // check the size
                            if ((response.ContentLength != -1) && (contentInfoXboxReal.PackageSize != response.ContentLength))
                            {
                                iErrors++;

                                richTextBoxAll.AppendText(richText.ToString());
                                richTextBoxErrors.AppendText(richText.ToString());

                                richTextBoxAll.SelectionColor = Color.Red;
                                richTextBoxAll.AppendText("\tError: Package Size (" + contentInfoXboxReal.PackageSize + ") != ContentLength (" + response.ContentLength + ")\n\n");

                                richTextBoxErrors.SelectionColor = Color.Red;
                                richTextBoxErrors.AppendText("\tError: Package Size (" + contentInfoXboxReal.PackageSize + ") != ContentLength (" + response.ContentLength + ")\n\n");
                            }
                            else
                            {
                                richTextBoxAll.AppendText(richText.ToString());
                                richTextBoxAll.SelectionColor = Color.Green;
                                richTextBoxAll.AppendText("\tPass\n\n");
                            }

                            response.Close();
                        }
                        catch (Exception e)
                        {
                            iErrors++;

                            richTextBoxAll.AppendText(richText.ToString());
                            richTextBoxErrors.AppendText(richText.ToString());

                            richTextBoxAll.SelectionColor = Color.Red;
                            richTextBoxAll.AppendText("\tException: " + e.Message + "\n\n");

                            richTextBoxErrors.SelectionColor = Color.Red;
                            richTextBoxErrors.AppendText("\tException: " + e.Message + "\n\n");
                        }
                    }

                    richTextBoxAll.AppendText("\n");
                    richTextBoxErrors.AppendText("\n");
                }

                lvi = new ListViewItem("Xbox Content Packages");
                lvi.SubItems.Add(arrayListContentInfoXboxRaw.Count.ToString("n0"));
                lvi.SubItems.Add(arrayListContentInfoXboxReal.Count.ToString("n0"));
                lvi.SubItems.Add(iErrors.ToString());
                listViewSummary.Items.Add(lvi);



                iErrors = 0;

                if (0 < arrayListContentInfoXbox360Real.Count)
                {
                    richTextBoxAll.AppendText("Checking Xbox 360 Content Packages...\n");
                    richTextBoxErrors.AppendText("Checking Xbox 360 Content Packages...\n");

                    foreach (ContentInfoXbox360 contentInfoXbox360Real in arrayListContentInfoXbox360Real)
                    {
                        // build the url
                        string         url = "http://" + contentInfoXbox360Real.xrlRealIP + "/content/" + contentInfoXbox360Real.TitleId.ToString("x") + "/" + contentInfoXbox360Real.PackageName;
                        StringBuilder  richText = new StringBuilder();

                        richText.Append("\tTitleId: " + contentInfoXbox360Real.TitleId.ToString("x") + "\n");
                        richText.Append("\tOfferId: " + contentInfoXbox360Real.OfferId.ToString("x") + "\n");

                        StringBuilder  contentId = new StringBuilder();

                        for (int iIndex = 0; iIndex < contentInfoXbox360Real.ContentId.Length; iIndex++)
                        {
                            contentId.Append(contentInfoXbox360Real.ContentId[iIndex].ToString("x2"));
                        }

                        richText.Append("\tContentId: " + contentId.ToString() + "\n");
                        richText.Append("\tXRL: " + contentInfoXbox360Real.XRL + "\n");
                        richText.Append("\tURL: " + url + "\n");

                        // build the request
                        HttpWebRequest   request = (HttpWebRequest) WebRequest.Create(url);
                        request.Credentials = CredentialCache.DefaultCredentials;

                        try
                        {
                            // get the response
                            HttpWebResponse  response = (HttpWebResponse) request.GetResponse();

                            // check the size
                            if ((response.ContentLength != -1) && (contentInfoXbox360Real.PackageSize != response.ContentLength))
                            {
                                iErrors++;

                                richTextBoxAll.AppendText(richText.ToString());
                                richTextBoxErrors.AppendText(richText.ToString());

                                richTextBoxAll.SelectionColor = Color.Red;
                                richTextBoxAll.AppendText("\tError: Package Size (" + contentInfoXbox360Real.PackageSize + ") != ContentLength (" + response.ContentLength + ")\n\n");

                                richTextBoxErrors.SelectionColor = Color.Red;
                                richTextBoxErrors.AppendText("\tError: Package Size (" + contentInfoXbox360Real.PackageSize + ") != ContentLength (" + response.ContentLength + ")\n\n");
                            }
                            else
                            {
                                richTextBoxAll.AppendText(richText.ToString());
                                richTextBoxAll.SelectionColor = Color.Green;
                                richTextBoxAll.AppendText("\tPass\n\n");
                            }

                            response.Close();
                        }
                        catch (Exception e)
                        {
                            iErrors++;

                            richTextBoxAll.AppendText(richText.ToString());
                            richTextBoxErrors.AppendText(richText.ToString());

                            richTextBoxAll.SelectionColor = Color.Red;
                            richTextBoxAll.AppendText("\tException: " + e.Message + "\n\n");

                            richTextBoxErrors.SelectionColor = Color.Red;
                            richTextBoxErrors.AppendText("\tException: " + e.Message + "\n\n");
                        }
                    }

                    richTextBoxAll.AppendText("\n");
                    richTextBoxErrors.AppendText("\n");
                }

                lvi = new ListViewItem("Xbox 360 Content Packages");
                lvi.SubItems.Add(arrayListContentInfoXbox360Raw.Count.ToString("n0"));
                lvi.SubItems.Add(arrayListContentInfoXbox360Real.Count.ToString("n0"));
                lvi.SubItems.Add(iErrors.ToString());
                listViewSummary.Items.Add(lvi);



                iErrors = 0;

                if (0 < arrayListAutoUpdateInfoReal.Count)
                {
                    richTextBoxAll.AppendText("Checking AutoUpdate Packages...\n");
                    richTextBoxErrors.AppendText("Checking AutoUpdate Packages...\n");

                    foreach (AutoUpdateInfo autoUpdateInfoReal in arrayListAutoUpdateInfoReal)
                    {
                        // build the url
                        string         url = "http://" + autoUpdateInfoReal.xrlRealIP + "/content/" + autoUpdateInfoReal.TitleId.ToString("x") + "/" + autoUpdateInfoReal.PackageName;
                        StringBuilder  richText = new StringBuilder();

                        richText.Append("\tTitleId: " + autoUpdateInfoReal.TitleId.ToString("x") + "\n");
                        richText.Append("\tBaseVersion: " + autoUpdateInfoReal.BaseVersion.ToString("x") + "\n");
                        richText.Append("\tUpdateVersion: " + autoUpdateInfoReal.UpdateVersion.ToString("x") + "\n");
                        richText.Append("\tXRL: " + autoUpdateInfoReal.XRL + "\n");
                        richText.Append("\tURL: " + url + "\n");

                        // build the request
                        HttpWebRequest   request = (HttpWebRequest) WebRequest.Create(url);
                        request.Credentials = CredentialCache.DefaultCredentials;

                        try
                        {
                            // get the response
                            HttpWebResponse  response = (HttpWebResponse) request.GetResponse();

                            // check the size
                            if ((response.ContentLength != -1) && (autoUpdateInfoReal.PackageSize != response.ContentLength))
                            {
                                iErrors++;

                                richTextBoxAll.AppendText(richText.ToString());
                                richTextBoxErrors.AppendText(richText.ToString());

                                richTextBoxAll.SelectionColor = Color.Red;
                                richTextBoxAll.AppendText("\tError: Package Size (" + autoUpdateInfoReal.PackageSize + ") != ContentLength (" + response.ContentLength + ")\n\n");

                                richTextBoxErrors.SelectionColor = Color.Red;
                                richTextBoxErrors.AppendText("\tError: Package Size (" + autoUpdateInfoReal.PackageSize + ") != ContentLength (" + response.ContentLength + ")\n\n");
                            }
                            else
                            {
                                richTextBoxAll.AppendText(richText.ToString());
                                richTextBoxAll.SelectionColor = Color.Green;
                                richTextBoxAll.AppendText("\tPass\n\n");
                            }

                            response.Close();
                        }
                        catch (Exception e)
                        {
                            iErrors++;

                            richTextBoxAll.AppendText(richText.ToString());
                            richTextBoxErrors.AppendText(richText.ToString());

                            richTextBoxAll.SelectionColor = Color.Red;
                            richTextBoxAll.AppendText("\tException: " + e.Message + "\n");

                            richTextBoxErrors.SelectionColor = Color.Red;
                            richTextBoxErrors.AppendText("\tException: " + e.Message + "\n");
                        }
                    }

                    richTextBoxAll.AppendText("\n");
                    richTextBoxErrors.AppendText("\n");
                }

                lvi = new ListViewItem("AutoUpdate Packages");
                lvi.SubItems.Add(arrayListAutoUpdateInfoRaw.Count.ToString("n0"));
                lvi.SubItems.Add(arrayListAutoUpdateInfoReal.Count.ToString("n0"));
                lvi.SubItems.Add(iErrors.ToString());
                listViewSummary.Items.Add(lvi);



                richTextBoxAll.SelectionColor = Color.Green;
                richTextBoxAll.AppendText("Done.\n");

                richTextBoxErrors.SelectionColor = Color.Green;
                richTextBoxErrors.AppendText("Done.\n");

                TimeCurrentStop();

                buttonBack.Enabled = true;
                buttonNext.Enabled = true;

                parentForm.Cursor = Cursors.Default;

                Interlocked.Decrement(ref lockThread);
            }

            private void buttonSave_Click(object sender, EventArgs e)
            {
                configSaveDialog.InitialDirectory = configOpenDialog.InitialDirectory;

                if (0 < configOpenDialog.FileName.Length)
                {
                    configSaveDialog.FileName = configOpenDialog.FileName;
                }
                else if (0 == configSaveDialog.FileName.Length)
                {
                    configSaveDialog.FileName = "PackageCheck_" + Convert.ToString(DateTime.Now.ToFileTime(), 16) + ".xml";
                }

                if (DialogResult.OK != configSaveDialog.ShowDialog())
                {
                    return;
                }

                configOpenDialog.FileName = configSaveDialog.FileName;

                Stream  xmlStream = configSaveDialog.OpenFile();

                XmlDocument  xmlDocument = new XmlDocument();

                // declaration
                XmlDeclaration  xmlDeclaration = xmlDocument.CreateXmlDeclaration("1.0", "utf-8", null);
                xmlDocument.InsertBefore(xmlDeclaration, xmlDocument.DocumentElement);

                // create the root
                XmlElement  xmlRoot = xmlDocument.CreateElement("PackageCheck");
                xmlDocument.AppendChild(xmlRoot);

                // create the servers
                XmlElement  nodeListServers = xmlDocument.CreateElement("Servers");
                xmlDocument.DocumentElement.AppendChild(nodeListServers);

                foreach (string serverName in hashtableServersSelected.Keys)
                {
                    XmlElement  nodeServerName = xmlDocument.CreateElement("Server");
                    nodeServerName.SetAttribute("Name", serverName);
                    nodeListServers.AppendChild(nodeServerName);
                }

                // create the databases
                XmlElement  nodeListDatabases = xmlDocument.CreateElement("Databases");
                xmlDocument.DocumentElement.AppendChild(nodeListDatabases);

                foreach (string serverName in hashtableServersSelected.Keys)
                {
                    ArrayList  arrayListDatabases = (ArrayList) hashtableServersSelected[serverName];

                    foreach (string databaseName in arrayListDatabases)
                    {
                        XmlElement  nodeDatabaseName = xmlDocument.CreateElement("Database");
                        nodeDatabaseName.SetAttribute("Name", databaseName);
                        nodeListDatabases.AppendChild(nodeDatabaseName);
                    }
                }

                // create the xrl ip map
                XmlElement  nodeListXrlIPMap = xmlDocument.CreateElement("XrlIPMapping");
                xmlDocument.DocumentElement.AppendChild(nodeListXrlIPMap);

                foreach (string xrlIP in sortedListXrlIPMap.Keys)
                {
                    ArrayList   arrayListXrlIPMap = (ArrayList) sortedListXrlIPMap[xrlIP];

                    if (0 == arrayListXrlIPMap.Count)
                    {
                        continue;
                    }

                    XmlElement  nodeXrlIPMap = xmlDocument.CreateElement("XrlIPMap");
                    nodeXrlIPMap.SetAttribute("XrlIP", xrlIP);

                    foreach (string xrlRealIP in arrayListXrlIPMap)
                    {
                        XmlElement  nodeXrlRealIP = xmlDocument.CreateElement("XrlRealIP");
                        nodeXrlRealIP.InnerText = xrlRealIP;
                        nodeXrlIPMap.AppendChild(nodeXrlRealIP);
                    }

                    nodeListXrlIPMap.AppendChild(nodeXrlIPMap);
                }

                xmlDocument.Save(xmlStream);
                xmlStream.Close();
            }
        }



        private GroupWelcome       groupWelcome;
        private GroupServerName    groupServerName;
        private GroupDatabaseName  groupDatabaseName;
        private GroupQuery         groupQuery;
        private GroupXrlIPMap      groupXrlIPMap;
        private GroupCheck         groupCheck;
        private GroupUsage         groupUsage;



        public PackageCheck(bool fUsage)
        {
            this.SuspendLayout();

            groupWelcome = new GroupWelcome(this);
            groupServerName = new GroupServerName(this);
            groupDatabaseName = new GroupDatabaseName(this);
            groupQuery = new GroupQuery(this);
            groupXrlIPMap = new GroupXrlIPMap(this);
            groupCheck = new GroupCheck(this);
            groupUsage = new GroupUsage(this);

            groupWelcome.SetGroupNext(groupServerName);

            groupServerName.SetGroupBack(groupWelcome);
            groupServerName.SetGroupNext(groupDatabaseName);

            groupDatabaseName.SetGroupBack(groupServerName);
            groupDatabaseName.SetGroupNext(groupQuery);

            groupQuery.SetGroupBack(groupDatabaseName);
            groupQuery.SetGroupNext(groupXrlIPMap);

            groupXrlIPMap.SetGroupBack(groupQuery);
            groupXrlIPMap.SetGroupNext(groupCheck);

            groupCheck.SetGroupBack(groupXrlIPMap);

            if (true == fUsage)
            {
                groupUsage.GroupActivate();
            }
            else
            {
                groupWelcome.GroupActivate();
            }

            //
            // PackageCheck
            //
            this.AutoScaleBaseSize = new Size(5, 13);
            this.ClientSize = new Size(808, 627);

            if (true == fUsage)
            {
                this.Controls.Add(groupUsage.groupBoxMain);
            }
            else
            {
                this.Controls.Add(groupWelcome.groupBoxMain);
            }

            this.MaximizeBox = false;
            this.MaximumSize = new Size(808, 627);
            this.MinimumSize = new Size(808, 627);
            this.Name = "PackageCheck";
            this.Text = "PackageCheck";
            this.ResumeLayout(false);
            this.Closing += new System.ComponentModel.CancelEventHandler(PackageCheck_Closing);
        }



        private void PackageCheck_Closing(object sender, System.ComponentModel.CancelEventArgs e)
        {
            if (1 == Interlocked.CompareExchange(ref lockThread, 1, 0))
            {
                e.Cancel = true;
            }
        }



        /// <summary>
        /// The main entry point for the application.
        /// </summary>
        [STAThread]
        static void Main()
        {
            try
            {
                argParser = new NamedArgParser(Environment.GetCommandLineArgs());
            }
            catch
            {
                Application.Run(new PackageCheck(true));
                return;
            }

            if (null != argParser["unattend"])
            {
                if (null == argParser["file"])
                {
                    Application.Run(new PackageCheck(true));
                    return;
                }
            }

            // determine the query type
            if (null != argParser["type"])
            {
                if (0 == String.Compare("content", argParser["type"]))
                {
                    queryType = ENUM_QUERY.content;
                }
                else if (0 == String.Compare("xboxcontent", argParser["type"]))
                {
                    queryType = ENUM_QUERY.xboxcontent;
                }
                else if (0 == String.Compare("xbox360content", argParser["type"]))
                {
                    queryType = ENUM_QUERY.xbox360content;
                }
                else if (0 == String.Compare("autoupdate", argParser["type"]))
                {
                    queryType = ENUM_QUERY.autoupdate;
                }
            }

            if (null != argParser["titleid"])
            {
                string  titleId = argParser["titleid"];

                if ((10 != titleId.Length) || (false == titleId.StartsWith("0x")))
                {
                    Application.Run(new PackageCheck(true));
                    return;
                }
            }

            if (null != argParser["offerid"])
            {
                if (ENUM_QUERY.all == queryType)
                {
                    queryType = ENUM_QUERY.content;
                }
                else if (ENUM_QUERY.content != (queryType & ENUM_QUERY.content))
                {
                    Application.Run(new PackageCheck(true));
                    return;
                }

                string  offerId = argParser["offerid"];

                if ((18 != offerId.Length) || (false == offerId.StartsWith("0x")))
                {
                    Application.Run(new PackageCheck(true));
                    return;
                }
            }

            if ((null != argParser["baseversion"]) || (null != argParser["updateversion"]))
            {
                if (ENUM_QUERY.all == queryType)
                {
                    queryType = ENUM_QUERY.autoupdate;
                }
                else if (ENUM_QUERY.autoupdate != (queryType & ENUM_QUERY.autoupdate))
                {
                    Application.Run(new PackageCheck(true));
                    return;
                }

                if (null == argParser["titleid"])
                {
                    Application.Run(new PackageCheck(true));
                    return;
                }

                if (null != argParser["baseversion"])
                {
                    string  baseVersion = argParser["baseversion"];

                    if (false == baseVersion.StartsWith("0x"))
                    {
                        Application.Run(new PackageCheck(true));
                        return;
                    }
                }

                if (null != argParser["updateversion"])
                {
                    string  updateVersion = argParser["updateversion"];

                    if (false == updateVersion.StartsWith("0x"))
                    {
                        Application.Run(new PackageCheck(true));
                        return;
                    }
                }
            }

            Application.Run(new PackageCheck(false));
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\parsers\xdashparse\Resource.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Visual C++ generated include file.
// Used by xdashparse.rc
//

#define IDS_APP_TITLE			103

#define IDR_MAINFRAME			128
#define IDD_XDASHPARSE_DIALOG	102
#define IDD_ABOUTBOX			103
#define IDM_ABOUT				104
#define IDM_EXIT				105
#define IDI_XDASHPARSE			107
#define IDI_SMALL				108
#define IDC_XDASHPARSE			109
#define IDC_MYICON				2
#define IDC_STATIC				-1
// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS

#define _APS_NO_MFC					130
#define _APS_NEXT_RESOURCE_VALUE	129
#define _APS_NEXT_COMMAND_VALUE		32771
#define _APS_NEXT_CONTROL_VALUE		1000
#define _APS_NEXT_SYMED_VALUE		110
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\parsers\capfileconvert\xomassert.cpp ===
/*++

Copyright (c) Microsoft Corporation

Module Name:

    xomassert.cpp

Abstract:

--*/

#include "stdafx.h"
#include <xmgmt.h>

#if DBG

#pragma optimize( "y", off )    // disable frame pointer omission (FPO)

VOID
__cdecl
XomDbgAssertFailed(const char * pszFilePath,
                   int          nLineNum,
                   const char * pszExpression,
                   const char * pszMessage)
{
//    CONTEXT context;
//    XomCaptureContext( &context );

    STATIC_BUFFER(DbgAssert, 8, 512);
    safe_snprintf(pch, cch - 1,
                  " Assertion (%s) Failed: %s\n"
                  " File: %s, line %ld\n",
                  pszExpression,
                  pszMessage,
                  pszFilePath,
                  nLineNum);

    OutputDebugString(pch);

    DebugBreak();
    return;
}

#pragma optimize( "", on )      // restore frame pointer omission (FPO)

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\parsers\xdashparse\stdafx.h ===
// stdafx.h : include file for standard system include files,
// or project specific include files that are used frequently, but
// are changed infrequently
//

#if !defined(AFX_STDAFX_H__C15C4F82_F7AB_45CC_A1A4_62DB039E61F7__INCLUDED_)
#define AFX_STDAFX_H__C15C4F82_F7AB_45CC_A1A4_62DB039E61F7__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000


// Insert your headers here
//#define WIN32_LEAN_AND_MEAN		// Exclude rarely-used stuff from Windows headers

#include <windows.h>
#include <netmon.h>
#include <stdio.h>
//#include "winsockx.h"
//#include "xonlinep.h"

// TODO: reference additional headers your program requires here

//{{AFX_INSERT_LOCATION}}
// Microsoft Visual C++ will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_STDAFX_H__C15C4F82_F7AB_45CC_A1A4_62DB039E61F7__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\parsers\xdashparse\xdashparse.cpp ===
// xdashparse.cpp : Defines the entry point for the application.
//

#include "stdafx.h"
#include <Winsock2.h>

//==================================================================================
// Globals
//==================================================================================
HPROTOCOL hXDash = NULL;
DWORD	  Attached = 0;
BYTE	  bStrLen = 0;

// Protocol header constants
#define E_TYPE				0x886F
#define E_SUBTYPE			0x58424F58
#define PROT_ID				0x01
#define VERSION				0x01

// Opcodes
#define DISCOVERY_REQ		0x01
#define DISCOVERY_RESP		0x02
#define BSSID_SCAN_REQ		0x03
#define BSSID_SCAN_RESP		0x04
#define QRY_PROPS_REQ		0x05
#define QRY_PROPS_RESP		0x06
#define SET_PROPS_REQ		0x07
#define SET_PROPS_RESP		0x08
#define QRY_CXN_REQ			0x09
#define QRY_CXN_RESP		0x0A

// Property Ids
#define RESET_DEFAULTS		0x00
#define IP_ADDRESS			0x01
#define IP_ACQ_MODE			0x02
#define ADMIN_PASSWORD		0x03
#define NETWORK_MODE		0x04
#define NETWORK_CHANNEL		0x05
#define BSSID				0x06
#define SSID				0x07
#define AUTH_TYPE			0x08
#define ENC_TYPE			0x09
#define WEP_KEY_64_1		0x0A
#define WEP_KEY_64_2		0x0B
#define WEP_KEY_64_3		0x0C
#define WEP_KEY_64_4		0x0D
#define ACTIVE_WEP_KEY_64	0x0E
#define WEP_KEY_128			0x0F
#define NETWORK_TYPE		0x11

#pragma pack(push, 1)  // one byte packing for all wire structures

// Common Protocol header
struct CXDashHdr
{
	DWORD	_dwESubtype;		// Ethernet subtype - constant at 0x58424F58
	BYTE	_bProtId;			// Protocol ID - constant at 0x01
	BYTE	_bVersion;			// Version - currently 0x01
	BYTE	_bLength;			// Total Length - total number of 32-bit DWORDS in
								// the packet
	BYTE	_bOpCode;			// Operation - what sort of request/response this
								// frame is
	WORD	_wSeqNum;			// Sequence Number - arbitrary 16-bit value sent
								// with a request; response must contain the same
								// value
	WORD	_wChkSum;			// Checksum - standard TCP/IP checksum
};

// Common payload components

// used in BSSID Scan Response, Set Properties Request and Query Properties Request
struct CRecordCount
{
	BYTE	_bNumRecords;		// Number of records contained in message
};

// used in Set Properties Request, Query Properties Request and Query Properties Response
struct CPropertyData
{
	BYTE	_bPropId;			// Property ID
	BYTE	_bPropLength;		// Number of bytes of property data in this record
};

// used in Set Properties Request, Query Properties Request and Query Properties Response
struct CPaddingBytes
{
	BYTE	_abPadding[3];
};

// Discovery Request payload
struct CDiscReqData
{
	BYTE	_abNonce[16];		// Random 16-byte nonce
};

// Discovery Response payload
struct CDiscRespData
{
	BYTE	_abSha1Hmac[20];	// SHA-1 HMAC of request nonce + responding
								// device's MAC address
	CHAR	_achCopyright[84];	// Microsoft copyright string
	CHAR	_achDevice[32];		// Vendor-defined device name string
	CHAR	_achFirmware[32];	// Vendor-defined device firmware version string
	BYTE	_abBssid[6];		// BSSID of network that device is connected to
	BYTE	_bAuthTypes;		// Supported authentication types
	BYTE	_bEncTypes;			// Supported encryption types
	BYTE	_ab2GhzChannels[4];	// Supported 2.4 GHz channels
	BYTE	_ab5GhzChannels[28];// Supported 5 GHz channels
	BYTE	_bNetTypes;			// Supported network types
	BYTE	_bIpAcqMode;		// IP acquisition mode
	BYTE	_bIpAddr[4];		// Current IP address
	BYTE	_bCfgStatus;		// Configuration status
	BYTE	_bCxnStatus;		// Connection status
	BYTE	_bNetworkMode;		// Network mode
	BYTE	_bNetworkChannel;	// Network channel
	BYTE	_bNetworkType;		// Network type
	BYTE	_bSsidLength;		// SSID length
	CHAR	_achSsidString[32];	// SSID string
	BYTE	_bAuthStatus;		// Authentication status
	BYTE	_bEncStatus;		// Encryption status
	BYTE	_abPadding[2];		// Padding bytes
};

// BSSID Scan Request payload is empty

// BSSID Scan Response payload is made up of three parts:
/*
struct CBssidScanRespCount
{
	BYTE	_bNumRecords;		// Number of BSSID records contained in response
};
*/
struct CBssidScanRespData
{
	BYTE	_abMacAddr[6];		// MAC address of access point (BSSID)
	BYTE	_bNetworkMode;		// Network mode
	BYTE	_bSsidLength;		// Length of SSID string of network
	CHAR	_achSsidString[32];	// SSID string
	BYTE	_bNetworkType;		// Network type
	BYTE	_bNetworkChannel;	// Network channel
	BYTE	_bAuthReq;			// Authentication requirement
	BYTE	_bEncReq;			// Encryption requirement
	BYTE	_bRssi;				// RSSI
	BYTE	_abDataRates[16];	// Supported data rates
};

struct CBssidScanRespTail
{
	BYTE	_abPadding[2];		// Padding bytes
};
/*
// Set Properties Request payload is made up of three parts:
struct CSetPropsReqCount
{
	BYTE	_bNumRecords;		// Number of property records contained in request
};

struct CSetPropsReqData
{
	BYTE	_bPropId;			// Property ID
	BYTE	_bPropLength;		// Number of bytes of property data in this record
};

struct CSetPropsReqTail
{
	BYTE	_abPadding[3];		// Padding bytes
};
*/
// Set Properties Response payload
struct CSetPropsRespData
{
	BYTE	_bStatus;			// Status of Set Properties
	BYTE	_abPadding[3];		// Padding bytes
};
/*
// Query Properties Request payload is made up of three parts:
struct CQryPropsReqCount
{
	BYTE	_bNumRecords;		// Number of property queries contained in request
};

struct CQryPropsReqData
{
	BYTE	_bPropId;			// Property ID
	BYTE	_bPropLength;		// Number of bytes of property data in this record
};

struct CQryPropsReqTail
{
	BYTE	_abPadding[3];		// Padding bytes
};
*/
// Query Properties Response payload is made up of three parts:
struct CQryPropsRespCount
{
	BYTE	_bStatus;			// Status of Query Properties
	BYTE	_bNumRecords;		// Number of property records contained in response
};
/*
struct CQryPropsRespData
{
	BYTE	_bPropId;			// Property ID
	BYTE	_bPropLength;		// Number of bytes of property data in this record
};

struct CQryPropsRespTail
{
	BYTE	_abPadding[3];		// Padding bytes
};
*/
// Query Connection Status Request payload is empty

// Query Connection Status Response payload
struct CQryCxnRespData
{
	BYTE	_bCxnStatus;		// Connection status
	BYTE	_bRssi;				// RSSI
	BYTE	_bRate;				// Data rate
	BYTE	_bPadding;			// Padding byte
};

#pragma pack(pop)

//==================================================================================
// Functions
//==================================================================================
extern PPF_PARSERDLLINFO WINAPI ParserAutoInstallInfo();

// Functions for Xbox Security Protocol
extern VOID   WINAPI XDash_Register(HPROTOCOL hXDash);
extern VOID   WINAPI XDash_Deregister(HPROTOCOL hXDash);
extern LPBYTE WINAPI XDash_RecognizeFrame(HFRAME hFrame, 
                                        LPBYTE pMacFrame, 
                                        LPBYTE pXDashFrame, 
                                        DWORD MacType, 
                                        DWORD BytesLeft, 
                                        HPROTOCOL hPrevProtocol, 
                                        DWORD nPrevProtOffset,
                                        LPDWORD pProtocolStatus,
                                        LPHPROTOCOL phNextProtocol, 
                                        LPDWORD InstData);
extern LPBYTE WINAPI XDash_AttachProperties(HFRAME hFrame, 
                                          LPBYTE pMacFrame, 
                                          LPBYTE pXDashFrame, 
                                          DWORD MacType, 
                                          DWORD BytesLeft, 
                                          HPROTOCOL hPrevProtocol, 
                                          DWORD nPrevProtOffset,
                                          DWORD InstData);
extern DWORD  WINAPI XDash_FormatProperties(HFRAME hFrame, 
                                          LPBYTE pMacFrame, 
                                          LPBYTE pXDashFrame, 
                                          DWORD nPropertyInsts, 
                                          LPPROPERTYINST p);
VOID WINAPIV XDash_FormatDiscoveryReqSummary(LPPROPERTYINST pPropertyInst);
VOID WINAPIV XDash_FormatDiscoveryRespSummary(LPPROPERTYINST pPropertyInst);
VOID WINAPIV XDash_FormatBssidScanReqSummary(LPPROPERTYINST pPropertyInst);
VOID WINAPIV XDash_FormatBssidScanRespSummary(LPPROPERTYINST pPropertyInst);
VOID WINAPIV XDash_FormatBssidScanRecSummary(LPPROPERTYINST pPropertyInst);
VOID WINAPIV XDash_FormatSetPropsReqSummary(LPPROPERTYINST pPropertyInst);
VOID WINAPIV XDash_FormatSetPropsRespSummary(LPPROPERTYINST pPropertyInst);
VOID WINAPIV XDash_FormatSetPropsRecSummary(LPPROPERTYINST pPropertyInst);
VOID WINAPIV XDash_FormatQryPropsReqSummary(LPPROPERTYINST pPropertyInst);
VOID WINAPIV XDash_FormatQryPropsRespSummary(LPPROPERTYINST pPropertyInst);
VOID WINAPIV XDash_FormatQryPropsRecSummary(LPPROPERTYINST pPropertyInst);
VOID WINAPIV XDash_FormatQryCxnReqSummary(LPPROPERTYINST pPropertyInst);
VOID WINAPIV XDash_FormatQryCxnRespSummary(LPPROPERTYINST pPropertyInst);
VOID WINAPIV XDash_FormatPropertyDataSummary(LPPROPERTYINST pPropertyInst);
VOID WINAPIV XDash_FormatNonce(LPPROPERTYINST pPropertyInst);
VOID WINAPIV XDash_FormatCopyright(LPPROPERTYINST pPropertyInst);
VOID WINAPIV XDash_FormatDevice(LPPROPERTYINST pPropertyInst);
VOID WINAPIV XDash_FormatFirmware(LPPROPERTYINST pPropertyInst);
VOID WINAPIV XDash_FormatAuthTypes(LPPROPERTYINST pPropertyInst);
VOID WINAPIV XDash_FormatEncTypes(LPPROPERTYINST pPropertyInst);
VOID WINAPIV XDash_FormatNetTypes(LPPROPERTYINST pPropertyInst);
VOID WINAPIV XDash_FormatIpAcqMode(LPPROPERTYINST pPropertyInst);
VOID WINAPIV XDash_FormatCfgStatus(LPPROPERTYINST pPropertyInst);
VOID WINAPIV XDash_FormatCxnStatus(LPPROPERTYINST pPropertyInst);
VOID WINAPIV XDash_FormatMode(LPPROPERTYINST pPropertyInst);
VOID WINAPIV XDash_FormatChannel(LPPROPERTYINST pPropertyInst);
VOID WINAPIV XDash_FormatNetwork(LPPROPERTYINST pPropertyInst);
VOID WINAPIV XDash_FormatAuthentication(LPPROPERTYINST pPropertyInst);
VOID WINAPIV XDash_FormatEncryption(LPPROPERTYINST pPropertyInst);
VOID WINAPIV XDash_FormatRssi(LPPROPERTYINST pPropertyInst);
VOID WINAPIV XDash_FormatDataRates(LPPROPERTYINST pPropertyInst);
VOID WINAPIV XDash_FormatStatus(LPPROPERTYINST pPropertyInst);
VOID WINAPIV XDash_FormatRate(LPPROPERTYINST pPropertyInst);
VOID WINAPIV XDash_FormatSsidString(LPPROPERTYINST pPropertyInst);
VOID WINAPIV XDash_FormatSsidLength(LPPROPERTYINST pPropertyInst);
VOID WINAPIV XDash_FormatPropertyId(LPPROPERTYINST pPropertyInst);
VOID WINAPIV XDash_FormatPropertyLength(LPPROPERTYINST pPropertyInst);
VOID WINAPIV XDash_FormatSsid(LPPROPERTYINST pPropertyInst);
VOID WINAPIV XDash_FormatPassword(LPPROPERTYINST pPropertyInst);
//VOID WINAPIV XDash_Format64WepKey(LPPROPERTYINST pPropertyInst);
//VOID WINAPIV XDash_Format128WepKey(LPPROPERTYINST pPropertyInst);
VOID WINAPIV XDash_FormatActiveWepKey(LPPROPERTYINST pPropertyInst);
VOID WINAPIV XDash_FormatNumRecords(LPPROPERTYINST pPropertyInst);

//==================================================================================
// Entry points
//==================================================================================
ENTRYPOINTS XDashEntryPoints =
{
	// XDash Entry Points
	XDash_Register,
	XDash_Deregister,
	XDash_RecognizeFrame,
	XDash_AttachProperties,
	XDash_FormatProperties
};

//==================================================================================
// Properties
//==================================================================================
typedef enum
{
	XDASH_SUMMARY_DISCOVERY_REQ = 0,
	XDASH_SUMMARY_DISCOVERY_RESP,
	XDASH_SUMMARY_BSSID_SCAN_REQ,
	XDASH_SUMMARY_BSSID_SCAN_RESP,
	XDASH_SUMMARY_BSSID_SCAN_REC,
	XDASH_SUMMARY_SET_PROPS_REQ,
	XDASH_SUMMARY_SET_PROPS_RESP,
	XDASH_SUMMARY_SET_PROPS_REC,
	XDASH_SUMMARY_QRY_PROPS_REQ,
	XDASH_SUMMARY_QRY_PROPS_RESP,
	XDASH_SUMMARY_QRY_PROPS_REC,
	XDASH_SUMMARY_QRY_CXN_REQ,
	XDASH_SUMMARY_QRY_CXN_RESP,
	XDASH_SUMMARY_PROPERTY_DATA,

	XDASH_NONCE,
	XDASH_SHA1_HMAC_NONCE,
	XDASH_COPYRIGHT_STRING,
	XDASH_DEVICE_NAME,
	XDASH_FIRMWARE_VERSION,
	XDASH_BSSID,
	XDASH_AUTH_TYPES,
	XDASH_ENC_TYPES,
	XDASH_2_GHZ_CHANNELS,
	XDASH_5_GHZ_CHANNELS,
	XDASH_NET_TYPES,
	XDASH_IP_ACQ_MODE,
	XDASH_IP_ADDR,
	XDASH_CFG_STATUS,
	XDASH_CXN_STATUS,

	XDASH_NETWORK_MODE,
	XDASH_NETWORK_CHANNEL,
	XDASH_NETWORK_TYPE,
	XDASH_SSID_LENGTH,
	XDASH_SSID_STRING,
	XDASH_AUTH,
	XDASH_ENC,
	XDASH_PAD,
	
	XDASH_NUM_RECORDS,
	XDASH_MAC_ADDR,
	XDASH_RSSI,
	XDASH_DATA_RATES,

	XDASH_PROPERTY_ID,
	XDASH_PROPERTY_LENGTH,
	XDASH_STATUS,
	XDASH_RATE,

	XDASH_SSID,
	XDASH_PASSWORD,
	XDASH_64_WEP_KEY,
	XDASH_128_WEP_KEY,
	XDASH_ACTIVE_WEP_KEY
};

PROPERTYINFO XDashPropTable[] =
{
	// XDASH_SUMMARY_DISCOVERY_REQ
	{ 0, 0,
		"Discovery Request",
		"Discovery Request",
		PROP_TYPE_SUMMARY,
		PROP_QUAL_NONE,
		NULL,
		80,
		XDash_FormatDiscoveryReqSummary
	},
	
	// XDASH_SUMMARY_DISCOVERY_RESP
	{ 0, 0,
		"Discovery Response",
		"Discovery Response",
		PROP_TYPE_SUMMARY,
		PROP_QUAL_NONE,
		NULL,
		80,
		XDash_FormatDiscoveryRespSummary
	},

	// XDASH_SUMMARY_BSSID_SCAN_REQ
	{ 0, 0,
		"BSSID Scan Request",
		"BSSID Scan Request",
		PROP_TYPE_SUMMARY,
		PROP_QUAL_NONE,
		NULL,
		80,
		XDash_FormatBssidScanReqSummary
	},

	// XDASH_SUMMARY_BSSID_SCAN_RESP
	{ 0, 0,
		"BSSID Scan Response",
		"BSSID Scan Response",
		PROP_TYPE_SUMMARY,
		PROP_QUAL_NONE,
		NULL,
		80,
		XDash_FormatBssidScanRespSummary
	},

	// XDASH_SUMMARY_BSSID_SCAN_REC
	{ 0, 0,
		"BSSID Scan Record",
		"BSSID Scan Record",
		PROP_TYPE_SUMMARY,
		PROP_QUAL_NONE,
		NULL,
		80,
		XDash_FormatBssidScanRecSummary
	},

	// XDASH_SUMMARY_SET_PROPS_REQ
	{ 0, 0,
		"Set Properties Request",
		"Set Properties Request",
		PROP_TYPE_SUMMARY,
		PROP_QUAL_NONE,
		NULL,
		80,
		XDash_FormatSetPropsReqSummary
	},

	// XDASH_SUMMARY_SET_PROPS_RESP
	{ 0, 0,
		"Set Properties Response",
		"Set Properties Response",
		PROP_TYPE_SUMMARY,
		PROP_QUAL_NONE,
		NULL,
		80,
		XDash_FormatSetPropsRespSummary
	},

	// XDASH_SUMMARY_SET_PROPS_REC
	{ 0, 0,
		"Set Properties Record",
		"Set Properties Record",
		PROP_TYPE_SUMMARY,
		PROP_QUAL_NONE,
		NULL,
		80,
		XDash_FormatSetPropsRecSummary
	},

	// XDASH_SUMMARY_QRY_PROPS_REQ
	{ 0, 0,
		"Query Properties Request",
		"Query Properties Request",
		PROP_TYPE_SUMMARY,
		PROP_QUAL_NONE,
		NULL,
		80,
		XDash_FormatQryPropsReqSummary
	},

	// XDASH_SUMMARY_QRY_PROPS_RESP
	{ 0, 0,
		"Query Properties Response",
		"Query Properties Response",
		PROP_TYPE_SUMMARY,
		PROP_QUAL_NONE,
		NULL,
		80,
		XDash_FormatQryPropsRespSummary
	},

	// XDASH_SUMMARY_QRY_PROPS_REC
	{ 0, 0,
		"Query Properties Record",
		"Query Properties Record",
		PROP_TYPE_SUMMARY,
		PROP_QUAL_NONE,
		NULL,
		80,
		XDash_FormatQryPropsRecSummary
	},

	// XDASH_SUMMARY_QRY_CXN_REQ
	{ 0, 0,
		"Query Connection Status Request",
		"Query Connection Status Request",
		PROP_TYPE_SUMMARY,
		PROP_QUAL_NONE,
		NULL,
		80,
		XDash_FormatQryCxnReqSummary
	},

	// XDASH_SUMMARY_QRY_CXN_RESP
	{ 0, 0,
		"Query Connection Status Response",
		"Query Connection Status Response",
		PROP_TYPE_SUMMARY,
		PROP_QUAL_NONE,
		NULL,
		80,
		XDash_FormatQryCxnRespSummary
	},

	// XDASH_SUMMARY_PROPERTY_DATA
	{ 0, 0,
		"Property Data",
		"Property Data",
		PROP_TYPE_SUMMARY,
		PROP_QUAL_NONE,
		NULL,
		80,
		XDash_FormatPropertyDataSummary
	},

	// XDASH_NONCE
	{ 0, 0,
		"Nonce",
		"Nonce",
		PROP_TYPE_RAW_DATA,
		PROP_QUAL_NONE,
		NULL,
		80,
		FormatPropertyInstance
	},

	// XDASH_SHA1_HMAC_NONCE
	{ 0, 0,
		"SHA-1 HMAC of Nonce + MAC",
		"SHA-1 HMAC of Nonce + MAC",
		PROP_TYPE_RAW_DATA,
		PROP_QUAL_NONE,
		NULL,
		80,
		FormatPropertyInstance
	},

	// XDASH_COPYRIGHT_STRING
	{ 0, 0,
		"Copyright String",
		"Copyright String",
		PROP_TYPE_STRING,
		PROP_QUAL_NONE,
		NULL,
		80,
		XDash_FormatCopyright
	},

	// XDASH_DEVICE_NAME
	{ 0, 0,
		"Device Name",
		"Device Name",
		PROP_TYPE_STRING,
		PROP_QUAL_NONE,
		NULL,
		80,
		XDash_FormatDevice
	},

	// XDASH_FIRMWARE_VERSION
	{ 0, 0,
		"Firmware Version",
		"Firmware Version",
		PROP_TYPE_STRING,
		PROP_QUAL_NONE,
		NULL,
		80,
		XDash_FormatFirmware
	},

	// XDASH_BSSID
	{ 0, 0,
		"BSSID",
		"BSSID",
		PROP_TYPE_RAW_DATA,
		PROP_QUAL_NONE,
		NULL,
		80,
		FormatPropertyInstance
	},

	// XDASH_AUTH_TYPES
	{ 0, 0,
		"Supported Authentication Types",
		"Supported Authentication Types",
		PROP_TYPE_BYTE,
		PROP_QUAL_NONE,
		NULL,
		80,
		XDash_FormatAuthTypes
	},

	// XDASH_ENC_TYPES
	{ 0, 0,
		"Supported Encryption Types",
		"Supported Encryption Types",
		PROP_TYPE_BYTE,
		PROP_QUAL_NONE,
		NULL,
		80,
		XDash_FormatEncTypes
	},

	// XDASH_2_GHZ_CHANNELS
	{ 0, 0,
		"Supported 2.4 GHz Channels",
		"Supported 2.4 GHz Channels",
		PROP_TYPE_RAW_DATA,
		PROP_QUAL_NONE,
		NULL,
		80,
		FormatPropertyInstance
	},

	// XDASH_5_GHZ_CHANNELS
	{ 0, 0,
		"Supported 5 GHz Channels",
		"Supported 5 GHz Channels",
		PROP_TYPE_RAW_DATA,
		PROP_QUAL_NONE,
		NULL,
		80,
		FormatPropertyInstance
	},

	// XDASH_NET_TYPES
	{ 0, 0,
		"Supported Network Types",
		"Supported Network Types",
		PROP_TYPE_BYTE,
		PROP_QUAL_NONE,
		NULL,
		80,
		XDash_FormatNetTypes
	},
	
	// XDASH_IP_ACQ_MODE
	{ 0, 0,
		"IP Acquisition Mode",
		"IP Acquisition Mode",
		PROP_TYPE_BYTE,
		PROP_QUAL_NONE,
		NULL,
		80,
		XDash_FormatIpAcqMode
	},

	// XDASH_IP_ADDR
	{ 0, 0,
		"IP Address",
		"IP Address",
		PROP_TYPE_IP_ADDRESS,
		PROP_QUAL_NONE,
		NULL,
		80,
		FormatPropertyInstance
	},

	// XDASH_CFG_STATUS
	{ 0, 0,
		"Configuration Status",
		"Configuration Status",
		PROP_TYPE_BYTE,
		PROP_QUAL_NONE,
		NULL,
		80,
		XDash_FormatCfgStatus
	},

	// XDASH_CXN_STATUS
	{ 0, 0,
		"Connection Status",
		"Connection Status",
		PROP_TYPE_BYTE,
		PROP_QUAL_NONE,
		NULL,
		80,
		XDash_FormatCxnStatus
	},

	// XDASH_NETWORK_MODE
	{ 0, 0,
		"Network Mode",
		"Network Mode",
		PROP_TYPE_BYTE,
		PROP_QUAL_NONE,
		NULL,
		80,
		XDash_FormatMode
	},

	// XDASH_NETWORK_CHANNEL
	{ 0, 0,
		"Network Channel",
		"Network Channel",
		PROP_TYPE_BYTE,
		PROP_QUAL_NONE,
		NULL,
		80,
		XDash_FormatChannel
	},

	// XDASH_NETWORK_TYPE
	{ 0, 0,
		"Network Type",
		"Network Type",
		PROP_TYPE_BYTE,
		PROP_QUAL_NONE,
		NULL,
		80,
		XDash_FormatNetwork
	},

	// XDASH_SSID_LENGTH
	{ 0, 0,
		"SSID Length",
		"SSID Length",
		PROP_TYPE_BYTE,
		PROP_QUAL_NONE,
		NULL,
		80,
		XDash_FormatSsidLength
	},

	// XDASH_SSID_STRING
	{ 0, 0,
		"SSID String",
		"SSID String",
		PROP_TYPE_STRING,
		PROP_QUAL_NONE,
		NULL,
		80,
		XDash_FormatSsidString
	},

	// XDASH_AUTHENTICATION
	{ 0, 0,
		"Authentication",
		"Authentication",
		PROP_TYPE_BYTE,
		PROP_QUAL_NONE,
		NULL,
		80,
		XDash_FormatAuthentication
	},

	// XDASH_ENCRYPTION
	{ 0, 0,
		"Encryption",
		"Encryption",
		PROP_TYPE_BYTE,
		PROP_QUAL_NONE,
		NULL,
		80,
		XDash_FormatEncryption
	},

	// XDASH_PAD
	{ 0, 0,
		"Padding",
		"Padding",
		PROP_TYPE_RAW_DATA,
		PROP_QUAL_NONE,
		NULL,
		80,
		FormatPropertyInstance
	},
	
	// XDASH_NUM_RECORDS
	{ 0, 0,
		"Number of Records",
		"Number of Records",
		PROP_TYPE_BYTE,
		PROP_QUAL_NONE,
		NULL,
		80,
		XDash_FormatNumRecords
	},

	// XDASH_MAC_ADDR
	{ 0, 0,
		"MAC Address",
		"MAC Address",
		PROP_TYPE_ADDR,
		PROP_QUAL_NONE,
		NULL,
		80,
		FormatPropertyInstance
	},

	// XDASH_RSSI
	{ 0, 0,
		"RSSI",
		"RSSI",
		PROP_TYPE_BYTE,
		PROP_QUAL_NONE,
		NULL,
		80,
		XDash_FormatRssi
	},

	// XDASH_DATA_RATES
	{ 0, 0,
		"Supported Data Rates",
		"Supported Data Rates",
		PROP_TYPE_RAW_DATA,
		PROP_QUAL_NONE,
		NULL,
		80,
		XDash_FormatDataRates
	},

	// XDASH_PROPERTY_ID
	{ 0, 0,
		"Property ID",
		"Property ID",
		PROP_TYPE_BYTE,
		PROP_QUAL_NONE,
		NULL,
		80,
		XDash_FormatPropertyId
	},

	// XDASH_PROPERTY_LENGTH
	{ 0, 0,
		"Property Length",
		"Property Length",
		PROP_TYPE_BYTE,
		PROP_QUAL_NONE,
		NULL,
		80,
		XDash_FormatPropertyLength
	},

	// XDASH_STATUS
	{ 0, 0,
		"Status",
		"Status",
		PROP_TYPE_BYTE,
		PROP_QUAL_NONE,
		NULL,
		80,
		XDash_FormatStatus
	},

	// XDASH_RATE
	{ 0, 0,
		"Data Rate",
		"Data Rate",
		PROP_TYPE_BYTE,
		PROP_QUAL_NONE,
		NULL,
		80,
		XDash_FormatRate
	},

	// XDASH_SSID
	{ 0, 0,
		"SSID",
		"SSID",
		PROP_TYPE_STRING,
		PROP_QUAL_NONE,
		NULL,
		80,
		XDash_FormatSsid
	},

	// XDASH_PASSWORD
	{ 0, 0,
		"Admin Password",
		"Admin Password",
		PROP_TYPE_STRING,
		PROP_QUAL_NONE,
		NULL,
		80,
		XDash_FormatPassword
	},

	// XDASH_64_WEP_KEY
	{ 0, 0,
		"64 Bit WEP Key",
		"64 Bit WEP Key",
		PROP_TYPE_RAW_DATA,
		PROP_QUAL_NONE,
		NULL,
		80,
		FormatPropertyInstance
	},

	// XDASH_128_WEP_KEY
	{ 0, 0,
		"128 Bit WEP Key",
		"128 Bit WEP Key",
		PROP_TYPE_RAW_DATA,
		PROP_QUAL_NONE,
		NULL,
		80,
		FormatPropertyInstance
	},

	// XDASH_ACTIVE_WEP_KEY
	{ 0, 0,
		"Active 64 Bit WEP Key",
		"Active 64 Bit WEP Key",
		PROP_TYPE_BYTE,
		PROP_QUAL_NONE,
		NULL,
		80,
		XDash_FormatActiveWepKey
	}

};

DWORD nNumXDashProps = (sizeof(XDashPropTable)/sizeof(PROPERTYINFO));

//==================================================================================
// ParserAutoInstallInfo
//----------------------------------------------------------------------------------
//
// Description: Function called by Netmon to automatically install the parser
//
// Arguments: none
//
// Returns: On success, returns a pointer to a PF_PARSERDLLINFO structure containing
//          information on the parsers in this DLL.  Otherwise, returns NULL
//==================================================================================
PPF_PARSERDLLINFO WINAPI ParserAutoInstallInfo()
{
	PPF_PARSERDLLINFO	pParserDllInfo;
	PPF_PARSERINFO		pParserInfo;
	DWORD				dwNumProtocols;

	PPF_HANDOFFSET		pIncomingHandoff;
	PPF_HANDOFFENTRY	pHandoffEntry;
	DWORD				dwIncomingHandoffs;

	// Base structure ==============================================================
	
	// Allocate memory for parser info
	dwNumProtocols = 1;
	pParserDllInfo = (PPF_PARSERDLLINFO)HeapAlloc(GetProcessHeap(),
		HEAP_ZERO_MEMORY,
		sizeof(PF_PARSERDLLINFO) + dwNumProtocols * sizeof(PF_PARSERINFO));
	if(pParserDllInfo == NULL)
	{
		return NULL;
	}

	// Fill in the parser DLL info
	pParserDllInfo->nParsers = dwNumProtocols;

	//-------------------------------------------------------------
	// Installation of Xbox Wireless Bridge Configuration Protocol
	//-------------------------------------------------------------

	// Enter XDash information
	pParserInfo = &(pParserDllInfo->ParserInfo[0]);
	sprintf(pParserInfo->szProtocolName, "XDASH");
	sprintf(pParserInfo->szComment,		 "Xbox Wireless Bridge Configuration Protocol");
	sprintf(pParserInfo->szHelpFile,	 "");

	// Allocate the incoming handoff set
	dwIncomingHandoffs = 1;
	pIncomingHandoff = (PPF_HANDOFFSET)HeapAlloc(GetProcessHeap(),
		HEAP_ZERO_MEMORY,
		sizeof(PF_HANDOFFSET) + dwIncomingHandoffs * sizeof(PF_HANDOFFENTRY));
	if(pIncomingHandoff == NULL)
	{
		return pParserDllInfo;
	}

	// Fill in the incoming handoff set
	pParserInfo->pWhoHandsOffToMe = pIncomingHandoff;
	pIncomingHandoff->nEntries = dwIncomingHandoffs;

	// Ethertype 0x886F
	pHandoffEntry = &(pIncomingHandoff->Entry[0]);
	sprintf(pHandoffEntry->szIniFile,    "mac.ini");
	sprintf(pHandoffEntry->szIniSection, "ETYPES");
	sprintf(pHandoffEntry->szProtocol,   "XDash");
	pHandoffEntry->dwHandOffValue =		 0x886F;
	pHandoffEntry->ValueFormatBase =	 HANDOFF_VALUE_FORMAT_BASE_HEX;

	return pParserDllInfo;
}

//==================================================================================
// DllMain
//----------------------------------------------------------------------------------
//
// Description: (Called by the OS) Tell the kernel about our entry points
//
// Returns: Always returns TRUE
//==================================================================================
BOOL WINAPI DllMain(HANDLE hInstance, ULONG Command, LPVOID Reserved)
{
	// What type of call is this?
	switch(Command)
	{
	case DLL_PROCESS_ATTACH:
		// Are we loading for the first time?
		if(Attached == 0)
		{
			// Create the Xbox Wireless Bridge Configuration Protocol
			hXDash = CreateProtocol("XDASH", &XDashEntryPoints, ENTRYPOINTS_SIZE);
		}
		Attached++;
		break;

	case DLL_PROCESS_DETACH:
		// Are we detaching our last instance?
		Attached--;
		if(Attached == 0)
		{
			// Clean up the protocol
			DestroyProtocol(hXDash);
		}
		break;
	}

	// Netmon parsers ALWAYS return TRUE
	return TRUE;
}

//==================================================================================
// XDash_Register
//----------------------------------------------------------------------------------
//
// Description: Creates the property database for XDash
//
// Arguments:
//	HPROTOCOL	hXDash	Handle to the XDash protocol
//
// Returns: void
//==================================================================================
void WINAPI XDash_Register(HPROTOCOL hXDash)
{
	WORD i;

	// Tell Netmon to reserve space for our property table
	CreatePropertyDatabase(hXDash, nNumXDashProps);

	// Add our properties to the Netmon database
	for(i = 0; i < nNumXDashProps; i++)
	{
		AddProperty(hXDash, &XDashPropTable[i]);
	}
}

//==================================================================================
// XDash_Deregister
//----------------------------------------------------------------------------------
//
// Description: Removes the property database for XDash
//
// Arguments:
//	HPROTOCOL	hXDash	Handle to the XDash protocol
//
// Returns: void
//==================================================================================
void WINAPI XDash_Deregister(HPROTOCOL hXDash)
{
	// Tell Netmon that it may now free our database
	DestroyPropertyDatabase(hXDash);
}

//==================================================================================
// XDash_RecognizeFrame
//----------------------------------------------------------------------------------
//
// Description: Called by Netmon to determine if the parser recognizes this frame as
//				XDash
//
// Arguments:
//	HFRAME			hFrame			Handle to the frame that contains the data.
//	LPBYTE			pMacFrame		Pointer to the first byte of a frame. The
//									pointer provides a way to view data that other
//									parsers recognize.
//	LPBYTE			pXDashFrame		Pointer to the start of the unclaimed data.
//									Typically the unclaimed data is located in the
//									middle of a frame because a previous parser has
//									claimed data before this parser. The parser must
//									test the unclaimed data first.
//	DWORD			MacType			MAC value of the first protocol in a frame.
//									Typically the MacType value is used when the
//									parser must identify the first protocol in a
//									frame.
//	DWORD			BytesLeft		The remaining number of bytes from a location in
//									a frame to the end of the frame.
//	HPROTOCOL		hPrevProtocol	Handle of the previous protocol.
//	DWORD			nPrevProtOffset	Offset of the previous protocol - beginning of
//									the frame.
//	LPDWORD			pProtocolStatus	Protocol status indicator.
//	LPHPROTOCOL		phNextProtocol	Pointer to the handle of the next protocol.
//									This parameter is set when a protocol identifies
//									the protocol that follows a protocol. To obtain
//									the handle of the next protocol, call the
//									GetProtocolFromTable function.
//	LPDWORD			InstData		On input, a pointer to the instance data from
//									the previous protocol. On output, a pointer to
//									the instance data for the current protocol.
//	
//	Returns: When XDash protocol is recognized, either returns a pointer to the next
//			 byte of unclaimed data or NULL to indicate there is no more protocol
//			 data in the packet. When XDash protocol isn't recognized, returns the
//			 original pXDashFrame value to submit the packet back to Netmon to find
//			 a proper protocol match.
//==================================================================================
LPBYTE WINAPI XDash_RecognizeFrame(HFRAME		hFrame,
								  LPBYTE		pMacFrame,
								  LPBYTE		pXDashFrame,
								  DWORD			MacType,
								  DWORD			BytesLeft,
								  HPROTOCOL		hPrevProtocol,
								  DWORD			nPrevProtOffset,
								  LPDWORD		pProtocolStatus,
								  LPHPROTOCOL	phNextProtocol,
								  LPDWORD		InstData)
{
	CXDashHdr *pXDashHdr = (CXDashHdr *) pXDashFrame;
	
	// Verify Ethernet subtype
	if(pXDashHdr->_dwESubtype != htonl(E_SUBTYPE))
	{
		*pProtocolStatus = PROTOCOL_STATUS_NOT_RECOGNIZED;
		goto Exit;
	}

	// Verify Protocol ID
	if(pXDashHdr->_bProtId != PROT_ID)
	{
		*pProtocolStatus = PROTOCOL_STATUS_NOT_RECOGNIZED;
		goto Exit;
	}

	// Verify Version
	if(pXDashHdr->_bVersion != VERSION)
	{
		*pProtocolStatus = PROTOCOL_STATUS_NOT_RECOGNIZED;
		goto Exit;
	}

	// Verify there is enough room for the CXDashHdr
	if(BytesLeft < sizeof(CXDashHdr))
	{
		*pProtocolStatus = PROTOCOL_STATUS_NOT_RECOGNIZED;
		goto Exit;
	}

	// Verify there is enough room for the packet
	if(BytesLeft < (BYTE)(pXDashHdr->_bLength * 4))
	{
		*pProtocolStatus = PROTOCOL_STATUS_NOT_RECOGNIZED;
		goto Exit;
	}

	*pProtocolStatus = PROTOCOL_STATUS_CLAIMED;
	pXDashFrame = NULL;

Exit:
	return pXDashFrame;
}

//==================================================================================
// XDash_AttachProperties
//----------------------------------------------------------------------------------
//
// Description: Called by Netmon to determine if the parser recognizes this frame as
//				XDash
//
// Arguments:
//	HFRAME			hFrame			Handle of the frame that is being parsed.
//	LPBYTE			lpFrame			Pointer to the first byte in a frame.
//	LPBYTE			pXDashFrame		Pointer to the start of the recognized data.
//	DWORD			MacType			MAC value of the first protocol in a frame.
//	DWORD			BytesLeft		The remaining number of bytes in a frame,
//									starting at the beginning of the recognized
//									data.
//	HPROTOCOL		hPrevProtocol	Handle of the previous protocol.
//	DWORD			nPrevProtOffset	Offset of the previous protocol, starting at
//									the beginning of the frame.
//	DWORD			InstData		Pointer to the instance data from the previous
//									protocol.
//
//	Returns: When the function is successful, either returns a pointer to the next
//			 byte of unclaimed data or NULL to indicate there is no more protocol
//			 data in the packet. When the function isn't successful, returns the
//			 original pXDashFrame value to submit the packet back to Netmon to find
//			 a proper protocol match.
//==================================================================================
LPBYTE WINAPI XDash_AttachProperties(HFRAME		hFrame,
									 LPBYTE		pMacFrame,
									 LPBYTE		pXDashFrame,
									 DWORD		MacType,
									 DWORD		BytesLeft,
									 HPROTOCOL	hPrevProtocol,
									 DWORD		nPrevProtOffset,
									 DWORD		InstData)
{
	CXDashHdr *pXDashHdr = (CXDashHdr *) pXDashFrame;
	LPBYTE pNextFrame = pXDashFrame;
	BYTE bTotal = 0, bCount = 0, bLength = 0;

	CRecordCount *pRecordCount = NULL;
	CPropertyData *pPropertyData = NULL;
	CPaddingBytes *pPaddingBytes = NULL;

	CDiscReqData *pDiscReqData = NULL;
	CDiscRespData *pDiscRespData = NULL;
	//CBssidScanRespCount *pBssidScanRespCount = NULL;
	CBssidScanRespData *pBssidScanRespData = NULL;
	CBssidScanRespTail *pBssidScanRespTail = NULL;
	//CSetPropsReqCount *pSetPropsReqCount = NULL;
	//CSetPropsReqData *pSetPropsReqData = NULL;
	//CSetPropsReqTail *pSetPropsReqTail = NULL;
	CSetPropsRespData *pSetPropsRespData = NULL;
	//CQryPropsReqCount *pQryPropsReqCount = NULL;
	//CQryPropsReqData *pQryPropsReqData = NULL;
	//CQryPropsReqTail *pQryPropsReqTail = NULL;
	CQryPropsRespCount *pQryPropsRespCount = NULL;
	//CQryPropsRespData *pQryPropsRespData = NULL;
	//CQryPropsRespTail *pQryPropsRespTail = NULL;
	CQryCxnRespData *pQryCxnRespData = NULL;

	// Parse packets according to operation
	switch(pXDashHdr->_bOpCode)
	{
		// Discovery Request
		case DISCOVERY_REQ:
			pDiscReqData = (CDiscReqData *)(pXDashFrame + sizeof(CXDashHdr));

			// Attach the summary
			if(!AttachPropertyInstance(hFrame,
				XDashPropTable[XDASH_SUMMARY_DISCOVERY_REQ].hProperty,
				BytesLeft,
				pXDashFrame,
				0, 1, 0))
			{
				goto Exit;
			}
			
			// Attach the nonce
			if(!AttachPropertyInstance(hFrame,
				XDashPropTable[XDASH_NONCE].hProperty,
				sizeof(pDiscReqData->_abNonce),
				(LPBYTE) &(pDiscReqData->_abNonce),
				0, 2, 0))
			{
				goto Exit;
			}

			// We've claimed the packet so when we return, point to the next byte
			// after the received packet
			pNextFrame += BytesLeft;

			// Clean up our pointers
			pDiscReqData = NULL;

			break;

		// Discovery Response
		case DISCOVERY_RESP:
			pDiscRespData = (CDiscRespData *)(pXDashFrame + sizeof(CXDashHdr));
		
			// Attach the summary
			if(!AttachPropertyInstance(hFrame,
				XDashPropTable[XDASH_SUMMARY_DISCOVERY_RESP].hProperty,
				BytesLeft,
				pXDashFrame,
				0, 1, 0))
			{
				goto Exit;
			}

			// Attach the SHA-1 HMAC of nonce + MAC
			if(!AttachPropertyInstance(hFrame,
				XDashPropTable[XDASH_SHA1_HMAC_NONCE].hProperty,
				sizeof(pDiscRespData->_abSha1Hmac),
				(LPBYTE) &(pDiscRespData->_abSha1Hmac),
				0, 2, 0))
			{
				goto Exit;
			}

			// Attach the copyright string
			if(!AttachPropertyInstance(hFrame,
				XDashPropTable[XDASH_COPYRIGHT_STRING].hProperty,
				sizeof(pDiscRespData->_achCopyright),
				(LPBYTE) &(pDiscRespData->_achCopyright),
				0, 2, 0))
			{
				goto Exit;
			}

			// Attach the device name
			if(!AttachPropertyInstance(hFrame,
				XDashPropTable[XDASH_DEVICE_NAME].hProperty,
				sizeof(pDiscRespData->_achDevice),
				(LPBYTE) &(pDiscRespData->_achDevice),
				0, 2, 0))
			{
				goto Exit;
			}

			// Attach the firmware version
			if(!AttachPropertyInstance(hFrame,
				XDashPropTable[XDASH_FIRMWARE_VERSION].hProperty,
				sizeof(pDiscRespData->_achFirmware),
				(LPBYTE) &(pDiscRespData->_achFirmware),
				0, 2, 0))
			{
				goto Exit;
			}

			// Attach the BSSID
			if(!AttachPropertyInstance(hFrame,
				XDashPropTable[XDASH_BSSID].hProperty,
				sizeof(pDiscRespData->_abBssid),
				(LPBYTE) &(pDiscRespData->_abBssid),
				0, 2, 0))
			{
				goto Exit;
			}

			// Attach the supported authentication types
			if(!AttachPropertyInstance(hFrame,
				XDashPropTable[XDASH_AUTH_TYPES].hProperty,
				sizeof(pDiscRespData->_bAuthTypes),
				(LPBYTE) &(pDiscRespData->_bAuthTypes),
				0, 2, 0))
			{
				goto Exit;
			}

			// Attach the supported encryption types
			if(!AttachPropertyInstance(hFrame,
				XDashPropTable[XDASH_ENC_TYPES].hProperty,
				sizeof(pDiscRespData->_bEncTypes),
				(LPBYTE) &(pDiscRespData->_bEncTypes),
				0, 2, 0))
			{
				goto Exit;
			}

			// Attach the supported 2.4 GHz channels
			if(!AttachPropertyInstance(hFrame,
				XDashPropTable[XDASH_2_GHZ_CHANNELS].hProperty,
				sizeof(pDiscRespData->_ab2GhzChannels),
				(LPBYTE) &(pDiscRespData->_ab2GhzChannels),
				0, 2, 0))
			{
				goto Exit;
			}

			// Attach the supported 5 GHz channels
			if(!AttachPropertyInstance(hFrame,
				XDashPropTable[XDASH_5_GHZ_CHANNELS].hProperty,
				sizeof(pDiscRespData->_ab5GhzChannels),
				(LPBYTE) &(pDiscRespData->_ab5GhzChannels),
				0, 2, 0))
			{
				goto Exit;
			}

			// Attach the supported network types
			if(!AttachPropertyInstance(hFrame,
				XDashPropTable[XDASH_NET_TYPES].hProperty,
				sizeof(pDiscRespData->_bNetTypes),
				(LPBYTE) &(pDiscRespData->_bNetTypes),
				0, 2, 0))
			{
				goto Exit;
			}

			// Attach the IP acquisition mode
			if(!AttachPropertyInstance(hFrame,
				XDashPropTable[XDASH_IP_ACQ_MODE].hProperty,
				sizeof(pDiscRespData->_bIpAcqMode),
				(LPBYTE) &(pDiscRespData->_bIpAcqMode),
				0, 2, 0))
			{
				goto Exit;
			}

			// Attach the current IP address
			if(!AttachPropertyInstance(hFrame,
				XDashPropTable[XDASH_IP_ADDR].hProperty,
				sizeof(pDiscRespData->_bIpAddr),
				(LPBYTE) &(pDiscRespData->_bIpAddr),
				0, 2, 0))
			{
				goto Exit;
			}

			// Attach the configuration status
			if(!AttachPropertyInstance(hFrame,
				XDashPropTable[XDASH_CFG_STATUS].hProperty,
				sizeof(pDiscRespData->_bCfgStatus),
				(LPBYTE) &(pDiscRespData->_bCfgStatus),
				0, 2, 0))
			{
				goto Exit;
			}

			// Attach the connection status
			if(!AttachPropertyInstance(hFrame,
				XDashPropTable[XDASH_CXN_STATUS].hProperty,
				sizeof(pDiscRespData->_bCxnStatus),
				(LPBYTE) &(pDiscRespData->_bCxnStatus),
				0, 2, 0))
			{
				goto Exit;
			}

			// Attach the network mode
			if(!AttachPropertyInstance(hFrame,
				XDashPropTable[XDASH_NETWORK_MODE].hProperty,
				sizeof(pDiscRespData->_bNetworkMode),
				(LPBYTE) &(pDiscRespData->_bNetworkMode),
				0, 2, 0))
			{
				goto Exit;
			}

			// Attach the network channel
			if(!AttachPropertyInstance(hFrame,
				XDashPropTable[XDASH_NETWORK_CHANNEL].hProperty,
				sizeof(pDiscRespData->_bNetworkChannel),
				(LPBYTE) &(pDiscRespData->_bNetworkChannel),
				0, 2, 0))
			{
				goto Exit;
			}

			// Attach the network type
			if(!AttachPropertyInstance(hFrame,
				XDashPropTable[XDASH_NETWORK_TYPE].hProperty,
				sizeof(pDiscRespData->_bNetworkType),
				(LPBYTE) &(pDiscRespData->_bNetworkType),
				0, 2, 0))
			{
				goto Exit;
			}

			// Attach the SSID length
			if(!AttachPropertyInstance(hFrame,
				XDashPropTable[XDASH_SSID_LENGTH].hProperty,
				sizeof(pDiscRespData->_bSsidLength),
				(LPBYTE) &(pDiscRespData->_bSsidLength),
				0, 2, 0))
			{
				goto Exit;
			}

			// Attach the SSID string
			if(!AttachPropertyInstance(hFrame,
				XDashPropTable[XDASH_SSID_STRING].hProperty,
				//pDiscRespData->_bSsidLength,
				sizeof(pDiscRespData->_achSsidString),
				(LPBYTE) &(pDiscRespData->_achSsidString),
				0, 2, 0))
			{
				goto Exit;
			}
			
			// Attach the authentication status
			if(!AttachPropertyInstance(hFrame,
				XDashPropTable[XDASH_AUTH].hProperty,
				sizeof(pDiscRespData->_bAuthStatus),
				(LPBYTE) &(pDiscRespData->_bAuthStatus),
				0, 2, 0))
			{
				goto Exit;
			}

			// Attach the encryption status
			if(!AttachPropertyInstance(hFrame,
				XDashPropTable[XDASH_ENC].hProperty,
				sizeof(pDiscRespData->_bEncStatus),
				(LPBYTE) &(pDiscRespData->_bEncStatus),
				0, 2, 0))
			{
				goto Exit;
			}
			/*
			// Attach the padding bytes
			if(!AttachPropertyInstance(hFrame,
				XDashPropTable[XDASH_PAD].hProperty,
				sizeof(pDiscRespData->_abPadding),
				(LPBYTE) &(pDiscRespData->_abPadding),
				0, 2, 0))
			{
				goto Exit;
			}
			*/
			// We've claimed the packet so when we return, point to the next byte
			// after the received packet
			pNextFrame += BytesLeft;

			// Clean up our pointers
			pDiscRespData = NULL;
			
			break;

		// BSSID Scan Request
		case BSSID_SCAN_REQ:

			// Attach the summary
			if(!AttachPropertyInstance(hFrame,
				XDashPropTable[XDASH_SUMMARY_BSSID_SCAN_REQ].hProperty,
				BytesLeft,
				pXDashFrame,
				0, 1, 0))
			{
				goto Exit;
			}

			// We've claimed the packet so when we return, point to the next byte
			// after the received packet
			pNextFrame += BytesLeft;

			break;

		// BSSID Scan Response
		case BSSID_SCAN_RESP:
			//pBssidScanRespCount = (CBssidScanRespCount *)(pXDashFrame + sizeof(CXDashHdr));
			pRecordCount = (CRecordCount *)(pXDashFrame + sizeof(CXDashHdr));
			
			// Attach the summary
			if(!AttachPropertyInstance(hFrame,
				XDashPropTable[XDASH_SUMMARY_BSSID_SCAN_RESP].hProperty,
				BytesLeft,
				pXDashFrame,
				0, 1, 0))
			{
				goto Exit;
			}

			// Attach the number of records
			if(!AttachPropertyInstance(hFrame,
				XDashPropTable[XDASH_NUM_RECORDS].hProperty,
				//sizeof(pBssidScanRespCount->_bNumRecords),
				//(LPBYTE) &(pBssidScanRespCount->_bNumRecords),
				sizeof(pRecordCount->_bNumRecords),
				(LPBYTE) &(pRecordCount->_bNumRecords),
				0, 2, 0))
			{
				goto Exit;
			}
			/*
			pBssidScanRespData = (CBssidScanRespData *)
				((LPBYTE)(pBssidScanRespCount) + sizeof(CBssidScanRespCount));
			bTotal = pBssidScanRespCount->_bNumRecords;*/
			pBssidScanRespData = (CBssidScanRespData *)
				((LPBYTE)(pRecordCount) + sizeof(CRecordCount));
			bTotal = pRecordCount->_bNumRecords;
			bCount = 0;

			// Attach properties for each record returned
			while(bCount < bTotal)
			{
				// Attach the record summary
				if(!AttachPropertyInstance(hFrame,
					XDashPropTable[XDASH_SUMMARY_BSSID_SCAN_REC].hProperty,
					sizeof(CBssidScanRespData),
					pBssidScanRespData,
					0, 2, 0))
				{
					goto Exit;
				}

				// Attach the MAC address of the access point
				if(!AttachPropertyInstance(hFrame,
					XDashPropTable[XDASH_MAC_ADDR].hProperty,
					sizeof(pBssidScanRespData->_abMacAddr),
					(LPBYTE) &(pBssidScanRespData->_abMacAddr),
					0, 3, 0))
				{
					goto Exit;
				}

				// Attach the network mode
				if(!AttachPropertyInstance(hFrame,
					XDashPropTable[XDASH_NETWORK_MODE].hProperty,
					sizeof(pBssidScanRespData->_bNetworkMode),
					(LPBYTE) &(pBssidScanRespData->_bNetworkMode),
					0, 3, 0))
				{
					goto Exit;
				}

				// Attach the SSID length
				if(!AttachPropertyInstance(hFrame,
					XDashPropTable[XDASH_SSID_LENGTH].hProperty,
					sizeof(pBssidScanRespData->_bSsidLength),
					(LPBYTE) &(pBssidScanRespData->_bSsidLength),
					0, 3, 0))
				{
					goto Exit;
				}

				// Attach the SSID string
				if(!AttachPropertyInstance(hFrame,
					XDashPropTable[XDASH_SSID_STRING].hProperty,
					//pBssidScanRespData->_bSsidLength,
					sizeof(pBssidScanRespData->_achSsidString),
					(LPBYTE) &(pBssidScanRespData->_achSsidString),
					0, 3, 0))
				{
					goto Exit;
				}
					
				// Attach the network type
				if(!AttachPropertyInstance(hFrame,
					XDashPropTable[XDASH_NETWORK_TYPE].hProperty,
					sizeof(pBssidScanRespData->_bNetworkType),
					(LPBYTE) &(pBssidScanRespData->_bNetworkType),
					0, 3, 0))
				{
					goto Exit;
				}

				// Attach the network channel
				if(!AttachPropertyInstance(hFrame,
					XDashPropTable[XDASH_NETWORK_CHANNEL].hProperty,
					sizeof(pBssidScanRespData->_bNetworkChannel),
					(LPBYTE) &(pBssidScanRespData->_bNetworkChannel),
					0, 3, 0))
				{
					goto Exit;
				}

				// Attach the authentication requirement
				if(!AttachPropertyInstance(hFrame,
					XDashPropTable[XDASH_AUTH].hProperty,
					sizeof(pBssidScanRespData->_bAuthReq),
					(LPBYTE) &(pBssidScanRespData->_bAuthReq),
					0, 3, 0))
				{
					goto Exit;
				}

				// Attach the encryption requirement
				if(!AttachPropertyInstance(hFrame,
					XDashPropTable[XDASH_ENC].hProperty,
					sizeof(pBssidScanRespData->_bEncReq),
					(LPBYTE) &(pBssidScanRespData->_bEncReq),
					0, 3, 0))
				{
					goto Exit;
				}

				// Attach the RSSI
				if(!AttachPropertyInstance(hFrame,
					XDashPropTable[XDASH_RSSI].hProperty,
					sizeof(pBssidScanRespData->_bRssi),
					(LPBYTE) &(pBssidScanRespData->_bRssi),
					0, 3, 0))
				{
					goto Exit;
				}

				// Attach the supported data rates
				if(!AttachPropertyInstance(hFrame,
					XDashPropTable[XDASH_DATA_RATES].hProperty,
					sizeof(pBssidScanRespData->_abDataRates),
					(LPBYTE) &(pBssidScanRespData->_abDataRates),
					0, 3, 0))
				{
					goto Exit;
				}
				
				// Advance to the next record
				pBssidScanRespData = (CBssidScanRespData *)
					((LPBYTE)(pBssidScanRespData) + sizeof(CBssidScanRespData));

				// increment count
				bCount++;			
			}

			pBssidScanRespTail = (CBssidScanRespTail *)(pBssidScanRespData);
			/*
			// Attach the padding bytes
			if(!AttachPropertyInstance(hFrame,
				XDashPropTable[XDASH_PAD].hProperty,
				sizeof(pBssidScanRespTail->_abPadding),
				(LPBYTE) &(pBssidScanRespTail->_abPadding),
				0, 2, 0))
			{
				goto Exit;
			}
			*/
			// We've claimed the packet so when we return, point to the next byte
			// after the received packet
			pNextFrame += BytesLeft;

			// Clean up our pointers
			//pBssidScanRespCount = NULL;
			pRecordCount = NULL;
			pBssidScanRespData = NULL;
			pBssidScanRespTail = NULL;

			break;

		// Set Properties Request
		case SET_PROPS_REQ:
			//pSetPropsReqCount = (CSetPropsReqCount *)(pXDashFrame + sizeof(CXDashHdr));
			pRecordCount = (CRecordCount *)(pXDashFrame + sizeof(CXDashHdr));


			// Attach the summary
			if(!AttachPropertyInstance(hFrame,
				XDashPropTable[XDASH_SUMMARY_SET_PROPS_REQ].hProperty,
				BytesLeft,
				pXDashFrame,
				0, 1, 0))
			{
				goto Exit;
			}

			// Attach the number of records
			if(!AttachPropertyInstance(hFrame,
				XDashPropTable[XDASH_NUM_RECORDS].hProperty,
				//sizeof(pSetPropsReqCount->_bNumRecords),
				//(LPBYTE) &(pSetPropsReqCount->_bNumRecords),
				sizeof(pRecordCount->_bNumRecords),
				(LPBYTE) &(pRecordCount->_bNumRecords),
				0, 2, 0))
			{
				goto Exit;
			}
			/*
			pSetPropsReqData = (CSetPropsReqData *) 
				((LPBYTE)(pSetPropsReqCount) + sizeof(CSetPropsReqCount));
			bTotal = pSetPropsReqCount->_bNumRecords;*/
			pPropertyData = (CPropertyData *) 
				((LPBYTE)(pRecordCount) + sizeof(CRecordCount));
			bTotal = pRecordCount->_bNumRecords;
			bCount = 0;
			bLength = 0;

			// Attach properties for each record specified
			while(bCount < bTotal)
			{
				// Get the variable property data length
				//bLength = pSetPropsReqData->_bPropLength;
				bLength = pPropertyData->_bPropLength;
				bStrLen = bLength;

				// Attach the record summary
				if(!AttachPropertyInstance(hFrame,
					XDashPropTable[XDASH_SUMMARY_SET_PROPS_REC].hProperty,
					//sizeof(CSetPropsReqData) + bLength,
					//pSetPropsReqData,
					sizeof(CPropertyData) + bLength,
					pPropertyData,
					0, 2, 0))
				{
					goto Exit;
				}
				
				// Attach the property id
				if(!AttachPropertyInstance(hFrame,
					XDashPropTable[XDASH_PROPERTY_ID].hProperty,
					//sizeof(pSetPropsReqData->_bPropId),
					//(LPBYTE) &(pSetPropsReqData->_bPropId),
					sizeof(pPropertyData->_bPropId),
					(LPBYTE) &(pPropertyData->_bPropId),
					0, 3, 0))
				{
					goto Exit;
				}

				// Attach the property length
				if(!AttachPropertyInstance(hFrame,
					XDashPropTable[XDASH_PROPERTY_LENGTH].hProperty,
					//sizeof(pSetPropsReqData->_bPropLength),
					//(LPBYTE) &(pSetPropsReqData->_bPropLength),
					sizeof(pPropertyData->_bPropLength),
					(LPBYTE) &(pPropertyData->_bPropLength),
					0, 3, 0))
				{
					goto Exit;
				}

				// Attach the property data summary
				if(!AttachPropertyInstance(hFrame,
					XDashPropTable[XDASH_SUMMARY_PROPERTY_DATA].hProperty,
					bLength,
					//(LPBYTE)(pSetPropsReqData) + sizeof(CSetPropsReqData),
					(LPBYTE)(pPropertyData) + sizeof(CPropertyData),
					0, 3, 0))
				{
					goto Exit;
				}

				// Attach the property data according to the property id
				switch(pPropertyData->_bPropId)
				{
				case RESET_DEFAULTS:
					// No property data, so do nothing
					break;

				case IP_ADDRESS:
					if(!AttachPropertyInstance(hFrame,
					XDashPropTable[XDASH_IP_ADDR].hProperty,
					bLength,
					//(LPBYTE)(pSetPropsReqData) + sizeof(CSetPropsReqData),
					(LPBYTE)(pPropertyData) + sizeof(CPropertyData),
					0, 4, 0))
					{
						goto Exit;
					}
					break;

				case IP_ACQ_MODE:
					if(!AttachPropertyInstance(hFrame,
					XDashPropTable[XDASH_IP_ACQ_MODE].hProperty,
					bLength,
					//(LPBYTE)(pSetPropsReqData) + sizeof(CSetPropsReqData),
					(LPBYTE)(pPropertyData) + sizeof(CPropertyData),
					0, 4, 0))
					{
						goto Exit;
					}
					break;

				case ADMIN_PASSWORD:
					if(!AttachPropertyInstance(hFrame,
					XDashPropTable[XDASH_SUMMARY_PROPERTY_DATA].hProperty,
					bLength,
					//(LPBYTE)(pSetPropsReqData) + sizeof(CSetPropsReqData),
					(LPBYTE)(pPropertyData) + sizeof(CPropertyData),
					0, 4, 0))
					{
						goto Exit;
					}					
					break;

				case NETWORK_MODE:
					if(!AttachPropertyInstance(hFrame,
					XDashPropTable[XDASH_NETWORK_MODE].hProperty,
					bLength,
					//(LPBYTE)(pSetPropsReqData) + sizeof(CSetPropsReqData),
					(LPBYTE)(pPropertyData) + sizeof(CPropertyData),
					0, 4, 0))
					{
						goto Exit;
					}
					break;

				case NETWORK_CHANNEL:
					if(!AttachPropertyInstance(hFrame,
					XDashPropTable[XDASH_NETWORK_CHANNEL].hProperty,
					bLength,
					//(LPBYTE)(pSetPropsReqData) + sizeof(CSetPropsReqData),
					(LPBYTE)(pPropertyData) + sizeof(CPropertyData),
					0, 4, 0))
					{
						goto Exit;
					}
					break;
					
				case BSSID:
					if(!AttachPropertyInstance(hFrame,
					XDashPropTable[XDASH_BSSID].hProperty,
					bLength,
					//(LPBYTE)(pSetPropsReqData) + sizeof(CSetPropsReqData),
					(LPBYTE)(pPropertyData) + sizeof(CPropertyData),
					0, 4, 0))
					{
						goto Exit;
					}
					break;					
					
				case SSID:
					if(!AttachPropertyInstance(hFrame,
					XDashPropTable[XDASH_SSID].hProperty,
					bLength,
					//(LPBYTE)(pSetPropsReqData) + sizeof(CSetPropsReqData),
					(LPBYTE)(pPropertyData) + sizeof(CPropertyData),
					0, 4, 0))
					{
						goto Exit;
					}
					break;					
					
				case AUTH_TYPE:
					if(!AttachPropertyInstance(hFrame,
					XDashPropTable[XDASH_AUTH].hProperty,
					bLength,
					//(LPBYTE)(pSetPropsReqData) + sizeof(CSetPropsReqData),
					(LPBYTE)(pPropertyData) + sizeof(CPropertyData),
					0, 4, 0))
					{
						goto Exit;
					}
					break;
					
				case ENC_TYPE:
					if(!AttachPropertyInstance(hFrame,
					XDashPropTable[XDASH_ENC].hProperty,
					bLength,
					//(LPBYTE)(pSetPropsReqData) + sizeof(CSetPropsReqData),
					(LPBYTE)(pPropertyData) + sizeof(CPropertyData),
					0, 4, 0))
					{
						goto Exit;
					}
					break;
					
				case WEP_KEY_64_1:
					if(!AttachPropertyInstance(hFrame,
					XDashPropTable[XDASH_64_WEP_KEY].hProperty,
					bLength,
					//(LPBYTE)(pSetPropsReqData) + sizeof(CSetPropsReqData),
					(LPBYTE)(pPropertyData) + sizeof(CPropertyData),
					0, 4, 0))
					{
						goto Exit;
					}
					break;
					
				case WEP_KEY_64_2:
					if(!AttachPropertyInstance(hFrame,
					XDashPropTable[XDASH_64_WEP_KEY].hProperty,
					bLength,
					//(LPBYTE)(pSetPropsReqData) + sizeof(CSetPropsReqData),
					(LPBYTE)(pPropertyData) + sizeof(CPropertyData),
					0, 4, 0))
					{
						goto Exit;
					}
					break;
					
				case WEP_KEY_64_3:
					if(!AttachPropertyInstance(hFrame,
					XDashPropTable[XDASH_64_WEP_KEY].hProperty,
					bLength,
					//(LPBYTE)(pSetPropsReqData) + sizeof(CSetPropsReqData),
					(LPBYTE)(pPropertyData) + sizeof(CPropertyData),
					0, 4, 0))
					{
						goto Exit;
					}
					break;
					
				case WEP_KEY_64_4:
					if(!AttachPropertyInstance(hFrame,
					XDashPropTable[XDASH_64_WEP_KEY].hProperty,
					bLength,
					//(LPBYTE)(pSetPropsReqData) + sizeof(CSetPropsReqData),
					(LPBYTE)(pPropertyData) + sizeof(CPropertyData),
					0, 4, 0))
					{
						goto Exit;
					}
					break;
					
				case ACTIVE_WEP_KEY_64:
					if(!AttachPropertyInstance(hFrame,
					XDashPropTable[XDASH_ACTIVE_WEP_KEY].hProperty,
					bLength,
					//(LPBYTE)(pSetPropsReqData) + sizeof(CSetPropsReqData),
					(LPBYTE)(pPropertyData) + sizeof(CPropertyData),
					0, 4, 0))
					{
						goto Exit;
					}
					break;
					
				case WEP_KEY_128:
					if(!AttachPropertyInstance(hFrame,
					XDashPropTable[XDASH_128_WEP_KEY].hProperty,
					bLength,
					//(LPBYTE)(pSetPropsReqData) + sizeof(CSetPropsReqData),
					(LPBYTE)(pPropertyData) + sizeof(CPropertyData),
					0, 4, 0))
					{
						goto Exit;
					}
					break;
					
				case NETWORK_TYPE:
					if(!AttachPropertyInstance(hFrame,
					XDashPropTable[XDASH_NETWORK_TYPE].hProperty,
					bLength,
					//(LPBYTE)(pSetPropsReqData) + sizeof(CSetPropsReqData),
					(LPBYTE)(pPropertyData) + sizeof(CPropertyData),
					0, 4, 0))
					{
						goto Exit;
					}
					break;
				}

				// Advance to the next record
				/*pSetPropsReqData = (CSetPropsReqData *)
					((LPBYTE)(pSetPropsReqData) + sizeof(CSetPropsReqData) + bLength);*/
				pPropertyData = (CPropertyData *)
					((LPBYTE)(pPropertyData) + sizeof(CPropertyData) + bLength);

				// increment count
				bCount++;			
			}
			
			//pSetPropsReqTail = (CSetPropsReqTail *)(pSetPropsReqData);
			pPaddingBytes = (CPaddingBytes *)(pPropertyData);
			/*
			// Attach the padding bytes
			if(!AttachPropertyInstance(hFrame,
				XDashPropTable[XDASH_PAD].hProperty,
				//(DWORD)(pXDashFrame + BytesLeft - (LPBYTE)(pSetPropsReqTail)),
				//(LPBYTE) &(pSetPropsReqTail->_abPadding),
				(DWORD)(pXDashFrame + BytesLeft - (LPBYTE)(pPaddingBytes)),
				(LPBYTE) &(pPaddingBytes->_abPadding),
				0, 2, 0))
			{
				goto Exit;
			}
			*/
			// We've claimed the packet so when we return, point to the next byte
			// after the received packet
			pNextFrame += BytesLeft;

			// Clean up our pointers
			//pSetPropsReqCount = NULL;
			//pSetPropsReqData = NULL;
			//pSetPropsReqTail = NULL;
			pRecordCount = NULL;
			pPropertyData = NULL;
			pPaddingBytes = NULL;

			break;

		// Set Properties Response
		case SET_PROPS_RESP:
			pSetPropsRespData = (CSetPropsRespData *)(pXDashFrame + sizeof(CXDashHdr));

			// Attach the summary
			if(!AttachPropertyInstance(hFrame,
				XDashPropTable[XDASH_SUMMARY_SET_PROPS_RESP].hProperty,
				BytesLeft,
				pXDashFrame,
				0, 1, 0))
			{
				goto Exit;
			}

			// Attach the status
			if(!AttachPropertyInstance(hFrame,
				XDashPropTable[XDASH_STATUS].hProperty,
				sizeof(pSetPropsRespData->_bStatus),
				(LPBYTE) &(pSetPropsRespData->_bStatus),
				0, 2, 0))
			{
				goto Exit;
			}
			/*
			// Attach the padding bytes
			if(!AttachPropertyInstance(hFrame,
				XDashPropTable[XDASH_PAD].hProperty,
				sizeof(pSetPropsRespData->_abPadding),
				(LPBYTE) &(pSetPropsRespData->_abPadding),
				0, 2, 0))
			{
				goto Exit;
			}
			*/
			// We've claimed the packet so when we return, point to the next byte
			// after the received packet
			pNextFrame += BytesLeft;

			// Clean up our pointers
			pSetPropsRespData = NULL;

			break;

		// Query Properties Request
		case QRY_PROPS_REQ:
			//pQryPropsReqCount = (CQryPropsReqCount *)(pXDashFrame + sizeof(CXDashHdr));
			pRecordCount = (CRecordCount *)(pXDashFrame + sizeof(CXDashHdr));

			// Attach the summary
			if(!AttachPropertyInstance(hFrame,
				XDashPropTable[XDASH_SUMMARY_QRY_PROPS_REQ].hProperty,
				BytesLeft,
				pXDashFrame,
				0, 1, 0))
			{
				goto Exit;
			}

			// Attach the number of records
			if(!AttachPropertyInstance(hFrame,
				XDashPropTable[XDASH_NUM_RECORDS].hProperty,
				//sizeof(pQryPropsReqCount->_bNumRecords),
				//(LPBYTE) &(pQryPropsReqCount->_bNumRecords),
				sizeof(pRecordCount->_bNumRecords),
				(LPBYTE) &(pRecordCount->_bNumRecords),
				0, 2, 0))
			{
				goto Exit;
			}
			/*
			pQryPropsReqData = (CQryPropsReqData *) 
				((LPBYTE)(pQryPropsReqCount) + sizeof(CQryPropsReqCount));
			bTotal = pQryPropsReqCount->_bNumRecords;*/
			pPropertyData = (CPropertyData *) 
				((LPBYTE)(pRecordCount) + sizeof(CRecordCount));
			bTotal = pRecordCount->_bNumRecords;
			bCount = 0;

			// Attach properties for each record specified
			while(bCount < bTotal)
			{
				// Attach the record summary
				if(!AttachPropertyInstance(hFrame,
					XDashPropTable[XDASH_SUMMARY_QRY_PROPS_REC].hProperty,
					//sizeof(CQryPropsReqData),
					//pSetPropsReqData,
					sizeof(CPropertyData),
					pPropertyData,
					0, 2, 0))
				{
					goto Exit;
				}
				
				// Attach the property id
				if(!AttachPropertyInstance(hFrame,
					XDashPropTable[XDASH_PROPERTY_ID].hProperty,
					//sizeof(pQryPropsReqData->_bPropId),
					//(LPBYTE) &(pQryPropsReqData->_bPropId),
					sizeof(pPropertyData->_bPropId),
					(LPBYTE) &(pPropertyData->_bPropId),
					0, 3, 0))
				{
					goto Exit;
				}

				// Attach the property length
				if(!AttachPropertyInstance(hFrame,
					XDashPropTable[XDASH_PROPERTY_LENGTH].hProperty,
					//sizeof(pQryPropsReqData->_bPropLength),
					//(LPBYTE) &(pQryPropsReqData->_bPropLength),
					sizeof(pPropertyData->_bPropLength),
					(LPBYTE) &(pPropertyData->_bPropLength),
					0, 3, 0))
				{
					goto Exit;
				}

				// Advance to the next record
			/*	pQryPropsReqData = (CQryPropsReqData *)
					((LPBYTE)(pQryPropsReqData) + sizeof(CQryPropsReqData));*/
				pPropertyData = (CPropertyData *)
					((LPBYTE)(pPropertyData) + sizeof(CPropertyData));

				// increment count
				bCount++;			
			}

			//pQryPropsReqTail = (CQryPropsReqTail *)(pQryPropsReqData);
			pPaddingBytes = (CPaddingBytes *)(pPropertyData);
			/*
			// Attach the padding bytes
			if(!AttachPropertyInstance(hFrame,
				XDashPropTable[XDASH_PAD].hProperty,
				//(DWORD)(pXDashFrame + BytesLeft - (LPBYTE)(pQryPropsReqTail)),
				//(LPBYTE) &(pQryPropsReqTail->_abPadding),
				(DWORD)(pXDashFrame + BytesLeft - (LPBYTE)(pPaddingBytes)),
				(LPBYTE) &(pPaddingBytes->_abPadding),
				0, 2, 0))
			{
				goto Exit;
			}
			*/
			// We've claimed the packet so when we return, point to the next byte
			// after the received packet
			pNextFrame += BytesLeft;

			// Clean up our pointers
			//pQryPropsReqCount = NULL;
			//pQryPropsReqData = NULL;
			//pQryPropsReqTail = NULL;
			pRecordCount = NULL;
			pPropertyData = NULL;
			pPaddingBytes = NULL;
			
			break;

		// Query Properties Response
		case QRY_PROPS_RESP:
			pQryPropsRespCount = (CQryPropsRespCount *)(pXDashFrame + sizeof(CXDashHdr));

			// Attach the summary
			if(!AttachPropertyInstance(hFrame,
				XDashPropTable[XDASH_SUMMARY_QRY_PROPS_RESP].hProperty,
				BytesLeft,
				pXDashFrame,
				0, 1, 0))
			{
				goto Exit;
			}

			// Attach the status
			if(!AttachPropertyInstance(hFrame,
				XDashPropTable[XDASH_STATUS].hProperty,
				sizeof(pQryPropsRespCount->_bStatus),
				(LPBYTE) &(pQryPropsRespCount->_bStatus),
				0, 2, 0))
			{
				goto Exit;
			}

			// Attach the number of records
			if(!AttachPropertyInstance(hFrame,
				XDashPropTable[XDASH_NUM_RECORDS].hProperty,
				sizeof(pQryPropsRespCount->_bNumRecords),
				(LPBYTE) &(pQryPropsRespCount->_bNumRecords),
				0, 2, 0))
			{
				goto Exit;
			}

		/*	pQryPropsRespData = (CQryPropsRespData *) 
				((LPBYTE)(pQryPropsRespCount) + sizeof(CQryPropsRespCount));*/
			pPropertyData = (CPropertyData *) 
				((LPBYTE)(pQryPropsRespCount) + sizeof(CQryPropsRespCount));
			bTotal = pQryPropsRespCount->_bNumRecords;
			bCount = 0;
			bLength = 0;

			// Attach properties for each record returned
			while(bCount < bTotal)
			{
				// Get the variable property data length
				//bLength = pQryPropsRespData->_bPropLength;
				bLength = pPropertyData->_bPropLength;

				// Attach the record summary
				if(!AttachPropertyInstance(hFrame,
					XDashPropTable[XDASH_SUMMARY_QRY_PROPS_REC].hProperty,
					//sizeof(CQryPropsRespData) + bLength,
					//pQryPropsRespData,
					sizeof(CPropertyData) + bLength,
					pPropertyData,
					0, 2, 0))
				{
					goto Exit;
				}
				
				// Attach the property id
				if(!AttachPropertyInstance(hFrame,
					XDashPropTable[XDASH_PROPERTY_ID].hProperty,
					//sizeof(pQryPropsRespData->_bPropId),
					//(LPBYTE) &(pQryPropsRespData->_bPropId),
					sizeof(pPropertyData->_bPropId),
					(LPBYTE) &(pPropertyData->_bPropId),
					0, 3, 0))
				{
					goto Exit;
				}

				// Attach the property length
				if(!AttachPropertyInstance(hFrame,
					XDashPropTable[XDASH_PROPERTY_LENGTH].hProperty,
					//sizeof(pQryPropsRespData->_bPropLength),
					//(LPBYTE) &(pQryPropsRespData->_bPropLength),
					sizeof(pPropertyData->_bPropLength),
					(LPBYTE) &(pPropertyData->_bPropLength),
					0, 3, 0))
				{
					goto Exit;
				}

				// Attach the property data summary
				if(!AttachPropertyInstance(hFrame,
					XDashPropTable[XDASH_SUMMARY_PROPERTY_DATA].hProperty,
					bLength,
					//(LPBYTE)(pSetPropsReqData) + sizeof(CSetPropsReqData),
					(LPBYTE)(pPropertyData) + sizeof(CPropertyData),
					0, 3, 0))
				{
					goto Exit;
				}

				// Attach the property data according to the property id
				switch(pPropertyData->_bPropId)
				{
				case RESET_DEFAULTS:
					// No property data, so do nothing
					break;

				case IP_ADDRESS:
					if(!AttachPropertyInstance(hFrame,
					XDashPropTable[XDASH_IP_ADDR].hProperty,
					bLength,
					//(LPBYTE)(pSetPropsReqData) + sizeof(CSetPropsReqData),
					(LPBYTE)(pPropertyData) + sizeof(CPropertyData),
					0, 4, 0))
					{
						goto Exit;
					}
					break;

				case IP_ACQ_MODE:
					if(!AttachPropertyInstance(hFrame,
					XDashPropTable[XDASH_IP_ACQ_MODE].hProperty,
					bLength,
					//(LPBYTE)(pSetPropsReqData) + sizeof(CSetPropsReqData),
					(LPBYTE)(pPropertyData) + sizeof(CPropertyData),
					0, 4, 0))
					{
						goto Exit;
					}
					break;

				case ADMIN_PASSWORD:
					if(!AttachPropertyInstance(hFrame,
					XDashPropTable[XDASH_SUMMARY_PROPERTY_DATA].hProperty,
					bLength,
					//(LPBYTE)(pSetPropsReqData) + sizeof(CSetPropsReqData),
					(LPBYTE)(pPropertyData) + sizeof(CPropertyData),
					0, 4, 0))
					{
						goto Exit;
					}					
					break;

				case NETWORK_MODE:
					if(!AttachPropertyInstance(hFrame,
					XDashPropTable[XDASH_NETWORK_MODE].hProperty,
					bLength,
					//(LPBYTE)(pSetPropsReqData) + sizeof(CSetPropsReqData),
					(LPBYTE)(pPropertyData) + sizeof(CPropertyData),
					0, 4, 0))
					{
						goto Exit;
					}
					break;

				case NETWORK_CHANNEL:
					if(!AttachPropertyInstance(hFrame,
					XDashPropTable[XDASH_NETWORK_CHANNEL].hProperty,
					bLength,
					//(LPBYTE)(pSetPropsReqData) + sizeof(CSetPropsReqData),
					(LPBYTE)(pPropertyData) + sizeof(CPropertyData),
					0, 4, 0))
					{
						goto Exit;
					}
					break;
					
				case BSSID:
					if(!AttachPropertyInstance(hFrame,
					XDashPropTable[XDASH_BSSID].hProperty,
					bLength,
					//(LPBYTE)(pSetPropsReqData) + sizeof(CSetPropsReqData),
					(LPBYTE)(pPropertyData) + sizeof(CPropertyData),
					0, 4, 0))
					{
						goto Exit;
					}
					break;					
					
				case SSID:
					if(!AttachPropertyInstance(hFrame,
					XDashPropTable[XDASH_SSID].hProperty,
					bLength,
					//(LPBYTE)(pSetPropsReqData) + sizeof(CSetPropsReqData),
					(LPBYTE)(pPropertyData) + sizeof(CPropertyData),
					0, 4, 0))
					{
						goto Exit;
					}
					break;					
					
				case AUTH_TYPE:
					if(!AttachPropertyInstance(hFrame,
					XDashPropTable[XDASH_AUTH].hProperty,
					bLength,
					//(LPBYTE)(pSetPropsReqData) + sizeof(CSetPropsReqData),
					(LPBYTE)(pPropertyData) + sizeof(CPropertyData),
					0, 4, 0))
					{
						goto Exit;
					}
					break;
					
				case ENC_TYPE:
					if(!AttachPropertyInstance(hFrame,
					XDashPropTable[XDASH_ENC].hProperty,
					bLength,
					//(LPBYTE)(pSetPropsReqData) + sizeof(CSetPropsReqData),
					(LPBYTE)(pPropertyData) + sizeof(CPropertyData),
					0, 4, 0))
					{
						goto Exit;
					}
					break;
					
				case WEP_KEY_64_1:
					if(!AttachPropertyInstance(hFrame,
					XDashPropTable[XDASH_64_WEP_KEY].hProperty,
					bLength,
					//(LPBYTE)(pSetPropsReqData) + sizeof(CSetPropsReqData),
					(LPBYTE)(pPropertyData) + sizeof(CPropertyData),
					0, 4, 0))
					{
						goto Exit;
					}
					break;
					
				case WEP_KEY_64_2:
					if(!AttachPropertyInstance(hFrame,
					XDashPropTable[XDASH_64_WEP_KEY].hProperty,
					bLength,
					//(LPBYTE)(pSetPropsReqData) + sizeof(CSetPropsReqData),
					(LPBYTE)(pPropertyData) + sizeof(CPropertyData),
					0, 4, 0))
					{
						goto Exit;
					}
					break;
					
				case WEP_KEY_64_3:
					if(!AttachPropertyInstance(hFrame,
					XDashPropTable[XDASH_64_WEP_KEY].hProperty,
					bLength,
					//(LPBYTE)(pSetPropsReqData) + sizeof(CSetPropsReqData),
					(LPBYTE)(pPropertyData) + sizeof(CPropertyData),
					0, 4, 0))
					{
						goto Exit;
					}
					break;
					
				case WEP_KEY_64_4:
					if(!AttachPropertyInstance(hFrame,
					XDashPropTable[XDASH_64_WEP_KEY].hProperty,
					bLength,
					//(LPBYTE)(pSetPropsReqData) + sizeof(CSetPropsReqData),
					(LPBYTE)(pPropertyData) + sizeof(CPropertyData),
					0, 4, 0))
					{
						goto Exit;
					}
					break;
					
				case ACTIVE_WEP_KEY_64:
					if(!AttachPropertyInstance(hFrame,
					XDashPropTable[XDASH_ACTIVE_WEP_KEY].hProperty,
					bLength,
					//(LPBYTE)(pSetPropsReqData) + sizeof(CSetPropsReqData),
					(LPBYTE)(pPropertyData) + sizeof(CPropertyData),
					0, 4, 0))
					{
						goto Exit;
					}
					break;
					
				case WEP_KEY_128:
					if(!AttachPropertyInstance(hFrame,
					XDashPropTable[XDASH_128_WEP_KEY].hProperty,
					bLength,
					//(LPBYTE)(pSetPropsReqData) + sizeof(CSetPropsReqData),
					(LPBYTE)(pPropertyData) + sizeof(CPropertyData),
					0, 4, 0))
					{
						goto Exit;
					}
					break;
					
				case NETWORK_TYPE:
					if(!AttachPropertyInstance(hFrame,
					XDashPropTable[XDASH_NETWORK_TYPE].hProperty,
					bLength,
					//(LPBYTE)(pSetPropsReqData) + sizeof(CSetPropsReqData),
					(LPBYTE)(pPropertyData) + sizeof(CPropertyData),
					0, 4, 0))
					{
						goto Exit;
					}
					break;
				}

				// Advance to the next record
			/*	pQryPropsRespData = (CQryPropsRespData *)
					((LPBYTE)(pQryPropsRespData) + sizeof(CQryPropsRespData) + bLength);*/
				pPropertyData = (CPropertyData *)
					((LPBYTE)(pPropertyData) + sizeof(CPropertyData) + bLength);

				// increment count
				bCount++;			
			}
			
			//pQryPropsRespTail = (CQryPropsRespTail *)(pQryPropsRespData);
			pPaddingBytes = (CPaddingBytes *)(pPropertyData);
			/*
			// Attach the padding bytes
			if(!AttachPropertyInstance(hFrame,
				XDashPropTable[XDASH_PAD].hProperty,
				//(DWORD)(pXDashFrame + BytesLeft - (LPBYTE)(pQryPropsRespTail)),
				//(LPBYTE) &(pQryPropsRespTail->_abPadding),
				(DWORD)(pXDashFrame + BytesLeft - (LPBYTE)(pPaddingBytes)),
				(LPBYTE) &(pPaddingBytes->_abPadding),
				0, 2, 0))
			{
				goto Exit;
			}
			*/
			// We've claimed the packet so when we return, point to the next byte
			// after the received packet
			pNextFrame += BytesLeft;

			// Clean up our pointers
			pQryPropsRespCount = NULL;
			//pQryPropsRespData = NULL;
			//pQryPropsRespTail = NULL;
			pPropertyData = NULL;
			pPaddingBytes = NULL;

			break;

		// Query Connection Status Request
		case QRY_CXN_REQ:

			// Attach the summary
			if(!AttachPropertyInstance(hFrame,
				XDashPropTable[XDASH_SUMMARY_QRY_CXN_REQ].hProperty,
				BytesLeft,
				pXDashFrame,
				0, 1, 0))
			{
				goto Exit;
			}
			
			// We've claimed the packet so when we return, point to the next byte
			// after the received packet
			pNextFrame += BytesLeft;
			break;

		// Query Connection Status Response
		case QRY_CXN_RESP:
			pQryCxnRespData = (CQryCxnRespData *)(pXDashFrame + sizeof(CXDashHdr));

			// Attach the summary
			if(!AttachPropertyInstance(hFrame,
				XDashPropTable[XDASH_SUMMARY_QRY_CXN_RESP].hProperty,
				BytesLeft,
				pXDashFrame,
				0, 1, 0))
			{
				goto Exit;
			}

			// Attach the connection status
			if(!AttachPropertyInstance(hFrame,
				XDashPropTable[XDASH_CXN_STATUS].hProperty,
				sizeof(pQryCxnRespData->_bCxnStatus),
				(LPBYTE) &(pQryCxnRespData->_bCxnStatus),
				0, 2, 0))
			{
				goto Exit;
			}

			// Attach the RSSI
			if(!AttachPropertyInstance(hFrame,
				XDashPropTable[XDASH_RSSI].hProperty,
				sizeof(pQryCxnRespData->_bRssi),
				(LPBYTE) &(pQryCxnRespData->_bRssi),
				0, 2, 0))
			{
				goto Exit;
			}

			// Attach the data rate
			if(!AttachPropertyInstance(hFrame,
				XDashPropTable[XDASH_RATE].hProperty,
				sizeof(pQryCxnRespData->_bRate),
				(LPBYTE) &(pQryCxnRespData->_bRate),
				0, 2, 0))
			{
				goto Exit;
			}
			/*
			// Attach the padding byte
			if(!AttachPropertyInstance(hFrame,
				XDashPropTable[XDASH_PAD].hProperty,
				sizeof(pQryCxnRespData->_bPadding),
				(LPBYTE) &(pQryCxnRespData->_bPadding),
				0, 2, 0))
			{
				goto Exit;
			}
			*/
			// We've claimed the packet so when we return, point to the next byte
			// after the received packet
			pNextFrame += BytesLeft;
			break;

			// Clean up our pointers
			pQryCxnRespData = NULL;

		// Unknown packet type
		default:
			goto Exit;
		}

Exit:
	return pNextFrame;
}
	
//==================================================================================
// XDash_FormatProperties
//----------------------------------------------------------------------------------
//
// Description: Called by Netmon to format each property that was attached by
//	XDash_AttachProperties
//
// Arguments:
//	HFRAME			hFrame			Handle to the frame that is being parsed.
//	LPBYTE			pMacFrame		Pointer to the first byte of a frame.
//	LPBYTE			pXDashFrame		Pointer to the beginning of the protocol data in a frame.
//	DWORD			nPropertyInsts	Number of PROPERTYINST structures provided by lpPropInst. 
//	LPPROPERTYINST	p				Pointer to an array of PROPERTYINST structures. 
//
// Returns: TRUE on successful formatting of all properties, FALSE otherwise
//==================================================================================
DWORD WINAPI XDash_FormatProperties(HFRAME          hFrame,
									LPBYTE          pMacFrame,
									LPBYTE          pXSPFrame,
									DWORD           nPropertyInsts,
									LPPROPERTYINST  p)
{
    // Loop through the property instances
    while( nPropertyInsts-- > 0)
    {
        // Call the formatter for each
        ((FORMAT)(p->lpPropertyInfo->InstanceData))(p);
        p++;
    }
	
    return NMERR_SUCCESS;
}

//==================================================================================
// XDash_FormatDiscoveryReqSummary
//
// Description: The custom formatter for the summary property
//==================================================================================
VOID WINAPIV XDash_FormatDiscoveryReqSummary(LPPROPERTYINST pPropertyInst)
{
	LPSTR pReturnedString = pPropertyInst->szPropertyText;

	strcpy(pReturnedString, "Discovery Request");
}

//==================================================================================
// XDash_FormatDiscoveryRespSummary
//
// Description: The custom formatter for the summary property
//==================================================================================
VOID WINAPIV XDash_FormatDiscoveryRespSummary(LPPROPERTYINST pPropertyInst)
{
	LPSTR pReturnedString = pPropertyInst->szPropertyText;

	strcpy(pReturnedString, "Discovery Response");
}

//==================================================================================
// XDash_FormatBssidScanReqSummary
//
// Description: The custom formatter for the summary property
//==================================================================================
VOID WINAPIV XDash_FormatBssidScanReqSummary(LPPROPERTYINST pPropertyInst)
{
	LPSTR pReturnedString = pPropertyInst->szPropertyText;

	strcpy(pReturnedString, "BSSID Scan Request");
}

//==================================================================================
// XDash_FormatBssidScanRespSummary
//
// Description: The custom formatter for the summary property
//==================================================================================
VOID WINAPIV XDash_FormatBssidScanRespSummary(LPPROPERTYINST pPropertyInst)
{
	LPSTR pReturnedString = pPropertyInst->szPropertyText;

	strcpy(pReturnedString, "BSSID Scan Response");
}

//==================================================================================
// XDash_FormatBssidScanRecSummary
//
// Description: The custom formatter for the summary property
//==================================================================================
VOID WINAPIV XDash_FormatBssidScanRecSummary(LPPROPERTYINST pPropertyInst)
{
	LPSTR pReturnedString = pPropertyInst->szPropertyText;

	strcpy(pReturnedString, "BSSID Scan Record");
}

//==================================================================================
// XDash_FormatSetPropsReqSummary
//
// Description: The custom formatter for the summary property
//==================================================================================
VOID WINAPIV XDash_FormatSetPropsReqSummary(LPPROPERTYINST pPropertyInst)
{
	LPSTR pReturnedString = pPropertyInst->szPropertyText;

	strcpy(pReturnedString, "Set Properties Request");
}

//==================================================================================
// XDash_FormatSetPropsRespSummary
//
// Description: The custom formatter for the summary property
//==================================================================================
VOID WINAPIV XDash_FormatSetPropsRespSummary(LPPROPERTYINST pPropertyInst)
{
	LPSTR pReturnedString = pPropertyInst->szPropertyText;

	strcpy(pReturnedString, "Set Properties Response");
}

//==================================================================================
// XDash_FormatSetPropsRecSummary
//
// Description: The custom formatter for the summary property
//==================================================================================
VOID WINAPIV XDash_FormatSetPropsRecSummary(LPPROPERTYINST pPropertyInst)
{
	LPSTR pReturnedString = pPropertyInst->szPropertyText;

	strcpy(pReturnedString, "Set Properties Record");
}

//==================================================================================
// XDash_FormatQryPropsReqSummary
//
// Description: The custom formatter for the summary property
//==================================================================================
VOID WINAPIV XDash_FormatQryPropsReqSummary(LPPROPERTYINST pPropertyInst)
{
	LPSTR pReturnedString = pPropertyInst->szPropertyText;

	strcpy(pReturnedString, "Query Properties Request");
}

//==================================================================================
// XDash_FormatQryPropsRespSummary
//
// Description: The custom formatter for the summary property
//==================================================================================
VOID WINAPIV XDash_FormatQryPropsRespSummary(LPPROPERTYINST pPropertyInst)
{
	LPSTR pReturnedString = pPropertyInst->szPropertyText;

	strcpy(pReturnedString, "Query Properties Response");
}

//==================================================================================
// XDash_FormatQryPropsRecSummary
//
// Description: The custom formatter for the summary property
//==================================================================================
VOID WINAPIV XDash_FormatQryPropsRecSummary(LPPROPERTYINST pPropertyInst)
{
	LPSTR pReturnedString = pPropertyInst->szPropertyText;

	strcpy(pReturnedString, "Query Properties Record");
}

//==================================================================================
// XDash_FormatQryCxnReqSummary
//
// Description: The custom formatter for the summary property
//==================================================================================
VOID WINAPIV XDash_FormatQryCxnReqSummary(LPPROPERTYINST pPropertyInst)
{
	LPSTR pReturnedString = pPropertyInst->szPropertyText;

	strcpy(pReturnedString, "Query Connection Status Request");
}

//==================================================================================
// XDash_FormatQryCxnRespSummary
//
// Description: The custom formatter for the summary property
//==================================================================================
VOID WINAPIV XDash_FormatQryCxnRespSummary(LPPROPERTYINST pPropertyInst)
{
	LPSTR pReturnedString = pPropertyInst->szPropertyText;

	strcpy(pReturnedString, "Query Connection Status Response");
}

//==================================================================================
// XDash_FormatPropertyDataSummary
//
// Description: The custom formatter for the summary property
//==================================================================================
VOID WINAPIV XDash_FormatPropertyDataSummary(LPPROPERTYINST pPropertyInst)
{
	LPSTR pReturnedString = pPropertyInst->szPropertyText;

	strcpy(pReturnedString, "Property Data");
}

//==================================================================================
// XDash_FormatNonce
//
// Description: The custom formatter for the nonce
//==================================================================================
VOID WINAPIV XDash_FormatNonce(LPPROPERTYINST pPropertyInst)
{
	LPSTR pReturnedString = pPropertyInst->szPropertyText;

	CHAR *pbNonce = (CHAR *)(pPropertyInst->lpData);

	strcpy(pReturnedString, "Nonce = ");
	strcat(pReturnedString, pbNonce);
}

//==================================================================================
// XDash_FormatCopyright
//
// Description: The custom formatter for the copyright string
//==================================================================================
VOID WINAPIV XDash_FormatCopyright(LPPROPERTYINST pPropertyInst)
{
	LPSTR pReturnedString = pPropertyInst->szPropertyText;
	CHAR *szCopyright = (CHAR *)(pPropertyInst->lpData);

	strcpy(pReturnedString, "Copyright String = ");
	memcpy(pReturnedString+19, szCopyright, 55);
	memset(pReturnedString+19+55, 46, 3);
	memset(pReturnedString+19+55+3, 0, 1);
}

//==================================================================================
// XDash_FormatDevice
//
// Description: The custom formatter for the device name
//==================================================================================
VOID WINAPIV XDash_FormatDevice(LPPROPERTYINST pPropertyInst)
{
	LPSTR pReturnedString = pPropertyInst->szPropertyText;
	CHAR *szDevice = (CHAR *)(pPropertyInst->lpData);

	strcpy(pReturnedString, "Device Name = ");
	strcat(pReturnedString, szDevice);
}

//==================================================================================
// XDash_FormatFirmware
//
// Description: The custom formatter for the device name
//==================================================================================
VOID WINAPIV XDash_FormatFirmware(LPPROPERTYINST pPropertyInst)
{
	LPSTR pReturnedString = pPropertyInst->szPropertyText;
	CHAR *szFirmware = (CHAR *)(pPropertyInst->lpData);
	
	strcpy(pReturnedString, "Firmware Version = ");
	strcat(pReturnedString, szFirmware);
}

//==================================================================================
// XDash_FormatSsidLength
//
// Description: The custom formatter for the SSID length
//==================================================================================
VOID WINAPIV XDash_FormatSsidLength(LPPROPERTYINST pPropertyInst)
{
	LPSTR pReturnedString = pPropertyInst->szPropertyText;

	BYTE *pbLength = (BYTE *)(pPropertyInst->lpData);

	char acBuffer[4];
	strcpy(pReturnedString, "SSID Length = ");
	_itoa(*pbLength, acBuffer, 10);
	strcat(pReturnedString, acBuffer);
	strcat(pReturnedString, " byte(s)");
	
}

//==================================================================================
// XDash_FormatSsidString
//
// Description: The custom formatter for the SSID string
//==================================================================================
VOID WINAPIV XDash_FormatSsidString(LPPROPERTYINST pPropertyInst)
{
	LPSTR pReturnedString = pPropertyInst->szPropertyText;
	CHAR *szSsid = (CHAR *)(pPropertyInst->lpData);

	strcpy(pReturnedString, "SSID String = ");
	strcat(pReturnedString, szSsid);
}

//==================================================================================
// XDash_FormatAuthTypes
//
// Description: The custom formatter for supported authentication types
//==================================================================================
VOID WINAPIV XDash_FormatAuthTypes(LPPROPERTYINST pPropertyInst)
{
	LPSTR pReturnedString = pPropertyInst->szPropertyText;

	BYTE *pbAuth = (BYTE *)(pPropertyInst->lpData);

	BYTE bCount = 0;

	strcpy(pReturnedString, "Supported Authentication Types = ");

	if(*pbAuth & 0x02)
	{
		strcat(pReturnedString, "Open");
		bCount++;
	}

	if(*pbAuth & 0x04)
	{
		if(bCount > 0)
		{
			strcat(pReturnedString, ", ");
		}
		strcat(pReturnedString, "Shared");
		bCount++;
	}

	if(*pbAuth & 0x10)
	{
		if(bCount > 0)
		{
			strcat(pReturnedString, ", ");
		}
		strcat(pReturnedString, "WPA-PSK");
		bCount++;
	}

	if(*pbAuth & 0x20)
	{
		if(bCount > 0)
		{
			strcat(pReturnedString, ", ");
		}
		strcat(pReturnedString, "WPA-NONE");
		bCount++;
	}

	if(bCount == 0)
	{
		strcat(pReturnedString, "No information");
	}
}

//==================================================================================
// XDash_FormatEncTypes
//
// Description: The custom formatter for supported encryption types
//==================================================================================
VOID WINAPIV XDash_FormatEncTypes(LPPROPERTYINST pPropertyInst)
{
	LPSTR pReturnedString = pPropertyInst->szPropertyText;

	BYTE *pbEnc = (BYTE *)(pPropertyInst->lpData);

	BYTE bCount = 0;

	strcpy(pReturnedString, "Supported Encryption Types = ");

	if(*pbEnc & 0x01)
	{
		strcat(pReturnedString, "None");
		bCount++;
	}

	if(*pbEnc & 0x02)
	{
		if(bCount > 0)
		{
			strcat(pReturnedString, ", ");
		}
		strcat(pReturnedString, "64-bit WEP");
		bCount++;
	}

	if(*pbEnc & 0x04)
	{
		if(bCount > 0)
		{
			strcat(pReturnedString, ", ");
		}
		strcat(pReturnedString, "128-bit WEP");
		bCount++;
	}

	if(*pbEnc & 0x08)
	{
		if(bCount > 0)
		{
			strcat(pReturnedString, ", ");
		}
		strcat(pReturnedString, "TKIP");
		bCount++;
	}

	if(*pbEnc & 0x10)
	{
		if(bCount > 0)
		{
			strcat(pReturnedString, ", ");
		}
		strcat(pReturnedString, "AES(WRAP)");
		bCount++;
	}

	if(*pbEnc & 0x20)
	{
		if(bCount > 0)
		{
			strcat(pReturnedString, ", ");
		}
		strcat(pReturnedString, "AES(CCMP)");
		bCount++;
	}

	if(bCount == 0)
	{
		strcat(pReturnedString, "No information");
	}
}

//==================================================================================
// XDash_FormatNetTypes
//
// Description: The custom formatter for supported network types
//==================================================================================
VOID WINAPIV XDash_FormatNetTypes(LPPROPERTYINST pPropertyInst)
{
	LPSTR pReturnedString = pPropertyInst->szPropertyText;

	BYTE *pbNet = (BYTE *)(pPropertyInst->lpData);

	BYTE bCount = 0;

	strcpy(pReturnedString, "Supported Network Types = ");

	if(*pbNet & 0x01)
	{
		strcat(pReturnedString, "802.11b");
		bCount++;
	}

	if(*pbNet & 0x02)
	{
		if(bCount > 0)
		{
			strcat(pReturnedString, ", ");
		}
		strcat(pReturnedString, "802.11a");
		bCount++;
	}

	if(*pbNet & 0x04)
	{
		if(bCount > 0)
		{
			strcat(pReturnedString, ", ");
		}
		strcat(pReturnedString, "802.11g");
		bCount++;
	}

	if(bCount == 0)
	{
		strcat(pReturnedString, "No information");
	}
}

//==================================================================================
// XDash_FormatIpAcqMode
//
// Description: The custom formatter for IP acquisition mode
//==================================================================================
VOID WINAPIV XDash_FormatIpAcqMode(LPPROPERTYINST pPropertyInst)
{
	LPSTR pReturnedString = pPropertyInst->szPropertyText;

	BYTE *pbIpAcq = (BYTE *)(pPropertyInst->lpData);

	strcpy(pReturnedString, "IP Acquisition Mode = ");

	switch(*pbIpAcq)
	{
	case 0x00:
		strcat(pReturnedString, "DHCP");
		break;
	case 0x01:
		strcat(pReturnedString, "AutoIP");
		break;
	case 0x02:
		strcat(pReturnedString, "Static");
		break;
	default:
		strcat(pReturnedString, "No information");
		break;
	}
}

//==================================================================================
// XDash_FormatCfgStatus
//
// Description: The custom formatter for configuration status
//==================================================================================
VOID WINAPIV XDash_FormatCfgStatus(LPPROPERTYINST pPropertyInst)
{
	LPSTR pReturnedString = pPropertyInst->szPropertyText;

	BYTE *pbCfg = (BYTE *)(pPropertyInst->lpData);

	strcpy(pReturnedString, "Configuration Status = ");

	switch(*pbCfg)
	{
	case 0x00:
		strcat(pReturnedString, "Factory default");
		break;
	case 0x01:
		strcat(pReturnedString, "Not factory default");
		break;
	default:
		strcat(pReturnedString, "No information");
		break;
	}
}

//==================================================================================
// XDash_FormatCxnStatus
//
// Description: The custom formatter for connection status
//==================================================================================
VOID WINAPIV XDash_FormatCxnStatus(LPPROPERTYINST pPropertyInst)
{
	LPSTR pReturnedString = pPropertyInst->szPropertyText;

	BYTE *pbCxn = (BYTE *)(pPropertyInst->lpData);

	strcpy(pReturnedString, "Connection Status = ");

	switch(*pbCxn)
	{
	case 0x00:
		strcat(pReturnedString, "Connected");
		break;
	case 0x01:
		strcat(pReturnedString, "Security error");
		break;
	case 0x02:
		strcat(pReturnedString, "Not connected");
		break;
	case 0x03:
		strcat(pReturnedString, "Pending");
		break;
	default:
		strcat(pReturnedString, "No information");
		break;
	}
}

//==================================================================================
// XDash_FormatMode
//
// Description: The custom formatter for the network mode
//==================================================================================
VOID WINAPIV XDash_FormatMode(LPPROPERTYINST pPropertyInst)
{
	LPSTR pReturnedString = pPropertyInst->szPropertyText;

	BYTE *pbMode = (BYTE *)(pPropertyInst->lpData);

	strcpy(pReturnedString, "Network Mode = ");

	switch(*pbMode)
	{
	case 0x00:
		strcat(pReturnedString, "Ad-hoc");
		break;
	case 0x01:
		strcat(pReturnedString, "Infrastructure");
		break;
	default:
		strcat(pReturnedString, "No information");
		break;
	}
}

//==================================================================================
// XDash_FormatChannel
//
// Description: The custom formatter for the network channel
//==================================================================================
VOID WINAPIV XDash_FormatChannel(LPPROPERTYINST pPropertyInst)
{
	LPSTR pReturnedString = pPropertyInst->szPropertyText;

	BYTE *pbChannel = (BYTE *)(pPropertyInst->lpData);

	char acBuffer[4];
	strcpy(pReturnedString, "Network Channel = ");
	_itoa(*pbChannel, acBuffer, 10);
	strcat(pReturnedString, acBuffer);
}

//==================================================================================
// XDash_FormatNetwork
//
// Description: The custom formatter for the network type
//==================================================================================
VOID WINAPIV XDash_FormatNetwork(LPPROPERTYINST pPropertyInst)
{
	LPSTR pReturnedString = pPropertyInst->szPropertyText;

	BYTE *pbNet = (BYTE *)(pPropertyInst->lpData);

	strcpy(pReturnedString, "Network Type = ");

	switch(*pbNet)
	{
	case 0x00:
		strcat(pReturnedString, "802.11b");
		break;
	case 0x01:
		strcat(pReturnedString, "802.11a");
		break;
	case 0x02:
		strcat(pReturnedString, "802.11g");
		break;
	default:
		strcat(pReturnedString, "No information");
		break;
	}
}

//==================================================================================
// XDash_FormatAuthentication
//
// Description: The custom formatter for the authentication property
//==================================================================================
VOID WINAPIV XDash_FormatAuthentication(LPPROPERTYINST pPropertyInst)
{
	LPSTR pReturnedString = pPropertyInst->szPropertyText;

	BYTE *pbAuth = (BYTE *)(pPropertyInst->lpData);

	BYTE bCount = 0;

	strcpy(pReturnedString, "Authentication Setting = ");

	if(*pbAuth & 0x02)
	{
		strcat(pReturnedString, "Open");
		bCount++;
	}

	if(*pbAuth & 0x04)
	{
		if(bCount > 0)
		{
			strcat(pReturnedString, ", ");
		}
		strcat(pReturnedString, "Shared");
		bCount++;
	}

	if(*pbAuth & 0x10)
	{
		if(bCount > 0)
		{
			strcat(pReturnedString, ", ");
		}
		strcat(pReturnedString, "WPA-PSK");
		bCount++;
	}

	if(*pbAuth & 0x20)
	{
		if(bCount > 0)
		{
			strcat(pReturnedString, ", ");
		}
		strcat(pReturnedString, "WPA-NONE");
		bCount++;
	}

	if(bCount == 0)
	{
		strcat(pReturnedString, "No information");
	}
}

//==================================================================================
// XDash_FormatEncryption
//
// Description: The custom formatter for the encryption property
//==================================================================================
VOID WINAPIV XDash_FormatEncryption(LPPROPERTYINST pPropertyInst)
{
	LPSTR pReturnedString = pPropertyInst->szPropertyText;

	BYTE *pbEnc = (BYTE *)(pPropertyInst->lpData);

	BYTE bCount = 0;

	strcpy(pReturnedString, "Encryption Setting = ");

	if(*pbEnc & 0x01)
	{
		strcat(pReturnedString, "No encryption");
		bCount++;
	}

	if(*pbEnc & 0x02)
	{
		if(bCount > 0)
		{
			strcat(pReturnedString, ", ");
		}
		strcat(pReturnedString, "64-bit WEP");
		bCount++;
	}

	if(*pbEnc & 0x04)
	{
		if(bCount > 0)
		{
			strcat(pReturnedString, ", ");
		}
		strcat(pReturnedString, "128-bit WEP");
		bCount++;
	}

	if(*pbEnc & 0x08)
	{
		if(bCount > 0)
		{
			strcat(pReturnedString, ", ");
		}
		strcat(pReturnedString, "TKIP");
		bCount++;
	}

	if(*pbEnc & 0x10)
	{
		if(bCount > 0)
		{
			strcat(pReturnedString, ", ");
		}
		strcat(pReturnedString, "AES(WRAP)");
		bCount++;
	}

	if(*pbEnc & 0x20)
	{
		if(bCount > 0)
		{
			strcat(pReturnedString, ", ");
		}
		strcat(pReturnedString, "AES(CCMP)");
		bCount++;
	}

	if(bCount == 0)
	{
		strcat(pReturnedString, "No information");
	}
}

//==================================================================================
// XDash_FormatRssi
//
// Description: The custom formatter for the RSSI
//==================================================================================
VOID WINAPIV XDash_FormatRssi(LPPROPERTYINST pPropertyInst)
{
	LPSTR pReturnedString = pPropertyInst->szPropertyText;

	BYTE *pbRssi = (BYTE *)(pPropertyInst->lpData);

	char acBuffer[4];
	strcpy(pReturnedString, "RSSI = ");
	_itoa(*pbRssi, acBuffer, 10);
	strcat(pReturnedString, acBuffer);
	strcat(pReturnedString, " dBm");
}

//==================================================================================
// XDash_FormatDataRates
//
// Description: The custom formatter for supported data rates
//==================================================================================
VOID WINAPIV XDash_FormatDataRates(LPPROPERTYINST pPropertyInst)
{
	LPSTR pReturnedString = pPropertyInst->szPropertyText;

	BYTE *pbRates = (BYTE *)(pPropertyInst->lpData);

	BYTE bCount = 0;
	char acBuffer[4];
	strcpy(pReturnedString, "Supported Data Rates =");

	while(*pbRates)
	{
		if(bCount > 0)
		{
			strcat(pReturnedString, ",");
		}
		strcat(pReturnedString, " ");
		_itoa(*pbRates/2, acBuffer, 10);
		strcat(pReturnedString, acBuffer);
		
		bCount++;
		pbRates++;
	}

	strcat(pReturnedString, " Mbps");
}

//==================================================================================
// XDash_FormatStatus
//
// Description: The custom formatter for status
//==================================================================================
VOID WINAPIV XDash_FormatStatus(LPPROPERTYINST pPropertyInst)
{
	LPSTR pReturnedString = pPropertyInst->szPropertyText;

	BYTE *pbStatus = (BYTE *)(pPropertyInst->lpData);

	strcpy(pReturnedString, "Status = ");

	switch(*pbStatus)
	{
	case 0x00:
		strcat(pReturnedString, "Success");
		break;
	case 0x01:
		strcat(pReturnedString, "Request malformed");
		break;
	case 0x02:
		strcat(pReturnedString, "Temporary error");
		break;
	case 0x03:
		strcat(pReturnedString, "Fatal error");
		break;
	case 0x04:
		strcat(pReturnedString, "Not supported");
		break;
	default:
		strcat(pReturnedString, "No information");
		break;
	}
}

//==================================================================================
// XDash_FormatRate
//
// Description: The custom formatter for the data rate
//==================================================================================
VOID WINAPIV XDash_FormatRate(LPPROPERTYINST pPropertyInst)
{
	LPSTR pReturnedString = pPropertyInst->szPropertyText;

	BYTE *pbRate = (BYTE *)(pPropertyInst->lpData);

	char acBuffer[4];
	strcpy(pReturnedString, "Data Rate = ");
	_itoa(*pbRate/2, acBuffer, 10);
	strcat(pReturnedString, acBuffer);
	strcat(pReturnedString, " Mbps");
}

//==================================================================================
// XDash_FormatSsid
//
// Description: The custom formatter for the SSID
//==================================================================================
VOID WINAPIV XDash_FormatSsid(LPPROPERTYINST pPropertyInst)
{
	LPSTR pReturnedString = pPropertyInst->szPropertyText;
	CHAR *szSsid = (CHAR *)(pPropertyInst->lpData);
	CHAR *szHead = "SSID = ";

	strcpy(pReturnedString, szHead);
	memcpy(pReturnedString + strlen(szHead), szSsid, pPropertyInst->DataLength);
	memset(pReturnedString + strlen(szHead) + pPropertyInst->DataLength, 0, 1);
}

//==================================================================================
// XDash_FormatPassword
//
// Description: The custom formatter for the admin password
//==================================================================================
VOID WINAPIV XDash_FormatPassword(LPPROPERTYINST pPropertyInst)
{
	LPSTR pReturnedString = pPropertyInst->szPropertyText;
	CHAR *szPass = (CHAR *)(pPropertyInst->lpData);
	CHAR *szHead = "Admin Password = ";

	strcpy(pReturnedString, szHead);
	memcpy(pReturnedString + strlen(szHead), szPass, pPropertyInst->DataLength);
	memcpy(pReturnedString + strlen(szHead) + pPropertyInst->DataLength, 0, 1);
}

//==================================================================================
// XDash_FormatActiveWepKey
//
// Description: The custom formatter for the active WEP key number
//==================================================================================
VOID WINAPIV XDash_FormatActiveWepKey(LPPROPERTYINST pPropertyInst)
{
	LPSTR pReturnedString = pPropertyInst->szPropertyText;

	BYTE *pbActive = (BYTE *)(pPropertyInst->lpData);

	char acBuffer[4];
	strcpy(pReturnedString, "Active Key for 64 bit WEP = ");
	_itoa(*pbActive, acBuffer, 10);
	strcat(pReturnedString, acBuffer);
}

//==================================================================================
// XDash_FormatPropertyId
//
// Description: The custom formatter for the property id
//==================================================================================
VOID WINAPIV XDash_FormatPropertyId(LPPROPERTYINST pPropertyInst)
{
	LPSTR pReturnedString = pPropertyInst->szPropertyText;

	BYTE *pbPropId = (BYTE *)(pPropertyInst->lpData);

	strcpy(pReturnedString, "Property ID = ");

	switch(*pbPropId)
	{
	case RESET_DEFAULTS:
		strcat(pReturnedString, "Reset to Defaults");
		break;
	case IP_ADDRESS:
		strcat(pReturnedString, "IP Address");
		break;
	case IP_ACQ_MODE:
		strcat(pReturnedString, "IP Acquisition Mode");
		break;
	case ADMIN_PASSWORD:
		strcat(pReturnedString, "Admin Password");
		break;
	case NETWORK_MODE:
		strcat(pReturnedString, "Network Mode");
		break;
	case NETWORK_CHANNEL:
		strcat(pReturnedString, "Network Channel");
		break;
	case BSSID:
		strcat(pReturnedString, "BSSID");
		break;
	case SSID:
		strcat(pReturnedString, "SSID");
		break;
	case AUTH_TYPE:
		strcat(pReturnedString, "Authentication Type");
		break;
	case ENC_TYPE:
		strcat(pReturnedString, "Encryption Type");
		break;
	case WEP_KEY_64_1:
		strcat(pReturnedString, "64 bit WEP Key 1");
		break;
	case WEP_KEY_64_2:
		strcat(pReturnedString, "64 bit WEP Key 2");
		break;
	case WEP_KEY_64_3:
		strcat(pReturnedString, "64 bit WEP Key 3");
		break;
	case WEP_KEY_64_4:
		strcat(pReturnedString, "64 bit WEP Key 4");
		break;
	case ACTIVE_WEP_KEY_64:
		strcat(pReturnedString, "Active Key for 64 bit WEP");
		break;
	case WEP_KEY_128:
		strcat(pReturnedString, "128 bit WEP Key");
		break;
	case NETWORK_TYPE:
		strcat(pReturnedString, "Network Type");
		break;
	}
}

//==================================================================================
// XDash_FormatPropertyLength
//
// Description: The custom formatter for the property length
//==================================================================================
VOID WINAPIV XDash_FormatPropertyLength(LPPROPERTYINST pPropertyInst)
{
	LPSTR pReturnedString = pPropertyInst->szPropertyText;

	BYTE *pbLength = (BYTE *)(pPropertyInst->lpData);

	char acBuffer[4];
	strcpy(pReturnedString, "Property Length = ");
	_itoa(*pbLength, acBuffer, 10);
	strcat(pReturnedString, acBuffer);
	strcat(pReturnedString, " byte(s)");
	
}

//==================================================================================
// XDash_FormatNumRecords
//
// Description: The custom formatter for the number of records
//==================================================================================
VOID WINAPIV XDash_FormatNumRecords(LPPROPERTYINST pPropertyInst)
{
	LPSTR pReturnedString = pPropertyInst->szPropertyText;

	BYTE *pbNum = (BYTE *)(pPropertyInst->lpData);

	char acBuffer[4];
	strcpy(pReturnedString, "Number of Records = ");
	_itoa(*pbNum, acBuffer, 10);
	strcat(pReturnedString, acBuffer);
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\parsers\xdashparse\stdafx.cpp ===
// stdafx.cpp : source file that includes just the standard includes
// xdashparse.pch will be the pre-compiled header
// stdafx.obj will contain the pre-compiled type information

#include "stdafx.h"

// TODO: reference any additional headers you need in STDAFX.H
// and not in this file
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\parsers\capfileconvert\capfileconvert.cpp ===
// Convert Xbox capture file from raw format to Netmon format
#pragma once

#include <stdio.h>
#include <string.h>
#include <netmon.h>

#include "DynCaptureFile.h"

#define BUFSIZE 1024
#define HDROFFSET 8

FRAME nfNewFrame;

DWORD GetDwordFromHex(BYTE* pbHexValue)
{
	DWORD dwRes = 0;

	BYTE bByte0, bByte1, bByte2, bByte3;
	DWORD dwTemp1, dwTemp2, dwTemp3;

	if(pbHexValue == NULL)
	{
		printf("Hex Value is NULL\n");
		goto Exit;
	}

	// get individual byte values in little-endian order
	bByte0 = *pbHexValue;
	bByte1 = *(pbHexValue+1);
	bByte2 = *(pbHexValue+2);
	bByte3 = *(pbHexValue+3);

	// convert from little-endian to big-endian by shifting higher-order bits
	dwTemp1 = bByte1 << 8;
	dwTemp2 = bByte2 << 16;
	dwTemp3 = bByte3 << 24;

	// get total decimal value
	dwRes = bByte0 + dwTemp1 + dwTemp2 + dwTemp3;

Exit:
	return dwRes;
}

BOOL ConvertCapFile(char* pszInFile, char* pszOutFile)
{
	BOOL bRes = FALSE;

	CDynCaptureFile* pcfNetmonFile;
	FILE* fpXboxFile;
	BYTE abFrameBytes[BUFSIZE];	
	DWORD dwTotalBytes, dwCurrBytes;
	DWORD dwTimeStamp, dwCurrTime = 0;
	HRESULT hr;
	
	if(pszInFile == NULL)
	{
		printf("Error: No input filename provided\n");
		goto Exit;
	}

	// create Netmon capture file object
	pcfNetmonFile = new CDynCaptureFile();
	if(pcfNetmonFile == NULL)
	{
		printf("Error creating capture file object\n");
		goto Exit;
	}

	// open input file
	fpXboxFile = fopen(pszInFile, "rb");
	if(fpXboxFile == NULL)
	{
		printf("Error opening input file %s\n", pszInFile);
		goto Exit;
	}

	// check if an output filename is provided
	// if not, derive one from input filename
	if(pszOutFile == NULL)
	{
		char acOutFile[BUFSIZE];
		ZeroMemory(acOutFile, BUFSIZE);
		strcpy(acOutFile, pszInFile);

		// raw capture files have suffix ".dat", want Netmon file to be ".cap"
		char* pDest;
		int iPos;

		// look for '.' character
		pDest = strchr(acOutFile, '.');
		iPos = pDest - acOutFile + 1;

		// replace suffix
		acOutFile[iPos] = '\0';
		strcat(acOutFile, "cap");

		pszOutFile = acOutFile;
	}

	// open output file
	hr = pcfNetmonFile->Open(pszOutFile);
	if(FAILED(hr))
	{
		printf("Error opening output file %s\n", pszOutFile);
		goto Exit;
	}

	// parse each raw frame and put it in Netmon capture
	while(!feof(fpXboxFile))
	{
		// reset everything
		ZeroMemory(abFrameBytes, BUFSIZE);
		dwTotalBytes = dwTimeStamp = 0;

		// fetch header bytes first
		for(int iPos = 0; iPos < HDROFFSET; iPos++)
		{
			abFrameBytes[iPos] = (BYTE)fgetc(fpXboxFile);
		}

		// get number of bytes in this frame
		// bytes 1-4 represent size of frame in bytes
		dwTotalBytes = GetDwordFromHex(abFrameBytes);
		if(dwTotalBytes == 0)
		{
			printf("Error: frame size = 0\n");
			goto Exit;
		}

		// hack to detect end of file -- EOF character not recognized in binary mode
		// don't expect any packets to be > 1024 bytes, so when we start
		// getting a bunch of bytes with value FF we must be at the end
		if(dwTotalBytes > BUFSIZE)
			break;

		// get relative timestamp of this frame
		// bytes 5-8 represent millisecond delta of frame
		dwTimeStamp = GetDwordFromHex(&abFrameBytes[4]);
		if(dwTimeStamp == 0)
		{
			printf("Error: time stamp = 0\n");
			goto Exit;
		}

		// fetch remaining data bytes
		for(dwCurrBytes = 0; dwCurrBytes < dwTotalBytes; dwCurrBytes++)
		{
			// we already have the header bytes, so skip over them
			if(dwCurrBytes >= HDROFFSET)
				abFrameBytes[dwCurrBytes] = (BYTE)fgetc(fpXboxFile);

			// print frame contents prettily on screen
			printf("%02X ", abFrameBytes[dwCurrBytes]);

			if(dwCurrBytes % 8 == 7)
				printf(" ");

			if(dwCurrBytes % 16 == 15)
				printf("\n");
		}
		printf("\nEND OF FRAME\n");

		// update current time
		dwCurrTime += dwTimeStamp;

		// create frame structure in NetMon format
		ZeroMemory(&nfNewFrame, sizeof(FRAME));
		nfNewFrame.TimeStamp = dwCurrTime;
		nfNewFrame.FrameLength = dwTotalBytes - HDROFFSET;
		nfNewFrame.nBytesAvail = dwTotalBytes - HDROFFSET;
		memcpy(nfNewFrame.MacFrame, &abFrameBytes[HDROFFSET], dwTotalBytes - HDROFFSET);

		// add frame to NetMon capture
		hr = pcfNetmonFile->SaveFrame((BYTE*)&nfNewFrame);
		if(FAILED(hr))
		{
			printf("Error saving frame to capture file %s\n", pszOutFile);
			goto Exit;
		}
	}

	// close output file
	hr = pcfNetmonFile->Close();
	if(FAILED(hr))
	{
		printf("Error closing output file %s\n", pszOutFile);
		goto Exit;
	}

	// reaching here means we parsed everything successfully and created a good NetMon file
	printf("Done converting capture file to NetMon format\n");
	bRes = TRUE;

Exit:
	printf("Exiting...\n");

	// cleanup
	if(fclose(fpXboxFile))
		printf("Error closing input file %s\n", pszInFile);

	if(pcfNetmonFile)
		delete pcfNetmonFile;

	return bRes;
}

int __cdecl main(int argc, char* argv[])
{
	if(argc < 2 || argc > 3)
	{
		printf("Usage: capfileconvert <inFileName> [outFileName]\n");
		return -1;
	}

	if(argc == 2)
	{
		ConvertCapFile(argv[1], NULL);
	}

	else
	{
		ConvertCapFile(argv[1], argv[2]);
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\parsers\capfileconvert\dyncapturefile.cpp ===
//-----------------------------------------------------------------------------
//  Microsoft (R) XWireTap (tm). 
//  Copyright (C) 2002. All rights reserved.
//
//  FILE: CaptureFile.cpp
//
//  Interface for NetMon Capture file writer.
//-----------------------------------------------------------------------------

//-----------------------------------------------------------------------------
// Includes
//-----------------------------------------------------------------------------
#include "StdAfx.h"
#include "dyncapturefile.h"
#include <netmon.h>

//-----------------------------------------------------------------------------
// Definitions
//-----------------------------------------------------------------------------
#define DEFAULT_READ_SIZE				128
#define MAX_PERMITTED_FILESIZE			2000000000

//-----------------------------------------------------------------------------
// CDynCaptureFile
//-----------------------------------------------------------------------------

CDynCaptureFile::CDynCaptureFile(void)
{
    SYSTEMTIME stStartTime;

    // initialize all variables to some default.
    m_CapFileHandle = INVALID_HANDLE_VALUE;
    m_FrameTableFileHandle = INVALID_HANDLE_VALUE;

    m_dwCurFileSize = 0;
    m_dwMaxFileSize = 0;
    m_dwFileOffset = 0;

    m_szCapFileName = NULL;    
    m_szDumpFileName = NULL;    

    // set up the capture file header.
    ZeroMemory( &m_objCFHeader, sizeof(CAPTUREFILE_HEADER_VALUES) );
    ZeroMemory( &m_objFrameTable, sizeof(FRAMETABLE) );
    
    // todo:  (lohab) make this non static
    m_objCFHeader.Signature   =  NETMON_2_0_CAPTUREFILE_SIGNATURE;
    m_objCFHeader.BCDVerMinor =  CAPTUREFILE_VERSION_MINOR;
    m_objCFHeader.BCDVerMajor =  CAPTUREFILE_VERSION_MAJOR;
    m_objCFHeader.MacType     =  MAC_TYPE_ETHERNET;

    // set the start time.
    GetSystemTime( &stStartTime );
    memcpy( (LPVOID)&(m_objCFHeader.TimeStamp),   
            (LPVOID)&(stStartTime),
            sizeof(SYSTEMTIME));

    m_bIsComplete = NULL;

}

CDynCaptureFile::~CDynCaptureFile(void)
{
    // ensure the file is closed.
    if ( !m_bIsComplete )
    {
        Close();
    }

    // clear the file name
    if ( m_szCapFileName != NULL )
    {
        delete[] m_szCapFileName;
        m_szCapFileName = NULL;
    }

    if ( m_szDumpFileName != NULL )
    {
        delete[] m_szDumpFileName;
        m_szDumpFileName = NULL;
    }

}

// -------------------------------------------------
//  Open:  Opens a capture file of a fixed size.
// -------------------------------------------------
HRESULT CDynCaptureFile::Open( char *szFilename, DWORD dwFileSize )
{
    HRESULT hr = S_OK;
    
    hr = Open( szFilename );
    if ( FAILED(hr) )
    {
        goto Exit;
    }
    m_dwMaxFileSize = dwFileSize;

Exit:
    return hr;
}

// -------------------------------------------------
//  Open:  Opens a file of variable size.
// -------------------------------------------------
HRESULT CDynCaptureFile::Open( char *szFilename )
{
    HRESULT hr = S_OK;
    int nFileNameSize = 0;
    DWORD dwBytesWritten = 0;

    // ensure the file has not already been opened.
    if ( m_szCapFileName != NULL && m_CapFileHandle != INVALID_HANDLE_VALUE )
    {
        hr = E_CAPFILE_ALREADY_OPEN;
        goto Exit;
    }

    XOMASSERT( szFilename !=  NULL );

    // get the size of the file name
    nFileNameSize = strlen( szFilename );
    m_szCapFileName = new char[ nFileNameSize + 1];
    ZeroMemory( m_szCapFileName, nFileNameSize + 1 );
    memcpy( m_szCapFileName, szFilename, nFileNameSize * sizeof(char) );

    m_szDumpFileName = new char[ nFileNameSize + 1];
    ZeroMemory( m_szDumpFileName, nFileNameSize + 1 );
    memcpy( m_szDumpFileName, szFilename, nFileNameSize * sizeof(char) );
    memcpy( (m_szDumpFileName + nFileNameSize - 3), "dmp", 3 );
    
    m_dwMaxFileSize = MAX_PERMITTED_FILESIZE;

    // open the capture file
    m_CapFileHandle = CreateFileA( 
                            m_szCapFileName, 
                            GENERIC_WRITE, 
                            0, 
                            NULL,
                            CREATE_ALWAYS,
                            FILE_ATTRIBUTE_NORMAL,
                            NULL);
    if ( INVALID_HANDLE_VALUE == m_CapFileHandle )
    {
        delete[] m_szCapFileName;
        delete[] m_szDumpFileName;
        hr = MAKE_HRESULT( 1, FACILITY_WIN32, GetLastError());
        goto Exit;
    }

    // open the dump file for the file table.
    m_FrameTableFileHandle = CreateFileA(
                            m_szDumpFileName, 
                            GENERIC_WRITE | GENERIC_READ, 
                            0, 
                            NULL,
                            CREATE_ALWAYS,
                            FILE_ATTRIBUTE_NORMAL,
                            NULL);
    if ( INVALID_HANDLE_VALUE == m_FrameTableFileHandle )
    {
        CloseHandle( m_CapFileHandle );
        delete[] m_szCapFileName;
        delete[] m_szDumpFileName;
        hr = MAKE_HRESULT( 1, FACILITY_WIN32, GetLastError() );
        goto Exit;
    }

    // write the empty header to the file.
    if (! WriteFile( m_CapFileHandle, (LPCVOID)&m_objCFHeader, CAPTURE_FILE_HEADER_SIZE, &dwBytesWritten, NULL ) )
    {
        CloseHandle( m_CapFileHandle );
        CloseHandle( m_FrameTableFileHandle );
        delete[] m_szCapFileName;
        delete[] m_szDumpFileName;
        hr = MAKE_HRESULT( 1, FACILITY_WIN32, GetLastError() );
        goto Exit;
    }

    // set file offsets
    m_bIsComplete = FALSE;
    m_dwCurFileSize = CAPTURE_FILE_HEADER_SIZE + sizeof(FRAMETABLE);
    m_dwFileOffset = CAPTURE_FILE_HEADER_SIZE;

Exit:
    return hr;
}

// -------------------------------------------------
//  Close:  Closes the file.  Building the final
//      capture file.
// -------------------------------------------------
HRESULT CDynCaptureFile::Close()
{
    HRESULT hr = S_OK;
    DWORD dwBytesWritten = 0;
    DWORD dwBytesRead = 0;
    DWORD dwFrameDescriptorOffset = 0;
    DWORD dwRes = 0;                    // temp pointer for setfilepointer result.
    BYTE  bytBuffer[128];               // used to read values from dump file.

    // ensure we should be here.
    if ( m_bIsComplete )
    {
        hr = E_CAPFILE_ALREADY_COMPLETE;
        goto Exit;
    }

    XOMASSERT( m_CapFileHandle != INVALID_HANDLE_VALUE );
    XOMASSERT( m_FrameTableFileHandle != INVALID_HANDLE_VALUE );

    // modify the flag.
    m_bIsComplete = TRUE;

    // set teh file pointer of the dump file back to the beginning.
    dwRes = SetFilePointer( m_FrameTableFileHandle, (-1 * m_objFrameTable.FrameCount * sizeof(DWORD)), NULL, FILE_CURRENT );
    if ( dwRes == INVALID_SET_FILE_POINTER )
    {
        // ok... all hell has broken loose... may God have mercy on us all.
        hr = MAKE_HRESULT( 1, FACILITY_WIN32, GetLastError() );
        goto Exit;    
    }

    // move the dump file into 
    while ( TRUE )
    {
        BOOL bIsEOF = FALSE;
        // read 128 bytes from the file.
        if ( !ReadFile( m_FrameTableFileHandle, bytBuffer, DEFAULT_READ_SIZE, &dwBytesRead, NULL ) )
        {
            if ( GetLastError() == ERROR_HANDLE_EOF )
            {
                bIsEOF = TRUE;
            }
            else
            {
                // ok... all hell has broken loose... may God have mercy on us all.
                hr = MAKE_HRESULT( 1, FACILITY_WIN32, GetLastError() );
                goto Exit;    
            }
        }

        // write to the end of the capture file
        if (! WriteFile( m_CapFileHandle, (LPCVOID)bytBuffer, dwBytesRead, &dwBytesWritten, NULL ) )
        {
            hr = MAKE_HRESULT( 1, FACILITY_WIN32, GetLastError() );
            goto Exit;
        }
    
        // see if we've read all the data.
        if ( bIsEOF || dwBytesRead == 0 )
        {
            break;
        }
    }
    
    // destroy the dump file. NOTE:  This is not an important action. Do not fail on error.
    CloseHandle( m_FrameTableFileHandle );
    DeleteFileA( m_szDumpFileName );

    // clean up offset values.
    m_objCFHeader.FrameTableLength = m_objFrameTable.FrameCount * sizeof(DWORD);
    m_objCFHeader.FrameTableOffset = m_dwFileOffset;

    // move the file pointer for the capture file.
    dwRes = SetFilePointer( m_CapFileHandle, 0, NULL, FILE_BEGIN );
    if ( dwRes == INVALID_SET_FILE_POINTER )
    {
        // ok... all hell has broken loose... may God have mercy on us all.
        hr = MAKE_HRESULT( 1, FACILITY_WIN32, GetLastError() );
        goto Exit;    
    }

    // re-write the file header.
    if (! WriteFile( m_CapFileHandle, (LPCVOID)&m_objCFHeader, sizeof(CAPTUREFILE_HEADER_VALUES), &dwBytesWritten, NULL ) )
    {
        hr = MAKE_HRESULT( 1, FACILITY_WIN32, GetLastError() );
        goto Exit;
    }

    CloseHandle( m_CapFileHandle );

Exit:
    return hr;
}

// -------------------------------------------------
//  SaveFrame:  Saves a frame to the capture file 
//   the file offsets to the frame table dump file.
// -------------------------------------------------
HRESULT CDynCaptureFile::SaveFrame( BYTE *pBytFrame )
{
    FRAME *pFrame = (FRAME*)pBytFrame;
    HRESULT hr = S_OK;
    DWORD dwCurOffset = 0;
    DWORD dwDataSize = 0;
    DWORD dwBytesWritten = 0;

    // ensure we should be here.
    if ( m_bIsComplete )
    {
        hr = E_CAPFILE_ALREADY_COMPLETE;
        goto Exit;
    }

    XOMASSERT( m_CapFileHandle != INVALID_HANDLE_VALUE );
    XOMASSERT( m_FrameTableFileHandle != INVALID_HANDLE_VALUE );
    XOMASSERT( pBytFrame != NULL );

    // calculate the byte offset.
    dwCurOffset = m_dwFileOffset;

    // re-calculate the offset after this frame.
    dwDataSize = sizeof(FRAME) + pFrame->FrameLength ;

    // ensure the capfile is not full. 
    if ( dwDataSize + sizeof(DWORD) + m_dwCurFileSize > m_dwMaxFileSize )
    {
        hr = E_CAPFILE_FULL;
        goto Exit;
    }

    // write to the capture file.
    if (! WriteFile( m_CapFileHandle, (LPCVOID)pBytFrame, dwDataSize, &dwBytesWritten, NULL ) )
    {
        hr = MAKE_HRESULT( 1, FACILITY_WIN32, GetLastError() );
        goto Exit;
    }
    
    if ( dwBytesWritten != dwDataSize )
    {
        hr = MAKE_HRESULT( 1, FACILITY_WIN32, GetLastError() );
        goto Exit;    
    }
    
    // set the offsets.
    m_dwFileOffset = m_dwFileOffset + dwBytesWritten;
    m_dwCurFileSize =  m_dwCurFileSize + dwBytesWritten;

    // write to the dump file.
    if (! WriteFile( m_FrameTableFileHandle, (LPCVOID)&dwCurOffset, sizeof(DWORD), &dwBytesWritten, NULL ) )
    {
        hr = MAKE_HRESULT( 1, FACILITY_WIN32, GetLastError() );
        goto Exit;
    }

    // ensure we've written the entire offset to this file or roll it back.
    if ( dwBytesWritten != sizeof(DWORD) )
    {
        DWORD dwRes;

        // re-set the file pointer
        dwRes = SetFilePointer( m_FrameTableFileHandle, -1 * dwBytesWritten, NULL, FILE_CURRENT );
        if ( dwRes == INVALID_SET_FILE_POINTER )
        {
            // ok... all hell has broken loose... may God have mercy on us all.
            hr = MAKE_HRESULT( 1, FACILITY_WIN32, GetLastError() );
            goto Exit;    
        }
    }

    m_objFrameTable.FrameCount++;
    m_objFrameTable.FrameTableLength = m_objFrameTable.FrameCount * sizeof(DWORD);
    m_dwCurFileSize =  m_dwCurFileSize + dwBytesWritten;

    // todo: (lohab) Make a rollback feature to remove entry from capture file if any file write fails.

Exit:
    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\parsers\xlinkparse\StdAfx.cpp ===
// stdafx.cpp : source file that includes just the standard includes
//	xlinkparse.pch will be the pre-compiled header
//	stdafx.obj will contain the pre-compiled type information

#include "stdafx.h"

// TODO: reference any additional headers you need in STDAFX.H
// and not in this file
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\parsers\xlinkparse\StdAfx.h ===
// stdafx.h : include file for standard system include files,
//  or project specific include files that are used frequently, but
//      are changed infrequently
//

#if !defined(AFX_STDAFX_H__C15C4F82_F7AB_45CC_A1A4_62DB039E61F7__INCLUDED_)
#define AFX_STDAFX_H__C15C4F82_F7AB_45CC_A1A4_62DB039E61F7__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000


// Insert your headers here
//#define WIN32_LEAN_AND_MEAN		// Exclude rarely-used stuff from Windows headers

#include <winsockx.h>
#include <windows.h>
#include <netmon.h>
#include <stdio.h>
#include <xonlinep.h>

// TODO: reference additional headers your program requires here

//{{AFX_INSERT_LOCATION}}
// Microsoft Visual C++ will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_STDAFX_H__C15C4F82_F7AB_45CC_A1A4_62DB039E61F7__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\parsers\xlinkparse\obj\i386\_asmid.inc ===
ASSEMBLY_IDENTITY_KEY_FORM=x86_xlinkparse_none_12.4.56.0_none_78d3c417dd7b0caf
ASSEMBLY_IDENTITY_XP_KEY_FORM=x86_xlinkparse_no-public-key_12.4.56.0_x-ww_0d097c37
ASSEMBLY_IDENTITY_CULTURE=
ASSEMBLY_IDENTITY_NAME=xlinkparse
ASSEMBLY_IDENTITY_PROCESSOR_ARCHITECTURE=x86
ASSEMBLY_IDENTITY_PUBLIC_KEY=
ASSEMBLY_IDENTITY_PUBLIC_KEY_TOKEN=
ASSEMBLY_IDENTITY_TYPE=
ASSEMBLY_IDENTITY_TYPE_NAME=
ASSEMBLY_IDENTITY_VERSION=12.4.56.0
XP_KEY_FORM=x86_xlinkparse_no-public-key_12.4.56.0_x-ww_0d097c37
XP_MANIFEST_DIRECTORY=manifests
XP_MANIFEST_NAME=x86_xlinkparse_no-public-key_12.4.56.0_x-ww_0d097c37.manifest
XP_MANIFEST_PATH=manifests\x86_xlinkparse_no-public-key_12.4.56.0_x-ww_0d097c37.manifest
XP_CATALOG_DIRECTORY=manifests
XP_CATALOG_NAME=x86_xlinkparse_no-public-key_12.4.56.0_x-ww_0d097c37.cat
XP_CATALOG_PATH=manifests\x86_xlinkparse_no-public-key_12.4.56.0_x-ww_0d097c37.cat
XP_PAYLOAD_PATH=x86_xlinkparse_no-public-key_12.4.56.0_x-ww_0d097c37
_DELAY_SIGN=0
!if [set _ASMIDTOATTRIBS_TLBIMP=]
!endif
CODESIGN_TESTKEY=
_TLBIMP_FLAGS=$(_TLBIMP_FLAGS)  /asmversion:12.4.56.0
_ASSEMBLY_IDENTITY=xlinkparse,processorArchitecture=x86,version=12.4.56.0,publicKeyToken=neutral
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\parsers\xlinkparse\xlinkparse.cpp ===
//============================================================================
//  FILE: xlinkparse.c
//
//  Description: Contains parsers for all Xbox key exchange and IP sec protocols
//     XSP - Xbox Security Protocols
//
//============================================================================

#include "stdafx.h"

//==================================================================================
// Globals
//==================================================================================
HPROTOCOL hXSP = NULL;
DWORD     Attached = 0;

#define XC_DIGEST_LEN             20
#define XC_SERVICE_DIGEST_SIZE    XC_DIGEST_LEN
#define CBDHG1 96

#define HTONL_(ul) \
    ((ULONG)((((ul) >> 24) & 0x000000FFL) | (((ul) >>  8) & 0x0000FF00L) | \
(((ul) <<  8) & 0x00FF0000L) | (((ul) << 24))))

#define NTOHL_(ul) HTONL_(ul)

#define HTONS_(us) \
((USHORT)((((us) >> 8) & 0x00FF) | (((us) << 8) & 0xFF00)))

#define NTOHS_(us) HTONS_(us)

INLINE ULONG  HTONL(ULONG  ul) { return(HTONL_(ul)); }
INLINE ULONG  NTOHL(ULONG  ul) { return(NTOHL_(ul)); }
INLINE USHORT HTONS(USHORT us) { return(HTONS_(us)); }
INLINE USHORT NTOHS(USHORT us) { return(NTOHS_(us)); }

#define TCP_FIN 0x01
#define TCP_SYN 0x02
#define TCP_RST 0x04
#define TCP_PSH 0x08
#define TCP_ACK 0x10
#define TCP_URG 0x20

#pragma pack(push, 1) // one byte packing for all wire structures



struct CEnetAddr
{
    BYTE _ab[6];

    INLINE BOOL IsEqual(const CEnetAddr & ea) const { return(memcmp(_ab, ea._ab, sizeof(_ab)) == 0); }
    INLINE BOOL IsEqual(const BYTE * pb) const { return(memcmp(_ab, pb, sizeof(_ab)) == 0); }
    INLINE void SetBroadcast()                { *(DWORD *)&_ab[0] = 0xFFFFFFFF; *(WORD *)&_ab[4] = 0xFFFF; }
    INLINE void SetMulticast(const BYTE * pb) { _ab[0] = 0x01; _ab[1] = 0x00; _ab[2] = 0x5E; _ab[3] = pb[1] & 0x7F; _ab[4] = pb[2]; _ab[5] = pb[3]; }
    INLINE void SetZero()                     { *(DWORD *)&_ab[0] = 0x00000000; *(WORD *)&_ab[4] = 0x0000; }
    INLINE BOOL IsBroadcast() const           { return(*(DWORD *)&_ab[0] == 0xFFFFFFFF && *(WORD *)&_ab[4] == 0xFFFF); }
    INLINE BOOL IsMulticast() const           { return((_ab[0] & 1) != 0); }
    INLINE BOOL IsZero() const                { return(*(DWORD *)&_ab[0] == 0 && *(WORD *)&_ab[4] == 0); }
    char * Str() const;
};

// ---------------------------------------------------------------------------------------
// CIpAddr
// ---------------------------------------------------------------------------------------

struct CIpAddr
{
    union
    {
        BYTE        _ab[4];
        DWORD       _dw;
    };
	
#define IPADDR_BROADCAST            CIpAddr(HTONL(0xFFFFFFFF))
#define IPADDR_LOOPBACK             CIpAddr(HTONL(0x7F000001))
#define IPADDR_CLASSA_NETMASK       CIpAddr(HTONL(0xFF000000))
#define IPADDR_CLASSB_NETMASK       CIpAddr(HTONL(0xFFFF0000))
#define IPADDR_CLASSC_NETMASK       CIpAddr(HTONL(0xFFFFFF00))
#define IPADDR_CLASSD_NETMASK       CIpAddr(HTONL(0xF0000000))
#define IPADDR_CLASSD_NETID         CIpAddr(HTONL(0xE0000000))
#define IPADDR_LOOPBACK_NETID       CIpAddr(HTONL(0x7F000000))
	
    INLINE operator DWORD () const { return(_dw); }
    INLINE DWORD operator = (DWORD & dw) { return(_dw = dw); }
    INLINE CIpAddr(DWORD dw) { _dw = dw; }
    INLINE CIpAddr() {}
	
    INLINE BOOL IsBroadcast() const { return(_dw == IPADDR_BROADCAST); }
    INLINE BOOL IsMulticast() const { return(IsClassD() && !IsBroadcast()); }
    INLINE BOOL IsLoopback() const { return((_dw & IPADDR_CLASSA_NETMASK) == IPADDR_LOOPBACK_NETID); }
    INLINE BOOL IsClassA() const { return((_dw & HTONL(0x80000000)) == HTONL(0x00000000)); }
    INLINE BOOL IsClassB() const { return((_dw & HTONL(0xC0000000)) == HTONL(0x80000000)); }
    INLINE BOOL IsClassC() const { return((_dw & HTONL(0xE0000000)) == HTONL(0xC0000000)); }
    INLINE BOOL IsClassD() const { return((_dw & HTONL(0xF0000000)) == HTONL(0xE0000000)); }
    INLINE BOOL IsValidMask() const { DWORD dw = ~NTOHL(_dw); return((dw & (dw + 1)) == 0); }
	BOOL IsValidAddr() const;
    char * Str() const;
};

// ---------------------------------------------------------------------------------------
// CIpPort
// ---------------------------------------------------------------------------------------

struct CIpPort
{
    WORD            _w;
	
    INLINE operator WORD () { return (_w); }
    INLINE WORD operator = (WORD & w) { return(_w = w); }
    INLINE CIpPort(WORD w) { _w = w; }
    INLINE CIpPort() {}
};

struct CEnetHdr
{
    CEnetAddr       _eaDst;
    CEnetAddr       _eaSrc;
    WORD            _wType;
};

struct CIpHdr
{
    BYTE            _bVerHdr;       // Version & header length
    BYTE            _bTos;          // Type of service
    WORD            _wLen;          // Total length including IP header
    WORD            _wId;           // Identification
    WORD            _wFragOff;      // Flags and fragment offset
    BYTE            _bTtl;          // Time to live
    BYTE            _bProtocol;     // Protocol
    WORD            _wChecksum;     // Header checksum
    CIpAddr         _ipaSrc;        // Source address
    CIpAddr         _ipaDst;        // Destination address
};

struct CUdpHdr
{
    CIpPort         _ipportSrc;     // Source port
    CIpPort         _ipportDst;     // Destination port
    WORD            _wLen;          // Datagram length including UDP header
    WORD            _wChecksum;     // Datagram checksum
};

struct CXspHdr : public CUdpHdr
{
    // Definitions -----------------------------------------------------------------------
	
#define XSP_TYPE_SEC            0           // Packet is in SecMsg format
#define XSP_TYPE_TCP_0          1           // Packet is in TCP format (0 byte ports)
#define XSP_TYPE_TCP_1          2           // Packet is in TCP format (1 byte ports)
#define XSP_TYPE_TCP_2          3           // Packet is in TCP format (2 byte ports)
#define XSP_TYPE_UDP_0          4           // Packet is in UDP format (0 byte ports)
#define XSP_TYPE_UDP_1          5           // Packet is in UDP format (1 byte ports)
#define XSP_TYPE_UDP_2          6           // Packet is in UDP format (2 byte ports)
#define XSP_TYPE_VDP_0          7           // Packet is in VDP format (0 byte ports)
#define XSP_TYPE_VDP_1          8           // Packet is in VDP format (1 byte ports)
#define XSP_TYPE_VDP_2          9           // Packet is in VDP format (2 byte ports)
#define XSP_TYPE_VDP_VO_0       10          // Packet is in VDP voice-only format (0 byte ports)
#define XSP_TYPE_VDP_VO_1       11          // Packet is in VDP voice-only format (1 byte ports)
#define XSP_TYPE_VDP_VO_2       12          // Packet is in VDP voice-only format (2 byte ports)
#define XSP_TYPE_VDP_DO_0       13          // Packet is in VDP data-only format (0 byte ports)
#define XSP_TYPE_VDP_DO_1       14          // Packet is in VDP data-only format (1 byte ports)
#define XSP_TYPE_VDP_DO_2       15          // Packet is in VDP data-only format (2 byte ports)
#define XSP_TYPE_MAX            15          // Highest packet type defined
#define XSP_TYPE_MASK           0x1F        // Packet type mask
#define XSP_DATPAD_MASK         0xE0        // Payload padding in bytes
#define XSP_DATPAD_SHIFT        5           // How far left to shift payload padding
	
#define XSP_SPI_MASK            0xFFFFFF00  // SPI occupies the top 24 bits
#define XSP_FLAGS_MASK          0x000000FF  // Flags occupies the low 8 bits
	
    // Data ------------------------------------------------------------------------------
	
    union {
        BYTE        _bFlags;                    // See XSP_* above
        DWORD       _dwSpiAndFlags;             // SPI and bFlags
    };
};

struct CXspTail
{
    WORD        _wSeqLo;                    // Low word of sequence number
    union {
        struct {
            WORD    _wSeqHi;                // High word of sequence number (not transmitted)
            DWORD   _dwSpiAndFlags;         // Copy of _dwSpiAndFlags from CXspHdr
            DWORD   _dwZero;                // Zero for making tail 4 byte multiple
        };
        BYTE    _abHash[10];                // HMAC-SHA digest
    };
};

#define QPF_PAIR_TWO            0x01    // This is the second packet of the pair
#define QPF_DATA_REQ            0x02    // This is a Qos data request only
#define QPF_DATA_REP            0x04    // This ia a Qos data reply only
#define QPF_DATA_NONE           0x08    // The host has no Qos data (sent in probe response)
#define QPF_DISABLED            0x10    // This host has disabled its Qos listener

struct CKeyExQosInit : public CKeyExHdr
{
	WORD            _wVersion;          // KEYEX_VERSION
	BYTE            _abNonce[8];        // Nonce assigned by the initiator
	WORD            _wQosIdx;           // Index assigned by the initiator
	BYTE            _bPktIdx;           // Packet sequence number
	BYTE            _bFlags;            // See QOF_* flags
	XNKID           _xnkid;             // key identifier of key-exchange-key
	XNADDR          _xnaddr;            // XNADDR of the responder
	BYTE            _abHash[12];        // HMAC-SHA-1-96 digest of this message (including header)
};

struct CKeyExQosResp : public CKeyExHdr
{
	WORD            _wVersion;          // KEYEX_VERSION
	BYTE            _abNonce[8];        // Nonce assigned by the initiator
	WORD            _wQosIdx;           // Index assigned by the initiator
	BYTE            _bPktIdx;           // Packet sequence number
	BYTE            _bFlags;            // See QOF_* flags
	DWORD           _dwusRtt;           // Time between recv/xmit of pkt in microseconds
	DWORD           _dwusGap;           // Time between recv of pkt1 and pkt2 (less traffic) in microseconds
	BYTE            _bPadLen;           // Padding included in the Qos data for DES alignment
	BYTE            _abHash[12];        // HMAC-SHA-1-96 digest of this message (including header and Qos Data)
	
	// The rest of this entry contains the Qos data (if QPF_DATA_REP)
	
};

struct CKeyExXbToXb : public CKeyExHdr
{
	WORD            _wVersion;          // KEYEX_VERSION
	WORD            _wFlags;            // Reserved
	XNKID           _xnkid;             // key identifier of key-exchange-key
	DWORD           _dwSpiInit;         // SPI of the initiator
	DWORD           _dwSpiResp;         // SPI of the responder
	BYTE            _abNonceInit[8];    // Nonce of the initiator
	BYTE            _abNonceResp[8];    // Nonce of the responder
	LARGE_INTEGER   _liTime;            // Increasing time-value of the sender
	BYTE            _abIv[8];           // Initialization vector for DES encryption
	XNADDR          _xnaddrInit;        // XNADDR of the initiator (encrypted)
	XNADDR          _xnaddrResp;        // XNADDR of the responder (encrypted)
};

struct CKeyExNatOpen : public CKeyExHdr
{
	// Definitions -------------------------------------------------------------------
	
#define KNOF_XBTOXB_KEYEX   0x0001  // Request occuring for key exchange
#define KNOF_XBTOXB_QOS     0x0002  // Request occuring for qos probe
	
	// Data --------------------------------------------------------------------------
	
	WORD            _wVersion;          // KEYEX_VERSION
	WORD            _wFlags;            // See KNOF_* above
	XNKID           _xnkid;             // key identifier of key-exhcange-key
	BYTE            _abNonce[8];        // Nonce from the sender
	DWORD           _dwCtx;             // Context identifier from the sender
	CIpAddr         _ipaDst;            // IP address of the sender
	CIpPort         _ipportDst;         // IP port of the sender
	BYTE            _abHash[12];        // HMAC-SHA-1-96 digest of this message (including header)
};

struct CKeyExDHGX : public CKeyExHdr
{
    BYTE            _ab[CBDHG1];
};

#pragma pack(pop)

//==================================================================================
// Functions
//==================================================================================
extern PPF_PARSERDLLINFO WINAPI ParserAutoInstallInfo();

// Functions for Xbox Security Protocol
extern VOID   WINAPI XSP_Register(HPROTOCOL hXSP);
extern VOID   WINAPI XSP_Deregister(HPROTOCOL hXSP);
extern LPBYTE WINAPI XSP_RecognizeFrame(HFRAME hFrame, 
                                        LPBYTE pMacFrame, 
                                        LPBYTE pXSPFrame, 
                                        DWORD MacType, 
                                        DWORD BytesLeft, 
                                        HPROTOCOL hPrevProtocol, 
                                        DWORD nPrevProtOffset,
                                        LPDWORD pProtocolStatus,
                                        LPHPROTOCOL phNextProtocol, 
                                        LPDWORD InstData);
extern LPBYTE WINAPI XSP_AttachProperties(HFRAME hFrame, 
                                          LPBYTE pMacFrame, 
                                          LPBYTE pXSPFrame, 
                                          DWORD MacType, 
                                          DWORD BytesLeft, 
                                          HPROTOCOL hPrevProtocol, 
                                          DWORD nPrevProtOffset,
                                          DWORD InstData);
extern DWORD  WINAPI XSP_FormatProperties(HFRAME hFrame, 
                                          LPBYTE pMacFrame, 
                                          LPBYTE pXSPFrame, 
                                          DWORD nPropertyInsts, 
                                          LPPROPERTYINST p);
VOID WINAPIV XSP_FormatX2XOnlineInitSummary( LPPROPERTYINST pPropertyInst);
VOID WINAPIV XSP_FormatX2XOnlineRespSummary( LPPROPERTYINST pPropertyInst);
VOID WINAPIV XSP_FormatX2XSystemLinkInitSummary( LPPROPERTYINST pPropertyInst);
VOID WINAPIV XSP_FormatX2XSystemLinkRespSummary( LPPROPERTYINST pPropertyInst);
VOID WINAPIV XSP_FormatX2SOnlineInitSummary( LPPROPERTYINST pPropertyInst);
VOID WINAPIV XSP_FormatS2XOnlineRespSummary( LPPROPERTYINST pPropertyInst);
VOID WINAPIV XSP_FormatX2TOnlineInitSummary( LPPROPERTYINST pPropertyInst);
VOID WINAPIV XSP_FormatT2XOnlineRespSummary( LPPROPERTYINST pPropertyInst);
VOID WINAPIV XSP_FormatNatOpenInitSummary( LPPROPERTYINST pPropertyInst);
VOID WINAPIV XSP_FormatNatOpenRespSummary( LPPROPERTYINST pPropertyInst);
VOID WINAPIV XSP_FormatQOSInitSummary( LPPROPERTYINST pPropertyInst);
VOID WINAPIV XSP_FormatQOSRespSummary( LPPROPERTYINST pPropertyInst);
VOID WINAPIV XSP_FormatXSPEncapSummary( LPPROPERTYINST pPropertyInst);
VOID WINAPIV XSP_FormatKeyExType( LPPROPERTYINST pPropertyInst);
VOID WINAPIV XSP_FormatXNKID( LPPROPERTYINST pPropertyInst);
VOID WINAPIV XSP_FormatX2SFlags( LPPROPERTYINST pPropertyInst);
VOID WINAPIV XSP_FormatS2XFlags( LPPROPERTYINST pPropertyInst);
VOID WINAPIV XSP_FormatUserPermBits( LPPROPERTYINST pPropertyInst);
VOID WINAPIV XSP_FormatNatOpenFlags( LPPROPERTYINST pPropertyInst);
VOID WINAPIV XSP_FormatQOSFlags( LPPROPERTYINST pPropertyInst);
VOID WINAPIV XSP_FormatPadLength( LPPROPERTYINST pPropertyInst);
VOID WINAPIV XSP_FormatEncapProtocolType( LPPROPERTYINST pPropertyInst);
VOID WINAPIV XSP_FormatX2XKeyExFlags( LPPROPERTYINST pPropertyInst);
VOID WINAPIV XSP_FormatTcpFlags( LPPROPERTYINST pPropertyInst);
VOID WINAPIV XSP_FormatSyslinkVdp( LPPROPERTYINST pPropertyInst);


#define XSPHDRSIZE (sizeof(CXspHdr) - sizeof(CUdpHdr))

//==================================================================================
// Entry points
//==================================================================================

// Entry points for Xbox LAN Key Exchange
ENTRYPOINTS XSPEntryPoints =
{
    // XSP Entry Points
    XSP_Register,
		XSP_Deregister,
		XSP_RecognizeFrame,
		XSP_AttachProperties,
		XSP_FormatProperties
};

//==================================================================================
// Properties
//==================================================================================

// Properties for Xbox LAN Key Exchange
typedef enum
{
	XSP_SUMMARY_X2X_ONLINE_INIT = 0,
		XSP_SUMMARY_X2X_ONLINE_RESP,
		XSP_SUMMARY_X2X_SLINK_INIT,
		XSP_SUMMARY_X2X_SLINK_RESP,
		XSP_SUMMARY_X2S_INIT,
		XSP_SUMMARY_S2X_RESP,
		XSP_SUMMARY_NATOPEN_INIT,
		XSP_SUMMARY_NATOPEN_RESP,
		XSP_SUMMARY_QOS_INIT,
		XSP_SUMMARY_QOS_RESP,
		XSP_SUMMARY_ENCAP_PACKET,
		XSP_SUMMARY_X2T_INIT,
		XSP_SUMMARY_T2X_RESP,
		XSP_SPI,
		XSP_KEYEX_TYPE,
		XSP_ENT_SIZE,
		XSP_XNKID,
		XSP_SPI_INIT,
		XSP_SPI_RESP,
		XSP_NONCE_INIT,
		XSP_NONCE_RESP,
		XSP_KEYEX_TIME,
		XSP_INIT_VECTOR,
		XSP_ENCRYPT_XNADDR_INIT,
		XSP_ENCRYPT_XNADDR_RESP,
		XSP_DH_GX,
		XSP_HMAC_SHA,
		XSP_X2S_FLAGS,
		XSP_USER_PERM,
		XSP_ENCRYPT_SG_PARAMS,
		XSP_CONTEXT,
		XSP_IP_ADDRESS,
		XSP_IP_PORT,
		XSP_NATOPEN_FLAGS,
		XSP_HASH,
		XSP_QOS_INDEX,
		XSP_QOS_SEQNUM,
		XSP_QOS_FLAGS,
		XSP_QOS_XNADDR,
		XSP_QOS_RTT,
		XSP_QOS_GAP,
		XSP_QOS_PADLEN,
		XSP_QOS_DATA,
		XSP_ENCRYPT_DATA,
		XSP_VOICE_DATA,
        XSP_VOICE_DATA_SYSLINK,
		XSP_ENCAP_PADLEN,
		XSP_ENCAP_PROTOTYPE,
		XSP_ENCAP_SEQNUM,
		XSP_VERSION,
		XSP_X2X_FLAGS,
		XSP_SOURCE_PORT_1,
		XSP_DEST_PORT_1,
		XSP_SOURCE_PORT_2,
		XSP_DEST_PORT_2,
		XSP_TCP_INFO,
		XSP_UDP_INFO,
		XSP_VDP_INFO,
		XSP_TCP_SEQNUM,
		XSP_TCP_ACKNUM,
		XSP_TCP_FLAGS,
		XSP_TCP_WINDOW,
		XSP_VDP_DATASIZE,
		XSP_TS_IN_TIMEOUT,
		XSP_TS_OUT_TIMEOUT,
		XSP_KEYEX_VERSION,
		XSP_AP_REQ,
		XSP_AP_REP,
		XSP_KEYEX_PADDING,
		XSP_CHAL_DVDBLOCK,
		XSP_CHAL_DVDHASH,
		XSP_CHAL_DVDCOPY,
		XSP_CHAL_PARAMS,
		XSP_CHAL_CODE,
		XSP_S2X_FLAGS
};

PROPERTYINFO  XSPPropTable[] = 
{
    // XSP_SUMMARY_X2X_ONLINE_INIT
    { 0, 0,
		"X2X Online Init",
		"Xbox-to-Xbox Online Key Exchange Initiator",
		PROP_TYPE_SUMMARY,
		PROP_QUAL_NONE,
		NULL,
		80,
		XSP_FormatX2XOnlineInitSummary
    },
	
    // XSP_SUMMARY_X2X_ONLINE_RESP
    { 0, 0,
	"X2X Online Resp",
	"Xbox-to-Xbox Online Key Exchange Response",
	PROP_TYPE_SUMMARY,
	PROP_QUAL_NONE,
	NULL,
	80,
	XSP_FormatX2XOnlineRespSummary
    },
	
    // XSP_SUMMARY_X2X_SLINK_INIT
    { 0, 0,
	"X2X Online Init",
	"Xbox-to-Xbox Systemlink Key Exchange Initiator",
	PROP_TYPE_SUMMARY,
	PROP_QUAL_NONE,
	NULL,
	80,
	XSP_FormatX2XSystemLinkInitSummary
    },
	
    // XSP_SUMMARY_X2X_SLINK_RESP
    { 0, 0,
	"X2X Online Resp",
	"Xbox-to-Xbox Systemlink Key Exchange Response",
	PROP_TYPE_SUMMARY,
	PROP_QUAL_NONE,
	NULL,
	80,
	XSP_FormatX2XSystemLinkRespSummary
    },
	
    // XSP_SUMMARY_X2S_INIT
    { 0, 0,
	"X2S Online Init",
	"Xbox-to-SG Online Key Exchange Initiator",
	PROP_TYPE_SUMMARY,
	PROP_QUAL_NONE,
	NULL,
	80,
	XSP_FormatX2SOnlineInitSummary
    },
	
    // XSP_SUMMARY_S2X_RESP
    { 0, 0,
	"S2X Online Resp",
	"SG-to-Xbox Online Key Exchange Response",
	PROP_TYPE_SUMMARY,
	PROP_QUAL_NONE,
	NULL,
	80,
	XSP_FormatS2XOnlineRespSummary
    },
	
    // XSP_SUMMARY_NATOPEN_INIT
    { 0, 0,
	"NAT Open Init",
	"NAT Open Key Exchange Initiator",
	PROP_TYPE_SUMMARY,
	PROP_QUAL_NONE,
	NULL,
	80,
	XSP_FormatNatOpenInitSummary
    },
	
    // XSP_SUMMARY_NATOPEN_RESP
    { 0, 0,
	"NAT Open Resp",
	"NAT Open Key Exchange Response",
	PROP_TYPE_SUMMARY,
	PROP_QUAL_NONE,
	NULL,
	80,
	XSP_FormatNatOpenRespSummary
    },
	
    // XSP_SUMMARY_QOS_INIT
    { 0, 0,
	"QOS Init",
	"QOS Key Exchange Initiator",
	PROP_TYPE_SUMMARY,
	PROP_QUAL_NONE,
	NULL,
	80,
	XSP_FormatQOSInitSummary
    },
	
    // XSP_SUMMARY_QOS_RESP
    { 0, 0,
	"QOS Resp",
	"QOS Key Exchange Response",
	PROP_TYPE_SUMMARY,
	PROP_QUAL_NONE,
	NULL,
	80,
	XSP_FormatQOSRespSummary
	},
		
	// XSP_SUMMARY_ENCAP_PACKET
    { 0, 0,
	"XSP Encapsulated",
	"XSP Encapsulated Packet",
	PROP_TYPE_SUMMARY,
	PROP_QUAL_NONE,
	NULL,
	80,
	XSP_FormatXSPEncapSummary
    },

	// XSP_SUMMARY_X2T_INIT
    { 0, 0,
	"X2SL Online Init",
	"Xbox-to-SGLite Online Key Exchange Init",
	PROP_TYPE_SUMMARY,
	PROP_QUAL_NONE,
	NULL,
	80,
	XSP_FormatX2TOnlineInitSummary
    },

	// XSP_SUMMARY_T2X_RESP
    { 0, 0,
	"SL2X Online Resp",
	"SGLite-to-Xbox Online Key Exchange Response",
	PROP_TYPE_SUMMARY,
	PROP_QUAL_NONE,
	NULL,
	80,
	XSP_FormatT2XOnlineRespSummary
    },

    // XSP_SPI
    { 0, 0,
	"SPI",
	"SPI",
	PROP_TYPE_DWORD,
	PROP_QUAL_NONE,
	NULL,
	80,
	FormatPropertyInstance
    },
	
    // XSP_KEYEX_TYPE
    { 0, 0,
	"Key Ex Type",
	"Key Exchange Packet Type",
	PROP_TYPE_WORD,
	PROP_QUAL_NONE,
	NULL,
	80,
	XSP_FormatKeyExType
    },
	
    // XSP_ENT_SIZE
    { 0, 0,
	"Entry Size",
	"Key Exchange Entry Size",
	PROP_TYPE_WORD,
	PROP_QUAL_NONE,
	NULL,
	80,
	FormatPropertyInstance
    },
	
    // XSP_XNKID
    { 0, 0,
	"XNKID",
	"Xbox Key ID",
	PROP_TYPE_RAW_DATA,
	PROP_QUAL_NONE,
	NULL,
	80,
	XSP_FormatXNKID
    },
	
    // XSP_SPI_INIT
    { 0, 0,
	"Init SPI",
	"SPI of the initiator",
	PROP_TYPE_DWORD,
	PROP_QUAL_NONE,
	NULL,
	80,
	FormatPropertyInstance
    },
	
    // XSP_SPI_RESP
    { 0, 0,
	"Resp SPI",
	"SPI of the responder",
	PROP_TYPE_DWORD,
	PROP_QUAL_NONE,
	NULL,
	80,
	FormatPropertyInstance
    },
	
    // XSP_NONCE_INIT
    { 0, 0,
	"Init nonce",
	"Nonce of the initiator",
	PROP_TYPE_RAW_DATA,
	PROP_QUAL_NONE,
	NULL,
	80,
	FormatPropertyInstance
    },
	
    // XSP_NONCE_RESP
    { 0, 0,
	"Resp nonce",
	"Nonce of the responder",
	PROP_TYPE_RAW_DATA,
	PROP_QUAL_NONE,
	NULL,
	80,
	FormatPropertyInstance
    },
	
    // XSP_KEYEX_TIME
    { 0, 0,
	"Time value",
	"Increasing time value of sender",
	PROP_TYPE_RAW_DATA,
	PROP_QUAL_NONE,
	NULL,
	80,
	FormatPropertyInstance
    },
	
    // XSP_INIT_VECTOR
    { 0, 0,
	"Init vector",
	"Initialization vector for DES encryption",
	PROP_TYPE_RAW_DATA,
	PROP_QUAL_NONE,
	NULL,
	80,
	FormatPropertyInstance
    },
	
    // XSP_ENCRYPT_XNADDR_INIT
    { 0, 0,
	"Encrypt XNADDR init",
	"Encrypted XNADDR of the initiator",
	PROP_TYPE_RAW_DATA,
	PROP_QUAL_NONE,
	NULL,
	80,
	FormatPropertyInstance
    },
	
    // XSP_ENCRYPT_XNADDR_RESP
    { 0, 0,
	"Encrypt XNADDR resp",
	"Encrypted XNADDR of the responder",
	PROP_TYPE_RAW_DATA,
	PROP_QUAL_NONE,
	NULL,
	80,
	FormatPropertyInstance
    },
	
    // XSP_DH_GX
    { 0, 0,
	"DH G^X",
	"Diffie-Helman G^X value",
	PROP_TYPE_RAW_DATA,
	PROP_QUAL_NONE,
	NULL,
	80,
	FormatPropertyInstance
    },
	
    // XSP_HMAC_SHA
    { 0, 0,
	"HMAC SHA",
	"HMAC SHA",
	PROP_TYPE_RAW_DATA,
	PROP_QUAL_NONE,
	NULL,
	80,
	FormatPropertyInstance
    },
	
    // XSP_X2S_FLAGS
    { 0, 0,
	"X2S flags",
	"Xbox-to-SG flags",
	PROP_TYPE_WORD,
	PROP_QUAL_NONE,
	NULL,
	80,
	XSP_FormatX2SFlags
    },
	
    // XSP_USER_PERM
    { 0, 0,
	"User bits",
	"Permutation and guest bits for all 4 users",
	PROP_TYPE_DWORD,
	PROP_QUAL_NONE,
	NULL,
	80,
	XSP_FormatUserPermBits
    },
	
    // XSP_ENCRYPT_SG_PARAMS
    { 0, 0,
	"Encrypt SG params",
	"Encrypted SG parameters",
	PROP_TYPE_RAW_DATA,
	PROP_QUAL_NONE,
	NULL,
	80,
	FormatPropertyInstance
    },
	
    // XSP_CONTEXT
    { 0, 0,
	"Sender context",
	"Context identifier from the sender",
	PROP_TYPE_DWORD,
	PROP_QUAL_NONE,
	NULL,
	80,
	FormatPropertyInstance
    },
	
    // XSP_IP_ADDRESS
    { 0, 0,
	"IP addr",
	"IP address of the sender",
	PROP_TYPE_IP_ADDRESS,
	PROP_QUAL_NONE,
	NULL,
	80,
	FormatPropertyInstance
    },
	
    // XSP_IP_PORT
    { 0, 0,
	"IP port",
	"IP port of the sender",
	PROP_TYPE_WORD,
	PROP_QUAL_NONE,
	NULL,
	80,
	FormatPropertyInstance
    },
	
    // XSP_NATOPEN_FLAGS
    { 0, 0,
	"NAT open flags",
	"Flags for NAT open operation",
	PROP_TYPE_WORD,
	PROP_QUAL_NONE,
	NULL,
	80,
	XSP_FormatNatOpenFlags
    },
	
    // XSP_HASH
    { 0, 0,
	"Hash",
	"HMAC-SHA digest",
	PROP_TYPE_RAW_DATA,
	PROP_QUAL_NONE,
	NULL,
	80,
	FormatPropertyInstance
    },
	
    // XSP_QOS_INDEX
    { 0, 0,
	"QOS index",
	"Index assigned by the initiator",
	PROP_TYPE_WORD,
	PROP_QUAL_NONE,
	NULL,
	80,
	FormatPropertyInstance
    },
	
    // XSP_QOS_SEQNUM
    { 0, 0,
	"QOS seq num",
	"QOS packet sequence number",
	PROP_TYPE_BYTE,
	PROP_QUAL_NONE,
	NULL,
	80,
	FormatPropertyInstance
    },
	
    // XSP_QOS_FLAGS
    { 0, 0,
	"QOS flags",
	"Flags for QOS operation",
	PROP_TYPE_BYTE,
	PROP_QUAL_NONE,
	NULL,
	80,
	XSP_FormatQOSFlags
    },
	
    // XSP_QOS_XNADDR
    { 0, 0,
	"QOS Resp XNADDR",
	"XNADDR of the QOS responder",
	PROP_TYPE_RAW_DATA,
	PROP_QUAL_NONE,
	NULL,
	80,
	FormatPropertyInstance
    },
	
    // XSP_QOS_RTT
    { 0, 0,
	"RTT",
	"Time between recv/xmit of pkt in microseconds",
	PROP_TYPE_DWORD,
	PROP_QUAL_NONE,
	NULL,
	80,
	FormatPropertyInstance
    },
	
    // XSP_QOS_GAP
    { 0, 0,
	"Gap",
	"Time between recv of pkt1 and pkt2 (less traffic) in microseconds",
	PROP_TYPE_DWORD,
	PROP_QUAL_NONE,
	NULL,
	80,
	FormatPropertyInstance
    },
	
    // XSP_QOS_PADLEN
    { 0, 0,
	"QoS Pad len",
	"Padding included in the Qos data for DES alignment",
	PROP_TYPE_BYTE,
	PROP_QUAL_NONE,
	NULL,
	80,
	FormatPropertyInstance
    },
	
    // XSP_QOS_DATA
    { 0, 0,
	"Data",
	"QOS Data",
	PROP_TYPE_RAW_DATA,
	PROP_QUAL_NONE,
	NULL,
	80,
	FormatPropertyInstance
    },
	
    // XSP_ENCRYPT_DATA
    { 0, 0,
	"Encrypted data",
	"Encrypted payload data",
	PROP_TYPE_RAW_DATA,
	PROP_QUAL_NONE,
	NULL,
	80,
	FormatPropertyInstance
    },
	
    // XSP_VOICE_DATA
    { 0, 0,
	"Voice data",
	"Unencrypted voice data",
	PROP_TYPE_RAW_DATA,
	PROP_QUAL_NONE,
	NULL,
	80,
	FormatPropertyInstance
    },

    // XSP_VOICE_DATA_SYSLINK
    { 0, 0,
	"Syslink broadcast data",
	"System link broadcast data",
	PROP_TYPE_RAW_DATA,
	PROP_QUAL_NONE,
	NULL,
	80,
	XSP_FormatSyslinkVdp
    },

    // XSP_ENCAP_PADLEN
    { 0, 0,
	"Pad len",
	"Encrypted padding length",
	PROP_TYPE_BYTE,
	PROP_QUAL_NONE,
	NULL,
	80,
	XSP_FormatPadLength
    },
	
    // XSP_ENCAP_PROTOTYPE
    { 0, 0,
	"Protocol",
	"Encapsulated protocol type",
	PROP_TYPE_BYTE,
	PROP_QUAL_NONE,
	NULL,
	80,
	XSP_FormatEncapProtocolType
    },
	
    // XSP_ENCAP_SEQNUM
    { 0, 0,
	"Encap seq num",
	"Low word of sequence number",
	PROP_TYPE_WORD,
	PROP_QUAL_NONE,
	NULL,
	80,
	FormatPropertyInstance
    },
	
    // XSP_VERSION
    { 0, 0,
	"Version",
	"Protocol version",
	PROP_TYPE_WORD,
	PROP_QUAL_NONE,
	NULL,
	80,
	FormatPropertyInstance
    },
	
    // XSP_X2X_FLAGS
    { 0, 0,
	"Flags",
	"Xbox-to-Xbox key exchange flags",
	PROP_TYPE_WORD,
	PROP_QUAL_NONE,
	NULL,
	80,
	XSP_FormatX2XKeyExFlags
    },
	
    // XSP_SOURCE_PORT_1
    { 0, 0,
	"Source port (1)",
	"Source port compressed to 1-byte ",
	PROP_TYPE_WORD,
	PROP_QUAL_NONE,
	NULL,
	80,
	FormatPropertyInstance
    },
	
    // XSP_DEST_PORT_1
    { 0, 0,
	"Dest port (1)",
	"Destination port compressed to 1-byte",
	PROP_TYPE_WORD,
	PROP_QUAL_NONE,
	NULL,
	80,
	FormatPropertyInstance
    },
	
    // XSP_SOURCE_PORT_2
    { 0, 0,
	"Source port",
	"Source port",
	PROP_TYPE_WORD,
	PROP_QUAL_NONE,
	NULL,
	80,
	FormatPropertyInstance
    },
	
    // XSP_DEST_PORT_2
    { 0, 0,
	"Dest port (2)",
	"Destination port",
	PROP_TYPE_WORD,
	PROP_QUAL_NONE,
	NULL,
	80,
	FormatPropertyInstance
    },
	
    // XSP_TCP_INFO
    { 0, 0,
	"TCP info",
	"Unencrypted TCP info",
	PROP_TYPE_RAW_DATA,
	PROP_QUAL_NONE,
	NULL,
	80,
	FormatPropertyInstance
    },
	
    // XSP_UDP_INFO
    { 0, 0,
	"UDP info",
	"Unencrypted UDP info",
	PROP_TYPE_RAW_DATA,
	PROP_QUAL_NONE,
	NULL,
	80,
	FormatPropertyInstance
    },
	
    // XSP_VDP_INFO
    { 0, 0,
	"VDP info",
	"Unencrypted VDP info",
	PROP_TYPE_RAW_DATA,
	PROP_QUAL_NONE,
	NULL,
	80,
	FormatPropertyInstance
    },
	
    // XSP_TCP_SEQNUM
    { 0, 0,
	"Seq num",
	"TCP sequence number",
	PROP_TYPE_DWORD,
	PROP_QUAL_NONE,
	NULL,
	80,
	FormatPropertyInstance
    },
	
    // XSP_TCP_ACKNUM
    { 0, 0,
	"Ack num",
	"TCP acknowledgement number",
	PROP_TYPE_DWORD,
	PROP_QUAL_NONE,
	NULL,
	80,
	FormatPropertyInstance
    },
	
    // XSP_TCP_FLAGS
    { 0, 0,
	"TCP flags",
	"TCP flags",
	PROP_TYPE_WORD,
	PROP_QUAL_NONE,
	NULL,
	80,
	XSP_FormatTcpFlags
    },
	
    // XSP_TCP_WINDOW
    { 0, 0,
	"TCP window",
	"TCP window",
	PROP_TYPE_DWORD,
	PROP_QUAL_NONE,
	NULL,
	80,
	FormatPropertyInstance
    },
	
	// XSP_VDP_DATASIZE
    { 0, 0,
	"Encrypt size",
	"Encrypted data size",
	PROP_TYPE_DWORD,
	PROP_QUAL_NONE,
	NULL,
	80,
	FormatPropertyInstance
    },

	// XSP_TS_IN_TIMEOUT
    { 0, 0,
	"Inbound Timeout",
	"Seconds of no inbound data before Xbox should assume it is disconnected",
	PROP_TYPE_WORD,
	PROP_QUAL_NONE,
	NULL,
	80,
	FormatPropertyInstance
    },

	// XSP_TS_OUT_TIMEOUT
    { 0, 0,
	"Outbound Timeout",
	"Seconds of no outbound data before Xbox should send a SEC message to the SG Light",
	PROP_TYPE_WORD,
	PROP_QUAL_NONE,
	NULL,
	80,
	FormatPropertyInstance
    },

    // XSP_KEYEX_VERSION
    { 0, 0,
	"Key Exchange Version",
	"Key Exchange Version",
	PROP_TYPE_WORD,
	PROP_QUAL_NONE,
	NULL,
	80,
	FormatPropertyInstance
    },

    // XSP_AP_REQ
    // @@@ kgoodier TODO - we may be able to parse some data inside this
    { 0, 0,
	"AP Request",
	"Kerberos AP request",
	PROP_TYPE_RAW_DATA,
	PROP_QUAL_NONE,
	NULL,
	80,
	FormatPropertyInstance
    },

    // XSP_AP_REP
    // @@@ kgoodier TODO - we may be able to parse some data inside this 
    { 0, 0,
	"AP Reply",
	"Kerberos AP reply",
	PROP_TYPE_RAW_DATA,
	PROP_QUAL_NONE,
	NULL,
	80,
	FormatPropertyInstance
    },
    
    // XSP_KEYEX_PADDING
    { 0, 0,
	"Padding",
	"Key exchange padding",
	PROP_TYPE_RAW_DATA,
	PROP_QUAL_NONE,
	NULL,
	80,
	FormatPropertyInstance
    },

    // XSP_CHAL_DVDBLOCK
    { 0, 0,
	"DVD Block",
	"DVD block to read",
	PROP_TYPE_DWORD,
	PROP_QUAL_NONE,
	NULL,
	80,
	FormatPropertyInstance
    },

    // XSP_CHAL_DVDHASH
    { 0, 0,
	"DVD Hash Offset",
	"Offset in DVD block to start hashing",
	PROP_TYPE_WORD,
	PROP_QUAL_NONE,
	NULL,
	80,
	FormatPropertyInstance
    },

    // XSP_CHAL_DVDCOPY
    { 0, 0,
	"DVD Copy Offset",
	"Offset in DVD block to start copying",
	PROP_TYPE_WORD,
	PROP_QUAL_NONE,
	NULL,
	80,
	FormatPropertyInstance
    },

    // XSP_CHAL_PARAMS
    { 0, 0,
	"Challenge Params",
	"Challenge parameters",
	PROP_TYPE_RAW_DATA,
	PROP_QUAL_NONE,
	NULL,
	80,
	FormatPropertyInstance
    },

    // XSP_CHAL_CODE
    { 0, 0,
	"Challenge Code",
	"Signed challenge code",
	PROP_TYPE_RAW_DATA,
	PROP_QUAL_NONE,
	NULL,
	80,
	FormatPropertyInstance
    },

    // XSP_S2X_FLAGS
    { 0, 0,
	"S2X flags",
	"SG-to-Xbox flags",
	PROP_TYPE_WORD,
	PROP_QUAL_NONE,
	NULL,
	80,
	XSP_FormatS2XFlags
    }
    

};

DWORD nNumXSPProps = (sizeof(XSPPropTable)/sizeof(PROPERTYINFO));

//==================================================================================
// DllMain
//----------------------------------------------------------------------------------
//
// Description: (Called by the OS) Tell the kernel about our entry points.
//
// Returns: Always returns TRUE
//==================================================================================
BOOL WINAPI DllMain( HANDLE hInstance, ULONG Command, LPVOID Reserved)
{
	
    // what type of call is this
    switch( Command )
    {
	case DLL_PROCESS_ATTACH:
		// are we loading for the first time?
		if( Attached == 0 )
		{
			// Create the Xbox Security Protocol
			hXSP = CreateProtocol("XSP", &XSPEntryPoints, ENTRYPOINTS_SIZE);
		}
		Attached++;
		break;
		
	case DLL_PROCESS_DETACH:
		// are we detaching our last instance?
		Attached--;
		if( Attached == 0 )
		{
			// Clean up the queue tickle protocol
			DestroyProtocol(hXSP);
		}
		break;
    }
	
    // Netmon parsers ALWAYS return TRUE.
    return TRUE;
}

//==================================================================================
// ParserAutoInstallInfo
//----------------------------------------------------------------------------------
//
// Description: Function called by Netmon to automatically install the parser
//
// Arguments: none
//
// Returns: On success, returns a pointer to a PF_PARSERDLLINFO structure containing
//	information on the parsers in this DLL.  Otherwise, returns NULL
//==================================================================================
PPF_PARSERDLLINFO WINAPI ParserAutoInstallInfo() 
{
    PPF_PARSERDLLINFO pParserDllInfo; 
    PPF_PARSERINFO    pParserInfo;
    DWORD dwNumProtocols;
	
    PPF_HANDOFFSET    pIncomingHandoff;
    PPF_HANDOFFENTRY  pHandoffEntry;
    DWORD dwIncomingHandoffs;

	/* We get handed off too by UDP rather than following it... we can probably remove this
    PPF_FOLLOWSET    pIncomingFollow;
    PPF_FOLLOWENTRY  pFollowEntry;
    DWORD dwIncomingFollows;
	*/
	
	/* For now, nothing can follow any Xbox protocols since we're doing all the interior parsing
	PPF_FOLLOWSET    pOutgoingFollow;
    PPF_FOLLOWENTRY  pFollowEntry;
    DWORD dwOutgoingFollows;
	*/
	
    // Base structure ========================================================
	
    // Allocate memory for parser info:
    dwNumProtocols = 2;
    pParserDllInfo = (PPF_PARSERDLLINFO)HeapAlloc(GetProcessHeap(),
		HEAP_ZERO_MEMORY,
		sizeof( PF_PARSERDLLINFO ) +
		dwNumProtocols * sizeof( PF_PARSERINFO) );
    if( pParserDllInfo == NULL)
    {
        return NULL;
    }       
    
    // Fill in the parser DLL info
    pParserDllInfo->nParsers = dwNumProtocols;
	
	// ----------------------------------------------
	// Installation of Xbox Security Protocl
	// ----------------------------------------------
	
    // Enter XSP information
    pParserInfo = &(pParserDllInfo->ParserInfo[0]);
    sprintf( pParserInfo->szProtocolName, "XSP" );
    sprintf( pParserInfo->szComment,      "Xbox Security Protocol" );
    sprintf( pParserInfo->szHelpFile,     "");
	
	/*
    // the incoming follow set ----------------------------------------------
    dwIncomingFollows = 1;
    pIncomingFollow = (PPF_FOLLOWSET)HeapAlloc(GetProcessHeap(),
	HEAP_ZERO_MEMORY,
	sizeof( PF_FOLLOWSET ) +
	dwIncomingFollows * sizeof( PF_FOLLOWENTRY) );
    if( pIncomingFollow == NULL )
    {
	return pParserDllInfo;
    }
	
	  // Fill in the incoming handoff set
	  pParserInfo->pWhoCanPrecedeMe = pIncomingFollow;
	  pIncomingFollow->nEntries = dwIncomingFollows;
	  
		// UDP
		pFollowEntry = &(pIncomingFollow->Entry[0]);
		sprintf( pFollowEntry->szProtocol,   "UDP" );
	*/
	
    // the incoming handoff set ----------------------------------------------
    // allocate
    dwIncomingHandoffs = 1;
    pIncomingHandoff = (PPF_HANDOFFSET)HeapAlloc(GetProcessHeap(),
		HEAP_ZERO_MEMORY,
		sizeof( PF_HANDOFFSET ) +
		dwIncomingHandoffs * sizeof( PF_HANDOFFENTRY) );
    if( pIncomingHandoff == NULL )
    {
        return pParserDllInfo;
    }
	
    // Fill in the incoming handoff set
    pParserInfo->pWhoHandsOffToMe = pIncomingHandoff;
    pIncomingHandoff->nEntries = dwIncomingHandoffs;
	
    // UDP port 3074
    pHandoffEntry = &(pIncomingHandoff->Entry[0]);
    sprintf( pHandoffEntry->szIniFile,    "TCPIP.INI" );
    sprintf( pHandoffEntry->szIniSection, "UDP_HandoffSet" );
    sprintf( pHandoffEntry->szProtocol,   "XSP" );
    pHandoffEntry->dwHandOffValue =        3074;
    pHandoffEntry->ValueFormatBase =       HANDOFF_VALUE_FORMAT_BASE_DECIMAL;    
	
    return pParserDllInfo;
}

// ---------------------------------------
// XSP 
// ---------------------------------------

//==================================================================================
// XSP_Register
//----------------------------------------------------------------------------------
//
// Description: Creates the property database for XSP
//
// Arguments:
//	HPROTOCOL		hXSP			Handle to the XSP protocol
//
// Returns: void
//==================================================================================
void WINAPI XSP_Register( HPROTOCOL hXSP)
{
    WORD  i;
	
    // Tell Netmon to make reserve some space for our property table
    CreatePropertyDatabase( hXSP, nNumXSPProps);
	
    // Add our properties to the Netmon's database
    for( i = 0; i < nNumXSPProps; i++)
    {
        AddProperty( hXSP, &XSPPropTable[i]);
    }
}

//==================================================================================
// XSP_Deregister
//----------------------------------------------------------------------------------
//
// Description: Removes the property database for XSP
//
// Arguments:
//	HPROTOCOL		hXSP			Handle to the XSP protocol
//
// Returns: void
//==================================================================================
VOID WINAPI XSP_Deregister(HPROTOCOL hXSP)
{
    // Tell the Netmon that it may now free our database
    DestroyPropertyDatabase( hXSP);
}

//==================================================================================
// XSP_RecognizeFrame
//----------------------------------------------------------------------------------
//
// Description: Called by Netmon to determine if the parser recognizes this frame as XSP
//
// Arguments:
//	HFRAME			hFrame			Handle to the frame that contains the data.
//	LPBYTE			pMacFrame		Pointer to the first byte of a frame. The pointer 
//									provides a way to view data that other parsers recognize.
//	LPBYTE			pXSPFrame		Pointer to the start of the unclaimed data. Typically,
//									the unclaimed data is located in the middle of a frame
//									because a previous parser has claimed data before this
//									parser. The parser must test the unclaimed data first. 
//	DWORD			MacType			MAC value of the first protocol in a frame. Typically,
//									the MacType value is used when the parser must identify
//									the first protocol in a frame.
//	DWORD			BytesLeft		The remaining number of bytes from a location in a frame
//									to the end of the frame. 
//	HPROTOCOL		hPrevProtocol	Handle of the previous protocol. 
//	DWORD			nPrevProtOffset	Offset of the previous protocol - beginning of the frame.
//	LPDWORD			pProtocolStatus	Protocol status indicator.
//	LPHPROTOCOL		phNextProtocol	Pointer to the handle of the next protocol. This
//									parameter is set when a protocol identifies the protocol
//									that follows a protocol. To obtain the handle of the next
//									protocol, call the GetProtocolFromTable function. 
//	LPDWORD			InstData		On input, a pointer to the instance data from the
//									previous protocol. On output, a pointer to the instance
//									data for the current protocol. 
//
// Returns: When XSP protocol is recognized, either returns a pointer to the next byte of
//			unclaimed data or NULL to indicate there is no more protocol data in the packet.
//			When XSP protocol isn't recognized, returns the original pXSPFrame value to submit
//			the packet back to Netmon to find a proper protocol match
//==================================================================================
LPBYTE WINAPI XSP_RecognizeFrame(HFRAME      hFrame,         
								 LPBYTE      pMacFrame,      
								 LPBYTE      pXSPFrame, 
								 DWORD       MacType,        
								 DWORD       BytesLeft,      
								 HPROTOCOL   hPrevProtocol,  
								 DWORD       nPrevProtOffset,
								 LPDWORD     pProtocolStatus,
								 LPHPROTOCOL phNextProtocol,
								 LPDWORD     InstData)       
{
	CXspHdr *pXspHdr = (CXspHdr *) (pXSPFrame - sizeof(CUdpHdr));
	
	// Verify UDP
	if((hPrevProtocol != GetProtocolFromName("UDP")) || ((pXSPFrame - pMacFrame) < sizeof(CUdpHdr)))
	{
		*pProtocolStatus = PROTOCOL_STATUS_NOT_RECOGNIZED;
		goto Exit;
	}
	
	// Verify port 3074
	if((pXspHdr->_ipportSrc != 0x020C) && (pXspHdr->_ipportDst != 0x020C))
	{
		*pProtocolStatus = PROTOCOL_STATUS_NOT_RECOGNIZED;
		goto Exit;
	}
	
	// Verify there is enough room for the CXSPHeader
	if(BytesLeft < XSPHDRSIZE)
	{
		*pProtocolStatus = PROTOCOL_STATUS_NOT_RECOGNIZED;
		goto Exit;
	}
	
	*pProtocolStatus = PROTOCOL_STATUS_CLAIMED;
	pXSPFrame = NULL;
	
Exit:
	
	return pXSPFrame;
}

//==================================================================================
// XSP_AttachProperties
//----------------------------------------------------------------------------------
//
// Description: Called by Netmon to determine if the parser recognizes this frame as XSP
//
// Arguments:
//	HFRAME			hFrame			Handle of the frame that is being parsed. 
//	LPBYTE			lpFrame			Pointer to the first byte in a frame.
//	LPBYTE			pXSPFrame		Pointer to the start of the recognized data.
//	DWORD			MacType			MAC value of the first protocol in a frame.
//	DWORD			BytesLeft		The remaining number of bytes in a frame, starting
//									at the beginning of the recognized data.
//	HPROTOCOL		hPrevProtocol	Handle of the previous protocol.
//	DWORD			nPrevProtOffset	Offset of the previous protocol, starting at the
//									beginning of the frame.
//	DWORD			InstData		Pointer to the instance data from the previous protocol.
//
// Returns: When the function is successful, either returns a pointer to the next byte of
//			unclaimed data or NULL to indicate there is no more protocol data in the packet.
//			When the function isn't successful, returns the original pXSPFrame value to
//			submit the packet back to Netmon to find a proper protocol match
//==================================================================================
LPBYTE WINAPI XSP_AttachProperties(HFRAME      hFrame,         
								   LPBYTE      pMacFrame,     
								   LPBYTE      pXSPFrame,   
								   DWORD       MacType,        
								   DWORD       BytesLeft,      
								   HPROTOCOL   hPrevProtocol,  
								   DWORD       nPrevProtOffset,
								   DWORD       InstData)       
								   
{
    CEnetHdr *pEnetHdr = (CEnetHdr *) (pMacFrame);
    CIpHdr *pIpHdr = (CIpHdr *) (pMacFrame + sizeof(CEnetHdr));
    CUdpHdr *pUdpHdr = (CUdpHdr *) (pMacFrame + sizeof(CEnetHdr) + sizeof(CIpHdr));
	CXspHdr *pXspHdr = (CXspHdr *) (pXSPFrame - sizeof(CUdpHdr));
	CXspTail *pXspTail = NULL;
	CKeyExHdr *pKeyExHdr = NULL;
	CKeyExXbToXb *pKeyExXbToXb = NULL;
	CKeyExXbToSgInit *pKeyExXbToSgInit = NULL;
	CKeyExSgToXbResp *pKeyExSgToXbResp = NULL;
	CKeyExXbToTsInit *pKeyExXbToTsInit = NULL;
	CKeyExTsToXbResp *pKeyExTsToXbResp = NULL;
	CKeyExNatOpen *pKeyExNatOpen = NULL;
	CKeyExQosInit *pKeyExQosInit = NULL;
	CKeyExQosResp *pKeyExQosResp = NULL;
    CKeyExDHGX *pKeyExDHGX = NULL;
    CKeyExKerbApReq *pKeyExApReq = NULL;
    CKeyExKerbApRep *pKeyExApRep = NULL;
    CKeyExSgToXbChal *pKeyExChal = NULL;
	DWORD cbOriginal = BytesLeft;
	LPBYTE pNextFrame = pXSPFrame, pUnencryptedDataIndex = NULL;
	BYTE bXspType = 0;
	WORD wSourcePort = 0, wDestPort = 0;
	DWORD dwSeqNum = 0, dwAckNum = 0;
	DWORD cbPad = 0;   // Counts the number of bytes needed to pad out the encrypted portion of the packet
	DWORD cbTex = 0;   // Counts the number of bytes needed for the encapsulated protocol's (TCP, UDP or VDP) header
	DWORD cbTov = 0;   // Counts the amount of the pad that's used by the encapsulated protocol's header
	DWORD cbPorts = 0; // Counts the number of bytes used by the port fields in the encapsulated protocol
	DWORD cbDat = 0;   // Counts the number of encrypted bytes
	DWORD cbTvo = 0;   // Counts the number of bytes of unencrypted voice data
	DWORD dwSpi = 0;
	
	// Verify there is enough room for the CXSPHeader
	if(BytesLeft < XSPHDRSIZE)
	{
		goto Exit;
	}
	
	// Parse key exchange packets
	if(pXspHdr->_dwSpiAndFlags == 0)
	{
		BytesLeft -= XSPHDRSIZE;
		
		// We got a key exchange packet but there isn't enough room for the key exchange header
		if(BytesLeft < sizeof(CKeyExHdr))
		{
			goto Exit;
		}
		
		pKeyExHdr = (CKeyExHdr *) (pXSPFrame + XSPHDRSIZE);
		
		switch(pKeyExHdr->_wType)
		{
			// Parse Xbox-to-Xbox packets
		case KEYEX_TYPE_XBTOXB_INIT:
		case KEYEX_TYPE_XBTOXB_RESP:
			
			// Badly formatted packet
			if((pKeyExHdr->_cbEnt < sizeof(CKeyExXbToXb)) || (pKeyExHdr->_cbEnt > BytesLeft))
			{
				goto Exit;
			}
			
			pKeyExXbToXb = (CKeyExXbToXb *) pKeyExHdr;
			
			// --------------------------------------------
			// We've got 4 possibilities here
			// 1) Online key exchange initialization
			// 2) Online key exchange response
			// 3) System link key exchange initialization
			// 4) System link key exchange response
			// --------------------------------------------
			
			// Parse online key exchange
			if(XNetXnKidIsOnlinePeer(&(pKeyExXbToXb->_xnkid)))
			{
				if(pKeyExXbToXb->_wType == KEYEX_TYPE_XBTOXB_INIT)
				{
					// We're dealing with...
					// 1) Online key exchange initialization
					if(!AttachPropertyInstance(hFrame, XSPPropTable[XSP_SUMMARY_X2X_ONLINE_INIT].hProperty, cbOriginal, 
						(LPBYTE) pXSPFrame, 0, 1, 0))
					{
						goto Exit;
					}
				}
				else if(pKeyExXbToXb->_wType == KEYEX_TYPE_XBTOXB_RESP)
				{
					// We're dealing with...
					// 2) Online key exchange response
					if(!AttachPropertyInstance(hFrame, XSPPropTable[XSP_SUMMARY_X2X_ONLINE_RESP].hProperty, cbOriginal, 
						(LPBYTE) pXSPFrame, 0, 1, 0))
					{
						goto Exit;
					}
				}
				
				// We've claimed the packet so when we return, point to the next byte after the received packet
				pNextFrame += cbOriginal;
			}
			// Parse system link key exchange
			else if(XNetXnKidIsSystemLink(&(pKeyExXbToXb->_xnkid)))
			{
				if(pKeyExHdr->_wType == KEYEX_TYPE_XBTOXB_INIT)
				{	
					// We're dealing with...
					// 3) System link key exchange initialization
					if(!AttachPropertyInstance(hFrame, XSPPropTable[XSP_SUMMARY_X2X_SLINK_INIT].hProperty, cbOriginal, 
						(LPBYTE) pXSPFrame, 0, 1, 0))
					{
						goto Exit;
					}
				}
				else if(pKeyExHdr->_wType == KEYEX_TYPE_XBTOXB_RESP)
				{
					// We're dealing with...
					// 4) System link key exchange response
					if(!AttachPropertyInstance(hFrame, XSPPropTable[XSP_SUMMARY_X2X_SLINK_RESP].hProperty, cbOriginal,
						(LPBYTE) pXSPFrame, 0, 1, 0))
					{
						goto Exit;
					}
				}
				// We've claimed the packet so when we return, point to the next byte after the received packet
				pNextFrame += cbOriginal;
			}
			
			// Can't have a Xbox-to-Xbox key exchange packet of type SG-to-Xbox
			else
			{
				goto Exit;
			}
			
			// Attach the NULL SPI
			dwSpi = pXspHdr->_dwSpiAndFlags & XSP_SPI_MASK;
			if(!AttachPropertyInstanceEx(hFrame, XSPPropTable[XSP_SPI].hProperty, sizeof(pXspHdr->_dwSpiAndFlags), (LPBYTE) &(pXspHdr->_dwSpiAndFlags),
				sizeof(dwSpi), (LPBYTE) &dwSpi, 0, 2, 0))
			{
				goto Exit;
			}
			
            // Summary: XbToXbKeyExInit
			if(!AttachPropertyInstance(hFrame, XSPPropTable[XSP_KEYEX_TYPE].hProperty, pKeyExXbToXb->_cbEnt, 
				(LPBYTE) pKeyExXbToXb, 0, 2, 0))
			{
				goto Exit;
			}

			// Attach the key exchange type
			if(!AttachPropertyInstance(hFrame, XSPPropTable[XSP_KEYEX_TYPE].hProperty, sizeof(pKeyExXbToXb->_wType),
				(LPBYTE) &(pKeyExXbToXb->_wType), 0, 3, 0))
			{
				goto Exit;
			}
			
			// Attach the key exchange size
			if(!AttachPropertyInstance(hFrame, XSPPropTable[XSP_ENT_SIZE].hProperty, sizeof(pKeyExXbToXb->_cbEnt),
				(LPBYTE) &(pKeyExXbToXb->_cbEnt), 0, 3, 0))
			{
				goto Exit;
			}
			
			// Attach the version
			if(!AttachPropertyInstance(hFrame, XSPPropTable[XSP_VERSION].hProperty, sizeof(pKeyExXbToXb->_wVersion),
				(LPBYTE) &(pKeyExXbToXb->_wVersion), 0, 3, 0))
			{
				goto Exit;
			}
			
			// Attach the Xbox-to-Xbox key exchange flags
			if(!AttachPropertyInstance(hFrame, XSPPropTable[XSP_X2X_FLAGS].hProperty, sizeof(pKeyExXbToXb->_wFlags),
				(LPBYTE) &(pKeyExXbToXb->_wFlags), 0, 3, 0))
			{
				goto Exit;
			}
			
			// Attach the key ID
			if(!AttachPropertyInstance(hFrame, XSPPropTable[XSP_XNKID].hProperty, sizeof(pKeyExXbToXb->_xnkid),
				(LPBYTE) &(pKeyExXbToXb->_xnkid), 0, 3, 0))
			{
				goto Exit;
			}
			
			// Attach the initiator SPI
			if(!AttachPropertyInstance(hFrame, XSPPropTable[XSP_SPI_INIT].hProperty, sizeof(pKeyExXbToXb->_dwSpiInit),
				(LPBYTE) &(pKeyExXbToXb->_dwSpiInit), 0, 3, 0))
			{
				goto Exit;
			}
			
			// Attach the response SPI
			if(!AttachPropertyInstance(hFrame, XSPPropTable[XSP_SPI_RESP].hProperty, sizeof(pKeyExXbToXb->_dwSpiResp),
				(LPBYTE) &(pKeyExXbToXb->_dwSpiResp), 0, 3, 0))
			{
				goto Exit;
			}
			
			// Attach the initiator nonce
			if(!AttachPropertyInstance(hFrame, XSPPropTable[XSP_NONCE_INIT].hProperty, sizeof(pKeyExXbToXb->_abNonceInit),
				(LPBYTE) &(pKeyExXbToXb->_abNonceInit), 0, 3, 0))
			{
				goto Exit;
			}
			
			// Attach the response nonce
			if(!AttachPropertyInstance(hFrame, XSPPropTable[XSP_NONCE_RESP].hProperty, sizeof(pKeyExXbToXb->_abNonceResp),
				(LPBYTE) &(pKeyExXbToXb->_abNonceResp), 0, 3, 0))
			{
				goto Exit;
			}
			
			// Attach the sender's time
			if(!AttachPropertyInstance(hFrame, XSPPropTable[XSP_KEYEX_TIME].hProperty, sizeof(pKeyExXbToXb->_liTime),
				(LPBYTE) &(pKeyExXbToXb->_liTime), 0, 3, 0))
			{
				goto Exit;
			}
			
			// Attach the initialization vector
			if(!AttachPropertyInstance(hFrame, XSPPropTable[XSP_INIT_VECTOR].hProperty, sizeof(pKeyExXbToXb->_abIv),
				(LPBYTE) &(pKeyExXbToXb->_abIv), 0, 3, 0))
			{
				goto Exit;
			}
			
			// Attach the encrypted XNADDR of the initiator
			if(!AttachPropertyInstance(hFrame, XSPPropTable[XSP_ENCRYPT_XNADDR_INIT].hProperty, sizeof(pKeyExXbToXb->_xnaddrInit),
				(LPBYTE) &(pKeyExXbToXb->_xnaddrInit), 0, 3, 0))
			{
				goto Exit;
			}
			
			// Attach the encrypted XNADDR of the responder
			if(!AttachPropertyInstance(hFrame, XSPPropTable[XSP_ENCRYPT_XNADDR_RESP].hProperty, sizeof(pKeyExXbToXb->_xnaddrResp),
				(LPBYTE) &(pKeyExXbToXb->_xnaddrResp), 0, 3, 0))
			{
				goto Exit;
			}

            BytesLeft -= pKeyExXbToXb->_cbEnt;
			
			// In system link key exchange, we also need to parse the G^X values
			if(XNetXnKidIsSystemLink(&(pKeyExXbToXb->_xnkid)))
			{
                // Smooshed packet #2: KEYEX_TYPE_DH_GX
    			// We don't have enough room left for the keyex headers for G^X values
    			if(BytesLeft < sizeof(CKeyExDHGX))
    			{
    				goto Exit;
    			}
    			
    			pKeyExDHGX = (CKeyExDHGX *) (pKeyExXbToXb + 1);

    			// Badly formatted packet
    			if((pKeyExDHGX->_cbEnt < sizeof(CKeyExDHGX)) || (pKeyExDHGX->_cbEnt > BytesLeft))
    			{
    				goto Exit;
    			}

                // Summary: DhGx
    			if(!AttachPropertyInstance(hFrame, XSPPropTable[XSP_KEYEX_TYPE].hProperty, pKeyExDHGX->_cbEnt, 
    				(LPBYTE)pKeyExDHGX, 0, 2, 0))
    			{
    				goto Exit;
    			}
    			
    			// Attach the key exchange type
    			if(!AttachPropertyInstance(hFrame, XSPPropTable[XSP_KEYEX_TYPE].hProperty, sizeof(pKeyExDHGX->_wType),
    				(LPBYTE) &(pKeyExDHGX->_wType), 0, 3, 0))
    			{
    				goto Exit;
    			}
    			
    			// Attach the key exchange size
    			if(!AttachPropertyInstance(hFrame, XSPPropTable[XSP_ENT_SIZE].hProperty, sizeof(pKeyExDHGX->_cbEnt),
    				(LPBYTE) &(pKeyExDHGX->_cbEnt), 0, 3, 0))
    			{
    				goto Exit;
    			}
    			
    			// If this isn't the G^X value, then we don't know how to interpret it
    			if(pKeyExDHGX->_wType != KEYEX_TYPE_DH_GX)
    			{
    				goto Exit;
    			}
    			
    			// Attach the G^X value
    			if(!AttachPropertyInstance(hFrame, XSPPropTable[XSP_DH_GX].hProperty, sizeof(pKeyExDHGX->_ab),
    				(LPBYTE) (pKeyExDHGX->_ab), 0, 3, 0))
    			{
    				goto Exit;
    			}
    			
    			BytesLeft -= pKeyExDHGX->_cbEnt;

                // We don't have enough room left for the HMAC SHA values
				if(BytesLeft < sizeof(CKeyExHdr))
				{
					goto Exit;
				}
                pKeyExHdr = (CKeyExHdr *) (pKeyExDHGX + 1);

			}
			// In online key exchange, we don't need to parse the G^X values
			else
			{
				
				// We don't have enough room left for the HMAC SHA values
				if(BytesLeft < sizeof(CKeyExHdr))
				{
					goto Exit;
				}
				pKeyExHdr = (CKeyExHdr *) (pKeyExXbToXb + 1);
			}
			
			
			// Badly formatted packet
			if((pKeyExHdr->_cbEnt < sizeof(CKeyExHdr)) || (pKeyExHdr->_cbEnt > BytesLeft))
			{
				goto Exit;
			}

            // Summary: HMAC-SHA
			if(!AttachPropertyInstance(hFrame, XSPPropTable[XSP_KEYEX_TYPE].hProperty, pKeyExHdr->_cbEnt, 
				(LPBYTE)pKeyExHdr, 0, 2, 0))
			{
				goto Exit;
			}
    						
			// Attach the key exchange type
			if(!AttachPropertyInstance(hFrame, XSPPropTable[XSP_KEYEX_TYPE].hProperty, sizeof(pKeyExHdr->_wType),
				(LPBYTE) &(pKeyExHdr->_wType), 0, 3, 0))
			{
				goto Exit;
			}
			
			// Attach the key exchange size
			if(!AttachPropertyInstance(hFrame, XSPPropTable[XSP_ENT_SIZE].hProperty, sizeof(pKeyExHdr->_cbEnt),
				(LPBYTE) &(pKeyExHdr->_cbEnt), 0, 3, 0))
			{
				goto Exit;
			}
			
			// If this isn't the HMAC SHA value, then we don't know how to interpret it
			if(pKeyExHdr->_wType != KEYEX_TYPE_HMAC_SHA)
			{
				goto Exit;
			}
			
			// Attach the HMAC SHA value
			if(!AttachPropertyInstance(hFrame, XSPPropTable[XSP_HMAC_SHA].hProperty, XC_SERVICE_DIGEST_SIZE,
				(LPBYTE) (pKeyExHdr + 1), 0, 3, 0))
			{
				goto Exit;
			}

            BytesLeft -= pKeyExHdr->_cbEnt;
			break;
			
			// Parse Xbox-to-SG packets
		case KEYEX_TYPE_XBTOSG_INIT:
			
			// Badly formatted packet
			if((pKeyExHdr->_cbEnt < sizeof(CKeyExXbToSgInit)) || (pKeyExHdr->_cbEnt > BytesLeft))
			{
				goto Exit;
			}
			
			pKeyExXbToSgInit = (CKeyExXbToSgInit *) pKeyExHdr;
			
			// We've identified an Xbox-to-SG init packet
			if(!AttachPropertyInstance(hFrame, XSPPropTable[XSP_SUMMARY_X2S_INIT].hProperty, cbOriginal, 
				(LPBYTE) pXSPFrame, 0, 1, 0))
			{
				goto Exit;
			}
			
			// Attach the SPI
			dwSpi = pXspHdr->_dwSpiAndFlags & XSP_SPI_MASK;
			if(!AttachPropertyInstanceEx(hFrame, XSPPropTable[XSP_SPI].hProperty, sizeof(pXspHdr->_dwSpiAndFlags), (LPBYTE) &(pXspHdr->_dwSpiAndFlags),
				sizeof(dwSpi), (LPBYTE) &dwSpi, 0, 2, 0))
			{
				goto Exit;
			}

            // Summary: XbToSgKeyExInit
			if(!AttachPropertyInstance(hFrame, XSPPropTable[XSP_KEYEX_TYPE].hProperty, pKeyExXbToSgInit->_cbEnt, 
				(LPBYTE) pKeyExXbToSgInit, 0, 2, 0))
			{
				goto Exit;
			}

			// Attach the key exchange type
			if(!AttachPropertyInstance(hFrame, XSPPropTable[XSP_KEYEX_TYPE].hProperty, sizeof(pKeyExXbToSgInit->_wType),
				(LPBYTE) &(pKeyExXbToSgInit->_wType), 0, 3, 0))
			{
				goto Exit;
			}
			
			// Attach the key exchange size
			if(!AttachPropertyInstance(hFrame, XSPPropTable[XSP_ENT_SIZE].hProperty, sizeof(pKeyExXbToSgInit->_cbEnt),
				(LPBYTE) &(pKeyExXbToSgInit->_cbEnt), 0, 3, 0))
			{
				goto Exit;
			}
			
			// Attach the key exchange version
			if(!AttachPropertyInstance(hFrame, XSPPropTable[XSP_KEYEX_VERSION].hProperty, sizeof(pKeyExXbToSgInit->_wVersion),
				(LPBYTE) &(pKeyExXbToSgInit->_wVersion), 0, 3, 0))
			{
				goto Exit;
			}

			// Attach the xbox to secure gateway flags
			if(!AttachPropertyInstance(hFrame, XSPPropTable[XSP_X2S_FLAGS].hProperty, sizeof(pKeyExXbToSgInit->_wFlags),
				(LPBYTE) &(pKeyExXbToSgInit->_wFlags), 0, 3, 0))
			{
				goto Exit;
			}
			
			// Attach the initiator SPI
			if(!AttachPropertyInstance(hFrame, XSPPropTable[XSP_SPI_INIT].hProperty, sizeof(pKeyExXbToSgInit->_dwSpiInit),
				(LPBYTE) &(pKeyExXbToSgInit->_dwSpiInit), 0, 3, 0))
			{
				goto Exit;
			}
			
			// Attach the initiator nonce
			if(!AttachPropertyInstance(hFrame, XSPPropTable[XSP_NONCE_INIT].hProperty, sizeof(pKeyExXbToSgInit->_abNonceInit),
				(LPBYTE) (pKeyExXbToSgInit->_abNonceInit), 0, 3, 0))
			{
				goto Exit;
			}
			
			// Attach user permutation flags
			if(!AttachPropertyInstance(hFrame, XSPPropTable[XSP_USER_PERM].hProperty, sizeof(pKeyExXbToSgInit->_dwUserPerm),
				(LPBYTE) &(pKeyExXbToSgInit->_dwUserPerm), 0, 3, 0))
			{
				goto Exit;
			}

			BytesLeft -= sizeof(CKeyExXbToSgInit);

            
            // Smooshed packet #2: KEYEX_TYPE_DH_GX
			// We don't have enough room left for the keyex headers for G^X values
			if(BytesLeft < sizeof(CKeyExDHGX))
			{
				goto Exit;
			}
			
			pKeyExDHGX = (CKeyExDHGX *) (pKeyExXbToSgInit + 1);
			
			// Badly formatted packet
			if((pKeyExDHGX->_cbEnt < sizeof(CKeyExDHGX)) || (pKeyExHdr->_cbEnt > BytesLeft))
			{
				goto Exit;
			}

            // Summary: DhGx
			if(!AttachPropertyInstance(hFrame, XSPPropTable[XSP_KEYEX_TYPE].hProperty, pKeyExDHGX->_cbEnt, 
				(LPBYTE)pKeyExDHGX, 0, 2, 0))
			{
				goto Exit;
			}
			
			// Attach the key exchange type
			if(!AttachPropertyInstance(hFrame, XSPPropTable[XSP_KEYEX_TYPE].hProperty, sizeof(pKeyExDHGX->_wType),
				(LPBYTE) &(pKeyExDHGX->_wType), 0, 3, 0))
			{
				goto Exit;
			}
			
			// Attach the key exchange size
			if(!AttachPropertyInstance(hFrame, XSPPropTable[XSP_ENT_SIZE].hProperty, sizeof(pKeyExDHGX->_cbEnt),
				(LPBYTE) &(pKeyExDHGX->_cbEnt), 0, 3, 0))
			{
				goto Exit;
			}
			
			// If this isn't the G^X value, then we don't know how to interpret it
			if(pKeyExDHGX->_wType != KEYEX_TYPE_DH_GX)
			{
				goto Exit;
			}
			
			// Attach the G^X value
			if(!AttachPropertyInstance(hFrame, XSPPropTable[XSP_DH_GX].hProperty, sizeof(pKeyExDHGX->_ab),
				(LPBYTE) (pKeyExDHGX->_ab), 0, 3, 0))
			{
				goto Exit;
			}
			
			BytesLeft -= pKeyExDHGX->_cbEnt;


            // Smooshed packet #3: APREQ
			// Do we have enough room left for the AP request header?
			if(BytesLeft < sizeof(CKeyExHdr))
			{
				goto Exit;
			}
			pKeyExApReq = (CKeyExKerbApReq *)(pKeyExDHGX + 1);
            
			// Badly formatted header packet
			if((pKeyExApReq->_cbEnt > BytesLeft))
			{
				goto Exit;
			}

            // Summary: ApReq
			if(!AttachPropertyInstance(hFrame, XSPPropTable[XSP_KEYEX_TYPE].hProperty, pKeyExApReq->_cbEnt, 
				(LPBYTE)pKeyExApReq, 0, 2, 0))
			{
				goto Exit;
			}
            
			// Attach the key exchange type
			if(!AttachPropertyInstance(hFrame, XSPPropTable[XSP_KEYEX_TYPE].hProperty, sizeof(pKeyExApReq->_wType),
				(LPBYTE) &(pKeyExApReq->_wType), 0, 3, 0))
			{
				goto Exit;
			}
			
			// Attach the key exchange size
			if(!AttachPropertyInstance(hFrame, XSPPropTable[XSP_ENT_SIZE].hProperty, sizeof(pKeyExApReq->_cbEnt),
				(LPBYTE) &(pKeyExApReq->_cbEnt), 0, 3, 0))
			{
				goto Exit;
			}
			
			// If this isn't the APREQ value, then we don't know how to interpret it
			if(pKeyExApReq->_wType != KEYEX_TYPE_KERB_APREQ || BytesLeft < pKeyExApReq->_cbEnt)
			{
				goto Exit;
			}
			
			// Attach the APREQ value
			if(!AttachPropertyInstance(hFrame, XSPPropTable[XSP_AP_REQ].hProperty, pKeyExApReq->_cbEnt -sizeof(CKeyExHdr),
				(LPBYTE) (pKeyExApReq->_ab), 0, 3, 0))
			{
				goto Exit;
			}
			
			BytesLeft -= pKeyExApReq->_cbEnt;


            // Smooshed packet #4: key exchange padding
            // Anything left?
            if (BytesLeft < sizeof(CKeyExHdr))
			{
				goto Exit;
			}
			pKeyExHdr = (CKeyExHdr *)(((BYTE*)(pKeyExApReq)) + pKeyExApReq->_cbEnt);
            
			// Badly formatted header packet
			if((pKeyExHdr->_cbEnt > BytesLeft))
			{
				goto Exit;
			}

            // Summary: KeyExPadding
			if(!AttachPropertyInstance(hFrame, XSPPropTable[XSP_KEYEX_TYPE].hProperty, pKeyExHdr->_cbEnt, 
				(LPBYTE)pKeyExHdr, 0, 2, 0))
			{
				goto Exit;
			}
            
			// Attach the key exchange type
			if(!AttachPropertyInstance(hFrame, XSPPropTable[XSP_KEYEX_TYPE].hProperty, sizeof(pKeyExHdr->_wType),
				(LPBYTE) &(pKeyExHdr->_wType), 0, 3, 0))
			{
				goto Exit;
			}
			
			// Attach the key exchange size
			if(!AttachPropertyInstance(hFrame, XSPPropTable[XSP_ENT_SIZE].hProperty, sizeof(pKeyExHdr->_cbEnt),
				(LPBYTE) &(pKeyExHdr->_cbEnt), 0, 3, 0))
			{
				goto Exit;
			}
			
			// If this isn't the padding value, then we don't know how to interpret it
			if(pKeyExHdr->_wType != KEYEX_TYPE_PADDING || BytesLeft < pKeyExHdr->_cbEnt)
			{
				goto Exit;
			}
			
			// Attach the padding value
			if(!AttachPropertyInstance(hFrame, XSPPropTable[XSP_KEYEX_PADDING].hProperty, pKeyExHdr->_cbEnt - sizeof(CKeyExHdr),
				(LPBYTE) (pKeyExHdr + 1), 0, 3, 0))
			{
				goto Exit;
			}
			
			BytesLeft -= pKeyExHdr->_cbEnt;

			
			// We've claimed the packet so when we return, point to the next byte after the received packet
			pNextFrame += cbOriginal;
			break;
			
			// Parse SG-to-Xbox packets
		case KEYEX_TYPE_SGTOXB_RESP:
			
			// Badly formatted packet
			if((pKeyExHdr->_cbEnt < sizeof(CKeyExSgToXbResp)) || (pKeyExHdr->_cbEnt > BytesLeft))
			{
				goto Exit;
			}
			
			pKeyExSgToXbResp = (CKeyExSgToXbResp *) pKeyExHdr;
			
			// We've identified an SG-to-Xbox response packet
			if(!AttachPropertyInstance(hFrame, XSPPropTable[XSP_SUMMARY_S2X_RESP].hProperty, cbOriginal, 
				(LPBYTE) pXSPFrame, 0, 1, 0))
			{
				goto Exit;
			}
			
			// Attach the SPI
			dwSpi = pXspHdr->_dwSpiAndFlags & XSP_SPI_MASK;
			if(!AttachPropertyInstanceEx(hFrame, XSPPropTable[XSP_SPI].hProperty, sizeof(pXspHdr->_dwSpiAndFlags), (LPBYTE) &(pXspHdr->_dwSpiAndFlags),
				sizeof(dwSpi), (LPBYTE) &dwSpi, 0, 2, 0))
			{
				goto Exit;
			}

            // Summary: KeyExResp
			if(!AttachPropertyInstance(hFrame, XSPPropTable[XSP_KEYEX_TYPE].hProperty, pKeyExSgToXbResp->_cbEnt, 
				(LPBYTE)pKeyExSgToXbResp, 0, 2, 0))
			{
				goto Exit;
			}

			// Attach the key exchange type
			if(!AttachPropertyInstance(hFrame, XSPPropTable[XSP_KEYEX_TYPE].hProperty, sizeof(pKeyExSgToXbResp->_wType),
				(LPBYTE) &(pKeyExSgToXbResp->_wType), 0, 3, 0))
			{
				goto Exit;
			}
			
			// Attach the key exchange size
			if(!AttachPropertyInstance(hFrame, XSPPropTable[XSP_ENT_SIZE].hProperty, sizeof(pKeyExSgToXbResp->_cbEnt),
				(LPBYTE) &(pKeyExSgToXbResp->_cbEnt), 0, 3, 0))
			{
				goto Exit;
			}
			
			// Attach the key exchange version
			if(!AttachPropertyInstance(hFrame, XSPPropTable[XSP_KEYEX_VERSION].hProperty, sizeof(pKeyExSgToXbResp->_wVersion),
				(LPBYTE) &(pKeyExSgToXbResp->_wVersion), 0, 3, 0))
			{
				goto Exit;
			}

			// Attach the xbox to secure gateway flags
			if(!AttachPropertyInstance(hFrame, XSPPropTable[XSP_S2X_FLAGS].hProperty, sizeof(pKeyExSgToXbResp->_wFlags),
				(LPBYTE) &(pKeyExSgToXbResp->_wFlags), 0, 3, 0))
			{
				goto Exit;
			}
			
			// Attach the initiator SPI
			if(!AttachPropertyInstance(hFrame, XSPPropTable[XSP_SPI_INIT].hProperty, sizeof(pKeyExSgToXbResp->_dwSpiInit),
				(LPBYTE) &(pKeyExSgToXbResp->_dwSpiInit), 0, 3, 0))
			{
				goto Exit;
			}
			
			// Attach the responder SPI
			if(!AttachPropertyInstance(hFrame, XSPPropTable[XSP_SPI_RESP].hProperty, sizeof(pKeyExSgToXbResp->_dwSpiResp),
				(LPBYTE) &(pKeyExSgToXbResp->_dwSpiResp), 0, 3, 0))
			{
				goto Exit;
			}
			
			// Attach the initiator nonce
			if(!AttachPropertyInstance(hFrame, XSPPropTable[XSP_NONCE_INIT].hProperty, sizeof(pKeyExSgToXbResp->_abNonceInit),
				(LPBYTE) (pKeyExSgToXbResp->_abNonceInit), 0, 3, 0))
			{
				goto Exit;
			}
			
			// Attach the responder nonce
			if(!AttachPropertyInstance(hFrame, XSPPropTable[XSP_NONCE_RESP].hProperty, sizeof(pKeyExSgToXbResp->_abNonceResp),
				(LPBYTE) (pKeyExSgToXbResp->_abNonceResp), 0, 3, 0))
			{
				goto Exit;
			}
			
			// Attach the encrypted SG parameters
			if(!AttachPropertyInstance(hFrame, XSPPropTable[XSP_ENCRYPT_SG_PARAMS].hProperty,
				( ((LPBYTE) (pKeyExSgToXbResp+1)) - ((LPBYTE)&(pKeyExSgToXbResp->_sgaddrInit))),
				(LPBYTE) &(pKeyExSgToXbResp->_sgaddrInit), 0, 3, 0))
			{
				goto Exit;
			}

			BytesLeft -= pKeyExSgToXbResp->_cbEnt;
            

            // Smooshed packet #2: KEYEX_TYPE_DH_GX (DHGY actually, but who's counting?)
    		// We don't have enough room left for the keyex headers for G^Y values
			if(BytesLeft < sizeof(CKeyExDHGX))
			{
			    goto Exit;
			}
			
			pKeyExDHGX = (CKeyExDHGX *) (pKeyExSgToXbResp + 1);
			
			// Badly formatted packet
			if((pKeyExDHGX->_cbEnt < sizeof(CKeyExDHGX)) || (pKeyExHdr->_cbEnt > BytesLeft))
			{
				goto Exit;
			}
			
            // Summary: KeyExDhGx
			if(!AttachPropertyInstance(hFrame, XSPPropTable[XSP_KEYEX_TYPE].hProperty, pKeyExDHGX->_cbEnt, 
				(LPBYTE)pKeyExDHGX, 0, 2, 0))
			{
				goto Exit;
			}

			// Attach the key exchange type
			if(!AttachPropertyInstance(hFrame, XSPPropTable[XSP_KEYEX_TYPE].hProperty, sizeof(pKeyExDHGX->_wType),
				(LPBYTE) &(pKeyExDHGX->_wType), 0, 3, 0))
			{
				goto Exit;
			}
			
			// Attach the key exchange size
			if(!AttachPropertyInstance(hFrame, XSPPropTable[XSP_ENT_SIZE].hProperty, sizeof(pKeyExDHGX->_cbEnt),
				(LPBYTE) &(pKeyExDHGX->_cbEnt), 0, 3, 0))
			{
				goto Exit;
			}
			
			// If this isn't the G^X value, then we don't know how to interpret it
			if(pKeyExDHGX->_wType != KEYEX_TYPE_DH_GX || BytesLeft < pKeyExDHGX->_cbEnt)
			{
				goto Exit;
			}
			
			// Attach the G^X value
			if(!AttachPropertyInstance(hFrame, XSPPropTable[XSP_DH_GX].hProperty, sizeof(pKeyExDHGX->_ab),
				(LPBYTE) (pKeyExDHGX->_ab), 0, 3, 0))
			{
				goto Exit;
			}
			
			BytesLeft -= pKeyExDHGX->_cbEnt;

            // Advance to the next one, to aid #4 if #3 doesn't exist
            pKeyExHdr = (CKeyExHdr *)(pKeyExDHGX + 1);

            // Smooshed packet #3: SgToXb challenge (optional)
            if(BytesLeft < sizeof(CKeyExHdr))
            {
                goto Exit;
            }
            if (pKeyExHdr->_wType == KEYEX_TYPE_SGTOXB_CHAL)
            {
                // Note that cbEnt can be larger than sizeof(CKeyExSgToXbChal), depending on the code
                // challenge size.
    			pKeyExChal = (CKeyExSgToXbChal *) (pKeyExHdr);
    			
    			// Badly formatted packet
    			if((pKeyExChal->_cbEnt < sizeof(CKeyExSgToXbChal)) || (pKeyExChal->_cbEnt > BytesLeft))
    			{
    				goto Exit;
    			}
    			
                // Summary: KeyExDhGx
    			if(!AttachPropertyInstance(hFrame, XSPPropTable[XSP_KEYEX_TYPE].hProperty, pKeyExChal->_cbEnt, 
    				(LPBYTE)pKeyExChal, 0, 2, 0))
    			{
    				goto Exit;
    			}

                // Attach the key exchange type
    			if(!AttachPropertyInstance(hFrame, XSPPropTable[XSP_KEYEX_TYPE].hProperty, sizeof(pKeyExChal->_wType),
    				(LPBYTE) &(pKeyExChal->_wType), 0, 3, 0))
    			{
    				goto Exit;
    			}
    			
    			// Attach the key exchange size
    			if(!AttachPropertyInstance(hFrame, XSPPropTable[XSP_ENT_SIZE].hProperty, sizeof(pKeyExChal->_cbEnt),
    				(LPBYTE) &(pKeyExChal->_cbEnt), 0, 3, 0))
    			{
    				goto Exit;
    			}
    			
    			// Attach the dvd block
    			if(!AttachPropertyInstance(hFrame, XSPPropTable[XSP_CHAL_DVDBLOCK].hProperty, sizeof(pKeyExChal->_dwDvdBlock),
    				(LPBYTE) &(pKeyExChal->_dwDvdBlock), 0, 3, 0))
    			{
    				goto Exit;
    			}

    			// Attach the dvd hash offset
    			if(!AttachPropertyInstance(hFrame, XSPPropTable[XSP_CHAL_DVDHASH].hProperty, sizeof(pKeyExChal->_ibDvdHash),
    				(LPBYTE) &(pKeyExChal->_ibDvdHash), 0, 3, 0))
    			{
    				goto Exit;
    			}

    			// Attach the dvd copy offset
    			if(!AttachPropertyInstance(hFrame, XSPPropTable[XSP_CHAL_DVDCOPY].hProperty, sizeof(pKeyExChal->_ibDvdCopy),
    				(LPBYTE) &(pKeyExChal->_ibDvdCopy), 0, 3, 0))
    			{
    				goto Exit;
    			}

    			// Attach the params
    			if(!AttachPropertyInstance(hFrame, XSPPropTable[XSP_CHAL_PARAMS].hProperty, sizeof(pKeyExChal->_abParams),
    				(LPBYTE) (pKeyExChal->_abParams), 0, 3, 0))
    			{
    				goto Exit;
    			}

                // Badly formatted packet
                if (BytesLeft < (pKeyExChal->_cbEnt - sizeof(CKeyExSgToXbChal)) + sizeof(pKeyExChal->_abPkSig))
                {
                    goto Exit;
                }
                
    			// Attach the code challenge (length depends on cbEnt)
    			if(!AttachPropertyInstance(hFrame, XSPPropTable[XSP_CHAL_PARAMS].hProperty, (pKeyExChal->_cbEnt - sizeof(CKeyExSgToXbChal)) + sizeof(pKeyExChal->_abPkSig),
    				(LPBYTE) (pKeyExChal->_abPkSig), 0, 3, 0))
    			{
    				goto Exit;
    			}
    			
    			BytesLeft -= pKeyExChal->_cbEnt;

                // Advance to the next one, to aid #4
                pKeyExHdr = (CKeyExHdr *)(((BYTE*)(pKeyExChal)) + pKeyExChal->_cbEnt);
            }


            // Smooshed packet #4: AP reply
			// Do we have enough room left for the AP reply header?
			if(BytesLeft < sizeof(CKeyExHdr))
			{
				goto Exit;
			}
            // pKeyExHdr should already point to our byte section
			pKeyExApRep = (CKeyExKerbApRep *)(pKeyExHdr);
			
            // Summary: APRep
			if(!AttachPropertyInstance(hFrame, XSPPropTable[XSP_KEYEX_TYPE].hProperty, pKeyExApRep->_cbEnt, 
				(LPBYTE)pKeyExApRep, 0, 2, 0))
			{
				goto Exit;
			}

			// Attach the key exchange type
			if(!AttachPropertyInstance(hFrame, XSPPropTable[XSP_KEYEX_TYPE].hProperty, sizeof(pKeyExApRep->_wType),
				(LPBYTE) &(pKeyExApRep->_wType), 0, 3, 0))
			{
				goto Exit;
			}
			
			// Attach the key exchange size
			if(!AttachPropertyInstance(hFrame, XSPPropTable[XSP_ENT_SIZE].hProperty, sizeof(pKeyExApRep->_cbEnt),
				(LPBYTE) &(pKeyExApRep->_cbEnt), 0, 3, 0))
			{
				goto Exit;
			}
			
			// If this isn't the APREP value, then we don't know how to interpret it
			if(pKeyExApRep->_wType != KEYEX_TYPE_KERB_APREP || BytesLeft < pKeyExApRep->_cbEnt)
			{
				goto Exit;
			}
			
			// Attach the APREP value
			if(!AttachPropertyInstance(hFrame, XSPPropTable[XSP_AP_REQ].hProperty, pKeyExApRep->_cbEnt -sizeof(CKeyExHdr),
				(LPBYTE) (pKeyExApRep->_ab), 0, 3, 0))
			{
				goto Exit;
			}
			
			BytesLeft -= pKeyExApRep->_cbEnt;

            
			// We've claimed the packet so when we return, point to the next byte after the received packet
			pNextFrame += cbOriginal;
			break;

			// Parse Xbox-to-TS packets
		case KEYEX_TYPE_XBTOTS_INIT:
			
			// Badly formatted packet
			if((pKeyExHdr->_cbEnt < sizeof(CKeyExXbToTsInit)) || (pKeyExHdr->_cbEnt > BytesLeft))
			{
				goto Exit;
			}
			
			pKeyExXbToTsInit = (CKeyExXbToTsInit *) pKeyExHdr;
			
			// We've identified an Xbox-to-TS init packet
			if(!AttachPropertyInstance(hFrame, XSPPropTable[XSP_SUMMARY_X2T_INIT].hProperty, cbOriginal, 
				(LPBYTE) pXSPFrame, 0, 1, 0))
			{
				goto Exit;
			}
			
			// Attach the SPI
			dwSpi = pXspHdr->_dwSpiAndFlags & XSP_SPI_MASK;
			if(!AttachPropertyInstanceEx(hFrame, XSPPropTable[XSP_SPI].hProperty, sizeof(pXspHdr->_dwSpiAndFlags), (LPBYTE) &(pXspHdr->_dwSpiAndFlags),
				sizeof(dwSpi), (LPBYTE) &dwSpi, 0, 2, 0))
			{
				goto Exit;
			}

            // Summary: KeyExXbToTsInit
			if(!AttachPropertyInstance(hFrame, XSPPropTable[XSP_KEYEX_TYPE].hProperty, pKeyExXbToTsInit->_cbEnt, 
				(LPBYTE)pKeyExXbToTsInit, 0, 2, 0))
			{
				goto Exit;
			}
			
			// Attach the key exchange type
			if(!AttachPropertyInstance(hFrame, XSPPropTable[XSP_KEYEX_TYPE].hProperty, sizeof(pKeyExXbToTsInit->_wType),
				(LPBYTE) &(pKeyExXbToTsInit->_wType), 0, 3, 0))
			{
				goto Exit;
			}
			
			// Attach the key exchange size
			if(!AttachPropertyInstance(hFrame, XSPPropTable[XSP_ENT_SIZE].hProperty, sizeof(pKeyExXbToTsInit->_cbEnt),
				(LPBYTE) &(pKeyExXbToTsInit->_cbEnt), 0, 3, 0))
			{
				goto Exit;
			}
			
			// Attach the xbox to secure gateway flags
			if(!AttachPropertyInstance(hFrame, XSPPropTable[XSP_X2S_FLAGS].hProperty, sizeof(pKeyExXbToTsInit->_wFlags),
				(LPBYTE) &(pKeyExXbToTsInit->_wFlags), 0, 3, 0))
			{
				goto Exit;
			}
			
			// Attach the key ID
			if(!AttachPropertyInstance(hFrame, XSPPropTable[XSP_XNKID].hProperty, sizeof(pKeyExXbToTsInit->_xnkid),
				(LPBYTE) &(pKeyExXbToTsInit->_xnkid), 0, 3, 0))
			{
				goto Exit;
			}

			// Attach the initiator SPI
			if(!AttachPropertyInstance(hFrame, XSPPropTable[XSP_SPI_INIT].hProperty, sizeof(pKeyExXbToTsInit->_dwSpiInit),
				(LPBYTE) &(pKeyExXbToTsInit->_dwSpiInit), 0, 3, 0))
			{
				goto Exit;
			}
			
			// Attach the initiator nonce
			if(!AttachPropertyInstance(hFrame, XSPPropTable[XSP_NONCE_INIT].hProperty, sizeof(pKeyExXbToTsInit->_abNonceInit),
				(LPBYTE) &(pKeyExXbToTsInit->_abNonceInit), 0, 3, 0))
			{
				goto Exit;
			}
			
			// Attach user permutation flags
			if(!AttachPropertyInstance(hFrame, XSPPropTable[XSP_USER_PERM].hProperty, sizeof(pKeyExXbToTsInit->_dwUserPerm),
				(LPBYTE) &(pKeyExXbToTsInit->_dwUserPerm), 0, 3, 0))
			{
				goto Exit;
			}

            BytesLeft -= pKeyExXbToTsInit->_cbEnt;
            

            // Smooshed packet #2: APREQ
			// Do we have enough room left for the AP request header?
			if(BytesLeft < sizeof(CKeyExHdr))
			{
				goto Exit;
			}
			pKeyExApReq = (CKeyExKerbApReq *)(pKeyExXbToTsInit + 1);
            
			// Badly formatted header packet
			if((pKeyExApReq->_cbEnt > BytesLeft))
			{
				goto Exit;
			}

            // Summary: ApReq
			if(!AttachPropertyInstance(hFrame, XSPPropTable[XSP_KEYEX_TYPE].hProperty, pKeyExApReq->_cbEnt, 
				(LPBYTE)pKeyExApReq, 0, 2, 0))
			{
				goto Exit;
			}
            
			// Attach the key exchange type
			if(!AttachPropertyInstance(hFrame, XSPPropTable[XSP_KEYEX_TYPE].hProperty, sizeof(pKeyExApReq->_wType),
				(LPBYTE) &(pKeyExApReq->_wType), 0, 3, 0))
			{
				goto Exit;
			}
			
			// Attach the key exchange size
			if(!AttachPropertyInstance(hFrame, XSPPropTable[XSP_ENT_SIZE].hProperty, sizeof(pKeyExApReq->_cbEnt),
				(LPBYTE) &(pKeyExApReq->_cbEnt), 0, 3, 0))
			{
				goto Exit;
			}
			
			// If this isn't the APREQ value, then we don't know how to interpret it
			if(pKeyExApReq->_wType != KEYEX_TYPE_KERB_APREQ || BytesLeft < pKeyExApReq->_cbEnt)
			{
				goto Exit;
			}
			
			// Attach the APREQ value
			if(!AttachPropertyInstance(hFrame, XSPPropTable[XSP_AP_REQ].hProperty, pKeyExApReq->_cbEnt -sizeof(CKeyExHdr),
				(LPBYTE) (pKeyExApReq->_ab), 0, 3, 0))
			{
				goto Exit;
			}
			
			BytesLeft -= pKeyExApReq->_cbEnt;

			
			// We've claimed the packet so when we return, point to the next byte after the received packet
			pNextFrame += cbOriginal;
			break;

			// Parse TS-to-Xbox packets
		case KEYEX_TYPE_TSTOXB_RESP:
			
			// Badly formatted packet
			if((pKeyExHdr->_cbEnt < sizeof(CKeyExTsToXbResp)) || (pKeyExHdr->_cbEnt > BytesLeft))
			{
				goto Exit;
			}
			
			pKeyExTsToXbResp = (CKeyExTsToXbResp *) pKeyExHdr;
			
			// We've identified an TS-to-Xbox response packet
			if(!AttachPropertyInstance(hFrame, XSPPropTable[XSP_SUMMARY_T2X_RESP].hProperty, cbOriginal, 
				(LPBYTE) pXSPFrame, 0, 1, 0))
			{
				goto Exit;
			}
			
			// Attach the SPI
			dwSpi = pXspHdr->_dwSpiAndFlags & XSP_SPI_MASK;
			if(!AttachPropertyInstanceEx(hFrame, XSPPropTable[XSP_SPI].hProperty, sizeof(pXspHdr->_dwSpiAndFlags), (LPBYTE) &(pXspHdr->_dwSpiAndFlags),
				sizeof(dwSpi), (LPBYTE) &dwSpi, 0, 2, 0))
			{
				goto Exit;
			}

            // Summary: KeyExXbToTsInit
			if(!AttachPropertyInstance(hFrame, XSPPropTable[XSP_KEYEX_TYPE].hProperty, pKeyExTsToXbResp->_cbEnt, 
				(LPBYTE)pKeyExTsToXbResp, 0, 2, 0))
			{
				goto Exit;
			}
			
			// Attach the key exchange type
			if(!AttachPropertyInstance(hFrame, XSPPropTable[XSP_KEYEX_TYPE].hProperty, sizeof(pKeyExTsToXbResp->_wType),
				(LPBYTE) &(pKeyExTsToXbResp->_wType), 0, 3, 0))
			{
				goto Exit;
			}
			
			// Attach the key exchange size
			if(!AttachPropertyInstance(hFrame, XSPPropTable[XSP_ENT_SIZE].hProperty, sizeof(pKeyExTsToXbResp->_cbEnt),
				(LPBYTE) &(pKeyExTsToXbResp->_cbEnt), 0, 3, 0))
			{
				goto Exit;
			}
			
			// Attach the secure gateway to xb flags
			if(!AttachPropertyInstance(hFrame, XSPPropTable[XSP_S2X_FLAGS].hProperty, sizeof(pKeyExTsToXbResp->_wFlags),
				(LPBYTE) &(pKeyExTsToXbResp->_wFlags), 0, 3, 0))
			{
				goto Exit;
			}
			
			// Attach the initiator SPI
			if(!AttachPropertyInstance(hFrame, XSPPropTable[XSP_SPI_INIT].hProperty, sizeof(pKeyExTsToXbResp->_dwSpiInit),
				(LPBYTE) &(pKeyExTsToXbResp->_dwSpiInit), 0, 3, 0))
			{
				goto Exit;
			}
			
			// Attach the responder SPI
			if(!AttachPropertyInstance(hFrame, XSPPropTable[XSP_SPI_RESP].hProperty, sizeof(pKeyExTsToXbResp->_dwSpiResp),
				(LPBYTE) &(pKeyExTsToXbResp->_dwSpiResp), 0, 3, 0))
			{
				goto Exit;
			}
			
			// Attach the initiator nonce
			if(!AttachPropertyInstance(hFrame, XSPPropTable[XSP_NONCE_INIT].hProperty, sizeof(pKeyExTsToXbResp->_abNonceInit),
				(LPBYTE) &(pKeyExTsToXbResp->_abNonceInit), 0, 3, 0))
			{
				goto Exit;
			}
			
			// Attach the responder nonce
			if(!AttachPropertyInstance(hFrame, XSPPropTable[XSP_NONCE_RESP].hProperty, sizeof(pKeyExTsToXbResp->_abNonceResp),
				(LPBYTE) &(pKeyExTsToXbResp->_abNonceResp), 0, 3, 0))
			{
				goto Exit;
			}
			
			// Attach the inbound timeout
			if(!AttachPropertyInstance(hFrame, XSPPropTable[XSP_TS_IN_TIMEOUT].hProperty, sizeof(pKeyExTsToXbResp->_wXbToTsTimeoutInSecs),
				(LPBYTE) &(pKeyExTsToXbResp->_wXbToTsTimeoutInSecs), 0, 3, 0))
			{
				goto Exit;
			}

			// Attach the inbound timeout
			if(!AttachPropertyInstance(hFrame, XSPPropTable[XSP_TS_OUT_TIMEOUT].hProperty, sizeof(pKeyExTsToXbResp->_wXbToTsPulseTimeoutInSecs),
				(LPBYTE) &(pKeyExTsToXbResp->_wXbToTsPulseTimeoutInSecs), 0, 3, 0))
			{
				goto Exit;
			}

            BytesLeft -= pKeyExTsToXbResp->_cbEnt;

            // Smooshed packet #2: AP reply
			// Do we have enough room left for the AP reply header?
			if(BytesLeft < sizeof(CKeyExHdr))
			{
				goto Exit;
			}

			pKeyExApRep = (CKeyExKerbApRep *)(pKeyExTsToXbResp + 1);
			
            // Summary: APRep
			if(!AttachPropertyInstance(hFrame, XSPPropTable[XSP_KEYEX_TYPE].hProperty, pKeyExApRep->_cbEnt, 
				(LPBYTE)pKeyExApRep, 0, 2, 0))
			{
				goto Exit;
			}

			// Attach the key exchange type
			if(!AttachPropertyInstance(hFrame, XSPPropTable[XSP_KEYEX_TYPE].hProperty, sizeof(pKeyExApRep->_wType),
				(LPBYTE) &(pKeyExApRep->_wType), 0, 3, 0))
			{
				goto Exit;
			}
			
			// Attach the key exchange size
			if(!AttachPropertyInstance(hFrame, XSPPropTable[XSP_ENT_SIZE].hProperty, sizeof(pKeyExApRep->_cbEnt),
				(LPBYTE) &(pKeyExApRep->_cbEnt), 0, 3, 0))
			{
				goto Exit;
			}
			
			// If this isn't the APREP value, then we don't know how to interpret it
			if(pKeyExApRep->_wType != KEYEX_TYPE_KERB_APREP || BytesLeft < pKeyExApRep->_cbEnt)
			{
				goto Exit;
			}
			
			// Attach the APREP value
			if(!AttachPropertyInstance(hFrame, XSPPropTable[XSP_AP_REQ].hProperty, pKeyExApRep->_cbEnt -sizeof(CKeyExHdr),
				(LPBYTE) (pKeyExApRep->_ab), 0, 3, 0))
			{
				goto Exit;
			}
			
			BytesLeft -= pKeyExApRep->_cbEnt;

            
			// We've claimed the packet so when we return, point to the next byte after the received packet
			pNextFrame += cbOriginal;
			break;

			// Parse NAT open packets
		case KEYEX_TYPE_NATOPEN_INIT:
		case KEYEX_TYPE_NATOPEN_RESP:
			// Badly formatted packet
			if((pKeyExHdr->_cbEnt < sizeof(CKeyExNatOpen)) || (pKeyExHdr->_cbEnt > BytesLeft))
			{
				goto Exit;
			}
			
			pKeyExNatOpen = (CKeyExNatOpen *) pKeyExHdr;
			
			if(pKeyExNatOpen->_wType == KEYEX_TYPE_NATOPEN_INIT)
			{
				// We're dealing with...
				// 1) NAT open init packet
				if(!AttachPropertyInstance(hFrame, XSPPropTable[XSP_SUMMARY_NATOPEN_INIT].hProperty, cbOriginal, 
					(LPBYTE) pXSPFrame, 0, 1, 0))
				{
					goto Exit;
				}
			}
			else
			{
				// We're dealing with...
				// 2) NAT open response packet
				if(!AttachPropertyInstance(hFrame, XSPPropTable[XSP_SUMMARY_NATOPEN_RESP].hProperty, cbOriginal, 
					(LPBYTE) pXSPFrame, 0, 1, 0))
				{
					goto Exit;
				}
			}
			
			// Attach the SPI
			dwSpi = pXspHdr->_dwSpiAndFlags & XSP_SPI_MASK;
			if(!AttachPropertyInstanceEx(hFrame, XSPPropTable[XSP_SPI].hProperty, sizeof(pXspHdr->_dwSpiAndFlags), (LPBYTE) &(pXspHdr->_dwSpiAndFlags),
				sizeof(dwSpi), (LPBYTE) &dwSpi, 0, 2, 0))
			{
				goto Exit;
			}
			
			// Attach the key exchange type
			if(!AttachPropertyInstance(hFrame, XSPPropTable[XSP_KEYEX_TYPE].hProperty, sizeof(pKeyExNatOpen->_wType),
				(LPBYTE) &(pKeyExNatOpen->_wType), 0, 2, 0))
			{
				goto Exit;
			}
			
			// Attach the key exchange type
			if(!AttachPropertyInstance(hFrame, XSPPropTable[XSP_ENT_SIZE].hProperty, sizeof(pKeyExNatOpen->_cbEnt),
				(LPBYTE) &(pKeyExNatOpen->_cbEnt), 0, 2, 0))
			{
				goto Exit;
			}
			
			// Attach the version
			if(!AttachPropertyInstance(hFrame, XSPPropTable[XSP_VERSION].hProperty, sizeof(pKeyExNatOpen->_wVersion),
				(LPBYTE) &(pKeyExNatOpen->_wVersion), 0, 2, 0))
			{
				goto Exit;
			}
			
			// Attach the nat open flags
			if(!AttachPropertyInstance(hFrame, XSPPropTable[XSP_NATOPEN_FLAGS].hProperty, sizeof(pKeyExNatOpen->_wFlags),
				(LPBYTE) &(pKeyExNatOpen->_wFlags), 0, 2, 0))
			{
				goto Exit;
			}
			
			// Attach the key ID
			if(!AttachPropertyInstance(hFrame, XSPPropTable[XSP_XNKID].hProperty, sizeof(pKeyExNatOpen->_xnkid),
				(LPBYTE) &(pKeyExNatOpen->_xnkid), 0, 2, 0))
			{
				goto Exit;
			}
			
			if(pKeyExNatOpen->_wType == KEYEX_TYPE_NATOPEN_INIT)
			{
				// Attach the sender nonce
				if(!AttachPropertyInstance(hFrame, XSPPropTable[XSP_NONCE_INIT].hProperty, sizeof(pKeyExNatOpen->_abNonce),
					(LPBYTE) &(pKeyExNatOpen->_abNonce), 0, 2, 0))
				{
					goto Exit;
				}
			}
			else
			{
				// Attach the sender nonce
				if(!AttachPropertyInstance(hFrame, XSPPropTable[XSP_NONCE_RESP].hProperty, sizeof(pKeyExNatOpen->_abNonce),
					(LPBYTE) &(pKeyExNatOpen->_abNonce), 0, 2, 0))
				{
					goto Exit;
				}
			}
			
			// Attach the sender context
			if(!AttachPropertyInstance(hFrame, XSPPropTable[XSP_CONTEXT].hProperty, sizeof(pKeyExNatOpen->_dwCtx),
				(LPBYTE) &(pKeyExNatOpen->_dwCtx), 0, 2, 0))
			{
				goto Exit;
			}
			
			// Attach the IP address of the sender
			if(!AttachPropertyInstance(hFrame, XSPPropTable[XSP_IP_ADDRESS].hProperty, sizeof(pKeyExNatOpen->_ipaDst),
				(LPBYTE) &(pKeyExNatOpen->_ipaDst), 0, 2, 0))
			{
				goto Exit;
			}

			// Attach the IP port of the sender
			wSourcePort =  NTOHS((WORD) pKeyExNatOpen->_ipportDst);
			if(!AttachPropertyInstanceEx(hFrame, XSPPropTable[XSP_IP_PORT].hProperty, sizeof(BYTE),
				(LPBYTE) &(pKeyExNatOpen->_ipportDst), sizeof(wSourcePort), &wSourcePort, 0, 2, 0))
			{
				goto Exit;
			}					

			// Attach the nat open hash
			if(!AttachPropertyInstance(hFrame, XSPPropTable[XSP_HASH].hProperty, sizeof(pKeyExNatOpen->_abHash),
				(LPBYTE) &(pKeyExNatOpen->_abHash), 0, 2, 0))
			{
				goto Exit;
			}
			
			// We've claimed the packet so when we return, point to the next byte after the received packet
			pNextFrame += cbOriginal;
			break;
			
			// Parse QOS initiator packet
		case KEYEX_TYPE_QOS_INIT:
			
			// Badly formatted packet
			if((pKeyExHdr->_cbEnt < sizeof(CKeyExQosInit)) || (pKeyExHdr->_cbEnt > BytesLeft))
			{
				goto Exit;
			}
			
			pKeyExQosInit = (CKeyExQosInit *) pKeyExHdr;
			
			// We've identified a QOS initiator packet
			if(!AttachPropertyInstance(hFrame, XSPPropTable[XSP_SUMMARY_QOS_INIT].hProperty, cbOriginal, 
				(LPBYTE) pXSPFrame, 0, 1, 0))
			{
				goto Exit;
			}
			
			// Attach the SPI
			dwSpi = pXspHdr->_dwSpiAndFlags & XSP_SPI_MASK;
			if(!AttachPropertyInstanceEx(hFrame, XSPPropTable[XSP_SPI].hProperty, sizeof(pXspHdr->_dwSpiAndFlags), (LPBYTE) &(pXspHdr->_dwSpiAndFlags),
				sizeof(dwSpi), (LPBYTE) &dwSpi, 0, 2, 0))
			{
				goto Exit;
			}
			
			// Attach the key exchange type
			if(!AttachPropertyInstance(hFrame, XSPPropTable[XSP_KEYEX_TYPE].hProperty, sizeof(pKeyExQosInit->_wType),
				(LPBYTE) &(pKeyExQosInit->_wType), 0, 2, 0))
			{
				goto Exit;
			}
			
			// Attach the key exchange size
			if(!AttachPropertyInstance(hFrame, XSPPropTable[XSP_ENT_SIZE].hProperty, sizeof(pKeyExQosInit->_cbEnt),
				(LPBYTE) &(pKeyExQosInit->_cbEnt), 0, 2, 0))
			{
				goto Exit;
			}
			
			// Attach the version
			if(!AttachPropertyInstance(hFrame, XSPPropTable[XSP_VERSION].hProperty, sizeof(pKeyExQosInit->_wVersion),
				(LPBYTE) &(pKeyExQosInit->_wVersion), 0, 2, 0))
			{
				goto Exit;
			}
			
			// Attach the sender nonce
			if(!AttachPropertyInstance(hFrame, XSPPropTable[XSP_NONCE_INIT].hProperty, sizeof(pKeyExQosInit->_abNonce),
				(LPBYTE) &(pKeyExQosInit->_abNonce), 0, 2, 0))
			{
				goto Exit;
			}
			
			// Attach the QOS index
			if(!AttachPropertyInstance(hFrame, XSPPropTable[XSP_QOS_INDEX].hProperty, sizeof(pKeyExQosInit->_wQosIdx),
				(LPBYTE) &(pKeyExQosInit->_wQosIdx), 0, 2, 0))
			{
				goto Exit;
			}
			
			// Attach the QOS sequence number
			if(!AttachPropertyInstance(hFrame, XSPPropTable[XSP_QOS_SEQNUM].hProperty, sizeof(pKeyExQosInit->_bPktIdx),
				(LPBYTE) &(pKeyExQosInit->_bPktIdx), 0, 2, 0))
			{
				goto Exit;
			}
			
			// Attach the QOS flags
			if(!AttachPropertyInstance(hFrame, XSPPropTable[XSP_QOS_FLAGS].hProperty, sizeof(pKeyExQosInit->_bFlags),
				(LPBYTE) &(pKeyExQosInit->_bFlags), 0, 2, 0))
			{
				goto Exit;
			}
			
			// Attach the key ID
			if(!AttachPropertyInstance(hFrame, XSPPropTable[XSP_XNKID].hProperty, sizeof(pKeyExQosInit->_xnkid),
				(LPBYTE) &(pKeyExQosInit->_xnkid), 0, 2, 0))
			{
				goto Exit;
			}
			
			// Attach the  XNADDR of the responder
			if(!AttachPropertyInstance(hFrame, XSPPropTable[XSP_QOS_XNADDR].hProperty, sizeof(pKeyExQosInit->_xnaddr),
				(LPBYTE) &(pKeyExQosInit->_xnaddr), 0, 2, 0))
			{
				goto Exit;
			}
			
			// Attach the QOS hash
			if(!AttachPropertyInstance(hFrame, XSPPropTable[XSP_HASH].hProperty, sizeof(pKeyExQosInit->_abHash),
				(LPBYTE) &(pKeyExQosInit->_abHash), 0, 2, 0))
			{
				goto Exit;
			}
			
			// We've claimed the packet so when we return, point to the next byte after the received packet
			pNextFrame += cbOriginal;
			break;
			
			// Parse QOS response packet
		case KEYEX_TYPE_QOS_RESP:
			
			// Badly formatted packet
			if((pKeyExHdr->_cbEnt < sizeof(CKeyExQosResp)) || (pKeyExHdr->_cbEnt > BytesLeft))
			{
				goto Exit;
			}
			
			pKeyExQosResp = (CKeyExQosResp *) pKeyExHdr;
			
			// We've identified a QOS response packet
			if(!AttachPropertyInstance(hFrame, XSPPropTable[XSP_SUMMARY_QOS_RESP].hProperty, cbOriginal, 
				(LPBYTE) pXSPFrame, 0, 1, 0))
			{
				goto Exit;
			}
			
			// Attach the SPI
			dwSpi = pXspHdr->_dwSpiAndFlags & XSP_SPI_MASK;
			if(!AttachPropertyInstanceEx(hFrame, XSPPropTable[XSP_SPI].hProperty, sizeof(pXspHdr->_dwSpiAndFlags), (LPBYTE) &(pXspHdr->_dwSpiAndFlags),
				sizeof(dwSpi), (LPBYTE) &dwSpi, 0, 2, 0))
			{
				goto Exit;
			}
			
			// Attach the key exchange type
			if(!AttachPropertyInstance(hFrame, XSPPropTable[XSP_KEYEX_TYPE].hProperty, sizeof(pKeyExQosResp->_wType),
				(LPBYTE) &(pKeyExQosResp->_wType), 0, 2, 0))
			{
				goto Exit;
			}
			
			// Attach the key exchange size
			if(!AttachPropertyInstance(hFrame, XSPPropTable[XSP_ENT_SIZE].hProperty, sizeof(pKeyExQosResp->_cbEnt),
				(LPBYTE) &(pKeyExQosResp->_cbEnt), 0, 2, 0))
			{
				goto Exit;
			}
			
			// Attach the version
			if(!AttachPropertyInstance(hFrame, XSPPropTable[XSP_VERSION].hProperty, sizeof(pKeyExQosResp->_wVersion),
				(LPBYTE) &(pKeyExQosResp->_wVersion), 0, 2, 0))
			{
				goto Exit;
			}
			
			// Attach the sender nonce
			if(!AttachPropertyInstance(hFrame, XSPPropTable[XSP_NONCE_INIT].hProperty, sizeof(pKeyExQosResp->_abNonce),
				(LPBYTE) &(pKeyExQosResp->_abNonce), 0, 2, 0))
			{
				goto Exit;
			}
			
			// Attach the QOS index
			if(!AttachPropertyInstance(hFrame, XSPPropTable[XSP_QOS_INDEX].hProperty, sizeof(pKeyExQosResp->_wQosIdx),
				(LPBYTE) &(pKeyExQosResp->_wQosIdx), 0, 2, 0))
			{
				goto Exit;
			}
			
			// Attach the QOS sequence number
			if(!AttachPropertyInstance(hFrame, XSPPropTable[XSP_QOS_SEQNUM].hProperty, sizeof(pKeyExQosResp->_bPktIdx),
				(LPBYTE) &(pKeyExQosResp->_bPktIdx), 0, 2, 0))
			{
				goto Exit;
			}
			
			// Attach the QOS flags
			if(!AttachPropertyInstance(hFrame, XSPPropTable[XSP_QOS_FLAGS].hProperty, sizeof(pKeyExQosResp->_bFlags),
				(LPBYTE) &(pKeyExQosResp->_bFlags), 0, 2, 0))
			{
				goto Exit;
			}
			
			// Attach the QOS round trip time
			if(!AttachPropertyInstance(hFrame, XSPPropTable[XSP_QOS_RTT].hProperty, sizeof(pKeyExQosResp->_dwusRtt),
				(LPBYTE) &(pKeyExQosResp->_dwusRtt), 0, 2, 0))
			{
				goto Exit;
			}
			
			// Attach the QOS gap
			if(!AttachPropertyInstance(hFrame, XSPPropTable[XSP_QOS_GAP].hProperty, sizeof(pKeyExQosResp->_dwusGap),
				(LPBYTE) &(pKeyExQosResp->_dwusGap), 0, 2, 0))
			{
				goto Exit;
			}
			
			// Attach the QOS pad len
			if(!AttachPropertyInstance(hFrame, XSPPropTable[XSP_QOS_PADLEN].hProperty, sizeof(pKeyExQosResp->_bPadLen),
				(LPBYTE) &(pKeyExQosResp->_bPadLen), 0, 2, 0))
			{
				goto Exit;
			}
			
			// Attach the QOS hash
			if(!AttachPropertyInstance(hFrame, XSPPropTable[XSP_HASH].hProperty, sizeof(pKeyExQosInit->_abHash),
				(LPBYTE) &(pKeyExQosInit->_abHash), 0, 2, 0))
			{
				goto Exit;
			}
			
			// Attach any remaining data at end of QOS response
			if(pKeyExHdr->_cbEnt > sizeof(CKeyExQosResp))
			{
				// Attach the QOS hash
				if(!AttachPropertyInstance(hFrame, XSPPropTable[XSP_QOS_DATA].hProperty, pKeyExHdr->_cbEnt - sizeof(CKeyExQosResp),
					(LPBYTE) (pKeyExQosInit + 1), 0, 2, 0))
				{
					goto Exit;
				}
			}
			
			// We've claimed the packet so when we return, point to the next byte after the received packet
			pNextFrame += cbOriginal;
			break;
			
			// Unknown packet type
		default:
			goto Exit;
		}
	}
	else
	{
		// Parse encapsulated packets
		
		// Badly formatted packet
		if(BytesLeft < (XSPHDRSIZE + sizeof(CXspTail)))
		{
			goto Exit;
		}
		
		cbPad = (((pXspHdr->_bFlags) & XSP_DATPAD_MASK) >> XSP_DATPAD_SHIFT);
		
		// Badly formatted packet
		if(BytesLeft < (XSPHDRSIZE + cbPad + sizeof(CXspTail)))
		{
			goto Exit;
		}
		
		bXspType = ((pXspHdr->_bFlags) & XSP_TYPE_MASK);

        // Calculate packet field variables
		switch(bXspType)
		{
		case XSP_TYPE_SEC:
			cbTex = 0;
			cbTov = 0;
			break;
		case XSP_TYPE_TCP_0:
			cbTex = 12;
			cbTov = cbPad;
			break;
		case XSP_TYPE_TCP_1:
			cbPorts = 2;
			cbTex = 14;
			cbTov = cbPad;
			break;
		case XSP_TYPE_TCP_2:
			cbPorts = 4;
			cbTex = 16;
			cbTov = cbPad;
			break;
		case XSP_TYPE_UDP_0:
		case XSP_TYPE_VDP_0:
		case XSP_TYPE_VDP_VO_0:
		case XSP_TYPE_VDP_DO_0:
			cbTex = 0;
			cbTov = 0;
			break;
		case XSP_TYPE_UDP_1:
		case XSP_TYPE_VDP_1:
		case XSP_TYPE_VDP_VO_1:
		case XSP_TYPE_VDP_DO_1:
			cbPorts = 2;
			cbTex = 2;
			if(cbTex < cbPad)
				cbTov = cbTex;
			else
				cbTov = cbPad;
			break;
		case XSP_TYPE_UDP_2:
		case XSP_TYPE_VDP_2:
		case XSP_TYPE_VDP_VO_2:
		case XSP_TYPE_VDP_DO_2:
			cbPorts = 4;
			cbTex = 4;
			if(cbTex < cbPad)
				cbTov = cbTex;
			else
				cbTov = cbPad;
			break;
		default:
			goto Exit;
		}
		
		// There must be enough room in the packet for the maximum of cbTex and cbPad
		if(cbTex > cbPad)
		{
			// Badly formatted packet
			if(BytesLeft < (XSPHDRSIZE + cbTex + sizeof(CXspTail)))
			{
				goto Exit;
			}
		}
		// For TCP packets, cbTex must be larger than cbPad
		else if((bXspType == XSP_TYPE_TCP_0) || (bXspType == XSP_TYPE_TCP_1) || (bXspType == XSP_TYPE_TCP_2))
		{
			goto Exit;
		}
		
		// For VDP packets with both voice and data, cbDat is determined by looking at the byte just before
		// the XSP tail.  The packet must be large enough for cbDat and the unencrypted part of the VDP header
		// (i.e. cbTex - cbTov)
		if((bXspType == XSP_TYPE_VDP_0) || (bXspType == XSP_TYPE_VDP_1) || (bXspType == XSP_TYPE_VDP_2))
		{
			cbDat = *(pXSPFrame + BytesLeft - sizeof(CXspTail) - 1) * 8;

			// Badly formatted packet
			if(BytesLeft < (XSPHDRSIZE + cbDat + (cbTex - cbTov) + sizeof(CXspTail)))
			{
				goto Exit;
			}

			cbTvo = BytesLeft - XSPHDRSIZE - cbDat - (cbTex - cbTov) - sizeof(CXspTail) ;			

			// Voice data has to be at least 1 byte in order to store the cbDat variable in the last byte
			if(!cbTvo)
			{
				goto Exit;
			}
		}
		else if((bXspType == XSP_TYPE_VDP_VO_0) || (bXspType == XSP_TYPE_VDP_VO_1) || (bXspType == XSP_TYPE_VDP_VO_2))
			cbDat = 0;
		else
			cbDat = BytesLeft - XSPHDRSIZE - (cbTex - cbTov) - sizeof(CXspTail);
		
		if((bXspType == XSP_TYPE_VDP_VO_0) || (bXspType == XSP_TYPE_VDP_VO_1) || (bXspType == XSP_TYPE_VDP_VO_2))
		{
			// Since this is a completely unencrypted packet, we shouldn't have any encrypted field padding
			if(cbPad)
			{
				goto Exit;
			}
		}
		
		// Locate the start of the unencrypted info
		pUnencryptedDataIndex = ((LPBYTE) (pXspHdr + 1)) + cbDat;
		
		// Set up the tail pointer
		pXspTail = (CXspTail *) (pXSPFrame + BytesLeft - sizeof(CXspTail));
		
		if(!AttachPropertyInstance(hFrame, XSPPropTable[XSP_SUMMARY_ENCAP_PACKET].hProperty, cbOriginal, 
			(LPBYTE) pXSPFrame, 0, 1, 0))
		{
			goto Exit;
		}
		
		// Attach the encrypted pad length
		if(!AttachPropertyInstanceEx(hFrame, XSPPropTable[XSP_ENCAP_PADLEN].hProperty, sizeof(pXspHdr->_bFlags),
			(LPBYTE) &(pXspHdr->_bFlags), 1, (LPBYTE)&cbPad, 0, 2, 0))
		{
			goto Exit;
		}
		
		// Attach the protocol type
		if(!AttachPropertyInstanceEx(hFrame, XSPPropTable[XSP_ENCAP_PROTOTYPE].hProperty, sizeof(pXspHdr->_bFlags),
			(LPBYTE) &(pXspHdr->_bFlags), 1, &bXspType, 0, 2, 0))
		{
			goto Exit;
		}
		
		// Attach the SPI
		dwSpi = pXspHdr->_dwSpiAndFlags & XSP_SPI_MASK;
		if(!AttachPropertyInstanceEx(hFrame, XSPPropTable[XSP_SPI].hProperty, sizeof(pXspHdr->_dwSpiAndFlags), (LPBYTE) &(pXspHdr->_dwSpiAndFlags),
			sizeof(dwSpi), (LPBYTE) &dwSpi, 0, 2, 0))
		{
			goto Exit;
		}
		
		switch(bXspType)
		{
			// If we're dealing with SEC packets
		case XSP_TYPE_SEC:
			// Attach the encrypted payload data data
			if(!AttachPropertyInstance(hFrame, XSPPropTable[XSP_ENCRYPT_DATA].hProperty, cbDat,
				(LPBYTE) (pXspHdr + 1), 0, 2, 0))
			{
				goto Exit;
			}
			
			break;
			
			// If we're dealing with TCP packets
		case XSP_TYPE_TCP_0:
		case XSP_TYPE_TCP_1:
		case XSP_TYPE_TCP_2:
			
			// Attach the encrypted payload data
			if(!AttachPropertyInstance(hFrame, XSPPropTable[XSP_ENCRYPT_DATA].hProperty, cbDat,
				(LPBYTE) (pXspHdr + 1), 0, 2, 0))
			{
				goto Exit;
			}
			
			// Note, we don't have to check that cbTex - cbTov is greater than 0 like we do with the
			// other protocols because the TCP info will always have a size greater than the maximum pad
			// And we checked for that already
			
			// Attach the TCP info (we only identify the unencrypted part)
			if(!AttachPropertyInstance(hFrame, XSPPropTable[XSP_TCP_INFO].hProperty, cbTex - cbTov,
				pUnencryptedDataIndex, 0, 2, 0))
			{
				goto Exit;
			}
			
			if(bXspType == XSP_TYPE_TCP_1)
			{
				// Attach the TCP source port
				if(!cbTov)
				{
					wSourcePort =  NTOHS(((WORD) *pUnencryptedDataIndex) + 1000);
					if(!AttachPropertyInstanceEx(hFrame, XSPPropTable[XSP_SOURCE_PORT_1].hProperty, sizeof(BYTE),
						pUnencryptedDataIndex, sizeof(wSourcePort), &wSourcePort, 0, 3, 0))
					{
						goto Exit;
					}					
				}
				
				// Attach the TCP dest port
				if(cbTov <= 1)
				{
					wDestPort = NTOHS(((WORD) *(pUnencryptedDataIndex + (1 - cbTov))) + 1000);
					if(!AttachPropertyInstanceEx(hFrame, XSPPropTable[XSP_DEST_PORT_1].hProperty, sizeof(BYTE),
						pUnencryptedDataIndex + (1 - cbTov), sizeof(wDestPort), &wDestPort, 0, 3, 0))
					{
						goto Exit;
					}					
				}
			}
			else if(bXspType == XSP_TYPE_TCP_2)
			{
				// Attach the TCP source port
				if(!cbTov)
				{
					wSourcePort = NTOHS(*((WORD *) pUnencryptedDataIndex));
					if(!AttachPropertyInstanceEx(hFrame, XSPPropTable[XSP_SOURCE_PORT_2].hProperty, sizeof(WORD),
						pUnencryptedDataIndex, sizeof(wSourcePort), &wSourcePort, 0, 3, 0))
					{
						goto Exit;
					}					
				}
				
				// Attach the TCP dest port
				if(cbTov <= 2)
				{
					wDestPort = NTOHS(*((WORD *) (pUnencryptedDataIndex + (2 - cbTov))));
					if(!AttachPropertyInstanceEx(hFrame, XSPPropTable[XSP_DEST_PORT_2].hProperty, sizeof(WORD),
						pUnencryptedDataIndex + (2 - cbTov), sizeof(wDestPort), &wDestPort, 0, 3, 0))
					{
						goto Exit;
					}					
				}
			}
			
			// Attach the TCP sequence number (if possible)
			if(cbPorts >= cbTov)
			{
				dwSeqNum = NTOHL(*((DWORD *)(pUnencryptedDataIndex + (cbPorts - cbTov))));
				if(!AttachPropertyInstanceEx(hFrame, XSPPropTable[XSP_TCP_SEQNUM].hProperty, sizeof(DWORD),
					pUnencryptedDataIndex + (cbPorts - cbTov), sizeof(dwSeqNum), &dwSeqNum, 0, 3, 0))
				{
					goto Exit;
				}
			}
			
			// Attach the TCP acknowledgement number (if possible)
			if((cbPorts + 4) >= cbTov)
			{
				dwAckNum = NTOHL(*((DWORD *)(pUnencryptedDataIndex + (cbPorts - cbTov) + sizeof(DWORD))));
				if(!AttachPropertyInstanceEx(hFrame, XSPPropTable[XSP_TCP_ACKNUM].hProperty, sizeof(DWORD),
					pUnencryptedDataIndex + (cbPorts - cbTov) + sizeof(DWORD), sizeof(DWORD), &dwAckNum, 0, 3, 0))
				{
					goto Exit;
				}
			}
			
			// Attach the TCP flags
			if(!AttachPropertyInstance(hFrame, XSPPropTable[XSP_TCP_FLAGS].hProperty, sizeof(BYTE),
				pUnencryptedDataIndex + (cbPorts - cbTov) + 2 * sizeof(DWORD) + 1, 0, 3, 0))
			{
				goto Exit;
			}
			
			break;
			
			// If we're dealing with UDP packets
		case XSP_TYPE_UDP_0:
		case XSP_TYPE_UDP_1:
		case XSP_TYPE_UDP_2:
			
			// Attach the encrypted payload data
			if(!AttachPropertyInstance(hFrame, XSPPropTable[XSP_ENCRYPT_DATA].hProperty, cbDat,
				(LPBYTE) (pXspHdr + 1), 0, 2, 0))
			{
				goto Exit;
			}
			
			// If there is any unencrypted UDP data left over after the pad, then parse it
			if(cbTex - cbTov)
			{
				// Attach the UDP info (we only identify the unencrypted part)
				if(!AttachPropertyInstance(hFrame, XSPPropTable[XSP_UDP_INFO].hProperty, cbTex - cbTov,
					pUnencryptedDataIndex, 0, 2, 0))
				{
					goto Exit;
				}

				if(bXspType == XSP_TYPE_UDP_1)
				{
					// Attach the UDP source port
					if(!cbTov)
					{
						wSourcePort =  NTOHS(((WORD) *pUnencryptedDataIndex) + 1000);
						if(!AttachPropertyInstanceEx(hFrame, XSPPropTable[XSP_SOURCE_PORT_1].hProperty, sizeof(BYTE),
							pUnencryptedDataIndex, sizeof(wSourcePort), &wSourcePort, 0, 3, 0))
						{
							goto Exit;
						}					
					}

					// Attach the UDP dest port
					if(cbTov <= 1)
					{
						wDestPort = NTOHS(((WORD) *(pUnencryptedDataIndex + (1 - cbTov))) + 1000);
						if(!AttachPropertyInstanceEx(hFrame, XSPPropTable[XSP_DEST_PORT_1].hProperty, sizeof(BYTE),
							pUnencryptedDataIndex + (1 - cbTov), sizeof(wDestPort), &wDestPort, 0, 3, 0))
						{
							goto Exit;
						}					
					}
				}
				else if(bXspType == XSP_TYPE_UDP_2)
				{
					// Attach the UDP source port
					if(!cbTov)
					{
						wSourcePort = NTOHS(*((WORD *) pUnencryptedDataIndex));
						if(!AttachPropertyInstanceEx(hFrame, XSPPropTable[XSP_SOURCE_PORT_2].hProperty, sizeof(WORD),
							pUnencryptedDataIndex, sizeof(wSourcePort), &wSourcePort, 0, 3, 0))
						{
							goto Exit;
						}					
					}

					// Attach the UDP dest port
					if(cbTov <= 2)
					{
						wDestPort = NTOHS(*((WORD *) (pUnencryptedDataIndex + (2 - cbTov))));
						if(!AttachPropertyInstanceEx(hFrame, XSPPropTable[XSP_DEST_PORT_2].hProperty, sizeof(WORD),
							pUnencryptedDataIndex + (2 - cbTov), sizeof(wDestPort), &wDestPort, 0, 3, 0))
						{
							goto Exit;
						}					
					}
				}
			}
			break;
			
			// If we're dealing with VDP packets
		case XSP_TYPE_VDP_0:
		case XSP_TYPE_VDP_1:
		case XSP_TYPE_VDP_2:

			if(cbDat)
			{
				// Attach the encrypted payload data
				if(!AttachPropertyInstance(hFrame, XSPPropTable[XSP_ENCRYPT_DATA].hProperty, cbDat,
					(LPBYTE) (pXspHdr + 1), 0, 2, 0))
				{
					goto Exit;
				}
			}
			
			// If there is any unencrypted VDP data left over after the pad, then parse it
			if(cbTex - cbTov)
			{
				// Attach the VDP info (we only identify the unencrypted part)
				if(!AttachPropertyInstance(hFrame, XSPPropTable[XSP_VDP_INFO].hProperty, cbTex - cbTov,
					pUnencryptedDataIndex, 0, 2, 0))
				{
					goto Exit;
				}
				
				if(bXspType == XSP_TYPE_VDP_1)
				{
					// Attach the VDP source port
					if(!cbTov)
					{
						wSourcePort =  NTOHS(((WORD) *pUnencryptedDataIndex) + 1000);
						if(!AttachPropertyInstanceEx(hFrame, XSPPropTable[XSP_SOURCE_PORT_1].hProperty, sizeof(BYTE),
							pUnencryptedDataIndex, sizeof(wSourcePort), &wSourcePort, 0, 3, 0))
						{
							goto Exit;
						}					
					}

					// Attach the VDP dest port
					if(cbTov <= 1)
					{
						wDestPort = NTOHS(((WORD) *(pUnencryptedDataIndex + (1 - cbTov))) + 1000);
						if(!AttachPropertyInstanceEx(hFrame, XSPPropTable[XSP_DEST_PORT_1].hProperty, sizeof(BYTE),
							pUnencryptedDataIndex + (1 - cbTov), sizeof(wDestPort), &wDestPort, 0, 3, 0))
						{
							goto Exit;
						}					
					}
				}
				else if(bXspType == XSP_TYPE_VDP_2)
				{
					// Attach the VDP source port
					if(!cbTov)
					{
						wSourcePort = NTOHS(*((WORD *) pUnencryptedDataIndex));
						if(!AttachPropertyInstanceEx(hFrame, XSPPropTable[XSP_SOURCE_PORT_2].hProperty, sizeof(WORD),
							pUnencryptedDataIndex, sizeof(wSourcePort), &wSourcePort, 0, 3, 0))
						{
							goto Exit;
						}					
					}

					// Attach the VDP dest port
					if(cbTov <= 2)
					{
						wDestPort = NTOHS(*((WORD *) (pUnencryptedDataIndex + (2 - cbTov))));
						if(!AttachPropertyInstanceEx(hFrame, XSPPropTable[XSP_DEST_PORT_2].hProperty, sizeof(WORD),
							pUnencryptedDataIndex + (2 - cbTov), sizeof(wDestPort), &wDestPort, 0, 3, 0))
						{
							goto Exit;
						}					
					}
				}
			}

			if(cbTvo - 1)
			{
                // Attach extra info for broadcast system link packets (not really voice)
                if (pEnetHdr->_eaDst.IsBroadcast())
                {
                    if(!AttachPropertyInstance(hFrame, XSPPropTable[XSP_VOICE_DATA_SYSLINK].hProperty, cbTvo - 1,
					    ((LPBYTE) (pXspHdr + 1)) + cbDat + (cbTex - cbTov), 0, 2, 0))
				    {
    					goto Exit;
				    }
                }
                else
                {
                    // Attach the unencrypted voice data
                    if(!AttachPropertyInstance(hFrame, XSPPropTable[XSP_VOICE_DATA].hProperty, cbTvo - 1,
                        ((LPBYTE) (pXspHdr + 1)) + cbDat + (cbTex - cbTov), 0, 2, 0))
                    {
                        goto Exit;
                    }
                }
            }

			// Attach the encrypted data size
			if(!AttachPropertyInstanceEx(hFrame, XSPPropTable[XSP_VDP_DATASIZE].hProperty, 1,
				((LPBYTE) pXspTail) - 1, 4, &cbDat , 0, 2, 0))
			{
				goto Exit;
			}
	
			break;
			
			// If we're dealing with VDP-VO packets
		case XSP_TYPE_VDP_VO_0:
		case XSP_TYPE_VDP_VO_1:
		case XSP_TYPE_VDP_VO_2:
			// Attach the unencrypted voice data
			
			// Attach the VDP info (we only identify the unencrypted part)
			if(!AttachPropertyInstance(hFrame, XSPPropTable[XSP_VDP_INFO].hProperty, cbTex - cbTov,
				pUnencryptedDataIndex, 0, 2, 0))
			{
				goto Exit;
			}
			
			if(bXspType == XSP_TYPE_VDP_VO_1)
			{
				// Note, since the entire packet is unencrypted, we don't have to worry about checking
				// what part is unencrypted or encrypted
				
				if(!AttachPropertyInstance(hFrame, XSPPropTable[XSP_SOURCE_PORT_1].hProperty, sizeof(BYTE),
					pUnencryptedDataIndex, 0, 3, 0))
				{
					goto Exit;
				}					
				
				if(!AttachPropertyInstance(hFrame, XSPPropTable[XSP_DEST_PORT_1].hProperty, sizeof(BYTE),
					pUnencryptedDataIndex + 1, 0, 3, 0))
				{
					goto Exit;
				}					
			}
			else if(bXspType == XSP_TYPE_VDP_VO_2)
			{
				// Note, since the entire packet is unencrypted, we don't have to worry about checking
				// what part is unencrypted or encrypted
				
				if(!AttachPropertyInstance(hFrame, XSPPropTable[XSP_SOURCE_PORT_2].hProperty, sizeof(WORD),
					pUnencryptedDataIndex, 0, 3, 0))
				{
					goto Exit;
				}					
				
				if(!AttachPropertyInstance(hFrame, XSPPropTable[XSP_DEST_PORT_2].hProperty, sizeof(WORD),
					pUnencryptedDataIndex + 2, 0, 3, 0))
				{
					goto Exit;
				}					
			}
			
			// Attach the unencrypted voice data
			if(!AttachPropertyInstance(hFrame, XSPPropTable[XSP_VOICE_DATA].hProperty, BytesLeft - XSPHDRSIZE - cbDat - (cbTex - cbTov) - sizeof(CXspTail),
				((LPBYTE) (pXspHdr + 1)) + cbDat + (cbTex - cbTov), 0, 2, 0))
			{
				goto Exit;
			}
			
			break;
			
			// If we're dealing with VDP-DO packets
		case XSP_TYPE_VDP_DO_0:
		case XSP_TYPE_VDP_DO_1:
		case XSP_TYPE_VDP_DO_2:
			
			// Attach the encrypted payload data
			if(!AttachPropertyInstance(hFrame, XSPPropTable[XSP_ENCRYPT_DATA].hProperty, cbDat,
				(LPBYTE) (pXspHdr + 1), 0, 2, 0))
			{
				goto Exit;
			}
			
			// If there is any unencrypted VDP data left over after the pad, then parse it
			if(cbTex - cbTov)
			{
				// Attach the VDP info (we only identify the unencrypted part)
				if(!AttachPropertyInstance(hFrame, XSPPropTable[XSP_VDP_INFO].hProperty, cbTex - cbTov,
					pUnencryptedDataIndex, 0, 2, 0))
				{
					goto Exit;
				}
				
				if(bXspType == XSP_TYPE_VDP_DO_1)
				{
					// Attach the VDP source port
					if(!cbTov)
					{
						wSourcePort =  NTOHS(((WORD) *pUnencryptedDataIndex) + 1000);
						if(!AttachPropertyInstanceEx(hFrame, XSPPropTable[XSP_SOURCE_PORT_1].hProperty, sizeof(BYTE),
							pUnencryptedDataIndex, sizeof(wSourcePort), &wSourcePort, 0, 3, 0))
						{
							goto Exit;
						}					
					}

					// Attach the VDP dest port
					if(cbTov <= 1)
					{
						wDestPort = NTOHS(((WORD) *(pUnencryptedDataIndex + (1 - cbTov))) + 1000);
						if(!AttachPropertyInstanceEx(hFrame, XSPPropTable[XSP_DEST_PORT_1].hProperty, sizeof(BYTE),
							pUnencryptedDataIndex + (1 - cbTov), sizeof(wDestPort), &wDestPort, 0, 3, 0))
						{
							goto Exit;
						}					
					}
				}
				else if(bXspType == XSP_TYPE_VDP_DO_2)
				{
					// Attach the VDP source port
					if(!cbTov)
					{
						wSourcePort = NTOHS(*((WORD *) pUnencryptedDataIndex));
						if(!AttachPropertyInstanceEx(hFrame, XSPPropTable[XSP_SOURCE_PORT_2].hProperty, sizeof(WORD),
							pUnencryptedDataIndex, sizeof(wSourcePort), &wSourcePort, 0, 3, 0))
						{
							goto Exit;
						}					
					}

					// Attach the VDP dest port
					if(cbTov <= 2)
					{
						wDestPort = NTOHS(*((WORD *) (pUnencryptedDataIndex + (2 - cbTov))));
						if(!AttachPropertyInstanceEx(hFrame, XSPPropTable[XSP_DEST_PORT_2].hProperty, sizeof(WORD),
							pUnencryptedDataIndex + (2 - cbTov), sizeof(wDestPort), &wDestPort, 0, 3, 0))
						{
							goto Exit;
						}					
					}
				}
			}
			
			break;
			
			// Unknown packet type
		default:
			goto Exit;
		}
		
		// Attach the sequence number low word
		if(!AttachPropertyInstance(hFrame, XSPPropTable[XSP_ENCAP_SEQNUM].hProperty, sizeof(pXspTail->_wSeqLo),
			(LPBYTE) &(pXspTail->_wSeqLo), 0, 2, 0))
		{
			goto Exit;
		}
		
		// Attach the hash
		if(!AttachPropertyInstance(hFrame, XSPPropTable[XSP_HASH].hProperty, sizeof(pXspTail->_abHash),
			(LPBYTE) &(pXspTail->_abHash), 0, 2, 0))
		{
			goto Exit;
		}
		
		// We've claimed the packet so when we return, point to the next byte after the received packet
		pNextFrame += cbOriginal;
	}
	
Exit:
	return pNextFrame;
}

//==================================================================================
// XSP_FormatProperties
//----------------------------------------------------------------------------------
//
// Description: Called by Netmon to format each property that was attached by
//	XSP_AttachProperties
//
// Arguments:
//	HFRAME			hFrame			Handle to the frame that is being parsed.
//	LPBYTE			pMacFrame		Pointer to the first byte of a frame.
//	LPBYTE			pXSPFrame		Pointer to the beginning of the protocol data in a frame.
//	DWORD			nPropertyInsts	Number of PROPERTYINST structures provided by lpPropInst. 
//	LPPROPERTYINST	p				Pointer to an array of PROPERTYINST structures. 
//
// Returns: TRUE on successful formatting of all properties, FALSE otherwise
//==================================================================================
DWORD WINAPI XSP_FormatProperties(	HFRAME          hFrame,
								  LPBYTE          pMacFrame,
								  LPBYTE          pXSPFrame,
								  DWORD           nPropertyInsts,
								  LPPROPERTYINST  p)
{
    // loop through the property instances
    while( nPropertyInsts-- > 0)
    {
        // and call the formatter for each
        ( (FORMAT)(p->lpPropertyInfo->InstanceData) )( p);
        p++;
    }
	
    return NMERR_SUCCESS;
}

//============================================================================
//  Function: XSP_FormatX2XOnlineInitSummary
// 
//  Description: The custom formatter for the summary property
//============================================================================
VOID WINAPIV XSP_FormatX2XOnlineInitSummary( LPPROPERTYINST pPropertyInst)
{
    LPSTR pReturnedString = pPropertyInst->szPropertyText;
	
	strcpy( pReturnedString, "Xbox-to-Xbox Key Exchange Initiator: Online");
}

//============================================================================
//  Function: XSP_FormatX2XOnlineRespSummary
// 
//  Description: The custom formatter for the summary property
//============================================================================
VOID WINAPIV XSP_FormatX2XOnlineRespSummary( LPPROPERTYINST pPropertyInst)
{
    LPSTR pReturnedString = pPropertyInst->szPropertyText;
	
	strcpy( pReturnedString, "XSP: Xbox-to-Xbox Key Exchange Response: Online");
}

//============================================================================
//  Function: XSP_FormatX2XSystemLinkInitSummary
// 
//  Description: The custom formatter for the summary property
//============================================================================
VOID WINAPIV XSP_FormatX2XSystemLinkInitSummary( LPPROPERTYINST pPropertyInst)
{
    LPSTR pReturnedString = pPropertyInst->szPropertyText;
	
	strcpy( pReturnedString, "XSP: Xbox-to-Xbox Key Exchange Initiator: SystemLink");
}

//============================================================================
//  Function: XSP_FormatX2XSystemLinkRespSummary
// 
//  Description: The custom formatter for the summary property
//============================================================================
VOID WINAPIV XSP_FormatX2XSystemLinkRespSummary( LPPROPERTYINST pPropertyInst)
{
    LPSTR pReturnedString = pPropertyInst->szPropertyText;
	
	strcpy( pReturnedString, "XSP: Xbox-to-Xbox Key Exchange Response: SystemLink");
}

//============================================================================
//  Function: XSP_FormatX2SOnlineInitSummary
// 
//  Description: The custom formatter for the summary property
//============================================================================
VOID WINAPIV XSP_FormatX2SOnlineInitSummary( LPPROPERTYINST pPropertyInst)
{
    LPSTR pReturnedString = pPropertyInst->szPropertyText;
	
	strcpy( pReturnedString, "XSP: Xbox-to-SG Key Exchange Initiator");
}

//============================================================================
//  Function: XSP_FormatS2XOnlineRespSummary
// 
//  Description: The custom formatter for the summary property
//============================================================================
VOID WINAPIV XSP_FormatS2XOnlineRespSummary( LPPROPERTYINST pPropertyInst)
{
    LPSTR pReturnedString = pPropertyInst->szPropertyText;
	
	strcpy( pReturnedString, "XSP: SG-to-Xbox Key Exchange Response");
}

VOID WINAPIV XSP_FormatX2TOnlineInitSummary( LPPROPERTYINST pPropertyInst);
VOID WINAPIV XSP_FormatT2XOnlineRespSummary( LPPROPERTYINST pPropertyInst);

//============================================================================
//  Function: XSP_FormatX2TOnlineInitSummary
// 
//  Description: The custom formatter for the summary property
//============================================================================
VOID WINAPIV XSP_FormatX2TOnlineInitSummary( LPPROPERTYINST pPropertyInst)
{
    LPSTR pReturnedString = pPropertyInst->szPropertyText;
	
	strcpy( pReturnedString, "XSP: Xbox-to-SGLite Key Exchange Initiator");
}

//============================================================================
//  Function: XSP_FormatT2XOnlineRespSummary
// 
//  Description: The custom formatter for the summary property
//============================================================================
VOID WINAPIV XSP_FormatT2XOnlineRespSummary( LPPROPERTYINST pPropertyInst)
{
    LPSTR pReturnedString = pPropertyInst->szPropertyText;
	
	strcpy( pReturnedString, "XSP: SGLite-to-Xbox Key Exchange Response");
}

//============================================================================
//  Function: XSP_FormatNatOpenInitSummary
// 
//  Description: The custom formatter for the summary property
//============================================================================
VOID WINAPIV XSP_FormatNatOpenInitSummary( LPPROPERTYINST pPropertyInst)
{
    LPSTR pReturnedString = pPropertyInst->szPropertyText;
	CHAR szNatOpenFlagsString[100] = "";
	CKeyExNatOpen *pKeyExNatOpen = (CKeyExNatOpen *) ((BYTE *) pPropertyInst->lpData + XSPHDRSIZE);
	
	if(pPropertyInst->DataLength < (sizeof(CKeyExNatOpen) + XSPHDRSIZE))
	{
		strcpy( pReturnedString, "XSP: NAT Open Initiator: <not enough data to parse>");
	}
	else
	{
		if(pKeyExNatOpen->_wFlags)
		{			
			if(pKeyExNatOpen->_wFlags & KNOF_XBTOXB_KEYEX)
			{
				strcat(szNatOpenFlagsString, "<KEYEX>");
			}
			
			if(pKeyExNatOpen->_wFlags & KNOF_XBTOXB_QOS)
			{
				strcat(szNatOpenFlagsString, "<QOS>");
			}
			
			sprintf( pReturnedString, "XSP: NAT Open Initiator: %s", szNatOpenFlagsString);
		}
		else
			strcpy( pReturnedString, "XSP: NAT Open Initiator: <no flags>");
	}
}

//============================================================================
//  Function: XSP_FormatNatOpenRespSummary
// 
//  Description: The custom formatter for the summary property
//============================================================================
VOID WINAPIV XSP_FormatNatOpenRespSummary( LPPROPERTYINST pPropertyInst)
{
    LPSTR pReturnedString = pPropertyInst->szPropertyText;
	CHAR szNatOpenFlagsString[100] = "";
	CKeyExNatOpen *pKeyExNatOpen = (CKeyExNatOpen *) ((BYTE *) pPropertyInst->lpData + XSPHDRSIZE);
	
	if(pPropertyInst->DataLength < (sizeof(CKeyExNatOpen) + XSPHDRSIZE))
	{
		strcpy( pReturnedString, "XSP: NAT Open Response: <not enough data to parse>");
	}
	else
	{
		if(pKeyExNatOpen->_wFlags)
		{			
			if(pKeyExNatOpen->_wFlags & KNOF_XBTOXB_KEYEX)
			{
				strcat(szNatOpenFlagsString, "<KEYEX>");
			}
			
			if(pKeyExNatOpen->_wFlags & KNOF_XBTOXB_QOS)
			{
				strcat(szNatOpenFlagsString, "<QOS>");
			}
			
			sprintf( pReturnedString, "XSP: NAT Open Response: %s", szNatOpenFlagsString);
		}
		else
			strcpy( pReturnedString, "XSP: NAT Open Response: <no flags>");
	}
}

//============================================================================
//  Function: XSP_FormatQOSInitSummary
// 
//  Description: The custom formatter for the summary property
//============================================================================
VOID WINAPIV XSP_FormatQOSInitSummary( LPPROPERTYINST pPropertyInst)
{
    LPSTR pReturnedString = pPropertyInst->szPropertyText;
	CHAR szQosFlagsString[100] = "";
	CKeyExQosInit *pKeyExQosInit = (CKeyExQosInit *) ((BYTE *) pPropertyInst->lpData + XSPHDRSIZE);
	
	if(pPropertyInst->DataLength < (sizeof(CKeyExQosInit) + XSPHDRSIZE))
	{
		strcpy( pReturnedString, "XSP: QOS Initiator: <not enough data to parse>");
	}
	else
	{
		if(pKeyExQosInit->_bFlags)
		{			
			if(pKeyExQosInit->_bFlags & QPF_PAIR_TWO)
			{
				strcat(szQosFlagsString, "<PAIRTWO>");
			}
			
			if(pKeyExQosInit->_bFlags & QPF_DATA_REQ)
			{
				strcat(szQosFlagsString, "<REQ>");
			}
			
			if(pKeyExQosInit->_bFlags & QPF_DATA_REP)
			{
				strcat(szQosFlagsString, "<REP>");
			}
			
			if(pKeyExQosInit->_bFlags & QPF_DATA_NONE)
			{
				strcat(szQosFlagsString, "<NODATA>");
			}
			
			if(pKeyExQosInit->_bFlags & QPF_DISABLED)
			{
				strcat(szQosFlagsString, "<DISABLED>");
			}
			
			sprintf( pReturnedString, "XSP: QOS Initiator: %s", szQosFlagsString);
		}
		else
			strcpy( pReturnedString, "XSP: QOS Initiator: <no flags>");
	}
}

//============================================================================
//  Function: XSP_FormatQOSRespSummary
// 
//  Description: The custom formatter for the summary property
//============================================================================
VOID WINAPIV XSP_FormatQOSRespSummary( LPPROPERTYINST pPropertyInst)
{
    LPSTR pReturnedString = pPropertyInst->szPropertyText;
	CHAR szQosFlagsString[100] = "";
	CKeyExQosResp *pKeyExQosResp = (CKeyExQosResp *) ((BYTE *) pPropertyInst->lpData + XSPHDRSIZE);
	
	if(pPropertyInst->DataLength < (sizeof(CKeyExQosResp) + XSPHDRSIZE))
	{
		strcpy( pReturnedString, "XSP: QOS Response: <not enough data to parse>");
	}
	else
	{
		if(pKeyExQosResp->_bFlags)
		{			
			if(pKeyExQosResp->_bFlags & QPF_PAIR_TWO)
			{
				strcat(szQosFlagsString, "<PAIRTWO>");
			}
			
			if(pKeyExQosResp->_bFlags & QPF_DATA_REQ)
			{
				strcat(szQosFlagsString, "<REQ>");
			}
			
			if(pKeyExQosResp->_bFlags & QPF_DATA_REP)
			{
				strcat(szQosFlagsString, "<REP>");
			}
			
			if(pKeyExQosResp->_bFlags & QPF_DATA_NONE)
			{
				strcat(szQosFlagsString, "<NODATA>");
			}
			
			if(pKeyExQosResp->_bFlags & QPF_DISABLED)
			{
				strcat(szQosFlagsString, "<DISABLED>");
			}
			
			sprintf( pReturnedString, "XSP: QOS Response: %s", szQosFlagsString);
		}
		else
			strcpy( pReturnedString, "XSP: QOS Response: <no flags>");
	}
}

//============================================================================
//  Function: XSP_FormatXSPEncapSummary
// 
//  Description: The custom formatter for the summary property
//============================================================================
VOID WINAPIV XSP_FormatXSPEncapSummary( LPPROPERTYINST pPropertyInst)
{
    LPSTR pReturnedString = pPropertyInst->szPropertyText;
	CHAR szEncapFlagsString[200] = "", szTemp[50] = "";
	CXspHdr *pXspHdr = (CXspHdr *) (((BYTE *) pPropertyInst->lpData) - sizeof(CUdpHdr));
	CIpHdr *pIpHdr = (CIpHdr *) (((BYTE *) pXspHdr) - sizeof(CIpHdr));
	CEnetHdr *pEnetHdr = (CEnetHdr *) (((BYTE *) pIpHdr) - sizeof(CEnetHdr));
    CXspTail *pXspTail = NULL;
	DWORD BytesLeft = pPropertyInst->DataLength;
	DWORD cbPad = 0;   // Counts the number of bytes needed to pad out the encrypted portion of the packet
	DWORD cbTex = 0;   // Counts the number of bytes needed for the encapsulated protocol's (TCP, UDP or VDP) header
	DWORD cbTov = 0;   // Counts the amount of the pad that's used by the encapsulated protocol's header
	DWORD cbPorts = 0; // Counts the number of bytes used by the port fields in the encapsulated protocol
	DWORD cbDat = 0;   // Counts the number of encrypted bytes
	DWORD cbTvo = 0;   // Counts the number of bytes of unencrypted voice data

	BYTE *pUnencryptedDataIndex = NULL, bTcpFlags = 0, bXspType = 0;
	
	if(BytesLeft < (XSPHDRSIZE + sizeof(CXspTail)))
	{
		goto BadFormat;
	}
	
	//"XSP: <type>(, Flags: <flags>, S: <source port>, D: <dest port>"
	
	// -------------------------------------------------------------------------
	
	cbPad = (((pXspHdr->_bFlags) & XSP_DATPAD_MASK) >> XSP_DATPAD_SHIFT);
	
	// Badly formatted packet
	if(BytesLeft < (XSPHDRSIZE + cbPad + sizeof(CXspTail)))
	{
		goto BadFormat;
	}
	
	bXspType = ((pXspHdr->_bFlags) & XSP_TYPE_MASK);
	
	// Calculate packet field variables
	switch(bXspType)
	{
	case XSP_TYPE_SEC:
		cbTex = 0;
		cbTov = 0;
		break;
	case XSP_TYPE_TCP_0:
		cbTex = 12;
		cbTov = cbPad;
		break;
	case XSP_TYPE_TCP_1:
		cbPorts = 2;
		cbTex = 14;
		cbTov = cbPad;
		break;
	case XSP_TYPE_TCP_2:
		cbPorts = 4;
		cbTex = 16;
		cbTov = cbPad;
		break;
	case XSP_TYPE_UDP_0:
	case XSP_TYPE_VDP_0:
	case XSP_TYPE_VDP_VO_0:
	case XSP_TYPE_VDP_DO_0:
		cbTex = 0;
		cbTov = 0;
		break;
	case XSP_TYPE_UDP_1:
	case XSP_TYPE_VDP_1:
	case XSP_TYPE_VDP_VO_1:
	case XSP_TYPE_VDP_DO_1:
		cbPorts = 2;
		cbTex = 2;
		if(cbTex < cbPad)
			cbTov = cbTex;
		else
			cbTov = cbPad;
		break;
	case XSP_TYPE_UDP_2:
	case XSP_TYPE_VDP_2:
	case XSP_TYPE_VDP_VO_2:
	case XSP_TYPE_VDP_DO_2:
		cbPorts = 4;
		cbTex = 4;
		if(cbTex < cbPad)
			cbTov = cbTex;
		else
			cbTov = cbPad;
		break;
	default:
		goto BadFormat;
	}
	
	// There must be enough room in the packet for the maximum of cbTex and cbPad
	if(cbTex > cbPad)
	{
		// Badly formatted packet
		if(BytesLeft < (XSPHDRSIZE + cbTex + sizeof(CXspTail)))
		{
			goto BadFormat;
		}
	}
	// For TCP packets, cbTex must be larger than cbPad
	else if((bXspType == XSP_TYPE_TCP_0) || (bXspType == XSP_TYPE_TCP_1) || (bXspType == XSP_TYPE_TCP_2))
	{
		goto BadFormat;
	}
	
	// For VDP packets with both voice and data, cbDat is determined by looking at the byte just before
	// the XSP tail.  The packet must be large enough for cbDat and the unencrypted part of the VDP header
	// (i.e. cbTex - cbTov)
	if((bXspType == XSP_TYPE_VDP_0) || (bXspType == XSP_TYPE_VDP_1) || (bXspType == XSP_TYPE_VDP_2))
	{
		cbDat = *((LPBYTE) pPropertyInst->lpData + BytesLeft - sizeof(CXspTail) - 1) * 8;

		// Badly formatted packet
		if(BytesLeft < (XSPHDRSIZE + cbDat + (cbTex - cbTov) + sizeof(CXspTail)))
		{
			goto BadFormat;
		}

		cbTvo = BytesLeft - XSPHDRSIZE - cbDat - (cbTex - cbTov) - sizeof(CXspTail);			

		// Voice data has to be at least 1 byte in order to store the cbDat variable in the last byte
		if(!cbTvo)
		{
			goto BadFormat;
		}
	}
	else if((bXspType == XSP_TYPE_VDP_VO_0) || (bXspType == XSP_TYPE_VDP_VO_1) || (bXspType == XSP_TYPE_VDP_VO_2))
	{
		cbDat = 0;

		// Badly formatted packet
		if(BytesLeft < (XSPHDRSIZE + (cbTex - cbTov) + sizeof(CXspTail)))
		{
			goto BadFormat;
		}

		cbTvo = BytesLeft - XSPHDRSIZE - (cbTex - cbTov) - sizeof(CXspTail);
	}
	else
	{
		cbDat = BytesLeft - XSPHDRSIZE - (cbTex - cbTov) - sizeof(CXspTail);
		cbTvo = 0;
	}
	
	if((bXspType == XSP_TYPE_VDP_VO_0) || (bXspType == XSP_TYPE_VDP_VO_1) || (bXspType == XSP_TYPE_VDP_VO_2))
	{
		// Since this is a completely unencrypted packet, we shouldn't have any encrypted field padding
		if(cbPad)
		{
			goto BadFormat;
		}
	}
	
	// Locate the start of the unencrypted info
	pUnencryptedDataIndex = ((LPBYTE) (pXspHdr + 1)) + cbDat;
	
	// Set up the tail pointer
	pXspTail = (CXspTail *) (((BYTE *) pPropertyInst->lpData) + BytesLeft - sizeof(CXspTail));
	
    // Identify broadcast packets so we can special case the VDP ones
    BOOL IsSyslinkVdp = pEnetHdr->_eaDst.IsBroadcast();

	// Calculate packet field variables
	switch(bXspType)
	{
	case XSP_TYPE_SEC:
		strcat(szEncapFlagsString, "SEC");
		break;
	case XSP_TYPE_TCP_0:
		strcat(szEncapFlagsString, "TCP0");
		break;
	case XSP_TYPE_TCP_1:
		strcat(szEncapFlagsString, "TCP1");
		break;
	case XSP_TYPE_TCP_2:
		strcat(szEncapFlagsString, "TCP2");
		break;
	case XSP_TYPE_UDP_0:
		strcat(szEncapFlagsString, "UDP0");
		break;
	case XSP_TYPE_VDP_0:
        strcat(szEncapFlagsString, IsSyslinkVdp ? "SYSLINK BROADCAST" : "VDP0");
		break;
	case XSP_TYPE_VDP_VO_0:
		strcat(szEncapFlagsString, "VDPVO0");
		break;
	case XSP_TYPE_VDP_DO_0:
		strcat(szEncapFlagsString, "VDPDO0");
		break;
	case XSP_TYPE_UDP_1:
		strcat(szEncapFlagsString, "UDP1");
		break;
	case XSP_TYPE_VDP_1:
		strcat(szEncapFlagsString, IsSyslinkVdp ? "SYSLINK BROADCAST" : "VDP1");
		break;
	case XSP_TYPE_VDP_VO_1:
		strcat(szEncapFlagsString, "VDPVO1");
		break;
	case XSP_TYPE_VDP_DO_1:
		strcat(szEncapFlagsString, "VDPDO1");
		break;
	case XSP_TYPE_UDP_2:
		strcat(szEncapFlagsString, "UDP2");
		break;
	case XSP_TYPE_VDP_2:
		strcat(szEncapFlagsString, IsSyslinkVdp ? "SYSLINK BROADCAST" : "VDP2");
		break;
	case XSP_TYPE_VDP_VO_2:
		strcat(szEncapFlagsString, "VDPVO2");
		break;
	case XSP_TYPE_VDP_DO_2:
		strcat(szEncapFlagsString, "VDPDO2");
		break;
	default:
		goto BadFormat;
	}

	// Attach the sequence num to the description
	sprintf( szTemp, ",%u",
		pXspTail->_wSeqLo);
	strcat(szEncapFlagsString, szTemp);

	switch(bXspType)
	{
		// If we're dealing with SEC packets
	case XSP_TYPE_SEC:
//		sprintf(szTemp, ", %u bytes encrypted data", cbDat);
//		strcat(szEncapFlagsString, szTemp);
		break;
		
		// If we're dealing with TCP packets
	case XSP_TYPE_TCP_0:
	case XSP_TYPE_TCP_1:
	case XSP_TYPE_TCP_2:
		
		// Attach the TCP flags		
		bTcpFlags = (*(pUnencryptedDataIndex + (cbPorts - cbTov) + 2 * sizeof(DWORD) + 1));
		
		sprintf( szTemp, ",Flags:%c%c%c%c%c%c",
			(bTcpFlags & TCP_FIN) ? 'F' : '-',
			(bTcpFlags & TCP_SYN) ? 'S' : '-',
			(bTcpFlags & TCP_RST) ? 'R' : '-',
			(bTcpFlags & TCP_PSH) ? 'P' : '-',
			(bTcpFlags & TCP_ACK) ? 'A' : '-',
			(bTcpFlags & TCP_URG) ? 'U' : '-');
		strcat(szEncapFlagsString, szTemp);

		if(bXspType == XSP_TYPE_TCP_0)
		{
			strcat(szEncapFlagsString, ",S:1000,D:1000");
		}
		else if(bXspType == XSP_TYPE_TCP_1)
		{
			// Attach the TCP source port
			if(!cbTov)
			{
				sprintf(szTemp, ",S:%u", (*pUnencryptedDataIndex) + 1000);
				strcat(szEncapFlagsString, szTemp);
			}
			
			// Attach the TCP dest port
			if(cbTov <= 1)
			{
				sprintf(szTemp, ",D:%u", (*(pUnencryptedDataIndex + (1 - cbTov))) + 1000);
				strcat(szEncapFlagsString, szTemp);
			}
		}
		else
		{
			// Attach the TCP source port
			if(!cbTov)
			{
				sprintf(szTemp, ",S:%u", NTOHS((*(WORD *)pUnencryptedDataIndex)));
				strcat(szEncapFlagsString, szTemp);
			}
			
			// Attach the TCP dest port
			if(cbTov <= 2)
			{
				sprintf(szTemp, ",D:%u", NTOHS((*(WORD *)(pUnencryptedDataIndex + (2 - cbTov)))));
				strcat(szEncapFlagsString, szTemp);
			}
		}
		
		// Attach the TCP sequence number (if possible)
//		if(cbPorts >= cbTov)
//		{
//			sprintf(szTemp, ",Seq num:%u", (*(DWORD *)(pUnencryptedDataIndex + (cbPorts - cbTov))));
//			strcat(szEncapFlagsString, szTemp);
//		}
		
		// Attach the TCP acknowledgement number (if possible)
//		if((cbPorts + sizeof(DWORD)) >= cbTov)
//		{
//			sprintf(szTemp, ",Ack num:%u", (*(DWORD *)(pUnencryptedDataIndex + (cbPorts - cbTov) + sizeof(DWORD))));
//			strcat(szEncapFlagsString, szTemp);
//		}
				
//		sprintf( szTemp, ",%u bytes encrypted data", cbDat);
//		strcat(szEncapFlagsString, szTemp);
		
		break;
		
		// If we're dealing with UDP packets
	case XSP_TYPE_UDP_0:
	case XSP_TYPE_UDP_1:
	case XSP_TYPE_UDP_2:
		
		// If there is any unencrypted UDP data left over after the pad, then parse it
		if(bXspType == XSP_TYPE_UDP_0)
		{
			strcat(szEncapFlagsString, ",S:1000,D:1000");
		}
		else if(cbTex - cbTov)
		{
			if(bXspType == XSP_TYPE_UDP_1)
			{
				// Attach the UDP source port
				if(!cbTov)
				{
					sprintf(szTemp, ",S:%u", (*pUnencryptedDataIndex) + 1000);
					strcat(szEncapFlagsString, szTemp);
				}
				
				// Attach the UDP dest port
				if(cbTov <= 1)
				{
					sprintf(szTemp, ",D:%u", (*(pUnencryptedDataIndex + (1 - cbTov))) + 1000);
					strcat(szEncapFlagsString, szTemp);
				}
			}
			else
			{
				// Attach the UDP source port
				if(!cbTov)
				{
					sprintf(szTemp, ",S:%u", NTOHS((*(WORD *)pUnencryptedDataIndex)));
					strcat(szEncapFlagsString, szTemp);
				}
				
				// Attach the UDP dest port
				if(cbTov <= 2)
				{
					sprintf(szTemp, ",D:%u", NTOHS((*(WORD *)(pUnencryptedDataIndex + (2 - cbTov)))));
					strcat(szEncapFlagsString, szTemp);
				}
			}
		}
		
//		sprintf( szTemp, ",%u bytes encrypted data", cbDat);
//		strcat(szEncapFlagsString, szTemp);
		
		break;
		
		// If we're dealing with VDP packets
	case XSP_TYPE_VDP_0:
	case XSP_TYPE_VDP_1:
	case XSP_TYPE_VDP_2:
		
		// If there is any unencrypted VDP data left over after the pad, then parse it
		if(bXspType == XSP_TYPE_VDP_0)
		{
			strcat(szEncapFlagsString, ",S:1000,D:1000");
		}
		else if(cbTex - cbTov)
		{
			if(bXspType == XSP_TYPE_VDP_1)
			{
				// Attach the VDP source port
				if(!cbTov)
				{
					sprintf(szTemp, ",S:%u", (*pUnencryptedDataIndex) + 1000);
					strcat(szEncapFlagsString, szTemp);
				}
				
				// Attach the VDP dest port
				if(cbTov <= 1)
				{
					sprintf(szTemp, ",D:%u", (*(pUnencryptedDataIndex + (1 - cbTov))) + 1000);
					strcat(szEncapFlagsString, szTemp);
				}
			}
			else
			{
				// Attach the VDP source port
				if(!cbTov)
				{
					sprintf(szTemp, ",S:%u", NTOHS((*(WORD *)pUnencryptedDataIndex)));
					strcat(szEncapFlagsString, szTemp);
				}
				
				// Attach the VDP dest port
				if(cbTov <= 2)
				{
					sprintf(szTemp, ",D:%u", NTOHS((*(WORD *)(pUnencryptedDataIndex + (2 -cbTov)))));
					strcat(szEncapFlagsString, szTemp);
				}
			}
		}
		
		// Spell out how many bytes of voice and how many of encrypted data
//		sprintf( szTemp, ",%u bytes encrypted data", cbDat);
//		strcat(szEncapFlagsString, szTemp);
		
//		sprintf( szTemp, ",%u bytes voice data", BytesLeft - XSPHDRSIZE - cbDat - (cbTex - cbTov) - sizeof(CXspTail));
//		strcat(szEncapFlagsString, szTemp);		
		
		break;
		
		// If we're dealing with VDP-VO packets
	case XSP_TYPE_VDP_VO_0:
	case XSP_TYPE_VDP_VO_1:
	case XSP_TYPE_VDP_VO_2:
		
		if(bXspType == XSP_TYPE_VDP_VO_0)
		{
			strcat(szEncapFlagsString, ",S:1000,D:1000");
		}
		else if(bXspType == XSP_TYPE_VDP_VO_1)
		{
			// Note, since the entire packet is unencrypted, we don't have to worry about checking
			// what part is unencrypted or encrypted
			sprintf(szTemp, ",S:%u", (*pUnencryptedDataIndex) + 1000);
			strcat(szEncapFlagsString, szTemp);
			
			sprintf(szTemp, ",D:%u", (*(pUnencryptedDataIndex + 1)) + 1000);
			strcat(szEncapFlagsString, szTemp);
			
		}
		else
		{
			// Note, since the entire packet is unencrypted, we don't have to worry about checking
			// what part is unencrypted or encrypted
			sprintf(szTemp, ",S:%u", NTOHS((*(WORD *)pUnencryptedDataIndex)));
			strcat(szEncapFlagsString, szTemp);
			
			sprintf(szTemp, ",D:%u", NTOHS((*(WORD *)(pUnencryptedDataIndex + 2))));
			strcat(szEncapFlagsString, szTemp);
		}
		
		// Spell out how many bytes of voice
//		sprintf( szTemp, ",%u bytes voice data", BytesLeft - XSPHDRSIZE - cbDat - (cbTex - cbTov) - sizeof(CXspTail));
//		strcat(szEncapFlagsString, szTemp);		
		
		break;
		
		// If we're dealing with VDP-DO packets
	case XSP_TYPE_VDP_DO_0:
	case XSP_TYPE_VDP_DO_1:
	case XSP_TYPE_VDP_DO_2:
		
		// If there is any unencrypted VDP data left over after the pad, then parse it
		if(bXspType == XSP_TYPE_VDP_DO_0)
		{
			strcat(szEncapFlagsString, ",S:1000,D:1000");
		}
		else if(cbTex - cbTov)
		{
			if(bXspType == XSP_TYPE_VDP_DO_1)
			{
				// Attach the VDP source port
				if(!cbTov)
				{
					sprintf(szTemp, ",S:%u", (*pUnencryptedDataIndex) + 1000);
					strcat(szEncapFlagsString, szTemp);
				}
				
				// Attach the VDP dest port
				if(cbTov <= 1)
				{
					sprintf(szTemp, ",D:%u", (*(pUnencryptedDataIndex + (1 - cbTov))) + 1000);
					strcat(szEncapFlagsString, szTemp);
				}
			}
			else if(bXspType == XSP_TYPE_VDP_DO_2)
			{
				// Attach the VDP source port
				if(!cbTov)
				{
					sprintf(szTemp, ",S:%u", NTOHS((*(WORD *)pUnencryptedDataIndex)));
					strcat(szEncapFlagsString, szTemp);
				}
				
				// Attach the VDP dest port
				if(cbTov <= 2)
				{
					sprintf(szTemp, ",D:%u", NTOHS((*(WORD *)(pUnencryptedDataIndex + (2 - cbTov)))));
					strcat(szEncapFlagsString, szTemp);
				}
			}
		}
		
		// Spell out how many bytes of data
//		sprintf( szTemp, ",%u bytes encrypted data", cbDat);
//		strcat(szEncapFlagsString, szTemp);
		
		break;
		
		// Unknown packet type
	default:
		goto BadFormat;
	}
	
	// Add the encrypted data count
	switch(bXspType)
	{
	case XSP_TYPE_TCP_0:
	case XSP_TYPE_TCP_1:
	case XSP_TYPE_TCP_2:
	case XSP_TYPE_UDP_0:
	case XSP_TYPE_UDP_1:
	case XSP_TYPE_UDP_2:
	case XSP_TYPE_VDP_DO_0:
	case XSP_TYPE_VDP_DO_1:
	case XSP_TYPE_VDP_DO_2:
	case XSP_TYPE_VDP_0:
	case XSP_TYPE_VDP_1:
	case XSP_TYPE_VDP_2:
		sprintf(szTemp, ",Data:%u", cbDat - cbPad);
		strcat(szEncapFlagsString, szTemp);
		break;
	default:
		break;
	}

	// Add the unencrypted voice data count
	switch(bXspType)
	{
	// VDPVO protocols don't have the extra byte at the end of their voice data
	case XSP_TYPE_VDP_VO_0:
	case XSP_TYPE_VDP_VO_1:
	case XSP_TYPE_VDP_VO_2:
		sprintf(szTemp, ",Voice:%u", cbTvo);
		strcat(szEncapFlagsString, szTemp);
		break;
	// VDP protocols have an extra byte at the end of their voice data indicating how much
	// non-voice data is present
	case XSP_TYPE_VDP_0:
	case XSP_TYPE_VDP_1:
	case XSP_TYPE_VDP_2:
        if (IsSyslinkVdp)
            sprintf(szTemp, ",Unencrypted:%u", cbTvo - 1);
        else
		    sprintf(szTemp, ",Voice:%u", cbTvo - 1);
		strcat(szEncapFlagsString, szTemp);
		break;
	default:
		break;
	}
	
	sprintf( pReturnedString, "%s", szEncapFlagsString);
	return;
	
BadFormat:
	
	strcpy( pReturnedString, "<not enough data to parse>");
	return;
}

//============================================================================
//  Function: XSP_FormatKeyExType
// 
//  Description: The custom formatter for the summary property
//============================================================================
VOID WINAPIV XSP_FormatKeyExType( LPPROPERTYINST pPropertyInst)
{
    LPSTR pReturnedString = pPropertyInst->szPropertyText;
	CHAR szKeyExTypeString[100] = "";
	WORD *pwKeyExType = (WORD *) (pPropertyInst->lpData); 
	
	if(pPropertyInst->DataLength < sizeof(WORD))
	{
		strcpy( pReturnedString, "Key Exchange Type: <not enough data to parse>");
	}
	else
	{
		switch(*pwKeyExType)
		{
		case KEYEX_TYPE_XBTOXB_INIT:
			strcpy(szKeyExTypeString, "Xbox-to-Xbox Init");
			break;
		case KEYEX_TYPE_XBTOXB_RESP:
			strcpy(szKeyExTypeString, "Xbox-to-Xbox Resp");
			break;
		case KEYEX_TYPE_XBTOSG_INIT:
			strcpy(szKeyExTypeString, "Xbox-to-SG Init");
			break;
		case KEYEX_TYPE_SGTOXB_RESP:
			strcpy(szKeyExTypeString, "SG-to-Xbox Resp");
			break;
		case KEYEX_TYPE_NATOPEN_INIT:
			strcpy(szKeyExTypeString, "NAT Open Init");
			break;
		case KEYEX_TYPE_NATOPEN_RESP:
			strcpy(szKeyExTypeString, "NAT Open Resp");
			break;
		case KEYEX_TYPE_QOS_INIT:
			strcpy(szKeyExTypeString, "QOS Init");
			break;
		case KEYEX_TYPE_QOS_RESP:
			strcpy(szKeyExTypeString, "QOS Resp");
			break;
		case KEYEX_TYPE_XBTOTS_INIT:
			strcpy(szKeyExTypeString, "Xbox-to-Title Server Init");
			break;
		case KEYEX_TYPE_TSTOXB_RESP:
			strcpy(szKeyExTypeString, "Title Server-to-Xbox Resp");
			break;
		case KEYEX_TYPE_DH_GX:
			strcpy(szKeyExTypeString, "Diffie-Helman G^X");
			break;
		case KEYEX_TYPE_HMAC_SHA:
			strcpy(szKeyExTypeString, "HMAC SHA");
			break;
		case KEYEX_TYPE_KERB_APREQ:
			strcpy(szKeyExTypeString, "Kerberos AP Request");
			break;
		case KEYEX_TYPE_KERB_APREP:
			strcpy(szKeyExTypeString, "Kerberos AP Reply");
			break;
		case KEYEX_TYPE_NULL_APREQ:
			strcpy(szKeyExTypeString, "Kerberos NULL AP Request");
			break;
		case KEYEX_TYPE_NULL_APREP:
			strcpy(szKeyExTypeString, "Kerberos NULL AP Reply");
			break;
		case KEYEX_TYPE_PADDING:
			strcpy(szKeyExTypeString, "Padding");
			break;
		case KEYEX_TYPE_SGTOXB_CHAL:
			strcpy(szKeyExTypeString, "SG-to-Xbox Challenge");
			break;
		default:
			strcpy(szKeyExTypeString, "Unknown");
			break;
		}
		
		sprintf( pReturnedString, "Key Exchange Packet Type: %s", szKeyExTypeString);
	}
}

//============================================================================
//  Function: XSP_FormatXNKID
// 
//  Description: The custom formatter for the summary property
//============================================================================
VOID WINAPIV XSP_FormatXNKID( LPPROPERTYINST pPropertyInst)
{
    LPSTR pReturnedString = pPropertyInst->szPropertyText;
	CHAR szXNKIDTypeString[100] = "";
	XNKID *pxnkid = (XNKID *) (pPropertyInst->lpData); 
	
	if(pPropertyInst->DataLength < sizeof(XNKID))
	{
		strcpy( pReturnedString, "XNKID: <not enough data to parse>");
	}
	else
	{
		if(XNetXnKidIsSystemLink(pxnkid))
		{
			strcpy(szXNKIDTypeString, "SystemLink Peer");
		}
		else if(XNetXnKidIsOnlinePeer(pxnkid))
		{
			strcpy(szXNKIDTypeString, "Online Peer");
		}
		else if(XNetXnKidIsOnlineServer(pxnkid))
		{
			strcpy(szXNKIDTypeString, "Online Server");
		}
		else
		{
			strcpy(szXNKIDTypeString, "Unknown Type");
		}
		
		sprintf( pReturnedString, "XNKID: %s", szXNKIDTypeString);
	}
}

//============================================================================
//  Function: XSP_FormatX2SFlags
// 
//  Description: The custom formatter for the summary property
//============================================================================
VOID WINAPIV XSP_FormatX2SFlags( LPPROPERTYINST pPropertyInst)
{
    LPSTR pReturnedString = pPropertyInst->szPropertyText;
	CHAR szX2SFlagsString[100] = "";
	WORD *pwFlags = (WORD *) (pPropertyInst->lpData); 
	
	if(pPropertyInst->DataLength < sizeof(WORD))
	{
		strcpy( pReturnedString, "Flags: <not enough data to parse>");
	}
	else
	{
		if(*pwFlags)
		{
			if(*pwFlags & XSIF_CONNECTION_SERVICE)
			{
				strcat(szX2SFlagsString, "<CONNSERVICE>");
			}
			
			sprintf( pReturnedString, "Flags: %s", szX2SFlagsString);
		}
		else
			strcpy( pReturnedString, "Flags: <NONE>" );
		
	}
}

//============================================================================
//  Function: XSP_FormatS2XFlags
// 
//  Description: The custom formatter for the summary property
//============================================================================
VOID WINAPIV XSP_FormatS2XFlags( LPPROPERTYINST pPropertyInst)
{
    LPSTR pReturnedString = pPropertyInst->szPropertyText;
	CHAR szS2XFlagsString[100] = "";
	WORD *pwFlags = (WORD *) (pPropertyInst->lpData); 
	
	if(pPropertyInst->DataLength < sizeof(WORD))
	{
		strcpy( pReturnedString, "Flags: <not enough data to parse>");
	}
	else
	{
		if(*pwFlags)
		{
			if(*pwFlags & SXRF_ENCRYPT_DES)
			{
				strcat(szS2XFlagsString, "<ENCRYPT_DES>");
			}
			if(*pwFlags & SXRF_ENCRYPT_3DES)
			{
				strcat(szS2XFlagsString, "<ENCRYPT_3DES>");
			}
			
			sprintf( pReturnedString, "S2X Flags: %s", szS2XFlagsString);
		}
		else
			strcpy( pReturnedString, "Flags: <NONE>" );
		
	}
}

//============================================================================
//  Function: XSP_FormatUserPermBits
// 
//  Description: The custom formatter for the summary property
//============================================================================
VOID WINAPIV XSP_FormatUserPermBits( LPPROPERTYINST pPropertyInst)
{
    LPSTR pReturnedString = pPropertyInst->szPropertyText;
	CHAR szUserPermBitsString[100] = "";
	BYTE *abUserPerm = (BYTE *) (pPropertyInst->lpData);
	INT i = 0;
	
	if(pPropertyInst->DataLength < sizeof(DWORD))
	{
		strcpy( pReturnedString, "User Bits: <not enough data to parse>");
	}
	else
	{
		for(i = 0; i < XONLINE_MAX_LOGON_USERS; ++i)
		{
			sprintf(szUserPermBitsString, "%u:<P:%d><G:0x%x>", i,
				(abUserPerm[i] >> KEYEX_USER_PERMUTATION_SHIFT),
				(abUserPerm[i] & KEYEX_USER_GUEST_MASK));
		}
		
		sprintf( pReturnedString, "User Bits: %s", szUserPermBitsString);
	}
}

//============================================================================
//  Function: XSP_FormatNatOpenFlags
// 
//  Description: The custom formatter for the summary property
//============================================================================
VOID WINAPIV XSP_FormatNatOpenFlags( LPPROPERTYINST pPropertyInst)
{
    LPSTR pReturnedString = pPropertyInst->szPropertyText;
	CHAR szNatOpenFlagsString[100] = "";
	WORD *pwFlags = (WORD *) (pPropertyInst->lpData); 
	
	if(pPropertyInst->DataLength < sizeof(WORD))
	{
		strcpy( pReturnedString, "Flags: <not enough data to parse>");
	}
	else
	{
		if(*pwFlags)
		{
			if(*pwFlags & KNOF_XBTOXB_KEYEX)
			{
				strcat(szNatOpenFlagsString, "<KEYEX>");
			}
			
			if(*pwFlags & KNOF_XBTOXB_QOS)
			{
				strcat(szNatOpenFlagsString, "<QOS>");
			}
			
			sprintf( pReturnedString, "Flags: %s", szNatOpenFlagsString);
		}
		else
			strcpy( pReturnedString, "Flags: <NONE>" );
		
	}
}

//============================================================================
//  Function: XSP_FormatQOSFlags
// 
//  Description: The custom formatter for the summary property
//============================================================================
VOID WINAPIV XSP_FormatQOSFlags( LPPROPERTYINST pPropertyInst)
{
    LPSTR pReturnedString = pPropertyInst->szPropertyText;
	CHAR szQosFlagsString[100] = "";
	BYTE *pbFlags = (BYTE *) (pPropertyInst->lpData); 
	
	if(pPropertyInst->DataLength < sizeof(BYTE))
	{
		strcpy( pReturnedString, "Flags: <not enough data to parse>");
	}
	else
	{
		if(*pbFlags)
		{			
			if(*pbFlags & QPF_PAIR_TWO)
			{
				strcat(szQosFlagsString, "<PAIRTWO>");
			}
			
			if(*pbFlags & QPF_DATA_REQ)
			{
				strcat(szQosFlagsString, "<REQ>");
			}
			
			if(*pbFlags & QPF_DATA_REP)
			{
				strcat(szQosFlagsString, "<REP>");
			}
			
			if(*pbFlags & QPF_DATA_NONE)
			{
				strcat(szQosFlagsString, "<NODATA>");
			}
			
			if(*pbFlags & QPF_DISABLED)
			{
				strcat(szQosFlagsString, "<DISABLED>");
			}
			
			sprintf( pReturnedString, "Flags: %s", szQosFlagsString);
		}
		else
			strcpy( pReturnedString, "Flags: <no flags>");
	}
}

//============================================================================
//  Function: XSP_FormatPadLength
// 
//  Description: The custom formatter for the summary property
//============================================================================
VOID WINAPIV XSP_FormatPadLength( LPPROPERTYINST pPropertyInst)
{
    LPSTR pReturnedString = pPropertyInst->szPropertyText;
	BYTE *pbFlags = (BYTE *) (pPropertyInst->lpPropertyInstEx->lpData), cbPad = 0;
	
	if(pPropertyInst->DataLength < sizeof(BYTE))
	{
		strcpy( pReturnedString, "Pad length: <not enough data to parse>");
	}
	else
	{
		cbPad = (((*pbFlags) & XSP_DATPAD_MASK) >> XSP_DATPAD_SHIFT);
		
		sprintf( pReturnedString, "Pad length: %u", cbPad);
	}
}

//============================================================================
//  Function: XSP_FormatEncapProtocolType 
//
//  Description: The custom formatter for the summary property
//============================================================================
VOID WINAPIV XSP_FormatEncapProtocolType( LPPROPERTYINST pPropertyInst)
{
    LPSTR pReturnedString = pPropertyInst->szPropertyText;
	CHAR szEncapFlagsString[100] = "";
	BYTE *pbFlags = (BYTE *) (pPropertyInst->lpPropertyInstEx->lpData), bProtocolType = 0;
	
	if(pPropertyInst->DataLength < sizeof(BYTE))
	{
		strcpy( pReturnedString, "Protocol Type: <not enough data to parse>");
	}
	else
	{
		bProtocolType = ((*pbFlags) & XSP_TYPE_MASK);
		
		switch(bProtocolType)
		{
		case XSP_TYPE_SEC:
			strcpy(szEncapFlagsString, "Xbox-SG message");
			break;
		case XSP_TYPE_TCP_0:
			strcpy(szEncapFlagsString, "TCP (Default ports)");
			break;
		case XSP_TYPE_TCP_1:
			strcpy(szEncapFlagsString, "TCP (1-byte ports)");
			break;
		case XSP_TYPE_TCP_2:
			strcpy(szEncapFlagsString, "TCP (2-byte ports)");
			break;
		case XSP_TYPE_UDP_0:
			strcpy(szEncapFlagsString, "UDP (Default ports)");
			break;
		case XSP_TYPE_UDP_1:
			strcpy(szEncapFlagsString, "UDP (1-byte ports)");
			break;
		case XSP_TYPE_UDP_2:
			strcpy(szEncapFlagsString, "UDP (2-byte ports)");
			break;
		case XSP_TYPE_VDP_0:
			strcpy(szEncapFlagsString, "VDP (Voice and data, No ports)");
			break;
		case XSP_TYPE_VDP_1:
			strcpy(szEncapFlagsString, "VDP (Voice and data, 1-byte ports)");
			break;
		case XSP_TYPE_VDP_2:
			strcpy(szEncapFlagsString, "VDP (Voice and data, 2-byte ports)");
			break;
		case XSP_TYPE_VDP_VO_0:
			strcpy(szEncapFlagsString, "VDP (Voice-only, Default ports)");
			break;
		case XSP_TYPE_VDP_VO_1:
			strcpy(szEncapFlagsString, "VDP (Voice-only, 1-byte ports)");
			break;
		case XSP_TYPE_VDP_VO_2:
			strcpy(szEncapFlagsString, "VDP (Voice-only, 2-byte ports)");
			break;
		case XSP_TYPE_VDP_DO_0:
			strcpy(szEncapFlagsString, "VDP (Data-only, Default ports)");
			break;
		case XSP_TYPE_VDP_DO_1:
			strcpy(szEncapFlagsString, "VDP (Data-only, 1-byte ports)");
			break;
		case XSP_TYPE_VDP_DO_2:
			strcpy(szEncapFlagsString, "VDP (Data-only, 2-byte ports)");
			break;
		default:
			strcpy(szEncapFlagsString, "Unknown");
			break;
		}
		
		sprintf( pReturnedString, "Protocol Type: %s", szEncapFlagsString);
	}
}

//============================================================================
//  Function: XSP_FormatTcpFlags
// 
//  Description: The custom formatter for the summary property
//============================================================================
VOID WINAPIV XSP_FormatTcpFlags( LPPROPERTYINST pPropertyInst)
{
    LPSTR pReturnedString = pPropertyInst->szPropertyText;
	BYTE *pbFlags = (BYTE *) (pPropertyInst->lpData); 
	
	if(pPropertyInst->DataLength < sizeof(BYTE))
	{
		strcpy( pReturnedString, "Flags: <not enough data to parse>");
	}
	else
	{
		if(*pbFlags)
		{			
			sprintf( pReturnedString, "Flags: %c%c%c%c%c%c",
				(*pbFlags & TCP_FIN) ? 'F' : '-',
				(*pbFlags & TCP_SYN) ? 'S' : '-',
				(*pbFlags & TCP_RST) ? 'R' : '-',
				(*pbFlags & TCP_PSH) ? 'P' : '-',
				(*pbFlags & TCP_ACK) ? 'A' : '-',
				(*pbFlags & TCP_URG) ? 'U' : '-');
		}
		else
			strcpy( pReturnedString, "Flags: <no flags>");
	}
}

//============================================================================
//  Function: XSP_FormatX2XKeyExFlags
// 
//  Description: The custom formatter for the summary property
//============================================================================
VOID WINAPIV XSP_FormatX2XKeyExFlags( LPPROPERTYINST pPropertyInst)
{
    LPSTR pReturnedString = pPropertyInst->szPropertyText;
	
	strcpy( pReturnedString, "Flags: <reserved>");
}

//============================================================================
//  Function: XSP_FormatSyslinkVdp
// 
//  Description: The custom formatter for the summary property
//============================================================================
VOID WINAPIV XSP_FormatSyslinkVdp( LPPROPERTYINST pPropertyInst)
{
    LPSTR pReturnedString = pPropertyInst->szPropertyText;
	BYTE *pbData = (BYTE *) (pPropertyInst->lpData); 
	
	if(pPropertyInst->DataLength < sizeof(DWORD) * 2)
	{
		strcpy( pReturnedString, "Syslink: <not enough data to parse>");
	}
	else
	{
        // This should always be one of the following:
        // 2 DWORDS - Xbox1 compatible
        //     DWORD1: title id
        //     DWORD2: title version
        // 3 DWORDS - Xbox360
        //     DWORD1: title id?
        //     DWORD2: title version?
        //     DWORD3: XNET version
        DWORD titleid = *((DWORD *)pbData);
        DWORD titleversion = *((DWORD *)pbData + 1);
		if(pPropertyInst->DataLength == sizeof(DWORD) * 2)
		{
			sprintf( pReturnedString, "Syslink: Xbox1-compatible broadcast, Title=0x%X, Version=0x%X", titleid, titleversion );
		}
		else if(pPropertyInst->DataLength == sizeof(DWORD) * 3)
        {
            DWORD xnetver = *((DWORD *)pbData + 2);
            sprintf( pReturnedString, "Syslink: Xbox360 broadcast, Title=0x%X, Version=0x%X, XNETVersion=0x%X", titleid, titleversion, xnetver );
        }
        else
        {
            sprintf( pReturnedString, "Syslink: <unknown broadcast type>" );
        }
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\parsers\xlinkparse\objd\i386\_asmid.inc ===
ASSEMBLY_IDENTITY_KEY_FORM=x86_xlinkparse_none_12.4.56.0_none_78d3c417dd7b0caf
ASSEMBLY_IDENTITY_XP_KEY_FORM=x86_xlinkparse_no-public-key_12.4.56.0_x-ww_0d097c37
ASSEMBLY_IDENTITY_CULTURE=
ASSEMBLY_IDENTITY_NAME=xlinkparse
ASSEMBLY_IDENTITY_PROCESSOR_ARCHITECTURE=x86
ASSEMBLY_IDENTITY_PUBLIC_KEY=
ASSEMBLY_IDENTITY_PUBLIC_KEY_TOKEN=
ASSEMBLY_IDENTITY_TYPE=
ASSEMBLY_IDENTITY_TYPE_NAME=
ASSEMBLY_IDENTITY_VERSION=12.4.56.0
XP_KEY_FORM=x86_xlinkparse_no-public-key_12.4.56.0_x-ww_0d097c37
XP_MANIFEST_DIRECTORY=manifests
XP_MANIFEST_NAME=x86_xlinkparse_no-public-key_12.4.56.0_x-ww_0d097c37.manifest
XP_MANIFEST_PATH=manifests\x86_xlinkparse_no-public-key_12.4.56.0_x-ww_0d097c37.manifest
XP_CATALOG_DIRECTORY=manifests
XP_CATALOG_NAME=x86_xlinkparse_no-public-key_12.4.56.0_x-ww_0d097c37.cat
XP_CATALOG_PATH=manifests\x86_xlinkparse_no-public-key_12.4.56.0_x-ww_0d097c37.cat
XP_PAYLOAD_PATH=x86_xlinkparse_no-public-key_12.4.56.0_x-ww_0d097c37
_DELAY_SIGN=0
!if [set _ASMIDTOATTRIBS_TLBIMP=]
!endif
CODESIGN_TESTKEY=
_TLBIMP_FLAGS=$(_TLBIMP_FLAGS)  /asmversion:12.4.56.0
_ASSEMBLY_IDENTITY=xlinkparse,processorArchitecture=x86,version=12.4.56.0,publicKeyToken=neutral
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\perflog\Counters\Counters.cs ===
using System;
using System.Data;
using System.IO;
using System.Text.RegularExpressions;
using System.Collections;

namespace Counters
{
	internal class ConfigFileInvalidException : Exception
	{
		public ConfigFileInvalidException() : base() {}
		public ConfigFileInvalidException(string s) : base(s) {}
		public ConfigFileInvalidException(string s, Exception e) : base(s, e) {}
	}

	internal class Counter
	{
		public string category;
		public string name;
		public string instance;
		public string graphname;
		public bool calcmedian;
	}

	internal class CounterGraphNameComparer : IComparer
	{
		public int Compare(object a, object b)
		{
			string sa = ((AttachedCounter)a).counter.graphname.ToLower();
			string sb = ((AttachedCounter)b).counter.graphname.ToLower();
			if (sa == "")
			{
				if (sb == "")
					return 0;
				return 1;
			}
			if (sb == "")
				return -1;
			return sa.CompareTo(sb);
		}
	}

	internal class AttachedCounter
	{
		public string server;
		public Counter counter;

		public AttachedCounter(string s, Counter c) {server = s; counter = c;}
	}

	internal class CounterFile
	{
		public string name;
		public ArrayList counters = new ArrayList();

		public CounterFile(string s) {name = s;}
	}

	class CounterGen
	{
		[STAThread]
		static void Main(string[] args)
		{
			CounterFile[] counterfiles = null;

			try
			{
				counterfiles = CounterInfo.GetCounters("counters.xml");
			}
			catch(ConfigFileInvalidException e)
			{
				if (e.Message == null || e.Message == "")
					Console.Out.WriteLine("There were problems reading the counters.xml file.");
				else
					Console.Out.WriteLine(e.Message);
				return;
			}

			FileStream fs = File.OpenRead("genericcounter.htm");
			StreamReader sr = new StreamReader(fs);
			string genericcounter = sr.ReadToEnd();
			fs.Close();

			for (int i = 0; i < counterfiles.Length; i++)
			{
				CounterFile cf = (CounterFile)counterfiles[i];
				StringWriter counterwriter = new StringWriter();
				StringWriter countermergewriter = new StringWriter();

				countermergewriter.WriteLine("CSVFile,axis-Y,# rows,name,Y-name,X-name,median");

				cf.counters.Sort(new CounterGraphNameComparer());

				int j;
				for (j = 0; j < cf.counters.Count; j++)
				{
					string acserver = ((AttachedCounter)cf.counters[j]).server;
					Counter ac = ((AttachedCounter)cf.counters[j]).counter;
					string instance = ac.instance != null ? "(" + ac.instance + ")" : "";
					counterwriter.WriteLine("\t<PARAM NAME=\"Counter{0}.Path\" VALUE=\"\\\\{1}\\{2}{3}\\{4}\">", (j + 1).ToString().PadLeft(5, '0'), acserver, ac.category, instance, ac.name);

					countermergewriter.Write(cf.name + ".csv,");
					countermergewriter.WriteLine("\\\\{0}\\{1}{2}\\{3},,{4},,,{5}", acserver, ac.category, instance, ac.name, ac.graphname, ac.calcmedian ? 1 : 0);
				}

				string counterdata = genericcounter;
				counterdata = counterdata.Replace(@"${name}", cf.name);
				counterdata = counterdata.Replace(@"${counters}", counterwriter.ToString());
				counterdata = counterdata.Replace(@"${numcounters}", j.ToString());

				if (File.Exists("perf-" + cf.name + ".htm"))
					File.Delete("perf-" + cf.name + ".htm");

				fs = File.OpenWrite("perf-" + cf.name + ".htm");
				StreamWriter sw = new StreamWriter(fs);
				sw.Write(counterdata);
				sw.Close();

				// Delete existing file
				if (File.Exists("perf-" + cf.name + ".csv"))
                    File.Delete("perf-" + cf.name + ".csv");

				fs = File.OpenWrite("perf-" + cf.name + ".csv");
				sw = new StreamWriter(fs);
				sw.Write(countermergewriter.ToString());
				sw.Close();
			}
		}
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\perflog\Counters\CounterInfo.cs ===
using System;
using System.Xml;
using System.Collections;

namespace Counters
{
	internal class CounterInfo
	{
		public static CounterFile[] GetCounters(string filename)
		{
			XmlDocument doc = new XmlDocument();
			doc.Load(filename);

			XmlNamespaceManager nm = new XmlNamespaceManager(doc.NameTable);
			nm.AddNamespace("s", "http://www.xboxlive.com/Testing/Counters");

			ArrayList counterfiles = new ArrayList();
			foreach (XmlNode counterfile in doc.SelectNodes("//s:counterinfo/s:counterfile", nm))
			{
				CounterFile cf = new CounterFile(counterfile.Attributes["name"].Value);

				foreach (XmlNode servertype in counterfile.SelectNodes("s:servertype", nm))
				{
					foreach (XmlNode server in servertype.SelectNodes("s:server", nm))
					{
						foreach (XmlNode group in servertype.SelectNodes("s:group", nm))
						{
							foreach (XmlNode counter in doc.SelectNodes("//s:counterinfo/s:group[@name='" + group.Attributes["name"].Value + "']/s:counter[not(@enabled='no')]", nm))
							{
								Counter c = new Counter();
								XmlAttributeCollection xac = counter.Attributes;

								if (xac["category"] == null || xac["category"].Value == "")
									throw new ConfigFileInvalidException("Category attribute missing in counter: " + counter.ToString());
								c.category = xac["category"].Value;

								if (xac["name"] == null || xac["name"].Value == "")
									throw new ConfigFileInvalidException("Name attribute missing in counter: " + counter.ToString());
								c.name = xac["name"].Value;

								c.instance = xac["instance"] != null ? xac["instance"].Value : null;
								
								if (xac["graph"] == null || xac["graph"].Value == "")
									throw new ConfigFileInvalidException("Graph attribute missing in counter: " + counter.OuterXml);
								c.graphname = xac["graph"].Value;
								
								c.calcmedian = xac["median"] != null && xac["median"].Value == "yes" ? true : false;
								
								AttachedCounter ac = new AttachedCounter(server.Attributes["name"].Value, c);
								cf.counters.Add(ac);
							}
						}
					}
				}

				counterfiles.Add(cf);
			}

			CounterFile[] cfa = new CounterFile[counterfiles.Count];
			counterfiles.CopyTo(cfa);
			return cfa;
		}
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\perflog\ServerLog\ServerLogInstaller.cs ===
using System;
using System.ServiceProcess;
using System.Configuration.Install;
using System.ComponentModel;

namespace ServerLog
{
	/// <summary>
	/// 
	/// </summary>
	[RunInstallerAttribute(true)]
	public class ServerLogInstaller : Installer
	{
		private ServiceInstaller serviceInstaller1;
		private ServiceProcessInstaller processInstaller;

		public ServerLogInstaller()
		{
			// Instantiate installers for process and services.
			processInstaller = new ServiceProcessInstaller();
			serviceInstaller1 = new ServiceInstaller();

			// The services run under the system account.
			processInstaller.Account = ServiceAccount.User;

			// The services are started manually.
			serviceInstaller1.StartType = ServiceStartMode.Manual;

			// ServiceName must equal those on ServiceBase derived classes.            
			serviceInstaller1.ServiceName = "ServerLog";

			// Add installers to collection. Order is not important.
			Installers.Add(serviceInstaller1);
			Installers.Add(processInstaller);
		}
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\perflog\CSVMerge\CSVMerge.cs ===
using System;
using System.IO;

namespace CSVMerge
{
	/// <summary>
	/// What this will do is go through the current directory, look for all *.csv, and merge the ones that begin
	/// with the same characters before the "_".  It will sort them based on the number following the "_".
	/// It will remove the first line of every file after the first one within a set.
	/// </summary>
	class MainClass
	{
		/// <summary>
		/// The main entry point for the application.
		/// </summary>
		[STAThread]
		static void Main(string[] args)
		{
			MainClass c = new MainClass();

			try
			{
				c.DoIt(args);
			}
			catch(Exception e)
			{
				Console.WriteLine("Exception caught: " + e.ToString());
			}
		}

		void DoIt(string[] args)
		{
			String fileAppend = "";
			String oldCurBase = null;
			String firstLine = "";
			bool noRename = false;

			if (args.Length == 0)
			{
				Console.WriteLine("Usage: CSVMerge <destination directory> [-norename]");
				return ;
			}

			if (args.Length >= 2)
			{
				if (args[1].Equals("-norename"))
					noRename = true;
			}

			// If they specified a directory...
			String destDirName = args[0];

			DirectoryInfo curDirInfo = new DirectoryInfo(Environment.CurrentDirectory);

			// Get a list of files in the directory

			FileInfo[] fiArray = curDirInfo.GetFiles("*.csv");

            // Create an array of filenames, and sort it
			String[] fileNames = new String[fiArray.Length];
			int i = 0;
			foreach (FileInfo fi in fiArray)
			{
				fileNames[i] = fi.Name;
				++i;
			}

			fiArray = null;

			String lastBase = "";

			if (fileNames.Length == 0)
			{
				Console.WriteLine("No files in " + curDirInfo.FullName + " to process!");
			}

			curDirInfo = null;

			foreach (String f in fileNames)
			{
				String curBase;

				Console.Write("Processing File: " + f + "...");

				int iDelimit = f.IndexOf('_');
				if (iDelimit == -1)
				{
					// if there's no underscore, skip this.
					Console.WriteLine("Skipping because there is no underscore");
					continue;
				}
				else
				{
					curBase = f.Substring(0, iDelimit);
				}

				if (curBase.CompareTo(oldCurBase) != 0)
				{
					// reset the fileAppend
					fileAppend = "";
					firstLine = "";
				}

				oldCurBase = curBase;

				// Open a stream from the input file
				StreamReader sr = null;
				try
				{
					sr = File.OpenText(f);
				}
				catch (Exception)
				{
					Console.WriteLine("WARNING: Could not open file " + f);
					continue;
				}

				// If the destination file exists, then let's compare the first line.
				// If the first line does not match, then let's produce a new file.
				String newFirstLine = sr.ReadLine();

				if (newFirstLine == null)
				{
					Console.WriteLine("WARNING: " + f + " is an empty file");
					sr.Close();
					if (!noRename)
						File.Move(f, f + ".processed");
					continue;
				}

				if (File.Exists(destDirName + "\\" + curBase + fileAppend + ".csv"))
				{
					if (newFirstLine.CompareTo(firstLine) != 0 && firstLine != "")
						fileAppend += "_";
				}

				FileInfo outFile = new FileInfo(destDirName + "\\" + curBase + fileAppend + ".csv");
				StreamWriter writer = outFile.AppendText();

				writer.WriteLine(newFirstLine);
				firstLine = newFirstLine;

				string input = null;
				while ((input = sr.ReadLine()) != null)
				{
					writer.WriteLine(input);
				}
				sr.Close();

				writer.Close();

				try
				{
					if (!noRename)
						File.Move(f, f + ".processed");
				}
				catch (IOException e)
				{
					Console.WriteLine("WARNING: Could not rename " + f + ", exception: " + e);
				}

				lastBase = curBase;

				Console.WriteLine("Done");
			}
		}
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\perflog\ServerLog\ServerLogShared\CounterInfo.cs ===
using System;
using System.Xml;
using System.Collections;

namespace ServerLog
{
	internal class CounterInfo
	{
		public static CounterFile[] GetCounters(string filename)
		{
			XmlDocument doc = new XmlDocument();
			doc.Load(filename);

			XmlNamespaceManager nm = new XmlNamespaceManager(doc.NameTable);
			nm.AddNamespace("s", "http://www.xboxlive.com/Testing/Counters");

			ArrayList counterfiles = new ArrayList();
			foreach (XmlNode counterfile in doc.SelectNodes("//s:counterinfo/s:counterfile", nm))
			{
				CounterFile cf = new CounterFile(counterfile.Attributes["name"].Value);

				foreach (XmlNode servertype in counterfile.SelectNodes("s:servertype", nm))
				{
					foreach (XmlNode server in servertype.SelectNodes("s:server", nm))
					{
						foreach (XmlNode group in servertype.SelectNodes("s:group", nm))
						{
							foreach (XmlNode counter in doc.SelectNodes("//s:counterinfo/s:group[@name='" + group.Attributes["name"].Value + "']/s:counter", nm))
							{
								Counter c = new Counter();
								XmlAttributeCollection xac = counter.Attributes;
								c.category = xac["category"].Value;
								c.name = xac["name"].Value;
								c.instance = xac["instance"] != null ? xac["instance"].Value : null;
								c.graphname = xac["graph"].Value;
								c.calcmedian = xac["median"] != null && xac["median"].Value == "yes" ? true : false;
								AttachedCounter ac = new AttachedCounter(server.Attributes["name"].Value, c);
								cf.counters.Add(ac);
							}
						}
					}
				}

				counterfiles.Add(cf);
			}

			CounterFile[] cfa = new CounterFile[counterfiles.Count];
			counterfiles.CopyTo(cfa);
			return cfa;
		}
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\perflog\ServerLog\Service1.cs ===
using System;
using System.Collections;
using System.ComponentModel;
using System.Data;
using System.Diagnostics;
using System.ServiceProcess;
using System.Threading;
using ServerLog;

namespace ServerLog
{
	public class Service1 : System.ServiceProcess.ServiceBase
	{
		/// <summary> 
		/// Required designer variable.
		/// </summary>
		private System.ComponentModel.Container components = null;

		public Service1()
		{
			// This call is required by the Windows.Forms Component Designer.
			InitializeComponent();

		}

		// The main entry point for the process
		static void Main()
		{
			System.ServiceProcess.ServiceBase[] ServicesToRun;
	
			// More than one user Service may run within the same process. To add
			// another service to this process, change the following line to
			// create a second service object. For example,
			//
			//   ServicesToRun = New System.ServiceProcess.ServiceBase[] {new Service1(), new MySecondUserService()};
			//
			Service1	serverLogService = new Service1();
			serverLogService.ServiceName = "ServerLog";
			ServicesToRun = new System.ServiceProcess.ServiceBase[] {serverLogService};
		//	ServicesToRun = new System.ServiceProcess.ServiceBase[] { new Service1() };

			System.ServiceProcess.ServiceBase.Run(ServicesToRun);
		}

		/// <summary> 
		/// Required method for Designer support - do not modify 
		/// the contents of this method with the code editor.
		/// </summary>
		private void InitializeComponent()
		{
			components = new System.ComponentModel.Container();
		//	this.ServiceName = "ServerLog";
		}

		/// <summary>
		/// Clean up any resources being used.
		/// </summary>
		protected override void Dispose( bool disposing )
		{
			if( disposing )
			{
				if (components != null) 
				{
					components.Dispose();
				}
			}
			base.Dispose( disposing );
		}

		/// <summary>
		/// Set things in motion so your service can do its work.
		/// </summary>
		protected override void OnStart(string[] args)
		{
			clog = new CounterLog();

			clog.waitMilliseconds = 60000;

			Thread backgroundThread = new Thread(new ThreadStart(clog.DoWork));

			backgroundThread.Start();
		}
 
		/// <summary>
		/// Stop this service.
		/// </summary>
		protected override void OnStop()
		{
			clog.Stop();
		}

		CounterLog clog;
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\perflog\ServerLog\ServerLogExe\ServerLogExe.cs ===
using System;
using ServerLog;
using System.Threading;

namespace ServerLogExe
{
	/// <summary>
	/// Summary description for Class1.
	/// </summary>
	class ServerLogExeMain
	{
		static void Usage()
		{
			Usage(null);
		}

		static void Usage(string message)
		{
			if (message != null)
				Console.WriteLine(message);

			Console.WriteLine("ServerLogExe [-counterpath <counterfilename> ] -verify <countergroup> | -verifyall | -log");
			Console.WriteLine(" <counterfilename> is the fully qualified path to the counter file");
			Console.WriteLine(" <server> is the name of the countergroup to verify. e.g. \"stats\"");
			Console.WriteLine(" default will just use the COUNTERPATH env variable, and will log instead of verify");
		}

		/// <summary>
		/// The main entry point for the application.
		/// </summary>
		[STAThread]
		static void Main(string[] args)
		{
			if (args.Length == 0)
			{
				Usage("No argument supplied");
				return;
			}

			CounterLog clog = new CounterLog();

			string countersToVerify = null;
			string counterPath = "";
			bool verifyMode = false;
			for (int idx = 0; idx < args.Length; ++idx)
			{
				if (args[idx].Equals("-verifyall"))
				{
					verifyMode = true;
				}
				else if (args[idx].Equals("-verify"))
				{
					verifyMode = true;
					if (++idx >= args.Length)
					{
						Usage("-verify needs a parameter following it");
						return;
					}

					countersToVerify = args[idx];
				}
				else if (args[idx].Equals("-counterpath"))
				{
					if (++idx >= args.Length)
					{
						Usage("-counterpath needs a parameter following it");
						return;
					}

					counterPath = args[idx];
				}
				else if (args[idx].Equals("-log"))
				{
					verifyMode = false;
				}
				else
				{
					Usage("Invalid switch: " + args[idx]);
					return;
				}
			}

			clog.waitMilliseconds = 60000;
			clog.counterFilePath = counterPath;

			if (verifyMode)
			{
				clog.Verify(countersToVerify);
				return;
			}

			Thread backgroundThread = new Thread(new ThreadStart(clog.DoWork));

			backgroundThread.Start();

			Console.WriteLine("Server logging started...");
			Console.Write("Hit 'q' to quit: ");
			while (true)
			{
				string inputString = Console.ReadLine();
				if (inputString.Equals("q"))
					break;
			}
			
			clog.Stop();
		}
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\perflog\TPSReportGen\TPSReportGen.cs ===
using System;
using System.Diagnostics;
using System.IO;
using System.Collections;

namespace TPSReportGenerator
{
	/// <summary>
	/// Summary description for Class1.
	/// </summary>
	class TPSReportGen
	{
		/// <summary>
		/// The main entry point for the application.
		/// </summary>
		[STAThread]
		static void Main(string[] args)
		{
			StreamReader sr = File.OpenText( args[0] );
			string hdrLine = sr.ReadLine();

			CounterData data = new CounterData( hdrLine );

			string dataLine;
			while( (dataLine = sr.ReadLine()) != null ) 
			{
				data.AddRow( dataLine );
			}

			data.Dump();						

			sr.Close();
		}
    }

	class CounterData
	{
		static string delimitStr = ",";
		static char[] delimit    = delimitStr.ToCharArray(); 

		// Table of CounterAreas
		private Hashtable areas = new Hashtable();

		// List of values assoctiated with each data column.
		private ArrayList columnVal = new ArrayList();

		// ctor with header line
		public CounterData( string hdrLine )
		{
			string[] cols = hdrLine.Split( delimit );

			string partDelimStr = "\\";
			char[] partDelim    = partDelimStr.ToCharArray();
				
			foreach( string s in cols )
			{
				if( ! s.StartsWith( "\\\\" ) )
					continue;

				string s2 = s.TrimStart( partDelim );
				string[] parts = s2.Split( partDelim );
				
				Debug.Assert( parts.Length == 3 );

				string server  = parts[0];
				string area    = parts[1];
				string counter = parts[2];

				// Special case common areas
				if( (area == "Process(_Total)") || (area == "Processor(_Total)") )
				{
					area = area + "-" + server;
				}
				
				if( ! areas.Contains( area ) )
				{
					areas[ area ] = new CounterArea( area );
				}
				
				CounterArea a = (CounterArea) areas[ area ];

				CounterValues v = a.AddCol( counter, server );

				columnVal.Add( v );
			}
		}

		public void AddRow( string dataLine )
		{
			string[] vals = dataLine.Split( delimit );

			Debug.Assert( vals.Length == columnVal.Count + 1 );

			string when = vals[0];
			for( int i = 1; i< vals.Length; ++i )
			{
				CounterValues v = (CounterValues) columnVal[i-1];
				if( vals[i].Length > 0 )
					v.AddVal( when, vals[i] );
				else 
					v.AddVal( when, "0" );

			}
		}
		
		public void Dump()
		{
			foreach( string area in areas.Keys )
			{
				CounterArea a = (CounterArea) areas[ area ];
				a.Dump();
			}
		}
	}

	class CounterArea
	{
		// Table of Counters 
		private Hashtable counters = new Hashtable();

		private string name;

		public CounterArea( string name ) 
		{ 
			this.name = name; 
		}

		public CounterValues AddCol( string counter, string server )
		{
			if( ! counters.Contains( counter ) )
			{
				counters[ counter ] = new Counter( counter, this );
			}
			
			Counter c = (Counter) counters[ counter ];

			CounterValues v = c.AddCol( server );
			return v;
		}			

		public void Dump()
		{
			Console.WriteLine( name );
			foreach( string counter in counters.Keys )
			{
				Counter c = (Counter) counters[ counter ];
				c.DumpMeanMedian();
			}
		}
	}

	class Counter
	{
		// Table of CounterValues 
		private Hashtable servers = new Hashtable();

		private string      name;
		private CounterArea parentArea;

		public Counter( string name, CounterArea parent ) 
		{ 
			this.name  = name; 
			parentArea = parent; 
		}

		public CounterValues AddCol( string server )
		{
			if( ! servers.Contains( server ) )
			{
				servers[ server ] = new CounterValues( server, this );
			}

			CounterValues v = (CounterValues) servers[ server ];
			return v;
		}	

		public void DumpMeanMedian()
		{
			double mean = 0.0;
			foreach( string s in servers.Keys )
			{
				CounterValues cv = (CounterValues)servers[s];
				mean += cv.Median();
			}
			mean /= servers.Count;
			Console.WriteLine( "\t{0}:\t\t{1}", name, mean );

			foreach( string s in servers.Keys )
			{
				CounterValues cv = (CounterValues)servers[s];
				cv.DumpMedian();
			}
		}					 
	}

	class CounterValues 
	{
		// List of values sorted by DateTime
		private SortedList vals   = new SortedList();
		private SortedList counts = new SortedList();

		private string  serverName;
		private Counter parentCounter;

		public CounterValues( string serverName, Counter parent ) 
		{ 
			this.serverName    = serverName;
			this.parentCounter = parent;
		}

		public void AddVal( string when, string val )
		{
			DateTime dt = DateTime.Parse( when );
			double   v  = double.Parse( val );

			if( vals.Contains( dt ) )
			{
				vals.Remove( dt );
			}
			vals.Add( dt, v );

			if( counts.Contains( v ) )
			{
				int i = (int)counts[ v ];
				counts.Remove( v );
				counts.Add( v, i+1);
			}
			else
			{
				counts.Add( v, 1 );
			}
		}

		public void DumpMedian()
		{
			Console.WriteLine( "\t\t{0}:\t\t{1}", serverName, Median() );
		}

		public double Median()
		{
			int count = 0;
			foreach( double d in counts.Keys )
			{
				if( count > (vals.Count / 2) )
					return d;
				
				count += (int) counts[ d ];
			}
			return 0.0;
		}
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\perflog\XBLPerfLog\XBLPerfLogEvent.cs ===
using System;
using System.Diagnostics;

namespace XBLPerfLog
{
	/// <summary>
	/// Summary description for XBLPerfLogEvent.
	/// </summary>
	public class XBLPerfLogEvent
	{
		public static void LogError(string msg)
		{
			EventLog	log = new EventLog();
			log.Log = "Application";
			log.Source = "XBLPerfLog";
			log.WriteEntry(msg,EventLogEntryType.Error);
			log.Close();
		}
		public static string RealCounterToString(XBLPerfCounter pc)
		{
			string counterString = String.Format("\\\\{0}\\{1}",pc.machineName,pc.objectName);
			if(pc.instanceName != null)
				counterString += '(' + pc.instanceName + ')';
			counterString += '\\' + pc.counterName;
			return counterString;
		}
		public static string AggCounterToString(XBLAggPerfCounter apc)
		{
			XBLPerfCounter	pc = (XBLPerfCounter)apc.realCounters[0];
			string counterString = String.Format("\\\\{0}\\{1}\\{2}",pc.machineName,pc.objectName,pc.counterName);
			return counterString;
		}
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\perflog\ServerLog\ServerLogShared\serverlog.cs ===
using System;
using System.Data;
using System.IO;
using System.Text.RegularExpressions;
using System.Collections;
using System.Diagnostics;
using System.Threading;

namespace ServerLog
{
	internal class ConfigFileInvalidException : Exception
	{
		public ConfigFileInvalidException() : base() {}
		public ConfigFileInvalidException(string s) : base(s) {}
		public ConfigFileInvalidException(string s, Exception e) : base(s, e) {}
	}

	public class Counter
	{
		public string category;
		public string name;
		public string instance;
		public string graphname;
		public bool calcmedian;
	}

	internal class PerfData
	{
		public string baseName = "";
		public string outFileName = "";
		public ArrayList perfCounterList = new ArrayList();
		public ArrayList errorSentArray = new ArrayList();
		public Thread workerThread = null;
	}

	internal class CounterGraphNameComparer : IComparer
	{
		public int Compare(object a, object b)
		{
			string sa = ((AttachedCounter)a).counter.graphname.ToLower();
			string sb = ((AttachedCounter)b).counter.graphname.ToLower();
			if (sa == "")
			{
				if (sb == "")
					return 0;
				return 1;
			}
			if (sb == "")
				return -1;
			return sa.CompareTo(sb);
		}
	}

	internal class PerformanceCounterComparer : IComparer
	{
		public int Compare(object a, object b)
		{
			PerformanceCounter pca = ((PerformanceCounter)a);
			PerformanceCounter pcb = ((PerformanceCounter)b);

			int result = pca.MachineName.CompareTo(pcb.MachineName);
			if (result != 0)
				return result;

			result = pca.CategoryName.CompareTo(pcb.CategoryName);
			if (result != 0)
				return result;

			if (pca.InstanceName == null && pcb.InstanceName != null)
				return -1;
			if (pca.InstanceName != null && pcb.InstanceName == null)
				return 1;

			if (pca.InstanceName != null && pcb.InstanceName != null)
			{
				result = pca.InstanceName.CompareTo(pcb.InstanceName);
				if (result != 0)
					return result;
			}

			result = pca.CounterName.CompareTo(pcb.CounterName);

			return result;
		}
	}

	internal class AttachedCounter
	{
		public string server;
		public Counter counter;

		public AttachedCounter(string s, Counter c) {server = s; counter = c;}
	}

	public class CounterFile
	{
		public string name;
		public ArrayList counters = new ArrayList();

		public CounterFile(string s) {name = s;}
	}

	public class CounterLog
	{	
		private static string counterFileName = "counters.xml";
		private System.DateTime dateOfCountersFile = new DateTime(0);
		private Hashtable hashOfPerfData = new Hashtable();
		private bool failedToReadCounters = false;

		public Object exitEvent = null;
		public int waitMilliseconds = 1000;
		public string counterFilePath = "";

		public CounterLog()
		{
			this.exitEvent = new Object();
		}

		public void Stop()
		{
			lock(exitEvent)
			{
				Monitor.PulseAll(exitEvent);
			}

			// Wait for all threads to quit
			foreach (DictionaryEntry de in hashOfPerfData)
			{
				PerfData pd = (PerfData) de.Value;

				if (pd.workerThread != null)
				{
					Console.Write("Waiting for thread " + (string)de.Key + "...");
					pd.workerThread.Join();
					Console.WriteLine("Joined");
				}
			}

			exitEvent = null;
		}

		public void DoWork()
		{
			EZEvent.LogInfo("Application started, counter file name is " + counterFileName);

			while (true)
			{
				Process();

				lock(exitEvent)
				{
					if (Monitor.Wait(exitEvent, waitMilliseconds, true))
					{
						// iterate through each thread and kill it
						foreach (Object opd in hashOfPerfData)
						{
							PerfData pd = (PerfData)((DictionaryEntry)opd).Value;
							lock(pd)
							{
								Monitor.PulseAll(pd);
							}
						}

						foreach (Object opd in hashOfPerfData)
						{
							PerfData pd = (PerfData)((DictionaryEntry)opd).Value;
							pd.workerThread.Join();
						}

						EZEvent.LogInfo("Application exiting");
						return;
					}
				}
			}
		}

		public void Verify(string countersToVerify)
		{
			try
			{
				AddCountersFromIni(false);
			}
			catch(Exception e)
			{
				Console.WriteLine("Exception caught: " + e);
			}

			foreach (DictionaryEntry opd in hashOfPerfData)
			{
				if (countersToVerify != null && !((String)opd.Key).Equals(countersToVerify))
					continue;

				Console.WriteLine("");
				Console.WriteLine("Verifying " + (String)opd.Key + "...");

				PerfData pd = (PerfData)opd.Value;
				for (int idx = 0; idx < pd.perfCounterList.Count; ++idx)
				{
					PerformanceCounter pc = (PerformanceCounter)pd.perfCounterList[idx];

					try
					{
						pc.NextValue();
						Console.WriteLine("Verified " + EZEvent.PerfCounterToString(pc));
					}
					catch(Exception e)
					{
						Console.WriteLine("Exception: " + e.ToString() + " for counter: " + EZEvent.PerfCounterToString(pc));
					}
				}
			}
		}

		[STAThread]
		public void Process()
		{
			try
			{
				// Check if the last write datetime of file has changed. If it has, then re-read
				AddCountersFromIni(true);
			}
			catch(Exception e)
			{
				EZEvent.LogError(e.ToString());
			}
		}
		
		[STAThread]
		private void AddCountersFromIni(bool startThread)
		{
			if (counterFilePath == "")
			{
				string envValue = Environment.ExpandEnvironmentVariables("%COUNTERPATH%");
				if (envValue == "%COUNTERPATH%")
				{
					EZEvent.LogError("Unable to start. COUNTERPATH environment variable was not set");
					return;
				}

				counterFilePath = envValue;
			}

			string counterFilePathName = counterFilePath + "\\" + counterFileName;

			// ArrayList of CounterFiles
			ArrayList counterfiles = new ArrayList();

			try
			{
				// exit if the file date has not changed
				if (File.GetLastWriteTime(counterFilePathName).Equals(dateOfCountersFile))
					return;

                dateOfCountersFile = File.GetLastWriteTime(counterFilePathName);
				
				counterfiles = new ArrayList(CounterInfo.GetCounters(counterFilePathName));
			}
			catch(Exception e)
			{
				// Only log once
				if (failedToReadCounters)
				{
					return;
				}

				failedToReadCounters = true;

				EZEvent.LogError("Exception caught while trying to get last write time of file " + counterFilePathName);

				// otherwise Throw
				throw new Exception(e.ToString());
			}

			failedToReadCounters = false;

			for (int i = 0; i < counterfiles.Count; i++)
			{
				ArrayList perfCounterList = new ArrayList();

				CounterFile cf = (CounterFile)counterfiles[i];

				cf.counters.Sort(new CounterGraphNameComparer());

				int j;
				for (j = 0; j < cf.counters.Count; j++)
				{
					string acserver = ((AttachedCounter)cf.counters[j]).server;
					Counter ac = ((AttachedCounter)cf.counters[j]).counter;

					PerformanceCounter pc = new PerformanceCounter();
					pc.MachineName = acserver;
					pc.CategoryName = ac.category;
					pc.InstanceName = ac.instance;
					pc.CounterName = ac.name;

					perfCounterList.Add(pc);
				}

				bool addCounters = false;

				perfCounterList.Sort(new PerformanceCounterComparer());

				// See if we have the list of counters here already, and add the counters
				if (!hashOfPerfData.Contains(cf.name))
				{
					addCounters = true;
				}
				else
				{
					// check to see if they are equal...
					if (((PerfData)hashOfPerfData[cf.name]).perfCounterList.Count != perfCounterList.Count)
					{
						hashOfPerfData.Remove(cf.name);
						addCounters = true;
					}
					else
					{
						for (int idx = 0; idx < ((PerfData)hashOfPerfData[cf.name]).perfCounterList.Count; ++idx)
						{
							if (!((PerfData)hashOfPerfData[cf.name]).perfCounterList[idx].Equals(perfCounterList[idx]))
							{
								hashOfPerfData.Remove(cf.name);
								addCounters = true;
							}
						}
					}
				}

				if (addCounters)
				{
					if (hashOfPerfData.Contains(cf.name))
					{
						// Kill this thread
						PerfData oldPd = ((PerfData)hashOfPerfData[cf.name]);
						lock(oldPd)
						{
							Monitor.PulseAll(oldPd);
						}

						oldPd.workerThread.Join();

						hashOfPerfData.Remove(cf.name);
					}

					PerfData pd = new PerfData();

					pd.perfCounterList = perfCounterList;

					pd.errorSentArray.Clear();
					for (int idx = 0; idx < pd.perfCounterList.Count; ++idx)
                        pd.errorSentArray.Add((Object)false);

					pd.baseName = counterFilePath + "\\" + cf.name;

					hashOfPerfData.Add(cf.name, pd);

					if (startThread)
					{
						CounterLogWorkerThreadHandler clwt = new CounterLogWorkerThreadHandler(pd, waitMilliseconds);
						ThreadStart threadStart = new ThreadStart(clwt.HandleThread);
						pd.workerThread = new Thread(threadStart);
						pd.workerThread.Start();
					}
				}
			}
		}
	}

	internal class CounterLogWorkerThreadHandler
	{
		private PerfData pd = null;
		private int waitMilliseconds;

		public CounterLogWorkerThreadHandler(PerfData pd, int waitMilliseconds)
		{
			this.pd = pd;
			this.waitMilliseconds = waitMilliseconds;
		}

		public void HandleThread()
		{
			bool proceed = true;
			try
			{
				while (proceed)
				{
					proceed = HandleData();
					Thread.Sleep(100);
				}
			}
			catch(Exception e)
			{
				EZEvent.LogWarning(String.Format("Exception caught by HandleThread: {0}", e.ToString()));
			}
		}

		public bool HandleData()
		{
			TextWriter outFile = null;

			// First let's verify that the file exists.. If it doesn't we probably will need to write headers
			if (!File.Exists(pd.outFileName))
			{
				pd.outFileName = pd.baseName + "_" + DateTime.Now.ToString("MMddHHmm") + ".csv";
				outFile = File.CreateText(pd.outFileName);
					
				// Write out each of the counter names (the header)
				// First add the column for the time
				outFile.Write("(PDH-CSV 4.0) (Pacific Daylight Time)(420),");
				ArrayList perfCounterList = ((PerfData)pd).perfCounterList;
				for (int idx = 0; idx < perfCounterList.Count; ++idx)
				{
					outFile.Write(EZEvent.PerfCounterToString((PerformanceCounter)perfCounterList[idx]));
					if (idx != perfCounterList.Count - 1)
						outFile.Write(',');
				}					
				outFile.WriteLine("");

				// Fill the next line with zeroes
				outFile.Write(DateTime.Now.ToString("MM/dd/yyyy HH:mm:ss") + ",");
				for (int idx = 0; idx < perfCounterList.Count; ++idx)
				{
					outFile.Write(0);
					if (idx != perfCounterList.Count - 1)
						outFile.Write(',');
				}					
				outFile.WriteLine("");

				EZEvent.LogInfo("Created new file: " + pd.outFileName);
			}
			else
			{
				outFile = File.AppendText(pd.outFileName);
			}

			outFile.Write(DateTime.Now.ToString("MM/dd/yyyy HH:mm:ss") + ",");

			DateTime startTime = DateTime.Now;

			for (int idx = 0; idx < pd.perfCounterList.Count; ++idx)
			{
				PerformanceCounter pc = (PerformanceCounter)pd.perfCounterList[idx];

				try
				{
					outFile.Write(pc.NextValue());

					// Log an event if this is this counter was in an error state
					if ((bool)pd.errorSentArray[idx])
					{
						EZEvent.LogInfo(String.Format("Counter was invalid, now working: " + EZEvent.PerfCounterToString(pc)));
						pd.errorSentArray[idx] = false;
					}
				}
				catch(Exception e)
				{
					// Log an error only if we haven't for this one
					if (!(bool)pd.errorSentArray[idx])
					{
						EZEvent.LogWarning(String.Format("Exception: {0}, where PerformanceCounters = {1}", e.ToString(), 
							EZEvent.PerfCounterToString(pc)));
						pd.errorSentArray[idx] = true;
					}
				}

				if (idx != pd.perfCounterList.Count - 1)
				{
					outFile.Write(',');
				}
				else
				{
					outFile.WriteLine();
				}
			}

			outFile.Close();

			TimeSpan diffTime = DateTime.Now - startTime;
			int msToWait = waitMilliseconds - diffTime.Milliseconds;
			if (msToWait < 0)
				msToWait = 0;
			
			// Wait for exit event
			lock(pd)
			{
				if (Monitor.Wait(pd, msToWait, true))
				{
					EZEvent.LogInfo("Thread for " + pd.baseName + " exiting");
					return false;
				}
			}

			return true;
		}
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\perflog\ServerLog\ServerLogShared\EZEvent.cs ===
using System;
using System.Data;
using System.IO;
using System.Text.RegularExpressions;
using System.Collections;
using System.Diagnostics;
using System.Threading;

namespace ServerLog
{
	/// <summary>
	/// 
	/// </summary>
	public class EZEvent
	{
		static public void LogError(string msg)
		{
			EventLog log = new EventLog();
			log.Log = "Application";
			log.Source = "CounterLog";
			log.WriteEntry(msg, EventLogEntryType.Error);
			log.Close();
		}

		static public void LogWarning(string msg)
		{
			EventLog log = new EventLog();
			log.Log = "Application";
			log.Source = "CounterLog";
			log.WriteEntry(msg, EventLogEntryType.Warning);
			log.Close();
		}

		static public void LogInfo(string msg)
		{
			EventLog log = new EventLog();
			log.Log = "Application";
			log.Source = "CounterLog";
			log.WriteEntry(msg);
			log.Close();
		}

		static public string PerfCounterToString(PerformanceCounter pc)
		{
			string counterString = String.Format("\\\\{0}\\{1}", pc.MachineName, pc.CategoryName);
			if (pc.InstanceName != null)
			{
				counterString += '(' + pc.InstanceName + ')';
			}
					
			counterString += '\\' + pc.CounterName;

			return counterString;
		}
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\perflog\XBLPerfLog\XBLPerfLogService\XBLPerfLogEvent.cs ===
using System;
using System.Diagnostics;

namespace XBLPerfLog
{
	/// <summary>
	/// Summary description for XBLPerfLogEvent.
	/// </summary>
	public class XBLPerfLogEvent
	{
		public static void LogError(string msg)
		{
			EventLog	log = new EventLog();
			log.Log = "Application";
			log.Source = "XBLPerfLog";
			log.WriteEntry(msg,EventLogEntryType.Error);
			log.Close();
		}
		public static string RealCounterToString(XBLPerfCounter pc)
		{
			string counterString = String.Format("\\\\{0}\\{1}",pc.machineName,pc.objectName);
			if(pc.instanceName != null)
				counterString += '(' + pc.instanceName + ')';
			counterString += '\\' + pc.counterName;
			return counterString;
		}
		public static string AggCounterToString(XBLAggPerfCounter apc)
		{
			XBLPerfCounter	pc = (XBLPerfCounter)apc.realCounters[0];
			string counterString = String.Format("\\\\{0}\\{1}\\{2}",pc.machineName,pc.objectName,pc.counterName);
			return counterString;
		}
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\perflog\XBLPerfLog\XBLPerfLog.cs ===
using System;
using System.Data;
using System.Data.SqlClient;
using System.Collections;
using System.Diagnostics;
using System.Threading;
using System.Globalization;

namespace XBLPerfLog
{
    /// <summary>
    /// Summary description for Class1.
    /// </summary>
    class XBLPerfLogMain
    {
        public static string            sqlIP;
        public static int               updateInterval;
        public static Guid              guid = Guid.NewGuid();  // the Guid in the DisplayToID table

        public static Hashtable         machineHT = new Hashtable();
        public static Hashtable         aggCounterHT = new Hashtable();
		public static ReaderWriterLock  htLock = new ReaderWriterLock();

		public static CounterValueQueue globalQueue = new CounterValueQueue();
		public static ManualResetEvent	dataAvailable = new ManualResetEvent(false);
		public static Thread			writeDataThread;

		// will be used by each machine thread:increment by 1 when a machine finishes collecting 
		// one round of it's own counters
		public static int				numMachineCollected = 0;

		public static int				recordIndex = 1;

		public static ManualResetEvent	shutdown = new ManualResetEvent(false);

        private static bool ProcessCommandLineArgs(string[] args)
        {
            if(args.Length != 4)
            {
                Console.WriteLine("Usage:");
                Console.WriteLine("XBLPerfLog -SQLBoxIP <SQL Server IP> -updateInterval <updateIntervalInSec>");
                Console.WriteLine("<SQL Server IP>:{0}", "the SQL Server IP or FQDN where the perflogDB resides in");
                Console.WriteLine("<updateIntervalInSec>:{0}", "log sample data every n seconds");
                return false;
            }
            for(int i = 0; i < args.Length; i++)
            {
                if(args[i].ToLower().Equals("-sqlboxip"))
                {
                    if(++i >= args.Length)
                    {
                        Console.WriteLine("-sqlboxip needs a parameter following it");
                        return false;
                    }
                    sqlIP = args[i];
                }
                else if(args[i].ToLower().Equals("-updateinterval"))
                {
                    if(++i >= args.Length)
                    {
                        Console.WriteLine("-updateInterval needs a INT following it");
                        return false;
                    }
                    updateInterval = Int32.Parse(args[i]);
                }
                else
                {
                    Console.WriteLine("Invalid Switch: " + args[i]);
                    return false;
                }
            }
            return true;
        }


        private static void AddCounterToTable(SqlDataReader sqlReader)
        {
            XBLPerfCounter  xpc = new XBLPerfCounter();

            xpc.counterID       = (int)sqlReader.GetInt32(0);
            xpc.machineName     = (string)sqlReader.GetString(1);
            xpc.objectName      = (string)sqlReader.GetString(2);
            xpc.counterName     = (string)sqlReader.GetString(3);
            xpc.instanceName        = (string)sqlReader.GetString(4);               

            // create PerformanceCounter object in advance so that we don't
            // need to repeatedly create it during collection.
            xpc.pc = new PerformanceCounter();
            xpc.pc.CategoryName = xpc.objectName;
            xpc.pc.CounterName = xpc.counterName;
            xpc.pc.InstanceName = xpc.instanceName;
            xpc.pc.MachineName = xpc.machineName.Substring(2);	// remove leading \\ from machineName

            if(machineHT.ContainsKey(xpc.machineName) == false)
            {
                XBLServerBox    box = new XBLServerBox();
                box.machineName = xpc.machineName;
                box.counterList.Add(xpc);
                machineHT.Add(xpc.machineName, box);
            }
            else    // only add the counter for a specific machine
                ((XBLServerBox)machineHT[xpc.machineName]).counterList.Add(xpc);
        }

        private static void AddAggCounterToTable(SqlDataReader sqlReader)
        {
            int counterID = (int)sqlReader.GetInt32(0);
            string counterName = (string)sqlReader.GetString(1);
		    string machineName = sqlReader.GetString(2);
            int realCounterId = (int)sqlReader.GetInt32(3);

            if(aggCounterHT.ContainsKey(counterID)==false)
            {
                byte type = sqlReader.GetByte(4);
                AggType aggType;
                if(type == 1)
                    aggType = AggType.SUM;
                else if (type == 2)
                    aggType = AggType.AVG;
                else
                    throw new Exception("Aggregated counter type of " + type +
                        " is not supported. Counter name: " + counterName);

                XBLAggPerfCounter   apc = new XBLAggPerfCounter(aggType);
                apc.counterID = counterID;
                apc.counterName = counterName;

				aggCounterHT.Add(apc.counterID, apc);

				XBLPerfCounter counter = FindRealCounter(machineName, realCounterId);
				if(counter != null)
				{
					apc.realCounters.Add(counter);
				}
				else
				{	
					XBLPerfLogEvent.LogError("AddAggCounterToTable: " + machineName + "\\" + realCounterId  
						+ " for aggregated counter " + counterName + " does not exist");
				}
            }
            else 
            {
                XBLPerfCounter counter = FindRealCounter(machineName, realCounterId);
				if(counter != null)
				{
					((XBLAggPerfCounter)aggCounterHT[counterID]).realCounters.Add( counter );
				}
				else
				{
					XBLPerfLogEvent.LogError("AddAggCounterToTable: " + machineName + "\\" + realCounterId  
						+ " for aggregated counter " + counterName + " does not exist");
				}
            }
        }

        private static XBLPerfCounter FindRealCounter(string machineName, int counterID)
        {
            ArrayList counterList = ((XBLServerBox)machineHT[machineName]).counterList;
            int listSize = counterList.Count;
            for (int i = 0; i < listSize; ++i)
            {
                if (((XBLPerfCounter)counterList[i]).counterID==counterID )
                {
                    return (XBLPerfCounter)counterList[i];
                }
            }
            return null;
        }

		// sp_GetNewInstances not only return old counters with instanceName changes, 
		// but also return any newly added counters, but we will ignore since it will 
		// be picked up by GetNewRealCounters sp
		private static void UpdateInstances(SqlDataReader newInstanceReader, ref bool lockAcquired)
		{
			int				tempCounterID;
			string			tempMachineName, tempInstanceName;

			while(newInstanceReader.Read())
			{
				tempCounterID = (int)newInstanceReader.GetInt32(0);
				tempMachineName = (string)newInstanceReader.GetString(1);
				tempInstanceName = (string)newInstanceReader.GetString(2);

				if(lockAcquired == false)
				{
					htLock.AcquireWriterLock(-1);
					lockAcquired = true;
				}

				if(machineHT.ContainsKey(tempMachineName) == true)
				{
					ArrayList	cl = ((XBLServerBox)machineHT[tempMachineName]).counterList;
					int c = cl.Count;
					for(int i = 0; i < c; i++)
					{
						if(((XBLPerfCounter)cl[i]).counterID == tempCounterID)
						{
							// this is an instance change
							((XBLPerfCounter)cl[i]).instanceName = tempInstanceName;
							break;
						}
					}
				}
				else
				{
					XBLPerfLogEvent.LogError("Machine: " + tempMachineName + 
											" returned in sp_GetNewInstances is invalid");
				}
			}
		}

		private static void AddNewCounters(SqlDataReader newCounterReader, ref bool lockAcquired)
		{
			while(newCounterReader.Read())
			{
				XBLPerfCounter  xpc  = new XBLPerfCounter();

				xpc.counterID        = (int)newCounterReader.GetInt32(0);
				xpc.machineName      = (string)newCounterReader.GetString(1);
				xpc.objectName       = (string)newCounterReader.GetString(2);
				xpc.counterName      = (string)newCounterReader.GetString(3);
				xpc.instanceName     = (string)newCounterReader.GetString(4);               

				xpc.pc = new PerformanceCounter();
				xpc.pc.CategoryName = xpc.objectName;
				xpc.pc.CounterName = xpc.counterName;
				xpc.pc.InstanceName = xpc.instanceName;
				xpc.pc.MachineName = xpc.machineName.Substring(2);	// remove leading \\ from machineName
        
				if(lockAcquired == false)
				{
					htLock.AcquireWriterLock(-1);
					lockAcquired = true;
				}

				((XBLServerBox)(XBLPerfLogMain.machineHT[xpc.machineName])).counterList.Add(xpc);
			}
		}

		private static void AddNewAggCounters(SqlDataReader newAggCounterReader, ref bool lockAcquired)
		{
			Hashtable	tempHt = new Hashtable();
			while(newAggCounterReader.Read())
			{
				int counterID = (int)newAggCounterReader.GetInt32(0);
				string counterName = (string)newAggCounterReader.GetString(1);
				string machineName = newAggCounterReader.GetString(2);
				int realCounterId = (int)newAggCounterReader.GetInt32(3);
				byte type = newAggCounterReader.GetByte(4);
				AggType aggType;
				if(type == 1)
					aggType = AggType.SUM;
				else if (type == 2)
					aggType = AggType.AVG;
				else
				{
					XBLPerfLogEvent.LogError("AddNewAggCounters: Aggregated counter type of " + type + 
											" is not supported. Counter name: " + counterName );
					continue;
				}

				if(lockAcquired == false)
				{
					htLock.AcquireWriterLock(-1);
					lockAcquired = true;
				}
				if(tempHt.Contains(counterID) == false)
				{
					XBLAggPerfCounter	apc = new XBLAggPerfCounter(aggType);
					apc.counterID = counterID;
					apc.counterName = counterName;

					aggCounterHT.Remove(counterID);
					tempHt.Add(counterID, counterID);
					aggCounterHT.Add(counterID,apc);
				}

				XBLPerfCounter		counter = FindRealCounter(machineName, realCounterId);
				if(counter == null)
				{
					XBLPerfLogEvent.LogError("CheckChangesThread: " + machineName + "\\" 
						+ realCounterId + " for aggregated counter " + counterName + " does not exist");
				}
				else
				{
					((XBLAggPerfCounter)aggCounterHT[counterID]).realCounters.Add(counter);
				}
			}
		}

		private static void RemoveRealCounters(SqlDataReader removedRealCounterReader, ref bool lockAcquired)
		{
			while(removedRealCounterReader.Read())
			{
				int		counterID	= (int)removedRealCounterReader.GetInt32(0);
				string	machineName = (string)removedRealCounterReader.GetString(1);
				XBLPerfCounter	xpc = FindRealCounter(machineName, counterID);

				if(xpc == null)
				{
					XBLPerfLogEvent.LogError("RemoveRealCounters: " + machineName + "\\" +
						counterID + " does not exist");
				}
				else
				{
					if(lockAcquired == false)
					{
						htLock.AcquireWriterLock(-1);
						lockAcquired = true;
					}

					((XBLServerBox)(XBLPerfLogMain.machineHT[xpc.machineName])).counterList.Remove(xpc);
				}
			}
		}

		private static void RemoveAggCounters(SqlDataReader removedAggCounterReader, ref bool lockAcquired)
		{
			while(removedAggCounterReader.Read())
			{
				int counterID = (int)removedAggCounterReader.GetInt32(0);

				if(lockAcquired == false)
				{
					htLock.AcquireWriterLock(-1);
					lockAcquired = true;
				}
				
				aggCounterHT.Remove(counterID);
			}
		}

        private static void WriteDataThread()
        {
            string                  myConnStr = "Data Source=" + sqlIP + @";Database=PerfDB" + 
                                                @";Trusted_Connection=true";
            SqlConnection           mySqlConn = new SqlConnection(myConnStr);
            SqlCommand              myCommand = new SqlCommand();
            SqlParameter            ret = null;
            CounterValueQueue       localValueQueue = new CounterValueQueue();
            XBLPerfCounterValue     pcv;

			WaitHandle[]			events = new WaitHandle[2];
			events[0] = dataAvailable;
			events[1] = shutdown;

            myCommand.Connection = mySqlConn;
            myCommand.CommandType = CommandType.StoredProcedure;
            myCommand.CommandText = "sp_InsertCounterData";

			try
			{
				mySqlConn.Open();

				while(true)
				{
					Debug.Assert((localValueQueue.head==null) && (localValueQueue.tail==null));

					int index = WaitHandle.WaitAny(events); 
					if (index==1) 
					{
						return;
					}

					// move all the content in the globalQueue into WriteDataThread's 
					// local queue to minimize lock contention
					lock(globalQueue)
					{
						localValueQueue.head = globalQueue.head;
						localValueQueue.tail = globalQueue.tail;
						globalQueue.head = globalQueue.tail = null;
						dataAvailable.Reset();
					}

					while((pcv = localValueQueue.Dequeue()) != null)
					{
						myCommand.Parameters.Clear();

						ret = new SqlParameter();
						ret.Direction = ParameterDirection.ReturnValue;
 
						myCommand.Parameters.Add(ret);
						myCommand.Parameters.Add("@GUID",SqlDbType.UniqueIdentifier).Value  = XBLPerfLogMain.guid;
						myCommand.Parameters.Add("@CounterID",SqlDbType.Int).Value  = pcv.counterID;
						myCommand.Parameters.Add("@RecordIndex",SqlDbType.Int).Value = pcv.recordIndex;
						myCommand.Parameters.Add("@CounterDateTime",SqlDbType.VarChar).Value = pcv.counterDateTime;
						myCommand.Parameters.Add("@CounterValue",SqlDbType.Float).Value = pcv.counterValue;
						myCommand.Parameters.Add("@FirstValueA",SqlDbType.Int).Value = pcv.firstValueA;
						myCommand.Parameters.Add("@FirstValueB",SqlDbType.Int).Value = pcv.firstValueB;
						myCommand.Parameters.Add("@SecondValueA",SqlDbType.Int).Value = pcv.secondValueA;
						myCommand.Parameters.Add("@SecondValueB",SqlDbType.Int).Value = pcv.secondValueB;
						myCommand.Parameters.Add("@MultiCount",SqlDbType.Int).Value = -1;
						myCommand.Parameters.Add("@MachineCount",SqlDbType.Int).Value = pcv.validCount;

						try
						{
							myCommand.ExecuteNonQuery();
						}
						catch (SqlException e)
						{
							XBLPerfLogEvent.LogError("SqlException: " + e.Message + " at " + e.StackTrace);
						}
						if((int)ret.Value != 0)
						{
							XBLPerfLogEvent.LogError("WriteDataThread:sp_InsertCounterData failed for " + 
								pcv.counterID + "at " + pcv.counterDateTime + ":" + pcv.recordIndex);
						}
					}
				}
			} 
			catch (SqlException e)
			{
				XBLPerfLogEvent.LogError("SqlException: " + e.Message + " at " + e.StackTrace);
			}
			finally
			{
				if(mySqlConn != null)
				{
					mySqlConn.Close();
					mySqlConn = null;
				}
			}
        }

        private static void CheckChangesThread()
        {
            string              myConnStr = "Data Source=" + sqlIP + @";Database=PerfDB" + 
                                            @";Trusted_Connection=true";
            SqlConnection       mySqlConn = new SqlConnection(myConnStr);
			bool				lockAcquired = false;
			SqlParameter		ret = null;
			SqlCommand          myCommand1 = new SqlCommand(), myCommand2 = new SqlCommand(), 
								myCommand3 = new SqlCommand(), myCommand4 = new SqlCommand(), myCommand5 = new SqlCommand();
			SqlDataReader       newCounterReader = null, newAggCounterReader = null, 
								newInstanceReader = null, removedRealCounterReader = null,
								removedAggCounterReader = null;
			bool				exit = false;

			try
			{
				mySqlConn.Open();

				myCommand1.Connection = mySqlConn;
				myCommand1.CommandType = CommandType.StoredProcedure;
				myCommand1.CommandText = "sp_GetNewInstances";

				myCommand2.Connection = mySqlConn;
				myCommand2.CommandType = CommandType.StoredProcedure;
				myCommand2.CommandText = "sp_GetNewRealCounter";

				myCommand3.Connection = mySqlConn;
				myCommand3.CommandType = CommandType.StoredProcedure;
				myCommand3.CommandText = "sp_GetNewAggregateCounters";

				myCommand4.Connection = mySqlConn;
				myCommand4.CommandType = CommandType.StoredProcedure;
				myCommand4.CommandText = "sp_GetDeletedRealCounter";

				myCommand5.Connection = mySqlConn;
				myCommand5.CommandType = CommandType.StoredProcedure;
				myCommand5.CommandText = "sp_GetDeletedAggCounters";

				int	timeCount = 0;
				while(exit == false)
				{
					// check instance changes every 1 minute
					Thread.Sleep(1*60*1000);
					timeCount++;
					ret = new SqlParameter();
					ret.Direction = ParameterDirection.ReturnValue;
					myCommand1.Parameters.Clear();
					myCommand1.Parameters.Add(ret);
					
					newInstanceReader = myCommand1.ExecuteReader();
					// sp_GetNewInstances: will return new counters also, but will ignore it
					// since it will be picked up when calling the sp_GetNewRealCounters
					UpdateInstances(newInstanceReader, ref lockAcquired);					
					newInstanceReader.Close();
					newInstanceReader = null;
					if((int)ret.Value != 0)
					{
						XBLPerfLogEvent.LogError("Calling sp_GetNewInstances failed");
					}

					// check every 15 minutes for newly added/removed counters
					if(timeCount == 15)
					{
						timeCount = 0;

						// check newly added real counters
						ret = new SqlParameter();
						ret.Direction = ParameterDirection.ReturnValue;
						myCommand2.Parameters.Clear();
						myCommand2.Parameters.Add(ret);
						newCounterReader = myCommand2.ExecuteReader();
						
						AddNewCounters(newCounterReader, ref lockAcquired);
						
						newCounterReader.Close();
						newCounterReader = null;
						if((int)ret.Value != 0)
						{
							XBLPerfLogEvent.LogError("Calling sp_GetNewRealCounter failed");
						}

						// check aggregatedCounters changes (adding/removing boxes or adding completely new agg)
						ret = new SqlParameter();
						ret.Direction = ParameterDirection.ReturnValue;
						myCommand3.Parameters.Clear();
						myCommand3.Parameters.Add(ret);
						newAggCounterReader = myCommand3.ExecuteReader();
						
						AddNewAggCounters(newAggCounterReader, ref lockAcquired);
						
						newAggCounterReader.Close();
						newAggCounterReader = null;
						if((int)ret.Value != 0)
						{
							XBLPerfLogEvent.LogError("Calling sp_GetNewAggregateCounters failed");
						}

						// check removed real counters
						ret = new SqlParameter();
						ret.Direction = ParameterDirection.ReturnValue;
						myCommand4.Parameters.Clear();
						myCommand4.Parameters.Add(ret);
						removedRealCounterReader = myCommand4.ExecuteReader();

						RemoveRealCounters(removedRealCounterReader, ref lockAcquired);

						removedRealCounterReader.Close();
						removedRealCounterReader = null;
						if((int)ret.Value != 0)
						{
							XBLPerfLogEvent.LogError("Calling sp_GetDeletedRealCounter failed");
						}

						// check removed aggregated counters
						ret = new SqlParameter();
						ret.Direction = ParameterDirection.ReturnValue;
						myCommand5.Parameters.Clear();
						myCommand5.Parameters.Add(ret);
						removedAggCounterReader = myCommand5.ExecuteReader();

						RemoveAggCounters(removedAggCounterReader, ref lockAcquired);

						removedAggCounterReader.Close();
						removedAggCounterReader = null;
						if((int)ret.Value != 0)
						{
							XBLPerfLogEvent.LogError("Calling sp_GetDeletedAggCounters failed");
						}
					}
					if(lockAcquired)
					{
						htLock.ReleaseWriterLock();
						lockAcquired = false;
					}

					exit = XBLPerfLogMain.shutdown.WaitOne(1,false);
				}			
			}
			catch (Exception e)
			{
				XBLPerfLogEvent.LogError("Exception: " + e.Message + " at " + e.StackTrace);
			}
			finally
			{
				if(mySqlConn!=null)
				{
					mySqlConn.Close();
					mySqlConn = null;
				}
				if(lockAcquired)
				{
					htLock.ReleaseWriterLock();
					lockAcquired = false;
				}
			}
        }

		private static void StartDataCollection()
		{
			IDictionaryEnumerator   ide = machineHT.GetEnumerator();
			int                     htCount = machineHT.Count;
			XBLServerBox            currentBox = null;

			for(int i = 0; i < htCount; i++)
			{
				if(ide.MoveNext())
				{
					currentBox = (XBLServerBox)(ide.Value);
					currentBox.StartCollection();
				}
			}
		}
        /// <summary>
        /// The main entry point for the application.
        /// </summary>
        [STAThread]
        static void Main(string[] args)
        {
            bool exit = false;
            SqlConnection   mySqlConn = null;
            SqlCommand      myCommand = null;
            SqlDataReader   sqlReader = null;
            SqlParameter    ret = null;

            // get command line arguments
            if ( ProcessCommandLineArgs(args)!=true )
            {
                return;
            }

            try
            {
                string myConnStr = "Data Source=" + sqlIP + @";Database=PerfDB" + 
								 @";Trusted_Connection=true";

                // open a connection to the perfCounterDB in SQL server
                mySqlConn = new SqlConnection(myConnStr);
                mySqlConn.Open();

                // add an entry in DisplayToID table
                myCommand = new SqlCommand();
                myCommand.Connection = mySqlConn;
                myCommand.CommandType = CommandType.StoredProcedure;
                myCommand.CommandText = "sp_StartNewLog";

                ret = new SqlParameter();
                ret.Direction = ParameterDirection.ReturnValue;
                myCommand.Parameters.Add(ret);
                myCommand.Parameters.Add("@GUID",SqlDbType.UniqueIdentifier).Value  = XBLPerfLogMain.guid;
                myCommand.Parameters.Add("@DisplayString",SqlDbType.VarChar).Value  = DateTime.Now.ToString("u",DateTimeFormatInfo.InvariantInfo);
        
                myCommand.ExecuteNonQuery();
            
                if((int)ret.Value != 0)
                    throw new Exception("Calling sp_StartNewLog failed");

                // get real counters and create machine hashtable
                myCommand.CommandText = "sp_GetRealCounters";
                myCommand.Parameters.Clear();
                myCommand.Parameters.Add(ret);
                sqlReader = myCommand.ExecuteReader();

                // build the machineHT
                while(sqlReader.Read())
                {
                    AddCounterToTable(sqlReader);
                }
                sqlReader.Close();
                sqlReader = null;
				if((int)ret.Value != 0)
					throw new Exception("Calling sp_GetRealCounters failed");                

                // get aggregated counters
                myCommand.CommandText = "sp_GetAggregateCounters";
                myCommand.Parameters.Clear();
                myCommand.Parameters.Add(ret);
                sqlReader = myCommand.ExecuteReader();  

                // build the aggregated counter HT
                while(sqlReader.Read())
                {
                    AddAggCounterToTable(sqlReader);
                }
                sqlReader.Close();
                sqlReader = null;
				if((int)ret.Value != 0)
					throw new Exception("Calling sp_GetAggregateCounters failed");                
            }
            catch(Exception e)
            {
				XBLPerfLogEvent.LogError("Exception: " + e.Message + " at " + e.StackTrace);
				exit = true;
            }
            finally
            {
                if(mySqlConn != null)
                {
                    mySqlConn.Close();
                    mySqlConn = null;
                }
            }
            if(exit)
                return;

            // start WriteDataThread thread that writes collected data to the CounterData table
            writeDataThread = new Thread(new ThreadStart(WriteDataThread));
            writeDataThread.Start();

            // start data collection threads on all boxes.
			StartDataCollection();

            // create another thread to check any new counters being added and any instance changes
            Thread checkUpdateThread = new Thread(new ThreadStart(CheckChangesThread));
            checkUpdateThread.Start();

            Console.WriteLine("Server Logging started ...");
            Console.Write("Hit 'q' to quit: ");
            while(true)
            {
                string inputString = Console.ReadLine();
                if(inputString.Equals("q"))
                    break;
            }

			shutdown.Set();
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\perflog\XBLPerfLogTool\AssemblyInfo.cs ===
using System.Reflection;
using System.Runtime.CompilerServices;

//
// General Information about an assembly is controlled through the following 
// set of attributes. Change these attribute values to modify the information
// associated with an assembly.
//
[assembly: AssemblyTitle("")]
[assembly: AssemblyDescription("")]
[assembly: AssemblyConfiguration("")]
[assembly: AssemblyCompany("")]
[assembly: AssemblyProduct("")]
[assembly: AssemblyCopyright("")]
[assembly: AssemblyTrademark("")]
[assembly: AssemblyCulture("")]		

//
// Version information for an assembly consists of the following four values:
//
//      Major Version
//      Minor Version 
//      Build Number
//      Revision
//
// You can specify all the values or you can default the Revision and Build Numbers 
// by using the '*' as shown below:

[assembly: AssemblyVersion("1.0.*")]

//
// In order to sign your assembly you must specify a key to use. Refer to the 
// Microsoft .NET Framework documentation for more information on assembly signing.
//
// Use the attributes below to control which key is used for signing. 
//
// Notes: 
//   (*) If no key is specified, the assembly is not signed.
//   (*) KeyName refers to a key that has been installed in the Crypto Service
//       Provider (CSP) on your machine. KeyFile refers to a file which contains
//       a key.
//   (*) If the KeyFile and the KeyName values are both specified, the 
//       following processing occurs:
//       (1) If the KeyName can be found in the CSP, that key is used.
//       (2) If the KeyName does not exist and the KeyFile does exist, the key 
//           in the KeyFile is installed into the CSP and used.
//   (*) In order to create a KeyFile, you can use the sn.exe (Strong Name) utility.
//        When specifying the KeyFile, the location of the KeyFile should be
//        relative to the "project output directory". The location of the project output
//        directory is dependent on whether you are working with a local or web project.
//        For local projects, the project output directory is defined as
//       <Project Directory>\obj\<Configuration>. For example, if your KeyFile is
//       located in the project directory, you would specify the AssemblyKeyFile 
//       attribute as [assembly: AssemblyKeyFile("..\\..\\mykey.snk")]
//        For web projects, the project output directory is defined as
//       %HOMEPATH%\VSWebCache\<Machine Name>\<Project Directory>\obj\<Configuration>.
//   (*) Delay Signing is an advanced option - see the Microsoft .NET Framework
//       documentation for more information on this.
//
[assembly: AssemblyDelaySign(false)]
[assembly: AssemblyKeyFile("")]
[assembly: AssemblyKeyName("")]
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\perflog\XBLPerfLog\XBLPerfLogService\InstanceMapperThread.cs ===
using System;
using System.Collections.Specialized;
using System.Data.SqlClient;
using System.Threading;
using InstanceMapper;

namespace XBLPerfLog
{
	/// <summary>
	/// The InstanceMapper class is the bridge between the larger XBLPerfLog appplication and the core InstanceMapper
	/// functionality, allowing InstanceMapper to integrate cleanly with XBLPerfLog
	/// </summary>
	public class InstanceMapper
	{
		private const int SecsPerCycle	= 300;

		/// <summary>
		/// Helper function for demo'ing and debugging
		/// </summary>
		private static void WriteMappingsToConsole(string MachineName, HybridDictionary processMap)
		{
			Console.WriteLine("Machine Name: {0}", MachineName);
			Console.WriteLine("Mappings Count = " + processMap.Count);
			foreach (int PID in processMap.Keys)
			{
				InstanceNameAndAppPoolIDMap Mapping = (InstanceNameAndAppPoolIDMap)processMap[PID];
				Console.WriteLine("PID: {0}\tAppPoolID: {1}\tInstanceName: {2}", PID, Mapping.AppPoolID, Mapping.InstanceName);
			}
			Console.WriteLine("");
		}

		/// <summary>
		/// Assigns the contents of a StringCollection to a new String Array
		/// </summary>
		private static string[] StringCollectionToStringArray(System.Collections.Specialized.StringCollection SourceCollection)
		{
			string[] TargetArray = new string[SourceCollection.Count];
			int i = 0;
			foreach (string s in SourceCollection)
			{
				TargetArray[i++] = s;
			}
            return(TargetArray);
		}

		/// <summary>
		/// Calls sp_GetWebServerMachineNames in the DB to retrieve the list of machine names registered as WebServers.
		/// </summary>
		private static string[] GetWebServerMachineNames()
		{
			SqlConnection XOnlineTestConn = new SqlConnection("Data Source=" + XBLPerfLogMain.sqlIP + "; Integrated Security=SSPI; Initial Catalog=PerfDB");
			SqlCommand WebServerMachineNamesCmd = new SqlCommand("sp_GetWebServerMachineNames", XOnlineTestConn);
			WebServerMachineNamesCmd.CommandType = System.Data.CommandType.StoredProcedure;

			XOnlineTestConn.Open();
			SqlDataReader MachineNamesReader = WebServerMachineNamesCmd.ExecuteReader();
			Console.WriteLine("{0}", MachineNamesReader.GetName(0));

			System.Collections.Specialized.StringCollection MachineNames = new System.Collections.Specialized.StringCollection();
			while (MachineNamesReader.Read())
			{
				Console.WriteLine("{0}", MachineNamesReader.GetString(0));
				MachineNames.Add(MachineNamesReader.GetString(0));
			}

			MachineNamesReader.Close();
			XOnlineTestConn.Close();

			return(StringCollectionToStringArray(MachineNames));
		}

		/// <summary>
		/// Calls sp_SetInstanceDisplayName in the DB to insert/update corresponding Display Name and Instance Name data
		/// for a specific machine
		/// </summary>
		private static void SetInstanceDisplayName(string MachineName, string AppPoolID, string InstanceName)
		{
			SqlConnection XOnlineTestConn = new SqlConnection("Data Source=" + XBLPerfLogMain.sqlIP + "; Integrated Security=SSPI; Initial Catalog=PerfDB");
			SqlCommand WebServerMachineNamesCmd = new SqlCommand("sp_SetInstanceDisplayName", XOnlineTestConn);
			WebServerMachineNamesCmd.CommandType = System.Data.CommandType.StoredProcedure;

			WebServerMachineNamesCmd.Parameters.Add("@MachineName", System.Data.SqlDbType.VarChar, 1024).Value = MachineName;
			WebServerMachineNamesCmd.Parameters.Add("@DisplayName", System.Data.SqlDbType.VarChar, 1024).Value = AppPoolID;
			WebServerMachineNamesCmd.Parameters.Add("@InstanceName", System.Data.SqlDbType.VarChar, 1024).Value = InstanceName;

			XOnlineTestConn.Open();
			SqlDataReader MachineNamesReader = WebServerMachineNamesCmd.ExecuteReader();
			if (MachineNamesReader.RecordsAffected != 1)
			{
				throw(new System.Exception("SetInstanceDisplayName: RecordsAffected != 1.  The # of records affected should always be 1.  Please investigate."));
			}

			MachineNamesReader.Close();
			XOnlineTestConn.Close();

			return;
		}

		/// <summary>
		/// Calls SetInstanceDisplayName for each w3wp.exe process in the process map from a single machine.
		/// </summary>
		private static void WriteMappingsToDB(string MachineName, HybridDictionary processMap)
		{
			foreach (int PID in processMap.Keys)
			{
				InstanceNameAndAppPoolIDMap Mapping = (InstanceNameAndAppPoolIDMap)processMap[PID];
				SetInstanceDisplayName(MachineName, Mapping.AppPoolID, Mapping.InstanceName);
			}
		}

		/// <summary>
		/// Calls the main function for getting instance names and app pool IDs then stores the results in the DB.
		/// Cycles until instructed to shutdown.
		/// </summary>
		public static void InstanceMapperThread()
		{
			bool Exit = false;
			while (!Exit)
			{
				DateTime StartDT = DateTime.Now;

				string[] MachineNames = GetWebServerMachineNames();

				// Get the data
				InstanceNameAndAppPoolIDMapper oMapper = new InstanceNameAndAppPoolIDMapper();
				HybridDictionary MachineMaps = oMapper.GetInstanceNameAndAppPoolIDMaps(MachineNames);

				// Spew it out
				foreach (string MachineName in MachineMaps.Keys)
				{
					HybridDictionary ProcessMap = (HybridDictionary)MachineMaps[MachineName];
					WriteMappingsToConsole(MachineName, ProcessMap);
					WriteMappingsToDB(MachineName, ProcessMap);
				}

				// Wait for another cycle or the exit signal
				int SleepSecs = SecsPerCycle - DateTime.Now.Subtract(StartDT).Seconds;
				if (SleepSecs < 0)
				{
					SleepSecs = 0;
				}
				Exit = XBLPerfLogMain.shutdown.WaitOne(SleepSecs * 1000, false);
			}
		}
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\perflog\XBLPerfLog\XBLPerfLogService\InstanceNameAndAppPoolIDMapper.cs ===
using System;
using System.Collections.Specialized;
using System.ComponentModel;
using System.Diagnostics;
using System.Management;
using System.Text.RegularExpressions;
using System.Threading;

namespace InstanceMapper
{
	/// <summary>
	/// Provides a type-safe way to associate an AppPoolID with its corresponding InstanceName
	/// </summary>
	public struct InstanceNameAndAppPoolIDMap
	{
		public string AppPoolID;
		public string InstanceName;
	}

	/// <summary>
	/// When an specialized exception (i.e. COMException) is logged by an inner function with extra context dependent
	/// details but can't be handled, it is re-thrown wrapped in this LoggedException class so that the main try/catch
	/// block doesn't re-log the exception.
	/// </summary>
	public class LoggedException : System.Exception
	{
		public LoggedException(System.Exception e)
		{
			this.e = e;
		}
		public System.Exception e;
	}

	/// <summary>
	/// Given a list of machine names, maps out the relationship between AppPoolIDs and PerfMon instance names
	/// </summary>
	class InstanceNameAndAppPoolIDMapper
	{
		private const string wmiConnect  = "\\\\{0}\\root\\cimv2";
		ManualResetEvent[] ThreadCompletionEvents;

		private struct TheadData
		{
			public HybridDictionary MachinesDict;
			public string MachineName;
			public ManualResetEvent OnCompletionEvent;

			public TheadData(string MachineName, ref HybridDictionary MachinesDict, ref ManualResetEvent OnCompletionEvent)
			{
				this.MachinesDict = MachinesDict;
				this.MachineName = MachineName;
				this.OnCompletionEvent = OnCompletionEvent;
			}
		}

		/// <summary>
		/// IIS includes the AppPoolID as part of the command line when it launches w3wp.exe.  Given the command line,
		/// this method extracts and returns the AppPoolID
		/// </summary>
		private static string ExtractAppPoolID(string commandLine)
		{
			Regex r = new Regex("-ap \"(?<name>\\w+)\"", RegexOptions.IgnoreCase | RegexOptions.Compiled);
			Match m = r.Match(commandLine);
			System.Diagnostics.Debug.Assert(m.Success);
			return m.Result("${name}");
		}

		/// <summary>
		/// Stores an IIS AppPoolID for a w3wp.exe process, indexed by that process's PID
		/// </summary>
		private static void GetAppPoolIDsByPID(HybridDictionary processMap, string machineName)
		{
			// The connection credentials - not needed if the logged in account has access
			ConnectionOptions oConnectionOptions = new ConnectionOptions();
			oConnectionOptions.Impersonation = ImpersonationLevel.Impersonate;
			//oConnectionOptions.Username = "JohnDoe"; 
			//oConnectionOptions.Password = "JohnsPass"; 

			// The scope
			string wmiScope = string.Format(wmiConnect, machineName);;
			ManagementScope oScope = new ManagementScope(wmiScope, oConnectionOptions);

			// The query
			string[] SelectProperties = { "Name", "ProcessID", "CommandLine" };
			SelectQuery oQuery = new SelectQuery("Win32_Process", "Name=\"w3wp.exe\"", SelectProperties);

			// Run the query within the scope
			ManagementObjectSearcher oSearcher = new ManagementObjectSearcher(oScope, oQuery);

			try
			{
				foreach(ManagementObject oReturn in oSearcher.Get())
				{
					InstanceNameAndAppPoolIDMap Mapping = new InstanceNameAndAppPoolIDMap();
					Mapping.AppPoolID = ExtractAppPoolID(oReturn["CommandLine"].ToString());
					int PID = int.Parse(oReturn["ProcessId"].ToString());
					processMap.Add(PID, Mapping);
				}
			}
			catch (System.Runtime.InteropServices.COMException COMException)
			{
				string ErrorMsg = string.Format("Exception thrown accessing {0}\nCOM Error:\n{1}", machineName, COMException.ToString());
				XBLPerfLog.XBLPerfLogEvent.LogError(ErrorMsg);
				throw(new LoggedException(COMException));
			}
			catch (System.Management.ManagementException WMIException)
			{
				string ErrorMsg = string.Format("Exception thrown accessing {0}\nWMI Error:\n{1}", machineName, WMIException.ToString());
				XBLPerfLog.XBLPerfLogEvent.LogError(ErrorMsg);
				throw(new LoggedException(WMIException));
			}
		}

		/// <summary>
		/// Stores a PerfMon instance name for a w3wp.exe process, indexed by that process's PID
		/// </summary>
		private static void GetInstanceNamesByPID(HybridDictionary processMap, string machineName)
		{
			PerformanceCounterCategory PerfCat = new PerformanceCounterCategory("Process", machineName);

			//NOTE: This is an extremely expensive call
			string[] InstanceNames = PerfCat.GetInstanceNames();

			foreach (string InstanceName in InstanceNames)
			{
				if (InstanceName.StartsWith("w3wp"))
				{
					PerformanceCounter PC = new PerformanceCounter("Process", "ID Process", InstanceName, machineName);
					int PID = int.Parse(PC.NextValue().ToString());
					if (processMap.Contains(PID))
					{
						InstanceNameAndAppPoolIDMap Mapping = (InstanceNameAndAppPoolIDMap)processMap[PID];
						Mapping.InstanceName = InstanceName;
						processMap[PID] = Mapping;
					}
				}
			}
		}

		/// <summary>
		/// Worker thread that owns collecting the data for a single machine and signaling the main thread when it's done
		/// </summary>
		static void GetInstanceNameAndAppPoolIDMapsWorker(object TargetDetails)
		{
			TheadData td = (TheadData)TargetDetails;

			try
			{
				HybridDictionary ProcessDict = new HybridDictionary();
				GetAppPoolIDsByPID(ProcessDict, td.MachineName);
				GetInstanceNamesByPID(ProcessDict, td.MachineName);
				lock(td.MachinesDict)
				{
					td.MachinesDict.Add(td.MachineName, ProcessDict);
				}
			}
			catch(LoggedException)
			{
				return;
			}
			catch(Exception e)
			{
				XBLPerfLog.XBLPerfLogEvent.LogError(string.Format("Machine Name: {0}\nUnhandled Error:\n{1}\n", td.MachineName, e.ToString()));
				//throw;
			}
			finally
			{
				td.OnCompletionEvent.Set();
			}
		}

		/// <summary>
		/// Launches 1 thread per machine and waits for them to gather the data before returning the complete results
		/// </summary>
		public HybridDictionary GetInstanceNameAndAppPoolIDMaps(string[] machineNames)
		{
			int EventsIndex = 0;
			ThreadCompletionEvents = new ManualResetEvent[machineNames.GetLength(0)];
			HybridDictionary MachinesDict = new HybridDictionary();

			DateTime StartDT = DateTime.Now;
			foreach (string MachineName in machineNames)
			{
				ThreadCompletionEvents[EventsIndex] = new ManualResetEvent(false);
				ThreadPool.QueueUserWorkItem(new WaitCallback(GetInstanceNameAndAppPoolIDMapsWorker), new TheadData(MachineName, ref MachinesDict, ref ThreadCompletionEvents[EventsIndex++]));
				Thread.Sleep(0);
			}
			WaitHandle.WaitAll(ThreadCompletionEvents);
			Console.WriteLine("WMI/PerfMon information gathering elapsed time = " + DateTime.Now.Subtract(StartDT).ToString());

			return(MachinesDict);
		}
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\perflog\XBLPerfLog\XBLPerfLogService\ProjectInstaller.cs ===
using System;
using System.Collections;
using System.ComponentModel;
using System.Configuration.Install;

namespace XBLPerfLogService
{
	/// <summary>
	/// Summary description for ProjectInstaller.
	/// </summary>
	[RunInstaller(true)]
	public class ProjectInstaller : System.Configuration.Install.Installer
	{
		private System.ServiceProcess.ServiceProcessInstaller serviceProcessInstaller1;
		private System.ServiceProcess.ServiceInstaller XBLPerfLogService;
		/// <summary>
		/// Required designer variable.
		/// </summary>
		private System.ComponentModel.Container components = null;

		public ProjectInstaller()
		{
			// This call is required by the Designer.
			InitializeComponent();

			// TODO: Add any initialization after the InitializeComponent call
		}

		/// <summary> 
		/// Clean up any resources being used.
		/// </summary>
		protected override void Dispose( bool disposing )
		{
			if( disposing )
			{
				if(components != null)
				{
					components.Dispose();
				}
			}
			base.Dispose( disposing );
		}


		#region Component Designer generated code
		/// <summary>
		/// Required method for Designer support - do not modify
		/// the contents of this method with the code editor.
		/// </summary>
		private void InitializeComponent()
		{
			this.serviceProcessInstaller1 = new System.ServiceProcess.ServiceProcessInstaller();
			this.XBLPerfLogService = new System.ServiceProcess.ServiceInstaller();
			// 
			// serviceProcessInstaller1
			// 
			this.serviceProcessInstaller1.Password = null;
			this.serviceProcessInstaller1.Username = null;
			// 
			// XBLPerfLogService
			// 
			this.XBLPerfLogService.ServiceName = "XBLPerfLogService";
			// 
			// ProjectInstaller
			// 
			this.Installers.AddRange(new System.Configuration.Install.Installer[] {
																					  this.serviceProcessInstaller1,
																					  this.XBLPerfLogService});

		}
		#endregion
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\perflog\XBLPerfLog\XBLPerfLogParams.cs ===
using System;
using System.Collections;
using System.Threading;
using System.Diagnostics;
using System.Globalization;

namespace XBLPerfLog
{
	public class node
	{
		public XBLPerfCounterValue v;
		public node next;
		public node(XBLPerfCounterValue pcv)
		{
			v = pcv;
			next = null;
		}
	}
	public class CounterValueQueue
	{
		public node head;
		public node tail;

		public void Enqueue(XBLPerfCounterValue pcv)
		{
			if(head == null)	
				head = tail = new node(pcv);
			else
			{
				tail.next = new node(pcv);
				tail = tail.next;
			}
		}

		public XBLPerfCounterValue Dequeue()
		{
			if(head == null)
			{
				return null;
			}
			else if(head == tail)
			{
				node temp = head;
				head = tail = null;
				return temp.v;
			}
			else
			{
				node n = head;
				head = head.next;
				n.next = null;
				return n.v;
			}
		}

		public void MoveTo(CounterValueQueue q)
		{
			Debug.Assert(q!=null);

			lock(q)
			{
				if(q.head != null)
				{
					q.tail.next = this.head;
					q.tail = this.tail;
				}
				else
				{
					q.head = this.head;
					q.tail = this.tail;
				}
				this.head = this.tail = null;
			}
		}

		public CounterValueQueue()
		{
			head = tail = null;
		}
	}

	public class XBLPerfCounterValue
	{
		public int			counterID;
		public string		counterDateTime;
		public float		counterValue;
		public int			recordIndex;
		public int			firstValueA;
		public int			firstValueB;
		public int			secondValueA;
		public int			secondValueB;

		public int			validCount;	// 1 for real counter, n for aggCounter
	}

	public enum AggType
	{
		SUM = 1,
		AVG = 2
	};
	
	public class XBLPerfCounter
	{
		public int			counterID;
		public string		objectName;
		public string		counterName;
		public string		instanceName;
		public string		machineName;

		public float		counterValue;
		// if no response got back for a server, this counter's value will be set to invalid value
		public bool			valueValid = true;

		public PerformanceCounter	pc;

		public XBLPerfCounter()
		{
		}
	}

	public class XBLAggPerfCounter
	{
		public	int			counterID;
		public	string		counterName;
		private AggType		aggType;
		public	ArrayList	realCounters;
		// the number of valid individual counter values used to calculate aggregated value
		public int			validCount;

		public XBLAggPerfCounter(AggType type)
		{
			aggType = type;
			realCounters = new ArrayList(100);
		}
		public float GetValue()
		{
			float result=0;
			int   count = realCounters.Count;

			validCount = 0;

			// SUM
			for (int i=0; i<count; ++i)
			{
				XBLPerfCounter counter = (XBLPerfCounter)realCounters[i];
				if (counter.valueValid)
				{
					result += counter.counterValue;
					validCount++;
				}
			}

			// AVG
			if (aggType==AggType.AVG)
			{
				if(validCount != 0)
					result /= validCount;
				else
					XBLPerfLogEvent.LogError("The aggregated counter" + XBLPerfLogEvent.AggCounterToString(this)
											+ " has no valid real counter values associated with it");
			}

			return result;
		}
	}

	public class XBLServerBox
	{
		public ArrayList			counterList = new ArrayList(1000);
		public string				machineName = null;
		public Thread				CounterCollectionThread;
		public CounterValueQueue	localQueue;

		public XBLServerBox()
		{
			CounterCollectionThread = new Thread(new ThreadStart(CollectionThreadStart));
			localQueue       = new CounterValueQueue();
		}

		private void CollectCounters(int recordIndex)
		{
			XBLPerfCounter	counter;
			string			counterDateTime = null;
			int				count = 0;
			float			cookedValue = 0F;
			int				fA,fB;
			double			dcV;

			count = counterList.Count;
			for (int i=0; i<count; ++i)
			{
				counter = (XBLPerfCounter)counterList[i];
				PerformanceCounter pc = counter.pc;

				counterDateTime = DateTime.UtcNow.ToString("u",DateTimeFormatInfo.InvariantInfo);

				// ???
				try
				{
					counter.counterValue = cookedValue = pc.NextValue();
				}
				catch
				{
					counter.valueValid = false;
					cookedValue = 0;	// ??? no response from server, enter 0 (right value?)
				}
				unsafe
				{
					dcV = (double)cookedValue;
					int *temp = (int *)&dcV;
					fA = *temp;
					temp++;
					fB = *temp;
				}

				XBLPerfCounterValue		cv = new XBLPerfCounterValue();
				cv.recordIndex = recordIndex;
				cv.counterID = counter.counterID;
				cv.counterValue = cookedValue;
				cv.counterDateTime = counterDateTime;
				cv.firstValueA = fA;
				cv.firstValueB = fB;
				cv.secondValueA = 0;
				cv.secondValueB = 0;
				cv.validCount = 1;
				localQueue.Enqueue(cv);

				// move local queue into global queue
				// to minimize lock contention, we will only move in batches
				if(((i % 100 == 0)&& (i != 0)) || (i == (count-1)))
				{
					localQueue.MoveTo(XBLPerfLogMain.globalQueue);
					XBLPerfLogMain.dataAvailable.Set();
				}
			}
		}

		private void CalculateAggCounters(int recordIndex)
		{
			IDictionaryEnumerator	ide;
			int						htCount = 0;
			double					dcV;
			int						fA,fB;

			ide = XBLPerfLogMain.aggCounterHT.GetEnumerator();
			htCount = XBLPerfLogMain.aggCounterHT.Count;

			XBLAggPerfCounter	currentApc = null;
			for(int i = 0; i < htCount; i++)
			{
				if(ide.MoveNext())
				{
					currentApc = (XBLAggPerfCounter)ide.Value;
							
					XBLPerfCounterValue		acv = new XBLPerfCounterValue();
					acv.recordIndex = recordIndex;
					acv.counterID = currentApc.counterID;
					acv.counterValue = currentApc.GetValue();
					acv.counterDateTime = DateTime.UtcNow.ToString("u",DateTimeFormatInfo.InvariantInfo);
					// needs to break up cookedValue 
					unsafe
					{
						dcV = (double)acv.counterValue;
						int *temp = (int *)&dcV;
						fA = *temp;
						temp++;
						fB = *temp;
					}

					acv.firstValueA = fA;
					acv.firstValueB = fB;
					acv.secondValueA = 0;
					acv.secondValueB = 0;

					acv.validCount = currentApc.validCount;

					localQueue.Enqueue(acv);
				}

				// to minimize lock contention, we will only move in batches
				if(((i % 100 == 0)&& (i != 0)) || (i == (htCount-1)))
				{
					localQueue.MoveTo(XBLPerfLogMain.globalQueue);
					XBLPerfLogMain.dataAvailable.Set();
				}
			}
		}

		public void StartCollection()
		{
			CounterCollectionThread.Start();
		}

		private void CollectionThreadStart()
		{
			int					recordIndex;
			bool				shutdown = false;
			DateTime			startTime;
			int					waitms;
			bool				lockRelease = false;

			while (shutdown != true)
			{
				lockRelease = false;
				try 
				{
					XBLPerfLogMain.htLock.AcquireReaderLock(-1);

					startTime = DateTime.UtcNow;
					recordIndex = XBLPerfLogMain.recordIndex;

					CollectCounters(recordIndex);

					// check if counter values needed to calculate aggCounter are already being
					// collected from all boxes
					int numMachine = Interlocked.Increment(ref XBLPerfLogMain.numMachineCollected);
					if(numMachine == XBLPerfLogMain.machineHT.Count)
					{
						CalculateAggCounters(recordIndex);
						XBLPerfLogMain.recordIndex++;
						XBLPerfLogMain.numMachineCollected = 0;
					}

					XBLPerfLogMain.htLock.ReleaseReaderLock();
					lockRelease = true;
					// wait until next polling period or shutdown event
					waitms = (XBLPerfLogMain.updateInterval * 1000) - 
						(int)((DateTime.UtcNow.Ticks - startTime.Ticks)*0.0001);
					if(waitms <= 0)
						continue;
					else
						shutdown = XBLPerfLogMain.shutdown.WaitOne(waitms, false);
				}
				catch (Exception e)
				{
					XBLPerfLogEvent.LogError("Exception: " + e.Message + " at " + e.StackTrace);
				}
				finally
				{
					if(lockRelease == false)
					{
						XBLPerfLogMain.htLock.ReleaseReaderLock();
					}
				}
			}
		}
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\perflog\XBLPerfLog\XBLPerfLogService\XBLPerfLog.cs ===
using System;
using System.Data;
using System.Data.SqlClient;
using System.Collections;
using System.Diagnostics;
using System.Threading;
using System.Globalization;

namespace XBLPerfLog
{
    /// <summary>
    /// Summary description for Class1.
    /// </summary>
    class XBLPerfLogMain
    {
        public static string            sqlIP;
        public static int               updateInterval;
        public static Guid              guid = Guid.NewGuid();  // the Guid in the DisplayToID table

        public static Hashtable         machineHT = new Hashtable();
        public static Hashtable         aggCounterHT = new Hashtable();
		public static ReaderWriterLock  htLock = new ReaderWriterLock();

		public static CounterValueQueue globalQueue = new CounterValueQueue();
		public static ManualResetEvent	dataAvailable = new ManualResetEvent(false);
		public static Thread			writeDataThread;
		public static Thread			instanceMapperThread;

		// will be used by each machine thread:increment by 1 when a machine finishes collecting 
		// one round of it's own counters
		public static int				numMachineCollected = 0;

		public static int				recordIndex = 1;

		public static ManualResetEvent	shutdown = new ManualResetEvent(false);

        public static void AddCounterToTable(SqlDataReader sqlReader)
        {
            XBLPerfCounter  xpc = new XBLPerfCounter();

            xpc.counterID       = (int)sqlReader.GetInt32(0);
            xpc.machineName     = (string)sqlReader.GetString(1);
            xpc.objectName      = (string)sqlReader.GetString(2);
            xpc.counterName     = (string)sqlReader.GetString(3);
            xpc.instanceName        = (string)sqlReader.GetString(4);               

            // create PerformanceCounter object in advance so that we don't
            // need to repeatedly create it during collection.
            xpc.pc = new PerformanceCounter();
            xpc.pc.CategoryName = xpc.objectName;
            xpc.pc.CounterName = xpc.counterName;
            xpc.pc.InstanceName = xpc.instanceName;
            xpc.pc.MachineName = xpc.machineName.Substring(2);	// remove leading \\ from machineName

            if(machineHT.ContainsKey(xpc.machineName) == false)
            {
                XBLServerBox    box = new XBLServerBox();
                box.machineName = xpc.machineName;
                box.counterList.Add(xpc);
                machineHT.Add(xpc.machineName, box);
            }
            else    // only add the counter for a specific machine
                ((XBLServerBox)machineHT[xpc.machineName]).counterList.Add(xpc);
        }

        public static void AddAggCounterToTable(SqlDataReader sqlReader)
        {
            int counterID = (int)sqlReader.GetInt32(0);
            string counterName = (string)sqlReader.GetString(1);
		    string machineName = sqlReader.GetString(2);
            int realCounterId = (int)sqlReader.GetInt32(3);

            if(aggCounterHT.ContainsKey(counterID)==false)
            {
                byte type = sqlReader.GetByte(4);
                AggType aggType;
                if(type == 1)
                    aggType = AggType.SUM;
                else if (type == 2)
                    aggType = AggType.AVG;
                else
                    throw new Exception("Aggregated counter type of " + type +
                        " is not supported. Counter name: " + counterName);

                XBLAggPerfCounter   apc = new XBLAggPerfCounter(aggType);
                apc.counterID = counterID;
                apc.counterName = counterName;

				aggCounterHT.Add(apc.counterID, apc);

				XBLPerfCounter counter = FindRealCounter(machineName, realCounterId);
				if(counter != null)
				{
					apc.realCounters.Add(counter);
				}
				else
				{	
					XBLPerfLogEvent.LogError("AddAggCounterToTable: " + machineName + "\\" + realCounterId  
						+ " for aggregated counter " + counterName + " does not exist");
				}
            }
            else 
            {
                XBLPerfCounter counter = FindRealCounter(machineName, realCounterId);
				if(counter != null)
				{
					((XBLAggPerfCounter)aggCounterHT[counterID]).realCounters.Add( counter );
				}
				else
				{
					XBLPerfLogEvent.LogError("AddAggCounterToTable: " + machineName + "\\" + realCounterId  
						+ " for aggregated counter " + counterName + " does not exist");
				}
            }
        }

        public static XBLPerfCounter FindRealCounter(string machineName, int counterID)
        {
            ArrayList counterList = ((XBLServerBox)machineHT[machineName]).counterList;
            int listSize = counterList.Count;
            for (int i = 0; i < listSize; ++i)
            {
                if (((XBLPerfCounter)counterList[i]).counterID==counterID )
                {
                    return (XBLPerfCounter)counterList[i];
                }
            }
            return null;
        }

		// sp_GetNewInstances not only return old counters with instanceName changes, 
		// but also return any newly added counters, but we will ignore since it will 
		// be picked up by GetNewRealCounters sp
		public static void UpdateInstances(SqlDataReader newInstanceReader, ref bool lockAcquired)
		{
			int				tempCounterID;
			string			tempMachineName, tempInstanceName;

			while(newInstanceReader.Read())
			{
				tempCounterID = (int)newInstanceReader.GetInt32(0);
				tempMachineName = (string)newInstanceReader.GetString(1);
				tempInstanceName = (string)newInstanceReader.GetString(2);

				if(lockAcquired == false)
				{
					htLock.AcquireWriterLock(-1);
					lockAcquired = true;
				}

				if(machineHT.ContainsKey(tempMachineName) == true)
				{
					ArrayList	cl = ((XBLServerBox)machineHT[tempMachineName]).counterList;
					int c = cl.Count;
					for(int i = 0; i < c; i++)
					{
						if(((XBLPerfCounter)cl[i]).counterID == tempCounterID)
						{
							// this is an instance change
							((XBLPerfCounter)cl[i]).instanceName = tempInstanceName;
							break;
						}
					}
				}
				else
				{
					XBLPerfLogEvent.LogError("Machine: " + tempMachineName + 
											" returned in sp_GetNewInstances is invalid");
				}
			}
		}

		public static void AddNewCounters(SqlDataReader newCounterReader, ref bool lockAcquired)
		{
			while(newCounterReader.Read())
			{
				XBLPerfCounter  xpc  = new XBLPerfCounter();

				xpc.counterID        = (int)newCounterReader.GetInt32(0);
				xpc.machineName      = (string)newCounterReader.GetString(1);
				xpc.objectName       = (string)newCounterReader.GetString(2);
				xpc.counterName      = (string)newCounterReader.GetString(3);
				xpc.instanceName     = (string)newCounterReader.GetString(4);               

				xpc.pc = new PerformanceCounter();
				xpc.pc.CategoryName = xpc.objectName;
				xpc.pc.CounterName = xpc.counterName;
				xpc.pc.InstanceName = xpc.instanceName;
				xpc.pc.MachineName = xpc.machineName.Substring(2);	// remove leading \\ from machineName
        
				if(lockAcquired == false)
				{
					htLock.AcquireWriterLock(-1);
					lockAcquired = true;
				}

				((XBLServerBox)(XBLPerfLogMain.machineHT[xpc.machineName])).counterList.Add(xpc);
			}
		}

		public static void AddNewAggCounters(SqlDataReader newAggCounterReader, ref bool lockAcquired)
		{
			Hashtable	tempHt = new Hashtable();
			while(newAggCounterReader.Read())
			{
				int counterID = (int)newAggCounterReader.GetInt32(0);
				string counterName = (string)newAggCounterReader.GetString(1);
				string machineName = newAggCounterReader.GetString(2);
				int realCounterId = (int)newAggCounterReader.GetInt32(3);
				byte type = newAggCounterReader.GetByte(4);
				AggType aggType;
				if(type == 1)
					aggType = AggType.SUM;
				else if (type == 2)
					aggType = AggType.AVG;
				else
				{
					XBLPerfLogEvent.LogError("AddNewAggCounters: Aggregated counter type of " + type + 
											" is not supported. Counter name: " + counterName );
					continue;
				}

				if(lockAcquired == false)
				{
					htLock.AcquireWriterLock(-1);
					lockAcquired = true;
				}
				if(tempHt.Contains(counterID) == false)
				{
					XBLAggPerfCounter	apc = new XBLAggPerfCounter(aggType);
					apc.counterID = counterID;
					apc.counterName = counterName;

					aggCounterHT.Remove(counterID);
					tempHt.Add(counterID, counterID);
					aggCounterHT.Add(counterID,apc);
				}

				XBLPerfCounter		counter = FindRealCounter(machineName, realCounterId);
				if(counter == null)
				{
					XBLPerfLogEvent.LogError("CheckChangesThread: " + machineName + "\\" 
						+ realCounterId + " for aggregated counter " + counterName + " does not exist");
				}
				else
				{
					((XBLAggPerfCounter)aggCounterHT[counterID]).realCounters.Add(counter);
				}
			}
		}

		
		private static void RemoveRealCounters(SqlDataReader removedRealCounterReader, ref bool lockAcquired)
		{
			while(removedRealCounterReader.Read())
			{
				int		counterID	= (int)removedRealCounterReader.GetInt32(0);
				string	machineName = (string)removedRealCounterReader.GetString(1);
				XBLPerfCounter	xpc = FindRealCounter(machineName, counterID);

				if(xpc == null)
				{
					XBLPerfLogEvent.LogError("RemoveRealCounters: " + machineName + "\\" +
						counterID + " does not exist");
				}
				else
				{
					if(lockAcquired == false)
					{
						htLock.AcquireWriterLock(-1);
						lockAcquired = true;
					}

					((XBLServerBox)(XBLPerfLogMain.machineHT[xpc.machineName])).counterList.Remove(xpc);
				}
			}
		}

		private static void RemoveAggCounters(SqlDataReader removedAggCounterReader, ref bool lockAcquired)
		{
			while(removedAggCounterReader.Read())
			{
				int counterID = (int)removedAggCounterReader.GetInt32(0);

				if(lockAcquired == false)
				{
					htLock.AcquireWriterLock(-1);
					lockAcquired = true;
				}
				
				aggCounterHT.Remove(counterID);
			}
		}

		public static void WriteDataThread()
        {
            string                  myConnStr = "Data Source=" + sqlIP + @";Database=PerfDB" + 
                                                @";Trusted_Connection=true";
            SqlConnection           mySqlConn = new SqlConnection(myConnStr);
            SqlCommand              myCommand = new SqlCommand();
            SqlParameter            ret = null;
            CounterValueQueue       localValueQueue = new CounterValueQueue();
            XBLPerfCounterValue     pcv;

			WaitHandle[]			events = new WaitHandle[2];
			events[0] = dataAvailable;
			events[1] = shutdown;

            myCommand.Connection = mySqlConn;
            myCommand.CommandType = CommandType.StoredProcedure;
            myCommand.CommandText = "sp_InsertCounterData";

			try
			{
				mySqlConn.Open();

				while(true)
				{
					Debug.Assert((localValueQueue.head==null) && (localValueQueue.tail==null));

					int index = WaitHandle.WaitAny(events); 
					if (index==1) 
					{
						return;
					}

					// move all the content in the globalQueue into WriteDataThread's 
					// local queue to minimize lock contention
					lock(globalQueue)
					{
						localValueQueue.head = globalQueue.head;
						localValueQueue.tail = globalQueue.tail;
						globalQueue.head = globalQueue.tail = null;
						dataAvailable.Reset();
					}

					while((pcv = localValueQueue.Dequeue()) != null)
					{
						myCommand.Parameters.Clear();

						ret = new SqlParameter();
						ret.Direction = ParameterDirection.ReturnValue;
 
						myCommand.Parameters.Add(ret);
						myCommand.Parameters.Add("@GUID",SqlDbType.UniqueIdentifier).Value  = XBLPerfLogMain.guid;
						myCommand.Parameters.Add("@CounterID",SqlDbType.Int).Value  = pcv.counterID;
						myCommand.Parameters.Add("@RecordIndex",SqlDbType.Int).Value = pcv.recordIndex;
						myCommand.Parameters.Add("@CounterDateTime",SqlDbType.VarChar).Value = pcv.counterDateTime;
						myCommand.Parameters.Add("@CounterValue",SqlDbType.Float).Value = pcv.counterValue;
						myCommand.Parameters.Add("@FirstValueA",SqlDbType.Int).Value = pcv.firstValueA;
						myCommand.Parameters.Add("@FirstValueB",SqlDbType.Int).Value = pcv.firstValueB;
						myCommand.Parameters.Add("@SecondValueA",SqlDbType.Int).Value = pcv.secondValueA;
						myCommand.Parameters.Add("@SecondValueB",SqlDbType.Int).Value = pcv.secondValueB;
						myCommand.Parameters.Add("@MultiCount",SqlDbType.Int).Value = -1;
						myCommand.Parameters.Add("@MachineCount",SqlDbType.Int).Value = pcv.validCount;

						try
						{
							myCommand.ExecuteNonQuery();
						}
						catch (SqlException e)
						{
							XBLPerfLogEvent.LogError("SqlException: " + e.Message + " at " + e.StackTrace);
						}
						if((int)ret.Value != 0)
						{
							XBLPerfLogEvent.LogError("WriteDataThread:sp_InsertCounterData failed for " + 
								pcv.counterID + "at " + pcv.counterDateTime + ":" + pcv.recordIndex);
						}
					}
				}
			} 
			catch (SqlException e)
			{
				XBLPerfLogEvent.LogError("SqlException: " + e.Message + " at " + e.StackTrace);
			}
			finally
			{
				if(mySqlConn != null)
				{
					mySqlConn.Close();
					mySqlConn = null;
				}
			}
        }

        public static void CheckChangesThread()
        {
            string              myConnStr = "Data Source=" + sqlIP + @";Database=PerfDB" + 
                                            @";Trusted_Connection=true";
            SqlConnection       mySqlConn = new SqlConnection(myConnStr);
			bool				lockAcquired = false;
			SqlParameter		ret = null;
			SqlCommand          myCommand1 = new SqlCommand(), myCommand2 = new SqlCommand(), 
								myCommand3 = new SqlCommand(), myCommand4 = new SqlCommand(), myCommand5 = new SqlCommand();
			SqlDataReader       newCounterReader = null, newAggCounterReader = null, 
								newInstanceReader = null, removedRealCounterReader = null,
								removedAggCounterReader = null;
			bool				exit = false;

			try
			{
				mySqlConn.Open();

				myCommand1.Connection = mySqlConn;
				myCommand1.CommandType = CommandType.StoredProcedure;
				myCommand1.CommandText = "sp_GetNewInstances";

				myCommand2.Connection = mySqlConn;
				myCommand2.CommandType = CommandType.StoredProcedure;
				myCommand2.CommandText = "sp_GetNewRealCounter";

				myCommand3.Connection = mySqlConn;
				myCommand3.CommandType = CommandType.StoredProcedure;
				myCommand3.CommandText = "sp_GetNewAggregateCounters";

				myCommand4.Connection = mySqlConn;
				myCommand4.CommandType = CommandType.StoredProcedure;
				myCommand4.CommandText = "sp_GetDeletedRealCounter";

				myCommand5.Connection = mySqlConn;
				myCommand5.CommandType = CommandType.StoredProcedure;
				myCommand5.CommandText = "sp_GetDeletedAggCounters";

				int	timeCount = 0;
				while(exit == false)
				{
					// check instance changes every 1 minute
					Thread.Sleep(1*60*1000);
					timeCount++;
					ret = new SqlParameter();
					ret.Direction = ParameterDirection.ReturnValue;
					myCommand1.Parameters.Clear();
					myCommand1.Parameters.Add(ret);
					
					newInstanceReader = myCommand1.ExecuteReader();
					// sp_GetNewInstances: will return new counters also, but will ignore it
					// since it will be picked up when calling the sp_GetNewRealCounters
					UpdateInstances(newInstanceReader, ref lockAcquired);					
					newInstanceReader.Close();
					newInstanceReader = null;
					if((int)ret.Value != 0)
					{
						XBLPerfLogEvent.LogError("Calling sp_GetNewInstances failed");
					}

					// check every 15 minutes for newly added/removed counters
					if(timeCount == 15)
					{
						timeCount = 0;
						ret = new SqlParameter();
						ret.Direction = ParameterDirection.ReturnValue;
						myCommand2.Parameters.Clear();
						myCommand2.Parameters.Add(ret);
						newCounterReader = myCommand2.ExecuteReader();
						
						AddNewCounters(newCounterReader, ref lockAcquired);
						
						newCounterReader.Close();
						newCounterReader = null;
						if((int)ret.Value != 0)
						{
							XBLPerfLogEvent.LogError("Calling sp_GetNewRealCounter failed");
						}

						// check aggregatedCounters changes (adding/removing boxes or adding completely new agg)
						ret = new SqlParameter();
						ret.Direction = ParameterDirection.ReturnValue;
						myCommand3.Parameters.Clear();
						myCommand3.Parameters.Add(ret);
						newAggCounterReader = myCommand3.ExecuteReader();
						
						AddNewAggCounters(newAggCounterReader, ref lockAcquired);
						
						newAggCounterReader.Close();
						newAggCounterReader = null;
						if((int)ret.Value != 0)
						{
							XBLPerfLogEvent.LogError("Calling sp_GetNewAggregateCounters failed");
						}

						// check removed real counters
						ret = new SqlParameter();
						ret.Direction = ParameterDirection.ReturnValue;
						myCommand4.Parameters.Clear();
						myCommand4.Parameters.Add(ret);
						removedRealCounterReader = myCommand4.ExecuteReader();

						RemoveRealCounters(removedRealCounterReader, ref lockAcquired);

						removedRealCounterReader.Close();
						removedRealCounterReader = null;
						if((int)ret.Value != 0)
						{
							XBLPerfLogEvent.LogError("Calling sp_GetDeletedRealCounter failed");
						}

						// check removed aggregated counters
						ret = new SqlParameter();
						ret.Direction = ParameterDirection.ReturnValue;
						myCommand5.Parameters.Clear();
						myCommand5.Parameters.Add(ret);
						removedAggCounterReader = myCommand5.ExecuteReader();

						RemoveAggCounters(removedAggCounterReader, ref lockAcquired);

						removedAggCounterReader.Close();
						removedAggCounterReader = null;
						if((int)ret.Value != 0)
						{
							XBLPerfLogEvent.LogError("Calling sp_GetDeletedAggCounters failed");
						}
					}
					if(lockAcquired)
					{
						htLock.ReleaseWriterLock();
						lockAcquired = false;
					}

					exit = XBLPerfLogMain.shutdown.WaitOne(1,false);
				}			
			}
			catch (Exception e)
			{
				XBLPerfLogEvent.LogError("Exception: " + e.Message + " at " + e.StackTrace);
			}
			finally
			{
				if(mySqlConn!=null)
				{
					mySqlConn.Close();
					mySqlConn = null;
				}
				if(lockAcquired)
				{
					htLock.ReleaseWriterLock();
					lockAcquired = false;
				}
			}
        }

		public static void StartDataCollection()
		{
			IDictionaryEnumerator   ide = machineHT.GetEnumerator();
			int                     htCount = machineHT.Count;
			XBLServerBox            currentBox = null;

			for(int i = 0; i < htCount; i++)
			{
				if(ide.MoveNext())
				{
					currentBox = (XBLServerBox)(ide.Value);
					currentBox.StartCollection();
				}
			}
		}
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\perflog\XBLPerfLogTool\CounterInfo.cs ===
using System;
using System.Collections;

namespace XBLPerfLogTool
{

    enum AggType 
    {
        Normal = 0,
        Sum = 1,
        Average = 2
    };

    /// <summary>
    /// Summary description for AggCounterInfo.
    /// </summary>
    public class AggCounterInfo : CounterInfoBase
    {
        public ArrayList MachineNames = null;
        public string AggCounterName = null;

        public AggCounterInfo() : base()
        {
            MachineNames = new ArrayList(8);
            AggregateType = (int)AggType.Sum;
            AggCounterName = null;
        }

        public AggCounterInfo(
            ArrayList machines,
            string objectName,
            string counterName,
            int counterType,
            int defaultScale,
            string instanceName,
            string displayInstanceName,
            string aggCounterName,
            int aggCounterType,
            int catID,
            int compID,
            int counterID) :
            base(objectName, counterName, counterType, defaultScale, instanceName, displayInstanceName, (int)AggType.Normal, catID, compID, counterID)
        {
            if (machines == null)
                MachineNames = new ArrayList(8);
            else
                MachineNames = machines;
            AggregateType = aggCounterType;
            AggCounterName = aggCounterName;
        }

        public override string ToString()
        {
            string counterName = "";
            // note MachineName includes prefix "\\" at this point
            counterName = "...\\" + ObjectName + "[" + InstanceName + "]" + "\\" + AggCounterName;
            return counterName;
        }

        public string ToStringMachines()
        {
            string counterName = "";
            string machineNames = "";
            bool first = true;
            foreach (object o in MachineNames)
            {
                if (first)
                    machineNames = (string)o;
                else
                    machineNames = machineNames + ", " + (string)o;
                first = false;
            }
            //counterName = machineNames + "\\" + ObjectName + "[" + InstanceName + "]" + "\\" + AggCounterName;
            counterName = machineNames;
            return counterName;
        }
    }

    /// <summary>
    /// Summary description for RealCounterInfo.
    /// </summary>
    public class RealCounterInfo : CounterInfoBase
    {
        public string MachineName = null;
   
        public RealCounterInfo() : base()
        {
            MachineName = null;
            AggregateType = (int)AggType.Normal;
        }

        public RealCounterInfo(
            string machineName,
            string objectName,
            string counterName,
            int counterType,
            int defaultScale,
            string instanceName,
            string displayInstanceName,
            int catID,
            int compID,
            int counterID) :
            base(objectName, counterName, counterType, defaultScale, instanceName, displayInstanceName, (int)AggType.Normal, catID, compID, counterID)
        {
            MachineName = machineName;
            AggregateType = (int)AggType.Normal;
        }

        public override string ToString()
        {
            string counterName = "";
            // note MachineName includes prefix "\\" at this point
            counterName = MachineName + "\\" + ObjectName + "[" + InstanceName + "]" + "\\" + CounterName;
            return counterName;
        }
    }


    /// <summary>
	/// Summary description for CounterInfoBase.
	/// </summary>
    abstract public class CounterInfoBase
    {
        public string ObjectName = null;
        public string CounterName = null;
        public int CounterType = 0;
        public int DefaultScale = 0;
        public string InstanceName = null;
        public string DisplayInstanceName = null;
        public int AggregateType = 0;
        public int CatID = 0;
        public int CompID = 0;

        public int CounterID = 0;  // from database

        public CounterInfoBase()
        {
            ObjectName = null;
            CounterName = null;
            CounterType = 0;
            DefaultScale = 0;
            InstanceName = null;
            DisplayInstanceName = null;
            AggregateType = 0;
            CatID = 0;
            CompID = 0;
            CounterID = 0;
        }

        public CounterInfoBase(
            string objectName,
            string counterName,
            int counterType,
            int defaultScale,
            string instanceName,
            string displayInstanceName,
            int aggregateType,
            int catID,
            int compID,
            int counterID)
        {
            ObjectName = objectName;
            CounterName = counterName;
            CounterType = counterType;
            DefaultScale = defaultScale;
            InstanceName = instanceName;
            DisplayInstanceName = displayInstanceName;
            AggregateType = aggregateType;
            CatID = catID;
            CompID = compID;
            CounterID = counterID;
        }

        abstract new public string ToString();
    }


}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\perflog\XBLPerfLogTool\Global.asax.cs ===
using System;
using System.Collections;
using System.ComponentModel;
using System.Web;
using System.Web.SessionState;

namespace XBLPerfLogTool 
{
	/// <summary>
	/// Summary description for Global.
	/// </summary>
	public class Global : System.Web.HttpApplication
	{
		/// <summary>
		/// Required designer variable.
		/// </summary>
		private System.ComponentModel.IContainer components = null;

		public Global()
		{
			InitializeComponent();
		}	
		
		protected void Application_Start(Object sender, EventArgs e)
		{

		}
 
		protected void Session_Start(Object sender, EventArgs e)
		{

		}

		protected void Application_BeginRequest(Object sender, EventArgs e)
		{

		}

		protected void Application_EndRequest(Object sender, EventArgs e)
		{

		}

		protected void Application_AuthenticateRequest(Object sender, EventArgs e)
		{

		}

		protected void Application_Error(Object sender, EventArgs e)
		{

		}

		protected void Session_End(Object sender, EventArgs e)
		{

		}

		protected void Application_End(Object sender, EventArgs e)
		{

		}
			
		#region Web Form Designer generated code
		/// <summary>
		/// Required method for Designer support - do not modify
		/// the contents of this method with the code editor.
		/// </summary>
		private void InitializeComponent()
		{    
			this.components = new System.ComponentModel.Container();
		}
		#endregion
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\perflog\XBLPerfLog\XBLPerfLogService\XBLPerfLogParams.cs ===
using System;
using System.Collections;
using System.Threading;
using System.Diagnostics;
using System.Globalization;

namespace XBLPerfLog
{
	public class node
	{
		public XBLPerfCounterValue v;
		public node next;
		public node(XBLPerfCounterValue pcv)
		{
			v = pcv;
			next = null;
		}
	}
	public class CounterValueQueue
	{
		public node head;
		public node tail;

		public void Enqueue(XBLPerfCounterValue pcv)
		{
			if(head == null)	
				head = tail = new node(pcv);
			else
			{
				tail.next = new node(pcv);
				tail = tail.next;
			}
		}

		public XBLPerfCounterValue Dequeue()
		{
			if(head == null)
			{
				return null;
			}
			else if(head == tail)
			{
				node temp = head;
				head = tail = null;
				return temp.v;
			}
			else
			{
				node n = head;
				head = head.next;
				n.next = null;
				return n.v;
			}
		}

		public void MoveTo(CounterValueQueue q)
		{
			Debug.Assert(q!=null);

			lock(q)
			{
				if(q.head != null)
				{
					q.tail.next = this.head;
					q.tail = this.tail;
				}
				else
				{
					q.head = this.head;
					q.tail = this.tail;
				}
				this.head = this.tail = null;
			}
		}

		public CounterValueQueue()
		{
			head = tail = null;
		}
	}

	public class XBLPerfCounterValue
	{
		public int			counterID;
		public string		counterDateTime;
		public float		counterValue;
		public int			recordIndex;
		public int			firstValueA;
		public int			firstValueB;
		public int			secondValueA;
		public int			secondValueB;

		public int			validCount;	// 1 for real counter, n for aggCounter
	}

	public enum AggType
	{
		SUM = 1,
		AVG = 2
	};
	
	public class XBLPerfCounter
	{
		public int			counterID;
		public string		objectName;
		public string		counterName;
		public string		instanceName;
		public string		machineName;

		public float		counterValue;
		// if no response got back for a server, this counter's value will be set to invalid value
		public bool			valueValid = true;

		public PerformanceCounter	pc;

		public XBLPerfCounter()
		{
		}
	}

	public class XBLAggPerfCounter
	{
		public	int			counterID;
		public	string		counterName;
		private AggType		aggType;
		public	ArrayList	realCounters;
		// the number of valid individual counter values used to calculate aggregated value
		public int			validCount;

		public XBLAggPerfCounter(AggType type)
		{
			aggType = type;
			realCounters = new ArrayList(100);
		}
		public float GetValue()
		{
			float result=0;
			int   count = realCounters.Count;

			validCount = 0;

			// SUM
			for (int i=0; i<count; ++i)
			{
				XBLPerfCounter counter = (XBLPerfCounter)realCounters[i];
				if (counter.valueValid)
				{
					result += counter.counterValue;
					validCount++;
				}
			}

			// AVG
			if (aggType==AggType.AVG)
			{
				if(validCount != 0)
					result /= validCount;
				else
					XBLPerfLogEvent.LogError("The aggregated counter" + XBLPerfLogEvent.AggCounterToString(this)
											+ " has no valid real counter values associated with it");
			}

			return result;
		}
	}

	public class XBLServerBox
	{
		public ArrayList			counterList = new ArrayList(1000);
		public string				machineName = null;
		public Thread				CounterCollectionThread;
		public CounterValueQueue	localQueue;

		public XBLServerBox()
		{
			CounterCollectionThread = new Thread(new ThreadStart(CollectionThreadStart));
			localQueue       = new CounterValueQueue();
		}

		private void CollectCounters(int recordIndex)
		{
			XBLPerfCounter	counter;
			string			counterDateTime = null;
			int				count = 0;
			float			cookedValue = 0F;
			int				fA,fB;
			double			dcV;

			count = counterList.Count;
			for (int i=0; i<count; ++i)
			{
				counter = (XBLPerfCounter)counterList[i];
				PerformanceCounter pc = counter.pc;

				counterDateTime = DateTime.UtcNow.ToString("u",DateTimeFormatInfo.InvariantInfo);

				// ???
				try
				{
					counter.counterValue = cookedValue = pc.NextValue();
				}
				catch
				{
					counter.valueValid = false;
					cookedValue = 0;	// ??? no response from server, enter 0 (right value?)
				}
				unsafe
				{
					dcV = (double)cookedValue;
					int *temp = (int *)&dcV;
					fA = *temp;
					temp++;
					fB = *temp;
				}

				XBLPerfCounterValue		cv = new XBLPerfCounterValue();
				cv.recordIndex = recordIndex;
				cv.counterID = counter.counterID;
				cv.counterValue = cookedValue;
				cv.counterDateTime = counterDateTime;
				cv.firstValueA = fA;
				cv.firstValueB = fB;
				cv.secondValueA = 0;
				cv.secondValueB = 0;
				cv.validCount = 1;
				localQueue.Enqueue(cv);

				// move local queue into global queue
				// to minimize lock contention, we will only move in batches
				if(((i % 100 == 0)&& (i != 0)) || (i == (count-1)))
				{
					localQueue.MoveTo(XBLPerfLogMain.globalQueue);
					XBLPerfLogMain.dataAvailable.Set();
				}
			}
		}

		private void CalculateAggCounters(int recordIndex)
		{
			IDictionaryEnumerator	ide;
			int						htCount = 0;
			double					dcV;
			int						fA,fB;

			ide = XBLPerfLogMain.aggCounterHT.GetEnumerator();
			htCount = XBLPerfLogMain.aggCounterHT.Count;

			XBLAggPerfCounter	currentApc = null;
			for(int i = 0; i < htCount; i++)
			{
				if(ide.MoveNext())
				{
					currentApc = (XBLAggPerfCounter)ide.Value;
							
					XBLPerfCounterValue		acv = new XBLPerfCounterValue();
					acv.recordIndex = recordIndex;
					acv.counterID = currentApc.counterID;
					acv.counterValue = currentApc.GetValue();
					acv.counterDateTime = DateTime.UtcNow.ToString("u",DateTimeFormatInfo.InvariantInfo);
					// needs to break up cookedValue 
					unsafe
					{
						dcV = (double)acv.counterValue;
						int *temp = (int *)&dcV;
						fA = *temp;
						temp++;
						fB = *temp;
					}

					acv.firstValueA = fA;
					acv.firstValueB = fB;
					acv.secondValueA = 0;
					acv.secondValueB = 0;

					acv.validCount = currentApc.validCount;

					localQueue.Enqueue(acv);
				}

				// to minimize lock contention, we will only move in batches
				if(((i % 100 == 0)&& (i != 0)) || (i == (htCount-1)))
				{
					localQueue.MoveTo(XBLPerfLogMain.globalQueue);
					XBLPerfLogMain.dataAvailable.Set();
				}
			}
		}

		public void StartCollection()
		{
			CounterCollectionThread.Start();
		}

		private void CollectionThreadStart()
		{
			int					recordIndex;
			bool				shutdown = false;
			DateTime			startTime;
			int					waitms;
			bool				lockRelease = false;

			while (shutdown != true)
			{
				lockRelease = false;
				try 
				{
					XBLPerfLogMain.htLock.AcquireReaderLock(-1);

					startTime = DateTime.UtcNow;
					recordIndex = XBLPerfLogMain.recordIndex;

					CollectCounters(recordIndex);

					// check if counter values needed to calculate aggCounter are already being
					// collected from all boxes
					int numMachine = Interlocked.Increment(ref XBLPerfLogMain.numMachineCollected);
					if(numMachine == XBLPerfLogMain.machineHT.Count)
					{
						CalculateAggCounters(recordIndex);
						XBLPerfLogMain.recordIndex++;
						XBLPerfLogMain.numMachineCollected = 0;
					}

					XBLPerfLogMain.htLock.ReleaseReaderLock();
					lockRelease = true;
					// wait until next polling period or shutdown event
					waitms = (XBLPerfLogMain.updateInterval * 1000) - 
						(int)((DateTime.UtcNow.Ticks - startTime.Ticks)*0.0001);
					if(waitms < 0)
						waitms = 0;
					shutdown = XBLPerfLogMain.shutdown.WaitOne(waitms, false);
				}
				catch (Exception e)
				{
					XBLPerfLogEvent.LogError("Exception: " + e.Message + " at " + e.StackTrace);
				}
				finally
				{
					if(lockRelease == false)
					{
						XBLPerfLogMain.htLock.ReleaseReaderLock();
					}
				}
			}
		}
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\perflog\XBLPerfLog\XBLPerfLogService\Service1.cs ===
using System;
using System.Collections;
using System.ComponentModel;
using System.Data;
using System.Diagnostics;
using System.ServiceProcess;
using XBLPerfLog;
using System.Threading;
using System.Data.SqlClient;
using System.Globalization;
using Microsoft.Win32;

namespace XBLPerfLog
{
	public class XBLPerfLogService : System.ServiceProcess.ServiceBase
	{
		/// <summary> 
		/// Required designer variable.
		/// </summary>
		private System.ComponentModel.Container components = null;

		public XBLPerfLogService()
		{
			InitializeComponent();
		}

		// The main entry point for the process
		static void Main()
		{
			System.ServiceProcess.ServiceBase[] ServicesToRun;

			ServicesToRun = new System.ServiceProcess.ServiceBase[] { new XBLPerfLogService() };

			System.ServiceProcess.ServiceBase.Run(ServicesToRun);
		}

		/// <summary> 
		/// Required method for Designer support - do not modify 
		/// the contents of this method with the code editor.
		/// </summary>
		private void InitializeComponent()
		{
			// 
			// XBLPerfLogService
			// 
			this.ServiceName = "XBLPerfLogService";

		}

		/// <summary>
		/// Clean up any resources being used.
		/// </summary>
		protected override void Dispose( bool disposing )
		{
			if( disposing )
			{
				if (components != null) 
				{
					components.Dispose();
				}
			}
			base.Dispose( disposing );
		}

		/// <summary>
		/// Set things in motion so your service can do its work.
		/// </summary>
		protected override void OnStart(string[] args)
		{
			// TODO: Add code here to start your service.
			bool			exit = false;
			SqlConnection   mySqlConn = null;
			SqlCommand      myCommand = null;
			SqlDataReader   sqlReader = null;
			SqlParameter    ret = null;

			// read sql server and updateInterval from registry
			try
			{
				RegistryKey		rk = Registry.Users.OpenSubKey(@".DEFAULT\Environment\XBLPerfLog");
				XBLPerfLogMain.sqlIP = (string)rk.GetValue("SQLIP");
				XBLPerfLogMain.updateInterval = (int)rk.GetValue("UpdateInterval");
			}
			catch (Exception e)
			{
				XBLPerfLogEvent.LogError("Cannot get registry key settings(SQLIP and UpdateInterval) " +
										"from local machine:HKEY_USERS\\DEFAULT\\Enviroment\\XBLPerfLog\\..." +
										"Exception is " + e.Message);
				return;
			}

			try
			{
				string myConnStr = "Data Source=" + XBLPerfLogMain.sqlIP + @";Database=PerfDB" + 
					@";Trusted_Connection=true";

				// open a connection to the perfCounterDB in SQL server
				mySqlConn = new SqlConnection(myConnStr);
				mySqlConn.Open();

				// add an entry in DisplayToID table
				myCommand = new SqlCommand();
				myCommand.Connection = mySqlConn;
				myCommand.CommandType = CommandType.StoredProcedure;
				myCommand.CommandText = "sp_StartNewLog";

				ret = new SqlParameter();
				ret.Direction = ParameterDirection.ReturnValue;
				myCommand.Parameters.Add(ret);
				myCommand.Parameters.Add("@GUID",SqlDbType.UniqueIdentifier).Value  = XBLPerfLogMain.guid;
				myCommand.Parameters.Add("@DisplayString",SqlDbType.VarChar).Value  = DateTime.Now.ToString("u",DateTimeFormatInfo.InvariantInfo);
        
				myCommand.ExecuteNonQuery();
            
				if((int)ret.Value != 0)
					throw new Exception("Calling sp_StartNewLog failed");

				// get real counters and create machine hashtable
				myCommand.CommandText = "sp_GetRealCounters";
				myCommand.Parameters.Clear();
				myCommand.Parameters.Add(ret);
				sqlReader = myCommand.ExecuteReader();

				// build the machineHT
				while(sqlReader.Read())
				{
					XBLPerfLogMain.AddCounterToTable(sqlReader);
				}
				sqlReader.Close();
				sqlReader = null;
				if((int)ret.Value != 0)
					throw new Exception("Calling sp_GetRealCounters failed");                

				// get aggregated counters
				myCommand.CommandText = "sp_GetAggregateCounters";
				myCommand.Parameters.Clear();
				myCommand.Parameters.Add(ret);
				sqlReader = myCommand.ExecuteReader();  

				// build the aggregated counter HT
				while(sqlReader.Read())
				{
					XBLPerfLogMain.AddAggCounterToTable(sqlReader);
				}
				sqlReader.Close();
				sqlReader = null;
				if((int)ret.Value != 0)
					throw new Exception("Calling sp_GetAggregateCounters failed");                
			}
			catch(Exception e)
			{
				XBLPerfLogEvent.LogError("Exception: " + e.Message + " at " + e.StackTrace);
				exit = true;
			}
			finally
			{
				if(mySqlConn != null)
				{
					mySqlConn.Close();
					mySqlConn = null;
				}
			}
			if(exit)
				return;

			// start WriteDataThread thread that writes collected data to the CounterData table
			XBLPerfLogMain.writeDataThread = new Thread(new ThreadStart(XBLPerfLogMain.WriteDataThread));
			XBLPerfLogMain.writeDataThread.Start();

			// start data collection threads on all boxes.
			XBLPerfLogMain.StartDataCollection();

			// create another thread to check any new counters being added and any instance changes
			Thread checkUpdateThread = new Thread(new ThreadStart(XBLPerfLogMain.CheckChangesThread));
			checkUpdateThread.Start();

			// start InstanceMapperThread thread that keeps the InstanceDisplayName table up to date
			XBLPerfLogMain.instanceMapperThread = new Thread(new ThreadStart(XBLPerfLog.InstanceMapper.InstanceMapperThread));
			XBLPerfLogMain.instanceMapperThread.Start();
		}
 
		/// <summary>
		/// Stop this service.
		/// </summary>
		protected override void OnStop()
		{
			// TODO: Add code here to perform any tear-down necessary to stop your service.
			XBLPerfLogMain.shutdown.Set();
		}
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\perflog\XBLPerfLogTool\PerfLogTool.aspx.cs ===
using System;
using System.Collections;
using System.ComponentModel;
using System.Data;
using System.Data.SqlClient;
using System.Drawing;
using System.Web;
using System.Web.SessionState;
using System.Web.UI;
using System.Web.UI.WebControls;
using System.Web.UI.HtmlControls;

namespace XBLPerfLogTool
{
   
	/// <summary>
	/// Summary description for PerfLogTool.
	/// </summary>
	public class PerfLogTool : PerfLogToolBase
	{
        #region Control declarations
        protected System.Web.UI.WebControls.Label SearchFilterLabel;
        protected System.Web.UI.WebControls.Label FilterResultsLabel;
        protected System.Web.UI.WebControls.ListBox ExistingCountersList;
        protected System.Web.UI.WebControls.Button AddNewBtn;
        protected System.Web.UI.WebControls.Button DuplicateBtn;
        protected System.Web.UI.WebControls.Button DeleteBtn;
        protected System.Web.UI.WebControls.Button EditBtn;
        protected System.Web.UI.WebControls.LinkButton FilterResultsLnk;
        protected System.Data.SqlClient.SqlCommand sqlcmdSelectCategoriesAll;
        protected System.Data.SqlClient.SqlCommand sqlcmdSelectComponents;
        protected System.Web.UI.WebControls.Panel FilterPanel;
        protected System.Data.SqlClient.SqlCommand sqlcmdSelectComponentsAll;
        protected System.Data.SqlClient.SqlCommand sqlcmdSelectMachinesAll;
        protected System.Data.SqlClient.SqlCommand sqlcmdSelectMachinesCat;
        protected System.Data.SqlClient.SqlCommand sqlcmdSelectMachinesComp;
        protected System.Data.SqlClient.SqlCommand sqlcmdSelectMachinesBoth;
        protected System.Web.UI.WebControls.Panel EditPanel;
        protected System.Web.UI.WebControls.Panel DetailsPanel;
        protected System.Web.UI.WebControls.Label Label1;
        protected System.Web.UI.WebControls.Button SaveChangesBtn;
        protected System.Web.UI.WebControls.Button CancelBtn;
        protected System.Web.UI.WebControls.DropDownList CategoryList1;
        protected System.Web.UI.WebControls.DropDownList ComponentList1;
        protected System.Web.UI.WebControls.DropDownList MachineList1;
        protected System.Web.UI.WebControls.DropDownList PerfObjectList1;
        protected System.Web.UI.WebControls.Label CategoryLabel1;
        protected System.Web.UI.WebControls.Label ComponentLabel1;
        protected System.Web.UI.WebControls.Label MachineLabel1;
        protected System.Web.UI.WebControls.Label PerfObjectLabel1;
        protected System.Web.UI.WebControls.Label CategoryLabel;
        protected System.Web.UI.WebControls.Label ComponentLabel;
        protected System.Web.UI.WebControls.Label PerfObjectLabel;
        protected System.Web.UI.WebControls.Label InstanceLabel;
        protected System.Web.UI.WebControls.Label CounterLabel;
        protected System.Web.UI.WebControls.ListBox PerfObjectList;
        protected System.Web.UI.WebControls.ListBox InstanceList;
        protected System.Web.UI.WebControls.ListBox CounterList;
        protected System.Web.UI.WebControls.Label CounterTypeLabel;
        protected System.Web.UI.WebControls.Label CounterNameLabel;
        protected System.Web.UI.WebControls.DropDownList CounterTypeList;
        protected System.Web.UI.WebControls.TextBox CounterNameText;
        protected System.Web.UI.WebControls.Button AddCounterBtn;
        protected System.Web.UI.WebControls.Button RemoveCounterBtn;
        protected System.Web.UI.WebControls.ListBox CountersToAddList;
        protected System.Web.UI.WebControls.Button SaveBtn;
        protected System.Web.UI.WebControls.Button SaveCloseBtn;
        protected System.Web.UI.WebControls.Label EditStatusLabel;
        protected System.Web.UI.WebControls.Label EditStatusLabel2;
        protected System.Web.UI.WebControls.Panel PanelMachines;
        protected System.Web.UI.WebControls.Label AllMachinesLabel;
        protected System.Web.UI.WebControls.Label SelectedMachinesLabel;
        protected System.Web.UI.WebControls.ListBox AllMachinesList;
        protected System.Web.UI.WebControls.Button AddMachineBtn;
        protected System.Web.UI.WebControls.Button RemoveMachineBtn;
        protected System.Web.UI.WebControls.ListBox SelectedMachinesList;
        protected System.Web.UI.WebControls.Label DetailsCounterID;
        protected System.Web.UI.WebControls.Label DetailsMachines;
        protected System.Web.UI.WebControls.Label DetailsCategory;
        protected System.Web.UI.WebControls.Label DetailsComponent;
        protected System.Web.UI.WebControls.Button RefreshCountersBtn;
        protected System.Data.SqlClient.SqlConnection sqlConnection1;

        #endregion

		#region Web Form Designer generated code
		override protected void OnInit(EventArgs e)
		{
			//
			// CODEGEN: This call is required by the ASP.NET Web Form Designer.
			//
			InitializeComponent();
			base.OnInit(e);
		}
		
		/// <summary>
		/// Required method for Designer support - do not modify
		/// the contents of this method with the code editor.
		/// </summary>
		private void InitializeComponent()
		{    
            this.sqlConnection1 = new System.Data.SqlClient.SqlConnection();
            this.sqlcmdSelectCategoriesAll = new System.Data.SqlClient.SqlCommand();
            this.sqlcmdSelectComponents = new System.Data.SqlClient.SqlCommand();
            this.sqlcmdSelectComponentsAll = new System.Data.SqlClient.SqlCommand();
            this.sqlcmdSelectMachinesAll = new System.Data.SqlClient.SqlCommand();
            this.sqlcmdSelectMachinesBoth = new System.Data.SqlClient.SqlCommand();
            this.sqlcmdSelectMachinesCat = new System.Data.SqlClient.SqlCommand();
            this.sqlcmdSelectMachinesComp = new System.Data.SqlClient.SqlCommand();
            this.CategoryList1.SelectedIndexChanged += new System.EventHandler(this.CategoryList1_SelectedIndexChanged);
            this.ComponentList1.SelectedIndexChanged += new System.EventHandler(this.ComponentList1_SelectedIndexChanged);
            this.MachineList1.SelectedIndexChanged += new System.EventHandler(this.MachineList1_SelectedIndexChanged);
            this.PerfObjectList1.SelectedIndexChanged += new System.EventHandler(this.PerfObjectList1_SelectedIndexChanged);
            this.FilterResultsLnk.Click += new System.EventHandler(this.FilterResultsLnk_Click);
            this.ExistingCountersList.SelectedIndexChanged += new System.EventHandler(this.ExistingCountersList_SelectedIndexChanged);
            this.AddNewBtn.Click += new System.EventHandler(this.AddNewBtn_Click);
            this.DuplicateBtn.Click += new System.EventHandler(this.DuplicateBtn_Click);
            this.EditBtn.Click += new System.EventHandler(this.EditBtn_Click);
            this.DeleteBtn.Click += new System.EventHandler(this.DeleteBtn_Click);
            this.CounterTypeList.SelectedIndexChanged += new System.EventHandler(this.CounterTypeList_SelectedIndexChanged);
            this.AddMachineBtn.Click += new System.EventHandler(this.AddMachineBtn_Click);
            this.RemoveMachineBtn.Click += new System.EventHandler(this.RemoveMachineBtn_Click);
            this.PerfObjectList.SelectedIndexChanged += new System.EventHandler(this.PerfObjectList_SelectedIndexChanged);
            this.InstanceList.SelectedIndexChanged += new System.EventHandler(this.InstanceList_SelectedIndexChanged);
            this.AddCounterBtn.Click += new System.EventHandler(this.AddCounterBtn_Click);
            this.RemoveCounterBtn.Click += new System.EventHandler(this.RemoveCounterBtn_Click);
            this.SaveBtn.Click += new System.EventHandler(this.SaveBtn_Click);
            this.SaveCloseBtn.Click += new System.EventHandler(this.SaveCloseBtn_Click);
            this.CancelBtn.Click += new System.EventHandler(this.CancelBtn_Click);
            // 
            // sqlConnection1
            // 
            this.sqlConnection1.ConnectionString = "user id=PerfLogTool;password=PerfLogTool;data source=localhost;persist security" +
                " info=False;initial catalog=PerfDB";
            // 
            // sqlcmdSelectCategoriesAll
            // 
            this.sqlcmdSelectCategoriesAll.CommandText = "SELECT CategoryID, CategoryName FROM Category ORDER BY CategoryName";
            this.sqlcmdSelectCategoriesAll.Connection = this.sqlConnection1;
            // 
            // sqlcmdSelectComponents
            // 
            this.sqlcmdSelectComponents.CommandText = @"SELECT DISTINCT Component.ComponentID AS ComponentID, Component.ComponentName AS ComponentName FROM Component INNER JOIN CompCatMach ON Component.ComponentID = CompCatMach.ComponentID WHERE (CompCatMach.CategoryID = @catid) ORDER BY Component.ComponentName";
            this.sqlcmdSelectComponents.Connection = this.sqlConnection1;
            this.sqlcmdSelectComponents.Parameters.Add(new System.Data.SqlClient.SqlParameter("@catid", System.Data.SqlDbType.Int, 4, "CategoryID"));
            // 
            // sqlcmdSelectComponentsAll
            // 
            this.sqlcmdSelectComponentsAll.CommandText = "SELECT ComponentID, ComponentName FROM Component";
            this.sqlcmdSelectComponentsAll.Connection = this.sqlConnection1;
            // 
            // sqlcmdSelectMachinesAll
            // 
            this.sqlcmdSelectMachinesAll.CommandText = "SELECT MachineID, MachineName FROM Machines ORDER BY MachineName";
            this.sqlcmdSelectMachinesAll.Connection = this.sqlConnection1;
            // 
            // sqlcmdSelectMachinesBoth
            // 
            this.sqlcmdSelectMachinesBoth.CommandText = @"SELECT DISTINCT Machines.MachineID AS MachineID, Machines.MachineName AS MachineName FROM CompCatMach INNER JOIN Machines ON CompCatMach.MachineID = Machines.MachineID WHERE (CompCatMach.CategoryID = @catid) AND (CompCatMach.ComponentID = @compid) ORDER BY Machines.MachineName";
            this.sqlcmdSelectMachinesBoth.Connection = this.sqlConnection1;
            this.sqlcmdSelectMachinesBoth.Parameters.Add(new System.Data.SqlClient.SqlParameter("@catid", System.Data.SqlDbType.Int, 4, "CategoryID"));
            this.sqlcmdSelectMachinesBoth.Parameters.Add(new System.Data.SqlClient.SqlParameter("@compid", System.Data.SqlDbType.Int, 4, "ComponentID"));
            // 
            // sqlcmdSelectMachinesCat
            // 
            this.sqlcmdSelectMachinesCat.CommandText = "SELECT DISTINCT Machines.MachineID AS MachineID, Machines.MachineName AS MachineN" +
                "ame FROM CompCatMach INNER JOIN Machines ON CompCatMach.MachineID = Machines.Mac" +
                "hineID WHERE (CompCatMach.CategoryID = @catid) ORDER BY Machines.MachineName";
            this.sqlcmdSelectMachinesCat.Connection = this.sqlConnection1;
            this.sqlcmdSelectMachinesCat.Parameters.Add(new System.Data.SqlClient.SqlParameter("@catid", System.Data.SqlDbType.Int, 4, "CategoryID"));
            // 
            // sqlcmdSelectMachinesComp
            // 
            this.sqlcmdSelectMachinesComp.CommandText = "SELECT DISTINCT Machines.MachineID AS MachineID, Machines.MachineName AS MachineN" +
                "ame FROM CompCatMach INNER JOIN Machines ON CompCatMach.MachineID = Machines.Mac" +
                "hineID WHERE (CompCatMach.ComponentID = @compid) ORDER BY Machines.MachineName";
            this.sqlcmdSelectMachinesComp.Connection = this.sqlConnection1;
            this.sqlcmdSelectMachinesComp.Parameters.Add(new System.Data.SqlClient.SqlParameter("@compid", System.Data.SqlDbType.Int, 4, "ComponentID"));
            this.RefreshCountersBtn.Click += new System.EventHandler(this.RefreshCountersBtn_Click);
            this.Load += new System.EventHandler(this.Page_Load);

        }
		#endregion
        

        private void Page_Load(object sender, System.EventArgs e)
        {
            // First time loaded
            if (!IsPostBack)
            {
                // Refresh all lists
                //Impersonate();
                sqlConnection1.Open();
                RefreshCategoryList();
                RefreshComponentList();
                RefreshMachineList();
                RefreshPerfObjectList();
                RefreshExistingCountersList();
                sqlConnection1.Close();
                //UnImpersonate();

            }
        }

        #region Database Refreshers
        private void RefreshCategoryList()
        {
            BindList(CategoryList1, sqlcmdSelectCategoriesAll, "CategoryName", "CategoryID");
            CategoryList1.Items.Insert(0, new ListItem("(All)", "-1"));
        }

        private void RefreshComponentList()
        {
            if (CategoryList1.SelectedIndex < 0 || CategoryList1.SelectedItem.Text == "(All)")
                BindList(ComponentList1, sqlcmdSelectComponentsAll, "ComponentName", "ComponentID");
            else
            {
                sqlcmdSelectComponents.Parameters["@catid"].Value = CategoryList1.SelectedValue;
                BindList(ComponentList1, sqlcmdSelectComponents, "ComponentName", "ComponentID");
            }
            ComponentList1.Items.Insert(0, new ListItem("(All)", "-1"));
        }

        private void RefreshMachineList()
        {
            // All (no) categories selected?
            if (CategoryList1.SelectedIndex < 0 || CategoryList1.SelectedItem.Text == "(All)")
            {
                // All categories, all components
                if (ComponentList1.SelectedIndex < 0 || ComponentList1.SelectedItem.Text == "(All)")
                {
                    BindList(MachineList1, sqlcmdSelectMachinesAll, "MachineName", "MachineID");
                }
                // All categories, 1 component
                else
                {
                    sqlcmdSelectMachinesComp.Parameters["@compid"].Value = ComponentList1.SelectedValue;
                    BindList(MachineList1, sqlcmdSelectMachinesComp, "MachineName", "MachineID");
                }                                                                                                         
            }
            else
            {
                // 1 category, all components
                if (ComponentList1.SelectedIndex < 0 || ComponentList1.SelectedItem.Text == "(All)")
                {
                    sqlcmdSelectMachinesCat.Parameters["@catid"].Value = CategoryList1.SelectedValue;
                    BindList(MachineList1, sqlcmdSelectMachinesCat, "MachineName", "MachineID");
                }
                // 1 category, 1 component
                else
                {
                    sqlcmdSelectMachinesBoth.Parameters["@compid"].Value = ComponentList1.SelectedValue;
                    sqlcmdSelectMachinesBoth.Parameters["@catid"].Value = CategoryList1.SelectedValue;
                    BindList(MachineList1, sqlcmdSelectMachinesBoth, "MachineName", "MachineID");
                }                                                                                                         
            }
            MachineList1.Items.Insert(0, new ListItem("(All normal)"));
            MachineList1.Items.Insert(1, new ListItem("(All aggregate)"));
        }

        private void RefreshPerfObjectList()
        {
            PerfObjectList1.Items.Clear();
            PerfObjectList1.Items.Add(new ListItem("(Not implemented yet)", "-1"));
        }

        private void RefreshExistingCountersList()
        {
            ExistingCountersList.Items.Clear();
            FilterResultsLabel.Text = "0 records returned";
            FilterResultsLnk.Text = "";

            // Show all results if at least one (1) filter box is selected (that is,
            // (all) is not selected in it)
            if (CategoryList1.SelectedIndex > 0 || ComponentList1.SelectedIndex > 0 || MachineList1.SelectedIndex > 0)
                GetExistingCounters(true);
            else
                GetExistingCounters(false);

        }

        #endregion


        protected bool IsAggregateSelected()
        {
            return MachineList1.SelectedIndex >= 0 && MachineList1.SelectedItem.Text == "(All aggregate)";
        }

        private void GetExistingCounters(bool bGetData)
        {
            // Get actual counter info
            if (bGetData)
            {
                ArrayList list;
                if (IsAggregateSelected())
                {
                    list = sp_GetAggCounterInfo(int.Parse(CategoryList1.SelectedValue), int.Parse(CategoryList1.SelectedValue));
                }
                else
                {
                    string machinename = null;
                    if (MachineList1.SelectedIndex >= 2)
                        machinename = MachineList1.SelectedItem.Text;
                    list = sp_GetRealCounterInfo(int.Parse(CategoryList1.SelectedValue), int.Parse(CategoryList1.SelectedValue), machinename);
                }
                
                foreach (object o in list)
                {
                    CounterInfoBase info = (CounterInfoBase)o;
                    string name = info.ToString();
                    ExistingCountersList.Items.Add(new ListItem(name, String.Format("{0}", info.CounterID)));
                }
                FilterResultsLabel.Text = String.Format("{0} records returned", ExistingCountersList.Items.Count);
                FilterResultsLnk.Text = "";
                Session["ExistingCounters"] = list;
            }
            // Only get row count for what would have been returned
            else
            {
                int rowcount = 0;
                if (IsAggregateSelected())
                {
                    rowcount = sp_GetAggCounterInfo_Count(int.Parse(CategoryList1.SelectedValue), int.Parse(CategoryList1.SelectedValue));
                }
                else
                {
                    string machinename = null;
                    if (MachineList1.SelectedIndex >= 2)
                        machinename = MachineList1.SelectedItem.Text;
                    rowcount = sp_GetRealCounterInfo_Count(int.Parse(CategoryList1.SelectedValue), int.Parse(CategoryList1.SelectedValue), machinename);
                }
                FilterResultsLabel.Text = String.Format("{0} records returned", rowcount);
                FilterResultsLnk.Text = "Click to view them all";
            }
        }


        private void SetEditCounterType(int type)
        {
            if (type == (int)AggType.Normal)
            {
                CounterNameLabel.Visible = false;
                CounterNameText.Visible = false;
                CounterTypeList.SelectedIndex = type;
            }
            else if (type == (int)AggType.Sum || type == (int)AggType.Average)
            {
                CounterNameLabel.Visible = true;
                CounterNameText.Visible = true;
                CounterTypeList.SelectedIndex = type;
            }
        }

        /// <summary>
        /// Show details of counter in the Details panel
        /// </summary>
        /// <param name="info">Counter to show details of. If null, clear the details panel.</param>
        private void ShowDetails(CounterInfoBase info)
        {
            if (info == null)
            {
                DetailsCounterID.Text = "";
                DetailsMachines.Text = "";
                DetailsCategory.Text = "";
                DetailsComponent.Text = "";
            }
            else
            {
                DetailsCounterID.Text = String.Format("{0}: {1}", info.CounterID, info.ToString());

                // If this is an aggregate counter, make DB request for more info
                if (info.GetType().Name == "AggCounterInfo")
                {
                    AggCounterInfo aggInfo = (AggCounterInfo)info;
                    sp_GetAggCounterDetails(info.CounterID, ref aggInfo);
                    DetailsMachines.Text = aggInfo.ToStringMachines();
                }
                else
                {
                    RealCounterInfo realInfo = (RealCounterInfo)info;
                    DetailsMachines.Text = realInfo.MachineName;
                }

                DetailsCategory.Text = String.Format("{0}", info.CatID);
                DetailsComponent.Text = String.Format("{0}", info.CompID);
            }
        }

        /// <summary>
        /// Toggle display of the EditPanel and corresponding state of FilterPanel and DetailsPanel
        /// </summary>
        /// <param name="showedit">True: Show edit panel, False: Hide edit panel</param>
        private void ShowEditPanel(bool showedit)
        {
            if (showedit)
            {
                ExistingCountersList.Height = (int)(ExistingCountersList.Height.Value * 0.35);
                FilterPanel.Visible = false;
                SearchFilterLabel.Visible = false;
                DetailsPanel.Visible = false;
                EditPanel.Visible = true;

                // Clear out all controls in Edit panel
                CategoryLabel.Text = "";
                ComponentLabel.Text = "";
                CounterNameText.Text = "";
                CounterNameText.ForeColor = Color.Black;
                SetEditCounterType(0);  // set to Normal counter
                AllMachinesList.Items.Clear();
                SelectedMachinesList.Items.Clear();
                EditStatusLabel.Text = "";
                PerfObjectList.Items.Clear();
                InstanceList.Items.Clear();
                CounterList.Items.Clear();
                CountersToAddList.Items.Clear();
                EditStatusLabel2.Text = "";

                // Clear the stored list of counters to add
                Session.Remove("CountersToAdd");
             
            }
            else
            {
                ExistingCountersList.Height = (int)(ExistingCountersList.Height.Value / 0.35);
                FilterPanel.Visible = true;
                SearchFilterLabel.Visible = true;
                DetailsPanel.Visible = true;
                EditPanel.Visible = false;
            }
        }

        /// <summary>
        /// Initialize the EditCounter panel for a brand new counter
        /// </summary>
        private void ShowEditPanel_New()
        {
            // Initialize Category and Component fields based on filter settings
            CategoryLabel.Text = CategoryList1.SelectedItem.Text;
            ComponentLabel.Text = ComponentList1.SelectedItem.Text;
            Session["CategoryID"] = CategoryList1.SelectedValue;
            Session["ComponentID"] = ComponentList1.SelectedValue;

            // If filtering on (All normal) or (All aggregate), then add all machines to selected list
            // bool bCopyAll = (MachineList1.SelectedIndex == 0) || (MachineList1.SelectedIndex == 1);

            // Adding all machines is kind of annoying and not the expected behavior for the user. Switching
            // to CopyAll only when (All aggregate) is selected.
            //bool bCopyAll = (MachineList1.SelectedIndex == 1);
            bool bCopyAll = false;  // i don't like this feature

            // Set counter type to an arbitrary aggregate type if (All aggregates) is selected
            if (MachineList1.SelectedIndex == 1)
            {
                SetEditCounterType((int)AggType.Average);
            }

            // Copy over list of machines from filter box. Skip first two, since they are 
            // (All normal) and (All aggregate).
            for (int i = 2; i < MachineList1.Items.Count; i++)
            {
                // If selected, add to Selected box
                if (MachineList1.Items[i].Selected || bCopyAll)
                {
                    SelectedMachinesList.Items.Add(MachineList1.Items[i]);
                }
                    // Otherwise add to All Machines list
                else
                {
                    AllMachinesList.Items.Add(MachineList1.Items[i]);
                }
            }

            // Fill listbox with categories common to all machines
            GetCategories();
        }

        /// <summary>
        /// Initialize the panel for editing an existing counter
        /// </summary>
        private void ShowEditPanel_Edit()
        {
            // TODO
        }

        /// <summary>
        /// Get common categories from selected machines and update UI
        /// </summary>
        private void GetCategories()
        {
            PerfObjectList.Items.Clear();
            EditStatusLabel.Text = "";
            CounterNameText.ForeColor = Color.Black;

            // Get list of common categories from all machines
            try 
            {
                GetCategories(ListToArrayList(SelectedMachinesList), ref PerfObjectList);
            }
            catch (System.Exception ex)
            {
                // Restore panel
                EditStatusLabel.Text = String.Format("Error getting categories: {0}", ex.ToString());
                return;
            }
            InstanceList.Items.Clear();
            CounterList.Items.Clear();
        }



        #region Edit Panel Buttons
        
        /// <summary>
        /// Store the currently created counter to a listbox and the Session variable, but
        /// don't write to the database.  This function has input parameters mainly for the 
        /// situation where multi-select is enabled for the CounterName and InstanceName listboxes.
        /// </summary>
        /// <param name="machines">List of selected machines. Used to specify multiple normal counters at once
        /// or the machines for a single aggregate counter.</param>
        /// <param name="counterName">The name of the counter.</param>
        /// <param name="instanceName">The name of the instance.</param>
        private void StoreCounter(ArrayList machines, string counterName, string instanceName)
        {
            Hashtable hash = (Hashtable)Session["CountersToAdd"];
            if (hash == null)
            {
                Session.Add("CountersToAdd", new Hashtable(100));
                hash = (Hashtable)Session["CountersToAdd"];
            }

            // Is this a normal counter or an aggregate?
            if (CounterTypeList.SelectedIndex == (int)AggType.Normal)
            {
                foreach (object o in machines)
                {
                    string machineName = (string)o;

                    // Create counter info object
                    RealCounterInfo info = new RealCounterInfo(
                        machineName, 
                        PerfObjectList.SelectedItem.Text,
                        counterName,
                        COUNTER_TYPE,
                        0,
                        instanceName,
                        instanceName,
                        int.Parse((string)Session["CategoryID"]),
                        int.Parse((string)Session["ComponentID"]),
                        -1);
                            
                    // And add it to CountersToAdd listbox and session hashtable, if it doesn't
                    // already exist.
                    string name = info.ToString();
                    if (!hash.ContainsKey(name))
                    {
                        hash.Add(name, info);
                        CountersToAddList.Items.Add(name);
                    }
                }
            }
                // Otherwise this is an aggregate counter
            else
            {
                // Force user to create a name for this aggregate counter
                if (CounterNameText.Text == "")
                {
                    CounterNameLabel.ForeColor = Color.Red;
                    EditStatusLabel.Text = "Please name this aggregate counter";
                    return;
                }
                // Create counter info object
                AggCounterInfo info = new AggCounterInfo(
                    machines, 
                    PerfObjectList.SelectedItem.Text,
                    counterName,
                    COUNTER_TYPE,
                    0,
                    instanceName,
                    instanceName,
                    CounterNameText.Text,
                    CounterTypeList.SelectedIndex,
                    int.Parse((string)Session["CategoryID"]),
                    int.Parse((string)Session["ComponentID"]),
                    -1);

                // And add it to CountersToAdd listbox and session hashtable, if it doesn't
                // already exist.
                string name = info.ToString();
                if (!hash.ContainsKey(name))
                {
                    hash.Add(name, info);
                    CountersToAddList.Items.Add(name);
                }
            }
        }

        /// <summary>
        /// Write stored but unsaved counters to the database
        /// </summary>
        private void SaveStoredCounters()
        {
            Hashtable hash = (Hashtable)Session["CountersToAdd"];
            if (hash == null)
            {
                CountersToAddList.Items.Clear();
                EditStatusLabel2.Text = "0 records saved (nothing in session variable)";
                return;
            }

            // save them here
            int totalwritten = 0;
            foreach (object val in hash.Values)
            {
                CounterInfoBase info = (CounterInfoBase)val;
                totalwritten += AddCounter(info);
            }
            EditStatusLabel2.Text = String.Format("{0} record(s) saved, {1} actually created.", hash.Count, totalwritten);
            CountersToAddList.Items.Clear();
            hash.Clear();
        }


        private void AddCounterBtn_Click(object sender, System.EventArgs e)
        {
#if ENABLEMULTISELECT
            // Iterate through selected counters
            foreach (ListItem counter in CounterList.Items)
            {
                if (!counter.Selected)
                    continue;
                // Iterate through selected machines
                foreach (ListItem machine in SelectedMachinesList.Items)
                {
                    // If items exist in InstanceList, loop through them
                    if (InstanceList.Items.Count > 0)
                    {
                        // Iterate through instances
                        foreach (ListItem instance in InstanceList.Items)
                        {
                            if (!instance.Selected)
                                continue;
                            StoreCounter(counter.Text, machine.Text, instance.Text);
                        }
                    }
                    else
                    {
                        // No instances available
                        StoreCounter(counter.Text, machine.Text, "");
                    }
                }
            }
#else
            // Iterate through selected machines
            string counter = CounterList.SelectedItem.Text;
            ArrayList machines = ListToArrayList(SelectedMachinesList);
            string instance = null;
            if (InstanceList.Items.Count > 0)
            {
                instance = InstanceList.SelectedItem.Text;
            }
            StoreCounter(machines, counter, instance);
#endif
        }

        private void RemoveCounterBtn_Click(object sender, System.EventArgs e)
        {
            Hashtable hash = (Hashtable)Session["CountersToAdd"];
            if (hash == null)
            {
                // hmm... this should never happen here unless the session got reset somehow in the middle
                Session.Add("CounterListHash", new Hashtable(500));
                hash = (Hashtable)Session["CountersToAdd"];
            }

            for (int i = CountersToAddList.Items.Count - 1; i >= 0; i--)
            {
                ListItem item = CountersToAddList.Items[i];
                if (item.Selected)
                {
                    hash.Remove(item.Text);
                    CountersToAddList.Items.Remove(item);
                }
            }
        }

        private void SaveBtn_Click(object sender, System.EventArgs e)
        {
            SaveStoredCounters();
        }

        private void SaveCloseBtn_Click(object sender, System.EventArgs e)
        {
            SaveStoredCounters();
            ShowEditPanel(false);
        }

        private void CancelBtn_Click(object sender, System.EventArgs e)
        {
            ShowEditPanel(false);
        }
        #endregion


        private void AddMachineBtn_Click(object sender, System.EventArgs e)
        {
            MoveItems(AllMachinesList, SelectedMachinesList);
            GetCategories();
        }

        private void RemoveMachineBtn_Click(object sender, System.EventArgs e)
        {
            MoveItems(SelectedMachinesList, AllMachinesList);   
            GetCategories();
        }

        private void PerfObjectList_SelectedIndexChanged(object sender, System.EventArgs e)
        {
            ArrayList machines = ListToArrayList(SelectedMachinesList);
            GetInstances(machines, PerfObjectList.SelectedItem.Text, ref InstanceList);
            GetCounters(machines, InstanceList, PerfObjectList.SelectedItem.Text, ref CounterList);
        }

        private void InstanceList_SelectedIndexChanged(object sender, System.EventArgs e)
        {
        
        }

        private void CounterTypeList_SelectedIndexChanged(object sender, System.EventArgs e)
        {
            SetEditCounterType(CounterTypeList.SelectedIndex);
        }

        private void RefreshCountersBtn_Click(object sender, System.EventArgs e)
        {
            /*foreach(ListItem item in SelectedMachinesList.Items)
            {
                // Make HealthXRL request here
                //serverComm.MakeRequest(labelService.Text, item.Text);
            }
            // Output status here
            //labelRefreshCounters.Text = serverComm.responseString;
	    */
        }

        
        private void CategoryList1_SelectedIndexChanged(object sender, System.EventArgs e)
        {
            sqlConnection1.Open();
            RefreshComponentList();
            RefreshMachineList();
            RefreshPerfObjectList();
            sqlConnection1.Close();
            RefreshExistingCountersList();
        }

        private void ComponentList1_SelectedIndexChanged(object sender, System.EventArgs e)
        {
            sqlConnection1.Open();
            RefreshMachineList();
            RefreshPerfObjectList();
            sqlConnection1.Close();
            RefreshExistingCountersList();
        }
    
        private void MachineList1_SelectedIndexChanged(object sender, System.EventArgs e)
        {
            RefreshPerfObjectList();
            RefreshExistingCountersList();
        }

        private void PerfObjectList1_SelectedIndexChanged(object sender, System.EventArgs e)
        {
        
        }

        private void ExistingCountersList_SelectedIndexChanged(object sender, System.EventArgs e)
        {
            // Update details
            ArrayList list = (ArrayList)Session["ExistingCounters"];
            if (list != null)
            {
                // Make sure selected index jives with the length of the ArrayList in Session var
                if (ExistingCountersList.SelectedIndex >= 0 && ExistingCountersList.SelectedIndex < list.Count)
                {
                    CounterInfoBase info = (CounterInfoBase)list[ExistingCountersList.SelectedIndex];
                    ShowDetails(info);
                }
            }
        }

        private void FilterResultsLnk_Click(object sender, System.EventArgs e)
        {
            // force show all counters returned
            GetExistingCounters(true);
        }

        private void AddNewBtn_Click(object sender, System.EventArgs e)
        {
            ShowEditPanel(true);
            ShowEditPanel_New();
        }

        private void DuplicateBtn_Click(object sender, System.EventArgs e)
        {
            ShowEditPanel(true);
            ShowEditPanel_Edit();
        }

        private void EditBtn_Click(object sender, System.EventArgs e)
        {
            ShowEditPanel(true);
            ShowEditPanel_Edit();
        }

        private void DeleteBtn_Click(object sender, System.EventArgs e)
        {
        
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\perflog\XBLPerfLogTool\CategoryDataset.cs ===
//------------------------------------------------------------------------------
// <autogenerated>
//     This code was generated by a tool.
//     Runtime Version: 1.1.4322.573
//
//     Changes to this file may cause incorrect behavior and will be lost if 
//     the code is regenerated.
// </autogenerated>
//------------------------------------------------------------------------------

namespace XBLPerfLogTool {
    using System;
    using System.Data;
    using System.Xml;
    using System.Runtime.Serialization;
    
    
    [Serializable()]
    [System.ComponentModel.DesignerCategoryAttribute("code")]
    [System.Diagnostics.DebuggerStepThrough()]
    [System.ComponentModel.ToolboxItem(true)]
    public class CategoryDataset : DataSet {
        
        private CategoryDataTable tableCategory;
        
        public CategoryDataset() {
            this.InitClass();
            System.ComponentModel.CollectionChangeEventHandler schemaChangedHandler = new System.ComponentModel.CollectionChangeEventHandler(this.SchemaChanged);
            this.Tables.CollectionChanged += schemaChangedHandler;
            this.Relations.CollectionChanged += schemaChangedHandler;
        }
        
        protected CategoryDataset(SerializationInfo info, StreamingContext context) {
            string strSchema = ((string)(info.GetValue("XmlSchema", typeof(string))));
            if ((strSchema != null)) {
                DataSet ds = new DataSet();
                ds.ReadXmlSchema(new XmlTextReader(new System.IO.StringReader(strSchema)));
                if ((ds.Tables["Category"] != null)) {
                    this.Tables.Add(new CategoryDataTable(ds.Tables["Category"]));
                }
                this.DataSetName = ds.DataSetName;
                this.Prefix = ds.Prefix;
                this.Namespace = ds.Namespace;
                this.Locale = ds.Locale;
                this.CaseSensitive = ds.CaseSensitive;
                this.EnforceConstraints = ds.EnforceConstraints;
                this.Merge(ds, false, System.Data.MissingSchemaAction.Add);
                this.InitVars();
            }
            else {
                this.InitClass();
            }
            this.GetSerializationData(info, context);
            System.ComponentModel.CollectionChangeEventHandler schemaChangedHandler = new System.ComponentModel.CollectionChangeEventHandler(this.SchemaChanged);
            this.Tables.CollectionChanged += schemaChangedHandler;
            this.Relations.CollectionChanged += schemaChangedHandler;
        }
        
        [System.ComponentModel.Browsable(false)]
        [System.ComponentModel.DesignerSerializationVisibilityAttribute(System.ComponentModel.DesignerSerializationVisibility.Content)]
        public CategoryDataTable Category {
            get {
                return this.tableCategory;
            }
        }
        
        public override DataSet Clone() {
            CategoryDataset cln = ((CategoryDataset)(base.Clone()));
            cln.InitVars();
            return cln;
        }
        
        protected override bool ShouldSerializeTables() {
            return false;
        }
        
        protected override bool ShouldSerializeRelations() {
            return false;
        }
        
        protected override void ReadXmlSerializable(XmlReader reader) {
            this.Reset();
            DataSet ds = new DataSet();
            ds.ReadXml(reader);
            if ((ds.Tables["Category"] != null)) {
                this.Tables.Add(new CategoryDataTable(ds.Tables["Category"]));
            }
            this.DataSetName = ds.DataSetName;
            this.Prefix = ds.Prefix;
            this.Namespace = ds.Namespace;
            this.Locale = ds.Locale;
            this.CaseSensitive = ds.CaseSensitive;
            this.EnforceConstraints = ds.EnforceConstraints;
            this.Merge(ds, false, System.Data.MissingSchemaAction.Add);
            this.InitVars();
        }
        
        protected override System.Xml.Schema.XmlSchema GetSchemaSerializable() {
            System.IO.MemoryStream stream = new System.IO.MemoryStream();
            this.WriteXmlSchema(new XmlTextWriter(stream, null));
            stream.Position = 0;
            return System.Xml.Schema.XmlSchema.Read(new XmlTextReader(stream), null);
        }
        
        internal void InitVars() {
            this.tableCategory = ((CategoryDataTable)(this.Tables["Category"]));
            if ((this.tableCategory != null)) {
                this.tableCategory.InitVars();
            }
        }
        
        private void InitClass() {
            this.DataSetName = "CategoryDataset";
            this.Prefix = "";
            this.Namespace = "http://www.tempuri.org/CategoryDataset.xsd";
            this.Locale = new System.Globalization.CultureInfo("en-US");
            this.CaseSensitive = false;
            this.EnforceConstraints = true;
            this.tableCategory = new CategoryDataTable();
            this.Tables.Add(this.tableCategory);
        }
        
        private bool ShouldSerializeCategory() {
            return false;
        }
        
        private void SchemaChanged(object sender, System.ComponentModel.CollectionChangeEventArgs e) {
            if ((e.Action == System.ComponentModel.CollectionChangeAction.Remove)) {
                this.InitVars();
            }
        }
        
        public delegate void CategoryRowChangeEventHandler(object sender, CategoryRowChangeEvent e);
        
        [System.Diagnostics.DebuggerStepThrough()]
        public class CategoryDataTable : DataTable, System.Collections.IEnumerable {
            
            private DataColumn columnCategoryID;
            
            private DataColumn columnCategoryName;
            
            internal CategoryDataTable() : 
                    base("Category") {
                this.InitClass();
            }
            
            internal CategoryDataTable(DataTable table) : 
                    base(table.TableName) {
                if ((table.CaseSensitive != table.DataSet.CaseSensitive)) {
                    this.CaseSensitive = table.CaseSensitive;
                }
                if ((table.Locale.ToString() != table.DataSet.Locale.ToString())) {
                    this.Locale = table.Locale;
                }
                if ((table.Namespace != table.DataSet.Namespace)) {
                    this.Namespace = table.Namespace;
                }
                this.Prefix = table.Prefix;
                this.MinimumCapacity = table.MinimumCapacity;
                this.DisplayExpression = table.DisplayExpression;
            }
            
            [System.ComponentModel.Browsable(false)]
            public int Count {
                get {
                    return this.Rows.Count;
                }
            }
            
            internal DataColumn CategoryIDColumn {
                get {
                    return this.columnCategoryID;
                }
            }
            
            internal DataColumn CategoryNameColumn {
                get {
                    return this.columnCategoryName;
                }
            }
            
            public CategoryRow this[int index] {
                get {
                    return ((CategoryRow)(this.Rows[index]));
                }
            }
            
            public event CategoryRowChangeEventHandler CategoryRowChanged;
            
            public event CategoryRowChangeEventHandler CategoryRowChanging;
            
            public event CategoryRowChangeEventHandler CategoryRowDeleted;
            
            public event CategoryRowChangeEventHandler CategoryRowDeleting;
            
            public void AddCategoryRow(CategoryRow row) {
                this.Rows.Add(row);
            }
            
            public CategoryRow AddCategoryRow(string CategoryName) {
                CategoryRow rowCategoryRow = ((CategoryRow)(this.NewRow()));
                rowCategoryRow.ItemArray = new object[] {
                        null,
                        CategoryName};
                this.Rows.Add(rowCategoryRow);
                return rowCategoryRow;
            }
            
            public CategoryRow FindByCategoryID(int CategoryID) {
                return ((CategoryRow)(this.Rows.Find(new object[] {
                            CategoryID})));
            }
            
            public System.Collections.IEnumerator GetEnumerator() {
                return this.Rows.GetEnumerator();
            }
            
            public override DataTable Clone() {
                CategoryDataTable cln = ((CategoryDataTable)(base.Clone()));
                cln.InitVars();
                return cln;
            }
            
            protected override DataTable CreateInstance() {
                return new CategoryDataTable();
            }
            
            internal void InitVars() {
                this.columnCategoryID = this.Columns["CategoryID"];
                this.columnCategoryName = this.Columns["CategoryName"];
            }
            
            private void InitClass() {
                this.columnCategoryID = new DataColumn("CategoryID", typeof(int), null, System.Data.MappingType.Element);
                this.Columns.Add(this.columnCategoryID);
                this.columnCategoryName = new DataColumn("CategoryName", typeof(string), null, System.Data.MappingType.Element);
                this.Columns.Add(this.columnCategoryName);
                this.Constraints.Add(new UniqueConstraint("Constraint1", new DataColumn[] {
                                this.columnCategoryID}, true));
                this.columnCategoryID.AutoIncrement = true;
                this.columnCategoryID.AllowDBNull = false;
                this.columnCategoryID.ReadOnly = true;
                this.columnCategoryID.Unique = true;
                this.columnCategoryName.AllowDBNull = false;
            }
            
            public CategoryRow NewCategoryRow() {
                return ((CategoryRow)(this.NewRow()));
            }
            
            protected override DataRow NewRowFromBuilder(DataRowBuilder builder) {
                return new CategoryRow(builder);
            }
            
            protected override System.Type GetRowType() {
                return typeof(CategoryRow);
            }
            
            protected override void OnRowChanged(DataRowChangeEventArgs e) {
                base.OnRowChanged(e);
                if ((this.CategoryRowChanged != null)) {
                    this.CategoryRowChanged(this, new CategoryRowChangeEvent(((CategoryRow)(e.Row)), e.Action));
                }
            }
            
            protected override void OnRowChanging(DataRowChangeEventArgs e) {
                base.OnRowChanging(e);
                if ((this.CategoryRowChanging != null)) {
                    this.CategoryRowChanging(this, new CategoryRowChangeEvent(((CategoryRow)(e.Row)), e.Action));
                }
            }
            
            protected override void OnRowDeleted(DataRowChangeEventArgs e) {
                base.OnRowDeleted(e);
                if ((this.CategoryRowDeleted != null)) {
                    this.CategoryRowDeleted(this, new CategoryRowChangeEvent(((CategoryRow)(e.Row)), e.Action));
                }
            }
            
            protected override void OnRowDeleting(DataRowChangeEventArgs e) {
                base.OnRowDeleting(e);
                if ((this.CategoryRowDeleting != null)) {
                    this.CategoryRowDeleting(this, new CategoryRowChangeEvent(((CategoryRow)(e.Row)), e.Action));
                }
            }
            
            public void RemoveCategoryRow(CategoryRow row) {
                this.Rows.Remove(row);
            }
        }
        
        [System.Diagnostics.DebuggerStepThrough()]
        public class CategoryRow : DataRow {
            
            private CategoryDataTable tableCategory;
            
            internal CategoryRow(DataRowBuilder rb) : 
                    base(rb) {
                this.tableCategory = ((CategoryDataTable)(this.Table));
            }
            
            public int CategoryID {
                get {
                    return ((int)(this[this.tableCategory.CategoryIDColumn]));
                }
                set {
                    this[this.tableCategory.CategoryIDColumn] = value;
                }
            }
            
            public string CategoryName {
                get {
                    return ((string)(this[this.tableCategory.CategoryNameColumn]));
                }
                set {
                    this[this.tableCategory.CategoryNameColumn] = value;
                }
            }
        }
        
        [System.Diagnostics.DebuggerStepThrough()]
        public class CategoryRowChangeEvent : EventArgs {
            
            private CategoryRow eventRow;
            
            private DataRowAction eventAction;
            
            public CategoryRowChangeEvent(CategoryRow row, DataRowAction action) {
                this.eventRow = row;
                this.eventAction = action;
            }
            
            public CategoryRow Row {
                get {
                    return this.eventRow;
                }
            }
            
            public DataRowAction Action {
                get {
                    return this.eventAction;
                }
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\perflog\XBLPerfLogTool\PerfLogToolBase.cs ===
using System;
using System.Collections;
using System.Diagnostics;
using System.Web.UI;
using System.Web.UI.WebControls;
using System.Web.UI.HtmlControls;
using System.Data;
using System.Data.SqlClient;

namespace XBLPerfLogTool
{
	/// <summary>
	/// Summary description for PerfLogToolBase.
	/// </summary>
	public class PerfLogToolBase : System.Web.UI.Page
	{
        public const int COUNTER_TYPE = 0x12000;

        protected System.Security.Principal.WindowsImpersonationContext impersonationContext;
        protected ServerComm serverComm = new ServerComm();
        
        /// <summary>
        /// Sorts PerformanceCounterCategory objects
        /// </summary>
        protected class myCounterSorter : IComparer
        {
            int IComparer.Compare(Object x, Object y) 
            {
                PerformanceCounterCategory a = (PerformanceCounterCategory) x;
                PerformanceCounterCategory b = (PerformanceCounterCategory) y;
                return String.Compare(a.CategoryName, b.CategoryName, true);
            }
        }
 
        /// <summary>
        /// Stored in hashtable while user is adding counters
        /// </summary>
        protected class CounterInfo
        {
            public CounterInfo(int counterType, int count)
            {
                CounterType = counterType;
                Count = count;
            }
            public void Increment() { Count++; }
        
            public int CounterType = 0;
            public int Count = 0;
        }
        
        public PerfLogToolBase()
		{
			//
			// TODO: Add constructor logic here
			//
		}

        #region Handy Utilities
        /// <summary>
        /// Binds a list control to a SQL command
        /// </summary>
        /// <param name="control"></param>
        /// <param name="sqlCommand"></param>
        /// <param name="dataTextField"></param>
        /// <param name="dataValueField"></param>
        static public void BindList(ListControl control, SqlCommand sqlCommand, string dataTextField, string dataValueField)
        {
            SqlDataReader dReader = sqlCommand.ExecuteReader();
            control.DataSource = dReader;
            control.DataTextField = dataTextField;
            control.DataValueField = dataValueField;
            control.DataBind();
            dReader.Close();
        }

        /// <summary>
        /// Utility function to fill a list box control with strings from an array
        /// </summary>
        /// <param name="control"></param>
        /// <param name="name"></param>
        public void FillList(ListBox control, params string[] name)
        {
            foreach (string s in name)
            {
                control.Items.Add(s);
            }
            control.Items[0].Selected = true;
        }

        /// <summary>
        /// Utility function to select all items in a list box control
        /// </summary>
        /// <param name="control"></param>
        public void SelectAll(ListBox control)
        {
            foreach (ListItem item in control.Items)
            {
                item.Selected = true;
            }
        }

        /// <summary>
        /// Move all selected Items from one ListBox to another
        /// </summary>
        /// <param name="from">The 'from' ListControl</param>
        /// <param name="to">The 'to' ListControl</param>
        protected void MoveItems(ListControl from, ListControl to)
        {
            for (int i = from.Items.Count - 1; i >= 0; i--)
            {
                if (from.Items[i].Selected)
                {
                    to.Items.Add(from.Items[i]);
                    from.Items.RemoveAt(i);
                }
            }
        }

                /// <summary>
        /// Utility function to convert a ListBox control to an ArrayList of items
        /// </summary>
        /// <param name="list"></param>
        /// <returns></returns>
        public ArrayList ListToArrayList(ListBox list)
        {
            ArrayList array = new ArrayList(list.Items.Count);
            foreach (ListItem item in list.Items)
            {
                array.Add(item.Text);
            }
            return array;
        }
        
        /// <summary>
        /// Forces impersonation of current user's credentials
        /// </summary>
        public void Impersonate()
        {
            impersonationContext = ((System.Security.Principal.WindowsIdentity)User.Identity).Impersonate();
        }

        /// <summary>
        /// Stops impersonating
        /// </summary>
        public void UnImpersonate()
        {
            impersonationContext.Undo();
        }
        #endregion

        /// <summary>
        /// Get union of performance counter categories on all machines, throwing out any categories
        /// not common to all machines.
        /// </summary>
        /// <param name="machines">List of machines to retrieve categories from</param>
        public void GetCategories(ArrayList machines, ref ListBox CategoryList)
        {
            PerformanceCounterCategory[] categories;

            // Using a sorted list here is potentially slow, as we need to do lookups on each category name.
            // I think I originally used a hashtable, which is more appropriate, but I need the end result to
            // be sorted, so I switched.  A better solution is to sort the hashtable once at the end. If
            // performance sucks, this is one thing to look at.
            SortedList finalCategories = new SortedList(100);

            // Be the current user, not some lowly internet account
            //Impersonate();

            // Get categories from each machine and form intersecting set with each other
            foreach (object m in machines)
            {
                categories = PerformanceCounterCategory.GetCategories(m.ToString());
                foreach (PerformanceCounterCategory c in categories)
                {
                    // If this counter already exists, increment its count by one, otherwise add it to the list
                    if (finalCategories.ContainsKey(c.CategoryName))
                        finalCategories[c.CategoryName] = (int)finalCategories[c.CategoryName] + 1;
                    else
                        finalCategories.Add(c.CategoryName, 1);
                }
            }

            //UnImpersonate();

            // Weed out non-common counter categories
            //DebugList.Items.Add("===== DISCARDED COUNTER CATEGORIES =====");
            foreach (System.Collections.DictionaryEntry c in finalCategories)
            {
                // If this counter existed on every machine we spoke with, keep it, otherwise throw it out
                if ((int)c.Value == machines.Count)
                {
                    CategoryList.Items.Add((string)c.Key);
                }
                else
                {
                    //DebugList.Items.Add((string)c.Key);  // debug
                }
            }
        }

        /// <summary>
        /// Gets all common performance object instances on the machines and fills a list box
        /// </summary>
        /// <param name="machines"></param>
        /// <param name="perfobjectName"></param>
        /// <param name="InstanceList"></param>
        public void GetInstances(ArrayList machines, string perfobjectName, ref ListBox InstanceList)
        {
            SortedList instances;

            // Get instances common to all selected machines
            instances = GetCommonInstances(machines, perfobjectName);

            // Add to list box
            InstanceList.Items.Clear();
            foreach (string s in instances.Keys)
            {
                InstanceList.Items.Add(s);
            }
            if (InstanceList.Items.Count > 0)
                InstanceList.Items[0].Selected = true;
        }


        /// <summary>
        /// Gets common counters across all machines and fills list box with results
        /// </summary>
        /// <param name="machines"></param>
        /// <param name="InstanceList"></param>
        /// <param name="perfobjectName"></param>
        /// <param name="CounterList"></param>
        /// <returns></returns>
        public SortedList GetCounters(ArrayList machines, ListBox InstanceList, string perfobjectName, ref ListBox CounterList)
        {
            SortedList counters;

            // Get counters common to all selected machines
            if (InstanceList.Items.Count > 0)
                counters = GetCommonCounters(machines, InstanceList.SelectedItem.Text, perfobjectName);
            else
                counters = GetCommonCounters(machines, null, perfobjectName);

            // Add to list box
            CounterList.Items.Clear();
            CounterList.ClearSelection();
            for (int i = 0; i < counters.Count; i++)
            {
                //string type = String.Format("{0}", ((CounterInfo)counters.GetByIndex(i)).CounterType);
                //ListItem item = new ListItem((string)counters.GetKey(i), type);
                //CounterList.Items.Add(item);
                CounterList.Items.Add((string)counters.GetKey(i));
            }

            return counters;
        }

        /// <summary>
        /// Gets instances common to all machines and returns as a sorted list
        /// </summary>
        /// <param name="machines"></param>
        /// <param name="categoryName"></param>
        /// <returns></returns>
        public SortedList GetCommonInstances(ArrayList machines, string categoryName)
        {
            SortedList finalInstances = new SortedList(20);
            PerformanceCounterCategory category = new PerformanceCounterCategory(categoryName);
            
            // Get list of instances from each machine
            foreach (object m in machines)
            {
                category.MachineName = m.ToString();
                string[] instances = category.GetInstanceNames();
                foreach (string s in instances)
                {
                    if (finalInstances.ContainsKey(s))
                        finalInstances[s] = (int)finalInstances[s] + 1;
                    else
                        finalInstances.Add(s, 1);
                }
            }

            // Weed out non-common ones. 
            for (int i = 0; i < finalInstances.Count; i++)
            {
                if ((int)finalInstances.GetByIndex(i) != machines.Count)
                {
                    //DebugList.Items.Add((string)finalInstances.GetKey(i));  // debug
                    finalInstances.RemoveAt(i);
                    i--;
                }
            }
            return finalInstances;
        }

        /// <summary>
        /// Gets counters common to all machines and returns as a sorted list
        /// </summary>
        /// <param name="machines"></param>
        /// <param name="instanceName"></param>
        /// <param name="categoryName"></param>
        /// <returns></returns>
        public SortedList GetCommonCounters(ArrayList machines, string instanceName, string categoryName)
        {
            PerformanceCounterCategory category = new PerformanceCounterCategory(categoryName);
            SortedList finalCounters = new SortedList(50);
            PerformanceCounter[] counters;

            try
            {
                // Get list of counters from each machine
                foreach (object m in machines)
                {
                    // Get performance counters
                    category.MachineName = m.ToString();
                    if (instanceName == null)
                        counters = category.GetCounters();
                    else
                        counters = category.GetCounters(instanceName);

                    foreach (PerformanceCounter c in counters)
                    {
                        if (finalCounters.ContainsKey(c.CounterName))
                        {
                            ((CounterInfo)finalCounters[c.CounterName]).Increment();
                        }
                        else 
                        {
                            finalCounters.Add(c.CounterName, new CounterInfo((int)c.CounterType, 1));
                        }
                    }
                }

                // Weed out non-common ones
                for (int i = 0; i < finalCounters.Count; i++) 
                {
                    if ((int)finalCounters.GetByIndex(i) != machines.Count)
                    {
                        //DebugList.Items.Add((string)finalCounters.GetKey(i));  // debug
                        finalCounters.RemoveAt(i);
                        i--;
                    }
                }
            
            }
            catch (System.Exception ex)
            {
                System.Console.WriteLine("Error: {0}", ex.ToString());
            }
            return finalCounters;
        }

        /// <summary>
        /// Main entry point for adding a counter to the database via the stored procedure.
        /// </summary>
        /// <param name="info"></param>
        /// <returns></returns>
        public int AddCounter(CounterInfoBase info)
        {
            // Is this a normal counter?
            if (info.GetType().Name == "RealCounterInfo")
            {
                RealCounterInfo info2 = (RealCounterInfo)info;
                sp_AddCounterInfo(
                    info2.MachineName,
                    info2.ObjectName,
                    info2.CounterName,
                    info2.CounterType,
                    info2.DefaultScale,
                    info2.InstanceName,
                    info2.CatID,
                    info2.CompID);
                return 1;
            }
                // Aggregate counter
            else if (info.GetType().Name == "AggCounterInfo")
            {
                AggCounterInfo info2 = (AggCounterInfo)info;
                int count = 0;
                foreach (object o in info2.MachineNames)
                {
                    string machine = (string)o;

                    // Add normal counter (required by collection tool)
                    sp_AddCounterInfo(
                        machine,
                        info2.ObjectName,
                        info2.CounterName,
                        info2.CounterType,
                        info2.DefaultScale,
                        info2.InstanceName,
                        info2.CatID,
                        info2.CompID);

                    // Add aggregate
                    sp_AddCounterInfo(
                        machine,
                        info2.ObjectName,
                        info2.CounterName,
                        info2.CounterType,
                        info2.DefaultScale,
                        info2.InstanceName,
                        info2.CatID,
                        info2.CompID,
                        info2.DisplayInstanceName,
                        info2.AggCounterName,
                        info2.AggregateType);
                    count++;
                }
                return count + 1;  // all normal counters + 1 agg counter
            }
            else 
            {
                throw new Exception("Unknown type of CounterInfoBase");
            }
        }

        // legacy for AddCounters.aspx
        public void AddCounter(object[] machines, string category, string instance, string counter, int counterType, int aggType)
        {

            // Always add normal (individual) counters, regardless of type
            foreach (object server in machines)
            {
                sp_AddCounterInfo(server.ToString(), category, counter, counterType, 0, instance, -1, -1);
            }

            // If not normal type
            if (aggType != 0)
            {
                AddCounterAggregate(machines, category, instance, counter, counterType, aggType);
            }
        }

        public void AddCounterAggregate(object[] machines, string category, string instance, string counter, int counterType, int type)
        {
            //Hashtable hash = (Hashtable)Session["CounterListHash"];
            string aggCounterName = ""; //CounterTypeList.SelectedItem.Text + "." + counter;
            string counterName;
            counterName = "\\\\...\\" + category + "[" + instance + "]" + "\\" + aggCounterName;
            //if (hash.ContainsKey(counterName))
            //    return;
            //hash.Add(counterName, null);
            //SelectedCountersList.Items.Add(counterName);

            foreach (object server in machines)
            {
                // make DB call here
                sp_AddCounterInfo((string)server, category, counter, counterType, 0, instance, -1, -1, null, aggCounterName, type);
            }
        }

        // 
        // The ugly code for interacting with the stored procedures is below.
        //
        #region Stored Procedures

        public int sp_AddCounterInfo(
            string MachineName,
            string ObjectName,
            string CounterName,
            int CounterType,
            int DefaultScale,
            string InstanceName,
            int CatID,
            int CompID)
        {
            return sp_AddCounterInfo(MachineName, ObjectName, CounterName, CounterType, DefaultScale, InstanceName, CatID, CompID, null, null, (int)AggType.Normal);
        }
        
        public int sp_AddCounterInfo(
            string MachineName,
            string ObjectName,
            string CounterName,
            int CounterType,
            int DefaultScale,
            string InstanceName,
            int CatID,
            int CompID,
            string DisplayInstanceName,
            string AggCounterName,
            int AggregateType)
        {       
            SqlCommand sqlCommand = new SqlCommand("sp_AddCounterInfo", serverComm.sqlConnection);
            sqlCommand.CommandType = CommandType.StoredProcedure;

            // return value parameter
            SqlParameter retval = new SqlParameter();
            retval.Direction = ParameterDirection.ReturnValue;
            sqlCommand.Parameters.Add(retval);

            sqlCommand.Parameters.Add("@MachineName", SqlDbType.VarChar, 1024).Value = "\\\\" + MachineName;
            sqlCommand.Parameters.Add("@ObjectName", SqlDbType.VarChar, 1024).Value = ObjectName;
            sqlCommand.Parameters.Add("@CounterName", SqlDbType.VarChar, 1024).Value = CounterName;
            sqlCommand.Parameters.Add("@CounterType", SqlDbType.Int).Value = CounterType;
            sqlCommand.Parameters.Add("@DefaultScale", SqlDbType.Int).Value = DefaultScale;
            sqlCommand.Parameters.Add("@InstanceName", SqlDbType.VarChar, 1024).Value = InstanceName;
            if (DisplayInstanceName != null)
                sqlCommand.Parameters.Add("@DisplayInstanceName", SqlDbType.VarChar, 1024).Value = DisplayInstanceName;
            if (AggCounterName != null)
                sqlCommand.Parameters.Add("@AggCounterName", SqlDbType.VarChar, 1024).Value = AggCounterName;
            sqlCommand.Parameters.Add("@AggregateType", SqlDbType.Int).Value = AggregateType;
            if (CatID >= 0)
                sqlCommand.Parameters.Add("@CatID", SqlDbType.Int).Value = CatID;
            if (CompID >= 0)
                sqlCommand.Parameters.Add("@CompID", SqlDbType.Int).Value = CompID;
            serverComm.sqlConnection.Open();
            try 
            {
                sqlCommand.ExecuteNonQuery();
                serverComm.sqlConnection.Close();
                return (int)retval.Value;
            }
            catch (System.Data.SqlClient.SqlException e)
            {
		    e = e;
            }
            return 0;
        }

        public ArrayList sp_GetRealCounterInfo(
            int CategoryID,
            int ComponentID,
            string MachineName)
        {
            SqlCommand sqlCommand = new SqlCommand("sp_GetRealCounterInfo", serverComm.sqlConnection);
            sqlCommand.CommandType = CommandType.StoredProcedure;

            // return value parameter
            SqlParameter retval = new SqlParameter();
            retval.Direction = ParameterDirection.ReturnValue;
            sqlCommand.Parameters.Add(retval);

            if (CategoryID >= 0) 
                sqlCommand.Parameters.Add("@CategoryID", SqlDbType.Int).Value = CategoryID;
            if (ComponentID >= 0)
                sqlCommand.Parameters.Add("@ComponentID", SqlDbType.Int).Value = ComponentID;
            if (MachineName != null)
                sqlCommand.Parameters.Add("@MachineName", SqlDbType.VarChar, 1024).Value = "\\\\" + MachineName;
            serverComm.sqlConnection.Open();
            SqlDataReader dReader = sqlCommand.ExecuteReader();
            //serverComm.sqlConnection.Close();
            //return (int)retval.Value;

            // Columns in the returned data reader
            const int COUNTERID = 0;
            const int MACHINENAME = 1;
            const int OBJECTNAME = 2;
            const int COUNTERNAME = 3;
            const int INSTANCENAME = 4;

            ArrayList list = new ArrayList(16);
            while (dReader.Read())
            {
                RealCounterInfo info = new RealCounterInfo(
                    dReader.GetString(MACHINENAME),
                    dReader.GetString(OBJECTNAME),
                    dReader.GetString(COUNTERNAME),
                    COUNTER_TYPE,
                    0,
                    dReader.GetString(INSTANCENAME),
                    dReader.GetString(INSTANCENAME),
                    CategoryID,
                    ComponentID,
                    dReader.GetInt32(COUNTERID));
                list.Add(info);
            }
            dReader.Close();
            serverComm.sqlConnection.Close();
            return list;
        }

        public int sp_GetRealCounterInfo_Count(
            int CategoryID,
            int ComponentID,
            string MachineName)
        {
            SqlCommand sqlCommand = new SqlCommand("sp_GetRealCounterInfo_Count", serverComm.sqlConnection);
            sqlCommand.CommandType = CommandType.StoredProcedure;

            // return value parameter
            SqlParameter retval = new SqlParameter();
            retval.Direction = ParameterDirection.ReturnValue;
            sqlCommand.Parameters.Add(retval);

            if (CategoryID >= 0) 
                sqlCommand.Parameters.Add("@CategoryID", SqlDbType.Int).Value = CategoryID;
            if (ComponentID >= 0)
                sqlCommand.Parameters.Add("@ComponentID", SqlDbType.Int).Value = ComponentID;
            if (MachineName != null)
                sqlCommand.Parameters.Add("@MachineName", SqlDbType.VarChar, 1024).Value = "\\\\" + MachineName;
            sqlCommand.Parameters.Add("@RowCount", SqlDbType.Int).Direction = ParameterDirection.Output;
            serverComm.sqlConnection.Open();
            sqlCommand.ExecuteNonQuery();
            serverComm.sqlConnection.Close();
            return (int)sqlCommand.Parameters["@RowCount"].Value;
        }

        public ArrayList sp_GetAggCounterInfo(
            int CategoryID,
            int ComponentID)
        {
            SqlCommand sqlCommand = new SqlCommand("sp_GetAggCounterInfo", serverComm.sqlConnection);
            sqlCommand.CommandType = CommandType.StoredProcedure;

            // return value parameter
            SqlParameter retval = new SqlParameter();
            retval.Direction = ParameterDirection.ReturnValue;
            sqlCommand.Parameters.Add(retval);

            if (CategoryID >= 0) 
                sqlCommand.Parameters.Add("@CategoryID", SqlDbType.Int).Value = CategoryID;
            if (ComponentID >= 0)
                sqlCommand.Parameters.Add("@ComponentID", SqlDbType.Int).Value = ComponentID;
            serverComm.sqlConnection.Open();
            SqlDataReader dReader = sqlCommand.ExecuteReader();
            //serverComm.sqlConnection.Close();
            //return (int)retval.Value;
            //return dReader;

            // Columns in the returned data reader
            const int COUNTERID = 0;
            const int OBJECTNAME = 1;
            const int COUNTERNAME = 2;
            const int TYPE = 3;

            ArrayList list = new ArrayList(16);
            while (dReader.Read())
            {
                AggCounterInfo info = new AggCounterInfo(
                    null,  // machine names
                    dReader.GetString(OBJECTNAME),
                    null, // counter name
                    COUNTER_TYPE,
                    0,
                    null, //dReader.GetString(INSTANCENAME),
                    null, //dReader.GetString(INSTANCENAME),
                    dReader.GetString(COUNTERNAME), // aggCounterName
                    dReader.GetByte(TYPE),  // not sure about this column..
                    CategoryID,
                    ComponentID,
                    dReader.GetInt32(COUNTERID));
                list.Add(info);
            }
            dReader.Close();
            serverComm.sqlConnection.Close();
            return list;
        }            

        public int sp_GetAggCounterInfo_Count(
            int CategoryID,
            int ComponentID)
        {
            SqlCommand sqlCommand = new SqlCommand("sp_GetAggCounterInfo_Count", serverComm.sqlConnection);
            sqlCommand.CommandType = CommandType.StoredProcedure;

            // return value parameter
            SqlParameter retval = new SqlParameter();
            retval.Direction = ParameterDirection.ReturnValue;
            sqlCommand.Parameters.Add(retval);

            if (CategoryID >= 0) 
                sqlCommand.Parameters.Add("@CategoryID", SqlDbType.Int).Value = CategoryID;
            if (ComponentID >= 0)
                sqlCommand.Parameters.Add("@ComponentID", SqlDbType.Int).Value = ComponentID;
            sqlCommand.Parameters.Add("@RowCount", SqlDbType.Int).Direction = ParameterDirection.Output;
            serverComm.sqlConnection.Open();
            sqlCommand.ExecuteNonQuery();
            serverComm.sqlConnection.Close();
            return (int)sqlCommand.Parameters["@RowCount"].Value;
        }            

        public int sp_GetAggCounterDetails(
            int CounterID,
            ref AggCounterInfo aggCounter)
        {
            SqlCommand sqlCommand = new SqlCommand("sp_GetAggCounterDetails", serverComm.sqlConnection);
            sqlCommand.CommandType = CommandType.StoredProcedure;

            // return value parameter
            SqlParameter retval = new SqlParameter();
            retval.Direction = ParameterDirection.ReturnValue;
            sqlCommand.Parameters.Add(retval);

            sqlCommand.Parameters.Add("@CounterID", SqlDbType.Int).Value = CounterID;
            serverComm.sqlConnection.Open();
            SqlDataReader dReader = sqlCommand.ExecuteReader();

            // Columns in the returned data reader
            //const int REALCOUNTERID = 0;
            const int REALOBJECTNAME = 1;
            const int REALCOUNTERNAME = 2;
            const int REALINSTANCENAME = 3;
            const int REALMACHINENAME = 4;

            ArrayList list = new ArrayList(16);
            while (dReader.Read())
            {
                // Safety checks
                if (dReader.GetString(REALOBJECTNAME) != aggCounter.ObjectName)
                    throw new Exception("This aggregate counter detail doesn't match its parent");
                //if (dReader.GetString(REALCOUNTERNAME) != aggCounter.CounterName)
                //    throw new Exception("This aggregate counter detail doesn't match its parent");
                //if (dReader.GetString(REALINSTANCENAME) != aggCounter.InstanceName)
                //    throw new Exception("This aggregate counter detail doesn't match its parent");
                aggCounter.CounterName = dReader.GetString(REALCOUNTERNAME);
                aggCounter.CounterName = dReader.GetString(REALINSTANCENAME);
                // Append machine name to array
                aggCounter.MachineNames.Add(dReader.GetString(REALMACHINENAME));
            }
            dReader.Close();
            serverComm.sqlConnection.Close();
            return (int)retval.Value;
        }            

        #endregion


    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\perflog\XBLPerfLogTool\ServerComm.cs ===
using System;
using System.ComponentModel;
using System.Collections;
using System.Diagnostics;
using System.Net;
using System.IO;
using System.Data.SqlClient;

namespace XBLPerfLogTool
{
	/// <summary>
	/// This was used as a temporary test of whether calling HealthXRL functions would cause an IIS component 
	/// to be loaded.  It does work.  However, this code has lots of ugly hard-coded addresses in it and
	/// needs to be generalized for a real solution.  At the very least, consolidate the 3 lists into
	/// 1 using a struct.  :) The hell was I thinking?
	/// </summary>
	public class ServerComm : System.ComponentModel.Component
	{
        public System.Data.SqlClient.SqlConnection sqlConnection;

        public Hashtable HealthXrlMap = new Hashtable(21);
        public Hashtable ServiceIPMap = new Hashtable(21);
        public Hashtable ServicePortMap = new Hashtable(21);

        public string GetServiceIP(string friendlyName)
        {
            return (string)ServiceIPMap[friendlyName.ToLower()];
        }

        /// <summary>
		/// Required designer variable.
		/// </summary>
		private System.ComponentModel.Container components = null;

		public ServerComm(System.ComponentModel.IContainer container)
		{
			///
			/// Required for Windows.Forms Class Composition Designer support
			///
			container.Add(this);
			InitializeComponent();

			//
			// TODO: Add any constructor code after InitializeComponent call
			//
            MyInitialize();
		}

		public ServerComm()
		{
			///
			/// Required for Windows.Forms Class Composition Designer support
			///
			InitializeComponent();

			//
			// TODO: Add any constructor code after InitializeComponent call
			//
            MyInitialize();
		}


        /// <summary>
        ///  Initialize object
        /// </summary>
        protected void MyInitialize()
        {
            HealthXrlMap.Add("mtch", "/xmatch/health.srf");
            HealthXrlMap.Add("xpnf", "/xpnfront/health.srf");
            HealthXrlMap.Add("xbos", "/xbos/health.ashx");
            HealthXrlMap.Add("uacs", "/xuacs/health.ashx");
            HealthXrlMap.Add("stat", "/xstats/health.ashx");
            HealthXrlMap.Add("strg", "/msgserver/health.ashx");
            HealthXrlMap.Add("fdbk", "/fbserver/health.ashx");
            HealthXrlMap.Add("xsig", "/xsig/health.ashx");
            HealthXrlMap.Add("xarb", "/xarb/health.ashx");
            HealthXrlMap.Add("cron", "/cron/health.ashx");
            HealthXrlMap.Add("xqry", "/xqry/health.ashx");
            HealthXrlMap.Add("stfd", "/stfd/health.ashx");
            HealthXrlMap.Add("wcstat", "/stats/health.ashx");
            HealthXrlMap.Add("wcgeneral", "/generalinfo/health.ashx");
            HealthXrlMap.Add("wcuser", "/UserAccount/health.ash");
            HealthXrlMap.Add("wcsig", "/signature/health.ashx");
            HealthXrlMap.Add("wcstor", "/storage/health.ashx");
            HealthXrlMap.Add("wcpres", "/presence/health.ashx");
            HealthXrlMap.Add("wcquery", "/query/health.ashx");
            HealthXrlMap.Add("wcmsg", "/messaging/health.ashx");
            HealthXrlMap.Add("wcalert", "/alerts/health.ashx");

            ServiceIPMap.Add("mtch", "10.10.7.206");
            ServiceIPMap.Add("xpnf", "10.10.7.201");
            ServiceIPMap.Add("xbos", "10.10.7.209");
            ServiceIPMap.Add("uacs", "10.10.7.205");
            ServiceIPMap.Add("stat", "10.10.7.207");
            ServiceIPMap.Add("strg", "10.10.7.202");
            ServiceIPMap.Add("fdbk", "10.10.7.208");
            ServiceIPMap.Add("xsig", "10.10.7.212");
            ServiceIPMap.Add("xarb", "10.10.7.216");
            ServiceIPMap.Add("cron", "10.10.7.210");
            ServiceIPMap.Add("xqry", "10.10.7.213");
            ServiceIPMap.Add("stfd", "10.10.7.215");
            ServiceIPMap.Add("wcstat", "10.10.7.203");
            ServiceIPMap.Add("wcgeneral", "10.10.7.203");
            ServiceIPMap.Add("wcuser", "10.10.7.203");
            ServiceIPMap.Add("wcsig", "10.10.7.203");
            ServiceIPMap.Add("wcstor", "10.10.7.203");
            ServiceIPMap.Add("wcpres", "10.10.7.203");
            ServiceIPMap.Add("wcquery", "10.10.7.203");
            ServiceIPMap.Add("wcmsg", "10.10.7.203");
            ServiceIPMap.Add("wcalert", "10.10.7.203");

            ServicePortMap.Add("mtch", ":8080");
            ServicePortMap.Add("xpnf", ":8080");
            ServicePortMap.Add("xbos", ":83");
            ServicePortMap.Add("uacs", ":8080");
            ServicePortMap.Add("stat", ":8080");
            ServicePortMap.Add("strg", "");
            ServicePortMap.Add("fdbk", "");
            ServicePortMap.Add("xsig", ":8080");
            ServicePortMap.Add("xarb", ":20500");
            ServicePortMap.Add("cron", ":8080");
            ServicePortMap.Add("xqry", ":8080");
            ServicePortMap.Add("stfd", ":8080");
            ServicePortMap.Add("wcstat", "");
            ServicePortMap.Add("wcgeneral", "");
            ServicePortMap.Add("wcuser", "");
            ServicePortMap.Add("wcsig", "");
            ServicePortMap.Add("wcstor", "");
            ServicePortMap.Add("wcpres", "");
            ServicePortMap.Add("wcquery", "");
            ServicePortMap.Add("wcmsg", "");
            ServicePortMap.Add("wcalert", "");

            // Initialize dataadapter stuff

        }

		/// <summary> 
		/// Clean up any resources being used.
		/// </summary>
		protected override void Dispose( bool disposing )
		{
			if( disposing )
			{
				if(components != null)
				{
					components.Dispose();
				}
			}
			base.Dispose( disposing );
		}

        public string responseString;

        /// <summary>
        /// Force server component to load
        /// </summary>
        /// <param name="friendlyName">Friendly name of server component, such as "stat" or "wcpres"</param>
        /// <returns>true if successful, false if error</returns>
        public bool MakeRequest(string friendlyName)
        {
            return MakeRequest(friendlyName, (string)ServiceIPMap[friendlyName]);
        }

        /// <summary>
        /// 
        /// </summary>
        /// <param name="friendlyName"></param>
        /// <param name="ip"></param>
        /// <returns></returns>
        public bool MakeRequest(string friendlyName, string ip)
        {
            string name = friendlyName.ToLower();
            if (!HealthXrlMap.ContainsKey(name))
            {
                // No key!
                return false;
            }
            string xrl = (string)HealthXrlMap[name];
            string port = (string)ServicePortMap[name];
            return AttemptHealthCheck(name, "http://" + ip + port + xrl, 5000);
        }

        /// <summary>
        /// Yanked from $corext\private\tools\Framework\CTitleMgr.cs
        /// </summary>
        /// <param name="sFriendlyName"></param>
        /// <param name="sHealthUrl"></param>
        /// <param name="iTimeout"></param>
        /// <returns>true if successful, false if error</returns>
        private bool AttemptHealthCheck(
            string sFriendlyName,
            string sHealthUrl,
            int iTimeout)
        {
            string [] sUrlParts = sHealthUrl.Split(';');
            string sMethod;
            string sUrl;

            if(sUrlParts.Length != 2)
            {
                //throw new ArgumentException("Health URL must be in the form <method>;<url>");
                // Assume to be GET since they all are for devnet2, at least
                sMethod = "GET";
                sUrl = sHealthUrl;
            }
            else 
            {
                sMethod = sUrlParts[0];
                sUrl = sUrlParts[1];
            }

            if(sMethod.ToUpper() != "GET" && sMethod.ToUpper() != "POST")
                throw new ArgumentException("Invalid HTTP method: " + sMethod);

            HttpWebRequest httpWebRequest = 
                (HttpWebRequest)WebRequest.Create(sUrl);

            // Turn off connection keep-alives.
            httpWebRequest.KeepAlive = false;

            // set the requested timeout, in milliseconds
            httpWebRequest.Timeout = iTimeout;

            // set method, and Content-Length
            httpWebRequest.Method = sMethod;
            if(sMethod == "POST")
                httpWebRequest.ContentLength = 0;
            
            HttpWebResponse httpWebResponse = null;
            try
            {
                httpWebResponse = (HttpWebResponse)httpWebRequest.GetResponse();
                string sResponse;
                try
                {
                    Stream stream = httpWebResponse.GetResponseStream();
                    StreamReader streamReader = new StreamReader(stream);
                    sResponse = streamReader.ReadToEnd();
                }
                catch (ProtocolViolationException)
                {
                    // no content to be had
                    sResponse = String.Empty;
                }

                if (httpWebResponse.StatusCode == HttpStatusCode.OK)
                {
                    responseString = "OK";
                    return true;
                }
                else
                {
                    responseString = 
                        "Error: " 
                        + sFriendlyName 
                        + " (" 
                        + sMethod + " " + sUrl 
                        + ") reports " 
                        + httpWebResponse.StatusCode.ToString();
                    return false;
                }
            }
            catch (WebException webException)
            {
                if (webException.Status == WebExceptionStatus.Timeout)
                {
                    responseString = "Error: " + sFriendlyName + " (" + sMethod + " " + sUrl + ") timed out";
                    return false;
                }
                responseString = 
                    "Error: " 
                    + sFriendlyName 
                    + " (" 
                    + sMethod + " " + sUrl 
                    + ") threw exception.";
                return false;
            }
            finally
            {
                if (httpWebResponse != null)
                {
                    httpWebResponse.Close();
                }
            }
        }


		#region Component Designer generated code
		/// <summary>
		/// Required method for Designer support - do not modify
		/// the contents of this method with the code editor.
		/// </summary>
		private void InitializeComponent()
		{
            this.sqlConnection = new System.Data.SqlClient.SqlConnection();
            // 
            // sqlConnection
            // 
            this.sqlConnection.ConnectionString = "user id=PerfLogTool;password=PerfLogTool;data source=xonlinetest;persist security info=False;initial catalog=PerfDB";

        }
		#endregion
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\RegDBViewer\AdminForm.cs ===
using System;
using System.Drawing;
using System.Collections;
using System.ComponentModel;
using System.Windows.Forms;

namespace RegDBViewer
{
	/// <summary>
	/// Summary description for Admin.
	/// </summary>
	public class AdminForm : System.Windows.Forms.Form
	{
		
		private int BldDescriptionChanged = 0;
		private bool BldRenameChanged = false;
		private bool BldDeletChecked = false;
		
		private RegDBQueryManager queryManager;
		private System.Windows.Forms.TabControl tabControl1;
		private System.Windows.Forms.TabPage DelBuild;
		private System.Windows.Forms.TabPage BuildDis;
		private System.Windows.Forms.Label label3;
		private System.Windows.Forms.Label label4;
		private System.Windows.Forms.Label label5;
		private System.Windows.Forms.ComboBox BuildcomboBox;
		private System.Windows.Forms.CheckedListBox BuildcheckedList;
		private System.Windows.Forms.Button button6;
		private System.Windows.Forms.Button button7;
		private System.Windows.Forms.TextBox BuildDes;
		private System.Windows.Forms.Button button1;
		private System.Windows.Forms.Panel panel1;
		private System.Windows.Forms.Panel panel2;
		private System.Windows.Forms.Label label7;
		private System.Windows.Forms.Label label9;
		private System.Windows.Forms.Label label10;
		private System.Windows.Forms.TabPage BldRename;
		private System.Windows.Forms.GroupBox groupBox1;
		private System.Windows.Forms.Label label8;
		private System.Windows.Forms.TextBox BLDDescription;
		private System.Windows.Forms.ComboBox RenameBldlist;
		private System.Windows.Forms.TextBox NewbldNo;
		private System.Windows.Forms.TextBox NewItnNo;
		/// <summary>
		/// Required designer variable.
		/// </summary>
		private System.ComponentModel.Container components = null;

		public AdminForm(RegDBQueryManager qManager)
		{
			//
			// Required for Windows Form Designer support
			//
			InitializeComponent();
			queryManager=qManager;

			//
			// TODO: Add any constructor code after InitializeComponent call
						
			ReloadBldLists();
			
			BuildcomboBox.SelectedIndex=0;

					

			
		}

		public void ReloadBldLists()
		{
			BuildList bl =  queryManager.GetBuildList();
			BuildcomboBox.Items.Clear();
			BuildcheckedList.Items.Clear();
			RenameBldlist.Items.Clear();
			foreach (Build b in bl)
				if (b.BuildName.Trim() != "")
				{
					BuildcomboBox.Items.Add(b);
					BuildcheckedList.Items.Add(b);
					RenameBldlist.Items.Add(b);
				}
		}

		/// <summary>
		/// Clean up any resources being used.
		/// </summary>
		protected override void Dispose( bool disposing )
		{
			if( disposing )
			{
				if(components != null)
				{
					components.Dispose();
				}
			}
			base.Dispose( disposing );
		}

		#region Windows Form Designer generated code
		/// <summary>
		/// Required method for Designer support - do not modify
		/// the contents of this method with the code editor.
		/// </summary>
		private void InitializeComponent()
		{
			this.tabControl1 = new System.Windows.Forms.TabControl();
			this.BuildDis = new System.Windows.Forms.TabPage();
			this.BuildDes = new System.Windows.Forms.TextBox();
			this.label3 = new System.Windows.Forms.Label();
			this.BuildcomboBox = new System.Windows.Forms.ComboBox();
			this.label4 = new System.Windows.Forms.Label();
			this.BldRename = new System.Windows.Forms.TabPage();
			this.groupBox1 = new System.Windows.Forms.GroupBox();
			this.BLDDescription = new System.Windows.Forms.TextBox();
			this.label8 = new System.Windows.Forms.Label();
			this.label9 = new System.Windows.Forms.Label();
			this.NewbldNo = new System.Windows.Forms.TextBox();
			this.NewItnNo = new System.Windows.Forms.TextBox();
			this.label10 = new System.Windows.Forms.Label();
			this.RenameBldlist = new System.Windows.Forms.ComboBox();
			this.label7 = new System.Windows.Forms.Label();
			this.DelBuild = new System.Windows.Forms.TabPage();
			this.label5 = new System.Windows.Forms.Label();
			this.BuildcheckedList = new System.Windows.Forms.CheckedListBox();
			this.button6 = new System.Windows.Forms.Button();
			this.button7 = new System.Windows.Forms.Button();
			this.button1 = new System.Windows.Forms.Button();
			this.panel1 = new System.Windows.Forms.Panel();
			this.panel2 = new System.Windows.Forms.Panel();
			this.tabControl1.SuspendLayout();
			this.BuildDis.SuspendLayout();
			this.BldRename.SuspendLayout();
			this.groupBox1.SuspendLayout();
			this.DelBuild.SuspendLayout();
			this.panel1.SuspendLayout();
			this.panel2.SuspendLayout();
			this.SuspendLayout();
			// 
			// tabControl1
			// 
			this.tabControl1.Controls.Add(this.BuildDis);
			this.tabControl1.Controls.Add(this.BldRename);
			this.tabControl1.Controls.Add(this.DelBuild);
			this.tabControl1.Dock = System.Windows.Forms.DockStyle.Fill;
			this.tabControl1.Location = new System.Drawing.Point(0, 0);
			this.tabControl1.Name = "tabControl1";
			this.tabControl1.SelectedIndex = 0;
			this.tabControl1.Size = new System.Drawing.Size(360, 254);
			this.tabControl1.TabIndex = 0;
			this.tabControl1.SelectedIndexChanged += new System.EventHandler(this.tabControl1_SelectedIndexChanged);
			// 
			// BuildDis
			// 
			this.BuildDis.Controls.Add(this.BuildDes);
			this.BuildDis.Controls.Add(this.label3);
			this.BuildDis.Controls.Add(this.BuildcomboBox);
			this.BuildDis.Controls.Add(this.label4);
			this.BuildDis.Location = new System.Drawing.Point(4, 22);
			this.BuildDis.Name = "BuildDis";
			this.BuildDis.Size = new System.Drawing.Size(352, 228);
			this.BuildDis.TabIndex = 1;
			this.BuildDis.Text = "Build Description";
			// 
			// BuildDes
			// 
			this.BuildDes.Location = new System.Drawing.Point(40, 104);
			this.BuildDes.MaxLength = 50;
			this.BuildDes.Multiline = true;
			this.BuildDes.Name = "BuildDes";
			this.BuildDes.Size = new System.Drawing.Size(296, 72);
			this.BuildDes.TabIndex = 7;
			this.BuildDes.Text = "";
			this.BuildDes.TextChanged += new System.EventHandler(this.BuildDes_TextChanged);
			// 
			// label3
			// 
			this.label3.Location = new System.Drawing.Point(16, 80);
			this.label3.Name = "label3";
			this.label3.Size = new System.Drawing.Size(80, 16);
			this.label3.TabIndex = 6;
			this.label3.Text = "Description:";
			// 
			// BuildcomboBox
			// 
			this.BuildcomboBox.DropDownStyle = System.Windows.Forms.ComboBoxStyle.DropDownList;
			this.BuildcomboBox.Items.AddRange(new object[] {
															   "00.00.0000",
															   "01.00.0000",
															   "02.00.0000",
															   "02.00.0458"});
			this.BuildcomboBox.Location = new System.Drawing.Point(40, 40);
			this.BuildcomboBox.Name = "BuildcomboBox";
			this.BuildcomboBox.Size = new System.Drawing.Size(120, 21);
			this.BuildcomboBox.TabIndex = 5;
			this.BuildcomboBox.SelectedIndexChanged += new System.EventHandler(this.BuildcomboBox_SelectedIndexChanged);
			// 
			// label4
			// 
			this.label4.Location = new System.Drawing.Point(16, 16);
			this.label4.Name = "label4";
			this.label4.Size = new System.Drawing.Size(40, 16);
			this.label4.TabIndex = 4;
			this.label4.Text = "Build:";
			// 
			// BldRename
			// 
			this.BldRename.Controls.Add(this.groupBox1);
			this.BldRename.Controls.Add(this.RenameBldlist);
			this.BldRename.Controls.Add(this.label7);
			this.BldRename.Location = new System.Drawing.Point(4, 22);
			this.BldRename.Name = "BldRename";
			this.BldRename.Size = new System.Drawing.Size(352, 196);
			this.BldRename.TabIndex = 3;
			this.BldRename.Text = "Rename Build";
			// 
			// groupBox1
			// 
			this.groupBox1.Controls.Add(this.BLDDescription);
			this.groupBox1.Controls.Add(this.label8);
			this.groupBox1.Controls.Add(this.label9);
			this.groupBox1.Controls.Add(this.NewbldNo);
			this.groupBox1.Controls.Add(this.NewItnNo);
			this.groupBox1.Controls.Add(this.label10);
			this.groupBox1.Location = new System.Drawing.Point(16, 48);
			this.groupBox1.Name = "groupBox1";
			this.groupBox1.Size = new System.Drawing.Size(312, 136);
			this.groupBox1.TabIndex = 13;
			this.groupBox1.TabStop = false;
			this.groupBox1.Text = "Rename To:-";
			// 
			// BLDDescription
			// 
			this.BLDDescription.Location = new System.Drawing.Point(80, 88);
			this.BLDDescription.MaxLength = 50;
			this.BLDDescription.Multiline = true;
			this.BLDDescription.Name = "BLDDescription";
			this.BLDDescription.Size = new System.Drawing.Size(208, 40);
			this.BLDDescription.TabIndex = 14;
			this.BLDDescription.Text = "";
			this.BLDDescription.TextChanged += new System.EventHandler(this.BLDDescription_TextChanged);
			// 
			// label8
			// 
			this.label8.Location = new System.Drawing.Point(16, 88);
			this.label8.Name = "label8";
			this.label8.Size = new System.Drawing.Size(64, 16);
			this.label8.TabIndex = 13;
			this.label8.Text = "Description";
			// 
			// label9
			// 
			this.label9.Location = new System.Drawing.Point(16, 24);
			this.label9.Name = "label9";
			this.label9.Size = new System.Drawing.Size(64, 16);
			this.label9.TabIndex = 9;
			this.label9.Text = "Build #";
			// 
			// NewbldNo
			// 
			this.NewbldNo.Location = new System.Drawing.Point(80, 24);
			this.NewbldNo.MaxLength = 10;
			this.NewbldNo.Name = "NewbldNo";
			this.NewbldNo.Size = new System.Drawing.Size(208, 20);
			this.NewbldNo.TabIndex = 11;
			this.NewbldNo.Text = "";
			this.NewbldNo.TextChanged += new System.EventHandler(this.NewbldNo_TextChanged);
			// 
			// NewItnNo
			// 
			this.NewItnNo.Location = new System.Drawing.Point(80, 56);
			this.NewItnNo.MaxLength = 5;
			this.NewItnNo.Name = "NewItnNo";
			this.NewItnNo.Size = new System.Drawing.Size(208, 20);
			this.NewItnNo.TabIndex = 12;
			this.NewItnNo.Text = "";
			this.NewItnNo.TextChanged += new System.EventHandler(this.NewItnNo_TextChanged);
			// 
			// label10
			// 
			this.label10.Location = new System.Drawing.Point(16, 56);
			this.label10.Name = "label10";
			this.label10.Size = new System.Drawing.Size(64, 16);
			this.label10.TabIndex = 10;
			this.label10.Text = "Iteration #";
			// 
			// RenameBldlist
			// 
			this.RenameBldlist.DropDownStyle = System.Windows.Forms.ComboBoxStyle.DropDownList;
			this.RenameBldlist.Location = new System.Drawing.Point(72, 16);
			this.RenameBldlist.Name = "RenameBldlist";
			this.RenameBldlist.Size = new System.Drawing.Size(120, 21);
			this.RenameBldlist.TabIndex = 7;
			this.RenameBldlist.SelectedIndexChanged += new System.EventHandler(this.RenameBldlist_SelectedIndexChanged);
			// 
			// label7
			// 
			this.label7.Location = new System.Drawing.Point(16, 16);
			this.label7.Name = "label7";
			this.label7.Size = new System.Drawing.Size(40, 16);
			this.label7.TabIndex = 6;
			this.label7.Text = "Build:";
			// 
			// DelBuild
			// 
			this.DelBuild.Controls.Add(this.label5);
			this.DelBuild.Controls.Add(this.BuildcheckedList);
			this.DelBuild.Location = new System.Drawing.Point(4, 22);
			this.DelBuild.Name = "DelBuild";
			this.DelBuild.Size = new System.Drawing.Size(352, 196);
			this.DelBuild.TabIndex = 0;
			this.DelBuild.Text = "Delete Build";
			// 
			// label5
			// 
			this.label5.Location = new System.Drawing.Point(16, 16);
			this.label5.Name = "label5";
			this.label5.Size = new System.Drawing.Size(144, 16);
			this.label5.TabIndex = 1;
			this.label5.Text = "Select builds to delete:";
			// 
			// BuildcheckedList
			// 
			this.BuildcheckedList.Anchor = ((System.Windows.Forms.AnchorStyles)(((System.Windows.Forms.AnchorStyles.Top | System.Windows.Forms.AnchorStyles.Bottom) 
				| System.Windows.Forms.AnchorStyles.Left)));
			this.BuildcheckedList.Location = new System.Drawing.Point(40, 40);
			this.BuildcheckedList.Name = "BuildcheckedList";
			this.BuildcheckedList.Size = new System.Drawing.Size(168, 139);
			this.BuildcheckedList.TabIndex = 0;
			this.BuildcheckedList.SelectedIndexChanged += new System.EventHandler(this.BuildcheckedList_SelectedIndexChanged);
			this.BuildcheckedList.ItemCheck += new System.Windows.Forms.ItemCheckEventHandler(this.BuildcheckedList_ItemCheck);
			// 
			// button6
			// 
			this.button6.Anchor = ((System.Windows.Forms.AnchorStyles)((System.Windows.Forms.AnchorStyles.Top | System.Windows.Forms.AnchorStyles.Right)));
			this.button6.DialogResult = System.Windows.Forms.DialogResult.Cancel;
			this.button6.Location = new System.Drawing.Point(208, 8);
			this.button6.Name = "button6";
			this.button6.Size = new System.Drawing.Size(72, 24);
			this.button6.TabIndex = 13;
			this.button6.Text = "Cancel";
			this.button6.Click += new System.EventHandler(this.button6_Click);
			// 
			// button7
			// 
			this.button7.Anchor = ((System.Windows.Forms.AnchorStyles)((System.Windows.Forms.AnchorStyles.Top | System.Windows.Forms.AnchorStyles.Right)));
			this.button7.Enabled = false;
			this.button7.Location = new System.Drawing.Point(288, 8);
			this.button7.Name = "button7";
			this.button7.Size = new System.Drawing.Size(72, 24);
			this.button7.TabIndex = 12;
			this.button7.Text = "Apply";
			this.button7.Click += new System.EventHandler(this.button7_Click);
			// 
			// button1
			// 
			this.button1.Anchor = ((System.Windows.Forms.AnchorStyles)((System.Windows.Forms.AnchorStyles.Top | System.Windows.Forms.AnchorStyles.Right)));
			this.button1.Location = new System.Drawing.Point(128, 8);
			this.button1.Name = "button1";
			this.button1.Size = new System.Drawing.Size(72, 24);
			this.button1.TabIndex = 14;
			this.button1.Text = "OK";
			this.button1.Click += new System.EventHandler(this.button1_Click);
			// 
			// panel1
			// 
			this.panel1.Controls.Add(this.button7);
			this.panel1.Controls.Add(this.button6);
			this.panel1.Controls.Add(this.button1);
			this.panel1.Dock = System.Windows.Forms.DockStyle.Bottom;
			this.panel1.Location = new System.Drawing.Point(8, 262);
			this.panel1.Name = "panel1";
			this.panel1.Size = new System.Drawing.Size(360, 32);
			this.panel1.TabIndex = 15;
			this.panel1.Paint += new System.Windows.Forms.PaintEventHandler(this.panel1_Paint);
			// 
			// panel2
			// 
			this.panel2.Controls.Add(this.tabControl1);
			this.panel2.Dock = System.Windows.Forms.DockStyle.Fill;
			this.panel2.Location = new System.Drawing.Point(8, 8);
			this.panel2.Name = "panel2";
			this.panel2.Size = new System.Drawing.Size(360, 254);
			this.panel2.TabIndex = 17;
			// 
			// AdminForm
			// 
			this.AcceptButton = this.button1;
			this.AutoScaleBaseSize = new System.Drawing.Size(5, 13);
			this.CancelButton = this.button6;
			this.ClientSize = new System.Drawing.Size(376, 302);
			this.Controls.Add(this.panel2);
			this.Controls.Add(this.panel1);
			this.DockPadding.All = 8;
			this.FormBorderStyle = System.Windows.Forms.FormBorderStyle.FixedDialog;
			this.MaximizeBox = false;
			this.MinimizeBox = false;
			this.Name = "AdminForm";
			this.ShowInTaskbar = false;
			this.StartPosition = System.Windows.Forms.FormStartPosition.CenterParent;
			this.Text = "Admin";
			this.Load += new System.EventHandler(this.AdminForm_Load);
			this.tabControl1.ResumeLayout(false);
			this.BuildDis.ResumeLayout(false);
			this.BldRename.ResumeLayout(false);
			this.groupBox1.ResumeLayout(false);
			this.DelBuild.ResumeLayout(false);
			this.panel1.ResumeLayout(false);
			this.panel2.ResumeLayout(false);
			this.ResumeLayout(false);

		}
		#endregion

		private void AdminForm_Load(object sender, System.EventArgs e)
		{
		
		}

		private void BuildcheckedList_SelectedIndexChanged(object sender, System.EventArgs e)
		{
		
		}

		private void BuildcomboBox_SelectedIndexChanged(object sender, System.EventArgs e)
		{
			//MessageBox.Show(BuildcomboBox.SelectedIndex.ToString());
			if(((Build)BuildcomboBox.SelectedItem).BuildDescription !=null)
				BuildDes.Text=((Build)BuildcomboBox.SelectedItem).BuildDescription.Trim();
			else 
				BuildDes.Text="";
		}

		private void tabControl1_SelectedIndexChanged(object sender, System.EventArgs e)
		{
			//MessageBox.Show("Tab changed ","Warning",MessageBoxButtons.OKCancel);
		}
		

		private void Apply()
		{
			// find out what has changed and update
			BuildList listtoDel = new BuildList();

			if(BldRenameChanged)
			{
				((Build)RenameBldlist.SelectedItem).BuildName=NewbldNo.Text.Trim()+"("+NewItnNo.Text.Trim()+")";;
				((Build)RenameBldlist.SelectedItem).BuildDescription= BLDDescription.Text.Trim();
				int itnnO =System.Convert.ToInt32(NewItnNo.Text);
				queryManager.ReNameBuild(((Build)RenameBldlist.SelectedItem).ID,NewbldNo.Text.Trim(),itnnO,BLDDescription.Text.Trim());
				
				BldRenameChanged= false;
				int preselectedIndex= RenameBldlist.SelectedIndex;
				ReloadBldLists();
				RenameBldlist.SelectedIndex=preselectedIndex;
			}
			if(BldDescriptionChanged >1)
			{
				((Build)BuildcomboBox.SelectedItem).BuildDescription = BuildDes.Text.Trim(); 
				queryManager.UpdateIterationDescription(((Build)BuildcomboBox.SelectedItem).ID,BuildDes.Text.Trim());
				
				BldDescriptionChanged= 1;
			}

			if(BldDeletChecked)
			{
				foreach(Build itemChecked in BuildcheckedList.CheckedItems) 
				{
					DialogResult result;
					string  temp =" Do you want to Delete  Build :-"+ itemChecked.ToString()+" Description :- "+itemChecked.BuildDescription;

					result = MessageBox.Show(temp,"Warning",MessageBoxButtons.YesNo);
					if(result == DialogResult.Yes)
					{
						queryManager.DeleteBuild(itemChecked.ID);
						listtoDel.Add(itemChecked);
					}
				}

				foreach(Build itemChecked in listtoDel)
				{
					BuildcheckedList.Items.Remove(itemChecked);
				}
				foreach(int itemChecked in BuildcheckedList.CheckedIndices)
				{
					BuildcheckedList.SetItemChecked(itemChecked,false);
				}
				
				BldDeletChecked = false;
				ReloadBldLists();
			}

			RefreshChanged();
		}

		private void button7_Click(object sender, System.EventArgs e)
		{
			Apply();
		}

		private void button6_Click(object sender, System.EventArgs e)
		{
			Close();
		}

		private void RefreshChanged()
		{
				button7.Enabled = BldDescriptionChanged>1 ||  BldDeletChecked||BldRenameChanged;
		}

		private void BuildDes_TextChanged(object sender, System.EventArgs e)
		{
			BldDescriptionChanged ++;
			if(BldDescriptionChanged ==2)
				RefreshChanged();
		}

	

		private void button1_Click(object sender, System.EventArgs e)
		{
			Apply();
			Close();
		}

		private void BuildcheckedList_ItemCheck(object sender, System.Windows.Forms.ItemCheckEventArgs e)
		{
			BldDeletChecked= true;
			RefreshChanged();
		}

		private void RenameBldlist_SelectedIndexChanged(object sender, System.EventArgs e)
		{
			NewbldNo.Text=((Build)RenameBldlist.SelectedItem).BuildName.Substring(0,10);
			NewItnNo.Text=((Build)RenameBldlist.SelectedItem).BuildName.Split(new char[]{'(',')'})[1].Trim();
			//MessageBox.Show(BuildcomboBox.SelectedIndex.ToString());
			if(((Build)RenameBldlist.SelectedItem).BuildDescription !=null)
				{
				BLDDescription.Text=((Build)RenameBldlist.SelectedItem).BuildDescription.Trim();
				}
			else 
				BLDDescription.Text="";
		
		}

		private void NewbldNo_TextChanged(object sender, System.EventArgs e)
		{
			BldRenameChanged= true;;
			RefreshChanged();
		}

		private void NewItnNo_TextChanged(object sender, System.EventArgs e)
		{
			BldRenameChanged= true;;
			RefreshChanged();

		}

		private void BLDDescription_TextChanged(object sender, System.EventArgs e)
		{
			BldRenameChanged= true;;
			RefreshChanged();

		}

		private void label6_Click(object sender, System.EventArgs e)
		{
		
		}

		private void panel1_Paint(object sender, System.Windows.Forms.PaintEventArgs e)
		{
		
		}
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\RegDBViewer\ControlTree.cs ===
using System;
using System.Collections;
using System.ComponentModel;
using System.Drawing;
using System.Data;
using System.Windows.Forms;

namespace RegDBViewer
{
	public class ControlTree : System.Windows.Forms.ListBox
	{
		static Brush passBrush = new SolidBrush(Color.Green);
		static Brush failBrush = new SolidBrush(Color.Red);
		static Brush linkBrush = new SolidBrush(Color.Blue);
		private ToolTip toolTip = new ToolTip();

		private System.ComponentModel.Container components = null;

		public ControlTree()
		{
			InitializeComponent();
		}

		protected override void Dispose( bool disposing )
		{
			if( disposing )
			{
				if( components != null )
					components.Dispose();
			}
			base.Dispose( disposing );
		}

		#region Component Designer generated code
		/// <summary>
		/// Required method for Designer support - do not modify 
		/// the contents of this method with the code editor.
		/// </summary>
		private void InitializeComponent()
		{
			// 
			// ControlTree
			// 
			this.DrawMode = System.Windows.Forms.DrawMode.OwnerDrawFixed;

		}
		#endregion

		protected override void OnDrawItem(DrawItemEventArgs e)
		{
			if (e.Index == -1 || e.Index >= Items.Count)
				return;
			DrawAnItem(e, (ItemRow)Items[e.Index]);
		}

		static private int Clamp(float c) {return Math.Min(Math.Max(0, (int)c), 255);}

		static private Color GetItemBackColor(DrawItemEventArgs e, ItemRow item)
		{
			float rColScale = ((float)Math.Pow(0.93, item.Depth));
			float gColScale = ((float)Math.Pow(0.93, item.Depth));
			float bColScale = ((float)Math.Pow(0.93, item.Depth));

			Color col = e.BackColor;
			int cMod = e.Index % 2 == 0 ? 6 : 0;

			return Color.FromArgb(
				Clamp((rColScale*col.R)-cMod), 
				Clamp((gColScale*col.G)-cMod), 
				Clamp(bColScale*col.B));
		}

		static public void DrawAnItem(DrawItemEventArgs e, ItemRow item)
		{
			Font font = e.Font;
			if (item != null && item.Depth == 0)
				font = new Font(e.Font, e.Font.Style | FontStyle.Bold);

			string pass, fail, total, rate;
			if (item == null)
			{
				item = new ItemRow();
				pass = "Passed:";
				fail = "Failed:";
				total = "Total:";
				rate = "Rate:";
				font = new Font(e.Font, FontStyle.Bold);
			}
			else
			{
				pass = item.Pass.ToString();
				fail = item.Fail.ToString();
				total = item.Total.ToString();
				rate = item.Rate;
			}

			Graphics g = e.Graphics;

			using (Brush backBrush = new SolidBrush(GetItemBackColor(e, item)))
                g.FillRectangle(backBrush, e.Bounds);

			using (Brush foreBrush = new SolidBrush(e.ForeColor))
			{
				Brush b;
				if (item.Fail > 0)
					b = failBrush;
				else if (item.Pass > 0)
					b = passBrush;
				else if (item.Fail + item.Pass > 1)
					b = linkBrush;
				else
					b = foreBrush;

				int rColW = 48;

				Rectangle r = e.Bounds;
				r.Location = new Point(r.Left + 8 * item.Depth, r.Top);
				r.Width -= 8 * item.Depth - rColW * 4;

				Font f = item.Total > 1 || item.Depth < 3 ? new Font(font, font.Style | FontStyle.Underline) : font;
				g.DrawString(item.Name, f, b, r);

				StringFormat rAlign = StringFormat.GenericDefault;
				rAlign.Alignment = StringAlignment.Far;

				r.Width = rColW;
				r.Location = new Point(e.Bounds.Width - rColW * 4, r.Top);
				g.DrawString(pass, font, b, r, rAlign);
				
				r.Location = new Point(e.Bounds.Width - rColW * 3, r.Top);
				g.DrawString(fail, font, b, r, rAlign);
				
				r.Location = new Point(e.Bounds.Width - rColW * 2, r.Top);
				g.DrawString(total, font, b, r, rAlign);
				
				r.Location = new Point(e.Bounds.Width - rColW * 1, r.Top);
				g.DrawString(rate, font, b, r, rAlign);
			}
		}

		protected override void OnSizeChanged(EventArgs e)
		{
			base.OnSizeChanged (e);
			Refresh();
		}

		protected override void OnMouseMove(MouseEventArgs e)
		{
			base.OnMouseMove(e);

			int index = e.Y / ItemHeight + this.TopIndex;
			if (index >= 0 && index < Items.Count)
			{
				ItemRow item = (ItemRow)Items[index];
				string desc = null;
				if (item is IterationRow)
					desc = ((IterationRow)item).Description;
				else if (item is TestCaseRow)
					desc = ((TestCaseRow)item).ResultDetails;

				if (desc != null && desc.Trim().Length != 0)
				{
					toolTip.SetToolTip(this, Items[index].ToString().Trim() + "\n" + desc.Trim());
					return;
				}
			}

			toolTip.SetToolTip(this, null);
		}
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\RegDBViewer\ItemRow.cs ===
using System;
using System.Collections;
using System.Data.SqlClient;
using System.Diagnostics;
using System.Windows.Forms;

namespace RegDBViewer
{
	public enum TestResult {Failed, Passed}

	public class ItemRow
	{
		public ItemRow Parent;
		public int ID;
		public string Name;
		public int Pass;
		public int Fail;
		public int Depth;
		public ItemRowList Children = null;
		public bool SubTreeOpen = false;

		public ItemRow()
		{
			this.Name = "";
		}

		public ItemRow(string name)
		{
			this.Name = name;
		}

		public TestResult Result {get {return Pass > 0 && Fail == 0 ? TestResult.Passed : TestResult.Failed;}}
		public int Total {get {return Pass + Fail;}}
		public string Rate {get {return Total > 0 ? ((float)Pass / Total * 100).ToString("F2") + "%" : "-";}}

		public ItemRow GetAtDepth(int depth)
		{
			if (depth > Depth)
				return null;
			if (depth == Depth)
				return this;
			return Parent.GetAtDepth(depth);
		}

		public bool IsChildOf(ItemRow item)
		{
			ItemRow ir = Parent;
			while (ir != null)
			{
				if (ir == item)
					return true;
				else
					ir = ir.Parent;
			}

			return false;
		}

		public override string ToString() {return Name;}
	}

	public class IterationRow : ItemRow
	{
		public string Description;
		public DateTime StartTime;
	}

	public class TestCaseRow : ItemRow
	{
		public string ResultDetails;
		public int BugID;

		public bool Passed {get {return Pass == 1;}}
	}

	public class ItemRowList : CollectionBase
	{
		public void Add(ItemRow a)
		{
			List.Add(a);
		}

		public ItemRow Item(int index)
		{
			return (ItemRow)List[index];
		}
	}

	public class ItemRowEventArgs : EventArgs
	{
		public ItemRow Item;
	}

	public delegate void ItemRowSelectedEventHandler(object sender, ItemRowEventArgs e);
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\RegDBViewer\AboutForm.cs ===
using System;
using System.Drawing;
using System.Collections;
using System.ComponentModel;
using System.Windows.Forms;

namespace RegDBViewer
{
	/// <summary>
	/// Summary description for AboutForm.
	/// </summary>
	public class AboutForm : System.Windows.Forms.Form
	{
		private System.Windows.Forms.PictureBox pictureBox1;
		private System.Windows.Forms.Button button1;
		private System.Windows.Forms.Panel panel1;
		private System.Windows.Forms.PictureBox pictureBox2;
		private System.Windows.Forms.Panel panel2;
		private System.Windows.Forms.Label label3;
		private System.Windows.Forms.Label label1;
		private System.Windows.Forms.Label label2;
		/// <summary>
		/// Required designer variable.
		/// </summary>
		private System.ComponentModel.Container components = null;

		public AboutForm()
		{
			//
			// Required for Windows Form Designer support
			//
			InitializeComponent();

			//
			// TODO: Add any constructor code after InitializeComponent call
			//
		}

		/// <summary>
		/// Clean up any resources being used.
		/// </summary>
		protected override void Dispose( bool disposing )
		{
			if( disposing )
			{
				if(components != null)
				{
					components.Dispose();
				}
			}
			base.Dispose( disposing );
		}

		#region Windows Form Designer generated code
		/// <summary>
		/// Required method for Designer support - do not modify
		/// the contents of this method with the code editor.
		/// </summary>
		private void InitializeComponent()
		{
			System.Resources.ResourceManager resources = new System.Resources.ResourceManager(typeof(AboutForm));
			this.pictureBox1 = new System.Windows.Forms.PictureBox();
			this.button1 = new System.Windows.Forms.Button();
			this.panel1 = new System.Windows.Forms.Panel();
			this.pictureBox2 = new System.Windows.Forms.PictureBox();
			this.panel2 = new System.Windows.Forms.Panel();
			this.label3 = new System.Windows.Forms.Label();
			this.label1 = new System.Windows.Forms.Label();
			this.label2 = new System.Windows.Forms.Label();
			this.panel1.SuspendLayout();
			this.panel2.SuspendLayout();
			this.SuspendLayout();
			// 
			// pictureBox1
			// 
			this.pictureBox1.BackColor = System.Drawing.SystemColors.Highlight;
			this.pictureBox1.Image = ((System.Drawing.Image)(resources.GetObject("pictureBox1.Image")));
			this.pictureBox1.Location = new System.Drawing.Point(5, 19);
			this.pictureBox1.Name = "pictureBox1";
			this.pictureBox1.Size = new System.Drawing.Size(64, 64);
			this.pictureBox1.SizeMode = System.Windows.Forms.PictureBoxSizeMode.AutoSize;
			this.pictureBox1.TabIndex = 3;
			this.pictureBox1.TabStop = false;
			// 
			// button1
			// 
			this.button1.Anchor = ((System.Windows.Forms.AnchorStyles)((System.Windows.Forms.AnchorStyles.Bottom | System.Windows.Forms.AnchorStyles.Right)));
			this.button1.Location = new System.Drawing.Point(248, 344);
			this.button1.Name = "button1";
			this.button1.TabIndex = 4;
			this.button1.Text = "OK";
			this.button1.Click += new System.EventHandler(this.button1_Click);
			// 
			// panel1
			// 
			this.panel1.Anchor = ((System.Windows.Forms.AnchorStyles)(((System.Windows.Forms.AnchorStyles.Top | System.Windows.Forms.AnchorStyles.Bottom) 
				| System.Windows.Forms.AnchorStyles.Left)));
			this.panel1.BackColor = System.Drawing.SystemColors.Highlight;
			this.panel1.Controls.Add(this.pictureBox1);
			this.panel1.Location = new System.Drawing.Point(8, 8);
			this.panel1.Name = "panel1";
			this.panel1.Size = new System.Drawing.Size(72, 368);
			this.panel1.TabIndex = 5;
			// 
			// pictureBox2
			// 
			this.pictureBox2.BorderStyle = System.Windows.Forms.BorderStyle.Fixed3D;
			this.pictureBox2.Image = ((System.Drawing.Image)(resources.GetObject("pictureBox2.Image")));
			this.pictureBox2.Location = new System.Drawing.Point(104, 136);
			this.pictureBox2.Name = "pictureBox2";
			this.pictureBox2.Size = new System.Drawing.Size(87, 125);
			this.pictureBox2.SizeMode = System.Windows.Forms.PictureBoxSizeMode.AutoSize;
			this.pictureBox2.TabIndex = 7;
			this.pictureBox2.TabStop = false;
			// 
			// panel2
			// 
			this.panel2.Anchor = ((System.Windows.Forms.AnchorStyles)(((System.Windows.Forms.AnchorStyles.Top | System.Windows.Forms.AnchorStyles.Left) 
				| System.Windows.Forms.AnchorStyles.Right)));
			this.panel2.Controls.Add(this.label3);
			this.panel2.Controls.Add(this.label1);
			this.panel2.Controls.Add(this.label2);
			this.panel2.Location = new System.Drawing.Point(80, 16);
			this.panel2.Name = "panel2";
			this.panel2.Size = new System.Drawing.Size(256, 88);
			this.panel2.TabIndex = 6;
			// 
			// label3
			// 
			this.label3.Location = new System.Drawing.Point(8, 64);
			this.label3.Name = "label3";
			this.label3.Size = new System.Drawing.Size(192, 16);
			this.label3.TabIndex = 2;
			this.label3.Text = "Copyright (c) MS XOSTT";
			// 
			// label1
			// 
			this.label1.Font = new System.Drawing.Font("Microsoft Sans Serif", 10F, System.Drawing.FontStyle.Regular, System.Drawing.GraphicsUnit.Point, ((System.Byte)(0)));
			this.label1.Location = new System.Drawing.Point(8, 8);
			this.label1.Name = "label1";
			this.label1.Size = new System.Drawing.Size(208, 16);
			this.label1.TabIndex = 0;
			this.label1.Text = "Xbox Live Server Test Team";
			// 
			// label2
			// 
			this.label2.Font = new System.Drawing.Font("Microsoft Sans Serif", 12F, System.Drawing.FontStyle.Bold, System.Drawing.GraphicsUnit.Point, ((System.Byte)(0)));
			this.label2.Location = new System.Drawing.Point(8, 24);
			this.label2.Name = "label2";
			this.label2.Size = new System.Drawing.Size(216, 24);
			this.label2.TabIndex = 1;
			this.label2.Text = "Functional Test DB Viewer";
			// 
			// AboutForm
			// 
			this.AcceptButton = this.button1;
			this.AutoScaleBaseSize = new System.Drawing.Size(5, 13);
			this.ClientSize = new System.Drawing.Size(346, 384);
			this.Controls.Add(this.pictureBox2);
			this.Controls.Add(this.panel2);
			this.Controls.Add(this.panel1);
			this.Controls.Add(this.button1);
			this.FormBorderStyle = System.Windows.Forms.FormBorderStyle.FixedDialog;
			this.MaximizeBox = false;
			this.MinimizeBox = false;
			this.Name = "AboutForm";
			this.StartPosition = System.Windows.Forms.FormStartPosition.CenterScreen;
			this.Text = "About RegDBViewer";
			this.panel1.ResumeLayout(false);
			this.panel2.ResumeLayout(false);
			this.ResumeLayout(false);

		}
		#endregion

		private void button1_Click(object sender, System.EventArgs e)
		{
			Close();
		}
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\RegDBViewer\RegDBQuery.cs ===
using System;
using System.Collections;

namespace RegDBViewer
{
	public class RegDBQuery
	{
		ArrayList builds = new ArrayList();
		ArrayList servers = new ArrayList();

		public  void AddBuild(int IterationID)
		{
			if(builds.Count < 6)
				builds.Add(IterationID);
		}

		public void AddServer(int SubCompID)
		{
			if(servers.Count<6)
				servers.Add(SubCompID);
		}

		public void RemoveServer(int SubCompID)
		{
			servers.Remove(SubCompID);
		}

		public int GetServerCount()
		{
			return servers.Count;
		}

		public int GetServerAT(int index)
		{
			return (int)servers[index];
		}
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\RegDBViewer\AdminTestCase.cs ===
using System;
using System.Drawing;
using System.Collections;
using System.ComponentModel;
using System.Windows.Forms;

namespace RegDBViewer
{
	/// <summary>
	/// Summary description for AdminTestCase.
	/// </summary>
	public class AdminTestCase : System.Windows.Forms.Form
	{
		private int SrvDescriptionChanged = 0;
		private RegDBQueryManager queryManager;
		private System.Windows.Forms.TabControl tabControl1;
		private System.Windows.Forms.TabPage tabPage1;
		private System.Windows.Forms.TabPage tabPage2;
		private System.Windows.Forms.TextBox ServerDes;
		private System.Windows.Forms.Label label2;
		private System.Windows.Forms.ComboBox SrvList;
		private System.Windows.Forms.Label label1;
		private System.Windows.Forms.Panel panel1;
		private System.Windows.Forms.Button button7;
		private System.Windows.Forms.Button button6;
		private System.Windows.Forms.Button button1;
		/// <summary>
		/// Required designer variable.
		/// </summary>
		private System.ComponentModel.Container components = null;

		public AdminTestCase(RegDBQueryManager qManager)
		{
			//
			// Required for Windows Form Designer support
			//
			InitializeComponent();

			//
			// TODO: Add any constructor code after InitializeComponent call
			//
			queryManager=qManager;
			ServerList sl = queryManager.GetServerList();

			SrvList.Items.Clear();
			foreach (Server s in sl)
				if (s.Servername.Trim() != "")
					SrvList.Items.Add(s);
			SrvList.SelectedIndex=0;

		}

		/// <summary>
		/// Clean up any resources being used.
		/// </summary>
		protected override void Dispose( bool disposing )
		{
			if( disposing )
			{
				if(components != null)
				{
					components.Dispose();
				}
			}
			base.Dispose( disposing );
		}

		#region Windows Form Designer generated code
		/// <summary>
		/// Required method for Designer support - do not modify
		/// the contents of this method with the code editor.
		/// </summary>
		private void InitializeComponent()
		{
			this.tabControl1 = new System.Windows.Forms.TabControl();
			this.tabPage1 = new System.Windows.Forms.TabPage();
			this.tabPage2 = new System.Windows.Forms.TabPage();
			this.ServerDes = new System.Windows.Forms.TextBox();
			this.label2 = new System.Windows.Forms.Label();
			this.SrvList = new System.Windows.Forms.ComboBox();
			this.label1 = new System.Windows.Forms.Label();
			this.panel1 = new System.Windows.Forms.Panel();
			this.button7 = new System.Windows.Forms.Button();
			this.button6 = new System.Windows.Forms.Button();
			this.button1 = new System.Windows.Forms.Button();
			this.tabControl1.SuspendLayout();
			this.panel1.SuspendLayout();
			this.SuspendLayout();
			// 
			// tabControl1
			// 
			this.tabControl1.Controls.Add(this.tabPage1);
			this.tabControl1.Controls.Add(this.tabPage2);
			this.tabControl1.Dock = System.Windows.Forms.DockStyle.Fill;
			this.tabControl1.Location = new System.Drawing.Point(8, 8);
			this.tabControl1.Name = "tabControl1";
			this.tabControl1.SelectedIndex = 0;
			this.tabControl1.Size = new System.Drawing.Size(360, 254);
			this.tabControl1.TabIndex = 0;
			// 
			// tabPage1
			// 
			this.tabPage1.Location = new System.Drawing.Point(4, 22);
			this.tabPage1.Name = "tabPage1";
			this.tabPage1.Size = new System.Drawing.Size(352, 228);
			this.tabPage1.TabIndex = 0;
			this.tabPage1.Text = "Add Server Description";
			// 
			// tabPage2
			// 
			this.tabPage2.Location = new System.Drawing.Point(4, 22);
			this.tabPage2.Name = "tabPage2";
			this.tabPage2.Size = new System.Drawing.Size(352, 228);
			this.tabPage2.TabIndex = 1;
			this.tabPage2.Text = "Add TestCase Description";
			// 
			// ServerDes
			// 
			this.ServerDes.Anchor = ((System.Windows.Forms.AnchorStyles)((((System.Windows.Forms.AnchorStyles.Top | System.Windows.Forms.AnchorStyles.Bottom) 
				| System.Windows.Forms.AnchorStyles.Left) 
				| System.Windows.Forms.AnchorStyles.Right)));
			this.ServerDes.Location = new System.Drawing.Point(56, 176);
			this.ServerDes.MaxLength = 50;
			this.ServerDes.Multiline = true;
			this.ServerDes.Name = "ServerDes";
			this.ServerDes.Size = new System.Drawing.Size(264, 48);
			this.ServerDes.TabIndex = 7;
			this.ServerDes.Text = "";
			this.ServerDes.TextChanged += new System.EventHandler(this.ServerDes_TextChanged);
			// 
			// label2
			// 
			this.label2.Location = new System.Drawing.Point(24, 144);
			this.label2.Name = "label2";
			this.label2.Size = new System.Drawing.Size(72, 16);
			this.label2.TabIndex = 6;
			this.label2.Text = "Description:";
			// 
			// SrvList
			// 
			this.SrvList.DropDownStyle = System.Windows.Forms.ComboBoxStyle.DropDownList;
			this.SrvList.Items.AddRange(new object[] {
														 "FBCK",
														 "Stats",
														 "MESSIIS",
														 "MONINH",
														 "SIGTEST"});
			this.SrvList.Location = new System.Drawing.Point(48, 104);
			this.SrvList.Name = "SrvList";
			this.SrvList.Size = new System.Drawing.Size(120, 21);
			this.SrvList.TabIndex = 5;
			this.SrvList.SelectedIndexChanged += new System.EventHandler(this.SrvList_SelectedIndexChanged);
			// 
			// label1
			// 
			this.label1.Location = new System.Drawing.Point(24, 80);
			this.label1.Name = "label1";
			this.label1.Size = new System.Drawing.Size(48, 16);
			this.label1.TabIndex = 4;
			this.label1.Text = "Server:";
			// 
			// panel1
			// 
			this.panel1.Controls.Add(this.button7);
			this.panel1.Controls.Add(this.button6);
			this.panel1.Controls.Add(this.button1);
			this.panel1.Dock = System.Windows.Forms.DockStyle.Bottom;
			this.panel1.Location = new System.Drawing.Point(8, 262);
			this.panel1.Name = "panel1";
			this.panel1.Size = new System.Drawing.Size(360, 32);
			this.panel1.TabIndex = 16;
			// 
			// button7
			// 
			this.button7.Anchor = ((System.Windows.Forms.AnchorStyles)((System.Windows.Forms.AnchorStyles.Top | System.Windows.Forms.AnchorStyles.Right)));
			this.button7.Enabled = false;
			this.button7.Location = new System.Drawing.Point(288, 8);
			this.button7.Name = "button7";
			this.button7.Size = new System.Drawing.Size(72, 24);
			this.button7.TabIndex = 12;
			this.button7.Text = "Apply";
			this.button7.Click += new System.EventHandler(this.button7_Click);
			// 
			// button6
			// 
			this.button6.Anchor = ((System.Windows.Forms.AnchorStyles)((System.Windows.Forms.AnchorStyles.Top | System.Windows.Forms.AnchorStyles.Right)));
			this.button6.DialogResult = System.Windows.Forms.DialogResult.Cancel;
			this.button6.Location = new System.Drawing.Point(208, 8);
			this.button6.Name = "button6";
			this.button6.Size = new System.Drawing.Size(72, 24);
			this.button6.TabIndex = 13;
			this.button6.Text = "Cancel";
			this.button6.Click += new System.EventHandler(this.button6_Click);
			// 
			// button1
			// 
			this.button1.Anchor = ((System.Windows.Forms.AnchorStyles)((System.Windows.Forms.AnchorStyles.Top | System.Windows.Forms.AnchorStyles.Right)));
			this.button1.Location = new System.Drawing.Point(128, 8);
			this.button1.Name = "button1";
			this.button1.Size = new System.Drawing.Size(72, 24);
			this.button1.TabIndex = 14;
			this.button1.Text = "OK";
			this.button1.Click += new System.EventHandler(this.button1_Click);
			// 
			// AdminTestCase
			// 
			this.AutoScaleBaseSize = new System.Drawing.Size(5, 13);
			this.ClientSize = new System.Drawing.Size(376, 302);
			this.Controls.Add(this.ServerDes);
			this.Controls.Add(this.label2);
			this.Controls.Add(this.SrvList);
			this.Controls.Add(this.label1);
			this.Controls.Add(this.tabControl1);
			this.Controls.Add(this.panel1);
			this.DockPadding.All = 8;
			this.FormBorderStyle = System.Windows.Forms.FormBorderStyle.FixedDialog;
			this.MaximizeBox = false;
			this.MinimizeBox = false;
			this.Name = "AdminTestCase";
			this.Text = "TestCase Manager";
			this.Load += new System.EventHandler(this.AdminTestCase_Load);
			this.tabControl1.ResumeLayout(false);
			this.panel1.ResumeLayout(false);
			this.ResumeLayout(false);

		}
		#endregion

		private void AdminTestCase_Load(object sender, System.EventArgs e)
		{
		
		}

		private void SrvList_SelectedIndexChanged(object sender, System.EventArgs e)
		{
			if(((Server)SrvList.SelectedItem).ServerDescription != null)
				ServerDes.Text=((Server)SrvList.SelectedItem).ServerDescription.Trim();
			else 
				ServerDes.Text="";
		}

		private void Apply()
		{
			// find out what has changed and update
			if(SrvDescriptionChanged>1)
			{
				((Server)SrvList.SelectedItem).ServerDescription = ServerDes.Text.Trim(); 
				queryManager.UpdateSrvDescription(((Server)SrvList.SelectedItem).ID,ServerDes.Text.Trim());
				SrvDescriptionChanged= 1;
			}
		}
		private void RefreshChanged()
		{
			button7.Enabled = SrvDescriptionChanged >1;
		}

		private void ServerDes_TextChanged(object sender, System.EventArgs e)
		{
			SrvDescriptionChanged ++;
			if(SrvDescriptionChanged==2)
				RefreshChanged();
		}

		private void button1_Click(object sender, System.EventArgs e)
		{
			Apply();
			Close();
		}

		private void button6_Click(object sender, System.EventArgs e)
		{
			Close();
		}

		private void button7_Click(object sender, System.EventArgs e)
		{
			Apply();
		}

	}
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\RegDBViewer\TestResultTree.cs ===
using System;
using System.Collections;
using System.ComponentModel;
using System.Drawing;
using System.Data;
using System.Windows.Forms;

namespace RegDBViewer
{
	/// <summary>
	/// Summary description for TestResultTree.
	/// </summary>
	public class TestResultTree : System.Windows.Forms.UserControl
	{
		private ItemRow lastSelected;

		private System.Windows.Forms.PictureBox pictureBox1;
		private ControlTree controlTree1;
		/// <summary> 
		/// Required designer variable.
		/// </summary>
		private System.ComponentModel.Container components = null;

		public TestResultTree()
		{
			// This call is required by the Windows.Forms Form Designer.
			InitializeComponent();

			// TODO: Add any initialization after the InitializeComponent call

		}

		/// <summary> 
		/// Clean up any resources being used.
		/// </summary>
		protected override void Dispose( bool disposing )
		{
			if( disposing )
			{
				if(components != null)
				{
					components.Dispose();
				}
			}
			base.Dispose( disposing );
		}

		#region Component Designer generated code
		/// <summary> 
		/// Required method for Designer support - do not modify 
		/// the contents of this method with the code editor.
		/// </summary>
		private void InitializeComponent()
		{
			this.pictureBox1 = new System.Windows.Forms.PictureBox();
			this.controlTree1 = new RegDBViewer.ControlTree();
			this.SuspendLayout();
			// 
			// pictureBox1
			// 
			this.pictureBox1.BorderStyle = System.Windows.Forms.BorderStyle.FixedSingle;
			this.pictureBox1.Dock = System.Windows.Forms.DockStyle.Top;
			this.pictureBox1.Location = new System.Drawing.Point(0, 0);
			this.pictureBox1.Name = "pictureBox1";
			this.pictureBox1.Size = new System.Drawing.Size(150, 16);
			this.pictureBox1.TabIndex = 0;
			this.pictureBox1.TabStop = false;
			this.pictureBox1.SizeChanged += new System.EventHandler(this.pictureBox1_SizeChanged);
			this.pictureBox1.Paint += new System.Windows.Forms.PaintEventHandler(this.pictureBox1_Paint);
			// 
			// controlTree1
			// 
			this.controlTree1.BorderStyle = System.Windows.Forms.BorderStyle.FixedSingle;
			this.controlTree1.Dock = System.Windows.Forms.DockStyle.Fill;
			this.controlTree1.DrawMode = System.Windows.Forms.DrawMode.OwnerDrawFixed;
			this.controlTree1.Location = new System.Drawing.Point(0, 16);
			this.controlTree1.Name = "controlTree1";
			this.controlTree1.Size = new System.Drawing.Size(150, 132);
			this.controlTree1.TabIndex = 0;
			this.controlTree1.SelectedIndexChanged += new System.EventHandler(this.controlTree1_SelectedIndexChanged);
			// 
			// TestResultTree
			// 
			this.Controls.Add(this.controlTree1);
			this.Controls.Add(this.pictureBox1);
			this.Name = "TestResultTree";
			this.Load += new System.EventHandler(this.TestResultTree_Load);
			this.ResumeLayout(false);

		}
		#endregion

		private void pictureBox1_Paint(object sender, System.Windows.Forms.PaintEventArgs e)
		{
			ControlTree.DrawAnItem(new DrawItemEventArgs(e.Graphics, controlTree1.Font, pictureBox1.ClientRectangle, -1, DrawItemState.Default, controlTree1.ForeColor, controlTree1.BackColor), null);
		}

		private void pictureBox1_SizeChanged(object sender, System.EventArgs e)
		{
			pictureBox1.Refresh();
		}

		private void TestResultTree_Load(object sender, System.EventArgs e)
		{
			pictureBox1.SizeChanged +=new EventHandler(pictureBox1_SizeChanged);
		}

		public ListBox.ObjectCollection Items {get {return controlTree1.Items;}}

//		public object SelectedItem {get {return controlTree1.SelectedItem;} set {controlTree1.SelectedItem = value;}}
//
		
		private void CloseSubTreeUp(ItemRow item)
		{
			if (item.Parent != null)
			{
				item.Parent.SubTreeOpen = false;
				CloseSubTreeUp(item.Parent);
			}
		}

		private void CloseSubTreeDown(ItemRow item)
		{
			item.SubTreeOpen = false;

			if (item.Children != null)
				foreach (ItemRow ir in item.Children)
					CloseSubTreeDown(ir);
		}

		private void OpenSubTree(ItemRow item)
		{
			item.SubTreeOpen = true;
			if (item.Parent != null)
				OpenSubTree(item.Parent);
		}

		private void controlTree1_SelectedIndexChanged(object sender, System.EventArgs e)
		{
			ItemRow item = (ItemRow)controlTree1.SelectedItem;

			if (item == lastSelected)
				return;

			if (lastSelected != null)
			{
				CloseSubTreeUp(lastSelected);
				CloseSubTreeDown(lastSelected);
			}

			lastSelected = item;

			OpenSubTree(item);

			if (item.Total > 1 || item.Depth < 3)
				OnSelectedIndexChanged(this, new SelectedRowChangedEventArgs(item));

			controlTree1.SelectedIndexChanged -= new EventHandler(controlTree1_SelectedIndexChanged);
			controlTree1.SelectedItem = item;
			controlTree1.SelectedIndexChanged += new EventHandler(controlTree1_SelectedIndexChanged);
		}

		public event SelectedRowChangedHandler SelectedIndexChanged;

		public void OnSelectedIndexChanged(object sender, SelectedRowChangedEventArgs e)
		{
			if (SelectedIndexChanged != null)
				SelectedIndexChanged(sender, e);
		}

		public ItemRow LastSelected {get {return lastSelected;} set {lastSelected = value;}}

		new public void SuspendLayout()
		{
			base.SuspendLayout();
			controlTree1.SuspendLayout();
		}

		new public void ResumeLayout()
		{
			base.ResumeLayout();
			controlTree1.ResumeLayout();
		}
	}

	public class SelectedRowChangedEventArgs : EventArgs
	{
		public ItemRow Row;

		public SelectedRowChangedEventArgs(ItemRow row)
		{
			this.Row = row;
		}
	}

	public delegate void SelectedRowChangedHandler(object sender, SelectedRowChangedEventArgs e);
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\SafetyNet\ActivityLibrary1\CreateSTFCmdLine.Designer.cs ===
namespace SafetyNet.Activities
{
	public partial class CreateSTFCmdLine
	{
		#region Designer generated code
		
		/// <summary> 
		/// Required method for Designer support - do not modify 
		/// the contents of this method with the code editor.
		/// </summary>
        [System.Diagnostics.DebuggerNonUserCode]
		private void InitializeComponent()
		{
			this.Name = "CreateSTFCmdLine";
		}

		#endregion
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\SafetyNet\ActivityLibrary1\CopyDirectory.cs ===
using System;
using System.ComponentModel;
using System.ComponentModel.Design;
using System.Collections;
using System.Drawing;
using System.Workflow.ComponentModel;
using System.Workflow.ComponentModel.Design;
using System.Workflow.ComponentModel.Compiler;
using System.Workflow.ComponentModel.Serialization;
using System.Workflow.Runtime;
using System.Workflow.Activities;
using System.Workflow.Activities.Rules;
using Microsoft.VisualBasic.FileIO;
using SafetyNet.Services;

namespace SafetyNet.Activities
{
	public partial class CopyDirectory: TrackableActivity
	{
        public static DependencyProperty SourceProperty = System.Workflow.ComponentModel.DependencyProperty.Register("Source", typeof(string), typeof(CopyDirectory), new PropertyMetadata(DependencyPropertyOptions.Metadata));

        [Description("This is the source directory.")]
        [Category("General")]
        [Browsable(true)]
        [DesignerSerializationVisibility(DesignerSerializationVisibility.Visible)]
        public string Source
        {
            get
            {
                return ((string)(base.GetValue(CopyDirectory.SourceProperty)));
            }
            set
            {
                base.SetValue(CopyDirectory.SourceProperty, value);
            }
        }

        public static DependencyProperty DestinationProperty = System.Workflow.ComponentModel.DependencyProperty.Register("Destination", typeof(string), typeof(CopyDirectory));

        [Description("This is the destination for directory being copied")]
        [Category("General")]
        [Browsable(true)]
        [DesignerSerializationVisibility(DesignerSerializationVisibility.Visible)]
        public string Destination
        {
            get
            {
                return ((string)(base.GetValue(CopyDirectory.DestinationProperty)));
            }
            set
            {
                base.SetValue(CopyDirectory.DestinationProperty, value);
            }
        }

		public CopyDirectory()
		{
			InitializeComponent();
		}

        protected override ActivityExecutionStatus Execute(ActivityExecutionContext executionContext) {
            FileSystem.CopyDirectory(Source, Destination, true);
            return ActivityExecutionStatus.Closed;
        }
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\SafetyNet\ActivityLibrary1\CopyDirectory.Designer.cs ===
using System;
using System.ComponentModel;
using System.ComponentModel.Design;
using System.Collections;
using System.Drawing;
using System.Reflection;
using System.Workflow.ComponentModel;
using System.Workflow.ComponentModel.Design;
using System.Workflow.ComponentModel.Compiler;
using System.Workflow.ComponentModel.Serialization;
using System.Workflow.Runtime;
using System.Workflow.Activities;
using System.Workflow.Activities.Rules;

namespace SafetyNet.Activities
{
	public partial class CopyDirectory
	{
		#region Designer generated code
		
		/// <summary> 
		/// Required method for Designer support - do not modify 
		/// the contents of this method with the code editor.
		/// </summary>
        [System.Diagnostics.DebuggerNonUserCode]
		private void InitializeComponent()
		{
			this.Name = "CopyDirectory";
		}

		#endregion
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\RegDBViewer\ViewerForm.cs ===
using System;
using System.Drawing;
using System.Collections;
using System.ComponentModel;
using System.Windows.Forms;

namespace RegDBViewer
{
	public class ViewerForm : System.Windows.Forms.Form
	{
		RegDBQueryManager queryManager = new RegDBQueryManager();
		private System.Windows.Forms.Panel panel2;
		private System.Windows.Forms.Panel panel3;
		private System.Windows.Forms.MainMenu mainMenu1;
		private System.Windows.Forms.MenuItem menuItem1;
		private System.Windows.Forms.MenuItem menuItem2;
		private System.Windows.Forms.MenuItem menuItem3;
		private System.Windows.Forms.MenuItem menuItem4;
		private System.Windows.Forms.MenuItem menuItem5;
		private System.Windows.Forms.MenuItem menuItem6;
		private System.Windows.Forms.MenuItem menuItem7;
		private System.Windows.Forms.MenuItem menuItem8;
		private System.Windows.Forms.MenuItem menuItem9;
		private System.Windows.Forms.MenuItem menuItem10;
		private System.Windows.Forms.MenuItem menuItem11;
		private System.Windows.Forms.CheckedListBox clbServerList;
		private System.Windows.Forms.CheckBox chkFilterServers;
		private System.Windows.Forms.MenuItem menuItem12;
		private System.Windows.Forms.MenuItem menuShowOnlyFailedTests;
		private System.Windows.Forms.MenuItem menuViewFilters;
		private System.Windows.Forms.MenuItem menuItem13;
		private System.Windows.Forms.MenuItem menuItem14;
		private RegDBViewer.TestResultTree testResultTree1;
		private System.Windows.Forms.ToolTip toolTip1;
		private System.ComponentModel.IContainer components;

		public ViewerForm()
		{
			InitializeComponent();
		}

		protected override void Dispose( bool disposing )
		{
			if( disposing )
			{
				if (components != null) 
				{
					components.Dispose();
				}
			}
			base.Dispose( disposing );
		}

		#region Windows Form Designer generated code
		/// <summary>
		/// Required method for Designer support - do not modify
		/// the contents of this method with the code editor.
		/// </summary>
		private void InitializeComponent()
		{
			this.components = new System.ComponentModel.Container();
			this.panel2 = new System.Windows.Forms.Panel();
			this.testResultTree1 = new RegDBViewer.TestResultTree();
			this.panel3 = new System.Windows.Forms.Panel();
			this.chkFilterServers = new System.Windows.Forms.CheckBox();
			this.clbServerList = new System.Windows.Forms.CheckedListBox();
			this.mainMenu1 = new System.Windows.Forms.MainMenu();
			this.menuItem1 = new System.Windows.Forms.MenuItem();
			this.menuItem5 = new System.Windows.Forms.MenuItem();
			this.menuItem6 = new System.Windows.Forms.MenuItem();
			this.menuItem7 = new System.Windows.Forms.MenuItem();
			this.menuItem8 = new System.Windows.Forms.MenuItem();
			this.menuItem10 = new System.Windows.Forms.MenuItem();
			this.menuItem9 = new System.Windows.Forms.MenuItem();
			this.menuItem12 = new System.Windows.Forms.MenuItem();
			this.menuItem11 = new System.Windows.Forms.MenuItem();
			this.menuShowOnlyFailedTests = new System.Windows.Forms.MenuItem();
			this.menuViewFilters = new System.Windows.Forms.MenuItem();
			this.menuItem3 = new System.Windows.Forms.MenuItem();
			this.menuItem13 = new System.Windows.Forms.MenuItem();
			this.menuItem14 = new System.Windows.Forms.MenuItem();
			this.menuItem2 = new System.Windows.Forms.MenuItem();
			this.menuItem4 = new System.Windows.Forms.MenuItem();
			this.toolTip1 = new System.Windows.Forms.ToolTip(this.components);
			this.panel2.SuspendLayout();
			this.panel3.SuspendLayout();
			this.SuspendLayout();
			// 
			// panel2
			// 
			this.panel2.BorderStyle = System.Windows.Forms.BorderStyle.FixedSingle;
			this.panel2.Controls.Add(this.testResultTree1);
			this.panel2.Dock = System.Windows.Forms.DockStyle.Fill;
			this.panel2.DockPadding.All = 8;
			this.panel2.Location = new System.Drawing.Point(152, 0);
			this.panel2.Name = "panel2";
			this.panel2.Size = new System.Drawing.Size(376, 473);
			this.panel2.TabIndex = 5;
			// 
			// testResultTree1
			// 
			this.testResultTree1.Dock = System.Windows.Forms.DockStyle.Fill;
			this.testResultTree1.LastSelected = null;
			this.testResultTree1.Location = new System.Drawing.Point(8, 8);
			this.testResultTree1.Name = "testResultTree1";
			this.testResultTree1.Size = new System.Drawing.Size(358, 455);
			this.testResultTree1.TabIndex = 4;
			this.testResultTree1.SelectedIndexChanged += new RegDBViewer.SelectedRowChangedHandler(this.testResultTree1_SelectedIndexChanged);
			// 
			// panel3
			// 
			this.panel3.BorderStyle = System.Windows.Forms.BorderStyle.FixedSingle;
			this.panel3.Controls.Add(this.chkFilterServers);
			this.panel3.Controls.Add(this.clbServerList);
			this.panel3.Dock = System.Windows.Forms.DockStyle.Left;
			this.panel3.Location = new System.Drawing.Point(0, 0);
			this.panel3.Name = "panel3";
			this.panel3.Size = new System.Drawing.Size(152, 473);
			this.panel3.TabIndex = 4;
			// 
			// chkFilterServers
			// 
			this.chkFilterServers.Location = new System.Drawing.Point(8, 16);
			this.chkFilterServers.Name = "chkFilterServers";
			this.chkFilterServers.Size = new System.Drawing.Size(120, 16);
			this.chkFilterServers.TabIndex = 8;
			this.chkFilterServers.Text = "Filter Server List";
			this.chkFilterServers.CheckedChanged += new System.EventHandler(this.chkFilterServers_CheckedChanged);
			// 
			// clbServerList
			// 
			this.clbServerList.Enabled = false;
			this.clbServerList.Location = new System.Drawing.Point(24, 32);
			this.clbServerList.Name = "clbServerList";
			this.clbServerList.Size = new System.Drawing.Size(120, 109);
			this.clbServerList.TabIndex = 7;
			this.clbServerList.ItemCheck += new System.Windows.Forms.ItemCheckEventHandler(this.clbServerList_ItemCheck);
			// 
			// mainMenu1
			// 
			this.mainMenu1.MenuItems.AddRange(new System.Windows.Forms.MenuItem[] {
																					  this.menuItem1,
																					  this.menuItem12,
																					  this.menuItem3,
																					  this.menuItem2});
			// 
			// menuItem1
			// 
			this.menuItem1.Index = 0;
			this.menuItem1.MenuItems.AddRange(new System.Windows.Forms.MenuItem[] {
																					  this.menuItem5,
																					  this.menuItem6,
																					  this.menuItem7,
																					  this.menuItem8,
																					  this.menuItem10,
																					  this.menuItem9});
			this.menuItem1.Text = "File";
			// 
			// menuItem5
			// 
			this.menuItem5.Enabled = false;
			this.menuItem5.Index = 0;
			this.menuItem5.Text = "New";
			// 
			// menuItem6
			// 
			this.menuItem6.Enabled = false;
			this.menuItem6.Index = 1;
			this.menuItem6.Text = "Open";
			// 
			// menuItem7
			// 
			this.menuItem7.Enabled = false;
			this.menuItem7.Index = 2;
			this.menuItem7.Text = "Save";
			// 
			// menuItem8
			// 
			this.menuItem8.Enabled = false;
			this.menuItem8.Index = 3;
			this.menuItem8.Text = "Save as...";
			// 
			// menuItem10
			// 
			this.menuItem10.Index = 4;
			this.menuItem10.Text = "-";
			// 
			// menuItem9
			// 
			this.menuItem9.Index = 5;
			this.menuItem9.Text = "Exit";
			this.menuItem9.Click += new System.EventHandler(this.menuItem9_Click);
			// 
			// menuItem12
			// 
			this.menuItem12.Index = 1;
			this.menuItem12.MenuItems.AddRange(new System.Windows.Forms.MenuItem[] {
																					   this.menuItem11,
																					   this.menuShowOnlyFailedTests,
																					   this.menuViewFilters});
			this.menuItem12.Text = "View";
			// 
			// menuItem11
			// 
			this.menuItem11.Index = 0;
			this.menuItem11.Text = "Refresh";
			this.menuItem11.Click += new System.EventHandler(this.menuItem11_Click);
			// 
			// menuShowOnlyFailedTests
			// 
			this.menuShowOnlyFailedTests.Index = 1;
			this.menuShowOnlyFailedTests.Text = "Show only failed tests";
			this.menuShowOnlyFailedTests.Click += new System.EventHandler(this.menuShowOnlyFailedTests_Click);
			// 
			// menuViewFilters
			// 
			this.menuViewFilters.Index = 2;
			this.menuViewFilters.Text = "Filters";
			this.menuViewFilters.Click += new System.EventHandler(this.menuViewFilters_Click);
			// 
			// menuItem3
			// 
			this.menuItem3.Index = 2;
			this.menuItem3.MenuItems.AddRange(new System.Windows.Forms.MenuItem[] {
																					  this.menuItem13,
																					  this.menuItem14});
			this.menuItem3.Text = "Admin";
			// 
			// menuItem13
			// 
			this.menuItem13.Index = 0;
			this.menuItem13.Text = "Build Manager...";
			this.menuItem13.Click += new System.EventHandler(this.menuItem13_Click);
			// 
			// menuItem14
			// 
			this.menuItem14.Index = 1;
			this.menuItem14.Text = "TestCase Manager ...";
			this.menuItem14.Click += new System.EventHandler(this.menuItem14_Click);
			// 
			// menuItem2
			// 
			this.menuItem2.Index = 3;
			this.menuItem2.MenuItems.AddRange(new System.Windows.Forms.MenuItem[] {
																					  this.menuItem4});
			this.menuItem2.Text = "Help";
			// 
			// menuItem4
			// 
			this.menuItem4.Index = 0;
			this.menuItem4.Text = "About...";
			this.menuItem4.Click += new System.EventHandler(this.menuItem4_Click);
			// 
			// ViewerForm
			// 
			this.AutoScaleBaseSize = new System.Drawing.Size(5, 13);
			this.ClientSize = new System.Drawing.Size(528, 473);
			this.Controls.Add(this.panel2);
			this.Controls.Add(this.panel3);
			this.Menu = this.mainMenu1;
			this.Name = "ViewerForm";
			this.Text = "RegDB Viewer";
			this.Load += new System.EventHandler(this.ViewerForm_Load);
			this.panel2.ResumeLayout(false);
			this.panel3.ResumeLayout(false);
			this.ResumeLayout(false);

		}
		#endregion

		[STAThread]
		static void Main() 
		{
			Application.Run(new ViewerForm());
		}

		private void ViewerForm_Load(object sender, System.EventArgs e)
		{
			LoadServerList();
			LoadData(null);

			panel3.Visible = menuViewFilters.Checked;
		}

		private void LoadServerList()
		{
			ServerList sl = queryManager.GetServerList();
			clbServerList.Items.Clear();
			foreach (Server s in sl)
				if (s.Servername.Trim() != "")
					clbServerList.Items.Add(s);
		}

		private RegDBQuery GenerateQuery(ItemCheckEventArgs e)
		{
			if (clbServerList.CheckedItems.Count + (e == null ? 0 : (e.NewValue == CheckState.Checked ? 1 : -1)) == 0)
				return null;

			RegDBQuery query = new RegDBQuery();

			if (chkFilterServers.Checked)
			{
				foreach (Server s in clbServerList.CheckedItems)
					query.AddServer(s.ID);
			}

			if (e != null)
			{
				if (e.NewValue == CheckState.Checked)
					query.AddServer(((Server)clbServerList.Items[e.Index]).ID);
				else
					query.RemoveServer(((Server)clbServerList.Items[e.Index]).ID);
			}

			return query;
		}

		private void LoadData(ItemRow selected) {LoadData(selected, GenerateQuery(null));}
		private void LoadData(ItemRow selected, RegDBQuery query)
		{
			ItemRowList root = queryManager.GetItems(query, selected);

			testResultTree1.SuspendLayout();
			testResultTree1.Items.Clear();

			InsertBranch(root, 0);

			testResultTree1.ResumeLayout();
		}

		private int InsertBranch(ItemRowList items, int index)
		{
			foreach (ItemRow item in items)
			{
				if (menuShowOnlyFailedTests.Checked && item.Fail == 0)
					continue;

				testResultTree1.Items.Insert(index, item);
				index++;

				if (item.Children != null && item.Children.Count > 0 && item.SubTreeOpen)
					index = InsertBranch(item.Children, index);
			}

			return index;
		}

		private void menuItem11_Click(object sender, System.EventArgs e)
		{
			testResultTree1.LastSelected = null;
			LoadServerList();
			LoadData(null);
		}

		private void menuItem4_Click(object sender, System.EventArgs e)
		{
			AboutForm af = new AboutForm();
			af.ShowDialog(this);
			af.Dispose();
		}

		private void menuItem9_Click(object sender, System.EventArgs e)
		{
			Close();
		}

		private void chkFilterServers_CheckedChanged(object sender, System.EventArgs e)
		{
			clbServerList.Enabled = chkFilterServers.Checked;
			if (clbServerList.CheckedItems.Count > 0)
				LoadData(null);
		}

		private void clbServerList_ItemCheck(object sender, System.Windows.Forms.ItemCheckEventArgs e)
		{
			LoadData(null, GenerateQuery(e));
		}

		private void menuShowOnlyFailedTests_Click(object sender, System.EventArgs e)
		{
			menuShowOnlyFailedTests.Checked = !menuShowOnlyFailedTests.Checked;
			LoadData(testResultTree1.LastSelected);
		}

		private void menuViewFilters_Click(object sender, System.EventArgs e)
		{
			menuViewFilters.Checked = !menuViewFilters.Checked;
			panel3.Visible = menuViewFilters.Checked;
		}

		private void menuItem13_Click(object sender, System.EventArgs e)
		{
			AdminForm admin = new AdminForm(queryManager);
			admin.ShowDialog(this);
			LoadData(null, GenerateQuery(null));
			admin.Dispose();
		}

		private void menuItem14_Click(object sender, System.EventArgs e)
		{
			AdminTestCase admin = new AdminTestCase(queryManager);
			admin.ShowDialog(this);
			LoadData(null, GenerateQuery(null));
			admin.Dispose();
		}

		private void testResultTree1_SelectedIndexChanged(object sender, RegDBViewer.SelectedRowChangedEventArgs e)
		{
			LoadData(e.Row);
		}
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\SafetyNet\ActivityLibrary1\DeleteDirectory.cs ===
using System;
using System.ComponentModel;
using System.ComponentModel.Design;
using System.Collections;
using System.Drawing;
using System.Workflow.ComponentModel;
using System.Workflow.ComponentModel.Design;
using System.Workflow.ComponentModel.Compiler;
using System.Workflow.ComponentModel.Serialization;
using System.Workflow.Runtime;
using System.Workflow.Activities;
using System.Workflow.Activities.Rules;
using System.IO;
using SafetyNet.Services;

namespace SafetyNet.Activities
{
	public partial class DeleteDirectory: TrackableActivity
    {
        #region Dependency Properties
        public static DependencyProperty TargetProperty = System.Workflow.ComponentModel.DependencyProperty.Register("Target", typeof(string), typeof(DeleteDirectory));

        [Description("This is directory to delete")]
        [Category("General")]
        [Browsable(true)]
        [DesignerSerializationVisibility(DesignerSerializationVisibility.Visible)]
        public string Target
        {
            get
            {
                return ((string)(base.GetValue(DeleteDirectory.TargetProperty)));
            }
            set
            {
                base.SetValue(DeleteDirectory.TargetProperty, value);
            }
        }
        #endregion

        public DeleteDirectory()
		{
			InitializeComponent();
		}

        protected override ActivityExecutionStatus Execute(ActivityExecutionContext executionContext)
        {
            if (Directory.Exists(Target))
            {
                Directory.Delete(Target, true);
            }

            return ActivityExecutionStatus.Closed;
        }
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\RegDBViewer\RegDBQueryManager.cs ===
using System;
using System.Collections;
using System.Data.SqlClient;
using System.Data;
using System.Diagnostics;

namespace RegDBViewer
{
	public class Server
	{
		public string Servername;
		public string ServerDescription;
		public int ID;
		public Server(string name ,int id,string Description)
		{
			Servername=name;
			ID=id;
			ServerDescription=Description;
		}

		public override string ToString()
		{
			return Servername.Trim();
		}
	}

	public class ServerList : CollectionBase
	{
		public void Add(Server a)
		{
			List.Add(a);
		}

		public Server Item(int index)
		{
			return (Server)List[index];
		}
	}


	public class Build
	{
		public string BuildName;
		public string BuildDescription;
		public int ID;
		public Build(string name ,int id,string Description)
		{
			BuildName=name;
			ID=id;
			BuildDescription=Description;
		}

		public override string ToString()
		{
			return BuildName.Trim();
		}
	}

	public class BuildList : CollectionBase
	{
		public void Add(Build a)
		{
			List.Add(a);
		}

		public Build Item(int index)
		{
			return (Build)List[index];
		}
	}


	public class RegDBQueryManager
	{
		ItemRowList items; 
		RegDb  regData;
		const string server = "10.198.102.240";
		
		public void UpdateSrvDescription(int ServerID,string Description)
		{
			regData.UpdateSrvDescription(ServerID,Description);
		}

		public void ReNameBuild(int IterationID,string NewBuildNO,int NewIterationNO,string NewDescription)
		{
			regData.ReNameBuild(IterationID,NewBuildNO,NewIterationNO,NewDescription);
		}

		public void DeleteBuild(int IterationID)
		{
			regData.DeleteBuild(IterationID);
		}

		public void UpdateIterationDescription(int IterationID,string Description)
		{
			regData.UpdateIterationDescription(IterationID,Description);
		}

		
		public RegDBQueryManager()
		{
			regData = new RegDb();
			
		}

		public ServerList GetServerList()
		{
				return regData.GetServerList();
		}
		public BuildList GetBuildList()
		{
			return regData.GetBuildList();
		}

		public ItemRowList GetItems(RegDBQuery query, ItemRow selected)
		{
			if(selected == null)
			{
				items = new ItemRowList();
				items= regData.GetBuildSummary(query);
			}
			else if(selected.Children==null)
			{
				ItemRow temp;
				for (temp = selected;temp.Parent!=null;temp= temp.Parent);
				int iterationID = temp.ID;
				switch(selected.Depth)
				{
					case 0:
						selected.Children= regData.GetSubCompSummary( iterationID,selected,query);
						break;
					case 1:
						selected.Children= regData.GetTestGroupSummary( iterationID,selected.ID,selected);
						break;
					case 2:
						selected.Children= regData.GetTestCaseSummary( iterationID,selected.ID,selected);
						break;
				}
				
			}
			return items; ///LoadBranch(null, selected, "IterationID = {0}", null, new LoadBranchCallback(LoadComponentBranch));
		}

	}


	public class RegDb
	{
		SqlConnection connection= null;
		
		int pass =1;
		//int fail=4;
		ItemRow parent;
		public RegDb()
		{
			
			try
			{
				connection = new SqlConnection("Server=10.198.102.240,3074;Initial Catalog=regdb;user id=regression;password=regression");
				connection.Open();
			}
			catch(System.Exception e)
			{
				string disp = e.ToString();
			}
			
		}

		public ItemRowList GetBuildSummary(RegDBQuery query)
		{
			parent=null;
			SqlCommand sqlCmd= null;
			SqlDataReader sqlReader= null;
			ItemRowList dataRowsList = new ItemRowList();
			try
			{
				sqlCmd = new SqlCommand("sp_BuildsSummary",connection);

				sqlCmd.CommandType= CommandType.StoredProcedure;

				SqlParameter ret = new SqlParameter();
				ret.Direction=ParameterDirection.ReturnValue;
				sqlCmd.Parameters.Add(ret);

				if(query !=null && query.GetServerCount()>0)
				{
					for(int i=0 ; i<query.GetServerCount();i++)
					{
						string param= "@SID"+(1+i);
						sqlCmd.Parameters.Add(param,SqlDbType.Int).Value=query.GetServerAT(i);
					}
				}

				sqlReader =sqlCmd.ExecuteReader();
				while(sqlReader.Read())
				{
					string name = sqlReader.GetString(1)+"("+sqlReader.GetInt32(2)+")";
					string Description = null;
					if (!sqlReader.IsDBNull(5))
						Description = sqlReader.GetString(5);
					
					AddBuildFailItem(sqlReader.GetInt32(0),name,sqlReader.GetInt32(3),sqlReader.GetInt32(4),dataRowsList,0,Description,sqlReader.GetDateTime(6));
				}
			}
			catch(Exception)
			{
				throw;
			}
			finally
			{
				if(sqlReader!=null)
					sqlReader.Close();
			}

			return  dataRowsList;
		}
		
		public ItemRowList GetSubCompSummary(int IterationID,ItemRow Parent,RegDBQuery query)
		{
			parent=Parent;
			Debug.Assert(parent.Parent ==null);
			
			SqlCommand sqlCmd= null;
			SqlDataReader sqlReader= null;
			ItemRowList dataRowsList = new ItemRowList();
			
			try
			{
				sqlCmd = new SqlCommand("sp_SubComponentStatForBuild",connection);
				sqlCmd.CommandType= CommandType.StoredProcedure;

				SqlParameter ret = new SqlParameter();
				ret.Direction=ParameterDirection.ReturnValue;

				sqlCmd.Parameters.Add(ret);
				sqlCmd.Parameters.Add("@IterationID",SqlDbType.Int).Value=IterationID;
				
				if(query !=null && query.GetServerCount()>0)
				{
					for(int i=0 ; i<query.GetServerCount();i++)
					{
						string param= "@SID"+(1+i);
						sqlCmd.Parameters.Add(param,SqlDbType.Int).Value=query.GetServerAT(i);
					}
				}
			

				sqlReader =sqlCmd.ExecuteReader();
				while(sqlReader.Read())
				{
					AddSubCompItem(sqlReader.GetInt32(0),sqlReader.GetString(1),sqlReader.GetInt32(2),sqlReader.GetInt32(3),dataRowsList,1);
					
				}

			}
			catch(Exception)
			{
				throw;
			}
			finally
			{
				if(sqlReader!=null)
					sqlReader.Close();
			}
			return  dataRowsList;
		}
		public ItemRowList GetTestGroupSummary(int IterationID,int SubCompID,ItemRow Parent)
		{
			parent=Parent;
			SqlCommand sqlCmd= null;
			SqlDataReader sqlReader= null;
			ItemRowList dataRowsList = new ItemRowList();
			
			try
			{
				sqlCmd = new SqlCommand("sp_TestGroupStatForBuild",connection);
				sqlCmd.CommandType= CommandType.StoredProcedure;

				SqlParameter ret = new SqlParameter();
				ret.Direction=ParameterDirection.ReturnValue;

				sqlCmd.Parameters.Add(ret);
				sqlCmd.Parameters.Add("@IterationID",SqlDbType.Int).Value=IterationID;
				sqlCmd.Parameters.Add("@SubCompID",SqlDbType.Int).Value=SubCompID;

				sqlReader =sqlCmd.ExecuteReader();
				while(sqlReader.Read())
				{
					if(sqlReader.GetInt32(2)== pass)
						AddPassItem(sqlReader.GetInt32(0),sqlReader.GetString(1),sqlReader.GetInt32(3),dataRowsList,2);
					else
						AddFailItem(sqlReader.GetInt32(0),sqlReader.GetString(1),sqlReader.GetInt32(3),dataRowsList,2);

				}

			}
			catch(Exception)
			{
				throw ;
			}
			finally
			{
				if(sqlReader!=null)
					sqlReader.Close();
			}
			return  dataRowsList;
		}
		public ItemRowList GetTestCaseSummary(int IterationID,int TestGroupID,ItemRow Parent)
		{
			parent=Parent;
			SqlCommand sqlCmd= null;
			SqlDataReader sqlReader= null;
			ItemRowList dataRowsList = new ItemRowList();
			
			try
			{
				sqlCmd = new SqlCommand("sp_TestCaseStatForBuild",connection);
				sqlCmd.CommandType= CommandType.StoredProcedure;

				SqlParameter ret = new SqlParameter();
				ret.Direction=ParameterDirection.ReturnValue;

				sqlCmd.Parameters.Add(ret);
				sqlCmd.Parameters.Add("@IterationID",SqlDbType.Int).Value=IterationID;
				sqlCmd.Parameters.Add("@TestGroupID",SqlDbType.Int).Value=TestGroupID;

				sqlReader =sqlCmd.ExecuteReader();
				while(sqlReader.Read())
				{
					string result=null;
					
					if (!sqlReader.IsDBNull(3))
						result =sqlReader.GetString(3);
					
					if(sqlReader.GetInt32(2)== pass)
						AddTestCasePassItem(sqlReader.GetInt32(0),sqlReader.GetString(1),1,dataRowsList,3,result,0);
					else
						AddTestCaseFailItem(sqlReader.GetInt32(0),sqlReader.GetString(1),1,dataRowsList,3,result,0);

				}

			}
			catch(Exception )
			{
				throw ;
			}
			finally
			{
				if(sqlReader!=null)
					sqlReader.Close();
			}
			return  dataRowsList;
		}
		

		public ServerList GetServerList()
		{
			ServerList SrvList = new ServerList();
			
			SqlCommand sqlCmd= null;
			SqlDataReader sqlReader= null;
			try
			{
				sqlCmd = new SqlCommand("Select * from SubComponent",connection);
				sqlReader =sqlCmd.ExecuteReader();
				while(sqlReader.Read())
				{
					string Description=null;
					if (!sqlReader.IsDBNull(1))
						Description =sqlReader.GetString(1);

					SrvList.Add(new Server(sqlReader.GetString(2), sqlReader.GetInt32(0),Description));	
				}

			}
			catch(Exception e)
			{
				// log exception to a file.
				throw e;
			}
			finally
			{
				if(sqlReader!=null)
					sqlReader.Close();
			}
			
			return SrvList;
		}

		public BuildList GetBuildList()
		{
			BuildList bldList = new BuildList();
			
			SqlCommand sqlCmd= null;
			SqlDataReader sqlReader= null;
			try
			{
				sqlCmd = new SqlCommand("Select * from Iteration",connection);
				sqlReader =sqlCmd.ExecuteReader();
				while(sqlReader.Read())
				{
					string Description=null;
					if (!sqlReader.IsDBNull(4))
						Description =sqlReader.GetString(4);

					bldList.Add(new Build(sqlReader.GetString(1)+"("+sqlReader.GetSqlInt32(2)+")", sqlReader.GetInt32(0),Description));	
				}
			}
			catch(Exception e)
			{
				// log exception to a file.
				throw e;
			}
			finally
			{
				if(sqlReader!=null)
					sqlReader.Close();
			}
			
			return bldList;

		}

		
		public void ReNameBuild(int IterationID,string NewBuildNO,int NewIterationNO,string NewDescription)
		{
			SqlCommand sqlCmd= null;
									
			try
			{
				sqlCmd = new SqlCommand("sp_BuildRename",connection);
				sqlCmd.CommandType= CommandType.StoredProcedure;

				SqlParameter ret = new SqlParameter();
				ret.Direction=ParameterDirection.ReturnValue;

				sqlCmd.Parameters.Add(ret);
				sqlCmd.Parameters.Add("@ItnIDToRename",SqlDbType.Int).Value=IterationID;
				sqlCmd.Parameters.Add("@BuildNew",SqlDbType.Char).Value=NewBuildNO;
				sqlCmd.Parameters.Add("@ItnoNew",SqlDbType.Int).Value=NewIterationNO;
				sqlCmd.Parameters.Add("@BuildDescription",SqlDbType.Char).Value=NewDescription;
				
				
				int rowsaffected =sqlCmd.ExecuteNonQuery();
				if(rowsaffected <=0)
					throw new Exception("Update failed to rename build");
				

			}
			catch(Exception)
			{
				throw;
			}
			finally
			{
				if(sqlCmd!=null)
					sqlCmd.Dispose();
			}
			
		}

		public void UpdateSrvDescription(int ServerID,string Description)
		{
						
			SqlCommand sqlCmd= null;
			
			try
			{
				string Query = "update [SubComponent] Set [SubCompDescription]='"+Description+"' where [SubCompID]="+ServerID;
				sqlCmd = new SqlCommand(Query,connection);
				int RowsAffected =sqlCmd.ExecuteNonQuery();

				if(RowsAffected !=1)
					throw new Exception("Update failed" );

				

			}
			catch(Exception e)
			{
				// log exception to a file.
				throw e;
			}
			finally
			{
				if(sqlCmd!=null)
					sqlCmd.Dispose();
			}
			
			

		}

		public void DeleteBuild(int IterationID)
		{
			SqlCommand sqlCmd= null;
					
			try
			{
				sqlCmd = new SqlCommand("sp_DeleteIteration",connection);
				sqlCmd.CommandType= CommandType.StoredProcedure;

				SqlParameter ret = new SqlParameter();
				ret.Direction=ParameterDirection.ReturnValue;

				sqlCmd.Parameters.Add(ret);
				sqlCmd.Parameters.Add("@IterationID",SqlDbType.Int).Value=IterationID;
				

				sqlCmd.ExecuteNonQuery();
				

			}
			catch(Exception )
			{
				throw ;
			}
			finally
			{
				if(sqlCmd!=null)
					sqlCmd.Dispose();
			}
			
		}

		public void UpdateIterationDescription(int IterationID,string Description)
		{
						
			SqlCommand sqlCmd= null;
			
			try
			{
				string Query = "update [Iteration] Set [Description]='"+Description+"' where [IterationID]="+IterationID;
				sqlCmd = new SqlCommand(Query,connection);
				int RowsAffected =sqlCmd.ExecuteNonQuery();

				

			}
			catch(Exception e)
			{
				// log exception to a file.
				throw e;
			}
			finally
			{
				if(sqlCmd!=null)
					sqlCmd.Dispose();
			}
			
			

		}

		protected void AddSubCompItem(int ID , string Name, int Passcount,int FailCount,ItemRowList dataRowsList,int Depth)
		{
			ItemRow temp= new ItemRow();
			temp.ID=ID;
			temp.Name=Name;
			temp.Pass=Passcount;
			temp.Fail=FailCount;
			temp.Parent=parent;
			temp.Depth=Depth;
			dataRowsList.Add(temp);
		}
		protected void AddPassItem(int ID , string Name, int count,ItemRowList dataRowsList,int Depth)
		{
			bool found= false;
			for (int i=0;i<dataRowsList.Count;i++)
			{
				if(dataRowsList.Item(i).ID == ID)
				{
					dataRowsList.Item(i).Pass=count;
					found= true;
					break;
				}
			}
			if(!found)
			{
				ItemRow temp= new ItemRow();
				temp.ID=ID;
				temp.Name=Name;
				temp.Pass=count;
				temp.Parent=parent;
				temp.Depth=Depth;
				dataRowsList.Add(temp);
			}
		}
								
		protected void AddFailItem(int ID , string Name, int count,ItemRowList dataRowsList, int Depth)
		{
			bool found= false;
			for (int i=0;i<dataRowsList.Count;i++)
			{
				if(dataRowsList.Item(i).ID == ID)
				{
					dataRowsList.Item(i).Fail=count;
					found= true;
					break;
				}
			}
			if(!found)
			{
				ItemRow temp= new ItemRow();
				temp.ID=ID;
				temp.Name=Name;
				temp.Fail=count;
				temp.Parent=parent;
				temp.Depth=Depth;
				dataRowsList.Add(temp);
			}
		}


		protected void AddBuildFailItem(int ID , string Name, int PassCount,int FailCount,ItemRowList dataRowsList,int Depth,string Description,DateTime Date)
		{
			IterationRow temp= new IterationRow();
			temp.ID=ID;
			temp.Name=Name;
			temp.Pass=PassCount;
			temp.Fail=FailCount;
			temp.Parent=parent;
			temp.Depth=Depth;
			temp.Description=Description;
			temp.StartTime=Date;
			dataRowsList.Add(temp);

		}
		
		protected void AddTestCasePassItem(int ID , string Name, int count,ItemRowList dataRowsList,int Depth,string ResultDetails,int BugID)
		{
			bool found= false;
			for (int i=0;i<dataRowsList.Count;i++)
			{
				if(dataRowsList.Item(i).ID == ID)
				{
					dataRowsList.Item(i).Pass=count;
					found= true;
					break;
				}
			}
			if(!found)
			{
				TestCaseRow temp= new TestCaseRow();
				temp.ID=ID;
				temp.Name=Name;
				temp.Pass=count;
				temp.Parent=parent;
				temp.Depth=Depth;
				temp.ResultDetails=ResultDetails;
				temp.BugID=BugID;
				dataRowsList.Add(temp);
			}
		}
								
		protected void AddTestCaseFailItem(int ID , string Name, int count,ItemRowList dataRowsList, int Depth, string ResultDetails,int BugID)
		{
			bool found= false;
			for (int i=0;i<dataRowsList.Count;i++)
			{
				if(dataRowsList.Item(i).ID == ID)
				{
					dataRowsList.Item(i).Fail=count;
					found= true;
					break;
				}
			}
			if(!found)
			{
				TestCaseRow temp= new TestCaseRow();
				temp.ID=ID;
				temp.Name=Name;
				temp.Fail=count;
				temp.Parent=parent;
				temp.Depth=Depth;
				temp.ResultDetails=ResultDetails;
				temp.BugID=BugID;
				dataRowsList.Add(temp);
			}
		}
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\SafetyNet\ActivityLibrary1\CreateSTFCmdLine.cs ===
using System;
using System.ComponentModel;
using System.Workflow.ComponentModel;

namespace SafetyNet.Activities
{
	public partial class CreateSTFCmdLine: Activity
    {
        #region Dependency Properties
        public static DependencyProperty SuiteNameProperty = System.Workflow.ComponentModel.DependencyProperty.Register("SuiteName", typeof(string), typeof(CreateSTFCmdLine));

        [Description("STF Suite DLL name")]
        [Category("General")]
        [Browsable(true)]
        [DesignerSerializationVisibility(DesignerSerializationVisibility.Visible)]
        public string SuiteName
        {
            get
            {
                return ((string)(base.GetValue(CreateSTFCmdLine.SuiteNameProperty)));
            }
            set
            {
                base.SetValue(CreateSTFCmdLine.SuiteNameProperty, value);
            }
        }

        public static DependencyProperty BuildProperty = System.Workflow.ComponentModel.DependencyProperty.Register("Build", typeof(string), typeof(CreateSTFCmdLine));

        [Description("Build Name/Number")]
        [Category("General")]
        [Browsable(true)]
        [DesignerSerializationVisibility(DesignerSerializationVisibility.Visible)]
        public string Build
        {
            get
            {
                return ((string)(base.GetValue(CreateSTFCmdLine.BuildProperty)));
            }
            set
            {
                base.SetValue(CreateSTFCmdLine.BuildProperty, value);
            }
        }

        public static DependencyProperty IterationProperty = System.Workflow.ComponentModel.DependencyProperty.Register("Iteration", typeof(int), typeof(CreateSTFCmdLine));

        [Description("Iteration")]
        [Category("General")]
        [Browsable(true)]
        [DesignerSerializationVisibility(DesignerSerializationVisibility.Visible)]
        public int Iteration
        {
            get
            {
                return ((int)(base.GetValue(CreateSTFCmdLine.IterationProperty)));
            }
            set
            {
                base.SetValue(CreateSTFCmdLine.IterationProperty, value);
            }
        }

        public static DependencyProperty EnvironmentProperty = System.Workflow.ComponentModel.DependencyProperty.Register("Environment", typeof(string), typeof(CreateSTFCmdLine));

        [Description("Environment")]
        [Category("General")]
        [Browsable(true)]
        [DesignerSerializationVisibility(DesignerSerializationVisibility.Visible)]
        public string Environment
        {
            get
            {
                return ((string)(base.GetValue(CreateSTFCmdLine.EnvironmentProperty)));
            }
            set
            {
                base.SetValue(CreateSTFCmdLine.EnvironmentProperty, value);
            }
        }
        #endregion

        #region Output properties 

        private string commandLine;

        [Category("General")]
        public string CommandLine
        {
            get { return commandLine; }
        }
        
        #endregion
        
        public CreateSTFCmdLine()
		{
			InitializeComponent();
		}

        protected override ActivityExecutionStatus Execute(ActivityExecutionContext executionContext)
        {

            commandLine = String.Format(@"suites\{0}.dll -plugparam:functionalplugin:autorun -plugparam:regdbplugin:logversion:{1}.{2:0000} -plugparam:environmentplugin:env:{3} -IgnoreDefaultPlugins STFGuiPluginFunctional.dll STFGuiPluginEnvironment.dll STFGuiPluginRegDB.dll", this.SuiteName, this.Build, this.Iteration, this.Environment);
            return ActivityExecutionStatus.Closed;
        }
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\SafetyNet\ActivityLibrary1\RunProgramActivity.cs ===
using System;
using System.ComponentModel;
using System.Diagnostics;
using System.Workflow.ComponentModel;
using System.Workflow.Runtime;
using SafetyNet.Services;

namespace SafetyNet.Activities
{
	public partial class RunProgramActivity: Activity
    {
        #region Dependency Properties
        public static DependencyProperty FileNameProperty = DependencyProperty.Register("FileName",
              typeof(string), typeof(RunProgramActivity));
  
        [Description("File name of executable run")]
        [Category("General")]
        [Browsable(true)]
        [DesignerSerializationVisibility(DesignerSerializationVisibility.Visible)]
        public string FileName
        {
	        get 
            { 
              return ((string)(base.GetValue(RunProgramActivity.FileNameProperty))); 
            }
            set 
            { 
              base.SetValue(RunProgramActivity.FileNameProperty, value); 
            }
        }

        public static DependencyProperty ArgumentsProperty = System.Workflow.ComponentModel.DependencyProperty.Register("Arguments",
               typeof(string), typeof(RunProgramActivity));

        [Description("Arguments to the program")]
        [Category("General")]
        [Browsable(true)]
        [DesignerSerializationVisibility(DesignerSerializationVisibility.Visible)]
        public string Arguments
        {
            get
            {
                return ((string)(base.GetValue(RunProgramActivity.ArgumentsProperty)));
            }
            set
            {
                base.SetValue(RunProgramActivity.ArgumentsProperty, value);
            }
        }

        public static DependencyProperty WorkingDirectoryProperty = System.Workflow.ComponentModel.DependencyProperty.Register("WorkingDirectory", typeof(string), typeof(RunProgramActivity));

        [Description("Working directory of the program")]
        [Category("General")]
        [Browsable(true)]
        [DesignerSerializationVisibility(DesignerSerializationVisibility.Visible)]
        public string WorkingDirectory
        {
            get
            {
                return ((string)(base.GetValue(RunProgramActivity.WorkingDirectoryProperty)));
            }
            set
            {
                base.SetValue(RunProgramActivity.WorkingDirectoryProperty, value);
            }
        }

        public static DependencyProperty ExitCodeProperty = System.Workflow.ComponentModel.DependencyProperty.Register("ExitCode", typeof(int), typeof(RunProgramActivity));

        [Description("Exit Code of the program")]
        [Category("General")]
        [Browsable(true)]
        [DesignerSerializationVisibility(DesignerSerializationVisibility.Visible)]
        public int ExitCode
        {
            get
            {
                return ((int)(base.GetValue(RunProgramActivity.ExitCodeProperty)));
            }
            set
            {
                base.SetValue(RunProgramActivity.ExitCodeProperty, value);
            }
        }
        #endregion

        #region Private Data
        private string runId;
        #endregion

        protected override ActivityExecutionStatus Execute(ActivityExecutionContext executionContext)
        {
            WorkflowQueuingService qService = executionContext.GetService<WorkflowQueuingService>();
            runId =  Name + Guid.NewGuid();
            WorkflowQueue queue= qService.CreateWorkflowQueue(runId, true);
            queue.QueueItemAvailable += ProcessExited;

            RunProgramService runProgramService = executionContext.GetService<RunProgramService>();
            ProcessStartInfo psi = new ProcessStartInfo(FileName, Arguments);
            psi.WorkingDirectory = WorkingDirectory;
            //psi.UseShellExecute = false;
            runProgramService.StartProcess(runId, psi);

            return ActivityExecutionStatus.Executing;
        }

        void ProcessExited(object sender, QueueEventArgs e)
        {
            ActivityExecutionContext context = sender as ActivityExecutionContext;
            DeleteQueue(context);
            context.CloseActivity();
        }

        private void DeleteQueue(ActivityExecutionContext context)
        {
            WorkflowQueuingService qService = context.GetService<WorkflowQueuingService>();
            WorkflowQueue queue = qService.GetWorkflowQueue(runId);
            ExitCode = (int)queue.Dequeue();
            queue.QueueItemAvailable -= ProcessExited;
            qService.DeleteWorkflowQueue(runId);
        }

        public RunProgramActivity()
        {
            InitializeComponent();
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\SafetyNet\ActivityLibrary1\TestRunActivity.cs ===
using System.Configuration;
using System.Workflow.Activities;

namespace SafetyNet.Activities
{
	public partial class TestRunActivity: SequentialWorkflowActivity
	{
		public TestRunActivity()
		{
			InitializeComponent();
		    targetDirectory = ConfigurationManager.AppSettings["TargetDirectory"];
		}

        private string targetDirectory;

        public string TargetDirectory
        {
            get { return targetDirectory; }
        }

        private int iteration;

        public int Iteration
        {
            get { return iteration; }
            set { iteration = value; }
        }

        private string build;
	    
        public string Build
        {
            get { return build; }
            set { build = value; }
        }

        private string environmentAddress;
        
        public string Environment
	    {
	        get { return environmentAddress; }
	        set { environmentAddress = value; }
	    }
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\SafetyNet\ActivityLibrary1\RunProgramActivity.Designer.cs ===
using System;
using System.ComponentModel;
using System.ComponentModel.Design;
using System.Collections;
using System.Drawing;
using System.Reflection;
using System.Workflow.ComponentModel;
using System.Workflow.ComponentModel.Design;
using System.Workflow.ComponentModel.Compiler;
using System.Workflow.ComponentModel.Serialization;
using System.Workflow.Runtime;
using System.Workflow.Activities;
using System.Workflow.Activities.Rules;

namespace SafetyNet.Activities
{
	public partial class RunProgramActivity
	{
		#region Designer generated code
		
		/// <summary> 
		/// Required method for Designer support - do not modify 
		/// the contents of this method with the code editor.
		/// </summary>
        [System.Diagnostics.DebuggerNonUserCode]
		private void InitializeComponent()
		{
			this.Name = "RunProgramActivity";
		}

		#endregion
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\SafetyNet\ActivityLibrary1\RunStfTest.xoml.cs ===
using System;
using System.ComponentModel;
using System.ComponentModel.Design;
using System.Collections;
using System.Drawing;
using System.Workflow.ComponentModel.Compiler;
using System.Workflow.ComponentModel.Serialization;
using System.Workflow.ComponentModel;
using System.Workflow.ComponentModel.Design;
using System.Workflow.Runtime;
using System.Workflow.Activities;
using System.Workflow.Activities.Rules;

namespace SafetyNet.Activities
{
	public partial class RunStfTest : SequenceActivity
	{
        #region Dependency Properties
        public static DependencyProperty SuiteNameProperty = System.Workflow.ComponentModel.DependencyProperty.Register("SuiteName", typeof(string), typeof(RunStfTest));

        [Description("STF Suite DLL name")]
        [Category("General")]
        [Browsable(true)]
        [DesignerSerializationVisibility(DesignerSerializationVisibility.Visible)]
        public string SuiteName
        {
            get
            {
                return ((string)(base.GetValue(SuiteNameProperty)));
            }
            set
            {
                base.SetValue(SuiteNameProperty, value);
            }
        }

        public static DependencyProperty BuildProperty = System.Workflow.ComponentModel.DependencyProperty.Register("Build", typeof(string), typeof(RunStfTest));

        [Description("Build Name/Number")]
        [Category("General")]
        [Browsable(true)]
        [DesignerSerializationVisibility(DesignerSerializationVisibility.Visible)]
        public string Build
        {
            get
            {
                return ((string)(base.GetValue(BuildProperty)));
            }
            set
            {
                base.SetValue(BuildProperty, value);
            }
        }

        public static DependencyProperty IterationProperty = System.Workflow.ComponentModel.DependencyProperty.Register("Iteration", typeof(int), typeof(RunStfTest));

        [Description("Iteration")]
        [Category("General")]
        [Browsable(true)]
        [DesignerSerializationVisibility(DesignerSerializationVisibility.Visible)]
        public int Iteration
        {
            get
            {
                return ((int)(base.GetValue(IterationProperty)));
            }
            set
            {
                base.SetValue(IterationProperty, value);
            }
        }

        public static DependencyProperty TargetDirectoryProperty = System.Workflow.ComponentModel.DependencyProperty.Register("TargetDirectory", typeof(string), typeof(RunStfTest));

        [Description("Directory in which STF binaries are located")]
        [Category("General")]
        [Browsable(true)]
        [DesignerSerializationVisibility(DesignerSerializationVisibility.Visible)]
        public string TargetDirectory
        {
            get
            {
                return ((string)(base.GetValue(RunStfTest.TargetDirectoryProperty)));
            }
            set
            {
                base.SetValue(RunStfTest.TargetDirectoryProperty, value);
            }
        }

        public static DependencyProperty EnvironmentProperty = System.Workflow.ComponentModel.DependencyProperty.Register("Environment", typeof(string), typeof(RunStfTest));

        [Description("Test Environment name")]
        [Category("General")]
        [Browsable(true)]
        [DesignerSerializationVisibility(DesignerSerializationVisibility.Visible)]
        public string Environment
        {
            get
            {
                return ((string)(base.GetValue(RunStfTest.EnvironmentProperty)));
            }
            set
            {
                base.SetValue(RunStfTest.EnvironmentProperty, value);
            }
        }
        #endregion

        private void ExitCodeNonZero(object sender, ConditionalEventArgs e)
        {
            e.Result = (((RunProgramActivity)this.Activities["RunStf"]).ExitCode != 0);
        }
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\SafetyNet\ActivityLibrary1\DeleteDirectory.Designer.cs ===
using System;
using System.ComponentModel;
using System.ComponentModel.Design;
using System.Collections;
using System.Drawing;
using System.Reflection;
using System.Workflow.ComponentModel;
using System.Workflow.ComponentModel.Design;
using System.Workflow.ComponentModel.Compiler;
using System.Workflow.ComponentModel.Serialization;
using System.Workflow.Runtime;
using System.Workflow.Activities;
using System.Workflow.Activities.Rules;

namespace SafetyNet.Activities
{
	public partial class DeleteDirectory
	{
		#region Designer generated code
		
		/// <summary> 
		/// Required method for Designer support - do not modify 
		/// the contents of this method with the code editor.
		/// </summary>
        [System.Diagnostics.DebuggerNonUserCode]
		private void InitializeComponent()
		{
			this.Name = "DeleteDirectory";
		}

		#endregion
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\SafetyNet\ActivityLibrary1\TestRunActivity.Designer.cs ===
using System;
using System.ComponentModel;
using System.ComponentModel.Design;
using System.Collections;
using System.Drawing;
using System.Reflection;
using System.Workflow.ComponentModel;
using System.Workflow.ComponentModel.Design;
using System.Workflow.ComponentModel.Compiler;
using System.Workflow.ComponentModel.Serialization;
using System.Workflow.Runtime;
using System.Workflow.Activities;
using System.Workflow.Activities.Rules;

namespace SafetyNet.Activities
{
	public partial class TestRunActivity
	{
		#region Designer generated code
		
		/// <summary> 
		/// Required method for Designer support - do not modify 
		/// the contents of this method with the code editor.
		/// </summary>
        [System.Diagnostics.DebuggerNonUserCode]
		private void InitializeComponent()
		{
			this.Name = "TestRunActivity";
		}

		#endregion
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\SafetyNet\SafetyNet.Admin\CreateRun.aspx.cs ===
using System;
using System.Data;
using System.Configuration;
using System.Collections;
using System.Web;
using System.Web.Security;
using System.Web.UI;
using System.Web.UI.WebControls;
using System.Web.UI.WebControls.WebParts;
using System.Web.UI.HtmlControls;
using SafetyNet.DAL;

public partial class CreateRun : System.Web.UI.Page
{
    protected void Page_Load(object sender, EventArgs e)
    {


    }
    protected void CreateButton_Click(object sender, EventArgs e)
    {
        RunBuilder rb = new RunBuilder();
        rb.Build = CreateBuild.Text;
        rb.Iteration = Convert.ToInt32(CreateIteration.Text);
        rb.Environment = CreateEnvironment.SelectedValue;
        foreach (ListItem item in TestSuites.Items)
            if(item.Selected)
                rb.AddStfSuite(item.Text, item.Value);
        
        DbTaskSource db = new DbTaskSource(ConfigurationManager.ConnectionStrings["RegDB"].ConnectionString);
        db.CreateTask(CreateName.Text, rb.BuildXoml());
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\SafetyNet\ActivityLibrary1\ThrowMessageActivity.cs ===
using System;
using System.ComponentModel;
using System.ComponentModel.Design;
using System.Collections;
using System.Drawing;
using System.Workflow.ComponentModel;
using System.Workflow.ComponentModel.Design;
using System.Workflow.ComponentModel.Compiler;
using System.Workflow.ComponentModel.Serialization;
using System.Workflow.Runtime;
using System.Workflow.Activities;
using System.Workflow.Activities.Rules;

namespace SafetyNet.Activities
{
	public partial class ThrowMessageActivity: Activity
	{
        public static DependencyProperty MessageProperty = System.Workflow.ComponentModel.DependencyProperty.Register("Message", typeof(string), typeof(ThrowMessageActivity));

        [Description("Exception Message")]
        [Category("General")]
        [Browsable(true)]
        [DesignerSerializationVisibility(DesignerSerializationVisibility.Visible)]
        public string Message
        {
            get
            {
                return ((string)(base.GetValue(ThrowMessageActivity.MessageProperty)));
            }
            set
            {
                base.SetValue(ThrowMessageActivity.MessageProperty, value);
            }
        }

		public ThrowMessageActivity()
		{
			InitializeComponent();
		}

        protected override ActivityExecutionStatus Execute(ActivityExecutionContext executionContext)
        {
            throw new Exception(Message);
        }
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\SafetyNet\SafetyNet.Admin\RunAdmin.aspx.cs ===
using System;
using System.Data;
using System.Configuration;
using System.Collections;
using System.Web;
using System.Web.Security;
using System.Web.UI;
using System.Web.UI.WebControls;
using System.Web.UI.WebControls.WebParts;
using System.Web.UI.HtmlControls;

public partial class RunAdmin : System.Web.UI.Page
{
    protected void Page_Load(object sender, EventArgs e)
    {

    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\SafetyNet\ActivityLibrary1\ThrowMessageActivity.Designer.cs ===
using System;
using System.ComponentModel;
using System.ComponentModel.Design;
using System.Collections;
using System.Drawing;
using System.Reflection;
using System.Workflow.ComponentModel;
using System.Workflow.ComponentModel.Design;
using System.Workflow.ComponentModel.Compiler;
using System.Workflow.ComponentModel.Serialization;
using System.Workflow.Runtime;
using System.Workflow.Activities;
using System.Workflow.Activities.Rules;

namespace SafetyNet.Activities
{
	public partial class ThrowMessageActivity
	{
		#region Designer generated code
		
		/// <summary> 
		/// Required method for Designer support - do not modify 
		/// the contents of this method with the code editor.
		/// </summary>
        [System.Diagnostics.DebuggerNonUserCode]
		private void InitializeComponent()
		{
			this.Name = "ThrowMessageActivity";
		}

		#endregion
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\SafetyNet\SafetyNet.Admin\TaskDetail.aspx.cs ===
using System;
using System.Data;
using System.Configuration;
using System.Collections;
using System.Web;
using System.Web.Security;
using System.Web.UI;
using System.Web.UI.WebControls;
using System.Web.UI.WebControls.WebParts;
using System.Web.UI.HtmlControls;

public partial class TaskDetail : System.Web.UI.Page
{
    protected void Page_Load(object sender, EventArgs e)
    {

    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\SafetyNet\ActivityLibrary1\Properties\Settings.Designer.cs ===
//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//     Runtime Version:2.0.50727.1433
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------

namespace SafetyNet.Activities.Properties {
    
    
    [global::System.Runtime.CompilerServices.CompilerGeneratedAttribute()]
    [global::System.CodeDom.Compiler.GeneratedCodeAttribute("Microsoft.VisualStudio.Editors.SettingsDesigner.SettingsSingleFileGenerator", "9.0.0.0")]
    internal sealed partial class Settings : global::System.Configuration.ApplicationSettingsBase {
        
        private static Settings defaultInstance = ((Settings)(global::System.Configuration.ApplicationSettingsBase.Synchronized(new Settings())));
        
        public static Settings Default {
            get {
                return defaultInstance;
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\SafetyNet\ActivityLibrary1\Properties\AssemblyInfo.cs ===
#region Using directives

using System.Reflection;
using System.Runtime.CompilerServices;

#endregion

// General Information about an assembly is controlled through the following 
// set of attributes. Change these attribute values to modify the information
// associated with an assembly.
[assembly: AssemblyTitle("ActivityLibrary1")]
[assembly: AssemblyDescription("")]
[assembly: AssemblyConfiguration("")]
[assembly: AssemblyCompany("MS")]
[assembly: AssemblyProduct("ActivityLibrary1")]
[assembly: AssemblyCopyright("Copyright  MS 2007")]
[assembly: AssemblyTrademark("")]
[assembly: AssemblyCulture("")]

// Version information for an assembly consists of the following four values:
//
//      Major Version
//      Minor Version 
//      Build Number
//      Revision
//
// You can specify all the values or you can default the Revision and Build Numbers 
// by using '*'.
[assembly: AssemblyVersion("1.0.0.0")]

//NOTE: When updating the namespaces in the project please add new or update existing the XmlnsDefinitionAttribute
//You can add additional attributes in order to map any additional namespaces you have in the project
//[assembly: System.Workflow.ComponentModel.Serialization.XmlnsDefinition("http://schemas.com/ActivityLibrary1", "ActivityLibrary1")]
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\SafetyNet\SafetyNet.Admin\TaskStatus.aspx.cs ===
using System;
using System.Data;
using System.Configuration;
using System.Collections;
using System.Web;
using System.Web.Security;
using System.Web.UI;
using System.Web.UI.WebControls;
using System.Web.UI.WebControls.WebParts;
using System.Web.UI.HtmlControls;

public partial class DragDropTest2 : System.Web.UI.Page
{
    protected void Page_Load(object sender, EventArgs e)
    {
        DataSource.SetInstance(new Guid(this.Request.Params["Id"]));
    }

    protected void ActivitiesGridView_SelectedIndexChanged(object sender, EventArgs e)
    {
        DataSource.SetInstance(new Guid(this.Request.Params["Id"]), ActivitiesGridView.SelectedRow.Cells[2].Text);
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\SafetyNet\SafetyNet.Admin\TaskManagement.aspx.cs ===
using System;
using System.Data;
using System.Data.SqlClient;
using System.Configuration;
using System.Collections.Generic;
using System.Web;
using System.Web.Security;
using System.Web.UI;
using System.Web.UI.WebControls;
using System.Web.UI.WebControls.WebParts;
using System.Web.UI.HtmlControls;
using SafetyNet.DAL;

public partial class AutomatedFunctionals_TaskManagement : System.Web.UI.Page
{
    protected void Page_Load (object sender, EventArgs e)
    {
        {
            DataBind();
        }
    }

    protected void CreatedView_RowCommand(object sender, GridViewCommandEventArgs e)
    {
        if (e.CommandName == "Ready")
        {
            int index = Convert.ToInt32(e.CommandArgument);
            int taskId = Convert.ToInt32(CreatedView.DataKeys[index].Value);
            DbTaskSource ts = new DbTaskSource();
            ts.SetTaskStatus(taskId, TaskStatus.Ready);
            DataBind();
        }
    }
    protected void ReadyView_RowCommand(object sender, GridViewCommandEventArgs e)
    {
        if (e.CommandName == "Inactive")
        {
            GridView view = sender as GridView;
            int index = Convert.ToInt32(e.CommandArgument);
            int taskId = Convert.ToInt32(view.DataKeys[index].Value);
            DbTaskSource ts = new DbTaskSource();
            ts.SetTaskStatus(taskId, TaskStatus.Created);
            DataBind();
        }

    }

    protected void CompletedView_RowCommand(object sender, GridViewCommandEventArgs e)
    {
        GridView view = sender as GridView;
        int index = Convert.ToInt32(e.CommandArgument);
        int taskId = Convert.ToInt32(view.DataKeys[index].Value);
        if (e.CommandName == "Ready")
        {
            DbTaskSource ts = new DbTaskSource();
            ts.SetTaskStatus(taskId, TaskStatus.Ready);
            DataBind();
        }
        else if (e.CommandName == "Archive")
        {
            DbTaskSource ts = new DbTaskSource();
            ts.SetTaskStatus(taskId, TaskStatus.Archived);
            DataBind();
        }

    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\SafetyNet\SafetyNet.Admin\App_Code\CustomActionForm.cs ===
using System;
using System.Data;
using System.Configuration;
using System.Reflection;
using System.Web;
using System.Web.Security;
using System.Web.UI;
using System.Web.UI.WebControls;
using System.Web.UI.WebControls.WebParts;
using System.Web.UI.HtmlControls;

namespace AutomatedFunctionals
{
    public class RegDB
    {
        public static string ConnectionString
        {
            get { return ConfigurationManager.ConnectionStrings["RegDB"].ConnectionString; }
        }
    }

    public class Task
    {
        public int TaskId;
        public byte Status;
        public string Name;

        public Task (int taskid, string name, byte status)
        {
            TaskId = taskid;
            Status = status;
            Name = name;
        }
    }

    /// <summary>
    /// Allows an action attribute to be specified for the form.
    /// </summary>
    public class CustomActionForm : HtmlForm
    {
//        public string Action
//        {
//            get
//            {
//                return Attributes["action"];
//            }
//            set
//            {
//                Attributes["action"] = ResolveUrl(value);
//            }
//        }
//
//        protected override void RenderAttributes(HtmlTextWriter writer)
//        {
//            Attributes.Render(writer);
//        }
    }

    /// <summary>
    /// Lets the user define a style for mousing over items and click them to post back.
    /// </summary>
    public class ItemClickableDataGrid : DataGrid
    {
        protected override DataGridItem CreateItem(int itemIndex, int dataSourceIndex, ListItemType itemType)
        {
            DataGridItem dgi = base.CreateItem(itemIndex, dataSourceIndex, itemType);

            // -1 is the header item
            if (itemIndex != -1)
            {
                dgi.Attributes.Add("onmouseover", "this.PrevClass = this.className; this.className = 'TaskGridMouseOver'");
                dgi.Attributes.Add("onmouseout", "this.className = this.PrevClass");
            }

            return dgi;
        }

        public override void DataBind()
        {
            base.DataBind();

            foreach (DataGridItem dgi in this.Items)
            {
                dgi.Attributes.Add("onclick", "window.location = './TaskDetail.aspx?TaskId=" + DataKeys[dgi.ItemIndex] + "'");
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\SafetyNet\SafetyNet.DAL\ITaskSource.cs ===
using System;
using System.Collections.Generic;
using System.Text;

namespace SafetyNet.DAL
{
    public interface ITaskSource
    {
        Task GetNextTask();
        void SetTaskStatus(int id, TaskStatus status);
        void SetWorkflowId(int taskId, Guid workflowId);

        Task GetTaskById(int id);

    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\SafetyNet\SafetyNet.DAL\DALException.cs ===
using System;
using System.Collections.Generic;
using System.Text;

namespace SafetyNet.DAL
{
    class DALException : Exception
    {
        public DALException() {}
        public DALException(string message) : base(message) { }
        public DALException(string message, Exception inner) : base(message, inner) {}
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\SafetyNet\SafetyNet.DAL\EnvironmentSource.cs ===
using System.Collections.Generic;
using System.Configuration;
using System.Data.SqlClient;

namespace SafetyNet.DAL
{
    public class EnvironmentSource
    {
        private static readonly string connectionString = ConfigurationManager.ConnectionStrings["RegDB"].ConnectionString;

        public static List<string> GetEnvironmentNames()
        {
            using (SqlConnection con = new SqlConnection(connectionString))
            {
                List<string> result = new List<string>();
                con.Open();
                SqlCommand cmd = con.CreateCommand();
                cmd.CommandText = "select Name from Environments order by EnvironmentId";
                SqlDataReader reader = cmd.ExecuteReader();
                while(reader.Read())
                {
                    result.Add(reader.GetString(0));
                }
                con.Close();
                return result;
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\SafetyNet\SafetyNet.Admin\App_Code\DataSource.cs ===
using System;
using System.Data;
using System.Configuration;
using System.Web.Configuration;
using System.Web;
using System.Web.Security;
using System.Web.UI;
using System.Web.UI.WebControls;
using System.Web.UI.WebControls.WebParts;
using System.Web.UI.HtmlControls;
using System.Workflow.Runtime.Tracking;
using System.Workflow.Runtime;
using System.Collections.Generic;

/// <summary>
/// Summary description for DataSource
/// </summary>
public class DataSource 
{
    public DataSource()
    {
        //
        // TODO: Add constructor logic here
        //
    }
    DateTime statusFromDateTime = new DateTime(2000, 1, 1);
    DateTime statusUntilDateTime = DateTime.Now.AddDays(1);
    static string connectionString
    {
        get { return WebConfigurationManager.ConnectionStrings["WFTracking"].ConnectionString; }
    }
    public static void SetInstance(Guid id)
    {
        SqlTrackingQuery sqlTrackingQuery = new SqlTrackingQuery(connectionString);
        SqlTrackingWorkflowInstance wi = null;
        bool success =  sqlTrackingQuery.TryGetWorkflow(id, out wi);
        if (success)
        {
            HttpContext.Current.Session["CurrentWF"] = wi;
            HttpContext.Current.Session["CurrentAct"] = null;
        }
    }
    public static void SetInstance(Guid id, string act)
    {
        SqlTrackingQuery sqlTrackingQuery = new SqlTrackingQuery(connectionString);
        SqlTrackingWorkflowInstance wi = null;
        bool success = sqlTrackingQuery.TryGetWorkflow(id, out wi);
        if (success)
        {
            HttpContext.Current.Session["CurrentWF"] = wi;
            HttpContext.Current.Session["CurrentAct"] = act;

        }
    }
    public IList<ActivityTrackingRecord> GetWorkflowActivities(Guid id)
    {
        List<SqlTrackingWorkflowInstance> queriedWorkflows = new List<SqlTrackingWorkflowInstance>();
        SqlTrackingQuery sqlTrackingQuery = new SqlTrackingQuery(connectionString);
        SqlTrackingWorkflowInstance twi = null;
        sqlTrackingQuery.TryGetWorkflow(id, out twi);
        if (twi != null)
            return twi.ActivityEvents;
        else
            return new List<ActivityTrackingRecord>();
        
       
    }
    public List<SqlTrackingWorkflowInstance> GetWorkflows()
    {
        List<SqlTrackingWorkflowInstance> queriedWorkflows = new List<SqlTrackingWorkflowInstance>();
        SqlTrackingQuery sqlTrackingQuery = new SqlTrackingQuery(connectionString);
        SqlTrackingQueryOptions sqlTrackingQueryOptions = new SqlTrackingQueryOptions();
        sqlTrackingQueryOptions.StatusMinDateTime = statusFromDateTime.ToUniversalTime();
        sqlTrackingQueryOptions.StatusMaxDateTime = statusUntilDateTime.ToUniversalTime();
        sqlTrackingQueryOptions.WorkflowStatus = WorkflowStatus.Created;
        queriedWorkflows.AddRange(sqlTrackingQuery.GetWorkflows(sqlTrackingQueryOptions));

        sqlTrackingQueryOptions.WorkflowStatus = WorkflowStatus.Completed;
        queriedWorkflows.AddRange(sqlTrackingQuery.GetWorkflows(sqlTrackingQueryOptions));

        sqlTrackingQueryOptions.WorkflowStatus = WorkflowStatus.Running;
        queriedWorkflows.AddRange(sqlTrackingQuery.GetWorkflows(sqlTrackingQueryOptions));

        sqlTrackingQueryOptions.WorkflowStatus = WorkflowStatus.Suspended;
        queriedWorkflows.AddRange(sqlTrackingQuery.GetWorkflows(sqlTrackingQueryOptions));

        sqlTrackingQueryOptions.WorkflowStatus = WorkflowStatus.Terminated;
        queriedWorkflows.AddRange(sqlTrackingQuery.GetWorkflows(sqlTrackingQueryOptions));
     
        return queriedWorkflows;

    }

}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\SafetyNet\SafetyNet.DAL\RunBuilderException.cs ===
using System;

namespace SafetyNet.DAL
{
    public class RunBuilderException : Exception
    {
        public RunBuilderException() { }
        public RunBuilderException(string message) : base(message) { }
        public RunBuilderException(string message, Exception inner) : base(message, inner) { }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\SafetyNet\SafetyNet.DAL\DbTaskSource.cs ===
using System;
using System.Collections.Generic;
using System.Data;
using System.Text;
using System.Data.SqlClient;
using System.Configuration;

namespace SafetyNet.DAL
{
    public class DbTaskSource: ITaskSource
    {
        private string connectString;
        public DbTaskSource(string connectString)
        {
            this.connectString = connectString;
        }

        public DbTaskSource()
        {
            this.connectString = ConfigurationManager.ConnectionStrings["RegDB"].ConnectionString;
        }

        #region ITaskSource implementation 
        public Task GetNextTask()
        {
            using (SqlConnection con = new SqlConnection(connectString))
            {
                con.Open();
                SqlCommand cmd = con.CreateCommand();
                cmd.CommandText = "select top 1 * from Task where Status = " + (int)TaskStatus.Ready + " order by ChangeTime";
                Task result = ReadTaskFromCmd(cmd);
                con.Close();
                return result;
            }
        }

        public void SetTaskStatus(int taskid, TaskStatus status)
        {
            using (SqlConnection con = new SqlConnection(connectString))
            {
                con.Open();
                SqlCommand cmd = con.CreateCommand();
                cmd.CommandText = "update Task set Status = @status where TaskId = @id";
                cmd.Parameters.AddWithValue("@status", (byte)status);
                cmd.Parameters.AddWithValue("@id", taskid);
                int rowsAffected = cmd.ExecuteNonQuery();
                con.Close();
                if (rowsAffected!=1)
                    throw new DALException(String.Format("Failed to update task status. Expected 1 row to be affected but {0} rows were affected", rowsAffected));
            }
        }

        public Task GetTaskById(int id)
        {
            using (SqlConnection con = new SqlConnection(connectString))
            {
                con.Open();
                SqlCommand cmd = con.CreateCommand();
                cmd.CommandText = "select * from Task where TaskId = @id";
                cmd.Parameters.AddWithValue("@id", id);
                Task result = ReadTaskFromCmd(cmd);
                con.Close();
                return result;
            }
        }

        private static Task ReadTaskFromCmd(SqlCommand cmd)
        {
            Task result = null;
            using (SqlDataReader reader = cmd.ExecuteReader())
            {
                if (reader.HasRows)
                {
                    reader.Read();
                    result = ReadTaskFromReader(reader);

                }
                reader.Close();
            }
            return result;
        }

        private static Task ReadTaskFromReader(IDataRecord reader)
        {
            return new Task((int)reader["TaskId"],
                (string)reader["Name"],
                (TaskStatus)(byte)reader["Status"],
                (DateTime)reader["ChangeTime"], 
                reader["WorkflowXml"]==DBNull.Value?String.Empty:(string)reader["WorkflowXml"],
                reader["WorkflowId"]==DBNull.Value?Guid.Empty:(Guid)reader["WorkflowId"]);
        }


        public void SetWorkflowId(int taskId, Guid workflowId)
        {
            using (SqlConnection con = new SqlConnection(connectString))
            {
                con.Open();
                SqlCommand cmd = con.CreateCommand();
                cmd.CommandText = "update Task set WorkflowId = @guid where TaskId = @id";
                cmd.Parameters.AddWithValue("@guid", workflowId);
                cmd.Parameters.AddWithValue("@id", taskId);
                int rowsAffected = cmd.ExecuteNonQuery();
                con.Close();
                if (rowsAffected != 1)
                    throw new DALException(String.Format("Failed to update task status. Expected 1 row to be affected but {0} rows were affected", rowsAffected));
            }
        }

        #endregion

        public int CreateTask(string name, string workflowXml)
        {
            using (SqlConnection con = new SqlConnection(connectString))
            {
                con.Open();
                SqlCommand cmd = con.CreateCommand();
                cmd.CommandText =
                    "insert into Task(Name, Status, ChangeTime, Environment, Build, Iteration, WorkflowXml) values (@name,@status,@change_time, 1, \'Build\', 0, @workflowXml);SELECT CAST(scope_identity() AS int)";
                cmd.Parameters.AddWithValue("@name", name);
                cmd.Parameters.AddWithValue("@status", (int) TaskStatus.Created);
                cmd.Parameters.AddWithValue("@change_time", DateTime.Now);
                cmd.Parameters.AddWithValue("@workflowXml", (object) workflowXml ?? DBNull.Value);

                int taskId = (int) cmd.ExecuteScalar();
                return taskId;
            }
        }

        public IList<Task> FindByStatus(TaskStatus status)
        {
            using (SqlConnection con = new SqlConnection(connectString))
            {
                con.Open();
                SqlCommand cmd = con.CreateCommand();
                cmd.CommandText = "select * from Task where Status = @status";
                cmd.Parameters.AddWithValue("@status", (int)status);
                List<Task> result = new List<Task>();
                using (SqlDataReader reader = cmd.ExecuteReader())
                {
                    while (reader.Read())
                        result.Add(ReadTaskFromReader(reader));
                    reader.Close();
                }
                con.Close();
                return result;
            }
        }

        public IList<Task> FindByStatus(string statusName)
        {
            return FindByStatus((TaskStatus) Enum.Parse(typeof(TaskStatus), statusName));
        }

    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\SafetyNet\SafetyNet.DAL\RunBuilder.cs ===
using System;
using System.Collections.Generic;
using System.Text;
using System.Workflow.ComponentModel;
using System.Workflow.ComponentModel.Serialization;
using System.Xml;
using SafetyNet.Activities;

namespace SafetyNet.DAL
{
    public class RunBuilder
    {
        private struct StfSuite
        {
            internal StfSuite(string name, string dll )
            {
                this.Name = name;
                this.Dll = dll;
            }

            internal string Name;
            internal string Dll;
        }

        private List<StfSuite> suites= new List<StfSuite>();
        private string build = null;
        private int? iteration = null;
        private string environmentAddress;

        public string Build
        {
            get { return build; }
            set { build = value; }
        }

        public int? Iteration
        {
            get { return iteration; }
            set { iteration = value; }
        }

        public string Environment
        {
            get { return environmentAddress; }
            set { environmentAddress = value; }
        }

        public Activity BuildUp()
        {
            if(Build== null)
               throw new RunBuilderException("Build parameter can not be null.");
            if (Iteration == null)
                throw new RunBuilderException("Iteration parameter can not be null.");
            if(Environment == null)
                throw new RunBuilderException("RegDbAddress parameter can not be null.");


            TestRunActivity result = new TestRunActivity();
            result.Build = build;
            result.Iteration = iteration??0;
            result.Environment = environmentAddress;

            foreach (StfSuite suite in suites)
            {
                RunStfTest piece = new RunStfTest();
                piece.Name = suite.Name;
                piece.SuiteName = suite.Dll;
                piece.SetBinding(RunStfTest.BuildProperty, new ActivityBind(result.Name, "Build"));
                piece.SetBinding(RunStfTest.IterationProperty, new ActivityBind(result.Name, "Iteration"));
                piece.SetBinding(RunStfTest.EnvironmentProperty, new ActivityBind(result.Name, "Environment"));
                piece.SetBinding(RunStfTest.TargetDirectoryProperty, new ActivityBind(result.Name, "TargetDirectory"));

                result.Activities.Add(piece);
            }
            return result;
        }

        public string BuildXoml()
        {
            StringBuilder result = new StringBuilder();
            WorkflowMarkupSerializer serializer = new WorkflowMarkupSerializer();
            XmlWriter writer = XmlWriter.Create(result);
            serializer.Serialize(writer, BuildUp());

            return result.ToString();
        }

        public void AddStfSuite(string name, string dll)
        {
            suites.Add(new StfSuite(name, dll));
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\SafetyNet\SafetyNet.DAL\Task.cs ===
using System;
using System.Collections.Generic;
using System.Text;

namespace SafetyNet.DAL
{
    public enum TaskStatus
    {
        Created,
        Ready,
        Running,
        Paused,
        Failed, 
        Cancelled,
        Completed,
        Reset,
        Archived
    }

    public class Task
    {
        private TaskStatus status;
        public TaskStatus Status
        {
            get { return status; }
            set { status = value; }
        }

        private DateTime changeTime;
        public DateTime ChangeTime
        {
            get { return changeTime; }
        }

        private int id;

        public int Id
        {
            get { return id; }
        }
        private string name;

        public string Name
        {
            get { return name; }
        }

        private string workflowXml;
        public string WorkflowXml
        {
            get { return workflowXml; }
        }

        private Guid workflowId;
        public Guid WorkflowId
        {
            get { return workflowId; }
        }

        public Task(int id, string name, TaskStatus status, DateTime changeTime, string workflowXml, Guid workflowId)
        {
            this.status = status;
            this.workflowXml = workflowXml;
            this.workflowId = workflowId;
            this.changeTime = changeTime;
            this.name = name;
            this.id = id;
        }

        public Task(int id, string name, string workflowXml): this(id, name, TaskStatus.Created, DateTime.Now, workflowXml, Guid.Empty)
        {
            this.workflowXml = workflowXml;
        }

    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\SafetyNet\SafetyNet.Services\TrackableActivity.cs ===
using System;
using System.Collections.Generic;
using System.Text;
using System.Workflow.ComponentModel;
using System.Workflow.Activities;

namespace SafetyNet.Services
{
    /// <summary>
    /// This is a base class for all SafetyNet activities. It will be used as a filter for tracking service
    /// </summary>
	public abstract class TrackableActivity : Activity
	{
	}

    public abstract class TrackableSequenceActivity : SequenceActivity
    {
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\SafetyNet\SafetyNet.Services\ActivityTrackingService.cs ===
using System;
using System.Collections.Generic;
using System.Workflow.ComponentModel;
using System.Workflow.Runtime.Tracking;

namespace SafetyNet.Services
{
    public enum LogSeverity
    {
        Info,
        Warning,
        Error
    }

    public class ActivityTrackingChannel : TrackingChannel
    {
        private TrackingParameters parameters = null;
        private int taskId;

        protected ActivityTrackingChannel()
        {
        }

        public ActivityTrackingChannel(TrackingParameters parameters, int taskId)
        {
            this.parameters = parameters;
            this.taskId = taskId;
        }

        // Send() is called by Tracking runtime to send various tracking records
        protected override void Send(TrackingRecord record)
        {
            // filter on record type
            if (record is WorkflowTrackingRecord)
            {
                WriteWorkflowTrackingRecord((WorkflowTrackingRecord)record);
            }
            if (record is ActivityTrackingRecord)
            {
                WriteActivityTrackingRecord((ActivityTrackingRecord)record);
            }
        }

        // InstanceCompletedOrTerminated() is called by Tracking runtime to indicate that the Workflow instance finished running
        protected override void InstanceCompletedOrTerminated()
        {
            WriteLog(DateTime.Now, LogSeverity.Info, "Workflow was completed or terminated");
        }

        private void WriteWorkflowTrackingRecord(WorkflowTrackingRecord workflowTrackingRecord)
        {
            if (workflowTrackingRecord.TrackingWorkflowEvent == TrackingWorkflowEvent.Started)
            {
                WriteLog(workflowTrackingRecord.EventDateTime, LogSeverity.Info, "Workflow {0} Started", taskId);
            } else if (workflowTrackingRecord.TrackingWorkflowEvent == TrackingWorkflowEvent.Completed) {
                    WriteLog(workflowTrackingRecord.EventDateTime, LogSeverity.Info, "Workflow {0} Completed", taskId);
            }
        }

        private static void WriteActivityTrackingRecord(ActivityTrackingRecord activityTrackingRecord)
        {
            WriteLog(activityTrackingRecord.EventDateTime, LogSeverity.Info, "{0} is {1}", activityTrackingRecord.QualifiedName.ToString(), activityTrackingRecord.ExecutionStatus);
        }

        private static void WriteLog(DateTime logTime, LogSeverity severity, string message, params object[] args)
        {
            Console.WriteLine("{0}: {1}", logTime, String.Format(message, args));  
        }
    }

    public class ActivityTrackingService : TrackingService
    {
        private int taskId;
        public ActivityTrackingService(int taskId)
        {
            this.taskId = taskId;
        }

        protected override bool TryGetProfile(Type workflowType, out TrackingProfile profile)
        {
            //Depending on the workflowType, service can return different tracking profiles
            //In this sample we're returning the same profile for all running types
            profile = GetProfile();
            return true;
        }

        protected override TrackingProfile GetProfile(Guid workflowInstanceId)
        {
            // Does not support reloading/instance profiles
            throw new NotImplementedException("The method or operation is not implemented.");
        }

        protected override TrackingProfile GetProfile(Type workflowType, Version profileVersionId)
        {
            // Return the version of the tracking profile that runtime requests (profileVersionId)
            return GetProfile();
        }

        protected override bool TryReloadProfile(Type workflowType, Guid workflowInstanceId, out TrackingProfile profile)
        {
            // Returning false to indicate there is no new profiles
            profile = null;
            return false;
        }

        protected override TrackingChannel GetTrackingChannel(TrackingParameters parameters)
        {
            //return a tracking channel to receive runtime events
            return new ActivityTrackingChannel(parameters, taskId);
        }

        // Profile creation
        private static TrackingProfile GetProfile()
        {
            // Create a Tracking Profile
            TrackingProfile profile = new TrackingProfile();
            profile.Version = new Version("3.0.0");

            // Add a TrackPoint to cover all activity status events
            ActivityTrackPoint activityTrackPoint = new ActivityTrackPoint();
            activityTrackPoint.MatchingLocations.Add(CreateActivityTrackingLocation(typeof(Activity)));
            profile.ActivityTrackPoints.Add(activityTrackPoint);

            // Add a TrackPoint to cover all workflow status events
            WorkflowTrackPoint workflowTrackPoint = new WorkflowTrackPoint();
            workflowTrackPoint.MatchingLocation = new WorkflowTrackingLocation();
            foreach (TrackingWorkflowEvent workflowEvent in Enum.GetValues(typeof(TrackingWorkflowEvent)))
            {
                workflowTrackPoint.MatchingLocation.Events.Add(workflowEvent);
            }
            profile.WorkflowTrackPoints.Add(workflowTrackPoint);
            
            //// Add a TrackPoint to cover all user track points
            //UserTrackPoint userTrackPoint = new UserTrackPoint();
            //UserTrackingLocation userLocation = new UserTrackingLocation();
            //userLocation.ActivityType = typeof(Activity);
            //userLocation.MatchDerivedActivityTypes = true;
            //userLocation.ArgumentType = typeof(object);
            //userLocation.MatchDerivedArgumentTypes = true;
            //userTrackPoint.MatchingLocations.Add(userLocation);
            //profile.UserTrackPoints.Add(userTrackPoint);

            return profile;
        }

        private static ActivityTrackingLocation CreateActivityTrackingLocation(Type typeToTrack)
        {
            ActivityTrackingLocation activityLocation;

            activityLocation = new ActivityTrackingLocation(typeToTrack);
            activityLocation.MatchDerivedTypes = true;

            IEnumerable<ActivityExecutionStatus> statuses = Enum.GetValues(typeof(ActivityExecutionStatus)) as IEnumerable<ActivityExecutionStatus>;
            foreach (ActivityExecutionStatus status in statuses)
            {
                activityLocation.ExecutionStatusEvents.Add(status);
            }
            return activityLocation;
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\SafetyNet\SafetyNet.Services\RunProgramService.cs ===
using System;
using System.Collections.Generic;
using System.Diagnostics;
using System.Workflow.Runtime;

namespace SafetyNet.Services
{
    public class RunProgramService
    {
        private Dictionary<string, Process> processes = new Dictionary<string,Process>();
        private WorkflowRuntime runtime;

        public RunProgramService(WorkflowRuntime runtime)
        {
            this.runtime = runtime;
        }

        public bool StartProcess(string runId, ProcessStartInfo psi)
        {
            Process p = new Process();
            p.StartInfo = psi;
            Guid workflowInstanceId = WorkflowEnvironment.WorkflowInstanceId;
            p.Exited += delegate
                            {
                                WorkflowInstance instance = runtime.GetWorkflow(workflowInstanceId);
                                instance.EnqueueItem(runId, p.ExitCode, null, null);
                                processes.Remove(runId);
                            };
            p.EnableRaisingEvents = true;
            p.Start();
            processes.Add(runId, p);
            return true;
        }

        
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\SafetyNet\SafetyNet.TaskEngine\TaskEngine.cs ===
using System;
using System.Collections.Generic;
using System.IO;
using System.Text;
using System.Workflow.Runtime;
using System.Threading;
using System.Xml;
using SafetyNet.Services;
using SafetyNet.DAL;

namespace SafetyNet.Engine
{
    public class TaskEngine
    {
        private ITaskSource taskSource;
        private bool stopRequested =false;
        private static readonly TimeSpan POLLING_INTERVAL = TimeSpan.FromSeconds(15);
        public TaskEngine(ITaskSource taskSource)
        {
            this.taskSource = taskSource;
        }

        public void Run()
        {
            while (!stopRequested)
            {
                Task t = taskSource.GetNextTask();
                if (t != null)
                {
                    taskSource.SetTaskStatus(t.Id, TaskStatus.Running);
                    TaskStatus result = ExecuteTask(t);
                    taskSource.SetTaskStatus(t.Id, result);
                }
                else
                {
                    System.Threading.Thread.Sleep(POLLING_INTERVAL);
                }
            }
        }

        public void HandleStop(object sender, ConsoleCancelEventArgs args)
        {
            args.Cancel = false;
            HandleStop();
        }

        public void HandleStop()
        {
            stopRequested = true;
        }

        public TaskStatus ExecuteTask(Task t)
        {

            using (WorkflowRuntime runtime = new WorkflowRuntime("WorkflowRuntime"))
            {
                TaskStatus result = TaskStatus.Failed;
                runtime.AddService(new ActivityTrackingService(0));
                runtime.StartRuntime();

                AutoResetEvent waitOne = new AutoResetEvent(false);
                runtime.WorkflowCompleted += delegate(object sender, WorkflowCompletedEventArgs eargs)
                {
                    result = TaskStatus.Completed;
                    waitOne.Set();

                };

                runtime.WorkflowTerminated += delegate(object sender, WorkflowTerminatedEventArgs eargs)
                {
                    result = TaskStatus.Failed;
                    waitOne.Set();
                };

                using (XmlReader reader = XmlReader.Create(new StringReader(t.WorkflowXml)))
                {
                    WorkflowInstance instance = runtime.CreateWorkflow(reader);
                    instance.Start();
                    taskSource.SetWorkflowId(t.Id, instance.InstanceId);
                }

                waitOne.WaitOne();

                runtime.StopRuntime();
                return result;
            }
        }


    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\SafetyNet\SafetyNet.Services\Properties\AssemblyInfo.cs ===
using System.Reflection;
using System.Runtime.CompilerServices;
using System.Runtime.InteropServices;

// General Information about an assembly is controlled through the following 
// set of attributes. Change these attribute values to modify the information
// associated with an assembly.
[assembly: AssemblyTitle("SafetyNet.Services")]
[assembly: AssemblyDescription("")]
[assembly: AssemblyConfiguration("")]
[assembly: AssemblyCompany("MS")]
[assembly: AssemblyProduct("SafetyNet.Services")]
[assembly: AssemblyCopyright("Copyright  MS 2007")]
[assembly: AssemblyTrademark("")]
[assembly: AssemblyCulture("")]

// Setting ComVisible to false makes the types in this assembly not visible 
// to COM components.  If you need to access a type in this assembly from 
// COM, set the ComVisible attribute to true on that type.
[assembly: ComVisible(false)]

// The following GUID is for the ID of the typelib if this project is exposed to COM
[assembly: Guid("3f355ecc-9df1-473d-9d1e-225b86ced43a")]

// Version information for an assembly consists of the following four values:
//
//      Major Version
//      Minor Version 
//      Build Number
//      Revision
//
// You can specify all the values or you can default the Revision and Build Numbers 
// by using the '*' as shown below:
[assembly: AssemblyVersion("1.0.0.0")]
[assembly: AssemblyFileVersion("1.0.0.0")]
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\SafetyNet\SafetyNet.DAL\Properties\AssemblyInfo.cs ===
using System.Reflection;
using System.Runtime.CompilerServices;
using System.Runtime.InteropServices;

// General Information about an assembly is controlled through the following 
// set of attributes. Change these attribute values to modify the information
// associated with an assembly.
[assembly: AssemblyTitle("SafetyNet.DAL")]
[assembly: AssemblyDescription("")]
[assembly: AssemblyConfiguration("")]
[assembly: AssemblyCompany("MS")]
[assembly: AssemblyProduct("SafetyNet.DAL")]
[assembly: AssemblyCopyright("Copyright  MS 2007")]
[assembly: AssemblyTrademark("")]
[assembly: AssemblyCulture("")]

// Setting ComVisible to false makes the types in this assembly not visible 
// to COM components.  If you need to access a type in this assembly from 
// COM, set the ComVisible attribute to true on that type.
[assembly: ComVisible(false)]

// The following GUID is for the ID of the typelib if this project is exposed to COM
[assembly: Guid("8d79b65e-ec05-464e-98f7-4e3427dcd508")]

// Version information for an assembly consists of the following four values:
//
//      Major Version
//      Minor Version 
//      Build Number
//      Revision
//
// You can specify all the values or you can default the Revision and Build Numbers 
// by using the '*' as shown below:
[assembly: AssemblyVersion("1.0.0.0")]
[assembly: AssemblyFileVersion("1.0.0.0")]
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\SafetyNet\SafetyNet.Tests\FailingActivity.cs ===
using System;
using System.Collections.Generic;
using System.Text;
using System.Workflow.ComponentModel;

namespace SafetyNet.Tests
{
    public class FailingActivity : Activity
    {
        protected override ActivityExecutionStatus Execute(ActivityExecutionContext executionContext)
        {
            throw new Exception("Here comes failure");
        }

        public FailingActivity()
        {
            this.Name = "FailigActivity";
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\SafetyNet\SafetyNet.Tests\DbTaskSourceTest.cs ===
// The following code was generated by Microsoft Visual Studio 2005.
// The test owner should check each test for validity.
using Microsoft.VisualStudio.TestTools.UnitTesting;
using System;
using System.Text;
using System.Collections.Generic;
using SafetyNet.DAL;
using System.Configuration;
using System.Data.SqlClient;
 
namespace SafetyNet.Tests
{
    [TestClass()]
    public class DbTaskSourceTest
    {


        private TestContext testContextInstance;

        public TestContext TestContext
        {
            get
            {
                return testContextInstance;
            }
            set
            {
                testContextInstance = value;
            }
        }

        private static string connectString;

        [ClassInitialize()]
        public static void Initialize(TestContext testContext)
        {
            connectString = ConfigurationManager.ConnectionStrings["Scratch"].ConnectionString;
        }

        [TestInitialize()]
        public void SetUp()
        {
            CleanupTaskTable();

        }
        
        [TestMethod()]
        public void GetNextTaskTest()
        {
            AddTask("Test Task", TaskStatus.Ready, "<test/>");

            DbTaskSource target = new DbTaskSource(connectString);
            Task task;
            task = target.GetNextTask();

            Assert.AreEqual("Test Task", task.Name);
            Assert.AreEqual(task.Status, TaskStatus.Ready);
            Assert.IsNotNull(task.WorkflowXml);
        }

        [TestMethod]
        public void CreateTaskTest()
        {
            DbTaskSource target = new DbTaskSource(connectString);
            int taskId = target.CreateTask("TaskName", "<test/>");
            Task task = target.GetTaskById(taskId);
            Assert.IsNotNull(task);
            Assert.AreEqual("TaskName", task.Name);
            Assert.AreEqual("<test/>", task.WorkflowXml);
            Assert.AreEqual(TaskStatus.Created, task.Status);

        }

        private static int AddTask(TaskStatus status, string workflowXml)
        {
            return AddTask("Test Task", status, workflowXml);
        }

        private static int AddTask(string name, TaskStatus status, string workflowXml)
        {

            using (SqlConnection con = new SqlConnection(connectString))
            {
                con.Open();
                SqlCommand cmd = con.CreateCommand();
                cmd.CommandText = "insert into Task(Name, Status, ChangeTime, Environment, Build, Iteration, WorkflowXml) values (@name,@status,@change_time, 1, \'Build\', 0, @workflowXml);SELECT CAST(scope_identity() AS int)";

                cmd.Parameters.AddWithValue("@name", name);
                cmd.Parameters.AddWithValue("@status", (int)status);
                cmd.Parameters.AddWithValue("@change_time", DateTime.Now);
                cmd.Parameters.AddWithValue("@workflowXml", (object)workflowXml??DBNull.Value);

                int taskId = (int)cmd.ExecuteScalar();
                return taskId;
            }
        }

        private static void CleanupTaskTable()
        {
            using (SqlConnection con = new SqlConnection(connectString))
            {
                con.Open();
                SqlCommand cmd = con.CreateCommand();
                cmd.CommandText = "delete from Task";
                cmd.ExecuteNonQuery();
            }
        }

        [TestMethod]
        public void GetNextTask_NoTasks()
        {
            DbTaskSource target = new DbTaskSource(connectString);
            Task task = target.GetNextTask();
            Assert.IsNull(task);
        }

        [TestMethod()]
        public void SetTaskStatusTest()
        {

            ITaskSource target = new DbTaskSource(connectString);
            int id = AddTask("Test Task", TaskStatus.Created, "<test/>");
            target.SetTaskStatus(id, TaskStatus.Ready);

            Task t = target.GetTaskById(id);
            Assert.AreEqual(TaskStatus.Ready, t.Status);
        }

        [TestMethod()]
        public void SetWorkflowIdTest()
        {

            ITaskSource target = new DbTaskSource(connectString);
            int id = AddTask("Test Task", TaskStatus.Created, "<test/>");
            Guid workflowId = Guid.NewGuid();
            target.SetWorkflowId(id, workflowId);

            Task t = target.GetTaskById(id);
            Assert.AreEqual(workflowId, t.WorkflowId);
        }

        [TestMethod]
        public void FindByStatusTest()
        {
            DbTaskSource target = new DbTaskSource(connectString);
            int createdId = AddTask("Created", TaskStatus.Created, "<test/>");
            int runningId = AddTask("Running", TaskStatus.Running, "<test/>");
            int failedId = AddTask("Failed", TaskStatus.Failed, "<test/>");

            IList<Task> created = target.FindByStatus(TaskStatus.Created);
            Assert.AreEqual(1, created.Count);
            Assert.AreEqual("Created", created[0].Name);
            Assert.AreEqual(createdId, created[0].Id);

            IList<Task> failed = target.FindByStatus(TaskStatus.Failed);
            Assert.AreEqual(1, failed.Count);
            Assert.AreEqual("Failed", failed[0].Name);
            Assert.AreEqual(failedId, failed[0].Id);

        }

        [TestMethod]
        public void FindByStatusStringTest()
        {
            DbTaskSource target = new DbTaskSource(connectString);
            int createdId = AddTask("Created", TaskStatus.Created, "<test/>");
            int failedId = AddTask("Failed", TaskStatus.Failed, "<test/>");

            IList<Task> created = target.FindByStatus("Created");
            Assert.AreEqual(1, created.Count);
            Assert.AreEqual("Created", created[0].Name);
            Assert.AreEqual(createdId, created[0].Id);

            IList<Task> failed = target.FindByStatus("Failed");
            Assert.AreEqual(1, failed.Count);
            Assert.AreEqual("Failed", failed[0].Name);
            Assert.AreEqual(failedId, failed[0].Id);
        }
    }


}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\SafetyNet\SafetyNet.Tests\RunBuilderTest.cs ===
using System.Text;
using System.Workflow.ComponentModel;
using System.Workflow.ComponentModel.Serialization;
using System.Xml;
using Microsoft.VisualStudio.TestTools.UnitTesting;
using SafetyNet.Activities;
using SafetyNet.DAL;

namespace SafetyNet.Tests
{
    [TestClass]
    public class RunBuilderTest
    {

        #region Additional test attributes
        //
        // You can use the following additional attributes as you write your tests:
        //
        // Use ClassInitialize to run code before running the first test in the class
        // [ClassInitialize()]
        // public static void MyClassInitialize(TestContext testContext) { }
        //
        // Use ClassCleanup to run code after all tests in a class have run
        // [ClassCleanup()]
        // public static void MyClassCleanup() { }
        //
        // Use TestInitialize to run code before running each test 
        // [TestInitialize()]
        // public void MyTestInitialize() { }
        //
        // Use TestCleanup to run code after each test has run
        // [TestCleanup()]
        // public void MyTestCleanup() { }
        //
        #endregion

        [TestMethod]
        public void TestEmpty()
        {
            RunBuilder rb = CreateRunBuilder();
            Activity result = rb.BuildUp();

            Assert.IsNotNull(result);
            Assert.IsInstanceOfType(result, typeof(TestRunActivity));
            
            TestRunActivity ta = result as TestRunActivity;

            Assert.AreEqual("1.0.00", ta.Build);
            Assert.AreEqual(1, ta.Iteration);
            Assert.AreEqual("10.0.0.1", ta.Environment);
            
        }

        private RunBuilder CreateRunBuilder()
        {
            RunBuilder rb = new RunBuilder();
            rb.Build = "1.0.00";
            rb.Iteration = 1;
            rb.Environment = "10.0.0.1";
            return rb;
        }

        [TestMethod]
        [ExpectedException(typeof(RunBuilderException))]
        public void TestBuildNotSet()
        {
            RunBuilder rb = CreateRunBuilder();
            rb.Build = null;
            Activity result = rb.BuildUp();
        }

        [TestMethod]
        [ExpectedException(typeof(RunBuilderException))]
        public void TestIterationNotSet()
        {
            RunBuilder rb = CreateRunBuilder();
            rb.Iteration = null;
            Activity result = rb.BuildUp();
        }

        [TestMethod]
        [ExpectedException(typeof(RunBuilderException))]
        public void TestEnvironmentNotSet()
        {
            RunBuilder rb =CreateRunBuilder();
            rb.Environment = null;
            Activity result = rb.BuildUp();
        }

        [TestMethod]
        public void TestAddStf()
        {
            RunBuilder rb = CreateRunBuilder();
            rb.AddStfSuite("Strings", "stringservtest");
            TestRunActivity result = rb.BuildUp() as TestRunActivity;

            Assert.AreEqual(1, result.Activities.Count);
            RunStfTest rst = result.Activities[0] as RunStfTest;
            Assert.IsNotNull(rst);
            Assert.AreEqual("Strings", rst.Name);
            Assert.AreEqual("stringservtest", rst.SuiteName);

        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\SafetyNet\SafetyNet.TaskEngine\Properties\AssemblyInfo.cs ===
using System.Reflection;
using System.Runtime.CompilerServices;
using System.Runtime.InteropServices;

// General Information about an assembly is controlled through the following 
// set of attributes. Change these attribute values to modify the information
// associated with an assembly.
[assembly: AssemblyTitle("SafetyNet.TaskEngine")]
[assembly: AssemblyDescription("")]
[assembly: AssemblyConfiguration("")]
[assembly: AssemblyCompany("MS")]
[assembly: AssemblyProduct("SafetyNet.TaskEngine")]
[assembly: AssemblyCopyright("Copyright  MS 2007")]
[assembly: AssemblyTrademark("")]
[assembly: AssemblyCulture("")]

// Setting ComVisible to false makes the types in this assembly not visible 
// to COM components.  If you need to access a type in this assembly from 
// COM, set the ComVisible attribute to true on that type.
[assembly: ComVisible(false)]

// The following GUID is for the ID of the typelib if this project is exposed to COM
[assembly: Guid("07082336-73a7-48ad-bf2b-6c59c68e2aa7")]

// Version information for an assembly consists of the following four values:
//
//      Major Version
//      Minor Version 
//      Build Number
//      Revision
//
// You can specify all the values or you can default the Revision and Build Numbers 
// by using the '*' as shown below:
[assembly: AssemblyVersion("1.0.0.0")]
[assembly: AssemblyFileVersion("1.0.0.0")]
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\SafetyNet\SafetyNet.Tests\TestExecuteActivity.cs ===
using System;
using System.Collections.Generic;
using System.Text;
using System.Workflow.ComponentModel;

namespace SafetyNet.Tests
{
    public class TestExecuteActivity:Activity
    {
        static public bool Executed = false;
        protected override ActivityExecutionStatus Execute(ActivityExecutionContext executionContext)
        {
            TestExecuteActivity.Executed = true;
            return ActivityExecutionStatus.Closed;
        }

        public TestExecuteActivity()
        {
            this.Name = "TestExecuteActivity";
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\SafetyNet\SafetyNet.Tests\TestRunActivityTest.cs ===
using System;
using System.Configuration;
using System.Text;
using System.Collections.Generic;
using Microsoft.VisualStudio.TestTools.UnitTesting;
using SafetyNet.Activities;

namespace SafetyNet.Tests
{
    /// <summary>
    /// Summary description for TestRunActivityTest
    /// </summary>
    [TestClass]
    public class TestRunActivityTest
    {
        public TestRunActivityTest()
        {
            //
            // TODO: Add constructor logic here
            //
        }

        #region Additional test attributes
        //
        // You can use the following additional attributes as you write your tests:
        //
        // Use ClassInitialize to run code before running the first test in the class
        // [ClassInitialize()]
        // public static void MyClassInitialize(TestContext testContext) { }
        //
        // Use ClassCleanup to run code after all tests in a class have run
        // [ClassCleanup()]
        // public static void MyClassCleanup() { }
        //
        // Use TestInitialize to run code before running each test 
        // [TestInitialize()]
        // public void MyTestInitialize() { }
        //
        // Use TestCleanup to run code after each test has run
        // [TestCleanup()]
        // public void MyTestCleanup() { }
        //
        #endregion

        [TestMethod]
        public void ReadingTargetDirFromConfigTest()
        {
            string expected = ConfigurationManager.AppSettings["TargetDirectory"];
            Assert.IsFalse(String.IsNullOrEmpty(expected));
            TestRunActivity ta = new TestRunActivity();
            Assert.AreEqual(expected, ta.TargetDirectory);
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\SafetyNet\SafetyNetController\RunBuilder.cs ===
using System;
using System.Collections.Generic;
using System.Text;
using System.Workflow.ComponentModel;
using System.Workflow.ComponentModel.Serialization;
using System.Xml;
using SafetyNet.Activities;

namespace SafetyNet.DAL
{
    public class RunBuilder
    {
        private struct StfSuite
        {
            internal StfSuite(string name, string dll )
            {
                this.Name = name;
                this.Dll = dll;
            }

            internal string Name;
            internal string Dll;
        }

        private List<StfSuite> suites= new List<StfSuite>();
        private string build = null;
        private int? iteration = null;
        private string environmentAddress;

        public string Build
        {
            get { return build; }
            set { build = value; }
        }

        public int? Iteration
        {
            get { return iteration; }
            set { iteration = value; }
        }

        public string Environment
        {
            get { return environmentAddress; }
            set { environmentAddress = value; }
        }

        public Activity BuildUp()
        {
            if(Build== null)
               throw new RunBuilderException("Build parameter can not be null.");
            if (Iteration == null)
                throw new RunBuilderException("Iteration parameter can not be null.");
            if(Environment == null)
                throw new RunBuilderException("RegDbAddress parameter can not be null.");


            TestRunActivity result = new TestRunActivity();
            result.Build = build;
            result.Iteration = iteration??0;
            result.Environment = environmentAddress;

            foreach (StfSuite suite in suites)
            {
                RunStfTest piece = new RunStfTest();
                piece.Name = suite.Name;
                piece.SuiteName = suite.Dll;
                piece.SetBinding(RunStfTest.BuildProperty, new ActivityBind(result.Name, "Build"));
                piece.SetBinding(RunStfTest.IterationProperty, new ActivityBind(result.Name, "Iteration"));
                piece.SetBinding(RunStfTest.EnvironmentProperty, new ActivityBind(result.Name, "Environment"));
                piece.SetBinding(RunStfTest.TargetDirectoryProperty, new ActivityBind(result.Name, "TargetDirectory"));

                result.Activities.Add(piece);
            }
            return result;
        }

        public string BuildXoml()
        {
            StringBuilder result = new StringBuilder();
            WorkflowMarkupSerializer serializer = new WorkflowMarkupSerializer();
            XmlWriter writer = XmlWriter.Create(result);
            serializer.Serialize(writer, BuildUp());

            return result.ToString();
        }

        public void AddStfSuite(string name, string dll)
        {
            suites.Add(new StfSuite(name, dll));
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\SafetyNet\SafetyNet.Util\Program.cs ===
using System;
using System.Collections.Generic;
using System.Text;
using System.Data.SqlClient;
using System.Configuration;
using SafetyNet.DAL;

namespace SafetyNet.Util
{
    class Program
    {
        private static string connectString;
        public static void Main()
        {
            Program.connectString = ConfigurationManager.ConnectionStrings["Tasks"].ConnectionString;
            CreateTask(TaskStatus.Ready);
        }

        private static int CreateTask(TaskStatus status)
        {

            using (SqlConnection con = new SqlConnection(connectString))
            {
                con.Open();
                SqlCommand cmd = con.CreateCommand();
                cmd.CommandText = "insert into Task(Name, Status, ChangeTime) values (@name,@status,@change_time);SELECT CAST(scope_identity() AS int)";
                cmd.Parameters.AddWithValue("@name", "Test task");
                cmd.Parameters.AddWithValue("@status", (int)status);
                cmd.Parameters.AddWithValue("@change_time", DateTime.Now);
                int taskId = (int)cmd.ExecuteScalar();
                return taskId;
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\SafetyNet\SafetyNet.Tests\WorkflowManipulationTests.cs ===
using System.IO;
using System.Text;
using System.Workflow.Activities;
using System.Workflow.ComponentModel;
using System.Workflow.ComponentModel.Serialization;
using System.Xml;
using Microsoft.VisualStudio.TestTools.UnitTesting;
using SafetyNet.Activities;

namespace SafetyNet.Tests
{
    [TestClass]
    public class WorkflowManipulationTests
    {
        [TestMethod]
        public void SerializationSpike()
        {
            TestRunActivity test = new TestRunActivity();
            test.Name = "TestRun";
//            test.TargetDirectory = @"c:\blah";
            test.Iteration = 500;
            test.Build = "Testbuild";

            RunStfTest strings = new RunStfTest();
            strings.Name = "Strings";
            strings.SetBinding(RunStfTest.BuildProperty, new ActivityBind("TestRun", "Build"));
            strings.SetBinding(RunStfTest.IterationProperty, new ActivityBind("TestRun", "Iteration"));
            strings.SuiteName = "StringTest";
            strings.SetBinding(RunStfTest.TargetDirectoryProperty, new ActivityBind("TestRun", "TargetDirectory"));
            
            test.Activities.Add(strings);
            StringBuilder result = new StringBuilder();
            WorkflowMarkupSerializer serializer = new WorkflowMarkupSerializer();
            XmlWriter writer = XmlWriter.Create(result);
            serializer.Serialize(writer, test);
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\SafetyNet\SafetyNet.Tests\TaskEngineTest.cs ===
// The following code was generated by Microsoft Visual Studio 2005.
// The test owner should check each test for validity.
using Microsoft.VisualStudio.TestTools.UnitTesting;
using System;
using System.Text;
using System.Collections.Generic;
using SafetyNet.Engine;
using SafetyNet.DAL;

namespace SafetyNet.Tests
{
    [TestClass()]
    public class TaskEngineTest
    {


        private TestContext testContextInstance;

        public TestContext TestContext
        {
            get
            {
                return testContextInstance;
            }
            set
            {
                testContextInstance = value;
            }
        }
        #region Additional test attributes
        // 
        //You can use the following additional attributes as you write your tests:
        //
        //Use ClassInitialize to run code before running the first test in the class
        //
        //[ClassInitialize()]
        //public static void MyClassInitialize(TestContext testContext)
        //{
        //}
        //
        //Use ClassCleanup to run code after all tests in a class have run
        //
        //[ClassCleanup()]
        //public static void MyClassCleanup()
        //{
        //}
        //
        //Use TestCleanup to run code after each test has run
        //
        //[TestCleanup()]
        //public void MyTestCleanup()
        //{
        //}
        //
        #endregion


        [TestMethod]
        public void RunTest()
        {
            TestTaskSource source = new TestTaskSource();
            source.newTaskId = 500;
            TaskEngine engine = new TaskEngine(source);
            source.engine = engine;
            TestExecuteActivity.Executed = false;
            engine.Run();

            Assert.AreEqual("GetNextTask|SetTaskStatus 500,Running|SetWorkflowId|SetTaskStatus 500,Completed|", source.callLog);
            Assert.IsTrue(TestExecuteActivity.Executed);
        }

        [TestMethod]
        public void RunFailingWorkflowTest()
        {
            TestTaskSource source = new TestTaskSource();
            source.newTaskId = 500;
            source.workflowFileName = "FailingWorkflow.xml";
            TaskEngine engine = new TaskEngine(source);
            source.engine = engine;
            
            engine.Run();

            Assert.AreEqual("GetNextTask|SetTaskStatus 500,Running|SetWorkflowId|SetTaskStatus 500,Failed|", source.callLog);
        }

    }

    class TestTaskSource : ITaskSource
    {
        public string callLog = String.Empty;
        public int newTaskId;
        public TaskEngine engine;
        public string workflowFileName = "ForTesting.xml";

        #region ITaskSource Members

        public Task GetNextTask()
        {
            engine.HandleStop();
            callLog += "GetNextTask|";

            string taskXml = System.IO.File.ReadAllText(workflowFileName);
            return new Task(newTaskId, "Test task", taskXml);
        }

        public void SetTaskStatus(int id, TaskStatus status)
        {
            callLog += String.Format("SetTaskStatus {0},{1}|", id, Enum.Format(typeof(TaskStatus), status, "g"));

        }
        
        public void SetWorkflowId(int taskId, Guid workflowId)
        {
            callLog += "SetWorkflowId|";
        }

        public Task GetTaskById(int id)
        {
            throw new Exception("The method or operation is not implemented.");
        }

        #endregion
    }

}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\SafetyNet\SafetyNetController\Program.cs ===
using System;
using System.Collections.Generic;
using System.Text;
using System.Configuration;

using SafetyNet.Engine;
using SafetyNet.DAL;

namespace SafetyNet.Controller
{
    class Program
    {
        static void Main(string[] args)
        {
//            if (args.Length != 0)
//            {
//                TaskEngine engine = new TaskEngine(null);
//                engine.WorkflowFileName = args[0];
//                engine.ExecuteTask();
//            }
            TaskEngine engine= new TaskEngine(new DbTaskSource(ConfigurationManager.ConnectionStrings["Tasks"].ConnectionString));
            Console.TreatControlCAsInput = false;
            Console.CancelKeyPress += new ConsoleCancelEventHandler(engine.HandleStop);
            engine.Run();
        }
        

    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\SafetyNet\SafetyNet.Tests\VSCodeGenAccessors.cs ===
// ------------------------------------------------------------------------------
//<autogenerated>
//        This code was generated by Microsoft Visual Studio Team System 2005.
//
//        Changes to this file may cause incorrect behavior and will be lost if
//        the code is regenerated.
//</autogenerated>
//------------------------------------------------------------------------------
using Microsoft.VisualStudio.TestTools.UnitTesting;

namespace SafetyNet.Tests
{
[System.Diagnostics.DebuggerStepThrough()]
[System.CodeDom.Compiler.GeneratedCodeAttribute("Microsoft.VisualStudio.TestTools.UnitTestGeneration", "1.0.0.0")]
internal class BaseAccessor {
    
    protected Microsoft.VisualStudio.TestTools.UnitTesting.PrivateObject m_privateObject;
    
    protected BaseAccessor(object target, Microsoft.VisualStudio.TestTools.UnitTesting.PrivateType type) {
        m_privateObject = new Microsoft.VisualStudio.TestTools.UnitTesting.PrivateObject(target, type);
    }
    
    protected BaseAccessor(Microsoft.VisualStudio.TestTools.UnitTesting.PrivateType type) : 
            this(null, type) {
    }
    
    internal virtual object Target {
        get {
            return m_privateObject.Target;
        }
    }
    
    public override string ToString() {
        return this.Target.ToString();
    }
    
    public override bool Equals(object obj) {
        if (typeof(BaseAccessor).IsInstanceOfType(obj)) {
            obj = ((BaseAccessor)(obj)).Target;
        }
        return this.Target.Equals(obj);
    }
    
    public override int GetHashCode() {
        return this.Target.GetHashCode();
    }
}


[System.Diagnostics.DebuggerStepThrough()]
[System.CodeDom.Compiler.GeneratedCodeAttribute("Microsoft.VisualStudio.TestTools.UnitTestGeneration", "1.0.0.0")]
internal class SafetyNet_DAL_ITaskSourceAccessor : BaseAccessor {
    
    protected static Microsoft.VisualStudio.TestTools.UnitTesting.PrivateType m_privateType = new Microsoft.VisualStudio.TestTools.UnitTesting.PrivateType("SafetyNet.DAL", "SafetyNet.DAL.ITaskSource");
    
    internal SafetyNet_DAL_ITaskSourceAccessor(object target) : 
            base(target, m_privateType) {
    }
    
    internal global::SafetyNet.DAL.Task GetNextTask() {
        object[] args = new object[0];
        global::SafetyNet.DAL.Task ret = ((global::SafetyNet.DAL.Task)(m_privateObject.Invoke("GetNextTask", new System.Type[0], args)));
        return ret;
    }
    
    internal void SetTaskStatus(global::SafetyNet.DAL.TaskStatus status) {
        object[] args = new object[] {
                status};
        m_privateObject.Invoke("SetTaskStatus", new System.Type[] {
                    typeof(global::SafetyNet.DAL.TaskStatus)}, args);
    }
}
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\SafetyNet\WorkflowDesignerControl\Helpers.cs ===
//---------------------------------------------------------------------
//  This file is part of the Windows Workflow Foundation SDK Code Samples.
// 
//  Copyright (C) Microsoft Corporation.  All rights reserved.
// 
//This source code is intended only as a supplement to Microsoft
//Development Tools and/or on-line documentation.  See these other
//materials for detailed information regarding Microsoft code samples.
// 
//THIS CODE AND INFORMATION ARE PROVIDED AS IS WITHOUT WARRANTY OF ANY
//KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
//IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A
//PARTICULAR PURPOSE.
//---------------------------------------------------------------------
using System;
using System.Collections;
using System.Collections.Generic;
using System.ComponentModel.Design;
using System.Workflow.ComponentModel;
using System.Windows.Forms;

namespace Microsoft.Samples.Workflow.WorkflowMonitor
{
    internal static class Helpers
    {
        internal static Activity[] GetNestedActivities(CompositeActivity compositeActivity)
        {
            if (compositeActivity == null)
                throw new ArgumentNullException("compositeActivity");

            IList<Activity> childActivities = null;
            ArrayList nestedActivities = new ArrayList();
            Queue compositeActivities = new Queue();
            compositeActivities.Enqueue(compositeActivity);
            while (compositeActivities.Count > 0)
            {
                CompositeActivity compositeActivity2 = (CompositeActivity)compositeActivities.Dequeue();
                childActivities = compositeActivity2.Activities;

                foreach (Activity activity in childActivities)
                {
                    nestedActivities.Add(activity);
                    if (activity is CompositeActivity)
                        compositeActivities.Enqueue(activity);
                }
            }
            return (Activity[])nestedActivities.ToArray(typeof(Activity));
        }

        internal static void AddObjectGraphToDesignerHost(IDesignerHost designerHost, Activity activity)
        {
            if (designerHost == null)
                throw new ArgumentNullException("designerHost");
            if (activity == null)
                throw new ArgumentNullException("activity");

            string rootSiteName = activity.QualifiedName;
            designerHost.Container.Add(activity, activity.QualifiedName);

            if (activity is CompositeActivity)
            {
                foreach (Activity activity2 in GetNestedActivities(activity as CompositeActivity))
                    designerHost.Container.Add(activity2, activity2.QualifiedName);
            }
        }
    }

    //ListView sorter that sorts alphanumeric or numeric
    internal class ListViewItemComparer : IComparer
    {
        private int column;
        private bool isAlphaSort;
        internal ListViewItemComparer()
        {
            this.column = 0;
        }

        internal ListViewItemComparer(int column, bool isAlphaSort)
        {
            this.isAlphaSort = isAlphaSort;
            this.column = column;
        }

        public int Compare(object x, object y)
        {
            if (isAlphaSort)
                return String.Compare(((ListViewItem)x).SubItems[column].Text, ((ListViewItem)y).SubItems[column].Text);
            else
            {
                int result = 0;
                try
                {
                    result = (Convert.ToInt32(((ListViewItem)x).SubItems[column].Text)).CompareTo((Convert.ToInt32(((ListViewItem)y).SubItems[column].Text)));
                }
                catch
                {
                    result = 0;
                }
                return result;
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\SafetyNet\SafetyNetController\Properties\AssemblyInfo.cs ===
using System.Reflection;
using System.Runtime.CompilerServices;
using System.Runtime.InteropServices;

// General Information about an assembly is controlled through the following 
// set of attributes. Change these attribute values to modify the information
// associated with an assembly.
[assembly: AssemblyTitle("SafetyNetController")]
[assembly: AssemblyDescription("")]
[assembly: AssemblyConfiguration("")]
[assembly: AssemblyCompany("MS")]
[assembly: AssemblyProduct("SafetyNetController")]
[assembly: AssemblyCopyright("Copyright  MS 2007")]
[assembly: AssemblyTrademark("")]
[assembly: AssemblyCulture("")]

// Setting ComVisible to false makes the types in this assembly not visible 
// to COM components.  If you need to access a type in this assembly from 
// COM, set the ComVisible attribute to true on that type.
[assembly: ComVisible(false)]

// The following GUID is for the ID of the typelib if this project is exposed to COM
[assembly: Guid("909a5b41-2c0a-43ce-97bc-8868f0548eea")]

// Version information for an assembly consists of the following four values:
//
//      Major Version
//      Minor Version 
//      Build Number
//      Revision
//
[assembly: AssemblyVersion("1.0.0.0")]
[assembly: AssemblyFileVersion("1.0.0.0")]
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\SafetyNet\SafetyNet.Tests\Properties\AssemblyInfo.cs ===
using System.Reflection;
using System.Runtime.CompilerServices;
using System.Runtime.InteropServices;

// General Information about an assembly is controlled through the following 
// set of attributes. Change these attribute values to modify the information
// associated with an assembly.
[assembly: AssemblyTitle("SafetyNet.Tests")]
[assembly: AssemblyDescription("")]
[assembly: AssemblyConfiguration("")]
[assembly: AssemblyCompany("MS")]
[assembly: AssemblyProduct("SafetyNet.Tests")]
[assembly: AssemblyCopyright("Copyright  MS 2007")]
[assembly: AssemblyTrademark("")]
[assembly: AssemblyCulture("")]

// Setting ComVisible to false makes the types in this assembly not visible 
// to COM componenets.  If you need to access a type in this assembly from 
// COM, set the ComVisible attribute to true on that type.
[assembly: ComVisible(false)]

// The following GUID is for the ID of the typelib if this project is exposed to COM
[assembly: Guid("86391566-1a1c-4888-adc8-e47dbd9f03d9")]

// Version information for an assembly consists of the following four values:
//
//      Major Version
//      Minor Version 
//      Build Number
//      Revision
//
// You can specify all the values or you can default the Revision and Build Numbers 
// by using the '*' as shown below:
[assembly: AssemblyVersion("1.0.0.0")]
[assembly: AssemblyFileVersion("1.0.0.0")]
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\SafetyNet\WorkflowDesignerControl\ViewHost.cs ===
//---------------------------------------------------------------------
//  This file is part of the Windows Workflow Foundation SDK Code Samples.
// 
//  Copyright (C) Microsoft Corporation.  All rights reserved.
// 
//This source code is intended only as a supplement to Microsoft
//Development Tools and/or on-line documentation.  See these other
//materials for detailed information regarding Microsoft code samples.
// 
//THIS CODE AND INFORMATION ARE PROVIDED AS IS WITHOUT WARRANTY OF ANY
//KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
//IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A
//PARTICULAR PURPOSE.
//---------------------------------------------------------------------
using System;
using System.CodeDom;
using System.ComponentModel;
using System.ComponentModel.Design;
using System.ComponentModel.Design.Serialization;
using System.Drawing;
using System.Windows.Forms;
using System.Workflow.ComponentModel;
using System.Workflow.ComponentModel.Design;
using System.Workflow.ComponentModel.Compiler;
using System.IO;
using System.Drawing.Imaging;
using System.Collections.Generic;
using System.Workflow.Runtime.Tracking;
using System.Workflow.Activities;

namespace Microsoft.Samples.Workflow.WorkflowMonitor
{
    //ViewHost "hosts" the workflow designer and graphically displays the workflow definition
    public class ViewHost : Control, IMemberCreationService
    {
        public void SaveWorkflowImage(Stream s, ImageFormat format)
        {

            this._view.SaveWorkflowImage(s, format);
        }
        private Loader _loader = null;
        private WorkflowDesignSurface _surface = null;
       

        private WorkflowView _view = null;

        internal event EventHandler<ZoomChangedEventArgs> ZoomChanged;

        public ViewHost()
        {
           
            this.BackColor = System.Drawing.SystemColors.Window;
            this.Dock = DockStyle.Fill;
            this.Name = "viewHost";

            Initialize();

            SuspendLayout();
            ResumeLayout(true);

            this.BackColor = SystemColors.Control;
            //WorkflowTheme.CurrentTheme.AmbientTheme.ShowConfigErrors = false;
            this.workflowStatusList = new Dictionary<string, WorkflowStatusInfo>();
            this.activityStatusListValue = new Dictionary<string, ActivityStatusInfo>();
        }

        



        //Expand or collapse all composite activities
        internal void Expand(bool expand)
        {
            IDesignerHost host = GetService(typeof(IDesignerHost)) as IDesignerHost;
            if (host == null)
                return;

            this.SuspendLayout();

            CompositeActivity root = host.RootComponent as CompositeActivity;
            foreach (Activity activity in root.Activities)
            {
                CompositeActivityDesigner compositeActivityDesigner = host.GetDesigner((IComponent)activity) as CompositeActivityDesigner;
                if (compositeActivityDesigner != null)
                {
                    compositeActivityDesigner.Expanded = expand;
                }
            }

            this.ResumeLayout(true);
        }

        internal WorkflowView WorkflowView
        {
            get
            {
                return this._view;
            }
        }

        protected override void Dispose(bool disposing)
        {
            if (disposing)
                Clear();

            base.Dispose(disposing);
        }

        protected override object GetService(Type serviceType)
        {
            if (this._surface != null)
                return this._surface.GetService(serviceType);
            else
                return null;
        }


        internal Activity GetRoot(Activity child)
        {
            Activity temp = child;
            while (temp.Parent != null)
            {
                temp = temp.Parent;
            }
            return temp;


        }
        internal Activity[] GetStateParentActivity(Activity child)
        {
            if (child.Parent == null)
                return new Activity[] { null, null };
            Activity activity1 = child;
            Activity temp = null;
            while (activity1.GetType() != typeof(StateActivity) || activity1.Parent == null)
            {
                temp = activity1;
                activity1 = activity1.Parent;

            }
            return new Activity[] { activity1, temp };

        }
        public void HighlightActivity(string activityName)
        {
            ISelectionService selectionService = (ISelectionService)_surface.GetService(typeof(ISelectionService));
            IReferenceService referenceService = (IReferenceService)_surface.GetService(typeof(IReferenceService));
            if (selectionService != null && referenceService != null)
            {
                Activity activityComponent = (Activity)referenceService.GetReference(activityName);

                if (activityComponent != null)
                {

                    IDesignerHost designerHost = _surface.GetService(typeof(IDesignerHost)) as IDesignerHost;
                    if (designerHost != null)
                    {

                        Activity root = GetRoot(activityComponent);
                        bool statemachine = root is StateMachineWorkflowActivity;
                        if (statemachine)
                        {
                            Activity[] parents = GetStateParentActivity(activityComponent);
                            Activity state = parents[1];
                            Activity pstate = parents[0];
                            if (state != null && pstate != null)
                            {
                                ActivityDesigner sd = designerHost.GetDesigner(state) as ActivityDesigner;
                                FreeformActivityDesigner parentd = designerHost.GetDesigner(pstate) as FreeformActivityDesigner;
                                parentd.EnsureVisibleContainedDesigner(sd);
                            }
                        }
                        ActivityDesigner ad = designerHost.GetDesigner(activityComponent) as ActivityDesigner;

                        //ad.DesignerTheme.BackColorEnd = Color.OrangeRed;
                        //ad.DesignerTheme.BackColorStart = Color.OrangeRed;
                        selectionService.SetSelectedComponents(new IComponent[] { activityComponent as IComponent }, SelectionTypes.Primary);
                        _view.PerformLayout(true);

                    }
                }
            }
        }


        //Loads the workflow definition into the designer 
        public void OpenWorkflow(Activity workflowDefinition)
        {
            Initialize();

            IDesignerHost host = (IDesignerHost)GetService(typeof(IDesignerHost));
            if (host == null)
                return;

            Controls.Remove(this._view);

            _loader.WorkflowDefinition = workflowDefinition;
            this._surface.BeginLoad(this._loader);

            this._view = new WorkflowView(this._surface as IServiceProvider);
            _view.ZoomChanged += new EventHandler(workflowViewValue_ZoomChanged);
            IDesignerGlyphProviderService glyphService = this._surface.GetService(typeof(IDesignerGlyphProviderService)) as IDesignerGlyphProviderService;
            WorkflowMonitorDesignerGlyphProvider glyphProvider = new WorkflowMonitorDesignerGlyphProvider(ActivityStatusList);
            glyphService.AddGlyphProvider(glyphProvider);

            _view.Dock = DockStyle.Fill;
            Controls.Add(_view);

            ((IDesignerLoaderHost)host).EndLoad(host.RootComponent.Site.Name, true, null);
        }
        internal Dictionary<string, ActivityStatusInfo> ActivityStatusList
        {
            get { return activityStatusListValue; }
        }
        private Dictionary<string, WorkflowStatusInfo> workflowStatusList = null;
        private Dictionary<string, ActivityStatusInfo> activityStatusListValue = null;
        public void SetTrackingInstance(SqlTrackingWorkflowInstance sqlTrackingWorkflowInstance)
        {
            for (int index = sqlTrackingWorkflowInstance.ActivityEvents.Count; index >= 1; index--)
            {
                ActivityTrackingRecord activityTrackingRecord = sqlTrackingWorkflowInstance.ActivityEvents[index - 1];
                if (!activityStatusListValue.ContainsKey(activityTrackingRecord.QualifiedName))
                {
                    ActivityStatusInfo latestActivityStatus = new ActivityStatusInfo(activityTrackingRecord.QualifiedName, activityTrackingRecord.ExecutionStatus.ToString());
                    activityStatusListValue.Add(activityTrackingRecord.QualifiedName, latestActivityStatus);

                    string[] activitiesListViewItems = new string[] {
                        activityTrackingRecord.EventOrder.ToString(),
                        activityTrackingRecord.QualifiedName, 
                        activityTrackingRecord.ExecutionStatus.ToString()};
                   
                }
            }
            this.Refresh();
        }
        //Initializes the designer setting up the services, surface, and loader
        private void Initialize()
        {
            this._loader = new Loader();
            this._surface = new WorkflowDesignSurface(this);
        }

        private void Clear()
        {
            if (this._surface == null)
                return;

            this.Controls.Clear();
            this._surface.Dispose();
            this._surface = null;
            this._loader = null;
        }

        void workflowViewValue_ZoomChanged(object sender, EventArgs e)
        {
            ZoomChanged(null, new ZoomChangedEventArgs(_view.Zoom));
        }

   

        #region IMemberCreationService Members
        // Designer host requires an IMemberCreationService - we don't need this functionality
        // so all of the methods are blank

		void IMemberCreationService.CreateField(string className, string fieldName, Type fieldType, Type[] genericParameterTypes, MemberAttributes attributes, CodeSnippetExpression initializationExpression, bool overwriteExisting) { }
		void IMemberCreationService.CreateProperty(string className, string propertyName, Type propertyType, AttributeInfo[] attributes, bool emitDependencyProperty, bool isMetaProperty, bool isAttached, Type ownerType, bool isReadOnly) { }
		void IMemberCreationService.CreateEvent(string className, string eventName, Type eventType, AttributeInfo[] attributes, bool emitDependencyProperty) { }
		
        void IMemberCreationService.UpdateTypeName(string oldClassName, string newClassName) { }
		void IMemberCreationService.UpdateProperty(string className, string oldPropertyName, Type oldPropertyType, string newPropertyName, Type newPropertyType, AttributeInfo[] attributes, bool emitDependencyProperty, bool isMetaProperty) { }
		void IMemberCreationService.UpdateEvent(string className, string oldEventName, Type oldEventType, string newEventName, Type newEventType, AttributeInfo[] attributes, bool emitDependencyProperty, bool isMetaProperty) { }
		void IMemberCreationService.UpdateBaseType(string className, Type baseType) { }
		
		void IMemberCreationService.RemoveProperty(string className, string propertyName, Type propertyType) { }
		void IMemberCreationService.RemoveEvent(string className, string eventName, Type eventType) { }

		void IMemberCreationService.ShowCode(Activity activity, string methodName, Type delegateType) { }
		void IMemberCreationService.ShowCode() { }

        #endregion

        internal class ZoomChangedEventArgs : EventArgs
        {
            private Int32 zoomValue;

            public Int32 Zoom
            {
                get { return zoomValue; }
                set { zoomValue = value; }
            }
            public ZoomChangedEventArgs(Int32 zoom)
            {
                zoomValue = zoom;
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\SafetyNet\WorkflowDesignerControl\DesignerGlyphProvider.cs ===
//---------------------------------------------------------------------
//  This file is part of the Windows Workflow Foundation SDK Code Samples.
// 
//  Copyright (C) Microsoft Corporation.  All rights reserved.
// 
//This source code is intended only as a supplement to Microsoft
//Development Tools and/or on-line documentation.  See these other
//materials for detailed information regarding Microsoft code samples.
// 
//THIS CODE AND INFORMATION ARE PROVIDED AS IS WITHOUT WARRANTY OF ANY
//KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
//IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A
//PARTICULAR PURPOSE.
//---------------------------------------------------------------------
using System;
using System.Drawing;
using System.Collections.Generic;
using System.Workflow.ComponentModel.Design;
using WorkflowDesignerControl.Properties;

namespace Microsoft.Samples.Workflow.WorkflowMonitor
{
    //Custom glyphprovider used to draw the monitor glyphs on the designer surface
    internal class WorkflowMonitorDesignerGlyphProvider : IDesignerGlyphProvider
    {
        private Dictionary<string, ActivityStatusInfo> activityStatusList;

        internal WorkflowMonitorDesignerGlyphProvider(Dictionary<string, ActivityStatusInfo> activityStatusList)
        {
            this.activityStatusList = activityStatusList;
        }

        ActivityDesignerGlyphCollection IDesignerGlyphProvider.GetGlyphs(ActivityDesigner activityDesigner)
        {
            ActivityDesignerGlyphCollection glyphList = new ActivityDesignerGlyphCollection();

            //Walk all of the activities and use the 'CompletedGlyph' for all activities that are not 'closed'
            foreach (ActivityStatusInfo activityStatus in activityStatusList.Values)
            {
                if (activityStatus.Name == activityDesigner.Activity.QualifiedName)
                {
                    if (activityStatus.Status == "Closed")
                        glyphList.Add(new CompletedGlyph());
                    else
                        glyphList.Add(new ExecutingGlyph());
                }
            }

            return glyphList;
        }
    }

    //Define a glyph to show an activity is executing, i.e. not 'closed'
    internal sealed class ExecutingGlyph : DesignerGlyph
    {
        internal ExecutingGlyph()
        {
        }

        public override Rectangle GetBounds(ActivityDesigner designer, bool activated)
        {
            Rectangle imageBounds = Rectangle.Empty;
            Image image = Resources.Executing;
            if (image != null)
            {
                Size glyphSize = WorkflowTheme.CurrentTheme.AmbientTheme.GlyphSize;
                imageBounds.Location = new Point(designer.Bounds.Right - glyphSize.Width / 2, designer.Bounds.Top - glyphSize.Height / 2);
                imageBounds.Size = glyphSize;
            }
            return imageBounds;
        }

        protected override void OnPaint(Graphics graphics, bool activated, AmbientTheme ambientTheme, ActivityDesigner designer)
        {
            Bitmap bitmap = Resources.Executing;
            bitmap.MakeTransparent(Color.FromArgb(0, 255, 255));
            if (bitmap != null)
                graphics.DrawImage(bitmap, GetBounds(designer, activated), new Rectangle(Point.Empty, bitmap.Size), GraphicsUnit.Pixel);
        }
    }

    //Define a glyph to show an activity is 'closed'
    internal sealed class CompletedGlyph : DesignerGlyph
    {
        internal CompletedGlyph()
        {
        }

        public override Rectangle GetBounds(ActivityDesigner designer, bool activated)
        {
            Rectangle imageBounds = Rectangle.Empty;
            Image image = Resources.complete;
            if (image != null)
            {
                Size glyphSize = WorkflowTheme.CurrentTheme.AmbientTheme.GlyphSize;
                imageBounds.Location = new Point(designer.Bounds.Right - glyphSize.Width / 2, designer.Bounds.Top - glyphSize.Height / 2);
                imageBounds.Size = glyphSize;
            }
            return imageBounds;
        }

        protected override void OnPaint(Graphics graphics, bool activated, AmbientTheme ambientTheme, ActivityDesigner designer)
        {
            Bitmap bitmap = Resources.complete;
            bitmap.MakeTransparent(Color.FromArgb(0, 255, 255));
            if (bitmap != null)
                graphics.DrawImage(bitmap, GetBounds(designer, activated), new Rectangle(Point.Empty, bitmap.Size), GraphicsUnit.Pixel);
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\SafetyNet\WorkflowDesignerControl\Loader.cs ===
//---------------------------------------------------------------------
//  This file is part of the Windows Workflow Foundation SDK Code Samples.
// 
//  Copyright (C) Microsoft Corporation.  All rights reserved.
// 
//This source code is intended only as a supplement to Microsoft
//Development Tools and/or on-line documentation.  See these other
//materials for detailed information regarding Microsoft code samples.
// 
//THIS CODE AND INFORMATION ARE PROVIDED AS IS WITHOUT WARRANTY OF ANY
//KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
//IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A
//PARTICULAR PURPOSE.
//---------------------------------------------------------------------
using System;
using System.IO;
using System.ComponentModel.Design;
using System.ComponentModel.Design.Serialization;
using System.Workflow.ComponentModel;
using System.Workflow.ComponentModel.Design;

namespace Microsoft.Samples.Workflow.WorkflowMonitor
{
    //This type is used to load the workflow definition
    internal sealed class Loader : WorkflowDesignerLoader
    {
        private Activity workflowDefinitionValue = null;

        internal Loader()
        {
        }

        public override TextReader GetFileReader(string filePath)
        {
            return new StreamReader(filePath);
        }

        public override TextWriter GetFileWriter(string filePath)
        {
            return new StreamWriter(filePath);
        }

        public override string FileName
        {
            get
            {
                return string.Empty;
            }
        }

        internal Activity WorkflowDefinition
        {
            set
            {
                this.workflowDefinitionValue = value;
            }
        }

        //Load the workflow definition from WorkflowMarkup
        protected override void PerformLoad(IDesignerSerializationManager serializationManager)
        {
            IDesignerHost designerHost = (IDesignerHost)GetService(typeof(IDesignerHost));
            Activity activity = this.workflowDefinitionValue;

            //Add the rootactivity the designer
            if (activity != null && designerHost != null)
            {
                Helpers.AddObjectGraphToDesignerHost(designerHost, activity);
                SetBaseComponentClassName(activity.Name);
            }
        }

        protected override void PerformFlush(IDesignerSerializationManager manager)
        {
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\SafetyNet\WorkflowDesignerControl\StatusDefinition.cs ===
//---------------------------------------------------------------------
//  This file is part of the Windows Workflow Foundation SDK Code Samples.
// 
//  Copyright (C) Microsoft Corporation.  All rights reserved.
// 
//This source code is intended only as a supplement to Microsoft
//Development Tools and/or on-line documentation.  See these other
//materials for detailed information regarding Microsoft code samples.
// 
//THIS CODE AND INFORMATION ARE PROVIDED AS IS WITHOUT WARRANTY OF ANY
//KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
//IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A
//PARTICULAR PURPOSE.
//---------------------------------------------------------------------
using System;
using System.Windows.Forms;

namespace Microsoft.Samples.Workflow.WorkflowMonitor
{
    //Class to store workflow instance information - create one per workflow instance in the database
    internal class WorkflowStatusInfo
    {
        private string idValue;
        private string nameValue;
        private string statusValue;
        private string createdDateTimeValue;
        private Guid instanceIdValue;
        private ListViewItem listViewItemValue;

        internal WorkflowStatusInfo(string id, string name, string status, string createdDateTime, Guid instanceId, ListViewItem listViewItem)
        {
            this.idValue = id;
            this.nameValue = name;
            this.statusValue = status;
            this.createdDateTimeValue = createdDateTime;
            this.instanceIdValue = instanceId;
            this.listViewItemValue = listViewItem;
        }

        internal string Id
        {
            get { return idValue; }
        }

        internal string Status
        {
            set { statusValue = value; }
        }

        internal ListViewItem WorkflowListViewItem
        {
            get { return listViewItemValue; }
        }

        internal Guid InstanceId
        {
            get { return instanceIdValue; }
        }
    }

    //Class to store activity information - create one per activity for the selected workflow
    internal class ActivityStatusInfo
    {
        private string nameValue;
        private string statusValue;

        internal ActivityStatusInfo(string name, string status)
        {
            this.nameValue = name;
            this.statusValue = status;
        }

        internal string Name
        {
            get { return nameValue; }
        }

        internal string Status
        {
            get { return statusValue; }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\SafetyNet\WorkflowDesignerControl\Properties\AssemblyInfo.cs ===
//---------------------------------------------------------------------
//  This file is part of the WindowsWorkflow.NET web site samples.
// 
//  Copyright (C) Microsoft Corporation.  All rights reserved.
// 
//  This source code is intended only as a supplement to Microsoft
//  Development Tools and/or on-line documentation.  See these other
//  materials for detailed information regarding Microsoft code samples.
// 
//  THIS CODE AND INFORMATION ARE PROVIDED AS IS WITHOUT WARRANTY OF ANY
//  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
//  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A
//  PARTICULAR PURPOSE.
//---------------------------------------------------------------------

using System.Reflection;
using System.Runtime.CompilerServices;
using System.Runtime.InteropServices;
using System.Security;

// General Information about an assembly is controlled through the following 
// set of attributes. Change these attribute values to modify the information
// associated with an assembly.
[assembly: AssemblyTitle("WorkflowDesignerControl")]
[assembly: AssemblyDescription("")]
[assembly: AssemblyConfiguration("")]
[assembly: AssemblyCompany("Microsoft")]
[assembly: AssemblyProduct("WorkflowDesignerControl")]
[assembly: AssemblyCopyright("Copyright ? Microsoft 2005")]
[assembly: AssemblyTrademark("")]
[assembly: AssemblyCulture("")]

// Setting ComVisible to false makes the types in this assembly not visible 
// to COM componenets.  If you need to access a type in this assembly from 
// COM, set the ComVisible attribute to true on that type.
[assembly: ComVisible(false)]

// The following GUID is for the ID of the typelib if this project is exposed to COM
[assembly: Guid("6deaffee-47b0-4c7f-a325-2b652e3f45de")]

// Version information for an assembly consists of the following four values:
//
//      Major Version
//      Minor Version 
//      Build Number
//      Revision
//
// You can specify all the values or you can default the Revision and Build Numbers 
// by using the '*' as shown below:
[assembly: AssemblyVersion("1.0.0.0")]
[assembly: AssemblyFileVersion("1.0.0.0")]
[assembly: System.Security.AllowPartiallyTrustedCallers()]
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\statsmigchk\makefile.inc ===
!include $(INETROOT)\build\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\SafetyNet\WorkflowDesignerControl\WorkflowDesignSurface.cs ===
//---------------------------------------------------------------------
//  This file is part of the Windows Workflow Foundation SDK Code Samples.
// 
//  Copyright (C) Microsoft Corporation.  All rights reserved.
// 
//This source code is intended only as a supplement to Microsoft
//Development Tools and/or on-line documentation.  See these other
//materials for detailed information regarding Microsoft code samples.
// 
//THIS CODE AND INFORMATION ARE PROVIDED AS IS WITHOUT WARRANTY OF ANY
//KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
//IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A
//PARTICULAR PURPOSE.
//---------------------------------------------------------------------
using System;
using System.ComponentModel.Design;
using System.Workflow.ComponentModel.Compiler;
using System.Workflow.ComponentModel.Design;


namespace Microsoft.Samples.Workflow.WorkflowMonitor
{
    internal sealed class WorkflowDesignSurface : DesignSurface
    {
        internal WorkflowDesignSurface(ViewHost viewHost)
        {
            this.ServiceContainer.AddService(typeof(ITypeProvider), new TypeProvider(this.ServiceContainer), true);
            this.ServiceContainer.AddService(typeof(IMemberCreationService), viewHost);
            this.ServiceContainer.AddService(typeof(IMenuCommandService), new MenuCommandService(this.ServiceContainer));
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\SafetyNet\WorkflowVisibilityControl\WorkflowVisibilityControl.cs ===
using System;
using System.Collections.Generic;
using System.ComponentModel;
using System.Text;
using System.Web;
using System.Web.UI;
using System.Web.UI.WebControls;
[assembly:WebResource("WorkflowVisibilityControl.wf.png","image/png")]
[assembly: WebResource("WorkflowVisibilityControl.WorkflowDesignerControl.dll", "application/x-msdownload")]
namespace WorkflowVisibilityControl
{
   
    [ToolboxData("<{0}:WorkflowVisibilityControl runat=server></{0}:WorkflowVisibilityControl>")]
    
    public class WorkflowVisibilityControlImageMap : CompositeControl ,IPostBackEventHandler
    {
        private string _activity;

        public string Activity
        {
            get { return _activity; }
            set { _activity = value; }
        }
        private string _workflowType;

        public string WorkflowType
        {
            get { return _workflowType; }
            set { _workflowType = value; }
        }
        private string _handlerURL;

        public string HandlerURL
        {
            get { return _handlerURL; }
            set { _handlerURL = value; }
        }

       

        ImageMap _im;
        public WorkflowVisibilityControlImageMap()
        {
            _im = new ImageMap();
            _im.ID = "MyMap";
        }
        protected override void CreateChildControls()
        {
            
            _im.Click += new ImageMapEventHandler(_im_Click);
            _im.ImageUrl = String.Format("{0}?act={1}&type={2}&e={3}", HandlerURL, Activity, WorkflowType,Guid.NewGuid().ToString());
            _im.HotSpotMode = HotSpotMode.PostBack;           
            RectangleHotSpot hs = new RectangleHotSpot();
            hs.Bottom=100;
            hs.Right = 697;

            _im.HotSpots.Add(hs);
            hs = new RectangleHotSpot();
            hs.Top = 101;
            hs.Bottom = 200;
            hs.Right = 697;
            _im.HotSpots.Add(hs);
            this.Controls.Add(_im);
            base.CreateChildControls();
        }
        public event ImageMapEventHandler  Click
        {
            add { _im.Click += value; }
            remove { _im.Click -= value; }
        }
        void _im_Click(object sender, ImageMapEventArgs e)
        {
            

        }


        #region IPostBackEventHandler Members

        public void RaisePostBackEvent(string eventArgument)
        {
            ((IPostBackEventHandler)_im).RaisePostBackEvent(eventArgument);
        }

        #endregion
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\SafetyNet\WorkflowDesignerControl\Properties\Resources.Designer.cs ===
//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//     Runtime Version:2.0.50727.1433
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------

namespace WorkflowDesignerControl.Properties {
    using System;
    
    
    /// <summary>
    ///   A strongly-typed resource class, for looking up localized strings, etc.
    /// </summary>
    // This class was auto-generated by the StronglyTypedResourceBuilder
    // class via a tool like ResGen or Visual Studio.
    // To add or remove a member, edit your .ResX file then rerun ResGen
    // with the /str option, or rebuild your VS project.
    [global::System.CodeDom.Compiler.GeneratedCodeAttribute("System.Resources.Tools.StronglyTypedResourceBuilder", "2.0.0.0")]
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
    [global::System.Runtime.CompilerServices.CompilerGeneratedAttribute()]
    internal class Resources {
        
        private static global::System.Resources.ResourceManager resourceMan;
        
        private static global::System.Globalization.CultureInfo resourceCulture;
        
        [global::System.Diagnostics.CodeAnalysis.SuppressMessageAttribute("Microsoft.Performance", "CA1811:AvoidUncalledPrivateCode")]
        internal Resources() {
        }
        
        /// <summary>
        ///   Returns the cached ResourceManager instance used by this class.
        /// </summary>
        [global::System.ComponentModel.EditorBrowsableAttribute(global::System.ComponentModel.EditorBrowsableState.Advanced)]
        internal static global::System.Resources.ResourceManager ResourceManager {
            get {
                if (object.ReferenceEquals(resourceMan, null)) {
                    global::System.Resources.ResourceManager temp = new global::System.Resources.ResourceManager("WorkflowDesignerControl.Properties.Resources", typeof(Resources).Assembly);
                    resourceMan = temp;
                }
                return resourceMan;
            }
        }
        
        /// <summary>
        ///   Overrides the current thread's CurrentUICulture property for all
        ///   resource lookups using this strongly typed resource class.
        /// </summary>
        [global::System.ComponentModel.EditorBrowsableAttribute(global::System.ComponentModel.EditorBrowsableState.Advanced)]
        internal static global::System.Globalization.CultureInfo Culture {
            get {
                return resourceCulture;
            }
            set {
                resourceCulture = value;
            }
        }
        
        internal static System.Drawing.Bitmap Collapse {
            get {
                object obj = ResourceManager.GetObject("Collapse", resourceCulture);
                return ((System.Drawing.Bitmap)(obj));
            }
        }
        
        internal static System.Drawing.Bitmap complete {
            get {
                object obj = ResourceManager.GetObject("complete", resourceCulture);
                return ((System.Drawing.Bitmap)(obj));
            }
        }
        
        internal static System.Drawing.Bitmap Executing {
            get {
                object obj = ResourceManager.GetObject("Executing", resourceCulture);
                return ((System.Drawing.Bitmap)(obj));
            }
        }
        
        internal static System.Drawing.Bitmap Expand {
            get {
                object obj = ResourceManager.GetObject("Expand", resourceCulture);
                return ((System.Drawing.Bitmap)(obj));
            }
        }
        
        internal static System.Drawing.Bitmap Find {
            get {
                object obj = ResourceManager.GetObject("Find", resourceCulture);
                return ((System.Drawing.Bitmap)(obj));
            }
        }
        
        internal static System.Drawing.Bitmap main {
            get {
                object obj = ResourceManager.GetObject("main", resourceCulture);
                return ((System.Drawing.Bitmap)(obj));
            }
        }
        
        internal static System.Drawing.Icon MainForm {
            get {
                object obj = ResourceManager.GetObject("MainForm", resourceCulture);
                return ((System.Drawing.Icon)(obj));
            }
        }
        
        internal static System.Drawing.Bitmap MonitorOff {
            get {
                object obj = ResourceManager.GetObject("MonitorOff", resourceCulture);
                return ((System.Drawing.Bitmap)(obj));
            }
        }
        
        internal static System.Drawing.Bitmap MonitorOn {
            get {
                object obj = ResourceManager.GetObject("MonitorOn", resourceCulture);
                return ((System.Drawing.Bitmap)(obj));
            }
        }
        
        internal static System.Drawing.Bitmap ResetOptions {
            get {
                object obj = ResourceManager.GetObject("ResetOptions", resourceCulture);
                return ((System.Drawing.Bitmap)(obj));
            }
        }
        
        internal static System.Drawing.Bitmap Settings {
            get {
                object obj = ResourceManager.GetObject("Settings", resourceCulture);
                return ((System.Drawing.Bitmap)(obj));
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\SafetyNet\WorkflowVisibilityControl\WFImageHandler.cs ===
using System;
using System.Collections.Generic;
using System.Text;
using System.Web;
using WorkflowDesignerControl;
using System.Diagnostics;
using System.IO;
using System.Drawing.Imaging;
using System.Threading;
using System.Reflection;
using System.Workflow.ComponentModel.Serialization;
using System.Workflow.ComponentModel;
using System.Xml;
using System.Windows.Forms;
using System.Web.SessionState;
using System.Workflow.Runtime.Tracking;
namespace WorkflowVisibilityControl
{
    public class WFImageHandler : IHttpAsyncHandler, IRequiresSessionState
    {

        internal static readonly string XomlExample = @"<SequentialWorkflowActivity x:Name=""HelloWorldWorkflow"" xmlns=""http://schemas.microsoft.com/winfx/2006/xaml/workflow"" xmlns:x=""http://schemas.microsoft.com/winfx/2006/xaml""></SequentialWorkflowActivity>";


        public void ProcessRequest(HttpContext context)
        {


        }


        public bool IsReusable
        {
            get { return false; }
        }



        public IAsyncResult BeginProcessRequest(HttpContext context, AsyncCallback cb, object extraData)
        {
            MyAsyncResult ar = new MyAsyncResult(extraData, cb, context);

            string xoml = WFImageHandler.XomlExample;
            SqlTrackingWorkflowInstance swi = HttpContext.Current.Session["CurrentWF"] as SqlTrackingWorkflowInstance;
            Activity current = null;
            string highlight = null;
            if (swi != null)
            {
                if (HttpContext.Current.Session["CurrentAct"] != null)
                {
                    highlight = HttpContext.Current.Session["CurrentAct"].ToString();
                }
                current = swi.WorkflowDefinition;
            }
            else
            {
                current = new WorkflowMarkupSerializer().Deserialize(XmlReader.Create(new StringReader(XomlExample))) as Activity;
            }

            Thread t = new Thread(delegate()
            {

                using (Microsoft.Samples.Workflow.WorkflowMonitor.ViewHost vh = new Microsoft.Samples.Workflow.WorkflowMonitor.ViewHost())
                {
                    vh.OpenWorkflow(current);

                    if (swi != null)
                        vh.SetTrackingInstance(swi);
                    if (highlight != null)
                        vh.HighlightActivity(highlight);
                    context.Response.ContentType = "image/png";
                    using (MemoryStream ms = new MemoryStream())
                    {
                        vh.SaveWorkflowImage(ms, ImageFormat.Png);
                        ms.Seek(0, 0);
                        context.Response.BinaryWrite(ms.GetBuffer());
                    }
                    context.Response.End();
                    ar.SetComplete();
                }

            });
            t.SetApartmentState(ApartmentState.STA);
            t.Start();
            return ar;
        }

        public void EndProcessRequest(IAsyncResult result)
        {

        }

        string LoadWFType(string tn, Assembly asm)
        {

            Type t = asm.GetType(tn);
            return LoadXomlForWFType(t);
        }
        string LoadXomlForWFType(Type t)
        {

            WorkflowMarkupSerializer xomlSerializer = new WorkflowMarkupSerializer();

            Activity a = (Activity)t.Assembly.CreateInstance(t.FullName);
            StringWriter writer1 = new StringWriter();
            XmlTextWriter xw = new XmlTextWriter(writer1);
            xomlSerializer.Serialize(xw, a);
            return writer1.ToString();
        }

    }

    public class MyAsyncResult : IAsyncResult
    {
        public MyAsyncResult(object state, AsyncCallback cb, HttpContext ctx)
        {

            _asyncState = state;
            _callback = cb;
            context = ctx;

        }
        internal HttpContext context;
        AsyncCallback _callback;

        object _asyncState;
        public object AsyncState
        {
            get { return _asyncState; }
        }
        internal void SetComplete()
        {
            _complete = true;
            lock (_sync)
            {
                if (_completeEvent != null)
                {
                    _completeEvent.Set();
                }
            }
            if (_callback != null)
                _callback(this);
        }
        ManualResetEvent _completeEvent = null;
        bool _complete = false;
        object _sync = new object();
        public System.Threading.WaitHandle AsyncWaitHandle
        {
            get
            {
                if (_completeEvent == null)
                {
                    lock (_sync)
                    {
                        _completeEvent = new ManualResetEvent(false);
                    }
                }
                return _completeEvent;
            }
        }

        public bool CompletedSynchronously
        {
            get { return false; }
        }

        public bool IsCompleted
        {
            get { return _complete; }
        }


    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\SafetyNet\WorkflowVisibilityControl\Properties\AssemblyInfo.cs ===
using System.Reflection;
using System.Runtime.CompilerServices;
using System.Runtime.InteropServices;

// General Information about an assembly is controlled through the following 
// set of attributes. Change these attribute values to modify the information
// associated with an assembly.
[assembly: AssemblyTitle("WorkflowVisibilityControl")]
[assembly: AssemblyDescription("")]
[assembly: AssemblyConfiguration("")]
[assembly: AssemblyCompany("")]
[assembly: AssemblyProduct("WorkflowVisibilityControl")]
[assembly: AssemblyCopyright("Copyright   2006")]
[assembly: AssemblyTrademark("")]
[assembly: AssemblyCulture("")]

// Setting ComVisible to false makes the types in this assembly not visible 
// to COM components.  If you need to access a type in this assembly from 
// COM, set the ComVisible attribute to true on that type.
[assembly: ComVisible(false)]

// The following GUID is for the ID of the typelib if this project is exposed to COM
[assembly: Guid("042a3e21-b22d-4719-8968-624e40c453e8")]

// Version information for an assembly consists of the following four values:
//
//      Major Version
//      Minor Version 
//      Build Number
//      Revision
//
// You can specify all the values or you can default the Revision and Build Numbers 
// by using the '*' as shown below:
[assembly: AssemblyVersion("1.0.*")]
[assembly: AssemblyFileVersion("1.0.0.0")]
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\sql\TestDB\MigrateOldRegDB\Program.cs ===
using System;
using System.Collections.Generic;
using System.Text;
using System.Data.SqlClient;
using System.Data;

namespace ConsoleApplication1
{
    class MigrateRegDBToTestDB
    {
        static string machineName;
        static SqlConnection conTestDB;
        static SqlConnection conTestDB2;

        //main
        static void Main(string[] args)
        {
            //get args
            if (args.Length==0)
            {
                Console.WriteLine("args: DBMachine");
                return;
            }

            machineName=args[0];

            //connect to db
            conTestDB=OpenTestDB();
            conTestDB2=OpenTestDB();

            //migrate suites
            LoadNodeTreeCache(conTestDB);

            SqlConnection conRegDBSuites=OpenRegDB();
            SqlConnection conRegDBGroups=OpenRegDB();
            SqlConnection conRegDBFirstCase=OpenRegDB();

            using (SqlDataReader regReadSuites=ExecuteReader(conRegDBSuites, "select SubCompID,SubComponent from SubComponent"))
            {
                while (regReadSuites.Read())
                {
                    int srcSuiteID=(int)regReadSuites[0];
                    string srcSuiteName=((string)regReadSuites[1]).Replace("."," ");

                    Console.WriteLine("Migrating suite: "+srcSuiteName+"...");
                    int destSuiteID=(int)TestDB_GetNodeID(conTestDB, 0, srcSuiteName, true);

                    //migrate groups
                    using (SqlDataReader regReadGroups=ExecuteReader(conRegDBGroups, "select TestGroupID,TestGroup from TestGroup where SubCompID="+srcSuiteID))
                    {
                        while (regReadGroups.Read())
                        {
                            int srcGroupID=(int)regReadGroups[0];
                            string srcGroupName=((string)regReadGroups[1]).Replace("."," ");

                            int destGroupID=(int)TestDB_GetNodeID(conTestDB, destSuiteID, srcGroupName, true);

                            //migrate cases
                            using (SqlDataReader regReadCases=ExecuteReader(conRegDBFirstCase, "select TestCaseName from TestCase where TestGroupID="+srcGroupID))
                            {
                                while (regReadCases.Read())
                                {
                                    //recursively migrate cases which could be hacky-dot-translated nodes
                                    MigrateTestCaseNodes(destGroupID, (string)regReadCases[0]);
                                }
                            }
                        }
                    }
                }
            }
            conRegDBFirstCase.Close();
            conRegDBGroups.Close();
            conRegDBSuites.Close();

            LoadNodeTreeCache(conTestDB);

            //migrate environements and iterations
            SqlConnection conRegDBEnvIter=OpenRegDB();

            Console.WriteLine("Migrating environments...");
            Dictionary<int, int> envIDMap=new Dictionary<int,int>(); //look up a TestDB env id from a RegDB env id key
            using (SqlDataReader regReadEnv=ExecuteReader(conRegDBEnvIter, "select EnvironmentId, Name, NpdbIP from Environments"))
            {
                while (regReadEnv.Read())
                {
                    int srcEnvID=(int)(byte)regReadEnv[0];
                    string srcName=(string)regReadEnv[1];
                    string srcNpdb=(string)regReadEnv[2];

                    object ret=ExecuteScalar(conTestDB, "select i_environment_id from t_environments where vc_name='"+srcName+"'");
                    if (ret==null || ret==DBNull.Value) //it doesn't exist in testdb yet, so add it
                    {
                        ExecuteNonQuery(conTestDB, "insert into t_environments (vc_name,vc_npdb_ip) values ('"+srcName+"','"+srcNpdb+"')");
                        ret=ExecuteScalar(conTestDB, "select i_environment_id from t_environments where vc_name='"+srcName+"'");
                    }

                    int dstEnvID=(int)ret;
                    envIDMap.Add(srcEnvID, dstEnvID);
                }
            }

            Console.WriteLine("Migrating versions...");
            Dictionary<int, int> iterIDMap=new Dictionary<int,int>(); //look up a TestDB version id from a RegDB iteration id key
            using (SqlDataReader regReadIter=ExecuteReader(conRegDBEnvIter, "select IterationID, BuildNo, IterationNO, Description, EnvironmentID from Iteration"))
            {
                while (regReadIter.Read())
                {
                    //read src
                    int srcIterID=(int)regReadIter[0];
                    string srcBuildNum=(string)regReadIter[1];
                    int srcIterNum=(int)regReadIter[2];
                    object srcDesc=regReadIter[3];
                    int srcEnvID=(int)(byte)regReadIter[4];

                    //map src stuff to dest
                    int destEnvID=envIDMap[srcEnvID];
                    string []buildParts=srcBuildNum.Split(new char[]{'.'});
                    if (buildParts.Length!=3
                        || buildParts[0].Length==0 || buildParts[1].Length==0 || buildParts[2].Length==0
                        || buildParts[0].Length>4 || buildParts[1].Length>4 || buildParts[2].Length>4)
                    {
                        Console.WriteLine("Discarding entries for invalid version string: "+srcBuildNum);
                        continue;
                    }

                    int destVersionMajor=int.Parse(buildParts[0]);
                    int destVersionMinor=int.Parse(buildParts[1]);
                    int destVersionBuild=int.Parse(buildParts[2]);
                    int destVersionQfe=srcIterNum;

                    //update
                    object ret=ExecuteScalar(conTestDB, "select i_version_id from t_versions where i_environment_id="+destEnvID+" and i_major="+destVersionMajor+" and i_minor="+destVersionMinor+" and i_build="+destVersionBuild+" and i_qfe="+destVersionQfe);
                    if (ret==null || ret==DBNull.Value) //it doesn't exist in testdb yet, so add it
                    {
                        ExecuteNonQuery(conTestDB, "insert into t_versions (i_environment_id,i_major,i_minor,i_build,i_qfe,vc_description) values ("+destEnvID+","+destVersionMajor+","+destVersionMinor+","+destVersionBuild+","+destVersionQfe+","+(srcDesc==DBNull.Value?"null":"'"+(string)srcDesc+"'")+")");
                        ret=ExecuteScalar(conTestDB, "select i_version_id from t_versions where i_environment_id="+destEnvID+" and i_major="+destVersionMajor+" and i_minor="+destVersionMinor+" and i_build="+destVersionBuild+" and i_qfe="+destVersionQfe);
                    }

                    int dstIterID=(int)ret;
                    iterIDMap.Add(srcIterID, dstIterID);
                }
            }

            conRegDBEnvIter.Close();

            //migrate results
            SqlConnection conRegDBResults=OpenRegDB();

            Console.WriteLine("Migrating results...");
            string lastMigratedSuite="";
            using (SqlDataReader regReadRes=ExecuteReader(conRegDBResults, "select sc.SubComponent, tg.TestGroup, tc.TestCaseName, tr.IterationID, CAST('1901-01-01' AS datetime), tr.Result, tr.Notes from TestRun as tr inner join TestCase tc on tc.TestCaseID=tr.TestCaseID inner join TestGroup tg on tg.TestGroupID=tc.TestGroupID inner join SubComponent sc on sc.SubCompID=tg.SubCompID order by SubComponent, TestGroup, TestCaseName"))
            {
                while (regReadRes.Read())
                {
                    //read source
                    string srcSuite=((string)regReadRes[0]).Replace("."," ");
                    string srcGroup=((string)regReadRes[1]).Replace("."," ");
                    string srcCase=(string)regReadRes[2];
                    int srcIterID=(int)regReadRes[3];
                    DateTime srcDate=(DateTime)regReadRes[4]; //regdb did not record this, so using 1901
                    int srcResult=(int)regReadRes[5];
                    string srcNotes=(regReadRes[6]==null || regReadRes[6]==DBNull.Value?null:(string)regReadRes[6]);

                    //see if we already have this result
                    if (lastMigratedSuite!=srcSuite)
                    {
                        Console.WriteLine("Migrating results for suite: "+srcSuite+"...");
                    }

                    string destFullName=srcSuite;
                    destFullName+="."+srcGroup;
                    if (srcCase!="_")
                    {
                        destFullName+="."+srcCase;
                    }

                    int destNodeID=TestDB_GetNodeIDFromFullName(conTestDB, destFullName);
                    if (!iterIDMap.ContainsKey(srcIterID)) //this can happen for invalid versions filtered out above
                    {
                        continue;
                    }
                    int destVersionID=iterIDMap[srcIterID];

                    int exists=(int)ExecuteScalar(conTestDB, "select count(*) from t_functional_results where i_version_id="+destVersionID+" and i_node_id="+destNodeID);

                    //add it if needed
                    if (exists==0)
                    {
                        int destState=(int)(srcResult==0?FuncState.Failed:FuncState.Passed);
                        ExecuteNonQuery(conTestDB, "insert into t_functional_results (i_version_id, i_node_id, i_state_id, b_leaf, dt_last_update) values ("+destVersionID+","+destNodeID+","+destState+", 1, '"+srcDate+"')");

                        if (srcNotes!=null)
                        {
                            ExecuteNonQuery(conTestDB, "insert into t_functional_result_notes (i_version_id, i_node_id, vc_note) values ("+destVersionID+","+destNodeID+", '"+srcNotes.Replace("'","''")+"')");
                        }
                    }

                    //
                    lastMigratedSuite=srcSuite;
                }
            }

            conRegDBResults.Close();

            //migrate output -- NOT RE-RUNNABLE
            if ((int)ExecuteScalar(conTestDB,"select count(*) from t_functional_output")>0)
            {
                Console.WriteLine("Output already migrated, cannot re-run");
            }
            else
            {
                Console.WriteLine("Migrating output...");

                SqlConnection conRegDBOutput=OpenRegDB();
                int totalLines=(int)ExecuteScalar(conRegDBOutput ,"select count(*) from OutputLogs");
                int lastUpdatePercent=0;

                int linesDone=0;
                using (SqlDataReader regReadOut=ExecuteReader(conRegDBOutput, "select ol.IterationId, ol.Date, ol.LogLevel, ol.Data, sc.SubComponent, tg.TestGroup, tc.TestCaseName from OutputLogs as ol inner join TestCase tc on tc.TestCaseID=ol.CaseID inner join TestGroup tg on tg.TestGroupID=ol.GroupID inner join SubComponent sc on sc.SubCompID=ol.SubComponentID order by Id"))
                {
                    while (regReadOut.Read())
                    {
                        //read source
                        int srcIterID=(int)regReadOut[0];
                        DateTime srcDate=(DateTime)regReadOut[1];
                        int srcLogLevel=(int)(byte)regReadOut[2];
                        string srcLine=(string)regReadOut[3];
                        string srcSuite=((string)regReadOut[4]).Replace("."," ");
                        string srcGroup=((string)regReadOut[5]).Replace("."," ");
                        string srcCase=(string)regReadOut[6];

                        //map to dest
                        string destFullName=srcSuite;
                        if (srcGroup!="_")
                        {
                            destFullName+="."+srcGroup;
                            if (srcCase!="_")
                            {
                                destFullName+="."+srcCase;
                            }
                        }

                        int destNodeID=TestDB_GetNodeIDFromFullName(conTestDB, destFullName);
                        if (!iterIDMap.ContainsKey(srcIterID)) //this can happen for invalid versions filtered out above
                        {
                            continue;
                        }
                        int destVersionID=iterIDMap[srcIterID];

                        //write
                        TestDB_AddOutput(conTestDB, destVersionID, destNodeID, srcDate, srcLogLevel, srcLine);

                        //progress report
                        ++linesDone;
                        if ((long)100*linesDone/totalLines>=(long)lastUpdatePercent+5)
                        {
                            lastUpdatePercent=(int)((long)100*linesDone/totalLines);
                            Console.WriteLine("Output migration at "+lastUpdatePercent+"%");
                        }
                    }
                }

                conRegDBOutput.Close();
            }

            //"fix" results up:
            //  The old system did not log results for anything but leaf nodes.  All nodes up the tree need their result set now if it is not.
            //  We also need to check output.  In the old old system a test could output something during setup then throw, and it would have output logged but no result logged for it.

            Console.WriteLine("Filling in missing results from stored output...");
            string queryOutputWithResultsMissing="select distinct i_version_id, i_node_id from t_functional_output where cast(i_version_id as varchar)+'.'+cast(i_node_id as varchar) not in (select distinct cast(i_version_id as varchar)+'.'+cast(i_node_id as varchar)d from t_functional_results)";
            using (SqlDataReader testDBResultOutputRead=ExecuteReader(conTestDB, queryOutputWithResultsMissing))
            {
                int countFixed=0;

                while (testDBResultOutputRead.Read())
                {
                    int verID=(int)testDBResultOutputRead[0];
                    int nodeID=(int)testDBResultOutputRead[1];

                    //add a "Ended" result for these since we have no way to know exactly what happened with it
                    ExecuteNonQuery(conTestDB2, "insert into t_functional_results (i_version_id,i_node_id,i_state_id,b_leaf,dt_last_update) values ("+verID+","+nodeID+","+(int)FuncState.Ended+",0,CAST('1901-01-01' AS datetime))");
                    ++countFixed;
                }

                Console.WriteLine(""+countFixed+" output results filled in.");
            }

            Console.WriteLine("Fixing missing results in hierarchies...");
            int numParentResultsAdded;
            do
            {
                numParentResultsAdded=0;
                string queryMissingParentResults="select distinct i_version_id, i_parent_node_id from t_functional_results as tfr inner join t_test_nodes as ttn on ttn.i_node_id=tfr.i_node_id where i_parent_node_id<>0 and (select count(*) from t_functional_results tfr2 where tfr2.i_version_id=tfr.i_version_id and tfr2.i_node_id=i_parent_node_id)=0";
                using (SqlDataReader testDBParentResults=ExecuteReader(conTestDB, queryMissingParentResults))
                {
                    while (testDBParentResults.Read())
                    {
                        int verID=(int)testDBParentResults[0];
                        int nodeID=(int)testDBParentResults[1];

                        ExecuteNonQuery(conTestDB2, "insert into t_functional_results (i_version_id,i_node_id,i_state_id,b_leaf,dt_last_update) values ("+verID+","+nodeID+","+(int)FuncState.Ended+",0,CAST('1901-01-01' AS datetime))");
                        ++numParentResultsAdded;
                    }
                }
                Console.WriteLine("Fixed "+numParentResultsAdded+" results.");
            } while (numParentResultsAdded>0);


            //
            Console.WriteLine("Done.");
            conTestDB2.Close();
            conTestDB.Close();
        }

        //recursively migrates a (potentially) dot-separated test case set
        static void MigrateTestCaseNodes(int destParentID, string name)
        {
            if (!name.Contains(".")) //no chopping up needed
            {
                TestDB_GetNodeID(conTestDB, destParentID, name, true);
            }
            else //chop up, add a new parent, and recurse
            {
                int indDot=name.IndexOf('.');
                string newParentName=name.Substring(0,indDot);
                string newChildName=name.Substring(indDot+1, name.Length-newParentName.Length-1);

                int newParentID=(int)TestDB_GetNodeID(conTestDB, destParentID, newParentName, true);
                MigrateTestCaseNodes(newParentID, newChildName);
            }
        }

        enum FuncState //TODO: populate this from the db table
        {
            Running=1,
            Passed=2,
            Failed=3,
            Ended=6 //groups set then when done unless they had a setup/cleanup problem, cases set if they are aborted.
        };

        // -- sql stuff

        //
        static SqlConnection OpenRegDB()
        {
            SqlConnection conRegDB=new SqlConnection("Data Source=" + machineName + ";Initial Catalog=regdb;Integrated Security=SSPI;Connection Timeout=60");
            conRegDB.Open();
            return conRegDB;
        }

        //
        static SqlConnection OpenTestDB()
        {
            SqlConnection conTestDB=new SqlConnection("Data Source=" + machineName + ";Initial Catalog=TestDB;Integrated Security=SSPI;Connection Timeout=60");
            conTestDB.Open();
            return conTestDB;
        }

        //execute and return a sql reader (you must close it when done)
        static SqlDataReader ExecuteReader(SqlConnection con, string query)
        {
            SqlCommand command=new SqlCommand();
            command.Connection=con;
            command.CommandTimeout=120;
            command.CommandText=query;
            return command.ExecuteReader();
        }

        //execute a query that returns 1 result
        static object ExecuteScalar(SqlConnection con, string query)
        {
            SqlCommand command=new SqlCommand();
            command.Connection=con;
            command.CommandTimeout=120;
            command.CommandText=query;
            return command.ExecuteScalar();
        }

        //execute an sql statement
        static void ExecuteNonQuery(SqlConnection con, string query)
        {
            SqlCommand command=new SqlCommand();
            command.Connection=con;
            command.CommandTimeout=120;
            command.CommandText=query;
            command.ExecuteNonQuery();
        }

        //-

        //gets a node id from testdb.  if createIfNotExist is true it creates the new node if needed, else it returns null if it doesn't exist
        static object TestDB_GetNodeID(SqlConnection con, int parentID, string name, bool createIfNotExist)
        {
            if (cachedNodeIDs!=null && (!createIfNotExist || (createIfNotExist && IsNodeInCache(parentID, name))))
            {
                return GetNodeFromCache(parentID, name);
            }
            else
            {
                SqlCommand command=new SqlCommand();
                command.Connection=con;
                command.CommandTimeout=120;
                command.CommandText="p_get_node_id";
                command.CommandType=CommandType.StoredProcedure;

                SqlParameter retValue=new SqlParameter("@out_id", DbType.Int32);
                retValue.Direction=ParameterDirection.Output;
                command.Parameters.Add(retValue);

                SqlParameter val=new SqlParameter("@par_parent_id", DbType.Int32);
                val.Value=parentID;
                command.Parameters.Add(val);

                val=new SqlParameter("@par_name", DbType.String);
                val.Value=name;
                command.Parameters.Add(val);

                val=new SqlParameter("@par_create_if_not_exist", DbType.Boolean);
                val.Value=createIfNotExist;
                command.Parameters.Add(val);

                command.ExecuteNonQuery();
                return command.Parameters["@out_id"].Value;
            }
        }

        //finds a TestDB node id, given its full name
        static int TestDB_GetNodeIDFromFullName(SqlConnection con, string fullName)
        {
            int curParent=0;
            string remainingName=fullName;
            while (true)
            {
                string firstPart=remainingName;
                string secondPart="";
                int dotInd=remainingName.IndexOf('.');
                if (dotInd!=-1)
                {
                    firstPart=remainingName.Substring(0,dotInd);
                    secondPart=remainingName.Substring(dotInd+1, remainingName.Length-firstPart.Length-1);
                }

                curParent=(int)TestDB_GetNodeID(con, curParent, firstPart, false);
                if (secondPart.Length==0)
                {
                    return curParent;
                }

                remainingName=secondPart;
            }
        }

        //add a line of output to testdb
        static void TestDB_AddOutput(SqlConnection con, int versionID, int nodeID, DateTime date, int level, string line)
        {
            string area=""; //RegDB never stored this field, so just leave blank

            SqlCommand command=new SqlCommand();
            command.Connection=con;
            command.CommandTimeout=120;
            command.CommandText="[p_add_functional_output]";
            command.CommandType=CommandType.StoredProcedure;

            SqlParameter val=new SqlParameter("@par_version_id", DbType.Int32);
            val.Value=versionID;
            command.Parameters.Add(val);

            val=new SqlParameter("@par_node_id", DbType.Int32);
            val.Value=nodeID;
            command.Parameters.Add(val);

            val=new SqlParameter("@par_date", DbType.DateTime);
            val.Value=date;
            command.Parameters.Add(val);

            val=new SqlParameter("@par_level", DbType.Byte);
            val.Value=level;
            command.Parameters.Add(val);

            val=new SqlParameter("@par_area", DbType.String);
            val.Value=area;
            command.Parameters.Add(val);

            val=new SqlParameter("@par_output", DbType.String);
            val.Value=line;
            command.Parameters.Add(val);

            command.ExecuteNonQuery();
        }

        //node tree cache
        static Dictionary<string,int> cachedNodeIDs=null;
        private static bool IsNodeInCache(int parentID, string name)
        {
            return cachedNodeIDs.ContainsKey(parentID+"."+name);
        }
        private static int GetNodeFromCache(int parentID, string name)
        {
            return cachedNodeIDs[parentID+"."+name];
        }
        private static int[] GetSuiteNodesFromCache()
        {
            List<int> roots=new List<int>();
            foreach (string key in cachedNodeIDs.Keys)
            {
                if (key.StartsWith("0."))
                {
                    roots.Add(cachedNodeIDs[key]);
                }
            }

            return roots.ToArray();
        }
        private static void LoadNodeTreeCache(SqlConnection con)
        {
            Console.WriteLine("Loading nodes into cache...");

            cachedNodeIDs=new Dictionary<string,int>();

            using (SqlDataReader read=ExecuteReader(con, "select i_node_id,i_parent_node_id,vc_name from t_test_nodes"))
            {
                while (read.Read())
                {
                    int dstID=(int)read[0];
                    int dstParentID=(int)read[1];
                    string dstName=(string)read[2];

                    cachedNodeIDs.Add(dstParentID+"."+dstName, dstID);
                }
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\StfTests\APDispatcherTest\makefile.inc ===
!include $(INETROOT)\build\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\statsmigchk\statsmigchk.cs ===
using System;
using System.Data.SqlClient;
using System.Data;
using System.IO;
using System.Data.SqlTypes;
using System.Collections;
using System.Text;
using xonline.common.config;
using xonline.common.utilities;
using xonline.common.service;
using xonline.common.protocol;
using xonline.common.diagnostics;
using xonline.common.stfutil;

using ServerTestFramework;
using LiveService = ServerTestFramework.LiveService;
using ServerTestFramework.Utilities;
using ServerTestFramework.LiveService.FakeSG;
using ServerTestFramework.Database;

namespace statsmigchk
{
    /// <summary>
    /// Summary description for Class1.
    /// </summary>


    class Class1
    {
        static bool CHECK_ALL = true;

        /// <summary>
        /// The main entry point for the application.
        /// </summary>
        [STAThread]
        static void Main(string[] args)
        {

            if (args.Length < 2)
            {
                Console.WriteLine("statsmigchk <sql server> <tsnumai stats db> [<title> <lb>]");
                return;
            }

            string server = args[0];
            string database = args[1];


            uint titleid = 0;
            uint lbid = 0;

            if (args.Length >= 3)
            {
                titleid = SafeConvert.ToUInt32(args[2]);
            }

            if (args.Length == 4)
            {
                lbid = SafeConvert.ToUInt32(args[3]);
            }

            GlobalFakeSG.FakeSG = new FakeSGClient( "FakeSGClient" );
            if( !GlobalFakeSG.FakeSG.ConnectToService() )
            {
                Console.WriteLine( "Failed to connect to FakeSG Service" );
                return;
            }



            /*
            SqlBinary sqlbin;
            MemoryStream stream;
            BinaryReader br;
            */
            Hashtable lbs = new Hashtable();
            ArrayList al;


            using (SqlConnection cxn = new SqlConnection("Data Source="+server
                       + ";Initial Catalog=" + database + ";Integrated Security=SSPI;Timeout=2400"))
            {
                cxn.Open();

                SqlCommand cmd;
                SqlDataReader reader;

                // get list of title ids and/or leaderboard ids

                if (titleid != 0)
                {
                    lbs.Add(titleid, GetTitleLbs(cxn, titleid));
                }
                else
                {
                    // get the list of titles
                    ArrayList titles = new ArrayList();
                    cmd = new SqlCommand("select distinct i_title_id from t_leader_board", cxn);

                    reader = cmd.ExecuteReader();

                    al = new ArrayList();
                    while (reader.Read())
                    {
                        al.Add((uint)reader.GetInt32(0));
                    }

                    reader.Close();


                    // get leaderboards for each title
                    for (int i = 0; i < al.Count; i++)
                    {
                        lbs.Add((uint)al[i], GetTitleLbs(cxn, (uint)al[i]));
                    }

                }

                int tc = 0;
                string badLbs = "";


                foreach(object k in lbs.Keys)
                {
                    ArrayList lblist = (ArrayList)lbs[k];
                    tc++;

                    for (int i = 0; i < lblist.Count; i++)
                    {
                        if (lbid != 0 && lbid != ((Lb)lblist[i]).LbId)
                            continue;


                        if (CHECK_ALL)
                            Console.WriteLine("");


                        Console.WriteLine("TitleId: 0x" + ((uint)k).ToString("x") + " (" + tc + " of " + lbs.Keys.Count + ")" +
                            " LB: 0x" + ((Lb)lblist[i]).LbId.ToString("x") + " (" + (i+1) + " of " + lblist.Count + ")");

                        bool cont = CHECK_ALL;
                        ulong lastpuid = 0;
                        int errors = 0;
                        uint processedRows = 0;
                        uint totalRows = 0;
                        ArrayList colList = new ArrayList();


                        do
                        {
                            if (errors >= 10)
                            {
                                Console.WriteLine("Aborting title/lb due to too many errors");
                                badLbs += "\r\nTitle: 0x" + ((uint)k).ToString("x") + " Leaderboard: 0x" + ((Lb)lblist[i]).LbId.ToString("x");
                                break;
                            }

                            DbRow[] dbRows = new DbRow[100];
                            int r = 0;

                            cmd = new SqlCommand(
                                "select top 100 a.bi_user_id, r.bi_rating, a.i_att_size, a.nvc_att_path_name, n.nvc_nickname, a.vb_attrib_data " +
                                " from dbo.t_leader_board lb " +
                                " join dbo.t_attrib a on lb.uid_leader_board_id = a.uid_leader_board_id " +
                                " left outer join dbo.t_rating r on a.uid_leader_board_id = r.uid_leader_board_id and a.bi_user_id = r.bi_user_id " +
                                " left outer join dbo.t_nickname n on a.uid_leader_board_id = n.uid_leader_board_id and a.bi_user_id = n.bi_user_id " +
                                " where i_title_id = " + (uint)k +
                                " and i_leader_board_type = " + ((Lb)lblist[i]).LbId +
                                " and a.bi_user_id > " + lastpuid +
                                " order by a.bi_user_id", cxn);

                            reader = cmd.ExecuteReader();
                            while(reader.Read())
                            {
                                dbRows[r].Puid = (ulong)reader.GetInt64(0);
                                dbRows[r].IsRatingNull = reader.IsDBNull(1);
                                dbRows[r].Rating = reader.IsDBNull(1) ? 0 : (ulong)reader.GetInt64(1);
                                dbRows[r].IsAttSizeNull = reader.IsDBNull(2);
                                dbRows[r].AttSize = reader.IsDBNull(2) ? 0 : reader.GetInt32(2);
                                dbRows[r].AttPath = reader.IsDBNull(3) ? null : reader.GetString(3);
                                dbRows[r].Nickname = reader.IsDBNull(4) ? null : reader.GetString(4);

                                ParseDbAttribs(reader.GetSqlBinary(5).Value, out dbRows[r].Ids, out dbRows[r].Types, out dbRows[r].Values);

                                for (int c = 0; c < dbRows[r].Ids.Length; c++)
                                {
                                    if (!colList.Contains(dbRows[r].Ids[c]))
                                        colList.Add(dbRows[r].Ids[c]);
                                }

                                lastpuid = dbRows[r].Puid;

                                r++;

                            }

                            reader.Close();

                            if (r == 0)
                                break;


                            StatsReadRequest req = new StatsReadRequest();
                            req.TitleId = (uint)k;
                            req.UserCount = (uint)r;
                            req.Users = new ulong[r];
                            for (int u = 0; u < r; u++)
                            {
                                req.Users[u] = dbRows[u].Puid;
                            }

                            req.SpecCount = 1;
                            req.Specs = new StatsSpec[1];
                            req.Specs[0] = new StatsSpec();
                            req.Specs[0].ViewId = ((Lb)lblist[i]).LbId;
                            req.Specs[0].ColumnCount = Math.Min((uint)(3 + colList.Count), XOn.XONLINE_MAX_STATS_COL_COUNT);
                            req.Specs[0].ColumnIds = new ushort[req.Specs[0].ColumnCount];
                            req.Specs[0].ColumnIds[0] = SpecialAttrib.AttachmentSize;
                            req.Specs[0].ColumnIds[1] = SpecialAttrib.AttachmentPathName;
                            req.Specs[0].ColumnIds[2] = SpecialAttrib.Nickname;

                            for (int c = 3; c < req.Specs[0].ColumnCount; c++)
                            {
                                req.Specs[0].ColumnIds[c] = (ushort)colList[c-3];
                            }

                            StatsReadResponse resp = new StatsReadResponse();
                            XRLObject2 xrlo = resp;

                            CSGInfo slot = GlobalFakeSG.FakeSG.GetSlot();
                            slot.titleId = req.TitleId;
                            slot.userPuid0 = req.Users[0];

                            StfXrlUtil.AppendSGIPPort = true;

                            uint hr = StfXrlUtil.PostXrlRequest(ref slot, XOService.Stats, false, req.GetXRL(), req, ref xrlo);

                            Assert.AreEqual(HResult.S_OK, hr, "Error reading stats!!");

                            if (resp.ResultsCount != 1)
                            {
                                Console.WriteLine("\r\nUnexpected resp.ResultsCount: " + resp.ResultsCount);
                                errors++;
                                continue;
                            }

                            totalRows = resp.Results[0].ViewSize;

                            //Assert.AreEqual(totalRows, totalExpected, " Mismatched total row count!!");

                            if (resp.Results[0].RowCount != r)
                            {
                                Console.WriteLine("\r\nUnexpected resp.Results[0].RowCount : " + resp.Results[0].RowCount + " expected: " + r);
                                errors++;
                                continue;
                            }

                            for (int u = 0; u < resp.Results[0].Rows.Length; u++)
                            {
                                StatsRow row = resp.Results[0].Rows[u];
                                DbRow dbrow = dbRows[u];

                                processedRows++;


                                try
                                {

                                    Assert.AreEqual(dbrow.Puid, row.Puid, "Mismatched puids!  fd: " + row.Puid + " db: " + dbrow.Puid);
                                    Assert.AreEqual(dbrow.Rating, row.Rating, "Mismatched Ratings!  fd: " + row.Rating + " db: " + dbrow.Rating);

                                    Assert.AreEqual(row.Columns[0].ColumnId, SpecialAttrib.AttachmentSize,
                                        "Unexpected column id 0! " +  row.Columns[0].ColumnId + " != " + SpecialAttrib.AttachmentSize);


                                    if (row.Columns[0].Type != StatParam.Null && row.Columns[0].Type != StatParam.Int32)
                                    {

                                        Console.WriteLine("\r\nUnexpected type " + row.Columns[0].Type + " for column 0!");
                                        errors++;
                                        continue;
                                    }

                                    if (row.Columns[0].Type == StatParam.Int32 && (int)row.Columns[0].Data != dbrow.AttSize)
                                    {

                                        Console.WriteLine("\r\nWrong value for attsize! " + (int)row.Columns[0].Data + ", expected: "  + dbrow.AttSize);
                                        errors++;
                                        continue;
                                    }


                                    Assert.AreEqual(row.Columns[1].ColumnId, SpecialAttrib.AttachmentPathName, "Unexpected columnid 1!");
                                    Assert.IsTrue(row.Columns[1].Type == StatParam.Null || row.Columns[1].Type == StatParam.Utf8string, "Unexpected column 1 type: " + row.Columns[1].Type);
                                    if (((Lb)lblist[i]).MaxAttach >= row.Rank && row.Columns[1].Type == StatParam.Null && dbrow.AttPath != null &&
                                        row.Columns[0].Type == StatParam.Int32 && (int)row.Columns[0].Data > 0)
                                    {

                                        Console.WriteLine("\r\nRow att path type is null, but db row's attsize is non-null!  Puid: 0x" + row.Puid.ToString("x"));
                                        errors++;
                                        continue;
                                    }

                                    if (row.Columns[1].Type == StatParam.Utf8string)
                                    {
                                        Assert.AreEqual((string)(row.Columns[1].Data), dbrow.AttPath);
                                    }


                                    Assert.AreEqual(row.Columns[2].ColumnId, SpecialAttrib.Nickname, "Unexpected columnid 2!");
                                    Assert.IsTrue(row.Columns[2].Type == StatParam.Null || row.Columns[2].Type == StatParam.Utf8string, "Unexpected column 2 type: " + row.Columns[2].Type);
                                    if (row.Columns[2].Type == StatParam.Null && dbrow.Nickname != null)
                                    {

                                        Console.WriteLine("\r\nRow nickname type is null, but db row's nickname is non-null!");
                                        errors++;
                                        continue;
                                    }

                                    if (row.Columns[2].Type == StatParam.Utf8string)
                                    {
                                        if ((string)(row.Columns[2].Data) != dbrow.Nickname)
                                        {
                                            Console.WriteLine("\r\nRow nicknames don't match!  '" + ((string)row.Columns[2].Data) + "' vs '" + dbrow.Nickname + "'  (" +
                                                ByteConvert.ToString(Encoding.Unicode.GetBytes((string)row.Columns[2].Data)) + " vs " +
                                                ByteConvert.ToString(Encoding.UTF8.GetBytes(dbrow.Nickname)) + ")");

                                            errors++;
                                            continue;
                                        }
                                    }


                                    for (int c = 3; c < row.Columns.Length; c++)
                                    {
                                        int idindex = Array.IndexOf(dbrow.Ids, row.Columns[c].ColumnId);
                                        if (idindex == -1)
                                        {
                                            Assert.AreEqual(row.Columns[c].Type, StatParam.Null, " Db row attrib " + row.Columns[c].ColumnId + " doesn't exist, but stat row attrib type isn't null!");
                                            continue;
                                        }

                                        Assert.AreEqual(row.Columns[c].ColumnId, dbrow.Ids[idindex], "Mismatched ids for column " + c);
                                        Assert.AreEqual(row.Columns[c].Type, StatParam.MapFromAttrType((xonline.common.protocol.AttrType)(dbrow.Types[idindex])), "Mismatched types for column " + c);

                                        switch((xonline.common.protocol.AttrType)(dbrow.Types[idindex]))
                                        {
                                            case xonline.common.protocol.AttrType.Long:
                                                Assert.AreEqual((int)row.Columns[c].Data, (int)dbrow.Values[idindex]);
                                                break;
                                            case xonline.common.protocol.AttrType.LongLong:
                                                Assert.AreEqual((long)row.Columns[c].Data, (long)dbrow.Values[idindex]);

                                                break;
                                            case xonline.common.protocol.AttrType.Double:
                                                Assert.AreEqual((double)row.Columns[c].Data, (double)dbrow.Values[idindex]);
                                                break;
                                            default:
                                                throw new Exception("Bad encoding. Data corruption?");
                                        }
                                    }
                                }
                                catch(Exception e)
                                {
                                    Console.WriteLine("\r\n" + e.ToString() + "\r\nPuid: " + row.Puid );
                                    errors++;
                                    continue;
                                }

                            }

                            if (cont)
                                Console.Write("\b\b\b" + ((uint)(((double)processedRows / (double)totalRows)*100)) + "%");


                        }
                        while (cont);
                    }

                }

                Console.WriteLine("Done!");
                if (badLbs != "")
                {
                    Console.WriteLine("!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!");
                    Console.WriteLine("Errors found in:");
                    Console.WriteLine(badLbs);
                }

            }
        }

        static public void ParseDbAttribs(
            byte[] attribs,
            out ushort[] ids,
            out ushort[] types,
            out object[] values )
        {
            MemoryStream stream = new MemoryStream(attribs, 0, attribs.Length, false, true);
            BinaryReader br = new BinaryReader(stream);

            ArrayList idList = new ArrayList();
            ArrayList typeList = new ArrayList();
            ArrayList valueList = new ArrayList();

            while(stream.Position != stream.Length)
            {
                ushort statId;
                ushort type;
                object val;

                ReadFromDbFormat(br, out statId, out type, out val);

                idList.Add(statId);
                typeList.Add(type);
                valueList.Add(val);

            }

            ids = new ushort[idList.Count];
            types = new ushort[typeList.Count];
            values = new object[valueList.Count];

            idList.CopyTo(ids);
            typeList.CopyTo(types);
            valueList.CopyTo(values);
        }


        // Attribute types
        public enum AttrType
        {
            None        = 0,
            Long        = 1,
            LongLong    = 2,
            Double      = 3,
            String      = 4
        }

        // ReadFromDbFormat
        static public void ReadFromDbFormat(
            BinaryReader    br,
            out ushort      usStatId,
            out ushort      type,
            out object      val )
        {
            usStatId = br.ReadUInt16();
            type = br.ReadUInt16();
            AttrType attrType = (AttrType) type;

            switch(attrType)
            {
                case AttrType.Long:
                    val = (int)br.ReadInt64();
                    break;
                case AttrType.LongLong:
                    val = br.ReadInt64();
                    break;
                case AttrType.Double:
                    val = br.ReadDouble();
                    break;
                default:
                    throw new Exception("Bad encoding. Data corruption?");
            }


        }

        static public ArrayList GetTitleLbs(SqlConnection cxn, uint titleid)
        {
            ArrayList al = new ArrayList();

            SqlCommand cmd = new SqlCommand(
                "select distinct i_leader_board_type, i_att_count from t_leader_board where i_title_id = " + titleid + " order by i_leader_board_type", cxn);

            SqlDataReader reader = cmd.ExecuteReader();

            while (reader.Read())
            {
                Lb lb;

                lb.LbId = (uint)reader.GetInt32(0);
                lb.MaxAttach = (uint)reader.GetInt32(1);

                al.Add(lb);
            }

            reader.Close();

            return al;
        }

        public struct DbRow
        {
            public ulong Puid;
            public ulong Rating;
            public bool IsRatingNull;

            public ushort[] Ids;
            public ushort[] Types;
            public object[] Values;

            public string AttPath;
            public int AttSize;
            public bool IsAttSizeNull;
            public string Nickname;
        }

        public struct Lb
        {
            public uint LbId;
            public uint MaxAttach;
        }



    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\StfTests\APDispatcherTest\APDispatcherShell.cs ===
using System;
using System.Diagnostics;
using ServerTestFramework;

namespace APDispatcherTest
{
    class APDispatcherShell
    {
        #region Member Variables

        private string _apDispatcherPath;
        private string _server;
        private string _uploadServer;
        private string _psDatabase;
        private string _psPath;
        private string _certificate;
        private int    _maxBugs;
        private static ServerTestFramework.Report _report = new Report("APDispatcherShell");

        #endregion

        #region CTOR/DTOR

        public APDispatcherShell(string apDispatcherPath)
        {
            _apDispatcherPath = apDispatcherPath;
        }

        #endregion

        #region Properties

        public string Server
        {
            get { return _server; }
            set { _server = value; }
        }

        public string UploadServer
        {
            get { return _uploadServer; }
            set { _uploadServer = value; }
        }

        public string PSDatabase
        {
            get { return _psDatabase; }
            set { _psDatabase = value; }
        }

        public string PSPath
        {
            get { return _psPath; }
            set { _psPath = value; }
        }

        public string Certificate
        {
            get { return _certificate; }
            set { _certificate = value; }
        }

        public int MaxBugs
        {
            get { return _maxBugs; }
            set { _maxBugs = value; }
        }

        #endregion

        #region Methods

        public int Run(ref string output)
        {
            Object [] parameters = { _server, _uploadServer, _psDatabase, _psPath, _certificate, _maxBugs };

            string args = string.Format("/server:{0} /uploadserver:{1} /psdatabase:{2} /pspath:{3} /certificate:{4} /maxbugs:{5}", parameters);

            int nReturn = RunCommandLine(_apDispatcherPath, args, ref output);

            return nReturn;
        }

        private static int RunCommandLine(string file, string args, ref string output)
        {
            Process p = new Process();
            p.StartInfo.FileName = file;
            p.StartInfo.Arguments = args;
            p.StartInfo.CreateNoWindow = true;
            p.StartInfo.UseShellExecute = false;
            p.StartInfo.RedirectStandardOutput = true;
            p.StartInfo.RedirectStandardError = true;
            p.StartInfo.WorkingDirectory = System.IO.Path.GetDirectoryName(file);
            _report.Debug("Command Line: {0} {1}", p.StartInfo.FileName, p.StartInfo.Arguments);
            p.Start();

            output = p.StandardOutput.ReadToEnd();
            output += p.StandardError.ReadToEnd();

            p.WaitForExit();
            _report.Debug("Output: {0}", output);

            return p.ExitCode;           
        }
        
        #endregion

    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\StfTests\APDispatcherTest\PSUtil.cs ===
using System;
using System.Collections;
using System.Text;
using ProductStudio;
using ServerTestFramework;
using ServerTestFramework.STFTools;
using ServerTestFramework.Utilities;

using xonline.tools.APDispatcher;

namespace APDispatcherTest
{
    public class PSUtil
    {
        /// <summary>
        /// Finds the ID from the Product Path.
        /// </summary>
        /// <param name="node"></param>
        /// <param name="path"></param>
        /// <returns></returns>
        private static int TreeIDFromPath(Node node, string path)
        {
            string[]    pathLevelNames;
            char[]      separator = {'\\'};
            int         pathCount = 0;
            Node        currentNode = null;
            
            pathLevelNames = path.Split(separator);
            
            currentNode = node;

            if(path.Trim().Length >= 1 && path.Trim() != "\\")
            {

                for (pathCount = 0; pathCount < pathLevelNames.Length; pathCount++)
                {
                    currentNode = currentNode.Nodes[pathLevelNames[pathCount]];
                }
            }

            return currentNode.ID;
        }
        
        /// <summary>
        /// Create an autoprop-compatible bug using the provided parameters.
        /// </summary>
        /// <param name="title"></param>
        /// <param name="files"></param>
        /// <param name="folders"></param>
        /// <returns></returns>
        public static int CreateAutoPropBug(string psDatabase, string psPath, string title, ArrayList files, ArrayList folders, string titleIdField, string titleIdDesc, string contact)
        {
            int bugID = 0;
            DirectoryClass psDirectory = null;

            try
            {
                //
                // Connect to the directory and the specific product.
                //
                psDirectory = new ProductStudio.DirectoryClass();
                psDirectory.Connect("redmond.corp.microsoft.com", "", "");

                Product psProduct = psDirectory.GetProductByName(psDatabase);
                Datastore psDataStore = psProduct.Connect("", "", "");
                
                //
                // Create a new datastore instance.
                //
                DatastoreItemListClass psDataList = new ProductStudio.DatastoreItemListClass();
                psDataList.Datastore = psDataStore;

                //
                // Create a blank bug
                //
                psDataList.CreateBlank(PsDatastoreItemTypeEnum.psDatastoreItemTypeBugs);
                DatastoreItem psDataItem = psDataList.DatastoreItems.Add(null, PsApplyRulesMask.psApplyRulesAll);
                
                //
                // Set fields for the new bug
                //
                Fields psFields = psDataItem.Fields;

                psFields["TreeID"].Value = TreeIDFromPath(psDataStore.RootNode, psPath);
                psFields["Opened by"].Value = "xladmins";
                psFields["Issue type"].Value = "Other";
                psFields["Severity"].Value = 1;
                psFields["Fix Priority"].Value = 1;
                psFields["Assigned to"].Value = "xladmins";
                psFields["Title"].Value = title;
                psFields["How found"].Value = "Other";
                psFields["Autoprop State"].Value = "Ready";
                psFields["Fix ETA"].Value = "1 Hour";
                psFields["Service Component"].Value = "Other";

                StringBuilder desc = new StringBuilder();

                if(titleIdField != null)
                    psFields["Title ID"].Value = titleIdField;

                if(titleIdDesc != null)
                    desc.Append(string.Format("Title ID:{0}\n", titleIdDesc));
                if(contact != null)
                    desc.Append(string.Format("Contact:{0}\n", contact));

                psFields["Description"].Value = desc.ToString();

                if(files != null)
                {
                    foreach(string file in files)
                    {
                        psDataItem.Files.Add(file, false);
                    }
                }

                if(folders != null)
                {
                    foreach(string folder in folders)
                    {
                        psDataItem.Files.Add(folder, true);
                    }
                }

                //
                //  Let's make sure all fields are valid before saving
                //
                bool hasInvalidField = false;
                foreach (ProductStudio.Field psField in psDataItem.Fields)
                {
                    if (psField.Validity != PsFieldStatusEnum.psFieldStatusValid)
                    {
                        hasInvalidField = true;
                        Console.WriteLine ("Invalid Field '{0}': {1}", psField.Name, psField.Validity.ToString());
                        Console.WriteLine ("Current Value: '{0}'", psField.Value);
                        Console.WriteLine();
                    }
                }

                if (hasInvalidField)
                {
                    throw (new ApplicationException("Invalid Field(s) were found.  Could not update."));
                }
                else
                {
                    psDataItem.Save(true);
                    bugID = Convert.ToInt32(psFields["ID"].Value);
                    Console.WriteLine ("Bug #{0} Successfully Created.", bugID);
                }
            }
            catch (Exception e)
            {
                Console.WriteLine("Error: {0}", e.Message);
            }
            finally
            {
                if (null != psDirectory)
                {
                    psDirectory.Disconnect();
                }
            }

            return bugID;
        }

        public static void ReactivateAutopropBug(string psDatabase, string psPath, int bugID)
        {
            int			                    fieldCount      = 0;
            string		                    psQueryXml      = "";
            ProductStudio.Query		        psQuery         = null;
            ProductStudio.DatastoreItemList	psDataList      = null;
            ProductStudio.FieldDefinitions	psFields        = null;
            string[]                        fieldsArray     = {"Title", "Autoprop State", "Status"};
            ProductStudio.DatastoreItem     psItem          = null;
            DirectoryClass                  psDirectory     = null;

            try
            {
                //
                // Connect to the directory and the specific product.
                //
                psDirectory = new ProductStudio.DirectoryClass();
                psDirectory.Connect("redmond.corp.microsoft.com", "", "");

                Product psProduct = psDirectory.GetProductByName(psDatabase);
                Datastore psDataStore = psProduct.Connect("", "", "");
                
                int treeID = TreeIDFromPath(psDataStore.RootNode, psPath);
                
                //
                // Open the specified bug
                //

                //
                // Query in Xml Format which retrieves all 
                // unassigned bugs 
                //
                psQueryXml = "<Query>" + 
                    "<Group GroupOperator='and'>" +
                    "<Expression Column='ID'     Operator='equals'><String>" + bugID.ToString() + "</String></Expression>" +
                    "<Expression Column='TreeID' Operator='equals'><Number>" + treeID.ToString() + "</Number></Expression>" +
                    "</Group>" +
                    "</Query>";
        
                //
                // Set up the query.
                //
                psQuery = new ProductStudio.QueryClass();
                psQuery.CountOnly         = false;
                psQuery.SelectionCriteria = psQueryXml;
        
                //
                // Bind the query and Datastore to our 
                // DatastoreItemList.
                //
                psDataList = new ProductStudio.DatastoreItemListClass();
                psDataList.Query     = psQuery;
                psDataList.Datastore = psDataStore;
        
                                                                                

                //-------------------------------------------------------------
                // Configure the query with the fields to return and sort by
                // processing
                //
                psFields = psDataStore.FieldDefinitions;

                psQuery.QueryFields.Clear();
                for (fieldCount = 0; fieldCount < fieldsArray.Length; fieldCount ++)
                {
                    psQuery.QueryFields.Add(psFields[fieldsArray[fieldCount]]);	
                }
                
                psQuery.QuerySortFields.Clear();

                //-------------------------------------------------------------
                // All set: Run the query and get the first matching bug for
                // processing
                //
                psDataList.Execute();

                // Was the bug found?
                ValueCheck.TestNonZero("Number of bugs retrieved from Product Studio must not be zero.", psDataList.DatastoreItems.Count);

                psItem = psDataList.DatastoreItems[0];

                psItem.Edit(PsItemEditActionEnum.psBugEditActionActivate, null, PsApplyRulesMask.psApplyRulesAll);
                psItem.Fields["Autoprop State"].Value = "Ready";
                psItem.Save(true);
            }
            finally
            {
                if (null != psDirectory)
                {
                    psDirectory.Disconnect();
                }
            }
        }

        public static void AddFileToBug(string psDatabase, string psPath, int bugID, string file)
        {
            int			                    fieldCount      = 0;
            string		                    psQueryXml      = "";
            ProductStudio.Query		        psQuery         = null;
            ProductStudio.DatastoreItemList	psDataList      = null;
            ProductStudio.FieldDefinitions	psFields        = null;
            string[]                        fieldsArray     = {"Title", "Autoprop State", "Status"};
            ProductStudio.DatastoreItem     psItem          = null;
            DirectoryClass                  psDirectory     = null;

            try
            {
                //
                // Connect to the directory and the specific product.
                //
                psDirectory = new ProductStudio.DirectoryClass();
                psDirectory.Connect("redmond.corp.microsoft.com", "", "");

                Product psProduct = psDirectory.GetProductByName(psDatabase);
                Datastore psDataStore = psProduct.Connect("", "", "");
                
                int treeID = TreeIDFromPath(psDataStore.RootNode, psPath);
                
                //
                // Open the specified bug
                //

                //
                // Query in Xml Format which retrieves all 
                // unassigned bugs 
                //
                psQueryXml = "<Query>" + 
                    "<Group GroupOperator='and'>" +
                    "<Expression Column='ID'     Operator='equals'><String>" + bugID.ToString() + "</String></Expression>" +
                    "<Expression Column='TreeID' Operator='equals'><Number>" + treeID.ToString() + "</Number></Expression>" +
                    "</Group>" +
                    "</Query>";
        
                //
                // Set up the query.
                //
                psQuery = new ProductStudio.QueryClass();
                psQuery.CountOnly         = false;
                psQuery.SelectionCriteria = psQueryXml;
        
                //
                // Bind the query and Datastore to our 
                // DatastoreItemList.
                //
                psDataList = new ProductStudio.DatastoreItemListClass();
                psDataList.Query     = psQuery;
                psDataList.Datastore = psDataStore;
        
                                                                                

                //-------------------------------------------------------------
                // Configure the query with the fields to return and sort by
                // processing
                //
                psFields = psDataStore.FieldDefinitions;

                psQuery.QueryFields.Clear();
                for (fieldCount = 0; fieldCount < fieldsArray.Length; fieldCount ++)
                {
                    psQuery.QueryFields.Add(psFields[fieldsArray[fieldCount]]);	
                }
                
                psQuery.QuerySortFields.Clear();

                //-------------------------------------------------------------
                // All set: Run the query and get the first matching bug for
                // processing
                //
                psDataList.Execute();

                // Was the bug found?
                ValueCheck.TestNonZero("Number of bugs retrieved from Product Studio must not be zero.", psDataList.DatastoreItems.Count);

                psItem = psDataList.DatastoreItems[0];

                psItem.Edit(PsItemEditActionEnum.psDatastoreItemEditActionEdit, null, PsApplyRulesMask.psApplyRulesAll);
                psItem.Files.Add(file, false);
                psItem.Save(true);
            }
            finally
            {
                if (null != psDirectory)
                {
                    psDirectory.Disconnect();
                }
            }
        }

        public static PropResultsReader ExtractLatestResults(DatastoreItem psItem)
        {
            DateTime dtLatest = DateTime.MinValue;
            string latestPropResults = null;
            PropResultsReader reader = null;

            psItem.Edit(PsItemEditActionEnum.psDatastoreItemEditActionReadOnly, null, PsApplyRulesMask.psApplyRulesAll);
            
            try
            {
                foreach (ProductStudio.File fItem in psItem.Files)
                {
                    //  Does this item reference a single file, or a folder containing files?
                    string itemFileName = fItem.FileName;

                    DateTime dtCur = FileGrouping.GetPropResultsTime(itemFileName);
                    if(dtCur > dtLatest)
                    {
                        dtLatest = dtCur;

                        string localFile = System.IO.Path.Combine(System.IO.Path.GetTempPath(), itemFileName);
                        fItem.SaveToFile(localFile, true);
                        latestPropResults = localFile;
                    }
                }

                if(latestPropResults != null)
                {                    
                    reader = new PropResultsReader(latestPropResults);
                }
            }
            finally
            {
                psItem.Reset(true);
            }

            return reader;
        }

        /// <summary>
        /// Given a bugID, verify that APDispatcher processed the bug correctly and
        /// all jobs were processed successfully.
        /// </summary>
        /// <param name="bugID"></param>
        /// <returns></returns>
        public static bool VerifyAutoPropBug(string psDatabase, string psPath, int bugID, string expectedStatus, string expectedAutopropState, PropResult.PropResultType expectedResult)
        {
            int			                    fieldCount      = 0;
            string		                    psQueryXml      = "";
            ProductStudio.Query		        psQuery         = null;
            ProductStudio.DatastoreItemList	psDataList      = null;
            ProductStudio.FieldDefinitions	psFields        = null;
            string[]                        fieldsArray     = {"Title", "Autoprop State", "Status"};
            ProductStudio.DatastoreItem     psItem          = null;
            DirectoryClass                  psDirectory     = null;

            try
            {
                //
                // Connect to the directory and the specific product.
                //
                psDirectory = new ProductStudio.DirectoryClass();
                psDirectory.Connect("redmond.corp.microsoft.com", "", "");

                Product psProduct = psDirectory.GetProductByName(psDatabase);
                Datastore psDataStore = psProduct.Connect("", "", "");
                
                int treeID = TreeIDFromPath(psDataStore.RootNode, psPath);
                
                //
                // Open the specified bug
                //

                //
                // Query in Xml Format which retrieves all 
                // unassigned bugs 
                //
                psQueryXml = "<Query>" + 
                    "<Group GroupOperator='and'>" +
                    "<Expression Column='ID'     Operator='equals'><String>" + bugID.ToString() + "</String></Expression>" +
                    "<Expression Column='TreeID' Operator='equals'><Number>" + treeID.ToString() + "</Number></Expression>" +
                    "</Group>" +
                    "</Query>";
        
                //
                // Set up the query.
                //
                psQuery = new ProductStudio.QueryClass();
                psQuery.CountOnly         = false;
                psQuery.SelectionCriteria = psQueryXml;
        
                //
                // Bind the query and Datastore to our 
                // DatastoreItemList.
                //
                psDataList = new ProductStudio.DatastoreItemListClass();
                psDataList.Query     = psQuery;
                psDataList.Datastore = psDataStore;
        
                                                                                

                //-------------------------------------------------------------
                // Configure the query with the fields to return and sort by
                // processing
                //
                psFields = psDataStore.FieldDefinitions;

                psQuery.QueryFields.Clear();
                for (fieldCount = 0; fieldCount < fieldsArray.Length; fieldCount ++)
                {
                    psQuery.QueryFields.Add(psFields[fieldsArray[fieldCount]]);	
                }
                
                psQuery.QuerySortFields.Clear();

                //-------------------------------------------------------------
                // All set: Run the query and get the first matching bug for
                // processing
                //
                psDataList.Execute();

                // Was the bug found?
                ValueCheck.TestNonZero("Number of bugs retrieved from Product Studio must not be zero.", psDataList.DatastoreItems.Count);

                psItem = psDataList.DatastoreItems[0];

                //
                //  Verify status and AutopropState
                //

                ValueCheck.Test("Bug Status", expectedStatus, (string)psItem.Fields["Status"].Value);
                ValueCheck.Test("Autoprop State", expectedAutopropState, (string)psItem.Fields["Autoprop State"].Value);

                //
                //  Get the most recent propResultsFile and make sure all jobs were successful
                //

                if(expectedResult != (PropResult.PropResultType)0)
                {
                    PropResultsReader reader = ExtractLatestResults(psItem);
                    ValueCheck.TestNotNull("PropResultsReader reader", reader);

                    foreach(PropResult propResult in reader.Results)
                    {
                        ValueCheck.Test("propResult.Result", expectedResult.ToString(), propResult.Result.ToString());
                    }
                }
                else
                {
                    //  In this case we actually expect there to be no results files.
                    PropResultsReader reader = ExtractLatestResults(psItem);
                    ValueCheck.IsTrue(reader == null, "Making sure no results files exist in bug.");
                }

                return true;
            }
            finally
            {
                if (null != psDirectory)
                {
                    psDirectory.Disconnect();
                }
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\StfTests\APDispatcherTest\obj\i386\_generated.cs ===
[assembly:System.Runtime.InteropServices.ComVisible(false)]
[assembly:System.Reflection.AssemblyVersion("12.4.56.0")]
[assembly:System.Reflection.AssemblyProduct("Microsoft(R) Xbox(TM)")]
[assembly:System.Reflection.AssemblyCopyright("Copyright (c) Microsoft Corporation. All rights reserved.")]
[assembly:System.Reflection.AssemblyCompany("Microsoft Corporation")]
[assembly:System.Reflection.AssemblyFileVersion("12.4.56.0")]
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\StfTests\APDispatcherTest\obj\i386\_asmid.inc ===
ASSEMBLY_IDENTITY_KEY_FORM=msil_apdispatchertest_none_12.4.56.0_none_4756d738cd732557
ASSEMBLY_IDENTITY_XP_KEY_FORM=msil_apdispatchertest_no-public-key_12.4.56.0_x-ww_b40b056b
ASSEMBLY_IDENTITY_CULTURE=
ASSEMBLY_IDENTITY_NAME=apdispatchertest
ASSEMBLY_IDENTITY_PROCESSOR_ARCHITECTURE=msil
ASSEMBLY_IDENTITY_PUBLIC_KEY=
ASSEMBLY_IDENTITY_PUBLIC_KEY_TOKEN=
ASSEMBLY_IDENTITY_TYPE=
ASSEMBLY_IDENTITY_TYPE_NAME=
ASSEMBLY_IDENTITY_VERSION=12.4.56.0
XP_KEY_FORM=msil_apdispatchertest_no-public-key_12.4.56.0_x-ww_b40b056b
XP_MANIFEST_DIRECTORY=manifests
XP_MANIFEST_NAME=msil_apdispatchertest_no-public-key_12.4.56.0_x-ww_b40b056b.manifest
XP_MANIFEST_PATH=manifests\msil_apdispatchertest_no-public-key_12.4.56.0_x-ww_b40b056b.manifest
XP_CATALOG_DIRECTORY=manifests
XP_CATALOG_NAME=msil_apdispatchertest_no-public-key_12.4.56.0_x-ww_b40b056b.cat
XP_CATALOG_PATH=manifests\msil_apdispatchertest_no-public-key_12.4.56.0_x-ww_b40b056b.cat
XP_PAYLOAD_PATH=msil_apdispatchertest_no-public-key_12.4.56.0_x-ww_b40b056b
_DELAY_SIGN=0
!if [set _ASMIDTOATTRIBS_TLBIMP=]
!endif
CODESIGN_TESTKEY=
_TLBIMP_FLAGS=$(_TLBIMP_FLAGS)  /asmversion:12.4.56.0
_ASSEMBLY_IDENTITY=apdispatchertest,processorArchitecture=msil,version=12.4.56.0,publicKeyToken=neutral
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\StfTests\APDispatcherTest\objd\i386\_asmid.inc ===
ASSEMBLY_IDENTITY_KEY_FORM=msil_apdispatchertest_none_12.4.56.0_none_4756d738cd732557
ASSEMBLY_IDENTITY_XP_KEY_FORM=msil_apdispatchertest_no-public-key_12.4.56.0_x-ww_b40b056b
ASSEMBLY_IDENTITY_CULTURE=
ASSEMBLY_IDENTITY_NAME=apdispatchertest
ASSEMBLY_IDENTITY_PROCESSOR_ARCHITECTURE=msil
ASSEMBLY_IDENTITY_PUBLIC_KEY=
ASSEMBLY_IDENTITY_PUBLIC_KEY_TOKEN=
ASSEMBLY_IDENTITY_TYPE=
ASSEMBLY_IDENTITY_TYPE_NAME=
ASSEMBLY_IDENTITY_VERSION=12.4.56.0
XP_KEY_FORM=msil_apdispatchertest_no-public-key_12.4.56.0_x-ww_b40b056b
XP_MANIFEST_DIRECTORY=manifests
XP_MANIFEST_NAME=msil_apdispatchertest_no-public-key_12.4.56.0_x-ww_b40b056b.manifest
XP_MANIFEST_PATH=manifests\msil_apdispatchertest_no-public-key_12.4.56.0_x-ww_b40b056b.manifest
XP_CATALOG_DIRECTORY=manifests
XP_CATALOG_NAME=msil_apdispatchertest_no-public-key_12.4.56.0_x-ww_b40b056b.cat
XP_CATALOG_PATH=manifests\msil_apdispatchertest_no-public-key_12.4.56.0_x-ww_b40b056b.cat
XP_PAYLOAD_PATH=msil_apdispatchertest_no-public-key_12.4.56.0_x-ww_b40b056b
_DELAY_SIGN=0
!if [set _ASMIDTOATTRIBS_TLBIMP=]
!endif
CODESIGN_TESTKEY=
_TLBIMP_FLAGS=$(_TLBIMP_FLAGS)  /asmversion:12.4.56.0
_ASSEMBLY_IDENTITY=apdispatchertest,processorArchitecture=msil,version=12.4.56.0,publicKeyToken=neutral
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\StfTests\APDispatcherTest\objd\i386\_generated.cs ===
[assembly:System.Runtime.InteropServices.ComVisible(false)]
[assembly:System.Reflection.AssemblyVersion("12.4.56.0")]
[assembly:System.Reflection.AssemblyProduct("Microsoft(R) Xbox(TM)")]
[assembly:System.Reflection.AssemblyCopyright("Copyright (c) Microsoft Corporation. All rights reserved.")]
[assembly:System.Reflection.AssemblyCompany("Microsoft Corporation")]
[assembly:System.Reflection.AssemblyFileVersion("12.4.56.0")]
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\StfTests\BasicTest\AsyncTests.cs ===
using System;
using ServerTestFramework;

namespace BasicTest
{
    #pragma warning disable 420 //self-defeating retarted c# compiler warning about volatile ints being used as referances (for Interlock Inc/Dec).

    /// <summary>
    /// Tests running classless tests at the same time
    /// </summary>
    [TestGroup, AsyncGroup(1, 0), AsyncThreadCount(3), Description("(run whole group) first 3 should run at the same time, then the 4th one should run")]
    public class AsyncTestNoClasses : TestNode
    {
        protected static volatile int syncValue=0; //used to check that several tests are actually running

        [TestCase]
        public void AsyncFunc1()
        {
            try
            {
                Global.RO.Debug("Ran 1");
                System.Threading.Interlocked.Increment(ref syncValue);
                System.Threading.Thread.Sleep(500);
                if (syncValue!=3) throw new UnexpectedTestResultException("Not all 3 tests started..!");
                System.Threading.Thread.Sleep(500);
            }
            finally
            {
                System.Threading.Interlocked.Decrement(ref syncValue);
            }
        }

        [TestCase]
        public void AsyncFunc2()
        {
            try
            {
                Global.RO.Debug("Ran 2");
                System.Threading.Interlocked.Increment(ref syncValue);
                System.Threading.Thread.Sleep(500);
                if (syncValue!=3) throw new UnexpectedTestResultException("Not all 3 tests started..!");
                System.Threading.Thread.Sleep(500);
            }
            finally
            {
                System.Threading.Interlocked.Decrement(ref syncValue);
            }
        }

        [TestCase]
        public void AsyncFunc3()
        {
            try
            {
                Global.RO.Debug("Ran 3");
                System.Threading.Interlocked.Increment(ref syncValue);
                System.Threading.Thread.Sleep(500);
                if (syncValue!=3) throw new UnexpectedTestResultException("Not all 3 tests started..!");
                System.Threading.Thread.Sleep(500);
            }
            finally
            {
                System.Threading.Interlocked.Decrement(ref syncValue);
            }
        }

        [TestCase,AsyncGroup(0)]
        public void NonAsyncFunc()
        {
            if (syncValue!=0) throw new UnexpectedTestResultException("Other tests were still running when I ran.");
        }
    }

    /// <summary>
    /// Tests running class tests at the same time
    /// </summary>
    [TestGroup, AsyncGroup(1, 0), Description("(run whole group) first 3 should run at the same time, then the 4th one should run")]
    public class AsyncTestClasses : TestNode
    {
        protected static volatile int syncValue=0; //used to check that several tests are actually running

        [TestCase]
        class AsyncClass1: TestBase
        {
            protected override void Execute()
            {
                try
                {
                    System.Threading.Interlocked.Increment(ref syncValue);
                    System.Threading.Thread.Sleep(500);
                    if (syncValue!=3) throw new UnexpectedTestResultException("Not all 3 tests started..!");
                    System.Threading.Thread.Sleep(500);
                    ResultCode = TEST_RESULTS.PASSED;
                }
                finally
                {
                    System.Threading.Interlocked.Decrement(ref syncValue);
                }
            }
        }

        [TestCase]
        class AsyncClass2: TestBase
        {
            protected override void Execute()
            {
                try
                {
                    System.Threading.Interlocked.Increment(ref syncValue);
                    System.Threading.Thread.Sleep(500);
                    if (syncValue!=3) throw new UnexpectedTestResultException("Not all 3 tests started..!");
                    System.Threading.Thread.Sleep(500);
                    ResultCode = TEST_RESULTS.PASSED;
                }
                finally
                {
                    System.Threading.Interlocked.Decrement(ref syncValue);
                }
            }
        }

        [TestCase]
        class AsyncClass3: TestBase
        {
            protected override void Execute()
            {
                try
                {
                    System.Threading.Interlocked.Increment(ref syncValue);
                    System.Threading.Thread.Sleep(500);
                    if (syncValue!=3) throw new UnexpectedTestResultException("Not all 3 tests started..!");
                    System.Threading.Thread.Sleep(500);
                    ResultCode = TEST_RESULTS.PASSED;
                }
                finally
                {
                    System.Threading.Interlocked.Decrement(ref syncValue);
                }
            }
        }

        [TestCase,AsyncGroup(0)]
        class NonAsyncClass: TestBase
        {
            protected override void Execute()
            {
                if (syncValue!=0) throw new UnexpectedTestResultException("Other tests were still running when I ran.");
                ResultCode = TEST_RESULTS.PASSED;
            }
        }
    }

    /// <summary>
    /// Tests that AsyncThreadDelay works.
    /// </summary>
    [TestGroup, AsyncGroup(1, 0), AsyncThreadDelay(500), Description("(run whole group) each test should have around a 500ms delay between runs")]
    public class AsyncThreadDelayTest : TestNode
    {
        protected static System.DateTime lastTime;

        [TestCase]
        class Test1: TestBase
        {
            protected override void Execute()
            {
                Global.RO.Info("Test 1 run.");
                lastTime=System.DateTime.Now;
                ResultCode = TEST_RESULTS.PASSED;
            }
        }

        [TestCase]
        class Test2: TestBase
        {
            protected override void Execute()
            {
                System.DateTime curTime=System.DateTime.Now;
                System.TimeSpan timePassed=curTime-lastTime;
                lastTime=curTime;
                Global.RO.Info("Test 2 run: timePassed was "+timePassed.Milliseconds+"ms");
                if (Math.Abs(500-timePassed.Milliseconds)>25)
                {
                    throw new UnexpectedTestResultException("More than 25ms off from the time the test should have started.");
                }
                ResultCode = TEST_RESULTS.PASSED;
            }
        }

        [TestCase]
        class Test3: TestBase
        {
            protected override void Execute()
            {
                System.DateTime curTime=System.DateTime.Now;
                System.TimeSpan timePassed=curTime-lastTime;
                lastTime=curTime;
                Global.RO.Info("Test 3 run: timePassed was "+timePassed.Milliseconds+"ms");
                if (Math.Abs(500-timePassed.Milliseconds)>25)
                {
                    throw new UnexpectedTestResultException("More than 25ms off from the time the test should have started.");
                }
                ResultCode = TEST_RESULTS.PASSED;
            }
        }
    }

    // -- test of AsyncSet portion of AsyncGroup attribute to run groups in parallel

    public static class AsyncSetGlobalHolder
    {
        public static volatile int SyncValue=0;
    }
    
    [TestGroup, AsyncGroup(0,33), Description("(run with AsyncSetTest1) Test that the AsyncSet attribute works")]
    public class AsyncSetTest0_RunBothGroups : TestNode
    {
        [TestCase]
        public void DoTheTest()
        {
            Global.RO.Info("Test0 started, waiting on Test1...");
            System.Threading.Interlocked.Increment(ref AsyncSetGlobalHolder.SyncValue);
            System.Threading.Thread.Sleep(500);

            try
            {
                if (AsyncSetGlobalHolder.SyncValue!=2)
                {
                    Global.RO.Error("0: shared int was not the expected value for both groups running");
                    throw new UnexpectedTestResultException();
                }
            }
            finally
            {
                System.Threading.Thread.Sleep(500);
                AsyncSetGlobalHolder.SyncValue=0;
            }
        }
    }

    [TestGroup, AsyncGroup(0,33), Description("(run with AsyncSetTest0) Test that the AsyncSet attribute works")]
    public class AsyncSetTest1_RunBothGroups : TestNode
    {
        [TestCase]
        public void DoTheTest()
        {
            Global.RO.Info("Test1 started, waiting on Test0...");
            System.Threading.Interlocked.Increment(ref AsyncSetGlobalHolder.SyncValue);
            System.Threading.Thread.Sleep(500);

            try
            {
                if (AsyncSetGlobalHolder.SyncValue!=2)
                {
                    Global.RO.Error("1: shared int was not the expected value for both groups running");
                    throw new UnexpectedTestResultException();
                }
            }
            finally
            {
                System.Threading.Thread.Sleep(500);
                AsyncSetGlobalHolder.SyncValue=0;
            }
        }
    }

    //test running AsyncGroups inside AsyncSets
    [TestGroup, AsyncGroup(1,1), Description("(run with AsyncSetAndGroup1) Tests using both AsyncSet and AsyncGroup together")]
    public class AsyncSetAndGroup0_RunBothGroups : TestNode
    {
        public void DoTheTest()
        {
            System.Threading.Interlocked.Increment(ref AsyncSetGlobalHolder.SyncValue);
            System.Threading.Thread.Sleep(500);

            try
            {
                if (AsyncSetGlobalHolder.SyncValue!=4)
                {
                    Global.RO.Error("1: shared int was not the expected value for 2 groups and 2 tests ("+AsyncSetGlobalHolder.SyncValue+")");
                    throw new UnexpectedTestResultException();
                }
            }
            finally
            {
                System.Threading.Thread.Sleep(500);
                AsyncSetGlobalHolder.SyncValue=0;
            }
        }

        [TestCase]
        public void AsyncFunc1()
        {
            DoTheTest();
        }

        [TestCase]
        public void AsyncFunc2()
        {
            DoTheTest();
        }
    };

    [TestGroup, AsyncGroup(1,1), Description("(run with AsyncSetAndGroup0) Tests using both AsyncSet and AsyncGroup together")]
    public class AsyncSetAndGroup1_RunBothGroups : TestNode
    {
        public void DoTheTest()
        {
            System.Threading.Interlocked.Increment(ref AsyncSetGlobalHolder.SyncValue);
            System.Threading.Thread.Sleep(500);

            try
            {
                if (AsyncSetGlobalHolder.SyncValue!=4)
                {
                    Global.RO.Error("0: shared int was not the expected value for 2 groups and 2 tests ("+AsyncSetGlobalHolder.SyncValue+")");
                    throw new UnexpectedTestResultException();
                }
            }
            finally
            {
                System.Threading.Thread.Sleep(500);
                AsyncSetGlobalHolder.SyncValue=0;
            }
        }

        [TestCase]
        public void AsyncFunc1()
        {
            DoTheTest();
        }

        [TestCase]
        public void AsyncFunc2()
        {
            DoTheTest();
        }
    };
} //namespace BasicTest
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\StfTests\APDispatcherTest\APDispatcherTest.cs ===
//
//	These tests were handed off as part of the overall handoff of deprecated content ingestion tools.  The tests
//	are no longer being run.
//

using System;
using System.Collections;
using System.IO;
using System.Reflection;
using System.Xml;
using ServerTestFramework;
using ServerTestFramework.STFTools;
using ServerTestFramework.Utilities;
using xonline.common.config;

using xonline.tools.APDispatcher;

namespace APDispatcherTest
{

    /// <summary>
    /// This class contains test cases specifically for the PropResults file class.
    /// </summary>
    [TestGroup, Owner("XNA Test"), TestFrequency("Daily"), EnvRequirement("Deprecated")]
    public class PropResultsFileTestCases : TestNode
    {
        #region Member Variables

        private string _inputFilePath;

        #endregion

        #region CTOR/DTOR

        public PropResultsFileTestCases()
        {
            XmlNode apDispatcherTestConfig = Global.Config.SelectSingleNode("descendant::APDispatcherTest");

            XmlElement inputFilePath = (XmlElement)apDispatcherTestConfig.SelectSingleNode("InputFilePath");
            _inputFilePath = inputFilePath.InnerText;

            if(!Path.IsPathRooted(_inputFilePath))
            {
                Assembly a = Assembly.GetExecutingAssembly();
                _inputFilePath = Path.Combine(Path.GetDirectoryName(a.Location), _inputFilePath);
            }
        }

        #endregion

        #region Test Cases

        [TestCase]
        public void Pos_CreateSaveLoadPropResults()
        {
            PropResultsWriter writer = new PropResultsWriter();
            ArrayList files;
            string output;

            files = new ArrayList();
            files.Add("file0.cab");
            files.Add("file0.offer");
            files.Add("file0.png");
            output = "line1\r\nline2\r\nline3\r\n";
            writer.AddResult(files, output, PropResult.PropResultType.SUCCESS);

            files = new ArrayList();
            files.Add("file1.cab");
            files.Add("file1.offer");
            files.Add("file1.png");
            output = "line1\r\nline2\r\nline3\r\n";
            writer.AddResult(files, output, PropResult.PropResultType.PROPFAILED);

            files = new ArrayList();
            files.Add("file2.cab");
            files.Add("file2.offer");
            files.Add("file2.png");
            output = "line1\r\nline2\r\nline3\r\n";
            writer.AddResult(files, output, PropResult.PropResultType.INVALIDGROUPING);

            files = new ArrayList();
            files.Add("file3.cab");
            files.Add("file3.offer");
            files.Add("file3.png");
            output = "line1\r\nline2\r\nline3\r\n";
            writer.AddResult(files, output, PropResult.PropResultType.SKIPPED);

            string resultsFile = writer.Save(_inputFilePath);

            PropResultsReader reader = new PropResultsReader(resultsFile);

            ValueCheck.Test("reader.Results.Count", 4, reader.Results.Count);

            PropResult r = (PropResult)reader.Results[0];

            ValueCheck.Test("reader.Results[0].Result", (byte)PropResult.PropResultType.SUCCESS, (byte)r.Result);
            ValueCheck.Test("reader.Results[0].Files.Count", 3, r.Files.Count);
            ValueCheck.Test("reader.Results[0].Files[0]", "file0.cab", (string)r.Files[0]);
            ValueCheck.Test("reader.Results[0].Files[1]", "file0.offer", (string)r.Files[1]);
            ValueCheck.Test("reader.Results[0].Files[1]", "file0.png", (string)r.Files[2]);

            r = (PropResult)reader.Results[1];

            ValueCheck.Test("reader.Results[1].Result", (byte)PropResult.PropResultType.PROPFAILED, (byte)r.Result);
            ValueCheck.Test("reader.Results[1].Files.Count", 3, r.Files.Count);
            ValueCheck.Test("reader.Results[1].Files[0]", "file1.cab", (string)r.Files[0]);
            ValueCheck.Test("reader.Results[1].Files[1]", "file1.offer", (string)r.Files[1]);
            ValueCheck.Test("reader.Results[1].Files[1]", "file1.png", (string)r.Files[2]);

            r = (PropResult)reader.Results[2];

            ValueCheck.Test("reader.Results[2].Result", (byte)PropResult.PropResultType.INVALIDGROUPING, (byte)r.Result);
            ValueCheck.Test("reader.Results[2].Files.Count", 3, r.Files.Count);
            ValueCheck.Test("reader.Results[2].Files[0]", "file2.cab", (string)r.Files[0]);
            ValueCheck.Test("reader.Results[2].Files[1]", "file2.offer", (string)r.Files[1]);
            ValueCheck.Test("reader.Results[2].Files[1]", "file2.png", (string)r.Files[2]);

            r = (PropResult)reader.Results[3];

            ValueCheck.Test("reader.Results[3].Result", (byte)PropResult.PropResultType.SKIPPED, (byte)r.Result);
            ValueCheck.Test("reader.Results[3].Files.Count", 3, r.Files.Count);
            ValueCheck.Test("reader.Results[3].Files[0]", "file3.cab", (string)r.Files[0]);
            ValueCheck.Test("reader.Results[3].Files[1]", "file3.offer", (string)r.Files[1]);
            ValueCheck.Test("reader.Results[3].Files[1]", "file3.png", (string)r.Files[2]);

            File.Delete(resultsFile);
        }

        [TestCase]
        public void Pos_LoadPropResults()
        {
            PropResultsReader reader = new PropResultsReader();

            reader.Load(Path.Combine(_inputFilePath, "PropResultsAllTest.txt"));

            ValueCheck.Test("reader.Results.Count", 4, reader.Results.Count);

            PropResult r = (PropResult)reader.Results[0];

            ValueCheck.Test("reader.Results[0].Result", (byte)PropResult.PropResultType.SUCCESS, (byte)r.Result);
            ValueCheck.Test("reader.Results[0].Files.Count", 3, r.Files.Count);
            ValueCheck.Test("reader.Results[0].Files[0]", "file0.cab", (string)r.Files[0]);
            ValueCheck.Test("reader.Results[0].Files[1]", "file0.offer", (string)r.Files[1]);
            ValueCheck.Test("reader.Results[0].Files[1]", "file0.png", (string)r.Files[2]);

            r = (PropResult)reader.Results[1];

            ValueCheck.Test("reader.Results[1].Result", (byte)PropResult.PropResultType.PROPFAILED, (byte)r.Result);
            ValueCheck.Test("reader.Results[1].Files.Count", 3, r.Files.Count);
            ValueCheck.Test("reader.Results[1].Files[0]", "file1.cab", (string)r.Files[0]);
            ValueCheck.Test("reader.Results[1].Files[1]", "file1.offer", (string)r.Files[1]);
            ValueCheck.Test("reader.Results[1].Files[1]", "file1.png", (string)r.Files[2]);

            r = (PropResult)reader.Results[2];

            ValueCheck.Test("reader.Results[2].Result", (byte)PropResult.PropResultType.INVALIDGROUPING, (byte)r.Result);
            ValueCheck.Test("reader.Results[2].Files.Count", 3, r.Files.Count);
            ValueCheck.Test("reader.Results[2].Files[0]", "file2.cab", (string)r.Files[0]);
            ValueCheck.Test("reader.Results[2].Files[1]", "file2.offer", (string)r.Files[1]);
            ValueCheck.Test("reader.Results[2].Files[1]", "file2.png", (string)r.Files[2]);

            r = (PropResult)reader.Results[3];

            ValueCheck.Test("reader.Results[3].Result", (byte)PropResult.PropResultType.SKIPPED, (byte)r.Result);
            ValueCheck.Test("reader.Results[3].Files.Count", 3, r.Files.Count);
            ValueCheck.Test("reader.Results[3].Files[0]", "file3.cab", (string)r.Files[0]);
            ValueCheck.Test("reader.Results[3].Files[1]", "file3.offer", (string)r.Files[1]);
            ValueCheck.Test("reader.Results[3].Files[1]", "file3.png", (string)r.Files[2]);
        }

        [TestCase(typeof(ApplicationException))]
        public void Neg_InvalidSummaryLineResultType()
        {
            PropResultsReader reader = new PropResultsReader();

            reader.Load(Path.Combine(_inputFilePath, "PropResultsBadResultType.txt"));
        }

        [TestCase]
        public void Pos_EmptyResultsFile()
        {
            PropResultsWriter writer = new PropResultsWriter();
            string resultsFile = writer.Save(_inputFilePath);

            PropResultsReader reader = new PropResultsReader(resultsFile);
            ValueCheck.Test("reader.Results.Count", 0, reader.Results.Count);
        }

        #endregion
    }


    /// <summary>
    /// This class contains test cases specifically for the File Grouping logic.
    /// </summary>
    [TestGroup, Owner("XNA Test"), TestFrequency("Daily"), EnvRequirement("Deprecated")]
    public class FileGroupingTestCases : TestNode
    {
        #region Member Variables

        private string _inputFilePath;

        #endregion

        #region CTOR/DTOR

        public FileGroupingTestCases()
        {
            XmlNode fileGroupingTestConfig = Global.Config.SelectSingleNode("descendant::APDispatcherTest");

            XmlElement inputFilePath = (XmlElement)fileGroupingTestConfig.SelectSingleNode("InputFilePath");
            _inputFilePath = inputFilePath.InnerText;

            if(!Path.IsPathRooted(_inputFilePath))
            {
                Assembly a = Assembly.GetExecutingAssembly();
                _inputFilePath = Path.Combine(Path.GetDirectoryName(a.Location), _inputFilePath);
            }
        }

        #endregion

        #region Properties

        private string InputFilePath
        {
            get
            {
                return _inputFilePath;
            }
        }

        private string WorkDirectory
        {
            get
            {
                return Path.Combine(Path.GetDirectoryName(Assembly.GetExecutingAssembly().Location), "Work");
            }
        }

        #endregion

        #region TestCases

        [TestCase]
        public void Neg_BadArgTests()
        {
            // 1.  Null file ArrayList
            try
            {
                FileGrouping.GroupFiles(null, null);
            }
            catch(ArgumentException)
            {
            }

            // 2.  Empty file ArrayList
            try
            {
                ArrayList files = new ArrayList();
                FileGrouping.GroupFiles(files, null);
            }
            catch(ArgumentException)
            {
            }

            //  3.  Null PropResultsWriter
            try
            {
                ArrayList files = new ArrayList();
                files.Add("foo");
                FileGrouping.GroupFiles(files, null);
            }
            catch(ArgumentException)
            {
            }
        }

        /// <summary>
        /// Submission job that contains both XLAST and CABs
        /// </summary>
        [TestCase]
        public void Neg_XlastAndCAB()
        {
            PropResultsWriter writer = new PropResultsWriter();

            CleanWorkDirectory();

            ArrayList files = new ArrayList();
            files.Add("APDVT.xlast");
            files.Add("fffe07f100100001.cab");

            CopyFilesToWorkDirectory(files);
            files = CreateWorkFileList();

            ArrayList groups = FileGrouping.GroupFiles(files, writer);

            //There should be 2 grouping errors. the Xlast and Cab, and no pngs found for the Xlast
            ValueCheck.Test("Verifying a single result returned.", 2, writer.Results.Count);
            ValueCheck.Test("Verifying result is PropResultType.INVALIDGROUPING.", (byte)PropResult.PropResultType.INVALIDGROUPING, (byte)((PropResult)writer.Results[0]).Result);
            ValueCheck.Test("Verifying result is PropResultType.INVALIDGROUPING.", (byte)PropResult.PropResultType.INVALIDGROUPING, (byte)((PropResult)writer.Results[1]).Result);
        }

        /// <summary>
        /// Offer that references a non-existent CAB file.
        /// </summary>
        [TestCase]
        public void Neg_MissingCab()
        {
            PropResultsWriter writer = new PropResultsWriter();

            CleanWorkDirectory();

            ArrayList files = new ArrayList();
            files.Add("fffe07f100100001.offer");

            CopyFilesToWorkDirectory(files);
            files = CreateWorkFileList();

            ArrayList groups = FileGrouping.GroupFiles(files, writer);

            ValueCheck.Test("Verifying a single result returned.", 1, writer.Results.Count);
            ValueCheck.Test("Verifying result is PropResultType.INVALIDGROUPING.", (byte)PropResult.PropResultType.INVALIDGROUPING, (byte)((PropResult)writer.Results[0]).Result);
        }

        /// <summary>
        /// Offer that does not contain a CAB reference.
        /// </summary>
        [TestCase]
        public void Neg_MissingCabReference()
        {
            PropResultsWriter writer = new PropResultsWriter();

            CleanWorkDirectory();

            ArrayList files = new ArrayList();
            files.Add("fffe07f100500001.offer");
            files.Add("fffe07f100500001.cab");

            CopyFilesToWorkDirectory(files);
            files = CreateWorkFileList();

            ArrayList groups = FileGrouping.GroupFiles(files, writer);
        
            ValueCheck.Test("Verifying a single result returned.", 1, writer.Results.Count);
            ValueCheck.Test("Verifying result is PropResultType.INVALIDGROUPING.", (byte)PropResult.PropResultType.INVALIDGROUPING, (byte)((PropResult)writer.Results[0]).Result);
        }

        /// <summary>
        /// Offer that references a non-existent PNG file.
        /// </summary>
        [TestCase]
        public void Neg_CabMissingPng()
        {
            PropResultsWriter writer = new PropResultsWriter();

            CleanWorkDirectory();

            ArrayList files = new ArrayList();
            files.Add("fffe07f100100001.offer");
            files.Add("fffe07f100100001.cab");

            CopyFilesToWorkDirectory(files);
            files = CreateWorkFileList();

            ArrayList groups = FileGrouping.GroupFiles(files, writer);
        
            ValueCheck.Test("Verifying a single result returned.", 1, writer.Results.Count);
            ValueCheck.Test("Verifying result is PropResultType.INVALIDGROUPING.", (byte)PropResult.PropResultType.INVALIDGROUPING, (byte)((PropResult)writer.Results[0]).Result);
        }

        /// <summary>
        /// Offer that references a non-existent PNG file.
        /// </summary>
        [TestCase]
        public void Neg_OfferMissingPng()
        {
            PropResultsWriter writer = new PropResultsWriter();

            CleanWorkDirectory();

            ArrayList files = new ArrayList();
            files.Add("fffe07f100400002.offer");

            CopyFilesToWorkDirectory(files);
            files = CreateWorkFileList();

            ArrayList groups = FileGrouping.GroupFiles(files, writer);

            ValueCheck.Test("Verifying a single result returned.", 1, writer.Results.Count);
            ValueCheck.Test("Verifying result is PropResultType.INVALIDGROUPING.", (byte)PropResult.PropResultType.INVALIDGROUPING, (byte)((PropResult)writer.Results[0]).Result);
        }

        [TestCase]
        public void Neg_MoreThanOneXlast()
        {
            PropResultsWriter writer = new PropResultsWriter();

            CleanWorkDirectory();

            ArrayList files = new ArrayList();
            files.Add("APDVT.xlast");
            files.Add("ffff0072.xlast");

            CopyFilesToWorkDirectory(files);
            files = CreateWorkFileList();

            ArrayList groups = FileGrouping.GroupFiles(files, writer);
                
            ValueCheck.Test("Verifying a single result returned.", 1, writer.Results.Count);
            ValueCheck.Test("Verifying result is PropResultType.INVALIDGROUPING.", (byte)PropResult.PropResultType.INVALIDGROUPING, (byte)((PropResult)writer.Results[0]).Result);
        }

        [TestCase]
        public void Pos_Xlast_NoPropResults()
        {
            PropResultsWriter writer = new PropResultsWriter();

            CleanWorkDirectory();

            ArrayList files = new ArrayList();
            files.Add("APDVT.xlast");
            files.Add("ach_img.png");
            files.Add("0xFFFFFFFFFFFFFFFF.png");

            CopyFilesToWorkDirectory(files);
            files = CreateWorkFileList();

            ArrayList groups = FileGrouping.GroupFiles(files, writer);
            ValueCheck.Test("Number of groups returned.", 1, groups.Count);

            FileGroup group0 = (FileGroup)groups[0];
            ValueCheck.Test("Number of files in group 1.", 3, group0.Files.Count);
            ValueCheck.Test("Work type in group 1.", WorkType.XLAST, group0.WorkType);
        }

        [TestCase]
        public void Pos_OfferOnly()
        {
            PropResultsWriter writer = new PropResultsWriter();

            CleanWorkDirectory();

            ArrayList files = new ArrayList();
            files.Add("0xffffffffffffffff.png");
            files.Add("fffe07f100400002.offer");

            CopyFilesToWorkDirectory(files);
            files = CreateWorkFileList();

            ArrayList groups = FileGrouping.GroupFiles(files, writer);
            ValueCheck.Test("Number of groups returned.", 1, groups.Count);

            FileGroup group0 = (FileGroup)groups[0];
            ValueCheck.Test("Number of files in group 1.", 2, group0.Files.Count);
            ValueCheck.Test("Work type in group 1.", WorkType.OfferOnly, group0.WorkType);
        }

        [TestCase]
        public void Pos_Cab()
        {
            PropResultsWriter writer = new PropResultsWriter();

            CleanWorkDirectory();

            ArrayList files = new ArrayList();
            files.Add("fffe07f100200001.offer");
            files.Add("fffe07f100200001.cab");
            files.Add("0xffffffffffffffff.png");

            CopyFilesToWorkDirectory(files);
            files = CreateWorkFileList();

            ArrayList groups = FileGrouping.GroupFiles(files, writer);
            ValueCheck.Test("Number of groups returned.", 1, groups.Count);

            FileGroup group0 = (FileGroup)groups[0];
            ValueCheck.Test("Number of files in group.", 3, group0.Files.Count);
            ValueCheck.Test("Work type in group 1.", WorkType.ContentAndOffer, group0.WorkType);
        }

        [TestCase]
        public void Pos_Cab_GameTrailer()
        {
            PropResultsWriter writer = new PropResultsWriter();

            CleanWorkDirectory();

            ArrayList files = new ArrayList();
            files.Add("fffe07f100100001.offer");
            files.Add("fffe07f100120001.offer");
            files.Add("fffe07f100100001.cab");
            files.Add("0xffffffffffffffff.png");

            CopyFilesToWorkDirectory(files);
            files = CreateWorkFileList();

            ArrayList groups = FileGrouping.GroupFiles(files, writer);
            ValueCheck.Test("Number of groups returned.", 1, groups.Count);

            FileGroup group0 = (FileGroup)groups[0];
            ValueCheck.Test("Number of files in group.", 4, group0.Files.Count);
            ValueCheck.Test("Work type in group 1.", WorkType.ContentAnd2Offers, group0.WorkType);
        }

        [TestCase]
        public void Pos_Cab_TwoGroups()
        {
            PropResultsWriter writer = new PropResultsWriter();

            CleanWorkDirectory();

            ArrayList files = new ArrayList();
            files.Add("fffe07f100100001.offer");
            files.Add("fffe07f100120001.offer");
            files.Add("fffe07f100100001.cab");
            files.Add("fffe07f100600001.offer");
            files.Add("fffe07f100600001.cab");
            files.Add("0xffffffffffffffff.png");

            CopyFilesToWorkDirectory(files);
            files = CreateWorkFileList();

            ArrayList groups = FileGrouping.GroupFiles(files, writer);
            ValueCheck.Test("Number of groups returned.", 2, groups.Count);

            FileGroup group0 = (FileGroup)groups[0];
            ValueCheck.Test("Number of files in group 1.", 4, group0.Files.Count);
            ValueCheck.Test("Work type in group 1.", WorkType.ContentAnd2Offers, group0.WorkType);

            FileGroup group1 = (FileGroup)groups[1];
            ValueCheck.Test("Number of files in group 2.", 3, group1.Files.Count);
            ValueCheck.Test("Work type in group 2.", WorkType.ContentAndOffer, group1.WorkType);

            ValueCheck.Test("Number of results in writer.", 0, writer.Results.Count);
        }

        /// <summary>
        /// In this test we have two groups of offer/cab, and one group of just cab
        /// </summary>
        [TestCase]
        public void Pos_Cab_ThreeGroups()
        {
            PropResultsWriter writer = new PropResultsWriter();

            CleanWorkDirectory();

            ArrayList files = new ArrayList();
            files.Add("fffe07f100100001.offer");
            files.Add("fffe07f100120001.offer");
            files.Add("fffe07f100100001.cab");
            files.Add("fffe07f100600001.offer");
            files.Add("fffe07f100600001.cab");
            files.Add("fffe07f100700001.cab");
            files.Add("0xffffffffffffffff.png");

            CopyFilesToWorkDirectory(files);
            files = CreateWorkFileList();

            ArrayList groups = FileGrouping.GroupFiles(files, writer);
            ValueCheck.Test("Number of groups returned.", 3, groups.Count);

            FileGroup group0 = (FileGroup)groups[0];
            ValueCheck.Test("Number of files in group 1.", 4, group0.Files.Count);
            ValueCheck.Test("Work type in group 1.", WorkType.ContentAnd2Offers, group0.WorkType);

            FileGroup group1 = (FileGroup)groups[1];
            ValueCheck.Test("Number of files in group 2.", 3, group1.Files.Count);
            ValueCheck.Test("Work type in group 1.", WorkType.ContentAndOffer, group1.WorkType);

            FileGroup group2 = (FileGroup)groups[2];
            ValueCheck.Test("Number of files in group 3.", 1, group2.Files.Count);
            ValueCheck.Test("Work type in group 3.", WorkType.Content, group2.WorkType);

            ValueCheck.Test("Number of results in writer.", 0, writer.Results.Count);
        }

        /// <summary>
        /// This submission contains a prop results file where the previous
        /// submission had one success and one failure
        /// </summary>
        [TestCase]
        public void Pos_Cab_SinglePropResultsFile()
        {
            PropResultsWriter writer = new PropResultsWriter();

            CleanWorkDirectory();

            ArrayList files = new ArrayList();
            files.Add("fffe07f100100001.offer");
            files.Add("fffe07f100120001.offer");
            files.Add("fffe07f100100001.cab");
            files.Add("fffe07f100600001.offer");
            files.Add("fffe07f100600001.cab");
            files.Add("PropResults_20060315121402442.txt");
            files.Add("0xffffffffffffffff.png");

            CopyFilesToWorkDirectory(files);
            files = CreateWorkFileList();

            ArrayList groups = FileGrouping.GroupFiles(files, writer);
            ValueCheck.Test("Number of groups returned.", 1, groups.Count);

            FileGroup group0 = (FileGroup)groups[0];
            ValueCheck.Test("Number of files in group.", 4, group0.Files.Count);
            ValueCheck.Test("Work type in group 1.", WorkType.ContentAnd2Offers, group0.WorkType);

            ValueCheck.Test("Number of results in writer.", 1, writer.Results.Count);
            ValueCheck.Test("Correct PropResultType.", (byte)(PropResult.PropResultType.SKIPPED), (byte)((PropResult)writer.Results[0]).Result);
        }

        /// <summary>
        /// This submission contains two prop results files.  The most
        /// recent prop results file has one skipped and one failure.
        /// The older prop results file should be ignored.
        /// </summary>
        [TestCase]
        public void Pos_Cab_TwoPropResultsFiles()
        {
            PropResultsWriter writer = new PropResultsWriter();

            CleanWorkDirectory();

            ArrayList files = new ArrayList();
            files.Add("fffe07f100100001.offer");
            files.Add("fffe07f100120001.offer");
            files.Add("fffe07f100100001.cab");
            files.Add("fffe07f100600001.offer");
            files.Add("fffe07f100600001.cab");
            files.Add("PropResults_20060315121402442.txt");
            files.Add("PropResults_20060315122202442.txt");
            files.Add("0xffffffffffffffff.png");

            CopyFilesToWorkDirectory(files);
            files = CreateWorkFileList();

            ArrayList groups = FileGrouping.GroupFiles(files, writer);
            ValueCheck.Test("Number of groups returned.", 1, groups.Count);

            FileGroup group0 = (FileGroup)groups[0];
            ValueCheck.Test("Number of files in group.", 4, group0.Files.Count);
            ValueCheck.Test("Work type in group 1.", WorkType.ContentAnd2Offers, group0.WorkType);

            ValueCheck.Test("Number of results in writer.", 1, writer.Results.Count);
            ValueCheck.Test("Correct PropResultType.", (byte)(PropResult.PropResultType.SKIPPED), (byte)((PropResult)writer.Results[0]).Result);
        }

        [TestCase]
        public void Neg_Trailer_NoMatchingOffer()
        {
            PropResultsWriter writer = new PropResultsWriter();

            CleanWorkDirectory();

            ArrayList files = new ArrayList();
            files.Add("fffe07f100100001.offer");
            files.Add("fffe07f100100001.cab");
            files.Add("0xffffffffffffffff.png");

            CopyFilesToWorkDirectory(files);
            files = CreateWorkFileList();

            ArrayList groups = FileGrouping.GroupFiles(files, writer);
            ValueCheck.Test("Number of groups returned.", 1, groups.Count);

            FileGroup group0 = (FileGroup)groups[0];
            ValueCheck.Test("Number of files in group.", 3, group0.Files.Count);
            ValueCheck.Test("Work type in group 1.", WorkType.ContentAndOffer, group0.WorkType);

            ValueCheck.Test("Number of results in writer.", 0, writer.Results.Count);
        }

        [TestCase]
        public void Pos_Cab_BungieBug()
        {
            PropResultsWriter writer = new PropResultsWriter();

            CleanWorkDirectory();

            ArrayList files = new ArrayList();
            files.Add("4D5307E600000001.offer");
            files.Add("4D5307E600000001.cab");
            files.Add("marketplace_banner.png");

            CopyFilesToWorkDirectory(files);
            files = CreateWorkFileList();

            ArrayList groups = FileGrouping.GroupFiles(files, writer);
            ValueCheck.Test("Number of groups returned.", 1, groups.Count);

            FileGroup group0 = (FileGroup)groups[0];
            ValueCheck.Test("Number of files in group.", 3, group0.Files.Count);
            ValueCheck.Test("Work type in group 1.", WorkType.ContentAndOffer, group0.WorkType);
        }


        #endregion

        #region Private Helper Methods

        /// <summary>
        /// Given a list of filenames w/o path information, copy each
        /// specified file from the InputFiles directory to the Work
        /// directory.
        /// </summary>
        /// <param name="files"></param>
        private void CopyFilesToWorkDirectory(ArrayList files)
        {
            if(!Directory.Exists(WorkDirectory))
                Directory.CreateDirectory(WorkDirectory);

            foreach(string file in files)
            {
                File.Copy(Path.Combine(InputFilePath, file), Path.Combine(WorkDirectory, file));
            }
        }

        /// <summary>
        /// Remove all files from the work directory.
        /// </summary>
        private void CleanWorkDirectory()
        {
            if(Directory.Exists(WorkDirectory))
            {
                string [] files = Directory.GetFiles(WorkDirectory, "*");
                foreach(string file in files)
                {
                    File.Delete(Path.Combine(WorkDirectory, file));
                }
            }
        }

        /// <summary>
        /// Create an ArrayList containing full path information to each
        /// file in the work directory.
        /// </summary>
        /// <returns></returns>
        private ArrayList CreateWorkFileList()
        {
            ArrayList a = new ArrayList();

            if(Directory.Exists(WorkDirectory))
            {
                string [] files = Directory.GetFiles(WorkDirectory, "*");
                foreach(string file in files)
                {
                    a.Add(Path.Combine(WorkDirectory, file));
                }
            }

            return a;
        }

        #endregion
    }


    /// <summary>
    /// This class contains test cases that exercise autoprop end-to-end by filing
    /// bugs and then executing APDispatcher.
    /// </summary>
    [TestGroup, Owner("XNA Test"), TestFrequency("Daily"), EnvRequirement("Deprecated")]
	public class APDispatcherTestCases : TestNode
	{
        #region Member Variables

        private string _inputFilePath;
        private string _server;
        private string _uploadServer;
        private string _psDatabase;
        private string _psPath;
        private string _emailAddr = "darrenan@xbox.com";
        private static string _executablePath = null;

        #endregion

        #region CTOR/DTOR

        public APDispatcherTestCases()
        {
            XmlNode apDispatcherTestConfig = Global.Config.SelectSingleNode("descendant::APDispatcherTest");

            XmlElement inputFilePath = (XmlElement)apDispatcherTestConfig.SelectSingleNode("InputFilePath");
            _inputFilePath = inputFilePath.InnerText;

            if(!Path.IsPathRooted(_inputFilePath))
            {
                Assembly a = Assembly.GetExecutingAssembly();
                _inputFilePath = Path.Combine(Path.GetDirectoryName(a.Location), _inputFilePath);
            }

            XmlElement server = (XmlElement)apDispatcherTestConfig.SelectSingleNode("Server");
            _server = server.InnerText;

            XmlElement uploadServer = (XmlElement)apDispatcherTestConfig.SelectSingleNode("UploadServer");
            _uploadServer = uploadServer.InnerText;

            XmlElement psDatabase = (XmlElement)apDispatcherTestConfig.SelectSingleNode("PSDatabase");
            _psDatabase = psDatabase.InnerText;

            XmlElement psPath = (XmlElement)apDispatcherTestConfig.SelectSingleNode("PSPath");
            _psPath = psPath.InnerText;

            XmlElement exeFilePath = (XmlElement)apDispatcherTestConfig.SelectSingleNode("ExePath");
            if (exeFilePath != null)
            {
                string executablePath = exeFilePath.InnerText;

                if (!Path.IsPathRooted(executablePath))
                {
                    Assembly a = Assembly.GetExecutingAssembly();
                    executablePath = Path.Combine(Path.GetDirectoryName(a.Location), executablePath);
                }
                _executablePath = Path.Combine(executablePath, @"APDispatcher.exe");
            }

            XmlElement emailAddr = (XmlElement)apDispatcherTestConfig.SelectSingleNode("Email");
            if (emailAddr != null)
            {
                _emailAddr = emailAddr.InnerText;
            }
        }

        #endregion

        #region Properties

        private static string APDispatcherPath
        {
            get
            {
                if (_executablePath == null)
                {
                    return Path.Combine(
                        Path.GetDirectoryName(Assembly.GetExecutingAssembly().Location),
                        @"..\..\..\tools\APDispatcher\APDispatcher.exe");
                }
                else
                {
                    return _executablePath;
                }
            }
        }

        #endregion

        #region Test Cases

        [TestCase]
        public void Pos_EmptyBug()
        {
            int bugID = PSUtil.CreateAutoPropBug(_psDatabase, _psPath, "Pos_EmptyBug", null, null, null, "fffe07f1", _emailAddr);
            RunAPDispatcher();

            PSUtil.VerifyAutoPropBug(_psDatabase, _psPath, bugID, "Active", "Ignored", (PropResult.PropResultType)0);
        }

        [TestCase]
        public void Pos_Xlast_Attached()
        {
            ArrayList files = new ArrayList();
            files.Add(Path.Combine(_inputFilePath, "APDVT.xlast"));
            files.Add(Path.Combine(_inputFilePath, "ach_img.png"));
            files.Add(Path.Combine(_inputFilePath, "0xFFFFFFFFFFFFFFFF.png"));

            int bugID = PSUtil.CreateAutoPropBug(_psDatabase, _psPath, "Pos_Xlast_Attached", files, null, null, "fffe07f1", _emailAddr);
            RunAPDispatcher();

            PSUtil.VerifyAutoPropBug(_psDatabase, _psPath, bugID, "Resolved", "Completed", PropResult.PropResultType.SUCCESS);
        }

        [TestCase]
        public void Pos_Xlast_Linked()
        {
            string folder = Path.Combine(MakeUncFolderPath(), "Pos_Xlast_Linked");

            if(!Directory.Exists(folder))
            {
                Directory.CreateDirectory(folder);
            }

            try
            {
                File.Copy(
                    Path.Combine(_inputFilePath, "APDVT.xlast"), 
                    Path.Combine(folder, "APDVT.xlast"), 
                    true );
                File.Copy(
                    Path.Combine(_inputFilePath, "ach_img.png"), 
                    Path.Combine(folder, "ach_img.png"), 
                    true );
                File.Copy(
                    Path.Combine(_inputFilePath, "0xFFFFFFFFFFFFFFFF.png"), 
                    Path.Combine(folder, "0xFFFFFFFFFFFFFFFF.png"), 
                    true );

                ArrayList folders = new ArrayList();
                folders.Add(folder);

                int bugID = PSUtil.CreateAutoPropBug(_psDatabase, _psPath, "Pos_Xlast_Linked", null, folders, null, "fffe07f1", _emailAddr);
                RunAPDispatcher();

                PSUtil.VerifyAutoPropBug(_psDatabase, _psPath, bugID, "Resolved", "Completed", PropResult.PropResultType.SUCCESS);
            }
            finally
            {
                Directory.Delete(folder, true);
            }            
        }

        [TestCase]
        public void Pos_CabDefaultOffer_Attached_AutoProp()
        {
            ArrayList files = new ArrayList();
            files.Add(Path.Combine(_inputFilePath, "fffe07f100400001.cab"));

            int bugID = PSUtil.CreateAutoPropBug(_psDatabase, _psPath, "Pos_CabDefaultOffer_Attached_AutoProp", files, null, null, "fffe07f1", _emailAddr);
            RunAPDispatcher();

            PSUtil.VerifyAutoPropBug(_psDatabase, _psPath, bugID, "Resolved", "Completed", PropResult.PropResultType.SUCCESS);
        }

        [TestCase]
        public void Pos_CabDefaultOffer_Linked_AutoProp()
        {
            string folder = Path.Combine(MakeUncFolderPath(), "Pos_CabDefaultOffer_Linked_AutoProp");

            if(!Directory.Exists(folder))
            {
                Directory.CreateDirectory(folder);
            }

            try
            {
                File.Copy(
                    Path.Combine(_inputFilePath, "fffe07f100400001.cab"),
                    Path.Combine(folder, "fffe07f100400001.cab"),
                    true);

                ArrayList folders = new ArrayList();
                folders.Add(folder);

                int bugID = PSUtil.CreateAutoPropBug(_psDatabase, _psPath, "Pos_CabDefaultOffer_Linked_AutoProp", null, folders, "fffe07f1", null, _emailAddr);
                RunAPDispatcher();

                PSUtil.VerifyAutoPropBug(_psDatabase, _psPath, bugID, "Resolved", "Completed", PropResult.PropResultType.SUCCESS);
            }
            finally
            {
                Directory.Delete(folder, true);
            } 
        }

        [TestCase]
        public void Pos_CabAndOffer_Linked_AutoProp()
        {
            string folder = Path.Combine(MakeUncFolderPath(), "Pos_CabAndOffer_Linked_AutoProp");

            if(!Directory.Exists(folder))
            {
                Directory.CreateDirectory(folder);
            }

            try
            {
                File.Copy(
                    Path.Combine(_inputFilePath, "fffe07f100400001.cab"),
                    Path.Combine(folder, "fffe07f100400001.cab"),
                    true);
                File.Copy(
                    Path.Combine(_inputFilePath, "fffe07f100400001.offer"),
                    Path.Combine(folder, "fffe07f100400001.offer"),
                    true);
                File.Copy(
                    Path.Combine(_inputFilePath, "0xffffffffffffffff.png"),
                    Path.Combine(folder, "0xffffffffffffffff.png"),
                    true);

                ArrayList folders = new ArrayList();
                folders.Add(folder);

                int bugID = PSUtil.CreateAutoPropBug(_psDatabase, _psPath, "Pos_CabAndOffer_Linked_AutoProp", null, folders, null, "fffe07f1", _emailAddr);
                RunAPDispatcher();

                PSUtil.VerifyAutoPropBug(_psDatabase, _psPath, bugID, "Resolved", "Completed", PropResult.PropResultType.SUCCESS);
            }
            finally
            {
                Directory.Delete(folder, true);
            }
        }

        [TestCase]
        public void Pos_MultiCabs_Attached_AutoProp()
        {
            ArrayList attachedFiles = new ArrayList();
            attachedFiles.Add(Path.Combine(_inputFilePath, "fffe07f100400001.cab"));
            attachedFiles.Add(Path.Combine(_inputFilePath, "fffe07f100400001.offer"));
            attachedFiles.Add(Path.Combine(_inputFilePath, "fffe07f100600001.cab"));
            attachedFiles.Add(Path.Combine(_inputFilePath, "fffe07f100600001.offer"));
            attachedFiles.Add(Path.Combine(_inputFilePath, "0xffffffffffffffff.png"));

            int bugID = PSUtil.CreateAutoPropBug(_psDatabase, _psPath, "Pos_MultiCabs_Attached_AutoProp", attachedFiles, null, null, "fffe07f1", _emailAddr);
            RunAPDispatcher();

            PSUtil.VerifyAutoPropBug(_psDatabase, _psPath, bugID, "Resolved", "Completed", PropResult.PropResultType.SUCCESS);
        }

        [TestCase]
        public void Pos_MultiCabs_Linked_AutoProp()
        {
            string folder = Path.Combine(MakeUncFolderPath(), "Pos_MultiCabs_Linked_AutoProp");

            if(!Directory.Exists(folder))
            {
                Directory.CreateDirectory(folder);
            }
            try
            {
                File.Copy(
                    Path.Combine(_inputFilePath, "fffe07f100400001.cab"),
                    Path.Combine(folder, "fffe07f100400001.cab"),
                    true);
                File.Copy(
                    Path.Combine(_inputFilePath, "fffe07f100400001.offer"),
                    Path.Combine(folder, "fffe07f100400001.offer"),
                    true);
                File.Copy(
                    Path.Combine(_inputFilePath, "fffe07f100600001.cab"),
                    Path.Combine(folder, "fffe07f100600001.cab"),
                    true);
                File.Copy(
                    Path.Combine(_inputFilePath, "fffe07f100600001.offer"),
                    Path.Combine(folder, "fffe07f100600001.offer"),
                    true);
                File.Copy(
                    Path.Combine(_inputFilePath, "0xffffffffffffffff.png"),
                    Path.Combine(folder, "0xffffffffffffffff.png"),
                    true);

                ArrayList folders = new ArrayList();
                folders.Add(folder);

                int bugID = PSUtil.CreateAutoPropBug(_psDatabase, _psPath, "Pos_MultiCabs_Linked_AutoProp", null, folders, null, "fffe07f1", _emailAddr);
                RunAPDispatcher();

                PSUtil.VerifyAutoPropBug(_psDatabase, _psPath, bugID, "Resolved", "Completed", PropResult.PropResultType.SUCCESS);
            }
            finally
            {
                Directory.Delete(folder, true);
            } 
        }

        [TestCase]
        public void Pos_MultiCabs_Mixed_AutoProp()
        {
            ArrayList files = new ArrayList();
            files.Add(Path.Combine(_inputFilePath, "fffe07f100400001.cab"));
            files.Add(Path.Combine(_inputFilePath, "fffe07f100400001.offer"));
            files.Add(Path.Combine(_inputFilePath, "0xffffffffffffffff.png"));

            string folder = Path.Combine(MakeUncFolderPath(), "Pos_MultiCabs_Mixed_AutoProp");

            if(!Directory.Exists(folder))
            {
                Directory.CreateDirectory(folder);
            }
            try
            {
                File.Copy(
                    Path.Combine(_inputFilePath, "fffe07f100600001.cab"),
                    Path.Combine(folder, "fffe07f100600001.cab"),
                    true);
                File.Copy(
                    Path.Combine(_inputFilePath, "fffe07f100600001.offer"),
                    Path.Combine(folder, "fffe07f100600001.offer"),
                    true);
                File.Copy(
                    Path.Combine(_inputFilePath, "0xffffffffffffffff.png"),
                    Path.Combine(folder, "0xffffffffffffffff.png"),
                    true);

                ArrayList folders = new ArrayList();
                folders.Add(folder);

                int bugID = PSUtil.CreateAutoPropBug(_psDatabase, _psPath, "Pos_MultiCabs_Mixed_AutoProp", files, folders, null, "fffe07f1", _emailAddr);
                RunAPDispatcher();

                PSUtil.VerifyAutoPropBug(_psDatabase, _psPath, bugID, "Resolved", "Completed", PropResult.PropResultType.SUCCESS);
            }
            finally
            {
                Directory.Delete(folder, true);
            }
        }


        [TestCase]
        public void Pos_OfferNoCabAttached()
        {
            ArrayList files = new ArrayList();
            files.Add(Path.Combine(_inputFilePath, "0xffffffffffffffff.png"));
            files.Add(Path.Combine(_inputFilePath, "fffe07f100400002.offer"));

            int bugID = PSUtil.CreateAutoPropBug(_psDatabase, _psPath, "Pos_OfferNoCabAttached", files, null, null, "fffe07f1", _emailAddr);
            RunAPDispatcher();

            PSUtil.VerifyAutoPropBug(_psDatabase, _psPath, bugID, "Resolved", "Completed", PropResult.PropResultType.SUCCESS);
        }


        [TestCase]
        public void Pos_OfferNoCabLinked()
        {
            string folder = Path.Combine(MakeUncFolderPath(), "Pos_OfferNoCabLinked");

            if (!Directory.Exists(folder))
            {
                Directory.CreateDirectory(folder);
            }
            try
            {
                File.Copy(
                    Path.Combine(_inputFilePath, "fffe07f100400002.offer"),
                    Path.Combine(folder, "fffe07f100400002.offer"),
                    true);
                File.Copy(
                    Path.Combine(_inputFilePath, "0xffffffffffffffff.png"),
                    Path.Combine(folder, "0xffffffffffffffff.png"),
                    true);

                ArrayList folders = new ArrayList();
                folders.Add(folder);

                int bugID = PSUtil.CreateAutoPropBug(_psDatabase, _psPath, "Pos_OfferNoCabLinked", null, folders, null, "fffe07f1", _emailAddr);
                RunAPDispatcher();

                PSUtil.VerifyAutoPropBug(_psDatabase, _psPath, bugID, "Resolved", "Completed", PropResult.PropResultType.SUCCESS);
            }
            finally
            {
                Directory.Delete(folder, true);
            }
        }


        [TestCase]
        public void Pos_XlastReProp()
        {
            ArrayList files = new ArrayList();
            files.Add(Path.Combine(_inputFilePath, "APDVT.xlast"));
            files.Add(Path.Combine(_inputFilePath, "ach_img.png"));
            files.Add(Path.Combine(_inputFilePath, "0xFFFFFFFFFFFFFFFF.png"));

            int bugID = PSUtil.CreateAutoPropBug(_psDatabase, _psPath, "Pos_XlastReProp", files, null, null, "fffe07f1", _emailAddr);
            RunAPDispatcher();

            PSUtil.VerifyAutoPropBug(_psDatabase, _psPath, bugID, "Resolved", "Completed", PropResult.PropResultType.SUCCESS);

            PSUtil.ReactivateAutopropBug(_psDatabase, _psPath, bugID);

            RunAPDispatcher();

            PSUtil.VerifyAutoPropBug(_psDatabase, _psPath, bugID, "Resolved", "Completed", PropResult.PropResultType.SKIPPED);
        }
        
        
        [TestCase]
        public void Pos_Cab_Attached_ReProp()
        {
            ArrayList files = new ArrayList();
            files.Add(Path.Combine(_inputFilePath, "fffe07f100400001.cab"));
            files.Add(Path.Combine(_inputFilePath, "fffe07f100400001.offer"));

            int bugID = PSUtil.CreateAutoPropBug(_psDatabase, _psPath, "Pos_Cab_Attached_ReProp", files, null, null, "fffe07f1", _emailAddr);
            RunAPDispatcher();

            PSUtil.VerifyAutoPropBug(_psDatabase, _psPath, bugID, "Active", "Failed", PropResult.PropResultType.INVALIDGROUPING);

            PSUtil.AddFileToBug(_psDatabase, _psPath, bugID, Path.Combine(_inputFilePath, "0xffffffffffffffff.png"));
            PSUtil.ReactivateAutopropBug(_psDatabase, _psPath, bugID);

            RunAPDispatcher();

            PSUtil.VerifyAutoPropBug(_psDatabase, _psPath, bugID, "Resolved", "Completed", PropResult.PropResultType.SUCCESS);
        }


        [TestCase]
        public void Neg_OneOfTwoGroupsInvalid()
        {
            ArrayList files = new ArrayList();
            files.Add(Path.Combine(_inputFilePath, "fffe07f100400001.cab"));
            files.Add(Path.Combine(_inputFilePath, "fffe07f100500001.offer"));
            files.Add(Path.Combine(_inputFilePath, "0xffffffffffffffff.png"));

            int bugID = PSUtil.CreateAutoPropBug(_psDatabase, _psPath, "Neg_OneOfTwoGroupsInvalid", files, null, null, "fffe07f1", _emailAddr);
            RunAPDispatcher();

            PSUtil.VerifyAutoPropBug(_psDatabase, _psPath, bugID, "Active", "Failed", PropResult.PropResultType.INVALIDGROUPING);
        }

        [TestCase]
        public void Neg_CabAndXlast()
        {
            ArrayList files = new ArrayList();
            files.Add(Path.Combine(_inputFilePath, "apdvt.xlast"));
            files.Add(Path.Combine(_inputFilePath, "fffe07f100400001.cab"));

            int bugID = PSUtil.CreateAutoPropBug(_psDatabase, _psPath, "Neg_CabAndXlast", files, null, null, "fffe07f1", _emailAddr);
            RunAPDispatcher();

            PSUtil.VerifyAutoPropBug(_psDatabase, _psPath, bugID, "Active", "Failed", PropResult.PropResultType.INVALIDGROUPING);
        }

        [TestCase]
        public void Neg_BadXlast_Attached()
        {
            ArrayList files = new ArrayList();
            files.Add(Path.Combine(_inputFilePath, "APDVTBad.xlast"));
            files.Add(Path.Combine(_inputFilePath, "ach_img.png"));
            files.Add(Path.Combine(_inputFilePath, "0xFFFFFFFFFFFFFFFF.png"));

            int bugID = PSUtil.CreateAutoPropBug(_psDatabase, _psPath, "Neg_BadXlast_Attached", files, null, null, "fffe07f1", _emailAddr);
            RunAPDispatcher();

            PSUtil.VerifyAutoPropBug(_psDatabase, _psPath, bugID, "Active", "Failed", PropResult.PropResultType.PROPFAILED);
        }

        [TestCase]
        public void Pos_TitleIdInField()
        {
            ArrayList files = new ArrayList();
            files.Add(Path.Combine(_inputFilePath, "fffe07f100400001.cab"));

            int bugID = PSUtil.CreateAutoPropBug(_psDatabase, _psPath, "Pos_TitleIdInField", files, null, "fffe07f1 (blah)", null, null);
            RunAPDispatcher();

            PSUtil.VerifyAutoPropBug(_psDatabase, _psPath, bugID, "Resolved", "Completed", PropResult.PropResultType.SUCCESS);
        }

        [TestCase]
        public void Neg_BadTitleIdInField()
        {
            ArrayList files = new ArrayList();
            files.Add(Path.Combine(_inputFilePath, "fffe07f100400001.cab"));

            int bugID = PSUtil.CreateAutoPropBug(_psDatabase, _psPath, "Neg_BadTitleIdInField", files, null, "jfffe07f1 (blah)", null, null);
            RunAPDispatcher();

            PSUtil.VerifyAutoPropBug(_psDatabase, _psPath, bugID, "Active", "Ignored", (PropResult.PropResultType)0);
        }

        [TestCase]
        public void Neg_BadTitleIdInDesc()
        {
            ArrayList files = new ArrayList();
            files.Add(Path.Combine(_inputFilePath, "fffe07f100400001.cab"));

            int bugID = PSUtil.CreateAutoPropBug(_psDatabase, _psPath, "Neg_BadTitleIdInDesc", files, null, null, "jfffe07f1", _emailAddr);
            RunAPDispatcher();

            PSUtil.VerifyAutoPropBug(_psDatabase, _psPath, bugID, "Active", "Ignored", (PropResult.PropResultType)0);
        }

        [TestCase]
        public void Neg_ShortTitleIdInDesc()
        {
            ArrayList files = new ArrayList();
            files.Add(Path.Combine(_inputFilePath, "fffe07f100400001.cab"));

            int bugID = PSUtil.CreateAutoPropBug(_psDatabase, _psPath, "Neg_ShortTitleIdInDesc", files, null, null, "fffe07f", _emailAddr);
            RunAPDispatcher();

            PSUtil.VerifyAutoPropBug(_psDatabase, _psPath, bugID, "Active", "Ignored", (PropResult.PropResultType)0);
        }

        [TestCase]
        public void Neg_EmptyTitleIdInDesc()
        {
            ArrayList files = new ArrayList();
            files.Add(Path.Combine(_inputFilePath, "fffe07f100400001.cab"));

            int bugID = PSUtil.CreateAutoPropBug(_psDatabase, _psPath, "Neg_EmptyTitleIdInDesc", files, null, null, "", _emailAddr);
            RunAPDispatcher();

            PSUtil.VerifyAutoPropBug(_psDatabase, _psPath, bugID, "Active", "Ignored", (PropResult.PropResultType)0);
        }

        [TestCase]
        public void Neg_SpaceTitleIdInDesc()
        {
            ArrayList files = new ArrayList();
            files.Add(Path.Combine(_inputFilePath, "fffe07f100400001.cab"));

            int bugID = PSUtil.CreateAutoPropBug(_psDatabase, _psPath, "Neg_SpaceTitleIdInDesc", files, null, null, " ", _emailAddr);
            RunAPDispatcher();

            PSUtil.VerifyAutoPropBug(_psDatabase, _psPath, bugID, "Active", "Ignored", (PropResult.PropResultType)0);
        }

        [TestCase]
        public void Neg_EmptyEmailInDesc()
        {
            ArrayList files = new ArrayList();
            files.Add(Path.Combine(_inputFilePath, "fffe07f100400001.cab"));

            int bugID = PSUtil.CreateAutoPropBug(_psDatabase, _psPath, "Neg_EmptyEmailInDesc", files, null, null, "fffe07f1", "");
            RunAPDispatcher();

            PSUtil.VerifyAutoPropBug(_psDatabase, _psPath, bugID, "Active", "Ignored", (PropResult.PropResultType)0);
        }

        [TestCase]
        public void Neg_SpaceEmailIdInDesc()
        {
            ArrayList files = new ArrayList();
            files.Add(Path.Combine(_inputFilePath, "fffe07f100400001.cab"));

            int bugID = PSUtil.CreateAutoPropBug(_psDatabase, _psPath, "Neg_SpaceEmailIdInDesc", files, null, null, "fffe07f1", " ");
            RunAPDispatcher();

            PSUtil.VerifyAutoPropBug(_psDatabase, _psPath, bugID, "Active", "Ignored", (PropResult.PropResultType)0);
        }

        #endregion

        #region Utilities

        private void RunAPDispatcher()
        {
            string output = null;
            APDispatcherShell shell = new APDispatcherShell(APDispatcherPath);
            shell.Server = _server;
            shell.UploadServer = _uploadServer;
            shell.PSDatabase = "xboxonlinetest";
            shell.PSPath = "DVT";
            shell.Certificate = Path.Combine(_inputFilePath, "test.AutoProp.rdw.001.cer");
            shell.MaxBugs = 1;
            
            int returnCode = shell.Run(ref output);

            ValueCheck.Test("APDispatcher return code.", 0, returnCode);
        }

        private string MakeUncFolderPath()
        {
            string [] components = Path.GetTempPath().Split(':');

            string folder = @"\\" + Environment.MachineName + @"\" + components[0] + "$" + components[1];
 
            return folder;
        }

        #endregion
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\StfTests\BasicTest\BasicTest.cs ===
using System;
using ServerTestFramework;
using System.Xml;

[assembly: RootNode(typeof(BasicTest.BasicTest))]

namespace BasicTest
{
    public class BasicTest: TestNode
    {
        public override void OneTimeSetup()
        {
            Global.RO.Info("Root OneTimeSetup called.");
        }

        public override void OneTimeCleanup()
        {
            Global.RO.Info("Root OneTimeCleanup called.");
        }

        public override void PreRun()
        {
            Global.RO.Info("Root PreRun called.");
        }

        public override void PostRun()
        {
            Global.RO.Info("Root PostRun called.");
        }

        public override bool Prerequisites(ref System.Collections.Generic.Dictionary<string, bool> data)
        {
            bool result = true;
            if (data.ContainsKey("prevalue1"))
            {
                data["prevalue1"] = false;
                result = false;
            }
            return result;
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\StfTests\BasicTest\obj\i386\_generated.cs ===
[assembly:System.Runtime.InteropServices.ComVisible(false)]
[assembly:System.Reflection.AssemblyVersion("12.4.56.0")]
[assembly:System.Reflection.AssemblyProduct("Microsoft(R) Xbox(TM)")]
[assembly:System.Reflection.AssemblyCopyright("Copyright (c) Microsoft Corporation. All rights reserved.")]
[assembly:System.Reflection.AssemblyCompany("Microsoft Corporation")]
[assembly:System.Reflection.AssemblyFileVersion("12.4.56.0")]
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\StfTests\BasicTest\obj\i386\_asmid.inc ===
ASSEMBLY_IDENTITY_KEY_FORM=msil_basictest_none_12.4.56.0_none_f3d7145f4921571b
ASSEMBLY_IDENTITY_XP_KEY_FORM=msil_basictest_no-public-key_12.4.56.0_x-ww_bfa90143
ASSEMBLY_IDENTITY_CULTURE=
ASSEMBLY_IDENTITY_NAME=basictest
ASSEMBLY_IDENTITY_PROCESSOR_ARCHITECTURE=msil
ASSEMBLY_IDENTITY_PUBLIC_KEY=
ASSEMBLY_IDENTITY_PUBLIC_KEY_TOKEN=
ASSEMBLY_IDENTITY_TYPE=
ASSEMBLY_IDENTITY_TYPE_NAME=
ASSEMBLY_IDENTITY_VERSION=12.4.56.0
XP_KEY_FORM=msil_basictest_no-public-key_12.4.56.0_x-ww_bfa90143
XP_MANIFEST_DIRECTORY=manifests
XP_MANIFEST_NAME=msil_basictest_no-public-key_12.4.56.0_x-ww_bfa90143.manifest
XP_MANIFEST_PATH=manifests\msil_basictest_no-public-key_12.4.56.0_x-ww_bfa90143.manifest
XP_CATALOG_DIRECTORY=manifests
XP_CATALOG_NAME=msil_basictest_no-public-key_12.4.56.0_x-ww_bfa90143.cat
XP_CATALOG_PATH=manifests\msil_basictest_no-public-key_12.4.56.0_x-ww_bfa90143.cat
XP_PAYLOAD_PATH=msil_basictest_no-public-key_12.4.56.0_x-ww_bfa90143
_DELAY_SIGN=0
!if [set _ASMIDTOATTRIBS_TLBIMP=]
!endif
CODESIGN_TESTKEY=
_TLBIMP_FLAGS=$(_TLBIMP_FLAGS)  /asmversion:12.4.56.0
_ASSEMBLY_IDENTITY=basictest,processorArchitecture=msil,version=12.4.56.0,publicKeyToken=neutral
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\StfTests\BasicTest\objd\i386\_asmid.inc ===
ASSEMBLY_IDENTITY_KEY_FORM=msil_basictest_none_12.4.56.0_none_f3d7145f4921571b
ASSEMBLY_IDENTITY_XP_KEY_FORM=msil_basictest_no-public-key_12.4.56.0_x-ww_bfa90143
ASSEMBLY_IDENTITY_CULTURE=
ASSEMBLY_IDENTITY_NAME=basictest
ASSEMBLY_IDENTITY_PROCESSOR_ARCHITECTURE=msil
ASSEMBLY_IDENTITY_PUBLIC_KEY=
ASSEMBLY_IDENTITY_PUBLIC_KEY_TOKEN=
ASSEMBLY_IDENTITY_TYPE=
ASSEMBLY_IDENTITY_TYPE_NAME=
ASSEMBLY_IDENTITY_VERSION=12.4.56.0
XP_KEY_FORM=msil_basictest_no-public-key_12.4.56.0_x-ww_bfa90143
XP_MANIFEST_DIRECTORY=manifests
XP_MANIFEST_NAME=msil_basictest_no-public-key_12.4.56.0_x-ww_bfa90143.manifest
XP_MANIFEST_PATH=manifests\msil_basictest_no-public-key_12.4.56.0_x-ww_bfa90143.manifest
XP_CATALOG_DIRECTORY=manifests
XP_CATALOG_NAME=msil_basictest_no-public-key_12.4.56.0_x-ww_bfa90143.cat
XP_CATALOG_PATH=manifests\msil_basictest_no-public-key_12.4.56.0_x-ww_bfa90143.cat
XP_PAYLOAD_PATH=msil_basictest_no-public-key_12.4.56.0_x-ww_bfa90143
_DELAY_SIGN=0
!if [set _ASMIDTOATTRIBS_TLBIMP=]
!endif
CODESIGN_TESTKEY=
_TLBIMP_FLAGS=$(_TLBIMP_FLAGS)  /asmversion:12.4.56.0
_ASSEMBLY_IDENTITY=basictest,processorArchitecture=msil,version=12.4.56.0,publicKeyToken=neutral
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\StfTests\BasicTest\objd\i386\_generated.cs ===
[assembly:System.Runtime.InteropServices.ComVisible(false)]
[assembly:System.Reflection.AssemblyVersion("12.4.56.0")]
[assembly:System.Reflection.AssemblyProduct("Microsoft(R) Xbox(TM)")]
[assembly:System.Reflection.AssemblyCopyright("Copyright (c) Microsoft Corporation. All rights reserved.")]
[assembly:System.Reflection.AssemblyCompany("Microsoft Corporation")]
[assembly:System.Reflection.AssemblyFileVersion("12.4.56.0")]
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\StfTests\BasicTest\Stress.cs ===
using System;
using ServerTestFramework;

namespace BasicTest
{
    // the higher the priority is, the more times it got executed
    [StressTest(Priority=1000000, TargetTPS=5000)]
    public class StressSimple : TestNode
    {
        public override void Run()
        {
            // put your stress test logic here
        }
    }

    [StressTest(Priority=100, TargetTPS=2)]
    public class StressSimpleTwo : TestNode
    {
        public override void Run()
        {
            Global.RO.Debug("Stress Outputting Text");

            // put your stress test logic here
        }
    }

    [StressTest(Priority=10, TargetTPS=0.5f)]
    public class StressFailer : TestNode
    {
        public override void Run()
        {
            // put your test logic here
            throw new UnexpectedTestResultException("Not really unexpected.");
        }
    }

    [StressTest(Priority=1, TargetTPS=0.05f)]
    public class StressDeadlocker : TestNode
    {
        public override void Run()
        {
            // put your test logic here
            Global.RO.Info("Forcing deadlock... (sleeping for 125 secs)");
            System.Threading.Thread.Sleep(125000);
            throw new UnexpectedTestResultException("This should've deadlocked!");
        }
    }

    [StressTest(Priority=1, TargetTPS=1.0f)]
    public class BasicAsyncStress : AsyncStressTestNode
    {
        public override void Begin (AsyncStressTracking tracker)
        {
            Global.RO.Info("Async Begin called for test run {0}", tracker.ID);
            ThreadMaker.CreateThread(AsyncCall, tracker).Start();
        }

        public void AsyncCall (object state)
        {
            AsyncStressTracking tracker = (AsyncStressTracking) state;

            System.Threading.Thread.Sleep(20000);
            Global.RO.Info("Calling Async End for test run {0}", tracker.ID);

            End(null, tracker);
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\StfTests\BasicTest\FuncBasic.cs ===
using System;
using System.Collections;
using System.Threading;
using ServerTestFramework;
using ServerTestFramework.LiveService;
using ServerTestFramework.LiveService.UserAccount;
using ServerTestFramework.Utilities;
using ServerTestFramework.Database;

namespace BasicTest
{
    /// <summary>
    /// This whole testGroup is a DVT test, which means any testCase in 
    /// this group is a DVT testCase even though they don't have a DVT
    /// attribute associated with it
    /// 
    /// Normally you will create a new file for each functional group
    /// but this is just a sample of what you can do with test groups
    /// and test cases.
    ///
    /// </summary>
    [TestGroup, DVT]
    public class FuncDVTGroup : TestNode
    {
        // This is an example of using the logging functionality 
        // in xonline. You can add your own report destinations to your
        // report or to the root report (ro.GetRoot()) to capture
        // logs in different ways.
        //
        // There are some default destinations that you can reuse in 
        // in ServerTestFramework.Utilties.
        static Report ro = new Report(typeof(FuncDVTGroup).Name);

        [TestCase, Description("This test case passes")]
        public class SimpleTest : TestNode
        {
            public override void Run()
            {
                Console.Write("Console.Write");
                Console.Out.Write("Console.Out.Write");
                Console.Error.Write("Console.Error.Write");
                Console.WriteLine();
            }
        }

        [TestCase, Description("This test case fails")]
        class SimpleFailingTest : TestNode
        {
            public override void Run()
            {
                throw new UnexpectedTestResultException("This failed.");
            }
        }

        [TestCase(BugID = 1), Description("This test case fails, with a known bug")]
        class FailingTestWithBug : TestNode
        {
            public override void Run()
            {
                throw new UnexpectedTestResultException("This failed.");
            }
        }

        [TestCase, Description("This test case fails, with a known bug exception")]
        class FailingTestWithKnownBugException : TestNode
        {
            public override void Run ()
            {
                throw new KnownBugException(2, "Xbox 360 Console Software");
            }
        }

        [TestCase(BugID = 1), Description("This test case fails, with a known bug exception")]
        class FailingTestWithKnownBugExceptionAndTagBug : TestNode
        {
            public override void Run ()
            {
                throw new KnownBugException(2, "Xbox 360 Console Software");
            }
        }

        [TestCase, Description("This test returns that it did not run.")]
        public class DoesNotRun : TestNode
        {
            public override void Run()
            {
                throw new DidNotExecuteException("This was not able to run.");
            }
        };

        // This test case passes and doesn't have a description
        [TestCase]
        class SimpleUndescribableTest : TestNode
        {
            public override void Run()
            {
            }
        }

        [TestCase, Ignore, Description("This test case will not be executed")]
        public void IgnoreTest_Method()
        {
            throw new UnexpectedTestResultException("This should not have been executed!");
        }

        [TestCase, Ignore, Description("This test case will not be executed")]
        public class IgnoreTest_Class : TestNode
        {
            public override void Run()
            {
                throw new UnexpectedTestResultException("This should not have been executed!");
            }
        }

        //
        //  Expected exception tests
        //

        [TestCase(typeof(ApplicationException))]
        public void ExpectedException_Pos_Method()
        {
            throw (new ApplicationException("Test exception"));
        }

        [TestCase(typeof(ApplicationException))]
        public void ExpectedException_Neg_NoThrow_Method()
        {
        }

        [TestCase(typeof(ApplicationException))]
        public void ExpectedException_Neg_WrongException_Method()
        {
            throw (new ArgumentException("Not the expected exception."));
        }

        [TestCase(typeof(System.IO.File))]
        public void ExpectedException_Neg_ExceptionNotSpecified_Method()
        {
        }

        [TestCase(typeof(ApplicationException))]
        public class ExpectedException_Pos_Class : TestNode
        {
            public override void Run()
            {
                throw (new ApplicationException("Test exception"));
            }
        }

        [TestCase(typeof(ApplicationException))]
        public class ExpectedException_Neg_NoThrow_Class : TestNode
        {
            public override void Run()
            {
            }
        }

        [TestCase(typeof(ApplicationException))]
        public class ExpectedException_Neg_WrongException_Class : TestNode
        {
            public override void Run()
            {
                throw (new ArgumentException("Not the expected exception."));
            }
        }

        [TestCase(typeof(System.IO.File))]
        public class ExpectedException_Neg_ExceptionNotSpecified_Class : TestNode
        {
            public override void Run()
            {
            }
        }
    }

    //deep tests
    [TestGroup]
    public class DeepGroupTest : TestNode
    {
        [TestGroup]
        public class DeepGroup1 : TestNode
        {
            [TestGroup]
            public class DeepGroup2a : TestNode
            {
                [TestGroup]
                public class DeepGroup3 : TestNode
                {
                    [TestCase, DVT]
                    public class DeepCase : TestNode
                    {
                        public override void Run()
                        {
                        }
                    }
                }
            }

            [TestGroup]
            public class DeepGroup2b : TestNode
            {
                [TestGroup]
                public class DeepGroup3 : TestNode
                {
                    [TestCase]
                    public void DeepFuncCase()
                    {
                    }
                }
            }
        }
    }

    /// <summary>
    ///        This entire group is ignored by the test runner.
    /// </summary>
    [TestGroup, Ignore]
    public class FuncIgnoreGroup : TestNode
    {
        [TestCase]
        class IgnoredCase : TestNode
        {
            public override void Run()
            {
                // We never get here.
            }
        }
    }

    /// <summary>
    ///        NUnit style test group definition. This also demonstrates
    ///        the initialization and teardown attributes.
    /// </summary>
    [TestGroup]
    public class FuncNUnitGroup : TestNode
    {
        static Report ro = new Report(typeof(FuncNUnitGroup).Name);
        [TestGroupSetup]
        public void Setup()
        {
            ro.Info("Setup ran");
        }

        [TestGroupTearDown]
        public void Teardown()
        {
            ro.Info("Teardown ran");
        }

        [TestCase]
        public void Test_A()
        {
            ro.Info("Running Test A...");
        }

        [TestCase]
        public void Test_B()
        {
            // do some fake work  (give me some time to hit the stop
            // button to make sure teardown still runs)
            ro.Info("Running Test B...");
            Thread.Sleep(5000);
        }

        [TestCase]
        public void Test_C()
        {
            ro.Info("Running Test C...");
        }

    }

    /// <summary>
    ///         These tests are used for testing backward compatibility when I make changes
    ///        to the runner.
    /// </summary>
    [TestGroup]
    public class FuncMiscJacobrTests : TestNode
    {
        [TestCase]
        public void P_ConsoleReportLoggingBridge()
        {
            // Make sure console logs redirect to reporting system
            ConsoleX.Write("ConsoleX.Write(): Test");
            ConsoleX.WriteLine("ConsoleX.WriteLine(): Test");

            Console.Out.Write("Console.Out.Write(): Test");
            Console.Out.WriteLine("Console.Out.WriteLine(): Test");

            Console.Error.Write("Console.Out.Write(): Test");
            Console.Error.WriteLine("Console.Out.WriteLine(): Test");
        }

        [TestCase, Ignore]
        public void P_CreatePrivateUsers()
        {
            UacsCommon uacs = new UacsCommon();
            uacs.CreatePrivateUsers("BT", 100, false);
        }

        [TestCase, Ignore]
        public void P_LogViewFickerFreeSpam()
        {
            for (int i = 0; i < 1000; ++i)
            {
                Global.RO.Debug("SPEW----------------------------------------------------{0}", i);
            }
        }

        [TestCase, Ignore]
        public void P_UserFeedbackInfoTools()
        {
            // You can create an anonmous sleeper info object to give the user something
            // to look at while you do 
            new SleepInfo("Doing something important for 15(s)", 1000 * 15);

            // You can also give a more fine grained approach
            ProgressInfo progress = new ProgressInfo("Multiphase progress indication", 3 * 100, 1);

            for (int phase = 0; phase < 3; ++phase)
            {
                progress.SetMessage("Performing phase: " + phase);
                for (int subtask = 0; subtask < 100; ++subtask)
                {
                    progress.Step();
                    Thread.Sleep(100);
                }
            }
        }

        [TestCase, Ignore]
        public void P_ExplicitFeedbackCleanup()
        {
            // Here is a case when you don't know that you are hitting the stop condition on a progress
            // info object and want to make sure it indicates a 'finished' state.
            ProgressInfo progress = new ProgressInfo(GetType().Name, 15, 1);
            for (int i = 0; i < 10; ++i)
            {
                progress.Step();
                Thread.Sleep(100);
            }
            progress.Finish();
        }

        [TestCase, Ignore]
        public void P_BulkCreateUsers()
        {
            BulkUserSet bulkUsers;
            UodbWS.CreateBulkUsers("Bu", 1000, out bulkUsers);
        }
    }

    /// <summary>
    ///        Test group that actually instantiates it's own test cases, this could be driven
    ///        from a configuration file with tabular test data.
    /// </summary>
    [TestGroup]
    public class FuncSelfPopulating : TestNode
    {
        public FuncSelfPopulating()
        {
            for (int i = 0; i < 5; ++i)
            {
                AddChild(new PositiveTest(i));
                AddChild(new NegativeTest(i));
            }
        }

        public class PositiveTest : TestNode
        {
            public PositiveTest(int i)
            {
                Name = "P_Test_" + i;
            }
            public override void Run()
            {
            }
        }
        public class NegativeTest : TestNode
        {
            public NegativeTest(int i)
            {
                Name = "N_Test_" + i;
            }
            public override void Run()
            {
            }
        }

        //now self-populate a compound case also to verify that that works
        [TestGroup]
        [CompoundCase("Instance0", 0)]
        [CompoundCase("Instance1", 1)]
        public class CompPopulatingGroup : TestNode
        {
            public CompPopulatingGroup()
            {
                for (int i = 0; i < 5; ++i)
                {
                    AddChild(new SomeNumberedTest(i), true, false);
                }
            }

            public override void PreRun()
            {
                if (MyValues != null)
                {
                    Global.RO.Info("Group Prerun for " + (int)MyValues[0]);
                }
            }

            public class SomeNumberedTest : TestNode
            {
                public SomeNumberedTest(int i)
                {
                    Name = "SomeTest_" + i;
                }
                public override void Run()
                {
                }
            }
        }
    }

    /// <summary>
    ///        Templated class group, this is based on the 'Template' pattern from
    ///        the patterns book.
    /// </summary>
    [TestGroup]
    public class TemplateTestGroup : TestNode
    {

        static Report ro = new Report(typeof(TemplateTestGroup).Name);

        class TemplateTest : TestNode
        {
            protected uint SettingA, SettingB, SettingC;
            private ArrayList AllowedExceptions;

            public TemplateTest()
            {
                AllowedExceptions = new ArrayList();
            }

            private static bool ExInterfaceFilter(Type typeObj, Object criteriaObj)
            {
                if (typeObj == typeof(Exception))
                    return true;
                else
                    return false;
            }

            protected void AddException(Type exType)
            {
                if (!exType.IsSubclassOf(typeof(Exception)))
                {
                    throw new ArgumentException("Type is not an exception: " + exType.Name);
                }

                AllowedExceptions.Add(exType);
            }

            protected virtual void DoPreInit()
            {
                SettingA = 4;
                SettingB = 8;
                SettingC = 16;
            }

            protected virtual void DoInit()
            {
                ro.Debug("Creating {0} TypeA", SettingA);
                ro.Debug("Setting {0} TypeA.Value", SettingB);
                ro.Debug("Prepopulating {0} SettingC.Value", SettingC);
            }

            protected virtual void DoTest()
            {
                ro.Warn("Test {0} did not override DoTest(), nothing to test.".GetType().Name);
            }

            protected virtual void DoCleanup()
            {
                ro.Debug("Cleaning up cruft");
            }


            public override void Run()
            {
                DoPreInit();
                DoInit();
                bool pass = false;

                try
                {
                    DoTest();
                    pass = true;
                }
                catch (Exception ex)
                {
                    Type exType = ex.GetType();
                    foreach (Type t in AllowedExceptions)
                    {
                        if (t == exType)
                        {
                            ro.Debug("Caught allowed exception: " + ex.GetType().Name + ", Message: " + ex.Message);
                            pass = true;
                        }
                    }

                    if (!pass)
                    {
                        throw ex;
                    }
                }
                finally
                {
                    DoCleanup();
                }
            }
        }

        [TestCase]
        class N_Filtered_Exception : TemplateTest
        {
            protected override void DoPreInit()
            {
                SettingA = 100;
            }
            protected override void DoTest()
            {
                // Add a handled exception
                AddException(typeof(HResultException));
                throw new HResultException(HResult.XONLINE_E_SERVER_ERROR);
            }
        }
        [TestCase]
        class P_NothingSpecial : TemplateTest
        {
            protected override void DoPreInit()
            {
                SettingB = 100;
            }
            protected override void DoTest()
            {
            }
        }
        [TestCase]
        class P_Unfiltered_Exception : TemplateTest
        {
            protected override void DoPreInit()
            {
                SettingB = 100;
                SettingC = 1000;
            }
            protected override void DoTest()
            {
                // uncaught exception
                throw new HResultException(HResult.XONLINE_E_SERVER_ERROR);
            }
        }
    }

    //
    [TestGroup]
    public class FuncThrowingSetup : TestNode
    {
        [TestCase, Description("Prerun throws")]
        class PreRunThrow : TestNode
        {
            public override void PreRun()
            {
                throw new System.Exception("PreRun hath been thrown!");
            }

            public override void Run()
            {
                Global.RO.Error("We were run but we shouldn't have been.  You should never see this.");
            }
        }

        [TestCase, Description("test passes but PostRun throws")]
        class PassAndPostRunThrow : TestNode
        {
            public override void PostRun()
            {
                throw new System.Exception("PostRun hath been thrown!");
            }

            public override void Run()
            {
            }
        }

        [TestCase, Description("test fails and PostRun throws")]
        class FailAndPostRunThrow : TestNode
        {
            public override void PostRun()
            {
                throw new System.Exception("PostRun hath been thrown!");
            }

            public override void Run()
            {
                throw new System.Exception("Test is failing.");
            }
        }

        [TestCase, Description("both pre and post run throw")]
        class PreAndPostThrow : TestNode
        {
            public override void PostRun()
            {
                throw new System.Exception("PostRun hath been thrown!");
            }

            public override void PreRun()
            {
                throw new System.Exception("PreRun hath been thrown!");
            }

            public override void Run()
            {
            }
        }

        [TestGroup, Description("PreRun for a group fails.")]
        public class GroupPreRunThrows: TestNode
        {
            public override void PreRun()
            {
                throw new System.Exception("PreRun for this group has thrown.");
            }

            [TestCase]
            public void ShouldNeverBeRun()
            {
                throw new UnexpectedTestResultException("This should never have been run.");
            }
        }
    }

    //
    [TestGroup]
    public class FuncRetryFailTests : TestNode
    {
        static private int groupCounter = 0;
        static private int onceCounter = 0;
        static private int twiceCounter = 0;
        static private int thriceCounter = 0;
        static private int noRetryCounter = 0;

        [TestGroupSetup]
        public void SetupFunc()
        {
            if (groupCounter == 1)
            {
                return;
            }

            groupCounter = 1;
            throw new System.Exception("group init has thrown!");
        }

        [TestGroupTearDown]
        public void CleanupFunc()
        {
            groupCounter = 0;
            onceCounter = 0;
            twiceCounter = 0;
            thriceCounter = 0;
            noRetryCounter = 0;
        }

        [TestCase, Description("Fails once")]
        class TestFailOnce : TestNode
        {
            public override void Run()
            {
                if (onceCounter == 1)
                {
                    Global.RO.Debug("Time to pass - counter=1");
                }
                else
                {
                    Global.RO.Debug("Time to fail..");
                    ++onceCounter;
                    throw new UnexpectedTestResultException();
                }
            }
        }

        [TestCase, Description("Fails twice")]
        class TestFailTwice : TestNode
        {
            public override void Run()
            {
                if (twiceCounter == 2)
                {
                    Global.RO.Debug("Time to pass - counter=2");
                }
                else
                {
                    Global.RO.Debug("Time to fail..");
                    ++twiceCounter;
                    throw new UnexpectedTestResultException();
                }
            }
        }

        [TestCase, Description("Fails thrice")]
        class TestFailThrice : TestNode
        {
            public override void Run()
            {
                if (thriceCounter == 3)
                {
                    Global.RO.Debug("Time to pass - counter=3 - SHOULD NOT EVER GET HERE (if retrycount is the default of 3)");
                }
                else
                {
                    Global.RO.Debug("Time to fail..");
                    ++thriceCounter;
                    throw new UnexpectedTestResultException();
                }
            }
        }

        [TestCase, DoNotRetry, Description("Fails always.. should never be retried")]
        class Fail_NoRetry : TestNode
        {
            public override void Run()
            {
                if (noRetryCounter >= 1)
                {
                    Global.RO.Warn("This should never happen!");
                }

                ++noRetryCounter;
                throw new UnexpectedTestResultException();
            }
        }
    }

    [TestGroup]
    public class FuncDependency : TestNode
    {
        [TestCase, Description("passes")]
        class PassingTest : TestNode
        {
            public override void Run()
            {
            }
        }

        [TestCase, Description("fails")]
        class FailingTest : TestNode
        {
            public override void Run()
            {
                throw new UnexpectedTestResultException("This fails.");
            }
        }

        [TestCase, Description("doesn't run")]
        class NotExecutedTest : TestNode
        {
            public override void Run()
            {
                throw new DidNotExecuteException("This could not run.");
            }
        }

        [TestCase, Description("depends on a test that passes to run first")]
        [RunDependency("PassingTest")]
        class Run_DependsOnPassingSibling : TestNode
        {
            public override void Run()
            {
            }
        }

        [TestCase, Description("depends on a test that passes to run first")]
        [RunDependency("BasicTest.FuncDVTGroup.SimpleTest")]
        class Run_DependsOnPassingDistantLeaf : TestNode
        {
            public override void Run()
            {
            }
        }

        [TestCase, Description("depends on a test that fails to run first")]
        [RunDependency("FailingTest")]
        class Run_DependsOnFailing : TestNode
        {
            public override void Run()
            {
                Global.RO.Error("THIS SHOULD NEVER HAVE BEEN RUN");
            }
        }

        [TestCase, Description("depends on a test that won't run to run first")]
        [RunDependency("NotExecutedTest")]
        class Run_DependsOnNotExecuted : TestNode
        {
            public override void Run()
            {
                Global.RO.Error("THIS SHOULD NEVER HAVE BEEN RUN");
            }
        }

        [TestCase, Description("depends on a test that won't run to run first")]
        [RunDependency("RandomNameThatWontExist")]
        class Run_DependsOnNonExistant : TestNode
        {
            public override void Run()
            {
                Global.RO.Error("THIS SHOULD NEVER HAVE BEEN RUN");
            }
        }

        [TestCase, Description("depends on a test that passes to run first")]
        [RunDependency("Run_DependsOnPassingSibling")]
        class Run_ChainedPassing : TestNode
        {
            public override void Run()
            {
            }
        }
    }

    //Compound TestNode tests
    [TestGroup]
    public class CompoundTest : TestNode
    {
        [TestCase, Description("This should show up as one test")]
        class CompoundNone : TestNode
        {
            public override void Run()
            {
                Global.RO.Debug("Running instance.");
            }
        }

        [TestCase, Description("This should show up as one test"),
        CompoundCase("Instance1",1)]
        class CompoundOne : TestNode
        {
            public override void Run()
            {
                Global.RO.Debug("Running instance " + (int)MyValues[0]);
            }
        }

        [TestCase, Description("This should show up as two different tests"),
        CompoundCase("Instance1",1),
        CompoundCase("Instance2",2)]
        class CompoundTwo : TestNode
        {
            public override void Run()
            {
                Global.RO.Debug("Running instance " + (int)MyValues[0]);
            }
        }

        [TestCase, Description("This should show up as two tests")]
        class CompoundOverride_Simple : TestNode
        {
            protected override void EditInstances(ref System.Collections.Generic.List<CompoundCaseAttribute> instances)
            {
                instances.Add(new CompoundCaseAttribute("Instance1", 1));
                instances.Add(new CompoundCaseAttribute("Instance2", 2));
            }

            public override void Run()
            {
                Global.RO.Debug("Running instance " + (int)MyValues[0]);
            }
        }

        [TestCase, Description("These tests have 2 instance parameters each")]
        [CompoundCase("Instance1",1,"GreatTest")]
        [CompoundCase("Instance2",2,"RandomTest")]
        class MultiArg : TestNode
        {
            public override void Run()
            {
                Global.RO.Debug("Running instance " + (int)MyValues[0] + "+" + (string)MyValues[1]);
            }
        }

        [TestCase(7), Description("These tests have bug IDs 7 and 101")]
        [CompoundCase("Default",1,"GreatTest")]
        [CompoundCase("Override101",2,"RandomTest",BugID=101)]
        class BugOverride : TestNode
        {
            public override void Run()
            {
            }
        }

        [TestCase, Description("This should show up as 6 test cases (3x2 matrix)")]
        class CompoundOverride_MatrixExample : TestNode
        {
            protected override void EditInstances(ref System.Collections.Generic.List<CompoundCaseAttribute> instances)
            {
                for (uint y = 0; y < 3; ++y)
                {
                    for (uint x = 0; x < 2; ++x)
                    {
                        instances.Add(new CompoundCaseAttribute("Instance-" + y + "-" + x, y, x));
                    }
                }
            }

            public override void Run()
            {
                Global.RO.Debug("Running instance " + MyValues[0] + "-" + MyValues[1]);
            }
        }

        [TestCase, Description("This should show up as two tests, one is renamed")]
        [CompoundCase("InstanceDupe",1)]
        [CompoundCase("InstanceDupe",2)]
        class CompoundDuplicateInstance : TestNode
        {
            public override void Run()
            {
                Global.RO.Debug("Running instance " + (int)MyValues[0]);
            }
        }

        [TestCase, Description("This should have 3 children, each with their own value.")]
        [CompoundCase("Case A", 'A')]
        [CompoundCase("Case B", 'B')]
        [CompoundCase("Case C", 'C')]
        public void FuncCompoundCase(TestNode thisNode)
        {
            char val = (char)thisNode.MyValues[0];
            Global.RO.Debug("This is case " + val);
        }

        [TestCase, Description("Null values passed in.")]
        [CompoundCase("None")]
        [CompoundCase("OneNull", null)]
        [CompoundCase("TwoNull", null, null)]
        [CompoundCase("StringNull", (string)null)]
        class CompoundNull : TestNode
        {
            public override void Run()
            {
                if (MyValues == null)
                {
                    Global.RO.Debug("MyValues is null");
                }
                else
                {
                    Global.RO.Debug("MyValues.Length : " + MyValues.Length);
                }
            }
        }
    }

    [TestGroup]
    [CompoundCase("GroupInstance100", 100)]
    [CompoundCase("GroupInstance101", 101)]
    public class CompoundTest_GroupAttribute : TestNode
    {
        [TestCase, Description("This should show up as four different tests"),
        CompoundCase("Instance1",1),
        CompoundCase("Instance2",2)]
        class CompoundTwo : TestNode
        {
            public override void Run()
            {
                Global.RO.Debug("Running instance " + (int)MyValues[0]);
            }
        }

        [TestCase, Description("This should show up as two tests")]
        class CompoundOverride : TestNode
        {
            protected override void EditInstances(ref System.Collections.Generic.List<CompoundCaseAttribute> instances)
            {
                //remove one, add one
                instances.Add(new CompoundCaseAttribute("Instance1", 1));
                instances.Add(new CompoundCaseAttribute("Instance2", 2));
            }

            public override void Run()
            {
                Global.RO.Debug("Running instance " + (int)MyValues[0]);
            }
        }

        [TestCase, Description("This is should just be a normal single case")]
        public void FuncCase()
        {
            Global.RO.Debug("There should only be one instance of this from this case.");
        }

        [TestCase, Description("This should show up as one test")]
        class NonCompound : TestNode
        {
            public override void Run()
            {
                if (MyValues[0] == null)
                {
                }
                else
                {
                    throw new UnexpectedTestResultException();
                }
            }
        }
    }

    //
    [TestGroup]
    [AtomicBranch]
    public class AtomicGroupTest : TestNode
    {
        [TestCase]
        public class SimpleTest1 : TestNode
        {
            public override void Run()
            {
            }
        }

        [TestCase]
        public class SimpleTest2 : TestNode
        {
            public override void Run()
            {
            }
        }

        [TestGroup]
        public class SubGroup : TestNode
        {
            [TestCase]
            public class SimpleTest1 : TestNode
            {
                public override void Run()
                {
                }
            }

            [TestCase]
            public class SimpleTest2 : TestNode
            {
                public override void Run()
                {
                }
            }
        }
    }

    //
    [TestGroup]
    public class ContextDataTest : TestNode
    {
        [TestCase]
        public class PutInData : TestNode
        {
            public override void Run()
            {
                SetContextData("kitty", "lion");
            }
        }

        [TestCase]
        public class CheckForData : TestNode
        {
            public override void Run()
            {
                string cdata = (string)GetContextData("kitty");

                if (cdata == "lion")
                {
                }
                else
                {
                    throw new UnexpectedTestResultException("cdata was unexpected value: "+cdata);
                }
            }
        }

        [TestCase]
        public class CheckForResettingThreadTrackingData : TestNode
        {
            public override void PreRun ()
            {
                Global.RO.Info("PreRun : " + ServerTestFramework.LiveService.FakeSG.CSGInfo.GetTestCaseFlowtoken());
            }

            public override void Run ()
            {
                Global.RO.Info("Run    : " + ServerTestFramework.LiveService.FakeSG.CSGInfo.GetTestCaseFlowtoken());
            }

            public override void PostRun ()
            {
                Global.RO.Info("PostRun: " + ServerTestFramework.LiveService.FakeSG.CSGInfo.GetTestCaseFlowtoken());
            }
        }
    }


    [TestCase]
    public class TestWithThrowingConstructor : TestNode
    {
        public TestWithThrowingConstructor()
        {
            throw new System.Exception("This constructor throws on purpose, which should not break anything.");
        }

        public override void Run()
        {
        }
    };

    [TestGroup]
    public class GroupWithThrowingConstructor : TestNode
    {
        public GroupWithThrowingConstructor()
        {
            throw new System.Exception("This constructor throws on purpose, which should not break anything.");
        }

        [TestCase]
        public void TestFunctionInBadGroup()
        {
        }

        [TestCase]
        public class TestClassInBadGroup : TestNode
        {
            public override void Run()
            {
            }
        };
    };

    [TestCase, Description("Useful for watching how the gui looks in each state.")]
    public class SlowSteps : TestNode
    {
        public override void PreRun()
        {
            Global.RO.Debug("PreRun start");
            System.Threading.Thread.Sleep(1000);
            Global.RO.Debug("PreRun finish");
        }

        public override void PostRun()
        {
            Global.RO.Debug("PostRun start");
            System.Threading.Thread.Sleep(1000);
            Global.RO.Debug("PostRun finish");
        }

        public override void Run()
        {
            Global.RO.Debug("Run start");
            System.Threading.Thread.Sleep(1000);
            Global.RO.Debug("Run finish");
        }
    }

    [TestCase, Ignore]
    public class UnhandledExceptionOnThreadPoolThread : TestNode
    {
        public override void Run()
        {
            ThreadPool.QueueUserWorkItem(Throws);
        }

        public void Throws(object state)
        {
            throw new Exception("This is an exception that isn't handled!!!");
        }
    }

    [TestGroup, TestTag("P1")]
    public partial class TestTagGroup : TestNode
    {
        [TestCase, TestTag("P1")]
        public partial class TestTagTest : TestNode
        {
            public override void Run()
            {
                Console.WriteLine("The Run method of partial class TestTagTest");
                Print();
            }
        }

        [TestTag("P2")]
        public partial class TestTagTest : TestNode
        {
            private void Print()
            {
                Console.WriteLine("The print method of partial class TestTagTest.");
            }
        }

        [TestCase, TestTag("P1")]
        public void Test_A()
        {
            Console.WriteLine("Test_A of TestTagGroup");
        }

        [TestCase, TestTag("P2")]
        public void Test_B()
        {
            Console.WriteLine("Test_B of TestTagGroup");
        }
    }

    [TestTag("P3")]
    public partial class TestTagGroup : TestNode
    {
        [TestCase, TestTag("P1")]
        public void Test_C()
        {
            Console.WriteLine("Test_C of TestTagGroup");
        }

        [TestCase, TestTag("P2")]
        public void Test_D()
        {
            Console.WriteLine("Test_D of TestTagGroup");
        }
    }

    //tag tests
    [TestGroup]
    [TestTag("OutterGroupTag")]
    public class TagOutterGroup : TestNode
    {
        [TestCase]
        public void CaseUntagged() { }

        [TestCase, TestTag("SimpleTag")]
        public void SimplyTagged() { }

        [TestCase, TestTag("TagOne"), TestTag("TagTwo")]
        public void TwoDifferentTags() { }

        [TestCase, TestTag("ValTagOne=x")]
        public void OneValueTag() { }

        [TestCase, TestTag("ValTagOne=x,y")]
        public void OneValueTagWithTwoValues() { }

        [TestCase, TestTag("ValTagOne=x"), TestTag("ValTagOne=y"), TestTag("ValTagTwo=z")]
        public void MultipleValueTags() { }

        [TestGroup, TestTag("InnerGroupTag0")]
        public class InnerGroup0 : TestNode
        {
            [TestCase]
            public void InnerGroupTest1() { }
        }
    }

    [TestGroup]
    public class FrequencyTest
    {
        [TestCase, TestFrequency("BVT")]
        public void BvtTag()
        {
        }

        [TestCase, TestFrequency("Daily")]
        public void DailyTag()
        {
        }

        [TestCase, TestFrequency("Regression")]
        public void RegressionTag()
        {
        }

        [TestCase, TestFrequency("ThisInNotValid")]
        public void NotValid()
        {
        }
    };

    [TestGroup]
    public class RequirementTest
    {
        [TestCase, EnvRequirement("Value1")]
        public void Value1()
        {
        }

        [TestCase, EnvRequirement("Value2")]
        public void Value2()
        {
        }

        [TestCase, EnvRequirement("Value1,Value2")]
        public void ValueBoth()
        {
        }
    };

    [TestGroup, TestTag("Prerequisite", "PreValue1"), TestTag("Prerequisite", "PreValue2")]
    public class PrerequisitesTest1
    {
        [TestCase, TestTag("Prerequisite", "PreValue1")]
        public void Value1()
        {
        }

        [TestCase, TestTag("Prerequisite", "PreValue2")]
        public void Value2()
        {
        }

        [TestCase, TestTag("Prerequisite", "Billing")]
        public void Value3()
        {
        }
    };

    [TestGroup, AsyncGroup(1)]
    public class PrerequisitesTest2
    {
        [TestCase, TestTag("Prerequisite", "PreValue1")]
        public void Value1()
        {
        }

        [TestCase, TestTag("Prerequisite", "PreValue2"), TestTag("Prerequisite", "PreValue1")]
        public void Value2()
        {
        }

        [TestCase, TestTag("Prerequisite", "PreValue2"), TestTag("Prerequisite", "PreValue3")]
        public void Value3()
        {
        }
    };

    [TestGroup]
    public class TimeOutTest
    {
        [TestCase(Timeout = 1000), Description("This should fail.")]
        class InfiniteLoop : TestNode
        {
            public override void Run()
            {
                while (true)
                {
                    Thread.Sleep(10);
                }
            }

            public override void PostRun()
            {
                Global.RO.Info("Do the post run");
            }

            public override void PreRun()
            {
                Global.RO.Info("Do the pre run");
            }
        }

        [TestCase(Timeout = 0), TestCasePriority(1)]
        public void VerifyZeroTimesOutAttribute()
        {
            
        }

        [TestCase(Timeout = 100)]
        public void TestThrowException()
        {
            throw new UnexpectedTestResultException("Show test fail in results!");
        }

        [TestCase, Description("This should show up as two tests, timeout 100 and timeout 200")]
        [CompoundCase("Test1", 1, Timeout=100)]
        [CompoundCase("Test2", 2, Timeout=200)]
        class CompoundTimeOutTest1 : TestBase
        {
            protected override void Execute()
            {                
                ResultCode = TEST_RESULTS.PASSED;
            }
        }

        [TestCase, TestCasePriority(1), Description("This should show up as two tests with timeout 10mins")]
        [CompoundCase("Test1", 1)]
        [CompoundCase("Test2", 2)]
        class CompoundTimeOutTest2 : TestBase
        {
            protected override void Execute()
            {
                ResultCode = TEST_RESULTS.PASSED;
            }
        }

        [TestCase(Timeout = 100), Description("This should fail.")]
        public void TestNonTerminatingThread()
        {
            Thread t = ThreadMaker.CreateThread(InifiniteLoop);
            t.IsBackground = true;
            t.Start();
            t.Join();            
        }

        private static void InifiniteLoop()
        {
            while (true)
            {
                Thread.Sleep(10);
            }
        }
                
    };

    [TestGroup, AsyncGroup(1, 0)]
    public class TimeOutAsyncTest
    {
        [TestCase(Timeout = 100), TestCasePriority(1), Description("This should fail.")]
        public void Test1()
        {
            while (true)
            {
                Thread.Sleep(10);
            }
        }

        [TestCase, TestCasePriority(1), Description("This should pass with timeout 10mins.")]
        public void Test2()
        {
        }

        [TestCase, TestCasePriority(2), Description("This should pass with timeout 15mins.")]
        public void Test3()
        {
        }

        [TestCase, TestCasePriority(3), Description("This should pass with timeout 30mins.")]
        public void Test4()
        {
        }

        [TestCase(Timeout = 100), Description("This should fail.")]
        public void Test5()
        {
            while (true)
            {
                Thread.Sleep(10);
            }
        }

        [TestCase(Timeout = 100), AsyncGroup(0), Description("This should pass with timeout 100.")]
        public void Test6()
        {
        }
    };

}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\StfTests\BatmanTest\makefile.inc ===
!include $(INETROOT)\build\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\StfTests\BatmanTest\Enum.cs ===
// Enumerations used for setting console window colors.
using System;

namespace Microsoft.GotDotNet
{
	/// <summary>
	/// Color definitions for the console foreground.
	/// </summary>
	public enum ConsoleForeground
	{	
		Black      = 0x00,
		Navy       = 0x01,
		DarkGreen  = 0x02,
		Aquamarine = 0x03,
		Maroon     = 0x04,
		Purple     = 0x05,
		Olive      = 0x06,
		LightGray  = 0x07,
		DarkGray   = 0x08,
		Blue       = 0x09,
		Green      = 0x0A,
		Cyan       = 0x0B,
		Red        = 0x0C,
		Magenta    = 0x0D,
		Yellow     = 0x0E,
		White      = 0x0F
	}


	/// <summary>
	/// Color definitions for the console background.
	/// </summary>
	public enum ConsoleBackground
	{	
		Black      = 0x00,
		Navy       = 0x10,
		DarkGreen  = 0x20,
		Aquamarine = 0x30,
		Maroon     = 0x40,
		Purple     = 0x50,
		Olive      = 0x60,
		LightGray  = 0x70,
		DarkGray   = 0x80,
		Blue       = 0x90,
		Green      = 0xA0,
		Cyan       = 0xB0,
		Red        = 0xC0,
		Magenta    = 0xD0,
		Yellow     = 0xE0,
		White      = 0xF0
	}


	/// <summary>
	/// Border styles used for drawing rectangles on the console output window.
	/// </summary>
	public enum BorderStyle
	{
		None,
		Text,
		LineSingle,
		LineDouble
	}


	[Flags]
	public enum InputModeFlags
	{
		ENABLE_PROCESSED_INPUT = 0x01,
		ENABLE_LINE_INPUT      = 0x02,
		ENABLE_ECHO_INPUT      = 0x04,
		ENABLE_WINDOW_INPUT    = 0x08,
		ENABLE_MOUSE_INPUT     = 0x10
	}

	[Flags]
	public enum OutputModeFlags
	{
		ENABLE_PROCESSED_OUTPUT   = 0x01,
		ENABLE_WRAP_AT_EOL_OUTPUT = 0x02
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\StfTests\BatmanTest\ConsoleEx.cs ===
// ConsoleEx V1.02 - Tim Sneath <tims@microsoft.com>

// ReadHiddenLine: Ben Zotto (benzotto@xbox.com)

using System;
using System.Runtime.InteropServices;
using System.Text;

namespace Microsoft.GotDotNet
{
	/// <summary>
	/// This class provides supplemental functionality to that available in the System.Console class. It 
	/// allows a developer to control the cursor location, size and visibility, to manipulate the color
	/// used for writing text on the screen, to read characters individually from the input buffer, to 
	/// manipulate the console window title, to clear the screen and to draw rectangles on the screen. It 
	/// does not replace traditional functions supplied in the System.Console class such as WriteLine() 
	/// and ReadLine(), but is intended to be use in conjunction with calls to that class.
	/// </summary>
	/// <remarks>
	/// This class is largely built using information from the Platform SDK. Documentation on the 
	/// Console APIs within kernel32 can be found at the following location:
	///       http://msdn.microsoft.com/library/en-us/dllproc/base/character_mode_applications.asp
	///
	/// Several of the functions within this class are reworked and expanded versions of those
	/// found in KnowledgeBase articles Q319883 and Q319257.
	/// </remarks>
	public class ConsoleEx
	{	

		#region API and Structure Declarations

		// Standard structures used for interop with kernel32
		[StructLayout(LayoutKind.Sequential)]
			struct COORD
		{
			public short x;
			public short y;
		}

		[StructLayout(LayoutKind.Sequential)]
			struct SMALL_RECT
		{
			public short Left;
			public short Top;
			public short Right;
			public short Bottom;
		}
		
		[StructLayout(LayoutKind.Sequential)]
			struct CONSOLE_SCREEN_BUFFER_INFO
		{
			public COORD dwSize;
			public COORD dwCursorPosition;
			public int wAttributes;
			public SMALL_RECT srWindow;
			public COORD dwMaximumWindowSize;
		}

		[StructLayout(LayoutKind.Sequential)]
			struct CONSOLE_CURSOR_INFO 
		{
			public int dwSize;  
			public bool bVisible;
		} 


		// External function declarations
		[DllImport("kernel32.dll", EntryPoint="GetStdHandle", SetLastError=true,
			 CharSet=CharSet.Auto, CallingConvention=CallingConvention.StdCall)]
		private static extern int GetStdHandle(int nStdHandle);

		[DllImport("kernel32.dll", EntryPoint="GetConsoleScreenBufferInfo", SetLastError=true, 
			 CharSet=CharSet.Auto, CallingConvention=CallingConvention.StdCall)]
		private static extern int GetConsoleScreenBufferInfo(int hConsoleOutput,
			ref CONSOLE_SCREEN_BUFFER_INFO lpConsoleScreenBufferInfo);

		[DllImport("kernel32.dll", EntryPoint="SetConsoleTextAttribute", SetLastError=true, 
			 CharSet=CharSet.Auto, CallingConvention=CallingConvention.StdCall)]
		private static extern int SetConsoleTextAttribute(int hConsoleOutput,
			int wAttributes);

		[DllImport("kernel32.dll", EntryPoint="FillConsoleOutputCharacter", SetLastError=true,
			 CharSet=CharSet.Auto, CallingConvention=CallingConvention.StdCall)]
		private static extern int FillConsoleOutputCharacter(int hConsoleOutput, 
			byte cCharacter, int nLength, COORD dwWriteCoord, ref int lpNumberOfCharsWritten);

		[DllImport("kernel32.dll", EntryPoint="FillConsoleOutputAttribute", SetLastError=true,
			 CharSet=CharSet.Auto, CallingConvention=CallingConvention.StdCall)]
		private static extern int FillConsoleOutputAttribute(int hConsoleOutput,
			int wAttribute, int nLength, COORD dwWriteCoord, ref int lpNumberOfAttrsWritten);

		[DllImport("kernel32.dll", EntryPoint="SetConsoleCursorPosition", SetLastError=true, 
			 CharSet=CharSet.Auto, CallingConvention=CallingConvention.StdCall)]
		private static extern int SetConsoleCursorPosition(int hConsoleOutput, 
			COORD dwCursorPosition);

		[DllImport("kernel32.dll", EntryPoint="SetConsoleTitle", SetLastError=true,
			 CharSet=CharSet.Auto, CallingConvention=CallingConvention.StdCall)]
		private static extern bool SetConsoleTitle(string lpConsoleTitle);

		[DllImport("kernel32.dll", EntryPoint="GetConsoleTitle", SetLastError=true,
			 CharSet=CharSet.Auto, CallingConvention=CallingConvention.StdCall)]
		private static extern int GetConsoleTitle(StringBuilder lpConsoleTitle, 
			int nSize);

		[DllImport("kernel32.dll", EntryPoint="SetConsoleCursorInfo", SetLastError=true,
			 CharSet=CharSet.Auto, CallingConvention=CallingConvention.StdCall)]
		private static extern int SetConsoleCursorInfo(int hConsoleOutput, 
			ref CONSOLE_CURSOR_INFO lpConsoleCursorInfo);

		[DllImport("kernel32.dll", EntryPoint="GetConsoleCursorInfo", SetLastError=true,
			 CharSet=CharSet.Auto, CallingConvention=CallingConvention.StdCall)]
		private static extern int GetConsoleCursorInfo(int hConsoleOutput, 
			ref CONSOLE_CURSOR_INFO lpConsoleCursorInfo);
		
		[DllImport("kernel32.dll", EntryPoint="ReadConsole", SetLastError=true,
			 CharSet=CharSet.Auto, CallingConvention=CallingConvention.StdCall)]
		private static extern bool ReadConsole(int hConsoleInput,
			StringBuilder buf, int nNumberOfCharsToRead, ref int lpNumberOfCharsRead, int lpReserved);

		[DllImport("kernel32.dll", EntryPoint="SetConsoleMode", SetLastError=true,
			 CharSet=CharSet.Auto, CallingConvention=CallingConvention.StdCall)]
		private static extern bool SetConsoleMode(int hConsoleHandle,
			int dwMode);

		[DllImport("kernel32.dll", EntryPoint="GetConsoleMode", SetLastError=true,
			 CharSet=CharSet.Auto, CallingConvention=CallingConvention.StdCall)]
		private static extern bool GetConsoleMode(int hConsoleHandle,
			ref int dwMode);

		#endregion


		// Const variables
		private const int  INVALID_HANDLE_VALUE    = -1;
		private const int  STD_INPUT_HANDLE        = -10;
		private const int  STD_OUTPUT_HANDLE       = -11;
		private const byte EMPTY                   = 32;
		private const int  TITLE_LENGTH            = 1024;

		// Internal variables
		private static int hConsoleOutput;	// handle to output buffer
		private static int hConsoleInput;	// handle to input buffer
		private static COORD ConsoleOutputLocation;
		private static CONSOLE_SCREEN_BUFFER_INFO ConsoleInfo;
		private static int OriginalConsolePen;
		private static int CurrentConsolePen;

		
		// Constructors
		static ConsoleEx()
		{
			// Grab input and output buffer handles
			hConsoleOutput = GetStdHandle(STD_OUTPUT_HANDLE);
			hConsoleInput = GetStdHandle(STD_INPUT_HANDLE);
			if (hConsoleOutput == INVALID_HANDLE_VALUE || hConsoleInput == INVALID_HANDLE_VALUE)
				throw new ApplicationException("Unable to obtain buffer handle during initialization.");

			// Get information about the console window characteristics.
			ConsoleInfo = new CONSOLE_SCREEN_BUFFER_INFO();
			ConsoleOutputLocation = new COORD();
			GetConsoleScreenBufferInfo(hConsoleOutput, ref ConsoleInfo);
			OriginalConsolePen = ConsoleInfo.wAttributes;

			// Disable wrapping at the end of a line (ENABLE_WRAP_AT_EOL_INPUT); this enables rectangles 
			// to be drawn that fill the screen without the window scrolling.
			SetConsoleMode(hConsoleOutput, 
				(int) OutputModeFlags.ENABLE_PROCESSED_OUTPUT);
		}

		private ConsoleEx() : base()
		{
			throw new NotSupportedException("This object may not be instantiated. Use static methods instead.");
		}


		/// <summary>
		/// Sets or gets the console window title.
		/// </summary>
		public static string Title 
		{
			get
			{
				StringBuilder title = new StringBuilder(TITLE_LENGTH);
				int ret = GetConsoleTitle(title, TITLE_LENGTH);
				return title.ToString(0, ret);
			}
			set 
			{	
				if (value.Length < TITLE_LENGTH)
					SetConsoleTitle(value);
				else
					throw new ArgumentOutOfRangeException(
						"Title", 
						value, 
						"Console window title must be no more than " + TITLE_LENGTH +  " characters.");
			}
		}


		/// <summary>
		/// Gets or sets the visibility of the cursor.
		/// </summary>
		public static bool CursorVisible
		{
			get
			{
				CONSOLE_CURSOR_INFO ConsoleCursorInfo = new CONSOLE_CURSOR_INFO();
				GetConsoleCursorInfo(hConsoleOutput, ref ConsoleCursorInfo);
				return ConsoleCursorInfo.bVisible;
			}
			set
			{
				// Obtain current cursor information, since the CONSOLE_CURSOR_INFO struct
				// also contains information on the shape of the cursor.
				CONSOLE_CURSOR_INFO ConsoleCursorInfo = new CONSOLE_CURSOR_INFO();
				GetConsoleCursorInfo(hConsoleOutput, ref ConsoleCursorInfo);

				ConsoleCursorInfo.bVisible = value;
				SetConsoleCursorInfo(hConsoleOutput, ref ConsoleCursorInfo);
			}
		}


		/// <summary>
		/// Gets or sets the height of the cursor, as a percentage of the overall character cell.
		/// The value must be a number between 1 and 100, otherwise an ArgumentOutOfRangeException
		/// will be thrown.
		/// </summary>
		public static int CursorHeight
		{
			get
			{
				CONSOLE_CURSOR_INFO ConsoleCursorInfo = new CONSOLE_CURSOR_INFO();
				GetConsoleCursorInfo(hConsoleOutput, ref ConsoleCursorInfo);
				return ConsoleCursorInfo.dwSize;
			}
			set
			{
				if (value >= 1 && value <= 100)
				{
					// Obtain current cursor information, since the CONSOLE_CURSOR_INFO struct
					// also contains information on the visibility of the cursor.
					CONSOLE_CURSOR_INFO ConsoleCursorInfo = new CONSOLE_CURSOR_INFO();
					GetConsoleCursorInfo(hConsoleOutput, ref ConsoleCursorInfo);

					ConsoleCursorInfo.dwSize = value;
					SetConsoleCursorInfo(hConsoleOutput, ref ConsoleCursorInfo);
				}
				else
					throw new ArgumentOutOfRangeException(
						"CursorHeight", 
						value, 
						"Cursor height must be a percentage of the character cell between 1 and 100.");
			}
		}


		/// <summary>
		/// Sets the console pen color to that specified.
		/// </summary>
		/// <param name="foreground">A foreground color specified from the 
		/// ConsoleForeground enumeration</param>
		/// <param name="background">A background color specified from the 
		/// ConsoleBackground enumeration</param>
		public static void TextColor(ConsoleForeground foreground, ConsoleBackground background)
		{
			CurrentConsolePen = (int)foreground + (int)background;
			SetConsoleTextAttribute(hConsoleOutput, CurrentConsolePen);
		}
	

		/// <summary>
		/// Resets the console pen color to the original default at the time 
		/// the class was originally initialised.
		/// </summary>
		public static void ResetColor()
		{
			SetConsoleTextAttribute(hConsoleOutput, OriginalConsolePen);
		}
	

		/// <summary>
		/// Clears screen.
		/// </summary>
		public static void Clear()
		{
			int hWrittenChars = 0;
			CONSOLE_SCREEN_BUFFER_INFO strConsoleInfo = new CONSOLE_SCREEN_BUFFER_INFO();			
			COORD Home;		
			Home.x = Home.y = 0;
			
			if (GetConsoleScreenBufferInfo(hConsoleOutput, ref strConsoleInfo) == 0)
			{
				// If the device does not support GetConsoleScreenBufferInfo, then try just
				// writing ^L (ASCII control code for Form Feed) to the screen. This may 
				// work for some scenarios such as using telnet to access a remote console.
				Console.Write('\x0c');	// ^L
				return;
			}
			
			FillConsoleOutputCharacter(hConsoleOutput, EMPTY, 
				strConsoleInfo.dwSize.x * strConsoleInfo.dwSize.y, Home, ref hWrittenChars);
			FillConsoleOutputAttribute(hConsoleOutput, CurrentConsolePen, 
				strConsoleInfo.dwSize.x * strConsoleInfo.dwSize.y, Home, ref hWrittenChars);
			
			SetConsoleCursorPosition(hConsoleOutput, Home);
		}


		/// <summary>
		/// Moves the console cursor to the specified location on the screen.
		/// </summary>
		/// <param name="x">X co-ordinate for desired location (typically 0 to 79)</param>
		/// <param name="y">Y co-ordinate for desired location (typically 0 to 24)</param>
		public static void Move(int x, int y)
		{
			// Check that parameters specified are sane
			CONSOLE_SCREEN_BUFFER_INFO strConsoleInfo = new CONSOLE_SCREEN_BUFFER_INFO();
			GetConsoleScreenBufferInfo(hConsoleOutput, ref strConsoleInfo);

			if (x >= strConsoleInfo.dwSize.x ||  x < 0)
				throw new ArgumentOutOfRangeException("x", x, 
					"The co-ordinates specified must be within the dimensions of the window.");

			if (y >= strConsoleInfo.dwSize.y || y < 0)
				throw new ArgumentOutOfRangeException("y", y, 
					"The co-ordinates specified must be within the dimensions of the window.");

			COORD Location;
			Location.x = (short)x;
			Location.y = (short)y;

			SetConsoleCursorPosition(hConsoleOutput, Location);
		}


		/// <summary>
		/// Writes the specified text at the given location.
		/// </summary>
		/// <remarks>
		/// This is a wrapper function that provides a shorthand for moving to a location and 
		/// writing there. The cursor will be left in the position immediately succeeding the 
		/// rightmost character of the text written to the screen.
		/// </remarks>
		/// <param name="x">X co-ordinate for leftmost character of text</param>
		/// <param name="y">Y co-ordinate for location of text</param>
		/// <param name="text">String to be written to the screen</param>
		public static void WriteAt(int x, int y, string text)
		{
			// No need to validate x and y co-ordinates as they will be tested by Move()
			Move(x, y);

			Console.Write(text);
		}


		/// <summary>
		/// Draws a rectangle on the console window using either 7-bit ASCII characters or
		/// line drawing characters, depending on the style specified. If the dimensions of 
		/// the rectangle exceed the boundaries of the screen, an ArgumentOutOfRangeException
		/// will be thrown.
		/// </summary>
		/// <remarks>
		/// Note that the sides of the rectangle themselves are one character wide,
		/// so, for example, a width and height of 2 will result in a 3-by-3 character rectangle.
		/// This matches the behavior of the equivalent Windows Forms DrawRectangle() method.
		/// </remarks>
		/// <param name="style">A border style specified from the BorderStyle enumeration</param>
		/// <param name="x">X co-ordinate of upper left corner of rectangle</param>
		/// <param name="y">Y co-ordinate of upper left corner of rectangle</param>
		/// <param name="cx">Width of the rectangle</param>
		/// <param name="cy">Height of the rectangle</param>
		public static void DrawRectangle(BorderStyle style, int x, int y, int cx, int cy, bool fill)
		{
			if (style != BorderStyle.None)
			{
				// Set rectangle frame appropriately for the style chosen. Unicode 
				// characters represent horizontal and vertical lines, then NW, NE,
				// SW and SE corners of the rectangle in that order.
				string frame;
				switch(style)
				{
					case BorderStyle.LineSingle:
						frame = "\u2500\u2502\u250c\u2510\u2514\u2518";
						break;
					case BorderStyle.LineDouble:
						frame = "\u2550\u2551\u2554\u2557\u255A\u255D";
						break;
					default:
						frame = @"-|/\\/";
						break;
				}

				// Create top line of box
				StringBuilder line = new StringBuilder(cx+1);
				line.Append(frame[2]);
				for (int i=1; i < cx; i++) line.Append(frame[0]);
				line.Append(frame[3]);
				Move(x, y);
				Console.Write(line);

				// Create sides of box
				for (int i=1; i < cy; i++)
				{
					Move(x, y+i);
					Console.Write(frame[1]);
					Move(x+cx, y+i);
					Console.Write(frame[1]);
				}

				// Create bottom line of box
				line[0] = frame[4];
				line[cx] = frame[5];
				Move(x, y+cy);
				Console.Write(line);
			}
		
			// Fill rectangle with current console pen
			if (fill)
			{
				int hWrittenChars = 0;
				COORD c = new COORD();
				c.x = (short)x;
			
				for (int i=0; i<=cy; i++)
				{
					c.y = (short)(y + i);
					FillConsoleOutputAttribute(hConsoleOutput, CurrentConsolePen, 
						cx + 1, c, ref hWrittenChars);
				}
			}
		}

		
		/// <summary>
		/// Read a single character from the input buffer. Unlike Console.Read(), which 
		/// only reads from the buffer when the read operation has terminated (e.g. by
		/// pressing Enter), this method reads as soon as the character has been entered.
		/// </summary>
		/// <returns>The character read by the system</returns>
		public static char ReadChar()
		{
			// Temporarily disable character echo (ENABLE_ECHO_INPUT) and line input
			// (ENABLE_LINE_INPUT) during this operation
			SetConsoleMode(hConsoleInput, 
				(int) (InputModeFlags.ENABLE_PROCESSED_INPUT | 
				InputModeFlags.ENABLE_WINDOW_INPUT | 
				InputModeFlags.ENABLE_MOUSE_INPUT));

			int lpNumberOfCharsRead = 0;
			StringBuilder buf = new StringBuilder(1);

			bool success = ReadConsole(hConsoleInput, buf, 1, ref lpNumberOfCharsRead, 0);
			
			// Reenable character echo and line input
			SetConsoleMode(hConsoleInput, 
				(int) (InputModeFlags.ENABLE_PROCESSED_INPUT | 
				InputModeFlags.ENABLE_ECHO_INPUT |
				InputModeFlags.ENABLE_LINE_INPUT |
				InputModeFlags.ENABLE_WINDOW_INPUT | 
				InputModeFlags.ENABLE_MOUSE_INPUT));
			
			if (success)
				return Convert.ToChar(buf[0]);
			else 
				throw new ApplicationException("Attempt to call ReadConsole API failed.");
		}
        
        ///
        /// BenZotto wrote this for BillingXCheck
        ///
        public static string ReadHiddenLine()
        {
            StringBuilder sb = new StringBuilder();
            char c;
            
            while((c = ReadChar()) != '\r' && c != '\n')
            {
                sb.Append(c);
            }
            
            return sb.ToString();
        }
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\StfTests\BatmanTest\BillingProvider.cs ===
// 
// BillingProvider.cs
//
// Copyright (c) Microsoft Corporation. All Rights Reserved.
//
// SPS 2.5 Wrapper Class
// Xbox Online Service
// 
// Author: Ben Zotto (benzotto)
//

using System;
using System.IO;
using System.Web;
using System.Data.SqlClient;
using System.Data;
using System.Net;
using System.Text;
using System.Xml;
using System.Globalization;
using System.Diagnostics;
using System.Web.Services.Protocols;
using System.Runtime.InteropServices;
using XBOX.Utilities;
using System.Security.Permissions;
using System.Security.Principal;
using Microsoft.GotDotNet;

                                

namespace BatmanTest
{


public class BillingProvider : bdk
{
        
    //
    // Stuff for impersonation to get public key
    //
    
    [DllImport("c:\\winnt\\system32\\advapi32.dll", EntryPoint="LogonUser", SetLastError=true,
             CharSet=CharSet.Auto, CallingConvention=CallingConvention.StdCall)]
    public static extern bool LogonUser(String lpszUsername, String lpszDomain, String lpszPassword, 
            int dwLogonType, int dwLogonProvider, out int phToken);
    
    [DllImport("c:\\winnt\\system32\\Kernel32.dll")]
    public static extern int GetLastError();

    //
    // BillingProvider
    //    
    
    private static string _server;
    private static string _iisuser;

    // data that persists across all connections
    public static string Username
    {
        get 
        { 
            if (!_initalized) Init();
            return _username; 
        }
        
        set { _username = value; }
    }

    public static string Password
    {
        get 
        { 
            if (!_initalized) Init();
            return _password;
        }
        set { _password = value; }
    }

    public static string WsdlLocation
    {
        get
        { 
            if (!_initalized) Init();
            return _wsdlLocation;            
        }
        set { _wsdlLocation = value; }
    }


    private static string _username;
    private static string _password;
    private static string _wsdlLocation;
    private static bool _initalized = false;
	private static string _key = null;
	private static PsoLib.PsoEncrypterClass _encrypter;

                
    public static void Init()
    {
        GetPartnerInfo(_server, _iisuser);
        
		// the encrypter object needs to hang around.
		if (CBatmanTest._useEnc)
		{
			_encrypter = new PsoLib.PsoEncrypterClass();
			_encrypter.Initialize();
			if(_encrypter.ErrorCode != 0x0) 
			{
				throw new Exception("SPS PSO Encrypter object init error: 0x" + 
					_encrypter.ErrorCode.ToString("x") + " " + _encrypter.ErrorDescription );
			}
		}

		if (CBatmanTest._debug)
		{
			Console.WriteLine("BillingProvider: Username=" + _username);
			Console.WriteLine("BillingProvider: Password=" + _password);
			Console.WriteLine("BillingProvider: WSDL=" + _wsdlLocation);       
		}
        
        _initalized = true;
    }    
    
	public static PsoLib.PsoEncrypterClass Encrypter
	{
		get 
		{ 
			if (!_initalized) Init();
			return _encrypter;
		}
		set { _encrypter = value; }
	}

	public static string Key
	{
		get { return _key; }
		set { _key = value; }
	}


    // constructor
    public BillingProvider(string server, string iisuser) : base()
    {
        _server = server;
        _iisuser = iisuser;
        
        // set up the bdk that we inherit from
        this.Url     = WsdlLocation;
        
        this.Credentials = new NetworkCredential(Username, Password);  
        this.Timeout     = 20000;

		// retrieve public key
		string strErrorXML	= null;
		string strKeyXML	= null;
		int	   idx			= 0;

		base.GetKey( 0, 0, "89BA9D19-9A04-4A15-A2A3-AF881B10FF53", out strErrorXML, out strKeyXML);
		idx = strKeyXML.IndexOf("<Data>");
		_key = strKeyXML.Substring( idx + 6, strKeyXML.IndexOf("</Data>") - idx - 6);
	}



    /// <summary>
    /// Gets the partner key info from UODB.
    /// </summary>
    private static void GetPartnerInfo(string server, string iisuser)
    {
        SqlCommand cmd;
        SqlConnection cxn;
        SqlDataReader reader;
        int masterkeyver;
        byte[] encPassword = null;
                           
		if (CBatmanTest._debug)
		{
			Console.WriteLine("Opening connection to " + server + "...");
		}
        cxn = new SqlConnection("server="+ server + ";trusted_connection=true;database=uodb");
        //cxn = new SqlConnection("server="+ server + ";uid=sa;password=Suck!H3ad;database=uodb");
        cxn.Open();
        
		if (CBatmanTest._debug)
		{
			Console.WriteLine("Getting service keys...");
		}
        cmd = new SqlCommand("p_xbos_get_raw_sps_info", cxn);
        cmd.CommandType = CommandType.StoredProcedure;
        SqlParameter sqlUsername = cmd.Parameters.Add("@username", SqlDbType.NVarChar, 200);
        SqlParameter sqlPassword = cmd.Parameters.Add("@password", SqlDbType.VarBinary, 256);
        SqlParameter sqlWsdlLocation = cmd.Parameters.Add("@wsdllocation", SqlDbType.NVarChar, 200);
        SqlParameter sqlKeyVer = cmd.Parameters.Add("@i_masterkeyversion", SqlDbType.Int);
        sqlUsername.Direction = ParameterDirection.Output;
        sqlPassword.Direction = ParameterDirection.Output;
        sqlWsdlLocation.Direction = ParameterDirection.Output;
        sqlKeyVer.Direction = ParameterDirection.Output;
            
        reader = cmd.ExecuteReader();
        reader.Close();
        
        Username = (string)sqlUsername.Value;
        encPassword = (byte[])sqlPassword.Value;
        WsdlLocation = (string)sqlWsdlLocation.Value;
        masterkeyver = (int)sqlKeyVer.Value;
        
        cxn.Close();
        
        // check the master key version
        if ( masterkeyver == 0 )
        {
            UnicodeEncoding UE = new UnicodeEncoding();
            Password = UE.GetString(encPassword);
        }
        else
        {
			/*
			if (CBatmanTest._debug)
			{
				Console.WriteLine("Impersonting " + iisuser);
			}
            
            Console.WriteLine("Password for " + iisuser + ": ");
            string pwd = ConsoleEx.ReadHiddenLine();
            Console.WriteLine("");
            
            string[] userDomain = iisuser.Split( new char[] { '\\' });
            string user = iisuser;
            string domain = "";
            if (userDomain.Length == 2)
            {
                domain = userDomain[0];
                user = userDomain[1];    
            }
            
            int token;

            bool loggedOn = LogonUser(user, domain, pwd, 3, 0, out token);
            if (!loggedOn)
            {
                throw new Exception("ERROR: LogonUser() failed, unable to decrypt SPS service key: " + GetLastError());
            }
            else
            {
			*/
                ASCIIEncoding AE = new ASCIIEncoding();        
                //IntPtr tokenPtr = new IntPtr(token);
                //WindowsIdentity wi = new WindowsIdentity(tokenPtr);
                //WindowsImpersonationContext impCtx = wi.Impersonate();
                
                Password = AE.GetString(KEKCryptoMgr.DecryptWithMasterKeyWrp( (uint)masterkeyver, (uint)encPassword.Length, encPassword ));              
                
                /*// revert to previous identity
                impCtx.Undo();                
            }
                */
        }
            
    
    /***** CODE BELOW IS LEGACY FOR WEBSTORE USE.  IT CAN BE REVIVED IF NECESSARY/DESIRABLE. ***
    
        WSClient ws = new WSClient("uodb", CmdType.WRITEONLY_COMMANDTYPE);
        int masterkeyver = 0;
        
        ws.ClearParameters();
        // TODO:  RENAME THIS STORED PROC.
        ws.StoredProc = "p_xbos_get_raw_sps_info";
               
        // intput and output params
        ws.AddParameter(ParamType.OUTPUT, "", 200);     // partner username
        ws.AddParameter(ParamType.OUTPUT, (byte[])null, 256);     // partner key
        ws.AddParameter(ParamType.OUTPUT, "", 200);     // partner WSDL location
        ws.AddParameter(ParamType.OUTPUT, 0);           // master key version to do decryption

        // call the procedure
        ws.ExecuteNonQuery();
	

        Username = ws.GetStringParameter(0);
        masterkeyver = ws.GetIntParameter(3);
        WsdlLocation = ws.GetStringParameter(2);
        
        // check the master key version
        if ( masterkeyver == 0 )
        {
            UnicodeEncoding UE = new UnicodeEncoding();
            Password = UE.GetString(ws.GetByteArrayParameter(1) );
        }
        else
        {
            ASCIIEncoding AE = new ASCIIEncoding();
            byte[] encPassword = ws.GetByteArrayParameter(1);
            Password = AE.GetString(KEKCryptoMgr.DecryptWithMasterKeyWrp( (uint)masterkeyver, (uint)encPassword.Length, encPassword ));    
        }
        */
    }
    
    
}



}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\StfTests\CMSBVT\AssemblyInfo.cs ===
using System.Reflection;
using System.Runtime.CompilerServices;

//
// General Information about an assembly is controlled through the following 
// set of attributes. Change these attribute values to modify the information
// associated with an assembly.
//
[assembly: AssemblyTitle("")]
[assembly: AssemblyDescription("")]
[assembly: AssemblyConfiguration("")]
[assembly: AssemblyCompany("")]
[assembly: AssemblyProduct("")]
[assembly: AssemblyCopyright("")]
[assembly: AssemblyTrademark("")]
[assembly: AssemblyCulture("")]		

//
// Version information for an assembly consists of the following four values:
//
//      Major Version
//      Minor Version 
//      Build Number
//      Revision
//
// You can specify all the values or you can default the Revision and Build Numbers 
// by using the '*' as shown below:

[assembly: AssemblyVersion("1.0.*")]

//
// In order to sign your assembly you must specify a key to use. Refer to the 
// Microsoft .NET Framework documentation for more information on assembly signing.
//
// Use the attributes below to control which key is used for signing. 
//
// Notes: 
//   (*) If no key is specified, the assembly is not signed.
//   (*) KeyName refers to a key that has been installed in the Crypto Service
//       Provider (CSP) on your machine. KeyFile refers to a file which contains
//       a key.
//   (*) If the KeyFile and the KeyName values are both specified, the 
//       following processing occurs:
//       (1) If the KeyName can be found in the CSP, that key is used.
//       (2) If the KeyName does not exist and the KeyFile does exist, the key 
//           in the KeyFile is installed into the CSP and used.
//   (*) In order to create a KeyFile, you can use the sn.exe (Strong Name) utility.
//       When specifying the KeyFile, the location of the KeyFile should be
//       relative to the project output directory which is
//       %Project Directory%\obj\<configuration>. For example, if your KeyFile is
//       located in the project directory, you would specify the AssemblyKeyFile 
//       attribute as [assembly: AssemblyKeyFile("..\\..\\mykey.snk")]
//   (*) Delay Signing is an advanced option - see the Microsoft .NET Framework
//       documentation for more information on this.
//
[assembly: AssemblyDelaySign(false)]
[assembly: AssemblyKeyFile("")]
[assembly: AssemblyKeyName("")]
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\StfTests\BatmanTest\SPS.cs ===
//
//  SPS.cs
//
//  Ben Zotto (benzotto), October 2002
//
//
using System;
using System.Collections;
using System.IO;
using System.Xml;
using System.Xml.Serialization;
using System.Diagnostics;
using System.Text.RegularExpressions;
                                  
                                     
namespace BatmanTest
{

    class SPS
    {
        private static BillingProvider _bdk = null;
        public static string Server = null;
        public static string IISUser = null;
                        
        public static int CheckOfferInBilling(string offeringID, string serviceComponentID, string opd)
        {
            if(_bdk == null) { _bdk = new BillingProvider(Server, IISUser); }
            
            int errorCount = 0;
            string errorText;
            int    offeringInfoCount, serviceComponentCount;
            string offeringInfoSet, serviceComponentSet;
            
            try
            {
                _bdk.GetBaseOfferings(offeringID, "", "", "en-US", "", out errorText, out offeringInfoCount, out offeringInfoSet);
            }
            catch (Exception e)
            {                
                if(e.Message.StartsWith("<ErrorPackage><ErrorHResult>0x80049E84"))
                {
                    errorCount++;
                    Console.WriteLine("FAIL: SPS doesn't know about offering " + offeringID + " (in expected en-US locale, anyways)");
                    return errorCount;
                }
                else
                    throw;
            }
            
            if(offeringInfoCount != 1)
            {
                    errorCount++;
                    Console.WriteLine("FAIL: SPS reports " + offeringInfoCount + " offerings matching " + offeringID + "!");
                    Console.WriteLine("\t(in en-US locale, anyways)");
                    return errorCount;                
            }
            
            //
            // get info set            
            //             
            if(opd != null && opd != "")
            {            
                OfferingInfoSet ois = new OfferingInfoSet();
                ois.FromXml(offeringInfoSet);            
                
                if(opd != ois.OfferingPriceDescription.Trim())
                {
                    errorCount++;
                    Console.WriteLine("WARNING: Offer " + offeringID + " has mismatching OPD set!");
                    Console.WriteLine("\tin SPS: \"" + ois.OfferingPriceDescription + "\" expecting: \"" + opd + "\"");                            
                }
            }
            
            //
            // Get Service Compoent info
            //                                 
            if(serviceComponentID != null && serviceComponentID != "")
            {
                try
                {
                    _bdk.GetServiceComponents(offeringID, out errorText, out serviceComponentCount, out serviceComponentSet);
                }
                catch (Exception e)
                {                
                    if(e.Message.StartsWith("<ErrorPackage><ErrorHResult>0x80049E84"))
                    {
                        errorCount++;
                        Console.WriteLine("FAIL: SPS doesn't know about offering " + offeringID);
                        return errorCount;
                    }
                    else
                        throw;
                }
                
                if(serviceComponentCount != 1)
                {
                        errorCount++;
                        Console.WriteLine("FAIL: SPS reports " + serviceComponentCount + " components matching " + offeringID + "!");
                        Console.WriteLine("\t(in en-US locale, anyways)");
                        return errorCount;                
                }
                
                ServiceComponentSet scs = new ServiceComponentSet();
                scs.FromXml(serviceComponentSet);            
                
                if(serviceComponentID.ToUpper() != scs.ServiceComponentId.ToUpper())
                {
                    errorCount++;
                    Console.WriteLine("WARNING: Offer " + offeringID + " has mismatching Service Component!");
                    Console.WriteLine("\tin SPS: \"" + scs.ServiceComponentId + "\" expecting: \"" + serviceComponentID + "\"");                            
                }
                
            }                                 
                                        
            return errorCount; 
        }
                
    }
    
    
    public class OfferingInfoSet
    {
        public string   OfferingGUID;
        public string   OfferingDescription;
        public string   OfferingPriceDescription;
        public string   InternalOfferingDescription;
        public string   LastAvailableDate;
        public string   FirstAvailableDate;
        public string   BaseOffering;
        public string   TermLocation;
        public string   CommitmentTerms;
        public string   MutuallyExclusiveGroupIdSet;
        public string   SignUpURL;
        public string   PaymentInstrumentRequired;                
        public string   PaymentTypeSet;
        public string   PaymentType;
            
        public OfferingInfoSet()
        {
        }
    
        public void FromXml(string xml)
        {
            XmlTextReader xmlReader = new XmlTextReader(new StringReader(xml));
            FromXml(xmlReader, "OfferingInfoSet");
            xmlReader.Close();
        }
    
        public void FromXml(XmlTextReader xmlReader, string rootNodeName)
        {
            xmlReader.MoveToContent(); 
    
            while (!xmlReader.EOF)   
            {
                if (xmlReader.NodeType == XmlNodeType.EndElement &&
                    (xmlReader.Name == rootNodeName))
                {
                    xmlReader.Skip();
                    break;
                }
    
                if (xmlReader.NodeType != XmlNodeType.Element)
                {
                    xmlReader.Skip();
                    continue;
                }
    
                switch (xmlReader.Name)
                {
                    case "OfferingGUID":
                       OfferingGUID = xmlReader.ReadElementString();
                       break;
    
                    case "OfferingDescription":
                        OfferingDescription = xmlReader.ReadElementString();
                        break;
    
                    case "OfferingPriceDescription":
                        OfferingPriceDescription = xmlReader.ReadElementString();
                        break;
    
                    case "InternalOfferingDescription":
                        InternalOfferingDescription = xmlReader.ReadElementString();
                        break;
    
                    case "LastAvailableDate":
                        LastAvailableDate = xmlReader.ReadElementString();
                        break;
    
                    case "FirstAvailableDate":
                        FirstAvailableDate = xmlReader.ReadElementString();
                        break;
    
                    case "BaseOffering":
                        BaseOffering = xmlReader.ReadElementString();
                        break;
    
                    case "TermLocation":
                        TermLocation = xmlReader.ReadElementString();
                        break;
    
                    case "CommitmentTerms":
                        CommitmentTerms = xmlReader.ReadElementString();
                        break;
    
                    case "MutuallyExclusiveGroupIdSet":
                        MutuallyExclusiveGroupIdSet = xmlReader.ReadElementString();
                        break;
    
                    case "SignUpURL":
                        SignUpURL = xmlReader.ReadElementString();
                        break;
    
                    case "PaymentInstrumentRequired":
                        PaymentInstrumentRequired = xmlReader.ReadElementString();
                        break;
    
                    case "PaymentType":
                        if(PaymentType == null)
                        {
                            PaymentType = xmlReader.ReadElementString();
                        }
                        else
                        {   
                            Console.WriteLine("WARNING: Offering " + OfferingGUID + " has multiple payment types defined.");
                            xmlReader.ReadElementString();
                        }
                        break;   
    
                    default:
                        if (xmlReader.Name == rootNodeName)
                        {
                            // advance to the first inner element
                            xmlReader.ReadStartElement();
                            break;
                        }
                        
                        if (xmlReader.Name == "OfferingInfo")
                        {
                            xmlReader.ReadStartElement();
                            break;
                        }
                        
                        if (xmlReader.Name == "PaymentTypeSet")
                        {
                            xmlReader.ReadStartElement();
                            break;
                        }
                        

                        
                        xmlReader.Skip();
                        break;
                }
            }
        }        
    }    
    
    public class ServiceComponentSet
    {                
        public string   ServiceComponentId;
        public string   InstanceCount;
        public string   ServiceComponentName;
        public string   MaxRoles;
            
        public ServiceComponentSet()
        {
        }
    
        public void FromXml(string xml)
        {
            XmlTextReader xmlReader = new XmlTextReader(new StringReader(xml));
            FromXml(xmlReader, "ServiceComponentSet");
            xmlReader.Close();
        }
    
        public void FromXml(XmlTextReader xmlReader, string rootNodeName)
        {
            xmlReader.MoveToContent(); 
    
            while (!xmlReader.EOF)   
            {
                if (xmlReader.NodeType == XmlNodeType.EndElement &&
                    (xmlReader.Name == rootNodeName))
                {
                    xmlReader.Skip();
                    break;
                }
    
                if (xmlReader.NodeType != XmlNodeType.Element)
                {
                    xmlReader.Skip();
                    continue;
                }
    
                switch (xmlReader.Name)
                {
                    case "ServiceComponentId":
                       ServiceComponentId = xmlReader.ReadElementString();
                       break;
    
                    case "InstanceCount":
                        InstanceCount = xmlReader.ReadElementString();
                        break;
    
                    case "ServiceComponentName":
                        ServiceComponentName = xmlReader.ReadElementString();
                        break;
    
                    case "MaxRoles":
                        MaxRoles = xmlReader.ReadElementString();
                        break;
    
       
                    default:
                        if (xmlReader.Name == rootNodeName)
                        {
                            // advance to the first inner element
                            xmlReader.ReadStartElement();
                            break;
                        }
                        
                        if (xmlReader.Name == "ServiceComponent")
                        {
                            xmlReader.ReadStartElement();
                            break;
                        }                                                
                        
                        xmlReader.Skip();
                        break;
                }
            }
        }
        
    
        
    
            
    }      
        
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\StfTests\BatmanTest\BatmanTest.cs ===
using System;
using System.IO;
using System.Xml;
using System.Xml.Serialization;
using System.Collections;
using System.Diagnostics;
using System.Text.RegularExpressions;
using System.Globalization;
using System.Threading;
using System.Data;
using System.Data.SqlClient;
using System.Text;
using XBOX.Utilities.Console;                                     

namespace BatmanTest
{
	/// <summary>
	/// Summary description for Class1.
	/// </summary>
	class CBatmanTest
	{
		// SPS
		public BillingProvider _sps = null;

		// SPS access
		public ArrayList _servers = null;
		public ArrayList _hashBuckets = null;

		// input file
		public string _strFileName = null;

		// debug
		public static bool _debug = true;
		// encryption
		public static bool _useEnc = true;
		public static string _strFakeCC1 = "4640386387810865";
		public static string _strFakeCC2 = "4968731202718641";

		/// <summary>
		/// The main entry point for the application.
		/// </summary>
		[STAThread]
		static void Main(string[] args)
		{
			FileStream		fs		= null;
			StreamReader	sr		= null;
			StreamWriter	sw		= null;
			string			strLine = null;
			CBatmanTest		bt		= new CBatmanTest();
			CUser			user	= null;
			ArrayList		rgUsers	= null;
			DateTime		dtChg	= DateTime.MinValue;

			if (args.Length < 2)
			{
				Usage();
				return;
			}

			// find input file
			Console.WriteLine("Opening file... " + args[0]);
			try
			{
				fs = new FileStream( args[0], System.IO.FileMode.Open, System.IO.FileAccess.Read);
			}
			catch (FileNotFoundException)
			{
				Console.WriteLine("File not found.  Please verify that file exists.\n\n");
				Usage();
				return;
			}

			bt._strFileName = args[0];
			dtChg = DateTime.Parse( args[1]);

			// open input file
			sr = new StreamReader(fs);
			sw = new StreamWriter("batmantest.log", true);
			Console.WriteLine("Reading configuration file...");
			// read configuration file
			try
			{
				bt.ReadConfigFile();
			}
			catch
			{
				Console.WriteLine("Could not read configuration file, make sure that ini file is in the same folder as the tool.");
				Usage();
				return;
			}
			// initialize billing provider
			Console.WriteLine("Initializing SPS interface...");
			
			try
			{
				bt._sps = new BillingProvider((string)bt._servers[0], "uodb_admin");
			}
			catch (Exception e)
			{
				Console.WriteLine( e.Message + "\nFailed to initialize SPS interface.");
				return;
			}
			
			// read input file
			bt.SkipRecoveryLines( sr);
			rgUsers = new ArrayList(30);
			
			// start case generation
			Console.WriteLine("User\tPUID\tCase");			
			
			// duplicate or missing accounts
			// create duplicate accounts
			user = bt.ParseUser( strLine = sr.ReadLine());
			Console.WriteLine( user.gamertag + "\t" + user.ownerPuid + "\t8.1.1.1. - many SPS accts, one matches UODB");
			bt.CreateDuplicateSPSAccount( user, _strFakeCC1);
			rgUsers.Add( user);
			// create unmatching UODB account
			user = bt.ParseUser( strLine = sr.ReadLine());
			Console.WriteLine( user.gamertag + "\t" + user.ownerPuid + "\t8.1.1.2. - SPS accts exists, but none match UODB");
			bt.CreateUnmatchedUODBAccount( user);
			rgUsers.Add( user);
			// good entry case - no changes
			user = bt.ParseUser( strLine = sr.ReadLine());
			Console.WriteLine( user.gamertag + "\t" + user.ownerPuid + "\t8.1.1.3. - 1 SPS acct, 1 UODB acct, match");
			rgUsers.Add( user);
			// create account only in UODB
			user = bt.ParseUser( strLine = sr.ReadLine());
			Console.WriteLine( user.gamertag + "\t" + user.ownerPuid + "\t8.1.1.4. - UODB acct, no matchin SPS accounts");
			bt.CreateUODBAccount( ref user);
			Console.WriteLine( user.gamertag + "\t" + user.ownerPuid);
			rgUsers.Add( user);

			// invalid locale
			// good locale
			user = bt.ParseUser( strLine = sr.ReadLine());
			Console.WriteLine( user.gamertag + "\t" + user.ownerPuid + "\t8.1.2.1. - user locale matches country");
			rgUsers.Add( user);
			// user locale exists, but doesn't match the country
			user = bt.ParseUser( strLine = sr.ReadLine());
			Console.WriteLine( user.gamertag + "\t" + user.ownerPuid + "\t8.1.2.2. - user locale invalid for the country (fr-fr / US)");
			bt.SetWrongLocale( user, "fr-fr");
			rgUsers.Add( user);
			// user locale exists, but doesn't match the country, for bilingual countries
			user = bt.ParseUser( strLine = sr.ReadLine());
			Console.WriteLine( user.gamertag + "\t" + user.ownerPuid + "\t8.1.2.3. - user locale invalid for the country, but language is valid, no update to UODB (fr-fr / CA)");
			bt.SetWrongLocale( user, "fr-fr", true);
			rgUsers.Add( user);
			// user locale exists, but doesn't match the country, for bilingual countries, update UODB
			user = bt.ParseUser( strLine = sr.ReadLine());
			Console.WriteLine( user.gamertag + "\t" + user.ownerPuid + "\t8.1.2.4. - user locale invalid for the country, but language is valid, update to UODB (fr-fr / CA)");
			bt.SetWrongLocale( user, "fr-fr", true, true);
			rgUsers.Add( user);
			// user locale doesn't exist
			user = bt.ParseUser( strLine = sr.ReadLine());
			Console.WriteLine( user.gamertag + "\t" + user.ownerPuid + "\t8.1.2.5. - user locale is not supported (ru-ru)");
			bt.SetWrongLocale( user, "ru-ru");
			rgUsers.Add( user);
			
			// publicate or missing payment info
			// 1-to-1 match, no change
			user = bt.ParseUser( strLine = sr.ReadLine());
			Console.WriteLine( user.gamertag + "\t" + user.ownerPuid + "\t8.1.3.1. - UODB payment info matches with one and only SPS payment info");
			rgUsers.Add( user);
			// create unmatching UODB payment info
			user = bt.ParseUser( strLine = sr.ReadLine());
			Console.WriteLine( user.gamertag + "\t" + user.ownerPuid + "\t8.1.3.2. - UODB payment doesn't match with one and only SPS payment info");
			bt.CreateUnmatchedUODBPayment( user);
			rgUsers.Add( user);
			// create duplicate SPS payment info
			user = bt.ParseUser( strLine = sr.ReadLine());
			Console.WriteLine( user.gamertag + "\t" + user.ownerPuid + "\t8.1.3.3. - Many SPS payment infos, one matches UODB");
			bt.CreateDuplicatePaymentInfo( user, true, _strFakeCC1);
			rgUsers.Add( user);
			// create duplicate SPS payment infos that doesn't match UODB or base subscription.
			user = bt.ParseUser( strLine = sr.ReadLine());
			Console.WriteLine( user.gamertag + "\t" + user.ownerPuid + "\t8.1.3.4. - Many SPS payment infos, none matches UODB or base subscription");
			bt.CreateDuplicatePaymentInfo( user, false, _strFakeCC1);
			bt.CreateDuplicatePaymentInfo( user, true, _strFakeCC2);
			rgUsers.Add( user);
			// create duplicate SPS payment info, none match UODB, one matches base subscription
			user = bt.ParseUser( strLine = sr.ReadLine());
			Console.WriteLine( user.gamertag + "\t" + user.ownerPuid + "\t8.1.3.5. - Many SPS payment infos, none matches UODB one matches base subscription");
			bt.CreateDuplicatePaymentInfo( user, true, _strFakeCC1);
			bt.CreateUnmatchedUODBPayment( user);
			rgUsers.Add( user);
			// No SPS payment info
			user = bt.ParseUser( strLine = sr.ReadLine());
			Console.WriteLine( user.gamertag + "\t" + user.ownerPuid + "\t8.1.3.6. - No SPS payment infos (impossible case)");
			bt.RemoveSPSPaymentInfo( user);
			rgUsers.Add( user);
			// create SPS payment info that doesn't match UODB or base subscription.
			user = bt.ParseUser( strLine = sr.ReadLine());
			Console.WriteLine( user.gamertag + "\t" + user.ownerPuid + "\t8.1.3.7. - one SPS payment info, not matching UODB or base subscription");
			bt.CreateDuplicatePaymentInfo( user, false, _strFakeCC1);
			rgUsers.Add( user);

			// duplicate or mismatching base subscriptions
			// good entry case - no changes
			user = bt.ParseUser( strLine = sr.ReadLine());
			Console.WriteLine( user.gamertag + "\t" + user.ownerPuid + "\t8.1.4.1. - 1 base subscription in UODB and 1 matching in SPS");
			rgUsers.Add( user);
			// active UODB subscription - no matching SPS subscription
			user = bt.ParseUser( strLine = sr.ReadLine());
			Console.WriteLine( user.gamertag + "\t" + user.ownerPuid + "\t8.1.4.2. - Active subscription UODB with no match in SPS");
			bt.CreateUODBSubscription( user);
			rgUsers.Add( user);
			// Subscription in SPS, not in UODB and there is no moved or queued entries in UODB
			user = bt.ParseUser( strLine = sr.ReadLine());
			bt.CreatePremiumSubscription( user, false, true);
			Console.WriteLine( user.gamertag + "\t" + user.ownerPuid + "\t8.1.4.3. - Subscription in SPS, not in UODB, no moved or queued entries in UODB");
			rgUsers.Add( user);
			// duplicate base subscription
			user = bt.ParseUser( strLine = sr.ReadLine());
			Console.WriteLine( user.gamertag + "\t" + user.ownerPuid + "\t8.1.4.4. - Duplicate base subscription(s) in SPS, one matches UODB");
			bt.CreateSPSSubscription( user);
			rgUsers.Add( user);
			// UODB subscription doesn't match SPS
			user = bt.ParseUser( strLine = sr.ReadLine());
			Console.WriteLine( user.gamertag + "\t" + user.ownerPuid + "\t8.1.4.5. - UODB subscription doesn't match with SPS (similar to 8.1.4.2.)");
			bt.CreateUODBSubscription( user);
			bt.CreatePremiumSubscription( user, false, true);
			rgUsers.Add( user);
			// duplicate SPS subscriptions neither matches with UODB
			user = bt.ParseUser( strLine = sr.ReadLine());
			Console.WriteLine( user.gamertag + "\t" + user.ownerPuid + "\t8.1.4.6. - Duplicate subscriptions in SPS, but none match UODB");
			bt.CreateUODBSubscription( user);
			bt.CreateSPSSubscription( user);
			rgUsers.Add( user);
			// subscription only in UODB
			Console.WriteLine( "Use emulator\t" + user.ownerPuid + "\t8.1.4.7. - Subscription only in UODB, make sure change date is updated");
			// cancelled subscription in SPS
			user = bt.ParseUser( strLine = sr.ReadLine());
			Console.WriteLine( user.gamertag + "\t" + user.ownerPuid + "\t8.1.4.8. - Subscription cancelled in SPS, make sure it is active in UODB");
			bt.CancelSPSSubscriptions( user);
			rgUsers.Add( user);
			// subscription in SPS, not in UODB, but there is queued entry in UODB
			user = bt.ParseUser( strLine = sr.ReadLine());
			Console.WriteLine( user.gamertag + "\t" + user.ownerPuid + "\t8.1.4.9. - Subscription in SPS, not in UODB, but there is queued entry in UODB");
			bt.CreateQueuedSubscription( user);
			rgUsers.Add( user);
			// cancelled subscription in UODB, active in SPS
			user = bt.ParseUser( strLine = sr.ReadLine());
			Console.WriteLine( user.gamertag + "\t" + user.ownerPuid + "\t8.1.4.10 - Subscription cancelled in UODB, active in SPS");
			bt.CancelUODBSubscription( user);

			// incomplete base subscription
			// create incomplete subscription in UODB
			user = bt.ParseUser( strLine = sr.ReadLine());
			Console.WriteLine( user.gamertag + "\t" + user.ownerPuid + "\t8.1.5.1. - Incomplete base subscription in UODB, complete in SPS");
			bt.CreateIncompleteUODBSubscription( user);
			rgUsers.Add( user);
			// incomplete non-base subscription
			// incomplete in UODB, not present in SPS
			user = bt.ParseUser( strLine = sr.ReadLine());
			Console.WriteLine( user.gamertag + "\t" + user.ownerPuid + "\t8.1.5.2. - Incomplete premium Subscription in UODB, no entry in SPS");
			bt.CreatePremiumSubscription( user, true, false);
			rgUsers.Add( user);
			// incomplete in UODB, complete in SPS
			user = bt.ParseUser( strLine = sr.ReadLine());
			Console.WriteLine( user.gamertag + "\t" + user.ownerPuid + "\t8.1.5.3. - Incomplete premium Subscription in UODB, but complete in SPS (update)");
			bt.CreatePremiumSubscription( user, true, true);
			rgUsers.Add( user);
			// incomplete in UODB and incomplete in SPS
			user = bt.ParseUser( strLine = sr.ReadLine());
			Console.WriteLine( user.gamertag + "\t" + user.ownerPuid + "\t8.1.5.4. - Incomplete premium Subscription in UODB and in SPS (purchase)");
			bt.CreatePremiumSubscription( user, true, true);
			bt.CancelSPSSubscription( user, 0); // cancel only PSO
			rgUsers.Add( user);
			
			// unprovisioned base subscriptions
			user = bt.ParseUser( strLine = sr.ReadLine());
			Console.WriteLine( user.gamertag + "\t" + user.ownerPuid + "\t8.1.6.1. - unprovisioned non-queued base subscription in UODB");
			bt.CreateUnprovisionedSubscription( user);
			rgUsers.Add( user);
			// create queued subscription
			user = bt.ParseUser( strLine = sr.ReadLine());
			Console.WriteLine( user.gamertag + "\t" + user.ownerPuid + "\t8.1.6.2. - queued base subscription in UODB");
			bt.CreateQueuedSubscription( user);
			rgUsers.Add( user);

			// Test case for BUG 33490
			// Add user with 3 subscriptions, 2 of which fall outside the date range
			// Batman should not return an error
			user = bt.ParseUser( strLine = sr.ReadLine());
			Console.WriteLine( user.gamertag + "\t" + user.ownerPuid + "\t8.1.6.3. - UODB subscriptions outside the date range");
			// Set change date time is done within this function, 
			// so don't add user to rgUsers
			bt.CreateSubsOutsideDateRange(user,dtChg);		
	
			// Invalid case for subs outside the date range
			// Mismatch should be reported
			user = bt.ParseUser( strLine = sr.ReadLine());
			Console.WriteLine( user.gamertag + "\t" + user.ownerPuid + "\t8.1.6.4. - UODB subscriptions outside the date range, mismatch");
			// Set change date time is done within this function, 
			// so don't add user to rgUsers
			bt.CreateSubsOutsideDateRangeMismatch(user,dtChg);	

			// change all processed user's & subscription's change datetime to the given future date.
			bt.SetChangeDateTime( rgUsers, dtChg);
			
			return;
		}

		static void Usage()
		{
			Console.WriteLine("BatmanTest tool will create duplicate SPS accounts, duplicate and wrong Payment Info," +
				" duplicate, incomplete and unprovisioned subscriptions.\r\n\r\nUsage: BatmanTest <filename> <date>\r\n" +
				"<filename>\tshould contain list of PUIDs for which bad data will be created\r\n" +
				"\t\tthe only currently supported format is output from AasManager\r\n" +
				"<date>\tshould be valid date preferably in the future, it will replace\r\n" +
				"\t\tdt_Change_datetime in t_users & t_subscriptions. \r\n\t\tIt should be in the format MM-DD-YYYY or YYYY-MM-DD ");
			return;
		}

		void ReadConfigFile()
		{
			string strLine;
			_servers = new ArrayList();
			_hashBuckets = new ArrayList();
			StreamReader sReader = new StreamReader("servers.ini");

			while ( null != (strLine = sReader.ReadLine()) )
			{
				if (strLine.IndexOf(';') < 0)
				{
					Console.WriteLine("Please make sure your servers.ini file looks like SERVER;HASHBUCKET on each line");
					throw new Exception();
				}
				string []lineParts = strLine.Split(';');
				_servers.Add(lineParts[0]);
				_hashBuckets.Add(lineParts[1]);
			}
			if (_servers.Count < 1)
			{
				throw new Exception( "Configuration file empty");
			}
			return;
		}

		bool CreateDuplicateSPSAccount( CUser user, string strCC)
		{
			ArrayList rgAccounts = null;
			ArrayList rgPayments = null;
			AccountInfo ai = null;
			PaymentInstrumentInfoSetPaymentInstrumentInfo pii = null;
			
			// get account info for an existing account
			GetSPSAccounts( user, out rgAccounts);
			GetPaymentInfos( user, out rgPayments);
			if (rgAccounts.Count == 0 || rgPayments.Count == 0)
			{
				Console.WriteLine( "No accounts or no paymens found for user " + user.gamertag);
				return false;
			}
			ai = (AccountInfo) rgAccounts[0];
			pii= (PaymentInstrumentInfoSetPaymentInstrumentInfo) rgPayments[0];

			//Console.WriteLine( "AccountInfo:\n" + rgAccounts[0].ToString());
			//Console.WriteLine( "PaymentInstruments:\n" + rgPayments[0].ToString());

			// encryption step - works only on xonteXBOSiis001
			if (_useEnc)
			{
				pii.CreditCardInfo.EncryptedAccountNumber = BillingProvider.Encrypter.Encrypt( strCC, BillingProvider.Key);
			}
			pii.CreditCardInfo.CardType = "VISA";

			// create an account
			return CreateSPSAccount( user, ai, pii);
		}
		
		bool CreateDuplicatePaymentInfo( CUser user, bool fGoodInfo, string strCC)
		{
			ArrayList	rgPayments			= null;
			PaymentInstrumentInfoSetPaymentInstrumentInfo pii = null;

			// read original PaymentInfo
			GetPaymentInfos( user, out rgPayments);
			if (rgPayments.Count < 1)
			{
				Console.WriteLine( "No payments found for an account " + user.gamertag);
				return false;
			}
			pii = (PaymentInstrumentInfoSetPaymentInstrumentInfo) rgPayments[0];
			
			// encryption step
			if (_useEnc)
			{
				pii.CreditCardInfo.EncryptedAccountNumber = BillingProvider.Encrypter.Encrypt( strCC, BillingProvider.Key);
			}
			pii.CreditCardInfo.CardType = "VISA";

			// create new PaymentInstrument
			/*
				[in]  LONG lDelegateIdHigh,
				[in]  LONG lDelegateIdLow,
				[in]  LONG lRequesterIdHigh,
				[in]  LONG lRequestedIdLow,
				[in]  BSTR bstrTrackingGUID,
				[in]  BSTR bstrAccountId,
				[in]  BSTR bstrPaymentInstrumentInfoXML,
				[out] BSTR *pbstrResultXML,
				[out] BSTR *pbstrPaymentInstrumentId,
				[out] BSTR *pbstrRequiredPaperWorkURL
			*/
			int			iHi					= (int)(user.ownerPuid >> 32);
			int			iLow				= (int)(user.ownerPuid & 0xFFFFFFFF);
			string		strGuid				= Guid.NewGuid().ToString();
			string		strPayXML			= null;
			
			string		strResultXML		= null;
			string		strPaymentInfoId	= null;
			string		strReqPaperWorkURL	= null;
			
			try
			{
				// serialize PaymentInstrumentInfo -> XML
				XmlSerializer xmlSerialize		= new XmlSerializer( typeof(BatmanTest.PaymentInstrumentInfoSetPaymentInstrumentInfo));
				StringWriter  sw				= new StringWriter();
				xmlSerialize.Serialize( sw, pii);
				strPayXML = sw.ToString().Replace( "PaymentInstrumentInfoSetPaymentInstrumentInfo", "PaymentInstrumentInfo");
				strPayXML = strPayXML.Replace( "<PaymentInstrumentInfo ", "<PaymentInstrumentInfo xmlns=\"urn:schemas-microsoft-com:billing-data\" ");
			}
			catch (Exception e)
			{
				Console.WriteLine( e.Message + "\nFailed to serialize into XML PaymentInstrumentInfo for user " + user.gamertag);
				return false;
			}
			
			try
			{
				// send request
				_sps.AddPaymentInstrument( 
					0,
					0,							// delegate can be 0
					iHi,
					iLow,						// Owner PUID
					strGuid,					// guid
					user.account,				// billing account id
					strPayXML,					// PaymentInstrumentInfoXML
					out strResultXML,			// any errors?
					out strPaymentInfoId,		// new PaymentInstrumentId
					out strReqPaperWorkURL		// url to paperwork
					);
				if (strPaymentInfoId.Length == 0)
				{
					Console.WriteLine( "Error creating new PaymentInstrument:" + strResultXML);
					return false;
				}
			}
			catch (Exception e)
			{
				Console.WriteLine( e.Message + "\nFailed to add new PaymentInstrument for user " + user.gamertag);
				return false;
			}
			if (_debug)
			{
				Console.WriteLine( "New PaymentInstrumentId\t" + strPaymentInfoId);
			}
			// delete old PaymentInstrumentInfo
			if (!fGoodInfo)
			{
				RemoveSPSPaymentInfo( user);
			}
			return true;
		}
		
		bool RemoveSPSPaymentInfo( CUser user)
		{
			int			iHi				= (int)(user.ownerPuid >> 32);
			int			iLow			= (int)(user.ownerPuid & 0xFFFFFFFF);
			
			string		strResultXML	= null;
			string		strGuid			= Guid.NewGuid().ToString();	
			string		strAmountChargedXML = null;

			try
			{
				/*
					[in]  LONG lDelegateIdHigh,
					[in]  LONG lDelegateIdLow,
					[in]  BSTR bstrTrackingGUID,
					[in]  BSTR bstrObjectId,
					[in]  BSTR bstrLineItemId,
					[out] BSTR *pbstrResultXML,
					[out] BSTR *pbstrAmountChargedXML
				*/
				_sps.CloseBalance(
					0,
					0,
					strGuid,
					user.payinfo,
					"",
					out strResultXML,
					out strAmountChargedXML
					);
			}
			catch (Exception e)
			{
				Console.WriteLine( e.Message + "\n" + strResultXML + "\nFailed to close balanse for PaymentInstrument for user " + user.gamertag);
				return false;
			}
			strGuid = Guid.NewGuid().ToString();
			try
			{
				/*
					[in]  LONG lDelegateIdHigh,
					[in]  LONG lDelegateIdLow,
					[in]  BSTR bstrTrackingGUID,
					[in]  BSTR bstrPaymentInstrumentId,
					[out] BSTR *pbstrResultXML,
					[out] BSTR *pbstrAmountChargedXML
				*/
				_sps.SettleBalance(
					0,
					0,
					strGuid,
					user.payinfo,
					out strResultXML,
					out strAmountChargedXML
					);
			}
			catch (Exception e)
			{
				Console.WriteLine( e.Message + "\n" + strResultXML + 
					"\nFailed to settle balance on PaymentInstrument for user " + user.gamertag);
				return false;
			}
			if ( !CancelSPSSubscriptions( user) )
			{
				Console.WriteLine( "\nFailed to delete PaymentInstrument for user " + user.gamertag);
				return false;
			}
			try
			{
				/*
					[in]  LONG lDelegateIdHigh,
					[in]  LONG lDelegateIdLow,
					[in]  LONG lRequesterIdHigh,
					[in]  LONG lRequestedIdLow,
					[in]  BSTR bstrPaymentInstrumentId,
					[out] BSTR *pbstrResultXML
				*/
				_sps.RemovePaymentInstrument(
					0,
					0,						// delegate can be 0
					iHi,
					iLow,					// Owner PUID
					user.payinfo,			// original payment info id
					out strResultXML
					);
			}
			catch (Exception e)
			{
				Console.WriteLine( e.Message + "\n" + strResultXML + 
					"\nFailed to delete PaymentInstrument for user " + user.gamertag);
				return false;
			}
			return true;
		}

		bool SetWrongLocale( CUser user, string strLocale)
		{
			return SetWrongLocale( user, strLocale, false, false);
		}

		bool SetWrongLocale( CUser user, string strLocale, bool fCA)
		{
			return SetWrongLocale( user, strLocale, fCA, false);
		}

		bool SetWrongLocale( CUser user, string strLocale, bool fCA, bool fUpdateUODB)
		{
			// setting locale to the one passed
			// optionally "moving" user to Canada
			ArrayList	rgAccounts	= null;
			AccountInfo	ai			= null;
			bool		fRet		= true;

			// get original account
			GetSPSAccounts( user, out rgAccounts);
			if (rgAccounts.Count == 0)
			{
				Console.WriteLine( "There are no accounts for user " + user.gamertag + " on SPS!");
				return false;
			}
			ai = (AccountInfo) rgAccounts[0];

			// change locale info
			ai.Locale = strLocale;
			// change country info
			if (fCA)
			{
				// just some bogus address in Canada
				ai.PhoneSet.Phone.CountryCode = "CA";
				ai.AddressInfoSet.AddressInfo.City = "Vancouver";
				ai.AddressInfoSet.AddressInfo.CountryCode = "CA";
				ai.AddressInfoSet.AddressInfo.PostalCode = "V6Z1Y5";
				ai.AddressInfoSet.AddressInfo.State = "BC";
			}
			// submit change request
			fRet = UpdateAccountInfo( user, ai);
			if (fRet && fCA && fUpdateUODB)
			{
				string strSQL = "UPDATE t_users SET ti_country_id = 16 WHERE bi_owner_puid = " + user.ownerPuid.ToString();
				fRet = (null != ExecuteUODBSQL( strSQL, false));
			}
			return fRet;
		}
		
		bool CreateSPSSubscription( CUser user)
		{
			ArrayList		rgSubscriptions = null;
			SubscriptionInfoSetSubscriptionInfo si = null;

			GetSPSSubscriptions( user, out rgSubscriptions);
			if (rgSubscriptions.Count == 0)
			{
				Console.WriteLine( "Subscriptions not found for user " + user.gamertag);
				return false;
			}
			si = (SubscriptionInfoSetSubscriptionInfo) rgSubscriptions[0];

			// call PurchaseOffering
			return PurchaseOffering( user, ref si);
		}
		
		bool CancelSPSSubscriptions( CUser user)
		{
			bool fRet = true;
			ArrayList	rgSubscriptions = null;
			SubscriptionInfoSetSubscriptionInfo si = null;
			GetSPSSubscriptions( user, out rgSubscriptions);
			if (rgSubscriptions.Count == 0)
			{
				Console.WriteLine( "No subscriptions found for user " + user.gamertag);
				return false;
			}

			for (int i = 0; i < rgSubscriptions.Count; i++)
			{
				si = (SubscriptionInfoSetSubscriptionInfo) rgSubscriptions[i];
				fRet = fRet && CancelSPSSubscription( user, si);
			}

			return fRet;
		}

		bool CancelSPSSubscription( CUser user, int i)
		{
			bool fRet = true;
			ArrayList	rgSubscriptions = null;
			SubscriptionInfoSetSubscriptionInfo si = null;
			GetSPSSubscriptions( user, out rgSubscriptions);

			if (rgSubscriptions.Count <= i)
			{
				Console.WriteLine( "Index out of bound, user " + user.gamertag + " doesn't have " + i + " subscriptions.");
				return false;
			}
			si = (SubscriptionInfoSetSubscriptionInfo) rgSubscriptions[i];
			fRet = fRet && CancelSPSSubscription( user, si);

			return fRet;
		}

		bool CancelSPSSubscription( CUser user, SubscriptionInfoSetSubscriptionInfo si)
		{
			int			iHi			= (int)(user.ownerPuid >> 32);
			int			iLow		= (int)(user.ownerPuid & 0xFFFFFFFF);
			string		strGuid		= Guid.NewGuid().ToString();
			bool		fNoCommit	= false;
			string		strComment	= "<CommentInfo xmlns=\"urn:schemas-microsoft-com:billing-data\">\r\n\t<CommentCode>6</CommentCode>\r\n\t" +
				"<CommentText>BatmanTest - Cancelled</CommentText>\r\n</CommentInfo>";
			string		strResultXML= null;
			string		strAmtCharged = null;
			string		strSSIXML	= null;
			int			iRemovedCnt	= 0;
			string		strRemovedServiceInstanceSetXML = null;

			try
			{
				/*
					[in]  LONG lDelegateIdHigh,
					[in]  LONG lDelegateIdLow,
					[in]  LONG lRequesterIdHigh,
					[in]  LONG lRequesterIdLow,
					[in]  BSTR bstrTrackingGUID,
					[in]  VARIANT_BOOL fComputeOnly,
					[in]  BSTR bstrSubscriptionId,
					[in]  BSTR bstrCancelDate,
					[in]  BSTR bstrCommentInfoXML,
					[out] BSTR *pbstrResultXML,
					[out] BSTR *pbstrAmountChargedXML,
					[out] BSTR *pbstrSubscriptionStatusInfoXML,
					[out] LONG *plRemovedServiceInstanceCount,
					[out] BSTR *pbstrRemovedServiceInstanceSetXML
				*/
				_sps.CancelSubscription(
					0,
					0,						// delegate can be 0
					iHi,
					iLow,					// owner PUID
					strGuid,				// tracking guid
					fNoCommit,				// fComputeOnly
					si.SubscriptionId,
					"",						// CancelDate blank means immediately
					strComment,				// CommentInfoXML
					out strResultXML,		// is there an error?
					out strAmtCharged,		// AmountChargedXML
					out strSSIXML,			// SubscriptionStatusInfoXML
					out iRemovedCnt,		// RemovedServiceInstanceCount
					out strRemovedServiceInstanceSetXML
					);
			}
			catch (Exception e)
			{
				Console.WriteLine( e.Message + "\nFailed to cancel subscription " + si.SubscriptionId + " for user " + user.gamertag);
				return false;
			}
			return true;
		}

/*		
		bool CreateIncompleteSPSSubscription( CUser user)
		{
			SubscriptionInfoSetSubscriptionInfo si	= null;
			ArrayList	rgSubscriptions = null;

			GetSPSSubscriptions( user, out rgSubscriptions);
			if (rgSubscriptions.Count == 0)
			{
				Console.WriteLine( "There are no subscriptions for user " + user.gamertag);
				return false;
			}
			si = (SubscriptionInfoSetSubscriptionInfo) rgSubscriptions[0];
			// cancel?
			return true;
		}
*/		
		bool CreateUnmatchedUODBAccount( CUser user)
		{
			string strSQL = "UPDATE t_users SET vc_billing_account_id = '0QAAAAAAAAAABE' WHERE bi_owner_puid = " + user.ownerPuid;

			ExecuteUODBSQL( strSQL);
			return true;
		}

		bool CreateUnmatchedUODBPayment( CUser user)
		{
			string strSQL = "UPDATE t_users SET vc_billing_payinfo_id = '0QAAAAAAAAAABE' WHERE bi_owner_puid = " + user.ownerPuid;

			ExecuteUODBSQL( strSQL);
			return true;
		}

		bool CreateIncompleteUODBSubscription( CUser user)
		{
			SubscriptionInfoSetSubscriptionInfo si	= null;
			ArrayList	rgSubscriptions = null;
			string		strSQL = null;

			GetSPSSubscriptions( user, out rgSubscriptions);
			if (rgSubscriptions.Count == 0)
			{
				Console.WriteLine( "There are no subscriptions for user " + user.gamertag);
				return false;
			}
			si = (SubscriptionInfoSetSubscriptionInfo) rgSubscriptions[0];
			strSQL = "UPDATE t_subscriptions\r\n SET i_transaction_flags = (i_transaction_flags | (0x4))\r\n " + 
				"WHERE vc_svc_instance_id = '" + si.ServiceInstanceSet[0].ServiceInstanceId + "'";
			ExecuteUODBSQL( strSQL);
			return true;
		}

		bool CreatePremiumSubscription( CUser user, bool fUODB, bool fSPS)
		{
			// create Premium subscription in UODB
			// if fIncomplete == true - don't purchase it in SPS
			// if fIncomplete == false -purchase it in SPS, then mark it as incomplete in UODB
			
			bool			fRet	= true;
			string			strSQL	= null;
			int				iHash	= 0;
			SqlDataReader	sr		= null;
			int				iServer	= 0;
			string			strId	= null;

			// retrieve hash_bucket
			strSQL = "SELECT si_hash_bucket FROM t_users WHERE bi_user_puid = " + user.ownerPuid;
			sr = ExecuteUODBSQL( strSQL, false, ref iServer);
			if (null != sr)
			{
				iHash = sr.GetInt16(0);
				sr.Close();
			}
			
			if (fUODB)
			{
				strSQL =
					"INSERT INTO t_subscriptions " + 
					"(bi_primary_puid, bi_offer_id, i_instances, vc_svc_instance_id, i_puid_is_machine, dt_start_date, " +
					"dt_end_date, i_subscription_status_id, i_transaction_flags, si_hash_bucket) " +
					"VALUES (" + user.ownerPuid + ", 6362460395042504711, 1, '$XBOX!USER" + user.ownerPuid.ToString().Substring(0,6) +
					"', 0, GETDATE(), GETDATE(), 0, 0x4, " + iHash + ")";
				fRet = (null != ExecuteUODBSQL( strSQL, false, ref iServer));
			}
			if (fRet && fSPS)
			{
				SubscriptionInfoSetSubscriptionInfo si = new SubscriptionInfoSetSubscriptionInfo();
				// PSO subscription
				si.SubscriptionId	= "";
				si.OfferingGUID		= "9877BFF1-0CFB-40A1-AA96-89C0C7FA7191";
				si.SubscriptionDescription = "PSO Episode 1 & 2 Hunter's License";
				si.SubscriptionPriceDescription = "Xbox Premium Subscription|PSO Episode 1 & 2 Hunter's License|US $5 Monthly|Plus Applicable Taxes||";
				si.InternalSubscriptionDescription = "XBX-10057 PSO Episode 1&amp;2 Hunter's license (5.00/mth, USD)";
				si.FriendlyName		= "PSO Episode 1 & 2 Hunter's License";
				si.ShippingAddressId= "";	// use default
				si.PurchaseDate		= DateTime.Now.ToShortDateString();
				si.ActivationDate	= si.PurchaseDate;
				si.EndDate			= "01/01/2099";
				si.PaymentInstrumentId = user.payinfo;
				
				fRet = PurchaseOffering( user, ref si);
				
				strId = (null != si.ServiceInstanceSet && si.ServiceInstanceSet.Length > 0)? 
					si.ServiceInstanceSet[0].ServiceInstanceId : "";
				if (fRet)
				{
					strSQL = "UPDATE t_subscriptions SET i_transaction_flags = i_transaction_flags | 0x4 " + 
						", vc_svc_instance_id = '" + strId + "' " +
						"WHERE bi_primary_puid = " + user.ownerPuid + " AND bi_offer_id = 6362460395042504711";
					fRet = (null != ExecuteUODBSQL( strSQL, false, ref iServer));
				}
			}
			
			return fRet;
		}
		public string CreatePremiumSubscriptionEx(CUser user, int enabled)
		{
			bool			fRet	= true;
			string			strSQL	= null;
			int				iHash	= 0;
			SqlDataReader	sr		= null;
			int				iServer	= 0;
			string			strId	= null;

			// Step 1 - Create SPS Premium Subscription		
			//
			SubscriptionInfoSetSubscriptionInfo si = new SubscriptionInfoSetSubscriptionInfo();
			// PSO subscription
			si.SubscriptionId	= "";
			si.OfferingGUID		= "9877BFF1-0CFB-40A1-AA96-89C0C7FA7191";
			si.SubscriptionDescription = "PSO Episode 1 & 2 Hunter's License";
			si.SubscriptionPriceDescription = "Xbox Premium Subscription|PSO Episode 1 & 2 Hunter's License|US $5 Monthly|Plus Applicable Taxes||";
			si.InternalSubscriptionDescription = "XBX-10057 PSO Episode 1&amp;2 Hunter's license (5.00/mth, USD)";
			si.FriendlyName		= "PSO Episode 1 & 2 Hunter's License";
			si.ShippingAddressId= "";	// use default
			si.PurchaseDate		= DateTime.Now.ToShortDateString();
			si.ActivationDate	= si.PurchaseDate;
			si.EndDate			= "01/01/2099";
			si.PaymentInstrumentId = user.payinfo;
	
			fRet = PurchaseOffering( user, ref si);
	
			strId = (null != si.ServiceInstanceSet && si.ServiceInstanceSet.Length > 0)? 
				si.ServiceInstanceSet[0].ServiceInstanceId : "";
			
			// Step 2 - Insert new subscription in UODB
			//
			if (fRet)
			{
				// retrieve hash_bucket
				strSQL = "SELECT si_hash_bucket FROM t_users WHERE bi_user_puid = " + user.ownerPuid;
				sr = ExecuteUODBSQL( strSQL, false, ref iServer);
				if (null != sr)
				{
					iHash = sr.GetInt16(0);
					sr.Close();
				}

				strSQL =
					"INSERT INTO t_subscriptions " + 
					"(bi_primary_puid, bi_offer_id, i_instances, vc_svc_instance_id, i_puid_is_machine, dt_start_date, " +
					"dt_end_date, i_subscription_status_id, i_transaction_flags, si_hash_bucket) " +
					"VALUES (" + user.ownerPuid + ", 6362460395042504711, 1, '" + strId + "'" +
					", 0, GETDATE(), GETDATE(), " + enabled.ToString() + ", 1, " + iHash + ")";
				fRet = (null != ExecuteUODBSQL( strSQL, false, ref iServer));
			}						

			return strId;
		}
		
		bool CreateUnprovisionedSubscription( CUser user)
		{
			SubscriptionInfoSetSubscriptionInfo si	= null;
			ArrayList	rgSubscriptions = null;
			string		strSQL = null;

			GetSPSSubscriptions( user, out rgSubscriptions);
			if (rgSubscriptions.Count == 0)
			{
				Console.WriteLine( "There are no subscriptions for user " + user.gamertag);
				return false;
			}
			si = (SubscriptionInfoSetSubscriptionInfo) rgSubscriptions[0];
			strSQL = "UPDATE t_subscriptions\r\n SET i_transaction_flags = (i_transaction_flags | (0x1))\r\n " + 
				"WHERE vc_svc_instance_id = '" + si.ServiceInstanceSet[0].ServiceInstanceId + "' AND bi_primary_puid = " +
				user.ownerPuid;
			ExecuteUODBSQL( strSQL);
			return true;
		}
		
		bool CreateQueuedSubscription( CUser user)
		{
			SubscriptionInfoSetSubscriptionInfo si	= null;
			ArrayList	rgSubscriptions = null;
			string		strSQL = null;
			int			iServer = 0;
			bool		fRet = true;

			GetSPSSubscriptions( user, out rgSubscriptions);
			if (rgSubscriptions.Count == 0)
			{
				Console.WriteLine( "There are no subscriptions for user " + user.gamertag);
				return false;
			}
			si = (SubscriptionInfoSetSubscriptionInfo) rgSubscriptions[0];
			strSQL = "UPDATE t_subscriptions\r\n SET vc_svc_instance_id = '$XBOX!USER" + 
				user.gamertag.Substring( 0, 6) + "',\r\n " + 
				"i_transaction_flags = ((i_transaction_flags | 0x1) & 0xfffffffB) \r\n" +
				"WHERE bi_primary_puid = " + user.ownerPuid.ToString();
			fRet = (null != ExecuteUODBSQL( strSQL, false, ref iServer));
			if (fRet)
			{
				strSQL = "UPDATE t_users\r\n SET vc_billing_account_id = '$XBOX!USER" + 
					user.gamertag.Substring( 0, 6) + "'\r\n, vc_billing_payinfo_id = '$XBOX!USER" +
					user.gamertag.Substring( 0, 6) + "'\r\n WHERE bi_owner_puid = " + 
					user.ownerPuid.ToString();
				fRet = (null != ExecuteUODBSQL( strSQL, false, ref iServer));
			}
			return fRet;
		}

		bool CreateUODBSubscription( CUser user)
		{
			SubscriptionInfoSetSubscriptionInfo si	= null;
			ArrayList	rgSubscriptions = null;
			string		strSQL = null;

			GetSPSSubscriptions( user, out rgSubscriptions);
			if (rgSubscriptions.Count == 0)
			{
				Console.WriteLine( "There are no subscriptions for user " + user.gamertag);
				return false;
			}

			si = (SubscriptionInfoSetSubscriptionInfo) rgSubscriptions[0];
			strSQL = "UPDATE t_subscriptions\r\n SET vc_svc_instance_id = '0QAAAAAAAAAA'\r\n " + 
				"WHERE vc_svc_instance_id = '" + si.ServiceInstanceSet[0].ServiceInstanceId + 
				"' AND bi_primary_puid = " + user.ownerPuid.ToString();
			ExecuteUODBSQL( strSQL);
			return true;
		}

		bool CancelUODBSubscription( CUser user)
		{
			SubscriptionInfoSetSubscriptionInfo si = null;
			ArrayList	rgSubs	= null;
			string		strSQL	= null;

			GetSPSSubscriptions( user, out rgSubs);
			if (0 == rgSubs.Count)
			{
				Console.WriteLine( "There are no subscriptions for user " + user.gamertag);
				return false;
			}

			si = (SubscriptionInfoSetSubscriptionInfo) rgSubs[0];
			if (null == si.ServiceInstanceSet || 0 == si.ServiceInstanceSet.Length)
			{
				Console.WriteLine( "There are no service instance ids for subscription " + si.FriendlyName + 
					" for user " + user.gamertag);
				return false;
			}
			strSQL = "UPDATE t_subscriptions\r\nSET i_subscription_status_id = 4\r\nWHERE vc_svc_instance_id = '" +
				si.ServiceInstanceSet[0].ServiceInstanceId + "' AND bi_primary_puid = " + user.ownerPuid.ToString();
			ExecuteUODBSQL( strSQL);
			return true;
		}

		bool GetUODBAccountInfo( string strPUID, out CAccountInfo ai)
		{
			ai = null;
			foreach ( string strServer in _servers)
			{
				SqlConnection sqlcon = new SqlConnection("server=" + strServer + ";trusted_connection=true;database=uodb");
				sqlcon.Open();
        
				SqlCommand cmd = new SqlCommand( "p_xuacs_get_user_acct", sqlcon);
				cmd.CommandType = CommandType.StoredProcedure;
				SqlParameter sqlPar = cmd.Parameters.Add("@bi_user_puid", strPUID);

				sqlPar = new SqlParameter( "@bi_owner_puid", SqlDbType.BigInt);
				sqlPar.Direction = ParameterDirection.Output;
				cmd.Parameters.Add( sqlPar);
				sqlPar = new SqlParameter( "@ti_country_id", SqlDbType.TinyInt);
				sqlPar.Direction = ParameterDirection.Output;
				cmd.Parameters.Add( sqlPar);
				sqlPar = new SqlParameter( "@vc_billing_account_id", SqlDbType.NVarChar, 255);
				sqlPar.Direction = ParameterDirection.Output;
				cmd.Parameters.Add( sqlPar);
				sqlPar = new SqlParameter( "@vc_billing_payinfo_id", SqlDbType.NVarChar, 255);
				sqlPar.Direction = ParameterDirection.Output;
				cmd.Parameters.Add( sqlPar);
				sqlPar = new SqlParameter( "@vc_nickname", SqlDbType.NVarChar, 16);
				sqlPar.Direction = ParameterDirection.Output;
				cmd.Parameters.Add( sqlPar);
				sqlPar = new SqlParameter( "@dt_birthdate", SqlDbType.DateTime);
				sqlPar.Direction = ParameterDirection.Output;
				cmd.Parameters.Add( sqlPar);
				sqlPar = new SqlParameter( "@i_acct_status_id", SqlDbType.Int);
				sqlPar.Direction = ParameterDirection.Output;
				cmd.Parameters.Add( sqlPar);
				sqlPar = new SqlParameter( "@si_ticket_flags", SqlDbType.SmallInt);
				sqlPar.Direction = ParameterDirection.Output;
				cmd.Parameters.Add( sqlPar);
				sqlPar = new SqlParameter( "@si_user_flags", SqlDbType.SmallInt);
				sqlPar.Direction = ParameterDirection.Output;
				cmd.Parameters.Add( sqlPar);
				sqlPar = new SqlParameter( "@dt_acct_resume_date", SqlDbType.DateTime);
				sqlPar.Direction = ParameterDirection.Output;
				cmd.Parameters.Add( sqlPar);
				sqlPar = new SqlParameter( "@i_suspension_length", SqlDbType.Int);
				sqlPar.Direction = ParameterDirection.Output;
				cmd.Parameters.Add( sqlPar);
				sqlPar = new SqlParameter( "@dt_voice_resume_date", SqlDbType.DateTime);
				sqlPar.Direction = ParameterDirection.Output;
				cmd.Parameters.Add( sqlPar);
				sqlPar = new SqlParameter( "@i_voice_ban_length", SqlDbType.Int);
				sqlPar.Direction = ParameterDirection.Output;
				cmd.Parameters.Add( sqlPar);
				sqlPar = new SqlParameter( "@ti_name_change_required", SqlDbType.TinyInt);
				sqlPar.Direction = ParameterDirection.Output;
				cmd.Parameters.Add( sqlPar);
				sqlPar = new SqlParameter( "@dt_accepted_tos", SqlDbType.DateTime);
				sqlPar.Direction = ParameterDirection.Output;
				cmd.Parameters.Add( sqlPar);
				sqlPar = new SqlParameter( "@dt_reset_date", SqlDbType.DateTime);
				sqlPar.Direction = ParameterDirection.Output;
				cmd.Parameters.Add( sqlPar);
				sqlPar = new SqlParameter( "@i_billing_account_status", SqlDbType.Int);
				sqlPar.Direction = ParameterDirection.Output;
				cmd.Parameters.Add( sqlPar);
				sqlPar = new SqlParameter( "@bin_acct_pin", SqlDbType.Binary, 4);
				sqlPar.Direction = ParameterDirection.Output;
				cmd.Parameters.Add( sqlPar);
				sqlPar = new SqlParameter( "@ti_accept_msspam", SqlDbType.TinyInt);
				sqlPar.Direction = ParameterDirection.Output;
				cmd.Parameters.Add( sqlPar);
				sqlPar = new SqlParameter( "@ti_accept_partnerspam", SqlDbType.TinyInt);
				sqlPar.Direction = ParameterDirection.Output;
				cmd.Parameters.Add( sqlPar);
				sqlPar = new SqlParameter( "@dt_change_datetime", SqlDbType.DateTime);
				sqlPar.Direction = ParameterDirection.Output;
				cmd.Parameters.Add( sqlPar);

                // since sproc returns results in parameters, use executeScalar
				cmd.ExecuteScalar();

				if (DBNull.Value != cmd.Parameters["@bi_owner_puid"].Value)
				{
					ai = new CAccountInfo();
					// read parameters
					ai.bi_owner_puid			= (long)cmd.Parameters["@bi_owner_puid"].Value;
					ai.ti_country_id			= (byte)cmd.Parameters["@ti_country_id"].Value;
					ai.vc_billing_account_id	= (string)cmd.Parameters["@vc_billing_account_id"].Value;
					ai.vc_billing_payinfo_id	= (string)cmd.Parameters["@vc_billing_payinfo_id"].Value;
					ai.vc_nickname				= (string)cmd.Parameters["@vc_nickname"].Value;
					ai.dt_birthdate				= (DateTime)cmd.Parameters["@dt_birthdate"].Value;
					ai.i_acct_status_id			= (int)cmd.Parameters["@i_acct_status_id"].Value;
					ai.si_ticket_flags			= Convert.ToInt32(cmd.Parameters["@si_ticket_flags"].Value);
					ai.si_user_flags			= Convert.ToInt32(cmd.Parameters["@si_user_flags"].Value);
					ai.dt_acct_resume_date		= (DateTime)cmd.Parameters["@dt_acct_resume_date"].Value;
					ai.i_suspension_length		= (int)cmd.Parameters["@i_suspension_length"].Value;
					ai.dt_voice_resume_date		= (DateTime)cmd.Parameters["@dt_voice_resume_date"].Value;
					ai.i_voice_ban_length		= (int)cmd.Parameters["@i_voice_ban_length"].Value;
					ai.ti_name_change_required	= (byte)cmd.Parameters["@ti_name_change_required"].Value;
					ai.dt_accepted_tos			= (DateTime)cmd.Parameters["@dt_accepted_tos"].Value;
					ai.dt_reset_date			= (DateTime)cmd.Parameters["@dt_reset_date"].Value;
					ai.i_billing_account_status	= (int)cmd.Parameters["@i_billing_account_status"].Value;
					ai.bin_acct_pin				= (byte[])cmd.Parameters["@bin_acct_pin"].Value;
					ai.ti_accept_msspam			= (byte)cmd.Parameters["@ti_accept_msspam"].Value;
					ai.ti_accept_partnerspam	= (byte)cmd.Parameters["@ti_accept_partnerspam"].Value;
					ai.dt_change_datetime		= (DateTime)cmd.Parameters["@dt_change_datetime"].Value;

					return true;
				}
			}
			return false;
		}

		public bool GetSPSAccounts(CUser user, out ArrayList rgAccounts)
		{
			/*
				[in]  LONG lDelegateIdHigh,
				[in]  LONG lDelegateIdLow,
				[in]  LONG lSearchPUIDHigh,
				[in]  LONG lSearchPUIDLow,
				[in]  VARIANT_BOOL fFullData,
				[in]  LONG lMax,
				[out] BSTR *pbstrResultXML,
				[out] LONG *pfMoreRows,
				[out] LONG *plAccountInfoCount,
				[out] BSTR *pbstrAccountInfoSetXML
			*/
			int high = (int)(user.ownerPuid >> 32);
			int low  = (int)(user.ownerPuid & 0xFFFFFFFF);
			string result = "";
			int moreRows = 0;
			int numAccounts = 0;
			string accountSet = "";

			rgAccounts = new ArrayList();

			AccountInfoSet aiSet = null;
			try
			{
				_sps.GetAccountIdFromAdminPUID(
					0
					,   0				//delegates can be 0
					,   high
					,   low				//the OWNER puid
					,   true			//we only need account string
					,   25				//the max of the max results
					,   out result		//if there are errors we will know here
					,   out moreRows	//0 if there were < than 25.  1 if we need to call again
					,   out numAccounts //how many accounts we retrieved
					,   out accountSet	//all the info about the accounts
					);
			}
			catch (Exception e)
			{
				Console.WriteLine( e.Message + "\nFailed to retrieve AccountInfo for user " + user.gamertag);
				return false;
			}

			accountSet = "<?xml version=\"1.0\" encoding=\"UTF-16\" ?>\n" + accountSet;
			//check result for error

			//check moreRows for excessive number of accounts
			if (moreRows == 1)
			{
				Console.WriteLine("User " + user.gamertag + " has more than 25 accounts in sps.");
			}
			try
			{
				//add each account from accountSet to rAccounts
				XmlSerializer serializer = new XmlSerializer(typeof(BatmanTest.AccountInfoSet));
				aiSet = new AccountInfoSet();

				byte[] xmlData = new byte[accountSet.Length * 4];
				UnicodeEncoding aEnc = new UnicodeEncoding();
				aEnc.GetBytes(accountSet, 0, accountSet.Length, xmlData, 0);

				MemoryStream ms = new MemoryStream(xmlData);
				aiSet = (AccountInfoSet)serializer.Deserialize(ms);
				if (aiSet.AccountInfo == null)
				{
					return false;
				}
			}
			catch (Exception e)
			{
				Console.WriteLine( e.Message + "\nFailed to parse AccountInfoSetXML for user " + user.gamertag);
				return false;
			}



			foreach(AccountInfo ai in aiSet.AccountInfo)
			{
				rgAccounts.Add(ai);
			}

			return true;
		}

		public CUser ParseUser( string strLine)
		{
			// batman1 , 2569464430260347
			string[]		rgszParts	= strLine.Split(',');
			CUser			user		= new CUser();
			CAccountInfo	ai			= null;
			
			GetUODBAccountInfo( rgszParts[1], out ai);
			
			user.gamertag	= rgszParts[0].Trim();
			user.ownerPuid	= Convert.ToInt64( rgszParts[1]);
			user.account	= ai.vc_billing_account_id;
			user.payinfo	= ai.vc_billing_payinfo_id;
			
			return user;
		}

		public bool GetPaymentInfos(CUser user, out ArrayList rPaymentInfos)
		{
			rPaymentInfos = new ArrayList();

			/*
				[in]  LONG lDelegateIdHigh,
				[in]  LONG lDelegateIdLow,
				[in]  LONG lRequesterIdHigh,
				[in]  LONG lRequestedIdLow,
				[in]  BSTR bstrObjectId,
				[out] BSTR *pbstrResultXML,
				[out] LONG *plPaymentInstrumentInfoCount,
				[out] BSTR *pbstrPaymentInstrumentInfoSetXML
			*/

			string result = "";

			int high = (int)(user.ownerPuid >> 32);
			int low  = (int)(user.ownerPuid & 0xFFFFFFFF);
            
			int count = 0;
			string xmlset = "";
			PaymentInstrumentInfoSet piSet = null;
    
			try
			{
				_sps.GetPaymentInstruments(
					0
					,   0
					,   high
					,   low //owner puid
					,   user.account
					,   out result //errors go here
					,   out count //how many PIs
					,   out xmlset //the actual PI info
					);
			}
			catch (Exception e)
			{
				Console.WriteLine( e.Message + "\nFailed to retrieve PaymentInstruments for user " + user.gamertag);
				return false;
			}

			xmlset = "<?xml version=\"1.0\" encoding=\"UTF-16\" ?>\n" + xmlset;
			//check result
			//as it turns out an error will be thrown if there is a problem

			try
			{
				//put xmlset into rPaymentInfos
				XmlSerializer serializer = new XmlSerializer(typeof(BatmanTest.PaymentInstrumentInfoSet));
				piSet = new PaymentInstrumentInfoSet();

				byte[] xmlData = new byte[xmlset.Length * 4];
				UnicodeEncoding aEnc = new  UnicodeEncoding();
				aEnc.GetBytes(xmlset, 0, xmlset.Length, xmlData, 0);

				MemoryStream ms = new MemoryStream(xmlData);
				piSet = (PaymentInstrumentInfoSet)serializer.Deserialize(ms);
			
				if (piSet.PaymentInstrumentInfo == null)
				{
					Console.WriteLine("User " + user.gamertag + " has no payment infos");
					return false;
				}
			}
			catch (Exception e)
			{
				Console.WriteLine( e.Message + "\nFailed to parse PaymentInstrumentInfoSetXML for user " + user.gamertag);
				return false;
			}


			foreach(PaymentInstrumentInfoSetPaymentInstrumentInfo pii in piSet.PaymentInstrumentInfo)
			{
				rPaymentInfos.Add(pii);
			}
			return true;
		}

		public bool CreateSPSAccount(CUser user, AccountInfo ai, PaymentInstrumentInfoSetPaymentInstrumentInfo pi)
		{
			/*
				[in]  LONG lDelegateIdHigh,
				[in]  LONG lDelegateIdLow,
				[in]  LONG lSearchPUIDHigh,
				[in]  LONG lSearchPUIDLow,
				[in]  VARIANT_BOOL fFullData,
				[in]  LONG lMax,
				[out] BSTR *pbstrResultXML,
				[out] LONG *pfMoreRows,
				[out] LONG *plAccountInfoCount,
				[out] BSTR *pbstrAccountInfoSetXML
			*/
			int high = (int)(user.ownerPuid >> 32);
			int low  = (int)(user.ownerPuid & 0xFFFFFFFF);
			string strResult = null;
			string strAcctId = null;
			string strPIId	 = null;
			string strDate	 = null;
			string strReqPaperWorkURL = null;

			string strGuid		= Guid.NewGuid().ToString();
			string strAIXML		= null;
			string strPayXML	= null;

			try
			{
				// AccountInfo -> XML
				XmlSerializer serializer = new XmlSerializer(typeof(BatmanTest.AccountInfo));
				StringWriter sw = new StringWriter();
				serializer.Serialize(sw, ai);
				strAIXML = sw.ToString();
				sw.Close();

				// PaymentInfo -> XML
				serializer = new XmlSerializer( typeof(BatmanTest.PaymentInstrumentInfoSetPaymentInstrumentInfo));
				sw = new StringWriter();
				serializer.Serialize( sw, pi);
				strPayXML = sw.ToString().Replace( "PaymentInstrumentInfoSetPaymentInstrumentInfo", "PaymentInstrumentInfo");
				strPayXML = strPayXML.Replace( "<PaymentInstrumentInfo ", "<PaymentInstrumentInfo xmlns=\"urn:schemas-microsoft-com:billing-data\" ");
			}			
			catch (Exception e)
			{
				Console.WriteLine( e.Message + "\nFailed to serialize AccountInfo or PaymentInstrumentInfo into XML for user " + user.gamertag);
				return false;
			}

			try
			{
				_sps.CreateAccount( 
					0, 
					0,					// delegates can be 0
					high,
					low,				// the OWNER puid
					"XBox Live",		// bstrPPMemberName
					strGuid,			// guid
					strAIXML,			// AccountInfoXML
					strPayXML,			// PaymentInstrumentInfoXML
					out strResult,		// if there are errors we will know here
					out strAcctId,		// AccountId
					out strPIId,		// PaymentInstrumentId
					out strDate,		// CreatedDate
					out strReqPaperWorkURL
					);
			}
			catch (Exception e)
			{
				Console.WriteLine( e.Message + "\nFailed to add new Account for user " + user.gamertag);
				return false;
			}

			if (strAcctId.Length == 0)
			{
				return false;
			}
//			if (_debug)
//			{
//				Console.WriteLine("Result:\r\n" + strResult + "\r\nNew AccountId\t\t" + strAcctId + 
//					"\r\nNew PaymentInstrumentId\t" + strPIId + "\r\nDate\t\t\t" + strDate + "\r\nPaperWorkURL\t\t" + strReqPaperWorkURL);
//			}
			
			return true;
		}

		public bool CreateUODBAccount( ref CUser user)
		{
			// get new PUID, update puid for an account, update billing, payment and svc_instance ids
			long	lNewPUID = 0;
			bool	fRet	 = true;
			string	strSQL	 = null;
			
			// get hash
			SqlDataReader	sr		= null;
			int				iServer	= 0;

			// retrieve hash_bucket
			strSQL = "SELECT si_hash_bucket FROM t_users WHERE bi_user_puid = " + user.ownerPuid;
			sr = ExecuteUODBSQL( strSQL, false, ref iServer);
			if (null != sr)
			{
				user.hash = sr.GetInt16(0);
				sr.Close();
			}

			// get new PUID
			try
			{
				SqlConnection con = new SqlConnection("server=" + (string)_servers[iServer] + ";trusted_connection=true;database=uodb");
				con.Open();
				
				SqlCommand cmd = new SqlCommand( "p_puid_get_next_id", con);
				cmd.CommandType = CommandType.StoredProcedure;
				// @i_bucket_id			int
				SqlParameter param = new SqlParameter( "@i_bucket_id", SqlDbType.Int);
				param.Value = user.hash;
				cmd.Parameters.Add( param);
				// @i_req_block_size	int
				param = new SqlParameter( "@i_req_block_size", SqlDbType.Int);
				param.Value = 1;
				cmd.Parameters.Add( param);
				// @bi_next_id			bigint OUTPUT
				param = new SqlParameter( "@bi_next_id", SqlDbType.BigInt);
				param.Direction = ParameterDirection.Output;
				cmd.Parameters.Add( param);
				
				SqlDataReader reader = cmd.ExecuteReader();
				lNewPUID = (long)cmd.Parameters["@bi_next_id"].Value;

				con.Close();
			}
			catch(Exception e)
			{
				Console.WriteLine( e.Message + "\nError executing p_puid_get_next_id against " + (string)_servers[0]);
				return false;
			}

			// update t_users
			strSQL = "UPDATE t_users SET bi_user_puid = " + lNewPUID + ", bi_owner_puid = " + lNewPUID + 
				", vc_billing_account_id = N'', vc_billing_payinfo_id = N'' WHERE bi_user_puid = " + user.ownerPuid;
			fRet = fRet && (null != ExecuteUODBSQL( strSQL, false, ref iServer));
			// update t_user_names
			//strSQL = "UPDATE t_user_names SET bi_user_puid = " + lNewPUID + " WHERE bi_user_puid = " + user.ownerPuid;
			//fRet = fRet && (null != ExecuteUODBSQL( strSQL, false, ref iServer));
			// update t_subscriptions
			strSQL = "UPDATE t_subscriptions SET bi_primary_puid = " + lNewPUID + 
				", vc_svc_instance_id = N'' WHERE bi_primary_puid = " + user.ownerPuid;
			fRet = fRet && (null != ExecuteUODBSQL( strSQL, false, ref iServer));

			// update user's ownerPuid
			user.puid = user.ownerPuid;
			user.ownerPuid = lNewPUID;

			return fRet;
		}

		public bool UpdateAccountInfo( CUser user, AccountInfo ai)
		{
			/*
				[in]  LONG lDelegateIdHigh,
				[in]  LONG lDelegateIdLow,
				[in]  LONG lRequesterIdHigh,
				[in]  LONG lRequestedIdLow,
				[in]  BSTR bstrAccountId,
				[in]  BSTR bstrAccountInfoXML,
				[out] BSTR *pbstrResultXML,
				[out] BSTR *pbstrRequiredPaperWorkURL
			*/
			int		iHi				= (int)(user.ownerPuid >> 32);
			int		iLow			= (int)(user.ownerPuid & 0xFFFFFFFF);
			string	strAIXML		= null;
			string	strResult		= null;
			string	strPaperWorkURL	= null;

			try
			{
				// AccountInfo -> XML
				XmlSerializer serializer = new XmlSerializer(typeof(BatmanTest.AccountInfo));
				StringWriter sw = new StringWriter();
				serializer.Serialize(sw, ai);
				strAIXML = sw.ToString();
				sw.Close();
			}			
			catch (Exception e)
			{
				Console.WriteLine( e.Message + "\nFailed to serialize AccountInfo into XML for user " + user.gamertag);
				return false;
			}

			try
			{
				_sps.UpdateAccountInfo(
					0,
					0,					// delegate can be 0
					iHi,
					iLow,				// Owner PUID
					user.account,		// vc_billing_id
					strAIXML,			// AccountInfoXML
					out strResult,		// was there an error?
					out strPaperWorkURL
					);
			}			
			catch (Exception e)
			{
				Console.WriteLine( e.Message + "\nFailed to update AccountInfo for user " + user.gamertag);
				return false;
			}

			return true;
		}

		public bool GetSPSSubscriptions( CUser user, out ArrayList rgSubscriptions)
		{
			/*
				[in]  LONG lDelegateIdHigh,
				[in]  LONG lDelegateIdLow,
				[in]  LONG lRequesterIdHigh,
				[in]  LONG lRequesterIdLow,
				[in]  BSTR bstrObjectId,
				[out] BSTR *pbstrResultXML,
				[out] LONG *lpSubscriptionInfoCount,
				[out] BSTR *pbstrSubscriptionInfoSetXML
			*/
			int		iHi			= (int)(user.ownerPuid >> 32);
			int		iLow		= (int)(user.ownerPuid & 0xFFFFFFFF);
            string	strResultXML= null;
			int		iCount		= 0;
			string	strSIXML	= null;

			SubscriptionInfoSet sis = null;
			rgSubscriptions = new ArrayList();

			try
			{
				_sps.GetSubscriptions(
					0,
					0,					//delegate
					iHi,
					iLow,				//owner puid
					user.account,		// vc_billing_id 
					out strResultXML,	//errors go here
					out iCount,			//how many subscriptions
					out strSIXML		//the actual subscription info
					);
				if (strSIXML.Length == 0)
				{
					Console.WriteLine( "Subscription not found for user " + user.gamertag);
					return false;
				}
			}
			catch (Exception e)
			{
				Console.WriteLine( e.Message + "\nError while trying to retrieve subscriptions for user " + user.gamertag);
				return false;
			}

			try
			{
				// XML -> SubscriptionInfoSet
				XmlSerializer serializer = new XmlSerializer(typeof(SubscriptionInfoSet));
				StringReader  sr = new StringReader( strSIXML);
				sis = (SubscriptionInfoSet) serializer.Deserialize( sr);
			}
			catch (Exception e)
			{
				Console.WriteLine( e.Message + "\nFailed to deserialize SubscriptionInfoSetXML for user " + user.gamertag);
				return false;
			}
			
			foreach (SubscriptionInfoSetSubscriptionInfo si in sis.SubscriptionInfo)
			{
				rgSubscriptions.Add( si);
			}

			return true; 
		}

		bool PurchaseOffering( CUser user, ref SubscriptionInfoSetSubscriptionInfo si)
		{
			/*
				[in]  LONG lDelegateIdHigh,
				[in]  LONG lDelegateIdLow,
				[in]  LONG lRequesterIdHigh,
				[in]  LONG lRequesterIdLow,
				[in]  BSTR bstrTrackingGUID,
				[in]  VARIANT_BOOL fComputeOnly,
				[in]  BSTR bstrSubscriptionName,
				[in]  BSTR bstrAccountId,
				[in]  BSTR bstrBaseSubscriptionId,
				[in]  BSTR bstrOfferingGUID,
				[in]  LONG lOverrideAmount,
				[in]  BSTR bstrPaymentInstrumentId,
				[in]  BSTR bstrShippingAddressId,
				[in]  BSTR bstrActivationDate,
				[in]  BSTR bstrSubscriptionEndDate,
				[in]  BSTR bstrReferralSetXML,
				[out] BSTR *pbstrResultXML,
				[out] BSTR *pbstrSubscriptionId,
				[out] BSTR *pbstrAmountChargedXML,
				[out] LONG *plAddedServiceInstanceCount,
				[out] BSTR *pbstrAddedServiceInstanceSetXML
			*/
			int		iHi			= (int)(user.ownerPuid >> 32);
			int		iLow		= (int)(user.ownerPuid & 0xFFFFFFFF);
			string	strGuid		= Guid.NewGuid().ToString();
			bool	fNoCommit	= false;
			
			string	strResultXML		= null;
			string	strSubscriptionId	= null;
			string	strAmtChargedXML	= null;
			int		iAddServiceInstCnt	= 0;
			string	strAddServiceInstSetXML = null;

			string	strServiceInstId	= null;
			
			try
			{
				/*Console.WriteLine( "_sps.PurchaseOffering( 1, 1, " + iHi + ", " + iLow + ", " + strGuid + ", " +
                    fNoCommit + ", " + si.FriendlyName + ", " + user.account + ", \"\", " + si.OfferingGUID + ", 0, " +
					si.PaymentInstrumentId + ", \"\", \"\", \"\", \"\", out strResultXML, out strSubscriptionId, " + 
					"out strAmtChargedXML, out iAddServiceInstCnt, out strAddServiceInstSetXML);");
				*/
				_sps.PurchaseOffering(
					1,
					1,							// delegate
					iHi,
					iLow,						// owner PUID
					strGuid,					// tracking Guid
					fNoCommit,					// fComputeOnly - no commit
					si.FriendlyName,			// friendly name
					user.account,				// vc_billing_id
					"",							// base subscription id, not implemented
					si.OfferingGUID,			
					0,							// override amount, not implemented
					si.PaymentInstrumentId,
					"",							// shipping address id, use default
					"",							// activation date, not implemented
					"",							// end date, not implemented
					"",							// referral set XML
					out strResultXML,			// is there an error?
					out strSubscriptionId,		// new subscription id
					out strAmtChargedXML,
					out iAddServiceInstCnt,		// added service instance count
					out strAddServiceInstSetXML	// added service instance set XML
					);
			}
			catch (Exception e)
			{
				Console.WriteLine( e.Message + "\nFailed to purchase new subscription for user " + user.gamertag);
				Console.WriteLine( strResultXML);
				Console.WriteLine( "iHi    = {0}\r\niLo    = {1}\r\nGuid   = {2}\r\nFrName = {3}\r\nAcctId = {4}\r\nPI     = {5}\r\nOffer  = {6}",
					iHi, iLow, strGuid, si.FriendlyName, user.account, si.PaymentInstrumentId, si.OfferingGUID);
				return false;
			}
			try
			{
				/*
					<ServiceInstanceSet xmlns="urn:schemas-microsoft-com:billing-data">
						<ServiceInstance>
							<ServiceInstanceId/>
							<ServiceComponentId/>
							<ConversionType/>
						</ServiceInstance>
					</ServiceInstanceSet>
				*/
				// add service instance set
				int iPos = strAddServiceInstSetXML.IndexOf( "<ServiceInstanceId>");
				if ( iPos >= 0 )
				{
					iPos += 19;	// "<ServiceInstanceId>".Length
					if ( (null == si.ServiceInstanceSet) || (0 == si.ServiceInstanceSet.Length) )
					{
						si.ServiceInstanceSet = new SubscriptionInfoSetSubscriptionInfoServiceInstance[1];
						si.ServiceInstanceSet[0] = new SubscriptionInfoSetSubscriptionInfoServiceInstance();
					}
					strServiceInstId = strAddServiceInstSetXML.Substring( iPos, 
						strAddServiceInstSetXML.IndexOf( "</ServiceInstanceId>") - iPos);
					si.ServiceInstanceSet[0].ServiceInstanceId = strServiceInstId;
				}
			}
			catch (Exception e)
			{
				Console.WriteLine( e.Message + "\nFailed to parse service instance id for user " + user.gamertag);
				Console.WriteLine( "XML = {0}\r\nSvcInstId = '{1}'", strAddServiceInstSetXML, strServiceInstId);
				return false;
			}
					
			return true;
		}

		public void CreateSubsOutsideDateRange(CUser user, DateTime dtChg)
		{
			// Purchase 2 additional subscriptions
			string instanceId1 = CreatePremiumSubscriptionEx(user,1);
			string instanceId2 = CreatePremiumSubscriptionEx(user,1);
			// Update UODB
			string		strSQL	= null;			
						
			// update t_users
			strSQL = "UPDATE t_users SET t_users.dt_Change_datetime = '" + dtChg.ToShortDateString() + 
				"' WHERE t_users.bi_user_puid = " + user.ownerPuid + "";			
			ExecuteUODBSQL( strSQL);
		
			// update t_subscriptions
			DateTime pastDate = dtChg.AddYears(-1);
			DateTime futureDate = dtChg.AddYears(+1);
			// Set subscription to date - 1 year
			strSQL = "UPDATE t_subscriptions SET t_subscriptions.dt_Change_datetime = '" + pastDate.ToShortDateString() +
				"' WHERE t_subscriptions.bi_primary_puid = " + user.ownerPuid + " AND " +
				"t_subscriptions.vc_svc_instance_id = '" + instanceId1 + "'";			
			ExecuteUODBSQL( strSQL);

			// Set subscription to date + 1 year
			strSQL = "UPDATE t_subscriptions SET t_subscriptions.dt_Change_datetime = '" + futureDate.ToShortDateString() +
				"' WHERE t_subscriptions.bi_primary_puid = " + user.ownerPuid + " AND " +
				"t_subscriptions.vc_svc_instance_id = '" + instanceId2 + "'";			
			ExecuteUODBSQL( strSQL);

			// Set subscription to date
			strSQL = "UPDATE t_subscriptions SET t_subscriptions.dt_Change_datetime = '" + dtChg.ToShortDateString() +
				"' WHERE t_subscriptions.bi_primary_puid = " + user.ownerPuid + " AND " +
				"t_subscriptions.vc_svc_instance_id != '" + instanceId1 + "' AND " +			
				"t_subscriptions.vc_svc_instance_id != '" + instanceId2 + "'";			
			ExecuteUODBSQL( strSQL);
		}		
		
		public void CreateSubsOutsideDateRangeMismatch(CUser user, DateTime dtChg)
		{
			// Purchase 2 additional subscriptions
			string instanceId1 = CreatePremiumSubscriptionEx(user,0);
			string instanceId2 = CreatePremiumSubscriptionEx(user,0);
			// Update UODB
			string		strSQL	= null;			
						
			// update t_users
			strSQL = "UPDATE t_users SET t_users.dt_Change_datetime = '" + dtChg.ToShortDateString() + 
				"' WHERE t_users.bi_user_puid = " + user.ownerPuid + "";			
			ExecuteUODBSQL( strSQL);
		
			// update t_subscriptions
			DateTime pastDate = dtChg.AddYears(-1);
			DateTime futureDate = dtChg.AddYears(+1);
			// Set subscription to date - 1 year
			strSQL = "UPDATE t_subscriptions SET t_subscriptions.dt_Change_datetime = '" + pastDate.ToShortDateString() +
				"' WHERE t_subscriptions.bi_primary_puid = " + user.ownerPuid + " AND " +
				"t_subscriptions.vc_svc_instance_id = '" + instanceId1 + "'";			
			ExecuteUODBSQL( strSQL);

			// Set subscription to date + 1 year
			strSQL = "UPDATE t_subscriptions SET t_subscriptions.dt_Change_datetime = '" + futureDate.ToShortDateString() +
				"' WHERE t_subscriptions.bi_primary_puid = " + user.ownerPuid + " AND " +
				"t_subscriptions.vc_svc_instance_id = '" + instanceId2 + "'";			
			ExecuteUODBSQL( strSQL);

			// Set subscription to date
			strSQL = "UPDATE t_subscriptions SET t_subscriptions.dt_Change_datetime = '" + dtChg.ToShortDateString() +
				"' WHERE t_subscriptions.bi_primary_puid = " + user.ownerPuid + " AND " +
				"t_subscriptions.vc_svc_instance_id != '" + instanceId1 + "' AND " +			
				"t_subscriptions.vc_svc_instance_id != '" + instanceId2 + "'";			
			ExecuteUODBSQL( strSQL);
		}

		public SqlDataReader ExecuteUODBSQL( string strSQL)
		{
			int iServer = 0;
			return ExecuteUODBSQL( strSQL, true, ref iServer);
		}



		public SqlDataReader ExecuteUODBSQL( string strSQL, bool fAll)
		{
			int iServer = 0;
			return ExecuteUODBSQL( strSQL, fAll, ref iServer);
		}

		public SqlDataReader ExecuteUODBSQL( string strSQL, bool fAll, ref int iServer)
		{
			string			strServer	= null;
			SqlDataReader	reader		= null;
			
			if (iServer < 0 || iServer > _servers.Count-1)
			{
				iServer = 0;
			}

			try
			{
				for ( ; iServer < _servers.Count; iServer++)
				{
					strServer = (string)_servers[iServer];
					
					SqlConnection con = new SqlConnection("server=" + strServer + ";trusted_connection=true;database=uodb");
					con.Open();
        
					SqlCommand cmd = new SqlCommand( strSQL, con);
					cmd.CommandType = CommandType.Text;
                
					reader = cmd.ExecuteReader();
					if (!fAll && reader.Read())
					{
						break;
					}
					con.Close();
				}
			}
			catch(Exception e)
			{
				Console.WriteLine( e.Message + "\nError executing " + strSQL + " against " + strServer);
			}
			return reader;
		}

		bool SkipRecoveryLines( StreamReader sr)
		{
			string strLine = null;

			while ("** User information ****" != (strLine = sr.ReadLine()))
				;
			return true;
		}

		bool SetChangeDateTime( ArrayList rgUsers, DateTime dtChg)
		{
			string		strSQL	= null;
			string		strList	= "";
			CUser		user	= null;

			// prepare list of puids
			for (int i = 0; i < rgUsers.Count; i++)
			{
				user = (CUser) rgUsers[i];
				strList += ", " + user.ownerPuid.ToString();
			}
			strList = strList.Substring( 2, strList.Length - 2);
			if (strList.Length < 2)
			{
				return false;
			}
			// update t_users
			strSQL = "UPDATE t_users SET t_users.dt_Change_datetime = '" + dtChg.ToShortDateString() + 
				"' WHERE t_users.bi_user_puid IN (" + strList + ")";
			Console.WriteLine( strSQL);
			if (null == ExecuteUODBSQL( strSQL))
			{
				return false;
			}
			// update t_subscriptions
			strSQL = "UPDATE t_subscriptions SET t_subscriptions.dt_Change_datetime = '" + dtChg.ToShortDateString() +
				"' WHERE t_subscriptions.bi_primary_puid IN (" + strList + ")";
			Console.WriteLine( strSQL);
			return (null != ExecuteUODBSQL( strSQL));
		}
	}

	class CAccountInfo
	{
		public long		bi_owner_puid;
		public byte		ti_country_id;
		public string	vc_billing_account_id;
		public string	vc_billing_payinfo_id;
		public string	vc_nickname;
		public DateTime	dt_birthdate;
		public int		i_acct_status_id;
		public int		si_ticket_flags;
		public int		si_user_flags;
		public DateTime dt_acct_resume_date;
		public int		i_suspension_length;
		public DateTime	dt_voice_resume_date;
		public int		i_voice_ban_length;
		public byte		ti_name_change_required;
		public DateTime	dt_accepted_tos;
		public DateTime	dt_reset_date;
		public int		i_billing_account_status;
		public byte[]	bin_acct_pin = new byte[4];
		public byte		ti_accept_msspam;
		public byte		ti_accept_partnerspam;
		public DateTime	dt_change_datetime;
	}

	// stipped down encapsulation of UODB t_users entry
	public class CUser
	{   
		public CUser()
		{
			puid = 0;
			account = null;
			ownerPuid = 0;
			gamertag = null;
			payinfo = null;
			subscriptions = new ArrayList();
			country = 0;
			hash = 0;
		}

		public long puid;
		public string account;
		public long ownerPuid;
		public ArrayList subscriptions;
		public string gamertag;
		public string payinfo;
		public string locale;
		public byte country;
		public int	hash;
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\StfTests\CMSBVT\ApprovalAssist.cs ===
using System;
using Microsoft.WebRunner;
using ServerTestFramework;
using System.Xml;
using System.Data;
using System.Data.SqlClient;
using System.IO;
using System.Collections;
using System.Net;
using System.Threading;
using System.ComponentModel;
using System.Diagnostics;
using System.Text;
using System.Resources;
using System.Reflection;
using System.Globalization;
using ServerTestFramework.Database;
using ServerTestFramework.LiveService.Notification;
using ServerTestFramework.LiveService.Presence;
using ServerTestFramework.LiveService.PresNotiCommon;
using ServerTestFramework.Utilities;


namespace WebFormNS
{
	/// <summary>
	
	public class ApprovalAssist
	{
		
		
		/// </summary>
		public static void ApprovalAssist1()
		{
			
			Console.WriteLine("Starting Approval Assistant");
			

			Helpers.XHTMLVal.SetCredentials(@"username="+Helpers.authUser+"&&password="+Helpers.authPass);
			Helpers.XHTMLVal.StartApplication(AppObj.IE, "url=http://auth.test.xbox.com/en-us");
			Helpers.XHTMLVal.FindIE("action=flexpage.aspx");
			Helpers.XHTMLVal.AttachTo(Win32Special.Window,"action=flexpage.aspx&&exactmatch=false");
			

			Helpers.XHTMLVal.Click(Win32UIObj.Link, "name=Switch To Edit Site&&id=SwitchToPresentationUnpublishedAnchor");
				
			Helpers.XHTMLVal.Click(Win32UIObj.Link, "name=Approval Assistant&&id=ApprovalAssistantAnchor&&exactmatch=false"); 
					//Helpers.XHTMLVal.Click(Win32UIObj.Link, "name=Approval Assistant&&value=http://auth.test.xbox.com/NR/exeres/D156AC5B-297F-49EC-A54E-084E1B07380F,frameless.htm?NRMODE=Unpublished&WBCMODE=PresentationUnpublished&wbc_purpose=Basic#");
			Helpers.XHTMLVal.FindIE("Title=Microsoft Content Management Server");
			Helpers.XHTMLVal.AttachTo(Win32Special.Window,"title=Microsoft Content Management Server&&exactmatch=false");						
			//if (Helpers.XHTMLVal.Verify(HTMLUIObj.ByTag, "name=NC_PostingAppove&&value=Approve", true))

			
			Helpers.XHTMLVal.Click(HTMLUIObj.Link, "innerText=Display Name&&exactmatch=false");
			Helpers.XHTMLVal.Click(HTMLUIObj.Link, "innerText=Location&&exactmatch=false");
			Helpers.XHTMLVal.Click(HTMLUIObj.Link, "innerText=Owner&&exactmatch=false");
			Helpers.XHTMLVal.Click(HTMLUIObj.Link, "innerText=Last Modified&&exactmatch=false");
			//string FullHTML = Helpers.XHTMLVal.GetHTMLAttribute(HTMLUIObj.ByTag, "tag=html&&AttributeToGet=InnerHTML");

			
			Helpers.XHTMLVal.CleanUp("CloseBrowsers=true&&ClearCache=false&&ClearCookies=false");
			Console.WriteLine("End of Approval Assistant");
			//ChannelProps.ChannelProps1();
			
			
			
			
			
			
		}
		public static bool PressEnter()
		{
			
			return Helpers.XHTMLVal.PressKey("TextToInput=[enter]");
		}
		public static bool PresstabKey()
		{
			return Helpers.XHTMLVal.PressKey("TextToInput=[tab]");
		}
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\StfTests\CMSBVT\ChannelProps.cs ===
using System;
using Microsoft.WebRunner;
using ServerTestFramework;
using ServerTestFramework.Utilities;
namespace WebFormNS
{
	/// <summary>
	/// Summary description for ChannelProps.
	/// </summary>
	public class ChannelProps
	{
		

		public static bool ChannelProps1()
		{
			//  This will test the Channel properties functionality 



			bool return2;
			
			Console.WriteLine("Starting Channel Props");
			
			Helpers.XHTMLVal.SetCredentials(@"username="+Helpers.authUser+"&&password="+Helpers.authPass);
			Helpers.XHTMLVal.StartApplication(AppObj.IE, "url=http://auth.test.xbox.com/en-us");
			///Helpers.XHTMLVal.FindIE("action=flexpage.aspx");
			//Helpers.XHTMLVal.AttachTo(Win32Special.Window,"action=flexpage.aspx&&exactmatch=false");
			Helpers.XHTMLVal.Click(Win32UIObj.Link, "name=Switch To Edit Site&&value=http://auth.test.xbox.com/en-us#");
			Helpers.XHTMLVal.Click(Win32UIObj.Link, "name=Channel Properties&&value=http://auth.test.xbox.com/CMS/WebAuthor/Dialogs/PropertiesDialogs/ChannelProperties.aspx?NRMODE=Update&FRAMELESS=true&NRNODEGUID=%7bD9EC795B-E176-4211-B1B7-593E8B81B1AB%7d");
			Helpers.XHTMLVal.FindIE("title=Microsoft Content Management Server");
			Helpers.XHTMLVal.AttachTo(Win32Special.Window,"Title=Microsoft Content Management Server&&exactmatch=false");
			if (Helpers.XHTMLVal.AttachTo(Win32Special.Window, "Title=Microsoft Content Management Server - Microsoft Internet Explorer&&ExactMatch=false"))
			{
				Console.WriteLine("Attach works");
			}
			if (Helpers.XHTMLVal.AttachTo(Win32Special.Window, "Title=Microsoft Content Management Server&&ExactMatch=false"))

			{
				return2 = true;
			}
			else
			{
				return2 = false;
			}
			Helpers.XHTMLVal.InputText(HTMLUIObj.TextArea, "name=StandardPropertiesControl:WBC_txtareaDescription&&TextToInput=TestforDavethis should show up all the time for this test.");
			Helpers.XHTMLVal.Click(HTMLUIObj.Button, "name=WBC_imgSaveChanges&&value=Save&&exactmatch=false");
			Helpers.XHTMLVal.CleanUp("CloseBrowsers=true&&ClearCache=false&&ClearCookies=false");
			Console.WriteLine("End of Channel Props");
			
			return return2;
			//
		}
		public static bool Pressnewchannel()
		{
			return Helpers.XHTMLVal.PressKey("TextToInput=WebrunnerChannel&&TimesToPress=1");

		}
		public static bool PressEnter()
		{
			System.Threading.Thread.Sleep(2000);
			
			return Helpers.XHTMLVal.PressKey("TextToInput=[enter]");
		}
		public static bool Pressleftmouse()
		{
			System.Threading.Thread.Sleep(2000);
			return Helpers.XHTMLVal.PressKey("TextToInput=[mouseleft]&&TimesToPress=1");

			
		}
		public static bool changetime()
		{
			return Helpers.XHTMLVal.PressKey("TextToInput=01:45 PM&&TimesToPress=1");
		}
		public static bool changedate()
		{
			return Helpers.XHTMLVal.PressKey("TextToInput=12/05/2004&&TimesToPress=1");

		}

		public static bool textforchannelprops()
		{
			System.Threading.Thread.Sleep(10000);
			Console.WriteLine("testing description text in channel prop");
			return Helpers.XHTMLVal.PressKey("TextToInput=Channel Prop Description text for webrunner test&&TimesToPress=1");

			
		}
		public static bool PresstabKey() 
		{
			return Helpers.XHTMLVal.PressKey("TextToInput=[tab]");
		}
		public static bool PressupKey()
		{
			System.Threading.Thread.Sleep(40000);
			return Helpers.XHTMLVal.PressKey("TextToInput=[up]");
			
		}
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\StfTests\CMSBVT\copy.cs ===
using System;
using Microsoft.WebRunner;
using ServerTestFramework;
using ServerTestFramework.Utilities;


namespace WebFormNS
{
	/// 
	/// Copy a page to another channel.
	/// 


	public class copy
	{
		
		

		
		public static bool copy1()
		{
			//
			bool return14;
			Console.WriteLine("starting Copy");
			Helpers.XHTMLVal.SetCredentials(@"username="+Helpers.authUser+"&&password="+Helpers.authPass);
			Helpers.XHTMLVal.StartApplication(AppObj.IE, "url=http://auth.test.xbox.com/en-us");
			Helpers.XHTMLVal.FindIE("title=Xenon.com");
			Helpers.XHTMLVal.AttachTo(Win32Special.Window,"name=Xenon.com&&ExactMatch=false");
			if (Helpers.XHTMLVal.AttachTo(Win32Special.Window,"name=Xenon.com&&ExactMatch=false"))
			{
				Console.WriteLine("Attached in copy works now");
			}
			Helpers.XHTMLVal.Click(Win32UIObj.Link, "name=Switch To Edit Site&&value=http://auth.test.xbox.com/en-us#");
			System.Threading.Thread.Sleep(4500);
			Helpers.XHTMLVal.FindIE("title=Xenon.com");
			Helpers.XHTMLVal.AttachTo(Win32Special.Window,"name=Xenon.com&&ExactMatch=false");
			Helpers.XHTMLVal.Click(Win32UIObj.Link, "name=Copy&&value=http://auth.test.xbox.com/CMS/WebAuthor/Dialogs/PageCopy/PageCopyDlg.aspx?NRMODE=Update&FRAMELESS=true&NRNODEGUID=%7b448C0438-899A-4D10-BB64-4DBD65770F53%7d");
			Helpers.XHTMLVal.FindIE("title=PageCopyDlg&&ExactMatch=false");
					
			Helpers.XHTMLVal.AttachTo(Win32Special.Window,"name=PageCopyDlg&&ExactMatch=false");
			if (Helpers.XHTMLVal.AttachTo(Win32Special.Window,"name=PageCopyDlg&&ExactMatch=false"))
			{
				Console.WriteLine("Attach to copy page works now");
			}
			if (Helpers.XHTMLVal.AttachTo(Win32Special.Window,"name=PageCopyDlg&&ExactMatch=false"))
			{
				return14 = true;
			}
			else
			{
				return14 = false;
			}
			
			
			
			Helpers.XHTMLVal.Click(Win32UIObj.Link, "name=da-DK&&value=http://auth.test.xbox.com/CMS/WebAuthor/Dialogs/PageCopy/TreeFrame.aspx?NRMODE=Update&FRAMELESS=true&NRNODEGUID=%7b448C0438-899A-4D10-BB64-4DBD65770F53%7d#");
			Helpers.XHTMLVal.Click(HTMLUIObj.Button, "name=OK&&ExactMatch=false");
			
			Helpers.XHTMLVal.CleanUp("CloseBrowsers=true&&ClearCache=false&&ClearCookies=false");
			//subappdec.subappdec1();
			Console.WriteLine("ending Copy");
			return return14;
			//ApprovalAssist.ApprovalAssist1();
			//
		}
		public static bool PressEnter()
		{
			
			return Helpers.XHTMLVal.PressKey("TextToInput=[enter]");
		}
		public static bool PresstabKey()
		{
			return Helpers.XHTMLVal.PressKey("TextToInput=[tab]");
		}
		public static bool PressupKey()
		{
			System.Threading.Thread.Sleep(40000);
			return Helpers.XHTMLVal.PressKey("TextToInput=[up]");
			
		}
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\StfTests\CMSBVT\CreateNewPage.cs ===
using System;
using Microsoft.WebRunner;
using ServerTestFramework;
using ServerTestFramework.Utilities;

namespace WebFormNS
{
	/// <summary>
	
	/// </summary>
	public class CreateNewPage
	{
	
		/// </summary>
		public static bool CreateNewPage1()
		{
			
			
			bool return1;	
			Helpers.XHTMLVal.SearchLevel = 10;
			Helpers.XHTMLVal.SetCredentials(@"username="+Helpers.authUser+"&&password="+Helpers.authPass);
			Helpers.XHTMLVal.StartApplication(AppObj.IE, "url=http://auth.test.xbox.com/en-us");
			Helpers.XHTMLVal.FindIE("action=flexpage.aspx");
			Helpers.XHTMLVal.AttachTo(Win32Special.Window,"action=flexpage.aspx&&exactmatch=false");
			// attach to window
			Helpers.XHTMLVal.FindIE("title=FlexTemplate");
			Helpers.XHTMLVal.AttachTo(Win32Special.Window,"action=flexpage.aspx&&exactmatch=false");

			// switch to edit
			Helpers.XHTMLVal.Click(Win32UIObj.Link, "name=Switch To Edit Site&&value=http://auth.test.xbox.com/en-us#");

			// select link to create a page
			Helpers.XHTMLVal.Click(Win32UIObj.Link, "innertext=Create New Page");

			// attach to new window
			Helpers.XHTMLVal.FindIE("title= Microsoft Content Management Server ");
			Helpers.XHTMLVal.AttachTo(Win32Special.Window,"title= Microsoft Content Management Server&&exactmatch=false");

			// go to templates
			Helpers.XHTMLVal.Click(Win32UIObj.Link, "name=Templates&&value=http://auth.test.xbox.com/CMS/WebAuthor/Dialogs/PageCreationWizard/TemplateBrowse/TemplateBrowse.aspx?NRMODE=UNPUBLISHED&DestinationChannel=%7bD9EC795B-E176-4211-B1B7-593E8B81B1AB%7d&TemplateGallery={E4D1912B-9DD3-11D1-B44E-006097071264}&TimeStamp=632446148609228509");
			//Helpers.XHTMLVal.Click(HTMLUIObj.Link, "name=Templates&&value=http://auth.test.xbox.com/CMS/WebAuthor/Dialogs/PageCreationWizard/TemplateBrowse/TemplateBrowse.aspx?NRMODE=UNPUBLISHED&DestinationChannel=%7bD9EC795B-E176-4211-B1B7-593E8B81B1AB%7d&TemplateGallery={E4D1912B-9DD3-11D1-B44E-006097071264}&TimeStamp=632446148609228509");
			//Helpers.XHTMLVal.Click(HTMLUIObj.Link,"innertext=Templates&&href='../TemplateBrowse/TemplateBrowse.aspx?&&exactmatch=false");
			Helpers.XHTMLVal.FindIE("title= Microsoft Content Management Server ");
			Helpers.XHTMLVal.AttachTo(Win32Special.Window,"title= Microsoft Content Management Server&&exactmatch=false");

			// select flexpage
			CreateNewPage.PresstabKey();
			CreateNewPage.PresstabKey();
			CreateNewPage.PresstabKey();
			CreateNewPage.PresstabKey();
			CreateNewPage.PresstabKey();
			CreateNewPage.PresstabKey();
			CreateNewPage.PressEnter();
			
			// attach to original window
			Helpers.XHTMLVal.FindIE("title=Flex Page Fragment");
			Helpers.XHTMLVal.AttachTo(Win32Special.Window,"name=Flex Page Fragment&&exactmatch=false");

			// allow page to load
			Helpers.XHTMLVal.WaitForWindow("name=Flex Page Fragment");
			
			Helpers.XHTMLVal.Click(HTMLUIObj.Button, "value=Create new free-form item&&exactmatch=false");
			
			
			Helpers.XHTMLVal.PressKey("TextToInput=Testing for dave&&exactmatch=false");
			
			
			
			//Verify Save New Page
			if (Helpers.XHTMLVal.Verify(HTMLUIObj.Title, "innertext=Flex Page Fragment&&ExactMatch=true", true))

			//if (Helpers.XHTMLVal.Verify(Win32UIObj.MenuItem, "name=Save New Page&&ExactMatch=true", true))
			{
				return1 = true;
			}
			else
			{
				return1 = false;
			}
			
			// save the page
			Helpers.XHTMLVal.Click(HTMLUIObj.Link,"innertext=Save New Page");

			// attach to new window
			Helpers.XHTMLVal.FindIE("title= Microsoft Content Management Server ");
			Helpers.XHTMLVal.AttachTo(Win32Special.Window,"name=Microsoft Content Management Server&&exactmatch=false");

			// get random #
			//Random rnd = new Random();
			//string pageName = "davewebrunnertest"+rnd.Next().ToString();

			// enter text
			CreateNewPage.PresstabKey();
			Helpers.XHTMLVal.FindIE("title= Microsoft Content Management Server ");
			Helpers.XHTMLVal.AttachTo(Win32Special.Window,"name=Microsoft Content Management Server&&exactmatch=false");
			
			Helpers.XHTMLVal.PressKey("TextToInput=BVTTesting&&exactmatch=false");
			CreateNewPage.PresstabKey();
			CreateNewPage.PresstabKey();
			CreateNewPage.PressEnter();
			CreateNewPage.PresstabKey();
			CreateNewPage.PressEnter();
			/*
			//Helpers.XHTMLVal.InputText(Win32UIObj.Text, "name=NC_intxtName&&TextToInput=BVTSaveTest&&exactmatch=false");
			//Helpers.XHTMLVal.InputText(Win32UIObj.Text,"name=NC_intxtName&&TextToInput="+pageName);
			//Helpers.XHTMLVal.InputText(HTMLUIObj.TextBox, "name=NC_intxtName&&TextToInput=BVTSaveTest&&exactmatch=false");
			// choose "same as name" button
			Helpers.XHTMLVal.Click(HTMLUIObj.ByTag,"tag=button&&innertext=Same As Name&&exactmatch=false&&order=0");
		
			// choose "ok" button
			Helpers.XHTMLVal.Click(HTMLUIObj.ByTag,"tag=button&&innertext=OK&&exactmatch=false&&order=0");
				*/
			// attach to original window again
			Helpers.XHTMLVal.FindIE("title=FlexTemplate");
			Helpers.XHTMLVal.AttachTo(Win32Special.Window,"name=FlexTemplate&&exactmatch=false");

			// allow page to load
			Helpers.XHTMLVal.WaitForWindow("name=FlexTemplate");

			// verify page was created
		//	if (Helpers.XHTMLVal.Verify(HTMLUIObj.ByTag,"tag=span&&id=DefaultConsoleHome_Console1_Presentationmodecontainer3_Cmspostinginfo1_PostingLabel&&innertext=/Channels/en-US/"+pageName))
			Helpers.XHTMLVal.CleanUp("CloseBrowsers=true&&ClearCache=false&&ClearCookies=false");
			//PageProps.PageProps1();
			return return1;
			
		}
		
		public static bool inputtxt()
		{
			Console.WriteLine("Did the text get There?");
			return Helpers.XHTMLVal.InputText(Win32UIObj.Text, "name=NC_intxtName&&TextToInput=DaveWRTest&&exactmatch=false");
			
		}
		public static bool ClickSameName()
		{
			return Helpers.XHTMLVal.Click(HTMLUIObj.Button, "name=NC_Reset");

		}
		
		public static bool PressEnter()
		{
			System.Threading.Thread.Sleep(2000);
			
			return Helpers.XHTMLVal.PressKey("TextToInput=[enter]");
		}
		public static bool PresstabKey()
		{
			return Helpers.XHTMLVal.PressKey("TextToInput=[tab]");
		}
		public static bool PressupKey()
		{
			System.Threading.Thread.Sleep(40000);
			return Helpers.XHTMLVal.PressKey("TextToInput=[up]");
			
		}
		public static bool Templat()
		{
			return Helpers.XHTMLVal.Click(HTMLUIObj.Link, "href=../TemplateBrowse/TemplateBrowse.aspx?NRMODE=UNPUBLISHED&DestinationChannel=%7bD9EC795B-E176-4211-B1B7-593E8B81B1AB%7d&TemplateGallery={E4D1912B-9DD3-11D1-B44E-006097071264}&TimeStamp=632364781954232953");
		}
		public static bool PressdownKey()
		{
			System.Threading.Thread.Sleep(40000);
			return Helpers.XHTMLVal.PressKey("TextToInput=[down]");
			
		}
		public static bool textforsavepage()
		{
			System.Threading.Thread.Sleep(10000);
			Console.WriteLine("testing input text");
			return Helpers.XHTMLVal.PressKey("TextToInput=Davewebrunnertest&&TimesToPress=1");

			
		}
		public static bool ClickTemplates()
		{
			Console.WriteLine("In ClickTemplates");
			Console.WriteLine("Clicking on the word Templates");
			return Helpers.XHTMLVal.Click(HTMLUIObj.Link, "href=../TemplateBrowse/TemplateBrowse.aspx?NRMODE=UNPUBLISHED&DestinationChannel=%7bD9EC795B-E176-4211-B1B7-593E8B81B1AB%7d&TemplateGallery={E4D1912B-9DD3-11D1-B44E-006097071264}&TimeStamp=632364230571099932");
			
		}
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\StfTests\BatmanTest\SPSResultSchema.cs ===
//------------------------------------------------------------------------------
// <autogenerated>
//     This code was generated by a tool.
//     Runtime Version: 1.0.3705.288
//
//     Changes to this file may cause incorrect behavior and will be lost if 
//     the code is regenerated.
// </autogenerated>
//------------------------------------------------------------------------------

// 
// This source code was auto-generated by xsd, Version=1.0.3705.288.
// 
namespace BatmanTest
{
    using System.Xml.Serialization;
    
    
    /// <remarks/>
    [System.Xml.Serialization.XmlTypeAttribute(Namespace="urn:schemas-microsoft-com:billing-data")]
    [System.Xml.Serialization.XmlRootAttribute(Namespace="urn:schemas-microsoft-com:billing-data", IsNullable=false)]
    public class ErrorPackage {
        
        /// <remarks/>
        public string ErrorHResult;
        
        /// <remarks/>
        public string Message;
        
        /// <remarks/>
        public ErrorPackageErrorDebugInfo ErrorDebugInfo;
        
        /// <remarks/>
        public ErrorPackageErrorDetailSet ErrorDetailSet;
        
        /// <remarks/>
        public string TrackingGUID;
    }
    
    /// <remarks/>
    [System.Xml.Serialization.XmlTypeAttribute(Namespace="urn:schemas-microsoft-com:billing-data")]
    public class ErrorPackageErrorDebugInfo {
        
        /// <remarks/>
        [System.Xml.Serialization.XmlElementAttribute("DebugInfo")]
        public string[] DebugInfo;
        
        /// <remarks/>
        public string ComputerName;
    }
    
    /// <remarks/>
    [System.Xml.Serialization.XmlTypeAttribute(Namespace="urn:schemas-microsoft-com:billing-data")]
    public class ErrorPackageErrorDetailSetErrorDetailErrorDebugInfo {
        
        /// <remarks/>
        [System.Xml.Serialization.XmlElementAttribute("DebugInfo")]
        public string[] DebugInfo;
        
        /// <remarks/>
        public string ComputerName;
    }
    
    /// <remarks/>
    [System.Xml.Serialization.XmlTypeAttribute(Namespace="urn:schemas-microsoft-com:billing-data")]
    public class ErrorPackageErrorDetailSetErrorDetail {
        
        /// <remarks/>
        public int EventId;
        
        /// <remarks/>
        public string ErrorHResult;
        
        /// <remarks/>
        public string Message;
        
        /// <remarks/>
        public ErrorPackageErrorDetailSetErrorDetailErrorDebugInfo ErrorDebugInfo;
    }
    
    /// <remarks/>
    [System.Xml.Serialization.XmlTypeAttribute(Namespace="urn:schemas-microsoft-com:billing-data")]
    public class ErrorPackageErrorDetailSet {
        
        /// <remarks/>
        public ErrorPackageErrorDetailSetErrorDetail ErrorDetail;
    }
    
    /// <remarks/>
    [System.Xml.Serialization.XmlTypeAttribute(Namespace="urn:schemas-microsoft-com:billing-data")]
    [System.Xml.Serialization.XmlRootAttribute("PaymentInstrumentInfoSet", Namespace="urn:schemas-microsoft-com:billing-data", IsNullable=false)]
    public class PaymentInstrumentInfoSet {
        
        /// <remarks/>
        [System.Xml.Serialization.XmlElementAttribute("PaymentInstrumentInfo")]
        public PaymentInstrumentInfoSetPaymentInstrumentInfo[] PaymentInstrumentInfo;
    }
    
    /// <remarks/>
    [System.Xml.Serialization.XmlTypeAttribute(Namespace="urn:schemas-microsoft-com:billing-data")]
    public class PaymentInstrumentInfoSetPaymentInstrumentInfo {
        
        /// <remarks/>
        public string PaymentInstrumentId;
        
        /// <remarks/>
        public string PaymentInstrumentStatus;
        
        /// <remarks/>
        public string PaymentInstrumentType;
        
        /// <remarks/>
        public string FriendlyName;
        
        /// <remarks/>
        public PaymentInstrumentInfoSetPaymentInstrumentInfoCreditCardInfo CreditCardInfo;
        
        /// <remarks/>
        public PaymentInstrumentInfoSetPaymentInstrumentInfoDirectDebitInfo DirectDebitInfo;
        
        /// <remarks/>
        public PaymentInstrumentInfoSetPaymentInstrumentInfoQwestInfo QwestInfo;
        
        /// <remarks/>
        public PaymentInstrumentInfoSetPaymentInstrumentInfoPhone Phone;
        
        /// <remarks/>
        public PaymentInstrumentInfoSetPaymentInstrumentInfoAddressInfo AddressInfo;
    }
    
    /// <remarks/>
    [System.Xml.Serialization.XmlTypeAttribute(Namespace="urn:schemas-microsoft-com:billing-data")]
    public class PaymentInstrumentInfoSetPaymentInstrumentInfoCreditCardInfo {
        
        /// <remarks/>
        public string AccountHolderName;
        
        /// <remarks/>
        public string EncryptedAccountNumber;
        
		/// <remarks/>
        public string AccountNumberLastFour;
        
        /// <remarks/>
        public string CardType;
        
        /// <remarks/>
        public string ExpirationDate;
    }
    
    /// <remarks/>
    [System.Xml.Serialization.XmlTypeAttribute(Namespace="urn:schemas-microsoft-com:billing-data")]
    public class PaymentInstrumentInfoSetPaymentInstrumentInfoDirectDebitInfo {
        
        /// <remarks/>
        public string AccountHolderName;
        
        /// <remarks/>
        public string AccountNumberLastFour;
        
        /// <remarks/>
        public string BankCode;
        
        /// <remarks/>
        public string BranchCode;
        
        /// <remarks/>
        public string CheckDigits;
        
        /// <remarks/>
        public string MandateStatus;
        
        /// <remarks/>
        public string MandateReceivedDate;
        
        /// <remarks/>
        public string MandateDueDate;
    }
    
    /// <remarks/>
    [System.Xml.Serialization.XmlTypeAttribute(Namespace="urn:schemas-microsoft-com:billing-data")]
    public class PaymentInstrumentInfoSetPaymentInstrumentInfoQwestInfo {
        
        /// <remarks/>
        public string AccountHolderName;
        
        /// <remarks/>
        public string AccountNumberLastFour;
    }
    
    /// <remarks/>
    [System.Xml.Serialization.XmlTypeAttribute(Namespace="urn:schemas-microsoft-com:billing-data")]
    public class PaymentInstrumentInfoSetPaymentInstrumentInfoPhone {
        
        /// <remarks/>
        public string PhoneType;
        
        /// <remarks/>
        public string PhonePrefix;
        
        /// <remarks/>
        public string PhoneNumber;
        
        /// <remarks/>
        public string PhoneExtension;
        
        /// <remarks/>
        public string CountryCode;
    }
    
    /// <remarks/>
    [System.Xml.Serialization.XmlTypeAttribute(Namespace="urn:schemas-microsoft-com:billing-data")]
    public class PaymentInstrumentInfoSetPaymentInstrumentInfoAddressInfo {
        
        /// <remarks/>
        public string AddressId;
        
        /// <remarks/>
        public string FriendlyName;
        
        /// <remarks/>
        public string Street1;
        
        /// <remarks/>
        public string Street2;
        
        /// <remarks/>
        public string Street3;
        
        /// <remarks/>
        public string City;
        
        /// <remarks/>
        public string District;
        
        /// <remarks/>
        public string State;
        
        /// <remarks/>
        public string CountryCode;
        
        /// <remarks/>
        public string PostalCode;
    }
    
    /// <remarks/>
    [System.Xml.Serialization.XmlTypeAttribute(Namespace="urn:schemas-microsoft-com:billing-data")]
    [System.Xml.Serialization.XmlRootAttribute("ServiceInstanceSet", Namespace="urn:schemas-microsoft-com:billing-data", IsNullable=false)]
    public class ServiceInstanceSet {
        
        /// <remarks/>
        [System.Xml.Serialization.XmlElementAttribute("ServiceInstance")]
        public ServiceInstanceSetServiceInstance[] ServiceInstance;
    }
    
    /// <remarks/>
    [System.Xml.Serialization.XmlTypeAttribute(Namespace="urn:schemas-microsoft-com:billing-data")]
    public class ServiceInstanceSetServiceInstance {
        
        /// <remarks/>
        public string ServiceInstanceId;
        
        /// <remarks/>
        public string ServiceComponentId;
        
        /// <remarks/>
        public string ProvisioningStatus;
        
        /// <remarks/>
        public string ProvisioningErrorCode;
    }
    
    /// <remarks/>
    [System.Xml.Serialization.XmlTypeAttribute(Namespace="urn:schemas-microsoft-com:billing-data")]
    [System.Xml.Serialization.XmlRootAttribute("SubscriptionInfoSet", Namespace="urn:schemas-microsoft-com:billing-data", IsNullable=false)]
    public class SubscriptionInfoSet {
        
        /// <remarks/>
        [System.Xml.Serialization.XmlElementAttribute("SubscriptionInfo")]
        public SubscriptionInfoSetSubscriptionInfo[] SubscriptionInfo;
    }
    
    /// <remarks/>
    [System.Xml.Serialization.XmlTypeAttribute(Namespace="urn:schemas-microsoft-com:billing-data")]
    public class SubscriptionInfoSetSubscriptionInfo {
        
        /// <remarks/>
        public string SubscriptionId;
        
        /// <remarks/>
        public string AnniversaryDate;
        
        /// <remarks/>
        public string OfferingGUID;
        
        /// <remarks/>
        public string SubscriptionDescription;
        
        /// <remarks/>
        public string SubscriptionPriceDescription;
        
        /// <remarks/>
        public string InternalSubscriptionDescription;
        
        /// <remarks/>
        public string FriendlyName;
        
        /// <remarks/>
        public string ShippingAddressId;
        
        /// <remarks/>
        public SubscriptionInfoSetSubscriptionInfoSubscriptionStatusInfo SubscriptionStatusInfo;
        
        /// <remarks/>
        public string PurchaseDate;
        
        /// <remarks/>
        public string ActivationDate;
        
        /// <remarks/>
        public string EndDate;
        
        /// <remarks/>
        public string RenewalGracePeriod;
        
        /// <remarks/>
        public string RenewOfferingId;
        
        /// <remarks/>
        public string PaymentInstrumentId;
        
        /// <remarks/>
        public string TermCommitCyclesRemaining;
        
        /// <remarks/>
        public SubscriptionInfoSetSubscriptionInfoDelayedConversion DelayedConversion;
        
        /// <remarks/>
        [System.Xml.Serialization.XmlArrayItemAttribute("ServiceInstance", IsNullable=false)]
        public SubscriptionInfoSetSubscriptionInfoServiceInstance[] ServiceInstanceSet;
    }
    
    /// <remarks/>
    [System.Xml.Serialization.XmlTypeAttribute(Namespace="urn:schemas-microsoft-com:billing-data")]
    public class SubscriptionInfoSetSubscriptionInfoSubscriptionStatusInfo {
        
        /// <remarks/>
        public string SubscriptionStatus;
        
        /// <remarks/>
        public SubscriptionInfoSetSubscriptionInfoSubscriptionStatusInfoViolationSet ViolationSet;
    }
    
    /// <remarks/>
    [System.Xml.Serialization.XmlTypeAttribute(Namespace="urn:schemas-microsoft-com:billing-data")]
    public class SubscriptionInfoSetSubscriptionInfoSubscriptionStatusInfoViolationSet {
        
        /// <remarks/>
        public string ViolationId;
    }
    
    /// <remarks/>
    [System.Xml.Serialization.XmlTypeAttribute(Namespace="urn:schemas-microsoft-com:billing-data")]
    public class SubscriptionInfoSetSubscriptionInfoDelayedConversion {
        
        /// <remarks/>
        public string OfferingGUID;
        
        /// <remarks/>
        public string ConversionDate;
    }
    
    /// <remarks/>
    [System.Xml.Serialization.XmlTypeAttribute(Namespace="urn:schemas-microsoft-com:billing-data")]
    public class SubscriptionInfoSetSubscriptionInfoServiceInstance {
        
        /// <remarks/>
        public string ServiceInstanceId;
        
        /// <remarks/>
        public string ServiceComponentId;
        
        /// <remarks/>
        public string ProvisioningStatus;
        
        /// <remarks/>
        public string ProvisioningErrorCode;
    }
    
    /// <remarks/>
    [System.Xml.Serialization.XmlTypeAttribute(Namespace="urn:schemas-microsoft-com:billing-data")]
    [System.Xml.Serialization.XmlRootAttribute(Namespace="urn:schemas-microsoft-com:billing-data", IsNullable=false)]
    public class SubscriptionStatusInfo {
        
        /// <remarks/>
        public string SubscriptionStatus;
        
        /// <remarks/>
        public SubscriptionStatusInfoViolationSet ViolationSet;
    }
    
    /// <remarks/>
    [System.Xml.Serialization.XmlTypeAttribute(Namespace="urn:schemas-microsoft-com:billing-data")]
    public class SubscriptionStatusInfoViolationSet {
        
        /// <remarks/>
        public string ViolationId;
    }
    
    /// <remarks/>
    [System.Xml.Serialization.XmlTypeAttribute(Namespace="urn:schemas-microsoft-com:billing-data")]
    [System.Xml.Serialization.XmlRootAttribute("AccountInfoSet", Namespace="urn:schemas-microsoft-com:billing-data", IsNullable=false)]
    public class AccountInfoSet {
        
        /// <remarks/>
        [System.Xml.Serialization.XmlElementAttribute("AccountInfo")]
        //public AccountInfoSetAccountInfo[] AccountInfo;
		public AccountInfo[] AccountInfo;
    }
    
    /// <remarks/>
    [System.Xml.Serialization.XmlTypeAttribute(Namespace="urn:schemas-microsoft-com:billing-data")]
    public class AccountInfoSetAccountInfo {
        
        /// <remarks/>
        public string AccountId;
        
        /// <remarks/>
        public string FriendlyName;
        
        /// <remarks/>
        public AccountInfoSetAccountInfoAccountStatusInfo AccountStatusInfo;
    }
    
    /// <remarks/>
    [System.Xml.Serialization.XmlTypeAttribute(Namespace="urn:schemas-microsoft-com:billing-data")]
    public class AccountInfoSetAccountInfoAccountStatusInfo {
        
        /// <remarks/>
        public string AccountStatus;
        public AccountInfoSetAccountInfoAccountStatusViolationSet ViolationSet;
    }
    
    /// <remarks/>
    [System.Xml.Serialization.XmlTypeAttribute(Namespace="urn:schemas-microsoft-com:billing-data")]
    public class AccountInfoSetAccountInfoAccountStatusViolationSet {
        
        /// <remarks/>
        public string ViolationId;
    }
    
    /// <remarks/>
    [System.Xml.Serialization.XmlTypeAttribute(Namespace="urn:schemas-microsoft-com:billing-data")]
    [System.Xml.Serialization.XmlRootAttribute(Namespace="urn:schemas-microsoft-com:billing-data", IsNullable=false)]
    public class AccountInfo {
        
        /// <remarks/>
        public string AccountId;
        
        /// <remarks/>
        public AccountInfoAccountStatusInfo AccountStatusInfo;
        
        /// <remarks/>
        public string AccountCreationDate;
        
        /// <remarks/>
        public string AccountHistoryDate;
        
        /// <remarks/>
        public string AccountSource;
        
        /// <remarks/>
        public string LegacyAccountId;
        
        /// <remarks/>
        public string AnniversaryDate;
        
        /// <remarks/>
        public string CustomerType;
        
        /// <remarks/>
        public string DefaultAddressId;
        
        /// <remarks/>
        public string CorporateIdentity;
        
        /// <remarks/>
        public string FriendlyName;
        
        /// <remarks/>
        public string FirstName;
        
        /// <remarks/>
        public string FirstNamePronunciation;
        
        /// <remarks/>
        public string LastName;
        
        /// <remarks/>
        public string LastNamePronunciation;
        
        /// <remarks/>
        public string Email;
        
        /// <remarks/>
        public string CompanyName;
        
        /// <remarks/>
        public string CompanyNamePronunciation;
        
        /// <remarks/>
        public string Locale;
        
        /// <remarks/>
        public string HCI;
        
        /// <remarks/>
        public string Currency;
        
        /// <remarks/>
        public AccountInfoPhoneSet PhoneSet;
        
        /// <remarks/>
        public AccountInfoAddressInfoSet AddressInfoSet;
        
        /// <remarks/>
        public AccountInfoTaxExemptionInfoSet TaxExemptionInfoSet;
    }
    
    /// <remarks/>
    [System.Xml.Serialization.XmlTypeAttribute(Namespace="urn:schemas-microsoft-com:billing-data")]
    public class AccountInfoAccountStatusInfo {
        
        /// <remarks/>
        public string AccountStatus;
        
        /// <remarks/>
        public AccountInfoAccountStatusInfoViolationSet ViolationSet;
    }
    
    /// <remarks/>
    [System.Xml.Serialization.XmlTypeAttribute(Namespace="urn:schemas-microsoft-com:billing-data")]
    public class AccountInfoAccountStatusInfoViolationSet {
        
        /// <remarks/>
        public string ViolationId;
    }
    
    /// <remarks/>
    [System.Xml.Serialization.XmlTypeAttribute(Namespace="urn:schemas-microsoft-com:billing-data")]
    public class AccountInfoPhoneSet {
        
        /// <remarks/>
        public AccountInfoPhoneSetPhone Phone;
    }
    
    /// <remarks/>
    [System.Xml.Serialization.XmlTypeAttribute(Namespace="urn:schemas-microsoft-com:billing-data")]
    public class AccountInfoPhoneSetPhone {
        
        /// <remarks/>
        public string PhoneType;
        
        /// <remarks/>
        public string PhonePrefix;
        
        /// <remarks/>
        public string PhoneNumber;
        
        /// <remarks/>
        public string PhoneExtension;
        
        /// <remarks/>
        public string CountryCode;
    }
    
    /// <remarks/>
    [System.Xml.Serialization.XmlTypeAttribute(Namespace="urn:schemas-microsoft-com:billing-data")]
    public class AccountInfoAddressInfoSet {
        
        /// <remarks/>
        public AccountInfoAddressInfoSetAddressInfo AddressInfo;
    }
    
    /// <remarks/>
    [System.Xml.Serialization.XmlTypeAttribute(Namespace="urn:schemas-microsoft-com:billing-data")]
    public class AccountInfoAddressInfoSetAddressInfo {
        
        /// <remarks/>
        public string AddressId;
        
        /// <remarks/>
        public string FriendlyName;
        
        /// <remarks/>
        public string Street1;
        
        /// <remarks/>
        public string Street2;
        
        /// <remarks/>
        public string Street3;
        
        /// <remarks/>
        public string City;
        
        /// <remarks/>
        public string District;
        
        /// <remarks/>
        public string State;
        
        /// <remarks/>
        public string CountryCode;
        
        /// <remarks/>
        public string PostalCode;
    }
    
    /// <remarks/>
    [System.Xml.Serialization.XmlTypeAttribute(Namespace="urn:schemas-microsoft-com:billing-data")]
    public class AccountInfoTaxExemptionInfoSet {
        
        /// <remarks/>
        public AccountInfoTaxExemptionInfoSetTaxExemptionInfo TaxExemptionInfo;
    }
    
    /// <remarks/>
    [System.Xml.Serialization.XmlTypeAttribute(Namespace="urn:schemas-microsoft-com:billing-data")]
    public class AccountInfoTaxExemptionInfoSetTaxExemptionInfo {
        
        /// <remarks/>
        public string TECertificateNumber;
        
        /// <remarks/>
        public string TEType;
        
        /// <remarks/>
        public string TEStatus;
        
        /// <remarks/>
        public string TEExpDate;
        
        /// <remarks/>
        public string TEDateAdded;
        
        /// <remarks/>
        public string TEDateReceived;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\StfTests\CMSBVT\DeleteTopNewPage.cs ===
using System;
using Microsoft.WebRunner;
using ServerTestFramework;
using ServerTestFramework.Utilities;

namespace WebFormNS
{
	/// 
	//  Delete the top html page, which should be davewebrunnertest
	/// </summary>
	public class DeleteTopNewPage
	{
		
		public static void DeleteTopNewPage1()
		{
			//	//
			Helpers.XHTMLVal.SetCredentials(@"username="+Helpers.authUser+"&&password="+Helpers.authPass);
			Helpers.XHTMLVal.StartApplication(AppObj.IE, "url=http://auth.test.xbox.com/en-us");
			Helpers.XHTMLVal.FindIE("title=FlexTemplate");
			Helpers.XHTMLVal.AttachTo(Win32Special.Window,"Title=FlexTemplate&&exactmatch=false");
							
			Helpers.XHTMLVal.Click(Win32UIObj.Link, "name=Switch To Edit Site&&value=http://auth.test.xbox.com/en-us#");
			Helpers.XHTMLVal.Click(HTMLUIObj.Link, "href=Davewebrunnertest.htm&&exactmatch=false");
			Helpers.XHTMLVal.Click(Win32UIObj.Link, "name=Delete&&value=http://auth.test.xbox.com/NR/exeres/D9EC795B-E176-4211-B1B7-593E8B81B1AB.htm?NRMODE=Unpublished&wbc_purpose=Basic#&&exactmatch=false&&exactmatch=false");
			Console.WriteLine("will try to click on davewebrunnertest.htm now");
			Helpers.XHTMLVal.CleanUp("CloseBrowsers=true&&ClearCache=false&&ClearCookies=false");
			Console.WriteLine("End of Delete New page");
			PageProps.PageProps1();
			
			
			//
		}
		public static bool PressEnter()
		{
			System.Threading.Thread.Sleep(2000);
			
			return Helpers.XHTMLVal.PressKey("TextToInput=[enter]");
		}
		public static bool PresstabKey()
		{
			return Helpers.XHTMLVal.PressKey("TextToInput=[tab]");
		}
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\StfTests\CMSBVT\Main.cs ===
using System;
using Microsoft.WebRunner;
using ServerTestFramework;
using System.Xml;
using System.Data;
using System.Data.SqlClient;
using System.IO;
using System.Collections;
using System.Net;
using System.Threading;
using System.Text;
using System.Resources;
using System.Reflection;
using System.Globalization;
using ServerTestFramework.Database;
using ServerTestFramework.LiveService.Notification;
using ServerTestFramework.LiveService.Presence;
using ServerTestFramework.LiveService.PresNotiCommon;
using ServerTestFramework.Utilities;
using Microsoft.WebRunner.Loggers;



 

namespace WebFormNS

{

	
	//Main.cs is designed to collect data from ProfReg.xml and put the data into Array's.
	//The section at the bottom of this class initiates the start of the functionality.

	public class Helpers
	{
	
		
		
		const int ERROR_FILE_NOT_FOUND =2;
		const int ERROR_ACCESS_DENIED = 5;
		public static WebRunnerSDK mySDK;
		public static System.Threading.Timer myPopUpTimer;
		public static WebRunnerSDK XHTMLVal = new WebRunnerSDK(); 
		//public static string authUser = "TEST\\_xbcauthbvt";
		//public static string authPass = "F0rSh@r0n";
		public static string authUser = "TEST\\davidulm";
		public static string authPass = "Test!tools";
		

		
		
	
			
		/// </summary>
		public static void Initializer() 
		{
			
			Helpers.XHTMLVal.SetTimeOutValue(120000);
			//Helpers.profreg.StartApplication(AppObj.IE, "url=http://test.xbox.com/en-us");
			XHTMLVal.SetCredentials(@"username="+authUser+"&&password="+authPass);

			//Helpers.XHTMLVal.StartApplication(AppObj.IE, "url=http://auth.test.xbox.com/en-us");
			
			
		}	
		
		public class WebFormTC : TestSuite

		{	

			public override void Initialize(System.Xml.XmlDocument config)
			{
			
				Console.WriteLine("Test am I getting here");
								 
			}
			
			public override InitializerInfo GetRequiredResources()

			{

				// need to use fakesg service

				InitializerInfo ii= new InitializerInfo();
				
				ii.UseFakeSG = false;
				
				Helpers.Initializer();		
				
				return ii;

			}

 

			// stress test for BasicTest

			public override InitializerInfo GetStressRequiredResources()

			{

				// besides using fakeSG service, this stress test also need to

				// createUsers before testing start, also need certificates

				InitializerInfo   ii = new InitializerInfo();

				ii.UseFakeSG = false;

				ii.CreateUsers = false;

				ii.Certificates = false;

				return ii;

			}
		}
		
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\StfTests\CMSBVT\Move.cs ===
using System;
using Microsoft.WebRunner;
using ServerTestFramework;
using ServerTestFramework.Utilities;

namespace WebFormNS
{
	/// <summary>
	/// Summary description for Move.
	/// </summary>
	public class Move
	{
		
		

		
		
		
		public static void Move1()
		{
			//
			Helpers.XHTMLVal.SetCredentials(@"username="+Helpers.authUser+"&&password="+Helpers.authPass);
			Helpers.XHTMLVal.StartApplication(AppObj.IE, "url=http://auth.test.xbox.com/en-us");
			Helpers.XHTMLVal.FindIE("title=FlexTemplate");
			Helpers.XHTMLVal.AttachTo(Win32Special.Window,"Title=FlexTemplate&&exactmatch=false");
			Helpers.XHTMLVal.Click(Win32UIObj.Link, "name=Switch To Edit Site&&value=http://auth.test.xbox.com/en-us#");
			Helpers.XHTMLVal.Click(Win32UIObj.Link, "name=Move&&value=http://auth.test.xbox.com/CMS/WebAuthor/Dialogs/PageMove/PageMoveDlg.aspx?NRMODE=Update&FRAMELESS=true&NRNODEGUID=%7b1BF207D7-A765-4903-88DE-1B93F38D1B56%7d}");
			Helpers.XHTMLVal.Click(Win32UIObj.Link, "name=zh-TW&&value=http://auth.test.xbox.com/CMS/WebAuthor/Dialogs/PageMove/TreeFrame.aspx?NRMODE=Update&FRAMELESS=true&NRNODEGUID=%7b1BF207D7-A765-4903-88DE-1B93F38D1B56%7d#}");
			Move.PresstabKey();
			Move.PresstabKey();
			Move.PresstabKey();
			Move.PressEnter();
			Helpers.XHTMLVal.CleanUp("CloseBrowsers=true&&ClearCache=false&&ClearCookies=false");
			subappdec.subappdec1();
			//
		}
		public static bool PressEnter()
		{
			
			return Helpers.XHTMLVal.PressKey("TextToInput=[enter]");
		}
		public static bool PresstabKey()
		{
			return Helpers.XHTMLVal.PressKey("TextToInput=[tab]");
		}
		public static bool PressupKey()
		{
			System.Threading.Thread.Sleep(40000);
			return Helpers.XHTMLVal.PressKey("TextToInput=[up]");
			
		}
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\StfTests\CMSBVT\Preview.cs ===
using System;
using Microsoft.WebRunner;
using ServerTestFramework;
using ServerTestFramework.Utilities;
namespace WebFormNS
{
	/// <summary>
	/// Summary description for Preview.
	/// </summary>
	public class Preview
	{
		

		public static void Preview1()
		{
			
			Helpers.XHTMLVal.SetCredentials(@"username="+Helpers.authUser+"&&password="+Helpers.authPass);
			Helpers.XHTMLVal.StartApplication(AppObj.IE, "url=http://auth.test.xbox.com/en-us");
			Helpers.XHTMLVal.FindIE("title=FlexTemplate");
			Helpers.XHTMLVal.AttachTo(Win32Special.Window,"Title=FlexTemplate&&exactmatch=false");
			Helpers.XHTMLVal.Click(Win32UIObj.Link, "name=Switch To Edit Site&&value=http://auth.test.xbox.com/en-us#");
			int start;
			int at;
			int end;
			int count;

			
		
			string FullHTML = Helpers.XHTMLVal.GetHTMLAttribute(HTMLUIObj.ByTag, "tag=html&&AttributeToGet=InnerHTML");
			
			end = FullHTML.Length;
			//start = end/2;
			start = 1;
			//FullHTML.IndexOf("At least we can put text in our first flex template", start, end);
			at = 0;
			while((start <= end) && (at > -1))
			{
				// start+count must be a position within -str-.
				count = end - start;
				at = FullHTML.IndexOf("At least we can put text in our first flex template", start, count);
				if (at == -1) break;
				Console.Write("{0} ", at);
				start = at+1;
			}

			Helpers.XHTMLVal.Click(Win32UIObj.Link, "name=Preview&&value=http://auth.test.xbox.com/NR/exeres/32C2FFBD-0A31-4FD1-A011-2DDBC4952BCF,frameless.htm?NRMODE=Unpublished&WBCMODE=PresentationUnpublishedPreview&nr_emit=View");
		
			int prestart;
			int preat;
			int preend;
			int precount;

			
		
			string preFullHTML = Helpers.XHTMLVal.GetHTMLAttribute(HTMLUIObj.ByTag, "tag=html&&AttributeToGet=InnerHTML");
			
			preend = preFullHTML.Length;
			//start = end/2;
			prestart = 1;
			//FullHTML.IndexOf("At least we can put text in our first flex template", start, end);
			preat = 0;
			while((prestart <= preend) && (preat > -1))
			{
				// start+count must be a position within -str-.
				precount = preend - prestart;
				preat = preFullHTML.IndexOf("At least we can put text in our first flex template", prestart, precount);
				if (preat == -1) break;
				Console.Write("{0} ", preat);
				prestart = preat+1;
			}
			if (preat != 0)
						{
							Console.WriteLine("The verification is on the main page and the preview page");
						}
			Helpers.XHTMLVal.CleanUp("CloseBrowsers=true&&ClearCache=false&&ClearCookies=false");
			//ResourceMan.ResourceMan1();
			//
		}
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\StfTests\CMSBVT\PManager.cs ===
using System;
using Microsoft.WebRunner;
using ServerTestFramework;
using ServerTestFramework.Utilities;



 



namespace WebFormNS
{
	/// <summary>
	/// Summary description for PManager.
	/// </summary>
	public class PManager
	{
		

		public static bool PManager1()
		{
			bool return6;
			Helpers.XHTMLVal.SearchLevel = 10;
			Helpers.XHTMLVal.SetCredentials(@"username="+Helpers.authUser+"&&password="+Helpers.authPass);
			Helpers.XHTMLVal.StartApplication(AppObj.IE, "url=http://auth.test.xbox.com/en-us");
			
			Helpers.XHTMLVal.FindIE("action=flexpage.aspx");
			Helpers.XHTMLVal.AttachTo(Win32Special.Window,"action=flexpage.aspx&&exactmatch=false");
			Helpers.XHTMLVal.Click(Win32UIObj.Link, "name=Switch To Edit Site&&value=http://auth.test.xbox.com/en-us#");
			Helpers.XHTMLVal.Click(Win32UIObj.Link, "innertext=Production Manager&&exactmatch=false");
			//Helpers.XHTMLVal.Click(Win32UIObj.Link, "name=Production Manager&&value=http://auth.test.xbox.com/NR/exeres/32C2FFBD-0A31-4FD1-A011-2DDBC4952BCF,frameless.htm?NRMODE=Unpublished&WBCMODE=PresentationUnpublished&wbc_purpose=Basic#");
			Helpers.XHTMLVal.FindIE("title=Microsoft Content Management Server");
			Helpers.XHTMLVal.AttachTo(Win32Special.Window,"Title=Microsoft Content Management Server&&ExactMatch=false");
			if (Helpers.XHTMLVal.AttachTo(Win32Special.Window,"Title=Microsoft Content Management Server&&ExactMatch=false"))
			{
				return6 = true;
			}
			else
			{
				return6 = false;
			}
			Helpers.XHTMLVal.Click(HTMLUIObj.Link, "InnerText=Last Modified&&exactmatch=false&&href=javascript:__doPostBack('ProductionManagerGrid$_ctl2$_ctl2','')");
		
			Helpers.XHTMLVal.Click(HTMLUIObj.Link, "InnerText=Page&&exactmatch=false&&href=javascript:__doPostBack('ProductionManagerGrid$_ctl2$_ctl0','')");
			Helpers.XHTMLVal.Click(HTMLUIObj.Link, "InnerText=Channel&&exactmatch=false&&href=javascript:__doPostBack('ProductionManagerGrid$_ctl2$_ctl1','')");
			Helpers.XHTMLVal.Click(HTMLUIObj.Select, "id=PagingConfigControl&&TextToInput=10");
			Helpers.XHTMLVal.Click(HTMLUIObj.Select, "id=PagingConfigControl&&TextToInput=15");
			Helpers.XHTMLVal.Click(HTMLUIObj.Select, "id=PagingConfigControl&&TextToInput=20");
			
			Helpers.XHTMLVal.CleanUp("CloseBrowsers=true&&ClearCache=false&&ClearCookies=false");	
			//Preview.Preview1();
			return return6;
			
			
			//
		}
		public static bool PressEnter()
		{
			
			return Helpers.XHTMLVal.PressKey("TextToInput=[enter]");
		}
		public static bool PresstabKey()
		{
			return Helpers.XHTMLVal.PressKey("TextToInput=[tab]");
		}
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\StfTests\CMSBVT\PageProps.cs ===
using System;
using Microsoft.WebRunner;
using ServerTestFramework;
using ServerTestFramework.Utilities;
namespace WebFormNS
{
	/// <summary>
	/// Summary description for PageProps.
	/// </summary>
	public class PageProps
	{

		public static bool PageProps1()
		{
			bool return3;
			
			
			Helpers.XHTMLVal.SetCredentials(@"username="+Helpers.authUser+"&&password="+Helpers.authPass);
			Helpers.XHTMLVal.StartApplication(AppObj.IE, "url=http://auth.test.xbox.com/en-us");
			Helpers.XHTMLVal.FindIE("action=flexpage.aspx");
			Helpers.XHTMLVal.AttachTo(Win32Special.Window,"action=flexpage.aspx&&exactmatch=false");
			// attach to window
			
			// switch to edit
			Helpers.XHTMLVal.Click(Win32UIObj.Link, "name=Switch To Edit Site&&value=http://auth.test.xbox.com/en-us#");

			Helpers.XHTMLVal.Click(Win32UIObj.Link, "name=Page Properties&&value=http://auth.test.xbox.com/NR/exeres/448C0438-899A-4D10-BB64-4DBD65770F53,frameless.htm?NRMODE=Unpublished&WBCMODE=PresentationUnpublished&wbc_purpose=Basic#");
			
			//Helpers.XHTMLVal.Click(HTMLUIObj.Link, "innertext=Page Properties&&ExactMatch=false");
			
			
			Helpers.XHTMLVal.FindIE("title=Microsoft Content Management Server");
			Helpers.XHTMLVal.AttachTo(Win32Special.Window, "Title=Microsoft Content Management Server&&ExactMatch=false");
			
			if (Helpers.XHTMLVal.AttachTo(Win32Special.Window, "name=Microsoft Content Management Server&&ExactMatch=false"))
			{
				return3 = true;
			}
			else
			{
				return3 = false;
			}
			Helpers.XHTMLVal.InputText(HTMLUIObj.TextArea, "name=StandardPropertiesControl:WBC_txtareaDescription&&TextToInput=Testing CMS via WebRunner");
			Helpers.XHTMLVal.Click(HTMLUIObj.Button, "name=WBC_imgSaveChanges&&exactmatch=false");
			Helpers.XHTMLVal.CleanUp("CloseBrowsers=true&&ClearCache=false&&ClearCookies=false");
			//PManager.PManager1();
			return return3;
			//
		}
	
		public static bool Pressnewchannel()
		{
			return Helpers.XHTMLVal.PressKey("TextToInput=Webrunpageproptest&&TimesToPress=1");

		}
		public static bool PressEnter()
		{
			System.Threading.Thread.Sleep(2000);
			
			return Helpers.XHTMLVal.PressKey("TextToInput=[enter]");
		}
		public static bool Pressleftmouse()
		{
			System.Threading.Thread.Sleep(2000);
			return Helpers.XHTMLVal.PressKey("TextToInput=[mouseleft]&&TimesToPress=1");

			
		}
		public static bool changetime()
		{
			return Helpers.XHTMLVal.PressKey("TextToInput=01:45 PM&&TimesToPress=1");
		}
		public static bool changedate()
		{
			return Helpers.XHTMLVal.PressKey("TextToInput=12/05/2004&&TimesToPress=1");

		}

		public static bool textforchannelprops()
		{
			System.Threading.Thread.Sleep(10000);
			Console.WriteLine("testing description text in channel prop");
			return Helpers.XHTMLVal.PressKey("TextToInput=Channel Prop Description text for webrunner test&&TimesToPress=1");

			
		}
		public static bool PresstabKey() 
		{
			return Helpers.XHTMLVal.PressKey("TextToInput=[tab]");
		}
		public static bool PressupKey()
		{
			System.Threading.Thread.Sleep(40000);
			return Helpers.XHTMLVal.PressKey("TextToInput=[up]");
			
		
		}
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\StfTests\CMSBVT\ResourceMan.cs ===
using System;
using Microsoft.WebRunner;
using ServerTestFramework;
using ServerTestFramework.Utilities;

namespace WebFormNS
{
	/// <summary>
	/// Summary description for ResourceMan.
	/// </summary>
	public class ResourceMan
	{
		
		
		

		public static bool ResourceMan1()
		{
			bool return6;
			Helpers.XHTMLVal.SetCredentials(@"username="+Helpers.authUser+"&&password="+Helpers.authPass);
			Helpers.XHTMLVal.StartApplication(AppObj.IE, "url=http://auth.test.xbox.com/en-us");
			Helpers.XHTMLVal.FindIE("action=flexpage.aspx");
			Helpers.XHTMLVal.AttachTo(Win32Special.Window,"action=flexpage.aspx&&exactmatch=false");
			Helpers.XHTMLVal.Click(Win32UIObj.Link, "name=Switch To Edit Site&&value=http://auth.test.xbox.com/en-us#");
			
			Helpers.XHTMLVal.Click(Win32UIObj.Link, "innertext=Resource Manager&&ExactMatch=false");
			Helpers.XHTMLVal.FindIE("title=Microsoft Content Management Server");
			Helpers.XHTMLVal.AttachTo(Win32Special.Window,"Title=Microsoft Content Management Server&&exactmatch=false");
			WebFormNS.ResourceMan.PresstabKey();
			WebFormNS.ResourceMan.PressupKey();
			//http://auth.test.xbox.com/CMS/WebAuthor/Dialogs/ResourceBrowser/Management/ResourcesBrowse.aspx?NRMODE=Update&FRAMELESS=true&NRNODEGUID={448C0438-899A-4D10-BB64-4DBD65770F53}&wbc_gallery={BFDBF648-9B78-49A0-B22C-BE09B99401D2}&TimeStamp=632441103627462357
				
			if (Helpers.XHTMLVal.AttachTo(Win32Special.Window,"Title=Microsoft Content Management Server&&exactmatch=false"))
				
			{
				return6 = true;
			}
			else
			{
				return6 = false;
			}
			Helpers.XHTMLVal.Click(HTMLUIObj.Select, "name=ResourceGalleriesControl:GalleriesViewSelect&&TextToInput=View As List");
			
			Helpers.XHTMLVal.FindIE("title=Microsoft Content Management Server");
			Helpers.XHTMLVal.AttachTo(Win32Special.Window,"Title=Microsoft Content Management Server&&exactmatch=false");

			Helpers.XHTMLVal.Click(HTMLUIObj.Select, "id=ResourceGalleriesControl_PagingConfigControl&&TextToInput=10");
			Helpers.XHTMLVal.Click(HTMLUIObj.Select, "id=ResourceGalleriesControl_PagingConfigControl&&TextToInput=15");
			Helpers.XHTMLVal.Click(HTMLUIObj.Select, "id=ResourceGalleriesControl_PagingConfigControl&&TextToInput=20");
			Helpers.XHTMLVal.Click(HTMLUIObj.Select, "id=ResourceGalleriesControl_PagingConfigControl&&TextToInput=All");
			Helpers.XHTMLVal.Click(Win32UIObj.Link, "name=halo2&&exactmatch=false&&value=http://auth.test.xbox.com/CMS/WebAuthor/Dialogs/ResourceBrowser/Management/ResourcesBrowse.aspx?NRMODE=Update&FRAMELESS=true&NRNODEGUID={90F79D5F-71E9-435F-AC5C-95B9D52B17AB}&wbc_gallery={BFDBF648-9B78-49A0-B22C-BE09B99401D2}&TimeStamp=632417632936892081");
			Helpers.XHTMLVal.Click(HTMLUIObj.Select, "id=PagingConfigControl&&TextToInput=10");
			Helpers.XHTMLVal.Click(HTMLUIObj.Select, "id=PagingConfigControl&&TextToInput=15");
			Helpers.XHTMLVal.Click(HTMLUIObj.Select, "id=PagingConfigControl&&TextToInput=20");
			Helpers.XHTMLVal.Click(HTMLUIObj.Select, "id=PagingConfigControl&&TextToInput=All");
			
			Helpers.XHTMLVal.FindIE("title=Microsoft Content Management Server");
			Helpers.XHTMLVal.AttachTo(Win32Special.Window,"Title=Microsoft Content Management Server&&exactmatch=false");

			Helpers.XHTMLVal.Click(HTMLUIObj.Link, "InnerText=Resource&&exactmatch=false&&href=javascript:__doPostBack('ProductionManagerGrid$_ctl2$_ctl0','')");
			Helpers.XHTMLVal.Click(HTMLUIObj.Link, "InnerText=File Type&&exactmatch=false&&href=javascript:__doPostBack('ProductionManagerGrid$_ctl2$_ctl1','')");
			Helpers.XHTMLVal.Click(HTMLUIObj.Link, "InnerText=Size&&exactmatch=false&&href=javascript:__doPostBack('ProductionManagerGrid$_ctl2$_ctl2','')");
			Helpers.XHTMLVal.Click(HTMLUIObj.Link, "InnerText=Last Modified&&exactmatch=false&&href=javascript:__doPostBack('ProductionManagerGrid$_ctl2$_ctl3','')");
			Helpers.XHTMLVal.CleanUp("CloseBrowsers=true&&ClearCache=false&&ClearCookies=false");
			Console.WriteLine("End of Resource Manager");
			//RevisonHist.RevisonHist1();
			
			
			
			return return6;
		}
		public static bool PressEnter()
		{
			System.Threading.Thread.Sleep(2000);
			
			return Helpers.XHTMLVal.PressKey("TextToInput=[enter]");
		}
		public static bool ClickonProdCat()
		{
			return Helpers.XHTMLVal.Click(HTMLUIObj.Link, "innertext=Product Catalog&&exactmatch=false");
		}
		public static bool PresstabKey()
		{
				return Helpers.XHTMLVal.PressKey("TextToInput=[tab]");
		}
		public static bool PressupKey()
		{
			return Helpers.XHTMLVal.PressKey("TextToInput=[up]");
			
		}
		public static bool PressdownKey()
		{
			return Helpers.XHTMLVal.PressKey("TextToInput=[down]");
			
		}
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\StfTests\BatmanTest\bdk.cs ===
//------------------------------------------------------------------------------
// <autogenerated>
//     This code was generated by a tool.
//     Runtime Version: 1.0.3705.0
//
//     Changes to this file may cause incorrect behavior and will be lost if 
//     the code is regenerated.
// </autogenerated>
//------------------------------------------------------------------------------

// 
// This source code was auto-generated by wsdl, Version=1.0.3705.0.
// 
using System.Diagnostics;
using System.Xml.Serialization;
using System;
using System.Web.Services.Protocols;
using System.ComponentModel;
using System.Web.Services;


/// <remarks/>
// CODEGEN: The optional WSDL extension element 'binding' from namespace 'http://schemas.microsoft.com/soap-toolkit/wsdl-extension' was not handled.
[System.Diagnostics.DebuggerStepThroughAttribute()]
[System.ComponentModel.DesignerCategoryAttribute("code")]
[System.Web.Services.WebServiceBindingAttribute(Name="BDKServerObj2SoapBinding", Namespace="http://tempuri.org/wsdl/")]
public class bdk : System.Web.Services.Protocols.SoapHttpClientProtocol {
    
    /// <remarks/>
    public bdk() {
        this.Url = "https://sps25tiexbox1.tiexbox1.ssd.extest.microsoft.com/bdk2/bdk.WSDL";
    }
    
    /// <remarks/>
    [System.Web.Services.Protocols.SoapRpcMethodAttribute("http://tempuri.org/action/BDKServerObj2.AddRoleAssignment", RequestNamespace="http://tempuri.org/message/", ResponseNamespace="http://tempuri.org/message/")]
    public void AddRoleAssignment(int lDelegateIdHigh, int lDelegateIdLow, int lRequesterIdHigh, int lRequesterIdLow, string bstrObjectId, string bstrRoleAssignmentXML, out string pbstrErrorXML) {
        object[] results = this.Invoke("AddRoleAssignment", new object[] {
                    lDelegateIdHigh,
                    lDelegateIdLow,
                    lRequesterIdHigh,
                    lRequesterIdLow,
                    bstrObjectId,
                    bstrRoleAssignmentXML});
        pbstrErrorXML = ((string)(results[0]));
    }
    
    /// <remarks/>
    public System.IAsyncResult BeginAddRoleAssignment(int lDelegateIdHigh, int lDelegateIdLow, int lRequesterIdHigh, int lRequesterIdLow, string bstrObjectId, string bstrRoleAssignmentXML, System.AsyncCallback callback, object asyncState) {
        return this.BeginInvoke("AddRoleAssignment", new object[] {
                    lDelegateIdHigh,
                    lDelegateIdLow,
                    lRequesterIdHigh,
                    lRequesterIdLow,
                    bstrObjectId,
                    bstrRoleAssignmentXML}, callback, asyncState);
    }
    
    /// <remarks/>
    public void EndAddRoleAssignment(System.IAsyncResult asyncResult, out string pbstrErrorXML) {
        object[] results = this.EndInvoke(asyncResult);
        pbstrErrorXML = ((string)(results[0]));
    }
    
    /// <remarks/>
    [System.Web.Services.Protocols.SoapRpcMethodAttribute("http://tempuri.org/action/BDKServerObj2.RemoveRoleAssignment", RequestNamespace="http://tempuri.org/message/", ResponseNamespace="http://tempuri.org/message/")]
    public void RemoveRoleAssignment(int lDelegateIdHigh, int lDelegateIdLow, int lRequesterIdHigh, int lRequesterIdLow, string bstrObjectId, string bstrRoleAssignmentXML, out string pbstrErrorXML) {
        object[] results = this.Invoke("RemoveRoleAssignment", new object[] {
                    lDelegateIdHigh,
                    lDelegateIdLow,
                    lRequesterIdHigh,
                    lRequesterIdLow,
                    bstrObjectId,
                    bstrRoleAssignmentXML});
        pbstrErrorXML = ((string)(results[0]));
    }
    
    /// <remarks/>
    public System.IAsyncResult BeginRemoveRoleAssignment(int lDelegateIdHigh, int lDelegateIdLow, int lRequesterIdHigh, int lRequesterIdLow, string bstrObjectId, string bstrRoleAssignmentXML, System.AsyncCallback callback, object asyncState) {
        return this.BeginInvoke("RemoveRoleAssignment", new object[] {
                    lDelegateIdHigh,
                    lDelegateIdLow,
                    lRequesterIdHigh,
                    lRequesterIdLow,
                    bstrObjectId,
                    bstrRoleAssignmentXML}, callback, asyncState);
    }
    
    /// <remarks/>
    public void EndRemoveRoleAssignment(System.IAsyncResult asyncResult, out string pbstrErrorXML) {
        object[] results = this.EndInvoke(asyncResult);
        pbstrErrorXML = ((string)(results[0]));
    }
    
    /// <remarks/>
    [System.Web.Services.Protocols.SoapRpcMethodAttribute("http://tempuri.org/action/BDKServerObj2.GetPermitsForPUID", RequestNamespace="http://tempuri.org/message/", ResponseNamespace="http://tempuri.org/message/")]
    public void GetPermitsForPUID(int lCustomerPUIDHigh, int lCustomerPUIDLow, string bstrServiceComponentGUID, out string pbstrErrorXML, out int plPermitCount, out string pbstrPermitSetXML) {
        object[] results = this.Invoke("GetPermitsForPUID", new object[] {
                    lCustomerPUIDHigh,
                    lCustomerPUIDLow,
                    bstrServiceComponentGUID});
        pbstrErrorXML = ((string)(results[0]));
        plPermitCount = ((int)(results[1]));
        pbstrPermitSetXML = ((string)(results[2]));
    }
    
    /// <remarks/>
    public System.IAsyncResult BeginGetPermitsForPUID(int lCustomerPUIDHigh, int lCustomerPUIDLow, string bstrServiceComponentGUID, System.AsyncCallback callback, object asyncState) {
        return this.BeginInvoke("GetPermitsForPUID", new object[] {
                    lCustomerPUIDHigh,
                    lCustomerPUIDLow,
                    bstrServiceComponentGUID}, callback, asyncState);
    }
    
    /// <remarks/>
    public void EndGetPermitsForPUID(System.IAsyncResult asyncResult, out string pbstrErrorXML, out int plPermitCount, out string pbstrPermitSetXML) {
        object[] results = this.EndInvoke(asyncResult);
        pbstrErrorXML = ((string)(results[0]));
        plPermitCount = ((int)(results[1]));
        pbstrPermitSetXML = ((string)(results[2]));
    }
    
    /// <remarks/>
    [System.Web.Services.Protocols.SoapRpcMethodAttribute("http://tempuri.org/action/BDKServerObj2.GetPermitsForObjectId", RequestNamespace="http://tempuri.org/message/", ResponseNamespace="http://tempuri.org/message/")]
    public void GetPermitsForObjectId(int lDelegateIdHigh, int lDelegateIdLow, int lRequesterIdHigh, int lRequesterIdLow, string bstrObjectId, bool fDeep, out string pbstrErrorXML, out int plPermitCount, out string pbstrPermitSetXML) {
        object[] results = this.Invoke("GetPermitsForObjectId", new object[] {
                    lDelegateIdHigh,
                    lDelegateIdLow,
                    lRequesterIdHigh,
                    lRequesterIdLow,
                    bstrObjectId,
                    fDeep});
        pbstrErrorXML = ((string)(results[0]));
        plPermitCount = ((int)(results[1]));
        pbstrPermitSetXML = ((string)(results[2]));
    }
    
    /// <remarks/>
    public System.IAsyncResult BeginGetPermitsForObjectId(int lDelegateIdHigh, int lDelegateIdLow, int lRequesterIdHigh, int lRequesterIdLow, string bstrObjectId, bool fDeep, System.AsyncCallback callback, object asyncState) {
        return this.BeginInvoke("GetPermitsForObjectId", new object[] {
                    lDelegateIdHigh,
                    lDelegateIdLow,
                    lRequesterIdHigh,
                    lRequesterIdLow,
                    bstrObjectId,
                    fDeep}, callback, asyncState);
    }
    
    /// <remarks/>
    public void EndGetPermitsForObjectId(System.IAsyncResult asyncResult, out string pbstrErrorXML, out int plPermitCount, out string pbstrPermitSetXML) {
        object[] results = this.EndInvoke(asyncResult);
        pbstrErrorXML = ((string)(results[0]));
        plPermitCount = ((int)(results[1]));
        pbstrPermitSetXML = ((string)(results[2]));
    }
    
    /// <remarks/>
    [System.Web.Services.Protocols.SoapRpcMethodAttribute("http://tempuri.org/action/BDKServerObj2.CreateAccount", RequestNamespace="http://tempuri.org/message/", ResponseNamespace="http://tempuri.org/message/")]
    public void CreateAccount(int lDelegateIdHigh, int lDelegateIdLow, int lRequesterIdHigh, int lRequesterIdLow, string bstrPPMemberName, string bstrTrackingGUID, string bstrAccountInfoXML, string bstrPaymentInstrumentXML, out string pbstrErrorXML, out string pbstrAccountId, out string pbstrPaymentInstrumentId, out string pbstrDate, out string bstrRequiredPaperWorkURL) {
        object[] results = this.Invoke("CreateAccount", new object[] {
                    lDelegateIdHigh,
                    lDelegateIdLow,
                    lRequesterIdHigh,
                    lRequesterIdLow,
                    bstrPPMemberName,
                    bstrTrackingGUID,
                    bstrAccountInfoXML,
                    bstrPaymentInstrumentXML});
        pbstrErrorXML = ((string)(results[0]));
        pbstrAccountId = ((string)(results[1]));
        pbstrPaymentInstrumentId = ((string)(results[2]));
        pbstrDate = ((string)(results[3]));
        bstrRequiredPaperWorkURL = ((string)(results[4]));
    }
    
    /// <remarks/>
    public System.IAsyncResult BeginCreateAccount(int lDelegateIdHigh, int lDelegateIdLow, int lRequesterIdHigh, int lRequesterIdLow, string bstrPPMemberName, string bstrTrackingGUID, string bstrAccountInfoXML, string bstrPaymentInstrumentXML, System.AsyncCallback callback, object asyncState) {
        return this.BeginInvoke("CreateAccount", new object[] {
                    lDelegateIdHigh,
                    lDelegateIdLow,
                    lRequesterIdHigh,
                    lRequesterIdLow,
                    bstrPPMemberName,
                    bstrTrackingGUID,
                    bstrAccountInfoXML,
                    bstrPaymentInstrumentXML}, callback, asyncState);
    }
    
    /// <remarks/>
    public void EndCreateAccount(System.IAsyncResult asyncResult, out string pbstrErrorXML, out string pbstrAccountId, out string pbstrPaymentInstrumentId, out string pbstrDate, out string bstrRequiredPaperWorkURL) {
        object[] results = this.EndInvoke(asyncResult);
        pbstrErrorXML = ((string)(results[0]));
        pbstrAccountId = ((string)(results[1]));
        pbstrPaymentInstrumentId = ((string)(results[2]));
        pbstrDate = ((string)(results[3]));
        bstrRequiredPaperWorkURL = ((string)(results[4]));
    }
    
    /// <remarks/>
    [System.Web.Services.Protocols.SoapRpcMethodAttribute("http://tempuri.org/action/BDKServerObj2.GetAccountInfo", RequestNamespace="http://tempuri.org/message/", ResponseNamespace="http://tempuri.org/message/")]
    public void GetAccountInfo(int lDelegateIdHigh, int lDelegateIdLow, int lRequesterIdHigh, int lRequesterIdLow, string bstrAccountId, out string pbstrErrorXML, out string pbstrAccountInfoXML) {
        object[] results = this.Invoke("GetAccountInfo", new object[] {
                    lDelegateIdHigh,
                    lDelegateIdLow,
                    lRequesterIdHigh,
                    lRequesterIdLow,
                    bstrAccountId});
        pbstrErrorXML = ((string)(results[0]));
        pbstrAccountInfoXML = ((string)(results[1]));
    }
    
    /// <remarks/>
    public System.IAsyncResult BeginGetAccountInfo(int lDelegateIdHigh, int lDelegateIdLow, int lRequesterIdHigh, int lRequesterIdLow, string bstrAccountId, System.AsyncCallback callback, object asyncState) {
        return this.BeginInvoke("GetAccountInfo", new object[] {
                    lDelegateIdHigh,
                    lDelegateIdLow,
                    lRequesterIdHigh,
                    lRequesterIdLow,
                    bstrAccountId}, callback, asyncState);
    }
    
    /// <remarks/>
    public void EndGetAccountInfo(System.IAsyncResult asyncResult, out string pbstrErrorXML, out string pbstrAccountInfoXML) {
        object[] results = this.EndInvoke(asyncResult);
        pbstrErrorXML = ((string)(results[0]));
        pbstrAccountInfoXML = ((string)(results[1]));
    }
    
    /// <remarks/>
    [System.Web.Services.Protocols.SoapRpcMethodAttribute("http://tempuri.org/action/BDKServerObj2.UpdateAccountInfo", RequestNamespace="http://tempuri.org/message/", ResponseNamespace="http://tempuri.org/message/")]
    public void UpdateAccountInfo(int lDelegateIdHigh, int lDelegateIdLow, int lRequesterIdHigh, int lRequesterIdLow, string bstrAccountId, string bstrAccountInfoXML, out string pbstrErrorXML, out string pbstrRequiredPaperWorkURL) {
        object[] results = this.Invoke("UpdateAccountInfo", new object[] {
                    lDelegateIdHigh,
                    lDelegateIdLow,
                    lRequesterIdHigh,
                    lRequesterIdLow,
                    bstrAccountId,
                    bstrAccountInfoXML});
        pbstrErrorXML = ((string)(results[0]));
        pbstrRequiredPaperWorkURL = ((string)(results[1]));
    }
    
    /// <remarks/>
    public System.IAsyncResult BeginUpdateAccountInfo(int lDelegateIdHigh, int lDelegateIdLow, int lRequesterIdHigh, int lRequesterIdLow, string bstrAccountId, string bstrAccountInfoXML, System.AsyncCallback callback, object asyncState) {
        return this.BeginInvoke("UpdateAccountInfo", new object[] {
                    lDelegateIdHigh,
                    lDelegateIdLow,
                    lRequesterIdHigh,
                    lRequesterIdLow,
                    bstrAccountId,
                    bstrAccountInfoXML}, callback, asyncState);
    }
    
    /// <remarks/>
    public void EndUpdateAccountInfo(System.IAsyncResult asyncResult, out string pbstrErrorXML, out string pbstrRequiredPaperWorkURL) {
        object[] results = this.EndInvoke(asyncResult);
        pbstrErrorXML = ((string)(results[0]));
        pbstrRequiredPaperWorkURL = ((string)(results[1]));
    }
    
    /// <remarks/>
    [System.Web.Services.Protocols.SoapRpcMethodAttribute("http://tempuri.org/action/BDKServerObj2.CloseAccount", RequestNamespace="http://tempuri.org/message/", ResponseNamespace="http://tempuri.org/message/")]
    public void CloseAccount(int lDelegateIdHigh, int lDelegateIdLow, string bstrAccountId, string bstrCommentInfoXML, out string pbstrErrorXML) {
        object[] results = this.Invoke("CloseAccount", new object[] {
                    lDelegateIdHigh,
                    lDelegateIdLow,
                    bstrAccountId,
                    bstrCommentInfoXML});
        pbstrErrorXML = ((string)(results[0]));
    }
    
    /// <remarks/>
    public System.IAsyncResult BeginCloseAccount(int lDelegateIdHigh, int lDelegateIdLow, string bstrAccountId, string bstrCommentInfoXML, System.AsyncCallback callback, object asyncState) {
        return this.BeginInvoke("CloseAccount", new object[] {
                    lDelegateIdHigh,
                    lDelegateIdLow,
                    bstrAccountId,
                    bstrCommentInfoXML}, callback, asyncState);
    }
    
    /// <remarks/>
    public void EndCloseAccount(System.IAsyncResult asyncResult, out string pbstrErrorXML) {
        object[] results = this.EndInvoke(asyncResult);
        pbstrErrorXML = ((string)(results[0]));
    }
    
    /// <remarks/>
    [System.Web.Services.Protocols.SoapRpcMethodAttribute("http://tempuri.org/action/BDKServerObj2.ActivateAccount", RequestNamespace="http://tempuri.org/message/", ResponseNamespace="http://tempuri.org/message/")]
    public void ActivateAccount(int lDelegateIdHigh, int lDelegateIdLow, string bstrAccountId, string bstrCommentInfoXML, out string pbstrErrorXML, out string pbstrAccountStatusInfoXML) {
        object[] results = this.Invoke("ActivateAccount", new object[] {
                    lDelegateIdHigh,
                    lDelegateIdLow,
                    bstrAccountId,
                    bstrCommentInfoXML});
        pbstrErrorXML = ((string)(results[0]));
        pbstrAccountStatusInfoXML = ((string)(results[1]));
    }
    
    /// <remarks/>
    public System.IAsyncResult BeginActivateAccount(int lDelegateIdHigh, int lDelegateIdLow, string bstrAccountId, string bstrCommentInfoXML, System.AsyncCallback callback, object asyncState) {
        return this.BeginInvoke("ActivateAccount", new object[] {
                    lDelegateIdHigh,
                    lDelegateIdLow,
                    bstrAccountId,
                    bstrCommentInfoXML}, callback, asyncState);
    }
    
    /// <remarks/>
    public void EndActivateAccount(System.IAsyncResult asyncResult, out string pbstrErrorXML, out string pbstrAccountStatusInfoXML) {
        object[] results = this.EndInvoke(asyncResult);
        pbstrErrorXML = ((string)(results[0]));
        pbstrAccountStatusInfoXML = ((string)(results[1]));
    }
    
    /// <remarks/>
    [System.Web.Services.Protocols.SoapRpcMethodAttribute("http://tempuri.org/action/BDKServerObj2.AddViolation", RequestNamespace="http://tempuri.org/message/", ResponseNamespace="http://tempuri.org/message/")]
    public void AddViolation(int lDelegateIdHigh, int lDelegateIdLow, string bstrObjectId, int lViolationId, string bstrCommentInfoXML, out string pbstrErrorXML, out string pbstrStatusInfoXML, out string pbstrAmountChargedXML) {
        object[] results = this.Invoke("AddViolation", new object[] {
                    lDelegateIdHigh,
                    lDelegateIdLow,
                    bstrObjectId,
                    lViolationId,
                    bstrCommentInfoXML});
        pbstrErrorXML = ((string)(results[0]));
        pbstrStatusInfoXML = ((string)(results[1]));
        pbstrAmountChargedXML = ((string)(results[2]));
    }
    
    /// <remarks/>
    public System.IAsyncResult BeginAddViolation(int lDelegateIdHigh, int lDelegateIdLow, string bstrObjectId, int lViolationId, string bstrCommentInfoXML, System.AsyncCallback callback, object asyncState) {
        return this.BeginInvoke("AddViolation", new object[] {
                    lDelegateIdHigh,
                    lDelegateIdLow,
                    bstrObjectId,
                    lViolationId,
                    bstrCommentInfoXML}, callback, asyncState);
    }
    
    /// <remarks/>
    public void EndAddViolation(System.IAsyncResult asyncResult, out string pbstrErrorXML, out string pbstrStatusInfoXML, out string pbstrAmountChargedXML) {
        object[] results = this.EndInvoke(asyncResult);
        pbstrErrorXML = ((string)(results[0]));
        pbstrStatusInfoXML = ((string)(results[1]));
        pbstrAmountChargedXML = ((string)(results[2]));
    }
    
    /// <remarks/>
    [System.Web.Services.Protocols.SoapRpcMethodAttribute("http://tempuri.org/action/BDKServerObj2.RemoveViolation", RequestNamespace="http://tempuri.org/message/", ResponseNamespace="http://tempuri.org/message/")]
    public void RemoveViolation(int lDelegateIdHigh, int lDelegateIdLow, string bstrObjectId, int lViolationId, string bstrCommentInfoXML, out string pbstrErrorXML, out string pbstrStatusInfoXML, out string pbstrAmountChargedXML) {
        object[] results = this.Invoke("RemoveViolation", new object[] {
                    lDelegateIdHigh,
                    lDelegateIdLow,
                    bstrObjectId,
                    lViolationId,
                    bstrCommentInfoXML});
        pbstrErrorXML = ((string)(results[0]));
        pbstrStatusInfoXML = ((string)(results[1]));
        pbstrAmountChargedXML = ((string)(results[2]));
    }
    
    /// <remarks/>
    public System.IAsyncResult BeginRemoveViolation(int lDelegateIdHigh, int lDelegateIdLow, string bstrObjectId, int lViolationId, string bstrCommentInfoXML, System.AsyncCallback callback, object asyncState) {
        return this.BeginInvoke("RemoveViolation", new object[] {
                    lDelegateIdHigh,
                    lDelegateIdLow,
                    bstrObjectId,
                    lViolationId,
                    bstrCommentInfoXML}, callback, asyncState);
    }
    
    /// <remarks/>
    public void EndRemoveViolation(System.IAsyncResult asyncResult, out string pbstrErrorXML, out string pbstrStatusInfoXML, out string pbstrAmountChargedXML) {
        object[] results = this.EndInvoke(asyncResult);
        pbstrErrorXML = ((string)(results[0]));
        pbstrStatusInfoXML = ((string)(results[1]));
        pbstrAmountChargedXML = ((string)(results[2]));
    }
    
    /// <remarks/>
    [System.Web.Services.Protocols.SoapRpcMethodAttribute("http://tempuri.org/action/BDKServerObj2.UpdateSubscriptionStatusFromPaymentInstru" +
"ment", RequestNamespace="http://tempuri.org/message/", ResponseNamespace="http://tempuri.org/message/")]
    public void UpdateSubscriptionStatusFromPaymentInstrument(int lDelegateIdHigh, int lDelegateIdLow, string bstrStatusChange, string bstrPaymentInstrumentInfoXML, string bstrCommentInfoXML, out string pbstrErrorXML) {
        object[] results = this.Invoke("UpdateSubscriptionStatusFromPaymentInstrument", new object[] {
                    lDelegateIdHigh,
                    lDelegateIdLow,
                    bstrStatusChange,
                    bstrPaymentInstrumentInfoXML,
                    bstrCommentInfoXML});
        pbstrErrorXML = ((string)(results[0]));
    }
    
    /// <remarks/>
    public System.IAsyncResult BeginUpdateSubscriptionStatusFromPaymentInstrument(int lDelegateIdHigh, int lDelegateIdLow, string bstrStatusChange, string bstrPaymentInstrumentInfoXML, string bstrCommentInfoXML, System.AsyncCallback callback, object asyncState) {
        return this.BeginInvoke("UpdateSubscriptionStatusFromPaymentInstrument", new object[] {
                    lDelegateIdHigh,
                    lDelegateIdLow,
                    bstrStatusChange,
                    bstrPaymentInstrumentInfoXML,
                    bstrCommentInfoXML}, callback, asyncState);
    }
    
    /// <remarks/>
    public void EndUpdateSubscriptionStatusFromPaymentInstrument(System.IAsyncResult asyncResult, out string pbstrErrorXML) {
        object[] results = this.EndInvoke(asyncResult);
        pbstrErrorXML = ((string)(results[0]));
    }
    
    /// <remarks/>
    [System.Web.Services.Protocols.SoapRpcMethodAttribute("http://tempuri.org/action/BDKServerObj2.GetAccountIdFromAdminPUID", RequestNamespace="http://tempuri.org/message/", ResponseNamespace="http://tempuri.org/message/")]
    public void GetAccountIdFromAdminPUID(int lDelegateIdHigh, int lDelegateIdLow, int lSearchPUIDHigh, int lSearchPUIDLow, bool fFullData, int lMax, out string pbstrErrorXML, out int pfMoreRows, out int plAccountInfoCount, out string pbstrAccountInfoSetXML) {
        object[] results = this.Invoke("GetAccountIdFromAdminPUID", new object[] {
                    lDelegateIdHigh,
                    lDelegateIdLow,
                    lSearchPUIDHigh,
                    lSearchPUIDLow,
                    fFullData,
                    lMax});
        pbstrErrorXML = ((string)(results[0]));
        pfMoreRows = ((int)(results[1]));
        plAccountInfoCount = ((int)(results[2]));
        pbstrAccountInfoSetXML = ((string)(results[3]));
    }
    
    /// <remarks/>
    public System.IAsyncResult BeginGetAccountIdFromAdminPUID(int lDelegateIdHigh, int lDelegateIdLow, int lSearchPUIDHigh, int lSearchPUIDLow, bool fFullData, int lMax, System.AsyncCallback callback, object asyncState) {
        return this.BeginInvoke("GetAccountIdFromAdminPUID", new object[] {
                    lDelegateIdHigh,
                    lDelegateIdLow,
                    lSearchPUIDHigh,
                    lSearchPUIDLow,
                    fFullData,
                    lMax}, callback, asyncState);
    }
    
    /// <remarks/>
    public void EndGetAccountIdFromAdminPUID(System.IAsyncResult asyncResult, out string pbstrErrorXML, out int pfMoreRows, out int plAccountInfoCount, out string pbstrAccountInfoSetXML) {
        object[] results = this.EndInvoke(asyncResult);
        pbstrErrorXML = ((string)(results[0]));
        pfMoreRows = ((int)(results[1]));
        plAccountInfoCount = ((int)(results[2]));
        pbstrAccountInfoSetXML = ((string)(results[3]));
    }
    
    /// <remarks/>
    [System.Web.Services.Protocols.SoapRpcMethodAttribute("http://tempuri.org/action/BDKServerObj2.GetAccountIdFromPaymentInstrumentInfo", RequestNamespace="http://tempuri.org/message/", ResponseNamespace="http://tempuri.org/message/")]
    public void GetAccountIdFromPaymentInstrumentInfo(int lDelegateIdHigh, int lDelegateIdLow, bool fFullData, int lMax, string bstrPaymentInstrumentInfoXML, out string pbstrErrorXML, out int pfMoreRows, out int plAccountInfoCount, out string pbstrAccountInfoSetXML) {
        object[] results = this.Invoke("GetAccountIdFromPaymentInstrumentInfo", new object[] {
                    lDelegateIdHigh,
                    lDelegateIdLow,
                    fFullData,
                    lMax,
                    bstrPaymentInstrumentInfoXML});
        pbstrErrorXML = ((string)(results[0]));
        pfMoreRows = ((int)(results[1]));
        plAccountInfoCount = ((int)(results[2]));
        pbstrAccountInfoSetXML = ((string)(results[3]));
    }
    
    /// <remarks/>
    public System.IAsyncResult BeginGetAccountIdFromPaymentInstrumentInfo(int lDelegateIdHigh, int lDelegateIdLow, bool fFullData, int lMax, string bstrPaymentInstrumentInfoXML, System.AsyncCallback callback, object asyncState) {
        return this.BeginInvoke("GetAccountIdFromPaymentInstrumentInfo", new object[] {
                    lDelegateIdHigh,
                    lDelegateIdLow,
                    fFullData,
                    lMax,
                    bstrPaymentInstrumentInfoXML}, callback, asyncState);
    }
    
    /// <remarks/>
    public void EndGetAccountIdFromPaymentInstrumentInfo(System.IAsyncResult asyncResult, out string pbstrErrorXML, out int pfMoreRows, out int plAccountInfoCount, out string pbstrAccountInfoSetXML) {
        object[] results = this.EndInvoke(asyncResult);
        pbstrErrorXML = ((string)(results[0]));
        pfMoreRows = ((int)(results[1]));
        plAccountInfoCount = ((int)(results[2]));
        pbstrAccountInfoSetXML = ((string)(results[3]));
    }
    
    /// <remarks/>
    [System.Web.Services.Protocols.SoapRpcMethodAttribute("http://tempuri.org/action/BDKServerObj2.AddPaymentInstrument", RequestNamespace="http://tempuri.org/message/", ResponseNamespace="http://tempuri.org/message/")]
    public void AddPaymentInstrument(int lDelegateIdHigh, int lDelegateIdLow, int lRequesterIdHigh, int lRequesterIdLow, string bstrTrackingGUID, string bstrAccountId, string bstrPaymentInstrumentInfoXML, out string pbstrErrorXML, out string pbstrPaymentInstrumentId, out string pbstrRequiredPaperWorkURL) {
        object[] results = this.Invoke("AddPaymentInstrument", new object[] {
                    lDelegateIdHigh,
                    lDelegateIdLow,
                    lRequesterIdHigh,
                    lRequesterIdLow,
                    bstrTrackingGUID,
                    bstrAccountId,
                    bstrPaymentInstrumentInfoXML});
        pbstrErrorXML = ((string)(results[0]));
        pbstrPaymentInstrumentId = ((string)(results[1]));
        pbstrRequiredPaperWorkURL = ((string)(results[2]));
    }
    
    /// <remarks/>
    public System.IAsyncResult BeginAddPaymentInstrument(int lDelegateIdHigh, int lDelegateIdLow, int lRequesterIdHigh, int lRequesterIdLow, string bstrTrackingGUID, string bstrAccountId, string bstrPaymentInstrumentInfoXML, System.AsyncCallback callback, object asyncState) {
        return this.BeginInvoke("AddPaymentInstrument", new object[] {
                    lDelegateIdHigh,
                    lDelegateIdLow,
                    lRequesterIdHigh,
                    lRequesterIdLow,
                    bstrTrackingGUID,
                    bstrAccountId,
                    bstrPaymentInstrumentInfoXML}, callback, asyncState);
    }
    
    /// <remarks/>
    public void EndAddPaymentInstrument(System.IAsyncResult asyncResult, out string pbstrErrorXML, out string pbstrPaymentInstrumentId, out string pbstrRequiredPaperWorkURL) {
        object[] results = this.EndInvoke(asyncResult);
        pbstrErrorXML = ((string)(results[0]));
        pbstrPaymentInstrumentId = ((string)(results[1]));
        pbstrRequiredPaperWorkURL = ((string)(results[2]));
    }
    
    /// <remarks/>
    [System.Web.Services.Protocols.SoapRpcMethodAttribute("http://tempuri.org/action/BDKServerObj2.GetPaymentInstruments", RequestNamespace="http://tempuri.org/message/", ResponseNamespace="http://tempuri.org/message/")]
    public void GetPaymentInstruments(int lDelegateIdHigh, int lDelegateIdLow, int lRequesterIdHigh, int lRequesterIdLow, string bstrObjectId, out string pbstrErrorXML, out int plPaymentInstrumentInfoCount, out string pbstrPaymentInstrumentInfoSetXML) {
        object[] results = this.Invoke("GetPaymentInstruments", new object[] {
                    lDelegateIdHigh,
                    lDelegateIdLow,
                    lRequesterIdHigh,
                    lRequesterIdLow,
                    bstrObjectId});
        pbstrErrorXML = ((string)(results[0]));
        plPaymentInstrumentInfoCount = ((int)(results[1]));
        pbstrPaymentInstrumentInfoSetXML = ((string)(results[2]));
    }
    
    /// <remarks/>
    public System.IAsyncResult BeginGetPaymentInstruments(int lDelegateIdHigh, int lDelegateIdLow, int lRequesterIdHigh, int lRequesterIdLow, string bstrObjectId, System.AsyncCallback callback, object asyncState) {
        return this.BeginInvoke("GetPaymentInstruments", new object[] {
                    lDelegateIdHigh,
                    lDelegateIdLow,
                    lRequesterIdHigh,
                    lRequesterIdLow,
                    bstrObjectId}, callback, asyncState);
    }
    
    /// <remarks/>
    public void EndGetPaymentInstruments(System.IAsyncResult asyncResult, out string pbstrErrorXML, out int plPaymentInstrumentInfoCount, out string pbstrPaymentInstrumentInfoSetXML) {
        object[] results = this.EndInvoke(asyncResult);
        pbstrErrorXML = ((string)(results[0]));
        plPaymentInstrumentInfoCount = ((int)(results[1]));
        pbstrPaymentInstrumentInfoSetXML = ((string)(results[2]));
    }
    
    /// <remarks/>
    [System.Web.Services.Protocols.SoapRpcMethodAttribute("http://tempuri.org/action/BDKServerObj2.UpdatePaymentInstrumentInfo", RequestNamespace="http://tempuri.org/message/", ResponseNamespace="http://tempuri.org/message/")]
    public void UpdatePaymentInstrumentInfo(int lDelegateIdHigh, int lDelegateIdLow, int lRequesterIdHigh, int lRequesterIdLow, string bstrPaymentInstrumentId, string bstrPaymentInstrumentInfoXML, out string pbstrErrorXML) {
        object[] results = this.Invoke("UpdatePaymentInstrumentInfo", new object[] {
                    lDelegateIdHigh,
                    lDelegateIdLow,
                    lRequesterIdHigh,
                    lRequesterIdLow,
                    bstrPaymentInstrumentId,
                    bstrPaymentInstrumentInfoXML});
        pbstrErrorXML = ((string)(results[0]));
    }
    
    /// <remarks/>
    public System.IAsyncResult BeginUpdatePaymentInstrumentInfo(int lDelegateIdHigh, int lDelegateIdLow, int lRequesterIdHigh, int lRequesterIdLow, string bstrPaymentInstrumentId, string bstrPaymentInstrumentInfoXML, System.AsyncCallback callback, object asyncState) {
        return this.BeginInvoke("UpdatePaymentInstrumentInfo", new object[] {
                    lDelegateIdHigh,
                    lDelegateIdLow,
                    lRequesterIdHigh,
                    lRequesterIdLow,
                    bstrPaymentInstrumentId,
                    bstrPaymentInstrumentInfoXML}, callback, asyncState);
    }
    
    /// <remarks/>
    public void EndUpdatePaymentInstrumentInfo(System.IAsyncResult asyncResult, out string pbstrErrorXML) {
        object[] results = this.EndInvoke(asyncResult);
        pbstrErrorXML = ((string)(results[0]));
    }
    
    /// <remarks/>
    [System.Web.Services.Protocols.SoapRpcMethodAttribute("http://tempuri.org/action/BDKServerObj2.RemovePaymentInstrument", RequestNamespace="http://tempuri.org/message/", ResponseNamespace="http://tempuri.org/message/")]
    public void RemovePaymentInstrument(int lDelegateIdHigh, int lDelegateIdLow, int lRequesterIdHigh, int lRequesterIdLow, string bstrPaymentInstrumentId, out string pbstrErrorXML) {
        object[] results = this.Invoke("RemovePaymentInstrument", new object[] {
                    lDelegateIdHigh,
                    lDelegateIdLow,
                    lRequesterIdHigh,
                    lRequesterIdLow,
                    bstrPaymentInstrumentId});
        pbstrErrorXML = ((string)(results[0]));
    }
    
    /// <remarks/>
    public System.IAsyncResult BeginRemovePaymentInstrument(int lDelegateIdHigh, int lDelegateIdLow, int lRequesterIdHigh, int lRequesterIdLow, string bstrPaymentInstrumentId, System.AsyncCallback callback, object asyncState) {
        return this.BeginInvoke("RemovePaymentInstrument", new object[] {
                    lDelegateIdHigh,
                    lDelegateIdLow,
                    lRequesterIdHigh,
                    lRequesterIdLow,
                    bstrPaymentInstrumentId}, callback, asyncState);
    }
    
    /// <remarks/>
    public void EndRemovePaymentInstrument(System.IAsyncResult asyncResult, out string pbstrErrorXML) {
        object[] results = this.EndInvoke(asyncResult);
        pbstrErrorXML = ((string)(results[0]));
    }
    
    /// <remarks/>
    [System.Web.Services.Protocols.SoapRpcMethodAttribute("http://tempuri.org/action/BDKServerObj2.ReplacePaymentInstrument", RequestNamespace="http://tempuri.org/message/", ResponseNamespace="http://tempuri.org/message/")]
    public void ReplacePaymentInstrument(int lDelegateIdHigh, int lDelegateIdLow, int lRequesterIdHigh, int lRequesterIdLow, string bstrTrackingGUID, string bstrFromPaymentInstrumentId, string bstrToPaymentInstrumentInfoXML, out string pbstrErrorXML, out string pbstrAmountChargedXML, out string pbstrPaymentInstrumentId, out string pbstrRequiredPaperWorkURL) {
        object[] results = this.Invoke("ReplacePaymentInstrument", new object[] {
                    lDelegateIdHigh,
                    lDelegateIdLow,
                    lRequesterIdHigh,
                    lRequesterIdLow,
                    bstrTrackingGUID,
                    bstrFromPaymentInstrumentId,
                    bstrToPaymentInstrumentInfoXML});
        pbstrErrorXML = ((string)(results[0]));
        pbstrAmountChargedXML = ((string)(results[1]));
        pbstrPaymentInstrumentId = ((string)(results[2]));
        pbstrRequiredPaperWorkURL = ((string)(results[3]));
    }
    
    /// <remarks/>
    public System.IAsyncResult BeginReplacePaymentInstrument(int lDelegateIdHigh, int lDelegateIdLow, int lRequesterIdHigh, int lRequesterIdLow, string bstrTrackingGUID, string bstrFromPaymentInstrumentId, string bstrToPaymentInstrumentInfoXML, System.AsyncCallback callback, object asyncState) {
        return this.BeginInvoke("ReplacePaymentInstrument", new object[] {
                    lDelegateIdHigh,
                    lDelegateIdLow,
                    lRequesterIdHigh,
                    lRequesterIdLow,
                    bstrTrackingGUID,
                    bstrFromPaymentInstrumentId,
                    bstrToPaymentInstrumentInfoXML}, callback, asyncState);
    }
    
    /// <remarks/>
    public void EndReplacePaymentInstrument(System.IAsyncResult asyncResult, out string pbstrErrorXML, out string pbstrAmountChargedXML, out string pbstrPaymentInstrumentId, out string pbstrRequiredPaperWorkURL) {
        object[] results = this.EndInvoke(asyncResult);
        pbstrErrorXML = ((string)(results[0]));
        pbstrAmountChargedXML = ((string)(results[1]));
        pbstrPaymentInstrumentId = ((string)(results[2]));
        pbstrRequiredPaperWorkURL = ((string)(results[3]));
    }
    
    /// <remarks/>
    [System.Web.Services.Protocols.SoapRpcMethodAttribute("http://tempuri.org/action/BDKServerObj2.SettleBalance", RequestNamespace="http://tempuri.org/message/", ResponseNamespace="http://tempuri.org/message/")]
    public void SettleBalance(int lDelegateIdHigh, int lDelegateIdLow, string bstrTrackingGUID, string bstrPaymentInstrumentId, out string pbstrErrorXML, out string pbstrAmountChargedXML) {
        object[] results = this.Invoke("SettleBalance", new object[] {
                    lDelegateIdHigh,
                    lDelegateIdLow,
                    bstrTrackingGUID,
                    bstrPaymentInstrumentId});
        pbstrErrorXML = ((string)(results[0]));
        pbstrAmountChargedXML = ((string)(results[1]));
    }
    
    /// <remarks/>
    public System.IAsyncResult BeginSettleBalance(int lDelegateIdHigh, int lDelegateIdLow, string bstrTrackingGUID, string bstrPaymentInstrumentId, System.AsyncCallback callback, object asyncState) {
        return this.BeginInvoke("SettleBalance", new object[] {
                    lDelegateIdHigh,
                    lDelegateIdLow,
                    bstrTrackingGUID,
                    bstrPaymentInstrumentId}, callback, asyncState);
    }
    
    /// <remarks/>
    public void EndSettleBalance(System.IAsyncResult asyncResult, out string pbstrErrorXML, out string pbstrAmountChargedXML) {
        object[] results = this.EndInvoke(asyncResult);
        pbstrErrorXML = ((string)(results[0]));
        pbstrAmountChargedXML = ((string)(results[1]));
    }
    
    /// <remarks/>
    [System.Web.Services.Protocols.SoapRpcMethodAttribute("http://tempuri.org/action/BDKServerObj2.TransferBalance", RequestNamespace="http://tempuri.org/message/", ResponseNamespace="http://tempuri.org/message/")]
    public void TransferBalance(int lDelegateIdHigh, int lDelegateIdLow, string bstrTrackingGUID, string bstrFromPaymentInstrumentId, string bstrToPaymentInstrumentId, out string pbstrErrorXML, out string pbstrAmountChargedXML) {
        object[] results = this.Invoke("TransferBalance", new object[] {
                    lDelegateIdHigh,
                    lDelegateIdLow,
                    bstrTrackingGUID,
                    bstrFromPaymentInstrumentId,
                    bstrToPaymentInstrumentId});
        pbstrErrorXML = ((string)(results[0]));
        pbstrAmountChargedXML = ((string)(results[1]));
    }
    
    /// <remarks/>
    public System.IAsyncResult BeginTransferBalance(int lDelegateIdHigh, int lDelegateIdLow, string bstrTrackingGUID, string bstrFromPaymentInstrumentId, string bstrToPaymentInstrumentId, System.AsyncCallback callback, object asyncState) {
        return this.BeginInvoke("TransferBalance", new object[] {
                    lDelegateIdHigh,
                    lDelegateIdLow,
                    bstrTrackingGUID,
                    bstrFromPaymentInstrumentId,
                    bstrToPaymentInstrumentId}, callback, asyncState);
    }
    
    /// <remarks/>
    public void EndTransferBalance(System.IAsyncResult asyncResult, out string pbstrErrorXML, out string pbstrAmountChargedXML) {
        object[] results = this.EndInvoke(asyncResult);
        pbstrErrorXML = ((string)(results[0]));
        pbstrAmountChargedXML = ((string)(results[1]));
    }
    
    /// <remarks/>
    [System.Web.Services.Protocols.SoapRpcMethodAttribute("http://tempuri.org/action/BDKServerObj2.CloseBalance", RequestNamespace="http://tempuri.org/message/", ResponseNamespace="http://tempuri.org/message/")]
    public void CloseBalance(int lDelegateIdHigh, int lDelegateIdLow, string bstrTrackingGUID, string bstrObjectId, string bstrLineItemId, out string pbstrErrorXML, out string pbstrAmountChargedXML) {
        object[] results = this.Invoke("CloseBalance", new object[] {
                    lDelegateIdHigh,
                    lDelegateIdLow,
                    bstrTrackingGUID,
                    bstrObjectId,
                    bstrLineItemId});
        pbstrErrorXML = ((string)(results[0]));
        pbstrAmountChargedXML = ((string)(results[1]));
    }
    
    /// <remarks/>
    public System.IAsyncResult BeginCloseBalance(int lDelegateIdHigh, int lDelegateIdLow, string bstrTrackingGUID, string bstrObjectId, string bstrLineItemId, System.AsyncCallback callback, object asyncState) {
        return this.BeginInvoke("CloseBalance", new object[] {
                    lDelegateIdHigh,
                    lDelegateIdLow,
                    bstrTrackingGUID,
                    bstrObjectId,
                    bstrLineItemId}, callback, asyncState);
    }
    
    /// <remarks/>
    public void EndCloseBalance(System.IAsyncResult asyncResult, out string pbstrErrorXML, out string pbstrAmountChargedXML) {
        object[] results = this.EndInvoke(asyncResult);
        pbstrErrorXML = ((string)(results[0]));
        pbstrAmountChargedXML = ((string)(results[1]));
    }
    
    /// <remarks/>
    [System.Web.Services.Protocols.SoapRpcMethodAttribute("http://tempuri.org/action/BDKServerObj2.SwitchPaymentInstruments", RequestNamespace="http://tempuri.org/message/", ResponseNamespace="http://tempuri.org/message/")]
    public void SwitchPaymentInstruments(int lDelegateIdHigh, int lDelegateIdLow, int lRequesterIdHigh, int lRequesterIdLow, string bstrTrackingGUID, string bstrFromPaymentInstrumentId, string bstrToPaymentInstrumentId, out string pbstrErrorXML, out string pbstrAmountChargedXML) {
        object[] results = this.Invoke("SwitchPaymentInstruments", new object[] {
                    lDelegateIdHigh,
                    lDelegateIdLow,
                    lRequesterIdHigh,
                    lRequesterIdLow,
                    bstrTrackingGUID,
                    bstrFromPaymentInstrumentId,
                    bstrToPaymentInstrumentId});
        pbstrErrorXML = ((string)(results[0]));
        pbstrAmountChargedXML = ((string)(results[1]));
    }
    
    /// <remarks/>
    public System.IAsyncResult BeginSwitchPaymentInstruments(int lDelegateIdHigh, int lDelegateIdLow, int lRequesterIdHigh, int lRequesterIdLow, string bstrTrackingGUID, string bstrFromPaymentInstrumentId, string bstrToPaymentInstrumentId, System.AsyncCallback callback, object asyncState) {
        return this.BeginInvoke("SwitchPaymentInstruments", new object[] {
                    lDelegateIdHigh,
                    lDelegateIdLow,
                    lRequesterIdHigh,
                    lRequesterIdLow,
                    bstrTrackingGUID,
                    bstrFromPaymentInstrumentId,
                    bstrToPaymentInstrumentId}, callback, asyncState);
    }
    
    /// <remarks/>
    public void EndSwitchPaymentInstruments(System.IAsyncResult asyncResult, out string pbstrErrorXML, out string pbstrAmountChargedXML) {
        object[] results = this.EndInvoke(asyncResult);
        pbstrErrorXML = ((string)(results[0]));
        pbstrAmountChargedXML = ((string)(results[1]));
    }
    
    /// <remarks/>
    [System.Web.Services.Protocols.SoapRpcMethodAttribute("http://tempuri.org/action/BDKServerObj2.AddComment", RequestNamespace="http://tempuri.org/message/", ResponseNamespace="http://tempuri.org/message/")]
    public void AddComment(int lDelegateIdHigh, int lDelegateIdLow, string bstrAccountId, string bstrCommentInfoXML, out string pbstrErrorXML) {
        object[] results = this.Invoke("AddComment", new object[] {
                    lDelegateIdHigh,
                    lDelegateIdLow,
                    bstrAccountId,
                    bstrCommentInfoXML});
        pbstrErrorXML = ((string)(results[0]));
    }
    
    /// <remarks/>
    public System.IAsyncResult BeginAddComment(int lDelegateIdHigh, int lDelegateIdLow, string bstrAccountId, string bstrCommentInfoXML, System.AsyncCallback callback, object asyncState) {
        return this.BeginInvoke("AddComment", new object[] {
                    lDelegateIdHigh,
                    lDelegateIdLow,
                    bstrAccountId,
                    bstrCommentInfoXML}, callback, asyncState);
    }
    
    /// <remarks/>
    public void EndAddComment(System.IAsyncResult asyncResult, out string pbstrErrorXML) {
        object[] results = this.EndInvoke(asyncResult);
        pbstrErrorXML = ((string)(results[0]));
    }
    
    /// <remarks/>
    [System.Web.Services.Protocols.SoapRpcMethodAttribute("http://tempuri.org/action/BDKServerObj2.GetComments", RequestNamespace="http://tempuri.org/message/", ResponseNamespace="http://tempuri.org/message/")]
    public void GetComments(int lDelegateIdHigh, int lDelegateIdLow, string bstrAccountId, out string pbstrErrorXML, out int plCommentInfoSetCount, out string pbstrCommentInfoSetXML) {
        object[] results = this.Invoke("GetComments", new object[] {
                    lDelegateIdHigh,
                    lDelegateIdLow,
                    bstrAccountId});
        pbstrErrorXML = ((string)(results[0]));
        plCommentInfoSetCount = ((int)(results[1]));
        pbstrCommentInfoSetXML = ((string)(results[2]));
    }
    
    /// <remarks/>
    public System.IAsyncResult BeginGetComments(int lDelegateIdHigh, int lDelegateIdLow, string bstrAccountId, System.AsyncCallback callback, object asyncState) {
        return this.BeginInvoke("GetComments", new object[] {
                    lDelegateIdHigh,
                    lDelegateIdLow,
                    bstrAccountId}, callback, asyncState);
    }
    
    /// <remarks/>
    public void EndGetComments(System.IAsyncResult asyncResult, out string pbstrErrorXML, out int plCommentInfoSetCount, out string pbstrCommentInfoSetXML) {
        object[] results = this.EndInvoke(asyncResult);
        pbstrErrorXML = ((string)(results[0]));
        plCommentInfoSetCount = ((int)(results[1]));
        pbstrCommentInfoSetXML = ((string)(results[2]));
    }
    
    /// <remarks/>
    [System.Web.Services.Protocols.SoapRpcMethodAttribute("http://tempuri.org/action/BDKServerObj2.PurchaseOffering", RequestNamespace="http://tempuri.org/message/", ResponseNamespace="http://tempuri.org/message/")]
    public void PurchaseOffering(
                int lDelegateIdHigh, 
                int lDelegateIdLow, 
                int lRequesterIdHigh, 
                int lRequesterIdLow, 
                string bstrTrackingGUID, 
                bool fComputeOnly, 
                string bstrSubscriptionName, 
                string bstrAccountId, 
                string bstrBaseSubscriptionId, 
                string bstrOfferingGUID, 
                int lOverrideAmount, 
                string bstrPaymentInstrumentId, 
                string bstrShippingAddressId, 
                string bstrActivationDate, 
                string bstrSubscriptionEndDate, 
                string bstrReferralSetXML, 
                out string pbstrErrorXML, 
                out string pbstrSubscriptionId, 
                out string pbstrAmountChargedXML, 
                out int plAddedServiceInstanceCount, 
                out string pbstrAddedServiceInstanceSetXML) {
        object[] results = this.Invoke("PurchaseOffering", new object[] {
                    lDelegateIdHigh,
                    lDelegateIdLow,
                    lRequesterIdHigh,
                    lRequesterIdLow,
                    bstrTrackingGUID,
                    fComputeOnly,
                    bstrSubscriptionName,
                    bstrAccountId,
                    bstrBaseSubscriptionId,
                    bstrOfferingGUID,
                    lOverrideAmount,
                    bstrPaymentInstrumentId,
                    bstrShippingAddressId,
                    bstrActivationDate,
                    bstrSubscriptionEndDate,
                    bstrReferralSetXML});
        pbstrErrorXML = ((string)(results[0]));
        pbstrSubscriptionId = ((string)(results[1]));
        pbstrAmountChargedXML = ((string)(results[2]));
        plAddedServiceInstanceCount = ((int)(results[3]));
        pbstrAddedServiceInstanceSetXML = ((string)(results[4]));
    }
    
    /// <remarks/>
    public System.IAsyncResult BeginPurchaseOffering(
                int lDelegateIdHigh, 
                int lDelegateIdLow, 
                int lRequesterIdHigh, 
                int lRequesterIdLow, 
                string bstrTrackingGUID, 
                bool fComputeOnly, 
                string bstrSubscriptionName, 
                string bstrAccountId, 
                string bstrBaseSubscriptionId, 
                string bstrOfferingGUID, 
                int lOverrideAmount, 
                string bstrPaymentInstrumentId, 
                string bstrShippingAddressId, 
                string bstrActivationDate, 
                string bstrSubscriptionEndDate, 
                string bstrReferralSetXML, 
                System.AsyncCallback callback, 
                object asyncState) {
        return this.BeginInvoke("PurchaseOffering", new object[] {
                    lDelegateIdHigh,
                    lDelegateIdLow,
                    lRequesterIdHigh,
                    lRequesterIdLow,
                    bstrTrackingGUID,
                    fComputeOnly,
                    bstrSubscriptionName,
                    bstrAccountId,
                    bstrBaseSubscriptionId,
                    bstrOfferingGUID,
                    lOverrideAmount,
                    bstrPaymentInstrumentId,
                    bstrShippingAddressId,
                    bstrActivationDate,
                    bstrSubscriptionEndDate,
                    bstrReferralSetXML}, callback, asyncState);
    }
    
    /// <remarks/>
    public void EndPurchaseOffering(System.IAsyncResult asyncResult, out string pbstrErrorXML, out string pbstrSubscriptionId, out string pbstrAmountChargedXML, out int plAddedServiceInstanceCount, out string pbstrAddedServiceInstanceSetXML) {
        object[] results = this.EndInvoke(asyncResult);
        pbstrErrorXML = ((string)(results[0]));
        pbstrSubscriptionId = ((string)(results[1]));
        pbstrAmountChargedXML = ((string)(results[2]));
        plAddedServiceInstanceCount = ((int)(results[3]));
        pbstrAddedServiceInstanceSetXML = ((string)(results[4]));
    }
    
    /// <remarks/>
    [System.Web.Services.Protocols.SoapRpcMethodAttribute("http://tempuri.org/action/BDKServerObj2.CancelSubscription", RequestNamespace="http://tempuri.org/message/", ResponseNamespace="http://tempuri.org/message/")]
    public void CancelSubscription(int lDelegateIdHigh, int lDelegateIdLow, int lRequesterIdHigh, int lRequesterIdLow, string bstrTrackingGUID, bool fComputeOnly, string bstrSubscriptionId, string bstrCancelDate, string bstrCommentInfoXML, out string pbstrErrorXML, out string pbstrAmountChargedXML, out string pbstrSubscriptionStatusInfoXML, out int plRemovedServiceInstanceCount, out string pbstrRemovedServiceInstanceSetXML) {
        object[] results = this.Invoke("CancelSubscription", new object[] {
                    lDelegateIdHigh,
                    lDelegateIdLow,
                    lRequesterIdHigh,
                    lRequesterIdLow,
                    bstrTrackingGUID,
                    fComputeOnly,
                    bstrSubscriptionId,
                    bstrCancelDate,
                    bstrCommentInfoXML});
        pbstrErrorXML = ((string)(results[0]));
        pbstrAmountChargedXML = ((string)(results[1]));
        pbstrSubscriptionStatusInfoXML = ((string)(results[2]));
        plRemovedServiceInstanceCount = ((int)(results[3]));
        pbstrRemovedServiceInstanceSetXML = ((string)(results[4]));
    }
    
    /// <remarks/>
    public System.IAsyncResult BeginCancelSubscription(int lDelegateIdHigh, int lDelegateIdLow, int lRequesterIdHigh, int lRequesterIdLow, string bstrTrackingGUID, bool fComputeOnly, string bstrSubscriptionId, string bstrCancelDate, string bstrCommentInfoXML, System.AsyncCallback callback, object asyncState) {
        return this.BeginInvoke("CancelSubscription", new object[] {
                    lDelegateIdHigh,
                    lDelegateIdLow,
                    lRequesterIdHigh,
                    lRequesterIdLow,
                    bstrTrackingGUID,
                    fComputeOnly,
                    bstrSubscriptionId,
                    bstrCancelDate,
                    bstrCommentInfoXML}, callback, asyncState);
    }
    
    /// <remarks/>
    public void EndCancelSubscription(System.IAsyncResult asyncResult, out string pbstrErrorXML, out string pbstrAmountChargedXML, out string pbstrSubscriptionStatusInfoXML, out int plRemovedServiceInstanceCount, out string pbstrRemovedServiceInstanceSetXML) {
        object[] results = this.EndInvoke(asyncResult);
        pbstrErrorXML = ((string)(results[0]));
        pbstrAmountChargedXML = ((string)(results[1]));
        pbstrSubscriptionStatusInfoXML = ((string)(results[2]));
        plRemovedServiceInstanceCount = ((int)(results[3]));
        pbstrRemovedServiceInstanceSetXML = ((string)(results[4]));
    }
    
    /// <remarks/>
    [System.Web.Services.Protocols.SoapRpcMethodAttribute("http://tempuri.org/action/BDKServerObj2.SearchAccounts", RequestNamespace="http://tempuri.org/message/", ResponseNamespace="http://tempuri.org/message/")]
    public void SearchAccounts(int lDelegateIdHigh, int lDelegateIdLow, bool fFullData, int lMax, string bstrSearchXML, out string pbstrErrorXML, out int pfMoreRows, out int plAccountInfoCount, out string pbstrAccountInfoSetXML) {
        object[] results = this.Invoke("SearchAccounts", new object[] {
                    lDelegateIdHigh,
                    lDelegateIdLow,
                    fFullData,
                    lMax,
                    bstrSearchXML});
        pbstrErrorXML = ((string)(results[0]));
        pfMoreRows = ((int)(results[1]));
        plAccountInfoCount = ((int)(results[2]));
        pbstrAccountInfoSetXML = ((string)(results[3]));
    }
    
    /// <remarks/>
    public System.IAsyncResult BeginSearchAccounts(int lDelegateIdHigh, int lDelegateIdLow, bool fFullData, int lMax, string bstrSearchXML, System.AsyncCallback callback, object asyncState) {
        return this.BeginInvoke("SearchAccounts", new object[] {
                    lDelegateIdHigh,
                    lDelegateIdLow,
                    fFullData,
                    lMax,
                    bstrSearchXML}, callback, asyncState);
    }
    
    /// <remarks/>
    public void EndSearchAccounts(System.IAsyncResult asyncResult, out string pbstrErrorXML, out int pfMoreRows, out int plAccountInfoCount, out string pbstrAccountInfoSetXML) {
        object[] results = this.EndInvoke(asyncResult);
        pbstrErrorXML = ((string)(results[0]));
        pfMoreRows = ((int)(results[1]));
        plAccountInfoCount = ((int)(results[2]));
        pbstrAccountInfoSetXML = ((string)(results[3]));
    }
    
    /// <remarks/>
    [System.Web.Services.Protocols.SoapRpcMethodAttribute("http://tempuri.org/action/BDKServerObj2.GetSubscriptions", RequestNamespace="http://tempuri.org/message/", ResponseNamespace="http://tempuri.org/message/")]
    public void GetSubscriptions(int lDelegateIdHigh, int lDelegateIdLow, int lRequesterIdHigh, int lRequesterIdLow, string bstrObjectId, out string pbstrErrorXML, out int plSubscriptionInfoCount, out string pbstrSubscriptionInfoSetXML) {
        object[] results = this.Invoke("GetSubscriptions", new object[] {
                    lDelegateIdHigh,
                    lDelegateIdLow,
                    lRequesterIdHigh,
                    lRequesterIdLow,
                    bstrObjectId});
        pbstrErrorXML = ((string)(results[0]));
        plSubscriptionInfoCount = ((int)(results[1]));
        pbstrSubscriptionInfoSetXML = ((string)(results[2]));
    }
    
    /// <remarks/>
    public System.IAsyncResult BeginGetSubscriptions(int lDelegateIdHigh, int lDelegateIdLow, int lRequesterIdHigh, int lRequesterIdLow, string bstrObjectId, System.AsyncCallback callback, object asyncState) {
        return this.BeginInvoke("GetSubscriptions", new object[] {
                    lDelegateIdHigh,
                    lDelegateIdLow,
                    lRequesterIdHigh,
                    lRequesterIdLow,
                    bstrObjectId}, callback, asyncState);
    }
    
    /// <remarks/>
    public void EndGetSubscriptions(System.IAsyncResult asyncResult, out string pbstrErrorXML, out int plSubscriptionInfoCount, out string pbstrSubscriptionInfoSetXML) {
        object[] results = this.EndInvoke(asyncResult);
        pbstrErrorXML = ((string)(results[0]));
        plSubscriptionInfoCount = ((int)(results[1]));
        pbstrSubscriptionInfoSetXML = ((string)(results[2]));
    }
    
    /// <remarks/>
    [System.Web.Services.Protocols.SoapRpcMethodAttribute("http://tempuri.org/action/BDKServerObj2.GetSubscriptionStatus", RequestNamespace="http://tempuri.org/message/", ResponseNamespace="http://tempuri.org/message/")]
    public void GetSubscriptionStatus(int lDelegateIdHigh, int lDelegateIdLow, int lRequesterIdHigh, int lRequesterIdLow, string bstrSubscriptionId, out string pbstrErrorXML, out string pbstrSubscriptionStatusInfoXML) {
        object[] results = this.Invoke("GetSubscriptionStatus", new object[] {
                    lDelegateIdHigh,
                    lDelegateIdLow,
                    lRequesterIdHigh,
                    lRequesterIdLow,
                    bstrSubscriptionId});
        pbstrErrorXML = ((string)(results[0]));
        pbstrSubscriptionStatusInfoXML = ((string)(results[1]));
    }
    
    /// <remarks/>
    public System.IAsyncResult BeginGetSubscriptionStatus(int lDelegateIdHigh, int lDelegateIdLow, int lRequesterIdHigh, int lRequesterIdLow, string bstrSubscriptionId, System.AsyncCallback callback, object asyncState) {
        return this.BeginInvoke("GetSubscriptionStatus", new object[] {
                    lDelegateIdHigh,
                    lDelegateIdLow,
                    lRequesterIdHigh,
                    lRequesterIdLow,
                    bstrSubscriptionId}, callback, asyncState);
    }
    
    /// <remarks/>
    public void EndGetSubscriptionStatus(System.IAsyncResult asyncResult, out string pbstrErrorXML, out string pbstrSubscriptionStatusInfoXML) {
        object[] results = this.EndInvoke(asyncResult);
        pbstrErrorXML = ((string)(results[0]));
        pbstrSubscriptionStatusInfoXML = ((string)(results[1]));
    }
    
    /// <remarks/>
    [System.Web.Services.Protocols.SoapRpcMethodAttribute("http://tempuri.org/action/BDKServerObj2.GetReferralData", RequestNamespace="http://tempuri.org/message/", ResponseNamespace="http://tempuri.org/message/")]
    public void GetReferralData(int lDelegateIdHigh, int lDelegateIdLow, string bstrSubscriptionId, out string pbstrErrorXML, out int plReferralCount, out string pbstrReferralSetXML) {
        object[] results = this.Invoke("GetReferralData", new object[] {
                    lDelegateIdHigh,
                    lDelegateIdLow,
                    bstrSubscriptionId});
        pbstrErrorXML = ((string)(results[0]));
        plReferralCount = ((int)(results[1]));
        pbstrReferralSetXML = ((string)(results[2]));
    }
    
    /// <remarks/>
    public System.IAsyncResult BeginGetReferralData(int lDelegateIdHigh, int lDelegateIdLow, string bstrSubscriptionId, System.AsyncCallback callback, object asyncState) {
        return this.BeginInvoke("GetReferralData", new object[] {
                    lDelegateIdHigh,
                    lDelegateIdLow,
                    bstrSubscriptionId}, callback, asyncState);
    }
    
    /// <remarks/>
    public void EndGetReferralData(System.IAsyncResult asyncResult, out string pbstrErrorXML, out int plReferralCount, out string pbstrReferralSetXML) {
        object[] results = this.EndInvoke(asyncResult);
        pbstrErrorXML = ((string)(results[0]));
        plReferralCount = ((int)(results[1]));
        pbstrReferralSetXML = ((string)(results[2]));
    }
    
    /// <remarks/>
    [System.Web.Services.Protocols.SoapRpcMethodAttribute("http://tempuri.org/action/BDKServerObj2.ConvertSubscription", RequestNamespace="http://tempuri.org/message/", ResponseNamespace="http://tempuri.org/message/")]
    public void ConvertSubscription(
                int lDelegateIdHigh, 
                int lDelegateIdLow, 
                int lRequesterIdHigh, 
                int lRequesterIdLow, 
                string bstrTrackingGUID, 
                bool fComputeOnly, 
                int lConvertMode, 
                int lOverrideFlags, 
                string bstrSubscriptionName, 
                string bstrSubscriptionId, 
                string bstrOfferingGUID, 
                int lOverrideAmount, 
                string bstrSubscriptionEndDate, 
                string bstrReferralSetXML, 
                out string pbstrErrorXML, 
                out string pbstrAmountChargedXML, 
                out int plAddedServiceInstanceSetCount, 
                out string pbstrAddedServiceInstanceSet, 
                out int plRemovedServiceInstanceSetCount, 
                out string pbstrRemoveServiceInstanceSet) {
        object[] results = this.Invoke("ConvertSubscription", new object[] {
                    lDelegateIdHigh,
                    lDelegateIdLow,
                    lRequesterIdHigh,
                    lRequesterIdLow,
                    bstrTrackingGUID,
                    fComputeOnly,
                    lConvertMode,
                    lOverrideFlags,
                    bstrSubscriptionName,
                    bstrSubscriptionId,
                    bstrOfferingGUID,
                    lOverrideAmount,
                    bstrSubscriptionEndDate,
                    bstrReferralSetXML});
        pbstrErrorXML = ((string)(results[0]));
        pbstrAmountChargedXML = ((string)(results[1]));
        plAddedServiceInstanceSetCount = ((int)(results[2]));
        pbstrAddedServiceInstanceSet = ((string)(results[3]));
        plRemovedServiceInstanceSetCount = ((int)(results[4]));
        pbstrRemoveServiceInstanceSet = ((string)(results[5]));
    }
    
    /// <remarks/>
    public System.IAsyncResult BeginConvertSubscription(
                int lDelegateIdHigh, 
                int lDelegateIdLow, 
                int lRequesterIdHigh, 
                int lRequesterIdLow, 
                string bstrTrackingGUID, 
                bool fComputeOnly, 
                int lConvertMode, 
                int lOverrideFlags, 
                string bstrSubscriptionName, 
                string bstrSubscriptionId, 
                string bstrOfferingGUID, 
                int lOverrideAmount, 
                string bstrSubscriptionEndDate, 
                string bstrReferralSetXML, 
                System.AsyncCallback callback, 
                object asyncState) {
        return this.BeginInvoke("ConvertSubscription", new object[] {
                    lDelegateIdHigh,
                    lDelegateIdLow,
                    lRequesterIdHigh,
                    lRequesterIdLow,
                    bstrTrackingGUID,
                    fComputeOnly,
                    lConvertMode,
                    lOverrideFlags,
                    bstrSubscriptionName,
                    bstrSubscriptionId,
                    bstrOfferingGUID,
                    lOverrideAmount,
                    bstrSubscriptionEndDate,
                    bstrReferralSetXML}, callback, asyncState);
    }
    
    /// <remarks/>
    public void EndConvertSubscription(System.IAsyncResult asyncResult, out string pbstrErrorXML, out string pbstrAmountChargedXML, out int plAddedServiceInstanceSetCount, out string pbstrAddedServiceInstanceSet, out int plRemovedServiceInstanceSetCount, out string pbstrRemoveServiceInstanceSet) {
        object[] results = this.EndInvoke(asyncResult);
        pbstrErrorXML = ((string)(results[0]));
        pbstrAmountChargedXML = ((string)(results[1]));
        plAddedServiceInstanceSetCount = ((int)(results[2]));
        pbstrAddedServiceInstanceSet = ((string)(results[3]));
        plRemovedServiceInstanceSetCount = ((int)(results[4]));
        pbstrRemoveServiceInstanceSet = ((string)(results[5]));
    }
    
    /// <remarks/>
    [System.Web.Services.Protocols.SoapRpcMethodAttribute("http://tempuri.org/action/BDKServerObj2.UpdateSubscriptionInfo", RequestNamespace="http://tempuri.org/message/", ResponseNamespace="http://tempuri.org/message/")]
    public void UpdateSubscriptionInfo(int lDelegateIdHigh, int lDelegateIdLow, int lRequesterIdHigh, int lRequesterIdLow, string bstrTrackingGUID, string bstrSubscriptionId, string bstrSubscriptionInfoXML, string bstrReferralSetXML, out string pbstrErrorXML) {
        object[] results = this.Invoke("UpdateSubscriptionInfo", new object[] {
                    lDelegateIdHigh,
                    lDelegateIdLow,
                    lRequesterIdHigh,
                    lRequesterIdLow,
                    bstrTrackingGUID,
                    bstrSubscriptionId,
                    bstrSubscriptionInfoXML,
                    bstrReferralSetXML});
        pbstrErrorXML = ((string)(results[0]));
    }
    
    /// <remarks/>
    public System.IAsyncResult BeginUpdateSubscriptionInfo(int lDelegateIdHigh, int lDelegateIdLow, int lRequesterIdHigh, int lRequesterIdLow, string bstrTrackingGUID, string bstrSubscriptionId, string bstrSubscriptionInfoXML, string bstrReferralSetXML, System.AsyncCallback callback, object asyncState) {
        return this.BeginInvoke("UpdateSubscriptionInfo", new object[] {
                    lDelegateIdHigh,
                    lDelegateIdLow,
                    lRequesterIdHigh,
                    lRequesterIdLow,
                    bstrTrackingGUID,
                    bstrSubscriptionId,
                    bstrSubscriptionInfoXML,
                    bstrReferralSetXML}, callback, asyncState);
    }
    
    /// <remarks/>
    public void EndUpdateSubscriptionInfo(System.IAsyncResult asyncResult, out string pbstrErrorXML) {
        object[] results = this.EndInvoke(asyncResult);
        pbstrErrorXML = ((string)(results[0]));
    }
    
    /// <remarks/>
    [System.Web.Services.Protocols.SoapRpcMethodAttribute("http://tempuri.org/action/BDKServerObj2.GetAccountStatus", RequestNamespace="http://tempuri.org/message/", ResponseNamespace="http://tempuri.org/message/")]
    public void GetAccountStatus(int lDelegateIdHigh, int lDelegateIdLow, int lRequesterIdHigh, int lRequesterIdLow, string bstrAccountId, out string pbstrErrorXML, out string pbstrAccountStatusInfoXML) {
        object[] results = this.Invoke("GetAccountStatus", new object[] {
                    lDelegateIdHigh,
                    lDelegateIdLow,
                    lRequesterIdHigh,
                    lRequesterIdLow,
                    bstrAccountId});
        pbstrErrorXML = ((string)(results[0]));
        pbstrAccountStatusInfoXML = ((string)(results[1]));
    }
    
    /// <remarks/>
    public System.IAsyncResult BeginGetAccountStatus(int lDelegateIdHigh, int lDelegateIdLow, int lRequesterIdHigh, int lRequesterIdLow, string bstrAccountId, System.AsyncCallback callback, object asyncState) {
        return this.BeginInvoke("GetAccountStatus", new object[] {
                    lDelegateIdHigh,
                    lDelegateIdLow,
                    lRequesterIdHigh,
                    lRequesterIdLow,
                    bstrAccountId}, callback, asyncState);
    }
    
    /// <remarks/>
    public void EndGetAccountStatus(System.IAsyncResult asyncResult, out string pbstrErrorXML, out string pbstrAccountStatusInfoXML) {
        object[] results = this.EndInvoke(asyncResult);
        pbstrErrorXML = ((string)(results[0]));
        pbstrAccountStatusInfoXML = ((string)(results[1]));
    }
    
    /// <remarks/>
    [System.Web.Services.Protocols.SoapRpcMethodAttribute("http://tempuri.org/action/BDKServerObj2.GetBaseOfferings", RequestNamespace="http://tempuri.org/message/", ResponseNamespace="http://tempuri.org/message/")]
    public void GetBaseOfferings(string bstrOfferingGUID, string bstrCategory, string bstrCountry, string bstrLocale, string bstrCurrency, out string pbstrErrorText, out int plOfferingInfoCount, out string pbstrOfferingInfoSetXML) {
        object[] results = this.Invoke("GetBaseOfferings", new object[] {
                    bstrOfferingGUID,
                    bstrCategory,
                    bstrCountry,
                    bstrLocale,
                    bstrCurrency});
        pbstrErrorText = ((string)(results[0]));
        plOfferingInfoCount = ((int)(results[1]));
        pbstrOfferingInfoSetXML = ((string)(results[2]));
    }
    
    /// <remarks/>
    public System.IAsyncResult BeginGetBaseOfferings(string bstrOfferingGUID, string bstrCategory, string bstrCountry, string bstrLocale, string bstrCurrency, System.AsyncCallback callback, object asyncState) {
        return this.BeginInvoke("GetBaseOfferings", new object[] {
                    bstrOfferingGUID,
                    bstrCategory,
                    bstrCountry,
                    bstrLocale,
                    bstrCurrency}, callback, asyncState);
    }
    
    /// <remarks/>
    public void EndGetBaseOfferings(System.IAsyncResult asyncResult, out string pbstrErrorText, out int plOfferingInfoCount, out string pbstrOfferingInfoSetXML) {
        object[] results = this.EndInvoke(asyncResult);
        pbstrErrorText = ((string)(results[0]));
        plOfferingInfoCount = ((int)(results[1]));
        pbstrOfferingInfoSetXML = ((string)(results[2]));
    }
    
    /// <remarks/>
    [System.Web.Services.Protocols.SoapRpcMethodAttribute("http://tempuri.org/action/BDKServerObj2.GetEligibleOfferings", RequestNamespace="http://tempuri.org/message/", ResponseNamespace="http://tempuri.org/message/")]
    public void GetEligibleOfferings(int lDelegateIdHigh, int lDelegateIdLow, int lRequesterIdHigh, int lRequesterIdLow, string bstrAccountId, string bstrOfferingGUID, string bstrCategory, string bstrFilter, out string pbstrErrorText, out int plOfferingInfoCount, out string pbstrOfferingInfoSetXML) {
        object[] results = this.Invoke("GetEligibleOfferings", new object[] {
                    lDelegateIdHigh,
                    lDelegateIdLow,
                    lRequesterIdHigh,
                    lRequesterIdLow,
                    bstrAccountId,
                    bstrOfferingGUID,
                    bstrCategory,
                    bstrFilter});
        pbstrErrorText = ((string)(results[0]));
        plOfferingInfoCount = ((int)(results[1]));
        pbstrOfferingInfoSetXML = ((string)(results[2]));
    }
    
    /// <remarks/>
    public System.IAsyncResult BeginGetEligibleOfferings(int lDelegateIdHigh, int lDelegateIdLow, int lRequesterIdHigh, int lRequesterIdLow, string bstrAccountId, string bstrOfferingGUID, string bstrCategory, string bstrFilter, System.AsyncCallback callback, object asyncState) {
        return this.BeginInvoke("GetEligibleOfferings", new object[] {
                    lDelegateIdHigh,
                    lDelegateIdLow,
                    lRequesterIdHigh,
                    lRequesterIdLow,
                    bstrAccountId,
                    bstrOfferingGUID,
                    bstrCategory,
                    bstrFilter}, callback, asyncState);
    }
    
    /// <remarks/>
    public void EndGetEligibleOfferings(System.IAsyncResult asyncResult, out string pbstrErrorText, out int plOfferingInfoCount, out string pbstrOfferingInfoSetXML) {
        object[] results = this.EndInvoke(asyncResult);
        pbstrErrorText = ((string)(results[0]));
        plOfferingInfoCount = ((int)(results[1]));
        pbstrOfferingInfoSetXML = ((string)(results[2]));
    }
    
    /// <remarks/>
    [System.Web.Services.Protocols.SoapRpcMethodAttribute("http://tempuri.org/action/BDKServerObj2.GetServiceComponents", RequestNamespace="http://tempuri.org/message/", ResponseNamespace="http://tempuri.org/message/")]
    public void GetServiceComponents(string bstrOfferingGUID, out string pbstrErrorText, out int plServiceComponentCount, out string pbstrServiceComponentSetXML) {
        object[] results = this.Invoke("GetServiceComponents", new object[] {
                    bstrOfferingGUID});
        pbstrErrorText = ((string)(results[0]));
        plServiceComponentCount = ((int)(results[1]));
        pbstrServiceComponentSetXML = ((string)(results[2]));
    }
    
    /// <remarks/>
    public System.IAsyncResult BeginGetServiceComponents(string bstrOfferingGUID, System.AsyncCallback callback, object asyncState) {
        return this.BeginInvoke("GetServiceComponents", new object[] {
                    bstrOfferingGUID}, callback, asyncState);
    }
    
    /// <remarks/>
    public void EndGetServiceComponents(System.IAsyncResult asyncResult, out string pbstrErrorText, out int plServiceComponentCount, out string pbstrServiceComponentSetXML) {
        object[] results = this.EndInvoke(asyncResult);
        pbstrErrorText = ((string)(results[0]));
        plServiceComponentCount = ((int)(results[1]));
        pbstrServiceComponentSetXML = ((string)(results[2]));
    }
    
    /// <remarks/>
    [System.Web.Services.Protocols.SoapRpcMethodAttribute("http://tempuri.org/action/BDKServerObj2.ValidateProvisioningData", RequestNamespace="http://tempuri.org/message/", ResponseNamespace="http://tempuri.org/message/")]
    public void ValidateProvisioningData(int lDelegateIdHigh, int lDelegateIdLow, int lRequesterIdHigh, int lRequesterIdLow, string bstrServiceComponentId, string bstrDetailsXML, out string pbstrErrorXML, out string pbstrResponseXML) {
        object[] results = this.Invoke("ValidateProvisioningData", new object[] {
                    lDelegateIdHigh,
                    lDelegateIdLow,
                    lRequesterIdHigh,
                    lRequesterIdLow,
                    bstrServiceComponentId,
                    bstrDetailsXML});
        pbstrErrorXML = ((string)(results[0]));
        pbstrResponseXML = ((string)(results[1]));
    }
    
    /// <remarks/>
    public System.IAsyncResult BeginValidateProvisioningData(int lDelegateIdHigh, int lDelegateIdLow, int lRequesterIdHigh, int lRequesterIdLow, string bstrServiceComponentId, string bstrDetailsXML, System.AsyncCallback callback, object asyncState) {
        return this.BeginInvoke("ValidateProvisioningData", new object[] {
                    lDelegateIdHigh,
                    lDelegateIdLow,
                    lRequesterIdHigh,
                    lRequesterIdLow,
                    bstrServiceComponentId,
                    bstrDetailsXML}, callback, asyncState);
    }
    
    /// <remarks/>
    public void EndValidateProvisioningData(System.IAsyncResult asyncResult, out string pbstrErrorXML, out string pbstrResponseXML) {
        object[] results = this.EndInvoke(asyncResult);
        pbstrErrorXML = ((string)(results[0]));
        pbstrResponseXML = ((string)(results[1]));
    }
    
    /// <remarks/>
    [System.Web.Services.Protocols.SoapRpcMethodAttribute("http://tempuri.org/action/BDKServerObj2.CheckProvisioningStatus", RequestNamespace="http://tempuri.org/message/", ResponseNamespace="http://tempuri.org/message/")]
    public void CheckProvisioningStatus(int lDelegateIdHigh, int lDelegateIdLow, int lRequesterIdHigh, int lRequesterIdLow, string bstrServiceComponentId, out string pbstrErrorXML, out string pbstrResponseXML) {
        object[] results = this.Invoke("CheckProvisioningStatus", new object[] {
                    lDelegateIdHigh,
                    lDelegateIdLow,
                    lRequesterIdHigh,
                    lRequesterIdLow,
                    bstrServiceComponentId});
        pbstrErrorXML = ((string)(results[0]));
        pbstrResponseXML = ((string)(results[1]));
    }
    
    /// <remarks/>
    public System.IAsyncResult BeginCheckProvisioningStatus(int lDelegateIdHigh, int lDelegateIdLow, int lRequesterIdHigh, int lRequesterIdLow, string bstrServiceComponentId, System.AsyncCallback callback, object asyncState) {
        return this.BeginInvoke("CheckProvisioningStatus", new object[] {
                    lDelegateIdHigh,
                    lDelegateIdLow,
                    lRequesterIdHigh,
                    lRequesterIdLow,
                    bstrServiceComponentId}, callback, asyncState);
    }
    
    /// <remarks/>
    public void EndCheckProvisioningStatus(System.IAsyncResult asyncResult, out string pbstrErrorXML, out string pbstrResponseXML) {
        object[] results = this.EndInvoke(asyncResult);
        pbstrErrorXML = ((string)(results[0]));
        pbstrResponseXML = ((string)(results[1]));
    }
    
    /// <remarks/>
    [System.Web.Services.Protocols.SoapRpcMethodAttribute("http://tempuri.org/action/BDKServerObj2.ProvisionServices", RequestNamespace="http://tempuri.org/message/", ResponseNamespace="http://tempuri.org/message/")]
    public void ProvisionServices(int lDelegateIdHigh, int lDelegateIdLow, int lRequesterIdHigh, int lRequesterIdLow, string bstrServiceInstanceSetXML, out string pbstrErrorXML) {
        object[] results = this.Invoke("ProvisionServices", new object[] {
                    lDelegateIdHigh,
                    lDelegateIdLow,
                    lRequesterIdHigh,
                    lRequesterIdLow,
                    bstrServiceInstanceSetXML});
        pbstrErrorXML = ((string)(results[0]));
    }
    
    /// <remarks/>
    public System.IAsyncResult BeginProvisionServices(int lDelegateIdHigh, int lDelegateIdLow, int lRequesterIdHigh, int lRequesterIdLow, string bstrServiceInstanceSetXML, System.AsyncCallback callback, object asyncState) {
        return this.BeginInvoke("ProvisionServices", new object[] {
                    lDelegateIdHigh,
                    lDelegateIdLow,
                    lRequesterIdHigh,
                    lRequesterIdLow,
                    bstrServiceInstanceSetXML}, callback, asyncState);
    }
    
    /// <remarks/>
    public void EndProvisionServices(System.IAsyncResult asyncResult, out string pbstrErrorXML) {
        object[] results = this.EndInvoke(asyncResult);
        pbstrErrorXML = ((string)(results[0]));
    }
    
    /// <remarks/>
    [System.Web.Services.Protocols.SoapRpcMethodAttribute("http://tempuri.org/action/BDKServerObj2.DeprovisionServices", RequestNamespace="http://tempuri.org/message/", ResponseNamespace="http://tempuri.org/message/")]
    public void DeprovisionServices(int lDelegateIdHigh, int lDelegateIdLow, int lRequesterIdHigh, int lRequesterIdLow, string bstrServiceInstanceSetXML, out string pbstrErrorXML) {
        object[] results = this.Invoke("DeprovisionServices", new object[] {
                    lDelegateIdHigh,
                    lDelegateIdLow,
                    lRequesterIdHigh,
                    lRequesterIdLow,
                    bstrServiceInstanceSetXML});
        pbstrErrorXML = ((string)(results[0]));
    }
    
    /// <remarks/>
    public System.IAsyncResult BeginDeprovisionServices(int lDelegateIdHigh, int lDelegateIdLow, int lRequesterIdHigh, int lRequesterIdLow, string bstrServiceInstanceSetXML, System.AsyncCallback callback, object asyncState) {
        return this.BeginInvoke("DeprovisionServices", new object[] {
                    lDelegateIdHigh,
                    lDelegateIdLow,
                    lRequesterIdHigh,
                    lRequesterIdLow,
                    bstrServiceInstanceSetXML}, callback, asyncState);
    }
    
    /// <remarks/>
    public void EndDeprovisionServices(System.IAsyncResult asyncResult, out string pbstrErrorXML) {
        object[] results = this.EndInvoke(asyncResult);
        pbstrErrorXML = ((string)(results[0]));
    }
    
    /// <remarks/>
    [System.Web.Services.Protocols.SoapRpcMethodAttribute("http://tempuri.org/action/BDKServerObj2.ReportUsageEvent", RequestNamespace="http://tempuri.org/message/", ResponseNamespace="http://tempuri.org/message/")]
    public void ReportUsageEvent(string bstrTrackingGUID, string bstrUsageSetXML, out string pbstrErrorXML) {
        object[] results = this.Invoke("ReportUsageEvent", new object[] {
                    bstrTrackingGUID,
                    bstrUsageSetXML});
        pbstrErrorXML = ((string)(results[0]));
    }
    
    /// <remarks/>
    public System.IAsyncResult BeginReportUsageEvent(string bstrTrackingGUID, string bstrUsageSetXML, System.AsyncCallback callback, object asyncState) {
        return this.BeginInvoke("ReportUsageEvent", new object[] {
                    bstrTrackingGUID,
                    bstrUsageSetXML}, callback, asyncState);
    }
    
    /// <remarks/>
    public void EndReportUsageEvent(System.IAsyncResult asyncResult, out string pbstrErrorXML) {
        object[] results = this.EndInvoke(asyncResult);
        pbstrErrorXML = ((string)(results[0]));
    }
    
    /// <remarks/>
    [System.Web.Services.Protocols.SoapRpcMethodAttribute("http://tempuri.org/action/BDKServerObj2.GetResourceBalances", RequestNamespace="http://tempuri.org/message/", ResponseNamespace="http://tempuri.org/message/")]
    public void GetResourceBalances(int lDelegateIdHigh, int lDelegateIdLow, int lRequesterIdHigh, int lRequesterIdLow, string bstrObjectId, string bstrResourceGUID, out string pbstrErrorText, out int pcResourceInfoCount, out string pbstrResourceInfoSet) {
        object[] results = this.Invoke("GetResourceBalances", new object[] {
                    lDelegateIdHigh,
                    lDelegateIdLow,
                    lRequesterIdHigh,
                    lRequesterIdLow,
                    bstrObjectId,
                    bstrResourceGUID});
        pbstrErrorText = ((string)(results[0]));
        pcResourceInfoCount = ((int)(results[1]));
        pbstrResourceInfoSet = ((string)(results[2]));
    }
    
    /// <remarks/>
    public System.IAsyncResult BeginGetResourceBalances(int lDelegateIdHigh, int lDelegateIdLow, int lRequesterIdHigh, int lRequesterIdLow, string bstrObjectId, string bstrResourceGUID, System.AsyncCallback callback, object asyncState) {
        return this.BeginInvoke("GetResourceBalances", new object[] {
                    lDelegateIdHigh,
                    lDelegateIdLow,
                    lRequesterIdHigh,
                    lRequesterIdLow,
                    bstrObjectId,
                    bstrResourceGUID}, callback, asyncState);
    }
    
    /// <remarks/>
    public void EndGetResourceBalances(System.IAsyncResult asyncResult, out string pbstrErrorText, out int pcResourceInfoCount, out string pbstrResourceInfoSet) {
        object[] results = this.EndInvoke(asyncResult);
        pbstrErrorText = ((string)(results[0]));
        pcResourceInfoCount = ((int)(results[1]));
        pbstrResourceInfoSet = ((string)(results[2]));
    }
    
    /// <remarks/>
    [System.Web.Services.Protocols.SoapRpcMethodAttribute("http://tempuri.org/action/BDKServerObj2.AdjustResourceBalance", RequestNamespace="http://tempuri.org/message/", ResponseNamespace="http://tempuri.org/message/")]
    public void AdjustResourceBalance(int lDelegateIdHigh, int lDelegateIdLow, string bstrTrackingGUID, string bstrObjectId, string bstrResourceGUID, int lNumberOfUnits, string bstrUnitsOfMeasure, string bstrCommentInfoXML, out string pbstrError) {
        object[] results = this.Invoke("AdjustResourceBalance", new object[] {
                    lDelegateIdHigh,
                    lDelegateIdLow,
                    bstrTrackingGUID,
                    bstrObjectId,
                    bstrResourceGUID,
                    lNumberOfUnits,
                    bstrUnitsOfMeasure,
                    bstrCommentInfoXML});
        pbstrError = ((string)(results[0]));
    }
    
    /// <remarks/>
    public System.IAsyncResult BeginAdjustResourceBalance(int lDelegateIdHigh, int lDelegateIdLow, string bstrTrackingGUID, string bstrObjectId, string bstrResourceGUID, int lNumberOfUnits, string bstrUnitsOfMeasure, string bstrCommentInfoXML, System.AsyncCallback callback, object asyncState) {
        return this.BeginInvoke("AdjustResourceBalance", new object[] {
                    lDelegateIdHigh,
                    lDelegateIdLow,
                    bstrTrackingGUID,
                    bstrObjectId,
                    bstrResourceGUID,
                    lNumberOfUnits,
                    bstrUnitsOfMeasure,
                    bstrCommentInfoXML}, callback, asyncState);
    }
    
    /// <remarks/>
    public void EndAdjustResourceBalance(System.IAsyncResult asyncResult, out string pbstrError) {
        object[] results = this.EndInvoke(asyncResult);
        pbstrError = ((string)(results[0]));
    }
    
    /// <remarks/>
    [System.Web.Services.Protocols.SoapRpcMethodAttribute("http://tempuri.org/action/BDKServerObj2.CreditPaymentInstrument", RequestNamespace="http://tempuri.org/message/", ResponseNamespace="http://tempuri.org/message/")]
    public void CreditPaymentInstrument(int lDelegateIdHigh, int lDelegateIdLow, string bstrTrackingGUID, string bstrPaymentInstrumentId, int lFinancialReportingCode, string bstrAmount, bool fImmediatelySettle, string bstrCommentInfoXML, out string pbstrError) {
        object[] results = this.Invoke("CreditPaymentInstrument", new object[] {
                    lDelegateIdHigh,
                    lDelegateIdLow,
                    bstrTrackingGUID,
                    bstrPaymentInstrumentId,
                    lFinancialReportingCode,
                    bstrAmount,
                    fImmediatelySettle,
                    bstrCommentInfoXML});
        pbstrError = ((string)(results[0]));
    }
    
    /// <remarks/>
    public System.IAsyncResult BeginCreditPaymentInstrument(int lDelegateIdHigh, int lDelegateIdLow, string bstrTrackingGUID, string bstrPaymentInstrumentId, int lFinancialReportingCode, string bstrAmount, bool fImmediatelySettle, string bstrCommentInfoXML, System.AsyncCallback callback, object asyncState) {
        return this.BeginInvoke("CreditPaymentInstrument", new object[] {
                    lDelegateIdHigh,
                    lDelegateIdLow,
                    bstrTrackingGUID,
                    bstrPaymentInstrumentId,
                    lFinancialReportingCode,
                    bstrAmount,
                    fImmediatelySettle,
                    bstrCommentInfoXML}, callback, asyncState);
    }
    
    /// <remarks/>
    public void EndCreditPaymentInstrument(System.IAsyncResult asyncResult, out string pbstrError) {
        object[] results = this.EndInvoke(asyncResult);
        pbstrError = ((string)(results[0]));
    }
    
    /// <remarks/>
    [System.Web.Services.Protocols.SoapRpcMethodAttribute("http://tempuri.org/action/BDKServerObj2.OffsetLineItem", RequestNamespace="http://tempuri.org/message/", ResponseNamespace="http://tempuri.org/message/")]
    public void OffsetLineItem(int lDelegateIdHigh, int lDelegateIdLow, string bstrTrackingGUID, string bstrLineItemId, int lFinancialReportingCode, bool fImmediatelySettle, string bstrAmount, string bstrCommentInfoXML, out string pbstrError) {
        object[] results = this.Invoke("OffsetLineItem", new object[] {
                    lDelegateIdHigh,
                    lDelegateIdLow,
                    bstrTrackingGUID,
                    bstrLineItemId,
                    lFinancialReportingCode,
                    fImmediatelySettle,
                    bstrAmount,
                    bstrCommentInfoXML});
        pbstrError = ((string)(results[0]));
    }
    
    /// <remarks/>
    public System.IAsyncResult BeginOffsetLineItem(int lDelegateIdHigh, int lDelegateIdLow, string bstrTrackingGUID, string bstrLineItemId, int lFinancialReportingCode, bool fImmediatelySettle, string bstrAmount, string bstrCommentInfoXML, System.AsyncCallback callback, object asyncState) {
        return this.BeginInvoke("OffsetLineItem", new object[] {
                    lDelegateIdHigh,
                    lDelegateIdLow,
                    bstrTrackingGUID,
                    bstrLineItemId,
                    lFinancialReportingCode,
                    fImmediatelySettle,
                    bstrAmount,
                    bstrCommentInfoXML}, callback, asyncState);
    }
    
    /// <remarks/>
    public void EndOffsetLineItem(System.IAsyncResult asyncResult, out string pbstrError) {
        object[] results = this.EndInvoke(asyncResult);
        pbstrError = ((string)(results[0]));
    }
    
    /// <remarks/>
    [System.Web.Services.Protocols.SoapRpcMethodAttribute("http://tempuri.org/action/BDKServerObj2.TestConnection", RequestNamespace="http://tempuri.org/message/", ResponseNamespace="http://tempuri.org/message/")]
    public void TestConnection(string bstrInputString, out string pbstrOutputString) {
        object[] results = this.Invoke("TestConnection", new object[] {
                    bstrInputString});
        pbstrOutputString = ((string)(results[0]));
    }
    
    /// <remarks/>
    public System.IAsyncResult BeginTestConnection(string bstrInputString, System.AsyncCallback callback, object asyncState) {
        return this.BeginInvoke("TestConnection", new object[] {
                    bstrInputString}, callback, asyncState);
    }
    
    /// <remarks/>
    public void EndTestConnection(System.IAsyncResult asyncResult, out string pbstrOutputString) {
        object[] results = this.EndInvoke(asyncResult);
        pbstrOutputString = ((string)(results[0]));
    }
    
    /// <remarks/>
    [System.Web.Services.Protocols.SoapRpcMethodAttribute("http://tempuri.org/action/BDKServerObj2.BanUser", RequestNamespace="http://tempuri.org/message/", ResponseNamespace="http://tempuri.org/message/")]
    public void BanUser(int lDelegateIdHigh, int lDelegateIdLow, int lReasonCode, string bstrAccountInfoXML, out string pbstrErrorXML) {
        object[] results = this.Invoke("BanUser", new object[] {
                    lDelegateIdHigh,
                    lDelegateIdLow,
                    lReasonCode,
                    bstrAccountInfoXML});
        pbstrErrorXML = ((string)(results[0]));
    }
    
    /// <remarks/>
    public System.IAsyncResult BeginBanUser(int lDelegateIdHigh, int lDelegateIdLow, int lReasonCode, string bstrAccountInfoXML, System.AsyncCallback callback, object asyncState) {
        return this.BeginInvoke("BanUser", new object[] {
                    lDelegateIdHigh,
                    lDelegateIdLow,
                    lReasonCode,
                    bstrAccountInfoXML}, callback, asyncState);
    }
    
    /// <remarks/>
    public void EndBanUser(System.IAsyncResult asyncResult, out string pbstrErrorXML) {
        object[] results = this.EndInvoke(asyncResult);
        pbstrErrorXML = ((string)(results[0]));
    }
    
    /// <remarks/>
    [System.Web.Services.Protocols.SoapRpcMethodAttribute("http://tempuri.org/action/BDKServerObj2.UnbanUser", RequestNamespace="http://tempuri.org/message/", ResponseNamespace="http://tempuri.org/message/")]
    public void UnbanUser(int lDelegateIdHigh, int lDelegateIdLow, string bstrAccountInfoXML, out string pbstrErrorXML) {
        object[] results = this.Invoke("UnbanUser", new object[] {
                    lDelegateIdHigh,
                    lDelegateIdLow,
                    bstrAccountInfoXML});
        pbstrErrorXML = ((string)(results[0]));
    }
    
    /// <remarks/>
    public System.IAsyncResult BeginUnbanUser(int lDelegateIdHigh, int lDelegateIdLow, string bstrAccountInfoXML, System.AsyncCallback callback, object asyncState) {
        return this.BeginInvoke("UnbanUser", new object[] {
                    lDelegateIdHigh,
                    lDelegateIdLow,
                    bstrAccountInfoXML}, callback, asyncState);
    }
    
    /// <remarks/>
    public void EndUnbanUser(System.IAsyncResult asyncResult, out string pbstrErrorXML) {
        object[] results = this.EndInvoke(asyncResult);
        pbstrErrorXML = ((string)(results[0]));
    }
    
    /// <remarks/>
    [System.Web.Services.Protocols.SoapRpcMethodAttribute("http://tempuri.org/action/BDKServerObj2.BanPaymentInstrument", RequestNamespace="http://tempuri.org/message/", ResponseNamespace="http://tempuri.org/message/")]
    public void BanPaymentInstrument(int lDelegateIdHigh, int lDelegateIdLow, int lReasonCode, string bstrPaymentInstrumentInfoXML, out string pbstrErrorXML) {
        object[] results = this.Invoke("BanPaymentInstrument", new object[] {
                    lDelegateIdHigh,
                    lDelegateIdLow,
                    lReasonCode,
                    bstrPaymentInstrumentInfoXML});
        pbstrErrorXML = ((string)(results[0]));
    }
    
    /// <remarks/>
    public System.IAsyncResult BeginBanPaymentInstrument(int lDelegateIdHigh, int lDelegateIdLow, int lReasonCode, string bstrPaymentInstrumentInfoXML, System.AsyncCallback callback, object asyncState) {
        return this.BeginInvoke("BanPaymentInstrument", new object[] {
                    lDelegateIdHigh,
                    lDelegateIdLow,
                    lReasonCode,
                    bstrPaymentInstrumentInfoXML}, callback, asyncState);
    }
    
    /// <remarks/>
    public void EndBanPaymentInstrument(System.IAsyncResult asyncResult, out string pbstrErrorXML) {
        object[] results = this.EndInvoke(asyncResult);
        pbstrErrorXML = ((string)(results[0]));
    }
    
    /// <remarks/>
    [System.Web.Services.Protocols.SoapRpcMethodAttribute("http://tempuri.org/action/BDKServerObj2.UnbanPaymentInstrument", RequestNamespace="http://tempuri.org/message/", ResponseNamespace="http://tempuri.org/message/")]
    public void UnbanPaymentInstrument(int lDelegateIdHigh, int lDelegateIdLow, string bstrPaymentInstrumentInfoXML, out string pbstrErrorXML) {
        object[] results = this.Invoke("UnbanPaymentInstrument", new object[] {
                    lDelegateIdHigh,
                    lDelegateIdLow,
                    bstrPaymentInstrumentInfoXML});
        pbstrErrorXML = ((string)(results[0]));
    }
    
    /// <remarks/>
    public System.IAsyncResult BeginUnbanPaymentInstrument(int lDelegateIdHigh, int lDelegateIdLow, string bstrPaymentInstrumentInfoXML, System.AsyncCallback callback, object asyncState) {
        return this.BeginInvoke("UnbanPaymentInstrument", new object[] {
                    lDelegateIdHigh,
                    lDelegateIdLow,
                    bstrPaymentInstrumentInfoXML}, callback, asyncState);
    }
    
    /// <remarks/>
    public void EndUnbanPaymentInstrument(System.IAsyncResult asyncResult, out string pbstrErrorXML) {
        object[] results = this.EndInvoke(asyncResult);
        pbstrErrorXML = ((string)(results[0]));
    }
    
    /// <remarks/>
    [System.Web.Services.Protocols.SoapRpcMethodAttribute("http://tempuri.org/action/BDKServerObj2.IsPaymentInstrumentBanned", RequestNamespace="http://tempuri.org/message/", ResponseNamespace="http://tempuri.org/message/")]
    public void IsPaymentInstrumentBanned(int lDelegateIdHigh, int lDelegateIdLow, string bstrPaymentInstrumentInfoXML, out string pbstrErrorXML, out int plIsBanned) {
        object[] results = this.Invoke("IsPaymentInstrumentBanned", new object[] {
                    lDelegateIdHigh,
                    lDelegateIdLow,
                    bstrPaymentInstrumentInfoXML});
        pbstrErrorXML = ((string)(results[0]));
        plIsBanned = ((int)(results[1]));
    }
    
    /// <remarks/>
    public System.IAsyncResult BeginIsPaymentInstrumentBanned(int lDelegateIdHigh, int lDelegateIdLow, string bstrPaymentInstrumentInfoXML, System.AsyncCallback callback, object asyncState) {
        return this.BeginInvoke("IsPaymentInstrumentBanned", new object[] {
                    lDelegateIdHigh,
                    lDelegateIdLow,
                    bstrPaymentInstrumentInfoXML}, callback, asyncState);
    }
    
    /// <remarks/>
    public void EndIsPaymentInstrumentBanned(System.IAsyncResult asyncResult, out string pbstrErrorXML, out int plIsBanned) {
        object[] results = this.EndInvoke(asyncResult);
        pbstrErrorXML = ((string)(results[0]));
        plIsBanned = ((int)(results[1]));
    }
    
    /// <remarks/>
    [System.Web.Services.Protocols.SoapRpcMethodAttribute("http://tempuri.org/action/BDKServerObj2.StopPayments", RequestNamespace="http://tempuri.org/message/", ResponseNamespace="http://tempuri.org/message/")]
    public void StopPayments(int lDelegateIdHigh, int lDelegateIdLow, string bstrPaymentInstrumentId, out string pbstrErrorXML) {
        object[] results = this.Invoke("StopPayments", new object[] {
                    lDelegateIdHigh,
                    lDelegateIdLow,
                    bstrPaymentInstrumentId});
        pbstrErrorXML = ((string)(results[0]));
    }
    
    /// <remarks/>
    public System.IAsyncResult BeginStopPayments(int lDelegateIdHigh, int lDelegateIdLow, string bstrPaymentInstrumentId, System.AsyncCallback callback, object asyncState) {
        return this.BeginInvoke("StopPayments", new object[] {
                    lDelegateIdHigh,
                    lDelegateIdLow,
                    bstrPaymentInstrumentId}, callback, asyncState);
    }
    
    /// <remarks/>
    public void EndStopPayments(System.IAsyncResult asyncResult, out string pbstrErrorXML) {
        object[] results = this.EndInvoke(asyncResult);
        pbstrErrorXML = ((string)(results[0]));
    }
    
    /// <remarks/>
    [System.Web.Services.Protocols.SoapRpcMethodAttribute("http://tempuri.org/action/BDKServerObj2.GetAccountActivity", RequestNamespace="http://tempuri.org/message/", ResponseNamespace="http://tempuri.org/message/")]
    public void GetAccountActivity(int lDelegateIdHigh, int lDelegateIdLow, int lRequesterIdHigh, int lRequesterIdLow, string bstrObjectId, int lBillingPeriodId, string bstrLocale, bool fDeep, out string pbstrErrorXML, out string pbstrAccountActivityXML) {
        object[] results = this.Invoke("GetAccountActivity", new object[] {
                    lDelegateIdHigh,
                    lDelegateIdLow,
                    lRequesterIdHigh,
                    lRequesterIdLow,
                    bstrObjectId,
                    lBillingPeriodId,
                    bstrLocale,
                    fDeep});
        pbstrErrorXML = ((string)(results[0]));
        pbstrAccountActivityXML = ((string)(results[1]));
    }
    
    /// <remarks/>
    public System.IAsyncResult BeginGetAccountActivity(int lDelegateIdHigh, int lDelegateIdLow, int lRequesterIdHigh, int lRequesterIdLow, string bstrObjectId, int lBillingPeriodId, string bstrLocale, bool fDeep, System.AsyncCallback callback, object asyncState) {
        return this.BeginInvoke("GetAccountActivity", new object[] {
                    lDelegateIdHigh,
                    lDelegateIdLow,
                    lRequesterIdHigh,
                    lRequesterIdLow,
                    bstrObjectId,
                    lBillingPeriodId,
                    bstrLocale,
                    fDeep}, callback, asyncState);
    }
    
    /// <remarks/>
    public void EndGetAccountActivity(System.IAsyncResult asyncResult, out string pbstrErrorXML, out string pbstrAccountActivityXML) {
        object[] results = this.EndInvoke(asyncResult);
        pbstrErrorXML = ((string)(results[0]));
        pbstrAccountActivityXML = ((string)(results[1]));
    }
    
    /// <remarks/>
    [System.Web.Services.Protocols.SoapRpcMethodAttribute("http://tempuri.org/action/BDKServerObj2.GetBillingPeriods", RequestNamespace="http://tempuri.org/message/", ResponseNamespace="http://tempuri.org/message/")]
    public void GetBillingPeriods(int lDelegateIdHigh, int lDelegateIdLow, int lRequesterIdHigh, int lRequesterIdLow, string bstrObjectId, string bstrLocale, out string pbstrErrorXML, out int plBillingPeriodCount, out string pbstrBillingPeriodSetXML) {
        object[] results = this.Invoke("GetBillingPeriods", new object[] {
                    lDelegateIdHigh,
                    lDelegateIdLow,
                    lRequesterIdHigh,
                    lRequesterIdLow,
                    bstrObjectId,
                    bstrLocale});
        pbstrErrorXML = ((string)(results[0]));
        plBillingPeriodCount = ((int)(results[1]));
        pbstrBillingPeriodSetXML = ((string)(results[2]));
    }
    
    /// <remarks/>
    public System.IAsyncResult BeginGetBillingPeriods(int lDelegateIdHigh, int lDelegateIdLow, int lRequesterIdHigh, int lRequesterIdLow, string bstrObjectId, string bstrLocale, System.AsyncCallback callback, object asyncState) {
        return this.BeginInvoke("GetBillingPeriods", new object[] {
                    lDelegateIdHigh,
                    lDelegateIdLow,
                    lRequesterIdHigh,
                    lRequesterIdLow,
                    bstrObjectId,
                    bstrLocale}, callback, asyncState);
    }
    
    /// <remarks/>
    public void EndGetBillingPeriods(System.IAsyncResult asyncResult, out string pbstrErrorXML, out int plBillingPeriodCount, out string pbstrBillingPeriodSetXML) {
        object[] results = this.EndInvoke(asyncResult);
        pbstrErrorXML = ((string)(results[0]));
        plBillingPeriodCount = ((int)(results[1]));
        pbstrBillingPeriodSetXML = ((string)(results[2]));
    }
    
    /// <remarks/>
    [System.Web.Services.Protocols.SoapRpcMethodAttribute("http://tempuri.org/action/BDKServerObj2.SyncUPSCacheForPUID", RequestNamespace="http://tempuri.org/message/", ResponseNamespace="http://tempuri.org/message/")]
    public void SyncUPSCacheForPUID(int lCustomerPUIDHigh, int lCustomerPUIDLow, out string pbstrErrorXML) {
        object[] results = this.Invoke("SyncUPSCacheForPUID", new object[] {
                    lCustomerPUIDHigh,
                    lCustomerPUIDLow});
        pbstrErrorXML = ((string)(results[0]));
    }
    
    /// <remarks/>
    public System.IAsyncResult BeginSyncUPSCacheForPUID(int lCustomerPUIDHigh, int lCustomerPUIDLow, System.AsyncCallback callback, object asyncState) {
        return this.BeginInvoke("SyncUPSCacheForPUID", new object[] {
                    lCustomerPUIDHigh,
                    lCustomerPUIDLow}, callback, asyncState);
    }
    
    /// <remarks/>
    public void EndSyncUPSCacheForPUID(System.IAsyncResult asyncResult, out string pbstrErrorXML) {
        object[] results = this.EndInvoke(asyncResult);
        pbstrErrorXML = ((string)(results[0]));
    }
    
    /// <remarks/>
    [System.Web.Services.Protocols.SoapRpcMethodAttribute("http://tempuri.org/action/BDKServerObj2.GetKey", RequestNamespace="http://tempuri.org/message/", ResponseNamespace="http://tempuri.org/message/")]
    public void GetKey(int lRequesterIdHigh, int lRequesterIdLow, string bstrKeyGuid, out string pbstrErrorXML, out string pbstrKeyXml) {
        object[] results = this.Invoke("GetKey", new object[] {
                    lRequesterIdHigh,
                    lRequesterIdLow,
                    bstrKeyGuid});
        pbstrErrorXML = ((string)(results[0]));
        pbstrKeyXml = ((string)(results[1]));
    }
    
    /// <remarks/>
    public System.IAsyncResult BeginGetKey(int lRequesterIdHigh, int lRequesterIdLow, string bstrKeyGuid, System.AsyncCallback callback, object asyncState) {
        return this.BeginInvoke("GetKey", new object[] {
                    lRequesterIdHigh,
                    lRequesterIdLow,
                    bstrKeyGuid}, callback, asyncState);
    }
    
    /// <remarks/>
    public void EndGetKey(System.IAsyncResult asyncResult, out string pbstrErrorXML, out string pbstrKeyXml) {
        object[] results = this.EndInvoke(asyncResult);
        pbstrErrorXML = ((string)(results[0]));
        pbstrKeyXml = ((string)(results[1]));
    }
    
    /// <remarks/>
    [System.Web.Services.Protocols.SoapRpcMethodAttribute("http://tempuri.org/action/BDKServerObj2.GetAdjustments", RequestNamespace="http://tempuri.org/message/", ResponseNamespace="http://tempuri.org/message/")]
    public void GetAdjustments(int lDelegateIdHigh, int lDelegateIdLow, string bstrSubscriptionId, int lBillingPeriodId, out string pbstrErrorXML, out int pcAppliedAdjustmentCount, out string pbstrAppliedAdjustmentSetXML, out int pcAvailableAdjustmentCount, out string pbstrAvailableAdjustmentSetXML) {
        object[] results = this.Invoke("GetAdjustments", new object[] {
                    lDelegateIdHigh,
                    lDelegateIdLow,
                    bstrSubscriptionId,
                    lBillingPeriodId});
        pbstrErrorXML = ((string)(results[0]));
        pcAppliedAdjustmentCount = ((int)(results[1]));
        pbstrAppliedAdjustmentSetXML = ((string)(results[2]));
        pcAvailableAdjustmentCount = ((int)(results[3]));
        pbstrAvailableAdjustmentSetXML = ((string)(results[4]));
    }
    
    /// <remarks/>
    public System.IAsyncResult BeginGetAdjustments(int lDelegateIdHigh, int lDelegateIdLow, string bstrSubscriptionId, int lBillingPeriodId, System.AsyncCallback callback, object asyncState) {
        return this.BeginInvoke("GetAdjustments", new object[] {
                    lDelegateIdHigh,
                    lDelegateIdLow,
                    bstrSubscriptionId,
                    lBillingPeriodId}, callback, asyncState);
    }
    
    /// <remarks/>
    public void EndGetAdjustments(System.IAsyncResult asyncResult, out string pbstrErrorXML, out int pcAppliedAdjustmentCount, out string pbstrAppliedAdjustmentSetXML, out int pcAvailableAdjustmentCount, out string pbstrAvailableAdjustmentSetXML) {
        object[] results = this.EndInvoke(asyncResult);
        pbstrErrorXML = ((string)(results[0]));
        pcAppliedAdjustmentCount = ((int)(results[1]));
        pbstrAppliedAdjustmentSetXML = ((string)(results[2]));
        pcAvailableAdjustmentCount = ((int)(results[3]));
        pbstrAvailableAdjustmentSetXML = ((string)(results[4]));
    }
    
    /// <remarks/>
    [System.Web.Services.Protocols.SoapRpcMethodAttribute("http://tempuri.org/action/BDKServerObj2.AdjustSubscription", RequestNamespace="http://tempuri.org/message/", ResponseNamespace="http://tempuri.org/message/")]
    public void AdjustSubscription(int lDelegateIdHigh, int lDelegateIdLow, string bstrSubscriptionId, int lBillingPeriodId, string bstrAdjustmentGUID, string bstrAmount, string bstrCommentTextXML, out string pbstrErrorXML) {
        object[] results = this.Invoke("AdjustSubscription", new object[] {
                    lDelegateIdHigh,
                    lDelegateIdLow,
                    bstrSubscriptionId,
                    lBillingPeriodId,
                    bstrAdjustmentGUID,
                    bstrAmount,
                    bstrCommentTextXML});
        pbstrErrorXML = ((string)(results[0]));
    }
    
    /// <remarks/>
    public System.IAsyncResult BeginAdjustSubscription(int lDelegateIdHigh, int lDelegateIdLow, string bstrSubscriptionId, int lBillingPeriodId, string bstrAdjustmentGUID, string bstrAmount, string bstrCommentTextXML, System.AsyncCallback callback, object asyncState) {
        return this.BeginInvoke("AdjustSubscription", new object[] {
                    lDelegateIdHigh,
                    lDelegateIdLow,
                    bstrSubscriptionId,
                    lBillingPeriodId,
                    bstrAdjustmentGUID,
                    bstrAmount,
                    bstrCommentTextXML}, callback, asyncState);
    }
    
    /// <remarks/>
    public void EndAdjustSubscription(System.IAsyncResult asyncResult, out string pbstrErrorXML) {
        object[] results = this.EndInvoke(asyncResult);
        pbstrErrorXML = ((string)(results[0]));
    }
    
    /// <remarks/>
    [System.Web.Services.Protocols.SoapRpcMethodAttribute("http://tempuri.org/action/BDKServerObj2.CompleteConversion", RequestNamespace="http://tempuri.org/message/", ResponseNamespace="http://tempuri.org/message/")]
    public void CompleteConversion(int lDelegateIdHigh, int lDelegateIdLow, int lRequesterIdHigh, int lRequesterIdLow, string bstrTrackingGUID, string bstrSubscriptionId, out string pbstrErrorXML, out string pbstrAmountChargedXML, out int plAddedServiceInstanceSetCount, out string pbstrAddedServiceInstanceSet, out int plRemovedServiceInstanceSetCount, out string pbstrRemoveServiceInstanceSet) {
        object[] results = this.Invoke("CompleteConversion", new object[] {
                    lDelegateIdHigh,
                    lDelegateIdLow,
                    lRequesterIdHigh,
                    lRequesterIdLow,
                    bstrTrackingGUID,
                    bstrSubscriptionId});
        pbstrErrorXML = ((string)(results[0]));
        pbstrAmountChargedXML = ((string)(results[1]));
        plAddedServiceInstanceSetCount = ((int)(results[2]));
        pbstrAddedServiceInstanceSet = ((string)(results[3]));
        plRemovedServiceInstanceSetCount = ((int)(results[4]));
        pbstrRemoveServiceInstanceSet = ((string)(results[5]));
    }
    
    /// <remarks/>
    public System.IAsyncResult BeginCompleteConversion(int lDelegateIdHigh, int lDelegateIdLow, int lRequesterIdHigh, int lRequesterIdLow, string bstrTrackingGUID, string bstrSubscriptionId, System.AsyncCallback callback, object asyncState) {
        return this.BeginInvoke("CompleteConversion", new object[] {
                    lDelegateIdHigh,
                    lDelegateIdLow,
                    lRequesterIdHigh,
                    lRequesterIdLow,
                    bstrTrackingGUID,
                    bstrSubscriptionId}, callback, asyncState);
    }
    
    /// <remarks/>
    public void EndCompleteConversion(System.IAsyncResult asyncResult, out string pbstrErrorXML, out string pbstrAmountChargedXML, out int plAddedServiceInstanceSetCount, out string pbstrAddedServiceInstanceSet, out int plRemovedServiceInstanceSetCount, out string pbstrRemoveServiceInstanceSet) {
        object[] results = this.EndInvoke(asyncResult);
        pbstrErrorXML = ((string)(results[0]));
        pbstrAmountChargedXML = ((string)(results[1]));
        plAddedServiceInstanceSetCount = ((int)(results[2]));
        pbstrAddedServiceInstanceSet = ((string)(results[3]));
        plRemovedServiceInstanceSetCount = ((int)(results[4]));
        pbstrRemoveServiceInstanceSet = ((string)(results[5]));
    }
    
    /// <remarks/>
    [System.Web.Services.Protocols.SoapRpcMethodAttribute("http://tempuri.org/action/BDKServerObj2.CancelConversion", RequestNamespace="http://tempuri.org/message/", ResponseNamespace="http://tempuri.org/message/")]
    public void CancelConversion(int lDelegateIdHigh, int lDelegateIdLow, int lRequesterIdHigh, int lRequesterIdLow, string bstrTrackingGUID, string bstrSubscriptionId, out string pbstrErrorXML, out int plAddedServiceInstanceSetCount, out string pbstrAddedServiceInstanceSet, out int plRemovedServiceInstanceSetCount, out string pbstrRemoveServiceInstanceSet) {
        object[] results = this.Invoke("CancelConversion", new object[] {
                    lDelegateIdHigh,
                    lDelegateIdLow,
                    lRequesterIdHigh,
                    lRequesterIdLow,
                    bstrTrackingGUID,
                    bstrSubscriptionId});
        pbstrErrorXML = ((string)(results[0]));
        plAddedServiceInstanceSetCount = ((int)(results[1]));
        pbstrAddedServiceInstanceSet = ((string)(results[2]));
        plRemovedServiceInstanceSetCount = ((int)(results[3]));
        pbstrRemoveServiceInstanceSet = ((string)(results[4]));
    }
    
    /// <remarks/>
    public System.IAsyncResult BeginCancelConversion(int lDelegateIdHigh, int lDelegateIdLow, int lRequesterIdHigh, int lRequesterIdLow, string bstrTrackingGUID, string bstrSubscriptionId, System.AsyncCallback callback, object asyncState) {
        return this.BeginInvoke("CancelConversion", new object[] {
                    lDelegateIdHigh,
                    lDelegateIdLow,
                    lRequesterIdHigh,
                    lRequesterIdLow,
                    bstrTrackingGUID,
                    bstrSubscriptionId}, callback, asyncState);
    }
    
    /// <remarks/>
    public void EndCancelConversion(System.IAsyncResult asyncResult, out string pbstrErrorXML, out int plAddedServiceInstanceSetCount, out string pbstrAddedServiceInstanceSet, out int plRemovedServiceInstanceSetCount, out string pbstrRemoveServiceInstanceSet) {
        object[] results = this.EndInvoke(asyncResult);
        pbstrErrorXML = ((string)(results[0]));
        plAddedServiceInstanceSetCount = ((int)(results[1]));
        pbstrAddedServiceInstanceSet = ((string)(results[2]));
        plRemovedServiceInstanceSetCount = ((int)(results[3]));
        pbstrRemoveServiceInstanceSet = ((string)(results[4]));
    }
    
    /// <remarks/>
    [System.Web.Services.Protocols.SoapRpcMethodAttribute("http://tempuri.org/action/BDKServerObj2.ImportSettledBillingItem", RequestNamespace="http://tempuri.org/message/", ResponseNamespace="http://tempuri.org/message/")]
    public void ImportSettledBillingItem(int lDelegateIdHigh, int lDelegateIdLow, string bstrSubscriptionId, string bstrPaymentInstrumentId, string bstrTaxAddressId, string bstrTrackingGUID, string bstrSettledBillingItemXML, out string pbstrResultXML) {
        object[] results = this.Invoke("ImportSettledBillingItem", new object[] {
                    lDelegateIdHigh,
                    lDelegateIdLow,
                    bstrSubscriptionId,
                    bstrPaymentInstrumentId,
                    bstrTaxAddressId,
                    bstrTrackingGUID,
                    bstrSettledBillingItemXML});
        pbstrResultXML = ((string)(results[0]));
    }
    
    /// <remarks/>
    public System.IAsyncResult BeginImportSettledBillingItem(int lDelegateIdHigh, int lDelegateIdLow, string bstrSubscriptionId, string bstrPaymentInstrumentId, string bstrTaxAddressId, string bstrTrackingGUID, string bstrSettledBillingItemXML, System.AsyncCallback callback, object asyncState) {
        return this.BeginInvoke("ImportSettledBillingItem", new object[] {
                    lDelegateIdHigh,
                    lDelegateIdLow,
                    bstrSubscriptionId,
                    bstrPaymentInstrumentId,
                    bstrTaxAddressId,
                    bstrTrackingGUID,
                    bstrSettledBillingItemXML}, callback, asyncState);
    }
    
    /// <remarks/>
    public void EndImportSettledBillingItem(System.IAsyncResult asyncResult, out string pbstrResultXML) {
        object[] results = this.EndInvoke(asyncResult);
        pbstrResultXML = ((string)(results[0]));
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\StfTests\CMSBVT\ViewRevbyDate.cs ===
using System;
using Microsoft.WebRunner;
using ServerTestFramework;
using System.Xml;
using System.Data;
using System.Data.SqlClient;
using System.IO;
using System.Collections;
using System.Net;
using System.Threading;
using System.Text;
using System.Resources;
using System.Reflection;
using System.Globalization;
using ServerTestFramework.Database;
using ServerTestFramework.LiveService.Notification;
using ServerTestFramework.LiveService.Presence;
using ServerTestFramework.LiveService.PresNotiCommon;
using ServerTestFramework.Utilities;
using Microsoft.WebRunner.Loggers;

namespace WebFormNS
{
	/// <summary>
	/// Summary description for ViewRevbyDate.
	/// </summary>
	public class ViewRevbyDate
	{
		const int ERROR_FILE_NOT_FOUND =2;
		const int ERROR_ACCESS_DENIED = 5;
		public static WebRunnerSDK mySDK;
		public static System.Threading.Timer myPopUpTimer;
		public static WebRunnerSDK XHTMLVal = new WebRunnerSDK(); 
		//public static string authUser = "TEST\\_xbcauthbvt";
		//public static string authPass = "F0rSh@r0n";
		public static string authUser = "TEST\\davidulm";
		public static string authPass = "Test!tools";


		public static bool ViewRevbyDate1()
		{
			//
			//Console.WriteLine("Starting View Revisions by Date");
			//Helpers.XHTMLVal.StartApplication(AppObj.IE, "url=http://test.xbox.com/en-us");
			bool return15;
			XHTMLVal.SetCredentials(@"username="+authUser+"&&password="+authPass);
			Helpers.XHTMLVal.StartApplication(AppObj.IE, "url=http://auth.test.xbox.com/en-us");
			Helpers.XHTMLVal.FindIE("action=flexpage.aspx");
			Helpers.XHTMLVal.AttachTo(Win32Special.Window,"action=flexpage.aspx&&exactmatch=false");
			
			Helpers.XHTMLVal.Click(Win32UIObj.Link, "name=Switch To Edit Site&&id=SwitchToPresentationUnpublishedAnchor");
		
			Helpers.XHTMLVal.Click(Win32UIObj.Link, "innertext=View Revisions by Date&&ExactMatch=false");
			Helpers.XHTMLVal.AttachTo(Win32Special.Window,"title=PageRevisionPreviewByDateDlg&&exactmatch=false");						
			if (Helpers.XHTMLVal.AttachTo(Win32Special.Window,"title=PageRevisionPreviewByDateDlg&&exactmatch=false"))
			{
			
				return15 = true;
			}
			else
			{
				return15 = false;
			}
			
			Helpers.XHTMLVal.FindIE("title=PageRevisionPreviewByDateDlg");
			Helpers.XHTMLVal.AttachTo(Win32Special.Window,"Title=PageRevisionPreviewByDateDlg&&exactmatch=false");
			Helpers.XHTMLVal.InputText(Win32UIObj.Text, "name=tbxStartDate&&InputToText=1/4/2005");
			Helpers.XHTMLVal.InputText(HTMLUIObj.TextBox, "TextToInput=1/19/2005&&name=tbxStartDate&&exactmatch=false");
			Helpers.XHTMLVal.Click(HTMLUIObj.ByTag, "tag=Button&&id=WBC_imgView&&exactmatch=false");
			Helpers.XHTMLVal.Click(HTMLUIObj.Button, "name=View&&exactmatch=false");
			Console.WriteLine("View Revision by date testing is done");
			Helpers.XHTMLVal.CleanUp("CloseBrowsers=true&&ClearCache=false&&ClearCookies=false");
			Preview.Preview1();
			return return15;
		}
		public static bool PressEnter()
		{
			System.Threading.Thread.Sleep(2000);
			Console.WriteLine("Pressing Enter");
			return Helpers.XHTMLVal.PressKey("TextToInput=[enter]");
		}
		public static bool changedate2()
		{
			return Helpers.XHTMLVal.PressKey("TextToInput=10/05/2004&&TimesToPress=1");

		}
		public static bool changedate1()
		{
			return Helpers.XHTMLVal.PressKey("TextToInput=10/06/2004&&TimesToPress=1");

		}
		public static bool PresstabKey() 
		{
			return Helpers.XHTMLVal.PressKey("TextToInput=[tab]");
		}
		public static bool PressupKey()
		{
			System.Threading.Thread.Sleep(40000);
			return Helpers.XHTMLVal.PressKey("TextToInput=[up]");
			
		
		}
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\StfTests\CMSTest\CMSTest.cs ===
using System;
using System.Xml;
using ServerTestFramework;
using ServerTestFramework.Utilities;

[assembly: RootNode(typeof(CMSTest.CMSTest))]

namespace CMSTest
{
	/// <summary>
	/// CMS Test suite
	/// </summary>
	public class CMSTest : TestNode
	{
		/// <summary>
		/// Initialize functional tests
		/// </summary>
		public override void PreRun()
		{
//			base.Initialize (config);

			// Read these from a config file
			ReadConfigFile ("CMSTestConfig.xml");
//			CMSTestUtil.ServerName = "massloi03";
//			CMSTestUtil.Port = ":51100";

			// Connect to CMS
			CMSTestUtil.ConnectToCMS (CMSTestUtil.AuthServer);

			// Create the channel where the tests are going to live
			CMSTestUtil.CreateChannel ("Content");

			// Create a logfile with a name that matches the channel
			CMSTestUtil.OpenLogFile (CMSTestUtil.ChannelName + ".csv");			

			// Uload the resource files
			UploadResourceFiles ();

		}
		
		/// <summary>
		/// Cleanup the functional test suite
		/// </summary>
		public override void PostRun()
		{
			CMSTestUtil.CloseLogFile ();
			base.DeinitializeSuite ();
		}

		/// <summary>
		/// Uploads certain resource files to CMS
		/// </summary>
		protected void UploadResourceFiles ()
		{
			// Images
			CMSTestUtil.UploadResource (null, @"CMSTestFiles\testfileImage01.gif");
			CMSTestUtil.UploadResource (null, @"CMSTestFiles\testfileImage02.jpg");

			// Flash
			CMSTestUtil.UploadResource (null, @"CMSTestFiles\testfileFlash01.swf");
		}

		/// <summary>
		/// Reads in the settings from an xml file
		/// </summary>
		/// <param name="sFilename">Name of the xml file</param>
		protected void ReadConfigFile (string sFilename)
		{
			// Load the Config file
			XmlConfigFile Config = new XmlConfigFile (sFilename);

			// Read in all the settings
			CMSTestUtil.AuthServer		= Config["/cmstest/authserver"];
			CMSTestUtil.ViewServer		= Config["/cmstest/viewserver"];
			CMSTestUtil.BrowseService	= Config["/cmstest/browseservice"];
			CMSTestUtil.Port			= Config["/cmstest/serverport"];
			Validator.Delay				= Convert.ToInt32 (Config["/cmstest/httpdelay"]);
			CMSTestUtil.Password		= Config["/cmstest/login/authpass"];
			string Username				= Config["/cmstest/login/authuser"];

			// Split the Domain\Username
			string [] DomainUsername = Username.Split ("\\".ToCharArray ());
			CMSTestUtil.Domain = DomainUsername[0];
			CMSTestUtil.Username = DomainUsername[1];
		}
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\StfTests\CMSBVT\WF.cs ===
using System;
using Microsoft.WebRunner;
using ServerTestFramework;
using System.Xml;
using System.Data;
using System.Data.SqlClient;
using System.IO;
using System.Collections;
using System.Net;
using System.Threading;
using System.Text;
using System.Resources;
using System.Reflection;
using System.Globalization;
using ServerTestFramework.Database;
using ServerTestFramework.LiveService.Notification;
using ServerTestFramework.LiveService.Presence;
using ServerTestFramework.LiveService.PresNotiCommon;
using ServerTestFramework.Utilities;
using Microsoft.WebRunner.Loggers;




namespace WebFormNS
{
	/// <summary>
	/// I will break this class up again to make it a more descriptive class but for now the test cases
	/// start here and consoleregistration will be broken out to another class to finish this out.
	/// I will do that this weekend...Dave
	/// </summary>
	[TestGroup] 

	public class WebFormInput : TestNode
	{
		/// <summary>
		const int ERROR_FILE_NOT_FOUND =2;
		const int ERROR_ACCESS_DENIED = 5;
		public static WebRunnerSDK mySDK;
		public static System.Threading.Timer myPopUpTimer;
		public static WebRunnerSDK XHTMLVal = new WebRunnerSDK(); 
		//Starting up the application to test my account with console serial number
		[TestCase, Description("copy BVT")]
			class CMSBVT : TestBase
		{
			protected override void Execute()
			{
				bool Results = copy.copy1();
				
				if (Results) 
				{
					ResultCode = TEST_RESULTS.PASSED;
				}
				else 
				{ 
					ResultCode = TEST_RESULTS.FAILED;
				}
			}
		}
		
		[TestCase, Description("ChannelProps BVT")]
			class CMSBVT1 : TestBase
		{
			protected override void Execute()
			{
				bool Results = ChannelProps.ChannelProps1();
				
				if (Results) 
				{
					ResultCode = TEST_RESULTS.PASSED;
				}
				else 
				{ 
					ResultCode = TEST_RESULTS.FAILED;
				}
			}
		}
		
		[TestCase, Description("Create New Page BVT")]
			class CMSBVT3 : TestBase
		{
			protected override void Execute()
			{
				bool Results = CreateNewPage.CreateNewPage1();
				
				if (Results) 
				{
					ResultCode = TEST_RESULTS.PASSED;
				}
				else 
				{ 
					ResultCode = TEST_RESULTS.FAILED;
				}
			}
		}
		[TestCase, Description("Page Properties BVT")]
			class CMSBVT4 : TestBase
		{
			protected override void Execute()
			{
				bool Results = PageProps.PageProps1();
				
				if (Results) 
				{
					ResultCode = TEST_RESULTS.PASSED;
				}
				else 
				{ 
					ResultCode = TEST_RESULTS.FAILED;
				}
			}
		}
		[TestCase, Description("Prod Manager BVT")]
			class CMSBVT5 : TestBase
		{
			protected override void Execute()
			{
				bool Results = PManager.PManager1();
				
				if (Results) 
				{
					ResultCode = TEST_RESULTS.PASSED;
				}
				else 
				{ 
					ResultCode = TEST_RESULTS.FAILED;
				}
			}
		}
		
		[TestCase, Description("Resource Manager BVT")]
			class CMSBVT7 : TestBase
		{
			protected override void Execute()
			{
				bool Results = ResourceMan.ResourceMan1();
				
				if (Results) 
				{
					ResultCode = TEST_RESULTS.PASSED;
				}
				else 
				{ 
					ResultCode = TEST_RESULTS.FAILED;
				}
			}
		}
		[TestCase, Description("Revision History BVT")]
			class CMSBVT8 : TestBase
		{
			protected override void Execute()
			{
				bool Results = RevisonHist.RevisonHist1();
				
				if (Results) 
				{
					ResultCode = TEST_RESULTS.PASSED;
				}
				else 
				{ 
					ResultCode = TEST_RESULTS.FAILED;
				}
			}
		}
		[TestCase, Description("View By Date BVT")]
			class CMSBVT9 : TestBase
		{
			protected override void Execute()
			{
				bool Results = ViewRevbyDate.ViewRevbyDate1();
				
				if (Results) 
				{
					ResultCode = TEST_RESULTS.PASSED;
				}
				else 
				{ 
					ResultCode = TEST_RESULTS.FAILED;
				}
			}
		}
		public static bool WebFormTC(int nCntr)
		{
			
			bool Results = true;
			bool Falseoverride = true;
			
			
		
				//
			//CreateNewPage.CreateNewPage1();
			//ChannelProps.ChannelProps1();
			//ApprovalAssist.ApprovalAssist1();
			//copy.copy1();
			//PManager.PManager1();
			//PageProps.PageProps1();
			//  OK ViewRevbyDate.ViewRevbyDate1();
			//  out subappdec.subappdec1();
			//ResourceMan.ResourceMan1();
			//ViewRevbyDate.ViewRevbyDate1();
			//RevisonHist.RevisonHist1();
				//Production Manager Testing
			//WebFormNS.PManager.PManager1();
			//WebFormNS.CreateNewPage.CreateNewPage1();
				
		  
			//End: Console.WriteLine("Logging out of passport and clearing cache then closing browser");
		
			Helpers.XHTMLVal.Click(HTMLUIObj.Link, "HREF=http://login.passport-ppe.com/logout.srf&&exactmatch=false");
					
			
			//Helpers.profreg.CleanUp("CloseBrowsers=true&&ClearCache=true&&ClearCookies=false");
			if (Falseoverride == false)
			{
				Results = false;
			}
			return Results;
			//
		}
		
	
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\StfTests\CMSBVT\RevisonHist.cs ===
using System;
using Microsoft.WebRunner;
using ServerTestFramework;
using ServerTestFramework.Utilities;

namespace WebFormNS
{
	/// <summary>
	/// Summary description for RevisonHist.
	/// </summary>
	public class RevisonHist
	{
		
		


		public static bool RevisonHist1()
		{
			//
			bool return4;
			Helpers.XHTMLVal.SetCredentials(@"username="+Helpers.authUser+"&&password="+Helpers.authPass);
			Helpers.XHTMLVal.StartApplication(AppObj.IE, "url=http://auth.test.xbox.com/en-us");
			Helpers.XHTMLVal.FindIE("action=flexpage.aspx");
			Helpers.XHTMLVal.AttachTo(Win32Special.Window,"action=flexpage.aspx&&exactmatch=false");
			Helpers.XHTMLVal.Click(Win32UIObj.Link, "name=Switch To Edit Site&&value=http://auth.test.xbox.com/en-us#");
			Helpers.XHTMLVal.Click(Win32UIObj.Link, "innertext=default.htm&&exactmatch=false");
			Helpers.XHTMLVal.Click(Win32UIObj.Link, "name=Revision History&&value=http://auth.test.xbox.com/NR/exeres/479B163C-9F86-4DD9-9089-9E2B60B955A2.htm?wbc_purpose=Basic&NRMODE=Unpublished&WBCMODE=PresentationUnpublished#");
			Helpers.XHTMLVal.FindIE("title=Microsoft Content Management Server");
			Helpers.XHTMLVal.AttachTo(Win32Special.Window,"Title=Microsoft Content Management Server&&exactmatch=false");
			
			if (Helpers.XHTMLVal.Verify(Win32UIObj.MenuItem, "innertext=Revision Approval Date&&exactmatch=false", true))
			{
				return4 = true;
			}
			else
			{
				return4 = false;
			}
			Helpers.XHTMLVal.Click(HTMLUIObj.CheckBox, "name=UnapprovedRevisionCheckBox&&exactmatch=false");
			Helpers.XHTMLVal.Click(HTMLUIObj.Button, "name=ClearButton&&exactmatch=false");
			Helpers.XHTMLVal.Click(HTMLUIObj.Select, "id=PagingConfigControl&&TextToInput=10");
			Helpers.XHTMLVal.Click(HTMLUIObj.Select, "id=PagingConfigControl&&TextToInput=15");
			Helpers.XHTMLVal.Click(HTMLUIObj.Select, "id=PagingConfigControl&&TextToInput=20");
			Helpers.XHTMLVal.Click(HTMLUIObj.Select, "id=PagingConfigControl&&TextToInput=All");
			
			
			Console.WriteLine("Revision History Testing is done");
			Helpers.XHTMLVal.CleanUp("CloseBrowsers=true&&ClearCache=false&&ClearCookies=false");
			//ViewRevbyDate.ViewRevbyDate1();
			
					return return4;
		}
		public static bool PressEnter()
		{
			
			return Helpers.XHTMLVal.PressKey("TextToInput=[enter]");
		}
		public static bool changedate2()
		{
			return Helpers.XHTMLVal.PressKey("TextToInput=10/05/2004&&TimesToPress=1");

		}
		public static bool changedate1()
		{
			return Helpers.XHTMLVal.PressKey("TextToInput=10/06/2004&&TimesToPress=1");

		}
		public static bool PresstabKey() 
		{
			return Helpers.XHTMLVal.PressKey("TextToInput=[tab]");
		}
		public static bool Pressleftmouse()
		{
			return Helpers.XHTMLVal.PressKey("TextToInput=[mouseleft]&&TimesToPress=2");
		}
		public static bool PressupKey()
		{
			System.Threading.Thread.Sleep(40000);
			return Helpers.XHTMLVal.PressKey("TextToInput=[up]");
			
		
		}
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\StfTests\CMSTest\CMSTestUtil.cs ===
using System;
using System.IO;
using System.Text;
using Microsoft.Win32;
using ServerTestFramework;
using ServerTestFramework.Utilities;
using CMSUtil;
using Microsoft.ContentManagement.Publishing;
using Microsoft.ContentManagement.Publishing.Extensions.Placeholders;

namespace CMSTest
{
	/// <summary>
	/// Utility class used to talk to CMS in a manner suited for these tests
	/// </summary>
	public class CMSTestUtil
	{
		//
		// P R I V A T E   M E M B E R S ///////////////////////////////////////////
		//

		static private CMS _CMS;
		static private Channel _TestChannel;
		static private string _ChannelName = String.Empty;		// Name of the channel where the tests are being run
		static private StreamWriter _LogFile;
		static private string _AuthServer;
		static private string _ViewServer;
		static private string _Port;
		static private string _BrowseService;
		static private string _Username;
		static private string _Password;
		static private string _Domain;

		//
		// P U B L I C   S T A T I C   A T T R I B U T E S /////////////////////////
		//
		/// <summary>
		/// Get the channel name.  If no channel exist it will create a new one
		/// with a default name of "Test"
		/// </summary>
		static public string ChannelName
		{
			get 
			{
				// If the channel name has not been set yet, create it
				if (_ChannelName == String.Empty)
				{
					CreateChannel ("Test");
				}

				// Return the channel name
				return _ChannelName;
			}
		}
		/// <summary>
		/// Gets/Sets the server name
		/// </summary>
		static public string AuthServer
		{
			get { return _AuthServer; }
			set { _AuthServer = value; }
		}
		static public string ViewServer
		{
			get { return _ViewServer; }
			set { _ViewServer = value; }
		}
		/// <summary>
		/// Gets/Sets the port
		/// </summary>
		static public string Port
		{
			get { return _Port; }
			set { _Port = value; }
		}
		/// <summary>
		/// Gets/Sets the Browse Service path
		/// </summary>
		static public string BrowseService
		{
			get { return _BrowseService; }
			set { _BrowseService = value; }
		}
		/// <summary>
		/// Gets/Sets the username
		/// </summary>
		static public string Username
		{
			get { return _Username; }
			set { _Username = value; }
		}
		/// <summary>
		/// Gets/Sets the Password
		/// </summary>
		static public string Password
		{
			get { return _Password; }
			set { _Password = value; }
		}
		/// <summary>
		/// Gets/Sets the Domain
		/// </summary>
		static public string Domain
		{
			get { return _Domain; }
			set { _Domain = value; }
		}

		//
		// P U B L I C   S T A T I C   M E T H O D S ///////////////////////////////
		//

		/// <summary>
		/// Creates a channel based off of the prefix, date, and time.
		/// </summary>
		/// <param name="Prefix">A short string to prefix the channel name</param>
		/// <returns>A string containing the channel name</returns>
		static public string CreateChannel (string Prefix)
		{
			// Get the current date and time
			DateTime Now = DateTime.Now;

			// Create the channel name
			_ChannelName =  String.Format ("{0}_{1}_{2}_{3}__{4}{5}{6}", 
				Prefix,
				Now.Month, 
				Now.Day,
				Now.Year,
				Now.Hour,
				Now.Minute,
				Now.Second.ToString("00"));

			// Create the channel
			_TestChannel = _CMS.CreateChannel (null, _ChannelName);

			// Done
			return _ChannelName;
		}

		/// <summary>
		/// Creates a channel at the end of the path.  If the interim channels
		/// do no exits, it creates them too
		/// </summary>
		static public Channel CreateChannelByPath (string Path)
		{
			return _CMS.CreateChannelByPath (Path);
		}

		static public void CreateLostsOfChannels (Channel Root, string Prefix, int nNumChannels)
		{
			for (int nChannel = 0; nChannel < nNumChannels; nChannel++)
			{
				_CMS.CreateChannel (Root, Prefix + "nChannel");
			}
		}

		static public void DeleteChannel (Channel GoByeBye)
		{
			// Delete the channel
			_DeleteChannel (GoByeBye);

			// Make sure it sticks
			_CMS.CommitAll ();
		}
		static protected void _DeleteChannel (Channel GoByeBye)
		{
			// Iterate through all the channels in here
			foreach (Channel ch in GoByeBye.Channels)
				_DeleteChannel (ch);

			// Now do the same for each posting
			foreach (Posting post in GoByeBye.Postings)
				post.Delete ();

			// Now delete this channel
			GoByeBye.Delete ();
		}

		/// <summary>
		/// Connects to CMS using the current user's credentials
		/// </summary>
		static public void ConnectToCMS (string MachineName)
		{
			_CMS = new CMS (MachineName);
		}

		/// <summary>
		/// Creates a Flex page based on the supplied XML string
		/// </summary>
		/// <param name="XML">String containing the XML</param>
		/// <param name="PageName">Name of the page to create</param>
		/// <param name="Valid">True if the page should be valid</param>
		/// <returns>URLTest containing the created page information</returns>
		static public URLTest CreateFlexPageFromXML (string XML, string PageName, bool Valid)
		{
			// Stuff the result in here
			URLTest url = new URLTest ();

			// Create a valid post
			string PartialURL = _CMS.CreatePageFromXml (_TestChannel, _CMS.GetTemplateByName ("FlexPage"), PageName, XML);
			url.URL = "http://" + _ViewServer + ":" + _Port + PartialURL;
			url.ShouldRender = Valid;

			// Done
			return url;
		}
		/// <summary>
		/// Creates a Flex Fragment page based on the supplied XML string
		/// </summary>
		/// <param name="XML">String containing the XML</param>
		/// <param name="PageName">Name of the page to create</param>
		/// <returns>string containing the created page's URL</returns>
		static public string CreateFlexFragmentPageFromXML (string XML, string PageName)
		{
			// Create a valid post
			string PartialURL = _CMS.CreatePageFromXml (_TestChannel, _CMS.GetTemplateByName ("FlexPageFragment"), PageName, XML);
			string URL = "http://" + _ViewServer + ":" + _Port + PartialURL;

			// Done
			return URL;
		}
		/// <summary>
		/// Creates a Flex page based on the supplied XML file
		/// </summary>
		/// <param name="FileName">Path and name of the XML file</param>
		/// <param name="PageName">Name of the page to create</param>
		/// <param name="Valid">True if the page should be valid</param>
		/// <returns>URLTest containing the created page information</returns>
		static public URLTest CreateFlexPageFromFile (string FileName, string PageName, bool Valid)
		{
			// Read the XML file into a string
			string XML = GetFileAsString (FileName);

			// Create a valid post
			return CreateFlexPageFromXML (XML, PageName, Valid);
		}

		/// <summary>
		/// Creates a Flex page based on the supplied XML file and places it at the
		/// specified channel
		/// </summary>
		/// <param name="FileName">Path and name of the XML file</param>
		/// <param name="ChannelPath">Channel that will contain the page</param>
		/// <param name="PageName">Name of the page to create</param>
		/// <returns>string containing the created page's URL</returns>
		static public string CreateFlexPageFromFileAtChannel (string FileName, Channel ChannelPath, string PageName)
		{
			// Read the XML file into a string
			string XML = GetFileAsString (FileName);

			// Create the page
			string PartialURL =_CMS.CreatePageFromXml (ChannelPath, _CMS.GetTemplateByName ("FlexPageFragment"), PageName, XML);
			string URL = "http://" + _ViewServer + ":" + _Port + PartialURL;

			// Done
			return URL;
		}

		/// <summary>
		/// Creates a Flex fragment page based on the supplied XML file
		/// </summary>
		/// <param name="FileName">Path and name of the XML file</param>
		/// <param name="PageName">Name of the page to create</param>
		/// <returns>string containing the created page's URL</returns>
		static public string CreateFlexFragmentPageFromFile (string FileName, string PageName)
		{
			// Read the XML file into a string
			string XML = GetFileAsString (FileName);

			// Create a valid post
			return CreateFlexFragmentPageFromXML (XML, PageName);
		}

		/// <summary>
		/// Returns a the contents of the file as a string
		/// </summary>
		/// <param name="FileName">Path and name of the file to read</param>
		/// <returns>The file's content</returns>
		static public string GetFileAsString (string FileName)
		{
			// Open the file
			StreamReader sr = File.OpenText(FileName);

			// Read the content
			String Content = "";
			String Input;
			while ((Input=sr.ReadLine())!=null) 
			{
				Content += Input;
			}

			// Done
			return Content;
		}
		/// <summary>
		/// Create a new logfile
		/// </summary>
		/// <param name="FileName">Name of the logfile</param>
		static public void OpenLogFile (string FileName)
		{
			// open the logfile
			_LogFile = File.CreateText (FileName);
		}
		/// <summary>
		/// Closes the logfile.
		/// </summary>
		static public void CloseLogFile ()
		{
			_LogFile.Close ();
		}
		/// <summary>
		/// Adds a line to the CSV log file in the format:
		/// URL tab ShouldRender tab DoesRender tab Error
		/// </summary>
		/// <param name="url">The URLTest whose data is getting outputed to the file</param>
		static public void LogResultToFile (URLTest url)
		{
			// Build the string to write
			string Output = String.Format ("{0}\t{1}\t{2}\t{3}", url.URL, url.ShouldRender.ToString (),
				url.DoesRender.ToString (), url.Error);

			// Write the string
			_LogFile.WriteLine (Output);
		}
		/// <summary>
		/// Finds a resource given a human readable resource path.
		/// The first part of the resource path should be the root 
		/// resource gallery.
		/// 
		/// ex: FindResourceByName ("Resources\Halo2\Intro.jpg");
		/// </summary>
		/// <param name="ResourcePath">Resource's path</param>
		/// <returns>The resource's URL</returns>
		static public string FindResourceByName (string ResourcePath)
		{
			return _CMS.FindResourceByName (ResourcePath);
		}
		/// <summary>
		/// Uploads a resource to the default resource gallery of the specified
		/// channel.  If the channel is null, then the RootResourceGallery will
		/// be used.
		/// </summary>
		/// <param name="CurrentChannel">Channel to add there resource to.  Can be null</param>
		/// <param name="ResourcePath">Location of the resource on disk</param>
		/// <returns>URL of the resource</returns>
		static public string UploadResource (Channel CurrentChannel, string ResourcePath)
		{
			return _CMS.UploadResource (CurrentChannel, ResourcePath);
		}

		/// <summary>
		/// Given a URL it returns the XML of the posting.  IF the posting contains
		/// the SingleSource webpart, it will recurse returning an XML string with
		/// the entire contents
		/// </summary>
		/// <param name="URL">URL of the page</param>
		/// <returns>XML string with the page's content</returns>
		static public string GetDeepXMLSourceFromURL (string URL)
		{
			// First we get the XML source from URL
			Posting Page = _CMS.GetPostingByURL (URL);
			string XML = (Page.Placeholders[0] as XmlPlaceholder).XmlAsString;

			// Then we search for every instance of the SingleSource tag
			int nIndex = 0;
			string sToken = "<SingleSource wp=\"SingleSource\" description=\"\" src=\"";
			while ((nIndex = XML.IndexOf (sToken, nIndex)) > 0)
			{
				// Get the end of the path
				int nNewIndex = nIndex + sToken.Length;
				int nEndIndex = XML.IndexOf ("\"", nNewIndex);

				// Get the path out of there
				string sPath = XML.Substring (nNewIndex, nEndIndex - nNewIndex);
 
				// Good, now contruct the URL ...
				sPath = "http://" + _AuthServer + sPath;

				// ... Get its complete XML ...
				string sFragmentXML = GetDeepXMLSourceFromURL (sPath);

				// ... Place the XML in the right spot, but first get the end of the SingleSource tag
				nEndIndex = XML.IndexOf (">", nNewIndex);
				XML = XML.Substring (0, nIndex) + sFragmentXML + XML.Substring (nEndIndex + 1);
			}

			// Done
			return XML;
		}
	}

	/// <summary>
	/// A simple class that encapsulates a test case.
	/// </summary>
	public class URLTest
	{
		// Member Data
		private string _URL;
		private bool _ShouldRender;
		private bool _DoesRender;
		private string _Error;

		// Accessors 
		/// <summary>
		/// Gets/Sets the URL of the test page
		/// </summary>
		public string URL { get { return _URL; } set { _URL = value; } }
		/// <summary>
		/// Gets/Sets the ShouldRender flag.  If true, the page is expected to render
		/// flawlessly.
		/// </summary>
		public bool ShouldRender { get { return _ShouldRender; } set { _ShouldRender = value; } }
		/// <summary>
		/// Gets/Sets the DoesRender flag.  If true, the page was rendered without error
		/// </summary>
		public bool DoesRender { get { return _DoesRender; } set { _DoesRender = value; } }
		/// <summary>
		/// Gets/Sets the error string.  If a page does not render, the reason
		/// why should be here.
		/// </summary>
		public string Error { get { return _Error; } set { _Error = value; } }

		/// <summary>
		/// Checks to see if the test was successful.  It basically compares the
		/// ShouldRender flag to the DoesRender flag.
		/// </summary>
		/// <returns>True if the test passed</returns>
		public bool IsValid ()
		{
			return _ShouldRender == _DoesRender;
		}
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\StfTests\CMSBVT\subappdec.cs ===
using System;
using Microsoft.WebRunner;
using ServerTestFramework;
using System.Xml;
using System.Data;
using System.Data.SqlClient;
using System.IO;
using System.Collections;
using System.Net;
using System.Threading;
using System.Text;
using System.Resources;
using System.Reflection;
using System.Globalization;
using ServerTestFramework.Database;
using ServerTestFramework.LiveService.Notification;
using ServerTestFramework.LiveService.Presence;
using ServerTestFramework.LiveService.PresNotiCommon;
using ServerTestFramework.Utilities;
using Microsoft.WebRunner.Loggers;

namespace WebFormNS
{
	/// <summary>
	/// Summary description for subappdec.
	/// </summary>
	public class subappdec
	{
		
			//
		const int ERROR_FILE_NOT_FOUND =2;
		const int ERROR_ACCESS_DENIED = 5;
		public static WebRunnerSDK mySDK;
		public static System.Threading.Timer myPopUpTimer;
		public static WebRunnerSDK XHTMLVal = new WebRunnerSDK(); 
		//public static string authUser = "TEST\\_xbcauthbvt";
		//public static string authPass = "F0rSh@r0n";
		public static string authUser = "TEST\\davidulm";
		public static string authPass = "Test!tools";
		/// </summary>
		public static void subappdec1()
		{
			//	//
			XHTMLVal.SetCredentials(@"username="+authUser+"&&password="+authPass);
			Helpers.XHTMLVal.StartApplication(AppObj.IE, "url=http://auth.test.xbox.com/en-us");
			Helpers.XHTMLVal.FindIE("title=FlexTemplate");
			Helpers.XHTMLVal.AttachTo(Win32Special.Window,"Title=FlexTemplate&&exactmatch=false");
								
			Helpers.XHTMLVal.Click(Win32UIObj.Link, "name=Switch To Edit Site&&value=http://auth.test.xbox.com/en-us#");
			
			Helpers.XHTMLVal.Click(Win32UIObj.Link, "name=View Revisions by Date&&value=http://auth.test.xbox.com/NR/exeres/3274E414-5270-4CA3-87D0-D0DDE1477020,frameless.htm?NRMODE=Unpublished&WBCMODE=PresentationUnpublished&wbc_purpose=Basic#");
			WebFormNS.subappdec.PresstabKey();
			WebFormNS.subappdec.PresstabKey();
			
			WebFormNS.subappdec.PresstabKey();
			WebFormNS.subappdec.PresstabKey();
			WebFormNS.subappdec.PresstabKey();
			WebFormNS.subappdec.PressEnter();
			WebFormNS.subappdec.PresstabKey();
			WebFormNS.subappdec.PressEnter();
			Helpers.XHTMLVal.Click(Win32UIObj.Link, "name=Submit&&value=http://auth.test.xbox.com/NR/exeres/B07380B3-98A5-4890-8BAB-AD7B11F4F89F.htm?wbc_purpose=Basic&NRMODE=Unpublished&WBCMODE=PresentationUnpublished#");
			Console.WriteLine("Clicking on submit");
			
			Helpers.XHTMLVal.Click(Win32UIObj.Link, "name=Decline&&value=http://auth.test.xbox.com/NR/exeres/4C4A5EFF-8EA8-42D9-B196-ECB9E7097FE9,frameless.htm?NRMODE=Update&WBCMODE=PresentationUnpublished#");
			Helpers.XHTMLVal.CleanUp("CloseBrowsers=true&&ClearCache=false&&ClearCookies=false");
			Helpers.XHTMLVal.Click(Win32UIObj.Link, "name=Submit&&value=http://auth.test.xbox.com/NR/exeres/B07380B3-98A5-4890-8BAB-AD7B11F4F89F.htm?wbc_purpose=Basic&NRMODE=Unpublished&WBCMODE=PresentationUnpublished#");
			Console.WriteLine("Clicking on submit");
			Console.WriteLine("End of submit approve decline page");
			Helpers.XHTMLVal.Click(Win32UIObj.Link, "name=Approve&&value=http://auth.test.xbox.com/NR/exeres/4C4A5EFF-8EA8-42D9-B196-ECB9E7097FE9,frameless.htm?NRMODE=Update&WBCMODE=PresentationUnpublished#");
			CreateNewPage.CreateNewPage1();
			
			//
		}
		public static bool PressEnter()
		{
			Console.WriteLine("Pressing Enter");
			return Helpers.XHTMLVal.PressKey("TextToInput=[enter]");
		}
		public static bool PresstabKey()
		{
			return Helpers.XHTMLVal.PressKey("TextToInput=[tab]");
		
		}
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\StfTests\CMSTest\FuncResources.cs ===
using System;
using System.IO;
using System.Text;
using Microsoft.Win32;
using ServerTestFramework;
using ServerTestFramework.Utilities;
using Microsoft.ContentManagement.Publishing;

namespace CMSTest
{
	/// <summary>
	/// Resources Test Group
	/// </summary>
	[TestGroup]
	public class Resources : TestNode
	{
		[TestCase, Description("Uploads a 1kB resource")]
		class Upload_1kB : TestBase
		{
			protected override void Execute()
			{
				// Upload the file
				CMSTestUtil.UploadResource (null, @"CMSTestFiles\upload_1kB.xml");				

				// Look for it
				string URL = CMSTestUtil.FindResourceByName ("Resources/upload_1kB.xml");

				// Well?
				ResultCode = (URL != null) ? TEST_RESULTS.PASSED : TEST_RESULTS.FAILED;
			}
		}
		[TestCase, Description("Uploads a 1MB resource")]
		class Upload_1MB : TestBase
		{
			protected override void Execute()
			{
				// Upload the file
				CMSTestUtil.UploadResource (null, @"CMSTestFiles\upload_1MB.xml");				

				// Look for it
				string URL = CMSTestUtil.FindResourceByName ("Resources/upload_1MB.xml");

				// Well?
				ResultCode = (URL != null) ? TEST_RESULTS.PASSED : TEST_RESULTS.FAILED;
			}
		}
		[TestCase, Description("Uploads a 10MB resource")]
		class Upload_10MB : TestBase
		{
			protected override void Execute()
			{
				// Upload the file
				CMSTestUtil.UploadResource (null, @"CMSTestFiles\upload_10MB.xml");				

				// Look for it
				string URL = CMSTestUtil.FindResourceByName ("Resources/upload_10MB.xml");

				// Well?
				ResultCode = (URL != null) ? TEST_RESULTS.PASSED : TEST_RESULTS.FAILED;
			}
		}
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\StfTests\CMSTest\CMSUtil.cs ===
using System;
using System.Security.Principal;
using Microsoft.ContentManagement.Publishing;
using Microsoft.ContentManagement.Publishing.Extensions;
using Microsoft.ContentManagement.Publishing.Extensions.Placeholders;

namespace CMSUtil
{
	/// <summary>
	/// Summary description for CMSUtil.
	/// </summary>
	public class CMS
	{
		// PRIVATE MEMBERS ///////////////////////////////////////////////////////////
		private CmsApplicationContext	_Context;	// The main CMS context, contains all CMS info
		//		private Channel					_Root;		// The root channel.  Usually Channels.

		// PUBLIC METHODS ////////////////////////////////////////////////////////////

		/// <summary>
		/// The constructor connects to CMS in Update mode
		/// </summary>
		public CMS (string MachineName)
		{
			// Connect to CMS
			_Context = new CmsApplicationContext ();

			// Log in as the current user
			WindowsIdentity id = WindowsIdentity.GetCurrent ();
			if (id != null)
			{
				_Context.AuthenticateUsingUserHandle (id.Token, PublishingMode.Update, null, null, MachineName);
			}
		}

		/// <summary>
		/// Creates a new channel under the specified parent channel
		/// </summary>
		public Channel CreateChannel (Channel Parent, string Name)
		{
			// Use the root channel if none is specified
			if (Parent == null)
				Parent = _Context.RootChannel;

			// Create a new channel
			Channel Child = Parent.CreateChannel ();

			if (Child != null)
			{
				if (!Parent.CanCreateChannels)
					throw new Exception ("The channel \"" + Parent.Name + "\" cannot have subchannels.");

				// Give it a proper name
				Child.Name = Name;
				Child.DisplayName = Name;

				// And make it permanent
				_Context.CommitAll ();
			}

			// Done
			return Child;
		}

		/// <summary>
		/// Creates a new channel under the root channel
		/// </summary>
		public Channel CreateChannel (string Name)
		{
			return CreateChannel (_Context.RootChannel, Name);
		}

		/// <summary>
		/// Creates a channel at the end of the path.  If the interim channels
		/// do no exits, it creates them too
		/// </summary>
		public Channel CreateChannelByPath (string Path)
		{
			// Remove the "/" from the beginning and end
			if (Path[0] == '/' || Path[0] == '\\')
				Path = Path.Substring (1);
			if (Path[Path.Length - 1] == '/' || Path[Path.Length - 1] == '\\')
				Path = Path.Substring (0, Path.Length - 1);

			// Break up the path and try to create each individual channels
			string [] ChannelNames = Path.Split (@"\/".ToCharArray ());
			if (ChannelNames.Length == 0)
				throw new Exception ("Channel path is empty.");

			// Create each subchannel if need be
			string ChannelPath = "/";
			Channel ParentChannel = null;
			Channel NewChannel = null;
			for (int nChannel = 0; nChannel < ChannelNames.Length; nChannel ++)
			{
				// Append the channel name
				ChannelPath += (ChannelNames[nChannel] + "/");

				// Does the channel exist?
				NewChannel = _Context.Searches.GetByPath (ChannelPath) as Channel;
				if (null == NewChannel)
				{
					NewChannel = CreateChannel (ParentChannel, ChannelNames[nChannel]);
				}

				// Set the new parent
				ParentChannel = NewChannel;
			}

			// Done
			return NewChannel;
		}

		/// <summary>
		/// Deletes a channel given a path
		/// </summary>
		public void DeleteChannel (string Path)
		{
			// Find the channel to delete
			Channel GoByeBye = _Context.Searches.GetByPath (Path) as Channel;

			// Delete the channel
			GoByeBye.Delete ();

			// Done
			_Context.CommitAll ();
		}

		public void CommitAll ()
		{
			_Context.CommitAll ();
		}

		/// <summary>
		/// Finds and returns a CMS template.  If no template is found, null is returned
		/// </summary>
		public Template GetTemplateByName (string Name)
		{
			// Look through all the templates for the desired template
			TemplateCollection tc = _Context.RootTemplateGallery.Templates;
			Template Desired = null;
			foreach (Template templ in tc)
			{
				// Is it The One(tm)?
				if (templ.Name == Name)
				{
					Desired = templ;
					break;
				}
			}

			// Done
			return Desired;
		}

		/// <summary>
		/// Creates and publishes a posting given a channel, template, page name, 
		/// and some xml data.
		/// This method assumes that the template has only one placeholder.
		/// </summary>
		public string CreatePageFromXml (Channel CurrentChannel, Template PageTemplate, string Name, string XmlData)
		{
			// Create a new posting
			Posting Page = CurrentChannel.CreatePosting (PageTemplate);
			Page.Name = Name;

			// Get the first placeholder.  If it doesn't exits, we trow an exception
			PlaceholderCollection pc = Page.Placeholders;
			try
			{
				// Assing the data to the first placeholder
				(pc[0] as XmlPlaceholder).XmlAsString = XmlData;
			}
			catch (Exception ex)
			{
				// Repackage the exceptions so that we know where it's coming from
				throw new Exception ("Error creating a page from XML: " + ex.Message);
			}

			// Now commit the page
			Page.Approve ();
			_Context.CommitAll ();

			// Return the page's URL
			return Page.UrlModePublished;
		}

		/// <summary>
		/// Creates and publishes a posting given a channel, template, page name, 
		/// and some html data.
		/// This method assumes that the template has only one placeholder.
		/// </summary>
		public void CreatePageFromHtml (Channel CurrentChannel, Template PageTemplate, string Name, string HtmlData)
		{
			// Create a new posting
			Posting Page = CurrentChannel.CreatePosting (PageTemplate);
			Page.Name = Name;

			// Get the first placeholder.  If it doesn't exits, we trow an exception
			PlaceholderCollection pc = Page.Placeholders;
			try
			{
				// Assing the data to the first placeholder
				(pc[0] as HtmlPlaceholder).Html = HtmlData;
			}
			catch (Exception ex)
			{
				// Repackage the exceptions so that we know where it's coming from
				throw new Exception ("Error creating a page from HTML: " + ex.Message);
			}

			// Now commit the page
			Page.Approve ();
			_Context.CommitAll ();
		}

		/// <summary>
		/// Uploads a resource to the default resource gallery of the specified
		/// channel.  If the channel is null, then the RootResourceGallery will
		/// be used.
		/// </summary>
		/// <param name="CurrentChannel">Channel to add there resource to</param>
		/// <param name="ResourcePath">Location of the resource on disk</param>
		/// <returns>URL of the resource</returns>
		public string UploadResource (Channel CurrentChannel, string ResourcePath)
		{
			// Does the resource exist?
			if (!System.IO.File.Exists (ResourcePath))
				throw new Exception (System.IO.Directory.GetCurrentDirectory () + "\\" + ResourcePath + " does not exist.");

			// Which gallery to use?
			ResourceGallery Gallery;
			if (CurrentChannel != null)
				Gallery = CurrentChannel.DefaultResourceGallery;
			else
				Gallery = _Context.RootResourceGallery;

			// Does it already exist?
			string [] Path = ResourcePath.Split (@"\/".ToCharArray ());
			string url = FindResourceByName (Gallery.Name + "/" + Path[Path.Length - 1]);
			if (null != url)
				return url;

			// Create the resource
			Resource NewResource = Gallery.CreateResource (ResourcePath);

			// Use the filename as the display name
			NewResource.Name = Path[Path.Length - 1];

			// Upload it
			_Context.CommitAll ();

			// Return the URL of the resource
			return NewResource.Url;
		}

		/// <summary>
		/// Finds a resource given a human readable resource path.
		/// The first part of the resource path should be the root 
		/// resource gallery.
		/// 
		/// ex: FindResourceByName ("Resources\Halo2\Intro.jpg");
		/// </summary>
		/// <param name="ResourcePath">Resource's path</param>
		/// <returns>The resource's URL</returns>
		public string FindResourceByName (string ResourcePath)
		{
			// Split the resource path into its parts
			string [] PathParts = ResourcePath.Split (@"\/".ToCharArray ());

			// The first part should be the root resource
			if (PathParts[0] != _Context.RootResourceGallery.Name)
				throw new Exception (PathParts[0] + " is not the root resource");

			// If there are no sub-galleries, skip this step
			ResourceGallery Gallery = _Context.RootResourceGallery;
			if (PathParts.Length > 2)
			{
				// Find the Resource gallery
				bool bGalleryFound = false;
				for (int nGallery = 1; nGallery < PathParts.Length - 1; nGallery++)
				{
					foreach (ResourceGallery rg in Gallery.ResourceGalleries)
					{
						if (rg.Name == PathParts[nGallery])
						{
							bGalleryFound = true;
							Gallery = rg;
							break;
						}
					}
				}

				// Did we find a gallery?
				if (!bGalleryFound)
					return null;
			}
			// Now that we have the gallery, look for the resource by name
			bool bResourceFound = false;
			Resource res = null;
			foreach (Resource r in Gallery.Resources)
			{
				if (r.Name == PathParts[PathParts.Length - 1])
				{
					res = r;
					bResourceFound = true;
					break;
				}
			}

			// Did we find the resource?
			if (!bResourceFound && res == null)
				return null;

			// Return the URL of the resource
			return res.Url;
		}

		/// <summary>
		/// Returns the posting.
		/// </summary>
		/// <param name="URL"></param>
		/// <returns></returns>
		public Posting GetPostingByURL (string URL)
		{
			// Ask the CMS search object for the posting
			ChannelItem ci = _Context.Searches.GetByUrl (URL);

			// Return the item only if it's a posting
			if (ci.GetType () == typeof (Posting))
				return ci as Posting;
			else
				throw new Exception (URL + " is not a posting");
		}
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\StfTests\CMSTest\FuncFlexPage.cs ===
using System;
using System.IO;
using System.Text;
using Microsoft.Win32;
using ServerTestFramework;
using ServerTestFramework.Utilities;
using Microsoft.ContentManagement.Publishing;

namespace CMSTest
{
	/// <summary>
	/// FlexPage Test group
	/// </summary>
	[TestGroup]
	public class FlexPage : TestNode
	{
		[TestCase, Description("Main test case for FlexPages")]
			class MainLine : TestBase
		{
			protected override void Execute()
			{
				// The page has several resources in it:
				// An Image, a flash animation
				string ImageURL = CMSTestUtil.FindResourceByName ("Resources/testfileImage01.gif");
				string FlashURL = CMSTestUtil.FindResourceByName ("Resources/testfileFlash01.swf");

				// Read in the XML File and make some add the resource paths to it
				string XML = CMSTestUtil.GetFileAsString (@"CMSTestFiles\flexpage_mainline.xml");
				string FormatedXML = String.Format (XML, ImageURL, FlashURL, ImageURL);

				// Create the page from the XML
				URLTest url = CMSTestUtil.CreateFlexPageFromXML (FormatedXML, "flexpage_mainline", true);

				// Validate the page
				url = Validator.Validate (@"CMSTestFiles\flexpage_mainline.xml", url);

				// How'd it go?
				if (!url.IsValid ())
				{
					ConsoleX.WriteLine (CC.ERROR, "Failure: " + url.Error);
					ResultCode = TEST_RESULTS.FAILED;
				}
				else
				{
					ResultCode = TEST_RESULTS.PASSED;
				}

				// Write the result to a CSV
				CMSTestUtil.LogResultToFile (url);
			}
		}

		[TestCase, Description("Contains one web parts: XHTML")]
			class OneWP_XHTML : TestBase
		{
			protected override void Execute()
			{
				// The page has several resources in it:
				// An Image, a flash animation
				string ImageURL = CMSTestUtil.FindResourceByName ("Resources/testfileImage02.jpg");

				// Read in the XML File and make some add the resource paths to it
				string XML = CMSTestUtil.GetFileAsString (@"CMSTestFiles\flexpage_1wp_xhtml.xml");
				string FormatedXML = String.Format (XML, ImageURL);

				// Create the page from the XML
				URLTest url = CMSTestUtil.CreateFlexPageFromXML (FormatedXML, "flexpage_1wp_xhtml", true);

				// Validate the page
				url = Validator.Validate (@"CMSTestFiles\flexpage_1wp_xhtml.xml", url);

				// How'd it go?
				if (!url.IsValid ())
				{
					ConsoleX.WriteLine (CC.ERROR, "Failure: " + url.Error);
					ResultCode = TEST_RESULTS.FAILED;
				}
				else
				{
					ResultCode = TEST_RESULTS.PASSED;
				}

				// Write the result to a CSV
				CMSTestUtil.LogResultToFile (url);
			}
		}

		[TestCase, Description("Contains one web part: SingleSource")]
			class OneWP_SingleSource : TestBase
		{
			protected override void Execute()
			{
				// First create and publish the SingleSource 
				string SingleSourceXML = CMSTestUtil.GetFileAsString (@"CMSTestFiles\flexfragmentpage_singlesource.xml");
				string SingleSourcePath = CMSTestUtil.CreateFlexFragmentPageFromXML (SingleSourceXML, "flexfragmentpage_singlesource");

				// Get the XML for the actual test page and place the SingleSource URL in the right place
				string XML = CMSTestUtil.GetFileAsString (@"CMSTestFiles\flexpage_singlesource.xml");
				string FormatedXML = String.Format (XML, SingleSourcePath);

				// Create the actual page from the XML
				URLTest url = CMSTestUtil.CreateFlexPageFromXML (FormatedXML, "flexpage_singlesource", true);

				// Now get the XML for the page we just published...
				string FullXML = CMSTestUtil.GetDeepXMLSourceFromURL (url.URL);

				// Validate the page
				url = Validator.ValidateFromString (FullXML, url);

				// How'd it go?
				if (!url.IsValid ())
				{
					ConsoleX.WriteLine (CC.ERROR, "Failure: " + url.Error);
					ResultCode = TEST_RESULTS.FAILED;
				}
				else
				{
					ResultCode = TEST_RESULTS.PASSED;
				}

				// Write the result to a CSV
				CMSTestUtil.LogResultToFile (url);
			}
		}

		[TestCase, Description("Contains one web parts: FLASH")]
			class OneWP_Flash : TestBase
		{
			protected override void Execute()
			{
				// The page has several resources in it:
				// An Image, a flash animation
				string FlashURL = CMSTestUtil.FindResourceByName ("Resources/testfileFlash01.swf");

				// Read in the XML File and make some add the resource paths to it
				string XML = CMSTestUtil.GetFileAsString (@"CMSTestFiles\flexpage_1wp_flash.xml");
				string FormatedXML = String.Format (XML, FlashURL);

				// Create the page from the XML
				URLTest url = CMSTestUtil.CreateFlexPageFromXML (FormatedXML, "flexpage_1wp_flash", true);

				// Validate the page
				url = Validator.Validate (@"CMSTestFiles\flexpage_1wp_flash.xml", url);

				// How'd it go?
				if (!url.IsValid ())
				{
					ConsoleX.WriteLine (CC.ERROR, "Failure: " + url.Error);
					ResultCode = TEST_RESULTS.FAILED;
				}
				else
				{
					ResultCode = TEST_RESULTS.PASSED;
				}

				// Write the result to a CSV
				CMSTestUtil.LogResultToFile (url);
			}
		}

		[TestCase, Description("Contains two web parts: XHTML and FLASH")]
			class TwoWP_XHTML_Flash : TestBase
		{
			protected override void Execute()
			{
				// The page has several resources in it:
				// An Image, a flash animation
				string ImageURL = CMSTestUtil.FindResourceByName ("Resources/testfileImage02.jpg");
				string FlashURL = CMSTestUtil.FindResourceByName ("Resources/testfileFlash01.swf");

				// Read in the XML File and make some add the resource paths to it
				string XML = CMSTestUtil.GetFileAsString (@"CMSTestFiles\flexpage_2wp_xhtml_flash.xml");
				string FormatedXML = String.Format (XML, ImageURL, FlashURL);

				// Create the page from the XML
				URLTest url = CMSTestUtil.CreateFlexPageFromXML (FormatedXML, "flexpage_2wp_xhtml_flash", true);

				// Validate the page
				url = Validator.Validate (@"CMSTestFiles\flexpage_2wp_xhtml_flash.xml", url);

				// How'd it go?
				if (!url.IsValid ())
				{
					ConsoleX.WriteLine (CC.ERROR, "Failure: " + url.Error);
					ResultCode = TEST_RESULTS.FAILED;
				}
				else
				{
					ResultCode = TEST_RESULTS.PASSED;
				}

				// Write the result to a CSV
				CMSTestUtil.LogResultToFile (url);
			}
		}

		[TestCase, Description("Contains nested Columns/ColumnGroups: 5 deep")]
			class Nested_05_Deep : TestBase
		{
			protected override void Execute()
			{
				// Create the page from the XML
				URLTest url = CMSTestUtil.CreateFlexPageFromFile (@"CMSTestFiles\flexpage_nested_5.xml", "flexpage_nested_05", true);

				// Validate the page
				url = Validator.Validate (@"CMSTestFiles\flexpage_nested_5.xml", url);

				// How'd it go?
				if (!url.IsValid ())
				{
					ConsoleX.WriteLine (CC.ERROR, "Failure: " + url.Error);
					ResultCode = TEST_RESULTS.FAILED;
				}
				else
				{
					ResultCode = TEST_RESULTS.PASSED;
				}

				// Write the result to a CSV
				CMSTestUtil.LogResultToFile (url);
			}
		}

		[TestCase, Ignore, Description("Contains nested Columns/ColumnGroups: 10 deep")]
			class Nested_10_Deep : TestBase
		{
			protected override void Execute()
			{
				// Create the page from the XML
				URLTest url = CMSTestUtil.CreateFlexPageFromFile (@"CMSTestFiles\flexpage_nested_10.xml", "flexpage_nested_10", true);

				// Validate the page
				url = Validator.Validate (@"CMSTestFiles\flexpage_nested_10.xml", url);

				// How'd it go?
				if (!url.IsValid ())
				{
					ConsoleX.WriteLine (CC.ERROR, "Failure: " + url.Error);
					ResultCode = TEST_RESULTS.FAILED;
				}
				else
				{
					ResultCode = TEST_RESULTS.PASSED;
				}

				// Write the result to a CSV
				CMSTestUtil.LogResultToFile (url);
			}
		}

		[TestCase, Description("Tests different sizes for the Flash webpart")]
			class WebPartSize_Flash : TestBase
		{
			protected override void Execute()
			{
				// The page has several resources in it:
				// An Image, a flash animation
				string FlashURL = CMSTestUtil.FindResourceByName ("Resources/testfileFlash01.swf");

				// Read in the XML File and make some add the resource paths to it
				string XML = CMSTestUtil.GetFileAsString (@"CMSTestFiles\flexpage_size_flash.xml");
				string FormatedXML = String.Format (XML, FlashURL, FlashURL, FlashURL);

				// Create the page from the XML
				URLTest url = CMSTestUtil.CreateFlexPageFromXML (FormatedXML, "flexpage_size_flash", true);

				// Validate the page
				url = Validator.Validate (@"CMSTestFiles\flexpage_size_flash.xml", url);

				// How'd it go?
				if (!url.IsValid ())
				{
					ConsoleX.WriteLine (CC.ERROR, "Failure: " + url.Error);
					ResultCode = TEST_RESULTS.FAILED;
				}
				else
				{
					ResultCode = TEST_RESULTS.PASSED;
				}

				// Write the result to a CSV
				CMSTestUtil.LogResultToFile (url);
			}
		}

		[TestCase, Description("Tests different heights for the column")]
			class WebPartSize_Height_Column : TestBase
		{
			protected override void Execute()
			{
				// Create the page from the XML
				URLTest url = CMSTestUtil.CreateFlexPageFromFile (@"CMSTestFiles\flexpage_size_height_column.xml", "flexpage_size_height_column", true);

				// Validate the page
				url = Validator.Validate (@"CMSTestFiles\flexpage_size_height_column.xml", url);

				// How'd it go?
				if (!url.IsValid ())
				{
					ConsoleX.WriteLine (CC.ERROR, "Failure: " + url.Error);
					ResultCode = TEST_RESULTS.FAILED;
				}
				else
				{
					ResultCode = TEST_RESULTS.PASSED;
				}

				// Write the result to a CSV
				CMSTestUtil.LogResultToFile (url);
			}
		}
		[TestCase, Description("Tests different widths for the column")]
			class WebPartSize_Width_Column : TestBase
		{
			protected override void Execute()
			{
				// Create the page from the XML
				URLTest url = CMSTestUtil.CreateFlexPageFromFile (@"CMSTestFiles\flexpage_size_width_column.xml", "flexpage_size_width_column", true);

				// Validate the page
				url = Validator.Validate (@"CMSTestFiles\flexpage_size_width_column.xml", url);

				// How'd it go?
				if (!url.IsValid ())
				{
					ConsoleX.WriteLine (CC.ERROR, "Failure: " + url.Error);
					ResultCode = TEST_RESULTS.FAILED;
				}
				else
				{
					ResultCode = TEST_RESULTS.PASSED;
				}

				// Write the result to a CSV
				CMSTestUtil.LogResultToFile (url);
			}
		}

		[TestCase, Description("Tests ColumnGroup transparency")]
			class Transparency_ColumnGroup : TestBase
		{
			protected override void Execute()
			{
				// Create the page from the XML
				URLTest url = CMSTestUtil.CreateFlexPageFromFile (@"CMSTestFiles\flexpage_transparency_columngroup.xml", "flexpage_transparency_columngroup", true);

				// Validate the page
				url = Validator.Validate (@"CMSTestFiles\flexpage_transparency_columngroup.xml", url);

				// How'd it go?
				if (!url.IsValid ())
				{
					ConsoleX.WriteLine (CC.ERROR, "Failure: " + url.Error);
					ResultCode = TEST_RESULTS.FAILED;
				}
				else
				{
					ResultCode = TEST_RESULTS.PASSED;
				}

				// Write the result to a CSV
				CMSTestUtil.LogResultToFile (url);
			}
		}

		[TestCase, Description("Tests Column transparency")]
			class Transparency_Column : TestBase
		{
			protected override void Execute()
			{
				// Create the page from the XML
				URLTest url = CMSTestUtil.CreateFlexPageFromFile (@"CMSTestFiles\flexpage_transparency_column.xml", "flexpage_transparency_column", true);

				// Validate the page
				url = Validator.Validate (@"CMSTestFiles\flexpage_transparency_column.xml", url);

				// How'd it go?
				if (!url.IsValid ())
				{
					ConsoleX.WriteLine (CC.ERROR, "Failure: " + url.Error);
					ResultCode = TEST_RESULTS.FAILED;
				}
				else
				{
					ResultCode = TEST_RESULTS.PASSED;
				}

				// Write the result to a CSV
				CMSTestUtil.LogResultToFile (url);
			}
		}

		[TestCase, Description("CTests webpart with Column/ColumnGroup transparency")]
			class Transparency_WebParts : TestBase
		{
			protected override void Execute()
			{
				// The page has several resources in it:
				// An Image, a flash animation
				string ImageURL = CMSTestUtil.FindResourceByName ("Resources/testfileImage02.jpg");
				string FlashURL = CMSTestUtil.FindResourceByName ("Resources/testfileFlash01.swf");

				// Read in the XML File and make some add the resource paths to it
				string XML = CMSTestUtil.GetFileAsString (@"CMSTestFiles\flexpage_transparency_webparts.xml");
				string FormatedXML = String.Format (XML, ImageURL, FlashURL, ImageURL, FlashURL, ImageURL, FlashURL, ImageURL, ImageURL);

				// Create the page from the XML
				URLTest url = CMSTestUtil.CreateFlexPageFromXML (FormatedXML, "flexpage_transparency_webparts", true);

				// Validate the page
				url = Validator.Validate (@"CMSTestFiles\flexpage_transparency_webparts.xml", url);

				// How'd it go?
				if (!url.IsValid ())
				{
					ConsoleX.WriteLine (CC.ERROR, "Failure: " + url.Error);
					ResultCode = TEST_RESULTS.FAILED;
				}
				else
				{
					ResultCode = TEST_RESULTS.PASSED;
				}

				// Write the result to a CSV
				CMSTestUtil.LogResultToFile (url);
			}
		}
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\StfTests\CMSTest\SimpleTree.cs ===
using System;
using System.Collections;
using System.Text;

namespace CMSTest
{
	/// <summary>
	/// Summary description for SimpleTree.
	/// </summary>
	public class SimpleTree
	{
		// P R O T E C T E D   M E M B E R S ////////////////////////////////////////
		protected SimpleTree	_Parent;			/// The tree's parent
		protected ArrayList		_Children;			/// A list of all the tree's children
		protected string		_Name;				/// A name for this node
		protected Hashtable		_Attributes;		/// All of the tree's attributes
 
		// P U B L I C   A T T R I B U T E S ////////////////////////////////////////
		#region
		/// <summary>
		/// Gets/Sets The tree's parent
		/// </summary>
		public SimpleTree Parent 
		{
			get { return _Parent; }
			set { _Parent = value; }
		}
		/// <summary>
		/// Returns the specified child.  Note that the indexer is 0-based.
		/// </summary>
		public SimpleTree this [int nIdx]
		{
			get
			{
				if (_Children == null)
					throw new Exception ("Node \'" + _Name + "\' does not have any children");
				if (nIdx >= _Children.Count)
					throw new Exception ("Index " + nIdx + " out of range (out of a possible " + _Children.Count + ")");
				return _Children[nIdx] as SimpleTree;
			}
		}

		/// <summary>
		/// Gest/Sets the node's name
		/// </summary>
		public string Name
		{
			get { return _Name; }
			set { _Name = value; }
		}

		/// <summary>
		/// Gets/Sets the tree's attributes
		/// </summary>
		public string this [string sAttribute]
		{
			get
			{
				return _Attributes[sAttribute] as string;
			}
			set 
			{
				if (_Attributes == null)
					_Attributes = new Hashtable ();

				_Attributes.Add (sAttribute, value);
			}
		}

		public Hashtable Attributes
		{
			get { return _Attributes; }
		}

		public ArrayList Children 
		{
			get { return _Children; }
		}
		#endregion

		// P R O T E C T E D   M E T H O D S ////////////////////////////////////////
		protected string _ToString (int nIndent)
		{
			// Create a string for this node
			StringBuilder sNode = new StringBuilder ();
			sNode.Append (' ', nIndent);
			sNode.Append (_Name);

			// Append the attributes
			if (_Attributes.Count > 0)
			{
				sNode.Append (" (");
				IDictionaryEnumerator iEnum = _Attributes.GetEnumerator ();
				iEnum.Reset ();
				while (iEnum.MoveNext ())
				{
					sNode.Append (iEnum.Entry.Key);
					sNode.Append ('=');
					sNode.Append (iEnum.Entry.Value);
					sNode.Append ("; ");
				}
				sNode.Append (")");
			}
			sNode.Append ('\n');

			// Time to add the kids
			foreach (SimpleTree Child in _Children)
			{
				sNode.Append (Child._ToString (nIndent + 4));
			}

			return sNode.ToString ();
		}

		/// <summary>
		/// Static method that compares to string hashtables
		/// </summary>
		/// <param name="LHS">Left Hand Side hashtable</param>
		/// <param name="RHS">Right Hand Side hastable</param>
		/// <returns>True if equal</returns>
		static protected bool _CompareHashetables (Hashtable LHS, Hashtable RHS)
		{
			bool bEqual = false;
			// First make sure the're the same number of items in there
			if (LHS.Count == RHS.Count)
			{
				bEqual = true;
				// Iterate through each item in LHS and see if it's in RHS
				IDictionaryEnumerator iEnum = LHS.GetEnumerator ();
				while (iEnum.MoveNext ())
				{
					try
					{
						string rhsValue = RHS[iEnum.Entry.Key] as string;
						string lhsValue = LHS[iEnum.Entry.Key] as string;
						if (rhsValue != lhsValue)
						{
							bEqual = false;
							break;
						}
						else
						{
							bEqual = true;
						}
					}
					catch
					{
						break;
					}
				}

			}

			// Done
			return bEqual;
		}

		// P U B L I C   M E T H O D S //////////////////////////////////////////////
		/// <summary>
		/// Default Constructor
		/// </summary>
		public SimpleTree ()
		{
			_Parent = null;
			_Name = null;
			_Children = new ArrayList ();
			_Attributes = new Hashtable ();
		}

		/// <summary>
		/// Constructor.  Can specify tree's parent and name
		/// </summary>
		/// <param name="Parent">Tree's parent</param>
		/// <param name="Name">Tree's name</param>
		public SimpleTree (SimpleTree Parent, string Name)
		{
			_Parent = Parent;
			_Name = Name;
			_Children = new ArrayList ();
			_Attributes = new Hashtable ();
		}

		/// <summary>
		/// Create a new node with the specified name and make it a child of this tree
		/// </summary>
		/// <param name="Name">Name of the child</param>
		/// <returns>A reference to the newly created child</returns>
		public SimpleTree Insert (string Name)
		{
			// Create a new tree
			SimpleTree NewTree = new SimpleTree (this, Name);

			// Add it to the new list
			_Children.Add (NewTree);

			// Done
			return NewTree;
		}

		public void Insert (SimpleTree Child)
		{
			// Add it to the new list
			_Children.Add (Child);
		}

		/// <summary>
		/// Returns a string representation of the tree
		/// </summary>
		/// <returns></returns>
		public override string ToString()
		{
			return _ToString (0);
		}

		public bool IsEqualTo (SimpleTree RHS)
		{
			bool bIsEqual = false;

			// Compare the hashtables of attributes
			if (_CompareHashetables (_Attributes, RHS._Attributes))
			{
				bIsEqual = true;
				// First make sure that they have the same number of children
				if (_Children.Count == RHS._Children.Count)
				{
					// Good, now test every child
					for (int nChild = 0; nChild < _Children.Count; nChild++)
					{
						// If a child isn't equal, then break outta here!
						bIsEqual = (_Children[nChild] as SimpleTree).IsEqualTo ((RHS._Children[nChild] as SimpleTree));
						if (!bIsEqual)
							break;
					}
				}
			}

			// Done
			return bIsEqual;
		}
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\StfTests\CMSTest\HTMLTreeBuilder.cs ===
using System;

namespace CMSTest
{
	/// <summary>
	/// Summary description for HTMLTreeBuilder.
	/// </summary>
	public class HTMLTreeBuilder
	{
		/// <summary>
		/// List of ignored attributes in the HTML
		/// </summary>
		#region
		protected string [] _sIgnoreList = 
		{ 
			"description", 
			"xmlformgroup_expanded",
			"backgroundPositionX",
			"backgroundPositionY"
		};
		#endregion

		public SimpleTree Build (string sSource)
		{
			// Strip the crap from the string
			sSource = TrimToBeginning (sSource);

			// Create a new tree
			SimpleTree Root = new SimpleTree ();
			Root.Name = "Page";

			// Add every XML node and attributes to the tree
			string sNode;
			SimpleTree Parent = Root;
			SimpleTree Child = Root;
			while ((sNode = GetNextNodeFromString (sSource)) != String.Empty)
			{
				// Skip non-div tags
				if (sNode.IndexOf ("<div") == -1 && sNode.IndexOf ("</div>") == -1)
					continue;

				// Who's yo daddy?
				if (sNode.IndexOf ('/') == -1)
				{
					Parent = Child;
				}
				else
				{
					// If it should happen that we have more </div> tags than <div> tags,
					// make sure we don't overflow.
					if (Child == Root)
						break;

					Child = Parent;
					Parent = Parent.Parent;
					continue;
				}

				// Create a new node with from the string
				Child = new SimpleTree (Parent, null);
				ParseString (Child, sNode);
				Parent.Insert (Child);
			}

			// Done
			return Root;
		}
//0---------|---------|---------|---------|---------|
//<div class="wpRootWebPart" style="width:100%;">
		protected void ParseString (SimpleTree Node, string sSource)
		{
			// Get the 'style="...."' string
			int nStart = sSource.IndexOf ("style=") + "style=".Length + 1;
			int nLen = sSource.IndexOf ("\"", nStart) - nStart - 1;
			string sAttribString = sSource.Substring (nStart, nLen);
			
			// Split the html string by ";" to get all the attributes
			string [] sAttribs = sAttribString.Split (";".ToCharArray ());

			// Iterate through all the attributes
			for (int nIdx = 0; nIdx < sAttribs.Length; nIdx++)
			{
				if (!IsIgnorable (sAttribs[nIdx]))
				{
					// The string should be in the form <attribute>:<value>;
					string [] sPair = sAttribs[nIdx].Split (":".ToCharArray ());
					Node[sPair[0].Trim ()] = sPair[1].Trim (" \">".ToCharArray ());
				}
			}

			// Set the name of the Node to that of the wp element
			int nNameStart = sSource.IndexOf ("class=\"wp") + "class=\"wp".Length;
			int nNameLen = sSource.IndexOf ("\"", nNameStart) - nNameStart;
			Node.Name = sSource.Substring (nNameStart, nNameLen);
		}

		/// <summary>
		/// Returns true if this attribute is one we should ignore
		/// </summary>
		/// <param name="sAttrib">Name of the attribute to check</param>
		/// <returns>true if we should ignore it</returns>
		protected bool IsIgnorable (string sAttrib)
		{
			// It should have an "=" sign in it
			if (sAttrib.IndexOf (":") == -1)
				return true;

			// Make sure it does not contain an ignorable attribute
			foreach (string s in _sIgnoreList)
			{
				if (sAttrib.IndexOf (s) != -1)
					return true;
			}

			return false;
		}

		protected int _nStartIdx = 0;
		protected string GetNextNodeFromString (string sXml)
		{
			string sNode = String.Empty;
			bool bDone = false;

			while (!bDone)
			{
				// Get the first "<"
				int nLT = sXml.IndexOf ('<', _nStartIdx);
			
				// if it does not exist, then we're done
				if (nLT != -1)
				{
					// Get the first ">"
					int nGT = sXml.IndexOf ('>', nLT);

					// Again, if it does not exist, we're done
					if (nGT != -1)
					{
						// Get the substring
						sNode = sXml.Substring (nLT, nGT - nLT + 1);

						// Update the index
						_nStartIdx = nGT + 1;
					}
				}

				// Well, we only want it if it has a wp attrib in it or if it's a </div> tag
				if (sNode.IndexOf ("wp") != -1 || sNode == "</div>")
					bDone = true;
			}

			// Done
			return sNode;
		}

		/// <summary>
		/// Strips all text up until the beginning of the XML->HTML content
		/// </summary>
		/// <param name="sHtml">Web page source</param>
		/// <returns>A string containing HTML generated from the HTML</returns>
		protected string TrimToBeginning (string sHtml)
		{
			// Skip app the junk and go right to the good stuff
			string sBeginning = "<div class=\"wpRootWebPart\"";
			return sHtml.Substring (sHtml.IndexOf (sBeginning) + sBeginning.Length);
		}
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\StfTests\CMSTest\PageValidator.cs ===
using System;
using System.Collections;

namespace CMSTest
{
	/// <summary>
	/// Summary description for Validator.
	/// </summary>
	public class PageValidator
	{
		protected static Hashtable _AttributeLUT = null;

		/// <summary>
		/// Initializes the Attribute Lookup Table
		/// </summary>
		protected static void _InitializeLUT ()
		{
			// Create a new hashtable
			_AttributeLUT = new Hashtable ();

			// Popupate it with attribs.  The XML attrib it the key while the HTML 
			// attrib is the value
			_AttributeLUT.Add ("width",				"width");
			_AttributeLUT.Add ("height",			"height");
			_AttributeLUT.Add ("backColor",			"back-color");
			_AttributeLUT.Add ("backgroundRepeat",	"background-repeat");
		}

		/// <summary>
		/// Converts an XML attribute into the appropriate HTML style
		/// </summary>
		/// <param name="sAttribute">The attribute to convert</param>
		/// <param name="sConvertedAttrib">Out param that will contain the converted attribute</param>
		/// <returns>Returns true if a corresponding attribute was found.  If the it returns
		/// false, then the sConvertedAttrib is null.</returns>
		protected static bool _Convert (string sAttribute, out string sConvertedAttrib)
		{
			bool bFoundMatch = false;
			// Make sure that LUT has been initialized
			if (null == _AttributeLUT)
				_InitializeLUT ();
		
			// Get the attribute
			try
			{
				sConvertedAttrib = _AttributeLUT[sAttribute] as string;
				bFoundMatch = true;
			}
			catch
			{
				sConvertedAttrib = null;
			}

			// Done
			return bFoundMatch;
		}

		/// <summary>
		/// Checks to see if we care about an attribute or not.
		/// </summary>
		/// <param name="sAttribute">Name of the attribute to check</param>
		/// <returns>True if we care about it.</returns>
		protected static bool _IsValidAttribute (string sAttribute)
		{
			// Try to access the attribute in the lut.  If it's not in there, we don't 
			// care for it.  We're elitist that way.
			bool bIsValid = false;
			try
			{
				string sValidAttrib = _AttributeLUT[sAttribute] as string;
				bIsValid = (null != sValidAttrib);
			}
			catch
			{
				// Do nothing
			}

			// Done
			return bIsValid;
		}

		/// <summary>
		/// Compares two SimpleTrees: one formed from the XML, the other from the HTML
		/// </summary>
		/// <param name="XML">SimpleTree formed from XML</param>
		/// <param name="HTML">SimpleTree formed from HTML</param>
		/// <returns>Returs true if they match</returns>
		public static bool Run (SimpleTree XML, SimpleTree HTML)
		{
			bool bAreEquivalent = false;

			// Compare the hashtables of attributes
			if (_CompareHashetables (XML.Attributes, HTML.Attributes))
			{
				bAreEquivalent = true;
				// First make sure that they have the same number of children
				if (XML.Children.Count == HTML.Children.Count)
				{
					// Good, now test every child
					for (int nChild = 0; nChild < XML.Children.Count; nChild++)
					{
						// If a child isn't equal, then break outta here!
						bAreEquivalent = Run (XML.Children[nChild] as SimpleTree, HTML.Children[nChild] as SimpleTree);
						if (!bAreEquivalent)
							break;
					}
				}
			}

			// Done
			return bAreEquivalent;
		}

		/// <summary>
		/// Compares to string hashtables
		/// </summary>
		/// <param name="LHS">Left Hand Side hashtable</param>
		/// <param name="RHS">Right Hand Side hastable</param>
		/// <returns>True if equal</returns>
		protected static bool _CompareHashetables (Hashtable LHS, Hashtable RHS)
		{
			bool bEqual = true;
			// Iterate through each item in LHS and see if it's in RHS
			IDictionaryEnumerator iEnum = LHS.GetEnumerator ();
			while (iEnum.MoveNext ())
			{
				try
				{
					string lhsValue = LHS[iEnum.Entry.Key] as string;
					// Do all the nice comparison stuff only if we care about 
					// the attribute to begin with
					if (_IsValidAttribute (lhsValue))
					{
						string rhsAttrib;
						string rhsValue = null;
						if (_Convert (lhsValue, out rhsAttrib))
							rhsValue = RHS[rhsAttrib] as string;

						if (rhsValue != lhsValue)
						{
							bEqual = false;
							break;
						}
						else
						{
							bEqual = true;
						}
					}
				}
				catch
				{
					break;
				}
			}

			// Done
			return bEqual;
		}
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\StfTests\CMSTest\Validator.cs ===
using System;
//using Microsoft.WebRunner;
using ServerTestFramework;
using System.Xml;
using System.Data;
using System.Data.SqlClient;
using System.IO;
using System.Collections;
using System.Net;
using System.Threading;
using System.ComponentModel;
using System.Diagnostics;
using System.Text;
using System.Resources;
using System.Reflection;
using System.Globalization;
using ServerTestFramework.Database;
using ServerTestFramework.LiveService.Notification;
using ServerTestFramework.LiveService.Presence;
using ServerTestFramework.LiveService.PresNotiCommon;
using ServerTestFramework.Utilities;
//using Microsoft.WebRunner.Loggers;


namespace CMSTest
{
	/// <summary>
	/// HTML Validator
	/// </summary>
	public class Validator
	{
		static public int Delay;
		public static URLTest Validate (string sFilename, URLTest TestPage)
		{
			// Read in the XML file
			string sXml;
			using (StreamReader sr = new StreamReader(sFilename, Encoding.ASCII)) 
			{
				sXml = sr.ReadToEnd();
			}
			
			// Do the validation
			return ValidateFromString (sXml, TestPage);
		}

		public static URLTest ValidateFromString (string sXml, URLTest TestPage)
		{
			// Read in the resulting HTML
			string sHTML = GetHTMLString (TestPage.URL);

			// Generate the XML tree
			XMLTreeBuilder xmlTB =  new XMLTreeBuilder ();
			SimpleTree xmlTree = xmlTB.Build (sXml);

			// Generate the HTML tree
			HTMLTreeBuilder htmlTB = new HTMLTreeBuilder ();
			SimpleTree htmlTree = htmlTB.Build (sHTML);

			// Validate the page
			TestPage.DoesRender = PageValidator.Run (xmlTree, htmlTree);
			return TestPage;
		}

		static public string GetHTMLString (string URL)
		{
			// Create the request instance.
			HttpWebRequest wReq = (HttpWebRequest)WebRequest.Create(URL);
			wReq.UserAgent = "Mozilla/4.0 (compatible; MSIE 6.0; Windows NT 6.0)";
			//wReq.Headers["Accept-language"] = "en-us";
			System.Threading.Thread.Sleep (Delay);

			// Get the response instance
			HttpWebResponse wResp = (HttpWebResponse)wReq.GetResponse();
			System.Threading.Thread.Sleep (Delay);

			// Get the response stream.
			Stream respStream = wResp.GetResponseStream();
			System.Threading.Thread.Sleep (Delay);

			// Read in the whole thing
			string Strhtml = null;
			using (StreamReader sr = new StreamReader(respStream, Encoding.ASCII)) 
			{
				Strhtml = sr.ReadToEnd();
			}

			return Strhtml;
		}
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\StfTests\CMSTest\XMLTreeBuilder.cs ===
using System;
using System.Collections;

namespace CMSTest
{
	/// <summary>
	/// Summary description for XMLTreeBuilder.
	/// </summary>
	public class XMLTreeBuilder
	{
		public SimpleTree Build (string sSource)
		{
			// Create a new tree
			SimpleTree Root = new SimpleTree ();
			Root.Name = "Page";

			// Skip the first node
			GetNextNodeFromString (sSource);

			// Add every XML node and attributes to the tree
			string sNode;
			SimpleTree Parent = Root;
			SimpleTree Child = Root;
			while ((sNode = GetNextNodeFromString (sSource)) != String.Empty)
			{
				// Who's yo daddy?
				if (sNode.IndexOf ('/') == -1)
				{
					Parent = Child;
				}
				else
				{
					// Go back a generation
					if (null != Parent)
					{
						Child = Parent;
						Parent = Parent.Parent;
					}

					// Skip the rest
					continue;
				}

				// Create a new node with from the string
				Child = new SimpleTree (Parent, null);
				ParseString (Child, sNode);
				if (null != Parent)
					Parent.Insert (Child);
				else
					Root = Child;
			}

			// Done
			return Root;
		}

/*		public SimpleTree Build (string sSource)
		{
			// Add every XML node and attributes to the tree
			string sNode;
			SimpleTree Parent = null;
			SimpleTree Child = null;
			SimpleTree Root = null;
			while ((sNode = GetNextNodeFromString (sSource)) != String.Empty)
			{
				// We always assume the child in the previous step has "matured" and become
				// a parent.  If, on the other hand, we find a "/", we "demote" them and
				// are no longer parents.
				if (sNode.IndexOf ('/') != -1)
				{
					// Go back a generation
					if (null != Parent)
						Parent = Parent.Parent;

					// Skip the rest
					continue;
				}

				// Congrat, you're a dad!
				Parent = Child;

				// Create a new node with from the string
				Child = new SimpleTree (Parent, null);
				ParseString (Child, sNode);
				if (null != Parent)
					Parent.Insert (Child);
				else
					Root = Child;
			}

			// Done
			return Root;
		}
*/
		/// <summary>
		/// List of ignored attributes in the XML
		/// </summary>
		#region
		protected string [] _sIgnoreList = 
		{ 
			"description", 
			"xmlformgroup_expanded",
			"backgroundPositionX",
			"backgroundPositionY",
			"wp"
		};
		#endregion

		/// <summary>
		/// Parse a string that is in the format &lt;name attribute1=value1 attribute2=value2 ...&gt;
		/// </summary>
		/// <param name="Node">Node which we want to add the attributes to</param>
		/// <param name="sXml">The XML string to parse</param>
		public void ParseString (SimpleTree Node, string sXml)
		{
			// Split the xml string by " " to get all the attributes
			string [] sAttribs = sXml.Split (" ".ToCharArray ());

			// Iterate through all the attributes
			for (int nIdx = 1; nIdx < sAttribs.Length; nIdx++)
			{
				if (!IsIgnorable (sAttribs[nIdx]))
				{
					// The string should be in the form <attribute>=<value>
					string [] sPair = sAttribs[nIdx].Split ("=".ToCharArray ());
					Node[sPair[0].Trim ()] = sPair[1].Trim (" \">".ToCharArray ());
				}
			}

			// Set the name of the Node to that of the wp element
			Node.Name = sAttribs[0].Trim (" <".ToCharArray ());
		}

		/// <summary>
		/// Returns true if this attribute is one we should ignore
		/// </summary>
		/// <param name="sAttrib">Name of the attribute to check</param>
		/// <returns>true if we should ignore it</returns>
		protected bool IsIgnorable (string sAttrib)
		{
			// It should have an "=" sign in it
			if (sAttrib.IndexOf ("=") == -1)
				return true;

			// Make sure it does not contain an ignorable attribute
			foreach (string s in _sIgnoreList)
			{
				if (sAttrib.IndexOf (s) != -1)
					return true;
			}

			return false;
		}

		protected int _nStartIdx = 0;
		public string GetNextNodeFromString (string sXml)
		{
			string sNode = String.Empty;

			// Get the first "<"
			int nLT = sXml.IndexOf ('<', _nStartIdx);
			
			// if it does not exist, then we're done
			if (nLT != -1)
			{
				// Get the first ">"
				int nGT = sXml.IndexOf ('>', nLT);

				// Again, if it does not exist, we're done
				if (nGT != -1)
				{
					// Get the substring
					sNode = sXml.Substring (nLT, nGT - nLT + 1);

					// Update the index
					_nStartIdx = nGT + 1;
				}
			}

			// Done
			return sNode;
		}
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\StfTests\CMSTest\XmlConfigFile.cs ===
using System;
using System.Xml;

namespace CMSTest
{
	/// <summary>
	/// This class facilitates the reading of an XML config file that contains
	/// data that depends on the enviroment that it is running againt.  For
	/// example: usernames may be different in TestNet vs. PreProd vs. BVTNet,
	/// etc.
	/// 
	/// The format of the XML file is expected to be as such:
	// <config>
	//      <environ>[EnvironmentName]</environ>
	//      <[EnvironmentName1]>
	//           <value1></value1>
	//           <value2></value2>
	//           <value3></value3>
	//      </[EnvironmentName1]>
	//      <[EnvironmentName2]>
	//           <value1></value1>
	//           <value2></value2>
	//           <value3></value3>
	//      </[EnvironmentName2]>
	// </config>
	///
	/// A practical example would be:
	// <config>
	//      <environ>TestNet</environ>
	//      <TestNet>
	//           <username>TestUser</username>
	//      </TestNet>
	//      <PreProd>
	//           <username>PreProdUser</username>
	//      </PreProd>
	// </config>
	/// </summary>
	public class XmlConfigFile
	{
		// P R I V A T E   M E M B E R S //////////////////////////////////////
		private XmlDocument _Doc = null;
		private string _Environment;

		// P U B L I C   M E M B E R S ////////////////////////////////////////

		/// <summary>
		/// Constructor reads in the config file and determines the environment
		/// to run on based on the "environ" tag
		/// </summary>
		/// <param name="Filename">name of the config file</param>
		public XmlConfigFile (string Filename)
		{
			// Load the file
			_Doc = new XmlDocument ();
			_Doc.Load (Filename);

			// Read in the environment
			XmlNode xmlEnvironment;
			xmlEnvironment = _Doc.SelectSingleNode ("/config/environ");
			if (null != xmlEnvironment)
				_Environment = "/config/" + xmlEnvironment.InnerText;
			else
				throw new XmlException ("Could not determine which environment to read");
		}

		/// <summary>
		/// Accessor method used to read the needed data, it automatically takes care of
		/// reading from the right environment.  It's used like this:
		/// 
		/// XmlConfigFile Config = new Config ("MyConfigFile.xml");
		/// string SomeSetting = Config["/Auth/Username"];
		/// 
		/// </summary>
		public string this [string NodeName]
		{
			get
			{
				// Make sure that the XmlDocument's intialized and loaded
				if (null == _Doc)
					throw new XmlException ("XmlConfigFile not intialized");

				// Read in the wanted node
				XmlNode xmlData = _Doc.SelectSingleNode (_Environment + NodeName);
				if (null == xmlData)
					throw new XmlException ("Cannot read " + NodeName + " in " + _Environment);
				else
					return xmlData.InnerText;
			}
		}
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\StfTests\Examples\CowBellTests\CowBellTests.cs ===
using System;
using ServerTestFramework;

//Indicate the root node of the test tree for this suite.
[assembly: RootNode(typeof(CowBellTests.CowBellTestSuite))]

namespace CowBellTests
{
    /// <summary> Tests for the CowBell server.  These tests don't actually call into Live, they just demonstrate how to write tests. </summary>
    /// <Goal> Eat grass </Goal>
    /// <NonGoal> Make the grass grow </NonGoal>
    /// <Description>
    ///     <p>High level description of what is expected from this suite.  Documetation can contain html formating.</p>
    ///     But using html formatting is totally optional.
    /// </Description>
    [TestGroup, Owner("Farmer Jim"), TestFrequency("Regression"), TestCasePriority(1)]
    public class CowBellTestSuite: TestNode
    {
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\StfTests\Examples\CowBellTests\EngraveBellApi.cs ===
using System;
using ServerTestFramework;
using ServerTestFramework.Utilities; //contains ValueCheck

namespace CowBellTests
{
    /// <summary> Tests for engraving the cowbell and showing some more advanced topics. </summary>
    /// <Goals>
    ///     Engrave the bell with a sharp stick.
    /// </Goals>
    /// <NonGoals>
    ///     Fix the bell if we break it.
    /// </NonGoals>
    [TestGroup]
    public class EngraveBell: TestNode
    {
        //Here's an example of creating our own reporting object. (totally optional, it just gives you a separate report area to look for)
        private static Report ro=new Report(typeof(EngraveBell).Name);

        //Tests
        [TestCase, Description("Shows how to use the reporting object we created.")]
        public void WriteOutput()
        {
            ro.Warn("Something suspicious happened.");
            ro.Info("Something important happened.");
            ro.Debug("Something minor happened.");
        }

        [TestCase, Description("Demonstrates how to use ValueCheck.")]
        public void CheckThatWeHaveABell()
        {
            string whatDoWeHave="Shoe";

            //If the second parameter (what we expect) is different than the third parameter (what we got), this throws an exception.
            ValueCheck.Test("What we have", "Bell", whatDoWeHave);
        }

        [TestCase, Description("Demonstrates how to use CompoundCase to generate multiple tests from a single class.")]
        [CompoundCase("Small Amount",    1)]
        [CompoundCase("Moderate Amount", 2)]
        [CompoundCase("Large Amount",    3)]
        public class DifferentAmounts: TestNode
        {
            public override void Run()
            {
                //MyValues is an object[] that is populated with all parameters to CompoundCase.  Each case can have any number of parameters, though we have just 1 here.
                int amount=(int)MyValues[0];

                if (amount<2)
                {
                    throw new UnexpectedTestResultException("Needs more cowbell.");
                }

                return TEST_RESULTS.PASSED;
            }
        }

        [TestCase, Ignore, Description("This test case will compile and show up but will not be run because it is ignored.")]
        public void ThisTestIsIgnored()
        {
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\StfTests\Examples\HouseFDTests\HouseFDTests.cs ===
using System;
using ServerTestFramework;

//Indicates the root node of the test tree for this suite.
[assembly: RootNode(typeof(HouseFDTests.HouseFDRootNode))]

namespace HouseFDTests
{
    /// <summary> Tests for the House Front Door server. </summary>
    /// <Goal> Make a call to the (mythical) server. </Goal>
    /// <NonGoal> Succeed in calling the server, since it doens't exist. </NonGoal>
    /// <Description>
    ///     These tests demonstrate how to make a front door call using the XRL objects.
    ///     The call will not actually succeed since the server does not exist.
    /// </Description>
    [TestGroup, Owner("Exemplum"), TestFrequency("Daily"), TestCasePriority(2)]
    public class HouseFDRootNode: TestNode
    {
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\StfTests\Examples\CowBellTests\RingBellApi.cs ===
using System;
using ServerTestFramework;

namespace CowBellTests
{
    /// <summary> Tests for ringing the cowbell. </summary>
    /// <Goals>
    ///       [What is the main goal of this testing]
    ///       Example: Ring the bell.
    /// </Goals>
    /// <NonGoals>
    ///       [What are the things that will not be tested.]
    ///       Example: Polish the bell.
    /// </NonGoals>
    [TestGroup]
    public class RingBell: TestNode
    {
        //Helper function for using the bell.
        private static void StrikeBell(string how)
        {
            //To output debug text, use a reporting object.  If you don't want to create your own, you may use the global one:
            Global.RO.Debug("Striking the bell "+how+".");

            if (how.Contains(" "))
            {
                //The preferred way to fail a test is to throw an exception.
                //This allows you to provide details on the failure and also gives us a stack trace for where in the test code the failure decision came from.
                throw new UnexpectedTestResultException("Failed to strike the bell because it was too complicated.");
            }
        }

        //Tests
        [TestCase, Description("Strikes the bell softly.")]
        public void StrikeSoftly()
        {
            StrikeBell("softly");

            //For tests declared as a function, the result is a pass unless they throw an exception.
        }

        [TestCase, Description("Paints the bell then strikes it.")]
        public class PaintThenStrike: TestNode
        {
            //This method is optional, and will be executed before the test gets run.
            //If it fails, it means that some prerequisite setup that the test needs could not be performed.
            public override void PreRun()
            {
                //PaintBell();
            }

            //This is the main body of the test
            public override void Run()
            {
                StrikeBell("carefully");

                //Most tests will simply returned PASSED here, as the preferred method of failing is to throw an exception.
                return TEST_RESULTS.PASSED;
            }

            //This method is optional, and will be executer after the test gets run, even if it failed.
            public override void PostRun()
            {
                //WipePaintOffBell();
            }
        };

        [TestCase, Description("Strike the bell with a rock, and fail.")]
        public void StrikeWithRock()
        {
            StrikeBell("with a rock");
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\StfTests\Examples\HouseFDTests\KnockApi.cs ===
using System;
using ServerTestFramework;
using ServerTestFramework.Utilities;
using ServerTestFramework.LiveService;
using xonline.common.protocol; //The request and response protocol from the dev code exists in this namespace.

namespace HouseFDTests
{
    /// <summary> Demonstrate how to make a front door call. </summary>
    /// <Goals>
    ///       Make a request to a pretend front door.
    /// </Goals>
    /// <NonGoals>
    ///       Have the request work (since this front door doesn't exist).
    /// </NonGoals>
    [TestGroup]
    public class KnockTests: TestNode
    {
        //Most people write a class to wrap part of the work to call the XRL.  This is one such class.
        //The method shown here references the dev code directly.  Some people prefer to copy the XRL and decorate it with test-only attributes to auto-set SGInfo.
        //This class would normally be placed inside STFLive so other people can use it as well.
        public class XRLKnockOnDoor: XRLPayload<KnockOnDoorRequest, KnockOnDoorResponse>
        {
            //This method is not implemented in the base class, since the base class does not know where to send the request.
            public override bool Execute()
            {
                System.Net.IPEndPoint ep=Global.XEnv.GetVirtualInterface(xonlineexample.common.config.Interface.housefd);
                return Execute(ep);
            }
        }

        [TestCase, Description("Calls the HouseFD's Knock API.")]
        public void KnockOnDoor()
        {
            //Setup the request, send it, and receive the response
            XRLKnockOnDoor xrl=new XRLKnockOnDoor();
            xrl.Request.HandToUse=1;

            if (!xrl.Execute())
            {
                throw new UnexpectedTestResultException("XRLKnockOnDoor call failed: "+xrl.ErrorStatusMessage);
            }

            //Verify that the details of the response are what we expect
            ValueCheck.Test("Response to knock", 1, xrl.Response.Answer);
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\StfTests\Examples\StatefulStress\Stress.cs ===
using System;
using ServerTestFramework;
using ServerTestFramework.LiveService;
using ServerTestFramework.Utilities;

namespace StatefulStressTest
{
    /// <summary>
    /// Takes an offline user and logs them in
    /// </summary>
    [StressTest]
    public class Logon : TestNode
    {
        public override void Run()
        {
            StressUser user = null;
            try
            {
                user = StressUserList.GetOfflineUser(true);

                if (user != null)
                {
                    user.Logon();

                    StressUserList.AddOnline(user);
                }
                else
                {
                    Global.RO.Warn("Logon: No offline user returned.");
                }
            }
            catch (Exception e)
            {
                Global.RO.Error("Logon exception caught:\n" + e.Message);
                StressUserList.AddOffline(user);
            }
            finally
            {
                if (user != null)
                {
                    user.Release();
                }
            }
        }
    }
	
    /// <summary>
    /// Takes an online user and sets them offline
    /// </summary>
    [StressTest]
    public class Logoff : TestNode
    {
        public override void Run()
        {
            StressUser user = null;
            try
            {
                user = StressUserList.GetOnlineUser(true);

                if (user != null)
                {
                    user.Logoff();

                    StressUserList.AddOffline(user);
                }
                else
                {
                    Global.RO.Warn("Logoff: No online user returned.");
                }
            }
            catch (Exception e)
            {
                Global.RO.Error("Logoff exception caught:\n" + e.Message);
                StressUserList.AddOnline(user);
            }
            finally
            {
                if (user != null)
                {
                    user.Release();
                }
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\StfTests\Examples\StatefulStress\StressUser.cs ===
using System;
using System.Threading;
using ServerTestFramework;
using ServerTestFramework.Database;

namespace StatefulStressTest
{
    public class StressUser
    {
        private int fLocked = 0;

        /// <summary>
        /// Constructor
        /// </summary>
        /// <param name="puidName"></param>
        public StressUser( PuidName puidName )
        {
        }

        /// <summary>
        /// Attempts to aquire the lock
        /// </summary>
        public bool Aquire()
        {
            return Interlocked.Exchange(ref fLocked, 1) == 0;
        }

        /// <summary>
        /// Releases the lock
        /// </summary>
        public void Release()
        {
            Interlocked.Exchange(ref fLocked, 0);
        }

        /// <summary>
        /// Sends the logon message to the server
        /// </summary>
        public void Logon()
        {
            // Send logon message here
        }

        /// <summary>
        /// Sends the logoff message to the server
        /// </summary>
        public void Logoff()
        {
            // Send logoff message here
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\StfTests\Examples\StatefulStress\StatefulStressTest.cs ===
using System;
using ServerTestFramework;

[assembly: RootNode(typeof(StatefulStressTest.StatefulStressSuite))]

namespace StatefulStressTest
{
    /// <summary>
    ///   <TestSuite>StatefulStress</TestSuite>
    /// </summary>
    /// <remarks>
    ///   <Description>
    ///     This test suite is a sort of template you can use if your stress requires multiple states.
    ///     It is a very basic example showing how you might handle state where you need a user to go
    ///     from offline to online and vice versa. Obviously you would only log on a user who is offline
    ///     and log off a user who is online so tracking their state is paramount. (This could also be
    ///     used by a suite without any state, but may be a bit unecessary.)
    /// 
    ///     This is done with the StressUerList class. It holds a Queue for each list we need and deals
    ///     with requesting and returning users to the queues in a thread safe way.
    /// 
    ///     Each user is represented by the StressUser class and exists in 1 queue at a time.
    ///     (Note: This framework has been successfully used where the user is in more than 1 queue.
    ///            For example, assume there are 3 queues: Online, Offline, and Everyone, where each user
    ///            is in the Online OR Offline queues, but every user is also in the Everyone queue.
    ///            This is useful when some calls are not affected by if the user is online or off;
    ///            for example a "QueryState" API.)
    /// 
    ///     The basic test layout here is:
    ///         - Request StressUser from desired StressUserList queue
    ///         - Make server call, which may change the user's state
    ///         - Return the StressUser to the appropriate StressUserList queue
    /// 
    ///     To see other (more complex) implementations of this strategy, see the following test suites:
    ///         private\server\xconnsrv\test\stf
    ///         private\server\presence\test\stress
    ///         private\server\messaging\test\stf
    ///   </Description>
    /// </remarks>
    [TestGroup, Owner("codyluit"), ServerTestFramework.Description("StatefulStress Test Suite")]
    public class StatefulStressSuite : TestNode
    {
        private static Report ro = new Report("UnhandledException");

        // Initialize
        public override void PreRun(RUN_TYPE runType)
        {
            // Make sure you brush up on the best practices of STF: http://xblwiki/default.aspx/XboxLive/STFBestPractices.html

            // See a list of test case attributes you can use here: http://xblwiki/default.aspx/XboxLive/STFAttributeList.html

            // This page explains how to set the test case priorities: http://xblwiki/default.aspx/XboxLive/TestCasePriorityDefinitions.html 

            // Set the endpoint for FakeSG to your service, if needed
            //GlobalFakeSG.FakeSG.SetStateEndpoint(Global.XEnv.GetVirtualInterface(VirtualInterface.xpnfd_presence_int).ToString());

            if (runType == RUN_TYPE.STRESS)
            {
                // Load bulk users and create initial queues
                StressUserList.Initialize();
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\StfTests\Examples\HouseFDTests\protocol.cs ===
using xonline.common.service;

//These classes would normally live in xonline\private\common\core\protocol.
//Since this is not a real front door or XRL, we're declaring our own here for use by our example.
namespace xonline.common.protocol
{
    public class KnockOnDoorRequest: XRLObject2
    {
        public uint HandToUse;

        public override string Xrl
        {
            get { return "/xhouse/KnockOnDoor.ashx"; }
        }
    }

    public class KnockOnDoorResponse : XRLObject2
    {
        public uint Answer;
    }
}

//This normally exists inside xonline\private\common\config, but is here for example purposes.
//The Interface class already exists, so we're putting it in a different namespace for this example.
namespace xonlineexample.common.config
{
    public static class Interface
    {
        public const string housefd="housefd";
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\StfTests\Examples\StatefulStress\StressUserList.cs ===
using System;
using System.Collections;
using ServerTestFramework;
using ServerTestFramework.Database;

namespace StatefulStressTest
{
    public class StressUserList
    {
        public static ulong basePuid = 0;
        public static int puidCount;

        // only used for reference not for making requests
        public static StressUser[] UserArray = null;

        private enum QueueTypes
        {
            OFFLINE,
            ONLINE
        }

        // used for making requests
        private static Queue OfflineUsers = Queue.Synchronized(new Queue());        // Users who are offline (pre alive, post deaduser/deadxbox)
        private static Queue OnlineUsers = Queue.Synchronized(new Queue());         // Users who are online (post alive)

        /// <summary>
        /// Constructor
        /// </summary>
        public StressUserList()
        {
        }

        /// <summary>
        /// Static initialization to load bulk users and create initial stress users
        /// </summary>
        public static void Initialize()
        {
            BulkUserSet userSet = Global.GetUserSet("xenon");
            puidCount = (int)userSet.Count;
            basePuid = userSet.Base;
            CPUIDList puidList = userSet.GetPuidList();
            UserArray = new StressUser[puidList.GetSize()];

            for (int i = 0; i < puidList.GetSize(); ++i)
            {
                StressUser user = new StressUser(puidList[i]);
                UserArray[i] = user;
                OfflineUsers.Enqueue(user);
            }
        }

        #region Add to Queues
        /// <summary>
        /// Adds a user to the offline queue
        /// </summary>
        public static void AddOffline(StressUser user)
        {
            lock (OfflineUsers.SyncRoot)
            {
                OfflineUsers.Enqueue(user);
            }
        }

        /// <summary>
        /// Adds a user to the online queue
        /// </summary>
        public static void AddOnline(StressUser user)
        {
            lock (OnlineUsers.SyncRoot)
            {
                OnlineUsers.Enqueue(user);
            }
        }
        #endregion

        #region Get from Queues
        /// <summary>
        /// Gets a single user from the offline queue. If there are none, null is returned.
        /// </summary>
        public static StressUser GetOfflineUser(bool Lock)
        {
            return GetUser(QueueTypes.OFFLINE, Lock);
        }

        /// <summary>
        /// Gets the requested number of users from the offline queue. If there are not enough, null is returned.
        /// </summary>
        public static StressUser[] GetOfflineUser(ushort NumUsers, bool Lock)
        {
            return GetUser(QueueTypes.OFFLINE, NumUsers, Lock);
        }

        /// <summary>
        /// Gets a single user from the online queue. If there are none, null is returned.
        /// </summary>
        public static StressUser GetOnlineUser(bool Lock)
        {
            return GetUser(QueueTypes.ONLINE, Lock);
        }

        /// <summary>
        /// Gets the requested number of users from the online queue. If there are not enough, null is returned.
        /// </summary>
        public static StressUser[] GetOnlineUser(ushort NumUsers, bool Lock)
        {
            return GetUser(QueueTypes.ONLINE, NumUsers, Lock);
        }

        /// <summary>
        /// Gets a single user from the desired queue. If there are none, null is returned.
        /// </summary>
        private static StressUser GetUser(QueueTypes type, bool Lock)
        {
            Queue q = null;
            switch(type)
            {
                case QueueTypes.OFFLINE:
                    q = OfflineUsers;
                    break;
                case QueueTypes.ONLINE:
                    q = OnlineUsers;
                    break;
            }

            StressUser user = null;
            lock (q.SyncRoot)
            {
                int iUser = 0;
                int iUserCount = q.Count;
                while (iUser < iUserCount)
                {
                    user = (StressUser)q.Dequeue();
                    iUser++;
                    if (!Lock || user.Aquire())
                    {
                        break;
                    }
                    else
                    {
                        q.Enqueue(user);
                        user = null;
                    }
                }
            }
            return user;
        }

        /// <summary>
        /// Gets the requested number of users from the desired queue. If there are not enough, null is returned.
        /// </summary>
        private static StressUser[] GetUser(QueueTypes type, ushort NumUsers, bool Lock)
        {
            Queue q = null;
            switch (type)
            {
                case QueueTypes.OFFLINE:
                    q = OfflineUsers;
                    break;
                case QueueTypes.ONLINE:
                    q = OnlineUsers;
                    break;
            }

            StressUser[] users = new StressUser[NumUsers];
            int iUser = 0;
            int iFoundUser = 0;
            int startingCount = q.Count;

            if (NumUsers > startingCount)
                return null;

            while (q.Count > 0 && iFoundUser < NumUsers && iUser < startingCount)
            {
                StressUser user = GetUser(type, Lock);
                iUser++;
                if (user != null)
                {
                    users[iFoundUser] = user;
                    iFoundUser++;
                }
            }
            if (iFoundUser < NumUsers)
            {
                lock (q.SyncRoot)
                {
                    for (int i = 0; i < iFoundUser; i++)
                    {
                        StressUser user = users[i];
                        q.Enqueue(user);
                        if (Lock)
                            user.Release();
                    }
                    users = null;
                }
            }
            return users;
        }
        #endregion

        #region Queue Counts
        /// <summary>
        /// Returns the count of offline users
        /// </summary>
        public static int OfflineUserQueueCount
        {
            get
            {
                lock (OfflineUsers.SyncRoot)
                {
                    return OfflineUsers.Count;
                }
            }
        }

        /// <summary>
        /// Returns the count of online users
        /// </summary>
        public static int OnlineUserQueueCount
        {
            get
            {
                lock (OnlineUsers.SyncRoot)
                {
                    return OnlineUsers.Count;
                }
            }
        }
        #endregion
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\StfTests\FakeSGService\FakeSGSocket.cs ===
using System;
using System.Collections;
using System.IO;
using System.Net;
using System.Net.Sockets;

namespace ServerTestFramework.LiveService.FakeSG
{
    public class FakeSGSocket
    {
        // _socketTable is the table of socket - address pairs used by FakeSG
        private static Hashtable  _socketTable = new Hashtable();

        /// <summary>
        /// Finds all ip addresses for FakeSG
        /// </summary>
		/// <returns>List of IPAddress</returns>
        public static ArrayList FindIPAddresses() 
        {
			ArrayList ipAddressArray = new ArrayList();

            // sw is the StreamWriter object to write text to a file
            StreamWriter  sw = new StreamWriter("fakesg_findconnections.log");

            // Get the host entry for the local host
            IPHostEntry ipHostEntry = Dns.GetHostEntry(Dns.GetHostName());
            foreach(IPAddress ipAddress in ipHostEntry.AddressList) 
            {
                sw.WriteLine("IP Address: {0} ({1})", ipAddress.ToString(), ipAddress.AddressFamily);

                if (AddressFamily.InterNetwork == ipAddress.AddressFamily) 
                {
                    sw.WriteLine("  Valid");
                    ipAddressArray.Add(ipAddress);
                }
                else 
                {
                    sw.WriteLine("  Invalid");
                }

                sw.WriteLine();
            }

			if (0 == ipAddressArray.Count)
			{
				throw new ApplicationException("Cannot find any valid IP addresses.");
			}

            // Explicitly add the Loopback address for xblob configs
			sw.WriteLine( "Loopback Address" );
			ipAddressArray.Add( IPAddress.Loopback );
                    
            sw.Close();

			return ipAddressArray;
        }

        /// <summary>
        /// Initialize initializes the underyling resources needed by FakeSG
        /// </summary>
        public static void Initialize( ArrayList ipAddressArray, ushort port ) 
        {
            foreach(IPAddress ipAddress in ipAddressArray) 
            {
                // Create the socket
                Socket  socket = new Socket( AddressFamily.InterNetwork, SocketType.Dgram, ProtocolType.Udp );

                // http://support.microsoft.com/default.aspx?scid=kb;en-us;263823
                byte[]  optValue = { 0 };
                int	    ioCtl    = 0;
                unchecked
                {
                    ioCtl = (int) (0x80000000 | 0x18000000 | 12);
                }
                socket.IOControl( ioCtl , optValue, null );

                // Bind the socket
                IPEndPoint  ipEndPoint = new IPEndPoint( ipAddress, port );
                socket.Bind( ipEndPoint );

                // Add the socket to the socket table
                _socketTable.Add(ipAddress, socket);
            }
        }

        /// <summary>
        /// Terminate releases the underyling resources needed by FakeSG
        /// </summary>
        public static void Terminate() 
        {
            foreach( Socket socket in _socketTable.Values ) 
            {
                // Close the socket
                socket.Close();
            }

            // Clear the socket table
            _socketTable.Clear();

            // Clear the ip address array
//            _ipAddressArray.Clear();
        }

        /// <summary>
        /// GetSocket returns the socket bound to a paticular ip address
        /// </summary>
        public static Socket GetSocket( 
            IPAddress  ipAddress ) 
        {
            return (Socket)_socketTable[ipAddress];
        }

        /// <summary>
        /// GetSocketArray builds and returns the array of sockets used by FakeSG
        /// </summary>
        public static ArrayList GetSocketArray() 
        {
            // Build the array of sockets
            ArrayList  socketArray = new ArrayList();

            foreach(Socket socket in _socketTable.Values) 
            {
                socketArray.Add(socket);
            }

            return socketArray;
        }

        /// <summary>
        /// Send just redirects to Socket.BeginSendTo
        /// </summary>
        public static void Send(
            Socket    socket,
            byte[]    buffer,
            int       size,
            EndPoint  remoteEP ) 
        {
            socket.BeginSendTo( buffer, 0, size, SocketFlags.None, remoteEP, null, null );
        }

        /// <summary>
        /// CheckReceive checks all sockets for readability
        /// </summary>
        public static ArrayList CheckReceive(
            int  microSeconds ) 
        {
            // Check sockets for readability
            ArrayList  checkRead = GetSocketArray();
            Socket.Select(checkRead, null, null, microSeconds);

            return checkRead;
        }

        /// <summary>
        /// Receive just redirects to Socket.ReceiveFrom
        /// </summary>
        public static int Receive(
            Socket        socket,
            byte[]        buffer,
            ref EndPoint  remoteEP ) 
        {
            return socket.ReceiveFrom(buffer, ref remoteEP);
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\StfTests\FakeSGService\obj\i386\_generated.cs ===
[assembly:System.Runtime.InteropServices.ComVisible(false)]
[assembly:System.Reflection.AssemblyVersion("12.4.56.0")]
[assembly:System.Reflection.AssemblyProduct("Microsoft(R) Xbox(TM)")]
[assembly:System.Reflection.AssemblyCopyright("Copyright (c) Microsoft Corporation. All rights reserved.")]
[assembly:System.Reflection.AssemblyCompany("Microsoft Corporation")]
[assembly:System.Reflection.AssemblyFileVersion("12.4.56.0")]
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\StfTests\FakeSGService\obj\i386\_asmid.inc ===
ASSEMBLY_IDENTITY_KEY_FORM=msil_fakesgservice_none_12.4.56.0_none_98ae276dd48c85d5
ASSEMBLY_IDENTITY_XP_KEY_FORM=msil_fakesgservice_no-public-key_12.4.56.0_x-ww_a1bfdbef
ASSEMBLY_IDENTITY_CULTURE=
ASSEMBLY_IDENTITY_NAME=fakesgservice
ASSEMBLY_IDENTITY_PROCESSOR_ARCHITECTURE=msil
ASSEMBLY_IDENTITY_PUBLIC_KEY=
ASSEMBLY_IDENTITY_PUBLIC_KEY_TOKEN=
ASSEMBLY_IDENTITY_TYPE=
ASSEMBLY_IDENTITY_TYPE_NAME=
ASSEMBLY_IDENTITY_VERSION=12.4.56.0
XP_KEY_FORM=msil_fakesgservice_no-public-key_12.4.56.0_x-ww_a1bfdbef
XP_MANIFEST_DIRECTORY=manifests
XP_MANIFEST_NAME=msil_fakesgservice_no-public-key_12.4.56.0_x-ww_a1bfdbef.manifest
XP_MANIFEST_PATH=manifests\msil_fakesgservice_no-public-key_12.4.56.0_x-ww_a1bfdbef.manifest
XP_CATALOG_DIRECTORY=manifests
XP_CATALOG_NAME=msil_fakesgservice_no-public-key_12.4.56.0_x-ww_a1bfdbef.cat
XP_CATALOG_PATH=manifests\msil_fakesgservice_no-public-key_12.4.56.0_x-ww_a1bfdbef.cat
XP_PAYLOAD_PATH=msil_fakesgservice_no-public-key_12.4.56.0_x-ww_a1bfdbef
_DELAY_SIGN=0
!if [set _ASMIDTOATTRIBS_TLBIMP=]
!endif
CODESIGN_TESTKEY=
_TLBIMP_FLAGS=$(_TLBIMP_FLAGS)  /asmversion:12.4.56.0
_ASSEMBLY_IDENTITY=fakesgservice,processorArchitecture=msil,version=12.4.56.0,publicKeyToken=neutral
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\StfTests\FakeSGService\ServiceMain.cs ===
using System;
using System.Collections;
using System.ComponentModel;
using System.Data;
using System.Diagnostics;
using System.ServiceProcess;
using ServerTestFramework;
using ServerTestFramework.LiveService.FakeSG;

namespace FakeSGWinService
{
	public class ServiceMain : System.ServiceProcess.ServiceBase
	{
		public ServiceMain()
		{
		}

		// The main entry point for the process
		static void Main()
		{
			System.ServiceProcess.ServiceBase[] ServicesToRun;
			ServicesToRun = new System.ServiceProcess.ServiceBase[] { new ServiceMain() };

			System.ServiceProcess.ServiceBase.Run( ServicesToRun );
		}

		/// <summary>
		/// Set things in motion so your service can do its work.
		/// </summary>
		protected override void OnStart( string[] args )
		{
			try
			{
				FakeSGService.Create();
			}
			catch( Exception e )
			{
				EventLog log = new EventLog();
				log.Source = "FakeSG";
				log.WriteEntry( "Uncaught Exception when service starting:\n\n" + e.ToString(), EventLogEntryType.Error );
			}
		}
 
		/// <summary>
		/// Stop this service.
		/// </summary>
		protected override void OnStop()
		{
			try
			{
				FakeSGService.Destroy();
			}
			catch( Exception e )
			{
				EventLog log = new EventLog();
				log.Source = "FakeSG";
				log.WriteEntry( "Uncaught Exception when service stopping:\n\n" + e.ToString(), EventLogEntryType.Error );
			}
		}
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\StfTests\FakeSGService\ProjectInstaller.cs ===
using System;
using System.Collections;
using System.ServiceProcess;
using System.ComponentModel;
using System.Configuration.Install;
using ServerTestFramework;
using ServerTestFramework.Utilities;

namespace FakeSGService
{
	/// <summary>
	/// Summary description for ProjectInstaller.
	/// </summary>
	[RunInstaller(true)]
	public class ProjectInstaller : System.Configuration.Install.Installer
	{
		private System.ServiceProcess.ServiceProcessInstaller serviceProcessInstaller1;
		private System.ServiceProcess.ServiceInstaller serviceInstaller1;
		/// <summary>
		/// Required designer variable.
		/// </summary>
		private System.ComponentModel.Container components = null;

		public ProjectInstaller()
		{
			// This call is required by the Designer.
			InitializeComponent();

			// TODO: Add any initialization after the InitializeComponent call
		}

		/// <summary> 
		/// Clean up any resources being used.
		/// </summary>
		protected override void Dispose( bool disposing )
		{
			if( disposing )
			{
				if(components != null)
				{
					components.Dispose();
				}
			}
			base.Dispose( disposing );
		}


		#region Component Designer generated code
		/// <summary>
		/// Required method for Designer support - do not modify
		/// the contents of this method with the code editor.
		/// </summary>
		private void InitializeComponent()
		{
            this.serviceProcessInstaller1 = new System.ServiceProcess.ServiceProcessInstaller();
            this.serviceInstaller1 = new System.ServiceProcess.ServiceInstaller();
            // 
            // serviceProcessInstaller1
            // 
            this.serviceProcessInstaller1.Account = System.ServiceProcess.ServiceAccount.LocalSystem;
            this.serviceProcessInstaller1.Password = null;
            this.serviceProcessInstaller1.Username = null;
            this.serviceProcessInstaller1.AfterUninstall += new System.Configuration.Install.InstallEventHandler(this.serviceProcessInstaller1_AfterUninstall);
            this.serviceProcessInstaller1.AfterInstall += new System.Configuration.Install.InstallEventHandler(this.serviceProcessInstaller1_AfterInstall);
            // 
            // serviceInstaller1
            // 
            this.serviceInstaller1.ServiceName = "FakeSGService";
            // 
            // ProjectInstaller
            // 
            this.Installers.AddRange(new System.Configuration.Install.Installer[] {
                                                                                      this.serviceProcessInstaller1,
                                                                                      this.serviceInstaller1});

        }
		#endregion

		private string GetName()
		{
			return "Service (FakeSG version "+ServerTestFramework.LiveService.FakeSG.FakeSGBase.GetCompiledVersion()+")";
		}

		private void serviceProcessInstaller1_AfterInstall(object sender, System.Configuration.Install.InstallEventArgs e)
		{
			ConsoleX.WriteLine(CC.GREEN, GetName()+" installed");
		}

		private void serviceProcessInstaller1_AfterUninstall(object sender, System.Configuration.Install.InstallEventArgs e)
		{
			ConsoleX.WriteLine(CC.GREEN, GetName()+" uninstalled");
		}
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\StfTests\FakeSGService\objd\i386\_generated.cs ===
[assembly:System.Runtime.InteropServices.ComVisible(false)]
[assembly:System.Reflection.AssemblyVersion("12.4.56.0")]
[assembly:System.Reflection.AssemblyProduct("Microsoft(R) Xbox(TM)")]
[assembly:System.Reflection.AssemblyCopyright("Copyright (c) Microsoft Corporation. All rights reserved.")]
[assembly:System.Reflection.AssemblyCompany("Microsoft Corporation")]
[assembly:System.Reflection.AssemblyFileVersion("12.4.56.0")]
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\StfTests\FakeSGService\FakeSGService.cs ===
using System;
using System.Text;
using System.Net;
using System.IO;
using System.Net.Sockets;
using System.Threading;
using System.Diagnostics;
using System.Runtime.InteropServices;
using System.Collections;
using System.Runtime.Remoting;
using System.Runtime.Remoting.Channels;
using System.Runtime.Remoting.Channels.Tcp;
using System.Runtime.Remoting.Services;

using ServerTestFramework;
using ServerTestFramework.Utilities;
using ServerTestFramework.LiveService;
using ServerTestFramework.LiveService.Auth;
using ServerTestFramework.LiveService.FakeSG;
using ServerTestFramework.LiveService.PresNotiCommon;

namespace FakeSGWinService
{
    unsafe public class FakeSGService : FakeSGBase, IFakeSGRemoteControl
    {
        // IPs and Port to listen on
        private ArrayList IpList = null;   
        private ushort    Port   = 0xffff; 

        // local interface IP to mmf port tabke mapping
        private Hashtable mmfPortTableOffset = null;

        // Table of Connected Xboxes for QVal processing
        private Hashtable SGXboxInfoSlots = Hashtable.Synchronized(new Hashtable()); 

        // Control Variables    
        private Thread SGThread  = null;  // Message handler thread
        private bool   terminate = false; // Signal for handler thread to terminate

        // Batched state updates
        private ArrayList  StateUpdateQueue = new ArrayList();
        private IPEndPoint StateEndpoint = null;
        private bool       EnableStateBatching = false;
        private Timer      StateUpdateTimer;

        class StateUpdateItem
        {
            public ulong   XboxId;
            public ulong   UserId;
            public uint    State;
            public ulong   MatchSessionId;
            public byte[]  TitleData;
            public ushort  TitleDataCount;


            public StateUpdateItem(
                    ulong   xboxId, 
                    ulong   userId, 
                    uint    state, 
                    ulong   matchSessionId, 
                    byte[]  titleData, 
                    ushort  titleDataCount)
            {
                TitleData      = new byte[XonPresNoti.MAX_TITLE_DATA_BYTES];
                XboxId         = xboxId;
                UserId         = userId;
                State          = state;
                MatchSessionId = matchSessionId;
                
                uint length = (uint)titleData.Length;
                if(length > XonPresNoti.MAX_TITLE_DATA_BYTES)
                {
                    Debug.WriteLine("StateUpdateItem: title data truncated to " + XonPresNoti.MAX_TITLE_DATA_BYTES);
                
                    length = XonPresNoti.MAX_TITLE_DATA_BYTES;
                }

                // For testing purposes we allow the actual data passed in to exceed count. The packet
                // sent to presence uses a fixed length buffer of MAX_TITLE_DATA_BYTES + PacketMetaData
                Array.Copy(titleData, TitleData, length);
                TitleDataCount = titleDataCount;
            }
        }

        class AsyncHttpRequest
        {
            public String       Resource; 
            public IPEndPoint   Endpoint;
            public MemoryStream Request; // Hdr + Payload
            public MemoryStream Payload;
            public Socket       Socket;
            public int          TotalSent;
            public int          TotalRecv;
            public byte         []RecvBuffer;
            public MemoryStream Response;

            public AsyncHttpRequest()
            {
            }

            public void OnConnect(IAsyncResult result)
            {
                if(!Socket.Connected)
                {
                    Debug.WriteLine("AsyncHttpRequest: Could not connect to: " + Endpoint.ToString());
                    return;
                }

                StringBuilder hdr = new StringBuilder(128);
                hdr.Append("POST ");
                hdr.Append(Resource);
                hdr.Append(" HTTP/1.0\r\n");

                hdr.Append("Host: ");
                hdr.Append(Endpoint.ToString());
                hdr.Append("\r\n");

                hdr.Append("Content-Length: ");
                hdr.Append(Payload.Length.ToString());
                hdr.Append("\r\n");

                hdr.Append("Connection: close\r\n");
                hdr.Append("Content-Type: xon/1\r\n");
                hdr.Append("User-Agent: 1/0.10.4715\r\n");
                hdr.Append("\r\n");

                byte[] hdrBytes = new ASCIIEncoding().GetBytes(hdr.ToString());

                Request = new MemoryStream();
                Request.Write(hdrBytes, 0, hdrBytes.Length);
                Payload.WriteTo(Request);

                TotalSent = 0;
                Socket.BeginSend(Request.ToArray(), 0, (int)Request.Length, SocketFlags.None, new AsyncCallback(OnSend), this);
            }

            public void OnSend(IAsyncResult result)
            {
                int nbytes = Socket.EndSend(result);
                if(nbytes < 0)
                {
                    Debug.WriteLine("Send Failed to: " + Endpoint.ToString() + ", Total sent: " + TotalSent);
                    return;
                } 

                TotalSent += nbytes;

                if(TotalSent < Request.Length)
                {
                    // Continue sending
                    Socket.BeginSend(Request.ToArray(), (int)TotalSent, (int)(Request.Length - TotalSent), SocketFlags.None,  new AsyncCallback(OnSend), this);
                }
                else
                {
                    // All data sent, recv response
                    Response = new MemoryStream();
                    RecvBuffer = new byte[512];
                    TotalRecv = 0;
                    try
                    {
                        Socket.BeginReceive(RecvBuffer, 0, (int)RecvBuffer.Length, SocketFlags.None, new AsyncCallback(OnRecv), this);
                    }
                    catch (System.Net.Sockets.SocketException ex)
                    {
                        Debug.WriteLine("BeginReceive failed: " + ex.Message);
                    }
                }
            } 

            public void OnRecv(IAsyncResult result)
            {
                int nbytes = 0;
                try
                {
                    nbytes = Socket.EndReceive(result);
                }
                catch (System.Net.Sockets.SocketException ex)
                {
                    Debug.WriteLine("EndReceive failed: " + ex.Message);
                }
                if(nbytes == 0)
                {
                    //Log.WriteEntry("Recv remote end closed connection: " + Endpoint.ToString() + "Response:\n" + 
                     //   new ASCIIEncoding().GetString(Response.ToArray()));

                    // Close the socket and dicard any time_wait or close_wait data
                    LingerOption linger = new LingerOption(false, 0);
                    Socket.SetSocketOption(SocketOptionLevel.Socket, SocketOptionName.Linger, linger);
                    Socket.Close();
                }
                else if(nbytes < 0)
                {
                    Debug.WriteLine("Recv failed from " + Endpoint.ToString() + ", Total Bytes: " + TotalRecv);
                }
                else
                {
                    TotalRecv += nbytes;
                    Response.Write(RecvBuffer, 0, nbytes);
                    Socket.BeginReceive(RecvBuffer, 0, (int)RecvBuffer.Length, SocketFlags.None, new AsyncCallback(OnRecv), this);
                }
            }
        }
        //////////////(uint)/////////////////////////////////////
        /// <summary>
        /// Message Handler Status
        /// </summary>
        public FakeSGState State
        {
            get{ return state; }
        }
        public enum FakeSGState
        {
            NotRunning,
            Starting,
            PortListening,
            ShuttingDown,
            ShutDown,
        }
        private FakeSGState state = FakeSGState.NotRunning;

        ///////////////////////////////////////////////////
        /// <summary>
        /// Numver of messages processed
        /// </summary>
        public int  Connections
        {
            get{ return connections; }
        }
        private int connections = 0;

        ///////////////////////////////////////////////////
        /// <summary>
        /// Exception occured in message handler
        /// </summary>
        public bool ExceptionOcurred
        {
            get{ return exceptionOcurred; }
        }
        private bool exceptionOcurred = false;
        
        ///////////////////////////////////////////////////
        /// <summary>
        /// Wrap creation to manage singleton 
        /// </summary>
        public static void Create()
        {
            if( Singleton != null )
            {
                Debug.WriteLine("Attempted Start Aborted. Service should already be started.");
            }
            else
            {
                Singleton = new FakeSGService();
                ((FakeSGService) Singleton).Start();
            }
        }

        ///////////////////////////////////////////////////
        /// <summary>
        /// Wrap destruction to manage singleton 
        /// </summary>
        public static void Destroy()
        {
            if( Singleton == null )
            {
                Debug.WriteLine("Attempted Stop Aborted. Service should already be stopped.");
            }
            else
            {
                ((FakeSGService) Singleton).End();
                Singleton = null;
            }
        }

        ///////////////////////////////////////////////////
        /// <summary>
        /// Constructor
        /// </summary>
        private FakeSGService()
        {
            // Setup for event logging
            Debug.WriteLine("Beginning Service Initialization...");

            // Get local interface list
            IpList = FakeSGSocket.FindIPAddresses();
            StringBuilder sb = new StringBuilder( "Local Interfaces detected.  Service will be monitoring:\n" );
            sb.AppendFormat( "Port:  {0:G} (0x{0:X})\nIP Addresses:\n", Port );
            foreach( IPAddress ip in IpList )
            {
                sb.AppendFormat( "   {0}\n", ip );
            }
            Debug.WriteLine(sb.ToString());
            
            // Create new MMF and store the version the service was built with
            SetUpMMF( (int)IpList.Count );
            header->Version = CurrentVersion;
            sb = new StringBuilder( "MMF Created with version "+header->Version );

            // Set up mapping of local interface IP to offset of port table in mmf
            mmfPortTableOffset = new Hashtable( (int)IpList.Count );
            sb.AppendFormat( "\nMapping of IP to offset of first MMF Slot:\n" );
            for( int i = 0; i < (int)IpList.Count; ++i )
            {
                int offset = i * tableSize;
                mmfPortTableOffset[ IpList[i] ] = offset; 
                sb.AppendFormat( "{0} <-- {1}\n", offset, IpList[i] );
            }
            Debug.WriteLine(sb.ToString());
            
            // Set up remote controller 
            TcpChannel channel = new TcpChannel( 9900 );
            ChannelServices.RegisterChannel( channel, false );
            
            WellKnownServiceTypeEntry wste = new WellKnownServiceTypeEntry(
                typeof( FakeSGRemoteController ),
                "RemoteFakeSGService", 
                WellKnownObjectMode.Singleton );
            
            RemotingConfiguration.RegisterWellKnownServiceType( wste );

            Debug.WriteLine("Remoting Configuration Registered");
        }

        ///////////////////////////////////////////////////
        /// <summary>
        /// Begin message processing
        /// </summary>
        private void Start()
        {
            if( SGThread != null )
            {
                Debug.WriteLine("Aborting. Message Handler Already started");
                return;
            }

            Debug.WriteLine("Starting Message Handler");
            terminate = false;
            state     = FakeSGState.NotRunning;

            // Start the thread
            SGThread = new Thread( new ThreadStart( FastHandler ) );
            SGThread.Priority = ThreadPriority.Highest;
            SGThread.Start();
        }

        ///////////////////////////////////////////////////
        /// <summary>
        /// End message processing 
        /// </summary>
        private void End()
        {
            Debug.WriteLine("Beginning Service Shutdown...");
            
            if( SGThread == null )
            {
                Debug.WriteLine("Aborting. Message Handler Already stopped");
                return;
            }

            Debug.WriteLine("Stopping Message Handler");
            state     = FakeSGState.ShuttingDown;
            terminate = true;
                    
            // Wait for Thread to get the message and quit
            int SleepCount = 10;
            while( --SleepCount >= 0 )
            {
                if( SGThread.IsAlive )
                {
                    Thread.Sleep( 200 );
                }
                else
                {
                    break;
                }
            }
            if( SleepCount == -1 )
            {
                Debug.WriteLine("Message Handler didn't stop when signalled.");
            }

            SGThread.Abort();
            SGThread = null;

            // Clear out QVal proccesing table
            SGXboxInfoSlots.Clear();
                
            state = FakeSGState.ShutDown;
        }

        ///////////////////////////////////////////////////
        /// <summary>
        /// Message handler thread
        /// </summary>
        void FastHandler()
        {
            Debug.WriteLine("FastHandler: Starting");
            try
            {
                state = FakeSGState.Starting;

                FakeSGSocket.Initialize( IpList, Port );

                state = FakeSGState.PortListening;
                IPEndPoint RemoteIpEndPoint = new IPEndPoint( IPAddress.Any, 0 );
                EndPoint remote = RemoteIpEndPoint;

                uint[] qvals = new uint[15];
                byte[] receiveBytes = new byte[ 1000 ];
                while( !terminate )
                {
                    try
                    {
                        ArrayList sockList = FakeSGSocket.CheckReceive( 500000 );

                        if( sockList.Count < 1 )
                            continue;
                        
                        foreach( Socket sock in sockList )
                        {
                            byte[] outArray = new byte[ 1492 ];
        
                            try
                            {
                                FakeSGSocket.Receive( sock, receiveBytes, ref remote );
                            }
                            catch( Exception )
                            {
                                continue;
                            }

                            RemoteIpEndPoint = remote as IPEndPoint;
    
                            Interlocked.Increment( ref connections );
                        
                            IPAddress localIp = ((IPEndPoint)sock.LocalEndPoint).Address;

                            fixed( Byte* b = receiveBytes )
                            {
                                SSgMsgHdr* regHdr = (SSgMsgHdr*) b;

                                if (regHdr->_wType == (ushort)SGMSG.SPIDATA_REQ || regHdr->_wType == (ushort)SGMSG.SPIDATA_REQ2)
                                {
                                    #region Process SpiData Request
                                    // determine authdata version of response
                                    ushort respAuthVer = Authdata_Base.XONLINE_XENON_AUTHDATA_VERSION;

                                    if (regHdr->_wType == (ushort)SGMSG.SPIDATA_REQ2)
                                    {
                                        SgMsgSpiReq2* req2 = (SgMsgSpiReq2*)b;

                                        // cap the requested version to the highest supported
                                        respAuthVer = Math.Min(req2->_wAuthDataVersion, Authdata_Base.XONLINE_XENON2_AUTHDATA_VERSION);
                                    }

                                    // The reply is actually of the form:
                                    // {
                                    //   CSgMsgSpiRep
                                    //   CSgMsgSpiData2
                                    //   CSgMsgHdr+CAuthData[2,3]
                                    // }
                                    SgMsgSpiReq* req = (SgMsgSpiReq*) b;
                                    
                                    ushort RealPort = (ushort) ((req->_ipportZ>>8) | (req->_ipportZ<<8));
                                    CSGInfo SGInfo = FindSlotByPort( RealPort, localIp );

                                    int packetSize = 0;
                                    fixed( byte* outBytes = outArray )
                                    {
                                        SgMsgSpiRep*    SpiRep   = (SgMsgSpiRep*)       outBytes;
                                        SSgMsgSpiData2* SpiData2 = (SSgMsgSpiData2*)    (outBytes+sizeof(SgMsgSpiRep));
                                        byte*           authPtr  = (byte*)              (outBytes+sizeof(SgMsgSpiRep)+sizeof(SSgMsgSpiData2));
                                                                                
                                        // Fill Spi Rep data
                                        //
                                        SpiRep->Header._wType = (ushort)SGMSG.SPIDATA_REP;
                                        SpiRep->Header._cbEnt = (ushort) sizeof(SgMsgSpiRep);                   // must be real size
                                        SpiRep->_dwReqNum     = req->_dwReqNum;
                                        SpiRep->_ipaZ         = req->_ipaZ;
                                        SpiRep->_ipportZ      = req->_ipportZ;
                                        SpiRep->_fNotFound    = (byte)(SGInfo.UserExists == 0 ? 1 : 0);

                                        // If user doesn't exist, we only send the SgMsgSpiRep back.  I think.
                                        packetSize = sizeof(SgMsgSpiRep);

                                        if (SGInfo.UserExists > 0)
                                        {
                                            // Fill SpiData2 data
                                            //
                                            // The commented out SpiData lines below are AuthData elements that so far are not 
                                            // nescessary.  If they become nescessary we will fill them in.
                                            SpiData2->Header._wType=(ushort)SGMSG.SPIDATA;
                                            SpiData2->Header._cbEnt=(ushort) sizeof(SSgMsgSpiData2);
                                            SpiData2->_fCs             = (byte)1;

                                            if(0 == SGInfo.ipaI)
                                            {
                                                byte[] thisIp = ((IPEndPoint)sock.LocalEndPoint).Address.GetAddressBytes();
                                                uint listenIP = 
                                                    ((uint) thisIp[3]<<24) |
                                                    ((uint) thisIp[2]<<16) |
                                                    ((uint) thisIp[1]<< 8) |
                                                    ((uint) thisIp[0]<< 0);
                                                SpiData2->_ipaI             = listenIP;
                                                SpiData2->_ipportI          = Port;
                                            }
                                            else
                                            {
                                                SpiData2->_ipaI             = SGInfo.ipaI;
                                                SpiData2->_ipportI          = SGInfo.ipportI;
                                            }

                                            SpiData2->_liNonce          = SGInfo.liNonce;
                                            DateTime today              = DateTime.UtcNow;
                                            SpiData2->_liTimeInit       = today.ToFileTime();
                                            //SpiData2->_wFlagsKeyEx    =
                                            //SpiData2->_wVersionKeyEx  =
                                            SpiData2->sgaddr.abReserved = 0;
                                            SpiData2->sgaddr.dwSpiSg    = SGInfo.SpiSg;
                                            SpiData2->sgaddr.inaSg      = SGInfo.inaSg;
                                            SpiData2->sgaddr.qwXboxID   = SGInfo.machinePuid;

                                            // Fill AuthData with requested version

                                            switch (respAuthVer)
                                            {
                                                case Authdata_Base.XONLINE_XENON_AUTHDATA_VERSION:
                                                    #region XONLINE_XENON_AUTHDATA_VERSION

                                                    SAuthData3* AuthData3 = (SAuthData3*)authPtr;

                                                    AuthData3->Header._wType = (ushort)SGMSG.AUTHDATA;
                                                    AuthData3->Header._cbEnt = (ushort)sizeof(SAuthData3);

                                                    // Fill AuthData3 data
                                                    //
                                                    AuthData3->wAuthDataVersion = Authdata_Base.XONLINE_XENON_AUTHDATA_VERSION;
                                                    AuthData3->wAuthDataSize = (ushort)(sizeof(SAuthData3) - sizeof(SSgMsgHdr));
                                                    AuthData3->clientVersion.wMajorVersion = SGInfo.wMajorVersion;
                                                    AuthData3->clientVersion.wMinorVersion = SGInfo.wMinorVersion;
                                                    AuthData3->clientVersion.wBuildNumber = SGInfo.wBuildNumber;
                                                    AuthData3->clientVersion.wQFENumber = SGInfo.wQFENumber;
                                                    AuthData3->dwTitleID = SGInfo.titleId;
                                                    AuthData3->dwTitleVersion = SGInfo.titleVersion;
                                                    AuthData3->dwTitleRegion = SGInfo.titleRegion;
                                                    AuthData3->dwConsoleRegion = SGInfo.consoleRegion;
                                                    AuthData3->dwMediaID = SGInfo.mediaID;
                                                    AuthData3->wLanguageID = SGInfo.languageID;
                                                    AuthData3->dwAuthDataFlags = SGInfo.authDataFlags;

                                                    AuthData3->wNumPrivileges = SGInfo.wNumPrivileges;
                                                    AuthData3->dwPrivileges0 = SGInfo.dwPrivileges0;
                                                    AuthData3->dwPrivileges1 = SGInfo.dwPrivileges1;
                                                    AuthData3->dwPrivileges2 = SGInfo.dwPrivileges2;
                                                    AuthData3->dwPrivileges3 = SGInfo.dwPrivileges3;
                                                    AuthData3->dwPrivileges4 = SGInfo.dwPrivileges4;
                                                    AuthData3->dwPrivileges5 = SGInfo.dwPrivileges5;
                                                    AuthData3->dwPrivileges6 = SGInfo.dwPrivileges6;
                                                    AuthData3->dwPrivileges7 = SGInfo.dwPrivileges7;

                                                    AuthData3->qwXboxID = SGInfo.machinePuid;
                                                    AuthData3->user0.flags = SGInfo.userFlag0;
                                                    AuthData3->user1.flags = SGInfo.userFlag1;
                                                    AuthData3->user2.flags = SGInfo.userFlag2;
                                                    AuthData3->user3.flags = SGInfo.userFlag3;
                                                    AuthData3->user0.puid = SGInfo.userPuid0;
                                                    AuthData3->user1.puid = SGInfo.userPuid1;
                                                    AuthData3->user2.puid = SGInfo.userPuid2;
                                                    AuthData3->user3.puid = SGInfo.userPuid3;

                                                    AuthData3->afltTrustFactor0 = SGInfo.userTrust0;
                                                    AuthData3->afltTrustFactor1 = SGInfo.userTrust1;
                                                    AuthData3->afltTrustFactor2 = SGInfo.userTrust2;
                                                    AuthData3->afltTrustFactor3 = SGInfo.userTrust3;

                                                    AuthData3->wNumDwordServices = SGInfo.wNumDwordServices;
                                                    AuthData3->dwServiceID0 = SGInfo.dwServiceID0;
                                                    AuthData3->dwServiceID1 = SGInfo.dwServiceID1;
                                                    AuthData3->dwServiceID2 = SGInfo.dwServiceID2;
                                                    AuthData3->dwServiceID3 = SGInfo.dwServiceID3;

                                                    AuthData3->dwAltTitleID0 = SGInfo.altTitleId0;
                                                    AuthData3->dwAltTitleID1 = SGInfo.altTitleId1;
                                                    AuthData3->dwAltTitleID2 = SGInfo.altTitleId2;
                                                    AuthData3->dwAltTitleID3 = SGInfo.altTitleId3;

                                                    AuthData3->abKey00 = SGInfo.key00;
                                                    AuthData3->abKey01 = SGInfo.key01;
                                                    AuthData3->abKey02 = SGInfo.key02;
                                                    AuthData3->abKey03 = SGInfo.key03;
                                                    AuthData3->abKey04 = SGInfo.key04;
                                                    AuthData3->abKey05 = SGInfo.key05;
                                                    AuthData3->abKey06 = SGInfo.key06;
                                                    AuthData3->abKey07 = SGInfo.key07;
                                                    AuthData3->abKey08 = SGInfo.key08;
                                                    AuthData3->abKey09 = SGInfo.key09;
                                                    AuthData3->abKey10 = SGInfo.key10;
                                                    AuthData3->abKey11 = SGInfo.key11;
                                                    AuthData3->abKey12 = SGInfo.key12;
                                                    AuthData3->abKey13 = SGInfo.key13;
                                                    AuthData3->abKey14 = SGInfo.key14;
                                                    AuthData3->abKey15 = SGInfo.key15;

                                                    packetSize = sizeof(SgMsgSpiRep) + sizeof(SSgMsgSpiData2) + sizeof(SAuthData3);
                                                    break;

                                                    #endregion

                                                case Authdata_Base.XONLINE_XENON2_AUTHDATA_VERSION:
                                                    #region XONLINE_XENON2_AUTHDATA_VERSION

                                                    SAuthData4* AuthData4 = (SAuthData4*)authPtr;

                                                    AuthData4->Header._wType = (ushort)SGMSG.AUTHDATA;
                                                    AuthData4->Header._cbEnt = (ushort)sizeof(SAuthData4);

                                                    // Fill AuthData4 data
                                                    // Currently copying the SgConvertAuthData3ToAuthData4 function from the SG
                                                    AuthData4->wAuthDataVersion = Authdata_Base.XONLINE_XENON2_AUTHDATA_VERSION;
                                                    AuthData4->wAuthDataSize = (ushort)(sizeof(SAuthData4) - sizeof(SSgMsgHdr));

                                                    // Client version
                                                    AuthData4->clientVersion.wMajorVersion = SGInfo.wMajorVersion;
                                                    AuthData4->clientVersion.wMinorVersion = SGInfo.wMinorVersion;
                                                    AuthData4->clientVersion.wBuildNumber = SGInfo.wBuildNumber;
                                                    AuthData4->clientVersion.wQFENumber = SGInfo.wQFENumber;

                                                    // Title
                                                    AuthData4->dwTitleID = SGInfo.titleId;
                                                    AuthData4->dwTitleVersion = SGInfo.titleVersion;
                                                    AuthData4->dwTitleRegion = SGInfo.titleRegion;

                                                    // Misc
                                                    AuthData4->dwConsoleRegion = SGInfo.consoleRegion;
                                                    AuthData4->dwMediaID = SGInfo.mediaID;
                                                    AuthData4->wLanguageID = SGInfo.languageID;
                                                    AuthData4->dwAuthDataFlags = SGInfo.authDataFlags;
                                                    AuthData4->qwXboxID = SGInfo.machinePuid;

                                                    // Users
                                                    AuthData4->user0.flags = SGInfo.userFlag0;
                                                    AuthData4->user1.flags = SGInfo.userFlag1;
                                                    AuthData4->user2.flags = SGInfo.userFlag2;
                                                    AuthData4->user3.flags = SGInfo.userFlag3;
                                                    AuthData4->user0.puid = SGInfo.userPuid0;
                                                    AuthData4->user1.puid = SGInfo.userPuid1;
                                                    AuthData4->user2.puid = SGInfo.userPuid2;
                                                    AuthData4->user3.puid = SGInfo.userPuid3;
                                                    AuthData4->afltTrustFactor0 = SGInfo.userTrust0;
                                                    AuthData4->afltTrustFactor1 = SGInfo.userTrust1;
                                                    AuthData4->afltTrustFactor2 = SGInfo.userTrust2;
                                                    AuthData4->afltTrustFactor3 = SGInfo.userTrust3;

                                                    // Alt titles
                                                    AuthData4->dwAltTitleID0 = SGInfo.altTitleId0;
                                                    AuthData4->dwAltTitleID1 = SGInfo.altTitleId1;
                                                    AuthData4->dwAltTitleID2 = SGInfo.altTitleId2;
                                                    AuthData4->dwAltTitleID3 = SGInfo.altTitleId3;

                                                    // Base services
                                                    AuthData4->dwBaseServices0 = SGInfo.dwPrivileges0;
                                                    AuthData4->dwBaseServices1 = SGInfo.dwPrivileges1;
                                                    AuthData4->dwBaseServices2 = SGInfo.dwPrivileges2;
                                                    AuthData4->dwBaseServices3 = SGInfo.dwPrivileges3;

                                                    AuthData4->dwMachinePrivileges0 = SGInfo.dwPrivileges4;

                                                    // User Privileges (all users get the same)
                                                    if (SGInfo.userPuid0 != 0)
                                                    {
                                                        AuthData4->dwUser0.Privileges0 = SGInfo.dwPrivileges5User0;
                                                        AuthData4->dwUser0.Privileges1 = SGInfo.dwPrivileges6User0;
                                                        AuthData4->dwUser0.Privileges2 = SGInfo.dwPrivileges7User0;
                                                    }
                                                    if (SGInfo.userPuid1 != 0)
                                                    {
                                                        AuthData4->dwUser1.Privileges0 = SGInfo.dwPrivileges5User1;
                                                        AuthData4->dwUser1.Privileges1 = SGInfo.dwPrivileges6User1;
                                                        AuthData4->dwUser1.Privileges2 = SGInfo.dwPrivileges7User1;
                                                    }
                                                    if (SGInfo.userPuid2 != 0)
                                                    {
                                                        AuthData4->dwUser2.Privileges0 = SGInfo.dwPrivileges5User2;
                                                        AuthData4->dwUser2.Privileges1 = SGInfo.dwPrivileges6User2;
                                                        AuthData4->dwUser2.Privileges2 = SGInfo.dwPrivileges7User2;
                                                    }
                                                    if (SGInfo.userPuid3 != 0)
                                                    {
                                                        AuthData4->dwUser3.Privileges0 = SGInfo.dwPrivileges5User3;
                                                        AuthData4->dwUser3.Privileges1 = SGInfo.dwPrivileges6User3;
                                                        AuthData4->dwUser3.Privileges2 = SGInfo.dwPrivileges7User3;
                                                    }

                                                    // Extended Services
                                                    AuthData4->wNumExtendedServices = SGInfo.wNumDwordServices;
                                                    AuthData4->dwExtendedServiceID0 = SGInfo.dwServiceID0;
                                                    AuthData4->dwExtendedServiceID1 = SGInfo.dwServiceID1;
                                                    AuthData4->dwExtendedServiceID2 = SGInfo.dwServiceID2;
                                                    AuthData4->dwExtendedServiceID3 = SGInfo.dwServiceID3;

                                                    // New to AuthdataV4
                                                    AuthData4->fltConsoleTrustFactor = 0f;
                                                    AuthData4->flowToken = SGInfo.flowToken;

                                                    // Key
                                                    AuthData4->abKey00 = SGInfo.key00;
                                                    AuthData4->abKey01 = SGInfo.key01;
                                                    AuthData4->abKey02 = SGInfo.key02;
                                                    AuthData4->abKey03 = SGInfo.key03;
                                                    AuthData4->abKey04 = SGInfo.key04;
                                                    AuthData4->abKey05 = SGInfo.key05;
                                                    AuthData4->abKey06 = SGInfo.key06;
                                                    AuthData4->abKey07 = SGInfo.key07;
                                                    AuthData4->abKey08 = SGInfo.key08;
                                                    AuthData4->abKey09 = SGInfo.key09;
                                                    AuthData4->abKey10 = SGInfo.key10;
                                                    AuthData4->abKey11 = SGInfo.key11;
                                                    AuthData4->abKey12 = SGInfo.key12;
                                                    AuthData4->abKey13 = SGInfo.key13;
                                                    AuthData4->abKey14 = SGInfo.key14;
                                                    AuthData4->abKey15 = SGInfo.key15;

                                                    packetSize = sizeof(SgMsgSpiRep) + sizeof(SSgMsgSpiData2) + sizeof(SAuthData4);
                                                    break;

                                                    #endregion

                                                default:
                                                    Debug.WriteLine("FakeSG SPIDATA_REQ error. Requested version not supported: " + respAuthVer);
                                                    // done with this packet, can't send the response
                                                    continue;
                                            }
                                        }

                                    }
                                    FakeSGSocket.Send( sock, outArray, packetSize, RemoteIpEndPoint );
                                    #endregion
                                }
                                else if( (regHdr->_wType==(ushort)SGMSG.SET_QVALS_LAZY) || 
                                    (regHdr->_wType==(ushort)SGMSG.SET_QVALS_PUSH) )
                                {
                                    #region Process QVal Request

                                    bool bIsPushRequest = regHdr->_wType == (ushort)SGMSG.SET_QVALS_PUSH;

                                    SSgMsgSetQValsReq* pRequest = (SSgMsgSetQValsReq*) b;
        
                                    fixed( byte* outBytes = outArray )
                                    {
                                        SSgMsgSetQValsRep* pReply = (SSgMsgSetQValsRep*) outBytes;
                                        pReply->Hdr._wType = (ushort)SGMSG.SET_QVALS_REP;
                                        pReply->Hdr._cbEnt = (ushort)sizeof( SSgMsgSetQValsRep );

                                        pReply->sgaddr  = pRequest->sgaddr;
                                        pReply->UserId  = pRequest->UserId;
                                        pReply->Context = pRequest->Context;

                                        SGXboxInfo xboxInfo = (SGXboxInfo) SGXboxInfoSlots[ pRequest->sgaddr.qwXboxID ];
                                        if( xboxInfo == null )
                                        {
                                            pReply->NotFound = 1;
                                            pReply->NoSuchUser = 1;
                                        }
                                        else
                                        {
                                            pReply->NotFound = 0;
                                            SGUserInfo userInfo = (SGUserInfo)xboxInfo.GetUser(pRequest->UserId);
                                            if( userInfo == null )
                                            {
                                                pReply->NoSuchUser = 1;
                                            }
                                            else
                                            {
                                                pReply->NoSuchUser = 0;

                                                // TODO-jacobr: this is not too desirable but 
                                                // it will do 
                                                qvals[0]  = pRequest->QVals.QFlagQVal; 
                                                qvals[1]  = pRequest->QVals.QFlags;
                                                qvals[2]  = pRequest->QVals.InviteQVal; 
                                                qvals[3]  = pRequest->QVals.NewMsgIdsQVal; 
                                                qvals[4]  = pRequest->QVals.NewMsgId_1;
                                                qvals[5]  = pRequest->QVals.NewMsgId_2;
                                                qvals[6]  = pRequest->QVals.NewMsgId_3;

                                                qvals[7]  = pRequest->QVals.NewMsgDataQVal;
                                                qvals[8]  = pRequest->QVals.NewMsgData_1;
                                                qvals[9]  = pRequest->QVals.NewMsgData_2;
                                                qvals[10] = pRequest->QVals.NewMsgData_3;

                                                qvals[11] = pRequest->QVals.DelMsgQVal; 
                                                qvals[12] = pRequest->QVals.DelMsg_1;
                                                qvals[13] = pRequest->QVals.DelMsg_2;
                                                qvals[14] = pRequest->QVals.DelMsg_3;
                                                if(!userInfo.EnqueueQVals(bIsPushRequest, qvals))
                                                {
                                                    Debug.WriteLine("QVal packet queue exceeded for user: " + userInfo.UserId.ToString("x"));
                                                }

                                            }
                                        }
                                    }
                                    FakeSGSocket.Send( sock, outArray, sizeof(SSgMsgSetQValsRep), RemoteIpEndPoint );
                                    #endregion                                                                              
                                }
                                else if (regHdr->_wType == (ushort)SGMSG.KICK_REQ)
                                {
                                    #region Process Kick Request
                                    CSgMsgKickReq* req = (CSgMsgKickReq*)b;
                                    int packetSize = 0;
                                    fixed (byte* outBytes = outArray)
                                    {
                                        CSgMsgKickRep* KickRep = (CSgMsgKickRep*)outBytes;

                                        // Fill Kick Rep data
                                        //
                                        KickRep->Hdr._wType = (ushort)SGMSG.KICK_REP;
                                        KickRep->Hdr._cbEnt = (ushort)sizeof(CSgMsgKickRep);
                                        KickRep->sgaddr = req->sgaddr;
                                        KickRep->fNotFound = (byte)0;

                                        packetSize = sizeof(CSgMsgKickRep);
                                    }
                                    FakeSGSocket.Send(sock, outArray, packetSize, RemoteIpEndPoint);
                                    #endregion
                                }
                            }
                        }
                    }       
                    catch( SocketException ex)
                    {
                        Debug.WriteLine("FakeSG socket exception.\nNativeErrorCode: 0x"+ex.NativeErrorCode.ToString("X") + "\nMessage: " + ex.Message + "\nStackTrace: " + ex.StackTrace);
                        exceptionOcurred = true;
                    }
                    catch( Exception ex)
                    {
                        Debug.WriteLine("NONFATAL ERROR: FakeSG should never throw an exception:\n" + ex.ToString());
                        exceptionOcurred = true;
                    }
                }
            }
            finally
            {
                FakeSGSocket.Terminate();
                Debug.WriteLine("FastHandler: Finished");
            }
        }

        private void StateUpdateTimerCallback(object state)
        {
            SendUpdateState(true);
        }

        // Called by either the timer drive batch state update 
        // or 
        private void SendUpdateState(bool batching)
        {
            // Provide a lock at the top level of this function to protect config
            // change race conditions and update queue modifications. This function
            // may be called from a system thread driven from the timer
            lock(StateUpdateQueue)
            {

                if(null == StateEndpoint)
                {
                    Debug.WriteLine("InternalSendUpdateState: cannot send state update, the state update endpoint has not be specified");
                    goto lbDone;
                }

                // This method was called from the wrong place, this isn't a bad thing but
                // indicates either:
                //
                //    - Stale timer which is should expire
                //    - Call from SetUserState() which can be ignored as the timer will kick off
                //        the appropriate call.
                if(EnableStateBatching != batching)
                {
                    goto lbDone;
                }

                //if queue length is 0, meaning other thread already sent it, than dont send.
                if (StateUpdateQueue.Count == 0)
                    goto lbDone;

                try
                {
                    MemoryStream stream = new MemoryStream();
                    CSgMsgNotifyCliUpdate msg = new CSgMsgNotifyCliUpdate();

                    // Batch all of the updates into a single stream
                    foreach(StateUpdateItem updateItem in StateUpdateQueue)
                    {
                        // Get the xbox slot information
                        SGXboxInfo xbox = SGXboxInfoSlots[updateItem.XboxId] as SGXboxInfo;
                        if(xbox == null) 
                        {
                            Debug.WriteLine("Attempted to write state update for xbox ID: " + 
                                    updateItem.XboxId.ToString("x") + 
                                    " which was not found in the slot hash");
                            continue;
                        }

                        // Build the msg
                        msg.wType       = (ushort)SGMSG.NOTIFY_CLI_UPD;
                        msg.cbEnt       = 310;
                        msg.inaSg       = xbox.SgIp;
                        msg.dwSpiSg     = xbox.Spi;
                        msg.qwXboxID    = xbox.XboxId;
                        msg.abReserved  = 0;
                        msg.qwUserId    = updateItem.UserId;
                        msg.qwMatchSessionId = updateItem.MatchSessionId;
                        if (xbox.ClientType == CSGInfo.ClientType.Xenon)
                        {
                            msg.dwAuthFlags = (uint)CSGInfo.AUTHDATA_FLAGS_ISXENON;
                        }
                        else if (xbox.ClientType == CSGInfo.ClientType.XenonBackCompat)
                        {
                            msg.dwAuthFlags = (uint)CSGInfo.AUTHDATA_FLAGS_ISXENONBACKCOMPAT;
                        }
                        else
                        {
                            msg.dwAuthFlags = 0;
                        }
                        msg.dwState     = updateItem.State;
                        msg.dwTitleId     = xbox.TitleId;
                        msg.cbTitleData = updateItem.TitleDataCount;

                        // This will never be more than MAX_TITLE_DATA_BYTES
                        Array.Copy(updateItem.TitleData, msg.rgbTitleData, updateItem.TitleData.Length);

                        // Serialize the header and data 
                        msg.WriteStream(stream);

                    } // end build up batch state

                    // All done with the items in the queue
                    StateUpdateQueue.Clear();

                    // Send the update to the presence FD state XRL
                    AsyncHttpRequest request = new AsyncHttpRequest();
                    request.Resource = "/xpnfront/state.ashx";
                    request.Endpoint = StateEndpoint;
                    request.Payload = stream;
                    request.Socket = new Socket(AddressFamily.InterNetwork, SocketType.Stream, ProtocolType.Tcp);
                    request.Socket.Blocking = false;
                    request.Socket.BeginConnect(request.Endpoint, new AsyncCallback(request.OnConnect), request);
                }
                catch(Exception ex)
                {
                    Debug.WriteLine("Error in batch state update: " + ex.ToString());
                }
            } // end lock(StateUpdateQueue)

lbDone:
            return;
        }

        ///////////////////////////////////////////////////
        /// <summary>
        /// Retries data from shared MMF
        /// </summary>
        /// <param name="port">Port for which data is requested</param>
        /// <param name="localIp">IP of interface requtest came in on</param>
        /// <returns>SPI Auth data</returns>
        private unsafe CSGInfo FindSlotByPort( ushort port, IPAddress localIp )
        {
            CSGInfo* pMirror = (CSGInfo*)( slotPtrs + (int)mmfPortTableOffset[ localIp ] );
            return pMirror[ port ];
        }
        
        ///////////////////////////////////////////////////
        /// <summary>
        /// Remote Controler to get service version
        /// </summary>
        /// <returns>Version number compiled into service</returns>
        public int GetServiceVersion()
        {
            return GetCompiledVersion();
        }

        ///////////////////////////////////////////////////
        /// <summary>
        /// Remote Controler to get number of serviced interfaces
        /// </summary>
        /// <returns>Number of interfaces service is listening on</returns>
        public int GetInterfaceCount()
        {
            return mmfPortTableOffset.Count;
        }
    
        ///////////////////////////////////////////////////
        /// <summary>
        /// Remote Controler to get the interface at a particular offset.  This makes sure the hash
        /// table the client uses to map local IP addresses to mmf slot data is the same as the 
        /// one used by the service.
        /// </summary>
        /// <param name="index">Interface index</param>
        /// <returns></returns>
        public IPAddress GetInterfaceAddress( int offset )
        {
            foreach( IPAddress ip in mmfPortTableOffset.Keys )
            {
                if( (int)mmfPortTableOffset[ ip ] == offset )
                    return ip;
            }
            return IPAddress.None;
        }


        public void LoadSlot( ref CSGInfo sgInfo, ulong xboxId )
        {
            SGXboxInfo xbox = (SGXboxInfo)SGXboxInfoSlots[ xboxId ];
            if( xbox == null ) 
            {
                throw new Exception( "Xbox: " + xboxId.ToString("x") + " not found in FakeSG" );
            }
            xbox.LoadSGInfo( ref sgInfo );
        }

        public void AddXbox(     uint sgIp, 
                                uint spi, 
                                ulong xboxId, 
                                uint titleId, 
                                uint titleVer, 
                                uint titleRegion, 
                                byte[] key, 
                                ulong clientVersion,
                                CSGInfo.ClientType clientType, 
                                uint languageId )
        {
            SGXboxInfo xbox = SGXboxInfoSlots[xboxId] as SGXboxInfo;

            if(null == xbox)
            {
                xbox = new SGXboxInfo(sgIp, spi, xboxId, languageId);
                SGXboxInfoSlots[xboxId] = xbox;
            }
            else
            {
                // Make sure we update spi
                xbox.SgIp = sgIp;
                xbox.Spi = spi;
                xbox.LanguageId = languageId;
            }

            xbox.TitleId = titleId;
            xbox.TitleVer = titleVer;
            xbox.TitleRegion = titleRegion;
            xbox.Key = key;
            xbox.ClientVersion = clientVersion;
            xbox.ClientType = clientType;
        }

        public void RemoveXbox( ulong xboxId )
        {
            SGXboxInfo xboxInfo = SGXboxInfoSlots[xboxId] as SGXboxInfo;

            if(null != xboxInfo)
            {
                SGXboxInfoSlots.Remove(xboxId);
            }
        }

        public void DeadXbox( ulong xboxId )
        {
            SGXboxInfo xboxInfo = SGXboxInfoSlots[xboxId] as SGXboxInfo;

            if(null != xboxInfo)
            {
                SendNotifyDelete(xboxInfo);
                SGXboxInfoSlots.Remove(xboxId);
            }
        }

        public void ClearXboxes()
        {
            try 
            {
                foreach(SGXboxInfo xboxInfo in SGXboxInfoSlots.Values)
                {
                    if(xboxInfo == null)
                        continue;
                    
                    SendNotifyDelete(xboxInfo);
                    
                }
            }
            catch(Exception ex)
            {
                Debug.WriteLine("Error in ClearXboxes() update: " + ex.ToString());
            }

            // Clear all slots
            SGXboxInfoSlots.Clear();
        }

        public void SendNotifyDelete(SGXboxInfo xboxInfo)
        {
            MemoryStream stream = new MemoryStream();
            CSgMsgNotifyCliDelete msg = new CSgMsgNotifyCliDelete();

            // Build the msg
            msg.wType           = (ushort)SGMSG.NOTIFY_CLI_DEL;
            msg.cbEnt           = 28; 
            msg.inaSg           = xboxInfo.SgIp;
            msg.dwSpiSg         = xboxInfo.Spi;
            msg.qwXboxId        = xboxInfo.XboxId;
            msg.abReserved      = 0;
            msg.dwTitleId       = xboxInfo.TitleId;

            // Serialize the header and data 
            msg.WriteStream(stream);

            // Send the dead xbox info to the presence FD state XRL
            AsyncHttpRequest request = new AsyncHttpRequest();
            request.Resource = "/xpnfront/deadxbox.ashx";
            request.Endpoint = StateEndpoint;
            request.Payload = stream;
            request.Socket = new Socket(AddressFamily.InterNetwork, SocketType.Stream, ProtocolType.Tcp);
            request.Socket.Blocking = false;
            request.Socket.BeginConnect(request.Endpoint, new AsyncCallback(request.OnConnect), request);
        }

        public void SetTitle( ulong xboxId, uint titleId, uint titleVer, uint titleRegion )
        {
            SGXboxInfo xbox = (SGXboxInfo)SGXboxInfoSlots[ xboxId ];
            if( xbox == null ) 
            {
                throw new Exception( "Xbox not found in FakeSG" );
            }
            xbox.TitleId     = titleId;
            xbox.TitleVer    = titleVer;
            xbox.TitleRegion = titleRegion;
        }

        public void SetAltTitles( ulong xboxId, uint[] altTitleIds )
        {
            SGXboxInfo xbox = (SGXboxInfo)SGXboxInfoSlots[ xboxId ];
            if( xbox == null ) 
            {
                throw new Exception( "Xbox not found in FakeSG" );
            }
            
            xbox.ClearAltTitles();
            foreach( uint id in altTitleIds )
            {
                xbox.AddAltTitle( id );
            }
        }

        public void SetKey( ulong xboxId, byte[] key )
        {
            SGXboxInfo xbox = LookupXbox(xboxId);
            xbox.Key = key;
        }

        public void SetUserState(ulong xboxId, ulong userId, ulong matchSessionId, uint state, byte []titleData, ushort titleDataLen)
        {
            SGXboxInfo xbox = LookupXbox(xboxId);
            xbox.SetUserState(userId, matchSessionId, state, titleData, titleDataLen);
            lock (StateUpdateQueue)
            {
                StateUpdateQueue.Add(new StateUpdateItem(xboxId, userId, state, matchSessionId, titleData, titleDataLen));
                //In prod, SG sends the state update in batch of 100. 
                //If batching is enabled, and queue is getting to 100, than send it right away..
                if (EnableStateBatching && StateUpdateQueue.Count >= 100)
                {
                    Debug.WriteLine("StateUpdateQueue is full. Sending state update now. Queue Length = " + StateUpdateQueue.Count);
                    SendUpdateState(EnableStateBatching);
                    return;
                }

            }
            SendUpdateState(false);
        }

        public void SetEnableStateBatching(bool enable, uint intervalmiliSeconds)
        {
            if(intervalmiliSeconds > 60*60*1000)
            {
                Debug.WriteLine("SetEnableStateBatching: interval times of over an hour not supported");
                goto lbDone;
            }
            
            lock(StateUpdateQueue)
            {
                EnableStateBatching = enable;
            
                if(null != StateUpdateTimer)
                {
                    StateUpdateTimer.Dispose();
                }

                if(EnableStateBatching)
                {
                    // State updates will now be driven off of a timer which will drain
                    // the StateUpdateQueue
                    StateUpdateTimer = new Timer(
                            new TimerCallback(this.StateUpdateTimerCallback),
                            this,
                            0,                // start right away
                            (int)(intervalmiliSeconds)); // repeat interval in milliseconds
                }
            }

lbDone:
            return;
        }

        public void SetStateEndpoint(string endpoint)
        {
            lock(StateUpdateQueue)
            {
                int mark = endpoint.IndexOf(':');
                if(mark > 0) 
                {
                    string address = endpoint.Substring(0, mark);
                    string port = endpoint.Substring(mark+1);
                    StateEndpoint = new IPEndPoint(IPAddress.Parse(address), Int16.Parse(port));
                }
            }
        }

        public void AddUser( ulong xboxId, ulong userId, uint userFlags )
        {
            // This will only add a new user if their UserId does not yet exist on this Xbox
            // else it will just update their flags
            SGXboxInfo xbox = LookupXbox(xboxId);
            xbox.AddUser( userId, userFlags );
        }

        public void RemoveUser( ulong xboxId, ulong userId )
        {
            SGXboxInfo xbox = LookupXbox(xboxId);
            xbox.RemoveUser( userId );
        }

        public byte GetUserCount( ulong xboxId )
        {
            SGXboxInfo xbox = LookupXbox(xboxId);
            return (byte) xbox.GetUserCount();
        }

        public bool ReadUserQValPacket( ulong xboxId, ulong userId, out QValPacket packet )
        {
            SGXboxInfo xbox = LookupXbox(xboxId);
            SGUserInfo user = xbox.GetUser(userId);
            if(user == null)
            {
                packet = null;
                return false;
            }
            else
            {
                return user.DequeueQVals(out packet);
            }
        }

        private SGXboxInfo LookupXbox( ulong xboxId)
        { 
            SGXboxInfo xbox = (SGXboxInfo)SGXboxInfoSlots[ xboxId ];
            if( xbox == null)
            {
                throw new Exception( "Xbox: " + xboxId.ToString("x") + " not found in FakeSG" );
            }

            return xbox;
        }

        #region SG Message Protocol constants and structures
        private enum SGMSG : ushort
        {
            AUTHDATA_REQ       = 0x4700, // CSgMsgAuthReq
            AUTHDATA_REP       = 0x4701, // CSgMsgAuthRep
            KICK_REQ           = 0x4705, // CSgMsgKickReq
            KICK_REP           = 0x4706, // CSgMsgKickRep
            CLIENT_ADD         = 0x4707, // CSgMsgClient
            CLIENT_DEL         = 0x4708, // CSgMsgClient
            CLIENT_UPD         = 0x4709, // CSgMsgClient
            XBTOXB_FORWARD     = 0x470A, // CSgMsgXbToXbForward
            SET_QVALS_LAZY     = 0x470B, // CSgMsgSetQValsReq
            SET_QVALS_PUSH     = 0x470C, // CSgMsgSetQValsReq
            SET_QVALS_REP      = 0x470D, // CSgMsgSetQValsRep
            SPIDATA_REQ        = 0x4710, // CSgMsgSpiReq
            SPIDATA_REQ2       = 0x4716, // CSgMsgSpiReq2
            SPIDATA_REP        = 0x4711, // CSgMsgSpiRep
            NOTIFY_CLI_DEL     = 0x4712, // CSgMsgNotifyCliDelete
            NOTIFY_CLI_UPD     = 0x4713, // CSgMsgNotifyCliUpdate
            NOTIFY_CLI_TCHG    = 0x4714, // CSgMsgNotifyCliTitleChange
            SPIDATA            = 0x4782, // CSgMsgSpiData2 in the payload
            AUTHDATA           = 0x4783  // CAuthData3 in the payload
        };

        [StructLayout(LayoutKind.Sequential, Pack=1)]
            private struct SSgMsgHdr 
        {
            public ushort _wType; // One of SGMSG enumeration
            public ushort _cbEnt; // Size of this entry (including header)
        };

        [StructLayout(LayoutKind.Sequential, Pack=1)]
            private struct SSGAddr
        {
            public uint  inaSg;      // IP address of the SG for the client
            public uint  dwSpiSg;    // Pseudo-random identifier assigned by the SG
            public ulong qwXboxID;   // Unique identifier of client machine account
            public uint  abReserved; // Reserved (must be zero)
        };

        [StructLayout(LayoutKind.Sequential, Pack=1)]
            private struct SSgMsgAuthReq
        {
            public SSgMsgHdr Header;
            public uint      _dwReqNum; // Request number from requester
            public uint      _ipaZ;     // IP address of the client on the DMZ
            public ushort    _ipportZ;  // IP port of the client on the DMZ
        };

        [StructLayout(LayoutKind.Sequential, Pack=1)]
            private struct SgMsgSpiReq
        {
            public SSgMsgHdr Header;    
            public uint      _dwReqNum; // Request number from requester
            public uint      _ipaZ;     // IP address of the client on the DMZ
            public ushort    _ipportZ;  // IP port of the client on the DMZ
        };

        // Intentionally NOT derived from SgMsgSpiReq to follow pattern from SG
        // However, the SG does treat it as though it was derived, le sigh
        [StructLayout(LayoutKind.Sequential, Pack=1)]
            private struct SgMsgSpiReq2
        {
            public SSgMsgHdr Header;    
            public uint      _dwReqNum;         // Request number from requester
            public uint      _ipaZ;             // IP address of the client on the DMZ
            public ushort    _ipportZ;          // IP port of the client on the DMZ
            public ushort    _wAuthDataVersion; // Maximum supported authdata version
        };

        [StructLayout(LayoutKind.Sequential, Pack=1)]
            private struct SgMsgSpiRep
        {
            public SSgMsgHdr Header;
            // Data ------------------------------------------------------------------------------
            public uint   _dwReqNum;  // Copy of _dwReqNum from request
            public uint   _ipaZ;      // IP address of the client on the DMZ
            public ushort _ipportZ;   // IP port of the client on the DMZ
            public byte   _fNotFound; // TRUE if client not found (no auth-data enclosed)
        };

        [StructLayout(LayoutKind.Sequential, Pack=1)]
            private struct SgMsgSpiData
        {
            public ushort  _ipportI;      // IP port of the client on the Internet
            public uint    _ipaI;         // IP address of the client on the Internet
            public SSGAddr sgaddr;
            public ushort _wVersionKeyEx; // KeyEx version of the client
            public ushort _wFlagsKeyEx;   // Flags sent in KeyEx initiator
            public long   _liNonce;       // A random nonce associated with this session
            public long   _liTimeInit;    // FILETIME marking session initiation
            public int    _fCs;           // TRUE if SG is providing connection service
        };

        [StructLayout(LayoutKind.Sequential, Pack=1)]
            private struct SSgMsgSpiData2 
        {
            public SSgMsgHdr Header;
            public ushort    _ipportI;       // IP port of the client on the Internet
            public uint      _ipaI;          // IP address of the client on the Internet
            public SSGAddr   sgaddr;
            public ushort    _wVersionKeyEx; // KeyEx version of the client
            public ushort    _wFlagsKeyEx;   // Flags sent in KeyEx initiator
            public long      _liNonce;       // A random nonce associated with this session
            public long      _liTimeInit;    // FILETIME marking session initiation
            public int       _fCs;           // TRUE if SG is providing connection services
        };

        [StructLayout(LayoutKind.Sequential, Pack=1)]
            private struct SAuthData1
        {
            public SSgMsgHdr      Header;
            public ushort         wAuthDataVersion; 
            public ushort         wAuthDataSize; 
            public ulong          clientVersion;
            public uint           dwTitleID;
            public uint           dwTitleVersion;
            public uint           dwTitleRegion;
            public ulong          qwXboxID;
            public SAuthData2User user0;
            public SAuthData2User user1;
            public SAuthData2User user2;
            public SAuthData2User user3;
        };

        [StructLayout(LayoutKind.Sequential, Pack=1)]
            private struct SAuthData2
        {
            public SSgMsgHdr        Header;
            public ushort           wAuthDataVersion; 
            public ushort           wAuthDataSize; 
            public ulong            clientVersion;
            public uint             dwTitleID;
            public uint             dwTitleVersion;
            public uint             dwTitleRegion;
            public ulong            qwXboxID;
            public SAuthData2User   user0;
            public SAuthData2User   user1;
            public SAuthData2User   user2;
            public SAuthData2User   user3;
            public uint             dwNumServices;

            // Arrays are difficult to specify in C#, easier to do this in the fixed{} block above
            //public ushort         dwServiceID[XONLINE_MAX_NUMBER_SERVICE_PER_TICKET];  // 12
            //public float          afltTrustFactor[4];
            //public uint           dwAltTitleID[4];
            //public byte           abKey[16];
        };

        [StructLayout(LayoutKind.Sequential, Pack=1)]
            private struct SAuthData2User
        {
            // The high 16 bits of dwUserFlags should come from the UODB User Table.
            public ulong puid; 
            public uint  flags; 
        };

        [StructLayout(LayoutKind.Sequential, Pack=1)]
            private struct SXboxLibraryVersion
        {
            public ushort           wMajorVersion;
            public ushort           wMinorVersion;
            public ushort           wBuildNumber;
            public ushort           wQFENumber;
        };

        [StructLayout(LayoutKind.Sequential, Pack = 1)]
        private struct SUserPrivileges
        {
            public uint Privileges0;
            public uint Privileges1;
            public uint Privileges2;
        };

        [StructLayout(LayoutKind.Sequential, Pack=1)]
            private struct SAuthData3
        {
            public SSgMsgHdr        Header;
            public ushort           wAuthDataVersion; 
            public ushort           wAuthDataSize; 
            public SXboxLibraryVersion  clientVersion;
            public uint             dwTitleID;
            public uint             dwTitleVersion;
            public uint             dwTitleRegion;
            public uint             dwConsoleRegion;
            public uint             dwMediaID;
            public ushort           wLanguageID;
            public uint             dwAuthDataFlags;
            public ushort           wNumPrivileges;
            //public uint           dwPrivileges[XONLINE_NUM_PRIVILEGE_DWORDS];  // 8
            public uint             dwPrivileges0;
            public uint             dwPrivileges1;
            public uint             dwPrivileges2;
            public uint             dwPrivileges3;
            public uint             dwPrivileges4;
            public uint             dwPrivileges5;
            public uint             dwPrivileges6;
            public uint             dwPrivileges7;
            public ulong            qwXboxID;
            //public XUID           users[XONLINE_MAX_LOGON_USERS];  // 4
            public SAuthData2User   user0;
            public SAuthData2User   user1;
            public SAuthData2User   user2;
            public SAuthData2User   user3;
            //public float          afltTrustFactor[XONLINE_MAX_LOGON_USERS];  // 4
            public float            afltTrustFactor0;
            public float            afltTrustFactor1;
            public float            afltTrustFactor2;
            public float            afltTrustFactor3;
            public ushort           wNumDwordServices;
            //public uint           dwServiceID[XONLINE_MAX_DWORD_SERVICEIDS];  // 4
            public uint             dwServiceID0;
            public uint             dwServiceID1;
            public uint             dwServiceID2;
            public uint             dwServiceID3;
            //public uint           dwAltTitleID[XONLINE_MAX_ALTERNATE_TITLE_ID];  // 4
            public uint             dwAltTitleID0;
            public uint             dwAltTitleID1;
            public uint             dwAltTitleID2;
            public uint             dwAltTitleID3;
            //public byte           abKey[XONLINE_KEY_LENGTH];  // 16
            public byte             abKey00;
            public byte             abKey01;
            public byte             abKey02;
            public byte             abKey03;
            public byte             abKey04;
            public byte             abKey05;
            public byte             abKey06;
            public byte             abKey07;
            public byte             abKey08;
            public byte             abKey09;
            public byte             abKey10;
            public byte             abKey11;
            public byte             abKey12;
            public byte             abKey13;
            public byte             abKey14;
            public byte             abKey15;
        };

        [StructLayout(LayoutKind.Sequential, Pack = 1)]
        private struct SAuthData4
        {
            public SSgMsgHdr Header;
            public ushort wAuthDataVersion;
            public ushort wAuthDataSize;
            public SXboxLibraryVersion clientVersion;
            public uint dwAuthDataFlags;
            public ulong qwXboxID;
            public float fltConsoleTrustFactor;
            public uint dwTitleID;
            public uint dwTitleVersion;
            public uint dwTitleRegion;
            public uint dwConsoleRegion;
            public uint dwMediaID;
            public ushort wLanguageID;
            public ushort wNumExtendedServices;
            //public uint           dwExtendedServices[XONLINE_MAX_DWORD_SERVICEIDS];  // 4
            public uint dwExtendedServiceID0;
            public uint dwExtendedServiceID1;
            public uint dwExtendedServiceID2;
            public uint dwExtendedServiceID3;
            //public XUID           users[XONLINE_MAX_LOGON_USERS];  // 4
            public SAuthData2User user0;
            public SAuthData2User user1;
            public SAuthData2User user2;
            public SAuthData2User user3;
            //public float          afltTrustFactor[XONLINE_MAX_LOGON_USERS];  // 4
            public float afltTrustFactor0;
            public float afltTrustFactor1;
            public float afltTrustFactor2;
            public float afltTrustFactor3;
            //public uint           dwBaseServices[XONLINE_NUM_BASE_SERVICE_DWORDS];  // 4
            public uint dwBaseServices0;
            public uint dwBaseServices1;
            public uint dwBaseServices2;
            public uint dwBaseServices3;
            //public uint           dwMachinePrivileges[XONLINE_NUM_MACHINE_PRIVILEGE_DWORDS];  // 1
            public uint dwMachinePrivileges0;
            //public uint           dwUserPrivileges[XONLINE_MAX_LOGON_USERS][XONLINE_NUM_USER_PRIVILEGE_DWORDS];  // 4 x 3
            public SUserPrivileges dwUser0;
            public SUserPrivileges dwUser1;
            public SUserPrivileges dwUser2;
            public SUserPrivileges dwUser3;
            //public uint           dwAltTitleID[XONLINE_MAX_ALTERNATE_TITLE_ID];  // 4
            public uint dwAltTitleID0;
            public uint dwAltTitleID1;
            public uint dwAltTitleID2;
            public uint dwAltTitleID3;
            public ulong flowToken;
            //public byte           abReserved[16];
            public byte abReserved00;
            public byte abReserved01;
            public byte abReserved02;
            public byte abReserved03;
            public byte abReserved04;
            public byte abReserved05;
            public byte abReserved06;
            public byte abReserved07;
            public byte abReserved08;
            public byte abReserved09;
            public byte abReserved10;
            public byte abReserved11;
            public byte abReserved12;
            public byte abReserved13;
            public byte abReserved14;
            public byte abReserved15;
            //public byte           abKey[XONLINE_KEY_LENGTH];  // 16
            public byte abKey00;
            public byte abKey01;
            public byte abKey02;
            public byte abKey03;
            public byte abKey04;
            public byte abKey05;
            public byte abKey06;
            public byte abKey07;
            public byte abKey08;
            public byte abKey09;
            public byte abKey10;
            public byte abKey11;
            public byte abKey12;
            public byte abKey13;
            public byte abKey14;
            public byte abKey15;
        };

        [StructLayout(LayoutKind.Sequential, Pack=1)]
            private struct SSgMsgAuthRep
        {
            public SSgMsgHdr Header;
            public uint      _dwReqNum;  // Copy of _dwReqNum from request
            public uint      _ipaZ;      // IP address of the client on the DMZ
            public ushort    _ipportZ;   // IP port of the client on the DMZ
            public ushort    _ipportI;   // IP port of the client on the Internet
            public uint      _ipaI;      // IP address of the client on the Internet
            public SSGAddr   sgaddr;
            public byte      _fNotFound; // TRUE if client not found (no auth-data enclosed)
        };

        // QVals - Xonline.x over engineers the crap out of these.
        //         In practice they always look like this
        [StructLayout(LayoutKind.Sequential, Pack=1)]
            private struct SQVals
        {
            public uint QFlagQVal; // Notification Queue Flags
            public uint QFlags;
            
            public uint InviteQVal; // Boolean (no extra data)

            public uint NewMsgIdsQVal; // The last 3 message IDs that arrived
            public uint NewMsgId_1;
            public uint NewMsgId_2;
            public uint NewMsgId_3;

            public uint NewMsgDataQVal; // Data for the last 3 messages that arrived
            public uint NewMsgData_1;
            public uint NewMsgData_2;
            public uint NewMsgData_3;

            public uint DelMsgQVal; // the last 3 messages deleted
            public uint DelMsg_1;
            public uint DelMsg_2;
            public uint DelMsg_3;
        };

        // QVal Request (From NotiInh)
        [StructLayout(LayoutKind.Sequential, Pack=1)]
            private struct SSgMsgSetQValsReq
        {
            public SSgMsgHdr Hdr;
            public SSGAddr   sgaddr;  // SGADDR of the client
            public ulong     UserId;  // User id of the user
            public uint      Context; // Sender's context to be returned in reply
            public SQVals    QVals;   // Turns out this blob at the end always looks the same
        };

        // QVal Reply
        [StructLayout(LayoutKind.Sequential, Pack=1)]
            private struct SSgMsgSetQValsRep
        {
            public SSgMsgHdr Hdr;
            public SSGAddr   sgaddr;     // SGADDR of the client
            public ulong     UserId;     // User id of the user
            public uint      Context;    // Sender's context from corresponding request
            public byte      NotFound;   // TRUE if client not found
            public byte      NoSuchUser; // TRUE if SG doesn't know about qwUserId
        };

        // Kick Request
        [StructLayout(LayoutKind.Sequential, Pack=1)]
            private struct CSgMsgKickReq
        {
            public SSgMsgHdr Hdr;
            public SSGAddr   sgaddr; // SGADDR of the client to kick
        };
        
        // Kick Reply
        [StructLayout(LayoutKind.Sequential, Pack=1)]
            private struct CSgMsgKickRep
        {
            public SSgMsgHdr Hdr;
            public SSGAddr   sgaddr;    // SGADDR of the client that was kicked
            public byte      fNotFound; // TRUE if client not found
        };

        // State update
        private class CSgMsgNotifyCliUpdate  : WireData
        {
            public ushort    wType;
            public ushort    cbEnt;
            public uint      inaSg;      // IP address of the SG for the client
            public uint      dwSpiSg;    // Pseudo-random identifier assigned by the SG
            public ulong     qwXboxID;   // Unique identifier of client machine account
            public uint      abReserved; // Reserved (must be zero)
            public ulong     qwUserId;
            public ulong     qwMatchSessionId;
            public uint      dwAuthFlags;  // <- New member
            public uint      dwState;
            public uint      dwTitleId;
            public ushort    cbTitleData;
            [WireInfo(ArraySize=256)]
            public byte      []rgbTitleData = new byte[256];
        }; 

         private class CSgMsgNotifyCliDelete : WireData
        {
            public ushort    wType;
            public ushort    cbEnt;
            public uint      inaSg;      // IP address of the SG for the client
            public uint      dwSpiSg;    // Pseudo-random identifier assigned by the SG
            public ulong     qwXboxId;   // Unique identifier of client machine account
            public uint      abReserved; // Reserved (must be zero)
            public uint      dwTitleId;
        };
    
        /*TODO-jacobr: stubbed in here in anticipation of m4 integration
        private class CSgMsgNotifyCliTitleChange : WireData
        {
            public ushort    wType;
            public ushort    cbEnt;
            public uint      inaSg;      // IP address of the SG for the client
            public uint      dwSpiSg;    // Pseudo-random identifier assigned by the SG
            public ulong     qwXboxID;   // Unique identifier of client machine account
            public uint      abReserved; // Reserved (must be zero)
            public uint      dwOldTitleId;
            public uint      dwNewTitleId;
        }
        */
        #endregion 
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\StfTests\FakeSGService\objd\i386\_asmid.inc ===
ASSEMBLY_IDENTITY_KEY_FORM=msil_fakesgservice_none_12.4.56.0_none_98ae276dd48c85d5
ASSEMBLY_IDENTITY_XP_KEY_FORM=msil_fakesgservice_no-public-key_12.4.56.0_x-ww_a1bfdbef
ASSEMBLY_IDENTITY_CULTURE=
ASSEMBLY_IDENTITY_NAME=fakesgservice
ASSEMBLY_IDENTITY_PROCESSOR_ARCHITECTURE=msil
ASSEMBLY_IDENTITY_PUBLIC_KEY=
ASSEMBLY_IDENTITY_PUBLIC_KEY_TOKEN=
ASSEMBLY_IDENTITY_TYPE=
ASSEMBLY_IDENTITY_TYPE_NAME=
ASSEMBLY_IDENTITY_VERSION=12.4.56.0
XP_KEY_FORM=msil_fakesgservice_no-public-key_12.4.56.0_x-ww_a1bfdbef
XP_MANIFEST_DIRECTORY=manifests
XP_MANIFEST_NAME=msil_fakesgservice_no-public-key_12.4.56.0_x-ww_a1bfdbef.manifest
XP_MANIFEST_PATH=manifests\msil_fakesgservice_no-public-key_12.4.56.0_x-ww_a1bfdbef.manifest
XP_CATALOG_DIRECTORY=manifests
XP_CATALOG_NAME=msil_fakesgservice_no-public-key_12.4.56.0_x-ww_a1bfdbef.cat
XP_CATALOG_PATH=manifests\msil_fakesgservice_no-public-key_12.4.56.0_x-ww_a1bfdbef.cat
XP_PAYLOAD_PATH=msil_fakesgservice_no-public-key_12.4.56.0_x-ww_a1bfdbef
_DELAY_SIGN=0
!if [set _ASMIDTOATTRIBS_TLBIMP=]
!endif
CODESIGN_TESTKEY=
_TLBIMP_FLAGS=$(_TLBIMP_FLAGS)  /asmversion:12.4.56.0
_ASSEMBLY_IDENTITY=fakesgservice,processorArchitecture=msil,version=12.4.56.0,publicKeyToken=neutral
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\StfTests\FakeSGService\SGUserInfo.cs ===
using System;
using System.IO;
using System.Collections;
using System.Diagnostics;

using ServerTestFramework.LiveService.FakeSG;

namespace FakeSGWinService
{
	public class SGUserInfo
	{
		public const uint MAX_QVAL_QUEUE_SIZE = 1000;

		public ulong  UserId         = 0;
		public uint   UserFlags      = 0;
		public uint   QFlags         = 0;
		public uint   QFlagSeqNum    = 0;
		public ushort Invites        = 0;  
		public uint   InviteSeqNum   = 0;
		public ulong  MatchSessionId = 0;
		public uint   State          = 0;
		public ushort TitleDataLen   = 0; 
		public byte   []TitleData    = new byte[256];
		public Queue  QValPacketQueue = new Queue();


		public SGUserInfo(ulong userId, uint userFlags)
		{
			UserId = userId;
			UserFlags = userFlags;
		}

		/// <summary>
		/// This method is called by the UDP handler to accumulate 
		/// SG qval data on the user object. This will be 'delivered'
		/// via a pull from a STF hosted PNUser object. 
		///
		/// Technically the real SG would accumulate these changes for the
		/// user this method will packetize it so that this process is not lossy.
		/// </summary>
		public bool EnqueueQVals(bool bIsPush, uint [] qvalData)
		{
			if(QValPacketQueue.Count > MAX_QVAL_QUEUE_SIZE)
			{
				return false;
			}

			QValPacket packet = new QValPacket();
			packet.Push = bIsPush;
			packet.Data = qvalData;
			packet.DeliveryTime = DateTime.Now;
			QValPacketQueue.Enqueue(packet);
		
			return true;
		}

		/// <summary>
		/// Read queued qval packets until false is returned.
		/// </summary>
		public bool DequeueQVals(out QValPacket packet)
		{
			if(QValPacketQueue.Count > 0)
			{
				packet = QValPacketQueue.Dequeue() as QValPacket;
				return true;
			}
			else
			{
				packet = null;
				return false;
			}
		}
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\StfTests\FakeSGService\SGXBoxInfo.cs ===
using System;
using System.Collections;
using ServerTestFramework.LiveService.FakeSG;
using xonline.common.service;

namespace FakeSGWinService
{
    public class SGXboxInfo
    {
        public uint  SgIp;
        public uint  Spi;
        public ulong XboxId;
        public long Nonce;

        public ulong ClientVersion;
        public CSGInfo.ClientType ClientType = CSGInfo.ClientType.Xbox;

        public SGXboxInfo( uint sgIp, uint spi, ulong xboxId, uint languageId )
        {
            SgIp   = sgIp;
            Spi    = spi;
            XboxId = xboxId;
            LanguageId = languageId;
            Random rand = new Random((int)DateTime.Now.Ticks);
            Nonce = (long) rand.Next();
        }

        public uint  TitleId;
        public uint  TitleVer;
        public uint  TitleRegion;
        public uint  LanguageId;

        public byte[] Key = DefaultKey;
        public static byte[] DefaultKey = {1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16};
        public static byte[] AnotherKey = {1,2,3,4,1,2,3,4,1,2,3,4,1,2,3,4};
		
        public uint[] AltTitles = new uint[4];
        public byte   NumAltTitles = 0;
        public SGUserInfo[] users = new SGUserInfo[4];

        public void AddAltTitle( uint id )
        {
            if( NumAltTitles == 4 )
            {
                throw new Exception( "No more alt titles allowed in SGXboxInfo" );
            }
            AltTitles[ NumAltTitles++ ] = id;
        }

        public void ClearAltTitles()
        {
            AltTitles = new uint[4];
            NumAltTitles = 0;
        }

        private int _getuserindex(ulong userid)
        {
            for (int i = 0; i < users.Length; i++)
            {
                if (users[i] != null)
                {
                    if (users[i].UserId == userid)
                        return i;
                }
            }
            return -1;
        }

        private SGUserInfo _getuser(ulong userId)
        {
            foreach (SGUserInfo u in users)
            {
                if (u != null)
                {
                    if (u.UserId == userId)
                        return u;
                }
            }
            return null;
        }

        public int GetUserCount()
        {
            int result = 0;

            for (int i = 0; i < users.Length; i++)
            {
                if (users[i] != null)
                {
                    result++;
                }
            }

            return result;
        }

		public SGUserInfo GetUser(ulong userId)
		{
			return GetUser(userId, false);
		}

        public SGUserInfo GetUser(ulong userId, bool mustExist)
        {
            SGUserInfo userInfo = _getuser(userId);
			if(null == userInfo && mustExist)
			{
				throw new Exception("UserId: " + userId.ToString("x") + " was not found for XboxId: " + XboxId.ToString("x"));
			}

			return userInfo;
        }

        public void AddUser( ulong userId, uint userFlags )
        {
            int idx = _getuserindex(userId);
			if(-1 == idx)
			{
                SGUserInfo userInfo = new SGUserInfo(userId, userFlags);
                for (int i = 0; i < users.Length; i++)
                {
                    if (users[i] == null)
                    {
                        users[i] = userInfo;
                        return;
                    }
                }
			}
			else
			{
                SGUserInfo userInfo = _getuser(userId);
				userInfo.UserFlags = userFlags;
                users[idx] = userInfo;
                return;
			}

            throw new Exception("Failed to Add UserId: " + userId.ToString("x") + ". No open slot found.");
        }

        // Title data can represent XBOX 1 title data or Xenon GI data, it is opaque to the SG
        // titleData is a static size array (xenon specifies 256 bytes)
        public void SetUserState(ulong userId, ulong matchSessionId, uint state, byte[] titleData, ushort titleDataLen)
        {
            SGUserInfo user = GetUser(userId, true);
            
            // update user state
            user.MatchSessionId   = matchSessionId;
            user.State            = state;
            user.TitleDataLen     = titleDataLen;
            user.TitleData        = titleData;

            users[_getuserindex(userId)] = user;
        }

        public void RemoveUser( ulong userId )
        {
            int idx = _getuserindex(userId);
            if (idx != -1)
            {
                users[idx] = null;
            }

        }

        public void ResetUser( ulong userId )
        {
            SGUserInfo user = GetUser(userId, true);
            
            user.QFlags       = 0; 
            user.QFlagSeqNum  = 0;
            user.Invites      = 0;
            user.InviteSeqNum = 0;

            users[_getuserindex(userId)] = user;
        }

        public uint GetUserQFlag( ulong userId )
        {
            SGUserInfo user = GetUser(userId, true);
            
            return user.QFlags;
        }

        public ushort GetUserInvites( ulong userId )
        {
            SGUserInfo user = GetUser(userId, true);

            return user.Invites;
        }

        public void LoadSGInfo( ref CSGInfo sgInfo )
        {
            sgInfo.inaSg = SgIp;
            sgInfo.SpiSg = Spi;

            sgInfo.machinePuid = XboxId;
            sgInfo.liNonce = Nonce;

            sgInfo.titleId      = TitleId;
            sgInfo.titleVersion = TitleVer;
            sgInfo.titleRegion  = TitleRegion;

            sgInfo.clientVersion = ClientVersion;
            sgInfo.SetClientType(ClientType);

            SGUserInfo userInfo;
            userInfo = users[0];
            if (userInfo != null)
            {
                sgInfo.userPuid0 = userInfo.UserId;
                sgInfo.userFlag0 = userInfo.UserFlags;
            }
            else
            {
                sgInfo.userPuid0 = 0;
                sgInfo.userFlag0 = 0; 
            }
            userInfo = users[1];
            if (userInfo != null)
            {
                sgInfo.userPuid1 = userInfo.UserId;
                sgInfo.userFlag1 = userInfo.UserFlags;
            }
            else
            {
                sgInfo.userPuid1 = 0;
                sgInfo.userFlag1 = 0;
            }
            userInfo = users[2];
            if (userInfo != null)
            {
                sgInfo.userPuid2 = userInfo.UserId;
                sgInfo.userFlag2 = userInfo.UserFlags;
            }
            else
            {
                sgInfo.userPuid2 = 0;
                sgInfo.userFlag2 = 0;
            }
            userInfo = users[3];
            if (userInfo != null)
            {
                sgInfo.userPuid3 = userInfo.UserId;
                sgInfo.userFlag3 = userInfo.UserFlags;
            }
            else
            {
                sgInfo.userPuid3 = 0;
                sgInfo.userFlag3 = 0;
            }
			
            sgInfo.altTitleId0 = AltTitles[0];
            sgInfo.altTitleId1 = AltTitles[1];
            sgInfo.altTitleId2 = AltTitles[2];
            sgInfo.altTitleId3 = AltTitles[3];
			
            sgInfo.SetKey( Key );

            sgInfo.UserExists = 1;
			sgInfo.languageID = (ushort)LanguageId;
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\StfTests\Feedback\Feedback\ICorThreadPool.cs ===
using System;
using System.Runtime.InteropServices;

namespace Feedback
{
	[
	// CLSID_CorRuntimeHost from MSCOREE.DLL
	Guid("CB2F6723-AB3A-11D2-9C40-00C04FA30A3E"),
	ComImport
	]
	public class CorRuntimeHost
	{
	}

	public class CLRThreadPool
	{
		public static ICorThreadPool Controller
		{
			get { return(thePool); }
		}

		private static ICorThreadPool thePool = (ICorThreadPool)new CorRuntimeHost();
	}

	// The ICorThreadpool interface is documented (prototypes only) in
	// mscoree.h, but is not made available from mscoree.tlb.  So the
	// following interop stub lets us get our hands on the interface
	// in order to query/control the CLR-managed thread pool.
	//
	// Because I'm only interested in adjusting the thread pool
	// configuration, most of the members are actually invalid and
	// cannot be called in their current form.
	//
	[
	// IID_ICorThreadpool
	Guid("84680D3A-B2C1-46e8-ACC2-DBC0A359159A"),
	InterfaceType(ComInterfaceType.InterfaceIsIUnknown)
	]
	public interface ICorThreadPool
	{
		void RegisterWaitForSingleObject(); // DO NOT CALL - INCORRECT STACK FRAME
		void UnregisterWait(); // DO NOT CALL - INCORRECT STACK FRAME
		void QueueUserWorkItem(); // DO NOT CALL - INCORRECT STACK FRAME
		void CreateTimer(); // DO NOT CALL - INCORRECT STACK FRAME
		void ChangeTimer(); // DO NOT CALL - INCORRECT STACK FRAME
		void DeleteTimer(); // DO NOT CALL - INCORRECT STACK FRAME
		void BindIoCompletionCallback(); // DO NOT CALL - INCORRECT STACK FRAME
		void CallOrQueueUserWorkItem(); // DO NOT CALL - INCORRECT STACK FRAME
		void SetMaxThreads( uint MaxWorkerThreads, uint MaxIOCompletionThreads );
		void GetMaxThreads( out uint MaxWorkerThreads, out uint MaxIOCompletionThreads );
		void GetAvailableThreads( out uint AvailableWorkerThreads, out uint AvailableIOCompletionThreads );
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\StfTests\Feedback\Feedback\AggregateReview.cs ===
using System;
using System.Threading;
using System.IO;
using System.Net;
using System.Text;
using ServerTestFramework;
using ServerTestFramework.LiveService;
using ServerTestFramework.LiveService.Feedback;
using ServerTestFramework.LiveService.Presence;
using ServerTestFramework.LiveService.PresNotiCommon;
using ServerTestFramework.LiveService.Achievement;
using xonline.common.config;

namespace Feedback
{
	/// <summary>
	/// Summary description for AggregateReview.
	/// </summary>
	public class AggregateReview : TestNode
	{
		public AggregateReview()
		{
            AddChild(new ValidUserWithNoReviews());
            AddChild(new ValidUserOneReviews());
            AddChild(new ValidUserOneReviewsAllType());
            AddChild(new ValidUserMultipleReviewsAllType());


            AddChild(new NegXRLUserAgent());
            AddChild(new NegXRLService());

            AddChild(new TCInvalidZeroPKT());
            AddChild(new TCInvalidSmallPKT());
            AddChild(new TCInvalidLargePKT());
		}

        [TestFrequency("Daily"), TestCasePriority(2)]
		public class ValidUserMultipleReviewsAllType : AggregateBase
		{
			protected override void Execute()
			{
				Random rand = new Random(100);
				PNUser user = getPNUser();
				Type PlayerReviewType = typeof(PlayerReview);
				foreach(string s in Enum.GetNames(PlayerReviewType))
				{
					uint ctype= (uint)Enum.Parse(PlayerReviewType,s);
					AddReview(user,ctype,rand.Next(10));
				}

                ExecuteAndVerify(user.UserId, 1);
			}
		}

        [TestFrequency("Daily"), TestCasePriority(2)]
		public class ValidUserOneReviewsAllType : AggregateBase
		{
			protected override void Execute()
			{
				Type PlayerReviewType = typeof(PlayerReview);
				PNUser user = getPNUser();
				foreach(string s in Enum.GetNames(PlayerReviewType))
				{
					uint ctype= (uint)Enum.Parse(PlayerReviewType,s);
					AddReview(user,ctype,1);
				}
					
				ExecuteAndVerify(user.UserId, 1);
			}
		}

        [TestFrequency("BVT"), TestCasePriority(1)]
		public class ValidUserOneReviews : AggregateBase
		{
			protected override void Execute()
			{
				PNUser user = getPNUser();
				AddReview(user,(uint)PlayerReview.Prefer,1);

                ExecuteAndVerify(user.UserId, 1);
			}
		}

        [TestFrequency("BVT"), TestCasePriority(1)]
		public class ValidUserWithNoReviews : AggregateBase
		{
			protected override void Execute()
			{
				ExecuteAndVerify(12345, 1);
			}
		}

        [TestFrequency("Regression"), TestCasePriority(3)]
		public class TCInvalidZeroPKT:TestBase
		{
			override protected void Execute()
			{
				InvalidFBRequest tmp = new InvalidFBRequest(0,"/fbserver/submitcomplaint.ashx");
				uint xerror= tmp.Execute();
				if(xerror != HResult.XONLINE_E_INVALID_REQUEST)
					throw new Exception("Invalid Xerror Expected :"+ HResult.E_FAIL+" recived:"+xerror);

				ResultCode=TEST_RESULTS.PASSED;
			}
		}

        [TestFrequency("Regression"), TestCasePriority(3)]
		public class TCInvalidSmallPKT:TestBase
		{
			override protected void Execute()
			{
				InvalidFBRequest tmp = new InvalidFBRequest(10,"/fbserver/submitcomplaint.ashx");
				uint xerror= tmp.Execute();
				if(xerror != HResult.XONLINE_E_INVALID_REQUEST)
					throw new Exception("Invalid Xerror Expected :"+ HResult.E_FAIL+" recived:"+xerror);

				ResultCode=TEST_RESULTS.PASSED;
			}
		}

        [TestFrequency("Regression"), TestCasePriority(3)]
		public class TCInvalidLargePKT:TestBase
		{
			override protected void Execute()
			{
				InvalidFBRequest tmp = new InvalidFBRequest(1000,"/fbserver/submitcomplaint.ashx");
				uint xerror= tmp.Execute();
				if(xerror != HResult.XONLINE_E_INVALID_REQUEST)
					throw new Exception("Invalid Xerror Expected :"+ HResult.E_FAIL+" recived:"+xerror);

				ResultCode=TEST_RESULTS.PASSED;
			}
		}

        [TestFrequency("Regression"), TestCasePriority(3)]
		public class NegXRLUserAgent : FeedbackTest
		{
			protected override void Execute()
			{
				MemoryStream		reqStream = new MemoryStream();
				BinaryWriter		bw = new BinaryWriter(reqStream);
				HttpWebRequest httpreq;
				HttpWebResponse response;
				Stream httpStream;

				// Construct valid request stream
				bw.Write(getRealUserPuid());
								
				// TEST: remove ContentType so XRL is rejected
				// Create and HTTP request and add headers
				string url= "http://"+Global.XEnv.GetVirtualInterface(VirtualInterface.fbserver).Address.ToString()+":"+ Global.XEnv.GetVirtualInterface(VirtualInterface.fbserver).Port.ToString()+"/fbserver/submitcomplaint.ashx";
				httpreq = (HttpWebRequest) WebRequest.Create(url);
				httpreq.Method = "POST";
				httpreq.ProtocolVersion = HttpVersion.Version10;
				httpreq.Headers.Add("Relja: true");
				httpreq.ContentType = "xon/8";
				httpreq.ContentLength = reqStream.Length;

				// attach the request data we wrote to the HTTP request
				httpStream = httpreq.GetRequestStream();
				reqStream.WriteTo(httpStream);
				httpStream.Close();

				httpreq.Timeout = 2000;

				try
				{
					response = (HttpWebResponse) httpreq.GetResponse();
				}
				catch( System.Net.WebException e )
				{
					// GetResponse() throws exception on HTTP 500
					response = (HttpWebResponse) e.Response;
					if ( (response != null) && (response.StatusCode == HttpStatusCode.InternalServerError) )
					{
						ResultCode=TEST_RESULTS.PASSED;
						return;
					}
				}

				// FAILED -- either request succeeded unexpectedly or we got back the wrong code
				if ( response != null )
					Global.RO.Error("\nRESPONSE: " + response.StatusCode.ToString() + " " + response.GetResponseHeader("XErr") );
			}
		}

        [TestFrequency("Regression"), TestCasePriority(3)]
		public class NegXRLService : FeedbackTest
		{
			protected override void Execute()
			{
				MemoryStream		reqStream = new MemoryStream();
				BinaryWriter		bw = new BinaryWriter(reqStream);
				HttpWebRequest httpreq;
				HttpWebResponse response;
				Stream httpStream;

				// Construct valid request stream
				bw.Write(getRealUserPuid());
				
				// TEST: remove ContentType so XRL is rejected
				// Create and HTTP request and add headers
				string url= "http://"+Global.XEnv.GetVirtualInterface(VirtualInterface.fbserver).Address.ToString()+":"+ Global.XEnv.GetVirtualInterface(VirtualInterface.fbserver).Port.ToString()+"/fbserver/submitcomplaint.ashx";
				httpreq = (HttpWebRequest) WebRequest.Create(url);
				httpreq.Method = "POST";
				httpreq.ProtocolVersion = HttpVersion.Version10;
				httpreq.Headers.Add("Relja: true");
				httpreq.UserAgent = "8/0.10.4715";
				httpreq.ContentLength = reqStream.Length;

				// attach the request data we wrote to the HTTP request
				httpStream = httpreq.GetRequestStream();
				reqStream.WriteTo(httpStream);
				httpStream.Close();

				httpreq.Timeout = 2000;

				try
				{
					response = (HttpWebResponse) httpreq.GetResponse();
				}
				catch( System.Net.WebException e )
				{
					// GetResponse() should throw 404 here
					response = (HttpWebResponse) e.Response;
					if ( (response != null) && (response.StatusCode == HttpStatusCode.NotFound) )
					{
						ResultCode=TEST_RESULTS.PASSED;
						return;
					}
				}

				// FAILED -- either request succeeded unexpectedly or we got back the wrong code
				if ( response != null )
					Global.RO.Error("\nRESPONSE: " + response.StatusCode.ToString() + " " + response.GetResponseHeader("XErr") );
			}
		}
	}

	abstract public class AggregateBase : XeFeedbackTest
	{
		public void AddReview(PNUser user , uint type,int count)
		{
			for (int i=0;i<count;i++)
				SendReviewAndVerify(getPNUser(),user,50,type,getContext(),1);
		}

		public void AddReview(PNUser user , uint type,int count,bool VerifyRating)
		{
			for (int i=0;i<count;i++)
				SendReviewAndVerify(getPNUser(),user,50,type,getContext(),1,Modify.None,VerifyRating);
		}

		public void ExecuteAndVerifyRating(ulong puid, double low , double high)
		{
			double Rating = FeedbackWS.GetRating(puid);
			if(Rating <low || Rating >high)
				throw new Exception("Rating out of range ("+ low +"-"+high+" ) Rating ="+Rating);
			ResultCode = TEST_RESULTS.PASSED;
		}

		public void ExecuteAndVerify(ulong puid, uint ExpectedError)
		{
			GetAggregateReviewsRequest req= new GetAggregateReviewsRequest(puid);
			GetAggregateReviewsReply resp = req.Execute();

			if(HResult.Succeeded(resp.hr))
				VerifyReview(puid, resp);
			else if(resp.hr!= ExpectedError)
				throw new Exception("unexpected Error Expected "+ ExpectedError+" Recived "+resp.hr);

			ResultCode = TEST_RESULTS.PASSED;
		}

		public void VerifyReview(ulong user ,GetAggregateReviewsReply resp)
		{
			Type PlayerReviewType = typeof(PlayerReview);
			foreach(string s in Enum.GetNames(PlayerReviewType))
			{
				uint ctype= (uint)Enum.Parse(PlayerReviewType,s);
					
				int AggCount =FeedbackWS.GetAggCount(user,ctype);
				bool found =false;

				for(int j=0;j<resp.cReviews;j++)
				{
					if(resp.aggReviews[j].type==ctype)
					{
						if(resp.aggReviews[j].count!=AggCount)
							throw new Exception( "Mismatched AggCount for type "+ ctype +"Expected "+AggCount+" Recived "+resp.aggReviews[j].count);

				        found = true;
					}
						
				}

				if(!found && AggCount!=0)
					throw new Exception( "Mismatched AggCount for type "+ ctype +"Expected 0 Recived "+AggCount);
			}
		}
	}

}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\StfTests\Feedback\Feedback\StressFeedback.cs ===
using System;
using System.Net;
using System.Threading;
using ServerTestFramework;
using ServerTestFramework.LiveService;
using ServerTestFramework.LiveService.Feedback;
using ServerTestFramework.Utilities;
using ServerTestFramework.Database;

namespace Feedback.Stress
{

	

	public class XPresListener : XHttpListener
	{
		public XPresListener (int listenPort,int delay,int maxConn):base(listenPort,delay,maxConn)
		{
			uint	maxWorkerThreads, maxIOThreads;
			ICorThreadPool tp = CLRThreadPool.Controller;
			tp.GetMaxThreads(out maxWorkerThreads, out maxIOThreads);
			maxWorkerThreads = maxWorkerThreads * 10;
			maxIOThreads = maxIOThreads * 2;
			tp.SetMaxThreads(maxWorkerThreads,maxIOThreads);
		}
	}

	

	public class StressSupport
	{
		public const int PresencePort = 100;
		public static IPEndPoint PresEndPoint= null;
		public static XPresListener PresListener = new XPresListener(PresencePort,-1,-1);
		public class ScrollingWindow
		{
			public int windowstart=0;
			public int CurrentUser=0;
		}

		static private ScrollingWindow Users = new ScrollingWindow();
		static protected Timer tmr =new Timer(new TimerCallback(StressSupport.RotateUsers), null,60000, 60000);

		public static void RotateUsers(Object state)
		{
			
			lock(Users)
			{
				int tmp = (int)(Users.windowstart+ windowsize+ NoOFUsersToRotatePerMin);
				if(tmp < (int)NoofUsers)
				{
					Users.windowstart=Users.windowstart+NoOFUsersToRotatePerMin;

				}
				else
					Users.windowstart=0;

			}
			
			Global.RO.Info("Rotating users current window start index = "+Users.windowstart);
		}

		static public int windowsize=4000;
		static public int NoOFUsersToRotatePerMin= 100;
		
		public static RandomEx rand = new RandomEx();
		public static BulkUserSet Userset =new BulkUserSet("FB", 2533274790509675, 200000); 
		public static int NoofUsers = 200000;
		public static void loadUsers()
		{
			// go to all UODb servers and disable constrain.
			//

			// use below 2 lines if  using fake users 
			FeedbackWS.prepareforStress();
			Userset.Base= 0x0009cff000000;
			Userset.Count= (uint)NoofUsers;

			// user below line for real users.
			// UodbWS.CreateBulkUsers("FB",(uint)NoofUsers , out Userset);
			
			

            Thread td = ThreadMaker.CreateThread(StressSupport.modifyGamesPlayed);
			td.Start();
		}

		public static void modifyGamesPlayed()
		{

			

			for(int i=0;i<NoofUsers;i++)
			{
				ulong user =	Userset.IndexToPuid((uint)i); 
				FeedbackWS.AddRatingData(user,1000,2000,0);
				Thread.Sleep(20);
			}
		}

		public static ulong  GetNextUser()
		{
			return 	Userset.IndexToPuid((uint)rand.Next(Users.windowstart,Users.windowstart+windowsize));
			//return (StartUser+(uint)rand.Next(Users.windowstart,Users.windowstart+windowsize));

		}
	}
	/// <summary>
	/// Summary description for StressFeedback.
	/// </summary>
    [StressInstantiate]
	public class Feedback : TestBase
	{
		protected override void Execute()
		{
			XrlFeedback request=new XrlFeedback();
			request.FeedbackType=(byte) RandomEx.GlobalRandGen.Next(0,6);
			
			request.SenderPuid=StressSupport.GetNextUser();
			request.TargetPuid=StressSupport.GetNextUser();
			while(request.SenderPuid==request.TargetPuid)
				request.TargetPuid=StressSupport.GetNextUser();
			
			request.Nickname="DoesntMatter";
			if (!request.Execute())				return;

			ResultCode=TEST_RESULTS.PASSED;
		}
	}

    [StressInstantiate]
	public class Complaint : TestBase
	{
		protected override void Execute()
		{
			FeedbackReq tmp = new FeedbackReq();
			ulong spuid =StressSupport.GetNextUser();
			ulong tpuid =StressSupport.GetNextUser();
			while(spuid==tpuid)
				tpuid =StressSupport.GetNextUser();

			tmp.SendComplaint(spuid,tpuid,501,(uint)StressSupport.rand.Next(0,8),0);
			ResultCode=TEST_RESULTS.PASSED;
		}
	}

    [StressInstantiate]
	public class XeFeedback : TestBase
	{
		protected override void Execute()
		{

			FeedbackReq tmp = new FeedbackReq();
			ulong spuid =StressSupport.GetNextUser();
			ulong tpuid =StressSupport.GetNextUser();
			while(spuid==tpuid)
				tpuid =StressSupport.GetNextUser();
			
			
			SubmitReview req = new  SubmitReview(spuid,tpuid,501,(uint)StressSupport.rand.Next(0,8),0);
			req.AlternatePresenceDestination=StressSupport.PresEndPoint;
			Response resp = req.Execute();
			if(!HResult.Succeeded(resp.Xerr))
				throw new Exception("request failed with Error " + resp.Xerr);
			ResultCode=TEST_RESULTS.PASSED;
		}
	}

    [StressInstantiate]
	public class AggregateReviews : TestBase
	{
		protected override void Execute()
		{

			GetAggregateReviewsRequest req= new GetAggregateReviewsRequest(StressSupport.GetNextUser());
			GetAggregateReviewsReply resp = req.Execute();

			if(!HResult.Succeeded(resp.hr))
				throw new Exception("request failed with Error " + resp.hr);
			
			ResultCode=TEST_RESULTS.PASSED;
		}
	}



	
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\StfTests\Feedback\Feedback\obj\i386\_generated.cs ===
[assembly:System.Runtime.InteropServices.ComVisible(false)]
[assembly:System.Reflection.AssemblyVersion("12.4.56.0")]
[assembly:System.Reflection.AssemblyProduct("Microsoft(R) Xbox(TM)")]
[assembly:System.Reflection.AssemblyCopyright("Copyright (c) Microsoft Corporation. All rights reserved.")]
[assembly:System.Reflection.AssemblyCompany("Microsoft Corporation")]
[assembly:System.Reflection.AssemblyFileVersion("12.4.56.0")]
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\StfTests\Feedback\Feedback\RatingCal.cs ===
using System;
using System.Threading;
using System.IO;
using System.Net;
using System.Text;
using ServerTestFramework;
using ServerTestFramework.LiveService;
using ServerTestFramework.LiveService.Feedback;
using ServerTestFramework.LiveService.Presence;
using ServerTestFramework.LiveService.PresNotiCommon;
using ServerTestFramework.LiveService.Achievement;
using xonline.common.config;

namespace Feedback
{
    /// <summary>
    /// Summary description for RatingCal.
    /// </summary>
    public class RatingCal : TestNode
    {
        public RatingCal()
        {
            AddChild(new NoFeedback());

            AddChild(new OnePrefer());
            AddChild(new OneAvoid());
            AddChild(new OneActivity());
            AddChild(new ActivityOnly());
            AddChild(new OneStar());
            AddChild(new FiveStar());
            AddChild(new TwoStar());
            AddChild(new ThreeStar());
            AddChild(new FourStar());
            AddChild(new SwitchBtwPosNeg());
			
            //  test for a single user with one positive and negative test. with diff coeff.
            AddChild(new CoEffRange());
            AddChild(new CoEffSlope());
            AddChild(new CoEffBias());
            AddChild(new CoEffreviewIgnoreThreshold());
            AddChild(new CoEffDcay());
            AddChild(new CoEffPositive());
            AddChild(new CoEffNegative());
        }

        [TestFrequency("Regression"), TestCasePriority(3)]
		public class CoEffreviewIgnoreThreshold : CoEffTestBase
		{
			public CoEffreviewIgnoreThreshold()
			{
				setting=xonline.common.config.Setting.feedback_reviewIgnoreThreshold;
				settingval=".80";
			}
			public override void Verify(ConfigInfo srvCfgInfo,string OldSettingVal)
			{
				base.Verify(srvCfgInfo,OldSettingVal);
				ulong context=XeFeedbackTest.getContext();
				ulong targetPUID= XeFeedbackTest.getRealUserPuid();
				ulong senderPUID= XeFeedbackTest.getRealUserPuid();
				
				
				// set the games played and total playes such that the 
				FeedbackWS.AddRatingData(senderPUID,10,20,15);
			
				string[] server= null;;
				server = Global.XEnv.GetServerListByComponent(component);
				IInterfaceInfo tmp =Config.GetInterface(server[0],xonline.common.config.Interface.fbserver);
				IPEndPoint fbsrv = new IPEndPoint(tmp.IPAddress,tmp.Port);

				SubmitReview req = new  SubmitReview(senderPUID,XeFeedbackTest.getRealUserPuid(),50,(uint)PlayerReview.AvoidUnskilled,XeFeedbackTest.getContext());
				Response resp = req.Execute(fbsrv);

				if(HResult.Failed(resp.Xerr))
					throw new Exception(" fail to send review");

				SubmitReview req2 = new  SubmitReview(senderPUID,XeFeedbackTest.getRealUserPuid(),50,(uint)PlayerReview.AvoidUnskilled,XeFeedbackTest.getContext());
				Response resp2 = req2.Execute(fbsrv);

				if(!HResult.Failed(resp2.Xerr))
					throw new Exception(" fail to send review");
			}
		}

        [TestFrequency("BVT"), TestCasePriority(1)]
		public class CoEffDcay : CoEffTestBase
		{
			public CoEffDcay()
			{
				setting=xonline.common.config.Setting.feedback_ratingDecayFactor;
				settingval=".1";
			}
			public override void Verify(ConfigInfo srvCfgInfo,string OldSettingVal)
			{
				base.Verify(srvCfgInfo,OldSettingVal);
				
				double Rating = FeedbackWS.GetRating(TargetPuid);
				System.Console.WriteLine("old rating was  " +Rating);

				FeedbackWS.AddRatingData(TargetPuid,2,2,0);
				AddReview(TargetPuid,(uint)PlayerReview.AvoidTooGood,1);
				ExecuteAndVerifyRating(TargetPuid, Rating+5,100);
			}
		}

        [TestFrequency("BVT"), TestCasePriority(1)]
		public class CoEffNegative : CoEffTestBase
		{
			public CoEffNegative()
			{
				setting=xonline.common.config.Setting.feedback_coeffNegativeReview;
				settingval="70";
			}
			public override void Verify(ConfigInfo srvCfgInfo,string OldSettingVal)
			{
				base.Verify(srvCfgInfo,OldSettingVal);
				
				double Rating = FeedbackWS.GetRating(TargetPuid);
				System.Console.WriteLine("old rating was  " +Rating);

				AddReview(TargetPuid,(uint)PlayerReview.AvoidTooGood,1);
				ExecuteAndVerifyRating(TargetPuid, 0,Rating-1);
			}
		}

        [TestFrequency("BVT"), TestCasePriority(1)]
		public class CoEffPositive : CoEffTestBase
		{
			public CoEffPositive()
			{
				setting=xonline.common.config.Setting.feedback_coeffPositiveReview;
				settingval="30";
			}
			public override void Verify(ConfigInfo srvCfgInfo,string OldSettingVal)
			{
				base.Verify(srvCfgInfo,OldSettingVal);
				
				double Rating = FeedbackWS.GetRating(TargetPuid);
				System.Console.WriteLine("old rating was  " +Rating);
				AddReview(TargetPuid,(uint)PlayerReview.AvoidTooGood,1);
				ExecuteAndVerifyRating(TargetPuid, Rating-1,85);
			}
		}

        [TestFrequency("BVT"), TestCasePriority(1)]
		public class CoEffBias : CoEffTestBase
		{
			public CoEffBias()
			{
				setting=xonline.common.config.Setting.feedback_coeffBias;
				settingval=".20";
			}
			public override void Verify(ConfigInfo srvCfgInfo,string OldSettingVal)
			{
				base.Verify(srvCfgInfo,OldSettingVal);
				AddReview(TargetPuid,(uint)PlayerReview.AvoidTooGood,1);
				ExecuteAndVerifyRating(TargetPuid, 90,100);
			}
		}

        [TestFrequency("BVT"), TestCasePriority(1)]
		public class CoEffSlope : CoEffTestBase
		{
			public CoEffSlope()
			{
				setting=xonline.common.config.Setting.feedback_coeffSlope;
				settingval="20";
			}
			public override void Verify(ConfigInfo srvCfgInfo,string OldSettingVal)
			{
				base.Verify(srvCfgInfo,OldSettingVal);
				AddReview(TargetPuid,(uint)PlayerReview.AvoidTooGood,1);
				ExecuteAndVerifyRating(TargetPuid, 65,75);
			}
		}

        [TestFrequency("BVT"), TestCasePriority(1)]
		public class CoEffRange : CoEffTestBase
		{
			public CoEffRange() : base()
			{
				setting=xonline.common.config.Setting.feedback_coeffRange;
				settingval="50";
			}
			public override void Verify(ConfigInfo srvCfgInfo,string OldSettingVal)
			{
				base.Verify(srvCfgInfo,OldSettingVal);
				AddReview(TargetPuid,(uint)PlayerReview.AvoidTooGood,1);
				ExecuteAndVerifyRating(TargetPuid, 25,32);
			}
		}

        [TestFrequency("BVT"), TestCasePriority(1)]
		public class CoEffTestBase : ConfigTestBase
		{
			public static ulong TargetPuid= 0;
            
            public CoEffTestBase()
            {
                component = xonline.common.config.Component.fbserver;
            }

			public override void Initialize()
			{
				if(TargetPuid ==0)
				{
					TargetPuid = XeFeedbackTest.getRealUserPuid();
					FeedbackWS.AddRatingData(TargetPuid,2,2,0);
					AddReview(TargetPuid,(uint)PlayerReview.Prefer,1);
					AddReview(TargetPuid,(uint)PlayerReview.AvoidDisconnect,1);
				}
			}
			

			public void AddReview(ulong user , uint type,int count)
			{
				// this only send request to 1 server 

				//string[] server= null;;
				//server = Global.XEnv.GetServerListByComponent(component);
				//IInterfaceInfo tmp = Config.GetInterface(server[0],xonline.common.config.Interface.fbserver);
				//IPEndPoint fbsrv = new IPEndPoint(tmp.IPAddress,tmp.Port);

                IPEndPoint fbsrv = Global.XEnv.GetVirtualInterface(VirtualInterface.fbserver);

				SubmitReview req = new  SubmitReview(XeFeedbackTest.getRealUserPuid(),user,50,type,XeFeedbackTest.getContext());
				Response resp = req.Execute(fbsrv);

				if(HResult.Failed(resp.Xerr))
					throw new Exception(" fail to send review");
			}

			
			public void ExecuteAndVerifyRating(ulong puid, double low , double high)
			{
				Thread.Sleep(3000);
				double Rating = FeedbackWS.GetRating(puid);
				if(Rating <low || Rating >high)
					throw new Exception("Rating out of range (" + low + "-" + high + " ) Rating =" + Rating);
				ResultCode = TEST_RESULTS.PASSED;
			}
		}

        [TestFrequency("Daily"), TestCasePriority(2)]
		public class FiveStar : AggregateBase
		{
			protected override void Execute()
			{
				PNUser user = getPNUser();
				FeedbackWS.AddRatingData(user.UserId,40,100,0);
				AddReview(user,(uint)PlayerReview.Prefer,50,false);
				ExecuteAndVerifyRating(user.UserId, 90,100);
			}
		}

        [TestFrequency("Daily"), TestCasePriority(2)]
		public class FourStar : AggregateBase
		{
			protected override void Execute()
			{
				PNUser user = getPNUser();
				FeedbackWS.AddRatingData(user.UserId,10,30,0);
				AddReview(user,(uint)PlayerReview.Prefer,20,false);
				ExecuteAndVerifyRating(user.UserId, 70,80);
			}
		}

        [TestFrequency("Daily"), TestCasePriority(2)]
		public class ThreeStar : AggregateBase
		{
			protected override void Execute()
			{
				PNUser user = getPNUser();
				FeedbackWS.AddRatingData(user.UserId,10,20,0);
				AddReview(user,(uint)PlayerReview.AvoidTrashTalk,7,false);
				ExecuteAndVerifyRating(user.UserId, 40,60);
			}
		}

        [TestFrequency("Daily"), TestCasePriority(2)]
		public class TwoStar : AggregateBase
		{
			protected override void Execute()
			{
				PNUser user = getPNUser();
				FeedbackWS.AddRatingData(user.UserId,10,10,0);
				AddReview(user,(uint)PlayerReview.AvoidTrashTalk,10,false);
				ExecuteAndVerifyRating(user.UserId, 20,40);
			}
		}

        [TestFrequency("Daily"), TestCasePriority(2)]
		public class OneStar : AggregateBase
		{
			protected override void Execute()
			{
				PNUser user = getPNUser();
				FeedbackWS.AddRatingData(user.UserId,10,2,0);
				AddReview(user,(uint)PlayerReview.AvoidTrashTalk,20,false);
				ExecuteAndVerifyRating(user.UserId, 0,20);
			}
		}

        [TestFrequency("BVT"), TestCasePriority(1)]
		public class ActivityOnly : AggregateBase
		{
			protected override void Execute()
			{
				PNUser user = getPNUser();
				FeedbackWS.AddRatingData(user.UserId,1,1,0);
				AddReview(user,(uint)PlayerReview.AvoidTooGood,1,false);
				ExecuteAndVerifyRating(user.UserId, 55,65);
			}
		}

        [TestFrequency("BVT"), TestCasePriority(1)]
		public class OneActivity : AggregateBase
		{
			protected override void Execute()
			{
				PNUser user = getPNUser();
			    FeedbackWS.AddRatingData(user.UserId,2,2,0);
				AddReview(user,(uint)PlayerReview.AvoidLanguage,1,false);
				ExecuteAndVerifyRating(user.UserId, 50,60);
				AddReview(user,(uint)PlayerReview.AvoidUnskilled,1,false);
				ExecuteAndVerifyRating(user.UserId, 50,60);
			}
		}

        [TestFrequency("BVT"), TestCasePriority(1)]
		public class OneAvoid : AggregateBase
		{
			protected override void Execute()
			{
				PNUser user = getPNUser();
				FeedbackWS.AddRatingData(user.UserId,1,1,0);
				AddReview(user,(uint)PlayerReview.AvoidAggressive,1,false);
				ExecuteAndVerifyRating(user.UserId, 50,60);
			}
		}

        [TestFrequency("Daily"), TestCasePriority(2)]
		public class SwitchBtwPosNeg : AggregateBase
		{
			protected override void Execute()
			{
				ulong Target = getRealUserPuid();
				FeedbackWS.AddRatingData(Target,1,1,0);
				ulong Sender =getRealUserPuid();
				for( int i=0;i<5;i++)
				{

					SubmitReview req = new  SubmitReview(Sender,Target,50,(uint)PlayerReview.Prefer,getContext());
					Response resp = req.Execute();
					if(HResult.Failed(resp.Xerr)) throw new Exception("Unexpected Error returned by server XERROR= "+resp.Xerr);
					ExecuteAndVerifyRating(Target, 55,65);
					SubmitReview req2 = new  SubmitReview(Sender,Target,50,(uint)PlayerReview.AvoidAggressive,getContext());
					Response resp2 = req2.Execute();
					if(HResult.Failed(resp2.Xerr)) throw new Exception("Unexpected Error returned by server XERROR= "+resp2.Xerr);
					
					ExecuteAndVerifyRating(Target, 55,65);
				}
			}
		}

        [TestFrequency("BVT"), TestCasePriority(1)]
		public class NoFeedback : AggregateBase
		{
			protected override void Execute()
			{
				PNUser user = getPNUser();
				ExecuteAndVerifyRating(user.UserId, 0,0);
			}
		}

        [TestFrequency("BVT"), TestCasePriority(1)]
		public class OnePrefer : AggregateBase
		{
			protected override void Execute()
			{
				PNUser user = getPNUser();
				FeedbackWS.AddRatingData(user.UserId,1,1,0);
				AddReview(user,(uint)PlayerReview.Prefer,1,false);
				ExecuteAndVerifyRating(user.UserId, 55,65);
			}
		}
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\StfTests\Feedback\Feedback\obj\i386\_asmid.inc ===
ASSEMBLY_IDENTITY_KEY_FORM=msil_feedback_none_12.4.56.0_none_9e2c6ed03a131a94
ASSEMBLY_IDENTITY_XP_KEY_FORM=msil_feedback_no-public-key_12.4.56.0_x-ww_f5c5aac8
ASSEMBLY_IDENTITY_CULTURE=
ASSEMBLY_IDENTITY_NAME=feedback
ASSEMBLY_IDENTITY_PROCESSOR_ARCHITECTURE=msil
ASSEMBLY_IDENTITY_PUBLIC_KEY=
ASSEMBLY_IDENTITY_PUBLIC_KEY_TOKEN=
ASSEMBLY_IDENTITY_TYPE=
ASSEMBLY_IDENTITY_TYPE_NAME=
ASSEMBLY_IDENTITY_VERSION=12.4.56.0
XP_KEY_FORM=msil_feedback_no-public-key_12.4.56.0_x-ww_f5c5aac8
XP_MANIFEST_DIRECTORY=manifests
XP_MANIFEST_NAME=msil_feedback_no-public-key_12.4.56.0_x-ww_f5c5aac8.manifest
XP_MANIFEST_PATH=manifests\msil_feedback_no-public-key_12.4.56.0_x-ww_f5c5aac8.manifest
XP_CATALOG_DIRECTORY=manifests
XP_CATALOG_NAME=msil_feedback_no-public-key_12.4.56.0_x-ww_f5c5aac8.cat
XP_CATALOG_PATH=manifests\msil_feedback_no-public-key_12.4.56.0_x-ww_f5c5aac8.cat
XP_PAYLOAD_PATH=msil_feedback_no-public-key_12.4.56.0_x-ww_f5c5aac8
_DELAY_SIGN=0
!if [set _ASMIDTOATTRIBS_TLBIMP=]
!endif
CODESIGN_TESTKEY=
_TLBIMP_FLAGS=$(_TLBIMP_FLAGS)  /asmversion:12.4.56.0
_ASSEMBLY_IDENTITY=feedback,processorArchitecture=msil,version=12.4.56.0,publicKeyToken=neutral
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\StfTests\Feedback\Feedback\objd\i386\_generated.cs ===
[assembly:System.Runtime.InteropServices.ComVisible(false)]
[assembly:System.Reflection.AssemblyVersion("12.4.56.0")]
[assembly:System.Reflection.AssemblyProduct("Microsoft(R) Xbox(TM)")]
[assembly:System.Reflection.AssemblyCopyright("Copyright (c) Microsoft Corporation. All rights reserved.")]
[assembly:System.Reflection.AssemblyCompany("Microsoft Corporation")]
[assembly:System.Reflection.AssemblyFileVersion("12.4.56.0")]
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\StfTests\Feedback\Feedback\MainClass.cs ===
using System;
using System.IO;
using System.Net;
using ServerTestFramework;
using ServerTestFramework.Utilities;
using ServerTestFramework.LiveService;
using xonline.common.config;
using ServerTestFramework.LiveService.Feedback;
using ServerTestFramework.Database;
using Feedback.Stress;
using System.Text;
using System.Threading;
using ServerTestFramework.LiveService.Presence;
using ServerTestFramework.LiveService.PresNotiCommon;
using System.Xml;

[assembly: RootNode(typeof(Feedback.Feedback))]

namespace Feedback
{
	/// <summary>
	/// Feedback ServertTestFramework Suite
	/// </summary>
	///
	public enum FeedbackType
	{
		NEG_NICKNAME,
		NEG_GAMEPLAY,
		NEG_SCREAMING,
		NEG_HARASSMENT,
		NEG_LEWDNESS,
		POS_ATTITUDE,
		POS_SESSION,
		STATS1,		// these are allowed per fbserver.ini, but not really defined by fbserver
		STATS2,
		STATS3,
		MAXFEEDBACKTYPE=20,
		XONLINE_FEEDBACK_DATA_MACHINE = 255
	}

    [Owner("codyluit")]
	public class Feedback : ServerTestFramework.TestNode
	{
        public override void PreRun(RUN_TYPE runType)
        {
            if (runType != RUN_TYPE.STRESS)
            {
                return;
            }

			//
			Stress.StressSupport.loadUsers();
			StressSupport.PresListener.Go();
			

			IPAddress myIp=null;
			LocalInterface.GetBestMatch(Global.XEnv.GetVirtualInterface(VirtualInterface.fbserver), out myIp);
			StressSupport.PresEndPoint = new IPEndPoint(myIp,StressSupport.PresencePort);
			
		}

        override public void PostRun(RUN_TYPE runType)
        {
            if (runType != RUN_TYPE.STRESS)
            {
                return;
            }

			StressSupport.PresListener.Stop();
		}

		public Feedback()
		{
			//functional
            AddChild(new BugRepor());
            AddChild(new FuncTests());
            AddChild(new FuncReviewTests());
            AddChild(new FuncComplaintTests());
            AddChild(new AggregateReview());
            AddChild(new RatingCal());
            AddChild(new CleanUPJob());

            //stress
            AddChild(new Stress.Feedback(), false, true);
            AddChild(new Stress.Complaint(), false, true);
            AddChild(new Stress.XeFeedback(), false, true);
            AddChild(new Stress.AggregateReviews(), false, true);
            //AddChild(new Stress.TOU(), false, true);
            //AddChild(new Stress.MessageOfDay(), false, true);
		}
	}

	
	abstract public class FeedbackTest : TestBase
	{
		//static long SenderPuididx=0;
		//static long TargetPuididx=0;
		//TODO : get max value from fbserver.ini?  This is where fbserver pulls the value
		public static ulong  getRealUserPuid()
		{
			FriendsCommon fc = new FriendsCommon();

			PNUser User = fc.CreateUser(true);

			return User.UserId;
		}

		
		public static ulong  getSenderPuid()
		{
			return getRealUserPuid();
		}
		public static ulong  getTargetPuid()
		{
			return getRealUserPuid();
		}

		public void LogRequest(XrlFeedback request)
		{
			ConsoleX.WriteLine("\nFEEDBACK: " +
				request.FeedbackType.ToString() + " " +
				request.SenderPuid + " " +
				request.TargetPuid + " " +
				request.TitleID + " " +
				request.NicknameLen + " " +
				request.Nickname);
		}

		public static  void Verify(XrlFeedback request)
		{
			FeedbackWS.verifyFeedback((long)request.SenderPuid,(long)request.TargetPuid,(int)request.TitleID,request.FeedbackType,request.Nickname);
		}
		public void DoPosTest(FeedbackType type, ulong senderPuid, ulong targetPuid, uint titleID, string nickname )
		{
			_DoPosTest( type,  senderPuid,  targetPuid,  titleID,  nickname );
			ResultCode=TEST_RESULTS.PASSED;
		}

		public static  void _DoPosTest(FeedbackType type, ulong senderPuid, ulong targetPuid, uint titleID, string nickname )
		{
			XrlFeedback request = new XrlFeedback();

			request.FeedbackType = (byte) type;
			request.SenderPuid = senderPuid;
			request.TargetPuid= targetPuid;
			request.TitleID = titleID;

			if ( nickname != null )
			{
				request.Nickname = nickname;
				request.NicknameLen = (byte) nickname.Length;
			}
			else
			{
				request.Nickname = "";
				request.NicknameLen = 0;
			}

			if (!request.Execute())
			{
				// log failure seperately?
				return;
			}

			//verify  data
			Verify(request);

			
		}

		// send nickname Len to accomodate tests where they are mismatched
		public void DoPosTestEx(FeedbackType type, ulong senderPuid, ulong targetPuid, uint titleID, string nickname, byte nickLength )
		{
			XrlFeedback request = new XrlFeedback();

			request.FeedbackType = (byte) type;
			request.SenderPuid = senderPuid;
			request.TargetPuid= targetPuid;
			request.TitleID = titleID;

			request.Nickname = nickname;
			request.NicknameLen = nickLength;

			if (!request.Execute())
			{
				// log failure seperately?
				return;
			}

			//verify data 
			Verify(request);

			ResultCode=TEST_RESULTS.PASSED;
		}


		public void DoNegReq(byte type, ulong senderPuid, ulong targetPuid, uint titleID, string nickname, byte nickLength, HttpStatusCode httpCheck, uint xErrCheck, bool logRequest )
		{
			XrlFeedback request = new XrlFeedback();

			request.FeedbackType = type;
			request.SenderPuid = senderPuid;
			request.TargetPuid= targetPuid;
			request.TitleID = titleID;

			request.Nickname = nickname;  // null should be OK here
			request.NicknameLen = nickLength;

			if (request.Execute())
			{
				// This is a NEG test, should fail (this is somewhat redundant to check below)
				//ConsoleX.WriteLine("\nUnexpected success: " + request.GetDumpString());
				//return;
				Verify(request);
			}

			//check expected return values
			if ( (request.httpStatus != httpCheck) || (request.XErr != xErrCheck))
			{
				ConsoleX.WriteLine("\nExpected: " + httpCheck.ToString() + " " + xErrCheck + "\nReturned: " + request.httpStatus + " " + request.XErr);
				return;
			}

			if ( logRequest )
			{
				LogRequest(request);
			}

			ResultCode=TEST_RESULTS.PASSED;
		}

	}


	public class CleanUPJob:TestNode
	{
		public  CleanUPJob()
		{
			AddChild(new MainLine());
		}

        [TestFrequency("BVT"), TestCasePriority(1)]
		public class MainLine : TestBase
		{
			protected override void Execute()
			{
                PNUser TargetPNUser = XeFeedbackTest.getPNUser();
                ulong Targetuser = TargetPNUser.UserId;
				// xbox1 feedback
				FeedbackTest._DoPosTest(FeedbackType.NEG_SCREAMING,XeFeedbackTest.getRealUserPuid(),Targetuser,1234,"test");
				// 360 compaint
				XeFeedbackTest.SendComplaintAndVerify(XeFeedbackTest.getRealUserPuid(), Targetuser,50,(uint)ComplaintType.OffensiveGamertag,XeFeedbackTest.getContext(),HResult.S_OK);
				// 360 review 
                XeFeedbackTest.SendReviewAndVerify(XeFeedbackTest.getPNUser(), TargetPNUser, (uint)123, (uint)PlayerReview.AvoidTooGood, XeFeedbackTest.getContext(), HResult.S_OK, Modify.None);

				FeedbackWS.ClearFeedbackAndVerify(Targetuser);

				ResultCode=TEST_RESULTS.PASSED;
			}
		}
	}

	public class BugRepor:TestNode
	{
		public  BugRepor()
		{
			AddChild(new Unicodenickname());
			//AddChild(new UnicodenicknameEx());
			AddChild(new GoodReq());
		}

        [TestFrequency("BVT"), TestCasePriority(1)]
		public class GoodReq : TestBase
		{
			protected override void Execute()
			{
				ushort maxint = 0;

				maxint=(ushort) ~((int)maxint);
				XrlFeedback request=new XrlFeedback();
				request.FeedbackType=(byte) 1;
				request.SenderPuid=FeedbackTest.getSenderPuid();
				request.TargetPuid=FeedbackTest.getTargetPuid();
				request.TitleID= 1397030950;
				request.Nickname="hello";

				if (!request.Execute())	return;

				ResultCode=TEST_RESULTS.PASSED;
			}
		}

		//[TestCase, Description("nickname has invalid Characters")]
		/*
		 * - 801|FEEDBACK|2750412629575073|2639162995921585|1397030950|1|.... 4......4.................... .......................................4............................P
		 */

		//
	/*	 E8 A4
		 *80 E0 A1 91 E1 96 8B E5 AB A0 34 E5 86 89 E6 98
		 *8C E1 96 8B E5 AB A4 34 E6 99 9F E5 86 89 E8 A8
		 *90 EE 98 95 E3 91 9A E5 B8 80 E5 86 88 E5 AC 92
		 *EC 92 83 EC 88 9C 04 E5 8A 8B EB A0 90 E8 AE AD
		 *E6 A3 9B EE AB B7 EF AB 81 E8 AC 8C EC 87 82 E1
		 BF A8 EC 88 83 EE AD 90 E8 AC 95 E1 91 92 EA B6
		 B8 ED AE 8B EF 9D A8 EC 87 AA E0 B3 BA EC AA 8B
		 EE A7 81 CC 9F E5 87 8A E7 92 8B E3 80 A4 EE B1
		 A8 E3 90 9B E5 98 80 E5 AB A8 EF B3 B5 E8 8F BF
		 E0 B3 84 E8 AD 9F E5 BB 86 E8 8D 9B E1 B3 84 D3
		 82 E8 AC 80 E1 81 B2 E5 B2 8B E2 B0 A4 E6 A1 96
		 E1 AF AC 34 EE A1 93 EF 94 B9 EF BF BC EC 92 83
		 E8 B4 8C E2 91 94 E8 AC 8C EE A3 8E EA 8C 8B EF
		 BF BF E4 92 8D E0 B0 A4 EC A2 8B CF AB E4 A6 8D
		 E8 A8 80 E4 80 90 ED 8A 84 EF A5 B5 EF AE 8B EC
		 84 AB EF 86 8B E8 AD 8F E8 AB BF C5 8F 0D 0A 50
		 3A 61 73 70 6E 65 74 5F 77 70 20 41 3A 66 65 65 :aspnet_wp A:fee
		 */

        [TestFrequency("BVT"), TestCasePriority(1)]
		public class Unicodenickname : TestBase
		{
			protected override void Execute()
			{
				ushort maxint = 0;

				maxint=(ushort) ~((int)maxint);
				XrlFeedback request=new XrlFeedback();
				request.FeedbackType=(byte) 1;
				request.SenderPuid=FeedbackTest.getSenderPuid();
				request.TargetPuid=FeedbackTest.getTargetPuid();
				request.TitleID= 1397030950;

				byte[] nickname = new byte[]{0xE8,0xA4,0x80,0xE0,0xA1,0x91,0xE1,0x96,0x8B,0xE5,0xAB,0xA0,0x34,0xE5,0x86,0x89,0xE6,0x98,
											 0x8C,0xE1,0x96,0x8B,0xE5,0xAB,0xA4,0x34,0xE6,0x99,0x9F,0xE5,0x86,0x89,0xE8,0xA8,
											 0x90,0xEE,0x98,0x95,0xE3,0x91,0x9A,0xE5,0xB8,0x80,0xE5,0x86,0x88,0xE5,0xAC,0x92,
											 0xEC,0x92,0x83,0xEC,0x88,0x9C,0x04,0xE5,0x8A,0x8B,0xEB,0xA0,0x90,0xE8,0xAE,0xAD,
											 0xE6,0xA3,0x9B,0xEE,0xAB,0xB7,0xEF,0xAB,0x81,0xE8,0xAC,0x8C,0xEC,0x87,0x82,0xE1,
											0xBF,0xA8,0xEC,0x88,0x83,0xEE,0xAD,0x90,0xE8,0xAC,0x95,0xE1,0x91,0x92,0xEA,0xB6,
											0xB8,0xED,0xAE,0x8B,0xEF,0x9D,0xA8,0xEC,0x87,0xAA,0xE0,0xB3,0xBA,0xEC,0xAA,0x8B,
											0xEE,0xA7,0x81,0xCC,0x9F,0xE5,0x87,0x8A,0xE7,0x92,0x8B,0xE3,0x80,0xA4,0xEE,0xB1,
											0xA8,0xE3,0x90,0x9B,0xE5,0x98,0x80,0xE5,0xAB,0xA8,0xEF,0xB3,0xB5,0xE8,0x8F,0xBF,
											0xE0,0xB3,0x84,0xE8,0xAD,0x9F,0xE5,0xBB,0x86,0xE8,0x8D,0x9B,0xE1,0xB3,0x84,0xD3,
											0x82,0xE8,0xAC,0x80,0xE1,0x81,0xB2,0xE5,0xB2,0x8B,0xE2,0xB0,0xA4,0xE6,0xA1,0x96,
											0xE1,0xAF,0xAC,0x34,0xEE,0xA1,0x93,0xEF,0x94,0xB9,0xEF,0xBF,0xBC,0xEC,0x92,0x83,
											0xE8,0xB4,0x8C,0xE2,0x91,0x94,0xE8,0xAC,0x8C,0xEE,0xA3,0x8E,0xEA,0x8C,0x8B,0xEF,
											0xBF,0xBF,0xE4,0x92,0x8D,0xE0,0xB0,0xA4,0xEC,0xA2,0x8B,0xCF,0xAB,0xE4,0xA6,0x8D,
											0xE8,0xA8,0x80,0xE4,0x80,0x90,0xED,0x8A,0x84,0xEF,0xA5,0xB5,0xEF,0xAE,0x8B,0xEC,
											0x84,0xAB,0xEF,0x86,0x8B,0xE8,0xAD,0x8F,0xE8,0xAB,0xBF,0xC5,0x8F,0x0D,0x0A,0x50,
											0x3A,0x61,0x73,0x70,0x6E,0x65,0x74,0x5F,0x77,0x70,0x20,0x41,0x3A,0x66,0x65,0x65};


				//string nname= GetUTF8String(nickname);

				//byte[] temp2= GetUTF16String(nname);

				if (!request.Execute(nickname))	return;

				ResultCode=TEST_RESULTS.PASSED;

			}

		}

        [TestFrequency("Regression"), TestCasePriority(3)]
		public class UnicodenicknameEx : TestBase
		{
			protected override void Execute()
			{
				ushort maxint = 0;

				maxint=(ushort) ~((int)maxint);
				XrlFeedback request=new XrlFeedback();
				request.FeedbackType=(byte) 1;
				request.SenderPuid=FeedbackTest.getSenderPuid();
				request.TargetPuid=FeedbackTest.getTargetPuid();
				request.TitleID= 1397030950;

				byte[] nickname = new byte[]{0xE8,0xA4,0x80,0xE0,0xA1,0x91,0xE1,0x96,0x8B,0xE5,0xAB,0xA0,0x34,0xE5,0x86,0x89,0xE6,0x98,
												0x8C,0xE1,0x96,0x8B,0xE5,0xAB,0xA4,0x34,0xE6,0x99,0x9F,0xE5,0x86,0x89,0xE8,0xA8,
												0x90,0xEE,0x98,0x95,0xE3,0x91,0x9A,0xE5,0xB8,0x80,0xE5,0x86,0x88,0xE5,0xAC,0x92,
												0xEC,0x92,0x83,0xEC,0x88,0x9C,0x04,0xE5,0x8A,0x8B,0xEB,0xA0,0x90,0xE8,0xAE,0xAD,
												0xE6,0xA3,0x9B,0xEE,0xAB,0xB7,0xEF,0xAB,0x81,0xE8,0xAC,0x8C,0xEC,0x87,0x82,0xE1,
												0xBF,0xA8,0xEC,0x88,0x83,0xEE,0xAD,0x90,0xE8,0xAC,0x95,0xE1,0x91,0x92,0xEA,0xB6,
												0xB8,0xED,0xAE,0x8B,0xEF,0x9D,0xA8,0xEC,0x87,0xAA,0xE0,0xB3,0xBA,0xEC,0xAA,0x8B,
												0xEE,0xA7,0x81,0xCC,0x9F,0xE5,0x87,0x8A,0xE7,0x92,0x8B,0xE3,0x80,0xA4,0xEE,0xB1,
												0xA8,0xE3,0x90,0x9B,0xE5,0x98,0x80,0xE5,0xAB,0xA8,0xEF,0xB3,0xB5,0xE8,0x8F,0xBF,
												0xE0,0xB3,0x84,0xE8,0xAD,0x9F,0xE5,0xBB,0x86,0xE8,0x8D,0x9B,0xE1,0xB3,0x84,0xD3,
												0x82,0xE8,0xAC,0x80,0xE1,0x81,0xB2,0xE5,0xB2,0x8B,0xE2,0xB0,0xA4,0xE6,0xA1,0x96,
												0xE1,0xAF,0xAC,0x34,0xEE,0xA1,0x93,0xEF,0x94,0xB9,0xEF,0xBF,0xBC,0xEC,0x92,0x83,
												0xE8,0xB4,0x8C,0xE2,0x91,0x94,0xE8,0xAC,0x8C,0xEE,0xA3,0x8E,0xEA,0x8C,0x8B,0xEF,
												0xBF,0xBF,0xE4,0x92,0x8D,0xE0,0xB0,0xA4,0xEC,0xA2,0x8B,0xCF,0xAB,0xE4,0xA6,0x8D,
												0xE8,0xA8,0x80,0xE4,0x80,0x90,0xED,0x8A,0x84,0xEF,0xA5,0xB5,0xEF,0xAE,0x8B,0xEC,
												0x84,0xAB,0xEF,0x86,0x8B,0xE8,0xAD,0x8F,0xE8,0xAB,0xBF,0xC5,0x8F,0x0D,0x0A,0x50,
												0x3A,0x61,0x73,0x70,0x6E,0x65,0x74,0x5F,0x77,0x70,0x20,0x41,0x3A,0x66,0x65,0x65};

				StringBuilder temp = new StringBuilder(50);

				for(int size=0;size< nickname.Length;size++)
				{
					temp.Insert(size,(Char)nickname[size]);
				}

				try
				{
					request.Nickname=temp.ToString();
				}
				catch (Exception e)
				{
					Console.WriteLine(e);
				}

				if (!request.Execute())	return;

				ResultCode=TEST_RESULTS.PASSED;
			}
		}
	}

	public class FuncTests : TestNode
	{
		public FuncTests()
		{
			AddChild(new ValidNegNick() );
			AddChild(new ValidNonNickTypes() );
			AddChild(new ValidMaxValues() );
            AddChild(new ReservedType());
			AddChild(new NullNick() );
			AddChild(new NeedlessNick() );
			AddChild(new InvalidChars() );
			AddChild(new NullSender() );

			AddChild(new NullNickMismatchedSize() );
			AddChild(new NickMismatchedSize1() );
			AddChild(new NickMismatchedSize2() );

			AddChild(new NegBadType() );
			AddChild(new NegNullTarget() );
			AddChild(new NegXRLUnderflow() );
			AddChild(new NegXRLZeroSize() );
			AddChild(new NegXRLUserAgent() );
			AddChild(new NegXRLService() );
			//AddChild(new NegTest() );

		}

		// NEG_NICKNAME is the only current feedback type which takes a nickname
        [TestFrequency("BVT"), TestCasePriority(1)]
		public class ValidNegNick : FeedbackTest
		{
			protected override void Execute()
			{
				DoPosTest(FeedbackType.NEG_NICKNAME, getSenderPuid(), getTargetPuid(), (uint) RandomEx.GlobalRandGen.Next(), "bryan");
			}
		}

		// check all other feedback types
        [TestFrequency("BVT"), TestCasePriority(1)]
		public class ValidNonNickTypes : FeedbackTest
		{
			protected override void Execute()
			{
				FeedbackType  fbtype = FeedbackType.NEG_GAMEPLAY;
				while ( fbtype != FeedbackType.MAXFEEDBACKTYPE )
				{
					DoPosTest(fbtype, getSenderPuid(), getTargetPuid(), (uint) RandomEx.GlobalRandGen.Next(), null);
					fbtype++;
				}
			}
		}

        [TestFrequency("Daily"), TestCasePriority(2)]
		public class ValidMaxValues : FeedbackTest
		{
			protected override void Execute()
			{
				//255-character string
				string strTest = "thisisastringwhichis255characterslong12345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678";

				DoPosTest(FeedbackType.NEG_NICKNAME, getSenderPuid(), getTargetPuid(), 0xFFFFFFFF, strTest);
			}
		}

        [TestFrequency("Daily"), TestCasePriority(2)]
		public class ReservedType : FeedbackTest
		{
			protected override void Execute()
			{
				// this value is reserved for system use (???), "min service type"
				DoPosTest(FeedbackType.XONLINE_FEEDBACK_DATA_MACHINE, getSenderPuid(), getTargetPuid(), (uint) RandomEx.GlobalRandGen.Next(), null);
			}
		}

        [TestFrequency("Regression"), TestCasePriority(3)]
		public class NegBadType : FeedbackTest
		{
			protected override void Execute()
			{
				DoNegReq( (byte) FeedbackType.MAXFEEDBACKTYPE, getSenderPuid(), getTargetPuid(), (uint) RandomEx.GlobalRandGen.Next(),
					null, 0, HttpStatusCode.InternalServerError, HResult.XONLINE_E_FEEDBACK_BAD_TYPE, false);
			}
		}

        [TestFrequency("Regression"), TestCasePriority(3)]
		public class NegMaxBadType : FeedbackTest
		{
			protected override void Execute()
			{
				DoNegReq( ((byte)FeedbackType.XONLINE_FEEDBACK_DATA_MACHINE)-1, getSenderPuid(), getTargetPuid(), (uint) RandomEx.GlobalRandGen.Next(),
					null, 0, HttpStatusCode.InternalServerError, HResult.XONLINE_E_FEEDBACK_BAD_TYPE, false);
			}
		}

		// obsolete Neg case per bug 17021 -- moved to Pos case
        [TestFrequency("Regression"), TestCasePriority(3)]
		public class NullNick : FeedbackTest
		{
			protected override void Execute()
			{
				//DoNegReq( (byte) FeedbackType.NEG_NICKNAME, RandomEx.GlobalRandGen.NextPuid(), RandomEx.GlobalRandGen.NextPuid(), (uint) RandomEx.GlobalRandGen.Next(),
				//	null, 0, HttpStatusCode.InternalServerError, 0x80158003, false);

				DoPosTest(FeedbackType.NEG_NICKNAME, getSenderPuid(), getTargetPuid(), (uint) RandomEx.GlobalRandGen.Next(), null);
			}
		}

		// obsolete Neg case -- moved to Pos case
        [TestFrequency("Regression"), TestCasePriority(3)]
		public class NeedlessNick : FeedbackTest
		{
			protected override void Execute()
			{
				//DoNegReq( (byte) FeedbackType.NEG_GAMEPLAY, RandomEx.GlobalRandGen.NextPuid(), RandomEx.GlobalRandGen.NextPuid(), (uint) RandomEx.GlobalRandGen.Next(),
				//	"bryan", 5, HttpStatusCode.InternalServerError, 0x80158005, true);

				DoPosTest(FeedbackType.NEG_GAMEPLAY, getSenderPuid(), getTargetPuid(), (uint) RandomEx.GlobalRandGen.Next(), "bryan");
			}
		}

        [TestFrequency("Regression"), TestCasePriority(3)]
		public class NegNullTarget : FeedbackTest
		{
			protected override void Execute()
			{
				DoNegReq( (byte) FeedbackType.NEG_GAMEPLAY, getSenderPuid(), 0, (uint) RandomEx.GlobalRandGen.Next(),
					null, 0, HttpStatusCode.InternalServerError, HResult.XONLINE_E_FEEDBACK_NULL_TARGET, true);
			}
		}

		// This should work OK, now POS test case
        [TestFrequency("Regression"), TestCasePriority(3)]
		public class NullSender : FeedbackTest
		{
			protected override void Execute()
			{
				//DoNegReq( (byte) FeedbackType.NEG_GAMEPLAY, 0, RandomEx.GlobalRandGen.NextPuid(), (uint) RandomEx.GlobalRandGen.Next(),
				//	"NullSender", 10, HttpStatusCode.InternalServerError, HResult.XONLINE_E_FEEDBACK_NULL_TARGET, true);
				DoPosTest(FeedbackType.NEG_GAMEPLAY, 0, getTargetPuid(), (uint) RandomEx.GlobalRandGen.Next(), "nullsender");

			}
		}

		//generic neg test
        [TestFrequency("Regression"), TestCasePriority(3)]
		public class NegTest : FeedbackTest
		{
			protected override void Execute()
			{
				DoNegReq( (byte) FeedbackType.NEG_GAMEPLAY, getSenderPuid(), getTargetPuid(), (uint) RandomEx.GlobalRandGen.Next(),
					null, 5, HttpStatusCode.InternalServerError, HResult.XONLINE_E_FEEDBACK_NULL_TARGET, true);
			}
		}

		// per Mason, this test should pass -- it is up to the log consumers to
		// read all valid ASCII chars, even | and \n that may affect log output
        [TestFrequency("Regression"), TestCasePriority(3)]
		public class InvalidChars : FeedbackTest
		{
			protected override void Execute()
			{
				//DoNegReq( (byte) FeedbackType.NEG_GAMEPLAY, RandomEx.GlobalRandGen.NextPuid(), RandomEx.GlobalRandGen.NextPuid(), (uint) RandomEx.GlobalRandGen.Next(),
				//	"this|couldbe\nbad", 16, HttpStatusCode.InternalServerError, HResult.XONLINE_E_FEEDBACK_NULL_TARGET, true);

				DoPosTest(FeedbackType.NEG_GAMEPLAY, getSenderPuid(), getTargetPuid(), (uint) RandomEx.GlobalRandGen.Next(), "this|couldbe\nbad");
			}
		}

        [TestFrequency("Regression"), TestCasePriority(3)]
		public class NullNickMismatchedSize : FeedbackTest
		{
			protected override void Execute()
			{
				DoPosTestEx(FeedbackType.NEG_GAMEPLAY, getSenderPuid(), getTargetPuid(), (uint) RandomEx.GlobalRandGen.Next(), null, 5);
			}
		}

        [TestFrequency("Regression"), TestCasePriority(3)]
		public class NickMismatchedSize1 : FeedbackTest
		{
			protected override void Execute()
			{
				DoPosTestEx(FeedbackType.NEG_GAMEPLAY, getSenderPuid(), getTargetPuid(), (uint) RandomEx.GlobalRandGen.Next(),
					"thisisastringwhichis255characterslong12345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678", 1);
			}
		}

        [TestFrequency("Regression"), TestCasePriority(3)]
		public class NickMismatchedSize2 : FeedbackTest
		{
			protected override void Execute()
			{
				DoPosTestEx(FeedbackType.NEG_GAMEPLAY, getSenderPuid(), getTargetPuid(), (uint) RandomEx.GlobalRandGen.Next(), "a", 255);
			}
		}

        [TestFrequency("Regression"), TestCasePriority(3)]
		public class NegXRLUnderflow : FeedbackTest
		{
			protected override void Execute()
			{
				MemoryStream		reqStream = new MemoryStream();
				BinaryWriter		bw = new BinaryWriter(reqStream);
				HttpWebRequest httpreq;
				HttpWebResponse response;
				Stream httpStream;

				string nickname="rawtest";
				ASCIIEncoding enc = new ASCIIEncoding();
				byte[] nickBytes = enc.GetBytes(nickname);

				// Construct request stream
				bw.Write(getSenderPuid());
				bw.Write(getTargetPuid());

				string url= "http://"+Global.XEnv.GetVirtualInterface(VirtualInterface.fbserver).Address.ToString()+":"+ Global.XEnv.GetVirtualInterface(VirtualInterface.fbserver).Port.ToString()+"/fbserver/fbserver.ashx";

				httpreq = (HttpWebRequest) WebRequest.Create(url);
				httpreq.Method = "POST";
				httpreq.ProtocolVersion = HttpVersion.Version10;
				httpreq.Headers.Add("Relja: true");
				httpreq.ContentType = "xon/8";
				httpreq.UserAgent = "8/0.10.4715";
				httpreq.ContentLength = reqStream.Length;

				// attach the request data we wrote to the HTTP request
				httpStream = httpreq.GetRequestStream();
				reqStream.WriteTo(httpStream);
				httpStream.Close();

				httpreq.Timeout = 2000;

				try
				{
					response = (HttpWebResponse) httpreq.GetResponse();
				}
				catch( System.Net.WebException e )
				{
					// GetResponse() throws exception on HTTP 500
					response = (HttpWebResponse) e.Response;
					if ( (response != null) && (response.StatusCode == HttpStatusCode.InternalServerError) )
					{
						ResultCode=TEST_RESULTS.PASSED;
						return;
					}
				}

				// FAILED -- either request succeeded unexpectedly or we got back the wrong code
				if ( response != null )
					ConsoleX.WriteLine("\nRESPONSE: " + response.StatusCode.ToString() + " " + response.GetResponseHeader("XErr") );
			}
		}

        [TestFrequency("Regression"), TestCasePriority(3)]
		public class NegXRLZeroSize : FeedbackTest
		{
			protected override void Execute()
			{
				MemoryStream		reqStream = new MemoryStream();
				BinaryWriter		bw = new BinaryWriter(reqStream);
				HttpWebRequest httpreq;
				HttpWebResponse response;
				Stream httpStream;

				string nickname="rawtest";
				ASCIIEncoding enc = new ASCIIEncoding();
				byte[] nickBytes = enc.GetBytes(nickname);

				// Create and HTTP request and add headers
				string url= "http://"+Global.XEnv.GetVirtualInterface(VirtualInterface.fbserver).Address.ToString()+":"+ Global.XEnv.GetVirtualInterface(VirtualInterface.fbserver).Port.ToString()+"/fbserver/fbserver.ashx";
				httpreq = (HttpWebRequest) WebRequest.Create(url);
				httpreq.Method = "POST";
				httpreq.ProtocolVersion = HttpVersion.Version10;
				httpreq.Headers.Add("Relja: true");
				httpreq.ContentType = "xon/8";
				httpreq.UserAgent = "8/0.10.4715";
				httpreq.ContentLength = reqStream.Length;

				// attach the request data we wrote to the HTTP request
				httpStream = httpreq.GetRequestStream();
				reqStream.WriteTo(httpStream);
				httpStream.Close();

				httpreq.Timeout = 2000;

				try
				{
					response = (HttpWebResponse) httpreq.GetResponse();
				}
				catch( System.Net.WebException e )
				{
					// GetResponse() throws exception on HTTP 500
					response = (HttpWebResponse) e.Response;
					if ( (response != null) && (response.StatusCode == HttpStatusCode.InternalServerError) )
					{
						ResultCode=TEST_RESULTS.PASSED;
						return;
					}
				}

				// FAILED -- either request succeeded unexpectedly or we got back the wrong code
				if ( response != null )
					ConsoleX.WriteLine("\nRESPONSE: " + response.StatusCode.ToString() + " " + response.GetResponseHeader("XErr") );
			}
		}

        [TestFrequency("Regression"), TestCasePriority(3)]
		public class NegXRLUserAgent : FeedbackTest
		{
			protected override void Execute()
			{
				MemoryStream		reqStream = new MemoryStream();
				BinaryWriter		bw = new BinaryWriter(reqStream);
				HttpWebRequest httpreq;
				HttpWebResponse response;
				Stream httpStream;

				string nickname="missuseragent";
				ASCIIEncoding enc = new ASCIIEncoding();
				byte[] nickBytes = enc.GetBytes(nickname);

				// Construct request stream
				bw.Write(RandomEx.GlobalRandGen.NextPuid());
				bw.Write(RandomEx.GlobalRandGen.NextPuid());
				bw.Write((uint)RandomEx.GlobalRandGen.Next());
				bw.Write((byte)0x01);
				bw.Write((byte)0x07);
				bw.Write(nickBytes, 0, nickBytes.Length);

				// TEST: missing UserAgent header
				// Create and HTTP request and add headers
				string url= "http://"+Global.XEnv.GetVirtualInterface(VirtualInterface.fbserver).Address.ToString()+":"+ Global.XEnv.GetVirtualInterface(VirtualInterface.fbserver).Port.ToString()+"/fbserver/fbserver.ashx";
				httpreq = (HttpWebRequest) WebRequest.Create(url);
				httpreq.Method = "POST";
				httpreq.ProtocolVersion = HttpVersion.Version10;
				httpreq.Headers.Add("Relja: true");
				httpreq.ContentType = "xon/8";
				httpreq.ContentLength = reqStream.Length;

				// attach the request data we wrote to the HTTP request
				httpStream = httpreq.GetRequestStream();
				reqStream.WriteTo(httpStream);
				httpStream.Close();

				httpreq.Timeout = 2000;

				try
				{
					response = (HttpWebResponse) httpreq.GetResponse();
				}
				catch( System.Net.WebException e )
				{
					// GetResponse() throws exception on HTTP 500
					response = (HttpWebResponse) e.Response;
					if ( (response != null) && (response.StatusCode == HttpStatusCode.InternalServerError) )
					{
						ResultCode=TEST_RESULTS.PASSED;
						return;
					}
				}

				// FAILED -- either request succeeded unexpectedly or we got back the wrong code
				if ( response != null )
					ConsoleX.WriteLine("\nRESPONSE: " + response.StatusCode.ToString() + " " + response.GetResponseHeader("XErr") );
			}
		}

        [TestFrequency("Regression"), TestCasePriority(3)]
		public class NegXRLService : FeedbackTest
		{
			protected override void Execute()
			{
				MemoryStream		reqStream = new MemoryStream();
				BinaryWriter		bw = new BinaryWriter(reqStream);
				HttpWebRequest httpreq;
				HttpWebResponse response;
				Stream httpStream;

				string nickname="missingserviceid";
				ASCIIEncoding enc = new ASCIIEncoding();
				byte[] nickBytes = enc.GetBytes(nickname);

				// Construct valid request stream
				bw.Write(RandomEx.GlobalRandGen.NextPuid());
				bw.Write(RandomEx.GlobalRandGen.NextPuid());
				bw.Write((uint)RandomEx.GlobalRandGen.Next());
				bw.Write((byte)0x01);
				bw.Write((byte)0x07);
				bw.Write(nickBytes, 0, nickBytes.Length);

				// TEST: remove ContentType so XRL is rejected
				// Create and HTTP request and add headers
				string url= "http://"+Global.XEnv.GetVirtualInterface(VirtualInterface.fbserver).Address.ToString()+":"+ Global.XEnv.GetVirtualInterface(VirtualInterface.fbserver).Port.ToString()+"/fbserver/fbserver.ashx";
				httpreq = (HttpWebRequest) WebRequest.Create(url);
				httpreq.Method = "POST";
				httpreq.ProtocolVersion = HttpVersion.Version10;
				httpreq.Headers.Add("Relja: true");
				httpreq.UserAgent = "8/0.10.4715";
				httpreq.ContentLength = reqStream.Length;

				// attach the request data we wrote to the HTTP request
				httpStream = httpreq.GetRequestStream();
				reqStream.WriteTo(httpStream);
				httpStream.Close();

				httpreq.Timeout = 2000;

				try
				{
					response = (HttpWebResponse) httpreq.GetResponse();
				}
				catch( System.Net.WebException e )
				{
					// GetResponse() should throw 404 here
					response = (HttpWebResponse) e.Response;
					if ( (response != null) && (response.StatusCode == HttpStatusCode.NotFound) )
					{
						ResultCode=TEST_RESULTS.PASSED;
						return;
					}
				}

				// FAILED -- either request succeeded unexpectedly or we got back the wrong code
				if ( response != null )
					ConsoleX.WriteLine("\nRESPONSE: " + response.StatusCode.ToString() + " " + response.GetResponseHeader("XErr") );
			}
		}
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\StfTests\Feedback\Feedback\XeFeedback.cs ===
using System;
using System.Threading;
using System.IO;
using System.Net;
using System.Text;
using ServerTestFramework;
//using ServerTestFramework.LiveService;
using ServerTestFramework.LiveService.Feedback;
using ServerTestFramework.LiveService.Presence;
using ServerTestFramework.LiveService.PresNotiCommon;
using ServerTestFramework.LiveService.Achievement;
using xonline.common.config;
using xonline.common.service;
using ServerTestFramework.Utilities;
using ServerTestFramework.LiveService.UserAccount;

namespace Feedback
{
	/// <summary>
	/// Summary description for XeFeedback.
	/// </summary>
	abstract public class XeFeedbackTest : TestBase
	{
		static long idx=0;
		public XeFeedbackTest()
		{
			
		}

		public XeFeedbackTest(string name): base (name)
		{
			
		}

		public static ulong  getRealUserPuid()
		{

			FriendsCommon fc = new FriendsCommon();

			PNUser user = fc.CreateUser(true);

			return user.UserId;
		}

        public static PNUser getPNUser()
        {

            FriendsCommon fc = new FriendsCommon();

            PNUser user = fc.CreateUser(true);

            return user;
        }

		public static ulong  getContext()
		{
			return (ulong)(0xFF000+ Interlocked.Increment(ref idx));
		}

		public static void SendComplaintAndVerify(ulong  senderPUID,ulong   targetPUID,uint    titleID,uint    type,ulong   context,uint ExpectedXErr)
		{
			SendComplaintAndVerify(senderPUID,targetPUID,titleID,type,context,ExpectedXErr,Modify.None);
		}

		public static void SendComplaintAndVerify(ulong  senderPUID,ulong   targetPUID,uint    titleID,uint    type,ulong   context,uint ExpectedXErr,Modify flags)
		{
			SubmitComplaintRequest req = new  SubmitComplaintRequest(senderPUID,targetPUID,titleID,type,context);
			//make sure that complaint is added in db.

			req.Modifyflag=flags;
			Response resp = req.Execute();

			if(HResult.Succeeded(resp.Xerr))
			{
				if(HResult.Failed(ExpectedXErr))
					throw new Exception("Unexpected Xerror "+resp.Xerr);

				FeedbackWS.verifyComplaint((long)senderPUID,(long)targetPUID,(int)titleID,(int)type,(long)context);
			}
			else
			{
				if(resp.Xerr != ExpectedXErr)
					throw new Exception("Unexpected Error returned by server XERROR= "+resp.Xerr);
			}
		}

        public static void SendReviewAndVerify(PNUser senderPUID, PNUser targetPUID, uint titleID, uint type, ulong context, uint ExpectedXErr, Modify flags)
		{
			SendReviewAndVerify(senderPUID,targetPUID,titleID,type,context,ExpectedXErr,flags,true);
		}

        public static void SendReviewAndVerify(PNUser senderPUID, PNUser targetPUID, uint titleID, uint type, ulong context, uint ExpectedXErr)
		{
			SendReviewAndVerify(senderPUID,targetPUID,titleID,type,context,ExpectedXErr,Modify.None,true);
		
		}

        public static void SendReviewAndVerify(PNUser senderPUID, PNUser targetPUID, uint titleID, uint type, ulong context, uint ExpectedXErr, Modify flags, bool VerifyRating)
		{
            int initialAggCount = FeedbackWS.GetAggCount(targetPUID.UserId, type);
            double initialRating = FeedbackWS.GetRating(targetPUID.UserId);
            SubmitReview req = new SubmitReview(senderPUID.UserId, targetPUID.UserId, titleID, type, context);
			req.Modifyflag=flags;

			Response resp = req.Execute();

			if(HResult.Succeeded(resp.Xerr))
			{
                Global.RO.Info("Logging off and on user.");

                FriendsCommon fc = new FriendsCommon();
                fc.LogoffUser(senderPUID);
                fc.LogonUser(senderPUID);

                fc.LogoffUser(targetPUID);
                fc.LogonUser(targetPUID);

                Thread.Sleep(2000);

				if(HResult.Failed(ExpectedXErr))
					throw new Exception("Unexpected Xerror "+resp.Xerr);
				// make sure the entry is add in db .
                object Reviewval = FeedbackWS.verifyReview((long)senderPUID.UserId, (long)targetPUID.UserId, (int)titleID, (int)type, (long)context);

				if(Reviewval==null || ((int)Reviewval)<=0)
					throw new Exception("User Review entry not found in DB");

                int AggCount = FeedbackWS.GetAggCount(targetPUID.UserId, type);
				if(AggCount != (initialAggCount+1))
					throw new Exception("Agg Count not incremented ");

				// make sure user is added in affiliates list.
				int AffiliatFlag = FeedbackWS.GetAffiliacteFlags(senderPUID,(long)targetPUID.UserId,(int)titleID);
				if(type==(int)PlayerReview.Prefer)
				{
					if(AffiliatFlag!=4)
                        throw new Exception("Affiliate with Positive Feedback not added for user " + senderPUID.UserId);
				}
				else
				{
					if(AffiliatFlag!=8)
                        throw new Exception("Affiliate with Negative Feedback not added for user " + senderPUID.UserId);

					int TargetAffiliatFlag = FeedbackWS.GetAffiliacteFlags(targetPUID,(long)senderPUID.UserId,(int)titleID);
					if(TargetAffiliatFlag!=16)
                        throw new Exception("Avoided Affiliate not added for user " + targetPUID.UserId);
				}
				// verify that Feedback rating is added or changed for the user.

				if(VerifyRating && type <(int)PlayerReview.AvoidUnskilled)
				{
					if(initialRating>1)
					{
                        double currentRating = FeedbackWS.GetRating(targetPUID.UserId);
						if(initialRating == currentRating )
							throw new Exception("Gamer Rating did not got updated");
					}
				}
			}
			else
			{
				if(resp.Xerr != ExpectedXErr)
					throw new Exception("Unexpected Error returned by server XERROR= "+resp.Xerr);

				//make sure that nothing is added in db.
                object Reviewval = FeedbackWS.verifyReview((long)senderPUID.UserId, (long)targetPUID.UserId, (int)titleID, (int)type, (long)context);
				if(Reviewval!=null && ((int)Reviewval)!=0)
					throw new Exception("User Review entry not found in DB");

                int AggCount = FeedbackWS.GetAggCount(targetPUID.UserId, type);
				if(AggCount != (initialAggCount))
					throw new Exception("Agg Count not incremented ");	
			}	
		}	
	}

	public class FuncReviewTests : TestNode
	{
		public FuncReviewTests()
		{
			Type PlayerReviewType = typeof(PlayerReview);
			int icount =0;
			foreach(string s in Enum.GetNames(PlayerReviewType))
			{
				icount++;
				uint type= (uint)Enum.Parse(PlayerReviewType,s);
				AddChild(new Reviews(s,type) );
			}

            AddChild(new Reviews("InvalidType",(uint)icount,HResult.XONLINE_E_FEEDBACK_BAD_TYPE) );
            AddChild(new Reviews("MaxType",(uint)0xFFFFFFFF,HResult.XONLINE_E_FEEDBACK_BAD_TYPE) );
            AddChild(new RatingCanBeUpdatedTwice());
            AddChild(new SameReviewsTwice());
            AddChild(new ChangePreferToAvoid());
            AddChild(new ChangeAvoidToPrefer());
            AddChild(new ChangeAvoidToAvoid());
            AddChild(new Blacklisted());
            AddChild(new Notblacklisted());
            AddChild(new InvalidBlacklisted());
            AddChild(new InvalidSender());
            AddChild(new InvalidTarget());
            AddChild(new SameSenderTarget());
            AddChild(new NullTarget());

            AddChild(new NegXRLUserAgent());
            AddChild(new NegXRLService());

            AddChild(new TCInvalidZeroPKT());
            AddChild(new TCInvalidSmallPKT());
            AddChild(new TCInvalidLargePKT());
		}

        [TestFrequency("Regression"), TestCasePriority(3)]
		public class TCInvalidZeroPKT:TestBase
		{
			override protected void Execute()
			{
				InvalidFBRequest tmp = new InvalidFBRequest(0,"/fbserver/submitreview.ashx");
				uint xerror= tmp.Execute();
				if(xerror != HResult.XONLINE_E_INVALID_REQUEST)
					throw new Exception("Invalid Xerror Expected :"+ HResult.E_FAIL+" recived:"+xerror);

				ResultCode=TEST_RESULTS.PASSED;
			}
		}

        [TestFrequency("Regression"), TestCasePriority(3)]
		public class TCInvalidSmallPKT:TestBase
		{
			override protected void Execute()
			{
				InvalidFBRequest tmp = new InvalidFBRequest(10,"/fbserver/submitreview.ashx");
				uint xerror= tmp.Execute();
				if(xerror != HResult.XONLINE_E_INVALID_REQUEST)
					throw new Exception("Invalid Xerror Expected :"+ HResult.E_FAIL+" recived:"+xerror);

				ResultCode=TEST_RESULTS.PASSED;
			}
		}

        [TestFrequency("Regression"), TestCasePriority(3)]
		public class TCInvalidLargePKT:TestBase
		{
			override protected void Execute()
			{
				InvalidFBRequest tmp = new InvalidFBRequest(1000,"/fbserver/submitreview.ashx");
				uint xerror= tmp.Execute();
				if(xerror != HResult.XONLINE_E_INVALID_REQUEST)
					throw new Exception("Invalid Xerror Expected :"+ HResult.E_FAIL+" recived:"+xerror);

				ResultCode=TEST_RESULTS.PASSED;
			}
		}

        [TestFrequency("Regression"), TestCasePriority(3)]
		public class SameSenderTarget : XeFeedbackTest
		{
			protected override void Execute()
			{
				PNUser sender = getPNUser();
				SendReviewAndVerify(sender,sender,50,(uint)PlayerReview.AvoidUnskilled,getContext(),HResult.XONLINE_E_FEEDBACK_NULL_TARGET);
				ResultCode = TEST_RESULTS.PASSED;
			}
		}

        [TestFrequency("Regression"), TestCasePriority(3)]
		public class InvalidTarget : XeFeedbackTest
		{
			protected override void Execute()
			{

                SendReviewAndVerify(getPNUser(), new PNUser("IVTarget", 123450), 50, (uint)PlayerReview.AvoidUnskilled, getContext(), HResult.XONLINE_E_DATABASE_EXECUTE_ERROR);
				ResultCode = TEST_RESULTS.PASSED;
			}
		}

        [TestFrequency("Regression"), TestCasePriority(3)]
		public class NullTarget : XeFeedbackTest
		{
			protected override void Execute()
			{
				
				SendReviewAndVerify(getPNUser(),new PNUser("NULL",0),50,(uint)PlayerReview.AvoidUnskilled,getContext(),HResult.XONLINE_E_FEEDBACK_NULL_TARGET);
				ResultCode = TEST_RESULTS.PASSED;
			}
		}

        [TestFrequency("Regression"), TestCasePriority(3)]
		public class InvalidSender : XeFeedbackTest
		{
			protected override void Execute()
			{

                SendReviewAndVerify(new PNUser("INvalud", 12344), getPNUser(), 50, (uint)PlayerReview.AvoidUnskilled, getContext(), HResult.XONLINE_E_FEEDBACK_USER_NOT_PRESENT, Modify.Change_User);
				ResultCode = TEST_RESULTS.PASSED;
			}

		}

        [TestFrequency("Daily"), TestCasePriority(2)]
		public class Notblacklisted : XeFeedbackTest
		{
			protected override void Execute()
			{
				PNUser sender = getPNUser();
				// set the games played and total playes such that the 
                FeedbackWS.AddRatingData(sender.UserId, 1, 1, 1);
				SendReviewAndVerify(sender,getPNUser(),50,(uint)PlayerReview.AvoidUnskilled,getContext(),1);
				ResultCode = TEST_RESULTS.PASSED;
			}
		}

        [TestFrequency("Regression"), TestCasePriority(3)]
		public class InvalidBlacklisted : XeFeedbackTest
		{
			protected override void Execute()
			{
				ulong context=getContext();
				uint type=(uint)PlayerReview.AvoidDisruptive;
				uint titleID = 50;
				PNUser targetPUID= getPNUser();
				PNUser senderPUID= getPNUser();
                int initialAggCount = FeedbackWS.GetAggCount(targetPUID.UserId, type);
                double initialRating = FeedbackWS.GetRating(targetPUID.UserId);
				//double currentRating1;

				// set the games played and total playes such that the 
                FeedbackWS.AddRatingData(senderPUID.UserId, 10, 20, 0);
				for(int i=0 ;i<11;i++)
					SendReviewAndVerify(senderPUID,getPNUser(),50,(uint)PlayerReview.Prefer,getContext(),1);

                SubmitReview req = new SubmitReview(senderPUID.UserId, targetPUID.UserId, titleID, type, context);
				Response resp = req.Execute();

				if(resp.Xerr != HResult.XONLINE_E_FEEDBACK_REVIEW_LIMIT_EXCEEDED)
				{

					// make sure the entry is  add in db .
                    object Reviewval = FeedbackWS.verifyReview((long)senderPUID.UserId, (long)targetPUID.UserId, (int)titleID, (int)type, (long)context);

					if(Reviewval==null && ((int)Reviewval)!=0)
						throw new Exception("User Review entry was not be added to DB");
				}
				else
					throw new Exception("Unexpected XError returned by server XERROR= "+resp.Xerr);
				
				ResultCode=TEST_RESULTS.PASSED;
			}
		}

        [TestFrequency("Daily"), TestCasePriority(2)]
		public class Blacklisted : XeFeedbackTest
		{
			protected override void Execute()
			{
				ulong context=getContext();
				uint type=(uint)PlayerReview.AvoidDisruptive;
				uint titleID = 50;
                PNUser targetPUID = getPNUser();
                PNUser senderPUID = getPNUser();
				int initialAggCount = FeedbackWS.GetAggCount(targetPUID.UserId,type);
				double initialRating = FeedbackWS.GetRating(targetPUID.UserId);
				double currentRating1;

				// set the games played and total playes such that the 
                FeedbackWS.AddRatingData(senderPUID.UserId, 10, 20, 0);
				for(int i=0 ;i<10;i++)
                    SendReviewAndVerify(senderPUID, getPNUser(), 50, (uint)PlayerReview.AvoidDisruptive, getContext(), 1);

				SubmitReview req = new  SubmitReview(senderPUID.UserId,targetPUID.UserId,titleID,type,context);
				Response resp = req.Execute();

				if(resp.Xerr == HResult.XONLINE_E_FEEDBACK_REVIEW_LIMIT_EXCEEDED)
				{
					// make sure the entry is not add in db .
					object Reviewval = FeedbackWS.verifyReview((long)senderPUID.UserId,(long)targetPUID.UserId,(int)titleID,(int)type,(long)context);

					if(Reviewval!=null && ((int)Reviewval)>0)
						throw new Exception("User Review entry should not be added to DB");

					int AggCount =FeedbackWS.GetAggCount(targetPUID.UserId,type);
					if(AggCount != (initialAggCount))
						throw new Exception("Agg Count must be incremented ");

					// make sure user is added in affiliates list.
					int AffiliatFlag = FeedbackWS.GetAffiliacteFlags(senderPUID,(long)targetPUID.UserId,(int)titleID);
					
					if(AffiliatFlag!=0)
						throw new Exception("Affiliate should not be added "+senderPUID);
										
					// verify that Feedback rating is added or changed for the user.

					currentRating1 = FeedbackWS.GetRating(targetPUID.UserId);
					if(initialRating != currentRating1 )
						throw new Exception("rating should not change");
				}
				else
					throw new Exception("Unexpected XError returned by server XERROR= "+resp.Xerr);

				ResultCode=TEST_RESULTS.PASSED;
			}
		}

        [TestFrequency("Daily"), TestCasePriority(2)]
		public class ChangeAvoidToAvoid : XeFeedbackTest
		{
			protected override void Execute()
			{
				ulong context=getContext();
				uint type=(uint)PlayerReview.AvoidDisruptive;
				uint titleID = 50;
				PNUser targetPUID= getPNUser();
				PNUser senderPUID= getPNUser();
                int initialAggCount = FeedbackWS.GetAggCount(targetPUID.UserId, type);
                double initialRating = FeedbackWS.GetRating(targetPUID.UserId);
				double currentRating1;
                SubmitReview req = new SubmitReview(senderPUID.UserId, targetPUID.UserId, titleID, type, context);

				Response resp = req.Execute();

				if(HResult.Succeeded(resp.Xerr))
				{
                    Global.RO.Info("Logging off and on user.");

                    FriendsCommon fc = new FriendsCommon();
                    fc.LogoffUser(senderPUID);
                    fc.LogonUser(senderPUID);

                    fc.LogoffUser(targetPUID);
                    fc.LogonUser(targetPUID);

					// make sure the entry is add in db .
                    object Reviewval = FeedbackWS.verifyReview((long)senderPUID.UserId, (long)targetPUID.UserId, (int)titleID, (int)type, (long)context);

					if(Reviewval==null || ((int)Reviewval)<=0)
						throw new Exception("User Review entry not found in DB");

                    int AggCount = FeedbackWS.GetAggCount(targetPUID.UserId, type);
					if(AggCount != (initialAggCount+1))
						throw new Exception("Agg Count not incremented ");

					// make sure user is added in affiliates list.
                    int AffiliatFlag = FeedbackWS.GetAffiliacteFlags(senderPUID, (long)targetPUID.UserId, (int)titleID);
					
					if(AffiliatFlag!=8)
						throw new Exception("Affiliate with Negative Feedback not added for user "+senderPUID);

                    int TargetAffiliatFlag = FeedbackWS.GetAffiliacteFlags(targetPUID, (long)senderPUID.UserId, (int)titleID);
					if(TargetAffiliatFlag!=16)
                        throw new Exception("Avoided Affiliate not added for user " + targetPUID.UserId);
					
											
					// verify that Feedback rating is added or changed for the user.

                    currentRating1 = FeedbackWS.GetRating(targetPUID.UserId);
					if(initialRating == currentRating1 )
						throw new Exception("Gamer Rating did not got updated");
				}
				else
					throw new Exception("Unexpected Error returned by server XERROR= "+resp.Xerr);

				type = req.type=(uint)PlayerReview.AvoidUnskilled;
				// send the same review secondtime. 
				Response resp2 = req.Execute();

				if(HResult.Succeeded(resp2.Xerr))
				{
                    Thread.Sleep(500);

					// make sure the entry for old type is updated 
                    object Reviewvalold = FeedbackWS.verifyReview((long)senderPUID.UserId, (long)targetPUID.UserId, (int)titleID, (int)PlayerReview.AvoidDisruptive, (long)context);

					if(Reviewvalold!=null && ((int)Reviewvalold)>0)
						throw new Exception("unexpected entry  found in DB");
					// make sure the entry is add in db .


                    object Reviewval = FeedbackWS.verifyReview((long)senderPUID.UserId, (long)targetPUID.UserId, (int)titleID, (int)type, (long)context);

					if(Reviewval==null || ((int)Reviewval)<=0)
						throw new Exception("User Review entry not found in DB");

					if(Reviewval!=null && ((int)Reviewval)!=1)
						throw new Exception("multiple entries for same review found");

                    int oldAggCount = FeedbackWS.GetAggCount(targetPUID.UserId, (uint)PlayerReview.AvoidDisruptive);
					if(oldAggCount!=1)
						throw new Exception("Aggregates not updated correctly");

                    int AggCount = FeedbackWS.GetAggCount(targetPUID.UserId, type);
					if(AggCount != (initialAggCount))
						throw new Exception("Agg Count incremented which should not be");

					// make sure user is added in affiliates list.
                    int AffiliatFlag = FeedbackWS.GetAffiliacteFlags(senderPUID, (long)targetPUID.UserId, (int)titleID);
					
					if(AffiliatFlag!=8)
						throw new Exception("Affiliate with Negative Feedback not added for user "+senderPUID);

                    int TargetAffiliatFlag = FeedbackWS.GetAffiliacteFlags(targetPUID, (long)senderPUID.UserId, (int)titleID);
					if(TargetAffiliatFlag!=16)
                        throw new Exception("Avoided Affiliate not added for user " + targetPUID.UserId);
					
					// verify that Feedback rating is added or changed for the user.

                    double currentRating = FeedbackWS.GetRating(targetPUID.UserId);
					if(currentRating1 != currentRating )
						throw new Exception("Gamer Rating changed");
				}
				else
					throw new Exception("Unexpected Error returned by server XERROR= "+resp.Xerr);

				ResultCode=TEST_RESULTS.PASSED;
			}
		}

        [TestFrequency("Daily"), TestCasePriority(2)]
		public class ChangeAvoidToPrefer : XeFeedbackTest
		{
			protected override void Execute()
			{
				ulong context=getContext();
				uint type=(uint)PlayerReview.AvoidDisruptive;
				uint titleID = 50;
				PNUser targetPUID= getPNUser();
				PNUser senderPUID= getPNUser();
                int initialAggCount = FeedbackWS.GetAggCount(targetPUID.UserId, type);
                double initialRating = FeedbackWS.GetRating(targetPUID.UserId);
				double currentRating1;
                SubmitReview req = new SubmitReview(senderPUID.UserId, targetPUID.UserId, titleID, type, context);

				Response resp = req.Execute();

				if(HResult.Succeeded(resp.Xerr))
				{
                    Global.RO.Info("Logging off and on user.");

                    FriendsCommon fc = new FriendsCommon();
                    fc.LogoffUser(senderPUID);
                    fc.LogonUser(senderPUID);

                    fc.LogoffUser(targetPUID);
                    fc.LogonUser(targetPUID);

					// make sure the entry is add in db .
                    object Reviewval = FeedbackWS.verifyReview((long)senderPUID.UserId, (long)targetPUID.UserId, (int)titleID, (int)type, (long)context);

					if(Reviewval==null || ((int)Reviewval)<=0)
						throw new Exception("User Review entry not found in DB");

                    int AggCount = FeedbackWS.GetAggCount(targetPUID.UserId, type);
					if(AggCount != (initialAggCount+1))
						throw new Exception("Agg Count not incremented ");

					// make sure user is added in affiliates list.
                    int AffiliatFlag = FeedbackWS.GetAffiliacteFlags(senderPUID, (long)targetPUID.UserId, (int)titleID);
					
					if(AffiliatFlag!=8)
                        throw new Exception("Affiliate with Negative Feedback not added for user " + senderPUID.UserId);

                    int TargetAffiliatFlag = FeedbackWS.GetAffiliacteFlags(targetPUID, (long)senderPUID.UserId, (int)titleID);
					if(TargetAffiliatFlag!=16)
						throw new Exception("Avoided Affiliate not added for user "+targetPUID);
					
											
					// verify that Feedback rating is added or changed for the user.

                    currentRating1 = FeedbackWS.GetRating(targetPUID.UserId);
					if(initialRating == currentRating1 )
						throw new Exception("Gamer Rating did not got updated");
				}
				else
					throw new Exception("Unexpected Error returned by server XERROR= "+resp.Xerr);

				type = req.type=(uint)PlayerReview.Prefer;
				// send the same review secondtime. 
				Response resp2 = req.Execute();

				if(HResult.Succeeded(resp2.Xerr))
				{
                    Global.RO.Info("Logging off and on user.");

                    FriendsCommon fc = new FriendsCommon();
                    fc.LogoffUser(senderPUID);
                    fc.LogonUser(senderPUID);

                    fc.LogoffUser(targetPUID);
                    fc.LogonUser(targetPUID);

					// make sure the entry for old type is updated 
                    object Reviewvalold = FeedbackWS.verifyReview((long)senderPUID.UserId, (long)targetPUID.UserId, (int)titleID, (int)PlayerReview.AvoidDisruptive, (long)context);

					if(Reviewvalold!=null && ((int)Reviewvalold)>0)
						throw new Exception("unexpected entry  found in DB");

                    // make sure the entry is add in db .
                    object Reviewval = FeedbackWS.verifyReview((long)senderPUID.UserId, (long)targetPUID.UserId, (int)titleID, (int)type, (long)context);

					if(Reviewval==null || ((int)Reviewval)<=0)
						throw new Exception("User Review entry not found in DB");

					if(Reviewval!=null && ((int)Reviewval)!=1)
						throw new Exception("multiple entries for same review found");

                    int oldAggCount = FeedbackWS.GetAggCount(targetPUID.UserId, (uint)PlayerReview.AvoidDisruptive);
					if(oldAggCount!=1)
						throw new Exception("Aggregates not updated correctly");

                    int AggCount = FeedbackWS.GetAggCount(targetPUID.UserId, type);
					if(AggCount != (initialAggCount))
						throw new Exception("Agg Count incremented which should not be ");

					// make sure user is added in affiliates list.
                    int AffiliatFlag = FeedbackWS.GetAffiliacteFlags(senderPUID, (long)targetPUID.UserId, (int)titleID);
					
					if(AffiliatFlag!=4)
                        throw new Exception("Affiliate with Positive Feedback not added for user " + senderPUID.UserId);
				
					// verify that Feedback rating is added or changed for the user.

                    double currentRating = FeedbackWS.GetRating(targetPUID.UserId);
					if(currentRating1 != currentRating )
						throw new Exception("Gamer Rating changed");
				}
				else
					throw new Exception("Unexpected Error returned by server XERROR= "+resp.Xerr);

				ResultCode=TEST_RESULTS.PASSED;
			}
		}

        [TestFrequency("Daily"), TestCasePriority(2)]
		public class ChangePreferToAvoid : XeFeedbackTest
		{
			protected override void Execute()
			{
				ulong context=getContext();
				uint type=(uint)PlayerReview.Prefer;
				uint titleID = 50;
				PNUser targetPUID= getPNUser();
				PNUser senderPUID= getPNUser();
                int initialAggCount = FeedbackWS.GetAggCount(targetPUID.UserId, type);
                double initialRating = FeedbackWS.GetRating(targetPUID.UserId);
				double currentRating1;
                SubmitReview req = new SubmitReview(senderPUID.UserId, targetPUID.UserId, titleID, type, context);

				Response resp = req.Execute();

				if(HResult.Succeeded(resp.Xerr))
				{
                    Global.RO.Info("Logging off and on user.");

                    FriendsCommon fc = new FriendsCommon();
                    fc.LogoffUser(senderPUID);
                    fc.LogonUser(senderPUID);

                    fc.LogoffUser(targetPUID);
                    fc.LogonUser(targetPUID);

					// make sure the entry is add in db .
                    object Reviewval = FeedbackWS.verifyReview((long)senderPUID.UserId, (long)targetPUID.UserId, (int)titleID, (int)type, (long)context);

					if(Reviewval==null || ((int)Reviewval)<=0)
						throw new Exception("User Review entry not found in DB");

                    int AggCount = FeedbackWS.GetAggCount(targetPUID.UserId, type);
					if(AggCount != (initialAggCount+1))
						throw new Exception("Agg Count not incremented ");

					// make sure user is added in affiliates list.
                    int AffiliatFlag = FeedbackWS.GetAffiliacteFlags(senderPUID, (long)targetPUID.UserId, (int)titleID);
					
					if(AffiliatFlag!=4)
						throw new Exception("Affiliate with Positive Feedback not added for user "+senderPUID);
										
					// verify that Feedback rating is added or changed for the user.

                    currentRating1 = FeedbackWS.GetRating(targetPUID.UserId);
					if(initialRating == currentRating1 )
						throw new Exception("Gamer Rating did not got updated");
				}
				else
					throw new Exception("Unexpected Error returned by server XERROR= "+resp.Xerr);

				type = req.type=(uint)PlayerReview.AvoidAggressive;
				// send the same review secondtime. 
				Response resp2 = req.Execute();

				if(HResult.Succeeded(resp2.Xerr))
				{
                    Global.RO.Info("Logging off and on user.");

                    FriendsCommon fc = new FriendsCommon();
                    fc.LogoffUser(senderPUID);
                    fc.LogonUser(senderPUID);

                    fc.LogoffUser(targetPUID);
                    fc.LogonUser(targetPUID);

                    object Reviewvalold = FeedbackWS.verifyReview((long)senderPUID.UserId, (long)targetPUID.UserId, (int)titleID, (int)PlayerReview.Prefer, (long)context);

					if(Reviewvalold!=null && ((int)Reviewvalold)>0)
						throw new Exception("unexpected entry found in DB");

					// make sure the entry is add in db .
                    object Reviewval = FeedbackWS.verifyReview((long)senderPUID.UserId, (long)targetPUID.UserId, (int)titleID, (int)type, (long)context);

					if(Reviewval==null || ((int)Reviewval)<=0)
						throw new Exception("User Review entry not found in DB");

					if(Reviewval!=null && ((int)Reviewval)!=1)
						throw new Exception("multiple entries for same review found");

                    int oldAggCount = FeedbackWS.GetAggCount(targetPUID.UserId, (uint)PlayerReview.Prefer);
					if(oldAggCount!=1)
						throw new Exception("Aggregates not updated correctly");

                    int AggCount = FeedbackWS.GetAggCount(targetPUID.UserId, type);
					if(AggCount != 0)
						throw new Exception("Agg Count incremented for second review by same user");

					// make sure user is added in affiliates list.
                    int AffiliatFlag = FeedbackWS.GetAffiliacteFlags(senderPUID, (long)targetPUID.UserId, (int)titleID);
					
					if(AffiliatFlag!=8)
                        throw new Exception("Affiliate with Negative Feedback not added for user " + senderPUID.UserId);

                    int TargetAffiliatFlag = FeedbackWS.GetAffiliacteFlags(targetPUID, (long)senderPUID.UserId, (int)titleID);
					if(TargetAffiliatFlag!=16)
                        throw new Exception("Avoided Affiliate not added for user " + targetPUID.UserId);
					
					// verify that Feedback rating is added or changed for the user.

                    double currentRating = FeedbackWS.GetRating(targetPUID.UserId);
					if(currentRating1 != currentRating )
						throw new Exception("Gamer Rating changed");
				
				}
				else
					throw new Exception("Unexpected Error returned by server XERROR= "+resp.Xerr);

				ResultCode=TEST_RESULTS.PASSED;
			}
		}

        [TestFrequency("Daily"), TestCasePriority(2)]
        public class RatingCanBeUpdatedTwice : XeFeedbackTest
        {
            protected override void Execute()
            {
                ulong context = getContext();
                uint type = (uint)PlayerReview.Prefer;
                uint titleID = 50;
                PNUser targetPUID = getPNUser();
                PNUser senderPUID = getPNUser();
                PNUser secondSenderPUID = getPNUser();
                double initialRating = FeedbackWS.GetRating(targetPUID.UserId);
                double ratingAfterOneFeedback;

                SubmitReview req = new SubmitReview(senderPUID.UserId, targetPUID.UserId, titleID, type, context);

                Response resp = req.Execute();

                if (HResult.Succeeded(resp.Xerr))
                {
                    Global.RO.Info("Logging off and on user.");

                    FriendsCommon fc = new FriendsCommon();
                    fc.LogoffUser(senderPUID);
                    fc.LogonUser(senderPUID);

                    fc.LogoffUser(targetPUID);
                    fc.LogonUser(targetPUID);

                    // verify that Feedback rating is added or changed for the user.
                    ratingAfterOneFeedback = FeedbackWS.GetRating(targetPUID.UserId);
                    if (initialRating == ratingAfterOneFeedback)
                        throw new Exception("Gamer Rating did not got updated");
                }
                else
                    throw new Exception("Unexpected Error returned by server XERROR= " + resp.Xerr);

                // send the same review second time. 
                SubmitReview req2 = new SubmitReview(secondSenderPUID.UserId, targetPUID.UserId, titleID, type, context);
                Response resp2 = req2.Execute();

                if (HResult.Succeeded(resp2.Xerr))
                {
                    // verify that Feedback rating is added or changed for the user.
                    double ratingAfterTwoFeedbacks = FeedbackWS.GetRating(targetPUID.UserId);
                    if (ratingAfterTwoFeedbacks == ratingAfterOneFeedback)
                        throw new Exception("Gamer Rating did not change");
                }
                else
                    throw new Exception("Unexpected Error returned by server XERROR= " + resp.Xerr);

                ResultCode = TEST_RESULTS.PASSED;
            }
        }

        [TestFrequency("Daily"), TestCasePriority(2)]
		public class SameReviewsTwice : XeFeedbackTest
		{
			protected override void Execute()
			{
				ulong context=getContext();
				uint type=(uint)PlayerReview.Prefer;
				uint titleID = 50;
                PNUser targetPUID = getPNUser();
                PNUser senderPUID = getPNUser();
                int initialAggCount = FeedbackWS.GetAggCount(targetPUID.UserId, type);
                double initialRating = FeedbackWS.GetRating(targetPUID.UserId);
				double currentRating1;
                SubmitReview req = new SubmitReview(senderPUID.UserId, targetPUID.UserId, titleID, type, context);

				Response resp = req.Execute();

				if(HResult.Succeeded(resp.Xerr))
				{
                    Global.RO.Info("Logging off and on user.");

                    FriendsCommon fc = new FriendsCommon();
                    fc.LogoffUser(senderPUID);
                    fc.LogonUser(senderPUID);

                    fc.LogoffUser(targetPUID);
                    fc.LogonUser(targetPUID);

					// make sure the entry is add in db .
                    object Reviewval = FeedbackWS.verifyReview((long)senderPUID.UserId, (long)targetPUID.UserId, (int)titleID, (int)type, (long)context);

					if(Reviewval==null || ((int)Reviewval)<=0)
						throw new Exception("User Review entry not found in DB");

                    int AggCount = FeedbackWS.GetAggCount(targetPUID.UserId, type);
					if(AggCount != (initialAggCount+1))
						throw new Exception("Agg Count not incremented ");

					// make sure user is added in affiliates list.
                    int AffiliatFlag = FeedbackWS.GetAffiliacteFlags(senderPUID, (long)targetPUID.UserId, (int)titleID);
					
					if(AffiliatFlag!=4)
                        throw new Exception("Affiliate with Positive Feedback not added for user " + senderPUID.UserId);
										
					// verify that Feedback rating is added or changed for the user.

                    currentRating1 = FeedbackWS.GetRating(targetPUID.UserId);
					if(initialRating == currentRating1 )
						throw new Exception("Gamer Rating did not got updated");
				}
				else
					throw new Exception("Unexpected Error returned by server XERROR= "+resp.Xerr);

				// send the same review secondtime. 
				Response resp2 = req.Execute();

				if(HResult.Succeeded(resp2.Xerr))
				{
					// make sure the entry is add in db .
                    object Reviewval = FeedbackWS.verifyReview((long)senderPUID.UserId, (long)targetPUID.UserId, (int)titleID, (int)type, (long)context);

					if(Reviewval==null || ((int)Reviewval)<=0)
						throw new Exception("User Review entry not found in DB");

					if(Reviewval!=null && ((int)Reviewval)!=1)
						throw new Exception("multiple entries for same review found");

                    int AggCount = FeedbackWS.GetAggCount(targetPUID.UserId, type);
					if(AggCount != (initialAggCount+1))
						throw new Exception("Agg Count not incremented ");

					// make sure user is added in affiliates list.
                    int AffiliatFlag = FeedbackWS.GetAffiliacteFlags(senderPUID, (long)targetPUID.UserId, (int)titleID);
					
					if(AffiliatFlag!=4)
						throw new Exception("Affiliate with Positive Feedback not added for user "+senderPUID);
										
					// verify that Feedback rating is added or changed for the user.

                    double currentRating = FeedbackWS.GetRating(targetPUID.UserId);
					if(currentRating1 != currentRating )
						throw new Exception("Gamer Rating changed");
				}
				else
					throw new Exception("Unexpected Error returned by server XERROR= "+resp.Xerr);

				ResultCode=TEST_RESULTS.PASSED;
			}
		}

        [TestFrequency("BVT"), TestCasePriority(1)]
		public class Reviews : XeFeedbackTest
		{
			uint type ;
			uint ExpectedXErr=HResult.S_OK;
			public Reviews(string name ,uint ReviewType):base(name)
			{
				type= ReviewType;
			}

			public Reviews(string name ,uint ReviewType, uint XErr):base(name)
			{
				type= ReviewType;
				ExpectedXErr= XErr;
			}

			protected override void Execute()
			{
                SendReviewAndVerify(getPNUser(), getPNUser(), 50, type, getContext(), ExpectedXErr);
				ResultCode = TEST_RESULTS.PASSED;
			}
		}

        [TestFrequency("Regression"), TestCasePriority(3)]
		public class NegXRLUserAgent : FeedbackTest
		{
			protected override void Execute()
			{
				MemoryStream		reqStream = new MemoryStream();
				BinaryWriter		bw = new BinaryWriter(reqStream);
				HttpWebRequest httpreq;
				HttpWebResponse response;
				Stream httpStream;

				// Construct valid request stream
				bw.Write(getRealUserPuid());
				bw.Write(getRealUserPuid());
				bw.Write((uint)50);
				bw.Write((uint)1);
				bw.Write((long)0x07);

				// TEST: remove ContentType so XRL is rejected
				// Create and HTTP request and add headers
				string url= "http://"+Global.XEnv.GetVirtualInterface(VirtualInterface.fbserver).Address.ToString()+":"+ Global.XEnv.GetVirtualInterface(VirtualInterface.fbserver).Port.ToString()+"/fbserver/submitreview.ashx";
				httpreq = (HttpWebRequest) WebRequest.Create(url);
				httpreq.Method = "POST";
				httpreq.ProtocolVersion = HttpVersion.Version10;
				httpreq.Headers.Add("Relja: true");
				httpreq.ContentType = "xon/8";
				httpreq.ContentLength = reqStream.Length;

				// attach the request data we wrote to the HTTP request
				httpStream = httpreq.GetRequestStream();
				reqStream.WriteTo(httpStream);
				httpStream.Close();

				httpreq.Timeout = 2000;

				try
				{
					response = (HttpWebResponse) httpreq.GetResponse();
				}
				catch( System.Net.WebException e )
				{
					// GetResponse() throws exception on HTTP 500
					response = (HttpWebResponse) e.Response;
					if ( (response != null) && (response.StatusCode == HttpStatusCode.InternalServerError) )
					{
						ResultCode=TEST_RESULTS.PASSED;
						return;
					}
				}

				// FAILED -- either request succeeded unexpectedly or we got back the wrong code
				if ( response != null )
					ConsoleX.WriteLine("\nRESPONSE: " + response.StatusCode.ToString() + " " + response.GetResponseHeader("XErr") );
			}
		}

        [TestFrequency("Regression"), TestCasePriority(3)]
		public class NegXRLService : FeedbackTest
		{
			protected override void Execute()
			{
				MemoryStream		reqStream = new MemoryStream();
				BinaryWriter		bw = new BinaryWriter(reqStream);
				HttpWebRequest httpreq;
				HttpWebResponse response;
				Stream httpStream;

				// Construct valid request stream
				bw.Write(getRealUserPuid());
				bw.Write(getRealUserPuid());
				bw.Write((uint)50);
				bw.Write((uint)1);
				bw.Write((long)0x07);

				// TEST: remove ContentType so XRL is rejected
				// Create and HTTP request and add headers
				string url= "http://"+Global.XEnv.GetVirtualInterface(VirtualInterface.fbserver).Address.ToString()+":"+ Global.XEnv.GetVirtualInterface(VirtualInterface.fbserver).Port.ToString()+"/fbserver/submitreview.ashx";
				httpreq = (HttpWebRequest) WebRequest.Create(url);
				httpreq.Method = "POST";
				httpreq.ProtocolVersion = HttpVersion.Version10;
				httpreq.Headers.Add("Relja: true");
				httpreq.UserAgent = "8/0.10.4715";
				httpreq.ContentLength = reqStream.Length;

				// attach the request data we wrote to the HTTP request
				httpStream = httpreq.GetRequestStream();
				reqStream.WriteTo(httpStream);
				httpStream.Close();

				httpreq.Timeout = 2000;

				try
				{
					response = (HttpWebResponse) httpreq.GetResponse();
				}
				catch( System.Net.WebException e )
				{
					// GetResponse() should throw 404 here
					response = (HttpWebResponse) e.Response;
					if ( (response != null) && (response.StatusCode == HttpStatusCode.NotFound) )
					{
						ResultCode=TEST_RESULTS.PASSED;
						return;
					}
				}

				// FAILED -- either request succeeded unexpectedly or we got back the wrong code
				if ( response != null )
					ConsoleX.WriteLine("\nRESPONSE: " + response.StatusCode.ToString() + " " + response.GetResponseHeader("XErr") );
			}
		}
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\StfTests\Feedback\Feedback\StressTOU.cs ===
using System;
using System.Net;
using ServerTestFramework;
using xonline.common.config;

namespace Feedback.Stress
{
	/// <summary>
	/// Summary description for StressTOU.
	/// </summary>
    [StressInstantiate]
	public class TOU : TestBase
	{
		string []Countries={"AT", "AU", "BE", "CA", "CH", "DE" ,"DK", "ES", "FI", "FR", "GB", "IE", "IT", "JP", "NL", "NO", "SE", "US"};

		protected override void Execute()
		{
			string request;
			string country=Countries[ServerTestFramework.Utilities.RandomEx.GlobalRandGen.Next(0,Countries.Length)];
			request=@"http://"+Global.XEnv.GetVirtualInterface(xonline.common.config.VirtualInterface.fbserver)+@":91/"+country+@"/TermsOfUse.ini";
			HttpWebRequest wr=(HttpWebRequest) WebRequest.Create(request);
			wr.ContentType=@"xon/8";
			wr.UserAgent=@"8/0.10.4715";
			HttpWebResponse resp;
			try
			{
				resp=(HttpWebResponse) wr.GetResponse();
			}
			catch (System.Net.WebException)
			{
				Console.WriteLine("Failed to get "+request);
				return;
			}
			ResultCode=TEST_RESULTS.PASSED;
			resp.Close();
		}
	}

    [StressInstantiate]
	public class MessageOfDay : TestBase
	{
		string []Countries={"AT", "AU", "BE", "CA", "CH", "DE" ,"DK", "ES", "FI", "FR", "GB", "IE", "IT", "JP", "NL", "NO", "SE", "US"};

		protected override void Execute()
		{
			string request;
			string country=Countries[ServerTestFramework.Utilities.RandomEx.GlobalRandGen.Next(0,Countries.Length)];
			request=@"http://"+Global.XEnv.GetVirtualInterface(VirtualInterface.xtou).Address.ToString()+@":"+Global.XEnv.GetVirtualInterface(VirtualInterface.xtou).Port.ToString()+"/motd/"+country+@"/english.txt";
			HttpWebRequest wr=(HttpWebRequest) WebRequest.Create(request);
			wr.ContentType=@"xon/8";
			wr.UserAgent=@"8/0.10.4715";
			HttpWebResponse resp;
			try
			{
				resp=(HttpWebResponse) wr.GetResponse();
			}
			catch (System.Net.WebException)
			{
				Console.WriteLine("Failed to get "+request);
				return;
			}
			ResultCode=TEST_RESULTS.PASSED;
			resp.Close();
		}
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\StfTests\Feedback\Feedback\objd\i386\_asmid.inc ===
ASSEMBLY_IDENTITY_KEY_FORM=msil_feedback_none_12.4.56.0_none_9e2c6ed03a131a94
ASSEMBLY_IDENTITY_XP_KEY_FORM=msil_feedback_no-public-key_12.4.56.0_x-ww_f5c5aac8
ASSEMBLY_IDENTITY_CULTURE=
ASSEMBLY_IDENTITY_NAME=feedback
ASSEMBLY_IDENTITY_PROCESSOR_ARCHITECTURE=msil
ASSEMBLY_IDENTITY_PUBLIC_KEY=
ASSEMBLY_IDENTITY_PUBLIC_KEY_TOKEN=
ASSEMBLY_IDENTITY_TYPE=
ASSEMBLY_IDENTITY_TYPE_NAME=
ASSEMBLY_IDENTITY_VERSION=12.4.56.0
XP_KEY_FORM=msil_feedback_no-public-key_12.4.56.0_x-ww_f5c5aac8
XP_MANIFEST_DIRECTORY=manifests
XP_MANIFEST_NAME=msil_feedback_no-public-key_12.4.56.0_x-ww_f5c5aac8.manifest
XP_MANIFEST_PATH=manifests\msil_feedback_no-public-key_12.4.56.0_x-ww_f5c5aac8.manifest
XP_CATALOG_DIRECTORY=manifests
XP_CATALOG_NAME=msil_feedback_no-public-key_12.4.56.0_x-ww_f5c5aac8.cat
XP_CATALOG_PATH=manifests\msil_feedback_no-public-key_12.4.56.0_x-ww_f5c5aac8.cat
XP_PAYLOAD_PATH=msil_feedback_no-public-key_12.4.56.0_x-ww_f5c5aac8
_DELAY_SIGN=0
!if [set _ASMIDTOATTRIBS_TLBIMP=]
!endif
CODESIGN_TESTKEY=
_TLBIMP_FLAGS=$(_TLBIMP_FLAGS)  /asmversion:12.4.56.0
_ASSEMBLY_IDENTITY=feedback,processorArchitecture=msil,version=12.4.56.0,publicKeyToken=neutral
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\StfTests\Feedback\Feedback\XeComplaint.cs ===
using System;
using System.Threading;
using System.IO;
using System.Net;
using System.Text;
using ServerTestFramework;
//using ServerTestFramework.LiveService;
using ServerTestFramework.LiveService.Feedback;
using ServerTestFramework.LiveService.Presence;
using ServerTestFramework.LiveService.PresNotiCommon;
using ServerTestFramework.LiveService.Achievement;
using xonline.common.config;
using xonline.common.service;

namespace Feedback
{
	/// <summary>
	/// Summary description for XeComplaint.
	/// </summary>
	public class FuncComplaintTests : TestNode
	{
		public FuncComplaintTests()
		{

			Type pComplaintType = typeof(ComplaintType);
			int icount =0;
			foreach(string s in Enum.GetNames(pComplaintType))
			{
				icount++;
				uint type= (uint)Enum.Parse(pComplaintType,s);
                AddChild(new Complaints(s,type) );
			}

            AddChild(new Complaints("InvalidType",(uint)icount,HResult.XONLINE_E_FEEDBACK_BAD_TYPE) );
            AddChild(new Complaints("MaxType",(uint)0xFFFFFFFF,HResult.XONLINE_E_FEEDBACK_BAD_TYPE) );
            AddChild(new SameComplaints2());
            AddChild(new InvalidSender());
            AddChild(new InvalidTarget());
            AddChild(new SameSenderTarget());


            AddChild(new NegXRLUserAgent());
            AddChild(new NegXRLService());

            AddChild(new TCInvalidZeroPKT());
            AddChild(new TCInvalidSmallPKT());
            AddChild(new TCInvalidLargePKT());

			
		}

        [TestFrequency("Regression"), TestCasePriority(3)]
		public class SameSenderTarget : XeFeedbackTest
		{
			protected override void Execute()
			{
				ulong spuid = getRealUserPuid();
			
				SendComplaintAndVerify(spuid, spuid,50,(uint)ComplaintType.OffensiveInGame,getContext(),HResult.XONLINE_E_FEEDBACK_NULL_TARGET);
				ResultCode = TEST_RESULTS.PASSED;
			}
		}

        [TestFrequency("Regression"), TestCasePriority(3)]
		public class InvalidTarget : XeFeedbackTest
		{
			protected override void Execute()
			{
				ulong spuid = getRealUserPuid();

                SendComplaintAndVerify(spuid, 12345, 50, (uint)ComplaintType.OffensiveInGame, getContext(), HResult.XONLINE_E_DATABASE_EXECUTE_ERROR);
				ResultCode = TEST_RESULTS.PASSED;
			}
		}

        [TestFrequency("Regression"), TestCasePriority(3)]
		public class InvalidSender : XeFeedbackTest
		{
			protected override void Execute()
			{
				ulong spuid = getRealUserPuid();
				ulong tpuid =getRealUserPuid();
                SendComplaintAndVerify(spuid, tpuid, 50, (uint)ComplaintType.OffensiveInGame, getContext(), HResult.XONLINE_E_FEEDBACK_USER_NOT_PRESENT, Modify.Change_User);
				ResultCode = TEST_RESULTS.PASSED;
			}
		}

        [TestFrequency("Daily"), TestCasePriority(2)]
		public class SameComplaints2 : XeFeedbackTest
		{
			protected override void Execute()
			{
				ulong spuid = getRealUserPuid();
				ulong tpuid =getRealUserPuid();
				SendComplaintAndVerify(spuid, tpuid,50,(uint)ComplaintType.OffensiveInGame,getContext(),1);
				SendComplaintAndVerify(spuid, tpuid,50,(uint)ComplaintType.OffensiveInGame,getContext(),1);
				ResultCode = TEST_RESULTS.PASSED;
			}
		}

        [TestFrequency("BVT"), TestCasePriority(1)]
		public class Complaints : XeFeedbackTest
		{
			uint type ;
			uint ExpectedXErr=HResult.S_OK;
			public Complaints(string name ,uint ReviewType):base(name)
			{
				type= ReviewType;
			}
			public Complaints(string name ,uint ReviewType,uint Xerr):base(name)
			{
				type= ReviewType;
				ExpectedXErr =Xerr;
			}

			protected override void Execute()
			{
				SendComplaintAndVerify(getRealUserPuid(), getRealUserPuid(),50,type,getContext(),ExpectedXErr);
				ResultCode = TEST_RESULTS.PASSED;
			}
		}

        [TestFrequency("Regression"), TestCasePriority(3)]
		public class TCInvalidZeroPKT:TestBase
		{
			override protected void Execute()
			{

				InvalidFBRequest tmp = new InvalidFBRequest(0,"/fbserver/getaggreview.ashx");
				uint xerror= tmp.Execute();
				if(xerror != HResult.XONLINE_E_INVALID_REQUEST)
					throw new Exception("Invalid Xerror Expected :"+ HResult.E_FAIL+" recived:"+xerror);

				ResultCode=TEST_RESULTS.PASSED;
			}
		}

        [TestFrequency("Regression"), TestCasePriority(3)]
		public class TCInvalidSmallPKT:TestBase
		{
			override protected void Execute()
			{

				InvalidFBRequest tmp = new InvalidFBRequest(10,"/fbserver/getaggreview.ashx");
				uint xerror= tmp.Execute();
				if(xerror != HResult.XONLINE_E_INVALID_REQUEST)
					throw new Exception("Invalid Xerror Expected :"+ HResult.E_FAIL+" recived:"+xerror);

				ResultCode=TEST_RESULTS.PASSED;
			}
		}

        [TestFrequency("Regression"), TestCasePriority(3)]
		public class TCInvalidLargePKT:TestBase
		{
			override protected void Execute()
			{
				InvalidFBRequest tmp = new InvalidFBRequest(1000,"/fbserver/getaggreview.ashx");
				uint xerror= tmp.Execute();
				if(xerror != HResult.XONLINE_E_INVALID_REQUEST)
					throw new Exception("Invalid Xerror Expected :"+ HResult.E_FAIL+" recived:"+xerror);

				ResultCode=TEST_RESULTS.PASSED;
			}
		}

        [TestFrequency("Regression"), TestCasePriority(3)]
		public class NegXRLUserAgent : FeedbackTest
		{
			protected override void Execute()
			{
				MemoryStream		reqStream = new MemoryStream();
				BinaryWriter		bw = new BinaryWriter(reqStream);
				HttpWebRequest httpreq;
				HttpWebResponse response;
				Stream httpStream;

				// Construct valid request stream
				bw.Write(getRealUserPuid());
				bw.Write(getRealUserPuid());
				bw.Write((uint)50);
				bw.Write((uint)1);
				bw.Write((long)0x07);

				// TEST: remove ContentType so XRL is rejected
				// Create and HTTP request and add headers
				string url= "http://"+Global.XEnv.GetVirtualInterface(VirtualInterface.fbserver).Address.ToString()+":"+ Global.XEnv.GetVirtualInterface(VirtualInterface.fbserver).Port.ToString()+"/fbserver/getaggreview.ashx";
				httpreq = (HttpWebRequest) WebRequest.Create(url);
				httpreq.Method = "POST";
				httpreq.ProtocolVersion = HttpVersion.Version10;
				httpreq.Headers.Add("Relja: true");
				httpreq.ContentType = "xon/8";
				httpreq.ContentLength = reqStream.Length;

				// attach the request data we wrote to the HTTP request
				httpStream = httpreq.GetRequestStream();
				reqStream.WriteTo(httpStream);
				httpStream.Close();
				httpreq.Timeout = 2000;

				try
				{
					response = (HttpWebResponse) httpreq.GetResponse();
				}
				catch( System.Net.WebException e )
				{
					// GetResponse() throws exception on HTTP 500
					response = (HttpWebResponse) e.Response;
					if ( (response != null) && (response.StatusCode == HttpStatusCode.InternalServerError) )
					{
						ResultCode=TEST_RESULTS.PASSED;
						return;
					}
				}

				// FAILED -- either request succeeded unexpectedly or we got back the wrong code
				if ( response != null )
					Global.RO.Error("\nRESPONSE: " + response.StatusCode.ToString() + " " + response.GetResponseHeader("XErr") );
			}
		}

        [TestFrequency("Regression"), TestCasePriority(3)]
		public class NegXRLService : FeedbackTest
		{
			protected override void Execute()
			{
				MemoryStream		reqStream = new MemoryStream();
				BinaryWriter		bw = new BinaryWriter(reqStream);
				HttpWebRequest httpreq;
				HttpWebResponse response;
				Stream httpStream;

				// Construct valid request stream
				bw.Write(getRealUserPuid());
				bw.Write(getRealUserPuid());
				bw.Write((uint)50);
				bw.Write((uint)1);
				bw.Write((long)0x07);
				

				// TEST: remove ContentType so XRL is rejected
				// Create and HTTP request and add headers
				string url= "http://"+Global.XEnv.GetVirtualInterface(VirtualInterface.fbserver).Address.ToString()+":"+ Global.XEnv.GetVirtualInterface(VirtualInterface.fbserver).Port.ToString()+"/fbserver/getaggreview.ashx";
				httpreq = (HttpWebRequest) WebRequest.Create(url);
				httpreq.Method = "POST";
				httpreq.ProtocolVersion = HttpVersion.Version10;
				httpreq.Headers.Add("Relja: true");
				httpreq.UserAgent = "8/0.10.4715";
				httpreq.ContentLength = reqStream.Length;

				// attach the request data we wrote to the HTTP request
				httpStream = httpreq.GetRequestStream();
				reqStream.WriteTo(httpStream);
				httpStream.Close();

				httpreq.Timeout = 2000;

				try
				{
					response = (HttpWebResponse) httpreq.GetResponse();
				}
				catch( System.Net.WebException e )
				{
					// GetResponse() should throw 404 here
					response = (HttpWebResponse) e.Response;
					if ( (response != null) && (response.StatusCode == HttpStatusCode.NotFound) )
					{
						ResultCode=TEST_RESULTS.PASSED;
						return;
					}
				}

				// FAILED -- either request succeeded unexpectedly or we got back the wrong code
				if ( response != null )
					Global.RO.Error("\nRESPONSE: " + response.StatusCode.ToString() + " " + response.GetResponseHeader("XErr") );
			}
		}
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\StfTests\GPStress\GPStress.cs ===
using System;
using System.IO;
using System.Collections;
using ServerTestFramework;
using ServerTestFramework.Utilities;
using ServerTestFramework.Database;
using  ServerTestFramework.LiveService;
using  ServerTestFramework.LiveService.UserSettings;
using xonline.common.config;

[assembly: RootNode(typeof(GPStress.GPStress))]

namespace GPStress
{
    /// <summary>
    /// Summary description for Class1.
    /// </summary>
    [Owner("KKline"), EnvRequirement("Stress"), TestFrequency("Regression")]
    public class GPStress : TestNode
    {
        public GPStress()
        {
            AddStressChildAndPrefixName(new SyncSettings());
            AddStressChildAndPrefixName(new GetSettings());
            AddStressChildAndPrefixName(new SyncAchievements());
            AddStressChildAndPrefixName(new EnumAchievements());
            AddStressChildAndPrefixName(new SyncTitleInfo());
            AddStressChildAndPrefixName(new EnumTitleInfo());
            AddStressChildAndPrefixName(new DeleteTitle());
            AddStressChildAndPrefixName(new SyncAvatarAssets());
            AddStressChildAndPrefixName(new EnumAvatarAssets());
            AddStressChildAndPrefixName(new UploadConsoleAuditList());
            AddStressChildAndPrefixName(new ValidateAvatarManifests());
        }

        public void AddStressChildAndPrefixName(TestNode n)
        {
            n.Name="GPStress "+n.Name;
            AddChild(n, false, true);
        }

        public override void PreRun(RUN_TYPE runType)
        {
            if (runType == RUN_TYPE.STRESS)
            {
                DBHelper.ClearTestSettings();
                int max = StressConst.max_settings;
                for (int i = 1; i < max; i++)
                {
                    DBHelper.AddSetting((int)TestUSetting.Test_bMaxNo + i, (TestUSetting.Test_bMaxNo.ToString() + i), "t_user_settings", 0);

                }

                //Global.XEnv.ExecuteXmgmtCommand(Interface.xstatsfd, "e :xstatsfd cacheflush");
                Global.RO.SetLevelFilter(Report.DEBUG | Report.WARN | Report.ERROR | Report.FATAL);

                //supposedly the person manually ran bulkusers before running this test. read the hardcoded output from stf.xml
                //GetUserSet throws an exception when the stf.xml line isn't there. good for GetUserSet
                BulkUserSet userSet = STFLiveGlobal.GetUserSet("xenon");
                StressConst.UMask = userSet.Base;
                StressConst.TotalUsers = (ulong)userSet.Count;
                if (StressConst.windowsize > StressConst.TotalUsers) StressConst.windowsize = StressConst.TotalUsers;

                Global.RO.Info("Checking to see if stress titles are propped correctly. This might take a little while.");
                //check to see if the titles are propped
                //yoinked from jefferson's gamerprofile addition
                string pathToConfigFiles = "InputFiles\\GamerProfile\\";
                //let's make sure the title information is present...
                for (uint title = (uint)StressConst.TitleStart; title < StressConst.TitleCount + StressConst.TitleStart; title++)
                {
                    try
                    {
                        TitleConfig.GetTitle(title);
                    }
                    catch (ApplicationException)
                    {
                        //prop the title accordingly
                        Global.RO.Info("Title number " + title + " not found in NPDB--attempting to remedy via sql file...");
                        try
                        {
                            string totalPath = pathToConfigFiles + "200titles.sql";
                            StreamReader file = File.OpenText(totalPath);
                            String sql;
                            sql = file.ReadToEnd();

                            int indexOfStart = sql.IndexOf("*");
                            sql = sql.Remove(indexOfStart, 1);
                            sql = sql.Insert(indexOfStart, title.ToString());

                            int indexOfEnd = sql.IndexOf("*");
                            sql = sql.Remove(indexOfEnd, 1);
                            sql = sql.Insert(indexOfEnd, (StressConst.TitleCount + StressConst.TitleStart).ToString());

                            Npdb npdb = new Npdb();
                            npdb.ConnectToServer();
                            npdb.IssueCommand(sql);
                            npdb.Close();

                        }
                        catch (Exception e)
                        {
                            Global.RO.Warn("Could not prop title " + title + "!  Test results may be inaccurate.");
                            Global.RO.Warn("Text is as follows:" + e.ToString());
                        }
                        Global.RO.Info("Title configuration info added successfully!");
                    }
                }

                #region cutcode
                //add titles to the users

                /*for(long i=StressSupport.Users.windowstart; i<StressSupport.Users.windowstart+StressConst.windowsize; i++)
                {
                    ulong userID = StressConst.UMask + (ulong) i;
                    uint Count = (uint)StressConst.numPlayedTitles;
                    UserTitle[] titles = null;
                    if (Count > 32) titles = new UserTitle[32];
                    else
                        titles= new UserTitle[Count];
                    RandomEx rand = new RandomEx();
                    int index=0;
                    for(uint j=0;j< Count;j++)
                    {
                        int data =  rand.Next(1,72);
                        DateTime tmp = DateTime.UtcNow;
                        tmp = tmp.AddHours((-1*data));
                        uint titleID = (uint) rand.Next(StressConst.TitleStart, StressConst.TitleCount+StressConst.TitleStart);
                        titles[index]= new UserTitle(titleID,tmp,(uint)data,(ushort)data,(uint)data);
                        if (j !=0 && j%31==0)
                        {
                            //we've reached the 32 limit, we must do the requesting now.
                            SyncTitlesRequest req= new SyncTitlesRequest(userID,DateTime.UtcNow,titles);

                            SyncTitlesResponse resp = req.Execute();
                            if(HResult.Failed(resp.XError))
                                throw new HResultException(resp.XError, "Setup stage failed: Error adding titles to user "+userID+".");

                            index=-1; //reset index so that it overwrites the existing titles in titles. at the very end, we'll sync some duplicate titles, but that's OK.
                        }

                        index++;
                    }

                    SyncTitlesRequest reqq = new SyncTitlesRequest(userID,DateTime.UtcNow,titles);

                    SyncTitlesResponse respp = reqq.Execute();
                    if(HResult.Failed(respp.XError))
                        throw new HResultException(respp.XError, "Setup stage failed: Error adding titles to user "+userID+".");
                }*/

                //add achievements to the users
                #endregion

                StressSupport.SM.Initialize("Suites\\ProfileStressSettings.xml");
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\StfTests\GPStress\support.cs ===
//1TODO: Fix title choosing ratios for GetSettings
//      All read settings requests use the same title choosing mechanisms. However, each setting request has a slightly (and sometimes not so slight) different title request ratio
using System;
using System.Collections;
using System.Threading;
using System.Xml;
using System.IO;
using xonline.common.config;
using ServerTestFramework;
using ServerTestFramework.Database;
using ServerTestFramework.LiveService;
using ServerTestFramework.LiveService.UserSettings;
using ServerTestFramework.LiveService.Achievement;
using ServerTestFramework.LiveService.AvatarAsset;
using ServerTestFramework.LiveService.Presence;
using ServerTestFramework.LiveService.PresNotiCommon;
using ServerTestFramework.LiveService.UploadConsoleList;
using ServerTestFramework.LiveService.FakeSG;
using ServerTestFramework.Utilities;

namespace GPStress
{
    
    public class StressConst
    {
        static public ulong windowsize=30000; //start at 30000 and go to TotalUsers
        //static public long NoOFUsersToRotatePerMin= 1;
        static public ulong UMask = 0x900000151c9a6;  //default value if not set
        static public ulong TotalUsers= 1000000;
        static public int TitleStart=11000;
        static public int TitleCount=1000;
        static public int numPlayedTitles = 10;
        static public int max_settingstoSync= 10;
        static public int max_settings= 120;
    }

    public class TitleInfo
    {
        public uint titleid;
        //Changed to start at 0 because the first time for a user it does an increment to 1
        public int NextAchievementID=0;
        //Start at 0 because the first time for a user it does an increment
        public int NextAvatarAssetID = 0;  
        //public Hashtable settings= new Hashtable();

        public TitleInfo(uint title)
        {
            titleid= title;
        }

    }

    public class UserTitleObject
    {
        public Hashtable users;
        

        public UserTitleObject(ulong user, uint title)
        {
            users = Hashtable.Synchronized(new Hashtable());
            ArrayList temp = new ArrayList();
            temp.Add(title);
            users[user] = temp;
        }
        public UserTitleObject(ulong user, ArrayList titleArray)
        {
            users = Hashtable.Synchronized(new Hashtable());
            users[user] = titleArray;
        }
        public void AddUser(ulong userid, ArrayList titleArray)
        {
            lock(users)
            {
                if (!users.Contains(userid)) users[userid] = titleArray;
            }
        }
        public ulong RemoveRandomUser(out ArrayList titleArray, out bool emptyUsers)
        {
            RandomEx rand = new RandomEx();
            ulong userid = 0;
            lock(users)
            {
                int index = rand.Next(0, users.Count);
                foreach(ulong user in users.Keys)
                {
                    if (index == 0) userid = user;
                    index --;
                }
                titleArray = (ArrayList) users[userid];
                users.Remove(userid);
                 if (users.Count == 0) emptyUsers = true;
                else 
                    emptyUsers = false;
            }
           
            return userid;
        }
        public ulong GetRandomUser()
        {
            RandomEx rand = new RandomEx();
            ulong userid = 0;
            lock(users)
            {
                int index = rand.Next(0, users.Count);
                foreach(ulong user in users.Keys)
                {
                    if (index == 0) userid = user;
                    index --;
                }
            }
            return userid;
        }
         public void RemoveUser(ulong userid, out bool emptyUsers)
        {
            lock(users)
            {
                users.Remove(userid);
                 if (users.Count == 0) emptyUsers = true;
                else 
                    emptyUsers = false;
            }
        }

    }

    public class ScrollingWindow
    {
        public long windowstart=0;
        public long CurrentUser=0;
    }

    public class RedSetReq
    {
        public uint title;
        public ulong user;
        public ulong[] forUsers;
        public uint[] sifds;
    }

    public class UserRatio
    {
        public int numUsers;
        public double ratio;
        public UserRatio(int n, double r)
        {
            numUsers = n;
            ratio = r;
        }
    }
        
    public class TitleRatio
    {
        public uint titleID;
        public double ratio;
        public TitleRatio(uint t, double r)
        {
            titleID = t;
            ratio = r;
        }
    }

    public class TypeBase
    {
        public string name;
        public double ratio;
        public ScenarioBase[] scenarios;

        public ScenarioBase GetNextScenario()
        {
            //all the ratio's pretty much add up to 1
            RandomEx rand = new RandomEx();
            double randRatio = (double) rand.Next(1,1000) / (double) 1000;

            //find the scenario to return
            double currentRatio = 0;
            for(int i=0; i<scenarios.Length; i++)
            {
                currentRatio+=scenarios[i].ratio;
                if (randRatio < currentRatio) return scenarios[i];
            }
            return scenarios[scenarios.Length - 1];
        }
         public void convertTitlesToFake(ref uint startFake, uint stopFake, uint restartFake, Hashtable realToFake)
         {
            if (scenarios == null) return;
            foreach(ScenarioBase sb in scenarios)
            {
                sb.convertTitlesToFake(ref startFake, stopFake, restartFake, realToFake);
            }
         }
        
    }

    public class ScenarioBase
    {
         public double ratio;
         public TitleRatio[] titles;
         public uint GetNextTitleID()
         {
             //all the ratio's pretty much add up to 1
            RandomEx rand = new RandomEx();
            double randRatio = (double) rand.Next(1,1000) / (double) 1000;

            double currentRatio = 0;
            for(int i=0; i<titles.Length; i++)
            {
                currentRatio+=titles[i].ratio;
                if (randRatio < currentRatio) return titles[i].titleID;
            }
            return titles[titles.Length - 1].titleID;
         }
         public uint GetNextTitleIDNotInArrayList(ArrayList list, ref double sumofweights)
         {
            RandomEx rand = new RandomEx();
            double randRatio = (double) rand.Next(1,(int)(1000-sumofweights*1000)) / (double) 1000;

            double currentRatio = 0;
            for(int i=0; i<titles.Length; i++)
            {
                if (list.Contains(titles[i].titleID)) continue;
                
                currentRatio+=titles[i].ratio;
                if (randRatio < currentRatio) 
                {
                    sumofweights+=titles[i].ratio;
                    return titles[i].titleID;
                }
            }
            
            sumofweights+=titles[titles.Length - 1].ratio;
            return titles[titles.Length - 1].titleID;
         }
         public void convertTitlesToFake(ref uint startFake, uint stopFake, uint restartFake, Hashtable realToFake)
         {
            if (titles == null) return;
            
            foreach(TitleRatio t in titles)
            {
                if (realToFake[t.titleID] == null)
                {
                    realToFake[t.titleID] = startFake;
                    t.titleID = startFake;
                    startFake ++;
                    if (startFake > stopFake) startFake = restartFake;
                    
                }
                else
                {
                    t.titleID = (uint) realToFake[t.titleID];
                }
            }
         }
    }
        
    public class RSScenario : ScenarioBase
    {
        public uint[] settings;
        public UserRatio[] users;
        public RSScenario(uint[] s, double r, UserRatio[] ur, TitleRatio[] tr)
        {
            settings = s;
            ratio = r;
            users = ur;
            titles = tr;
        }
        public int GetNextUserCount()
        {
             //all the ratio's pretty much add up to 1
            RandomEx rand = new RandomEx();
            double randRatio = (double) rand.Next(1,1000) / (double) 1000;

            //find the scenario to return
            double currentRatio = 0;
            for(int i=0; i<users.Length; i++)
            {
                currentRatio+=users[i].ratio;
                if (randRatio < currentRatio) return users[i].numUsers;
            }
            return users[users.Length - 1].numUsers;
        }
         
    }

    public class ETScenario : ScenarioBase //this one does not have a list of titles for each scenario, each scenario is how many titles are returned
    {
        public int paramMaxTitles;
        public ETScenario(double r, TitleRatio[] tr, int maxTitles)
        {
            ratio = r;
            paramMaxTitles = maxTitles;
            titles = tr; //shouldbe null
        }
    }

    public class EAScenario : ScenarioBase 
    {
        public int paramMinAchievement;
        public int paramMaxAchievement;
        public EAScenario(double r, TitleRatio[] tr, int minAchievement, int maxAchievement)
        {
            paramMinAchievement = minAchievement;
            paramMaxAchievement = maxAchievement;
            ratio = r;
            titles = tr;
        }
    }

    public class EVScenario : ScenarioBase
    {
        public int paramMinAvatarAsset;
        public int paramMaxAvatarAsset;
        public EVScenario(double r, TitleRatio[] tr, int minAvatarAsset, int maxAvatarAsset)
        {
            paramMinAvatarAsset = minAvatarAsset;
            paramMaxAvatarAsset = maxAvatarAsset;
            ratio = r;
            titles = tr;
        }
    }

    public class VMScenario : ScenarioBase
    {
        public int validationFlags;
        public VMScenario(double r, int flag)
        {
            validationFlags = flag;
            ratio = r;
        }
    }

    public class SSScenario : ScenarioBase
    {
        public uint[] settings1;
        public uint[] settings2;            
        
        public SSScenario(double r, TitleRatio[] tr, uint[] s1, uint[] s2)
        {
            settings1 = s1;
            settings2 = s2;
            ratio = r;
            titles = tr;
        }
        
    }
        
    public class STScenario : ScenarioBase //this one I was lazy with. I didn't want to do the "both title" case, so when we get to the both title, we'll figure something else out.
    {
        public int numTitles;
        public STScenario(double r, TitleRatio[] tr, int nt)
        {
            ratio = r;
            titles = tr; 
            numTitles = nt;
        }
        public uint[] GetNextTitleList(int numTitles)
        {
            if (numTitles > titles.Length) return null;
            uint[] retVal = new uint[numTitles];
            if (titles.Length == numTitles)
            {
                for(int i=0; i<numTitles; i++)
                {
                    retVal[i] = titles[i].titleID;
                }
            }
            else
            {
                ArrayList temp = new ArrayList();
                double sumofweights = 0;
               for(int i=0; i<numTitles; i++)
                {
                    uint trialID = GetNextTitleIDNotInArrayList(temp, ref sumofweights);
                    retVal[i] = titles[i].titleID;
                    temp.Add(trialID);
                }
                
            }
            return retVal;
        }
        
    }

    public class SAScenario : ScenarioBase
    {
        public int numAchievements; //we don't keep track of how many ach up and how many ach down during a "both" type of scenario
        public SAScenario(double r, TitleRatio[] tr, int n1)
        {
            numAchievements = n1;
            titles = tr;
            ratio = r;
        }
        
    }

    public class SVScenario : ScenarioBase
    {
        public int numAvatarAssets; //we don't keep track of how many ach up and how many ach down during a "both" type of scenario
        public SVScenario(double r, TitleRatio[] tr, int n1)
        {
            numAvatarAssets = n1;
            titles = tr;
            ratio = r;
        }

    }

    public class SSType : TypeBase
    {
         public SSType(string n, double r, SSScenario[] s)
        {
            name = n;
            scenarios = s;
            ratio = r;
        }
    }

    public class STType : TypeBase
    {
         public STType(string n, double r, STScenario[] s)
        {
            name = n;
            scenarios = s;
            ratio = r;
        }
    }

    public class SAType : TypeBase
    {
         public SAType(string n, double r, SAScenario[] s)
        {
            name = n;
            scenarios = s;
            ratio = r;
        }
    }

    public class SVType : TypeBase
    {
        public SVType(string n, double r, SVScenario[] s)
        {
            name = n;
            scenarios = s;
            ratio = r;
        }
    }        

    public class ScenarioManager
    {
        public RSScenario[] readSettingsScenarios;
        public SSType[] syncSettingsTypes;
        public ETScenario[] enumerateTitlesScenarios;
        public STType[] syncTitlesTypes;
        public EAScenario[] enumerateAchievementsScenarios;
        public SAType[] syncAchievementsTypes;
        public EVScenario[] enumerateAvatarAssetsScenarios;
        public SVType[] syncAvatarAssetsTypes;
        public VMScenario[] validateAvatarManifestsScenarios;

        public void Initialize(string locationToXMLFile)
        {
            XmlDocument doc;
            try 
            {
                StreamReader file = File.OpenText(locationToXMLFile);
                String xmlFile;
                xmlFile = file.ReadToEnd();
                doc = new XmlDocument();
                doc.LoadXml(xmlFile);
                ParseReadSettings(doc.SelectSingleNode("descendant::ReadSettings"));
                ParseSyncSettings(doc.SelectSingleNode("descendant::SyncSettings"));     
                ParseEnumerateTitles(doc.SelectSingleNode("descendant::EnumTitles"));
                ParseSyncTitles(doc.SelectSingleNode("descendant::SyncTitles"));     
                ParseEnumerateAchievements(doc.SelectSingleNode("descendant::EnumAchievements"));
                ParseSyncAchievements(doc.SelectSingleNode("descendant::SyncAchievements"));
                ParseEnumerateAvatarAssets(doc.SelectSingleNode("descendant::EnumAvatarAssets"));
                ParseSyncAvatarAssets(doc.SelectSingleNode("descendant::SyncAvatarAssets"));
                ParseValidateAvatarManifests(doc.SelectSingleNode("descendant::ValidateAvatarManifests"));
  
            } 
            catch (Exception e) 
            {
                Global.RO.Warn("Could open or parse xml file from location: "+locationToXMLFile);
                Global.RO.Warn("Error text is as follows:" + e.ToString());
                throw e;
            }
            ConvertToFakeTitles();
            AddTitlesToUsers();
            // kkline, moved so we don't start the timer until after we loaded the users.
            StressSupport.tmr =new Timer(new TimerCallback(StressSupport.RotateUsers), null,60000, 60000);
            
        }

        public void ConvertToFakeTitles()
        {
            Hashtable realToFake = new Hashtable();
            uint curFake = (uint) StressConst.TitleStart;
            uint stopFake = (uint)((int)curFake + StressConst.TitleCount);
            uint restartFake = curFake;

            ConvertFakeTitlesScenarios(readSettingsScenarios, ref curFake, stopFake, restartFake, realToFake);
            ConvertFakeTitlesScenarios(enumerateAchievementsScenarios, ref curFake, stopFake, restartFake, realToFake);
            ConvertFakeTitlesScenarios(enumerateTitlesScenarios, ref curFake, stopFake, restartFake, realToFake);
            ConvertFakeTitlesScenarios(enumerateAvatarAssetsScenarios, ref curFake, stopFake, restartFake, realToFake);

            ConvertFakeTitlesTypes(syncSettingsTypes, ref curFake, stopFake, restartFake, realToFake);
            ConvertFakeTitlesTypes(syncAchievementsTypes, ref curFake, stopFake, restartFake, realToFake);
            ConvertFakeTitlesTypes(syncTitlesTypes, ref curFake, stopFake, restartFake, realToFake);
            ConvertFakeTitlesTypes(syncAvatarAssetsTypes, ref curFake, stopFake, restartFake, realToFake);
        }
        public void AddTitlesToUsers()
        {

            for(ulong i=0; i<StressConst.windowsize; i++)
            {
                ulong userID = StressConst.UMask +  i;
                uint Count = (uint) ((ETScenario)GetNextETScenario()).paramMaxTitles;
                ArrayList titleArray = new ArrayList();
                UserTitle[] titles = null;
                if (Count > 32) titles = new UserTitle[32];
                else
                     titles= new UserTitle[Count];
                RandomEx rand = new RandomEx();
                int index=0;
                for(uint j=0;j< Count;j++)
                {
                    int data =  rand.Next(1,72);
                    DateTime tmp = DateTime.UtcNow;
                    tmp = tmp.AddHours((-1*data));
                    uint titleID = (uint) rand.Next(StressConst.TitleStart, StressConst.TitleCount+StressConst.TitleStart);
                    if (! titleArray.Contains(titleID)) titleArray.Add(titleID);
                    titles[index]= new UserTitle(titleID,tmp,(uint)data,(ushort)data,(uint)data);
                    if (j !=0 && j%31==0)
                    {
                        //we've reached the 32 limit, we must do the requesting now.
                         SyncTitlesRequest req= new SyncTitlesRequest(userID,DateTime.UtcNow,titles);

                        SyncTitlesResponse resp = req.Execute();
//                         if(HResult.Failed(resp.XError))
//                              throw new HResultException(resp.XError, "Setup stage failed: Error adding titles to user "+userID+".");

                        index=-1; //reset index so that it overwrites the existing titles in titles. at the very end, we'll sync some duplicate titles, but that's OK.
                    }

                    index++;
                }

                SyncTitlesRequest reqq = new SyncTitlesRequest(userID,DateTime.UtcNow,titles);

                SyncTitlesResponse respp = reqq.Execute();
//                      if(HResult.Failed(respp.XError))
//                          throw new HResultException(respp.XError, "Setup stage failed: Error adding titles to user "+userID+".");

                if (StressSupport.UsersByTitlesPlayed[titleArray.Count] == null)
                {
                    StressSupport.UsersByTitlesPlayed[titleArray.Count] = new UserTitleObject(userID, titleArray);
                }
                else
                {
                    UserTitleObject uto = (UserTitleObject)StressSupport.UsersByTitlesPlayed[titleArray.Count];
                    uto.AddUser(userID, titleArray);
                }
            }
        }
        public void ConvertFakeTitlesScenarios(ScenarioBase[] SB, ref uint startFake, uint stopFake, uint restartFake, Hashtable realToFake)
        {
            foreach(ScenarioBase sb in SB)
            {
                sb.convertTitlesToFake(ref startFake,  stopFake, restartFake, realToFake);
            }
        }
        public void ConvertFakeTitlesTypes(TypeBase[] TB, ref uint startFake, uint stopFake, uint restartFake, Hashtable realToFake)
        {
            foreach(TypeBase tb in TB)
            {
                tb.convertTitlesToFake( ref startFake,  stopFake,  restartFake,  realToFake);
            }
        }
        public ETScenario GetNextETScenario()
        {
            //all the ratio's pretty much add up to 1
            RandomEx rand = new RandomEx();
            double randRatio = (double) rand.Next(1,1000) / (double) 1000;

            //find the scenario to return
            double currentRatio = 0;
            for(int i=0; i<enumerateTitlesScenarios.Length; i++)
            {
                currentRatio+=enumerateTitlesScenarios[i].ratio;
                if (randRatio < currentRatio) return enumerateTitlesScenarios[i];
            }
            return enumerateTitlesScenarios[enumerateTitlesScenarios.Length - 1];
        }
        public EAScenario GetNextEAScenario()
        {
            //all the ratio's pretty much add up to 1
            RandomEx rand = new RandomEx();
            double randRatio = (double) rand.Next(1,1000) / (double) 1000;

            //find the scenario to return
            double currentRatio = 0;
            for(int i=0; i<enumerateAchievementsScenarios.Length; i++)
            {
                currentRatio+=enumerateAchievementsScenarios[i].ratio;
                if (randRatio < currentRatio) return enumerateAchievementsScenarios[i];
            }
            return enumerateAchievementsScenarios[enumerateAchievementsScenarios.Length - 1];
        }
        public EVScenario GetNextEVScenario()
        {
            //all the ratio's pretty much add up to 1
            RandomEx rand = new RandomEx();
            double randRatio = (double)rand.Next(1, 1000) / (double)1000;

            //find the scenario to return
            double currentRatio = 0;
            for (int i = 0; i < enumerateAvatarAssetsScenarios.Length; i++)
            {
                currentRatio += enumerateAvatarAssetsScenarios[i].ratio;
                if (randRatio < currentRatio) return enumerateAvatarAssetsScenarios[i];
            }
            return enumerateAvatarAssetsScenarios[enumerateAvatarAssetsScenarios.Length - 1];
        }
        public VMScenario GetNextVMScenario()
        {
            //all the ratio's pretty much add up to 1
            RandomEx rand = new RandomEx();
            double randRatio = (double)rand.Next(1, 1000) / (double)1000;

            //find the scenario to return
            double currentRatio = 0;
            for (int i = 0; i < validateAvatarManifestsScenarios.Length; i++)
            {
                currentRatio += validateAvatarManifestsScenarios[i].ratio;
                if (randRatio < currentRatio) return validateAvatarManifestsScenarios[i];
            }
            return validateAvatarManifestsScenarios[validateAvatarManifestsScenarios.Length - 1];
        }
        public RSScenario GetNextRSScenario()
        {
            //all the ratio's pretty much add up to 1
            RandomEx rand = new RandomEx();
            double randRatio = (double) rand.Next(1,1000) / (double) 1000;

            //find the scenario to return
            double currentRatio = 0;
            for(int i=0; i<readSettingsScenarios.Length; i++)
            {
                currentRatio+=readSettingsScenarios[i].ratio;
                if (randRatio < currentRatio) return readSettingsScenarios[i];
            }
            return readSettingsScenarios[readSettingsScenarios.Length - 1];
        }
        public SSType GetNextSSType()
        {
            //all the ratio's pretty much add up to 1
            RandomEx rand = new RandomEx();
            double randRatio = (double) rand.Next(1,1000) / (double) 1000;

            //get the type to return
            double currentRatio = 0;
            for(int i=0; i<syncSettingsTypes.Length; i++)
            {
                currentRatio+=syncSettingsTypes[i].ratio;
                if (randRatio < currentRatio) return syncSettingsTypes[i];
            }
            return syncSettingsTypes[syncSettingsTypes.Length - 1];
        }
        public STType GetNextSTType()
        {
            //all the ratio's pretty much add up to 1
            RandomEx rand = new RandomEx();
            double randRatio = (double) rand.Next(1,1000) / (double) 1000;

            //get the type to return
            double currentRatio = 0;
            for(int i=0; i<syncTitlesTypes.Length; i++)
            {
                currentRatio+=syncTitlesTypes[i].ratio;
                if (randRatio < currentRatio) return syncTitlesTypes[i];
            }
            return syncTitlesTypes[syncTitlesTypes.Length - 1];
        }
        public SAType GetNextSAType()
        {
            //all the ratio's pretty much add up to 1
            RandomEx rand = new RandomEx();
            double randRatio = (double) rand.Next(1,1000) / (double) 1000;

            //get the type to return
            double currentRatio = 0;
            for(int i=0; i<syncAchievementsTypes.Length; i++)
            {
                currentRatio+=syncAchievementsTypes[i].ratio;
                if (randRatio < currentRatio) return syncAchievementsTypes[i];
            }
            return syncAchievementsTypes[syncAchievementsTypes.Length - 1];
        }
        public SVType GetNextSVType()
        {
            //all the ratio's pretty much add up to 1
            RandomEx rand = new RandomEx();
            double randRatio = (double)rand.Next(1, 1000) / (double)1000;

            //get the type to return
            double currentRatio = 0;
            for (int i = 0; i < syncAvatarAssetsTypes.Length; i++)
            {
                currentRatio += syncAvatarAssetsTypes[i].ratio;
                if (randRatio < currentRatio) return syncAvatarAssetsTypes[i];
            }
            return syncAvatarAssetsTypes[syncAvatarAssetsTypes.Length - 1];
        }
        
        private void ParseReadSettings(XmlNode ReadSettings)
        {
            XmlNodeList scenarios  = ReadSettings.SelectNodes("Scenario");
            readSettingsScenarios = new RSScenario[scenarios.Count];
            int index=0;
            foreach (XmlNode Scenaro in scenarios)
            {
                XmlNodeList settings  = Scenaro.SelectNodes("Settings/setting");
                XmlNodeList users  = Scenaro.SelectNodes("user");
                XmlNodeList titles  = Scenaro.SelectNodes("title");
                //pull out the ratio
                string ra =  Scenaro.Attributes["ratio"].Value.Trim();
                double rat = Double.Parse(ra);

                //pull out the settings
                uint[] setting = new uint[settings.Count];
                int i=0;
                foreach(XmlNode s in settings)
                {
                    string stringNum=s.Attributes["ID"].Value.Trim();
                    setting[i] = UInt32.Parse(stringNum, System.Globalization.NumberStyles.AllowHexSpecifier);
                    i++;
                }
                //pull out the users
                UserRatio[] ur = new UserRatio[users.Count];
                i=0;
                foreach(XmlNode u in users)
                {
                    string userNum=u.Attributes["num"].Value.Trim();
                    string ratio = u.Attributes["ratio"].Value.Trim();
                    UserRatio temp = new UserRatio(Int32.Parse(userNum), Double.Parse(ratio));
                    ur[i] = temp;
                    i++;
                }
                //pull out the titles
                TitleRatio[] tr = new TitleRatio[titles.Count];
                i=0;
                foreach(XmlNode t in titles)
                {
                    string titleID=t.Attributes["num"].Value.Trim();
                    string ratio = t.Attributes["ratio"].Value.Trim();
                    TitleRatio temp2 = new TitleRatio(UInt32.Parse(titleID, System.Globalization.NumberStyles.AllowHexSpecifier), Double.Parse(ratio));
                    tr[i] = temp2;
                    i++;
                }
                
                readSettingsScenarios[index] = new RSScenario(setting, rat, ur, tr);
                index ++;
               
            }
        }

        private void ParseSyncSettings(XmlNode SyncSettings)
        {
            XmlNodeList types  = SyncSettings.SelectNodes("Type");
            syncSettingsTypes = new SSType[types.Count];
            int typeIndex = 0;
            foreach(XmlNode type in types)
            {
                //pull out the type ratio
                string typeRatio =  type.Attributes["ratio"].Value.Trim();
                double dtypeRatio = Double.Parse(typeRatio);
                //pull out the name
                string typeName =  type.Attributes["name"].Value.Trim();
                SSType newType = new SSType(typeName, dtypeRatio, null);
                syncSettingsTypes[typeIndex] = newType;
                typeIndex++;

                //pull out the scenarios, if any
                XmlNodeList scenarios  = type.SelectNodes("Scenario");
                if (scenarios == null  || scenarios.Count == 0)
                {
                    continue;
                }
                //there are scenarios, lets pull them out!
                newType.scenarios = new SSScenario[scenarios.Count];
                int index=0;
                foreach (XmlNode Scenaro in scenarios)
                {
                    XmlNodeList settings  = Scenaro.SelectNodes("Settings/setting");
                    int i=0;
                    XmlNodeList titles  = Scenaro.SelectNodes("title");
                    //pull out the ratio
                    string ra =  Scenaro.Attributes["ratio"].Value.Trim();
                    double scenarioRatio = Double.Parse(ra);

                    //pull out the settings
                    uint[] setting1 = null;
                    uint[] setting2 = null;                        
                    if(settings == null || settings.Count == 0)
                    {
                        settings  = Scenaro.SelectNodes("Settings/ReqSettings");
                        XmlNodeList settings2  = Scenaro.SelectNodes("Settings/RespSettings");
                        setting2 = new uint[settings2.Count];
                        i=0;
                        foreach(XmlNode s in settings2)
                        {
                            string stringNum2=s.Attributes["ID"].Value.Trim();
                            setting2[i] = UInt32.Parse(stringNum2, System.Globalization.NumberStyles.AllowHexSpecifier);
                            i++;
                        }
                    }
                    setting1 = new uint[settings.Count];
                    i = 0;
                    foreach(XmlNode s in settings)
                    {
                        string stringNum=s.Attributes["ID"].Value.Trim();
                        setting1[i] = UInt32.Parse(stringNum, System.Globalization.NumberStyles.AllowHexSpecifier);
                        i++;
                    }
                    
                    //pull out the titles
                    TitleRatio[] tr = new TitleRatio[titles.Count];
                    i=0;
                    foreach(XmlNode t in titles)
                    {
                        try
                        {
                            string titleID = t.Attributes["num"].Value.Trim();
                            string ratio = t.Attributes["ratio"].Value.Trim();
                            TitleRatio temp2 = new TitleRatio(UInt32.Parse(titleID, System.Globalization.NumberStyles.AllowHexSpecifier), Double.Parse(ratio));
                            tr[i] = temp2;
                            i++;
                        }
                        catch (Exception e)
                        {
                            Global.RO.Warn("Failure Parsing SyncSettings.");
                            Global.RO.Warn("Text is as follows:" + e.ToString());
                        }
                    }

                    newType.scenarios[index] = new SSScenario(scenarioRatio, tr, setting1, setting2);
                    index ++;

                }
            }
        }

        private void ParseEnumerateTitles(XmlNode EnumTitles)
        {
            XmlNodeList scenarios  = EnumTitles.SelectNodes("Scenario");
            enumerateTitlesScenarios = new ETScenario[scenarios.Count];
            int index=0;
            foreach (XmlNode Scenaro in scenarios)
            {
                //pull out the ratio
                string ra =  Scenaro.Attributes["ratio"].Value.Trim();
                double rat = Double.Parse(ra);

                 //pull out the maxTitles
                string mt =  Scenaro.Attributes["num"].Value.Trim();
                int maxTitles = Int32.Parse(mt);

                
                enumerateTitlesScenarios[index] = new ETScenario(rat, null, maxTitles);
                index ++;
            }
        }
         
        private void ParseSyncTitles(XmlNode SyncTitles)
        {
            XmlNodeList types  = SyncTitles.SelectNodes("Type");
            syncTitlesTypes = new STType[types.Count];
            int typeIndex = 0;
            foreach(XmlNode type in types)
            {
                //pull out the type ratio
                string typeRatio =  type.Attributes["ratio"].Value.Trim();
                double dtypeRatio = Double.Parse(typeRatio);
                //pull out the name
                string typeName =  type.Attributes["name"].Value.Trim();
                STType newType = new STType(typeName, dtypeRatio, null);
                syncTitlesTypes[typeIndex] = newType;
                typeIndex++;

                //pull out the scenarios, if any
                XmlNodeList scenarios  = type.SelectNodes("Scenario");
                if (scenarios == null  || scenarios.Count == 0)
                {
                    continue;
                }
                //there are scenarios, lets pull them out!
                newType.scenarios = new STScenario[scenarios.Count];
                int index=0;
                foreach (XmlNode Scenaro in scenarios)
                {
                    int i=0;
                    XmlNodeList titles  = Scenaro.SelectNodes("title");
                    //pull out the ratio
                    string ra =  Scenaro.Attributes["ratio"].Value.Trim();
                    double scenarioRatio = Double.Parse(ra);

                    //pull out the num
                    int numTitles = Int32.Parse(Scenaro.Attributes["num"].Value.Trim());
                    
                    //pull out the titles
                    TitleRatio[] tr = new TitleRatio[titles.Count];
                    i=0;
                    foreach(XmlNode t in titles)
                    {
                        string titleID=t.Attributes["num"].Value.Trim();
                        string ratio = t.Attributes["ratio"].Value.Trim();
                        TitleRatio temp2 = new TitleRatio(UInt32.Parse(titleID, System.Globalization.NumberStyles.AllowHexSpecifier), Double.Parse(ratio));
                        tr[i] = temp2;
                        i++;
                    }

                    newType.scenarios[index] = new STScenario(scenarioRatio, tr, numTitles);
                    index ++;

                }
            }
        }

        private void ParseEnumerateAchievements(XmlNode EnumAchievements)
        {
            XmlNodeList scenarios  = EnumAchievements.SelectNodes("Scenario");
            enumerateAchievementsScenarios = new EAScenario[scenarios.Count];
            int index=0;
            foreach (XmlNode Scenaro in scenarios)
            {
                //pull out the ratio
                string ra =  Scenaro.Attributes["ratio"].Value.Trim();
                double rat = Double.Parse(ra);

                 //pull out the min/max ach
                string minAch =  Scenaro.Attributes["min"].Value.Trim();
                int minAchi = Int32.Parse(minAch);
                string maxAch =  Scenaro.Attributes["max"].Value.Trim();
                int maxAchi = Int32.Parse(maxAch);

                 //pull out the titles, if any
                XmlNodeList titles  = Scenaro.SelectNodes("title");
                 if (titles == null  || titles.Count == 0)
                {
                    continue;
                }
                int i=0;
                TitleRatio[] tr = new TitleRatio[titles.Count];
                i=0;
                foreach(XmlNode t in titles)
                {
                    string titleID=t.Attributes["num"].Value.Trim();
                    string ratio = t.Attributes["ratio"].Value.Trim();
                    TitleRatio temp2 = new TitleRatio(UInt32.Parse(titleID, System.Globalization.NumberStyles.AllowHexSpecifier), Double.Parse(ratio));
                    tr[i] = temp2;
                    i++;
                }

                enumerateAchievementsScenarios[index] = new EAScenario(rat, tr, minAchi, maxAchi);
                index ++;
            }
        }

        private void ParseSyncAchievements(XmlNode SyncAchievements)
        {
            XmlNodeList types  = SyncAchievements.SelectNodes("Type");
            syncAchievementsTypes = new SAType[types.Count];
            int typeIndex = 0;
            foreach(XmlNode type in types)
            {
                //pull out the type ratio
                string typeRatio =  type.Attributes["ratio"].Value.Trim();
                double dtypeRatio = Double.Parse(typeRatio);
                //pull out the name
                string typeName =  type.Attributes["name"].Value.Trim();
                SAType newType = new SAType(typeName, dtypeRatio, null);
                syncAchievementsTypes[typeIndex] = newType;
                typeIndex++;

                 //pull out the titles, if any
                XmlNodeList titles  = type.SelectNodes("title");
                 if (titles == null || titles.Count == 0)
                {
                    continue;
                }
                int i=0;
                TitleRatio[] tr = new TitleRatio[titles.Count];
                i=0;
                foreach(XmlNode t in titles)
                {
                    string titleID=t.Attributes["num"].Value.Trim();
                    string ratio = t.Attributes["ratio"].Value.Trim();
                    TitleRatio temp2 = new TitleRatio(UInt32.Parse(titleID, System.Globalization.NumberStyles.AllowHexSpecifier), Double.Parse(ratio));
                    tr[i] = temp2;
                    i++;
                }

                //pull out the scenarios, if any
                XmlNodeList scenarios  = type.SelectNodes("Scenario");
                if (scenarios == null || scenarios.Count == 0)
                {
                    continue;
                }
                //there are scenarios, lets pull them out!
                newType.scenarios = new SAScenario[scenarios.Count];
                int index=0;
                foreach (XmlNode Scenaro in scenarios)
                {
                    
                    //pull out the ratio
                    string ra =  Scenaro.Attributes["ratio"].Value.Trim();
                    double scenarioRatio = Double.Parse(ra);

                    //pull out the num
                    int numAch = Int32.Parse(Scenaro.Attributes["num"].Value.Trim());

                    //all the scenarios have the same titlearray
                    newType.scenarios[index] = new SAScenario(scenarioRatio, tr, numAch);
                    index ++;

                }
            }
        }

        private void ParseSyncAvatarAssets(XmlNode SyncAvatarAssets)
         {
             XmlNodeList types = SyncAvatarAssets.SelectNodes("Type");
             syncAvatarAssetsTypes = new SVType[types.Count];
             int typeIndex = 0;
             foreach (XmlNode type in types)
             {
                 //pull out the type ratio
                 string typeRatio = type.Attributes["ratio"].Value.Trim();
                 double dtypeRatio = Double.Parse(typeRatio);
                 //pull out the name
                 string typeName = type.Attributes["name"].Value.Trim();
                 SVType newType = new SVType(typeName, dtypeRatio, null);
                 syncAvatarAssetsTypes[typeIndex] = newType;
                 typeIndex++;

                 //pull out the titles, if any
                 XmlNodeList titles = type.SelectNodes("title");
                 if (titles == null || titles.Count == 0)
                 {
                     continue;
                 }
                 int i = 0;
                 TitleRatio[] tr = new TitleRatio[titles.Count];
                 i = 0;
                 foreach (XmlNode t in titles)
                 {
                     string titleID = t.Attributes["num"].Value.Trim();
                     string ratio = t.Attributes["ratio"].Value.Trim();
                     TitleRatio temp2 = new TitleRatio(UInt32.Parse(titleID, System.Globalization.NumberStyles.AllowHexSpecifier), Double.Parse(ratio));
                     tr[i] = temp2;
                     i++;
                 }

                 //pull out the scenarios, if any
                 XmlNodeList scenarios = type.SelectNodes("Scenario");
                 if (scenarios == null || scenarios.Count == 0)
                 {
                     continue;
                 }
                 //there are scenarios, lets pull them out!
                 newType.scenarios = new SVScenario[scenarios.Count];
                 int index = 0;
                 foreach (XmlNode Scenaro in scenarios)
                 {

                     //pull out the ratio
                     string ra = Scenaro.Attributes["ratio"].Value.Trim();
                     double scenarioRatio = Double.Parse(ra);

                     //pull out the num
                     int numAvAssets = Int32.Parse(Scenaro.Attributes["num"].Value.Trim());

                     //all the scenarios have the same titlearray
                     newType.scenarios[index] = new SVScenario(scenarioRatio, tr, numAvAssets);
                     index++;

                 }
             }
         }

        private void ParseEnumerateAvatarAssets(XmlNode EnumAvatarAssets)
        {
            XmlNodeList scenarios = EnumAvatarAssets.SelectNodes("Scenario");
            enumerateAvatarAssetsScenarios = new EVScenario[scenarios.Count];
            int index = 0;
            foreach (XmlNode Scenaro in scenarios)
            {
                //pull out the ratio
                string ra = Scenaro.Attributes["ratio"].Value.Trim();
                double rat = Double.Parse(ra);

                //pull out the min/max ach
                string minAvAssets = Scenaro.Attributes["min"].Value.Trim();
                int iminAvAssets = Int32.Parse(minAvAssets);
                string maxAvAssets = Scenaro.Attributes["max"].Value.Trim();
                int imaxAvAssets = Int32.Parse(maxAvAssets);

                //pull out the titles, if any
                XmlNodeList titles = Scenaro.SelectNodes("title");
                if (titles == null || titles.Count == 0)
                {
                    continue;
                }
                int i = 0;
                TitleRatio[] tr = new TitleRatio[titles.Count];
                i = 0;
                foreach (XmlNode t in titles)
                {
                    string titleID = t.Attributes["num"].Value.Trim();
                    string ratio = t.Attributes["ratio"].Value.Trim();
                    TitleRatio temp2 = new TitleRatio(UInt32.Parse(titleID, System.Globalization.NumberStyles.AllowHexSpecifier), Double.Parse(ratio));
                    tr[i] = temp2;
                    i++;
                }

                enumerateAvatarAssetsScenarios[index] = new EVScenario(rat, tr, iminAvAssets, imaxAvAssets);
                index++;
            }
        }

        private void ParseValidateAvatarManifests(XmlNode ValidateAvatarManifests)
        {
            XmlNodeList scenarios = ValidateAvatarManifests.SelectNodes("Scenario");
            validateAvatarManifestsScenarios = new VMScenario[scenarios.Count];
            int index = 0;
            foreach (XmlNode Scenario in scenarios)
            {
                //pull out the ratio
                string ra = Scenario.Attributes["ratio"].Value.Trim();
                double rat = Double.Parse(ra);

                //pull out the validationflag
                string vf = Scenario.Attributes["validationflag"].Value.Trim();
                int iValidationFlag = Int32.Parse(vf);

                validateAvatarManifestsScenarios[index] = new VMScenario(rat, iValidationFlag);
                index++;
            }
        }
    }

    public class StressSupport
    {
        
        //static public ScrollingWindow Users = new ScrollingWindow();
        static public Object windowLock = new Object();
        //static private ArrayList UsersList= ArrayList.Synchronized(new ArrayList());
        static private Hashtable UsersInfo= Hashtable.Synchronized(new Hashtable());
        static public Hashtable UsersByTitlesPlayed= Hashtable.Synchronized(new Hashtable());
        static private ArrayList TitlesToClear =ArrayList.Synchronized(new ArrayList());
        static public Timer tmr;
        static public ScenarioManager SM = new ScenarioManager();

        public static void RotateUsers(Object state)
        {
            if (StressConst.windowsize >= StressConst.TotalUsers)
            {
                System.Console.WriteLine("Run out of new users to add to the stress mix");
                return;
            }
            ulong userToAdd = 0;
            lock(windowLock)
            {
                // kkline added - add 10 users instead of just 1 in the rotation
                for (int i = 0; i < 10; i++)
                {
                    StressConst.windowsize++;
                    userToAdd = StressConst.UMask + StressConst.windowsize;
                    lock (UsersByTitlesPlayed) //not dangerous because we don't request a lock for UsersByTitlesPlayed before windowLock
                    {
                        ((UserTitleObject)(UsersByTitlesPlayed[0])).AddUser(userToAdd, new ArrayList());
                    }
                }

            }
            #region cutcode
//            lock(Users)
//            {
//                ulong tmp = (ulong)(Users.windowstart+StressConst.windowsize+ StressConst.NoOFUsersToRotatePerMin);
//                if(tmp < StressConst.TotalUsers)
//                {
//                    
//                    // delete user from hastable here.
//                    long Userend = Users.windowstart-(StressConst.NoOFUsersToRotatePerMin*2);
//
//                    int  count=0;
//                    for( int i=(int)StressConst.NoOFUsersToRotatePerMin; i>0 && Userend+i > 0;i--)
//                    {
//                        ulong user = StressConst.UMask+(ulong)(Userend+i);
//                        if(i==1)
//                        {
//                            System.Console.WriteLine("deleted "+count.ToString()+" users Current size is " + UsersInfo.Count.ToString());
//                        }
//                        if(UsersInfo.ContainsKey(user))
//                        {
//                            count++;
//                            Hashtable userinfo= (Hashtable)UsersInfo[user];
//                            userinfo.Clear();
//                            UsersInfo.Remove(user);
//                            
//                        }
//                    }
//                    Users.windowstart=Users.windowstart+StressConst.NoOFUsersToRotatePerMin;
//
//                }
//                else
//                    Users.windowstart=0;
//
//            }
//            
//            Global.RO.Info("Rotating users current window start index = "+Users.windowstart);
            #endregion
        }

        public static ulong  GetNextUser()
        {
            RandomEx rand = new RandomEx();
            ulong user;

            lock(windowLock)
            {
                user= StressConst.UMask+ (ulong)rand.Next(0, (int)StressConst.windowsize);
            }
            return user;
            #region cutcode
//            lock(Users)
//            {
//                user= StressConst.UMask+ (ulong)rand.Next((int)Users.windowstart,(int)(Users.windowstart+StressConst.windowsize));
//            }
//            return user;
            #endregion
        }

        #region cutfunction
//        public static void AddSetting(uint title,ulong user,  uint SettingId,byte[] Svalue)
//        {
//            Hashtable userinfo=null;
//            if(UsersInfo.ContainsKey(user))
//            {
//                userinfo= (Hashtable)UsersInfo[user];
//            }
//            else
//            {
//                userinfo= new Hashtable();
//                UsersInfo.Add(user,userinfo);
//                UsersList.Add(user);
//
//            }
//            TitleInfo  Tinfo= null;
//            if(userinfo.ContainsKey(title))
//                Tinfo= (TitleInfo) userinfo[title];
//            else
//            {
//                Tinfo=new TitleInfo(title);
//                userinfo.Add(title,Tinfo);
//            }
//            if(!Tinfo.settings.Contains(SettingId))
//                Tinfo.settings.Add(SettingId,Svalue);
//            else
//            {
//                Tinfo.settings[SettingId]=Svalue;
//            }
//
//
//
//      }
        #endregion

        public static SyncSettingsRequest GetSyncSettingRequest()
        {
            RandomEx rand = new RandomEx();
            SSType synctype = SM.GetNextSSType();
            SyncSettingsRequest request = new SyncSettingsRequest();
            ulong user = GetNextUser();
            request.UserId = user;
            //we will only sync up new settings
            if (synctype.name.ToLower().Contains("req"))
            {
                //figure out the scenario
                SSScenario scenario = (SSScenario)synctype.GetNextScenario();

                //set up the settings to sync
                uint titleID = scenario.GetNextTitleID();
                request.Settings = new UserSetting[scenario.settings1.Length];
                for(int i=0; i<request.Settings.Length; i++)
                {
                    request.Settings[i] = new UserSetting();
                    request.Settings[i].SettingId = scenario.settings1[i];
                    request.Settings[i].userId = user;
                    request.Settings[i].Source = (titleID==XOn.XENON_DASH_TITLE_ID)?(uint)SettingSource.XSOURCE_DEFAULT:(uint)SettingSource.XSOURCE_TITLE;
                    request.Settings[i].Value = GetNextValueBasedOnSettingID(request.Settings[i].SettingId, titleID);
                }

                request.SettingsLen = (ushort)request.Settings.Length;
                request.TitleId = titleID;
                request.Version = DateTime.Now;

                
                    
            }
            //we want to sync down new settings by passing in an old version on a known user
            else if (synctype.name.ToLower().Contains("resp"))
            {
                 //figure out the scenario
                SSScenario scenario = (SSScenario)synctype.GetNextScenario();

                //set up the settings to sync
                uint titleID = scenario.GetNextTitleID();
                request.Settings = new UserSetting[scenario.settings1.Length];
                for(int i=0; i<request.Settings.Length; i++)
                {
                    request.Settings[i] = new UserSetting();
                    request.Settings[i].SettingId = scenario.settings1[i];
                    request.Settings[i].userId = user;
                    request.Settings[i].Source = (titleID==XOn.XENON_DASH_TITLE_ID)?(uint)SettingSource.XSOURCE_DEFAULT:(uint)SettingSource.XSOURCE_TITLE;
                    request.Settings[i].Value = GetNextValueBasedOnSettingID(request.Settings[i].SettingId, titleID);
                }

                request.SettingsLen = (ushort)request.Settings.Length;
                request.TitleId = titleID;
                request.Version = DateTime.Now;

                //call sync settings to sync this data, then pass back the request with an old datetime
                request.Execute();

                
                request.Settings = new UserSetting[0];
                request.SettingsLen = 0;
                DateTime t = DateTime.UtcNow;
                request.Version = t.AddMinutes(- rand.Next(1,9999));
                
            }
            //we want to sync up new settings and sync down new server settings
            else if (synctype.name.ToLower().Contains("both"))
            {
                //pull out a both scenario
                SSScenario bothScenario = (SSScenario)synctype.GetNextScenario();
                 //set up the settings to sync
                uint titleID = bothScenario.GetNextTitleID();
                request.Settings = new UserSetting[bothScenario.settings2.Length];
                for(int i=0; i<request.Settings.Length; i++)
                {
                    request.Settings[i] = new UserSetting();
                    request.Settings[i].SettingId = bothScenario.settings2[i];
                    request.Settings[i].userId = user;
                    request.Settings[i].Source = (titleID==XOn.XENON_DASH_TITLE_ID)?(uint)SettingSource.XSOURCE_DEFAULT:(uint)SettingSource.XSOURCE_TITLE;
                    request.Settings[i].Value = GetNextValueBasedOnSettingID(request.Settings[i].SettingId, titleID);
                }

                request.SettingsLen = (ushort)request.Settings.Length;
                request.TitleId = titleID;
                request.Version = DateTime.Now;

                //call sync settings to sync this data
                request.Execute();

                 //set up the settings to sync
                request.Settings = new UserSetting[bothScenario.settings1.Length];
                for(int i=0; i<request.Settings.Length; i++)
                {
                    request.Settings[i] = new UserSetting();
                    request.Settings[i].SettingId = bothScenario.settings1[i];
                    request.Settings[i].userId = user;
                    request.Settings[i].Source = (titleID==XOn.XENON_DASH_TITLE_ID)?(uint)SettingSource.XSOURCE_DEFAULT:(uint)SettingSource.XSOURCE_TITLE;
                    request.Settings[i].Value = GetNextValueBasedOnSettingID(request.Settings[i].SettingId, titleID);
                }

                request.SettingsLen = (ushort)request.Settings.Length;
                DateTime t = DateTime.UtcNow;
                request.Version = t.AddMinutes(- rand.Next(1,9999));
                
            }
            //we want to sync no new settings and recieve no new settings
            else if (synctype.name.ToLower().Contains("empty"))
            {
                request.Settings = new UserSetting[0];
                request.TitleId = getTitle(); //random titles
                request.Version = DateTime.Now;
            }

            return request;
            
        }

        public static SyncTitlesRequest GetSyncTitlesRequest()
        {
            RandomEx rand = new RandomEx();
            STType synctype = SM.GetNextSTType();
            //get a user
            int key = 0;
            UserTitleObject uto = null;
            lock(UsersByTitlesPlayed)
            {
                int r = rand.Next(0,UsersByTitlesPlayed.Keys.Count - 1);
                foreach(int k in UsersByTitlesPlayed.Keys)
                {
                    if (r == 0) key = k;
                    r--;
                }
                uto = (UserTitleObject) UsersByTitlesPlayed[key];
            }
            ArrayList titlesPlayedByUser = null; 
            bool needToRemoveKey = false;
            ulong user = uto.RemoveRandomUser(out titlesPlayedByUser, out needToRemoveKey);
            if (needToRemoveKey == true)
            {
                lock(UsersByTitlesPlayed)
                {
                    UsersByTitlesPlayed.Remove(key);
                }
            }
            
            SyncTitlesRequest request = new SyncTitlesRequest(user, DateTime.Now, null);
            //we will only sync up new titles
            if (synctype.name.ToLower().Contains("req"))
            {
                //figure out the scenario
                STScenario scenario = (STScenario)synctype.GetNextScenario();

                //set up the titles to sync
                uint[] titleIDs = scenario.GetNextTitleList(scenario.numTitles);
                request.Titles = new UserTitle[scenario.numTitles];
                request.TitlesLen = (ushort)scenario.numTitles;
                
                DateTime t = DateTime.UtcNow;
                for(int i=0; i<request.Titles.Length; i++)
                {
                    request.Titles[i] = new UserTitle(titleIDs[i], t.AddMinutes(- rand.Next(1,60)), (uint) rand.Next(1,72), (ushort) rand.Next(1,72), (uint)rand.Next(1,72)) ;
                }

                request.Version = DateTime.Now;

                //add titles to the user's played list
                foreach(uint titleid in titleIDs)
                {
                    if (! titlesPlayedByUser.Contains(titleid)) titlesPlayedByUser.Add(titleid);
                }
            }
            //we want to sync down new settings by passing in an old version on a known user
            else if (synctype.name.ToLower().Contains("resp"))
            {
                  //figure out the scenario
                STScenario scenario = (STScenario)synctype.GetNextScenario();

                //set up the titles to sync
                uint[] titleIDs = scenario.GetNextTitleList(scenario.numTitles);
                request.Titles = new UserTitle[scenario.numTitles];
                request.TitlesLen = (ushort)scenario.numTitles;
                
                DateTime t = DateTime.UtcNow;
                for(int i=0; i<request.Titles.Length; i++)
                {
                    request.Titles[i] = new UserTitle(titleIDs[i], t.AddMinutes(- rand.Next(1,60)), (uint) rand.Next(1,72), (ushort) rand.Next(1,72), (uint)rand.Next(1,72)) ;
                }

                request.Version = DateTime.Now;

                //call sync titles to sync this data, then pass back the request with an old datetime
                request.Execute();

                request.Titles = new UserTitle[0];
                request.TitlesLen = 0;
                request.Version = t.AddMinutes(- rand.Next(1,9999));

                //add titles to the user's played list
                foreach(uint titleid in titleIDs)
                {
                    if (! titlesPlayedByUser.Contains(titleid)) titlesPlayedByUser.Add(titleid);
                }
                
            }
            //we want to sync up new settings and sync down new server settings
            else if (synctype.name.ToLower().Contains("both"))
            {
                //pull out a response scenario
                STScenario responseScenario = (STScenario)SM.syncTitlesTypes[1].GetNextScenario();
                  //set up the titles to sync
                uint[] titleIDs = responseScenario.GetNextTitleList(responseScenario.numTitles);
                request.Titles = new UserTitle[responseScenario.numTitles];
                request.TitlesLen = (ushort)responseScenario.numTitles;
                
                DateTime t = DateTime.UtcNow;
                for(int i=0; i<request.Titles.Length; i++)
                {
                    request.Titles[i] = new UserTitle(titleIDs[i], t.AddMinutes(- rand.Next(1,60)), (uint) rand.Next(1,72), (ushort) rand.Next(1,72), (uint)rand.Next(1,72)) ;
                }

                request.Version = DateTime.Now;

                //call sync titles to sync this data
                request.Execute();

                //add titles to the user's played list
                foreach(uint titleid in titleIDs)
                {
                    if (! titlesPlayedByUser.Contains(titleid)) titlesPlayedByUser.Add(titleid);
                }

                STScenario requestScenario = (STScenario)SM.syncTitlesTypes[0].GetNextScenario();
                 //set up the settings to sync
                titleIDs = requestScenario.GetNextTitleList(requestScenario.numTitles);
                request.Titles = new UserTitle[requestScenario.numTitles];
                request.TitlesLen = (ushort)requestScenario.numTitles;
                
                for(int i=0; i<request.Titles.Length; i++)
                {
                    request.Titles[i] = new UserTitle(titleIDs[i], t.AddMinutes(- rand.Next(1,60)), (uint) rand.Next(1,72), (ushort) rand.Next(1,72), (uint)rand.Next(1,72)) ;
                }

                request.Version = t.AddMinutes(- rand.Next(1,9999));

                 //add titles to the user's played list
                foreach(uint titleid in titleIDs)
                {
                    if (! titlesPlayedByUser.Contains(titleid)) titlesPlayedByUser.Add(titleid);
                }
               
                
            }
            //we want to sync no new settings and recieve no new settings
            else if (synctype.name.ToLower().Contains("empty"))
            {
                request.Titles = new UserTitle[0];
                request.Version = DateTime.Now;
            }

            //hash the user back
             lock(UsersByTitlesPlayed)
            {
                if (UsersByTitlesPlayed[titlesPlayedByUser.Count] == null)
                    {
                        UsersByTitlesPlayed[titlesPlayedByUser.Count] = new UserTitleObject(user, titlesPlayedByUser);
                    }
                    else
                    {
                         uto = (UserTitleObject) UsersByTitlesPlayed[titlesPlayedByUser.Count];
                         uto.AddUser(user, titlesPlayedByUser);
                    }
            }

            return request;
            
        }

        public static XRLSyncAchievements GetSyncAchievementRequest()
        {
            RandomEx rand = new RandomEx();
            SAType synctype = SM.GetNextSAType();
            XRLSyncAchievements request = new XRLSyncAchievements();
            request.UserId =  StressSupport.GetNextUser();
            
            //we will only sync up new titles
            if (synctype.name.ToLower().Contains("req"))
            {
                //figure out the scenario
                SAScenario scenario = (SAScenario)synctype.GetNextScenario();

                //set up the achievements to sync
                
                request.Achievements = new AchievementWD[scenario.numAchievements];
                request.AchievementsLen = (ushort)scenario.numAchievements;
                uint titleID = scenario.GetNextTitleID();
                
                DateTime t = DateTime.UtcNow;
                for(int i=0; i<scenario.numAchievements; i++)
                {
                    int id =StressSupport.getNextAchievementID(titleID,request.UserId);
                    request.Achievements[i] = new AchievementWD((uint)id,(uint)id);
                }
                request.TitleId = titleID;
                request.Version = DateTime.Now;
                
            }
            //we want to sync down new settings by passing in an old version on a known user
            else if (synctype.name.ToLower().Contains("resp"))
            {
                 //figure out the scenario
                SAScenario scenario = (SAScenario)synctype.GetNextScenario();

                //set up the achievements to sync
                
                request.Achievements = new AchievementWD[scenario.numAchievements];
                request.AchievementsLen = (ushort)scenario.numAchievements;
                uint titleID = scenario.GetNextTitleID();
                
                DateTime t = DateTime.UtcNow;
                for(int i=0; i<scenario.numAchievements; i++)
                {
                    int id =StressSupport.getNextAchievementID(titleID,request.UserId);
                    request.Achievements[i] = new AchievementWD((uint)id,(uint)id);
                }
                request.TitleId = titleID;
                request.Version = DateTime.Now;

                //call sync achievements to sync this data, then pass back the request with an old datetime
                request.Execute();

                request.Achievements = new AchievementWD[0];
                request.AchievementsLen = 0;
                request.Version = t.AddMinutes(- rand.Next(1,9999));
            }
            //we want to sync up new settings and sync down new server settings
            else if (synctype.name.ToLower().Contains("both"))
            {
                //pull out the both scenario for the titleID list
                SAScenario bothScenario = (SAScenario)synctype.GetNextScenario();
                 uint titleID = bothScenario.GetNextTitleID();
                //pull out a response scenario
                SAScenario responseScenario = (SAScenario)SM.syncAchievementsTypes[1].GetNextScenario();

                //set up the achievements to sync
                request.Achievements = new AchievementWD[responseScenario.numAchievements];
                request.AchievementsLen = (ushort)responseScenario.numAchievements;
                
                
                for(int i=0; i<responseScenario.numAchievements; i++)
                {
                    int id =StressSupport.getNextAchievementID(titleID,request.UserId);
                    request.Achievements[i] = new AchievementWD((uint)id,(uint)id);
                }
                request.TitleId = titleID;
                request.Version = DateTime.Now;

                //call sync achievements to sync this data
                request.Execute();

                SAScenario requestScenario = (SAScenario)SM.syncAchievementsTypes[0].GetNextScenario();
                 //set up the settings to sync
                //set up the achievements to sync
                request.Achievements = new AchievementWD[responseScenario.numAchievements];
                request.AchievementsLen = (ushort)responseScenario.numAchievements;
                for(int i=0; i<responseScenario.numAchievements; i++)
                {
                    int id =StressSupport.getNextAchievementID(titleID,request.UserId);
                    request.Achievements[i] = new AchievementWD((uint)id,(uint)id);
                }

                DateTime t = DateTime.UtcNow;
                request.Version = t.AddMinutes(- rand.Next(1,9999));
                
            }
            //we want to sync no new settings and recieve no new settings
            else if (synctype.name.ToLower().Contains("empty"))
            {
                request.Achievements = new AchievementWD[0];
                request.Version = DateTime.Now;
                request.TitleId = getTitle(); //random title
            }

            return request;
        }

        public static EnumTitlesRequest GetEnumerateTitlesRequest( )
        {
            RandomEx rand = new RandomEx();
            EnumTitlesRequest  request = new EnumTitlesRequest();
            //pick a user to initiate the call
            request.UserId=(ulong) StressSupport.GetNextUser();
            //get the scenario
            ETScenario scenario = SM.GetNextETScenario();
            request.MaxTitles = (ushort)scenario.paramMaxTitles;
            //pick a user to have his maxtitles enumerated
            if (scenario.paramMaxTitles > 20)
            {
                //pick a special user
                int key = 0;
                UserTitleObject uto = null;
                lock(UsersByTitlesPlayed)
                {
                    int r = rand.Next(0,UsersByTitlesPlayed.Keys.Count - 1);
                    foreach(int k in UsersByTitlesPlayed.Keys)
                    {
                        if (r == 0) key = k;
                        r--;
                    }
                    uto = (UserTitleObject) UsersByTitlesPlayed[key];
                }
                request.ForUserId = uto.GetRandomUser();
                
            }
            //pick a random user
            else
            {
                request.ForUserId = (ulong) StressSupport.GetNextUser();
            }
            
            return request;
        }

        public static XRLEnumAchievement GetEnumerateAchievementsRequest( )
        {
            RandomEx rand = new RandomEx();
            XRLEnumAchievement  request = new XRLEnumAchievement(1,1,1,1,0,0);
            //pick users
            request.Puid=(ulong) StressSupport.GetNextUser();
            request.ForPuid=(ulong) StressSupport.GetNextUser();
            //get the scenario
            EAScenario scenario = SM.GetNextEAScenario();
            request.MaxAchievements= (ushort)scenario.paramMaxAchievement;
            request.StartingIndex =  (ushort)scenario.paramMinAchievement;
            request.TitleId=  scenario.GetNextTitleID();
            request.LocaleId = (ushort)Locales.en_US;
            
            return request;
        }

        public static XRLSyncAvatarAssets GetSyncAvatarAssetsRequest()
        {
            RandomEx rand = new RandomEx();
            SVType synctype = SM.GetNextSVType();
            XRLSyncAvatarAssets request = new XRLSyncAvatarAssets();
            request.UserId = StressSupport.GetNextUser();

            //we will only sync up new titles
            if (synctype.name.ToLower().Contains("req"))
            {
                //figure out the scenario
                SVScenario scenario = (SVScenario)synctype.GetNextScenario();

                //set up the avatarassets to sync

                request.AvatarAssets = new AvatarAssetWD[scenario.numAvatarAssets];
                request.AvatarAssetCount = (ushort)scenario.numAvatarAssets;
                uint titleID = scenario.GetNextTitleID();

                DateTime t = DateTime.UtcNow;
                for (int i = 0; i < scenario.numAvatarAssets; i++)
                {
                    int id = StressSupport.getNextAvatarAssetID(titleID, request.UserId);
                    // Ordinal ID and Sequence ID are same (although sequence in this case doesn't matter)
                    // BodyTypeMask is set to 3 - unisex, XLAST is setup with all unisex items for stress
                    request.AvatarAssets[i] = new AvatarAssetWD((uint)id, (byte)3, (uint)id);
                }
                request.TitleId = titleID;
                request.Version = DateTime.Now;

            }
            //we want to sync down new settings by passing in an old version on a known user
            else if (synctype.name.ToLower().Contains("resp"))
            {
                //figure out the scenario
                SVScenario scenario = (SVScenario)synctype.GetNextScenario();

                //set up the achievements to sync

                request.AvatarAssets = new AvatarAssetWD[scenario.numAvatarAssets];
                request.AvatarAssetCount = (ushort)scenario.numAvatarAssets;
                uint titleID = scenario.GetNextTitleID();

                DateTime t = DateTime.UtcNow;
                for (int i = 0; i < scenario.numAvatarAssets; i++)
                {
                    int id = StressSupport.getNextAvatarAssetID(titleID, request.UserId);
                    // Ordinal ID and Sequence ID are same (although sequence in this case doesn't matter)
                    // BodyTypeMask is set to 3 - unisex, XLAST is setup with all unisex items for stress
                    request.AvatarAssets[i] = new AvatarAssetWD((uint)id, (byte)3, (uint)id);
                }
                request.TitleId = titleID;
                request.Version = DateTime.Now;

                //call sync avatar assets to sync this data, then pass back the request with an old datetime
                request.Execute();

                request.AvatarAssets = new AvatarAssetWD[0];
                request.AvatarAssetCount = 0;
                request.Version = t.AddMinutes(-rand.Next(1, 9999));
            }
            //we want to sync up new avatarassets and sync down new avatarassets
            else if (synctype.name.ToLower().Contains("both"))
            {
                //pull out the both scenario for the titleID list
                SVScenario bothScenario = (SVScenario)synctype.GetNextScenario();
                uint titleID = bothScenario.GetNextTitleID();
                //pull out a response scenario
                SVScenario responseScenario = (SVScenario)SM.syncAvatarAssetsTypes[1].GetNextScenario();

                //set up the avatarAssets to sync
                request.AvatarAssets = new AvatarAssetWD[responseScenario.numAvatarAssets];
                request.AvatarAssetCount = (ushort)responseScenario.numAvatarAssets;


                for (int i = 0; i < responseScenario.numAvatarAssets; i++)
                {
                    int id = StressSupport.getNextAvatarAssetID(titleID, request.UserId);
                    // Ordinal ID and Sequence ID are same (although sequence in this case doesn't matter)
                    // BodyTypeMask is set to 3 - unisex, XLAST is setup with all unisex items for stress
                    request.AvatarAssets[i] = new AvatarAssetWD((uint)id, (byte)3, (uint)id);
                }
                request.TitleId = titleID;
                request.Version = DateTime.Now;

                //call sync avatarassets to sync this data
                request.Execute();

                SVScenario requestScenario = (SVScenario)SM.syncAvatarAssetsTypes[0].GetNextScenario();
                //set up the avatarassets to sync
                request.AvatarAssets = new AvatarAssetWD[responseScenario.numAvatarAssets];
                request.AvatarAssetCount = (ushort)responseScenario.numAvatarAssets;
                for (int i = 0; i < responseScenario.numAvatarAssets; i++)
                {
                    int id = StressSupport.getNextAchievementID(titleID, request.UserId);
                    // Ordinal ID and Sequence ID are same (although sequence in this case doesn't matter)
                    // BodyTypeMask is set to 3 - unisex, XLAST is setup with all unisex items for stress
                    request.AvatarAssets[i] = new AvatarAssetWD((uint)id, (byte)3, (uint)id);
                }

                DateTime t = DateTime.UtcNow;
                request.Version = t.AddMinutes(-rand.Next(1, 9999));

            }
            //we want to sync no new settings and recieve no new settings
            else if (synctype.name.ToLower().Contains("empty"))
            {
                request.AvatarAssets = new AvatarAssetWD[0];
                request.Version = DateTime.Now;
                request.TitleId = getTitle(); //random title
            }

            return request;
        }

        public static XRLEnumAvatarAsset GetEnumerateAvatarAssetsRequest()
        {
            RandomEx rand = new RandomEx();
            XRLEnumAvatarAsset request = new XRLEnumAvatarAsset(1, 1, 1,1,0,0);
            //pick users
            request.Puid = (ulong)StressSupport.GetNextUser();
            request.ForPuid = (ulong)StressSupport.GetNextUser();

            // Now get the next scenario and update the request info
            EVScenario scenario = SM.GetNextEVScenario();
            request.MaxAssets = (ushort)scenario.paramMaxAvatarAsset;
            request.StartingIndex = (ushort)scenario.paramMinAvatarAsset;
            // For Enum, make 25% of the calls be for titleID=0
            // which was added to return all avatar assets for that user
            int randNum = rand.Next(1, 5);  // random min includes 1, max excludes 5 (so 1-4)
            if (randNum == 1)
                request.TitleId = 0;
            else
                request.TitleId = scenario.GetNextTitleID();

            request.LocaleId = (ushort)Locales.en_US;
            return request;
        }

        public static ValidateAvatarManifestRequest GetValidateAvatarManifestsRequest()
        {
            RandomEx rand = new RandomEx();
            ValidateAvatarManifestRequest request = new ValidateAvatarManifestRequest();
            //pick user
            request.UserId = (ulong)StressSupport.GetNextUser();
            
            // Now get the next scenario and update the request info
            VMScenario scenario = SM.GetNextVMScenario();
            request.ValidationFlags = (uint)scenario.validationFlags;

            // currently use the same manifest, need to change this to have a few options to help stress all the validation code
            // including 
            string manifestDefaultMale = "00000000BF000000BF00000000100000031F0003C1C8F109A19CB2E000080000032B0003C1C8F109A19CB2E000200000033B0003C1C8F109A19CB2E00000800002EA0003C1C8F109A19CB2E00000000000000000000000000000000000002000029E0003C1C8F109A19CB2E0000000000000000000000000000000000000400002640003C1C8F109A19CB2E03F800000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000FFD7AA71FF6E5326FFB56157FF6381A7FF493421FF5395CAFF493421FFCF5969FFCF59690000000200000001C1C8F109A19CB2E0000200000000000000000000000000000000000100020003C1C8F109A19CB2E0000100000000000000000000000000000000000401B20003C1C8F109A19CB2E0000400000000000000000000000000000000000800580001C1C8F109A19CB2E0000800000000000000000000000000000000001000900001C1C8F109A19CB2E0001000000000000000000000000000000000002000310001C1C8F109A19CB2E0002000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000002000310001C1C8F109A19CB2E0002000000000000000000000000000000000001000900001C1C8F109A19CB2E0001000000000000000000000000000000000000800580001C1C8F109A19CB2E0000800000000000000000000000000000000000401B20003C1C8F109A19CB2E000040000000000000000000000000000E004B6145AE2B204000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000";
            xonline.common.service.AvatarManifest manifest = xonline.common.service.AvatarManifest.Read(AvatarManifestHelpers.HexToBytes(manifestDefaultMale));
            request.AvatarManifest = (byte[])manifest;

            return request;
        }

        // Create an XRLUploadConsoleListRequest and make the request
        // with uploading, signing and consoleList the same consoleId
        public static uint UploadConsoleAuditListRequest()
        {
            RandomEx rand = new RandomEx();
            uint hr;

            ulong puid;
            puid = (ulong)StressSupport.GetNextUser();
            
            // Don't want to grow the DB too big for this with completely random, so want a way to 
            // reuse the same list of the same user later.  So we'll give consoleid
            // some uniqueness but ref the last byte of the puid for the last byte so it will be the same next time
            byte[] consoleId = new byte[] { 0x00, 0x98, 0xBA, 0xDC, 0xFE };
            consoleId[0] = (byte)puid;

            int randNum = rand.Next(1, 21);  // random min includes 1, max excludes 21 (so 1-20)

            // kkline - 5% of the time we are going to have a bigger list
            // because at this point I don't know what we'll see in prod
            if (randNum == 20)
            {
                // Create a consolist, the first item is the signing consoleId set above
                ConsoleIdData[] consoleList = new ConsoleIdData[5];
                consoleList[0] = new ConsoleIdData(consoleId);

                // Loop through the remaining 4 and create consoleIds
                for (int i = 1; i < consoleList.Length; i++)
                {
                    consoleList[i] = new ConsoleIdData(new byte[] { (byte)i, 0x11, 0x11, 0x11, 0x11 });
                }

                // XRL request with uploading and signing consoleId the same, with consoleList provided.
                XRLUploadConsoleListRequest bigrequest = new XRLUploadConsoleListRequest(puid, consoleId, consoleId, consoleList);
                hr = bigrequest.PostXRLUploadConsoleListRequest(puid, bigrequest, CSGInfo.ClientType.Xenon);
            }
            // The other 95% of the time make a standard single entry call
            else
            {
                // this is the default XRL request which uses the same uploading consoleId as the 
                // signing consoleId and the single consoleId in the consoleList
                XRLUploadConsoleListRequest request = new XRLUploadConsoleListRequest(puid, consoleId);
                hr = request.PostXRLUploadConsoleListRequest(puid, request, CSGInfo.ClientType.Xenon);
            }

            return hr;
        }

        public static RedSetReq GetReadSettings( )
        {
            RandomEx rand = new RandomEx();
            RedSetReq  tmp = new RedSetReq();
            //pick a user to initiate the call
            tmp.user=(ulong) StressSupport.GetNextUser();

            //get the scenario
            RSScenario scenario = SM.GetNextRSScenario();
            //save the settings for this scenario
            tmp.sifds = scenario.settings;
            //pick a number of users for this scenario
            tmp.forUsers = new ulong[scenario.GetNextUserCount()];
            for(int i=0; i<tmp.forUsers.Length; i++)
            {
                tmp.forUsers[i] = GetNextUser();
            }
            
            //save the titleID for this scenario
            tmp.title = scenario.GetNextTitleID();
            return tmp;


//                /*
//                 int randnum = rand.Next(1,102);
//                if (randnum <= 46) //we're going to request the picture
//                {
//                    //get the settings for picture
//                    tmp.sifds = new uint[] {ProfileDefs.XPROFILE_GAMERCARD_PICTURE_KEY};
//                    
//                    //get the number of users to request the picture for
//                    int numUsers = getNumPictureUsers();
//                    tmp.forUsers = new ulong[numUsers];
//                    for(int i=0; i<numUsers; i++)
//                    {
//                        tmp.forUsers[i] = GetNextUser();
//                    }
//
//                    //set the title
//                    tmp.title = getNonRandomTitle();
//                        
//                    }
//                    else if(randnum <= 46+15)  //we're going to request the name&motto
//                    {
//                        //get the settings for n&m
//                        tmp.sifds = ProfileDefs.XPROFILE_NAME_MOTTO_SETTINGS;
//
//                        //get the number of users to request the n&m for
//                         int numUsers = getNumNameMottoUsers();
//                         tmp.forUsers = new ulong[numUsers];
//                        for(int i=0; i<numUsers; i++)
//                        {
//                            tmp.forUsers[i] = GetNextUser();
//                        }
//
//                        //set the title
//                        tmp.title = getNonRandomTitle();
//                    }
//                    else if(randnum <= 46+15+13) //we're going to request the gamercard
//                    {
//                        //get gamercard settings
//                         tmp.sifds = ProfileDefs.XPROFILE_GAMERCARD_SETTINGS;
//
//                        //gamercard is only request for 1 user.
//                        //set the user
//                        tmp.forUsers = new ulong[] {GetNextUser()};
//
//                        //set the title
//                        tmp.title = getNonRandomTitle();
//                        
//                    }
//                    else if(randnum <= 46+15+13+8) //we're going to request the extended profile info (name,loc,bio)
//                    {
//                        //get xtended profile settings
//                         tmp.sifds = ProfileDefs.XPROFILE_EXTENDED_PROFILE_SETTINGS;
//
//                        //extended profile is only request for 1 user.
//                        //set the user
//                        tmp.forUsers = new ulong[] {GetNextUser()};
//
//                        //set the title
//                        tmp.title = getNonRandomTitle();
//                    }
//                    else if(randnum <= 46+15+13+8+8) //we're going to request has_vision (stupid client360 bug)
//                    {
//                         //get has_vision setting
//                         tmp.sifds = new uint[] {ProfileDefs.XPROFILE_GAMERCARD_HAS_VISION};
//
//                        //set the user
//                        int numUsers = getNumHasVisionUsers();
//                        tmp.forUsers = new ulong[numUsers];
//                        for(int i=0; i<numUsers; i++)
//                        {
//                            tmp.forUsers[i] = GetNextUser();
//                        }
//
//                        //set the title
//                        tmp.title = getNonRandomTitle();
//                    }
//                    else if(randnum <= 46+15+13+8+8+6) //we're going to request the reputation
//                    {
//                        //get reputation setting
//                         tmp.sifds = new uint[] {ProfileDefs.XPROFILE_GAMERCARD_REP};
//
//                        //set the user
//                        int numUsers = getNumReputationUsers();
//                        tmp.forUsers = new ulong[numUsers];
//                        for(int i=0; i<numUsers; i++)
//                        {
//                            tmp.forUsers[i] = GetNextUser();
//                        }
//
//                        //set the title
//                        //1 REPUTATION HAS A DIFFERENT USER TITLE SKEW. 
//                        tmp.title = getNonRandomTitle();
//                    }
//                    else if(randnum <= 46+15+13+8+8+6+2) //we're going to request the xboxcom small gamercard
//                    {
//                        //get small gamercard setting
//                         tmp.sifds = ProfileDefs.XPROFILE_XBOXCOM_SMALL_GAMERCARD;
//
//                        //smallgamercard is only request for 1 user.
//                        //set the user
//                        tmp.forUsers = new ulong[] {GetNextUser()};
//                        
//                        //.com uses the .com title id
//                        tmp.title = XOn.WEB_TITLE_ID;
//                    }
//                    else if(randnum <= 46+15+13+8+8+6+2+2) //we're going to request the xboxcom gamertile
//                    {
//                        //get gamertile setting
//                         tmp.sifds = ProfileDefs.XPROFILE_XBOXCOM_GAMERTILE;
//
//                        //set the user
//                        int numUsers = getNumGamertileUsers();
//                        tmp.forUsers = new ulong[numUsers];
//                        for(int i=0; i<numUsers; i++)
//                        {
//                            tmp.forUsers[i] = GetNextUser();
//                        }
//                        
//                        //.com uses the .com title id
//                        tmp.title = XOn.WEB_TITLE_ID;
//                    }
//                    else if(randnum <= 46+15+13+8+8+6+2+2+1) //we're going to request the xboxcom large gamercard
//                    {
//                        //get large gamercard setting
//                         tmp.sifds = ProfileDefs.XPROFILE_XBOXCOM_LARGE_GAMERCARD;
//
//                        //large gamercard is only request for 1 user.
//                        //set the user
//                        tmp.forUsers = new ulong[] {GetNextUser()};
//                        
//                        //.com uses the .com title id
//                        tmp.title = XOn.WEB_TITLE_ID;
//                    }
//                    else if(randnum <= 46+15+13+8+8+6+2+2+1+1)//we're going to request the title specific settings
//                    {
//                        //get title specific setting
//                         tmp.sifds = ProfileDefs.XPROFILE_TITLE_OVERRIDE_SETTINGS;
//
//                        //set the user, only one user
//                        tmp.forUsers = new ulong[] {GetNextUser()};
//                        
//                        //very few titles use the title specific settings (about 5), and they are NOT popular (as you can tell, <1% of RS requests request these group of settings).
//                        //so the actual title ID isn't importnat, just as long as it's the same one every time
//                        tmp.title = (uint) StressConst.TitleStart + 6;
//                    }*/
                    
            


            //TitleInfo current =null;
            //Hashtable userinfo=null;
            //bool found = false;
            //do
            //{
            //  if(UsersList.Count >0)
            //  {
            //      int idx = rand.Next(0,UsersList.Count);
            //      cUser=(ulong)UsersList[idx];
            //  }
            //  else
            //      return null;
            //  
            //  
            //  if(cUser<=StressConst.UMask)
            //      return null;

            //  userinfo= (Hashtable)UsersInfo[cUser];
            //  if(userinfo!=null)
            //  {
            //      lock(userinfo)
            //      {
            //          foreach(TitleInfo  Tinfo in userinfo.Values)
            //          {
            //              if(Tinfo.settings.Keys.Count>1)
            //              {
            //                  current=Tinfo;
            //                  found=true;
            //                  break;
            //              }
            //          }
            //      }
            //  }
            //}while(!found);

            //tmp.user=cUser;
            //tmp.title= current.titleid;
            
            //lock(current)
            //{
            //  int len = current.settings.Keys.Count<count?current.settings.Keys.Count:count;
            //  tmp.sifds = new uint[len];
            //  int i=1;
                     //       tmp.sifds[0]=ProfileDefs.XPROFILE_GAMERCARD_PICTURE_KEY;
            //  foreach(uint key in current.settings.Keys)
            //  {
            //      if(i>=len)
            //          break;
            //      tmp.sifds[i++]= key;
            //  }
            //      
            //}
            
        }

        public static RedSetReq GetUserTitle()
        {
            RandomEx rand = new RandomEx();
            RedSetReq  tmp = new RedSetReq();
            ulong cUser=(ulong) StressSupport.GetNextUser();
            TitleInfo current =null;
            Hashtable userinfo=null;
            bool found = false;
            int Retrycount=0;
            do
            {
                /*if(UsersList.Count >300)  - this was commented out, it's never set.
                {
                    int idx = rand.Next(0,UsersList.Count);
                    cUser=(ulong)UsersList[idx];
                }
                else
                    return null;
                
                
                if(cUser<=StressConst.UMask)
                    return null;
                */

                userinfo= (Hashtable)UsersInfo[cUser];
                if(userinfo!=null)
                {
                    lock(userinfo)
                    {
                        if(userinfo.Count>2)
                        {
                            

                        
                            foreach(TitleInfo  Tinfo in userinfo.Values)
                            {
                                if(Tinfo.NextAchievementID>=1)
                                {
                                    current=Tinfo;
                                    userinfo.Remove(current.titleid);
                                    found=true;
                                    break;
                                }

                            }
                        }
                    }
                }
                Retrycount++;
            }while(!found && Retrycount<5);

            if(Retrycount >= 5)
                return null;

            tmp.user=cUser;
            tmp.title= current.titleid;
            return tmp;
            
        }

        public static int getNextAchievementID(uint title, ulong user)
        {
            int NextId= 0;
            Hashtable userinfo=null;
            if(UsersInfo.ContainsKey(user))
            {
                userinfo= (Hashtable)UsersInfo[user];
            }
            else
            {
                userinfo= new Hashtable();
                UsersInfo.Add(user,userinfo);

            }
            TitleInfo  Tinfo= null;
            if(userinfo.ContainsKey(title))
                Tinfo= (TitleInfo) userinfo[title];
            else
            {
                Tinfo=new TitleInfo(title);
                userinfo.Add(title,Tinfo);
            }
            NextId = Interlocked.Increment(ref Tinfo.NextAchievementID);
            lock(Tinfo)
            {
                if(NextId>=40)
                {

                    NextId=0;
                    lock(TitlesToClear)
                    {
                        TitlesToClear.Add(Tinfo);
                    }
                }
            }
            return NextId;


        }

        public static int getNextAvatarAssetID(uint title, ulong user)
        {
            // Avatar Assets start with ordinal of 1 and go to 5
            // but we are going to increment this before we send it out
            int NextId = 0;
            Hashtable userinfo = null;
            if (UsersInfo.ContainsKey(user))
            {
                userinfo = (Hashtable)UsersInfo[user];
            }
            else
            {
                userinfo = new Hashtable();
                UsersInfo.Add(user, userinfo);

            }
            TitleInfo Tinfo = null;
            if (userinfo.ContainsKey(title))
                Tinfo = (TitleInfo)userinfo[title];
            else
            {
                Tinfo = new TitleInfo(title);
                userinfo.Add(title, Tinfo);
            }
            NextId = Interlocked.Increment(ref Tinfo.NextAvatarAssetID);
            lock (Tinfo)
            {
                // If we reach past the 5th avatar asset
                if (NextId > 5)
                {
                    // set it to 1 for when we send this out
                    NextId = 1;
                    lock (TitlesToClear)
                    {
                        TitlesToClear.Add(Tinfo);
                    }
                }
            }
            return NextId;


        }

        public static byte[] GetNextValueBasedOnSettingID(uint settingID, uint title)
        {
            RandomEx rand = new RandomEx();
            if (settingID == ProfileDefs.XPROFILE_GAMERCARD_PICTURE_KEY)
            {
                int pic = rand.Next(9999);
                return SConvert.UnicodeBytes(title.ToString("X8") + pic.ToString("X8") + pic.ToString("X8") + "\0");
            
            }
            // The original code dup'ed the picture key, but i think the intended code
            // should have been for the personal pic, where we use the FFFE0700.
            if (settingID == ProfileDefs.XPROFILE_GAMERCARD_PERSONAL_PICTURE)
            {
                int pic = rand.Next(9999);
                return SConvert.UnicodeBytes(("FFFE0700" + "0000" + pic.ToString("X4") + "0000" + pic.ToString("X4") + "\0"));
            
            }

            //SettingInfo GetMaxSize function (ushort)((Id >> 16) & 0x3FF);
            //with BUG LSG 5804 - MaxSize is now checked so these calls could fail
            int settingIDMaxSize = (int)((settingID >> 16) & 0x3FF);

            // want to make sure avatar stuff always gets max size
            if ((settingID == ProfileDefs.XPROFILE_GAMERCARD_AVATAR_INFO_1) || (settingID == ProfileDefs.XPROFILE_GAMERCARD_AVATAR_INFO_2))
            {
                //byte[] val2 = new byte[settingIDMaxSize];
                //rand.NextBytes(val2);
                //return val2;

                string manifest = "00000000BF8000003F80000000100000031C0003C1C8F109A19CB2E00008000003250003C1C8F109A19CB2E000200000033B0003C1C8F109A19CB2E00000800002EB0003C1C8F109A19CB2E03F8000000000000000000000000000000000200002A40003C1C8F109A19CB2E03F80000000000000000000000000000000004000026F0003C1C8F109A19CB2E03F800000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000FFD7AA71FF493421FFC65265FF243F53FF493421FFB37D59FF493421FF399251FF3992510000000200010002C1C8F109A19CB2E0000200000000000000000000000000000000000100020003C1C8F109A19CB2E0000100000000000000000000000000000000000402410003C1C8F109A19CB2E0000400000000000000000000000000000000000801130002C1C8F109A19CB2E000080000FF0F5DA6000000000000000000000010015E0002C1C8F109A19CB2E0001000000000000000000000000000000000002001090002C1C8F109A19CB2E0002000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000002001090002C1C8F109A19CB2E00020000000000000000000000000000000000010015E0002C1C8F109A19CB2E0001000000000000000000000000000000000000801130002C1C8F109A19CB2E000080000FF0F5DA600000000000000000000000402410003C1C8F109A19CB2E000040000000000000000000000000000E00038D55A354F22000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000";
                return AvatarManifestHelpers.HexToBytes(manifest);
            }

            //random 4 - MaxSize for the setting bytes. this will need to change for better accuracy!!!!
            int length = rand.Next(4, settingIDMaxSize); 
            byte[] val = new byte[length];
            rand.NextBytes(val);
            return val;
        }
    
        
//        public static uint GetRandomSettingid()
//        {
//            RandomEx rand = new RandomEx();
//            return (uint)((int)TestUSetting.Test_bMaxNo+rand.Next(1,StressConst.max_settings));
//        }
//        public static int GetSettingCountTosync()
//        {
//            RandomEx rand = new RandomEx();
//            //80% of the time setting count must be zero , 20% on the time it will be beetween 1 to 10.
//            int scount=0;
//            int tmp =rand.Next(1,100);
//            if(tmp>80)
//                scount=rand.Next(1,StressConst.max_settingstoSync);
//            return scount;
//
//        }

//        public static int GetNoOFTitlesTosync()
//        {
//            RandomEx rand = new RandomEx();
//            //80% of the time setting count must be zero , 20% on the time it will be beetween 1 to 10.
//            int scount=1;
//            int tmp =rand.Next(1,100);
//            if(tmp>80)
//                scount=rand.Next(1,StressConst.max_settingstoSync);
//
//            return scount;
//
//        }

        public static uint getTitle()
        {
            RandomEx rand = new RandomEx();
             return (uint)rand.Next(StressConst.TitleStart,(StressConst.TitleStart+StressConst.TitleCount));
        }
//              public static uint getNonRandomTitle()
//        {
//              RandomEx rand = new RandomEx();
//                    int randnum = rand.Next(1,100);
//
//                    
//                    if (randnum <= 30) // title 1
//                    {
//                       return (uint) StressConst.TitleStart;
//                    }
//                    else if(randnum <=30+25) //title2
//                    {
//                        return (uint) StressConst.TitleStart + 1;
//                    }
//                     else if(randnum <=30+25+12) //dash title!
//                    {
//                        return (uint) XOn.XENON_DASH_TITLE_ID;
//                    }
//                    else if(randnum <=30+25+12+7) // title3!
//                    {
//                        return (uint) StressConst.TitleStart + 2;
//                    }
//                     else if(randnum <=30+25+12+7+2) // title5!
//                    {
//                        return (uint) StressConst.TitleStart + 3;
//                    }
//                    else if(randnum <=30+25+12+7+2+1) // title6!
//                    {
//                        return (uint) StressConst.TitleStart + 4;
//                    }
//                    else if(randnum <=30+25+12+7+2+1+1) // title7!
//                    {
//                        return (uint) StressConst.TitleStart + 5;
//                    }
//                    else if(randnum <=30+25+12+7+2+1+1+1) // title8!
//                    {
//                        return (uint) StressConst.TitleStart + 6;
//                    }
//                    else
//                    {
//                        //random title
//                        return (uint)rand.Next(StressConst.TitleStart+7,(StressConst.TitleStart+StressConst.TitleCount));
//                    }
//             
//        }
//
//                public static int getNumPictureUsers()
//                {
//                    RandomEx rand = new RandomEx();
//                    int randnum = rand.Next(1,100);
//                    if (randnum <= 52) 
//                    {
//                        return 16 ;
//                    }
//                    else if(randnum <=52+14) 
//                    {
//                        return 1;
//                    }
//                     else if(randnum <=52+14+8) 
//                    {
//                        return 2;
//                    }
//                    else if(randnum <=52+14+8+5) 
//                    {
//                        return 5;
//                    }
//                     else if(randnum <=52+14+8+5+4) 
//                    {
//                        return 7;
//                    }
//                    else if(randnum <=52+14+8+5+4+3)
//                    {
//                        return 6;
//                    }
//                    else if(randnum <=52+14+8+5+4+3+3) 
//                    {
//                        return 4;
//                    }
//                    else if(randnum <=52+14+8+5+4+3+3+2) 
//                    {
//                        return 3;
//                    }
//                    else
//                    {
//                        return rand.Next(8,15);
//                    }
//                }
//
//                 public static int getNumNameMottoUsers()
//                {
//                    //you gotta love client bugs...name&motto doesn't request up to 16 users...only 8.
//                    RandomEx rand = new RandomEx();
//                    int randnum = rand.Next(1,100);
//                    if (randnum <= 89) 
//                    {
//                        return 16 ;
//                    }
//                    else if(randnum <=89+3) 
//                    {
//                        return 1;
//                    }
//                    else
//                    {
//                        return rand.Next(2,7);
//                    }
//                }
//
//                 public static int getNumHasVisionUsers()
//                {
//                    RandomEx rand = new RandomEx();
//                    int randnum = rand.Next(1,100);
//                    if (randnum <= 98) 
//                    {
//                        return 1 ;
//                    }
//                    else if(randnum <=98+2)
//                    {
//                        return 16;
//                    }
//                     else
//                    {
//                        return rand.Next(2,15);
//                    }
//                }
//
//                 public static int getNumReputationUsers()
//                {
//                    RandomEx rand = new RandomEx();
//                    int randnum = rand.Next(1,100);
//                    if (randnum <= 56) 
//                    {
//                        return 16 ;
//                    }
//                    else if(randnum <=56+22) 
//                    {
//                        return 1;
//                    }
//                     else if(randnum <=56+22+4) 
//                    {
//                        return 2;
//                    }
//                    else if(randnum <=56+22+4+2) 
//                    {
//                        return 3;
//                    }
//                     else if(randnum <=56+22+4+2+2) 
//                    {
//                        return 7;
//                    }
//                    else if(randnum <=56+22+4+2+2+2)
//                    {
//                        return 4;
//                    }
//                    else if(randnum <=56+22+4+2+2+2+2) 
//                    {
//                        return 5;
//                    }
//                    else if(randnum <=56+22+4+2+2+2+2) 
//                    {
//                        return 6;
//                    }
//                    else
//                    {
//                        return rand.Next(8,15);
//                    }
//
//                }
//
//                 public static int getNumGamertileUsers()
//                {
//                    RandomEx rand = new RandomEx();
//                    int randnum = rand.Next(1,100);
//                    if (randnum <= 70) 
//                    {
//                        return 16 ;
//                    }
//                    else
//                    {
//                        return rand.Next(1,15);
//                    }
//                }
    }

}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\StfTests\GPStress\obj\i386\_generated.cs ===
[assembly:System.Runtime.InteropServices.ComVisible(false)]
[assembly:System.Reflection.AssemblyVersion("12.4.56.0")]
[assembly:System.Reflection.AssemblyProduct("Microsoft(R) Xbox(TM)")]
[assembly:System.Reflection.AssemblyCopyright("Copyright (c) Microsoft Corporation. All rights reserved.")]
[assembly:System.Reflection.AssemblyCompany("Microsoft Corporation")]
[assembly:System.Reflection.AssemblyFileVersion("12.4.56.0")]
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\StfTests\GPStress\obj\i386\_asmid.inc ===
ASSEMBLY_IDENTITY_KEY_FORM=msil_gpstress_none_12.4.56.0_none_bc49990a4a7cf80c
ASSEMBLY_IDENTITY_XP_KEY_FORM=msil_gpstress_no-public-key_12.4.56.0_x-ww_65b34f80
ASSEMBLY_IDENTITY_CULTURE=
ASSEMBLY_IDENTITY_NAME=gpstress
ASSEMBLY_IDENTITY_PROCESSOR_ARCHITECTURE=msil
ASSEMBLY_IDENTITY_PUBLIC_KEY=
ASSEMBLY_IDENTITY_PUBLIC_KEY_TOKEN=
ASSEMBLY_IDENTITY_TYPE=
ASSEMBLY_IDENTITY_TYPE_NAME=
ASSEMBLY_IDENTITY_VERSION=12.4.56.0
XP_KEY_FORM=msil_gpstress_no-public-key_12.4.56.0_x-ww_65b34f80
XP_MANIFEST_DIRECTORY=manifests
XP_MANIFEST_NAME=msil_gpstress_no-public-key_12.4.56.0_x-ww_65b34f80.manifest
XP_MANIFEST_PATH=manifests\msil_gpstress_no-public-key_12.4.56.0_x-ww_65b34f80.manifest
XP_CATALOG_DIRECTORY=manifests
XP_CATALOG_NAME=msil_gpstress_no-public-key_12.4.56.0_x-ww_65b34f80.cat
XP_CATALOG_PATH=manifests\msil_gpstress_no-public-key_12.4.56.0_x-ww_65b34f80.cat
XP_PAYLOAD_PATH=msil_gpstress_no-public-key_12.4.56.0_x-ww_65b34f80
_DELAY_SIGN=0
!if [set _ASMIDTOATTRIBS_TLBIMP=]
!endif
CODESIGN_TESTKEY=
_TLBIMP_FLAGS=$(_TLBIMP_FLAGS)  /asmversion:12.4.56.0
_ASSEMBLY_IDENTITY=gpstress,processorArchitecture=msil,version=12.4.56.0,publicKeyToken=neutral
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\StfTests\GPStress\Achievements.cs ===
using System;
using ServerTestFramework;
using ServerTestFramework.Database;
using ServerTestFramework.LiveService;
using ServerTestFramework.LiveService.Achievement;
using ServerTestFramework.LiveService.AvatarAsset;
using ServerTestFramework.LiveService.Presence;
using ServerTestFramework.LiveService.PresNotiCommon;
using ServerTestFramework.LiveService.UserSettings;
using xonline.common.config;
using ServerTestFramework.LiveService.UploadConsoleList;
using ServerTestFramework.Utilities;

namespace GPStress
{
    /// <summary>
    /// SyncAchievements adds 1 or 2 achievements to the next user and title, always achieved online.
    /// </summary>
    [StressInstantiate]
    public class SyncAchievements :TestBase
    {
        protected override void Execute()
        {
            XRLSyncAchievements req = StressSupport.GetSyncAchievementRequest();
            SyncAchievementsResponse resp = req.Execute();
            if(HResult.Succeeded(resp.xResult))
                ResultCode=TEST_RESULTS.PASSED;
            else
                ResultCode= TEST_RESULTS.FAILED;

            #region cutcode
//            RandomEx rand = new RandomEx();
//
//            uint title = StressSupport.getTitle();
//            ulong user = StressSupport.GetNextUser();
//            int count =1;
//
//            if(rand.Next(0,2)<1)
//                count=2;
//
//
//            AchievementWD[] ach=new AchievementWD[count];
//            for(int i=0;i< count;i++)
//            {
//                int id =StressSupport.getNextAchievementID(title,user);
//                ach[i]= new AchievementWD((uint)id,(uint)id);
//            }
//                        
//            XRLSyncAchievements req = new XRLSyncAchievements(title,user,ach);
//            SyncAchievementsResponse resp = req.Execute();
//            if(HResult.Succeeded(resp.xResult))
//                ResultCode=TEST_RESULTS.PASSED;
//            else
//                ResultCode= TEST_RESULTS.FAILED;
            #endregion
        }
    }

    //EnumAchievements calls for 32 achievements for the next user and title from the next next user
    [StressInstantiate]
    public class EnumAchievements :TestBase
    {
        protected override void Execute()
        {
            #region cutcode
//            uint title = StressSupport.getTitle();
//            ulong user = StressSupport.GetNextUser();
//            ulong friend = StressSupport.GetNextUser();
//
//            XRLEnumAchievement req= new XRLEnumAchievement(title,user,friend,(ushort)Locales.en_US,0,32);
            #endregion

            XRLEnumAchievement req= StressSupport.GetEnumerateAchievementsRequest();
            AchievementEnumResponse resp= req.Execute();
            if(HResult.Succeeded(resp.xResult))
                ResultCode=TEST_RESULTS.PASSED;
            else
                ResultCode= TEST_RESULTS.FAILED;
        }
    }

    /// <summary>
    /// SyncAvatarAssets adds 1 or 2 avatarassets to the next user and title, always achieved online.
    /// </summary>
    [StressInstantiate]
    public class SyncAvatarAssets : TestBase
    {
        protected override void Execute()
        {
            XRLSyncAvatarAssets req = StressSupport.GetSyncAvatarAssetsRequest();
            SyncAvatarAssetsResponse resp = req.Execute();
            if (HResult.Succeeded(resp.xResult))
                ResultCode = TEST_RESULTS.PASSED;
            else
                ResultCode = TEST_RESULTS.FAILED;
        }
    }
    //EnumAvatarAssets calls for 5 avatar assets for the next user and title from the next next user
    [StressInstantiate]
    public class EnumAvatarAssets : TestBase
    {
        protected override void Execute()
        {
            XRLEnumAvatarAsset req = StressSupport.GetEnumerateAvatarAssetsRequest();
            AvatarAssetEnumResponse resp = req.Execute();
            if (HResult.Succeeded(resp.xResult))
                ResultCode = TEST_RESULTS.PASSED;
            else
                ResultCode = TEST_RESULTS.FAILED;
        }
    }

    // Upload Console Audit List is different from the rest, it will just do the single case
    // without reading anything from the XML file.
    [StressInstantiate]
    public class UploadConsoleAuditList : TestBase
    {
        protected override void Execute()
        {
            uint hr;
            // Create an XRL request and make the request
            hr = StressSupport.UploadConsoleAuditListRequest();
            
            if (hr == HResult.S_OK)
                ResultCode = TEST_RESULTS.PASSED;
            else
                ResultCode = TEST_RESULTS.FAILED;
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\StfTests\GPStress\Settings.cs ===
using System;
using ServerTestFramework;
using ServerTestFramework.LiveService;
using ServerTestFramework.Utilities;
using ServerTestFramework.LiveService.UserSettings;

namespace GPStress
{
    /// <summary>
    /// SyncSettings picks a random user, title and settings to add or update. It always adds or updates the gamerpicture and personal pictures.
    /// The number of settings to add/update is random, with an 80% chance that no settings will be updated (except for pictures)
    /// </summary>
    [StressInstantiate]
    public class SyncSettings : TestBase
    {
        protected override void Execute()
        {
            SyncSettingsRequest req = StressSupport.GetSyncSettingRequest();
            SyncSettingsResponse resp = req.Execute();
            if (HResult.Succeeded(resp.XError))
                ResultCode = TEST_RESULTS.PASSED;
            else
                ResultCode = TEST_RESULTS.FAILED;
        }
    }

    /// <summary>
    /// GetSettings picks a random user with more than 1 title setting. Always returns the first title that has more than 1 title setting (not too good)
    /// Up to 11 settings from the title are then read from user-1.
    /// </summary>
    [StressInstantiate]
    public class GetSettings : TestBase
    {
        protected override void Execute()
        {
            //get a random user that has >1 settings, and up to the first 10 settings with the first setting as gamercard_picture_key
            RedSetReq tmp = StressSupport.GetReadSettings();
            if (tmp != null)
            {
                //read the user's settings as user -1 
                ReadSettingsRequest req = new ReadSettingsRequest(tmp.title, tmp.user, tmp.forUsers, tmp.sifds);
                req.SchemaVersion = WireData.MakeSchemaVersion(5, 0);
                ReadSettingsResponse resp = req.Execute();
                if (HResult.Succeeded(resp.XError))
                {
                    ResultCode = TEST_RESULTS.PASSED;
                }
                else
                {
                    ResultCode = TEST_RESULTS.FAILED;
                }
            }
            else
                ResultCode = TEST_RESULTS.NOT_EXECUTED;
        }
    }

    /// <summary>
    /// Call ValidateAvatarManifest API with a different validation flag
    /// </summary>
    [StressInstantiate]
    public class ValidateAvatarManifests : TestBase
    {
        protected override void Execute()
        {
            ValidateAvatarManifestRequest req = StressSupport.GetValidateAvatarManifestsRequest();
            ValidateAvatarManifestResponse resp = req.Execute();
            if (resp.ValidationResult == 1)
                ResultCode = TEST_RESULTS.PASSED;
            else
                ResultCode = TEST_RESULTS.FAILED;
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\StfTests\GPStress\objd\i386\_generated.cs ===
[assembly:System.Runtime.InteropServices.ComVisible(false)]
[assembly:System.Reflection.AssemblyVersion("12.4.56.0")]
[assembly:System.Reflection.AssemblyProduct("Microsoft(R) Xbox(TM)")]
[assembly:System.Reflection.AssemblyCopyright("Copyright (c) Microsoft Corporation. All rights reserved.")]
[assembly:System.Reflection.AssemblyCompany("Microsoft Corporation")]
[assembly:System.Reflection.AssemblyFileVersion("12.4.56.0")]
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\StfTests\GPStress\objd\i386\_asmid.inc ===
ASSEMBLY_IDENTITY_KEY_FORM=msil_gpstress_none_12.4.56.0_none_bc49990a4a7cf80c
ASSEMBLY_IDENTITY_XP_KEY_FORM=msil_gpstress_no-public-key_12.4.56.0_x-ww_65b34f80
ASSEMBLY_IDENTITY_CULTURE=
ASSEMBLY_IDENTITY_NAME=gpstress
ASSEMBLY_IDENTITY_PROCESSOR_ARCHITECTURE=msil
ASSEMBLY_IDENTITY_PUBLIC_KEY=
ASSEMBLY_IDENTITY_PUBLIC_KEY_TOKEN=
ASSEMBLY_IDENTITY_TYPE=
ASSEMBLY_IDENTITY_TYPE_NAME=
ASSEMBLY_IDENTITY_VERSION=12.4.56.0
XP_KEY_FORM=msil_gpstress_no-public-key_12.4.56.0_x-ww_65b34f80
XP_MANIFEST_DIRECTORY=manifests
XP_MANIFEST_NAME=msil_gpstress_no-public-key_12.4.56.0_x-ww_65b34f80.manifest
XP_MANIFEST_PATH=manifests\msil_gpstress_no-public-key_12.4.56.0_x-ww_65b34f80.manifest
XP_CATALOG_DIRECTORY=manifests
XP_CATALOG_NAME=msil_gpstress_no-public-key_12.4.56.0_x-ww_65b34f80.cat
XP_CATALOG_PATH=manifests\msil_gpstress_no-public-key_12.4.56.0_x-ww_65b34f80.cat
XP_PAYLOAD_PATH=msil_gpstress_no-public-key_12.4.56.0_x-ww_65b34f80
_DELAY_SIGN=0
!if [set _ASMIDTOATTRIBS_TLBIMP=]
!endif
CODESIGN_TESTKEY=
_TLBIMP_FLAGS=$(_TLBIMP_FLAGS)  /asmversion:12.4.56.0
_ASSEMBLY_IDENTITY=gpstress,processorArchitecture=msil,version=12.4.56.0,publicKeyToken=neutral
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\StfTests\GPStress\TitleInfo.cs ===
using System;
using ServerTestFramework;
using ServerTestFramework.LiveService;
using ServerTestFramework.Utilities;
using ServerTestFramework.LiveService.UserSettings;
using xonline.common.config;

namespace GPStress
{
    [StressInstantiate]
    public class SyncTitleInfo : TestBase
    {
        protected override void Execute()
        {
            
//            ulong user = StressSupport.GetNextUser();
//            int Count = StressSupport.GetNoOFTitlesTosync();
//
//            UserTitle[] titles= new UserTitle[Count];
//            RandomEx rand = new RandomEx();
//
//            for(int i=0;i< Count;i++)
//            {
//                    int data =  rand.Next(1,72);
//                    DateTime tmp = DateTime.UtcNow;
//                    tmp = tmp.AddHours((-1*data));
//
//                    titles[i]= new UserTitle(StressSupport.getTitle(),tmp,(uint)data,(ushort)data,(uint)data);
//            }
//
//
//            SyncTitlesRequest req= new SyncTitlesRequest(user,DateTime.UtcNow,titles);
            SyncTitlesRequest req = StressSupport.GetSyncTitlesRequest();
            SyncTitlesResponse resp = req.Execute();
            if(HResult.Succeeded(resp.XError))
                ResultCode=TEST_RESULTS.PASSED;
            else
                ResultCode= TEST_RESULTS.FAILED;
        }

    }

    [StressInstantiate]
    public class EnumTitleInfo : TestBase
    {
        protected override void Execute()
        {
//            ulong user = StressSupport.GetNextUser();
//            ulong friend = StressSupport.GetNextUser();
//
//            EnumTitlesRequest req= new EnumTitlesRequest(user,friend,0,32);
            EnumTitlesRequest req=StressSupport.GetEnumerateTitlesRequest();

            EnumTitlesResponse resp= req.Execute();

            if(HResult.Succeeded(resp.XError))
                ResultCode=TEST_RESULTS.PASSED;
            else
                ResultCode= TEST_RESULTS.FAILED;

        }

    }

    [StressInstantiate]
    public class DeleteTitle : TestBase
    {
        protected override void Execute()
        {
            RedSetReq tmp = StressSupport.GetUserTitle();
            
            if(tmp!=null)
            {

                TitleClearRequest req= new TitleClearRequest(tmp.user,tmp.title);

                req.Execute(Global.XEnv.GetVirtualInterface(VirtualInterface.xstatsfd));

                if(HResult.Succeeded(req.XErr))
                    ResultCode=TEST_RESULTS.PASSED;
                else
                    ResultCode= TEST_RESULTS.FAILED;
            }
            else
                ResultCode= TEST_RESULTS.NOT_EXECUTED;

        }

    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\StfTests\HijackAccountTests\Suite.cs ===
using System;
using ServerTestFramework;

[assembly: RootNode(typeof(HijackAccountTests.HijackAccountTests))]

namespace HijackAccountTests
{
    [TestGroup, TestFrequency("Regression")]
    public class HijackAccountTests: TestNode
    {
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\StfTests\HijackAccountTests\Combos.cs ===
using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using HijackAccountTests.Database;
using ServerTestFramework;
using ServerTestFramework.LiveService.UserAccount;
using ServerTestFramework.Utilities;
using xonline.common.config;
using xonline.common.service;

namespace HijackAccountTests
{
    public class ComboTestBase : HijackTestBase
    {
        protected UacsCommon UacsCommon = new UacsCommon();
        protected Events eventMonitor = null;

        public override void PreRun()
        {
            String[] serverList = Global.XEnv.GetServerListByInterface(Interface.xuacs);
            eventMonitor = new Events(serverList);
            // Events come from xuacs and xbos usually so we're not filtering
            //eventMonitor.Source = Interface.xuacs;

            base.PreRun();
        }

        public void StartEventMonitor()
        {
            if (!eventMonitor.Init())
            {
                Global.RO.Warn("Unable to connect to one or more servers for event logs.  This may cause failures.");
            }
        }

        /// <summary>
        /// Checks for a Hijacking Warning event.
        /// </summary>
        /// <param name="expect">Defines whether the event is expected to be found or not</param>
        public void CheckForWarning(Boolean expect)
        {
            CheckForEvent(XEvent.Id.ACCOUNTS_HIJACKING_WARNING, expect);
        }

        /// <summary>
        /// Checks for a Hijacking Error event.
        /// </summary>
        /// <param name="expect">Defines whether the event is expected to be found or not</param>
        public void CheckForError(Boolean expect)
        {
            CheckForEvent(XEvent.Id.ACCOUNTS_HIJACKING_ERROR, expect);
        }

        /// <summary>
        /// Checks the event monitor for the presence or absence of a specific event
        /// </summary>
        /// <param name="eventType">The type of event to look for</param>
        /// <param name="expect">If true and the event is not found, or false and the event is found, then an exception will be thrown</param>
        public void CheckForEvent(XEvent.Id eventType, Boolean expect)
        {
            if (eventMonitor.TestForChange((Int64)eventType, false) != expect)
            {
                if (expect)
                {
                    throw new UnexpectedTestResultException(eventType + " not logged.");
                }
                else
                {
                    throw new UnexpectedTestResultException(eventType + " logged when not expected.");
                }
            }
        }
    }

    [TestGroup, Owner("BenRan"), TestFrequency("Regression"), Description("Do you want fries with that?  Daily Double and Trifecta tests.")]
    [AsyncGroup(1)] // These tests cannot be run in parallel.  We do dumb event checking that only looks at event types, not event contents
    public class ComboTests : TestNode
    {
        [TestGroup, Description("Validates Hijack Warning events are logged when two of the three events occur")]
        public class DailyDouble : TestNode
        {
            [TestCase, TestCasePriority(1), Description("Recover account and switch passport on trusted console - no events")]
            public class RecoverPassportTrusted : ComboTestBase
            {
                public override void Run()
                {
                    StartEventMonitor();

                    // recover the account on their only machine they  ever  used
                    HijackUtilites.RecoverAccount(user);

                    // and switch their passport on  that  single  machine  (which
                    // should be allowed without waiting for the hijacing interval)

                    HijackUtilites.SwitchPassport(user, UacsCommon.CreatePassportUser());

                    // there should be no errors or warnings. it's only one machine

                    CheckForWarning(false);
                    CheckForError(false);
                }
            }

            [TestCase, TestCasePriority(1), Description("Recover account and switch passport across multiple trusted consoles - no events")]
            public class RecoverPassportMultipleTrusted : ComboTestBase
            {
                public override void Run()
                {
                    StartEventMonitor();

                    // recover the account on their only  machine  they  ever  used
                    HijackUtilites.RecoverAccount(user);

                    // give them a second machine, and enough tenure on the machine
                    // to get past  the  waiting  period  and  the  warning  period

                    HijackUtilites.SwitchMachines(user);
                    HijackUtilites.FastForwardTimeForUser(user.UserPuid, new TimeSpan(HijackSettings.HijackingIntervalHours, 0, 0));

                    // and switch their passport on  that  single  machine  (which
                    // should be allowed without waiting for the hijacing interval)

                    HijackUtilites.SwitchPassport(user, UacsCommon.CreatePassportUser());

                    // there should be no errors or warnings. it's only one machine

                    CheckForWarning(false);
                    CheckForError(false);
                }
            }
            


            [TestCase, TestCasePriority(1), Description("Recover account and switch passport on untrusted console - warning event")]
            public class RecoverPassportUntrusted : ComboTestBase
            {
                public override void Run()
                {
                    StartEventMonitor();

                    // users with only one machine are  not  considered  hijacked
                    // get onto a new machine and then recover the account  there

                    HijackUtilites.SwitchMachines(user);
                    HijackUtilites.RecoverAccount(user);

                    // move forward to get past the hijacking wait interval  time
                    // and perform a second critical account management operation

                    HijackUtilites.FastForwardTimeForUser(user.UserPuid, new TimeSpan(HijackSettings.PassportChangeWaitIntervalHours, 0, 0));
                    HijackUtilites.SwitchPassport(user, UacsCommon.CreatePassportUser());

                    CheckForWarning(true);
                    CheckForError(false);
                }
            }


            [TestCase, TestCasePriority(1), Description("Recover account and switch passport across multiple untrusted consoles - warning event")]
            public class RecoverPassportUntrusted_MultiMachine : ComboTestBase
            {
                public override void Run()
                {
                    StartEventMonitor();

                    // users with only one machine are  not  considered  hijacked
                    // get onto a new machine and then recover the account  there

                    HijackUtilites.SwitchMachines(user);
                    HijackUtilites.RecoverAccount(user);

                    // move to new machine and move time past hijacking  interval
                    // and perform a second critical account management operation

                    HijackUtilites.SwitchMachines(user);
                    HijackUtilites.FastForwardTimeForUser(user.UserPuid, new TimeSpan(HijackSettings.PassportChangeWaitIntervalHours, 0, 0));
                    HijackUtilites.SwitchPassport(user, UacsCommon.CreatePassportUser());

                    CheckForWarning(true);
                    CheckForError(false);
                }
            }

            [TestCase, TestCasePriority(1), Description("Recover account and change gamertag on trusted console - no events")]
            public class RecoverGamertagTrusted : ComboTestBase
            {
                public override void Run()
                {
                    StartEventMonitor();

                    // recover the account on their only machine they  ever  used
                    HijackUtilites.RecoverAccount(user);

                    // and change their gamertag on  that  single  machine  (which
                    // should be allowed without waiting for the hijacing interval)

                    HijackUtilites.ChangeGamertag(user, "X" + RandomEx.GlobalRandGen.GenerateRandomNameString(14));

                    // there should be no errors or warnings. it's only one machine

                    CheckForWarning(false);
                    CheckForError(false);
                }
            }

            [TestCase, TestCasePriority(1), Description("Recover account and change gamertag on multiple trusted console - no events")]
            public class RecoverGamertagTrusted_MultiMachine : ComboTestBase
            {
                public override void Run()
                {
                    StartEventMonitor();

                    // recover account  on  their  only  machine  they  ever  used
                    HijackUtilites.RecoverAccount(user);

                    // give them a second machine, and enough tenure on the machine
                    // to get past  the  waiting  period  and  the  warning  period

                    HijackUtilites.SwitchMachines(user);
                    HijackUtilites.FastForwardTimeForUser(user.UserPuid, new TimeSpan(HijackSettings.HijackingIntervalHours, 0, 0));

                    // and then change their gamertag on the new (trusted) machine
                    // should be allowed without waiting for the hijacking interval)

                    HijackUtilites.ChangeGamertag(user, "X" + RandomEx.GlobalRandGen.GenerateRandomNameString(14));

                    // there should be no errors or warnings. it's only one machine

                    CheckForWarning(false);
                    CheckForError(false);
                }
            }
                    
            [TestCase, TestCasePriority(1), Description("Recover account and change gamertag on untrusted console - warning event")]
            public class RecoverGamertagUntrusted : ComboTestBase
            {
                public override void Run()
                {
                    StartEventMonitor();

                    // users with only one machine are  not  considered  hijacked
                    // get onto a new machine and then recover the account  there

                    HijackUtilites.SwitchMachines(user);
                    HijackUtilites.RecoverAccount(user);

                    // move forward to get past the hijacking wait interval  time
                    // and perform a second critical account management operation

                    HijackUtilites.FastForwardTimeForUser(user.UserPuid, new TimeSpan(HijackSettings.GamertagChangeWaitIntervalHours, 0, 0));
                    HijackUtilites.ChangeGamertag(user, "X" + RandomEx.GlobalRandGen.GenerateRandomNameString(14));

                    CheckForWarning(true);
                    CheckForError(false);
                }
            }

            [TestCase, TestCasePriority(1), Description("Recover account and change gamertag across multiple untrusted consoles - warning event")]
            public class RecoverGamertagMultiple_MultiMahcine : ComboTestBase
            {
                public override void Run()
                {
                    StartEventMonitor();

                    // users with only one machine are  not  considered  hijacked
                    // get onto a new machine and then recover the account  there

                    HijackUtilites.SwitchMachines(user);
                    HijackUtilites.RecoverAccount(user);

                    // move to new machine and move time past hijacking  interval
                    // and perform a second critical account management operation

                    HijackUtilites.SwitchMachines(user);
                    HijackUtilites.FastForwardTimeForUser(user.UserPuid, new TimeSpan(HijackSettings.GamertagChangeWaitIntervalHours, 0, 0));
                    HijackUtilites.ChangeGamertag(user, "X" + RandomEx.GlobalRandGen.GenerateRandomNameString(14));

                    CheckForWarning(true);
                    CheckForError(false);
                }
            }


            [TestCase, TestCasePriority(2), Description("Change gamertag then recover account - warning event")]
            public class GamertagRecoverUntrusted : ComboTestBase
            {
                public override void Run()
                {
                    StartEventMonitor();

                    // we are recovering out of order,  but we can never  log
                    // events on our home machine.  get  on  another  machine

                    HijackUtilites.SwitchMachines(user);

                    // get past wait interval so we can change  our  gamertag
                    // but not so far that we won't get  any  warning  events

                    HijackUtilites.FastForwardTimeForUser(user.UserPuid, new TimeSpan(HijackSettings.GamertagChangeWaitIntervalHours, 0, 0));
                    HijackUtilites.ChangeGamertag(user, "X"+RandomEx.GlobalRandGen.GenerateRandomNameString(14));
                    HijackUtilites.RecoverAccount(user);

                    CheckForWarning(true);
                    CheckForError(false);
                }
            }

            [TestCase, TestCasePriority(2), Description("Switch passport then recover account - warning event")]
            public class PassportRecoverUntrusted : ComboTestBase
            {
                public override void Run()
                {
                    StartEventMonitor();

                    // we are recovering out of order,  but we can never  log
                    // events on our home machine.  get  on  another  machine

                    HijackUtilites.SwitchMachines(user);

                    // get past wait interval so we can change  our  gamertag
                    // but not so far that we won't get  any  warning  events

                    HijackUtilites.FastForwardTimeForUser(user.UserPuid, new TimeSpan(HijackSettings.GamertagChangeWaitIntervalHours, 0, 0));
                    HijackUtilites.SwitchPassport(user, UacsCommon.CreatePassportUser());
                    HijackUtilites.RecoverAccount(user);

                    CheckForWarning(true);
                    CheckForError(false);
                }
            }
        }

        [TestGroup, Description("Validates Hijack Error events are logged when all three events occur")]
        public class Trifecta : TestNode
        {
            // Note: Recover passport is always the event that will occur first.  If it 
            // happens after the gamertag and/or passport change, no event is logged.

            [TestCase, TestCasePriority(0), Description("Recover account, change gamertag then switch passport on trusted console - no event")]
            public class RecoverGamertagPassportTrusted : ComboTestBase
            {
                public override void Run()
                {
                    StartEventMonitor();

                    // recover account on trusted console
                    HijackUtilites.RecoverAccount(user);

                    // move past waiting period so we can hijack
                    HijackUtilites.FastForwardTimeForUser(user.UserPuid, new TimeSpan(HijackSettings.MaxWaitIntervalHours, 0, 0));
                    HijackUtilites.ChangeGamertag(user, "X" + RandomEx.GlobalRandGen.GenerateRandomNameString(14));
                    HijackUtilites.SwitchPassport(user, UacsCommon.CreatePassportUser());

                    CheckForWarning(false);
                    CheckForError(false);
                }
            }

            [TestCase, TestCasePriority(0), Description("Recover account, change gamertag and switch passport on untrusted console - event")]
            public class RecoverGamertagPassportUntrusted : ComboTestBase
            {
                public override void Run()
                {
                    StartEventMonitor();

                    // Move onto untrusted machine
                    HijackUtilites.SwitchMachines(user);
                    HijackUtilites.RecoverAccount(user);

                    // move past waiting period so we can hijack
                    HijackUtilites.FastForwardTimeForUser(user.UserPuid, new TimeSpan(HijackSettings.MaxWaitIntervalHours, 0, 0));
                    HijackUtilites.ChangeGamertag(user, "X" + RandomEx.GlobalRandGen.GenerateRandomNameString(14));
                    HijackUtilites.SwitchPassport(user, UacsCommon.CreatePassportUser());

                    CheckForWarning(true);
                    CheckForError(true);
                }
            }


            [TestCase, TestCasePriority(0), Description("Recover account, switch passport then change gamertag on trusted console - no event")]
            public class RecoverPassportGamertagTrusted : ComboTestBase
            {
                public override void Run()
                {
                    StartEventMonitor();

                    // recover account on trusted console
                    HijackUtilites.RecoverAccount(user);

                    // should not have to move past waiting period
                    HijackUtilites.SwitchPassport(user, UacsCommon.CreatePassportUser());
                    HijackUtilites.ChangeGamertag(user, "X"+RandomEx.GlobalRandGen.GenerateRandomNameString(14));

                    CheckForWarning(false);
                    CheckForError(false);
                }
            }

            [TestCase, TestCasePriority(0), Description("Recover account, switch passport then change gamertag on untrusted console - event")]
            public class RecoverPassportGamertagUntrusted : ComboTestBase
            {
                public override void Run()
                {
                    StartEventMonitor();

                    // Move onto untrusted machine
                    HijackUtilites.SwitchMachines(user);
                    HijackUtilites.RecoverAccount(user);

                    // move past waiting period so we can hijack
                    HijackUtilites.FastForwardTimeForUser(user.UserPuid, new TimeSpan(HijackSettings.MaxWaitIntervalHours, 0, 0));
                    HijackUtilites.SwitchPassport(user, UacsCommon.CreatePassportUser());
                    HijackUtilites.ChangeGamertag(user, "X" + RandomEx.GlobalRandGen.GenerateRandomNameString(14));

                    CheckForWarning(true);
                    CheckForError(true);
                }
            }

            [TestCase, TestCasePriority(1), Description("Recover account, change gamertag, recover again then switch passport on trusted console - no event")]
            public class RecoverGamertagTrustedRecoverPassportTrusted : ComboTestBase
            {
                public override void Run()
                {
                    StartEventMonitor();

                    HijackUtilites.RecoverAccount(user);

                    // should not need to move past waiting period
                    HijackUtilites.ChangeGamertag(user, "X" + RandomEx.GlobalRandGen.GenerateRandomNameString(14));
                    HijackUtilites.RecoverAccount(user);
                    HijackUtilites.SwitchPassport(user, UacsCommon.CreatePassportUser());

                    CheckForWarning(false);
                    CheckForError(false);
                }
            }

            [TestCase, TestCasePriority(1), Description("Recover account, change gamertag on trusted console, recover again then switch passport on untrusted console - warning event")]
            public class RecoverGamertagTrustedRecoverPassportUntrusted : ComboTestBase
            {
                public override void Run()
                {
                    StartEventMonitor();

                    HijackUtilites.RecoverAccount(user);
                    HijackUtilites.ChangeGamertag(user, "X" + RandomEx.GlobalRandGen.GenerateRandomNameString(14));

                    HijackUtilites.SwitchMachines(user);

                    // move past waiting period so we can hijack
                    HijackUtilites.FastForwardTimeForUser(user.UserPuid, new TimeSpan(HijackSettings.MaxWaitIntervalHours, 0, 0));
                    HijackUtilites.RecoverAccount(user);
                    HijackUtilites.SwitchPassport(user, UacsCommon.CreatePassportUser());

                    CheckForWarning(true);
                    CheckForError(false);
                }
            }

            [TestCase, TestCasePriority(1), Description("Recover account, change gamertag on untrusted console, then recover again and switch passport on trusted console - warning event")]
            public class RecoverGamertagUntrustedRecoverPassportTrusted : ComboTestBase
            {
                public override void Run()
                {
                    StartEventMonitor();
                    
                    // save current machine id so we can go back to it later
                    ulong machinePuid = HijackUtilites.SwitchMachines(user);
                    HijackUtilites.RecoverAccount(user);

                    HijackUtilites.FastForwardTimeForUser(user.UserPuid, new TimeSpan(HijackSettings.MaxWaitIntervalHours, 0, 0));
                    HijackUtilites.ChangeGamertag(user, "X" + RandomEx.GlobalRandGen.GenerateRandomNameString(14));

                    // switch back to original untrusted machine
                    HijackUtilites.SwitchMachines(user, machinePuid);
                    HijackUtilites.RecoverAccount(user);
                    HijackUtilites.SwitchPassport(user, UacsCommon.CreatePassportUser());

                    CheckForWarning(true);
                    CheckForError(false);
                }
            }

            [TestCase, TestCasePriority(1), Description("Recover account, switch passport on untrusted machine, then recover again and change gamertag on same untrusted machine - event")]
            public class RecoverPassportUntrustedRecoverGamertagUntrusted : ComboTestBase
            {
                public override void Run()
                {
                    StartEventMonitor();

                    // get ourselves onto a new untrusted machine
                    HijackUtilites.SwitchMachines(user);                   
                    HijackUtilites.RecoverAccount(user);

                    // move past the waiting period so we can hijack
                    HijackUtilites.FastForwardTimeForUser(user.UserPuid, new TimeSpan(HijackSettings.MaxWaitIntervalHours, 0, 0));
                    HijackUtilites.SwitchPassport(user, UacsCommon.CreatePassportUser());

                    // recover again, on the same untrusted machine
                    HijackUtilites.RecoverAccount(user);
                    HijackUtilites.ChangeGamertag(user, "X" + RandomEx.GlobalRandGen.GenerateRandomNameString(14));

                    CheckForWarning(true);
                    CheckForError(true);
                }
            }

            [TestCase, TestCasePriority(1), Description("Recover account, switch passport on untrusted machine, then recover again and change gamertag on different untrusted machine - warning and error event")]
            public class RecoverPassportUntrustedRecoverGamertagUntrusted_MultiMachine : ComboTestBase
            {
                public override void Run()
                {
                    StartEventMonitor();

                    // get ourselves onto two untrusted machines
                    HijackUtilites.SwitchMachines(user);
                    HijackUtilites.RecoverAccount(user);
                    ulong machinePuid = HijackUtilites.SwitchMachines(user);
                    HijackUtilites.RecoverAccount(user);

                    // move past the waiting period so we can hijack (this will move both machines)
                    HijackUtilites.FastForwardTimeForUser(user.UserPuid, new TimeSpan(HijackSettings.MaxWaitIntervalHours, 0, 0));
                    HijackUtilites.SwitchPassport(user, UacsCommon.CreatePassportUser());

                    
                    // switch back to the first machine and change the gamertag
                    HijackUtilites.SwitchMachines(user, machinePuid);
                    HijackUtilites.RecoverAccount(user);
                    HijackUtilites.ChangeGamertag(user, "X" + RandomEx.GlobalRandGen.GenerateRandomNameString(14));

                    CheckForWarning(true);
                    CheckForError(true);
                }
            }

            [TestCase, TestCasePriority(1), Description("Recover account, switch passport on untrusted machine, then change gamertag on different untrusted machine (no second recovery) - warning and error event")]
            public class RecoverPassportUntrustedGamertagUntrusted_MultiMachine : ComboTestBase
            {
                public override void Run()
                {
                    StartEventMonitor();

                    // get ourselves onto two untrusted machines
                    HijackUtilites.SwitchMachines(user);
                    HijackUtilites.RecoverAccount(user);
                    ulong machinePuid = HijackUtilites.SwitchMachines(user);
                    HijackUtilites.RecoverAccount(user);

                    // move past the waiting period so we can hijack (this will move both machines)
                    HijackUtilites.FastForwardTimeForUser(user.UserPuid, new TimeSpan(HijackSettings.MaxWaitIntervalHours, 0, 0));
                    HijackUtilites.SwitchPassport(user, UacsCommon.CreatePassportUser());

                    // change gamertag on other machine (no recovery, like moving profile with MU).
                    HijackUtilites.SwitchMachines(user, machinePuid);
                    HijackUtilites.ChangeGamertag(user, "X" + RandomEx.GlobalRandGen.GenerateRandomNameString(14));

                    CheckForWarning(true);
                    CheckForError(true);
                }
            }
        }
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\StfTests\HijackAccountTests\obj\i386\_generated.cs ===
[assembly:System.Runtime.InteropServices.ComVisible(false)]
[assembly:System.Reflection.AssemblyVersion("12.4.56.0")]
[assembly:System.Reflection.AssemblyProduct("DEPOT")]
[assembly:System.Reflection.AssemblyCopyright("")]
[assembly:System.Reflection.AssemblyCompany("")]
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\StfTests\HijackAccountTests\Billing.cs ===
using System;

using ServerTestFramework;
using ServerTestFramework.Utilities;
using ServerTestFramework.Database;
using ServerTestFramework.LiveService;
using ServerTestFramework.LiveService.FakeSG;
using ServerTestFramework.LiveService.UserAccount;
using ServerTestFramework.LiveService.Billing;

using HijackAccountTests.Database;

using xonline.core.history;

namespace HijackAccountTests
{
    [TestGroup, AsyncGroup(1)]
    public class Billing: TestNode
    {
        [TestGroup, Owner("LukeL"), EnvRequirement("billing"), TestFrequency("Regression")]
        [AsyncGroup(11, 11), AsyncThreadCount(5), AsyncThreadDelay(1000)]
        public class PurchaseGamertag: TestNode
        {
            public static XRLXeOfferPurchaseGamertag CallPurchaseGamertag(ulong machine, ulong user, string newTag)
            {
                Global.RO.Debug(string.Format("Calling XRLXeOfferPurchaseGamertag for user 0x{0:X} on machine 0x{1:X}...", user, machine));
                XRLXeOfferPurchaseGamertag xrl=new XRLXeOfferPurchaseGamertag();
                xrl.UserPuid=user;
                xrl.MachinePuid=machine;
                xrl.Gamertag=newTag;

                bool result=xrl.Execute();
                if (!result || xrl.XErr!=0)
                {
                    throw new System.Exception("XRLXeOfferPurchaseGamertag call failed: "+xrl.ErrorStatusMessage);
                }

                return xrl;
            }

            public static void CallPurchaseGamertag_ExpectFail(ulong machine, ulong user, string newTag, uint expectedXErr)
            {
                Global.RO.Debug(string.Format("Calling XRLXeOfferPurchaseGamertag for user 0x{0:X} on machine 0x{1:X}...", user, machine));
                XRLXeOfferPurchaseGamertag xrl=new XRLXeOfferPurchaseGamertag();
                xrl.UserPuid=user;
                xrl.MachinePuid=machine;
                xrl.Gamertag=newTag;

                bool result=xrl.Execute();
                if (result || xrl.XErr==0)
                {
                    throw new UnexpectedTestResultException("XRLXeOfferPurchaseGamertag unexpectedly succeeded.");
                }

                ValueCheck.Test("Expected XErr", expectedXErr, xrl.XErr);
                Global.RO.Debug("Got expected XErr: "+xrl.XErr);
            }

            public static void ClearUserHistory(ulong user)
            {
                UodbWS.ExecuteSQLNonQuery("delete from t_user_gamertag_history where bi_user_puid="+(long)user, user);
                UodbWS.ExecuteSQLNonQuery("delete from t_user_machine_history where bi_user_puid="+(long)user, user);
            }

            public static void ClearMachineHistory(ulong machine)
            {
                UodbWS.ExecuteSQLNonQuery("delete from t_machine_gamertag_history where bi_machine_puid="+(long)machine, machine);
                UodbWS.ExecuteSQLNonQuery("delete from t_user_machine_history where bi_machine_puid="+(long)machine, machine);
            }

            [TestCase, Description("No records created by presence yet (perhaps xbos was updated zdt while the service was running)"), TestCasePriority(1)]
            public void NoHistoryForUser()
            {
                //create user and machine, and give the user some points
                XeUser user=new XeUser(false);
                ulong userPuid=user.Create();
                if (userPuid==0)
                {
                    throw new System.Exception("Uacs XeUser.Create() failed.");
                }

                MachineEditor machine=MachineEditor.CreateNew(MachineType.Xbox360);

                Global.RO.Debug("Adding points...");
                user.AddPoints_500();
                user.AddPoints_500();

                //wipe out any previous history; would be better to just take it into account with expectations but this is simpler
                ClearUserHistory(userPuid);
                ClearMachineHistory(machine.Id);

                //call api
                string oldTag=user.Gamertag;
                string newTag="X"+RandomEx.GlobalRandGen.GenerateRandomNameString(14);
                CallPurchaseGamertag(machine.Id, user.UserPuid, newTag);

                //verify the user and machine history was recorded
                for (int lookupPass=0; lookupPass<2; ++lookupPass)
                {
                    bool isUserPass=(lookupPass==1);

                    for (int detailsPass=0; detailsPass<2; ++detailsPass)
                    {
                        bool details=(detailsPass==1);

                        Global.RO.Debug("Checking "+(isUserPass?"user "+string.Format("0x{0:X}",userPuid):"machine "+string.Format("0x{0:X}",machine.Id))+" gamertag history "+(details?"with":"without")+" details...");

                        GamertagHistoryGetResponse reply;
                        if (isUserPass)
                        {
                            reply=HijackUtilites.GetUserGamertagHistory(userPuid, details);
                        }
                        else
                        {
                            reply=HijackUtilites.GetMachineGamertagHistory(machine.Id, details);
                        }

                        ValueCheck.Test("Unique", 1, reply.Unique);
                        ValueCheck.Test("Total", 1, reply.Total);
                        ValueCheck.Test("First", System.DateTime.UtcNow, reply.First.Value, new System.TimeSpan(0, 3, 0));
                        ValueCheck.Test("Last", System.DateTime.UtcNow, reply.Last.Value, new System.TimeSpan(0, 3, 0));

                        ValueCheck.Test("Details exist", details, reply.Details!=null && reply.Details.Count>0);
                        if (details)
                        {
                            ValueCheck.Test("Details count", 1, reply.Details.Count);

                            ValueCheck.Test("Details[0].UserPuid", user.UserPuid, reply.Details[0].UserPuid);
                            ValueCheck.Test("Details[0].MachinePuid", machine.Id, reply.Details[0].MachinePuid);
                            HijackUtilites.VerifyIpIsUs(reply.Details[0].IpAddress);
                            ValueCheck.Test("Details[0].Timestamp", reply.First.Value, reply.Details[0].Timestamp, new System.TimeSpan(0, 0, 1));
                            ValueCheck.Test("Details[0].Hr", HResult.S_OK, reply.Details[0].Hr);
                            ValueCheck.Test("Details[0].Reason", HistoryReason.PurchaseGamertag, reply.Details[0].Reason);
                            ValueCheck.Test("Details[0].OldGamertag", oldTag, reply.Details[0].OldGamertag);
                            ValueCheck.Test("Details[0].NewGamertag", newTag, reply.Details[0].NewGamertag);
                        }
                    }
                }
            }

            [TestCase, Description("User only has an entry on the current machine and no other"), TestCasePriority(0)]
            public void OneMachine_Immediate()
            {
                //create user and machine, and give the user some points
                MachineEditor machine=MachineEditor.CreateNew(MachineType.Xbox360);
                XeUser user=new XeUser(false, machine.Id);
                ulong userPuid=user.Create();
                if (userPuid==0)
                {
                    throw new System.Exception("Uacs XeUser.Create() failed.");
                }

                Global.RO.Debug("Adding points...");
                user.AddPoints_500();
                user.AddPoints_500();

                //wipe out any previous history; would be better to just take it into account with expectations but this is simpler
                ClearUserHistory(userPuid);
                ClearMachineHistory(machine.Id);

                //first time we've seen on presence
                Presence.SignInPresence(userPuid, user.Gamertag, machine.Id, CSGInfo.ClientType.Xenon);

                //call api
                string oldTag=user.Gamertag;
                string newTag="X"+RandomEx.GlobalRandGen.GenerateRandomNameString(14);
                CallPurchaseGamertag(machine.Id, user.UserPuid, newTag);

                //verify the user and machine history was recorded
                for (int lookupPass=0; lookupPass<2; ++lookupPass)
                {
                    bool isUserPass=(lookupPass==1);

                    for (int detailsPass=0; detailsPass<2; ++detailsPass)
                    {
                        bool details=(detailsPass==1);

                        Global.RO.Debug("Checking "+(isUserPass?"user "+string.Format("0x{0:X}",userPuid):"machine "+string.Format("0x{0:X}",machine.Id))+" gamertag history "+(details?"with":"without")+" details...");

                        GamertagHistoryGetResponse reply;
                        if (isUserPass)
                        {
                            reply=HijackUtilites.GetUserGamertagHistory(userPuid, details);
                        }
                        else
                        {
                            reply=HijackUtilites.GetMachineGamertagHistory(machine.Id, details);
                        }

                        ValueCheck.Test("Unique", 1, reply.Unique);
                        ValueCheck.Test("Total", 1, reply.Total);
                        ValueCheck.Test("First", System.DateTime.UtcNow, reply.First.Value, new System.TimeSpan(0, 3, 0));
                        ValueCheck.Test("Last", System.DateTime.UtcNow, reply.Last.Value, new System.TimeSpan(0, 3, 0));

                        ValueCheck.Test("Details exist", details, reply.Details!=null && reply.Details.Count>0);
                        if (details)
                        {
                            ValueCheck.Test("Details count", 1, reply.Details.Count);

                            ValueCheck.Test("Details[0].UserPuid", user.UserPuid, reply.Details[0].UserPuid);
                            ValueCheck.Test("Details[0].MachinePuid", machine.Id, reply.Details[0].MachinePuid);
                            HijackUtilites.VerifyIpIsUs(reply.Details[0].IpAddress);
                            ValueCheck.Test("Details[0].Timestamp", reply.First.Value, reply.Details[0].Timestamp, new System.TimeSpan(0, 0, 1));
                            ValueCheck.Test("Details[0].Hr", HResult.S_OK, reply.Details[0].Hr);
                            ValueCheck.Test("Details[0].Reason", HistoryReason.PurchaseGamertag, reply.Details[0].Reason);
                            ValueCheck.Test("Details[0].OldGamertag", oldTag, reply.Details[0].OldGamertag);
                            ValueCheck.Test("Details[0].NewGamertag", newTag, reply.Details[0].NewGamertag);
                        }
                    }
                }
            }

            [TestCase, Description("User only has an entry on one machine, then gets another on a different machine.  We should block the call on both machines."), TestCasePriority(2)]
            public void TwoMachines_Immediate()
            {
                //create user and machine, and give the user some points
                MachineEditor machine0=MachineEditor.CreateNew(MachineType.Xbox360);
                MachineEditor machine1=MachineEditor.CreateNew(MachineType.Xbox360);
                XeUser user=new XeUser(false);
                ulong userPuid=user.Create();
                if (userPuid==0)
                {
                    throw new System.Exception("Uacs XeUser.Create() failed.");
                }

                Global.RO.Debug("Adding points...");
                user.AddPoints_500();
                user.AddPoints_500();

                //wipe out any previous history; would be better to just take it into account with expectations but this is simpler
                ClearUserHistory(userPuid);
                ClearMachineHistory(machine0.Id);
                ClearMachineHistory(machine1.Id);

                //first time we've seen on presence
                Presence.SignInPresence(userPuid, user.Gamertag, machine0.Id, CSGInfo.ClientType.Xenon);
                Presence.SignInPresence(userPuid, user.Gamertag, machine1.Id, CSGInfo.ClientType.Xenon);

                //call api
                string oldTag=user.Gamertag;
                string newTag="X"+RandomEx.GlobalRandGen.GenerateRandomNameString(14);
                CallPurchaseGamertag_ExpectFail(machine0.Id, user.UserPuid, newTag, HResult.XONLINE_E_OFFERING_PURCHASE_BLOCKED);
                CallPurchaseGamertag_ExpectFail(machine1.Id, user.UserPuid, newTag, HResult.XONLINE_E_OFFERING_PURCHASE_BLOCKED);
            }

            [TestCase, Description("User has old an entry on one machine, then gets a new one on different machine.  We should block the call new machine and not the old"), TestCasePriority(2)]
            public void TwoMachines_OneOld()
            {
                //create user and machine, and give the user some points
                MachineEditor machine0=MachineEditor.CreateNew(MachineType.Xbox360);
                MachineEditor machine1=MachineEditor.CreateNew(MachineType.Xbox360);
                XeUser user=new XeUser(false);
                ulong userPuid=user.Create();
                if (userPuid==0)
                {
                    throw new System.Exception("Uacs XeUser.Create() failed.");
                }

                Global.RO.Debug("Adding points...");
                user.AddPoints_500();
                user.AddPoints_500();

                //wipe out any previous history; would be better to just take it into account with expectations but this is simpler
                ClearUserHistory(userPuid);
                ClearMachineHistory(machine0.Id);
                ClearMachineHistory(machine1.Id);

                //log into presence at different times
                Presence.SignInPresence(userPuid, user.Gamertag, machine0.Id, CSGInfo.ClientType.Xenon);
                HijackUtilites.FastForwardTimeForUser(userPuid, new TimeSpan(200, 0, 0, 0));
                Presence.SignInPresence(userPuid, user.Gamertag, machine0.Id, CSGInfo.ClientType.Xenon);
                Presence.SignInPresence(userPuid, user.Gamertag, machine1.Id, CSGInfo.ClientType.Xenon);

                //call api on the new machine, it should be blocked
                string oldTag=user.Gamertag;
                string newTag="X"+RandomEx.GlobalRandGen.GenerateRandomNameString(14);
                CallPurchaseGamertag_ExpectFail(machine1.Id, user.UserPuid, newTag, HResult.XONLINE_E_OFFERING_PURCHASE_BLOCKED);

                //go forward a day
                HijackUtilites.FastForwardTimeForUser(userPuid, new TimeSpan(1, 0, 0, 0));

                //call api on the old machine, it should work
                CallPurchaseGamertag(machine0.Id, user.UserPuid, newTag);

                // Verify the user gamertag history is right
                // There should be exactly 1 record,  for machine0.Id
                for (int detailsPass = 0; detailsPass < 2; ++detailsPass)
                {
                    bool details = (detailsPass == 1);

                    Global.RO.Debug("Checking user " + string.Format("0x{0:X}", userPuid) + " gamertag history " + (details ? "with" : "without") + " details...");

                    GamertagHistoryGetResponse reply = HijackUtilites.GetUserGamertagHistory(userPuid, details);

                    ValueCheck.Test("Unique", 1, reply.Unique);
                    ValueCheck.Test("Total", 1, reply.Total);
                    ValueCheck.Test("First", System.DateTime.UtcNow, reply.First.Value, TimeSpan.FromMinutes(5));
                    ValueCheck.Test("Last", System.DateTime.UtcNow, reply.Last.Value, TimeSpan.FromMinutes(5));

                    ValueCheck.Test("Details exist", details, reply.Details != null && reply.Details.Count > 0);
                    if (details)
                    {
                        ValueCheck.Test("Details count", 1, reply.Details.Count);

                        ValueCheck.Test("Details[0].UserPuid", user.UserPuid, reply.Details[0].UserPuid);
                        ValueCheck.Test("Details[0].MachinePuid", machine0.Id, reply.Details[0].MachinePuid);
                        HijackUtilites.VerifyIpIsUs(reply.Details[0].IpAddress);
                        ValueCheck.Test("Details[0].Timestamp", reply.Last.Value, reply.Details[0].Timestamp, TimeSpan.FromSeconds(1));
                        ValueCheck.Test("Details[0].Hr", HResult.S_OK, reply.Details[0].Hr);
                        ValueCheck.Test("Details[0].Reason", HistoryReason.PurchaseGamertag, reply.Details[0].Reason);
                        ValueCheck.Test("Details[0].OldGamertag", oldTag, reply.Details[0].OldGamertag);
                        ValueCheck.Test("Details[0].NewGamertag", newTag, reply.Details[0].NewGamertag);
                    }
                }

                // Verify the machine history is right,  machine id 1 had the failed creation
                // There should be no gamertag record for machine id 1

                for (int detailsPass = 0; detailsPass < 2; ++detailsPass)
                {
                    bool details = (detailsPass == 1);

                    Global.RO.Debug("Checking machine " + string.Format("0x{0:X}", machine1.Id) + " gamertag history " + (details ? "with" : "without") + " details...");

                    GamertagHistoryGetResponse reply = HijackUtilites.GetMachineGamertagHistory(machine1.Id, details);
                    ValueCheck.Test("Unique", 0, reply.Unique);
                    ValueCheck.Test("Total", 0, reply.Total);

                    // there won't be any details
                }

                for (int detailsPass = 0; detailsPass < 2; ++detailsPass)
                {
                    bool details = (detailsPass == 1);

                    Global.RO.Debug("Checking machine " + string.Format("0x{0:X}", machine0.Id) + " gamertag history " + (details ? "with" : "without") + " details...");

                    GamertagHistoryGetResponse reply = HijackUtilites.GetMachineGamertagHistory(machine0.Id, details);

                    ValueCheck.Test("Unique", 1, reply.Unique);
                    ValueCheck.Test("Total", 1, reply.Total);
                    ValueCheck.Test("First", System.DateTime.UtcNow, reply.First.Value, TimeSpan.FromMinutes(3));
                    ValueCheck.Test("Last", System.DateTime.UtcNow, reply.Last.Value, TimeSpan.FromMinutes(3));

                    ValueCheck.Test("Details exist", details, reply.Details != null && reply.Details.Count > 0);
                    if (details)
                    {
                        ValueCheck.Test("Details count", 1, reply.Details.Count);

                        ValueCheck.Test("Details[0].UserPuid", user.UserPuid, reply.Details[0].UserPuid);
                        ValueCheck.Test("Details[0].MachinePuid", machine0.Id, reply.Details[0].MachinePuid);
                        HijackUtilites.VerifyIpIsUs(reply.Details[0].IpAddress);
                        ValueCheck.Test("Details[0].Timestamp", reply.First.Value, reply.Details[0].Timestamp, TimeSpan.FromSeconds(1));
                        ValueCheck.Test("Details[0].Hr", HResult.S_OK, reply.Details[0].Hr);
                        ValueCheck.Test("Details[0].Reason", HistoryReason.PurchaseGamertag, reply.Details[0].Reason);
                        ValueCheck.Test("Details[0].OldGamertag", oldTag, reply.Details[0].OldGamertag);
                        ValueCheck.Test("Details[0].NewGamertag", newTag, reply.Details[0].NewGamertag);
                    }
                }
            }

            [TestCase, Description("Two users sign onto the same machine on different days.  The older one should work, the newer one should be blocked"), TestCasePriority(2)]
            public void TwoUsers_SameMachine_DifferentDays()
            {
                //create user and machine, and give the user some points
                MachineEditor machine=MachineEditor.CreateNew(MachineType.Xbox360);
                MachineEditor machineUnrelated=MachineEditor.CreateNew(MachineType.Xbox360);
                XeUser user0=new XeUser(false);
                ulong userPuid0=user0.Create();
                if (userPuid0==0)
                {
                    throw new System.Exception("Uacs XeUser.Create() failed.");
                }
                XeUser user1=new XeUser(false);
                ulong userPuid1=user1.Create();
                if (userPuid1==0)
                {
                    throw new System.Exception("Uacs XeUser.Create() failed.");
                }

                Global.RO.Debug("Adding points...");
                user0.AddPoints_500();
                user0.AddPoints_500();
                user1.AddPoints_500();
                user1.AddPoints_500();

                //wipe out any previous history; would be better to just take it into account with expectations but this is simpler
                ClearUserHistory(userPuid0);
                ClearUserHistory(userPuid1);
                ClearMachineHistory(machine.Id);
                ClearMachineHistory(machineUnrelated.Id);

                //log into presence at different times
                Presence.SignInPresence(userPuid0, user0.Gamertag, machine.Id, CSGInfo.ClientType.Xenon);
                Presence.SignInPresence(userPuid1, user1.Gamertag, machineUnrelated.Id, CSGInfo.ClientType.Xenon);
                HijackUtilites.FastForwardTimeForUser(userPuid0, new TimeSpan(200, 0, 0, 0));
                HijackUtilites.FastForwardTimeForUser(userPuid1, new TimeSpan(200, 0, 0, 0));
                Presence.SignInPresence(userPuid1, user1.Gamertag, machine.Id, CSGInfo.ClientType.Xenon);

                //user1 should be blocked on the machine
                string oldTag1=user1.Gamertag;
                string newTag="X"+RandomEx.GlobalRandGen.GenerateRandomNameString(14);
                CallPurchaseGamertag_ExpectFail(machine.Id, user1.UserPuid, newTag, HResult.XONLINE_E_OFFERING_PURCHASE_BLOCKED);

                //user0 should work on the machine
                string oldTag0=user0.Gamertag;
                CallPurchaseGamertag(machine.Id, user0.UserPuid, newTag);

                // Verify machine gamertag history
                // There should only be one result, for User0's gamertag change
                for (int detailsPass=0; detailsPass<2; ++detailsPass)
                {
                    bool details=(detailsPass==1);

                    Global.RO.Debug("Checking machine "+string.Format("0x{0:X}",machine.Id)+" gamertag history "+(details?"with":"without")+" details...");

                    GamertagHistoryGetResponse reply=HijackUtilites.GetMachineGamertagHistory(machine.Id, details);

                    ValueCheck.Test("Unique", 1, reply.Unique);
                    ValueCheck.Test("Total", 1, reply.Total);
                    ValueCheck.Test("First", System.DateTime.UtcNow, reply.First.Value, TimeSpan.FromMinutes(3));
                    ValueCheck.Test("Last", System.DateTime.UtcNow, reply.Last.Value, TimeSpan.FromMinutes(3));

                    ValueCheck.Test("Details exist", details, reply.Details!=null && reply.Details.Count>0);
                    if (details)
                    {
                        ValueCheck.Test("Details count", 1, reply.Details.Count);

                        ValueCheck.Test("Details[0].UserPuid", user0.UserPuid, reply.Details[0].UserPuid);
                        ValueCheck.Test("Details[0].MachinePuid", machine.Id, reply.Details[0].MachinePuid);
                        HijackUtilites.VerifyIpIsUs(reply.Details[0].IpAddress);
                        ValueCheck.Test("Details[0].Timestamp", reply.Last.Value, reply.Details[0].Timestamp, TimeSpan.FromSeconds(1));
                        ValueCheck.Test("Details[0].Hr", HResult.S_OK, reply.Details[0].Hr);
                        ValueCheck.Test("Details[0].Reason", HistoryReason.PurchaseGamertag, reply.Details[0].Reason);
                        ValueCheck.Test("Details[0].OldGamertag", oldTag0, reply.Details[0].OldGamertag);
                        ValueCheck.Test("Details[0].NewGamertag", newTag, reply.Details[0].NewGamertag);
                    }
                }
            }
        };
    };
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\StfTests\HijackAccountTests\HijackUtilites.cs ===
using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;

using HijackAccountTests.Database;

using ServerTestFramework;
using ServerTestFramework.Database;
using ServerTestFramework.LiveService;
using ServerTestFramework.LiveService.Auth;
using ServerTestFramework.LiveService.FakeSG;
using ServerTestFramework.LiveService.UserAccount;
using ServerTestFramework.Utilities;

using xonline.common.config;
using xonline.common.protocol;

namespace HijackAccountTests
{
    public enum OperationType
    {
        Unknown = 0,
        RecoverAccount,
        SwitchPassport,
        ChangeGamertag,
    }

    public enum TargetType
    {
        None = 0,
        User,
        Machine,
    }

    public class HijackTestBase : TestNode
    {
        /// <summary>
        /// A centralized tolerance value that can be used when validating times for various operations
        /// </summary>
        public static TimeSpan DefaultTolerance = TimeSpan.FromSeconds(15);

        protected MachineEditor client;
        //protected IXblMachine client;
        protected XeUser user;

        /// <summary>
        /// Default pre-run for the hijack test cases that just 
        /// creates a regular gold user and xenon client
        /// </summary>
        public override void PreRun()
        {
            user = HijackUtilites.CreateUser(false, true, true);

            // get some presence on a machine to establish tenure
            client = HijackUtilites.CreateClient();
            user.MachinePuid = client.Id;
            HijackUtilites.UpdateUserMachineHistory(user);

            // all users get a year of history on their account creation machine
            HijackUtilites.FastForwardTimeForUser(user.UserPuid, new TimeSpan(365, 0, 0, 0));
        }
    }

    public class HijackUtilites
    {
        /// <summary>
        /// Creates a Gold 360 user and waits on XCache to pick it up
        /// </summary>
        /// <returns>A Xenon User</returns>
        public static XeUser CreateUser()
        {
            return CreateUser(true, false, true);
        }

        /// <summary>
        /// Create a Gold 360 user and optionally waits on XCache to pick it up
        /// </summary>
        /// <param name="waitForXCache">Indicates if we should wait for XCache to pickup the user</param>
        /// <returns>A Xenon User</returns>
        public static XeUser CreateUser(bool waitForXCache)
        {
            return CreateUser(waitForXCache, false, true);
        }

        /// <summary>
        /// Create a 360 user and optionally waits on XCache to pick it up
        /// </summary>
        /// <param name="waitForXCache">If true, wait 31 seconds for XCache to pickup user</param>
        /// <param name="createPassport">Indicates if a passport should be created for the user</param>
        /// <param name="createAsGold">Indicates if a gold user account should be created</param>
        /// <returns>A Xenon User</returns>
        public static XeUser CreateUser(bool waitForXCache, bool createPassport, bool createAsGold)
        {
            XeUser user = AuthContext.MakeNewBillingUser(createPassport, createAsGold, true);
            if (waitForXCache)
            {
                Global.RO.Info("Waiting 31 seconds for new user to be picked up by XCache...");
                System.Threading.Thread.Sleep(31 * 1000);
            }

            return user;
        }

        public static MachineEditor CreateClient()
        {
            return MachineEditor.CreateNew(MachineType.Xbox360);
        }

        /*
        public static IXblMachine CreateClient3()
        {
            return MachineFactory.CreateMachine();
        }
         */

        /// <summary>
        /// Creates a Xenon Xmacs Client and signs it in
        /// </summary>
        /// <returns>A Xenon Xmacs Client</returns>
        public static XmacsClient CreateClient2()
        {
            return CreateClient(AuthContext.ClientTypes.Xenon, true);
        }

        /// <summary>
        /// Creates and Xmacs Client and signs it in
        /// </summary>
        /// <param name="clientType">The type of client you want to create</param>
        /// <returns>An Xmacs client of the specified type</returns>
        public static XmacsClient CreateClient(AuthContext.ClientTypes clientType)
        {
            return CreateClient(clientType, true);
        }

        /// <summary>
        /// Creates and Xmacs Client and optionally signs it in
        /// </summary>
        /// <param name="clientType">The type of client you want to create</param>
        /// <param name="signInXmacs">If true, the client will be signed into Xmacs</param>
        /// <returns>An Xmacs client of the specified type</returns>
        public static XmacsClient CreateClient(AuthContext.ClientTypes clientType, bool signInXmacs)
        {
            XmacsClient client = new XmacsClient(new AuthContext(clientType));
            if (signInXmacs)
            {
                client.SignInXmacs();
            }

            return client;
        }

        public static void SwitchPassport(XeUser user, UacsCommon.PassportUser newPassport)
        {
            HijackUtilites.UpdateUserMachineHistory(user);
            SwitchPassport(user, newPassport, true);
        }

        public static void SwitchPassport(XeUser user, UacsCommon.PassportUser newPassport, Boolean overwriteUser)
        {
            XRLXeSwitchUserPassport switchPassportRequest = new XRLXeSwitchUserPassport();

            switchPassportRequest.UserPuid = user.UserPuid;
            switchPassportRequest.MachinePuid = user.MachinePuid;

            switchPassportRequest.OldUserPassportMemberName = user.PassportMemberName;
            switchPassportRequest.SignedOldUserPassportPuid = user.PassportSessionToken;
            switchPassportRequest.NewUserPassportMemberName = newPassport.MemberName;
            switchPassportRequest.SignedNewUserPassportPuid = newPassport.SessionToken;

            if (!switchPassportRequest.Execute())
            {
                throw new xonline.common.service.XRLExceptionWithoutEvent(switchPassportRequest.XErr, switchPassportRequest.GetDumpString());
            }

            if (overwriteUser)
            {
                // Switch passport was successful, so let's save the new data
                user.PassportMemberName = newPassport.MemberName;
                user.PassportSessionToken = newPassport.SessionToken;
                user.PassportUserPuid = newPassport.PassportPuid;
                user.PassportPassword = newPassport.Password;
            }
        }

        public static XeRecoverAccountResponse RecoverAccount(XeUser user)
        {
            HijackUtilites.UpdateUserMachineHistory(user);
            return RecoverAccount(user.MachinePuid, user.PassportSessionToken);
        }

        public static XeRecoverAccountResponse RecoverAccount(UInt64 machinePuid, Byte[] passportSessionToken)
        {
            XRLXeRecoverAccount req = new XRLXeRecoverAccount();

            req.Request.machinePuid = machinePuid;
            req.Request.signedPuid = passportSessionToken;

            if (!req.Execute())
            {
                throw new UnexpectedTestResultException("Unable to recover account: " + req.GetDumpString());
            }

            return req.Response;
        }

        public static ulong SwitchMachines(XeUser user)
        {
            MachineEditor client = HijackUtilites.CreateClient();
            return SwitchMachines(user, client.Id);
        }

        public static ulong SwitchMachines(XeUser user, ulong machinePuid)
        {
            ulong oldMachinePuid = user.MachinePuid;
            user.MachinePuid = machinePuid;

            // establish history for the user on the machine
            HijackUtilites.UpdateUserMachineHistory(user);
            return oldMachinePuid;
        }
        
        public static void ChangeGamertag(XeUser user, string newTag)
        {
            HijackUtilites.UpdateUserMachineHistory(user);

            user.AddPoints_500();
            user.AddPoints_500();
            Billing.PurchaseGamertag.CallPurchaseGamertag(user.MachinePuid, user.UserPuid, newTag);
            
            // if there was no exception then fix up the gamertag in the user
            user.Gamertag = newTag;
        }

        public static RecoveryHistoryGetResponse GetUserRecoveryHistory(ulong puid, bool details)
        {
            return GetUserRecoveryHistory(puid, null, details);
        }

        public static RecoveryHistoryGetResponse GetUserRecoveryHistory(ulong puid, DateTime? since, bool details)
        {
            UserRecoveryHistoryGetSproc s = new UserRecoveryHistoryGetSproc(puid, since, details);

            if (!s.Execute())
            {
                throw new UnexpectedTestResultException("Unable to get UserRecovery history: " + s.GetDumpString());
            }

            return s.Response;
        }

        public static RecoveryHistoryGetResponse GetMachineRecoveryHistory(ulong puid, bool details)
        {
            return GetMachineRecoveryHistory(puid, null, details);
        }

        public static RecoveryHistoryGetResponse GetMachineRecoveryHistory(ulong puid, DateTime? since, bool details)
        {
            MachineRecoveryHistoryGetSproc s = new MachineRecoveryHistoryGetSproc(puid, since, details);

            if (!s.Execute())
            {
                throw new UnexpectedTestResultException("Unable to get MachineRecovery history: " + s.GetDumpString());
            }

            return s.Response;
        }

        public static PassportHistoryGetResponse GetUserPassportHistory(ulong puid, bool details)
        {
            return GetUserPassportHistory(puid, null, details);
        }

        public static PassportHistoryGetResponse GetUserPassportHistory(ulong puid, DateTime? since, bool details)
        {
            UserPassportHistoryGetSproc s = new UserPassportHistoryGetSproc(puid, since, details);

            if (!s.Execute())
            {
                throw new UnexpectedTestResultException("Unable to get UserPassport history: " + s.GetDumpString());
            }

            return s.Response;
        }

        public static PassportHistoryGetResponse GetMachinePassportHistory(ulong puid, bool details)
        {
            return GetMachinePassportHistory(puid, null, details);
        }

        public static PassportHistoryGetResponse GetMachinePassportHistory(ulong puid, DateTime? since, bool details)
        {
            MachinePassportHistoryGetSproc s = new MachinePassportHistoryGetSproc(puid, since, details);

            if (!s.Execute())
            {
                throw new UnexpectedTestResultException("Unable to get MachinePassport history: " + s.GetDumpString());
            }

            return s.Response;
        }

        public static GamertagHistoryGetResponse GetUserGamertagHistory(ulong puid, bool details)
        {
            return GetUserGamertagHistory(puid, null, details);
        }

        public static GamertagHistoryGetResponse GetUserGamertagHistory(ulong puid, DateTime? since, bool details)
        {
            UserGamertagHistoryGetSproc s = new UserGamertagHistoryGetSproc(puid, since, details);

            if (!s.Execute())
            {
                throw new UnexpectedTestResultException("Unable to get UserGamertag history: " + s.GetDumpString());
            }

            return s.Response;
        }

        public static GamertagHistoryGetResponse GetMachineGamertagHistory(ulong puid, bool details)
        {
            return GetMachineGamertagHistory(puid, null, details);
        }

        public static GamertagHistoryGetResponse GetMachineGamertagHistory(ulong puid, DateTime? since, bool details)
        {
            MachineGamertagHistoryGetSproc s = new MachineGamertagHistoryGetSproc(puid, since, details);

            if (!s.Execute())
            {
                throw new UnexpectedTestResultException("Unable to get MachineGamertag history: " + s.GetDumpString());
            }

            return s.Response;
        }

        public static UserHistoryGetResponse GetUserHistory(ulong puid, bool details)
        {
            return GetUserHistory(puid, null, details);
        }

        public static UserHistoryGetResponse GetUserHistory(ulong puid, DateTime? since, bool details)
        {
            UserHistoryGetSproc s = new UserHistoryGetSproc(puid, since, details);

            if (!s.Execute())
            {
                throw new UnexpectedTestResultException("Unable to get User history: " + s.GetDumpString());
            }

            return s.Response;
        }

        public static MachineHistoryGetResponse GetMachineHistory(ulong machinePuid, bool details)
        {
            return GetMachineHistory(machinePuid, null, details);
        }

        public static MachineHistoryGetResponse GetMachineHistory(ulong machinePuid, DateTime? since, bool details)
        {
            MachineHistoryGetSproc s = new MachineHistoryGetSproc(machinePuid, null, since, details);

            if (!s.Execute())
            {
                throw new UnexpectedTestResultException("Unable to get Machine history: " + s.GetDumpString());
            }

            return s.Response;
        }

        public static UserMachineHistoryGetResponse GetUserMachineHistory(ulong userPuid, Boolean details)
        {
            UserMachineHistoryGetSproc s = new UserMachineHistoryGetSproc(userPuid, details);

            if (!s.Execute())
            {
                throw new UnexpectedTestResultException("Unable to get UserMachine history: " + s.GetDumpString());
            }

            return s.Response;
        }

        public static void VerifyOperation(OperationHistoryDetails operation, UInt64 userPuid, UInt64 machinePuid, DateTime timestamp)
        {
            VerifyOperation(operation, userPuid, machinePuid, timestamp, TimeSpan.FromSeconds(15));
        }

        public static void VerifyOperation(OperationHistoryDetails operation, UInt64 userPuid, UInt64 machinePuid, DateTime timestamp, TimeSpan toleance)
        {
            ValueCheck.Test("Operation Result", HResult.S_OK, operation.Hr);
            ValueCheck.Test("UserPuid", userPuid, operation.UserPuid);
            ValueCheck.Test("MachinePuid", machinePuid, operation.MachinePuid);
            ValueCheck.Test("Timestamp", timestamp, operation.Timestamp, toleance);

            Global.RO.Success("Vaidated {0}.  User: {1:X16}, Machine: {2:X16} - Timestamp: {3}", operation.GetType().Name, userPuid, machinePuid, timestamp);
        }

        public static AccountHijackSproc GetHistorySproc(TargetType target, OperationType operation, ulong puid, DateTime? since, bool details)
        {
            AccountHijackSproc sproc = null;

            switch (target)
            {
                case TargetType.User:
                    switch (operation)
                    {
                        case OperationType.RecoverAccount:
                            sproc = new UserRecoveryHistoryGetSproc(puid, since, details);
                            break;
                        case OperationType.SwitchPassport:
                            sproc = new UserPassportHistoryGetSproc(puid, since, details);
                            break;
                        case OperationType.ChangeGamertag:
                            sproc = new UserGamertagHistoryGetSproc(puid, since, details);
                            break;
                        case OperationType.Unknown:
                            sproc = new UserHistoryGetSproc(puid, since, details);
                            break;
                    }
                    break;
                case TargetType.Machine:
                    switch (operation)
                    {
                        case OperationType.RecoverAccount:
                            sproc = new MachineRecoveryHistoryGetSproc(puid, since, details);
                            break;
                        case OperationType.SwitchPassport:
                            sproc = new MachinePassportHistoryGetSproc(puid, since, details);
                            break;
                        case OperationType.ChangeGamertag:
                            sproc = new MachineGamertagHistoryGetSproc(puid, since, details);
                            break;
                        case OperationType.Unknown:
                            sproc = new MachineHistoryGetSproc(puid, null, since, details);
                            break;
                    }
                    break;
            }

            if (sproc == null)
            {
                throw new InvalidOperationException(String.Format("Invalid Target and/or Operation. Target: {0} Operation: {1}", target, operation));
            }

            return sproc;
        }

        public static String GenerateGetHistorySprocName(TargetType target, OperationType operation)
        {
            StringBuilder sb = new StringBuilder("p_xuacs_");

            if(target == TargetType.None)
            {
                sb.Append("user_machine_");
            }
            else
            {
                sb.Append(target.ToString().ToLower());
            }

            switch (operation)
            {
                case OperationType.RecoverAccount:
                    sb.Append("recovery_");
                    break;
                case OperationType.SwitchPassport:
                    sb.Append("passport_");
                    break;
                case OperationType.ChangeGamertag:
                    sb.Append("gamertag_");
                    break;
            }

            sb.Append("history_get");

            return sb.ToString();
        }

        /// <summary>
        /// Subtracts a number of hours from all the date fields in the hijacking-related 
        /// tables for a user, so it seems like that many hours have passed
        /// </summary>
        /// <param name="userPuid">The user to update</param>
        /// <param name="days">The number of days to change the time by</param>
        public static void FastForwardTimeForUser(UInt64 puid, int days)
        {
            if (days==0)
                return;

            Global.RO.Debug("Advancing user 0x{0:X} {1} days through time.", puid, days);

            //put together a list of all tables and all columns that need updated.  the first string column is the name of the key column for the where clause.  the rest are columns to be updated
            List<KeyValuePair<string, string[]>> tableColumns=new List<KeyValuePair<string, string[]>>();

            string []xxx={"user", "machine"};
            string []yyy={"recovery", "passport", "gamertag"};
            foreach (string x in xxx)
            {
                foreach (string y in yyy)
                {
                    List<string> columns=new List<string>();
                    columns.Add("bi_"+x+"_puid"); //key for where

                    columns.Add("dt_timestamp"); //common to all

                    string tableName="t_"+x+"_"+y+"_history";
                    tableColumns.Add(new KeyValuePair<string, string[]>(tableName, columns.ToArray()));
                }
            }

            tableColumns.Add(new KeyValuePair<string, string[]>("t_user_machine_history", new string[]{"bi_user_puid", "d_first_seen", "d_last_seen"}));

            //now do all the updates
            foreach (KeyValuePair<string, string[]> tc in tableColumns)
            {
                string key=tc.Value[0];
                string table=tc.Key;
                string query="update "+table+" set ";
                bool isFirstSet=true;
                for (int i=1; i<tc.Value.Length; ++i)
                {
                    if (isFirstSet)
                    {
                        isFirstSet=false;
                    }
                    else
                    {
                        query+=", ";
                    }

                    string col=tc.Value[i];
                    query+=col+"=dateadd(day,"+-days+","+col+")";
                }

                query+=" where "+key+"="+(long)puid;

                UodbWS.ExecuteSQLNonQuery(query, puid);
            }
        }

        /// <summary>
        /// Subtracts a length of time from all the date fields in the hijacking-related 
        /// tables for a user, so it seems like that many days have passed
        /// </summary>
        /// <param name="userPuid">The user to update</param>
        /// <param name="timespan">The length of time to change the date by</param>
        public static void FastForwardTimeForUser(UInt64 puid, TimeSpan timespan)
        {
            FastForwardTimeForUser(puid, (int) timespan.TotalDays);
        }

        public static void UpdateUserMachineHistory(XeUser user)
        {
            Global.RO.Debug("Updating history for user " + user.UserPuid + " on machine " + user.MachinePuid);
            PresUpdateUserMachineHistorySproc s = new PresUpdateUserMachineHistorySproc(user.UserPuid, user.MachinePuid);

            if (! s.Execute()) {
                throw new UnexpectedTestResultException("Unable to update user user_machine history: " + s.GetDumpString());
            }
        }

        public static ulong PassportGetPuidFromMemberName(string name)
        {
            XRLPayload<XePassportGetPuidFromMemberNameRequest, XePassportGetPuidFromMemberNameResponse> xrl=new XRLPayload<XePassportGetPuidFromMemberNameRequest, XePassportGetPuidFromMemberNameResponse>();

            xrl.Request.memberName=name;
            xrl.Request.memberNameLength=(ushort)name.Length;

            bool result=xrl.Execute(Global.XEnv.GetVirtualInterface(xonline.common.config.VirtualInterface.xuacs_int));
            if (!result || xrl.XErr!=0)
            {
                throw new System.Exception("XRLPassportGetPuidFromMemberName failed: "+xrl.ErrorStatusMessage);
            }

            return xrl.Response.passportPuid;
        }

        public static MachineType GetMachineType(CSGInfo.ClientType sgClientType)
        {
            if (sgClientType==CSGInfo.ClientType.Xbox) return MachineType.Xbox1;
            else if (sgClientType==CSGInfo.ClientType.Xenon) return MachineType.Xbox360;
            else if (sgClientType==CSGInfo.ClientType.XenonBackCompat) return MachineType.Xbox360;
            else if (sgClientType==CSGInfo.ClientType.PC) return MachineType.PC;
            else
                throw new System.Exception("Unknown sg client type");
        }

        public static uint GetClientTitle(CSGInfo.ClientType sgClientType)
        {
            if (sgClientType==CSGInfo.ClientType.Xbox) return 0x4D530064;
            else if (sgClientType==CSGInfo.ClientType.Xenon) return 0xfffe07d1;
            else if (sgClientType==CSGInfo.ClientType.XenonBackCompat) return 0x4D530064;
            else if (sgClientType==CSGInfo.ClientType.PC) return 0x585207d1;
            else
                throw new System.Exception("Unknown sg client type");
        }

        public static System.DateTime TruncateToDay(System.DateTime datetime)
        {
            System.DateTime newDT=new System.DateTime(datetime.Year, datetime.Month, datetime.Day);
            return newDT;
        }

        public static void VerifyIpIsUs(System.Net.IPAddress testIP)
        {
            if (testIP==null)
            {
                throw new UnexpectedTestResultException("IP was null");
            }

            System.Net.IPHostEntry usIPs=System.Net.Dns.GetHostEntry(System.Net.Dns.GetHostName());
            foreach (System.Net.IPAddress ip in usIPs.AddressList)
            {
                if (ip.ToString()==testIP.ToString())
                {
                    return;
                }
            }

            throw new UnexpectedTestResultException("IP "+testIP+" is not the IP of the local machine.");
        }

        public static void VerifyIpIsNotUs(System.Net.IPAddress testIP)
        {
            if (testIP == null)
            {
                return;
            }

            System.Net.IPHostEntry usIPs = System.Net.Dns.GetHostEntry(System.Net.Dns.GetHostName());
            foreach (System.Net.IPAddress ip in usIPs.AddressList)
            {
                if (ip.ToString() == testIP.ToString())
                {
                    throw new UnexpectedTestResultException("IP " + testIP + " is the IP of the local machine.");
                }
            }
            return;
        }

        public static uint GetMyIPUint()
        {
            System.Net.IPHostEntry usIPs=System.Net.Dns.GetHostEntry(System.Net.Dns.GetHostName());
            foreach (System.Net.IPAddress ip in usIPs.AddressList)
            {
                if (ip.AddressFamily==System.Net.Sockets.AddressFamily.InterNetwork)
                {
                    return System.BitConverter.ToUInt32(ip.GetAddressBytes(), 0);
                }
            }

            throw new System.Exception("Error getting local IP");
        }

        public static System.Net.IPAddress GetMyIP()
        {
            System.Net.IPHostEntry usIPs = System.Net.Dns.GetHostEntry(System.Net.Dns.GetHostName());
            foreach (System.Net.IPAddress ip in usIPs.AddressList)
            {
                if (ip.AddressFamily == System.Net.Sockets.AddressFamily.InterNetwork)
                {
                    return ip;
                }
            }

            throw new System.Exception("Error getting local IP");
        }

    }

    public class HijackSettings
    {
        public static Int32 UserGamertagChangeThreshold = Config.GetIntSetting(Setting.xuacs_userGamertagThreshold);
        public static Int32 UserGamertagChangeIntervalDays = Config.GetIntSetting(Setting.xuacs_userGamertagIntervalDays);
        public static Int32 UserPassportChangeThreshold = Config.GetIntSetting(Setting.xuacs_userPassportThreshold);
        public static Int32 UserPassportChangeIntervalDays = Config.GetIntSetting(Setting.xuacs_userPassportIntervalDays);
        public static Int32 UserRecoveryChangeThreshold = Config.GetIntSetting(Setting.xuacs_userRecoveryThreshold);
        public static Int32 UserRecoveryChangeIntervalDays = Config.GetIntSetting(Setting.xuacs_userRecoveryIntervalDays);
        public static Int32 MachineGamertagChangeThreshold = Config.GetIntSetting(Setting.xuacs_machineGamertagThreshold);
        public static Int32 MachineGamertagChangeIntervalDays = Config.GetIntSetting(Setting.xuacs_machineGamertagIntervalDays);
        public static Int32 MachinePassportChangeThreshold = Config.GetIntSetting(Setting.xuacs_machinePassportThreshold);
        public static Int32 MachinePassportChangeIntervalDays = Config.GetIntSetting(Setting.xuacs_machinePassportIntervalDays);
        public static Int32 MachineRecoveryChangeThreshold = Config.GetIntSetting(Setting.xuacs_machineRecoveryThreshold);
        public static Int32 MachineRecoveryChangeIntervalDays = Config.GetIntSetting(Setting.xuacs_machineRecoveryIntervalDays);

        public static Int32 HijackingIntervalHours = Config.GetIntSetting(Setting.xuacs_hijackingIntervalHours);

        public static Int32 PassportChangeWaitIntervalHours = Config.GetIntSetting(Setting.xuacs_passportChangeWaitIntervalHours);
        public static Int32 GamertagChangeWaitIntervalHours = Config.GetIntSetting(Setting.xuacs_gamertagChangeWaitIntervalHours);
        public static Int32 MaxWaitIntervalHours = Math.Max(PassportChangeWaitIntervalHours, GamertagChangeWaitIntervalHours);

        public static Int32 PresenceWelcomeToXboxLiveMessage = Config.GetIntSetting(Setting.presence_WelcomeToXboxLiveMessage);
        public static Int32 PresenceWelcomeToNewConsoleMessage = Config.GetIntSetting(Setting.presence_WelcomeToNewConsoleMessage);

        static HijackSettings()
        {
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\StfTests\HijackAccountTests\objd\i386\_generated.cs ===
[assembly:System.Runtime.InteropServices.ComVisible(false)]
[assembly:System.Reflection.AssemblyVersion("12.4.56.0")]
[assembly:System.Reflection.AssemblyProduct("DEPOT")]
[assembly:System.Reflection.AssemblyCopyright("")]
[assembly:System.Reflection.AssemblyCompany("")]
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\StfTests\HijackAccountTests\History.cs ===
using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Net;
using Microsoft.Webstore.WstClient;
using System.Data;
using xonline.core.history;
using xonline.common.sql.webstore;

namespace HijackAccountTests.Database
{
    public class OperationHistoryDetails
    {
        public UInt64 UserPuid;
        public UInt64? MachinePuid;
        public IPAddress IpAddress;
        public DateTime Timestamp;
        public UInt32 Hr;
        public HistoryReason Reason;

        public OperationHistoryDetails() { }

        public OperationHistoryDetails(ulong userPuid, ulong machinePuid, String ipAddress, DateTime timestamp, UInt32 hr, HistoryReason reason)
        {
            this.UserPuid = userPuid;
            this.MachinePuid = machinePuid;
            this.IpAddress = IPAddress.Parse(ipAddress);
            this.Timestamp = timestamp;
            this.Hr = hr;
            this.Reason = reason;
        }

        public OperationHistoryDetails(WstDataReader reader)
        {
            Read(reader);
        }

        public virtual void Read(WstDataReader reader)
        {
            UserPuid = reader.GetUInt64("bi_user_puid");
            MachinePuid = (UInt64?)reader.GetValueOrDefault<Int64?>("bi_machine_puid", null);
            IpAddress = reader.GetIpAddress("vc_ip_address");
            Timestamp = reader.GetDateTime("dt_timestamp");
            Hr = reader.GetUInt32("i_hr");
            Reason = (HistoryReason)WSClient.GetByte(reader, "ti_reason");
        }

        public override string ToString()
        {
            return String.Format("User: 0x{0:X16}, Machine: 0x{1:X16}, IP: {2} ({3} - {4}; Result: {5})", UserPuid, MachinePuid, IpAddress, Timestamp, Reason, Hr);
        }
    }

    public class RecoveryHistoryDetails : OperationHistoryDetails
    {
        public UInt64 UserPassportPuid;

        public RecoveryHistoryDetails() { }

        public RecoveryHistoryDetails(ulong userPuid, ulong machinePuid, String ipAddress, DateTime timestamp, UInt32 hr, HistoryReason reason, UInt64 userPassportPuid)
            : base(userPuid, machinePuid, ipAddress, timestamp, hr, reason)
        {
            this.UserPassportPuid = userPassportPuid;
        }

        public RecoveryHistoryDetails(WstDataReader reader) : base(reader) { }

        public override void Read(WstDataReader reader)
        {
            this.UserPassportPuid = reader.GetUInt64("bi_user_passport_puid");
            base.Read(reader);
        }

        public override string ToString()
        {
            return String.Format("PassportPuid: 0x{0:X16}, {1}", UserPassportPuid, base.ToString());
        }
    }

    public class PassportHistoryDetails : OperationHistoryDetails
    {
        public UInt64? OldPassportPuid;
        public UInt64? NewPassportPuid;

        public PassportHistoryDetails() { }

        public PassportHistoryDetails(ulong userPuid, ulong machinePuid, String ipAddress, DateTime timestamp, UInt32 hr, HistoryReason reason, UInt64 oldPassportPuid, UInt64 newPassportPuid)
            : base(userPuid, machinePuid, ipAddress, timestamp, hr, reason)
        {
            this.OldPassportPuid = oldPassportPuid;
            this.NewPassportPuid = newPassportPuid;
        }

        public PassportHistoryDetails(WstDataReader reader) : base(reader) { }

        public override void Read(WstDataReader reader)
        {
            // SQL doesn't handled UInt's so we have to handle this ourselves
            this.OldPassportPuid = (UInt64?)reader.GetValueOrDefault<Int64?>("bi_old_passport_puid", null);
            this.NewPassportPuid = (UInt64?)reader.GetValueOrDefault<Int64?>("bi_new_passport_puid", null);
            base.Read(reader);
        }

        public override string ToString()
        {
            return String.Format("OldPuid: 0x{0:X16}, NewPuid: 0x{1:X16}, {2}", OldPassportPuid ?? 0, NewPassportPuid ?? 0, base.ToString());
        }
    }

    public class GamertagHistoryDetails : OperationHistoryDetails
    {
        public String OldGamertag;
        public String NewGamertag;

        public GamertagHistoryDetails() { }

        public GamertagHistoryDetails(ulong userPuid, ulong machinePuid, String ipAddress, DateTime timestamp, UInt32 hr, HistoryReason reason, String oldGamertag, String newGamertag)
            : base(userPuid, machinePuid, ipAddress, timestamp, hr, reason)
        {
            this.OldGamertag = oldGamertag;
            this.NewGamertag = newGamertag;
        }

        public GamertagHistoryDetails(WstDataReader reader) : base(reader) { }

        public override void Read(WstDataReader reader)
        {
            this.OldGamertag = reader.GetValueOrDefault<String>("vc_old_gamertag", null);
            this.NewGamertag = reader.GetValueOrDefault<String>("vc_new_gamertag", null);
            base.Read(reader);
        }

        public override string ToString()
        {
            return String.Format("OldTag: 0x{0:X16}, NewTag: 0x{1:X16}, {2}", OldGamertag ?? "-", NewGamertag ?? "-", base.ToString());
        }
    }

    public class OperationHistoryGetResponse<DetailType> : AccountHijackSprocResponse
        where DetailType: OperationHistoryDetails, new()
    {
        public int Unique = -1;
        public int Total = -1;
        public DateTime? First = null;
        public DateTime? Last = null;
        public List<DetailType> Details = null;

        /// <summary>
        /// Get details for a specific operation in this history
        /// </summary>
        /// <param name="index">The index of the operation details to retrieve</param>
        /// <returns>The history details for the operation specified by the index</returns>
        public DetailType this[Int32 index]
        {
            get { return Details[index]; }
        }

        public override void Read(WstDataReader reader)
        {
            // Check if there's data
            if (!reader.Read())
            {
                throw new InvalidOperationException("Unable to read any data from DataReader");
            }
            
            this.Details = new List<DetailType>();

            this.Unique = reader.GetValueOrDefault("i_unique", 0);
            this.Total = reader.GetValueOrDefault("i_total", 0);
            this.First = reader.GetValueOrDefault<DateTime?>("dt_first", null);
            this.Last = reader.GetValueOrDefault<DateTime?>("dt_last", null);
        }

        public override void ReadDetail(WstDataReader reader)
        {
            DetailType detail = new DetailType();
            detail.Read(reader);
            this.Details.Add(detail);
        }

        public override string ToString()
        {
            StringBuilder sb = new StringBuilder();
            sb.AppendFormat("{0}; Count: {1}({2}) - {3}\n", this.GetType().Name, Total, Unique, Last);

            foreach(DetailType detail in Details)
            {
                sb.AppendLine("\t" + detail.ToString());
            }

            return sb.ToString();
        }
    }

    public class RecoveryHistoryGetResponse : OperationHistoryGetResponse<RecoveryHistoryDetails> { }

    public class PassportHistoryGetResponse : OperationHistoryGetResponse<PassportHistoryDetails> { }

    public class GamertagHistoryGetResponse : OperationHistoryGetResponse<GamertagHistoryDetails> { }

    public class MachineHistoryGetResponse : AccountHijackSprocResponse
    {
        public Boolean ShouldReadDetails = false;
        public RecoveryHistoryGetResponse Recovery = new RecoveryHistoryGetResponse();
        public PassportHistoryGetResponse Passport = new PassportHistoryGetResponse();
        public GamertagHistoryGetResponse Gamertag = new GamertagHistoryGetResponse();

        public override void Read(WstDataReader reader)
        {
            Recovery.Read(reader);

            if (ShouldReadDetails)
            {
                // Move onto the next result set
                reader.NextResult();

                // If there are no result sets, than this read will just return false
                while (reader.Read())
                {
                    Recovery.ReadDetail(reader);
                }
            }

            // Move to the passport result set
            reader.NextResult();

            Passport.Read(reader);

            if (ShouldReadDetails)
            {
                // Move onto the next result set
                reader.NextResult();

                // If there are no result sets, than this read will just return false
                while (reader.Read())
                {
                    Passport.ReadDetail(reader);
                }
            }

            // Move to the gamertag result set
            reader.NextResult();

            Gamertag.Read(reader);

            if (ShouldReadDetails)
            {
                // Move onto the next result set
                reader.NextResult();

                // If there are no result sets, than this read will just return false
                while (reader.Read())
                {
                    Gamertag.ReadDetail(reader);
                }
            }
        }

        public override string ToString()
        {
            return String.Format("Recovery: {0}Passport: {1}Gamertag:{2}", Recovery.ToString(), Passport.ToString(), Gamertag.ToString());
        }
    }

    public class UserHistoryGetResponse : MachineHistoryGetResponse
    {
        private UserMachineHistoryGetResponse UserMachine = new UserMachineHistoryGetResponse();

        public override void Read(WstDataReader reader)
        {
            // The UserMachineHistory stuff comes first

            // Read has already been called once on the reader. We're assuming 
            // that if a HR of 0 was returned and there's at least one result
            // set, then all the result sets will be there.  So no more checking
            UserMachine.Read(reader);

            if (ShouldReadDetails)
            {
                // Move onto the next result set
                reader.NextResult();
                
                // If there are no result sets, than this read will just return false
                while (reader.Read())
                {
                    UserMachine.ReadDetail(reader);
                }
            }

            // Move it onto the next result set as expected by the base class
            reader.NextResult();

            base.Read(reader);
        }

        public override string ToString()
        {
            return String.Format("UserMachine: {0}{1}", UserMachine.ToString(), base.ToString());
        }
    }

    public class UserMachineHistoryDetails
    {
        public UInt64 UserPuid;
        public UInt64 MachinePuid;
        public DateTime FirstSeen;
        public DateTime LastSeen;
        public Int32 DaysSeen;
        public IPAddress IpAddress;

        public UserMachineHistoryDetails(UInt64 userPuid, UInt64 machinePuid, DateTime firstSeen, DateTime lastSeen, Int32 daysSeen, string ipAddress)
        {
            this.UserPuid = userPuid;
            this.MachinePuid = machinePuid;
            this.FirstSeen = firstSeen;
            this.LastSeen = lastSeen;
            this.DaysSeen = daysSeen;
            this.IpAddress = IPAddress.Parse(ipAddress);
        }

        public UserMachineHistoryDetails(WstDataReader reader)
        {
            Read(reader);
        }

        public void Read(WstDataReader reader)
        {
            this.UserPuid = reader.GetUInt64("bi_user_puid");
            this.MachinePuid = reader.GetUInt64("bi_machine_puid");
            this.FirstSeen = reader.GetDateTime("d_first_seen");
            this.LastSeen = reader.GetDateTime("d_last_seen");
            this.DaysSeen = reader.GetInt32("i_days_seen");
            this.IpAddress = reader.GetIpAddress("vc_ip_address"); 
        }

        public override string ToString()
        {
            return String.Format("User: 0x{0:X16}, Machine: 0x{1:X16}, Seen {2} Days: {3} - {4} LastIp: {5}", UserPuid, MachinePuid, DaysSeen, FirstSeen, LastSeen, IpAddress);
        }
    }

    public class UserMachineHistoryGetResponse : AccountHijackSprocResponse
    {
        public Int32 Unique = 0;
        public DateTime? FirstSeen = null;
        public DateTime? LastSeen = null;
        public Int32 DaysSeen = 0;
        public List<UserMachineHistoryDetails> Details = null;

        public UserMachineHistoryDetails this[Int32 index]
        {
            get { return Details[index]; }
        }

        public override void Read(WstDataReader reader)
        {
            // Check if there's data
            if (!reader.Read())
            {
                throw new InvalidOperationException("Unable to read any data from DataReader");
            }

            this.Details = new List<UserMachineHistoryDetails>();

            this.Unique = reader.GetValueOrDefault("i_unique", 0);
            this.FirstSeen = reader.GetValueOrDefault<DateTime?>("d_first_seen", null);
            this.LastSeen = reader.GetValueOrDefault<DateTime?>("d_last_seen", null);
            this.DaysSeen = reader.GetValueOrDefault("i_days_seen", 0);
        }

        public override void ReadDetail(WstDataReader reader)
        {
            this.Details.Add(new UserMachineHistoryDetails(reader));
        }
    }

    public class OperationHistoryGetSproc<ResponseType> : AccountHijackSproc<ResponseType>
        where ResponseType : AccountHijackSprocResponse, new()
    {
        [SprocParam("bi_user_puid", DbType.Int64)]
        protected Int64? userPuid;
        [SprocParam("bi_machine_puid", DbType.Int64)]
        protected Int64? machinePuid;
        [SprocParam("dt_since", DbType.DateTime)]
        protected DateTime? since;
        [SprocParam("b_details", DbType.Boolean)]
        protected Boolean details;

        public UInt64? UserPuid
        {
            get { return (UInt64?)userPuid; }
            set { userPuid = (Int64?)value; }
        }

        public UInt64? MachinePuid
        {
            get { return (UInt64?)machinePuid; }
            set { machinePuid = (Int64?)value; }
        }

        public DateTime? Since
        {
            get { return since; }
            set { since = value; }
        }

        public Boolean Details
        {
            get { return details; }
            set { details = value; }
        }

        public OperationHistoryGetSproc(UInt64? userPuid, UInt64? machinePuid, DateTime? since, Boolean details)
        {
            this.UserPuid = userPuid;
            this.MachinePuid = machinePuid;
            this.Since = since;
            this.Details = details;
        }

        protected override void ReadResponse(WstDataReader reader)
        {
            base.ReadResponse(reader);

            // If we want details, then we get the next result set
            if (Details && reader.NextResult())
            {
                while (reader.Read())
                {
                    Response.ReadDetail(reader);
                }
            }
        }
    }

    public class MachineGamertagHistoryGetSproc : OperationHistoryGetSproc<GamertagHistoryGetResponse>
    {
        public override String SprocName
        {
            get { return "p_xuacs_machine_gamertag_history_get"; }
        }

        public MachineGamertagHistoryGetSproc(UInt64 machinePuid, Boolean details)
            : base(null, machinePuid, null, details) { }

        public MachineGamertagHistoryGetSproc(UInt64 machinePuid, DateTime? since, Boolean details)
            : base(null, machinePuid, since, details) { }

        protected override void PreExecute(WSClient client)
        {
            client.SetHashVal(MachinePuid.Value);
        }
    }

    public class MachinePassportHistoryGetSproc : OperationHistoryGetSproc<PassportHistoryGetResponse>
    {
        public override String SprocName
        {
            get { return "p_xuacs_machine_passport_history_get"; }
        }

        public MachinePassportHistoryGetSproc(UInt64 machinePuid, Boolean details)
            : base(null, machinePuid, null, details) { }

        public MachinePassportHistoryGetSproc(UInt64 machinePuid, DateTime? since, Boolean details)
            : base(null, machinePuid, since, details) { }

        protected override void PreExecute(WSClient client)
        {
            client.SetHashVal(MachinePuid.Value);
        }
    }

    public class MachineRecoveryHistoryGetSproc : OperationHistoryGetSproc<RecoveryHistoryGetResponse>
    {
        public override String SprocName
        {
            get { return "p_xuacs_machine_recovery_history_get"; }
        }

        public MachineRecoveryHistoryGetSproc(UInt64 machinePuid, Boolean details)
            : base(null, machinePuid, null, details) { }

        public MachineRecoveryHistoryGetSproc(UInt64 machinePuid, DateTime? since, Boolean details)
            : base(null, machinePuid, since, details) { }

        protected override void PreExecute(WSClient client)
        {
            client.SetHashVal(MachinePuid.Value);
        }
    }

    public class UserGamertagHistoryGetSproc : OperationHistoryGetSproc<GamertagHistoryGetResponse>
    {
        public override String SprocName
        {
            get { return "p_xuacs_user_gamertag_history_get"; }
        }

        public UserGamertagHistoryGetSproc(UInt64 userPuid, Boolean details)
            : base(userPuid, null, null, details) { }

        public UserGamertagHistoryGetSproc(UInt64 userPuid, DateTime? since, Boolean details)
            : base(userPuid, null, since, details) { }

        protected override void PreExecute(WSClient client)
        {
            client.SetHashVal(UserPuid.Value);
        }
    }

    public class UserPassportHistoryGetSproc : OperationHistoryGetSproc<PassportHistoryGetResponse>
    {
        public override String SprocName
        {
            get { return "p_xuacs_user_passport_history_get"; }
        }

        public UserPassportHistoryGetSproc(UInt64 userPuid, Boolean details)
            : base(userPuid, null, null, details) { }

        public UserPassportHistoryGetSproc(UInt64 userPuid, DateTime? since, Boolean details)
            : base(userPuid, null, since, details) { }

        protected override void PreExecute(WSClient client)
        {
            client.SetHashVal(UserPuid.Value);
        }
    }

    public class UserRecoveryHistoryGetSproc : OperationHistoryGetSproc<RecoveryHistoryGetResponse>
    {
        public override String SprocName
        {
            get { return "p_xuacs_user_recovery_history_get"; }
        }

        public UserRecoveryHistoryGetSproc(UInt64 userPuid, Boolean details)
            : base(userPuid, null, null, details) { }

        public UserRecoveryHistoryGetSproc(UInt64 userPuid, DateTime? since, Boolean details)
            : base(userPuid, null, since, details) { }

        protected override void PreExecute(WSClient client)
        {
            client.SetHashVal(UserPuid.Value);
        }
    }

    public class UserMachineHistoryGetSproc : OperationHistoryGetSproc<UserMachineHistoryGetResponse>
    {
        public override string SprocName
        {
            get { return "p_xuacs_user_machine_history_get"; }
        }

        public UserMachineHistoryGetSproc(UInt64 userPuid)
            : base(userPuid, null, null, false) { }

        public UserMachineHistoryGetSproc(UInt64 userPuid, Boolean details)
            : base(userPuid, null, null, details) { }

        public UserMachineHistoryGetSproc(UInt64 userPuid, UInt64? machinePuid, DateTime? since, Boolean details)
            : base(userPuid, machinePuid, since, details) { }

        protected override void PreExecute(WSClient client)
        {
            client.SetHashVal(UserPuid.Value);
        }
    }

    public class AggregateHistoryGetSproc<ResponseType> : OperationHistoryGetSproc<ResponseType>
        where ResponseType : MachineHistoryGetResponse, new()
    {
        public AggregateHistoryGetSproc(UInt64? userPuid, UInt64? machinePuid, Boolean details)
            : base(userPuid, machinePuid, null, details) { }

        public AggregateHistoryGetSproc(UInt64? userPuid, UInt64? machinePuid, DateTime? since, Boolean details)
            : base(userPuid, machinePuid, since, details) { }

        protected override void ReadResponse(WstDataReader reader)
        {
            Response.ShouldReadDetails = this.Details;

            base.ReadResponse(reader);
        }
    }

    public class MachineHistoryGetSproc : AggregateHistoryGetSproc<MachineHistoryGetResponse>
    {
        public override String SprocName
        {
            get { return "p_xuacs_machine_history_get"; }
        }

        public MachineHistoryGetSproc(UInt64 machinePuid, Boolean details)
            : base(null, machinePuid, null, details) { }

        public MachineHistoryGetSproc(UInt64 machinePuid, UInt64? userPuid, Boolean details)
            : base(userPuid, machinePuid, null, details) { }

        public MachineHistoryGetSproc(UInt64 machinePuid, UInt64? userPuid, DateTime? since, Boolean details)
            : base(userPuid, machinePuid, since, details) { }

        protected override void PreExecute(WSClient client)
        {
            client.SetHashVal(MachinePuid.Value);
        }
    }

    public class UserHistoryGetSproc : AggregateHistoryGetSproc<UserHistoryGetResponse>
    {
        public override String SprocName
        {
            get { return "p_xuacs_user_history_get"; }
        }

        public UserHistoryGetSproc(UInt64 userPuid, Boolean details)
            : base(userPuid, null, details) { }

        public UserHistoryGetSproc(UInt64 userPuid, DateTime? since, Boolean details)
            : base(userPuid, null, since, details) { }

        protected override void PreExecute(WSClient client)
        {
            client.SetHashVal(UserPuid.Value);
        }
    }

    public class OperationHistoryAddSproc : AccountHijackSproc
    {
        // Common/Index Parameters
        [SprocParam("bi_user_puid", DbType.Int64)]
        protected Int64? userPuid;
        [SprocParam("bi_machine_puid", DbType.Int64)]
        protected Int64? machinePuid;
        [SprocParam("vc_ip_address", DbType.String)]
        public IPAddress IpAddress;
        [SprocParam("dt_timestamp", DbType.DateTime)]
        public DateTime Timestamp;
        [SprocParam("i_hr", DbType.Int32)]
        public UInt32 HResult;
        [SprocParam("ti_reason", DbType.Byte)]
        public HistoryReason Reason;

        // Return the count since this date
        [SprocParam("dt_since", DbType.DateTime)]
        public DateTime? Since;

        /// <summary>
        /// SQL doesn't have uint's so this property marshals the user
        /// puid into an Int64 internally for use in the sproc request
        /// </summary>
        public UInt64? UserPuid
        {
            get { return (UInt64?)userPuid; }
            set { userPuid = (Int64?)value; }
        }

        /// <summary>
        /// SQL doesn't have uint's so this property marshals the machine
        /// puid into an Int64 internally for use in the sproc request
        /// </summary>
        public UInt64? MachinePuid
        {
            get { return (UInt64?)machinePuid; }
            set { machinePuid = (Int64?)value; }
        }

        private UInt32 operationCount;
        /// <summary>
        /// The value returned by the execution of the history add sproc.
        /// The number of operations of the given type that have occured 
        /// since the the date provided
        /// </summary>
        public UInt32 OperationCount
        {
            get { return operationCount; }
        }

        public OperationHistoryAddSproc(UInt64? userPuid, UInt64? machinePuid, String ipAddress, DateTime timestamp, UInt32 hr, HistoryReason reason)
        {
            this.UserPuid = userPuid;
            this.MachinePuid = machinePuid;
            if (String.IsNullOrEmpty(ipAddress))
            {
                this.IpAddress = null;
            }
            else
            {
                this.IpAddress = IPAddress.Parse(ipAddress);
            }
            this.Timestamp = timestamp;
            this.HResult = hr;
            this.Reason = reason;
        }

        protected override void ReadResponse(WstDataReader reader)
        {
            base.ReadResponse(reader);

            if (reader.Read())
            {
                operationCount = (UInt32)reader.GetInt32(0);
            }
        }
    }

    public class RecoveryHistoryAddSproc : OperationHistoryAddSproc
    {
        [SprocParam("bi_user_passport_puid", DbType.Int64)]
        protected Int64 userPassportPuid;

        public UInt64 UserPassportPuid
        {
            get { return (UInt64)userPassportPuid; }
            set { userPassportPuid = (Int64)value; }
        }

        public RecoveryHistoryAddSproc(UInt64? userPuid, UInt64? machinePuid, String ipAddress, DateTime timestamp, UInt32 hr, UInt64 userPassportPuid, HistoryReason reason)
            : base(userPuid, machinePuid, ipAddress, timestamp, hr, reason)
        {
            this.UserPassportPuid = userPassportPuid;
        }
    }

    public class UserRecoveryHistoryAddSproc : RecoveryHistoryAddSproc
    {
        public override string SprocName
        {
            get { return "p_xuacs_user_recovery_history_add"; }
        }

        public UserRecoveryHistoryAddSproc(UInt64? userPuid, UInt64? machinePuid, String ipAddress, DateTime timestamp, UInt32 hr, UInt64 userPassportPuid, HistoryReason reason)
            : base(userPuid, machinePuid, ipAddress, timestamp, hr, userPassportPuid, reason) { }

        protected override void PreExecute(WSClient client)
        {
            client.SetHashVal(UserPuid.Value);
        }
    }

    public class MachineRecoveryHistoryAddSproc : RecoveryHistoryAddSproc
    {
        public override string SprocName
        {
            get { return "p_xuacs_machine_recovery_history_add"; }
        }

        public MachineRecoveryHistoryAddSproc(UInt64? userPuid, UInt64? machinePuid, String ipAddress, DateTime timestamp, UInt32 hr, UInt64 userPassportPuid, HistoryReason reason)
            : base(userPuid, machinePuid, ipAddress, timestamp, hr, userPassportPuid, reason) { }

        protected override void PreExecute(WSClient client)
        {
            client.SetHashVal(MachinePuid.Value);
        }
    }

    public class PassportHistoryAddSproc : OperationHistoryAddSproc
    {
        [SprocParam("bi_old_passport_puid", DbType.Int64)]
        protected Int64? oldPassportPuid;
        [SprocParam("bi_new_passport_puid", DbType.Int64)]
        protected Int64? newPassportPuid;

        public UInt64? OldPassportPuid
        {
            get { return (UInt64?)oldPassportPuid; }
            set { oldPassportPuid = (Int64?)value; }
        }

        public UInt64? NewPassportPuid
        {
            get { return (UInt64?)newPassportPuid; }
            set { newPassportPuid = (Int64?)value; }
        }
        
        public PassportHistoryAddSproc(UInt64? userPuid, UInt64? machinePuid, String ipAddress, DateTime timestamp, UInt32 hr, UInt64? oldPassportPuid, UInt64? newPassportPuid, HistoryReason reason)
            : base(userPuid, machinePuid, ipAddress, timestamp, hr, reason)
        {
            this.OldPassportPuid = oldPassportPuid;
            this.NewPassportPuid = newPassportPuid;
        }
    }

    public class UserPassportHistoryAddSproc : PassportHistoryAddSproc
    {
        public override string SprocName
        {
            get { return "p_xuacs_user_passport_history_add"; }
        }

        public UserPassportHistoryAddSproc(UInt64? userPuid, UInt64? machinePuid, String ipAddress, DateTime timestamp, UInt32 hr, UInt64? oldPassportPuid, UInt64? newPassportPuid, HistoryReason reason)
            : base(userPuid, machinePuid, ipAddress, timestamp, hr, oldPassportPuid, newPassportPuid, reason) { }

        protected override void PreExecute(WSClient client)
        {
            client.SetHashVal(UserPuid.Value);
        }
    }

    public class MachinePassportHistoryAddSproc : PassportHistoryAddSproc
    {
        public override string SprocName
        {
            get { return "p_xuacs_machine_passport_history_add"; }
        }

        public MachinePassportHistoryAddSproc(UInt64? userPuid, UInt64? machinePuid, String ipAddress, DateTime timestamp, UInt32 hr, UInt64? oldPassportPuid, UInt64? newPassportPuid, HistoryReason reason)
            : base(userPuid, machinePuid, ipAddress, timestamp, hr, oldPassportPuid, newPassportPuid, reason) { }

        protected override void PreExecute(WSClient client)
        {
            client.SetHashVal(MachinePuid.Value);
        }
    }

    public class GamertagHistoryAddSproc : OperationHistoryAddSproc
    {
        [SprocParam("vc_old_gamertag", DbType.String)]
        public String OldGamertag;
        [SprocParam("vc_new_gamertag", DbType.String)]
        public String NewGamertag;

        public GamertagHistoryAddSproc(UInt64? userPuid, UInt64? machinePuid, String ipAddress, DateTime timestamp, UInt32 hr, String oldGamertag, String newGamertag, HistoryReason reason)
            : base(userPuid, machinePuid, ipAddress, timestamp, hr, reason)
        {
            this.OldGamertag = oldGamertag;
            this.NewGamertag = newGamertag;
        }
    }

    public class UserGamertagHistoryAddSproc : GamertagHistoryAddSproc
    {
        public override string SprocName
        {
            get { return "p_xuacs_user_gamertag_history_add"; }
        }

        public UserGamertagHistoryAddSproc(UInt64? userPuid, UInt64? machinePuid, String ipAddress, DateTime timestamp, UInt32 hr, String oldGamertag, String newGamertag, HistoryReason reason)
            : base(userPuid, machinePuid, ipAddress, timestamp, hr, oldGamertag, newGamertag, reason) { }

        protected override void PreExecute(WSClient client)
        {
            client.SetHashVal(UserPuid.Value);
        }
    }

    public class MachineGamertagHistoryAddSproc : GamertagHistoryAddSproc
    {
        public override string SprocName
        {
            get { return "p_xuacs_machine_gamertag_history_add"; }
        }

        public MachineGamertagHistoryAddSproc(UInt64? userPuid, UInt64? machinePuid, String ipAddress, DateTime timestamp, UInt32 hr, String oldGamertag, String newGamertag, HistoryReason reason)
            : base(userPuid, machinePuid, ipAddress, timestamp, hr, oldGamertag, newGamertag, reason) { }

        protected override void PreExecute(WSClient client)
        {
            client.SetHashVal(MachinePuid.Value);
        }
    }

    public class PresUpdateUserMachineHistorySproc : AccountHijackSproc
    {
        [SprocParam("bi_user_puid", DbType.Int64)]
        public Int64 userPuid;

        [SprocParam("bi_machine_puid", DbType.Int64)]
        public Int64 machinePuid;

        [SprocParam("si_hash_bucket", DbType.Int16)]
        public short hashBucket;

        public override string SprocName
        {
            get { return "p_pres_update_user_machine_history"; }
        }

        public PresUpdateUserMachineHistorySproc(UInt64 userPuid, UInt64 machinePuid)
        {
            this.userPuid    = (Int64) userPuid;
            this.machinePuid = (Int64) machinePuid;
        }

        protected override void PreExecute(WSClient client)
        {
            client.SetHashVal(userPuid);
            hashBucket = (short) client.CalcPartition(userPuid);
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\StfTests\HijackAccountTests\HijackDB.cs ===
using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using ServerTestFramework.Database;
using System.Net;
using xonline.common.sql.webstore;
using xonline.common.config;
using Microsoft.Webstore.WstClient;
using ServerTestFramework;
using xonline.common.service;
using System.Reflection;
using System.Data;

namespace HijackAccountTests.Database
{
    public static class ReaderExtensions
    {
        /// <summary>
        /// Allows us to easily deal with DB Nulls while reading values.  Checks if a value
        /// returned by the reader is a DB Null, and if so returns a null, otherwise it
        /// returns the value.
        /// </summary>
        /// <typeparam name="T">The type of the value to get</typeparam>
        /// <param name="reader">The reader to read the values from</param>
        /// <param name="index">The index of the value to read</param>
        /// <returns>A nullable object of the type specified with the appropriate value</returns>
        public static T? GetNullable<T>(this System.Data.IDataReader reader, Int32 index)
            where T : struct
        {
            if (reader.IsDBNull(index))
            {
                return null;
            }
            else
            {
                return (T)reader.GetValue(index);
            }
        }

        public static T GetValueOrDefault<T>(this System.Data.IDataReader reader, String name)
        {
            return GetValueOrDefault(reader, reader.GetOrdinal(name), default(T));
        }

        public static T GetValueOrDefault<T>(this System.Data.IDataReader reader, String name, T defaultValue)
        {
            return GetValueOrDefault(reader, reader.GetOrdinal(name), defaultValue);
        }

        public static T GetValueOrDefault<T>(this System.Data.IDataReader reader, Int32 index)
        {
            return GetValueOrDefault(reader, index, default(T));
        }

        public static T GetValueOrDefault<T>(this System.Data.IDataReader reader, Int32 index, T defaultValue)
        {
            if (reader.IsDBNull(index))
            {
                return defaultValue;
            }
            else
            {
                return (T)reader.GetValue(index);
            }
        }

        public static IPAddress GetIpAddress(this System.Data.IDataReader reader, String name)
        {
            return GetIpAddress(reader, reader.GetOrdinal(name));
        }

        public static IPAddress GetIpAddress(this System.Data.IDataReader reader, Int32 index)
        {
            String ip = reader.GetValueOrDefault<String>("vc_ip_address", null);

            if (String.IsNullOrEmpty(ip))
            {
                return null;
            }
            else
            {
                return IPAddress.Parse(ip);
            }
        }

        public static DateTime GetDateTime(this WstDataReader reader, String name)
        {
            return reader.GetDateTime(reader.GetOrdinal(name));
        }

        public static Int16 GetInt16(this WstDataReader reader, String name)
        {
            return reader.GetInt16(reader.GetOrdinal(name));
        }

        public static Int32 GetInt32(this WstDataReader reader, String name)
        {
            return reader.GetInt32(reader.GetOrdinal(name));
        }

        public static Int64 GetInt64(this WstDataReader reader, String name)
        {
            return reader.GetInt64(reader.GetOrdinal(name));
        }

        public static UInt16 GetUInt16(this WstDataReader reader, String name)
        {
            return (UInt16)reader.GetInt16(reader.GetOrdinal(name));
        }

        public static UInt16 GetUInt16(this WstDataReader reader, Int32 index)
        {
            return (UInt16)reader.GetInt16(index);
        }

        public static UInt32 GetUInt32(this WstDataReader reader, String name)
        {
            return (UInt32)reader.GetInt32(reader.GetOrdinal(name));
        }

        public static UInt32 GetUInt32(this WstDataReader reader, Int32 index)
        {
            return (UInt32)reader.GetInt32(index);
        }

        public static UInt64 GetUInt64(this WstDataReader reader, String name)
        {
            return (UInt64)reader.GetInt64(reader.GetOrdinal(name));
        }

        public static UInt64 GetUInt64(this WstDataReader reader, Int32 index)
        {
            return (UInt64)reader.GetInt64(index);
        }
    }

    public class AccountHijackSprocResponse
    {
        public virtual void Read(WstDataReader reader) { }

        public virtual void ReadDetail(WstDataReader reader) { }
    }

    public class SprocParamAttribute : Attribute
    {
        private String name = String.Empty;
        public String Name
        {
            get { return name; }
        }

        private DbType type = DbType.String;
        public DbType Type
        {
            get { return type; }
        }

        public SprocParamAttribute()
        {
        }

        public SprocParamAttribute(String paramName)
        {
            this.name = paramName;
        }

        public SprocParamAttribute(String paramName, DbType paramType)
        {
            this.name = paramName;
            this.type = paramType;
        }
    }

    public class AccountHijackSproc// : StoredProc
    {
        public virtual String SprocName
        {
            get { return String.Empty; }
        }

        private HResult hr = HResult.S_OK;
        public HResult Hr
        {
            get { return hr; }
        }

        public AccountHijackSproc() { }

        protected virtual void SetParams(WSClient client)
        {
            foreach (FieldInfo field in GetType().GetFields(BindingFlags.Public | BindingFlags.NonPublic | BindingFlags.Instance))
            {
                Object[] attributes = field.GetCustomAttributes(typeof(SprocParamAttribute), false);

                // If it has ONE sproc param attribute, then get the value
                if (attributes.Length == 1)
                {
                    SprocParamAttribute paramAttrib = attributes[0] as SprocParamAttribute;

                    // We're not responsible for ensuring that all proper parameter values 
                    // are provided.  If it's null, we assume it has a default.
                    Object value = field.GetValue(this);
                    if (value != null)
                    {
                        client.AddParameter("@" + paramAttrib.Name, value, paramAttrib.Type);
                    }
                }
            }
        }

        protected virtual void PreExecute(WSClient client) { }

        public bool Execute()
        {
            using (WSClient ws = new WSClient(ConfigUtil.UodbWebstoreApp, CmdType.WRITETHENREAD_COMMANDTYPE))
            {
                //ws.PartitionType = WstPartitionType.Logical;
                //ws.Partition = WstCommand.AnyPartition;

                // Set the sproc name
                ws.StoredProc = SprocName;
                // Add all the parameters
                SetParams(ws);

                // Add a return value parameter
                ws.AddParameter(ParamType.RETVAL, "@hr", hr);

                PreExecute(ws);

                using (WstDataReader reader = ws.Execute())
                {
                    hr = (UInt32)ws.GetIntParameter("@hr");

                    if (HResult.Succeeded(hr))
                    {
                        // If the request succeeded, then pass the reader to be read
                        ReadResponse(reader);
                    }
                    else
                    {
                        Global.RO.Error("Sproc Failed. " + GetDumpString());
                        return false;
                    }
                }

                return true;
            }

        }

        protected virtual void ReadResponse(WstDataReader reader) { }

        public String GetDumpString()
        {
            StringBuilder sb = new StringBuilder(this.GetType().Name);
            sb.Append(" XErr: ");
            sb.Append(Global.XErrToString(hr));

            return sb.ToString();
        }
    }

    public class AccountHijackSproc<ResponseType> : AccountHijackSproc
        where ResponseType : AccountHijackSprocResponse, new()
    {
        private ResponseType response = new ResponseType();
        public ResponseType Response
        {
            get { return response; }
        }

        public AccountHijackSproc() : base() { }

        protected override void ReadResponse(WstDataReader reader)
        {
            Response.Read(reader);
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\StfTests\HijackAccountTests\Presence.cs ===
using System;
using System.Net;
using HijackAccountTests.Database;
using ServerTestFramework;
using ServerTestFramework.Database;
using ServerTestFramework.LiveService.FakeSG;
using ServerTestFramework.LiveService.PresNotiCommon;
using ServerTestFramework.Utilities;
using ServerTestFramework.LiveService.Notification;
using System.Threading;
using xonline.common.service;
using xonline.common.protocol;

namespace HijackAccountTests
{
    [TestGroup]
    [AsyncGroup(1)]
    public class Presence: TestNode
    {
        public static MachineType GetMachineType(CSGInfo.ClientType sgClientType)
        {
            if (sgClientType==CSGInfo.ClientType.Xbox) return MachineType.Xbox1;
            else if (sgClientType==CSGInfo.ClientType.Xenon) return MachineType.Xbox360;
            else if (sgClientType==CSGInfo.ClientType.XenonBackCompat) return MachineType.Xbox360;
            else if (sgClientType==CSGInfo.ClientType.PC) return MachineType.PC;
            else
                throw new System.Exception("Unknown sg client type");
        }

        public static uint GetClientTitle(CSGInfo.ClientType sgClientType)
        {
            if (sgClientType==CSGInfo.ClientType.Xbox) return 0x4D530064;
            else if (sgClientType==CSGInfo.ClientType.Xenon) return 0xfffe07d1;
            else if (sgClientType==CSGInfo.ClientType.XenonBackCompat) return 0x4D530064;
            else if (sgClientType==CSGInfo.ClientType.PC) return 0x585207d1;
            else
                throw new System.Exception("Unknown sg client type");
        }

        public static void SignInPresence(UserEditor user, MachineEditor machine)
        {
            PNUser pnUser = null;
            PNXbox pnXbox = null;

            SignInPresence(user.Puid, user.Gamertag, machine.Id, CSGInfo.ClientType.Xenon, ref pnUser, ref pnXbox);
        }

        public static void SignInPresence(UserEditor user, MachineEditor machine, ref PNUser presUser, ref PNXbox presXbox)
        {
            SignInPresence(user.Puid, user.Gamertag, machine.Id, CSGInfo.ClientType.Xenon, ref presUser, ref presXbox);
        }

        public static void SignInPresence(UserEditor user, MachineEditor machine, CSGInfo.ClientType clientType)
        {
            PNUser pnUser = null;
            PNXbox pnXbox = null;

            SignInPresence(user.Puid, user.Gamertag, machine.Id, clientType, ref pnUser, ref pnXbox);
        }
        public static void SignInPresence(UserEditor user, MachineEditor machine, CSGInfo.ClientType clientType, ref PNUser presUser, ref PNXbox presXbox, bool disconnect)
        {
            SignInPresence(user.Puid, user.Gamertag, machine.Id, clientType, ref presUser, ref presXbox, disconnect);
        }

        public static void SignInPresence(UInt64 userPuid, String gamertag, UInt64 machinePuid, CSGInfo.ClientType clientType)
        {
            PNUser pnUser = null;
            PNXbox pnXbox = null;

            SignInPresence(userPuid, gamertag, machinePuid, clientType, ref pnUser, ref pnXbox);
        }

        public static void SignInPresence(UInt64 userPuid, String gamertag, UInt64 machinePuid, CSGInfo.ClientType clientType, ref PNUser presUser, ref PNXbox presXbox)
        {
            SignInPresence(userPuid, gamertag, machinePuid, clientType, ref presUser, ref presXbox, true);
        }

        public static void SignInPresence(UInt64 userPuid, String gamertag, UInt64 machinePuid, CSGInfo.ClientType clientType, ref PNUser presUser, ref PNXbox presXbox, bool disconnect)
        {
            //sign in
            Global.RO.Info("Signing user 0x{0:X}({1}) into presence on machine 0x{2:X} as client type {3}.", userPuid, gamertag, machinePuid, clientType);
            if (presXbox == null)
            {
                presXbox = new PNXbox(machinePuid, GetClientTitle(clientType), clientType);
            }

            if (presUser == null)
            {
                // This performs the connect as well
                presUser = new PNUser(gamertag, userPuid, presXbox);
            }
            else
            {
                presUser.Connect(presXbox);
            }

            presUser.Alive();

            //now sign out and abolish them from presence cache so that signing in again later will cause presence to hit the db again
            if (disconnect)
            {
                SignOutPresence(presUser);
            }
        }

        public static void SignOutPresence(PNUser presUser)
        {
            Global.RO.Info("Signing out of presence and clearing caches..."); //this clears the cache on the presense server also so that signing in again will hit the db again
            presUser.Disconnect();

            string output;
            string cmd = "e :Presence kick " + presUser.UserId;
            Global.RO.Debug("Running xmgmt: " + cmd);
            ServerTestFramework.LiveService.ManagementConsole.ExecuteOnAll("xpserver", cmd, out output);
            Global.RO.Debug(output);

            cmd = "e :Presence setcachestate " + presUser.UserId + " 0";
            Global.RO.Debug("Running xmgmt: " + cmd);
            ServerTestFramework.LiveService.ManagementConsole.ExecuteOnAll("xpserver", cmd, out output); //0 = "not in memory"
            Global.RO.Debug(output);
        }

        /// <summary>
        /// Enumerates all the messages in the users inbox after waiting for 
        /// a given period of time or until a message arrives
        /// </summary>
        /// <param name="user">The user whos inbox should be loaded</param>
        /// <param name="loadDelay">The delay time in ms</param>
        /// <returns>A message folder for the given user</returns>
        public static UserMsgFolder LoadInbox(PNUser user, double loadDelay)
        {
            if (loadDelay > 0)
            {
                PNUser.DefaultNotificationWait = loadDelay;
                Global.RO.Debug("Waiting {0} sec to allow any messages to arrive...", PNUser.DefaultNotificationWait);

                try
                {
                    QValPacket qval = user.WaitForNewMessage();
                    user.HandleQValPacket(qval);
                }
                catch (TimeOutException)
                {
                    // We don't care if it times out.  We just use the delay to wait 
                    // in case there are any messages that arrive, but we're not 
                    // necessarily expecting one to.
                }
            }

            return LoadInbox(user);
        }

        /// <summary>
        /// Enumerates all the messages in the users inbox after waiting for a message
        /// of the given type to arrive
        /// </summary>
        /// <param name="user">The user whos inbox should be loaded</param>
        /// <param name="msgTypeToWaitFor">The message type to wait for</param>
        /// <returns>A message folder for the given user</returns>
        public static UserMsgFolder LoadInbox(PNUser user, Byte msgTypeToWaitFor)
        {
            Global.RO.Debug("Waiting for message type {0}.  This will timeout if the message does not arrive.", msgTypeToWaitFor);
            QValPacket qval = user.WaitForNewMessageType(msgTypeToWaitFor);
            user.HandleQValPacket(qval);

            return LoadInbox(user);
        }

        /// <summary>
        /// Enumerates all the messages in the users inbox
        /// </summary>
        /// <param name="user">The user whos inbox should be loaded</param>
        /// <returns>A message folder for the given user</returns>
        public static UserMsgFolder LoadInbox(PNUser user)
        {
            Global.RO.Debug("Loading user inbox...");
            UserMsgFolder folder = new UserMsgFolder(user);

            int numMessages = folder.LoadEx();
            Global.RO.Debug("Loaded {0} message(s).", numMessages);

            return folder;
        }

        // --

        [CompoundCase("Xbox360", CSGInfo.ClientType.Xenon)]
        [CompoundCase("PC", CSGInfo.ClientType.PC)]
        //[CompoundCase("Xbox1", CSGInfo.ClientType.Xbox)] // We don't need Xbox1 tests anymore
        //[CompoundCase("Fusion", CSGInfo.ClientType.XenonBackCompat)] //unless we add platform-specific logic we shouldn't need this set
        [TestGroup, TestFrequency("Regression"), Owner("LukeL")]
        [AsyncGroup(13, 13), AsyncThreadCount(5), AsyncThreadDelay(5000)]
        public class Platforms : TestNode
        {
            public override void PreRun()
            {
                CreateContextData();
                SetContextData("ClientType", MyValues[0]);
            }

            [TestCase, Description("User has never signed into presence since the update that added this stuff.  Verify sproc returns sane things."), TestCasePriority(0)]
            public void NeverSignedIn()
            {
                UserEditor user=UserEditor.CreateNew();

                //verify sproc with and without details
                for (int detailsPass=0; detailsPass<2; ++detailsPass)
                {
                    bool details=(detailsPass==1);

                    Global.RO.Debug("Checking UserMachine history for user "+string.Format("0x{0:X} ",user.Puid)+(details?"with":"without")+" details...");

                    UserMachineHistoryGetResponse reply=HijackUtilites.GetUserMachineHistory(user.Puid, details);
                    ValueCheck.Test("Unique", 0, reply.Unique);
                    ValueCheck.TestNull("FirstSeen", reply.FirstSeen);
                    ValueCheck.TestNull("LastSeen", reply.LastSeen);
                    ValueCheck.Test("DaysSeen", 0, reply.DaysSeen);

                    ValueCheck.Test("Details exist", false, reply.Details!=null && reply.Details.Count>0);
                }
            }

            [TestCase, Description("User signs into presence for the first time."), TestCasePriority(0)]
            public void SignIn_OneMachine()
            {
                //create user and machine
                CSGInfo.ClientType clientType=(CSGInfo.ClientType)GetContextData("ClientType");
                UserEditor user=UserEditor.CreateNew();
                MachineEditor machine=MachineEditor.CreateNew(HijackUtilites.GetMachineType(clientType));

                //sign into presense
                SignInPresence(user.Puid, user.Gamertag, machine.Id, clientType);

                //verify sproc with and without details
                for (int detailsPass=0; detailsPass<2; ++detailsPass)
                {
                    bool details=(detailsPass==1);

                    Global.RO.Debug("Checking UserMachine history for user "+string.Format("0x{0:X} ",user.Puid)+(details?"with":"without")+" details...");

                    UserMachineHistoryGetResponse reply=HijackUtilites.GetUserMachineHistory(user.Puid, details);
                    ValueCheck.Test("Unique", 1, reply.Unique);
                    ValueCheck.Test("FirstSeen", HijackUtilites.TruncateToDay(System.DateTime.UtcNow), reply.FirstSeen.Value, new System.TimeSpan(0, 0, 1));
                    ValueCheck.Test("LastSeen", reply.FirstSeen.Value, reply.LastSeen.Value, new System.TimeSpan(0, 0, 1));
                    ValueCheck.Test("DaysSeen", 1, reply.DaysSeen);

                    ValueCheck.Test("Details exist", details, reply.Details!=null && reply.Details.Count>0);
                    if (details)
                    {
                        ValueCheck.Test("Details count", 1, reply.Details.Count);
                        ValueCheck.Test("Details[0] UserPuid", user.Puid, reply[0].UserPuid);
                        ValueCheck.Test("Details[0] MachinePuid", machine.Id, reply[0].MachinePuid);
                        ValueCheck.Test("Details[0] FirstSeen", reply.FirstSeen.Value, reply[0].FirstSeen, new System.TimeSpan(0, 0, 1));
                        ValueCheck.Test("Details[0] LastSeen", reply.LastSeen.Value, reply[0].LastSeen, new System.TimeSpan(0, 0, 1));
                        ValueCheck.Test("Details[0] DaysSeen", 1, reply.Details[0].DaysSeen);
                    }
                }
            }

            [TestCase, TestCasePriority(1)]
            public void SignInTwice_OneMachine_SameDay()
            {
                //create user and machine
                CSGInfo.ClientType clientType=(CSGInfo.ClientType)GetContextData("ClientType");
                UserEditor user=UserEditor.CreateNew();
                MachineEditor machine=MachineEditor.CreateNew(HijackUtilites.GetMachineType(clientType));

                //sign into presense, wait 10 seconds, then sign in again
                SignInPresence(user.Puid, user.Gamertag, machine.Id, clientType);
                System.Threading.Thread.Sleep(10000);
                SignInPresence(user.Puid, user.Gamertag, machine.Id, clientType);

                //verify sproc with and without details
                for (int detailsPass=0; detailsPass<2; ++detailsPass)
                {
                    bool details=(detailsPass==1);

                    Global.RO.Debug("Checking UserMachine history for user "+string.Format("0x{0:X} ",user.Puid)+(details?"with":"without")+" details...");

                    UserMachineHistoryGetResponse reply=HijackUtilites.GetUserMachineHistory(user.Puid, details);
                    ValueCheck.Test("Unique", 1, reply.Unique);
                    ValueCheck.Test("FirstSeen", HijackUtilites.TruncateToDay(System.DateTime.UtcNow), reply.FirstSeen.Value, new System.TimeSpan(0, 0, 1));
                    ValueCheck.Test("LastSeen", reply.FirstSeen.Value, reply.LastSeen.Value, new System.TimeSpan(0, 0, 1));
                    ValueCheck.Test("DaysSeen", 1, reply.DaysSeen);

                    ValueCheck.Test("Details exist", details, reply.Details!=null && reply.Details.Count>0);
                    if (details)
                    {
                        ValueCheck.Test("Details count", 1, reply.Details.Count);
                        ValueCheck.Test("Details[0] UserPuid", user.Puid, reply.Details[0].UserPuid);
                        ValueCheck.Test("Details[0] MachinePuid", machine.Id, reply.Details[0].MachinePuid);
                        ValueCheck.Test("Details[0] FirstSeen", reply.FirstSeen.Value, reply.Details[0].FirstSeen, new System.TimeSpan(0, 0, 1));
                        ValueCheck.Test("Details[0] LastSeen", reply.LastSeen.Value, reply.Details[0].LastSeen, new System.TimeSpan(0, 0, 1));
                        ValueCheck.Test("Details[0] DaysSeen", 1, reply.Details[0].DaysSeen);
                    }
                }
            }

            [TestCase, TestCasePriority(1)]
            public void SignInThree_OneMachine_DifferentDays()
            {
                //create user and machine
                CSGInfo.ClientType clientType=(CSGInfo.ClientType)GetContextData("ClientType");
                UserEditor user=UserEditor.CreateNew();
                MachineEditor machine=MachineEditor.CreateNew(HijackUtilites.GetMachineType(clientType));

                //sign into presense on different days
                Global.RO.Fatal("TEMPTEST: 1");
                SignInPresence(user.Puid, user.Gamertag, machine.Id, clientType);
                HijackUtilites.FastForwardTimeForUser(user.Puid, new TimeSpan(1, 0, 0, 0));
                Global.RO.Fatal("TEMPTEST: 2");
                SignInPresence(user.Puid, user.Gamertag, machine.Id, clientType);
                HijackUtilites.FastForwardTimeForUser(user.Puid, new TimeSpan(400, 0, 0, 0));
                Global.RO.Fatal("TEMPTEST: 3");
                SignInPresence(user.Puid, user.Gamertag, machine.Id, clientType);

                //verify sproc with and without details
                for (int detailsPass=0; detailsPass<2; ++detailsPass)
                {
                    bool details=(detailsPass==1);

                    Global.RO.Debug("Checking UserMachine history for user "+string.Format("0x{0:X} ",user.Puid)+(details?"with":"without")+" details...");

                    UserMachineHistoryGetResponse reply=HijackUtilites.GetUserMachineHistory(user.Puid, details);
                    ValueCheck.Test("Unique", 1, reply.Unique);
                    ValueCheck.Test("FirstSeen", HijackUtilites.TruncateToDay(System.DateTime.UtcNow)-new System.TimeSpan(401, 0, 0, 0), reply.FirstSeen.Value, new System.TimeSpan(0, 0, 1));
                    ValueCheck.Test("LastSeen", HijackUtilites.TruncateToDay(System.DateTime.UtcNow), reply.LastSeen.Value, new System.TimeSpan(0, 0, 1));
                    ValueCheck.Test("DaysSeen", 3, reply.DaysSeen);

                    ValueCheck.Test("Details exist", details, reply.Details!=null && reply.Details.Count>0);
                    if (details)
                    {
                        ValueCheck.Test("Details count", 1, reply.Details.Count);
                        ValueCheck.Test("Details[0] UserPuid", user.Puid, reply.Details[0].UserPuid);
                        ValueCheck.Test("Details[0] MachinePuid", machine.Id, reply.Details[0].MachinePuid);
                        ValueCheck.Test("Details[0] FirstSeen", reply.FirstSeen.Value, reply.Details[0].FirstSeen, new System.TimeSpan(0, 0, 1));
                        ValueCheck.Test("Details[0] LastSeen", reply.LastSeen.Value, reply.Details[0].LastSeen, new System.TimeSpan(0, 0, 1));
                        ValueCheck.Test("Details[0] DaysSeen", 3, reply.Details[0].DaysSeen);
                    }
                }
            }

            [TestCase, TestCasePriority(2)]
            public void SignIn_TwoUsers_SameMachine()
            {
                //create users and machine
                CSGInfo.ClientType clientType=(CSGInfo.ClientType)GetContextData("ClientType");
                UserEditor []users=new UserEditor[2];
                users[0]=UserEditor.CreateNew();
                users[1]=UserEditor.CreateNew();
                MachineEditor machine=MachineEditor.CreateNew(HijackUtilites.GetMachineType(clientType));

                //sign both users into presence separately on the same machine
                SignInPresence(users[0].Puid, users[0].Gamertag, machine.Id, clientType);
                SignInPresence(users[1].Puid, users[1].Gamertag, machine.Id, clientType);

                //verify sproc with and without details
                for (int user=0; user<2; ++user)
                {
                    for (int detailsPass=0; detailsPass<2; ++detailsPass)
                    {
                        bool details=(detailsPass==1);

                        Global.RO.Debug("Checking UserMachine history for user "+string.Format("0x{0:X} ",users[user].Puid)+(details?"with":"without")+" details...");

                        UserMachineHistoryGetResponse reply=HijackUtilites.GetUserMachineHistory(users[user].Puid, details);
                        ValueCheck.Test("Unique", 1, reply.Unique);
                        ValueCheck.Test("FirstSeen", HijackUtilites.TruncateToDay(System.DateTime.UtcNow), reply.FirstSeen.Value, new System.TimeSpan(0, 0, 1));
                        ValueCheck.Test("LastSeen", HijackUtilites.TruncateToDay(System.DateTime.UtcNow), reply.LastSeen.Value, new System.TimeSpan(0, 0, 1));
                        ValueCheck.Test("DaysSeen", 1, reply.DaysSeen);

                        ValueCheck.Test("Details exist", details, reply.Details!=null && reply.Details.Count>0);
                        if (details)
                        {
                            ValueCheck.Test("Details count", 1, reply.Details.Count);
                            ValueCheck.Test("Details[0] UserPuid", users[user].Puid, reply.Details[0].UserPuid);
                            ValueCheck.Test("Details[0] MachinePuid", machine.Id, reply.Details[0].MachinePuid);
                            ValueCheck.Test("Details[0] FirstSeen", reply.FirstSeen.Value, reply.Details[0].FirstSeen, new System.TimeSpan(0, 0, 1));
                            ValueCheck.Test("Details[0] LastSeen", reply.LastSeen.Value, reply.Details[0].LastSeen, new System.TimeSpan(0, 0, 1));
                            ValueCheck.Test("Details[0] DaysSeen", 1, reply.Details[0].DaysSeen);
                        }
                    }
                }
            }

            [TestCase, TestCasePriority(2)]
            public void SignIn_TwoMachines_SameDay()
            {
                //create user and machine
                CSGInfo.ClientType clientType=(CSGInfo.ClientType)GetContextData("ClientType");
                UserEditor user=UserEditor.CreateNew();
                MachineEditor machine0=MachineEditor.CreateNew(HijackUtilites.GetMachineType(clientType));
                MachineEditor machine1=MachineEditor.CreateNew(HijackUtilites.GetMachineType(clientType));

                //sign into presense on both machines separately
                SignInPresence(user.Puid, user.Gamertag, machine0.Id, clientType);
                SignInPresence(user.Puid, user.Gamertag, machine1.Id, clientType);

                //verify sproc with and without details
                for (int detailsPass=0; detailsPass<2; ++detailsPass)
                {
                    bool details=(detailsPass==1);

                    Global.RO.Debug("Checking UserMachine history for user "+string.Format("0x{0:X} ",user.Puid)+(details?"with":"without")+" details...");

                    UserMachineHistoryGetResponse reply=HijackUtilites.GetUserMachineHistory(user.Puid, details);
                    ValueCheck.Test("Unique", 2, reply.Unique);
                    ValueCheck.Test("FirstSeen", HijackUtilites.TruncateToDay(System.DateTime.UtcNow), reply.FirstSeen.Value, new System.TimeSpan(0, 0, 1));
                    ValueCheck.Test("LastSeen", reply.FirstSeen.Value, reply.LastSeen.Value, new System.TimeSpan(0, 0, 1));
                    ValueCheck.Test("DaysSeen", 2, reply.DaysSeen); //arguably this should be 1, but the current design only stores edges in the table rather than every signin, so it's not possible to get the actual correct answer.  it's basically the number of days we've seen each machine added together.

                    ValueCheck.Test("Details exist", details, reply.Details!=null && reply.Details.Count>0);
                    if (details)
                    {
                        ValueCheck.Test("Details count", 2, reply.Details.Count);

                        int machine0Index=0;
                        int machine1Index=1;
                        if (reply.Details[0].MachinePuid==machine1.Id)
                        {
                            machine1Index=0;
                            machine0Index=1;
                        }

                        ValueCheck.Test("Details["+machine0Index+"] UserPuid", user.Puid, reply.Details[machine0Index].UserPuid);
                        ValueCheck.Test("Details["+machine0Index+"] MachinePuid", machine0.Id, reply.Details[machine0Index].MachinePuid);
                        ValueCheck.Test("Details["+machine0Index+"] FirstSeen", reply.FirstSeen.Value, reply.Details[machine0Index].FirstSeen, new System.TimeSpan(0, 0, 1));
                        ValueCheck.Test("Details["+machine0Index+"] LastSeen", reply.LastSeen.Value, reply.Details[machine0Index].LastSeen, new System.TimeSpan(0, 0, 1));
                        ValueCheck.Test("Details["+machine0Index+"] DaysSeen", 1, reply.Details[machine0Index].DaysSeen);

                        ValueCheck.Test("Details["+machine1Index+"] UserPuid", user.Puid, reply.Details[machine1Index].UserPuid);
                        ValueCheck.Test("Details["+machine1Index+"] MachinePuid", machine1.Id, reply.Details[machine1Index].MachinePuid);
                        ValueCheck.Test("Details["+machine1Index+"] FirstSeen", reply.FirstSeen.Value, reply.Details[machine1Index].FirstSeen, new System.TimeSpan(0, 0, 1));
                        ValueCheck.Test("Details["+machine1Index+"] LastSeen", reply.LastSeen.Value, reply.Details[machine1Index].LastSeen, new System.TimeSpan(0, 0, 1));
                        ValueCheck.Test("Details["+machine1Index+"] DaysSeen", 1, reply.Details[machine1Index].DaysSeen);
                    }
                }
            }

            [TestCase, TestCasePriority(2)]
            public void SignIn_TwoMachines_MultipleDays()
            {
                //create user and machine
                CSGInfo.ClientType clientType=(CSGInfo.ClientType)GetContextData("ClientType");
                UserEditor user=UserEditor.CreateNew();
                MachineEditor machine0=MachineEditor.CreateNew(HijackUtilites.GetMachineType(clientType));
                MachineEditor machine1=MachineEditor.CreateNew(HijackUtilites.GetMachineType(clientType));

                //sign into presense on both machines separately, the second machine on different days
                SignInPresence(user.Puid, user.Gamertag, machine1.Id, clientType);
                HijackUtilites.FastForwardTimeForUser(user.Puid, new TimeSpan(1, 0, 0 ,0));
                SignInPresence(user.Puid, user.Gamertag, machine1.Id, clientType);
                HijackUtilites.FastForwardTimeForUser(user.Puid, new TimeSpan(1, 0, 0, 0));
                SignInPresence(user.Puid, user.Gamertag, machine0.Id, clientType);
                SignInPresence(user.Puid, user.Gamertag, machine1.Id, clientType);

                //verify sproc with and without details
                for (int detailsPass=0; detailsPass<2; ++detailsPass)
                {
                    bool details=(detailsPass==1);

                    Global.RO.Debug("Checking UserMachine history for user "+string.Format("0x{0:X} ",user.Puid)+(details?"with":"without")+" details...");

                    UserMachineHistoryGetResponse reply=HijackUtilites.GetUserMachineHistory(user.Puid, details);
                    ValueCheck.Test("Unique", 2, reply.Unique);
                    ValueCheck.Test("FirstSeen", HijackUtilites.TruncateToDay(System.DateTime.UtcNow)-new System.TimeSpan(2, 0, 0, 0), reply.FirstSeen.Value, new System.TimeSpan(0, 0, 1));
                    ValueCheck.Test("LastSeen", HijackUtilites.TruncateToDay(System.DateTime.UtcNow), reply.LastSeen.Value, new System.TimeSpan(0, 0, 1));
                    ValueCheck.Test("DaysSeen", 4, reply.DaysSeen); //arguably this should be 3, but the current design only stores edges in the table rather than every signin, so it's not possible to get the actual correct answer.  it's basically the number of days we've seen each machine added together.

                    ValueCheck.Test("Details exist", details, reply.Details!=null && reply.Details.Count>0);
                    if (details)
                    {
                        ValueCheck.Test("Details count", 2, reply.Details.Count);

                        int machine0Index=0;
                        int machine1Index=1;
                        if (reply.Details[0].MachinePuid==machine1.Id)
                        {
                            machine1Index=0;
                            machine0Index=1;
                        }

                        ValueCheck.Test("Details["+machine0Index+"] UserPuid", user.Puid, reply.Details[machine0Index].UserPuid);
                        ValueCheck.Test("Details["+machine0Index+"] MachinePuid", machine0.Id, reply.Details[machine0Index].MachinePuid);
                        ValueCheck.Test("Details["+machine0Index+"] FirstSeen", HijackUtilites.TruncateToDay(System.DateTime.UtcNow), reply.Details[machine0Index].FirstSeen, new System.TimeSpan(0, 0, 1));
                        ValueCheck.Test("Details["+machine0Index+"] LastSeen", HijackUtilites.TruncateToDay(System.DateTime.UtcNow), reply.Details[machine0Index].LastSeen, new System.TimeSpan(0, 0, 1));
                        ValueCheck.Test("Details["+machine0Index+"] DaysSeen", 1, reply.Details[machine0Index].DaysSeen);

                        ValueCheck.Test("Details["+machine1Index+"] UserPuid", user.Puid, reply.Details[machine1Index].UserPuid);
                        ValueCheck.Test("Details["+machine1Index+"] MachinePuid", machine1.Id, reply.Details[machine1Index].MachinePuid);
                        ValueCheck.Test("Details["+machine1Index+"] FirstSeen", reply.FirstSeen.Value, reply.Details[machine1Index].FirstSeen, new System.TimeSpan(0, 0, 1));
                        ValueCheck.Test("Details["+machine1Index+"] LastSeen", reply.LastSeen.Value, reply.Details[machine1Index].LastSeen, new System.TimeSpan(0, 0, 1));
                        ValueCheck.Test("Details["+machine1Index+"] DaysSeen", 3, reply.Details[machine1Index].DaysSeen);
                    }
                }
            }

            [TestCase, Owner("BenRan"), Description("Verifies that a user recieves a LIVE welcome message the first time they ever sign in"), TestCasePriority(2)]
            public class SignIn_FirstTime_LiveWelcomeMessage : TestNode
            {
                CSGInfo.ClientType clientType;
                UserEditor user;
                MachineEditor machine; 

                public override void PreRun()
                {
                    //create user and machine
                    clientType = (CSGInfo.ClientType)GetContextData("ClientType");
                    user = UserEditor.CreateNew();
                    machine = MachineEditor.CreateNew(GetMachineType(clientType));
                    SignInPresence(user.Puid, user.Gamertag, machine.Id, clientType);
                }

                public override void Run()
                {
                    PNUser pnUser = null;
                    PNXbox pnXbox = null;

                    SignInPresence(user.Puid, user.Gamertag, machine.Id, clientType);

                    // Sign the user into presence
                    Global.RO.Info("Connecting to first machine...");
                    SignInPresence(user.Puid, user.Gamertag, machine.Id, clientType);

                    SignInPresence(user, machine, clientType, ref pnUser, ref pnXbox, false);
                    UserMsgFolder userMsgFolder = LoadInbox(pnUser, 5.0);

                    foreach (UserMessage message in userMsgFolder.Inbox) 
                    {
                        if (message.GetDetails(pnUser) == HResult.S_OK) 
                        {
                            UInt32 messageId = message.Details.GetStringIdProperty(MsgDefs.XONLINE_MSG_PROP_SYSTEM_TEXT);

                            if (messageId == HijackSettings.PresenceWelcomeToXboxLiveMessage) 
                            {
                                Global.RO.Success("Found expected welcome message!");
                                return;
                            }
                        }
                    }

                    throw new UnexpectedTestResultException("Welcome message not found");
                }
            }

            [TestCase, Owner("BenRan"), Description("Verifies that a user does not recieve a welcome message the second time they sign into live"), TestCasePriority(1)]
            public class SignIn_SecondTime_NoLiveWelcomeMessage : TestNode
            {
                CSGInfo.ClientType clientType;
                UserEditor user;
                MachineEditor machine;

                public override void PreRun()
                {
                    //create user and machine
                    clientType = (CSGInfo.ClientType)GetContextData("ClientType");
                    user = UserEditor.CreateNew();
                    machine = MachineEditor.CreateNew(GetMachineType(clientType));
                }

                public override void Run()
                {
                    PNUser pnUser = null;
                    PNXbox pnXbox = null;

                    Global.RO.Info("Connecting to machine...");
                    SignInPresence(user.Puid, user.Gamertag, machine.Id, clientType);

                    Global.RO.Info("Clearing user inbox...");
                    SignInPresence(user, machine, clientType, ref pnUser, ref pnXbox, false);
                    UserMsgFolder inbox = LoadInbox(pnUser, 5.0);
                    inbox.DeleteAllMessages();
                    SignOutPresence(pnUser);

                    Global.RO.Info("Connecting to machine again...");
                    SignInPresence(user.Puid, user.Gamertag, machine.Id, clientType);
                    inbox = LoadInbox(pnUser, 2.0);
                    
                    // Disconnect the user and reconnect them
                    Global.RO.Info("Checking for empty inbox...");
                    SignInPresence(user, machine, clientType, ref pnUser, ref pnXbox, false);

                    if (inbox.InboxCount > 0) {
                        throw new UnexpectedTestResultException("Unexpected messages in inbox");
                    }

                    Global.RO.Success("No welcome message as expected!");
                }
            }

            [TestCase, Owner("BenRan"), Description("Verifies that a user recieves a Console welcome message the first time they ever sign into a new console"), TestCasePriority(1)]
            public class SignIn_FirstTime_NewConsoleMessage : TestNode
            {
                CSGInfo.ClientType clientType;
                UserEditor user;
                MachineEditor machine0;
                MachineEditor machine1;

                public override void PreRun()
                {
                    //create user and machine
                    clientType = (CSGInfo.ClientType)GetContextData("ClientType");
                    user = UserEditor.CreateNew();
                    machine0 = MachineEditor.CreateNew(GetMachineType(clientType));
                    machine1 = MachineEditor.CreateNew(GetMachineType(clientType));
                }

                public override void Run()
                {
                    PNUser pnUser = null;
                    PNXbox pnXbox = null;

                    // Sign the user into presence
                    Global.RO.Info("Connecting to first machine...");
                    SignInPresence(user.Puid, user.Gamertag, machine0.Id, clientType);
                    Global.RO.Info("Connecting to second machine...");
                    SignInPresence(user.Puid, user.Gamertag, machine1.Id, clientType);

                    SignInPresence(user, machine0, clientType, ref pnUser, ref pnXbox, false);
                    UserMsgFolder userMsgFolder = LoadInbox(pnUser, 5.0);

                    foreach (UserMessage message in userMsgFolder.Inbox) {
                        if (message.GetDetails(pnUser) == HResult.S_OK) {
                            UInt32 messageId = message.Details.GetStringIdProperty(MsgDefs.XONLINE_MSG_PROP_SYSTEM_TEXT);

                            if (messageId == HijackSettings.PresenceWelcomeToNewConsoleMessage) 
                            {
                                Global.RO.Success("Found expected welcome message!");
                                return;
                            }
                        }
                    }

                    throw new UnexpectedTestResultException("Message not found");
                }
            }

            [TestCase, Owner("BenRan"), Description("Verifies that a user does not recieve a new console message the second time they sign into a console they've been on before"), TestCasePriority(2)]
            public class SignIn_SecondTime_NoNewConsoleMessage : TestNode
            {
                CSGInfo.ClientType clientType;
                UserEditor user;
                MachineEditor machine0;
                MachineEditor machine1;

                public override void PreRun()
                {
                    //create user and machine
                    clientType = (CSGInfo.ClientType)GetContextData("ClientType");
                    user = UserEditor.CreateNew();
                    machine0 = MachineEditor.CreateNew(GetMachineType(clientType));
                    machine1 = MachineEditor.CreateNew(GetMachineType(clientType));
                }

                public override void Run()
                {
                    PNUser pnUser = null;
                    PNXbox pnXbox = null;

                    Global.RO.Info("Connecting to first machine...");
                    SignInPresence(user.Puid, user.Gamertag, machine0.Id, clientType);
                    Global.RO.Info("Connecting to second machine...");
                    SignInPresence(user.Puid, user.Gamertag, machine1.Id, clientType);

                    // Clear all messages from their inbox
                    SignInPresence(user, machine0, clientType, ref pnUser, ref pnXbox, false);
                    UserMsgFolder inbox = LoadInbox(pnUser, 5.0);
                    Global.RO.Info("Clearing user inbox...");
                    inbox.DeleteAllMessages();
                    SignOutPresence(pnUser);

                    // Connect a second time (should not get more messages)
                    Global.RO.Info("Connecting to first machine again...");
                    SignInPresence(user.Puid, user.Gamertag, machine0.Id, clientType);
                    Global.RO.Info("Connecting to second machine again...");
                    SignInPresence(user.Puid, user.Gamertag, machine1.Id, clientType);

                    // Disconnect and sign into second machine
                    Global.RO.Info("Checking for empty inbox...");
                    SignInPresence(user, machine0, clientType, ref pnUser, ref pnXbox, false);
                    inbox = LoadInbox(pnUser, 5.0);

                    if (inbox.InboxCount > 0) {
                        throw new UnexpectedTestResultException("Unexpected messages in inbox");
                    }

                    Global.RO.Success("No welcome message as expected!");
                }
            }

            [TestCase, Owner("BenRan"), Description("Validates that the user's IP on first sign on is correct."), TestCasePriority(0)]
            public void IP_SignIn_FirstMachine()
            {
                //create user and machine
                CSGInfo.ClientType clientType = (CSGInfo.ClientType)GetContextData("ClientType");
                UserEditor user = UserEditor.CreateNew();
                MachineEditor machine = MachineEditor.CreateNew(HijackUtilites.GetMachineType(clientType));

                //sign into presense on the box
                SignInPresence(user.Puid, user.Gamertag, machine.Id, clientType);

                //very the result (IP Address is in the detailed results only)

                Global.RO.Debug("Checking UserMachine history for user " + string.Format("0x{0:X} ", user.Puid) + "with details...");

                UserMachineHistoryGetResponse reply = HijackUtilites.GetUserMachineHistory(user.Puid, true);
                ValueCheck.Test("Unique", 1, reply.Unique);
                ValueCheck.Test("FirstSeen", HijackUtilites.TruncateToDay(System.DateTime.UtcNow), reply.FirstSeen.Value, new System.TimeSpan(0, 0, 1));
                ValueCheck.Test("LastSeen", reply.FirstSeen.Value, reply.LastSeen.Value, new System.TimeSpan(0, 0, 1));
                ValueCheck.Test("DaysSeen", 1, reply.DaysSeen);

                ValueCheck.Test("Details exist", true, reply.Details != null && reply.Details.Count > 0);
                ValueCheck.Test("Details count", 1, reply.Details.Count);
                ValueCheck.Test("Details[0] UserPuid", user.Puid, reply[0].UserPuid);
                ValueCheck.Test("Details[0] MachinePuid", machine.Id, reply[0].MachinePuid);
                ValueCheck.Test("Details[0] FirstSeen", reply.FirstSeen.Value, reply[0].FirstSeen, new System.TimeSpan(0, 0, 1));
                ValueCheck.Test("Details[0] LastSeen", reply.LastSeen.Value, reply[0].LastSeen, new System.TimeSpan(0, 0, 1));
                ValueCheck.Test("Details[0] DaysSeen", 1, reply.Details[0].DaysSeen);
                HijackUtilites.VerifyIpIsUs(reply[0].IpAddress);                
            }

            [TestCase, Owner("BenRan"), Description("Validates that the user's IP on two seperate machines is correct."), TestCasePriority(0)]
            public void IP_SignIn_TwoMachines()
            {
                //create user and machine
                CSGInfo.ClientType clientType = (CSGInfo.ClientType)GetContextData("ClientType");
                UserEditor user = UserEditor.CreateNew();
                MachineEditor machine0 = MachineEditor.CreateNew(HijackUtilites.GetMachineType(clientType));
                MachineEditor machine1 = MachineEditor.CreateNew(HijackUtilites.GetMachineType(clientType));

                //sign into presense on both machines separately
                SignInPresence(user.Puid, user.Gamertag, machine0.Id, clientType);
                SignInPresence(user.Puid, user.Gamertag, machine1.Id, clientType);

                //very the result (IP Address is in the detailed results only)
                Global.RO.Debug("Checking UserMachine history for user " + string.Format("0x{0:X} ", user.Puid) + "with details...");

                UserMachineHistoryGetResponse reply = HijackUtilites.GetUserMachineHistory(user.Puid, true);
                ValueCheck.Test("Unique", 2, reply.Unique);
                ValueCheck.Test("FirstSeen", HijackUtilites.TruncateToDay(System.DateTime.UtcNow), reply.FirstSeen.Value, new System.TimeSpan(0, 0, 1));
                ValueCheck.Test("LastSeen", reply.FirstSeen.Value, reply.LastSeen.Value, new System.TimeSpan(0, 0, 1));
                ValueCheck.Test("DaysSeen", 2, reply.DaysSeen); //arguably this should be 1, but the current design only stores edges in the table rather than every signin, so it's not possible to get the actual correct answer.  it's basically the number of days we've seen each machine added together.

                ValueCheck.Test("Details exist", true, reply.Details != null && reply.Details.Count > 0);
                ValueCheck.Test("Details count", 2, reply.Details.Count);

                int machine0Index = 0;
                int machine1Index = 1;
                if (reply.Details[0].MachinePuid == machine1.Id)
                {
                    machine1Index = 0;
                    machine0Index = 1;
                }

                ValueCheck.Test("Details[" + machine0Index + "] UserPuid", user.Puid, reply.Details[machine0Index].UserPuid);
                ValueCheck.Test("Details[" + machine0Index + "] MachinePuid", machine0.Id, reply.Details[machine0Index].MachinePuid);
                ValueCheck.Test("Details[" + machine0Index + "] FirstSeen", reply.FirstSeen.Value, reply.Details[machine0Index].FirstSeen, new System.TimeSpan(0, 0, 1));
                ValueCheck.Test("Details[" + machine0Index + "] LastSeen", reply.LastSeen.Value, reply.Details[machine0Index].LastSeen, new System.TimeSpan(0, 0, 1));
                ValueCheck.Test("Details[" + machine0Index + "] DaysSeen", 1, reply.Details[machine0Index].DaysSeen);
                HijackUtilites.VerifyIpIsUs(reply[machine0Index].IpAddress);

                ValueCheck.Test("Details[" + machine1Index + "] UserPuid", user.Puid, reply.Details[machine1Index].UserPuid);
                ValueCheck.Test("Details[" + machine1Index + "] MachinePuid", machine1.Id, reply.Details[machine1Index].MachinePuid);
                ValueCheck.Test("Details[" + machine1Index + "] FirstSeen", reply.FirstSeen.Value, reply.Details[machine1Index].FirstSeen, new System.TimeSpan(0, 0, 1));
                ValueCheck.Test("Details[" + machine1Index + "] LastSeen", reply.LastSeen.Value, reply.Details[machine1Index].LastSeen, new System.TimeSpan(0, 0, 1));
                ValueCheck.Test("Details[" + machine1Index + "] DaysSeen", 1, reply.Details[machine1Index].DaysSeen);
                HijackUtilites.VerifyIpIsUs(reply[machine1Index].IpAddress);
            }

            [TestCase, Owner("BenRan"), Description("Validates that the machine's IP changed is detected."), TestCasePriority(0)]
            public class IP_SignIn_Changed : TestNode
            {
                CSGInfo.ClientType clientType;
                UserEditor user;
                MachineEditor machine0;

                public override void PreRun()
                {
                    //create user and machine
                    clientType = (CSGInfo.ClientType)GetContextData("ClientType");
                    user = UserEditor.CreateNew();
                    machine0 = MachineEditor.CreateNew(GetMachineType(clientType));

                    //sign into presense on the machine
                    PNUser pnUser = null;
                    PNXbox pnXbox = null;
                    SignInPresence(user.Puid, user.Gamertag, machine0.Id, clientType, ref pnUser, ref pnXbox);

                    //sign out of presence
                    SignOutPresence(pnUser);
                    System.Threading.Thread.Sleep(1000);
                    
                    // Edit the history to make change the last seen IP to some random string
                    UserMachineHistoryEditor editUserMachineHistory = UserMachineHistoryEditor.FromId(user.Puid, machine0.Id);

                    // Get the local IP address and create a new fake one
                    IPAddress localIp = HijackUtilites.GetMyIP();
                    byte[] localIpAsBytes = localIp.GetAddressBytes();

                    // Fake the IP address by setting the lowest byte to the broadcast byte
                    localIpAsBytes[localIpAsBytes.Length-1] = 255;
                    IPAddress newIp = new IPAddress(localIpAsBytes);

                    // Store that IP address
                    editUserMachineHistory.IPAddress = newIp.ToString();
                }

                public override void Run()
                {
                    PNUser pnUser = null;
                    PNXbox pnXbox = null;

                    //verify the result (IP Address is in the detailed results only)
                    Global.RO.Debug("Checking UserMachine history for user " + string.Format("0x{0:X} ", user.Puid) + "with details...");

                    UserMachineHistoryGetResponse reply = HijackUtilites.GetUserMachineHistory(user.Puid, true);
                    ValueCheck.Test("Unique", 1, reply.Unique);
                    ValueCheck.Test("FirstSeen", HijackUtilites.TruncateToDay(System.DateTime.UtcNow), reply.FirstSeen.Value, new System.TimeSpan(0, 0, 1));
                    ValueCheck.Test("LastSeen", reply.FirstSeen.Value, reply.LastSeen.Value, new System.TimeSpan(0, 0, 1));
                    ValueCheck.Test("Details exist", true, reply.Details != null && reply.Details.Count > 0);
                    ValueCheck.Test("Details count", 1, reply.Details.Count);
                    ValueCheck.Test("Details[0] UserPuid", user.Puid, reply.Details[0].UserPuid);
                    ValueCheck.Test("Details[0] MachinePuid", machine0.Id, reply.Details[0].MachinePuid);
                    ValueCheck.Test("Details[0] FirstSeen", reply.FirstSeen.Value, reply.Details[0].FirstSeen, new System.TimeSpan(0, 0, 1));
                    ValueCheck.Test("Details[0] LastSeen", reply.LastSeen.Value, reply.Details[0].LastSeen, new System.TimeSpan(0, 0, 1));
                    ValueCheck.Test("Details[0] DaysSeen", 1, reply.Details[0].DaysSeen);
                    HijackUtilites.VerifyIpIsNotUs(reply[0].IpAddress);

                    // Now log in the user to the machine again
                    SignInPresence(user.Puid, user.Gamertag, machine0.Id, clientType, ref pnUser, ref pnXbox);

                    //sign out of presence
                    SignOutPresence(pnUser);

                    // Verify the result. The IP Address should match this time
                    reply = HijackUtilites.GetUserMachineHistory(user.Puid, true);
                    ValueCheck.Test("Unique", 1, reply.Unique);
                    ValueCheck.Test("FirstSeen", HijackUtilites.TruncateToDay(System.DateTime.UtcNow), reply.FirstSeen.Value, new System.TimeSpan(0, 0, 1));
                    ValueCheck.Test("LastSeen", reply.FirstSeen.Value, reply.LastSeen.Value, new System.TimeSpan(0, 0, 1));
                    ValueCheck.Test("Details exist", true, reply.Details != null && reply.Details.Count > 0);
                    ValueCheck.Test("Details count", 1, reply.Details.Count);
                    ValueCheck.Test("Details[0] UserPuid", user.Puid, reply.Details[0].UserPuid);
                    ValueCheck.Test("Details[0] MachinePuid", machine0.Id, reply.Details[0].MachinePuid);
                    ValueCheck.Test("Details[0] FirstSeen", reply.FirstSeen.Value, reply.Details[0].FirstSeen, new System.TimeSpan(0, 0, 1));
                    ValueCheck.Test("Details[0] LastSeen", reply.LastSeen.Value, reply.Details[0].LastSeen, new System.TimeSpan(0, 0, 1));
                    ValueCheck.Test("Details[0] DaysSeen", 1, reply.Details[0].DaysSeen);
                    HijackUtilites.VerifyIpIsUs(reply[0].IpAddress);

                    Global.RO.Success("IP Address succesfully updated");
                }
            }
        }
    };
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\StfTests\HijackAccountTests\Xuacs.cs ===
using System;
using System.Collections.Generic;
using System.Diagnostics;
using System.Linq;
using System.Text;

using HijackAccountTests.Database;

using ServerTestFramework;
using ServerTestFramework.Database;
using ServerTestFramework.LiveService;
using ServerTestFramework.LiveService.Auth;
using ServerTestFramework.LiveService.FakeSG;
using ServerTestFramework.LiveService.PresNotiCommon;
using ServerTestFramework.LiveService.UserAccount;
using ServerTestFramework.Utilities;

using xonline.common.config;
using xonline.common.protocol;
using xonline.common.service;
using xonline.core.history;

using HResult = xonline.common.service.HResult;
using Events = ServerTestFramework.Utilities.Events;
using PassportHistoryDetails = HijackAccountTests.Database.PassportHistoryDetails;
using RecoveryHistoryDetails = HijackAccountTests.Database.RecoveryHistoryDetails;

namespace HijackAccountTests
{
    [TestGroup, Description("Contains all Account Hijacking tests which are associated with XUACS"), TestFrequency("Regression")]
    [AsyncGroup(1)]
    public class Xuacs : TestNode
    {
        [TestGroup, Owner("BenRan"), Description("Tests that XeCreateLiveAccount peforms as expected")]
        [AsyncGroup(141, 14), AsyncThreadCount(1)]
        public class CreateLiveAccount : TestNode
        {
            [TestCase, Description("Verify that XeCreateLiveAccount properly updates the hijacking tables with user and machine data"), TestCasePriority(0)]
            public class CreateLiveAccount_Mainline : HijackTestBase
            {
                public override void PreRun()
                {
                    client = HijackUtilites.CreateClient();

                    // This uses XeCreateLiveAccount
                    user = new XeUser();
                    user.CreateAsGold = true;
                    user.MachinePuid = client.Id;// client.GetMachinePuid();
                    user.Create();
                }

                public override void Run()
                {
                    UserHistoryGetResponse userHistory = HijackUtilites.GetUserHistory(user.UserPuid, true);
                    MachineHistoryGetResponse machineHistory = HijackUtilites.GetMachineHistory(user.MachinePuid, true);

                    if (userHistory.Passport.Total != 1 || machineHistory.Passport.Total != 1)
                    {
                        throw new UnexpectedTestResultException("Passport history not properly updated");
                    }

                    if (userHistory.Gamertag.Total != 1 || machineHistory.Gamertag.Total != 1)
                    {
                        throw new UnexpectedTestResultException("Gamertag history not properly updated");
                    }
                }
            }

            [TestCase, Description("Verify that XeCreateLiveAccount properly updates the hijacking tables with user data"), Ignore("Unable to create user account using XeCreateLiveAccount without a machine puid"), TestCasePriority(3)]
            public class CreateLiveAccount_NoMachine : HijackTestBase
            {
                public override void PreRun()
                {
                    client = HijackUtilites.CreateClient();

                    // This uses XeCreateLiveAccount
                    user = new XeUser();
                    user.CreateAsGold = true;
                    user.MachinePuid = 0x0;
                    user.m_request.Slot.machinePuid = 0x0;
                    user.Create();
                }

                public override void Run()
                {
                    Boolean failed = false;

                    UserHistoryGetResponse userHistory = HijackUtilites.GetUserHistory(user.UserPuid, true);
                    UserMachineHistoryGetResponse userMachineHistory = HijackUtilites.GetUserMachineHistory(user.UserPuid, true);

                    if (userMachineHistory.Unique > 0)
                    {
                        Global.RO.Error("User/Machine history is not empty as expected for new user");
                        failed = true;
                    }

                    if (userHistory.Passport.Total == 0)
                    {
                        Global.RO.Error("User passport history not properly updated");
                        failed = true;
                    }
                    else if(userHistory.Passport[0].MachinePuid != 0)
                    {
                        Global.RO.Error("User passport history has a machine puid associated with it");
                        failed = true;
                    }

                    if (userHistory.Gamertag.Total == 0)
                    {
                        Global.RO.Error("User gamertag history not properly updated");
                        failed = true;
                    }
                    else if(userHistory.Gamertag[0].MachinePuid != 0)
                    {
                        Global.RO.Error("User gamertag history has a machine puid associated with it");
                        failed = true;
                    }

                    if (failed)
                    {
                        throw new UnexpectedTestResultException("User History was in an unexpected state. See log for more information.");
                    }
                }
            }

            [TestCase, Description("Verify that XeCreateLiveAccount from Xbox.Com properly updates the hijacking tables with user data"), TestCasePriority(0)]
            public class CreateLiveAccount_XboxCom : HijackTestBase
            {
                public override void PreRun()
                {
                    XRLXeCreateXboxComAccount request = new XRLXeCreateXboxComAccount();
                    XRLXeCreateXboxComAccountResponse response = new XRLXeCreateXboxComAccountResponse();

                    // Force the machinepuid to be a real xbox.com machine puid
                    request.MachinePuid = 0xffed000022224444;

                    // Create the account and get the result
                    if (!request.Execute(out response))
                    {
                        throw new UnexpectedTestResultException("XeCreateXboxComAccount failed: " + request.GetDumpString());
                    }
                    if (request.XErr != HResult.S_OK)
                    {
                        throw new UnexpectedTestResultException(String.Format("XeCreateXboxComAccount return XErr=0x{0:x}", request.XErr));
                    }
                    if (response.UserPuid == 0)
                    {
                        throw new UnexpectedTestResultException("XeCreateXboxComAccount returned Puid=0");
                    }
                    user = new XeUser();
                    user.UserPuid = response.UserPuid;
                    user.MachinePuid = request.MachinePuid;
                }

                public override void Run()
                {
                    bool machineHistoryFailed = false;

                    UserHistoryGetResponse userHistory = HijackUtilites.GetUserHistory(user.UserPuid, true);
                    UserMachineHistoryGetResponse userMachineHistory = HijackUtilites.GetUserMachineHistory(user.UserPuid, true);

                    // This should fail. Make sure that it does
                    try
                    {
                        MachineHistoryGetResponse machineHistory = HijackUtilites.GetMachineHistory(user.MachinePuid, true);
                    }
                    catch (UnexpectedTestResultException)
                    {
                        machineHistoryFailed = true;
                    }
                    finally
                    {
                        if (machineHistoryFailed == false)
                        {
                            throw new UnexpectedTestResultException(
                                string.Format(
                                    "Machine History could be read for {0:X16}", 
                                    user.MachinePuid
                                    )
                                );
                        }
                    }

                    // Check the passport history. Expected value is 1 row in user's history
                    // and no rows in machine history
                    if (userHistory.Passport.Total != 1)
                    {
                        throw new UnexpectedTestResultException("User Passport history not properly updated");
                    }
                    else if (xonline.common.service.XOn.XboxId.IsXboxcomMachinePuid(userHistory.Passport[0].MachinePuid.Value) == false)
                    {
                        throw new UnexpectedTestResultException("User Passport history has non Xbox.com machine puid associated with it");
                    }

                    // Check the gamertag history. Expected value is 1 row in user's history
                    // and no rows in machine history
                    if (userHistory.Gamertag.Total != 1)
                    {
                        throw new UnexpectedTestResultException("User Gamertag history not properly updated");
                    }
                    else if (xonline.common.service.XOn.XboxId.IsXboxcomMachinePuid(userHistory.Gamertag[0].MachinePuid.Value) == false)
                    {
                        throw new UnexpectedTestResultException("User Gamertag history has non Xbox.com machine puid associated with it");
                    }

                    // Check the recovery history. Expected value is 0 rows
                    if (userHistory.Recovery.Total != 0)
                    {
                        throw new UnexpectedTestResultException("Recovery history incorrectly updated");
                    }

                    // Check to make sure that this user hasn't been on any machines
                    if (userMachineHistory.Unique > 0)
                    {
                        throw new UnexpectedTestResultException("User/Machine history is not empty as expected for new user");
                    }
                }
            }
        }

        [TestGroup, Owner("BenRan"), Description("Tests that XeRecoverAccount performs as expected")]
        [AsyncGroup(142, 14), AsyncThreadCount(2), AsyncThreadDelay(5000)]
        public class RecoverAccount : TestNode
        {
            [TestCase, Description("Verify that XeRecoverAccount writes account recovery info"), TestCasePriority(0)]
            public class RecoverAccount_Mainline : HijackTestBase
            {
                public override void Run()
                {
                    // Check the user and machine recovery histories
                    int userRecoveryCount = HijackUtilites.GetUserRecoveryHistory(user.UserPuid, false).Total;
                    int machineRecoveryCount = HijackUtilites.GetMachineGamertagHistory(user.MachinePuid, false).Total;

                    TimeSpan tolerance = TimeSpan.FromSeconds(15);
                    DateTime expectedRecoveryTime = DateTime.UtcNow;

                    // Recover the account
                    XeRecoverAccountResponse resp = HijackUtilites.RecoverAccount(user);
                    // Validate the response a bit
                    ValueCheck.Test("UserGamertag", user.Gamertag, resp.gamertag);
                    ValueCheck.Test("UserPuid", user.UserPuid, resp.userPuid);
                    
                    RecoveryHistoryGetResponse userHistory = HijackUtilites.GetUserRecoveryHistory(user.UserPuid, false);
                    RecoveryHistoryGetResponse machineHistory = HijackUtilites.GetMachineRecoveryHistory(client.Id/*client.GetMachinePuid()*/, false);

                    // If we're more than a minute or so off, we're probably doing something wrong
                    ValueCheck.Test("UserRecoveryCount", userRecoveryCount+1, userHistory.Total);
                    ValueCheck.IsTrue(userHistory.Last.HasValue, "UserPassportHasLastRecoveryTime");
                    ValueCheck.Test("UserPassportLastRecoveryTime", expectedRecoveryTime, userHistory.Last.Value, DefaultTolerance);

                    ValueCheck.Test("MachineRecoveryCount", machineRecoveryCount+1, machineHistory.Total);
                    ValueCheck.IsTrue(machineHistory.Last.HasValue, "MachinePassportHasLastRecoveryTime");
                    ValueCheck.Test("MachinePassportLastRecoveryTime", expectedRecoveryTime, machineHistory.Last.Value, DefaultTolerance);
                }
            }

            [TestCase, Description("Verifies that if an account is recovered excessively on different machines, an event is logged"), TestCasePriority(1)]
            public class RecoverAccount_User_ExcessiveUse : HijackTestBase
            {
                ServerTestFramework.Utilities.Events eventMonitor = null;

                public override void PreRun()
                {
                    base.PreRun();

                    // Check the user recovery history so far
                    RecoveryHistoryGetResponse userRecoveryHistory = HijackUtilites.GetUserRecoveryHistory(user.UserPuid, true);
                    
                    int recentRecoverCount = 0;
                    foreach(RecoveryHistoryDetails detail in userRecoveryHistory.Details)
                    {
                        int daysSince = (DateTime.UtcNow - detail.Timestamp).Duration().Days;
                        if (daysSince < HijackSettings.UserRecoveryChangeIntervalDays)
                        {
                            recentRecoverCount++;
                        }
                    }

                    if (recentRecoverCount > HijackSettings.UserRecoveryChangeThreshold)
                    {
                        throw new UnexpectedTestResultException("Users recovery count is already above the threshold");
                    }

                    while (recentRecoverCount < HijackSettings.UserRecoveryChangeThreshold)
                    {
                        MachineEditor recoveryClient = HijackUtilites.CreateClient();
                        //IXblMachine recoveryClient = HijackUtilites.CreateClient();
                        // We can't add a recovery at the exact same time so just add on some seconds to make it different
                        DateTime recoveryTime = DateTime.UtcNow.AddHours(-5).AddSeconds(recentRecoverCount);
                        UserRecoveryHistoryAddSproc addRecovery = new UserRecoveryHistoryAddSproc(user.UserPuid, recoveryClient.Id, null, recoveryTime, 0, user.PassportUserPuid, HistoryReason.RecoverAccount);

                        if (!addRecovery.Execute())
                        {
                            throw new UnexpectedTestResultException("Unable to add recovery details for user.");
                        }

                        recentRecoverCount++;
                    }

                    Global.RO.Info("User is just below account recovery threshold");

                    String[] servers = Global.XEnv.GetServerListByInterface(Interface.xuacs);
                    eventMonitor = new ServerTestFramework.Utilities.Events(servers);
                    eventMonitor.Source = Interface.xuacs;
                }

                public override void Run()
                {
                    if(!eventMonitor.Init())
                    {
                        Global.RO.Warn("Unable to connect to one or more servers for event logs.  This may cause failures.");
                    }

                    Global.RO.Info("Attempting to recover account...");
                    HijackUtilites.RecoverAccount(user);

                    Global.RO.Info("Checking recovery history...");
                    RecoveryHistoryGetResponse userHistory = HijackUtilites.GetUserRecoveryHistory(user.UserPuid, false);

                    // We're expecting it to be greater than the threshold now
                    if (userHistory.Total <= HijackSettings.UserRecoveryChangeThreshold)
                    {
                        Global.RO.Warn("User Recovery count didn't increase.  Ensure that recoveries are properly being logged.");
                    }

                    Global.RO.Info("Checking event logs...");
                    if (!eventMonitor.TestForChange((Int64)xonline.common.service.XEvent.Id.ACCOUNTS_USER_RECOVERY_THRESHOLD_EXCEEDED))
                    {
                        throw new UnexpectedTestResultException("Unable to find user recovery threshold warning event.");
                    }

                    Global.RO.Success("Found User Threshold warning event.");
                }
            }

            [TestCase, Description("Verifies that if an account is recovered excessively on the same few consoles, no event is logged"), TestCasePriority(2)]
            public class RecoverAccount_User_NonExcessiveUse : HijackTestBase
            {
                Events eventMonitor = null;
                //IXblMachine altClient;
                MachineEditor altClient;

                public override void PreRun()
                {
                    base.PreRun();

                    // Create a second client
                    altClient = HijackUtilites.CreateClient();

                    // Check the user recovery history so far
                    RecoveryHistoryGetResponse userRecoveryHistory = HijackUtilites.GetUserRecoveryHistory(user.UserPuid, true);

                    int recentRecoverCount = 0;
                    foreach (RecoveryHistoryDetails detail in userRecoveryHistory.Details)
                    {
                        int daysSince = (DateTime.UtcNow - detail.Timestamp).Duration().Days;
                        if (daysSince < HijackSettings.UserRecoveryChangeIntervalDays)
                        {
                            recentRecoverCount++;
                        }
                    }

                    if (recentRecoverCount > HijackSettings.UserRecoveryChangeThreshold)
                    {
                        throw new UnexpectedTestResultException("Users recovery count is already above the threshold");
                    }

                    while (recentRecoverCount < HijackSettings.UserRecoveryChangeThreshold)
                    {
                        // Alternate between the original client and the alternate
                        UInt64 recoveryMachinePuid = recentRecoverCount % 2 == 0 ? user.MachinePuid : altClient.Id;

                        // We can't add a recovery at the exact same time so just add on some seconds to make it different
                        DateTime recoveryTime = DateTime.UtcNow.AddHours(-5).AddSeconds(recentRecoverCount);

                        UserRecoveryHistoryAddSproc addRecovery = new UserRecoveryHistoryAddSproc(user.UserPuid, recoveryMachinePuid, null, recoveryTime, 0, user.PassportUserPuid, HistoryReason.RecoverAccount);

                        if (!addRecovery.Execute())
                        {
                            throw new UnexpectedTestResultException("Unable to add recovery details for user.");
                        }

                        recentRecoverCount++;
                    }

                    Global.RO.Info("User is just below account recovery threshold");

                    String[] servers = Global.XEnv.GetServerListByInterface(Interface.xuacs);
                    eventMonitor = new Events(servers);
                    eventMonitor.Source = Interface.xuacs;
                }

                public override void Run()
                {
                    if (!eventMonitor.Init())
                    {
                        Global.RO.Warn("Unable to connect to one or more servers for event logs.  This may cause failures.");
                    }

                    Global.RO.Info("Attempting to recover account...");
                    HijackUtilites.RecoverAccount(user);

                    Global.RO.Info("Checking recovery history...");
                    RecoveryHistoryGetResponse userHistory = HijackUtilites.GetUserRecoveryHistory(user.UserPuid, false);

                    // We're expecting it to be greater than the threshold now
                    if (userHistory.Total <= HijackSettings.UserRecoveryChangeThreshold)
                    {
                        Global.RO.Warn("User Recovery count didn't increase.  Ensure that recoveries are properly being logged.");
                    }

                    Global.RO.Info("Checking event logs...");
                    if (eventMonitor.TestForChange((Int64)XEvent.Id.ACCOUNTS_USER_RECOVERY_THRESHOLD_EXCEEDED))
                    {
                        throw new UnexpectedTestResultException("User recovery threshold warning event thrown due to excessive recovery on trusted consoles.");
                    }

                    Global.RO.Success("User Threshold warning event not logged as expected.");
                }
            }

            [TestCase, Description("Verifies that if an excessive number of accounts are recovered on a machine, an event is logged"), TestCasePriority(1)]
            public class RecoverAccount_Machine_ExcessiveUse : HijackTestBase
            {
                ServerTestFramework.Utilities.Events eventMonitor = null;

                public override void PreRun()
                {
                    base.PreRun();

                    // Check the user recovery history so far
                    RecoveryHistoryGetResponse userRecoveryHistory = HijackUtilites.GetMachineRecoveryHistory(user.MachinePuid, true);

                    int recentRecoverCount = 0;
                    foreach (RecoveryHistoryDetails detail in userRecoveryHistory.Details)
                    {
                        int daysSince = (DateTime.UtcNow - detail.Timestamp).Duration().Days;
                        if (daysSince < HijackSettings.MachineRecoveryChangeIntervalDays)
                        {
                            recentRecoverCount++;
                        }
                    }

                    if (recentRecoverCount > HijackSettings.MachineRecoveryChangeThreshold)
                    {
                        throw new UnexpectedTestResultException("Machines recovery count is already above the threshold");
                    }

                    while (recentRecoverCount < HijackSettings.MachineRecoveryChangeThreshold)
                    {
                        //Create a random user
                        UserEditor recoveryUser = UserEditor.CreateNew();
                        UacsCommon.PassportUser passport = new UacsCommon.PassportUser();

                        //XeUser recoveryUser = HijackUtilites.CreateUser(false);

                        MachineRecoveryHistoryAddSproc addRecovery = new MachineRecoveryHistoryAddSproc(recoveryUser.Puid, user.MachinePuid, null, DateTime.UtcNow, 0, (ulong)recoveryUser.UserPassportPuid, HistoryReason.RecoverAccount);

                        if (!addRecovery.Execute())
                        {
                            throw new UnexpectedTestResultException("Unable to add recovery details for user.");
                        }

                        recentRecoverCount++;
                    }

                    Global.RO.Info("Machine is just below account recovery threshold");

                    String[] servers = Global.XEnv.GetServerListByInterface(Interface.xuacs);
                    eventMonitor = new ServerTestFramework.Utilities.Events(servers);
                    eventMonitor.Source = Interface.xuacs;
                }

                public override void Run()
                {
                    if (!eventMonitor.Init())
                    {
                        Global.RO.Warn("Unable to connect to one or more servers for event logs.  This may cause failures.");
                    }

                    Global.RO.Info("Attempting to recover account...");
                    HijackUtilites.RecoverAccount(user);

                    Global.RO.Info("Checking recovery history...");
                    RecoveryHistoryGetResponse machineHistory = HijackUtilites.GetMachineRecoveryHistory(user.MachinePuid, false);
                    // We're expecting it to be greater than the threshold now
                    if (machineHistory.Total <= HijackSettings.MachineRecoveryChangeThreshold)
                    {
                        Global.RO.Warn("Machine Recovery count didn't increase.  Ensure that recoveries are properly being logged.");
                    }

                    Global.RO.Info("Checking event logs...");
                    if (!eventMonitor.TestForChange((Int64)xonline.common.service.XEvent.Id.ACCOUNTS_MACHINE_RECOVERY_THRESHOLD_EXCEEDED))
                    {
                        throw new UnexpectedTestResultException("Unable to find machine recovery threshold warning event.");
                    }

                    Global.RO.Success("Found Machine Threshold warning event.");
                }
            }
        }

        [TestGroup, Owner("BenRan"), Description("Tests that XeSwitchUserPassport performs as expected")]
        [AsyncGroup(143, 14), AsyncThreadCount(2), AsyncThreadDelay(5000)]
        public class SwitchPassport : TestNode
        {
            public class SwitchPassportTestBase : HijackTestBase
            {
                protected static UacsCommon UacsCommon = new UacsCommon();
                protected XRLXeSwitchUserPassport switchPassportRequest = null;

                protected UacsCommon.PassportUser newPassport = null;

                protected PNXbox presenseXbox = null;
                protected PNUser presenseUser = null;

                protected static UacsCommon.PassportUser CreateNewPassport()
                {
                    return UacsCommon.CreatePassportUser();
                }
                protected static UacsCommon.PassportUser CreateNewPassport(String memberName)
                {
                    return UacsCommon.CreatePassportUser(memberName, (byte)XeUser.Country.US);
                }

                protected void SignInPresence()
                {
                    SignInPresence(true);
                }

                protected void SignInPresence(bool disconnect)
                {
                    presenseUser = null;
                    presenseXbox = null;
                    Presence.SignInPresence(user.UserPuid, user.Gamertag, client.Id, CSGInfo.ClientType.Xenon, ref presenseUser, ref presenseXbox, disconnect);
                }

                protected void SignOutPresence()
                {
                    Presence.SignOutPresence(presenseUser);
                }

                /// <summary>
                /// Switch the current users passport for a randomly generated new one
                /// </summary>
                /// <remarks>The newly generated passport can be retrieved in the newPassport variable</remarks>
                protected void SwitchPassport()
                {
                    newPassport = CreateNewPassport();
                    HijackUtilites.SwitchPassport(user, newPassport, true);
                }

                /// <summary>
                /// Switch the current users passport for a randomly generated new one, and optionally
                /// overwrites the current passport data with the new passport data
                /// </summary>
                /// <param name="overwriteUser">If true, the data on the current user will be overwritten</param>
                protected void SwitchPassport(Boolean overwriteUser)
                {
                    newPassport = CreateNewPassport();
                    HijackUtilites.SwitchPassport(user, newPassport, overwriteUser);
                }

                /// <summary>
                /// Switch the current users passport to the one provided.
                /// </summary>
                /// <param name="newPassport">The passport to switch to</param>
                protected void SwitchPassport(UacsCommon.PassportUser newPassport)
                {
                    HijackUtilites.SwitchPassport(user, newPassport, true);
                }

                /// <summary>
                /// Switch the current users passport to the one provided and optionally
                /// overwrite the passport data on the user object
                /// </summary>
                /// <param name="newPassport">The passport to switch to</param>
                /// <param name="overwriteUser">If true, the data on the current user will be overwritten</param>
                protected void SwitchPassport(UacsCommon.PassportUser newPassport, Boolean overwriteUser)
                {
                    HijackUtilites.SwitchPassport(user, newPassport, overwriteUser);                    
                }

                public override void PreRun()
                {
                    base.PreRun();

                    // Nullify these so that they will be recreated as needed.
                    presenseUser = null;
                    presenseXbox = null;
                }
            }

            [TestCase, Description("Verify that XeSwitchUserPassport writes passport info"), TestCasePriority(0)]
            public class SwitchPassport_Mainline : SwitchPassportTestBase
            {
                public override void Run()
                {
                    DateTime expectedSwitchDate = DateTime.UtcNow;

                    Global.RO.Info("Switching User Passport...");
                    SwitchPassport();

                    Global.RO.Info("Getting User/Machine Passport History...");
                    PassportHistoryGetResponse userHistory = HijackUtilites.GetUserPassportHistory(user.UserPuid, true);
                    PassportHistoryGetResponse machineHistory = HijackUtilites.GetMachinePassportHistory(user.MachinePuid, true);

                    HijackUtilites.VerifyOperation(userHistory[0], user.UserPuid, user.MachinePuid, expectedSwitchDate);
                    HijackUtilites.VerifyOperation(machineHistory[0], user.UserPuid, user.MachinePuid, expectedSwitchDate);

                    ValueCheck.IsTrue(userHistory[0].Reason == HistoryReason.SwitchUserPassport, "User Passport Reason");
                    ValueCheck.IsTrue(machineHistory[0].Reason == HistoryReason.SwitchUserPassport, "Machine Passport Reason");
                    ValueCheck.IsTrue(userHistory.Last.HasValue, "UserHistoryHasLastTime");
                    ValueCheck.IsTrue(machineHistory.Last.HasValue, "MachineHistoryHasLastTime");
                    ValueCheck.Test("User Passport Last", expectedSwitchDate, userHistory.Last.Value, DefaultTolerance);
                    ValueCheck.Test("Machine Passport Last", expectedSwitchDate, machineHistory.Last.Value, DefaultTolerance);
                    ValueCheck.Test("User PassportPuid", newPassport.PassportPuid, userHistory[0].NewPassportPuid);
                    ValueCheck.Test("Machine PassportPuid", newPassport.PassportPuid, machineHistory[0].NewPassportPuid);
                    //ValueCheck.Test("User PassportMemberName", newPassport.MemberName, userHistory.NewPassportMemberName);
                    //ValueCheck.Test("Machine PassportMemberName", newPassport.MemberName, machineHistory.NewPassportMemberName);
                }
            }

            [TestCase, Description("Verify that a user is unable to change their passport from a new machine until a certain period of time has passed"), TestCasePriority(1)]
            public class SwitchPassport_BlockOnFirstTime : SwitchPassportTestBase
            {
                public override void Run()
                {
                    // need a second machine to look like a hijacking
                    HijackUtilites.SwitchMachines(user);

                    // After we've logged in, check the history for the user
                    UserMachineHistoryGetResponse userMachineHistory = HijackUtilites.GetUserMachineHistory(user.UserPuid, true);

                    // We need to have more than one unique machine
                    ValueCheck.IsTrue(userMachineHistory.Unique > 1, "UniqueMachines");
                    // The user shold have been seen last on this machine with the last day or so.
                    ValueCheck.Test("UserLastSeen", HijackUtilites.TruncateToDay(DateTime.UtcNow), userMachineHistory.LastSeen.Value);
                    ValueCheck.Test("MachinePuid", userMachineHistory.Details[0].MachinePuid, user.MachinePuid);
                    ValueCheck.Test("UserPuid", userMachineHistory.Details[0].UserPuid, user.UserPuid);

                    try
                    {
                        SwitchPassport();
                        throw new UnexpectedTestResultException("Passport switch succeeded when it was expected to fail.");
                    }
                    catch (xonline.common.service.XRLExceptionWithoutEvent e)
                    {
                        ValueCheck.TestHR("Passport Change Result", HResult.XONLINE_E_ACCOUNTS_SWITCH_PASSPORT_INELIGIBLE, e.HResult);

                        Global.RO.Success("Passport changed blocked on untrusted console");
                        Global.RO.Success(e.Message);
                    }
                }
            }

            [TestCase, Description("Verify that if a user has changed their passport, they are unable to do so until a certain number of days later"), TestCasePriority(2)]
            public class SwitchPassport_User_BlockMultiple : SwitchPassportTestBase
            {
                public override void Run()
                {
                    SwitchPassport();

                    try
                    {
                        SwitchPassport();
                        throw new UnexpectedTestResultException("Passport switch succeeded when it was expected to fail.");
                    }
                    catch (xonline.common.service.XRLExceptionWithoutEvent e)
                    {
                        ValueCheck.TestHR("Switch Passport Result", HResult.XONLINE_E_ACCOUNTS_SWITCH_PASSPORT_INELIGIBLE, e.HResult);

                        Global.RO.Success("Passport changed blocked within the waiting period");
                        Global.RO.Success(e.Message);
                    }
                }
            }

            [TestCase, Description("Verify that if a user has changed their passport multiple times on unique machines in a certain number of days, an event is logged"), TestCasePriority(1)]
            public class SwitchPassport_User_ExcessiveUse : SwitchPassportTestBase
            {
                ServerTestFramework.Utilities.Events eventMonitor = null;

                public override void PreRun()
                {
                    base.PreRun();

                    // Check the user recovery history so far
                    PassportHistoryGetResponse userPassportHistory = HijackUtilites.GetUse